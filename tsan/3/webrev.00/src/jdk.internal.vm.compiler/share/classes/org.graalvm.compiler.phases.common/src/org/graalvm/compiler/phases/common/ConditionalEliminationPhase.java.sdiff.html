<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ConditionalEliminationPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CanonicalizerPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="DeoptimizationGroupingPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ConditionalEliminationPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.phases.common;
  26 
  27 import static org.graalvm.compiler.nodes.StaticDeoptimizingNode.mergeActions;



  28 
  29 import java.util.ArrayDeque;
  30 import java.util.Deque;
  31 import java.util.List;
  32 
  33 import jdk.internal.vm.compiler.collections.EconomicMap;
  34 import jdk.internal.vm.compiler.collections.Equivalence;
  35 import jdk.internal.vm.compiler.collections.MapCursor;
  36 import jdk.internal.vm.compiler.collections.Pair;
  37 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
  38 import org.graalvm.compiler.core.common.cfg.BlockMap;
  39 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
  40 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;
  41 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.And;
  42 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Or;
  43 import org.graalvm.compiler.core.common.type.IntegerStamp;
  44 import org.graalvm.compiler.core.common.type.ObjectStamp;
  45 import org.graalvm.compiler.core.common.type.Stamp;
  46 import org.graalvm.compiler.core.common.type.StampFactory;
  47 import org.graalvm.compiler.debug.CounterKey;
  48 import org.graalvm.compiler.debug.DebugCloseable;
  49 import org.graalvm.compiler.debug.DebugContext;
  50 import org.graalvm.compiler.graph.Node;
  51 import org.graalvm.compiler.graph.NodeMap;
  52 import org.graalvm.compiler.graph.NodeStack;
  53 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
  54 import org.graalvm.compiler.nodeinfo.InputType;
  55 import org.graalvm.compiler.nodes.AbstractBeginNode;
  56 import org.graalvm.compiler.nodes.AbstractMergeNode;
  57 import org.graalvm.compiler.nodes.BinaryOpLogicNode;
  58 import org.graalvm.compiler.nodes.ConditionAnchorNode;

  59 import org.graalvm.compiler.nodes.DeoptimizingGuard;
  60 import org.graalvm.compiler.nodes.EndNode;
  61 import org.graalvm.compiler.nodes.FixedGuardNode;
  62 import org.graalvm.compiler.nodes.FixedNode;
  63 import org.graalvm.compiler.nodes.FixedWithNextNode;
  64 import org.graalvm.compiler.nodes.GuardNode;
  65 import org.graalvm.compiler.nodes.IfNode;
  66 import org.graalvm.compiler.nodes.LogicConstantNode;
  67 import org.graalvm.compiler.nodes.LogicNode;
  68 import org.graalvm.compiler.nodes.LoopExitNode;
  69 import org.graalvm.compiler.nodes.MergeNode;
  70 import org.graalvm.compiler.nodes.NodeView;
<span class="line-removed">  71 import org.graalvm.compiler.nodes.ParameterNode;</span>
  72 import org.graalvm.compiler.nodes.PiNode;
  73 import org.graalvm.compiler.nodes.ProxyNode;
<span class="line-removed">  74 import org.graalvm.compiler.nodes.ShortCircuitOrNode;</span>
  75 import org.graalvm.compiler.nodes.StructuredGraph;
  76 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  77 import org.graalvm.compiler.nodes.UnaryOpLogicNode;
  78 import org.graalvm.compiler.nodes.ValueNode;
  79 import org.graalvm.compiler.nodes.ValuePhiNode;
  80 import org.graalvm.compiler.nodes.calc.AndNode;
<span class="line-removed">  81 import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;</span>
<span class="line-removed">  82 import org.graalvm.compiler.nodes.calc.BinaryNode;</span>
  83 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
<span class="line-removed">  84 import org.graalvm.compiler.nodes.calc.UnaryNode;</span>
  85 import org.graalvm.compiler.nodes.cfg.Block;
  86 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  87 import org.graalvm.compiler.nodes.extended.GuardingNode;
  88 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
  89 import org.graalvm.compiler.nodes.extended.LoadHubNode;
  90 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;

  91 import org.graalvm.compiler.nodes.java.TypeSwitchNode;

  92 import org.graalvm.compiler.nodes.spi.NodeWithState;
  93 import org.graalvm.compiler.nodes.spi.StampInverter;
  94 import org.graalvm.compiler.nodes.util.GraphUtil;
  95 import org.graalvm.compiler.phases.BasePhase;







  96 import org.graalvm.compiler.phases.schedule.SchedulePhase;
  97 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
<span class="line-removed">  98 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  99 
 100 import jdk.vm.ci.meta.DeoptimizationAction;
<span class="line-removed"> 101 import jdk.vm.ci.meta.JavaConstant;</span>
 102 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 103 import jdk.vm.ci.meta.TriState;
 104 
<span class="line-modified"> 105 public class ConditionalEliminationPhase extends BasePhase&lt;PhaseContext&gt; {</span>
 106 
 107     private static final CounterKey counterStampsRegistered = DebugContext.counter(&quot;StampsRegistered&quot;);
<span class="line-removed"> 108     private static final CounterKey counterStampsFound = DebugContext.counter(&quot;StampsFound&quot;);</span>
 109     private static final CounterKey counterIfsKilled = DebugContext.counter(&quot;CE_KilledIfs&quot;);
 110     private static final CounterKey counterPhiStampsImproved = DebugContext.counter(&quot;CE_ImprovedPhis&quot;);
 111     private final boolean fullSchedule;
 112     private final boolean moveGuards;
 113 
 114     public ConditionalEliminationPhase(boolean fullSchedule) {
 115         this(fullSchedule, true);
 116     }
 117 
 118     public ConditionalEliminationPhase(boolean fullSchedule, boolean moveGuards) {
 119         this.fullSchedule = fullSchedule;
 120         this.moveGuards = moveGuards;
 121     }
 122 
 123     @Override
 124     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 125     protected void run(StructuredGraph graph, PhaseContext context) {</span>
 126         try (DebugContext.Scope s = graph.getDebug().scope(&quot;DominatorConditionalElimination&quot;)) {
 127             BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes = null;
 128             NodeMap&lt;Block&gt; nodeToBlock = null;
 129             ControlFlowGraph cfg = ControlFlowGraph.compute(graph, true, true, true, true);
 130             if (fullSchedule) {
 131                 if (moveGuards) {
 132                     cfg.visitDominatorTree(new MoveGuardsUpwards(), graph.hasValueProxies());
 133                 }
 134                 try (DebugContext.Scope scheduleScope = graph.getDebug().scope(SchedulePhase.class)) {
 135                     SchedulePhase.run(graph, SchedulingStrategy.EARLIEST_WITH_GUARD_ORDER, cfg);
 136                 } catch (Throwable t) {
 137                     throw graph.getDebug().handle(t);
 138                 }
 139                 ScheduleResult r = graph.getLastSchedule();
 140                 blockToNodes = r.getBlockToNodesMap();
 141                 nodeToBlock = r.getNodeToBlockMap();
 142             } else {
 143                 nodeToBlock = cfg.getNodeToBlock();
 144                 blockToNodes = getBlockToNodes(cfg);
 145             }
 146             ControlFlowGraph.RecursiveVisitor&lt;?&gt; visitor = createVisitor(graph, cfg, blockToNodes, nodeToBlock, context);
 147             cfg.visitDominatorTree(visitor, graph.hasValueProxies());
 148         }
 149     }
 150 
 151     protected BlockMap&lt;List&lt;Node&gt;&gt; getBlockToNodes(@SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg) {
 152         return null;
 153     }
 154 
 155     protected ControlFlowGraph.RecursiveVisitor&lt;?&gt; createVisitor(StructuredGraph graph, @SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes,
<span class="line-modified"> 156                     NodeMap&lt;Block&gt; nodeToBlock, PhaseContext context) {</span>
 157         return new Instance(graph, blockToNodes, nodeToBlock, context);
 158     }
 159 
 160     public static class MoveGuardsUpwards implements ControlFlowGraph.RecursiveVisitor&lt;Block&gt; {
 161 
 162         Block anchorBlock;
 163 
 164         @Override
 165         @SuppressWarnings(&quot;try&quot;)
 166         public Block enter(Block b) {
 167             Block oldAnchorBlock = anchorBlock;
 168             if (b.getDominator() == null || b.getDominator().getPostdominator() != b) {
 169                 // New anchor.
 170                 anchorBlock = b;
 171             }
 172 
 173             AbstractBeginNode beginNode = b.getBeginNode();
 174             if (beginNode instanceof AbstractMergeNode &amp;&amp; anchorBlock != b) {
 175                 AbstractMergeNode mergeNode = (AbstractMergeNode) beginNode;
<span class="line-modified"> 176                 for (GuardNode guard : mergeNode.guards().snapshot()) {</span>
<span class="line-modified"> 177                     try (DebugCloseable closeable = guard.withNodeSourcePosition()) {</span>
<span class="line-modified"> 178                         GuardNode newlyCreatedGuard = new GuardNode(guard.getCondition(), anchorBlock.getBeginNode(), guard.getReason(), guard.getAction(), guard.isNegated(), guard.getSpeculation(),</span>
<span class="line-removed"> 179                                         guard.getNoDeoptSuccessorPosition());</span>
<span class="line-removed"> 180                         GuardNode newGuard = mergeNode.graph().unique(newlyCreatedGuard);</span>
<span class="line-removed"> 181                         guard.replaceAndDelete(newGuard);</span>
<span class="line-removed"> 182                     }</span>
<span class="line-removed"> 183                 }</span>
 184             }
 185 
 186             FixedNode endNode = b.getEndNode();
 187             if (endNode instanceof IfNode) {
 188                 IfNode node = (IfNode) endNode;
 189 
 190                 // Check if we can move guards upwards.
 191                 AbstractBeginNode trueSuccessor = node.trueSuccessor();


 192                 EconomicMap&lt;LogicNode, GuardNode&gt; trueGuards = EconomicMap.create(Equivalence.IDENTITY);
 193                 for (GuardNode guard : trueSuccessor.guards()) {
 194                     LogicNode condition = guard.getCondition();
 195                     if (condition.hasMoreThanOneUsage()) {
 196                         trueGuards.put(condition, guard);
 197                     }
 198                 }
 199 
 200                 if (!trueGuards.isEmpty()) {
<span class="line-modified"> 201                     for (GuardNode guard : node.falseSuccessor().guards().snapshot()) {</span>
 202                         GuardNode otherGuard = trueGuards.get(guard.getCondition());
 203                         if (otherGuard != null &amp;&amp; guard.isNegated() == otherGuard.isNegated()) {
 204                             Speculation speculation = otherGuard.getSpeculation();
 205                             if (speculation == null) {
 206                                 speculation = guard.getSpeculation();
 207                             } else if (guard.getSpeculation() != null &amp;&amp; guard.getSpeculation() != speculation) {
 208                                 // Cannot optimize due to different speculations.
 209                                 continue;
 210                             }
 211                             try (DebugCloseable closeable = guard.withNodeSourcePosition()) {
 212                                 GuardNode newlyCreatedGuard = new GuardNode(guard.getCondition(), anchorBlock.getBeginNode(), guard.getReason(), guard.getAction(), guard.isNegated(), speculation,
 213                                                 guard.getNoDeoptSuccessorPosition());
 214                                 GuardNode newGuard = node.graph().unique(newlyCreatedGuard);
 215                                 if (otherGuard.isAlive()) {
<span class="line-modified"> 216                                     otherGuard.replaceAndDelete(newGuard);</span>









 217                                 }
<span class="line-removed"> 218                                 guard.replaceAndDelete(newGuard);</span>
 219                             }
 220                         }
 221                     }
 222                 }
 223             }
 224             return oldAnchorBlock;
 225         }
 226 
 227         @Override
 228         public void exit(Block b, Block value) {
 229             anchorBlock = value;
 230         }
 231 
 232     }
 233 
 234     private static final class PhiInfoElement {
 235 
 236         private EconomicMap&lt;EndNode, InfoElement&gt; infoElements;
 237 
 238         public void set(EndNode end, InfoElement infoElement) {
 239             if (infoElements == null) {
 240                 infoElements = EconomicMap.create(Equivalence.IDENTITY);
 241             }
 242             infoElements.put(end, infoElement);
 243         }
 244 
 245         public InfoElement get(EndNode end) {
 246             if (infoElements == null) {
 247                 return null;
 248             }
 249             return infoElements.get(end);
 250         }
 251     }
 252 
<span class="line-removed"> 253     public static final class Marks {</span>
<span class="line-removed"> 254         final int infoElementOperations;</span>
<span class="line-removed"> 255         final int conditions;</span>
<span class="line-removed"> 256 </span>
<span class="line-removed"> 257         public Marks(int infoElementOperations, int conditions) {</span>
<span class="line-removed"> 258             this.infoElementOperations = infoElementOperations;</span>
<span class="line-removed"> 259             this.conditions = conditions;</span>
<span class="line-removed"> 260         }</span>
<span class="line-removed"> 261     }</span>
<span class="line-removed"> 262 </span>
<span class="line-removed"> 263     protected static final class GuardedCondition {</span>
<span class="line-removed"> 264         private final GuardingNode guard;</span>
<span class="line-removed"> 265         private final LogicNode condition;</span>
<span class="line-removed"> 266         private final boolean negated;</span>
<span class="line-removed"> 267 </span>
<span class="line-removed"> 268         public GuardedCondition(GuardingNode guard, LogicNode condition, boolean negated) {</span>
<span class="line-removed"> 269             this.guard = guard;</span>
<span class="line-removed"> 270             this.condition = condition;</span>
<span class="line-removed"> 271             this.negated = negated;</span>
<span class="line-removed"> 272         }</span>
<span class="line-removed"> 273 </span>
<span class="line-removed"> 274         public GuardingNode getGuard() {</span>
<span class="line-removed"> 275             return guard;</span>
<span class="line-removed"> 276         }</span>
<span class="line-removed"> 277 </span>
<span class="line-removed"> 278         public LogicNode getCondition() {</span>
<span class="line-removed"> 279             return condition;</span>
<span class="line-removed"> 280         }</span>
<span class="line-removed"> 281 </span>
<span class="line-removed"> 282         public boolean isNegated() {</span>
<span class="line-removed"> 283             return negated;</span>
<span class="line-removed"> 284         }</span>
<span class="line-removed"> 285     }</span>
<span class="line-removed"> 286 </span>
 287     public static class Instance implements ControlFlowGraph.RecursiveVisitor&lt;Marks&gt; {
 288         protected final NodeMap&lt;InfoElement&gt; map;
 289         protected final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes;
 290         protected final NodeMap&lt;Block&gt; nodeToBlock;
 291         protected final CanonicalizerTool tool;
 292         protected final NodeStack undoOperations;
 293         protected final StructuredGraph graph;
 294         protected final DebugContext debug;
 295         protected final EconomicMap&lt;MergeNode, EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt;&gt; mergeMaps;


 296 
 297         protected final ArrayDeque&lt;GuardedCondition&gt; conditions;
 298 
 299         /**
 300          * Tests which may be eliminated because post dominating tests to prove a broader condition.
 301          */
 302         private Deque&lt;DeoptimizingGuard&gt; pendingTests;
 303 
<span class="line-modified"> 304         public Instance(StructuredGraph graph, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes, NodeMap&lt;Block&gt; nodeToBlock, PhaseContext context) {</span>
 305             this.graph = graph;
 306             this.debug = graph.getDebug();
 307             this.blockToNodes = blockToNodes;
 308             this.nodeToBlock = nodeToBlock;
 309             this.undoOperations = new NodeStack();
 310             this.map = graph.createNodeMap();
 311             this.pendingTests = new ArrayDeque&lt;&gt;();
 312             this.conditions = new ArrayDeque&lt;&gt;();
 313             tool = GraphUtil.getDefaultSimplifier(context.getMetaAccess(), context.getConstantReflection(), context.getConstantFieldProvider(), false, graph.getAssumptions(), graph.getOptions(),
 314                             context.getLowerer());
<span class="line-modified"> 315             mergeMaps = EconomicMap.create();</span>














 316         }
 317 
 318         protected void processConditionAnchor(ConditionAnchorNode node) {
<span class="line-modified"> 319             tryProveCondition(node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
 320                 if (result != node.isNegated()) {
 321                     node.replaceAtUsages(guard.asNode());
 322                     GraphUtil.unlinkFixedNode(node);
 323                     GraphUtil.killWithUnusedFloatingInputs(node);
 324                 } else {
 325                     ValueAnchorNode valueAnchor = node.graph().add(new ValueAnchorNode(null));
 326                     node.replaceAtUsages(valueAnchor);
 327                     node.graph().replaceFixedWithFixed(node, valueAnchor);
 328                 }
 329                 return true;
 330             });
 331         }
 332 
 333         protected void processGuard(GuardNode node) {
 334             if (!tryProveGuardCondition(node, node.getCondition(), (guard, result, guardedValueStamp, newInput) -&gt; {
 335                 if (result != node.isNegated()) {
 336                     node.replaceAndDelete(guard.asNode());



 337                 } else {
<span class="line-removed"> 338                     /*</span>
<span class="line-removed"> 339                      * Don&#39;t kill this branch immediately because `killCFG` can have complex</span>
<span class="line-removed"> 340                      * implications in the presence of loops: it might replace or delete nodes in</span>
<span class="line-removed"> 341                      * other branches or even above the kill point. Instead of killing immediately,</span>
<span class="line-removed"> 342                      * just leave the graph in a state that is easy to simplify by a subsequent</span>
<span class="line-removed"> 343                      * canonicalizer phase.</span>
<span class="line-removed"> 344                      */</span>
<span class="line-removed"> 345                     FixedGuardNode deopt = new FixedGuardNode(LogicConstantNode.forBoolean(result, node.graph()), node.getReason(), node.getAction(), node.getSpeculation(), node.isNegated(),</span>
<span class="line-removed"> 346                                     node.getNodeSourcePosition());</span>
 347                     AbstractBeginNode beginNode = (AbstractBeginNode) node.getAnchor();
<span class="line-removed"> 348                     graph.addAfterFixed(beginNode, node.graph().add(deopt));</span>
 349 














 350                 }
 351                 return true;
 352             })) {
 353                 registerNewCondition(node.getCondition(), node.isNegated(), node);
 354             }
 355         }
 356 
 357         protected void processFixedGuard(FixedGuardNode node) {
 358             if (!tryProveGuardCondition(node, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {
 359                 if (result != node.isNegated()) {
 360                     node.replaceAtUsages(guard.asNode());
 361                     GraphUtil.unlinkFixedNode(node);
 362                     GraphUtil.killWithUnusedFloatingInputs(node);



 363                 } else {
 364                     node.setCondition(LogicConstantNode.forBoolean(result, node.graph()), node.isNegated());
 365                     // Don&#39;t kill this branch immediately, see `processGuard`.
 366                 }
<span class="line-modified"> 367                 debug.log(&quot;Kill fixed guard guard&quot;);</span>

 368                 return true;
 369             })) {
 370                 registerNewCondition(node.condition(), node.isNegated(), node);
 371             }
 372         }
 373 





















































 374         protected void processIf(IfNode node) {
<span class="line-modified"> 375             tryProveCondition(node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
 376                 node.setCondition(LogicConstantNode.forBoolean(result, node.graph()));
 377                 AbstractBeginNode survivingSuccessor = node.getSuccessor(result);
 378                 survivingSuccessor.replaceAtUsages(InputType.Guard, guard.asNode());
 379                 // Don&#39;t kill the other branch immediately, see `processGuard`.
 380                 counterIfsKilled.increment(debug);
 381                 return true;
 382             });
 383         }
 384 
 385         @Override
 386         public Marks enter(Block block) {
 387             int infoElementsMark = undoOperations.size();
 388             int conditionsMark = conditions.size();
 389             debug.log(&quot;[Pre Processing block %s]&quot;, block);
 390             // For now conservatively collect guards only within the same block.
 391             pendingTests.clear();
 392             processNodes(block);
 393             return new Marks(infoElementsMark, conditionsMark);
 394         }
 395 
</pre>
<hr />
<pre>
 494                         if (bestPossibleStamp instanceof ObjectStamp) {
 495                             // Always allow object stamps.
 496                             allow = true;
 497                         } else if (bestPossibleStamp instanceof IntegerStamp) {
 498                             IntegerStamp integerStamp = (IntegerStamp) bestPossibleStamp;
 499                             IntegerStamp oldIntegerStamp = (IntegerStamp) oldStamp;
 500                             if (integerStamp.isPositive() != oldIntegerStamp.isPositive()) {
 501                                 allow = true;
 502                             } else if (integerStamp.isNegative() != oldIntegerStamp.isNegative()) {
 503                                 allow = true;
 504                             } else if (integerStamp.isStrictlyPositive() != oldIntegerStamp.isStrictlyPositive()) {
 505                                 allow = true;
 506                             } else if (integerStamp.isStrictlyNegative() != oldIntegerStamp.isStrictlyNegative()) {
 507                                 allow = true;
 508                             } else if (integerStamp.asConstant() != null) {
 509                                 allow = true;
 510                             } else if (oldStamp.isUnrestricted()) {
 511                                 allow = true;
 512                             }
 513                         } else {


 514                             allow = (bestPossibleStamp.asConstant() != null);
 515                         }
 516 
 517                         if (allow) {
 518                             ValuePhiNode newPhi = graph.addWithoutUnique(new ValuePhiNode(bestPossibleStamp, merge));
 519                             for (int i = 0; i &lt; phi.valueCount(); ++i) {
 520                                 ValueNode valueAt = phi.valueAt(i);
 521                                 if (bestPossibleStamp.meet(valueAt.stamp(NodeView.DEFAULT)).equals(bestPossibleStamp)) {
 522                                     // Pi not required here.
 523                                 } else {
 524                                     InfoElement infoElement = phiInfoElements.get(merge.forwardEndAt(i));
 525                                     assert infoElement != null;
 526                                     Stamp curBestStamp = infoElement.getStamp();
 527                                     ValueNode input = infoElement.getProxifiedInput();
 528                                     if (input == null) {
 529                                         input = valueAt;
 530                                     }
<span class="line-modified"> 531                                     valueAt = graph.maybeAddOrUnique(PiNode.create(input, curBestStamp, (ValueNode) infoElement.guard));</span>
 532                                 }
 533                                 newPhi.addInput(valueAt);
 534                             }
 535                             counterPhiStampsImproved.increment(debug);
 536                             phi.replaceAtUsagesAndDelete(newPhi);
 537                         }
 538                     }
 539                 }
 540             }
 541         }
 542 
 543         protected void processEnd(EndNode end) {
 544             AbstractMergeNode abstractMerge = end.merge();
 545             if (abstractMerge instanceof MergeNode) {
 546                 MergeNode merge = (MergeNode) abstractMerge;
 547 
 548                 EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt; mergeMap = this.mergeMaps.get(merge);
 549                 for (ValuePhiNode phi : merge.valuePhis()) {
 550                     ValueNode valueAt = phi.valueAt(end);
 551                     InfoElement infoElement = this.getInfoElements(valueAt);
 552                     while (infoElement != null) {
 553                         Stamp newStamp = infoElement.getStamp();
 554                         if (phi.stamp(NodeView.DEFAULT).tryImproveWith(newStamp) != null) {
 555                             if (mergeMap == null) {
<span class="line-modified"> 556                                 mergeMap = EconomicMap.create();</span>
 557                                 mergeMaps.put(merge, mergeMap);
 558                             }
 559 
 560                             PhiInfoElement phiInfoElement = mergeMap.get(phi);
 561                             if (phiInfoElement == null) {
 562                                 phiInfoElement = new PhiInfoElement();
 563                                 mergeMap.put(phi, phiInfoElement);
 564                             }
 565 
 566                             phiInfoElement.set(end, infoElement);
 567                             break;
 568                         }
 569                         infoElement = nextElement(infoElement);
 570                     }
 571                 }
 572             }
 573         }
 574 
 575         protected void registerNewCondition(LogicNode condition, boolean negated, GuardingNode guard) {
 576             if (condition instanceof UnaryOpLogicNode) {
</pre>
<hr />
<pre>
 603                         if (and.getY() == y &amp;&amp; maybeMultipleUsages(andX)) {
 604                             /*
 605                              * This &#39;and&#39; proves something about some of the bits in and.getX().
 606                              * It&#39;s equivalent to or&#39;ing in the mask value since those values are
 607                              * known to be set.
 608                              */
 609                             BinaryOp&lt;Or&gt; op = ArithmeticOpTable.forStamp(x.stamp(NodeView.DEFAULT)).getOr();
 610                             IntegerStamp newStampX = (IntegerStamp) op.foldStamp(getSafeStamp(andX), getOtherSafeStamp(y));
 611                             registerNewStamp(andX, newStampX, guard);
 612                         }
 613                     }
 614                 }
 615             }
 616             if (guard instanceof DeoptimizingGuard) {
 617                 assert ((DeoptimizingGuard) guard).getCondition() == condition;
 618                 pendingTests.push((DeoptimizingGuard) guard);
 619             }
 620             registerCondition(condition, negated, guard);
 621         }
 622 
<span class="line-removed"> 623         Pair&lt;InfoElement, Stamp&gt; recursiveFoldStamp(Node node) {</span>
<span class="line-removed"> 624             if (node instanceof UnaryNode) {</span>
<span class="line-removed"> 625                 UnaryNode unary = (UnaryNode) node;</span>
<span class="line-removed"> 626                 ValueNode value = unary.getValue();</span>
<span class="line-removed"> 627                 InfoElement infoElement = getInfoElements(value);</span>
<span class="line-removed"> 628                 while (infoElement != null) {</span>
<span class="line-removed"> 629                     Stamp result = unary.foldStamp(infoElement.getStamp());</span>
<span class="line-removed"> 630                     if (result != null) {</span>
<span class="line-removed"> 631                         return Pair.create(infoElement, result);</span>
<span class="line-removed"> 632                     }</span>
<span class="line-removed"> 633                     infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 634                 }</span>
<span class="line-removed"> 635             } else if (node instanceof BinaryNode) {</span>
<span class="line-removed"> 636                 BinaryNode binary = (BinaryNode) node;</span>
<span class="line-removed"> 637                 ValueNode y = binary.getY();</span>
<span class="line-removed"> 638                 ValueNode x = binary.getX();</span>
<span class="line-removed"> 639                 if (y.isConstant()) {</span>
<span class="line-removed"> 640                     InfoElement infoElement = getInfoElements(x);</span>
<span class="line-removed"> 641                     while (infoElement != null) {</span>
<span class="line-removed"> 642                         Stamp result = binary.foldStamp(infoElement.stamp, y.stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 643                         if (result != null) {</span>
<span class="line-removed"> 644                             return Pair.create(infoElement, result);</span>
<span class="line-removed"> 645                         }</span>
<span class="line-removed"> 646                         infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 647                     }</span>
<span class="line-removed"> 648                 }</span>
<span class="line-removed"> 649             }</span>
<span class="line-removed"> 650             return null;</span>
<span class="line-removed"> 651         }</span>
<span class="line-removed"> 652 </span>
<span class="line-removed"> 653         /**</span>
<span class="line-removed"> 654          * Get the stamp that may be used for the value for which we are registering the condition.</span>
<span class="line-removed"> 655          * We may directly use the stamp here without restriction, because any later lookup of the</span>
<span class="line-removed"> 656          * registered info elements is in the same chain of pi nodes.</span>
<span class="line-removed"> 657          */</span>
<span class="line-removed"> 658         private static Stamp getSafeStamp(ValueNode x) {</span>
<span class="line-removed"> 659             return x.stamp(NodeView.DEFAULT);</span>
<span class="line-removed"> 660         }</span>
<span class="line-removed"> 661 </span>
<span class="line-removed"> 662         /**</span>
<span class="line-removed"> 663          * We can only use the stamp of a second value involved in the condition if we are sure that</span>
<span class="line-removed"> 664          * we are not implicitly creating a dependency on a pi node that is responsible for that</span>
<span class="line-removed"> 665          * stamp. For now, we are conservatively only using the stamps of constants. Under certain</span>
<span class="line-removed"> 666          * circumstances, we may also be able to use the stamp of the value after skipping pi nodes</span>
<span class="line-removed"> 667          * (e.g., the stamp of a parameter after inlining, or the stamp of a fixed node that can</span>
<span class="line-removed"> 668          * never be replaced with a pi node via canonicalization).</span>
<span class="line-removed"> 669          */</span>
<span class="line-removed"> 670         private static Stamp getOtherSafeStamp(ValueNode x) {</span>
<span class="line-removed"> 671             if (x.isConstant() || x.graph().isAfterFixedReadPhase()) {</span>
<span class="line-removed"> 672                 return x.stamp(NodeView.DEFAULT);</span>
<span class="line-removed"> 673             }</span>
<span class="line-removed"> 674             return x.stamp(NodeView.DEFAULT).unrestricted();</span>
<span class="line-removed"> 675         }</span>
<span class="line-removed"> 676 </span>
 677         /**
 678          * Recursively try to fold stamps within this expression using information from
 679          * {@link #getInfoElements(ValueNode)}. It&#39;s only safe to use constants and one
 680          * {@link InfoElement} otherwise more than one guard would be required.
 681          *
 682          * @param node
 683          * @return the pair of the @{link InfoElement} used and the stamp produced for the whole
 684          *         expression
 685          */
 686         Pair&lt;InfoElement, Stamp&gt; recursiveFoldStampFromInfo(Node node) {
<span class="line-modified"> 687             return recursiveFoldStamp(node);</span>
 688         }
 689 
 690         /**
 691          * Look for a preceding guard whose condition is implied by {@code thisGuard}. If we find
 692          * one, try to move this guard just above that preceding guard so that we can fold it:
 693          *
 694          * &lt;pre&gt;
 695          *     guard(C1); // preceding guard
 696          *     ...
 697          *     guard(C2); // thisGuard
 698          * &lt;/pre&gt;
 699          *
 700          * If C2 =&gt; C1, transform to:
 701          *
 702          * &lt;pre&gt;
 703          *     guard(C2);
 704          *     ...
 705          * &lt;/pre&gt;
 706          */
 707         protected boolean foldPendingTest(DeoptimizingGuard thisGuard, ValueNode original, Stamp newStamp, GuardRewirer rewireGuardFunction) {
</pre>
<hr />
<pre>
 783                 GuardRewirer rewirer = (guard, result, innerGuardedValueStamp, newInput) -&gt; {
 784                     // `result` is `outcome`, `guard` is `otherGuard`
 785                     boolean mustDeopt = result == otherGuard.isNegated();
 786                     if (rewireGuardFunction.rewire(guard, mustDeopt == thisGuard.isNegated(), innerGuardedValueStamp, newInput)) {
 787                         if (!mustDeopt) {
 788                             otherGuard.setCondition(condition, thisGuard.isNegated());
 789                             otherGuard.setAction(action);
 790                             otherGuard.setReason(thisGuard.getReason());
 791                         }
 792                         return true;
 793                     }
 794                     condition.safeDelete();
 795                     return false;
 796                 };
 797                 // Move the later test up
 798                 return rewireGuards(otherGuard, outcome, null, guardedValueStamp, rewirer);
 799             }
 800             return false;
 801         }
 802 




 803         protected void registerCondition(LogicNode condition, boolean negated, GuardingNode guard) {
 804             if (condition.hasMoreThanOneUsage()) {
 805                 registerNewStamp(condition, negated ? StampFactory.contradiction() : StampFactory.tautology(), guard);
 806             }
 807             conditions.push(new GuardedCondition(guard, condition, negated));
 808         }
 809 
 810         protected InfoElement getInfoElements(ValueNode proxiedValue) {
 811             if (proxiedValue == null) {
 812                 return null;
 813             }
 814             InfoElement infoElement = map.getAndGrow(proxiedValue);
 815             if (infoElement == null) {
 816                 infoElement = map.getAndGrow(GraphUtil.skipPi(proxiedValue));
 817             }
 818             return infoElement;
 819         }
 820 
<span class="line-removed"> 821         protected boolean rewireGuards(GuardingNode guard, boolean result, ValueNode proxifiedInput, Stamp guardedValueStamp, GuardRewirer rewireGuardFunction) {</span>
<span class="line-removed"> 822             counterStampsFound.increment(debug);</span>
<span class="line-removed"> 823             return rewireGuardFunction.rewire(guard, result, guardedValueStamp, proxifiedInput);</span>
<span class="line-removed"> 824         }</span>
<span class="line-removed"> 825 </span>
<span class="line-removed"> 826         protected boolean tryProveCondition(LogicNode node, GuardRewirer rewireGuardFunction) {</span>
<span class="line-removed"> 827             return tryProveGuardCondition(null, node, rewireGuardFunction);</span>
<span class="line-removed"> 828         }</span>
<span class="line-removed"> 829 </span>
 830         private InfoElement nextElement(InfoElement current) {
 831             InfoElement parent = current.getParent();
 832             if (parent != null) {
 833                 return parent;
 834             } else {
 835                 ValueNode proxifiedInput = current.getProxifiedInput();
 836                 if (proxifiedInput instanceof PiNode) {
 837                     PiNode piNode = (PiNode) proxifiedInput;
 838                     return getInfoElements(piNode.getOriginalNode());
 839                 }
 840             }
 841             return null;
 842         }
 843 
<span class="line-removed"> 844         protected boolean tryProveGuardCondition(DeoptimizingGuard thisGuard, LogicNode node, GuardRewirer rewireGuardFunction) {</span>
<span class="line-removed"> 845             InfoElement infoElement = getInfoElements(node);</span>
<span class="line-removed"> 846             while (infoElement != null) {</span>
<span class="line-removed"> 847                 Stamp stamp = infoElement.getStamp();</span>
<span class="line-removed"> 848                 JavaConstant constant = (JavaConstant) stamp.asConstant();</span>
<span class="line-removed"> 849                 if (constant != null) {</span>
<span class="line-removed"> 850                     // No proxified input and stamp required.</span>
<span class="line-removed"> 851                     return rewireGuards(infoElement.getGuard(), constant.asBoolean(), null, null, rewireGuardFunction);</span>
<span class="line-removed"> 852                 }</span>
<span class="line-removed"> 853                 infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 854             }</span>
<span class="line-removed"> 855 </span>
<span class="line-removed"> 856             for (GuardedCondition guardedCondition : this.conditions) {</span>
<span class="line-removed"> 857                 TriState result = guardedCondition.getCondition().implies(guardedCondition.isNegated(), node);</span>
<span class="line-removed"> 858                 if (result.isKnown()) {</span>
<span class="line-removed"> 859                     return rewireGuards(guardedCondition.guard, result.toBoolean(), null, null, rewireGuardFunction);</span>
<span class="line-removed"> 860                 }</span>
<span class="line-removed"> 861             }</span>
<span class="line-removed"> 862 </span>
<span class="line-removed"> 863             if (node instanceof UnaryOpLogicNode) {</span>
<span class="line-removed"> 864                 UnaryOpLogicNode unaryLogicNode = (UnaryOpLogicNode) node;</span>
<span class="line-removed"> 865                 ValueNode value = unaryLogicNode.getValue();</span>
<span class="line-removed"> 866                 infoElement = getInfoElements(value);</span>
<span class="line-removed"> 867                 while (infoElement != null) {</span>
<span class="line-removed"> 868                     Stamp stamp = infoElement.getStamp();</span>
<span class="line-removed"> 869                     TriState result = unaryLogicNode.tryFold(stamp);</span>
<span class="line-removed"> 870                     if (result.isKnown()) {</span>
<span class="line-removed"> 871                         return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);</span>
<span class="line-removed"> 872                     }</span>
<span class="line-removed"> 873                     infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 874                 }</span>
<span class="line-removed"> 875                 Pair&lt;InfoElement, Stamp&gt; foldResult = recursiveFoldStampFromInfo(value);</span>
<span class="line-removed"> 876                 if (foldResult != null) {</span>
<span class="line-removed"> 877                     TriState result = unaryLogicNode.tryFold(foldResult.getRight());</span>
<span class="line-removed"> 878                     if (result.isKnown()) {</span>
<span class="line-removed"> 879                         return rewireGuards(foldResult.getLeft().getGuard(), result.toBoolean(), foldResult.getLeft().getProxifiedInput(), foldResult.getRight(), rewireGuardFunction);</span>
<span class="line-removed"> 880                     }</span>
<span class="line-removed"> 881                 }</span>
<span class="line-removed"> 882                 if (thisGuard != null) {</span>
<span class="line-removed"> 883                     Stamp newStamp = unaryLogicNode.getSucceedingStampForValue(thisGuard.isNegated());</span>
<span class="line-removed"> 884                     if (newStamp != null &amp;&amp; foldPendingTest(thisGuard, value, newStamp, rewireGuardFunction)) {</span>
<span class="line-removed"> 885                         return true;</span>
<span class="line-removed"> 886                     }</span>
<span class="line-removed"> 887 </span>
<span class="line-removed"> 888                 }</span>
<span class="line-removed"> 889             } else if (node instanceof BinaryOpLogicNode) {</span>
<span class="line-removed"> 890                 BinaryOpLogicNode binaryOpLogicNode = (BinaryOpLogicNode) node;</span>
<span class="line-removed"> 891                 ValueNode x = binaryOpLogicNode.getX();</span>
<span class="line-removed"> 892                 ValueNode y = binaryOpLogicNode.getY();</span>
<span class="line-removed"> 893                 infoElement = getInfoElements(x);</span>
<span class="line-removed"> 894                 while (infoElement != null) {</span>
<span class="line-removed"> 895                     TriState result = binaryOpLogicNode.tryFold(infoElement.getStamp(), y.stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 896                     if (result.isKnown()) {</span>
<span class="line-removed"> 897                         return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);</span>
<span class="line-removed"> 898                     }</span>
<span class="line-removed"> 899                     infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 900                 }</span>
<span class="line-removed"> 901 </span>
<span class="line-removed"> 902                 if (y.isConstant()) {</span>
<span class="line-removed"> 903                     Pair&lt;InfoElement, Stamp&gt; foldResult = recursiveFoldStampFromInfo(x);</span>
<span class="line-removed"> 904                     if (foldResult != null) {</span>
<span class="line-removed"> 905                         TriState result = binaryOpLogicNode.tryFold(foldResult.getRight(), y.stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 906                         if (result.isKnown()) {</span>
<span class="line-removed"> 907                             return rewireGuards(foldResult.getLeft().getGuard(), result.toBoolean(), foldResult.getLeft().getProxifiedInput(), foldResult.getRight(), rewireGuardFunction);</span>
<span class="line-removed"> 908                         }</span>
<span class="line-removed"> 909                     }</span>
<span class="line-removed"> 910                 } else {</span>
<span class="line-removed"> 911                     infoElement = getInfoElements(y);</span>
<span class="line-removed"> 912                     while (infoElement != null) {</span>
<span class="line-removed"> 913                         TriState result = binaryOpLogicNode.tryFold(x.stamp(NodeView.DEFAULT), infoElement.getStamp());</span>
<span class="line-removed"> 914                         if (result.isKnown()) {</span>
<span class="line-removed"> 915                             return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);</span>
<span class="line-removed"> 916                         }</span>
<span class="line-removed"> 917                         infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 918                     }</span>
<span class="line-removed"> 919                 }</span>
<span class="line-removed"> 920 </span>
<span class="line-removed"> 921                 /*</span>
<span class="line-removed"> 922                  * For complex expressions involving constants, see if it&#39;s possible to fold the</span>
<span class="line-removed"> 923                  * tests by using stamps one level up in the expression. For instance, (x + n &lt; y)</span>
<span class="line-removed"> 924                  * might fold if something is known about x and all other values are constants. The</span>
<span class="line-removed"> 925                  * reason for the constant restriction is that if more than 1 real value is involved</span>
<span class="line-removed"> 926                  * the code might need to adopt multiple guards to have proper dependences.</span>
<span class="line-removed"> 927                  */</span>
<span class="line-removed"> 928                 if (x instanceof BinaryArithmeticNode&lt;?&gt; &amp;&amp; y.isConstant()) {</span>
<span class="line-removed"> 929                     BinaryArithmeticNode&lt;?&gt; binary = (BinaryArithmeticNode&lt;?&gt;) x;</span>
<span class="line-removed"> 930                     if (binary.getY().isConstant()) {</span>
<span class="line-removed"> 931                         infoElement = getInfoElements(binary.getX());</span>
<span class="line-removed"> 932                         while (infoElement != null) {</span>
<span class="line-removed"> 933                             Stamp newStampX = binary.foldStamp(infoElement.getStamp(), binary.getY().stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 934                             TriState result = binaryOpLogicNode.tryFold(newStampX, y.stamp(NodeView.DEFAULT));</span>
<span class="line-removed"> 935                             if (result.isKnown()) {</span>
<span class="line-removed"> 936                                 return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), newStampX, rewireGuardFunction);</span>
<span class="line-removed"> 937                             }</span>
<span class="line-removed"> 938                             infoElement = nextElement(infoElement);</span>
<span class="line-removed"> 939                         }</span>
<span class="line-removed"> 940                     }</span>
<span class="line-removed"> 941                 }</span>
<span class="line-removed"> 942 </span>
<span class="line-removed"> 943                 if (thisGuard != null &amp;&amp; binaryOpLogicNode instanceof IntegerEqualsNode &amp;&amp; !thisGuard.isNegated()) {</span>
<span class="line-removed"> 944                     if (y.isConstant() &amp;&amp; x instanceof AndNode) {</span>
<span class="line-removed"> 945                         AndNode and = (AndNode) x;</span>
<span class="line-removed"> 946                         if (and.getY() == y) {</span>
<span class="line-removed"> 947                             /*</span>
<span class="line-removed"> 948                              * This &#39;and&#39; proves something about some of the bits in and.getX().</span>
<span class="line-removed"> 949                              * It&#39;s equivalent to or&#39;ing in the mask value since those values are</span>
<span class="line-removed"> 950                              * known to be set.</span>
<span class="line-removed"> 951                              */</span>
<span class="line-removed"> 952                             BinaryOp&lt;Or&gt; op = ArithmeticOpTable.forStamp(x.stamp(NodeView.DEFAULT)).getOr();</span>
<span class="line-removed"> 953                             IntegerStamp newStampX = (IntegerStamp) op.foldStamp(getSafeStamp(and.getX()), getOtherSafeStamp(y));</span>
<span class="line-removed"> 954                             if (foldPendingTest(thisGuard, and.getX(), newStampX, rewireGuardFunction)) {</span>
<span class="line-removed"> 955                                 return true;</span>
<span class="line-removed"> 956                             }</span>
<span class="line-removed"> 957                         }</span>
<span class="line-removed"> 958                     }</span>
<span class="line-removed"> 959                 }</span>
<span class="line-removed"> 960 </span>
<span class="line-removed"> 961                 if (thisGuard != null) {</span>
<span class="line-removed"> 962                     if (!x.isConstant()) {</span>
<span class="line-removed"> 963                         Stamp newStampX = binaryOpLogicNode.getSucceedingStampForX(thisGuard.isNegated(), getSafeStamp(x), getOtherSafeStamp(y));</span>
<span class="line-removed"> 964                         if (newStampX != null &amp;&amp; foldPendingTest(thisGuard, x, newStampX, rewireGuardFunction)) {</span>
<span class="line-removed"> 965                             return true;</span>
<span class="line-removed"> 966                         }</span>
<span class="line-removed"> 967                     }</span>
<span class="line-removed"> 968                     if (!y.isConstant()) {</span>
<span class="line-removed"> 969                         Stamp newStampY = binaryOpLogicNode.getSucceedingStampForY(thisGuard.isNegated(), getOtherSafeStamp(x), getSafeStamp(y));</span>
<span class="line-removed"> 970                         if (newStampY != null &amp;&amp; foldPendingTest(thisGuard, y, newStampY, rewireGuardFunction)) {</span>
<span class="line-removed"> 971                             return true;</span>
<span class="line-removed"> 972                         }</span>
<span class="line-removed"> 973                     }</span>
<span class="line-removed"> 974                 }</span>
<span class="line-removed"> 975             } else if (node instanceof ShortCircuitOrNode) {</span>
<span class="line-removed"> 976                 final ShortCircuitOrNode shortCircuitOrNode = (ShortCircuitOrNode) node;</span>
<span class="line-removed"> 977                 return tryProveCondition(shortCircuitOrNode.getX(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
<span class="line-removed"> 978                     if (result == !shortCircuitOrNode.isXNegated()) {</span>
<span class="line-removed"> 979                         return rewireGuards(guard, true, newInput, guardedValueStamp, rewireGuardFunction);</span>
<span class="line-removed"> 980                     } else {</span>
<span class="line-removed"> 981                         return tryProveCondition(shortCircuitOrNode.getY(), (innerGuard, innerResult, innerGuardedValueStamp, innerNewInput) -&gt; {</span>
<span class="line-removed"> 982                             ValueNode proxifiedInput = newInput;</span>
<span class="line-removed"> 983                             if (proxifiedInput == null) {</span>
<span class="line-removed"> 984                                 proxifiedInput = innerNewInput;</span>
<span class="line-removed"> 985                             } else if (innerNewInput != null) {</span>
<span class="line-removed"> 986                                 if (innerNewInput != newInput) {</span>
<span class="line-removed"> 987                                     // Cannot canonicalize due to different proxied inputs.</span>
<span class="line-removed"> 988                                     return false;</span>
<span class="line-removed"> 989                                 }</span>
<span class="line-removed"> 990                             }</span>
<span class="line-removed"> 991                             // Can only canonicalize if the guards are equal.</span>
<span class="line-removed"> 992                             if (innerGuard == guard) {</span>
<span class="line-removed"> 993                                 return rewireGuards(guard, innerResult ^ shortCircuitOrNode.isYNegated(), proxifiedInput, guardedValueStamp, rewireGuardFunction);</span>
<span class="line-removed"> 994                             }</span>
<span class="line-removed"> 995                             return false;</span>
<span class="line-removed"> 996                         });</span>
<span class="line-removed"> 997                     }</span>
<span class="line-removed"> 998                 });</span>
<span class="line-removed"> 999             }</span>
<span class="line-removed">1000 </span>
<span class="line-removed">1001             return false;</span>
<span class="line-removed">1002         }</span>
<span class="line-removed">1003 </span>
1004         protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard) {
1005             registerNewStamp(maybeProxiedValue, newStamp, guard, false);
1006         }
1007 
1008         protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard, boolean propagateThroughPis) {
1009             assert maybeProxiedValue != null;
1010             assert guard != null;
1011 
1012             if (newStamp == null || newStamp.isUnrestricted()) {
1013                 return;
1014             }
1015 
1016             ValueNode value = maybeProxiedValue;
1017             Stamp stamp = newStamp;
1018 
1019             while (stamp != null &amp;&amp; value != null) {
1020                 ValueNode proxiedValue = null;
1021                 if (value instanceof PiNode) {
1022                     proxiedValue = value;
1023                 }
</pre>
<hr />
<pre>
1089             }
1090         }
1091 
1092         @Override
1093         public void exit(Block b, Marks marks) {
1094             int infoElementsMark = marks.infoElementOperations;
1095             while (undoOperations.size() &gt; infoElementsMark) {
1096                 Node node = undoOperations.pop();
1097                 if (node.isAlive()) {
1098                     map.set(node, map.get(node).getParent());
1099                 }
1100             }
1101 
1102             int conditionsMark = marks.conditions;
1103             while (conditions.size() &gt; conditionsMark) {
1104                 conditions.pop();
1105             }
1106         }
1107     }
1108 
<span class="line-removed">1109     @FunctionalInterface</span>
<span class="line-removed">1110     protected interface InfoElementProvider {</span>
<span class="line-removed">1111         Iterable&lt;InfoElement&gt; getInfoElements(ValueNode value);</span>
<span class="line-removed">1112     }</span>
<span class="line-removed">1113 </span>
<span class="line-removed">1114     /**</span>
<span class="line-removed">1115      * Checks for safe nodes when moving pending tests up.</span>
<span class="line-removed">1116      */</span>
<span class="line-removed">1117     static class InputFilter extends Node.EdgeVisitor {</span>
<span class="line-removed">1118         boolean ok;</span>
<span class="line-removed">1119         private ValueNode value;</span>
<span class="line-removed">1120 </span>
<span class="line-removed">1121         InputFilter(ValueNode value) {</span>
<span class="line-removed">1122             this.value = value;</span>
<span class="line-removed">1123             this.ok = true;</span>
<span class="line-removed">1124         }</span>
<span class="line-removed">1125 </span>
<span class="line-removed">1126         @Override</span>
<span class="line-removed">1127         public Node apply(Node node, Node curNode) {</span>
<span class="line-removed">1128             if (!ok) {</span>
<span class="line-removed">1129                 // Abort the recursion</span>
<span class="line-removed">1130                 return curNode;</span>
<span class="line-removed">1131             }</span>
<span class="line-removed">1132             if (!(curNode instanceof ValueNode)) {</span>
<span class="line-removed">1133                 ok = false;</span>
<span class="line-removed">1134                 return curNode;</span>
<span class="line-removed">1135             }</span>
<span class="line-removed">1136             ValueNode curValue = (ValueNode) curNode;</span>
<span class="line-removed">1137             if (curValue.isConstant() || curValue == value || curValue instanceof ParameterNode) {</span>
<span class="line-removed">1138                 return curNode;</span>
<span class="line-removed">1139             }</span>
<span class="line-removed">1140             if (curValue instanceof BinaryNode || curValue instanceof UnaryNode) {</span>
<span class="line-removed">1141                 curValue.applyInputs(this);</span>
<span class="line-removed">1142             } else {</span>
<span class="line-removed">1143                 ok = false;</span>
<span class="line-removed">1144             }</span>
<span class="line-removed">1145             return curNode;</span>
<span class="line-removed">1146         }</span>
<span class="line-removed">1147     }</span>
<span class="line-removed">1148 </span>
<span class="line-removed">1149     @FunctionalInterface</span>
<span class="line-removed">1150     protected interface GuardRewirer {</span>
<span class="line-removed">1151         /**</span>
<span class="line-removed">1152          * Called if the condition could be proven to have a constant value ({@code result}) under</span>
<span class="line-removed">1153          * {@code guard}.</span>
<span class="line-removed">1154          *</span>
<span class="line-removed">1155          * @param guard the guard whose result is proven</span>
<span class="line-removed">1156          * @param result the known result of the guard</span>
<span class="line-removed">1157          * @param newInput new input to pi nodes depending on the new guard</span>
<span class="line-removed">1158          * @return whether the transformation could be applied</span>
<span class="line-removed">1159          */</span>
<span class="line-removed">1160         boolean rewire(GuardingNode guard, boolean result, Stamp guardedValueStamp, ValueNode newInput);</span>
<span class="line-removed">1161     }</span>
<span class="line-removed">1162 </span>
<span class="line-removed">1163     protected static final class InfoElement {</span>
<span class="line-removed">1164         private final Stamp stamp;</span>
<span class="line-removed">1165         private final GuardingNode guard;</span>
<span class="line-removed">1166         private final ValueNode proxifiedInput;</span>
<span class="line-removed">1167         private final InfoElement parent;</span>
<span class="line-removed">1168 </span>
<span class="line-removed">1169         public InfoElement(Stamp stamp, GuardingNode guard, ValueNode proxifiedInput, InfoElement parent) {</span>
<span class="line-removed">1170             this.stamp = stamp;</span>
<span class="line-removed">1171             this.guard = guard;</span>
<span class="line-removed">1172             this.proxifiedInput = proxifiedInput;</span>
<span class="line-removed">1173             this.parent = parent;</span>
<span class="line-removed">1174         }</span>
<span class="line-removed">1175 </span>
<span class="line-removed">1176         public InfoElement getParent() {</span>
<span class="line-removed">1177             return parent;</span>
<span class="line-removed">1178         }</span>
<span class="line-removed">1179 </span>
<span class="line-removed">1180         public Stamp getStamp() {</span>
<span class="line-removed">1181             return stamp;</span>
<span class="line-removed">1182         }</span>
<span class="line-removed">1183 </span>
<span class="line-removed">1184         public GuardingNode getGuard() {</span>
<span class="line-removed">1185             return guard;</span>
<span class="line-removed">1186         }</span>
<span class="line-removed">1187 </span>
<span class="line-removed">1188         public ValueNode getProxifiedInput() {</span>
<span class="line-removed">1189             return proxifiedInput;</span>
<span class="line-removed">1190         }</span>
<span class="line-removed">1191 </span>
<span class="line-removed">1192         @Override</span>
<span class="line-removed">1193         public String toString() {</span>
<span class="line-removed">1194             return stamp + &quot; -&gt; &quot; + guard;</span>
<span class="line-removed">1195         }</span>
<span class="line-removed">1196     }</span>
<span class="line-removed">1197 </span>
1198     @Override
1199     public float codeSizeIncrease() {
1200         return 1.5f;
1201     }
1202 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.phases.common;
  26 
  27 import static org.graalvm.compiler.nodes.StaticDeoptimizingNode.mergeActions;
<span class="line-added">  28 import static org.graalvm.compiler.phases.common.ConditionalEliminationUtil.getOtherSafeStamp;</span>
<span class="line-added">  29 import static org.graalvm.compiler.phases.common.ConditionalEliminationUtil.getSafeStamp;</span>
<span class="line-added">  30 import static org.graalvm.compiler.phases.common.ConditionalEliminationUtil.rewireGuards;</span>
  31 
  32 import java.util.ArrayDeque;
  33 import java.util.Deque;
  34 import java.util.List;
  35 
  36 import jdk.internal.vm.compiler.collections.EconomicMap;
  37 import jdk.internal.vm.compiler.collections.Equivalence;
  38 import jdk.internal.vm.compiler.collections.MapCursor;
  39 import jdk.internal.vm.compiler.collections.Pair;
  40 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
  41 import org.graalvm.compiler.core.common.cfg.BlockMap;
  42 import org.graalvm.compiler.core.common.type.ArithmeticOpTable;
  43 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;
  44 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.And;
  45 import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Or;
  46 import org.graalvm.compiler.core.common.type.IntegerStamp;
  47 import org.graalvm.compiler.core.common.type.ObjectStamp;
  48 import org.graalvm.compiler.core.common.type.Stamp;
  49 import org.graalvm.compiler.core.common.type.StampFactory;
  50 import org.graalvm.compiler.debug.CounterKey;
  51 import org.graalvm.compiler.debug.DebugCloseable;
  52 import org.graalvm.compiler.debug.DebugContext;
  53 import org.graalvm.compiler.graph.Node;
  54 import org.graalvm.compiler.graph.NodeMap;
  55 import org.graalvm.compiler.graph.NodeStack;
  56 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
  57 import org.graalvm.compiler.nodeinfo.InputType;
  58 import org.graalvm.compiler.nodes.AbstractBeginNode;
  59 import org.graalvm.compiler.nodes.AbstractMergeNode;
  60 import org.graalvm.compiler.nodes.BinaryOpLogicNode;
  61 import org.graalvm.compiler.nodes.ConditionAnchorNode;
<span class="line-added">  62 import org.graalvm.compiler.nodes.DeoptimizeNode;</span>
  63 import org.graalvm.compiler.nodes.DeoptimizingGuard;
  64 import org.graalvm.compiler.nodes.EndNode;
  65 import org.graalvm.compiler.nodes.FixedGuardNode;
  66 import org.graalvm.compiler.nodes.FixedNode;
  67 import org.graalvm.compiler.nodes.FixedWithNextNode;
  68 import org.graalvm.compiler.nodes.GuardNode;
  69 import org.graalvm.compiler.nodes.IfNode;
  70 import org.graalvm.compiler.nodes.LogicConstantNode;
  71 import org.graalvm.compiler.nodes.LogicNode;
  72 import org.graalvm.compiler.nodes.LoopExitNode;
  73 import org.graalvm.compiler.nodes.MergeNode;
  74 import org.graalvm.compiler.nodes.NodeView;

  75 import org.graalvm.compiler.nodes.PiNode;
  76 import org.graalvm.compiler.nodes.ProxyNode;

  77 import org.graalvm.compiler.nodes.StructuredGraph;
  78 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  79 import org.graalvm.compiler.nodes.UnaryOpLogicNode;
  80 import org.graalvm.compiler.nodes.ValueNode;
  81 import org.graalvm.compiler.nodes.ValuePhiNode;
  82 import org.graalvm.compiler.nodes.calc.AndNode;


  83 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;

  84 import org.graalvm.compiler.nodes.cfg.Block;
  85 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  86 import org.graalvm.compiler.nodes.extended.GuardingNode;
  87 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
  88 import org.graalvm.compiler.nodes.extended.LoadHubNode;
  89 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
<span class="line-added">  90 import org.graalvm.compiler.nodes.java.InstanceOfNode;</span>
  91 import org.graalvm.compiler.nodes.java.TypeSwitchNode;
<span class="line-added">  92 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
  93 import org.graalvm.compiler.nodes.spi.NodeWithState;
  94 import org.graalvm.compiler.nodes.spi.StampInverter;
  95 import org.graalvm.compiler.nodes.util.GraphUtil;
  96 import org.graalvm.compiler.phases.BasePhase;
<span class="line-added">  97 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.GuardFolding;</span>
<span class="line-added">  98 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.GuardRewirer;</span>
<span class="line-added">  99 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.GuardedCondition;</span>
<span class="line-added"> 100 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.InfoElement;</span>
<span class="line-added"> 101 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.InfoElementProvider;</span>
<span class="line-added"> 102 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.InputFilter;</span>
<span class="line-added"> 103 import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.Marks;</span>
 104 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 105 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;

 106 
 107 import jdk.vm.ci.meta.DeoptimizationAction;

 108 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 109 import jdk.vm.ci.meta.TriState;
 110 
<span class="line-modified"> 111 public class ConditionalEliminationPhase extends BasePhase&lt;CoreProviders&gt; {</span>
 112 
 113     private static final CounterKey counterStampsRegistered = DebugContext.counter(&quot;StampsRegistered&quot;);

 114     private static final CounterKey counterIfsKilled = DebugContext.counter(&quot;CE_KilledIfs&quot;);
 115     private static final CounterKey counterPhiStampsImproved = DebugContext.counter(&quot;CE_ImprovedPhis&quot;);
 116     private final boolean fullSchedule;
 117     private final boolean moveGuards;
 118 
 119     public ConditionalEliminationPhase(boolean fullSchedule) {
 120         this(fullSchedule, true);
 121     }
 122 
 123     public ConditionalEliminationPhase(boolean fullSchedule, boolean moveGuards) {
 124         this.fullSchedule = fullSchedule;
 125         this.moveGuards = moveGuards;
 126     }
 127 
 128     @Override
 129     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 130     protected void run(StructuredGraph graph, CoreProviders context) {</span>
 131         try (DebugContext.Scope s = graph.getDebug().scope(&quot;DominatorConditionalElimination&quot;)) {
 132             BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes = null;
 133             NodeMap&lt;Block&gt; nodeToBlock = null;
 134             ControlFlowGraph cfg = ControlFlowGraph.compute(graph, true, true, true, true);
 135             if (fullSchedule) {
 136                 if (moveGuards) {
 137                     cfg.visitDominatorTree(new MoveGuardsUpwards(), graph.hasValueProxies());
 138                 }
 139                 try (DebugContext.Scope scheduleScope = graph.getDebug().scope(SchedulePhase.class)) {
 140                     SchedulePhase.run(graph, SchedulingStrategy.EARLIEST_WITH_GUARD_ORDER, cfg);
 141                 } catch (Throwable t) {
 142                     throw graph.getDebug().handle(t);
 143                 }
 144                 ScheduleResult r = graph.getLastSchedule();
 145                 blockToNodes = r.getBlockToNodesMap();
 146                 nodeToBlock = r.getNodeToBlockMap();
 147             } else {
 148                 nodeToBlock = cfg.getNodeToBlock();
 149                 blockToNodes = getBlockToNodes(cfg);
 150             }
 151             ControlFlowGraph.RecursiveVisitor&lt;?&gt; visitor = createVisitor(graph, cfg, blockToNodes, nodeToBlock, context);
 152             cfg.visitDominatorTree(visitor, graph.hasValueProxies());
 153         }
 154     }
 155 
 156     protected BlockMap&lt;List&lt;Node&gt;&gt; getBlockToNodes(@SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg) {
 157         return null;
 158     }
 159 
 160     protected ControlFlowGraph.RecursiveVisitor&lt;?&gt; createVisitor(StructuredGraph graph, @SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes,
<span class="line-modified"> 161                     NodeMap&lt;Block&gt; nodeToBlock, CoreProviders context) {</span>
 162         return new Instance(graph, blockToNodes, nodeToBlock, context);
 163     }
 164 
 165     public static class MoveGuardsUpwards implements ControlFlowGraph.RecursiveVisitor&lt;Block&gt; {
 166 
 167         Block anchorBlock;
 168 
 169         @Override
 170         @SuppressWarnings(&quot;try&quot;)
 171         public Block enter(Block b) {
 172             Block oldAnchorBlock = anchorBlock;
 173             if (b.getDominator() == null || b.getDominator().getPostdominator() != b) {
 174                 // New anchor.
 175                 anchorBlock = b;
 176             }
 177 
 178             AbstractBeginNode beginNode = b.getBeginNode();
 179             if (beginNode instanceof AbstractMergeNode &amp;&amp; anchorBlock != b) {
 180                 AbstractMergeNode mergeNode = (AbstractMergeNode) beginNode;
<span class="line-modified"> 181                 mergeNode.replaceAtUsages(InputType.Anchor, anchorBlock.getBeginNode());</span>
<span class="line-modified"> 182                 mergeNode.replaceAtUsages(InputType.Guard, anchorBlock.getBeginNode());</span>
<span class="line-modified"> 183                 assert mergeNode.anchored().isEmpty();</span>





 184             }
 185 
 186             FixedNode endNode = b.getEndNode();
 187             if (endNode instanceof IfNode) {
 188                 IfNode node = (IfNode) endNode;
 189 
 190                 // Check if we can move guards upwards.
 191                 AbstractBeginNode trueSuccessor = node.trueSuccessor();
<span class="line-added"> 192                 AbstractBeginNode falseSuccessor = node.falseSuccessor();</span>
<span class="line-added"> 193 </span>
 194                 EconomicMap&lt;LogicNode, GuardNode&gt; trueGuards = EconomicMap.create(Equivalence.IDENTITY);
 195                 for (GuardNode guard : trueSuccessor.guards()) {
 196                     LogicNode condition = guard.getCondition();
 197                     if (condition.hasMoreThanOneUsage()) {
 198                         trueGuards.put(condition, guard);
 199                     }
 200                 }
 201 
 202                 if (!trueGuards.isEmpty()) {
<span class="line-modified"> 203                     for (GuardNode guard : falseSuccessor.guards().snapshot()) {</span>
 204                         GuardNode otherGuard = trueGuards.get(guard.getCondition());
 205                         if (otherGuard != null &amp;&amp; guard.isNegated() == otherGuard.isNegated()) {
 206                             Speculation speculation = otherGuard.getSpeculation();
 207                             if (speculation == null) {
 208                                 speculation = guard.getSpeculation();
 209                             } else if (guard.getSpeculation() != null &amp;&amp; guard.getSpeculation() != speculation) {
 210                                 // Cannot optimize due to different speculations.
 211                                 continue;
 212                             }
 213                             try (DebugCloseable closeable = guard.withNodeSourcePosition()) {
 214                                 GuardNode newlyCreatedGuard = new GuardNode(guard.getCondition(), anchorBlock.getBeginNode(), guard.getReason(), guard.getAction(), guard.isNegated(), speculation,
 215                                                 guard.getNoDeoptSuccessorPosition());
 216                                 GuardNode newGuard = node.graph().unique(newlyCreatedGuard);
 217                                 if (otherGuard.isAlive()) {
<span class="line-modified"> 218                                     if (trueSuccessor instanceof LoopExitNode &amp;&amp; beginNode.graph().hasValueProxies()) {</span>
<span class="line-added"> 219                                         otherGuard.replaceAndDelete(ProxyNode.forGuard(newGuard, (LoopExitNode) trueSuccessor));</span>
<span class="line-added"> 220                                     } else {</span>
<span class="line-added"> 221                                         otherGuard.replaceAndDelete(newGuard);</span>
<span class="line-added"> 222                                     }</span>
<span class="line-added"> 223                                 }</span>
<span class="line-added"> 224                                 if (falseSuccessor instanceof LoopExitNode &amp;&amp; beginNode.graph().hasValueProxies()) {</span>
<span class="line-added"> 225                                     guard.replaceAndDelete(ProxyNode.forGuard(newGuard, (LoopExitNode) falseSuccessor));</span>
<span class="line-added"> 226                                 } else {</span>
<span class="line-added"> 227                                     guard.replaceAndDelete(newGuard);</span>
 228                                 }

 229                             }
 230                         }
 231                     }
 232                 }
 233             }
 234             return oldAnchorBlock;
 235         }
 236 
 237         @Override
 238         public void exit(Block b, Block value) {
 239             anchorBlock = value;
 240         }
 241 
 242     }
 243 
 244     private static final class PhiInfoElement {
 245 
 246         private EconomicMap&lt;EndNode, InfoElement&gt; infoElements;
 247 
 248         public void set(EndNode end, InfoElement infoElement) {
 249             if (infoElements == null) {
 250                 infoElements = EconomicMap.create(Equivalence.IDENTITY);
 251             }
 252             infoElements.put(end, infoElement);
 253         }
 254 
 255         public InfoElement get(EndNode end) {
 256             if (infoElements == null) {
 257                 return null;
 258             }
 259             return infoElements.get(end);
 260         }
 261     }
 262 


































 263     public static class Instance implements ControlFlowGraph.RecursiveVisitor&lt;Marks&gt; {
 264         protected final NodeMap&lt;InfoElement&gt; map;
 265         protected final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes;
 266         protected final NodeMap&lt;Block&gt; nodeToBlock;
 267         protected final CanonicalizerTool tool;
 268         protected final NodeStack undoOperations;
 269         protected final StructuredGraph graph;
 270         protected final DebugContext debug;
 271         protected final EconomicMap&lt;MergeNode, EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt;&gt; mergeMaps;
<span class="line-added"> 272         private final InfoElementProvider infoElementProvider;</span>
<span class="line-added"> 273         private final GuardFolding guardFolding;</span>
 274 
 275         protected final ArrayDeque&lt;GuardedCondition&gt; conditions;
 276 
 277         /**
 278          * Tests which may be eliminated because post dominating tests to prove a broader condition.
 279          */
 280         private Deque&lt;DeoptimizingGuard&gt; pendingTests;
 281 
<span class="line-modified"> 282         public Instance(StructuredGraph graph, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes, NodeMap&lt;Block&gt; nodeToBlock, CoreProviders context) {</span>
 283             this.graph = graph;
 284             this.debug = graph.getDebug();
 285             this.blockToNodes = blockToNodes;
 286             this.nodeToBlock = nodeToBlock;
 287             this.undoOperations = new NodeStack();
 288             this.map = graph.createNodeMap();
 289             this.pendingTests = new ArrayDeque&lt;&gt;();
 290             this.conditions = new ArrayDeque&lt;&gt;();
 291             tool = GraphUtil.getDefaultSimplifier(context.getMetaAccess(), context.getConstantReflection(), context.getConstantFieldProvider(), false, graph.getAssumptions(), graph.getOptions(),
 292                             context.getLowerer());
<span class="line-modified"> 293             mergeMaps = EconomicMap.create(Equivalence.IDENTITY);</span>
<span class="line-added"> 294             infoElementProvider = new InfoElementProvider() {</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296                 @Override</span>
<span class="line-added"> 297                 public InfoElement infoElements(ValueNode value) {</span>
<span class="line-added"> 298                     return getInfoElements(value);</span>
<span class="line-added"> 299                 }</span>
<span class="line-added"> 300             };</span>
<span class="line-added"> 301             guardFolding = new GuardFolding() {</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303                 @Override</span>
<span class="line-added"> 304                 public boolean foldGuard(DeoptimizingGuard thisGuard, ValueNode original, Stamp newStamp, GuardRewirer rewireGuardFunction) {</span>
<span class="line-added"> 305                     return foldPendingTest(thisGuard, original, newStamp, rewireGuardFunction);</span>
<span class="line-added"> 306                 }</span>
<span class="line-added"> 307             };</span>
 308         }
 309 
 310         protected void processConditionAnchor(ConditionAnchorNode node) {
<span class="line-modified"> 311             tryProveGuardCondition(null, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
 312                 if (result != node.isNegated()) {
 313                     node.replaceAtUsages(guard.asNode());
 314                     GraphUtil.unlinkFixedNode(node);
 315                     GraphUtil.killWithUnusedFloatingInputs(node);
 316                 } else {
 317                     ValueAnchorNode valueAnchor = node.graph().add(new ValueAnchorNode(null));
 318                     node.replaceAtUsages(valueAnchor);
 319                     node.graph().replaceFixedWithFixed(node, valueAnchor);
 320                 }
 321                 return true;
 322             });
 323         }
 324 
 325         protected void processGuard(GuardNode node) {
 326             if (!tryProveGuardCondition(node, node.getCondition(), (guard, result, guardedValueStamp, newInput) -&gt; {
 327                 if (result != node.isNegated()) {
 328                     node.replaceAndDelete(guard.asNode());
<span class="line-added"> 329                     if (guard instanceof DeoptimizingGuard &amp;&amp; !((DeoptimizingGuard) guard).isNegated()) {</span>
<span class="line-added"> 330                         rebuildPiNodes((DeoptimizingGuard) guard);</span>
<span class="line-added"> 331                     }</span>
 332                 } else {









 333                     AbstractBeginNode beginNode = (AbstractBeginNode) node.getAnchor();

 334 
<span class="line-added"> 335                     if (beginNode.next() instanceof DeoptimizeNode) {</span>
<span class="line-added"> 336                         // This branch is already dead.</span>
<span class="line-added"> 337                     } else {</span>
<span class="line-added"> 338                         /*</span>
<span class="line-added"> 339                          * Don&#39;t kill this branch immediately because `killCFG` can have complex</span>
<span class="line-added"> 340                          * implications in the presence of loops: it might replace or delete nodes</span>
<span class="line-added"> 341                          * in other branches or even above the kill point. Instead of killing</span>
<span class="line-added"> 342                          * immediately, just leave the graph in a state that is easy to simplify by</span>
<span class="line-added"> 343                          * a subsequent canonicalizer phase.</span>
<span class="line-added"> 344                          */</span>
<span class="line-added"> 345                         FixedGuardNode deopt = new FixedGuardNode(LogicConstantNode.forBoolean(result, node.graph()), node.getReason(), node.getAction(), node.getSpeculation(), node.isNegated(),</span>
<span class="line-added"> 346                                         node.getNodeSourcePosition());</span>
<span class="line-added"> 347                         graph.addAfterFixed(beginNode, node.graph().add(deopt));</span>
<span class="line-added"> 348                     }</span>
 349                 }
 350                 return true;
 351             })) {
 352                 registerNewCondition(node.getCondition(), node.isNegated(), node);
 353             }
 354         }
 355 
 356         protected void processFixedGuard(FixedGuardNode node) {
 357             if (!tryProveGuardCondition(node, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {
 358                 if (result != node.isNegated()) {
 359                     node.replaceAtUsages(guard.asNode());
 360                     GraphUtil.unlinkFixedNode(node);
 361                     GraphUtil.killWithUnusedFloatingInputs(node);
<span class="line-added"> 362                     if (guard instanceof DeoptimizingGuard &amp;&amp; !((DeoptimizingGuard) guard).isNegated()) {</span>
<span class="line-added"> 363                         rebuildPiNodes((DeoptimizingGuard) guard);</span>
<span class="line-added"> 364                     }</span>
 365                 } else {
 366                     node.setCondition(LogicConstantNode.forBoolean(result, node.graph()), node.isNegated());
 367                     // Don&#39;t kill this branch immediately, see `processGuard`.
 368                 }
<span class="line-modified"> 369 </span>
<span class="line-added"> 370                 debug.log(&quot;Kill fixed guard %s&quot;, node);</span>
 371                 return true;
 372             })) {
 373                 registerNewCondition(node.condition(), node.isNegated(), node);
 374             }
 375         }
 376 
<span class="line-added"> 377         private void rebuildPiNodes(DeoptimizingGuard guard) {</span>
<span class="line-added"> 378             LogicNode newCondition = guard.getCondition();</span>
<span class="line-added"> 379             if (newCondition instanceof InstanceOfNode) {</span>
<span class="line-added"> 380                 InstanceOfNode inst = (InstanceOfNode) newCondition;</span>
<span class="line-added"> 381                 ValueNode originalValue = GraphUtil.skipPi(inst.getValue());</span>
<span class="line-added"> 382                 PiNode pi = null;</span>
<span class="line-added"> 383                 // Ensure that any Pi that&#39;s weaker than what the instanceof proves is</span>
<span class="line-added"> 384                 // replaced by one derived from the instanceof itself.</span>
<span class="line-added"> 385                 for (PiNode existing : guard.asNode().usages().filter(PiNode.class).snapshot()) {</span>
<span class="line-added"> 386                     if (!existing.isAlive()) {</span>
<span class="line-added"> 387                         continue;</span>
<span class="line-added"> 388                     }</span>
<span class="line-added"> 389                     if (originalValue != GraphUtil.skipPi(existing.object())) {</span>
<span class="line-added"> 390                         // Somehow these are unrelated values so leave it alone</span>
<span class="line-added"> 391                         continue;</span>
<span class="line-added"> 392                     }</span>
<span class="line-added"> 393                     // If the pi has a weaker stamp or the same stamp but a different input</span>
<span class="line-added"> 394                     // then replace it.</span>
<span class="line-added"> 395                     boolean strongerStamp = !existing.piStamp().join(inst.getCheckedStamp()).equals(inst.getCheckedStamp());</span>
<span class="line-added"> 396                     boolean differentCheckedStamp = !existing.piStamp().equals(inst.getCheckedStamp());</span>
<span class="line-added"> 397                     boolean differentObject = existing.object() != inst.getValue();</span>
<span class="line-added"> 398                     if (!strongerStamp &amp;&amp; (differentCheckedStamp || differentObject)) {</span>
<span class="line-added"> 399                         if (pi == null) {</span>
<span class="line-added"> 400                             pi = graph.unique(new PiNode(inst.getValue(), inst.getCheckedStamp(), (ValueNode) guard));</span>
<span class="line-added"> 401                         }</span>
<span class="line-added"> 402                         if (!pi.stamp(NodeView.DEFAULT).join(existing.stamp(NodeView.DEFAULT)).equals(pi.stamp(NodeView.DEFAULT))) {</span>
<span class="line-added"> 403                             /*</span>
<span class="line-added"> 404                              * With a code sequence like null check, type check, null check of type</span>
<span class="line-added"> 405                              * checked value, CE will use the first null check to prove the second</span>
<span class="line-added"> 406                              * null check so the graph ends up a Pi guarded by the first null check</span>
<span class="line-added"> 407                              * but consuming the output Pi from the type check check. In this case</span>
<span class="line-added"> 408                              * we should still canonicalize the checked stamp for consistency.</span>
<span class="line-added"> 409                              */</span>
<span class="line-added"> 410                             if (differentCheckedStamp) {</span>
<span class="line-added"> 411                                 PiNode alternatePi = graph.unique(new PiNode(existing.object(), inst.getCheckedStamp(), (ValueNode) guard));</span>
<span class="line-added"> 412                                 /*</span>
<span class="line-added"> 413                                  * If the resulting stamp is as good or better then do the</span>
<span class="line-added"> 414                                  * replacement. However when interface types are involved it&#39;s</span>
<span class="line-added"> 415                                  * possible that improving the checked stamp merges types which</span>
<span class="line-added"> 416                                  * appear unrelated so there&#39;s we must skip the replacement.</span>
<span class="line-added"> 417                                  */</span>
<span class="line-added"> 418                                 if (alternatePi.stamp(NodeView.DEFAULT).join(existing.stamp(NodeView.DEFAULT)).equals(alternatePi.stamp(NodeView.DEFAULT))) {</span>
<span class="line-added"> 419                                     existing.replaceAndDelete(alternatePi);</span>
<span class="line-added"> 420                                 }</span>
<span class="line-added"> 421                             }</span>
<span class="line-added"> 422                             continue;</span>
<span class="line-added"> 423                         }</span>
<span class="line-added"> 424                         existing.replaceAndDelete(pi);</span>
<span class="line-added"> 425                     }</span>
<span class="line-added"> 426                 }</span>
<span class="line-added"> 427             }</span>
<span class="line-added"> 428         }</span>
<span class="line-added"> 429 </span>
 430         protected void processIf(IfNode node) {
<span class="line-modified"> 431             tryProveGuardCondition(null, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
 432                 node.setCondition(LogicConstantNode.forBoolean(result, node.graph()));
 433                 AbstractBeginNode survivingSuccessor = node.getSuccessor(result);
 434                 survivingSuccessor.replaceAtUsages(InputType.Guard, guard.asNode());
 435                 // Don&#39;t kill the other branch immediately, see `processGuard`.
 436                 counterIfsKilled.increment(debug);
 437                 return true;
 438             });
 439         }
 440 
 441         @Override
 442         public Marks enter(Block block) {
 443             int infoElementsMark = undoOperations.size();
 444             int conditionsMark = conditions.size();
 445             debug.log(&quot;[Pre Processing block %s]&quot;, block);
 446             // For now conservatively collect guards only within the same block.
 447             pendingTests.clear();
 448             processNodes(block);
 449             return new Marks(infoElementsMark, conditionsMark);
 450         }
 451 
</pre>
<hr />
<pre>
 550                         if (bestPossibleStamp instanceof ObjectStamp) {
 551                             // Always allow object stamps.
 552                             allow = true;
 553                         } else if (bestPossibleStamp instanceof IntegerStamp) {
 554                             IntegerStamp integerStamp = (IntegerStamp) bestPossibleStamp;
 555                             IntegerStamp oldIntegerStamp = (IntegerStamp) oldStamp;
 556                             if (integerStamp.isPositive() != oldIntegerStamp.isPositive()) {
 557                                 allow = true;
 558                             } else if (integerStamp.isNegative() != oldIntegerStamp.isNegative()) {
 559                                 allow = true;
 560                             } else if (integerStamp.isStrictlyPositive() != oldIntegerStamp.isStrictlyPositive()) {
 561                                 allow = true;
 562                             } else if (integerStamp.isStrictlyNegative() != oldIntegerStamp.isStrictlyNegative()) {
 563                                 allow = true;
 564                             } else if (integerStamp.asConstant() != null) {
 565                                 allow = true;
 566                             } else if (oldStamp.isUnrestricted()) {
 567                                 allow = true;
 568                             }
 569                         } else {
<span class="line-added"> 570                             // Fortify: Suppress Null Dereference false positive</span>
<span class="line-added"> 571                             assert bestPossibleStamp != null;</span>
 572                             allow = (bestPossibleStamp.asConstant() != null);
 573                         }
 574 
 575                         if (allow) {
 576                             ValuePhiNode newPhi = graph.addWithoutUnique(new ValuePhiNode(bestPossibleStamp, merge));
 577                             for (int i = 0; i &lt; phi.valueCount(); ++i) {
 578                                 ValueNode valueAt = phi.valueAt(i);
 579                                 if (bestPossibleStamp.meet(valueAt.stamp(NodeView.DEFAULT)).equals(bestPossibleStamp)) {
 580                                     // Pi not required here.
 581                                 } else {
 582                                     InfoElement infoElement = phiInfoElements.get(merge.forwardEndAt(i));
 583                                     assert infoElement != null;
 584                                     Stamp curBestStamp = infoElement.getStamp();
 585                                     ValueNode input = infoElement.getProxifiedInput();
 586                                     if (input == null) {
 587                                         input = valueAt;
 588                                     }
<span class="line-modified"> 589                                     valueAt = graph.maybeAddOrUnique(PiNode.create(input, curBestStamp, (ValueNode) infoElement.getGuard()));</span>
 590                                 }
 591                                 newPhi.addInput(valueAt);
 592                             }
 593                             counterPhiStampsImproved.increment(debug);
 594                             phi.replaceAtUsagesAndDelete(newPhi);
 595                         }
 596                     }
 597                 }
 598             }
 599         }
 600 
 601         protected void processEnd(EndNode end) {
 602             AbstractMergeNode abstractMerge = end.merge();
 603             if (abstractMerge instanceof MergeNode) {
 604                 MergeNode merge = (MergeNode) abstractMerge;
 605 
 606                 EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt; mergeMap = this.mergeMaps.get(merge);
 607                 for (ValuePhiNode phi : merge.valuePhis()) {
 608                     ValueNode valueAt = phi.valueAt(end);
 609                     InfoElement infoElement = this.getInfoElements(valueAt);
 610                     while (infoElement != null) {
 611                         Stamp newStamp = infoElement.getStamp();
 612                         if (phi.stamp(NodeView.DEFAULT).tryImproveWith(newStamp) != null) {
 613                             if (mergeMap == null) {
<span class="line-modified"> 614                                 mergeMap = EconomicMap.create(Equivalence.IDENTITY);</span>
 615                                 mergeMaps.put(merge, mergeMap);
 616                             }
 617 
 618                             PhiInfoElement phiInfoElement = mergeMap.get(phi);
 619                             if (phiInfoElement == null) {
 620                                 phiInfoElement = new PhiInfoElement();
 621                                 mergeMap.put(phi, phiInfoElement);
 622                             }
 623 
 624                             phiInfoElement.set(end, infoElement);
 625                             break;
 626                         }
 627                         infoElement = nextElement(infoElement);
 628                     }
 629                 }
 630             }
 631         }
 632 
 633         protected void registerNewCondition(LogicNode condition, boolean negated, GuardingNode guard) {
 634             if (condition instanceof UnaryOpLogicNode) {
</pre>
<hr />
<pre>
 661                         if (and.getY() == y &amp;&amp; maybeMultipleUsages(andX)) {
 662                             /*
 663                              * This &#39;and&#39; proves something about some of the bits in and.getX().
 664                              * It&#39;s equivalent to or&#39;ing in the mask value since those values are
 665                              * known to be set.
 666                              */
 667                             BinaryOp&lt;Or&gt; op = ArithmeticOpTable.forStamp(x.stamp(NodeView.DEFAULT)).getOr();
 668                             IntegerStamp newStampX = (IntegerStamp) op.foldStamp(getSafeStamp(andX), getOtherSafeStamp(y));
 669                             registerNewStamp(andX, newStampX, guard);
 670                         }
 671                     }
 672                 }
 673             }
 674             if (guard instanceof DeoptimizingGuard) {
 675                 assert ((DeoptimizingGuard) guard).getCondition() == condition;
 676                 pendingTests.push((DeoptimizingGuard) guard);
 677             }
 678             registerCondition(condition, negated, guard);
 679         }
 680 






















































 681         /**
 682          * Recursively try to fold stamps within this expression using information from
 683          * {@link #getInfoElements(ValueNode)}. It&#39;s only safe to use constants and one
 684          * {@link InfoElement} otherwise more than one guard would be required.
 685          *
 686          * @param node
 687          * @return the pair of the @{link InfoElement} used and the stamp produced for the whole
 688          *         expression
 689          */
 690         Pair&lt;InfoElement, Stamp&gt; recursiveFoldStampFromInfo(Node node) {
<span class="line-modified"> 691             return ConditionalEliminationUtil.recursiveFoldStamp(infoElementProvider, node);</span>
 692         }
 693 
 694         /**
 695          * Look for a preceding guard whose condition is implied by {@code thisGuard}. If we find
 696          * one, try to move this guard just above that preceding guard so that we can fold it:
 697          *
 698          * &lt;pre&gt;
 699          *     guard(C1); // preceding guard
 700          *     ...
 701          *     guard(C2); // thisGuard
 702          * &lt;/pre&gt;
 703          *
 704          * If C2 =&gt; C1, transform to:
 705          *
 706          * &lt;pre&gt;
 707          *     guard(C2);
 708          *     ...
 709          * &lt;/pre&gt;
 710          */
 711         protected boolean foldPendingTest(DeoptimizingGuard thisGuard, ValueNode original, Stamp newStamp, GuardRewirer rewireGuardFunction) {
</pre>
<hr />
<pre>
 787                 GuardRewirer rewirer = (guard, result, innerGuardedValueStamp, newInput) -&gt; {
 788                     // `result` is `outcome`, `guard` is `otherGuard`
 789                     boolean mustDeopt = result == otherGuard.isNegated();
 790                     if (rewireGuardFunction.rewire(guard, mustDeopt == thisGuard.isNegated(), innerGuardedValueStamp, newInput)) {
 791                         if (!mustDeopt) {
 792                             otherGuard.setCondition(condition, thisGuard.isNegated());
 793                             otherGuard.setAction(action);
 794                             otherGuard.setReason(thisGuard.getReason());
 795                         }
 796                         return true;
 797                     }
 798                     condition.safeDelete();
 799                     return false;
 800                 };
 801                 // Move the later test up
 802                 return rewireGuards(otherGuard, outcome, null, guardedValueStamp, rewirer);
 803             }
 804             return false;
 805         }
 806 
<span class="line-added"> 807         protected boolean tryProveGuardCondition(DeoptimizingGuard thisGuard, LogicNode node, GuardRewirer rewireGuardFunction) {</span>
<span class="line-added"> 808             return ConditionalEliminationUtil.tryProveGuardCondition(infoElementProvider, conditions, guardFolding, thisGuard, node, rewireGuardFunction);</span>
<span class="line-added"> 809         }</span>
<span class="line-added"> 810 </span>
 811         protected void registerCondition(LogicNode condition, boolean negated, GuardingNode guard) {
 812             if (condition.hasMoreThanOneUsage()) {
 813                 registerNewStamp(condition, negated ? StampFactory.contradiction() : StampFactory.tautology(), guard);
 814             }
 815             conditions.push(new GuardedCondition(guard, condition, negated));
 816         }
 817 
 818         protected InfoElement getInfoElements(ValueNode proxiedValue) {
 819             if (proxiedValue == null) {
 820                 return null;
 821             }
 822             InfoElement infoElement = map.getAndGrow(proxiedValue);
 823             if (infoElement == null) {
 824                 infoElement = map.getAndGrow(GraphUtil.skipPi(proxiedValue));
 825             }
 826             return infoElement;
 827         }
 828 









 829         private InfoElement nextElement(InfoElement current) {
 830             InfoElement parent = current.getParent();
 831             if (parent != null) {
 832                 return parent;
 833             } else {
 834                 ValueNode proxifiedInput = current.getProxifiedInput();
 835                 if (proxifiedInput instanceof PiNode) {
 836                     PiNode piNode = (PiNode) proxifiedInput;
 837                     return getInfoElements(piNode.getOriginalNode());
 838                 }
 839             }
 840             return null;
 841         }
 842 
































































































































































 843         protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard) {
 844             registerNewStamp(maybeProxiedValue, newStamp, guard, false);
 845         }
 846 
 847         protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard, boolean propagateThroughPis) {
 848             assert maybeProxiedValue != null;
 849             assert guard != null;
 850 
 851             if (newStamp == null || newStamp.isUnrestricted()) {
 852                 return;
 853             }
 854 
 855             ValueNode value = maybeProxiedValue;
 856             Stamp stamp = newStamp;
 857 
 858             while (stamp != null &amp;&amp; value != null) {
 859                 ValueNode proxiedValue = null;
 860                 if (value instanceof PiNode) {
 861                     proxiedValue = value;
 862                 }
</pre>
<hr />
<pre>
 928             }
 929         }
 930 
 931         @Override
 932         public void exit(Block b, Marks marks) {
 933             int infoElementsMark = marks.infoElementOperations;
 934             while (undoOperations.size() &gt; infoElementsMark) {
 935                 Node node = undoOperations.pop();
 936                 if (node.isAlive()) {
 937                     map.set(node, map.get(node).getParent());
 938                 }
 939             }
 940 
 941             int conditionsMark = marks.conditions;
 942             while (conditions.size() &gt; conditionsMark) {
 943                 conditions.pop();
 944             }
 945         }
 946     }
 947 

























































































 948     @Override
 949     public float codeSizeIncrease() {
 950         return 1.5f;
 951     }
 952 }
</pre>
</td>
</tr>
</table>
<center><a href="CanonicalizerPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="DeoptimizationGroupingPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
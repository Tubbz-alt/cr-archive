<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptImplicitNullChecks;
 28 
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.debug.CounterKey;
 32 import org.graalvm.compiler.debug.DebugContext;
 33 import org.graalvm.compiler.graph.Node;
 34 import org.graalvm.compiler.nodeinfo.InputType;
 35 import org.graalvm.compiler.nodes.AbstractBeginNode;
 36 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
 37 import org.graalvm.compiler.nodes.AbstractEndNode;
 38 import org.graalvm.compiler.nodes.AbstractMergeNode;
 39 import org.graalvm.compiler.nodes.BeginNode;
 40 import org.graalvm.compiler.nodes.CompressionNode;
 41 import org.graalvm.compiler.nodes.DeoptimizeNode;
 42 import org.graalvm.compiler.nodes.DeoptimizingFixedWithNextNode;
 43 import org.graalvm.compiler.nodes.DynamicDeoptimizeNode;
 44 import org.graalvm.compiler.nodes.EndNode;
 45 import org.graalvm.compiler.nodes.FixedNode;
 46 import org.graalvm.compiler.nodes.IfNode;
 47 import org.graalvm.compiler.nodes.LogicNode;
 48 import org.graalvm.compiler.nodes.LoopExitNode;
 49 import org.graalvm.compiler.nodes.StructuredGraph;
 50 import org.graalvm.compiler.nodes.ValueNode;
 51 import org.graalvm.compiler.nodes.ValuePhiNode;
 52 import org.graalvm.compiler.nodes.calc.IsNullNode;
 53 import org.graalvm.compiler.nodes.extended.NullCheckNode;
 54 import org.graalvm.compiler.nodes.memory.FixedAccessNode;
 55 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 56 import org.graalvm.compiler.nodes.util.GraphUtil;
 57 import org.graalvm.compiler.options.Option;
 58 import org.graalvm.compiler.options.OptionKey;
 59 import org.graalvm.compiler.options.OptionType;
 60 import org.graalvm.compiler.phases.BasePhase;
 61 import org.graalvm.compiler.phases.tiers.LowTierContext;
 62 
 63 import jdk.vm.ci.meta.DeoptimizationReason;
 64 import jdk.vm.ci.meta.MetaAccessProvider;
 65 import jdk.vm.ci.meta.SpeculationLog;
 66 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 67 
 68 public class UseTrappingNullChecksPhase extends BasePhase&lt;LowTierContext&gt; {
 69 
 70     private static final CounterKey counterTrappingNullCheck = DebugContext.counter(&quot;TrappingNullCheck&quot;);
 71     private static final CounterKey counterTrappingNullCheckExistingRead = DebugContext.counter(&quot;TrappingNullCheckExistingRead&quot;);
 72     private static final CounterKey counterTrappingNullCheckUnreached = DebugContext.counter(&quot;TrappingNullCheckUnreached&quot;);
 73     private static final CounterKey counterTrappingNullCheckDynamicDeoptimize = DebugContext.counter(&quot;TrappingNullCheckDynamicDeoptimize&quot;);
 74 
 75     public static class Options {
 76 
 77         // @formatter:off
 78         @Option(help = &quot;Use traps for null checks instead of explicit null-checks&quot;, type = OptionType.Expert)
 79         public static final OptionKey&lt;Boolean&gt; UseTrappingNullChecks = new OptionKey&lt;&gt;(true);
 80         // @formatter:on
 81     }
 82 
 83     @Override
 84     protected void run(StructuredGraph graph, LowTierContext context) {
 85         if (!Options.UseTrappingNullChecks.getValue(graph.getOptions()) || context.getTarget().implicitNullCheckLimit &lt;= 0) {
 86             return;
 87         }
 88         assert graph.getGuardsStage().areFrameStatesAtDeopts();
 89 
 90         long implicitNullCheckLimit = context.getTarget().implicitNullCheckLimit;
 91         for (DeoptimizeNode deopt : graph.getNodes(DeoptimizeNode.TYPE)) {
 92             tryUseTrappingNullCheck(deopt, deopt.predecessor(), deopt.getReason(), deopt.getSpeculation(), implicitNullCheckLimit);
 93         }
 94         for (DynamicDeoptimizeNode deopt : graph.getNodes(DynamicDeoptimizeNode.TYPE)) {
 95             tryUseTrappingNullCheck(context.getMetaAccess(), deopt, implicitNullCheckLimit);
 96         }
 97 
 98     }
 99 
100     private static void tryUseTrappingNullCheck(MetaAccessProvider metaAccessProvider, DynamicDeoptimizeNode deopt, long implicitNullCheckLimit) {
101         Node predecessor = deopt.predecessor();
102         if (predecessor instanceof AbstractMergeNode) {
103             AbstractMergeNode merge = (AbstractMergeNode) predecessor;
104 
105             // Process each predecessor at the merge, unpacking the reasons and speculations as
106             // needed.
107             ValueNode reason = deopt.getActionAndReason();
108             ValuePhiNode reasonPhi = null;
109             List&lt;ValueNode&gt; reasons = null;
110             int expectedPhis = 0;
111 
112             if (reason instanceof ValuePhiNode) {
113                 reasonPhi = (ValuePhiNode) reason;
114                 if (reasonPhi.merge() != merge) {
115                     return;
116                 }
117                 reasons = reasonPhi.values().snapshot();
118                 expectedPhis++;
119             } else if (!reason.isConstant()) {
120                 merge.getDebug().log(&quot;Non constant reason %s&quot;, merge);
121                 return;
122             }
123 
124             ValueNode speculation = deopt.getSpeculation();
125             ValuePhiNode speculationPhi = null;
126             List&lt;ValueNode&gt; speculations = null;
127             if (speculation instanceof ValuePhiNode) {
128                 speculationPhi = (ValuePhiNode) speculation;
129                 if (speculationPhi.merge() != merge) {
130                     return;
131                 }
132                 speculations = speculationPhi.values().snapshot();
133                 expectedPhis++;
134             }
135 
136             if (merge.phis().count() != expectedPhis) {
137                 return;
138             }
139 
140             int index = 0;
141             List&lt;EndNode&gt; predecessors = merge.cfgPredecessors().snapshot();
142             for (AbstractEndNode end : predecessors) {
143                 Node endPredecesssor = end.predecessor();
144                 ValueNode thisReason = reasons != null ? reasons.get(index) : reason;
145                 ValueNode thisSpeculation = speculations != null ? speculations.get(index) : speculation;
146                 if (!merge.isAlive()) {
147                     // When evacuating a merge the last successor simplfies the merge away so it
148                     // must be handled specially.
149                     assert predecessors.get(predecessors.size() - 1) == end : &quot;must be last end&quot;;
150                     endPredecesssor = deopt.predecessor();
151                     thisSpeculation = deopt.getSpeculation();
152                     thisReason = deopt.getActionAndReason();
153                 }
154 
155                 index++;
156                 if (!thisReason.isConstant() || !thisSpeculation.isConstant()) {
157                     end.getDebug().log(&quot;Non constant deopt %s&quot;, end);
158                     continue;
159                 }
160                 DeoptimizationReason deoptimizationReason = metaAccessProvider.decodeDeoptReason(thisReason.asJavaConstant());
161                 Speculation speculationConstant = metaAccessProvider.decodeSpeculation(thisSpeculation.asJavaConstant(), deopt.graph().getSpeculationLog());
162                 tryUseTrappingNullCheck(deopt, endPredecesssor, deoptimizationReason, speculationConstant, implicitNullCheckLimit);
163             }
164         }
165     }
166 
167     private static void tryUseTrappingNullCheck(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, Speculation speculation, long implicitNullCheckLimit) {
168         assert predecessor != null;
169         if (deoptimizationReason != DeoptimizationReason.NullCheckException &amp;&amp; deoptimizationReason != DeoptimizationReason.UnreachedCode &amp;&amp;
170                         deoptimizationReason != DeoptimizationReason.TypeCheckedInliningViolated) {
171             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Not a null check or unreached %s&quot;, predecessor);
172             return;
173         }
174         assert speculation != null;
175         if (!speculation.equals(SpeculationLog.NO_SPECULATION)) {
176             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Has a speculation %s&quot;, predecessor);
177             return;
178         }
179 
180         // Skip over loop exit nodes.
181         Node pred = predecessor;
182         while (pred instanceof LoopExitNode) {
183             pred = pred.predecessor();
184         }
185         if (pred instanceof AbstractMergeNode) {
186             AbstractMergeNode merge = (AbstractMergeNode) pred;
187             if (merge.phis().isEmpty()) {
188                 for (AbstractEndNode end : merge.cfgPredecessors().snapshot()) {
189                     checkPredecessor(deopt, end.predecessor(), deoptimizationReason, implicitNullCheckLimit);
190                 }
191             }
192         } else if (pred instanceof AbstractBeginNode) {
193             checkPredecessor(deopt, pred, deoptimizationReason, implicitNullCheckLimit);
194         } else {
195             deopt.getDebug().log(DebugContext.INFO_LEVEL, &quot;Not a Begin or Merge %s&quot;, pred);
196         }
197     }
198 
199     private static void checkPredecessor(AbstractDeoptimizeNode deopt, Node predecessor, DeoptimizationReason deoptimizationReason, long implicitNullCheckLimit) {
200         Node current = predecessor;
201         AbstractBeginNode branch = null;
202         while (current instanceof AbstractBeginNode) {
203             branch = (AbstractBeginNode) current;
204             if (branch.anchored().isNotEmpty()) {
205                 // some input of the deopt framestate is anchored to this branch
206                 return;
207             }
208             current = current.predecessor();
209         }
210         if (current instanceof IfNode) {
211             IfNode ifNode = (IfNode) current;
212             if (branch != ifNode.trueSuccessor()) {
213                 return;
214             }
215             LogicNode condition = ifNode.condition();
216             if (condition instanceof IsNullNode) {
217                 replaceWithTrappingNullCheck(deopt, ifNode, condition, deoptimizationReason, implicitNullCheckLimit);
218             }
219         }
220     }
221 
222     private static void replaceWithTrappingNullCheck(AbstractDeoptimizeNode deopt, IfNode ifNode, LogicNode condition, DeoptimizationReason deoptimizationReason, long implicitNullCheckLimit) {
223         DebugContext debug = deopt.getDebug();
224         counterTrappingNullCheck.increment(debug);
225         if (deopt instanceof DynamicDeoptimizeNode) {
226             counterTrappingNullCheckDynamicDeoptimize.increment(debug);
227         }
228         if (deoptimizationReason == DeoptimizationReason.UnreachedCode) {
229             counterTrappingNullCheckUnreached.increment(debug);
230         }
231         IsNullNode isNullNode = (IsNullNode) condition;
232         AbstractBeginNode nonTrappingContinuation = ifNode.falseSuccessor();
233         AbstractBeginNode trappingContinuation = ifNode.trueSuccessor();
234 
235         DeoptimizingFixedWithNextNode trappingNullCheck = null;
236         FixedNode nextNonTrapping = nonTrappingContinuation.next();
237         ValueNode value = isNullNode.getValue();
238         if (OptImplicitNullChecks.getValue(ifNode.graph().getOptions()) &amp;&amp; implicitNullCheckLimit &gt; 0) {
239             if (nextNonTrapping instanceof FixedAccessNode) {
240                 FixedAccessNode fixedAccessNode = (FixedAccessNode) nextNonTrapping;
241                 if (fixedAccessNode.canNullCheck()) {
242                     AddressNode address = fixedAccessNode.getAddress();
243                     ValueNode base = address.getBase();
244                     ValueNode index = address.getIndex();
245                     // allow for architectures which cannot fold an
246                     // intervening uncompress out of the address chain
247                     if (base != null &amp;&amp; base instanceof CompressionNode) {
248                         base = ((CompressionNode) base).getValue();
249                     }
250                     if (index != null &amp;&amp; index instanceof CompressionNode) {
251                         index = ((CompressionNode) index).getValue();
252                     }
253                     if (((base == value &amp;&amp; index == null) || (base == null &amp;&amp; index == value)) &amp;&amp; address.getMaxConstantDisplacement() &lt; implicitNullCheckLimit) {
254                         // Opportunity for implicit null check as part of an existing read found!
255                         fixedAccessNode.setStateBefore(deopt.stateBefore());
256                         fixedAccessNode.setNullCheck(true);
257                         deopt.graph().removeSplit(ifNode, nonTrappingContinuation);
258                         trappingNullCheck = fixedAccessNode;
259                         counterTrappingNullCheckExistingRead.increment(debug);
260                         deopt.getDebug().log(&quot;Added implicit null check to %s&quot;, fixedAccessNode);
261                     }
262                 }
263             }
264         }
265 
266         if (trappingNullCheck == null) {
267             // Need to add a null check node.
268             trappingNullCheck = deopt.graph().add(new NullCheckNode(value));
269             deopt.graph().replaceSplit(ifNode, trappingNullCheck, nonTrappingContinuation);
270             deopt.getDebug().log(&quot;Inserted NullCheckNode %s&quot;, trappingNullCheck);
271         }
272 
273         trappingNullCheck.setStateBefore(deopt.stateBefore());
274 
275         /*
276          * We now have the pattern NullCheck/BeginNode/... It&#39;s possible some node is using the
277          * BeginNode as a guard input, so replace guard users of the Begin with the NullCheck and
278          * then remove the Begin from the graph.
279          */
280         nonTrappingContinuation.replaceAtUsages(InputType.Guard, trappingNullCheck);
281 
282         if (nonTrappingContinuation instanceof BeginNode) {
283             GraphUtil.unlinkFixedNode(nonTrappingContinuation);
284             nonTrappingContinuation.safeDelete();
285         }
286 
287         GraphUtil.killCFG(trappingContinuation);
288         GraphUtil.tryKillUnused(isNullNode);
289     }
290 }
    </pre>
  </body>
</html>
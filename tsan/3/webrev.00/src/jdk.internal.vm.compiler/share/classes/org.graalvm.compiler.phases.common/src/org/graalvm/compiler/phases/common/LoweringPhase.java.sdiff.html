<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/LoweringPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IterativeConditionalEliminationPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeCounterPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/LoweringPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptEliminateGuards;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
 29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
 30 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_ENTER;
 31 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_ENTER_ALWAYS_REACHED;
 32 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_LEAVE;
 33 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_PROCESS;
 34 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_PROCESS_ALWAYS_REACHED;
 35 
 36 import java.util.ArrayList;
 37 import java.util.Collection;
 38 import java.util.List;
 39 
 40 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;

 41 import org.graalvm.compiler.core.common.type.StampFactory;
 42 import org.graalvm.compiler.debug.DebugCloseable;
 43 import org.graalvm.compiler.debug.GraalError;
 44 import org.graalvm.compiler.graph.Graph.Mark;
 45 import org.graalvm.compiler.graph.Node;
 46 import org.graalvm.compiler.graph.NodeBitMap;
 47 import org.graalvm.compiler.graph.NodeClass;

 48 import org.graalvm.compiler.graph.NodeSourcePosition;
 49 import org.graalvm.compiler.graph.iterators.NodeIterable;
 50 import org.graalvm.compiler.nodeinfo.InputType;
 51 import org.graalvm.compiler.nodeinfo.NodeInfo;
 52 import org.graalvm.compiler.nodes.AbstractBeginNode;
 53 import org.graalvm.compiler.nodes.BeginNode;
 54 import org.graalvm.compiler.nodes.ControlSinkNode;
 55 import org.graalvm.compiler.nodes.FixedGuardNode;
 56 import org.graalvm.compiler.nodes.FixedNode;
 57 import org.graalvm.compiler.nodes.FixedWithNextNode;
 58 import org.graalvm.compiler.nodes.GuardNode;
 59 import org.graalvm.compiler.nodes.LogicNode;
 60 import org.graalvm.compiler.nodes.PhiNode;
 61 import org.graalvm.compiler.nodes.ProxyNode;
 62 import org.graalvm.compiler.nodes.StructuredGraph;
 63 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 64 import org.graalvm.compiler.nodes.ValueNode;
 65 import org.graalvm.compiler.nodes.calc.FloatingNode;
 66 import org.graalvm.compiler.nodes.cfg.Block;
 67 import org.graalvm.compiler.nodes.extended.AnchoringNode;
 68 import org.graalvm.compiler.nodes.extended.GuardedNode;
 69 import org.graalvm.compiler.nodes.extended.GuardingNode;
 70 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;

 71 import org.graalvm.compiler.nodes.spi.Lowerable;
 72 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 73 import org.graalvm.compiler.nodes.spi.LoweringTool;
 74 import org.graalvm.compiler.nodes.spi.Replacements;
 75 import org.graalvm.compiler.nodes.spi.StampProvider;
 76 import org.graalvm.compiler.options.OptionValues;
 77 import org.graalvm.compiler.phases.BasePhase;
 78 import org.graalvm.compiler.phases.Phase;
 79 import org.graalvm.compiler.phases.schedule.SchedulePhase;
<span class="line-removed"> 80 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 81 import jdk.internal.vm.compiler.word.LocationIdentity;
 82 
 83 import jdk.vm.ci.meta.ConstantReflectionProvider;
 84 import jdk.vm.ci.meta.DeoptimizationAction;
 85 import jdk.vm.ci.meta.DeoptimizationReason;
 86 import jdk.vm.ci.meta.MetaAccessProvider;
 87 import jdk.vm.ci.meta.SpeculationLog;
 88 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 89 
 90 /**
 91  * Processes all {@link Lowerable} nodes to do their lowering.
 92  */
<span class="line-modified"> 93 public class LoweringPhase extends BasePhase&lt;PhaseContext&gt; {</span>
 94 
 95     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 96     static final class DummyGuardHandle extends ValueNode implements GuardedNode {
 97         public static final NodeClass&lt;DummyGuardHandle&gt; TYPE = NodeClass.create(DummyGuardHandle.class);
 98         @Input(InputType.Guard) GuardingNode guard;
 99 
100         protected DummyGuardHandle(GuardingNode guard) {
101             super(TYPE, StampFactory.forVoid());
102             this.guard = guard;
103         }
104 
105         @Override
106         public GuardingNode getGuard() {
107             return guard;
108         }
109 
110         @Override
111         public void setGuard(GuardingNode guard) {
112             updateUsagesInterface(this.guard, guard);
113             this.guard = guard;
114         }
115 
116         @Override
117         public ValueNode asNode() {
118             return this;
119         }
120     }
121 
122     @Override
123     public boolean checkContract() {
124         return false;
125     }
126 
127     final class LoweringToolImpl implements LoweringTool {
128 
<span class="line-modified">129         private final PhaseContext context;</span>
130         private final NodeBitMap activeGuards;
131         private AnchoringNode guardAnchor;
132         private FixedWithNextNode lastFixedNode;

133 
<span class="line-modified">134         LoweringToolImpl(PhaseContext context, AnchoringNode guardAnchor, NodeBitMap activeGuards, FixedWithNextNode lastFixedNode) {</span>
135             this.context = context;
136             this.guardAnchor = guardAnchor;
137             this.activeGuards = activeGuards;
138             this.lastFixedNode = lastFixedNode;

139         }
140 
141         @Override
142         public LoweringStage getLoweringStage() {
143             return loweringStage;
144         }
145 





146         @Override
147         public ConstantReflectionProvider getConstantReflection() {
148             return context.getConstantReflection();
149         }
150 
151         @Override
152         public ConstantFieldProvider getConstantFieldProvider() {
153             return context.getConstantFieldProvider();
154         }
155 
156         @Override
157         public MetaAccessProvider getMetaAccess() {
158             return context.getMetaAccess();
159         }
160 
161         @Override
162         public LoweringProvider getLowerer() {
163             return context.getLowerer();
164         }
165 
166         @Override
167         public Replacements getReplacements() {
168             return context.getReplacements();
169         }
170 




171         @Override
172         public AnchoringNode getCurrentGuardAnchor() {
173             return guardAnchor;
174         }
175 
176         @Override
177         public GuardingNode createGuard(FixedNode before, LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action) {
178             return createGuard(before, condition, deoptReason, action, SpeculationLog.NO_SPECULATION, false, null);
179         }
180 
181         @Override
182         public StampProvider getStampProvider() {
183             return context.getStampProvider();
184         }
185 
186         @Override
187         public GuardingNode createGuard(FixedNode before, LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, Speculation speculation, boolean negated,
188                         NodeSourcePosition noDeoptSucccessorPosition) {
189             StructuredGraph graph = before.graph();
190             if (OptEliminateGuards.getValue(graph.getOptions())) {
191                 for (Node usage : condition.usages()) {
<span class="line-modified">192                     if (!activeGuards.isNew(usage) &amp;&amp; activeGuards.isMarked(usage) &amp;&amp; ((GuardNode) usage).isNegated() == negated) {</span>

193                         return (GuardNode) usage;
194                     }
195                 }
196             }
197             if (!condition.graph().getGuardsStage().allowsFloatingGuards()) {
198                 FixedGuardNode fixedGuard = graph.add(new FixedGuardNode(condition, deoptReason, action, speculation, negated, noDeoptSucccessorPosition));
199                 graph.addBeforeFixed(before, fixedGuard);
200                 DummyGuardHandle handle = graph.add(new DummyGuardHandle(fixedGuard));
201                 fixedGuard.lower(this);
202                 GuardingNode result = handle.getGuard();
203                 handle.safeDelete();
204                 return result;
205             } else {
206                 GuardNode newGuard = graph.unique(new GuardNode(condition, guardAnchor, deoptReason, action, negated, speculation, noDeoptSucccessorPosition));
207                 if (OptEliminateGuards.getValue(graph.getOptions())) {
208                     activeGuards.markAndGrow(newGuard);
209                 }
210                 return newGuard;
211             }
212         }
</pre>
<hr />
<pre>
224 
225     private final CanonicalizerPhase canonicalizer;
226     private final LoweringTool.LoweringStage loweringStage;
227 
228     public LoweringPhase(CanonicalizerPhase canonicalizer, LoweringTool.LoweringStage loweringStage) {
229         this.canonicalizer = canonicalizer;
230         this.loweringStage = loweringStage;
231     }
232 
233     @Override
234     protected boolean shouldDumpBeforeAtBasicLevel() {
235         return loweringStage == LoweringTool.StandardLoweringStage.HIGH_TIER;
236     }
237 
238     /**
239      * Checks that second lowering of a given graph did not introduce any new nodes.
240      *
241      * @param graph a graph that was just {@linkplain #lower lowered}
242      * @throws AssertionError if the check fails
243      */
<span class="line-modified">244     private boolean checkPostLowering(StructuredGraph graph, PhaseContext context) {</span>
245         Mark expectedMark = graph.getMark();
246         lower(graph, context, LoweringMode.VERIFY_LOWERING);
247         Mark mark = graph.getMark();
248         assert mark.equals(expectedMark) : graph + &quot;: a second round in the current lowering phase introduced these new nodes: &quot; + graph.getNewNodes(expectedMark).snapshot();
249         return true;
250     }
251 
252     @Override
<span class="line-modified">253     protected void run(final StructuredGraph graph, PhaseContext context) {</span>
254         lower(graph, context, LoweringMode.LOWERING);
255         assert checkPostLowering(graph, context);
256     }
257 
<span class="line-modified">258     private void lower(StructuredGraph graph, PhaseContext context, LoweringMode mode) {</span>
<span class="line-modified">259         IncrementalCanonicalizerPhase&lt;PhaseContext&gt; incrementalCanonicalizer = new IncrementalCanonicalizerPhase&lt;&gt;(canonicalizer);</span>
260         incrementalCanonicalizer.appendPhase(new Round(context, mode, graph.getOptions()));
261         incrementalCanonicalizer.apply(graph, context);
262         assert graph.verify();
263     }
264 
265     /**
266      * Checks that lowering of a given node did not introduce any new {@link Lowerable} nodes that
267      * could be lowered in the current {@link LoweringPhase}. Such nodes must be recursively lowered
268      * as part of lowering {@code node}.
269      *
270      * @param node a node that was just lowered
271      * @param preLoweringMark the graph mark before {@code node} was lowered
272      * @param unscheduledUsages set of {@code node}&#39;s usages that were unscheduled before it was
273      *            lowered
274      * @throws AssertionError if the check fails
275      */
276     private static boolean checkPostNodeLowering(Node node, LoweringToolImpl loweringTool, Mark preLoweringMark, Collection&lt;Node&gt; unscheduledUsages) {
277         StructuredGraph graph = (StructuredGraph) node.graph();
278         Mark postLoweringMark = graph.getMark();
279         NodeIterable&lt;Node&gt; newNodesAfterLowering = graph.getNewNodes(preLoweringMark);
</pre>
<hr />
<pre>
283                     assert !(n instanceof FixedNode) : node.graph() + &quot;: cannot lower floatable node &quot; + node + &quot; as it introduces fixed node(s) but has the following unscheduled usages: &quot; +
284                                     unscheduledUsages;
285                 }
286             }
287         }
288         for (Node n : newNodesAfterLowering) {
289             if (n instanceof Lowerable) {
290                 ((Lowerable) n).lower(loweringTool);
291                 Mark mark = graph.getMark();
292                 assert postLoweringMark.equals(mark) : graph + &quot;: lowering of &quot; + node + &quot; produced lowerable &quot; + n + &quot; that should have been recursively lowered as it introduces these new nodes: &quot; +
293                                 graph.getNewNodes(postLoweringMark).snapshot();
294             }
295             if (graph.isAfterFloatingReadPhase() &amp;&amp; n instanceof MemoryCheckpoint &amp;&amp; !(node instanceof MemoryCheckpoint) &amp;&amp; !(node instanceof ControlSinkNode)) {
296                 /*
297                  * The lowering introduced a MemoryCheckpoint but the current node isn&#39;t a
298                  * checkpoint. This is only OK if the locations involved don&#39;t affect the memory
299                  * graph or if the new kill location doesn&#39;t connect into the existing graph.
300                  */
301                 boolean isAny = false;
302                 if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">303                     isAny = ((MemoryCheckpoint.Single) n).getLocationIdentity().isAny();</span>
304                 } else {
<span class="line-modified">305                     for (LocationIdentity ident : ((MemoryCheckpoint.Multi) n).getLocationIdentities()) {</span>
306                         if (ident.isAny()) {
307                             isAny = true;
308                         }
309                     }
310                 }
311                 if (isAny &amp;&amp; n instanceof FixedWithNextNode) {
312                     /*
313                      * Check if the next kill location leads directly to a ControlSinkNode in the
314                      * new part of the graph. This is a fairly conservative test that could be made
315                      * more general if required.
316                      */
317                     FixedWithNextNode cur = (FixedWithNextNode) n;
318                     while (cur != null &amp;&amp; graph.isNew(preLoweringMark, cur)) {
319                         if (cur.next() instanceof ControlSinkNode) {
320                             isAny = false;
321                             break;
322                         }
323                         if (cur.next() instanceof FixedWithNextNode) {
324                             cur = (FixedWithNextNode) cur.next();
325                         } else {
326                             break;
327                         }
328                     }
329                 }
330                 assert !isAny : node + &quot; &quot; + n;
331             }
332         }
333         return true;
334     }
335 
336     private enum LoweringMode {
337         LOWERING,
338         VERIFY_LOWERING
339     }
340 
341     private final class Round extends Phase {
342 
<span class="line-modified">343         private final PhaseContext context;</span>
344         private final LoweringMode mode;
345         private ScheduleResult schedule;
346         private final SchedulePhase schedulePhase;
347 
<span class="line-modified">348         private Round(PhaseContext context, LoweringMode mode, OptionValues options) {</span>
349             this.context = context;
350             this.mode = mode;
351 
352             /*
353              * In VERIFY_LOWERING, we want to verify whether the lowering itself changes the graph.
354              * Make sure we&#39;re not detecting spurious changes because the SchedulePhase modifies the
355              * graph.
356              */
357             boolean immutableSchedule = mode == LoweringMode.VERIFY_LOWERING;
358 
359             this.schedulePhase = new SchedulePhase(immutableSchedule, options);
360         }
361 
362         @Override
363         protected CharSequence getName() {
364             switch (mode) {
365                 case LOWERING:
366                     return &quot;LoweringRound&quot;;
367                 case VERIFY_LOWERING:
368                     return &quot;VerifyLoweringRound&quot;;
</pre>
<hr />
<pre>
420                 }
421                 return new ProcessFrame(b, activeGuards, newAnchor, this);
422             }
423 
424             @Override
425             public void postprocess() {
426                 if (anchor == block.getBeginNode() &amp;&amp; OptEliminateGuards.getValue(activeGuards.graph().getOptions())) {
427                     for (GuardNode guard : anchor.asNode().usages().filter(GuardNode.class)) {
428                         if (activeGuards.isMarkedAndGrow(guard)) {
429                             activeGuards.clear(guard);
430                         }
431                     }
432                 }
433             }
434 
435         }
436 
437         @SuppressWarnings(&quot;try&quot;)
438         private AnchoringNode process(final Block b, final NodeBitMap activeGuards, final AnchoringNode startAnchor) {
439 
<span class="line-modified">440             final LoweringToolImpl loweringTool = new LoweringToolImpl(context, startAnchor, activeGuards, b.getBeginNode());</span>
441 
442             // Lower the instructions of this block.
443             List&lt;Node&gt; nodes = schedule.nodesFor(b);
444             for (Node node : nodes) {
445 
446                 if (node.isDeleted()) {
447                     // This case can happen when previous lowerings deleted nodes.
448                     continue;
449                 }
450 
451                 // Cache the next node to be able to reconstruct the previous of the next node
452                 // after lowering.
453                 FixedNode nextNode = null;
454                 if (node instanceof FixedWithNextNode) {
455                     nextNode = ((FixedWithNextNode) node).next();
456                 } else {
457                     nextNode = loweringTool.lastFixedNode().next();
458                 }
459 
460                 if (node instanceof Lowerable) {
</pre>
<hr />
<pre>
573             } else if (state == ST_ENTER) {
574                 if (f.dominated != null) {
575                     Block n = f.dominated;
576                     f.dominated = n.getDominatedSibling();
577                     if (n == f.alwaysReachedBlock) {
578                         if (f.dominated != null) {
579                             n = f.dominated;
580                             f.dominated = n.getDominatedSibling();
581                         } else {
582                             n = null;
583                         }
584                     }
585                     if (n == null) {
586                         nextState = ST_LEAVE;
587                     } else {
588                         f = f.enter(n);
589                         assert f.block.getDominator() == f.parent.block;
590                         nextState = ST_PROCESS;
591                     }
592                 } else {
<span class="line-removed">593                     nextState = ST_LEAVE;</span>
<span class="line-removed">594                 }</span>
<span class="line-removed">595             } else if (state == ST_LEAVE) {</span>
<span class="line-removed">596                 f.postprocess();</span>
<span class="line-removed">597                 f = f.parent;</span>
<span class="line-removed">598                 nextState = ST_ENTER;</span>
<span class="line-removed">599             } else {</span>
<span class="line-removed">600                 throw GraalError.shouldNotReachHere();</span>
<span class="line-removed">601             }</span>
<span class="line-removed">602             state = nextState;</span>
<span class="line-removed">603         }</span>
<span class="line-removed">604     }</span>
<span class="line-removed">605 </span>
<span class="line-removed">606     public static void processBlockBounded(final Frame&lt;?&gt; rootFrame) {</span>
<span class="line-removed">607         ProcessBlockState state = ST_PROCESS;</span>
<span class="line-removed">608         Frame&lt;?&gt; f = rootFrame;</span>
<span class="line-removed">609         while (f != null) {</span>
<span class="line-removed">610             ProcessBlockState nextState;</span>
<span class="line-removed">611             if (state == ST_PROCESS || state == ST_PROCESS_ALWAYS_REACHED) {</span>
<span class="line-removed">612                 f.preprocess();</span>
<span class="line-removed">613                 nextState = state == ST_PROCESS_ALWAYS_REACHED ? ST_ENTER : ST_ENTER_ALWAYS_REACHED;</span>
<span class="line-removed">614             } else if (state == ST_ENTER_ALWAYS_REACHED) {</span>
<span class="line-removed">615                 if (f.alwaysReachedBlock != null &amp;&amp; f.alwaysReachedBlock.getDominator() == f.block) {</span>
<span class="line-removed">616                     Frame&lt;?&gt; continueRecur = f.enterAlwaysReached(f.alwaysReachedBlock);</span>
<span class="line-removed">617                     if (continueRecur == null) {</span>
<span class="line-removed">618                         // stop recursion here</span>
<span class="line-removed">619                         f.postprocess();</span>
<span class="line-removed">620                         f = f.parent;</span>
<span class="line-removed">621                         state = ST_ENTER;</span>
<span class="line-removed">622                         continue;</span>
<span class="line-removed">623                     }</span>
<span class="line-removed">624                     f = continueRecur;</span>
<span class="line-removed">625                     nextState = ST_PROCESS;</span>
<span class="line-removed">626                 } else {</span>
<span class="line-removed">627                     nextState = ST_ENTER;</span>
<span class="line-removed">628                 }</span>
<span class="line-removed">629             } else if (state == ST_ENTER) {</span>
<span class="line-removed">630                 if (f.dominated != null) {</span>
<span class="line-removed">631                     Block n = f.dominated;</span>
<span class="line-removed">632                     f.dominated = n.getDominatedSibling();</span>
<span class="line-removed">633                     if (n == f.alwaysReachedBlock) {</span>
<span class="line-removed">634                         if (f.dominated != null) {</span>
<span class="line-removed">635                             n = f.dominated;</span>
<span class="line-removed">636                             f.dominated = n.getDominatedSibling();</span>
<span class="line-removed">637                         } else {</span>
<span class="line-removed">638                             n = null;</span>
<span class="line-removed">639                         }</span>
<span class="line-removed">640                     }</span>
<span class="line-removed">641                     if (n == null) {</span>
<span class="line-removed">642                         nextState = ST_LEAVE;</span>
<span class="line-removed">643                     } else {</span>
<span class="line-removed">644                         Frame&lt;?&gt; continueRecur = f.enter(n);</span>
<span class="line-removed">645                         if (continueRecur == null) {</span>
<span class="line-removed">646                             // stop recursion here</span>
<span class="line-removed">647                             f.postprocess();</span>
<span class="line-removed">648                             f = f.parent;</span>
<span class="line-removed">649                             state = ST_ENTER;</span>
<span class="line-removed">650                             continue;</span>
<span class="line-removed">651                         }</span>
<span class="line-removed">652                         f = continueRecur;</span>
<span class="line-removed">653                         nextState = ST_PROCESS;</span>
<span class="line-removed">654                     }</span>
<span class="line-removed">655                 } else {</span>
656                     nextState = ST_LEAVE;
657                 }
658             } else if (state == ST_LEAVE) {
659                 f.postprocess();
660                 f = f.parent;
661                 nextState = ST_ENTER;
662             } else {
663                 throw GraalError.shouldNotReachHere();
664             }
665             state = nextState;
666         }
667     }
668 
669     public abstract static class Frame&lt;T extends Frame&lt;?&gt;&gt; {
670         protected final Block block;
671         final T parent;
672         Block dominated;
673         final Block alwaysReachedBlock;
674 
675         public Frame(Block block, T parent) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.phases.common;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptEliminateGuards;
 28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
 29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
 30 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_ENTER;
 31 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_ENTER_ALWAYS_REACHED;
 32 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_LEAVE;
 33 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_PROCESS;
 34 import static org.graalvm.compiler.phases.common.LoweringPhase.ProcessBlockState.ST_PROCESS_ALWAYS_REACHED;
 35 
 36 import java.util.ArrayList;
 37 import java.util.Collection;
 38 import java.util.List;
 39 
 40 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
<span class="line-added"> 41 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;</span>
 42 import org.graalvm.compiler.core.common.type.StampFactory;
 43 import org.graalvm.compiler.debug.DebugCloseable;
 44 import org.graalvm.compiler.debug.GraalError;
 45 import org.graalvm.compiler.graph.Graph.Mark;
 46 import org.graalvm.compiler.graph.Node;
 47 import org.graalvm.compiler.graph.NodeBitMap;
 48 import org.graalvm.compiler.graph.NodeClass;
<span class="line-added"> 49 import org.graalvm.compiler.graph.NodeMap;</span>
 50 import org.graalvm.compiler.graph.NodeSourcePosition;
 51 import org.graalvm.compiler.graph.iterators.NodeIterable;
 52 import org.graalvm.compiler.nodeinfo.InputType;
 53 import org.graalvm.compiler.nodeinfo.NodeInfo;
 54 import org.graalvm.compiler.nodes.AbstractBeginNode;
 55 import org.graalvm.compiler.nodes.BeginNode;
 56 import org.graalvm.compiler.nodes.ControlSinkNode;
 57 import org.graalvm.compiler.nodes.FixedGuardNode;
 58 import org.graalvm.compiler.nodes.FixedNode;
 59 import org.graalvm.compiler.nodes.FixedWithNextNode;
 60 import org.graalvm.compiler.nodes.GuardNode;
 61 import org.graalvm.compiler.nodes.LogicNode;
 62 import org.graalvm.compiler.nodes.PhiNode;
 63 import org.graalvm.compiler.nodes.ProxyNode;
 64 import org.graalvm.compiler.nodes.StructuredGraph;
 65 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 66 import org.graalvm.compiler.nodes.ValueNode;
 67 import org.graalvm.compiler.nodes.calc.FloatingNode;
 68 import org.graalvm.compiler.nodes.cfg.Block;
 69 import org.graalvm.compiler.nodes.extended.AnchoringNode;
 70 import org.graalvm.compiler.nodes.extended.GuardedNode;
 71 import org.graalvm.compiler.nodes.extended.GuardingNode;
 72 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;
<span class="line-added"> 73 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 74 import org.graalvm.compiler.nodes.spi.Lowerable;
 75 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 76 import org.graalvm.compiler.nodes.spi.LoweringTool;
 77 import org.graalvm.compiler.nodes.spi.Replacements;
 78 import org.graalvm.compiler.nodes.spi.StampProvider;
 79 import org.graalvm.compiler.options.OptionValues;
 80 import org.graalvm.compiler.phases.BasePhase;
 81 import org.graalvm.compiler.phases.Phase;
 82 import org.graalvm.compiler.phases.schedule.SchedulePhase;

 83 import jdk.internal.vm.compiler.word.LocationIdentity;
 84 
 85 import jdk.vm.ci.meta.ConstantReflectionProvider;
 86 import jdk.vm.ci.meta.DeoptimizationAction;
 87 import jdk.vm.ci.meta.DeoptimizationReason;
 88 import jdk.vm.ci.meta.MetaAccessProvider;
 89 import jdk.vm.ci.meta.SpeculationLog;
 90 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 91 
 92 /**
 93  * Processes all {@link Lowerable} nodes to do their lowering.
 94  */
<span class="line-modified"> 95 public class LoweringPhase extends BasePhase&lt;CoreProviders&gt; {</span>
 96 
 97     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 98     static final class DummyGuardHandle extends ValueNode implements GuardedNode {
 99         public static final NodeClass&lt;DummyGuardHandle&gt; TYPE = NodeClass.create(DummyGuardHandle.class);
100         @Input(InputType.Guard) GuardingNode guard;
101 
102         protected DummyGuardHandle(GuardingNode guard) {
103             super(TYPE, StampFactory.forVoid());
104             this.guard = guard;
105         }
106 
107         @Override
108         public GuardingNode getGuard() {
109             return guard;
110         }
111 
112         @Override
113         public void setGuard(GuardingNode guard) {
114             updateUsagesInterface(this.guard, guard);
115             this.guard = guard;
116         }
117 
118         @Override
119         public ValueNode asNode() {
120             return this;
121         }
122     }
123 
124     @Override
125     public boolean checkContract() {
126         return false;
127     }
128 
129     final class LoweringToolImpl implements LoweringTool {
130 
<span class="line-modified">131         private final CoreProviders context;</span>
132         private final NodeBitMap activeGuards;
133         private AnchoringNode guardAnchor;
134         private FixedWithNextNode lastFixedNode;
<span class="line-added">135         private NodeMap&lt;Block&gt; nodeMap;</span>
136 
<span class="line-modified">137         LoweringToolImpl(CoreProviders context, AnchoringNode guardAnchor, NodeBitMap activeGuards, FixedWithNextNode lastFixedNode, NodeMap&lt;Block&gt; nodeMap) {</span>
138             this.context = context;
139             this.guardAnchor = guardAnchor;
140             this.activeGuards = activeGuards;
141             this.lastFixedNode = lastFixedNode;
<span class="line-added">142             this.nodeMap = nodeMap;</span>
143         }
144 
145         @Override
146         public LoweringStage getLoweringStage() {
147             return loweringStage;
148         }
149 
<span class="line-added">150         @Override</span>
<span class="line-added">151         public CoreProviders getProviders() {</span>
<span class="line-added">152             return context;</span>
<span class="line-added">153         }</span>
<span class="line-added">154 </span>
155         @Override
156         public ConstantReflectionProvider getConstantReflection() {
157             return context.getConstantReflection();
158         }
159 
160         @Override
161         public ConstantFieldProvider getConstantFieldProvider() {
162             return context.getConstantFieldProvider();
163         }
164 
165         @Override
166         public MetaAccessProvider getMetaAccess() {
167             return context.getMetaAccess();
168         }
169 
170         @Override
171         public LoweringProvider getLowerer() {
172             return context.getLowerer();
173         }
174 
175         @Override
176         public Replacements getReplacements() {
177             return context.getReplacements();
178         }
179 
<span class="line-added">180         public ForeignCallsProvider getForeignCalls() {</span>
<span class="line-added">181             return context.getForeignCalls();</span>
<span class="line-added">182         }</span>
<span class="line-added">183 </span>
184         @Override
185         public AnchoringNode getCurrentGuardAnchor() {
186             return guardAnchor;
187         }
188 
189         @Override
190         public GuardingNode createGuard(FixedNode before, LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action) {
191             return createGuard(before, condition, deoptReason, action, SpeculationLog.NO_SPECULATION, false, null);
192         }
193 
194         @Override
195         public StampProvider getStampProvider() {
196             return context.getStampProvider();
197         }
198 
199         @Override
200         public GuardingNode createGuard(FixedNode before, LogicNode condition, DeoptimizationReason deoptReason, DeoptimizationAction action, Speculation speculation, boolean negated,
201                         NodeSourcePosition noDeoptSucccessorPosition) {
202             StructuredGraph graph = before.graph();
203             if (OptEliminateGuards.getValue(graph.getOptions())) {
204                 for (Node usage : condition.usages()) {
<span class="line-modified">205                     if (!activeGuards.isNew(usage) &amp;&amp; activeGuards.isMarked(usage) &amp;&amp; ((GuardNode) usage).isNegated() == negated &amp;&amp;</span>
<span class="line-added">206                                     (!before.graph().hasValueProxies() || nodeMap.get(((GuardNode) usage).getAnchor().asNode()).isInSameOrOuterLoopOf(nodeMap.get(before)))) {</span>
207                         return (GuardNode) usage;
208                     }
209                 }
210             }
211             if (!condition.graph().getGuardsStage().allowsFloatingGuards()) {
212                 FixedGuardNode fixedGuard = graph.add(new FixedGuardNode(condition, deoptReason, action, speculation, negated, noDeoptSucccessorPosition));
213                 graph.addBeforeFixed(before, fixedGuard);
214                 DummyGuardHandle handle = graph.add(new DummyGuardHandle(fixedGuard));
215                 fixedGuard.lower(this);
216                 GuardingNode result = handle.getGuard();
217                 handle.safeDelete();
218                 return result;
219             } else {
220                 GuardNode newGuard = graph.unique(new GuardNode(condition, guardAnchor, deoptReason, action, negated, speculation, noDeoptSucccessorPosition));
221                 if (OptEliminateGuards.getValue(graph.getOptions())) {
222                     activeGuards.markAndGrow(newGuard);
223                 }
224                 return newGuard;
225             }
226         }
</pre>
<hr />
<pre>
238 
239     private final CanonicalizerPhase canonicalizer;
240     private final LoweringTool.LoweringStage loweringStage;
241 
242     public LoweringPhase(CanonicalizerPhase canonicalizer, LoweringTool.LoweringStage loweringStage) {
243         this.canonicalizer = canonicalizer;
244         this.loweringStage = loweringStage;
245     }
246 
247     @Override
248     protected boolean shouldDumpBeforeAtBasicLevel() {
249         return loweringStage == LoweringTool.StandardLoweringStage.HIGH_TIER;
250     }
251 
252     /**
253      * Checks that second lowering of a given graph did not introduce any new nodes.
254      *
255      * @param graph a graph that was just {@linkplain #lower lowered}
256      * @throws AssertionError if the check fails
257      */
<span class="line-modified">258     private boolean checkPostLowering(StructuredGraph graph, CoreProviders context) {</span>
259         Mark expectedMark = graph.getMark();
260         lower(graph, context, LoweringMode.VERIFY_LOWERING);
261         Mark mark = graph.getMark();
262         assert mark.equals(expectedMark) : graph + &quot;: a second round in the current lowering phase introduced these new nodes: &quot; + graph.getNewNodes(expectedMark).snapshot();
263         return true;
264     }
265 
266     @Override
<span class="line-modified">267     protected void run(final StructuredGraph graph, CoreProviders context) {</span>
268         lower(graph, context, LoweringMode.LOWERING);
269         assert checkPostLowering(graph, context);
270     }
271 
<span class="line-modified">272     private void lower(StructuredGraph graph, CoreProviders context, LoweringMode mode) {</span>
<span class="line-modified">273         IncrementalCanonicalizerPhase&lt;CoreProviders&gt; incrementalCanonicalizer = new IncrementalCanonicalizerPhase&lt;&gt;(canonicalizer);</span>
274         incrementalCanonicalizer.appendPhase(new Round(context, mode, graph.getOptions()));
275         incrementalCanonicalizer.apply(graph, context);
276         assert graph.verify();
277     }
278 
279     /**
280      * Checks that lowering of a given node did not introduce any new {@link Lowerable} nodes that
281      * could be lowered in the current {@link LoweringPhase}. Such nodes must be recursively lowered
282      * as part of lowering {@code node}.
283      *
284      * @param node a node that was just lowered
285      * @param preLoweringMark the graph mark before {@code node} was lowered
286      * @param unscheduledUsages set of {@code node}&#39;s usages that were unscheduled before it was
287      *            lowered
288      * @throws AssertionError if the check fails
289      */
290     private static boolean checkPostNodeLowering(Node node, LoweringToolImpl loweringTool, Mark preLoweringMark, Collection&lt;Node&gt; unscheduledUsages) {
291         StructuredGraph graph = (StructuredGraph) node.graph();
292         Mark postLoweringMark = graph.getMark();
293         NodeIterable&lt;Node&gt; newNodesAfterLowering = graph.getNewNodes(preLoweringMark);
</pre>
<hr />
<pre>
297                     assert !(n instanceof FixedNode) : node.graph() + &quot;: cannot lower floatable node &quot; + node + &quot; as it introduces fixed node(s) but has the following unscheduled usages: &quot; +
298                                     unscheduledUsages;
299                 }
300             }
301         }
302         for (Node n : newNodesAfterLowering) {
303             if (n instanceof Lowerable) {
304                 ((Lowerable) n).lower(loweringTool);
305                 Mark mark = graph.getMark();
306                 assert postLoweringMark.equals(mark) : graph + &quot;: lowering of &quot; + node + &quot; produced lowerable &quot; + n + &quot; that should have been recursively lowered as it introduces these new nodes: &quot; +
307                                 graph.getNewNodes(postLoweringMark).snapshot();
308             }
309             if (graph.isAfterFloatingReadPhase() &amp;&amp; n instanceof MemoryCheckpoint &amp;&amp; !(node instanceof MemoryCheckpoint) &amp;&amp; !(node instanceof ControlSinkNode)) {
310                 /*
311                  * The lowering introduced a MemoryCheckpoint but the current node isn&#39;t a
312                  * checkpoint. This is only OK if the locations involved don&#39;t affect the memory
313                  * graph or if the new kill location doesn&#39;t connect into the existing graph.
314                  */
315                 boolean isAny = false;
316                 if (n instanceof MemoryCheckpoint.Single) {
<span class="line-modified">317                     isAny = ((MemoryCheckpoint.Single) n).getKilledLocationIdentity().isAny();</span>
318                 } else {
<span class="line-modified">319                     for (LocationIdentity ident : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
320                         if (ident.isAny()) {
321                             isAny = true;
322                         }
323                     }
324                 }
325                 if (isAny &amp;&amp; n instanceof FixedWithNextNode) {
326                     /*
327                      * Check if the next kill location leads directly to a ControlSinkNode in the
328                      * new part of the graph. This is a fairly conservative test that could be made
329                      * more general if required.
330                      */
331                     FixedWithNextNode cur = (FixedWithNextNode) n;
332                     while (cur != null &amp;&amp; graph.isNew(preLoweringMark, cur)) {
333                         if (cur.next() instanceof ControlSinkNode) {
334                             isAny = false;
335                             break;
336                         }
337                         if (cur.next() instanceof FixedWithNextNode) {
338                             cur = (FixedWithNextNode) cur.next();
339                         } else {
340                             break;
341                         }
342                     }
343                 }
344                 assert !isAny : node + &quot; &quot; + n;
345             }
346         }
347         return true;
348     }
349 
350     private enum LoweringMode {
351         LOWERING,
352         VERIFY_LOWERING
353     }
354 
355     private final class Round extends Phase {
356 
<span class="line-modified">357         private final CoreProviders context;</span>
358         private final LoweringMode mode;
359         private ScheduleResult schedule;
360         private final SchedulePhase schedulePhase;
361 
<span class="line-modified">362         private Round(CoreProviders context, LoweringMode mode, OptionValues options) {</span>
363             this.context = context;
364             this.mode = mode;
365 
366             /*
367              * In VERIFY_LOWERING, we want to verify whether the lowering itself changes the graph.
368              * Make sure we&#39;re not detecting spurious changes because the SchedulePhase modifies the
369              * graph.
370              */
371             boolean immutableSchedule = mode == LoweringMode.VERIFY_LOWERING;
372 
373             this.schedulePhase = new SchedulePhase(immutableSchedule, options);
374         }
375 
376         @Override
377         protected CharSequence getName() {
378             switch (mode) {
379                 case LOWERING:
380                     return &quot;LoweringRound&quot;;
381                 case VERIFY_LOWERING:
382                     return &quot;VerifyLoweringRound&quot;;
</pre>
<hr />
<pre>
434                 }
435                 return new ProcessFrame(b, activeGuards, newAnchor, this);
436             }
437 
438             @Override
439             public void postprocess() {
440                 if (anchor == block.getBeginNode() &amp;&amp; OptEliminateGuards.getValue(activeGuards.graph().getOptions())) {
441                     for (GuardNode guard : anchor.asNode().usages().filter(GuardNode.class)) {
442                         if (activeGuards.isMarkedAndGrow(guard)) {
443                             activeGuards.clear(guard);
444                         }
445                     }
446                 }
447             }
448 
449         }
450 
451         @SuppressWarnings(&quot;try&quot;)
452         private AnchoringNode process(final Block b, final NodeBitMap activeGuards, final AnchoringNode startAnchor) {
453 
<span class="line-modified">454             final LoweringToolImpl loweringTool = new LoweringToolImpl(context, startAnchor, activeGuards, b.getBeginNode(), this.schedule.getNodeToBlockMap());</span>
455 
456             // Lower the instructions of this block.
457             List&lt;Node&gt; nodes = schedule.nodesFor(b);
458             for (Node node : nodes) {
459 
460                 if (node.isDeleted()) {
461                     // This case can happen when previous lowerings deleted nodes.
462                     continue;
463                 }
464 
465                 // Cache the next node to be able to reconstruct the previous of the next node
466                 // after lowering.
467                 FixedNode nextNode = null;
468                 if (node instanceof FixedWithNextNode) {
469                     nextNode = ((FixedWithNextNode) node).next();
470                 } else {
471                     nextNode = loweringTool.lastFixedNode().next();
472                 }
473 
474                 if (node instanceof Lowerable) {
</pre>
<hr />
<pre>
587             } else if (state == ST_ENTER) {
588                 if (f.dominated != null) {
589                     Block n = f.dominated;
590                     f.dominated = n.getDominatedSibling();
591                     if (n == f.alwaysReachedBlock) {
592                         if (f.dominated != null) {
593                             n = f.dominated;
594                             f.dominated = n.getDominatedSibling();
595                         } else {
596                             n = null;
597                         }
598                     }
599                     if (n == null) {
600                         nextState = ST_LEAVE;
601                     } else {
602                         f = f.enter(n);
603                         assert f.block.getDominator() == f.parent.block;
604                         nextState = ST_PROCESS;
605                     }
606                 } else {































































607                     nextState = ST_LEAVE;
608                 }
609             } else if (state == ST_LEAVE) {
610                 f.postprocess();
611                 f = f.parent;
612                 nextState = ST_ENTER;
613             } else {
614                 throw GraalError.shouldNotReachHere();
615             }
616             state = nextState;
617         }
618     }
619 
620     public abstract static class Frame&lt;T extends Frame&lt;?&gt;&gt; {
621         protected final Block block;
622         final T parent;
623         Block dominated;
624         final Block alwaysReachedBlock;
625 
626         public Frame(Block block, T parent) {
</pre>
</td>
</tr>
</table>
<center><a href="IterativeConditionalEliminationPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeCounterPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
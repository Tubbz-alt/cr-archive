<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ConditionalEliminationPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CanonicalizerPhase.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="DeoptimizationGroupingPhase.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ConditionalEliminationPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,10 +23,13 @@</span>
  
  
  package org.graalvm.compiler.phases.common;
  
  import static org.graalvm.compiler.nodes.StaticDeoptimizingNode.mergeActions;
<span class="udiff-line-added">+ import static org.graalvm.compiler.phases.common.ConditionalEliminationUtil.getOtherSafeStamp;</span>
<span class="udiff-line-added">+ import static org.graalvm.compiler.phases.common.ConditionalEliminationUtil.getSafeStamp;</span>
<span class="udiff-line-added">+ import static org.graalvm.compiler.phases.common.ConditionalEliminationUtil.rewireGuards;</span>
  
  import java.util.ArrayDeque;
  import java.util.Deque;
  import java.util.List;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -54,10 +57,11 @@</span>
  import org.graalvm.compiler.nodeinfo.InputType;
  import org.graalvm.compiler.nodes.AbstractBeginNode;
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.BinaryOpLogicNode;
  import org.graalvm.compiler.nodes.ConditionAnchorNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.DeoptimizeNode;</span>
  import org.graalvm.compiler.nodes.DeoptimizingGuard;
  import org.graalvm.compiler.nodes.EndNode;
  import org.graalvm.compiler.nodes.FixedGuardNode;
  import org.graalvm.compiler.nodes.FixedNode;
  import org.graalvm.compiler.nodes.FixedWithNextNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66,48 +70,49 @@</span>
  import org.graalvm.compiler.nodes.LogicConstantNode;
  import org.graalvm.compiler.nodes.LogicNode;
  import org.graalvm.compiler.nodes.LoopExitNode;
  import org.graalvm.compiler.nodes.MergeNode;
  import org.graalvm.compiler.nodes.NodeView;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.ParameterNode;</span>
  import org.graalvm.compiler.nodes.PiNode;
  import org.graalvm.compiler.nodes.ProxyNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.ShortCircuitOrNode;</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  import org.graalvm.compiler.nodes.UnaryOpLogicNode;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.ValuePhiNode;
  import org.graalvm.compiler.nodes.calc.AndNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;</span>
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.calc.BinaryNode;</span>
  import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.calc.UnaryNode;</span>
  import org.graalvm.compiler.nodes.cfg.Block;
  import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  import org.graalvm.compiler.nodes.extended.GuardingNode;
  import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
  import org.graalvm.compiler.nodes.extended.LoadHubNode;
  import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.java.InstanceOfNode;</span>
  import org.graalvm.compiler.nodes.java.TypeSwitchNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
  import org.graalvm.compiler.nodes.spi.NodeWithState;
  import org.graalvm.compiler.nodes.spi.StampInverter;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.phases.BasePhase;
<span class="udiff-line-added">+ import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.GuardFolding;</span>
<span class="udiff-line-added">+ import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.GuardRewirer;</span>
<span class="udiff-line-added">+ import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.GuardedCondition;</span>
<span class="udiff-line-added">+ import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.InfoElement;</span>
<span class="udiff-line-added">+ import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.InfoElementProvider;</span>
<span class="udiff-line-added">+ import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.InputFilter;</span>
<span class="udiff-line-added">+ import org.graalvm.compiler.phases.common.ConditionalEliminationUtil.Marks;</span>
  import org.graalvm.compiler.phases.schedule.SchedulePhase;
  import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
<span class="udiff-line-removed">- import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
  
  import jdk.vm.ci.meta.DeoptimizationAction;
<span class="udiff-line-removed">- import jdk.vm.ci.meta.JavaConstant;</span>
  import jdk.vm.ci.meta.SpeculationLog.Speculation;
  import jdk.vm.ci.meta.TriState;
  
<span class="udiff-line-modified-removed">- public class ConditionalEliminationPhase extends BasePhase&lt;PhaseContext&gt; {</span>
<span class="udiff-line-modified-added">+ public class ConditionalEliminationPhase extends BasePhase&lt;CoreProviders&gt; {</span>
  
      private static final CounterKey counterStampsRegistered = DebugContext.counter(&quot;StampsRegistered&quot;);
<span class="udiff-line-removed">-     private static final CounterKey counterStampsFound = DebugContext.counter(&quot;StampsFound&quot;);</span>
      private static final CounterKey counterIfsKilled = DebugContext.counter(&quot;CE_KilledIfs&quot;);
      private static final CounterKey counterPhiStampsImproved = DebugContext.counter(&quot;CE_ImprovedPhis&quot;);
      private final boolean fullSchedule;
      private final boolean moveGuards;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120,11 +125,11 @@</span>
          this.moveGuards = moveGuards;
      }
  
      @Override
      @SuppressWarnings(&quot;try&quot;)
<span class="udiff-line-modified-removed">-     protected void run(StructuredGraph graph, PhaseContext context) {</span>
<span class="udiff-line-modified-added">+     protected void run(StructuredGraph graph, CoreProviders context) {</span>
          try (DebugContext.Scope s = graph.getDebug().scope(&quot;DominatorConditionalElimination&quot;)) {
              BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes = null;
              NodeMap&lt;Block&gt; nodeToBlock = null;
              ControlFlowGraph cfg = ControlFlowGraph.compute(graph, true, true, true, true);
              if (fullSchedule) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -151,11 +156,11 @@</span>
      protected BlockMap&lt;List&lt;Node&gt;&gt; getBlockToNodes(@SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg) {
          return null;
      }
  
      protected ControlFlowGraph.RecursiveVisitor&lt;?&gt; createVisitor(StructuredGraph graph, @SuppressWarnings(&quot;unused&quot;) ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes,
<span class="udiff-line-modified-removed">-                     NodeMap&lt;Block&gt; nodeToBlock, PhaseContext context) {</span>
<span class="udiff-line-modified-added">+                     NodeMap&lt;Block&gt; nodeToBlock, CoreProviders context) {</span>
          return new Instance(graph, blockToNodes, nodeToBlock, context);
      }
  
      public static class MoveGuardsUpwards implements ControlFlowGraph.RecursiveVisitor&lt;Block&gt; {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -171,36 +176,33 @@</span>
              }
  
              AbstractBeginNode beginNode = b.getBeginNode();
              if (beginNode instanceof AbstractMergeNode &amp;&amp; anchorBlock != b) {
                  AbstractMergeNode mergeNode = (AbstractMergeNode) beginNode;
<span class="udiff-line-modified-removed">-                 for (GuardNode guard : mergeNode.guards().snapshot()) {</span>
<span class="udiff-line-modified-removed">-                     try (DebugCloseable closeable = guard.withNodeSourcePosition()) {</span>
<span class="udiff-line-modified-removed">-                         GuardNode newlyCreatedGuard = new GuardNode(guard.getCondition(), anchorBlock.getBeginNode(), guard.getReason(), guard.getAction(), guard.isNegated(), guard.getSpeculation(),</span>
<span class="udiff-line-removed">-                                         guard.getNoDeoptSuccessorPosition());</span>
<span class="udiff-line-removed">-                         GuardNode newGuard = mergeNode.graph().unique(newlyCreatedGuard);</span>
<span class="udiff-line-removed">-                         guard.replaceAndDelete(newGuard);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 mergeNode.replaceAtUsages(InputType.Anchor, anchorBlock.getBeginNode());</span>
<span class="udiff-line-modified-added">+                 mergeNode.replaceAtUsages(InputType.Guard, anchorBlock.getBeginNode());</span>
<span class="udiff-line-modified-added">+                 assert mergeNode.anchored().isEmpty();</span>
              }
  
              FixedNode endNode = b.getEndNode();
              if (endNode instanceof IfNode) {
                  IfNode node = (IfNode) endNode;
  
                  // Check if we can move guards upwards.
                  AbstractBeginNode trueSuccessor = node.trueSuccessor();
<span class="udiff-line-added">+                 AbstractBeginNode falseSuccessor = node.falseSuccessor();</span>
<span class="udiff-line-added">+ </span>
                  EconomicMap&lt;LogicNode, GuardNode&gt; trueGuards = EconomicMap.create(Equivalence.IDENTITY);
                  for (GuardNode guard : trueSuccessor.guards()) {
                      LogicNode condition = guard.getCondition();
                      if (condition.hasMoreThanOneUsage()) {
                          trueGuards.put(condition, guard);
                      }
                  }
  
                  if (!trueGuards.isEmpty()) {
<span class="udiff-line-modified-removed">-                     for (GuardNode guard : node.falseSuccessor().guards().snapshot()) {</span>
<span class="udiff-line-modified-added">+                     for (GuardNode guard : falseSuccessor.guards().snapshot()) {</span>
                          GuardNode otherGuard = trueGuards.get(guard.getCondition());
                          if (otherGuard != null &amp;&amp; guard.isNegated() == otherGuard.isNegated()) {
                              Speculation speculation = otherGuard.getSpeculation();
                              if (speculation == null) {
                                  speculation = guard.getSpeculation();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -211,13 +213,21 @@</span>
                              try (DebugCloseable closeable = guard.withNodeSourcePosition()) {
                                  GuardNode newlyCreatedGuard = new GuardNode(guard.getCondition(), anchorBlock.getBeginNode(), guard.getReason(), guard.getAction(), guard.isNegated(), speculation,
                                                  guard.getNoDeoptSuccessorPosition());
                                  GuardNode newGuard = node.graph().unique(newlyCreatedGuard);
                                  if (otherGuard.isAlive()) {
<span class="udiff-line-modified-removed">-                                     otherGuard.replaceAndDelete(newGuard);</span>
<span class="udiff-line-modified-added">+                                     if (trueSuccessor instanceof LoopExitNode &amp;&amp; beginNode.graph().hasValueProxies()) {</span>
<span class="udiff-line-added">+                                         otherGuard.replaceAndDelete(ProxyNode.forGuard(newGuard, (LoopExitNode) trueSuccessor));</span>
<span class="udiff-line-added">+                                     } else {</span>
<span class="udiff-line-added">+                                         otherGuard.replaceAndDelete(newGuard);</span>
<span class="udiff-line-added">+                                     }</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                                 if (falseSuccessor instanceof LoopExitNode &amp;&amp; beginNode.graph().hasValueProxies()) {</span>
<span class="udiff-line-added">+                                     guard.replaceAndDelete(ProxyNode.forGuard(newGuard, (LoopExitNode) falseSuccessor));</span>
<span class="udiff-line-added">+                                 } else {</span>
<span class="udiff-line-added">+                                     guard.replaceAndDelete(newGuard);</span>
                                  }
<span class="udiff-line-removed">-                                 guard.replaceAndDelete(newGuard);</span>
                              }
                          }
                      }
                  }
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -248,77 +258,59 @@</span>
              }
              return infoElements.get(end);
          }
      }
  
<span class="udiff-line-removed">-     public static final class Marks {</span>
<span class="udiff-line-removed">-         final int infoElementOperations;</span>
<span class="udiff-line-removed">-         final int conditions;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public Marks(int infoElementOperations, int conditions) {</span>
<span class="udiff-line-removed">-             this.infoElementOperations = infoElementOperations;</span>
<span class="udiff-line-removed">-             this.conditions = conditions;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     protected static final class GuardedCondition {</span>
<span class="udiff-line-removed">-         private final GuardingNode guard;</span>
<span class="udiff-line-removed">-         private final LogicNode condition;</span>
<span class="udiff-line-removed">-         private final boolean negated;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public GuardedCondition(GuardingNode guard, LogicNode condition, boolean negated) {</span>
<span class="udiff-line-removed">-             this.guard = guard;</span>
<span class="udiff-line-removed">-             this.condition = condition;</span>
<span class="udiff-line-removed">-             this.negated = negated;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public GuardingNode getGuard() {</span>
<span class="udiff-line-removed">-             return guard;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public LogicNode getCondition() {</span>
<span class="udiff-line-removed">-             return condition;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public boolean isNegated() {</span>
<span class="udiff-line-removed">-             return negated;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      public static class Instance implements ControlFlowGraph.RecursiveVisitor&lt;Marks&gt; {
          protected final NodeMap&lt;InfoElement&gt; map;
          protected final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes;
          protected final NodeMap&lt;Block&gt; nodeToBlock;
          protected final CanonicalizerTool tool;
          protected final NodeStack undoOperations;
          protected final StructuredGraph graph;
          protected final DebugContext debug;
          protected final EconomicMap&lt;MergeNode, EconomicMap&lt;ValuePhiNode, PhiInfoElement&gt;&gt; mergeMaps;
<span class="udiff-line-added">+         private final InfoElementProvider infoElementProvider;</span>
<span class="udiff-line-added">+         private final GuardFolding guardFolding;</span>
  
          protected final ArrayDeque&lt;GuardedCondition&gt; conditions;
  
          /**
           * Tests which may be eliminated because post dominating tests to prove a broader condition.
           */
          private Deque&lt;DeoptimizingGuard&gt; pendingTests;
  
<span class="udiff-line-modified-removed">-         public Instance(StructuredGraph graph, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes, NodeMap&lt;Block&gt; nodeToBlock, PhaseContext context) {</span>
<span class="udiff-line-modified-added">+         public Instance(StructuredGraph graph, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes, NodeMap&lt;Block&gt; nodeToBlock, CoreProviders context) {</span>
              this.graph = graph;
              this.debug = graph.getDebug();
              this.blockToNodes = blockToNodes;
              this.nodeToBlock = nodeToBlock;
              this.undoOperations = new NodeStack();
              this.map = graph.createNodeMap();
              this.pendingTests = new ArrayDeque&lt;&gt;();
              this.conditions = new ArrayDeque&lt;&gt;();
              tool = GraphUtil.getDefaultSimplifier(context.getMetaAccess(), context.getConstantReflection(), context.getConstantFieldProvider(), false, graph.getAssumptions(), graph.getOptions(),
                              context.getLowerer());
<span class="udiff-line-modified-removed">-             mergeMaps = EconomicMap.create();</span>
<span class="udiff-line-modified-added">+             mergeMaps = EconomicMap.create(Equivalence.IDENTITY);</span>
<span class="udiff-line-added">+             infoElementProvider = new InfoElementProvider() {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 @Override</span>
<span class="udiff-line-added">+                 public InfoElement infoElements(ValueNode value) {</span>
<span class="udiff-line-added">+                     return getInfoElements(value);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+             guardFolding = new GuardFolding() {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 @Override</span>
<span class="udiff-line-added">+                 public boolean foldGuard(DeoptimizingGuard thisGuard, ValueNode original, Stamp newStamp, GuardRewirer rewireGuardFunction) {</span>
<span class="udiff-line-added">+                     return foldPendingTest(thisGuard, original, newStamp, rewireGuardFunction);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             };</span>
          }
  
          protected void processConditionAnchor(ConditionAnchorNode node) {
<span class="udiff-line-modified-removed">-             tryProveCondition(node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
<span class="udiff-line-modified-added">+             tryProveGuardCondition(null, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
                  if (result != node.isNegated()) {
                      node.replaceAtUsages(guard.asNode());
                      GraphUtil.unlinkFixedNode(node);
                      GraphUtil.killWithUnusedFloatingInputs(node);
                  } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -332,23 +324,30 @@</span>
  
          protected void processGuard(GuardNode node) {
              if (!tryProveGuardCondition(node, node.getCondition(), (guard, result, guardedValueStamp, newInput) -&gt; {
                  if (result != node.isNegated()) {
                      node.replaceAndDelete(guard.asNode());
<span class="udiff-line-added">+                     if (guard instanceof DeoptimizingGuard &amp;&amp; !((DeoptimizingGuard) guard).isNegated()) {</span>
<span class="udiff-line-added">+                         rebuildPiNodes((DeoptimizingGuard) guard);</span>
<span class="udiff-line-added">+                     }</span>
                  } else {
<span class="udiff-line-removed">-                     /*</span>
<span class="udiff-line-removed">-                      * Don&#39;t kill this branch immediately because `killCFG` can have complex</span>
<span class="udiff-line-removed">-                      * implications in the presence of loops: it might replace or delete nodes in</span>
<span class="udiff-line-removed">-                      * other branches or even above the kill point. Instead of killing immediately,</span>
<span class="udiff-line-removed">-                      * just leave the graph in a state that is easy to simplify by a subsequent</span>
<span class="udiff-line-removed">-                      * canonicalizer phase.</span>
<span class="udiff-line-removed">-                      */</span>
<span class="udiff-line-removed">-                     FixedGuardNode deopt = new FixedGuardNode(LogicConstantNode.forBoolean(result, node.graph()), node.getReason(), node.getAction(), node.getSpeculation(), node.isNegated(),</span>
<span class="udiff-line-removed">-                                     node.getNodeSourcePosition());</span>
                      AbstractBeginNode beginNode = (AbstractBeginNode) node.getAnchor();
<span class="udiff-line-removed">-                     graph.addAfterFixed(beginNode, node.graph().add(deopt));</span>
  
<span class="udiff-line-added">+                     if (beginNode.next() instanceof DeoptimizeNode) {</span>
<span class="udiff-line-added">+                         // This branch is already dead.</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         /*</span>
<span class="udiff-line-added">+                          * Don&#39;t kill this branch immediately because `killCFG` can have complex</span>
<span class="udiff-line-added">+                          * implications in the presence of loops: it might replace or delete nodes</span>
<span class="udiff-line-added">+                          * in other branches or even above the kill point. Instead of killing</span>
<span class="udiff-line-added">+                          * immediately, just leave the graph in a state that is easy to simplify by</span>
<span class="udiff-line-added">+                          * a subsequent canonicalizer phase.</span>
<span class="udiff-line-added">+                          */</span>
<span class="udiff-line-added">+                         FixedGuardNode deopt = new FixedGuardNode(LogicConstantNode.forBoolean(result, node.graph()), node.getReason(), node.getAction(), node.getSpeculation(), node.isNegated(),</span>
<span class="udiff-line-added">+                                         node.getNodeSourcePosition());</span>
<span class="udiff-line-added">+                         graph.addAfterFixed(beginNode, node.graph().add(deopt));</span>
<span class="udiff-line-added">+                     }</span>
                  }
                  return true;
              })) {
                  registerNewCondition(node.getCondition(), node.isNegated(), node);
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -358,23 +357,80 @@</span>
              if (!tryProveGuardCondition(node, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {
                  if (result != node.isNegated()) {
                      node.replaceAtUsages(guard.asNode());
                      GraphUtil.unlinkFixedNode(node);
                      GraphUtil.killWithUnusedFloatingInputs(node);
<span class="udiff-line-added">+                     if (guard instanceof DeoptimizingGuard &amp;&amp; !((DeoptimizingGuard) guard).isNegated()) {</span>
<span class="udiff-line-added">+                         rebuildPiNodes((DeoptimizingGuard) guard);</span>
<span class="udiff-line-added">+                     }</span>
                  } else {
                      node.setCondition(LogicConstantNode.forBoolean(result, node.graph()), node.isNegated());
                      // Don&#39;t kill this branch immediately, see `processGuard`.
                  }
<span class="udiff-line-modified-removed">-                 debug.log(&quot;Kill fixed guard guard&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+                 debug.log(&quot;Kill fixed guard %s&quot;, node);</span>
                  return true;
              })) {
                  registerNewCondition(node.condition(), node.isNegated(), node);
              }
          }
  
<span class="udiff-line-added">+         private void rebuildPiNodes(DeoptimizingGuard guard) {</span>
<span class="udiff-line-added">+             LogicNode newCondition = guard.getCondition();</span>
<span class="udiff-line-added">+             if (newCondition instanceof InstanceOfNode) {</span>
<span class="udiff-line-added">+                 InstanceOfNode inst = (InstanceOfNode) newCondition;</span>
<span class="udiff-line-added">+                 ValueNode originalValue = GraphUtil.skipPi(inst.getValue());</span>
<span class="udiff-line-added">+                 PiNode pi = null;</span>
<span class="udiff-line-added">+                 // Ensure that any Pi that&#39;s weaker than what the instanceof proves is</span>
<span class="udiff-line-added">+                 // replaced by one derived from the instanceof itself.</span>
<span class="udiff-line-added">+                 for (PiNode existing : guard.asNode().usages().filter(PiNode.class).snapshot()) {</span>
<span class="udiff-line-added">+                     if (!existing.isAlive()) {</span>
<span class="udiff-line-added">+                         continue;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     if (originalValue != GraphUtil.skipPi(existing.object())) {</span>
<span class="udiff-line-added">+                         // Somehow these are unrelated values so leave it alone</span>
<span class="udiff-line-added">+                         continue;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     // If the pi has a weaker stamp or the same stamp but a different input</span>
<span class="udiff-line-added">+                     // then replace it.</span>
<span class="udiff-line-added">+                     boolean strongerStamp = !existing.piStamp().join(inst.getCheckedStamp()).equals(inst.getCheckedStamp());</span>
<span class="udiff-line-added">+                     boolean differentCheckedStamp = !existing.piStamp().equals(inst.getCheckedStamp());</span>
<span class="udiff-line-added">+                     boolean differentObject = existing.object() != inst.getValue();</span>
<span class="udiff-line-added">+                     if (!strongerStamp &amp;&amp; (differentCheckedStamp || differentObject)) {</span>
<span class="udiff-line-added">+                         if (pi == null) {</span>
<span class="udiff-line-added">+                             pi = graph.unique(new PiNode(inst.getValue(), inst.getCheckedStamp(), (ValueNode) guard));</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         if (!pi.stamp(NodeView.DEFAULT).join(existing.stamp(NodeView.DEFAULT)).equals(pi.stamp(NodeView.DEFAULT))) {</span>
<span class="udiff-line-added">+                             /*</span>
<span class="udiff-line-added">+                              * With a code sequence like null check, type check, null check of type</span>
<span class="udiff-line-added">+                              * checked value, CE will use the first null check to prove the second</span>
<span class="udiff-line-added">+                              * null check so the graph ends up a Pi guarded by the first null check</span>
<span class="udiff-line-added">+                              * but consuming the output Pi from the type check check. In this case</span>
<span class="udiff-line-added">+                              * we should still canonicalize the checked stamp for consistency.</span>
<span class="udiff-line-added">+                              */</span>
<span class="udiff-line-added">+                             if (differentCheckedStamp) {</span>
<span class="udiff-line-added">+                                 PiNode alternatePi = graph.unique(new PiNode(existing.object(), inst.getCheckedStamp(), (ValueNode) guard));</span>
<span class="udiff-line-added">+                                 /*</span>
<span class="udiff-line-added">+                                  * If the resulting stamp is as good or better then do the</span>
<span class="udiff-line-added">+                                  * replacement. However when interface types are involved it&#39;s</span>
<span class="udiff-line-added">+                                  * possible that improving the checked stamp merges types which</span>
<span class="udiff-line-added">+                                  * appear unrelated so there&#39;s we must skip the replacement.</span>
<span class="udiff-line-added">+                                  */</span>
<span class="udiff-line-added">+                                 if (alternatePi.stamp(NodeView.DEFAULT).join(existing.stamp(NodeView.DEFAULT)).equals(alternatePi.stamp(NodeView.DEFAULT))) {</span>
<span class="udiff-line-added">+                                     existing.replaceAndDelete(alternatePi);</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             continue;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         existing.replaceAndDelete(pi);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          protected void processIf(IfNode node) {
<span class="udiff-line-modified-removed">-             tryProveCondition(node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
<span class="udiff-line-modified-added">+             tryProveGuardCondition(null, node.condition(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
                  node.setCondition(LogicConstantNode.forBoolean(result, node.graph()));
                  AbstractBeginNode survivingSuccessor = node.getSuccessor(result);
                  survivingSuccessor.replaceAtUsages(InputType.Guard, guard.asNode());
                  // Don&#39;t kill the other branch immediately, see `processGuard`.
                  counterIfsKilled.increment(debug);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -509,10 +565,12 @@</span>
                                  allow = true;
                              } else if (oldStamp.isUnrestricted()) {
                                  allow = true;
                              }
                          } else {
<span class="udiff-line-added">+                             // Fortify: Suppress Null Dereference false positive</span>
<span class="udiff-line-added">+                             assert bestPossibleStamp != null;</span>
                              allow = (bestPossibleStamp.asConstant() != null);
                          }
  
                          if (allow) {
                              ValuePhiNode newPhi = graph.addWithoutUnique(new ValuePhiNode(bestPossibleStamp, merge));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -526,11 +584,11 @@</span>
                                      Stamp curBestStamp = infoElement.getStamp();
                                      ValueNode input = infoElement.getProxifiedInput();
                                      if (input == null) {
                                          input = valueAt;
                                      }
<span class="udiff-line-modified-removed">-                                     valueAt = graph.maybeAddOrUnique(PiNode.create(input, curBestStamp, (ValueNode) infoElement.guard));</span>
<span class="udiff-line-modified-added">+                                     valueAt = graph.maybeAddOrUnique(PiNode.create(input, curBestStamp, (ValueNode) infoElement.getGuard()));</span>
                                  }
                                  newPhi.addInput(valueAt);
                              }
                              counterPhiStampsImproved.increment(debug);
                              phi.replaceAtUsagesAndDelete(newPhi);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -551,11 +609,11 @@</span>
                      InfoElement infoElement = this.getInfoElements(valueAt);
                      while (infoElement != null) {
                          Stamp newStamp = infoElement.getStamp();
                          if (phi.stamp(NodeView.DEFAULT).tryImproveWith(newStamp) != null) {
                              if (mergeMap == null) {
<span class="udiff-line-modified-removed">-                                 mergeMap = EconomicMap.create();</span>
<span class="udiff-line-modified-added">+                                 mergeMap = EconomicMap.create(Equivalence.IDENTITY);</span>
                                  mergeMaps.put(merge, mergeMap);
                              }
  
                              PhiInfoElement phiInfoElement = mergeMap.get(phi);
                              if (phiInfoElement == null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -618,75 +676,21 @@</span>
                  pendingTests.push((DeoptimizingGuard) guard);
              }
              registerCondition(condition, negated, guard);
          }
  
<span class="udiff-line-removed">-         Pair&lt;InfoElement, Stamp&gt; recursiveFoldStamp(Node node) {</span>
<span class="udiff-line-removed">-             if (node instanceof UnaryNode) {</span>
<span class="udiff-line-removed">-                 UnaryNode unary = (UnaryNode) node;</span>
<span class="udiff-line-removed">-                 ValueNode value = unary.getValue();</span>
<span class="udiff-line-removed">-                 InfoElement infoElement = getInfoElements(value);</span>
<span class="udiff-line-removed">-                 while (infoElement != null) {</span>
<span class="udiff-line-removed">-                     Stamp result = unary.foldStamp(infoElement.getStamp());</span>
<span class="udiff-line-removed">-                     if (result != null) {</span>
<span class="udiff-line-removed">-                         return Pair.create(infoElement, result);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     infoElement = nextElement(infoElement);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else if (node instanceof BinaryNode) {</span>
<span class="udiff-line-removed">-                 BinaryNode binary = (BinaryNode) node;</span>
<span class="udiff-line-removed">-                 ValueNode y = binary.getY();</span>
<span class="udiff-line-removed">-                 ValueNode x = binary.getX();</span>
<span class="udiff-line-removed">-                 if (y.isConstant()) {</span>
<span class="udiff-line-removed">-                     InfoElement infoElement = getInfoElements(x);</span>
<span class="udiff-line-removed">-                     while (infoElement != null) {</span>
<span class="udiff-line-removed">-                         Stamp result = binary.foldStamp(infoElement.stamp, y.stamp(NodeView.DEFAULT));</span>
<span class="udiff-line-removed">-                         if (result != null) {</span>
<span class="udiff-line-removed">-                             return Pair.create(infoElement, result);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         infoElement = nextElement(infoElement);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return null;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Get the stamp that may be used for the value for which we are registering the condition.</span>
<span class="udiff-line-removed">-          * We may directly use the stamp here without restriction, because any later lookup of the</span>
<span class="udiff-line-removed">-          * registered info elements is in the same chain of pi nodes.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private static Stamp getSafeStamp(ValueNode x) {</span>
<span class="udiff-line-removed">-             return x.stamp(NodeView.DEFAULT);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * We can only use the stamp of a second value involved in the condition if we are sure that</span>
<span class="udiff-line-removed">-          * we are not implicitly creating a dependency on a pi node that is responsible for that</span>
<span class="udiff-line-removed">-          * stamp. For now, we are conservatively only using the stamps of constants. Under certain</span>
<span class="udiff-line-removed">-          * circumstances, we may also be able to use the stamp of the value after skipping pi nodes</span>
<span class="udiff-line-removed">-          * (e.g., the stamp of a parameter after inlining, or the stamp of a fixed node that can</span>
<span class="udiff-line-removed">-          * never be replaced with a pi node via canonicalization).</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private static Stamp getOtherSafeStamp(ValueNode x) {</span>
<span class="udiff-line-removed">-             if (x.isConstant() || x.graph().isAfterFixedReadPhase()) {</span>
<span class="udiff-line-removed">-                 return x.stamp(NodeView.DEFAULT);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return x.stamp(NodeView.DEFAULT).unrestricted();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          /**
           * Recursively try to fold stamps within this expression using information from
           * {@link #getInfoElements(ValueNode)}. It&#39;s only safe to use constants and one
           * {@link InfoElement} otherwise more than one guard would be required.
           *
           * @param node
           * @return the pair of the @{link InfoElement} used and the stamp produced for the whole
           *         expression
           */
          Pair&lt;InfoElement, Stamp&gt; recursiveFoldStampFromInfo(Node node) {
<span class="udiff-line-modified-removed">-             return recursiveFoldStamp(node);</span>
<span class="udiff-line-modified-added">+             return ConditionalEliminationUtil.recursiveFoldStamp(infoElementProvider, node);</span>
          }
  
          /**
           * Look for a preceding guard whose condition is implied by {@code thisGuard}. If we find
           * one, try to move this guard just above that preceding guard so that we can fold it:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -798,10 +802,14 @@</span>
                  return rewireGuards(otherGuard, outcome, null, guardedValueStamp, rewirer);
              }
              return false;
          }
  
<span class="udiff-line-added">+         protected boolean tryProveGuardCondition(DeoptimizingGuard thisGuard, LogicNode node, GuardRewirer rewireGuardFunction) {</span>
<span class="udiff-line-added">+             return ConditionalEliminationUtil.tryProveGuardCondition(infoElementProvider, conditions, guardFolding, thisGuard, node, rewireGuardFunction);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          protected void registerCondition(LogicNode condition, boolean negated, GuardingNode guard) {
              if (condition.hasMoreThanOneUsage()) {
                  registerNewStamp(condition, negated ? StampFactory.contradiction() : StampFactory.tautology(), guard);
              }
              conditions.push(new GuardedCondition(guard, condition, negated));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -816,19 +824,10 @@</span>
                  infoElement = map.getAndGrow(GraphUtil.skipPi(proxiedValue));
              }
              return infoElement;
          }
  
<span class="udiff-line-removed">-         protected boolean rewireGuards(GuardingNode guard, boolean result, ValueNode proxifiedInput, Stamp guardedValueStamp, GuardRewirer rewireGuardFunction) {</span>
<span class="udiff-line-removed">-             counterStampsFound.increment(debug);</span>
<span class="udiff-line-removed">-             return rewireGuardFunction.rewire(guard, result, guardedValueStamp, proxifiedInput);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         protected boolean tryProveCondition(LogicNode node, GuardRewirer rewireGuardFunction) {</span>
<span class="udiff-line-removed">-             return tryProveGuardCondition(null, node, rewireGuardFunction);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          private InfoElement nextElement(InfoElement current) {
              InfoElement parent = current.getParent();
              if (parent != null) {
                  return parent;
              } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -839,170 +838,10 @@</span>
                  }
              }
              return null;
          }
  
<span class="udiff-line-removed">-         protected boolean tryProveGuardCondition(DeoptimizingGuard thisGuard, LogicNode node, GuardRewirer rewireGuardFunction) {</span>
<span class="udiff-line-removed">-             InfoElement infoElement = getInfoElements(node);</span>
<span class="udiff-line-removed">-             while (infoElement != null) {</span>
<span class="udiff-line-removed">-                 Stamp stamp = infoElement.getStamp();</span>
<span class="udiff-line-removed">-                 JavaConstant constant = (JavaConstant) stamp.asConstant();</span>
<span class="udiff-line-removed">-                 if (constant != null) {</span>
<span class="udiff-line-removed">-                     // No proxified input and stamp required.</span>
<span class="udiff-line-removed">-                     return rewireGuards(infoElement.getGuard(), constant.asBoolean(), null, null, rewireGuardFunction);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 infoElement = nextElement(infoElement);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             for (GuardedCondition guardedCondition : this.conditions) {</span>
<span class="udiff-line-removed">-                 TriState result = guardedCondition.getCondition().implies(guardedCondition.isNegated(), node);</span>
<span class="udiff-line-removed">-                 if (result.isKnown()) {</span>
<span class="udiff-line-removed">-                     return rewireGuards(guardedCondition.guard, result.toBoolean(), null, null, rewireGuardFunction);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (node instanceof UnaryOpLogicNode) {</span>
<span class="udiff-line-removed">-                 UnaryOpLogicNode unaryLogicNode = (UnaryOpLogicNode) node;</span>
<span class="udiff-line-removed">-                 ValueNode value = unaryLogicNode.getValue();</span>
<span class="udiff-line-removed">-                 infoElement = getInfoElements(value);</span>
<span class="udiff-line-removed">-                 while (infoElement != null) {</span>
<span class="udiff-line-removed">-                     Stamp stamp = infoElement.getStamp();</span>
<span class="udiff-line-removed">-                     TriState result = unaryLogicNode.tryFold(stamp);</span>
<span class="udiff-line-removed">-                     if (result.isKnown()) {</span>
<span class="udiff-line-removed">-                         return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     infoElement = nextElement(infoElement);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 Pair&lt;InfoElement, Stamp&gt; foldResult = recursiveFoldStampFromInfo(value);</span>
<span class="udiff-line-removed">-                 if (foldResult != null) {</span>
<span class="udiff-line-removed">-                     TriState result = unaryLogicNode.tryFold(foldResult.getRight());</span>
<span class="udiff-line-removed">-                     if (result.isKnown()) {</span>
<span class="udiff-line-removed">-                         return rewireGuards(foldResult.getLeft().getGuard(), result.toBoolean(), foldResult.getLeft().getProxifiedInput(), foldResult.getRight(), rewireGuardFunction);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (thisGuard != null) {</span>
<span class="udiff-line-removed">-                     Stamp newStamp = unaryLogicNode.getSucceedingStampForValue(thisGuard.isNegated());</span>
<span class="udiff-line-removed">-                     if (newStamp != null &amp;&amp; foldPendingTest(thisGuard, value, newStamp, rewireGuardFunction)) {</span>
<span class="udiff-line-removed">-                         return true;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else if (node instanceof BinaryOpLogicNode) {</span>
<span class="udiff-line-removed">-                 BinaryOpLogicNode binaryOpLogicNode = (BinaryOpLogicNode) node;</span>
<span class="udiff-line-removed">-                 ValueNode x = binaryOpLogicNode.getX();</span>
<span class="udiff-line-removed">-                 ValueNode y = binaryOpLogicNode.getY();</span>
<span class="udiff-line-removed">-                 infoElement = getInfoElements(x);</span>
<span class="udiff-line-removed">-                 while (infoElement != null) {</span>
<span class="udiff-line-removed">-                     TriState result = binaryOpLogicNode.tryFold(infoElement.getStamp(), y.stamp(NodeView.DEFAULT));</span>
<span class="udiff-line-removed">-                     if (result.isKnown()) {</span>
<span class="udiff-line-removed">-                         return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     infoElement = nextElement(infoElement);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 if (y.isConstant()) {</span>
<span class="udiff-line-removed">-                     Pair&lt;InfoElement, Stamp&gt; foldResult = recursiveFoldStampFromInfo(x);</span>
<span class="udiff-line-removed">-                     if (foldResult != null) {</span>
<span class="udiff-line-removed">-                         TriState result = binaryOpLogicNode.tryFold(foldResult.getRight(), y.stamp(NodeView.DEFAULT));</span>
<span class="udiff-line-removed">-                         if (result.isKnown()) {</span>
<span class="udiff-line-removed">-                             return rewireGuards(foldResult.getLeft().getGuard(), result.toBoolean(), foldResult.getLeft().getProxifiedInput(), foldResult.getRight(), rewireGuardFunction);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     infoElement = getInfoElements(y);</span>
<span class="udiff-line-removed">-                     while (infoElement != null) {</span>
<span class="udiff-line-removed">-                         TriState result = binaryOpLogicNode.tryFold(x.stamp(NodeView.DEFAULT), infoElement.getStamp());</span>
<span class="udiff-line-removed">-                         if (result.isKnown()) {</span>
<span class="udiff-line-removed">-                             return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), infoElement.getStamp(), rewireGuardFunction);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                         infoElement = nextElement(infoElement);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 /*</span>
<span class="udiff-line-removed">-                  * For complex expressions involving constants, see if it&#39;s possible to fold the</span>
<span class="udiff-line-removed">-                  * tests by using stamps one level up in the expression. For instance, (x + n &lt; y)</span>
<span class="udiff-line-removed">-                  * might fold if something is known about x and all other values are constants. The</span>
<span class="udiff-line-removed">-                  * reason for the constant restriction is that if more than 1 real value is involved</span>
<span class="udiff-line-removed">-                  * the code might need to adopt multiple guards to have proper dependences.</span>
<span class="udiff-line-removed">-                  */</span>
<span class="udiff-line-removed">-                 if (x instanceof BinaryArithmeticNode&lt;?&gt; &amp;&amp; y.isConstant()) {</span>
<span class="udiff-line-removed">-                     BinaryArithmeticNode&lt;?&gt; binary = (BinaryArithmeticNode&lt;?&gt;) x;</span>
<span class="udiff-line-removed">-                     if (binary.getY().isConstant()) {</span>
<span class="udiff-line-removed">-                         infoElement = getInfoElements(binary.getX());</span>
<span class="udiff-line-removed">-                         while (infoElement != null) {</span>
<span class="udiff-line-removed">-                             Stamp newStampX = binary.foldStamp(infoElement.getStamp(), binary.getY().stamp(NodeView.DEFAULT));</span>
<span class="udiff-line-removed">-                             TriState result = binaryOpLogicNode.tryFold(newStampX, y.stamp(NodeView.DEFAULT));</span>
<span class="udiff-line-removed">-                             if (result.isKnown()) {</span>
<span class="udiff-line-removed">-                                 return rewireGuards(infoElement.getGuard(), result.toBoolean(), infoElement.getProxifiedInput(), newStampX, rewireGuardFunction);</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                             infoElement = nextElement(infoElement);</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 if (thisGuard != null &amp;&amp; binaryOpLogicNode instanceof IntegerEqualsNode &amp;&amp; !thisGuard.isNegated()) {</span>
<span class="udiff-line-removed">-                     if (y.isConstant() &amp;&amp; x instanceof AndNode) {</span>
<span class="udiff-line-removed">-                         AndNode and = (AndNode) x;</span>
<span class="udiff-line-removed">-                         if (and.getY() == y) {</span>
<span class="udiff-line-removed">-                             /*</span>
<span class="udiff-line-removed">-                              * This &#39;and&#39; proves something about some of the bits in and.getX().</span>
<span class="udiff-line-removed">-                              * It&#39;s equivalent to or&#39;ing in the mask value since those values are</span>
<span class="udiff-line-removed">-                              * known to be set.</span>
<span class="udiff-line-removed">-                              */</span>
<span class="udiff-line-removed">-                             BinaryOp&lt;Or&gt; op = ArithmeticOpTable.forStamp(x.stamp(NodeView.DEFAULT)).getOr();</span>
<span class="udiff-line-removed">-                             IntegerStamp newStampX = (IntegerStamp) op.foldStamp(getSafeStamp(and.getX()), getOtherSafeStamp(y));</span>
<span class="udiff-line-removed">-                             if (foldPendingTest(thisGuard, and.getX(), newStampX, rewireGuardFunction)) {</span>
<span class="udiff-line-removed">-                                 return true;</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 if (thisGuard != null) {</span>
<span class="udiff-line-removed">-                     if (!x.isConstant()) {</span>
<span class="udiff-line-removed">-                         Stamp newStampX = binaryOpLogicNode.getSucceedingStampForX(thisGuard.isNegated(), getSafeStamp(x), getOtherSafeStamp(y));</span>
<span class="udiff-line-removed">-                         if (newStampX != null &amp;&amp; foldPendingTest(thisGuard, x, newStampX, rewireGuardFunction)) {</span>
<span class="udiff-line-removed">-                             return true;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     if (!y.isConstant()) {</span>
<span class="udiff-line-removed">-                         Stamp newStampY = binaryOpLogicNode.getSucceedingStampForY(thisGuard.isNegated(), getOtherSafeStamp(x), getSafeStamp(y));</span>
<span class="udiff-line-removed">-                         if (newStampY != null &amp;&amp; foldPendingTest(thisGuard, y, newStampY, rewireGuardFunction)) {</span>
<span class="udiff-line-removed">-                             return true;</span>
<span class="udiff-line-removed">-                         }</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-             } else if (node instanceof ShortCircuitOrNode) {</span>
<span class="udiff-line-removed">-                 final ShortCircuitOrNode shortCircuitOrNode = (ShortCircuitOrNode) node;</span>
<span class="udiff-line-removed">-                 return tryProveCondition(shortCircuitOrNode.getX(), (guard, result, guardedValueStamp, newInput) -&gt; {</span>
<span class="udiff-line-removed">-                     if (result == !shortCircuitOrNode.isXNegated()) {</span>
<span class="udiff-line-removed">-                         return rewireGuards(guard, true, newInput, guardedValueStamp, rewireGuardFunction);</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         return tryProveCondition(shortCircuitOrNode.getY(), (innerGuard, innerResult, innerGuardedValueStamp, innerNewInput) -&gt; {</span>
<span class="udiff-line-removed">-                             ValueNode proxifiedInput = newInput;</span>
<span class="udiff-line-removed">-                             if (proxifiedInput == null) {</span>
<span class="udiff-line-removed">-                                 proxifiedInput = innerNewInput;</span>
<span class="udiff-line-removed">-                             } else if (innerNewInput != null) {</span>
<span class="udiff-line-removed">-                                 if (innerNewInput != newInput) {</span>
<span class="udiff-line-removed">-                                     // Cannot canonicalize due to different proxied inputs.</span>
<span class="udiff-line-removed">-                                     return false;</span>
<span class="udiff-line-removed">-                                 }</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                             // Can only canonicalize if the guards are equal.</span>
<span class="udiff-line-removed">-                             if (innerGuard == guard) {</span>
<span class="udiff-line-removed">-                                 return rewireGuards(guard, innerResult ^ shortCircuitOrNode.isYNegated(), proxifiedInput, guardedValueStamp, rewireGuardFunction);</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                             return false;</span>
<span class="udiff-line-removed">-                         });</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                 });</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard) {
              registerNewStamp(maybeProxiedValue, newStamp, guard, false);
          }
  
          protected void registerNewStamp(ValueNode maybeProxiedValue, Stamp newStamp, GuardingNode guard, boolean propagateThroughPis) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1104,99 +943,10 @@</span>
                  conditions.pop();
              }
          }
      }
  
<span class="udiff-line-removed">-     @FunctionalInterface</span>
<span class="udiff-line-removed">-     protected interface InfoElementProvider {</span>
<span class="udiff-line-removed">-         Iterable&lt;InfoElement&gt; getInfoElements(ValueNode value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Checks for safe nodes when moving pending tests up.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     static class InputFilter extends Node.EdgeVisitor {</span>
<span class="udiff-line-removed">-         boolean ok;</span>
<span class="udiff-line-removed">-         private ValueNode value;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         InputFilter(ValueNode value) {</span>
<span class="udiff-line-removed">-             this.value = value;</span>
<span class="udiff-line-removed">-             this.ok = true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         @Override</span>
<span class="udiff-line-removed">-         public Node apply(Node node, Node curNode) {</span>
<span class="udiff-line-removed">-             if (!ok) {</span>
<span class="udiff-line-removed">-                 // Abort the recursion</span>
<span class="udiff-line-removed">-                 return curNode;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if (!(curNode instanceof ValueNode)) {</span>
<span class="udiff-line-removed">-                 ok = false;</span>
<span class="udiff-line-removed">-                 return curNode;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             ValueNode curValue = (ValueNode) curNode;</span>
<span class="udiff-line-removed">-             if (curValue.isConstant() || curValue == value || curValue instanceof ParameterNode) {</span>
<span class="udiff-line-removed">-                 return curNode;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if (curValue instanceof BinaryNode || curValue instanceof UnaryNode) {</span>
<span class="udiff-line-removed">-                 curValue.applyInputs(this);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 ok = false;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             return curNode;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     @FunctionalInterface</span>
<span class="udiff-line-removed">-     protected interface GuardRewirer {</span>
<span class="udiff-line-removed">-         /**</span>
<span class="udiff-line-removed">-          * Called if the condition could be proven to have a constant value ({@code result}) under</span>
<span class="udiff-line-removed">-          * {@code guard}.</span>
<span class="udiff-line-removed">-          *</span>
<span class="udiff-line-removed">-          * @param guard the guard whose result is proven</span>
<span class="udiff-line-removed">-          * @param result the known result of the guard</span>
<span class="udiff-line-removed">-          * @param newInput new input to pi nodes depending on the new guard</span>
<span class="udiff-line-removed">-          * @return whether the transformation could be applied</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         boolean rewire(GuardingNode guard, boolean result, Stamp guardedValueStamp, ValueNode newInput);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     protected static final class InfoElement {</span>
<span class="udiff-line-removed">-         private final Stamp stamp;</span>
<span class="udiff-line-removed">-         private final GuardingNode guard;</span>
<span class="udiff-line-removed">-         private final ValueNode proxifiedInput;</span>
<span class="udiff-line-removed">-         private final InfoElement parent;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public InfoElement(Stamp stamp, GuardingNode guard, ValueNode proxifiedInput, InfoElement parent) {</span>
<span class="udiff-line-removed">-             this.stamp = stamp;</span>
<span class="udiff-line-removed">-             this.guard = guard;</span>
<span class="udiff-line-removed">-             this.proxifiedInput = proxifiedInput;</span>
<span class="udiff-line-removed">-             this.parent = parent;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public InfoElement getParent() {</span>
<span class="udiff-line-removed">-             return parent;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public Stamp getStamp() {</span>
<span class="udiff-line-removed">-             return stamp;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public GuardingNode getGuard() {</span>
<span class="udiff-line-removed">-             return guard;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         public ValueNode getProxifiedInput() {</span>
<span class="udiff-line-removed">-             return proxifiedInput;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         @Override</span>
<span class="udiff-line-removed">-         public String toString() {</span>
<span class="udiff-line-removed">-             return stamp + &quot; -&gt; &quot; + guard;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      @Override
      public float codeSizeIncrease() {
          return 1.5f;
      }
  }
</pre>
<center><a href="CanonicalizerPhase.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="DeoptimizationGroupingPhase.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
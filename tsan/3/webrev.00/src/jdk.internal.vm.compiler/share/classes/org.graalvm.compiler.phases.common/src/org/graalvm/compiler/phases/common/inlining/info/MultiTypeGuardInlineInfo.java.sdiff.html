<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/info/MultiTypeGuardInlineInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../InliningUtil.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="elem/InlineableGraph.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/inlining/info/MultiTypeGuardInlineInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
191         // setup merge and phi nodes for results and exceptions
192         AbstractMergeNode returnMerge = graph.add(new MergeNode());
193         returnMerge.setStateAfter(invoke.stateAfter());
194 
195         PhiNode returnValuePhi = null;
196         if (invoke.asNode().getStackKind() != JavaKind.Void) {
197             returnValuePhi = graph.addWithoutUnique(new ValuePhiNode(invoke.asNode().stamp(NodeView.DEFAULT).unrestricted(), returnMerge));
198         }
199 
200         AbstractMergeNode exceptionMerge = null;
201         PhiNode exceptionObjectPhi = null;
202         if (invoke instanceof InvokeWithExceptionNode) {
203             InvokeWithExceptionNode invokeWithException = (InvokeWithExceptionNode) invoke;
204             ExceptionObjectNode exceptionEdge = (ExceptionObjectNode) invokeWithException.exceptionEdge();
205 
206             exceptionMerge = graph.add(new MergeNode());
207 
208             FixedNode exceptionSux = exceptionEdge.next();
209             graph.addBeforeFixed(exceptionSux, exceptionMerge);
210             exceptionObjectPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(JavaKind.Object), exceptionMerge));
<span class="line-modified">211             exceptionMerge.setStateAfter(exceptionEdge.stateAfter().duplicateModified(invoke.stateAfter().bci, true, JavaKind.Object, new JavaKind[]{JavaKind.Object},</span>
<span class="line-modified">212                             new ValueNode[]{exceptionObjectPhi}));</span>


213         }
214 
215         // create one separate block for each invoked method
216         AbstractBeginNode[] successors = new AbstractBeginNode[numberOfMethods + 1];
217         for (int i = 0; i &lt; numberOfMethods; i++) {
218             successors[i] = createInvocationBlock(graph, invoke, returnMerge, returnValuePhi, exceptionMerge, exceptionObjectPhi, true);
219         }
220 
221         // create the successor for an unknown type
222         FixedNode unknownTypeSux;
223         if (shouldFallbackToInvoke()) {
224             unknownTypeSux = createInvocationBlock(graph, invoke, returnMerge, returnValuePhi, exceptionMerge, exceptionObjectPhi, false);
225         } else {
226             unknownTypeSux = graph.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TypeCheckedInliningViolated));
227         }
228         successors[successors.length - 1] = BeginNode.begin(unknownTypeSux);
229 
230         // replace the invoke exception edge
231         if (invoke instanceof InvokeWithExceptionNode) {
232             InvokeWithExceptionNode invokeWithExceptionNode = (InvokeWithExceptionNode) invoke;
</pre>
<hr />
<pre>
379 
380         EndNode endNode = graph.add(new EndNode());
381         duplicatedInvoke.setNext(endNode);
382         returnMerge.addForwardEnd(endNode);
383 
384         if (returnValuePhi != null) {
385             returnValuePhi.addInput(duplicatedInvoke.asNode());
386         }
387         return calleeEntryNode;
388     }
389 
390     private static Invoke duplicateInvokeForInlining(StructuredGraph graph, Invoke invoke, AbstractMergeNode exceptionMerge, PhiNode exceptionObjectPhi, boolean useForInlining) {
391         Invoke result = (Invoke) invoke.asNode().copyWithInputs();
392         Node callTarget = result.callTarget().copyWithInputs();
393         result.asNode().replaceFirstInput(result.callTarget(), callTarget);
394         result.setUseForInlining(useForInlining);
395 
396         JavaKind kind = invoke.asNode().getStackKind();
397         if (kind != JavaKind.Void) {
398             FrameState stateAfter = invoke.stateAfter();
<span class="line-modified">399             stateAfter = stateAfter.duplicate(stateAfter.bci);</span>
400             stateAfter.replaceFirstInput(invoke.asNode(), result.asNode());
401             result.setStateAfter(stateAfter);
402         }
403 
404         if (invoke instanceof InvokeWithExceptionNode) {
405             assert exceptionMerge != null &amp;&amp; exceptionObjectPhi != null;
406 
407             InvokeWithExceptionNode invokeWithException = (InvokeWithExceptionNode) invoke;
408             ExceptionObjectNode exceptionEdge = (ExceptionObjectNode) invokeWithException.exceptionEdge();
409             FrameState stateAfterException = exceptionEdge.stateAfter();
410 
411             ExceptionObjectNode newExceptionEdge = (ExceptionObjectNode) exceptionEdge.copyWithInputs();
412             // set new state (pop old exception object, push new one)
413             newExceptionEdge.setStateAfter(stateAfterException.duplicateModified(JavaKind.Object, JavaKind.Object, newExceptionEdge));
414 
415             EndNode endNode = graph.add(new EndNode());
416             newExceptionEdge.setNext(endNode);
417             exceptionMerge.addForwardEnd(endNode);
418             exceptionObjectPhi.addInput(newExceptionEdge);
419 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
191         // setup merge and phi nodes for results and exceptions
192         AbstractMergeNode returnMerge = graph.add(new MergeNode());
193         returnMerge.setStateAfter(invoke.stateAfter());
194 
195         PhiNode returnValuePhi = null;
196         if (invoke.asNode().getStackKind() != JavaKind.Void) {
197             returnValuePhi = graph.addWithoutUnique(new ValuePhiNode(invoke.asNode().stamp(NodeView.DEFAULT).unrestricted(), returnMerge));
198         }
199 
200         AbstractMergeNode exceptionMerge = null;
201         PhiNode exceptionObjectPhi = null;
202         if (invoke instanceof InvokeWithExceptionNode) {
203             InvokeWithExceptionNode invokeWithException = (InvokeWithExceptionNode) invoke;
204             ExceptionObjectNode exceptionEdge = (ExceptionObjectNode) invokeWithException.exceptionEdge();
205 
206             exceptionMerge = graph.add(new MergeNode());
207 
208             FixedNode exceptionSux = exceptionEdge.next();
209             graph.addBeforeFixed(exceptionSux, exceptionMerge);
210             exceptionObjectPhi = graph.addWithoutUnique(new ValuePhiNode(StampFactory.forKind(JavaKind.Object), exceptionMerge));
<span class="line-modified">211 </span>
<span class="line-modified">212             assert exceptionEdge.stateAfter().bci == invoke.bci();</span>
<span class="line-added">213             assert exceptionEdge.stateAfter().rethrowException();</span>
<span class="line-added">214             exceptionMerge.setStateAfter(exceptionEdge.stateAfter().duplicateModified(JavaKind.Object, JavaKind.Object, exceptionObjectPhi));</span>
215         }
216 
217         // create one separate block for each invoked method
218         AbstractBeginNode[] successors = new AbstractBeginNode[numberOfMethods + 1];
219         for (int i = 0; i &lt; numberOfMethods; i++) {
220             successors[i] = createInvocationBlock(graph, invoke, returnMerge, returnValuePhi, exceptionMerge, exceptionObjectPhi, true);
221         }
222 
223         // create the successor for an unknown type
224         FixedNode unknownTypeSux;
225         if (shouldFallbackToInvoke()) {
226             unknownTypeSux = createInvocationBlock(graph, invoke, returnMerge, returnValuePhi, exceptionMerge, exceptionObjectPhi, false);
227         } else {
228             unknownTypeSux = graph.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TypeCheckedInliningViolated));
229         }
230         successors[successors.length - 1] = BeginNode.begin(unknownTypeSux);
231 
232         // replace the invoke exception edge
233         if (invoke instanceof InvokeWithExceptionNode) {
234             InvokeWithExceptionNode invokeWithExceptionNode = (InvokeWithExceptionNode) invoke;
</pre>
<hr />
<pre>
381 
382         EndNode endNode = graph.add(new EndNode());
383         duplicatedInvoke.setNext(endNode);
384         returnMerge.addForwardEnd(endNode);
385 
386         if (returnValuePhi != null) {
387             returnValuePhi.addInput(duplicatedInvoke.asNode());
388         }
389         return calleeEntryNode;
390     }
391 
392     private static Invoke duplicateInvokeForInlining(StructuredGraph graph, Invoke invoke, AbstractMergeNode exceptionMerge, PhiNode exceptionObjectPhi, boolean useForInlining) {
393         Invoke result = (Invoke) invoke.asNode().copyWithInputs();
394         Node callTarget = result.callTarget().copyWithInputs();
395         result.asNode().replaceFirstInput(result.callTarget(), callTarget);
396         result.setUseForInlining(useForInlining);
397 
398         JavaKind kind = invoke.asNode().getStackKind();
399         if (kind != JavaKind.Void) {
400             FrameState stateAfter = invoke.stateAfter();
<span class="line-modified">401             stateAfter = stateAfter.duplicate();</span>
402             stateAfter.replaceFirstInput(invoke.asNode(), result.asNode());
403             result.setStateAfter(stateAfter);
404         }
405 
406         if (invoke instanceof InvokeWithExceptionNode) {
407             assert exceptionMerge != null &amp;&amp; exceptionObjectPhi != null;
408 
409             InvokeWithExceptionNode invokeWithException = (InvokeWithExceptionNode) invoke;
410             ExceptionObjectNode exceptionEdge = (ExceptionObjectNode) invokeWithException.exceptionEdge();
411             FrameState stateAfterException = exceptionEdge.stateAfter();
412 
413             ExceptionObjectNode newExceptionEdge = (ExceptionObjectNode) exceptionEdge.copyWithInputs();
414             // set new state (pop old exception object, push new one)
415             newExceptionEdge.setStateAfter(stateAfterException.duplicateModified(JavaKind.Object, JavaKind.Object, newExceptionEdge));
416 
417             EndNode endNode = graph.add(new EndNode());
418             newExceptionEdge.setNext(endNode);
419             exceptionMerge.addForwardEnd(endNode);
420             exceptionObjectPhi.addInput(newExceptionEdge);
421 
</pre>
</td>
</tr>
</table>
<center><a href="../InliningUtil.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="elem/InlineableGraph.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
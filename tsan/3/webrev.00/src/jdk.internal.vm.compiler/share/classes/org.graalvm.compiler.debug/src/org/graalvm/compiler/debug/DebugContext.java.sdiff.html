<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.debug/src/org/graalvm/compiler/debug/DebugContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.core/src/org/graalvm/compiler/core/target/Backend.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DebugOptions.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.debug/src/org/graalvm/compiler/debug/DebugContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  36 import static org.graalvm.compiler.debug.DebugOptions.Log;
  37 import static org.graalvm.compiler.debug.DebugOptions.MemUseTrackers;
  38 import static org.graalvm.compiler.debug.DebugOptions.ShowDumpFiles;
  39 import static org.graalvm.compiler.debug.DebugOptions.Time;
  40 import static org.graalvm.compiler.debug.DebugOptions.Timers;
  41 import static org.graalvm.compiler.debug.DebugOptions.TrackMemUse;
  42 
  43 import java.io.ByteArrayOutputStream;
  44 import java.io.File;
  45 import java.io.IOException;
  46 import java.io.PrintStream;
  47 import java.nio.file.Files;
  48 import java.nio.file.Path;
  49 import java.nio.file.Paths;
  50 import java.nio.file.StandardOpenOption;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.Collection;
  54 import java.util.Collections;
  55 import java.util.Formatter;

  56 import java.util.List;
  57 import java.util.Map;
  58 import java.util.SortedMap;
  59 import java.util.TreeMap;
  60 
  61 import jdk.internal.vm.compiler.collections.EconomicMap;
  62 import jdk.internal.vm.compiler.collections.EconomicSet;
  63 import jdk.internal.vm.compiler.collections.Pair;
  64 import org.graalvm.compiler.options.OptionKey;
  65 import org.graalvm.compiler.options.OptionValues;
  66 import org.graalvm.compiler.serviceprovider.GraalServices;
  67 import org.graalvm.graphio.GraphOutput;
  68 
  69 import jdk.vm.ci.meta.JavaMethod;
  70 
  71 /**
  72  * A facility for logging and dumping as well as a container for values associated with
  73  * {@link MetricKey}s.
  74  *
  75  * A {@code DebugContext} object must only be used on the thread that created it. This means it
</pre>
<hr />
<pre>
 222             }
 223             Immutable immutable = new Immutable(options);
 224             if (i &lt; CACHE.length) {
 225                 CACHE[i] = immutable;
 226             }
 227             return immutable;
 228         }
 229 
 230         private static boolean isNotEmpty(OptionKey&lt;String&gt; option, OptionValues options) {
 231             return option.getValue(options) != null &amp;&amp; !option.getValue(options).isEmpty();
 232         }
 233 
 234         private Immutable(OptionValues options) {
 235             this.options = options;
 236             String timeValue = Time.getValue(options);
 237             String trackMemUseValue = TrackMemUse.getValue(options);
 238             this.unscopedCounters = parseUnscopedMetricSpec(Counters.getValue(options), &quot;&quot;.equals(Count.getValue(options)), false);
 239             this.unscopedTimers = parseUnscopedMetricSpec(Timers.getValue(options), &quot;&quot;.equals(timeValue), true);
 240             this.unscopedMemUseTrackers = parseUnscopedMetricSpec(MemUseTrackers.getValue(options), &quot;&quot;.equals(trackMemUseValue), true);
 241 
<span class="line-removed"> 242             if (unscopedTimers != null || timeValue != null) {</span>
<span class="line-removed"> 243                 if (!GraalServices.isCurrentThreadCpuTimeSupported()) {</span>
<span class="line-removed"> 244                     throw new IllegalArgumentException(&quot;Time and Timers options require VM support for querying CPU time&quot;);</span>
<span class="line-removed"> 245                 }</span>
<span class="line-removed"> 246             }</span>
<span class="line-removed"> 247 </span>
 248             if (unscopedMemUseTrackers != null || trackMemUseValue != null) {
 249                 if (!GraalServices.isThreadAllocatedMemorySupported()) {
<span class="line-modified"> 250                     throw new IllegalArgumentException(&quot;MemUseTrackers and TrackMemUse options require VM support for querying thread allocated memory&quot;);</span>
 251                 }
 252             }
 253 
 254             this.scopesEnabled = DumpOnError.getValue(options) ||
 255                             Dump.getValue(options) != null ||
 256                             Log.getValue(options) != null ||
 257                             isNotEmpty(DebugOptions.Count, options) ||
 258                             isNotEmpty(DebugOptions.Time, options) ||
 259                             isNotEmpty(DebugOptions.TrackMemUse, options) ||
 260                             DumpOnPhaseChange.getValue(options) != null;
 261             this.listMetrics = ListMetrics.getValue(options);
 262         }
 263 
 264         private Immutable() {
 265             this.options = new OptionValues(EconomicMap.create());
 266             this.unscopedCounters = null;
 267             this.unscopedTimers = null;
 268             this.unscopedMemUseTrackers = null;
 269             this.scopesEnabled = false;
 270             this.listMetrics = false;
</pre>
<hr />
<pre>
 300         @Override
 301         public void close() {
 302             activated.set(parent);
 303         }
 304     }
 305 
 306     /**
 307      * Activates this object as the debug context {@linkplain DebugContext#forCurrentThread for the
 308      * current thread}. This method should be used in a try-with-resources statement.
 309      *
 310      * @return an object that will deactivate the debug context for the current thread when
 311      *         {@link Activation#close()} is called on it
 312      */
 313     public Activation activate() {
 314         Activation res = new Activation(activated.get());
 315         activated.set(this);
 316         return res;
 317     }
 318 
 319     /**
<span class="line-modified"> 320      * Shared object used to represent a disabled debug context.</span>
 321      */
<span class="line-modified"> 322     public static final DebugContext DISABLED = new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, new Immutable(), NO_CONFIG_CUSTOMIZERS);</span>










 323 
 324     /**
 325      * Gets the debug context for the current thread. This should only be used when there is no
 326      * other reasonable means to get a hold of a debug context.
 327      */
 328     public static DebugContext forCurrentThread() {
 329         DebugContext current = activated.get();
 330         if (current == null) {
 331             return DISABLED;
 332         }
 333         return current;
 334     }
 335 
 336     private final GlobalMetrics globalMetrics;
 337 
 338     /**
 339      * Describes the computation associated with a {@link DebugContext}.
 340      */
 341     public static class Description {
 342         /**
</pre>
<hr />
<pre>
1820      * Debug.timer(String.format(format, arg1, arg2))
1821      * &lt;/pre&gt;
1822      *
1823      * except that the string formatting only happens if timing is enabled. In addition, each
1824      * argument is subject to the following type based conversion before being passed as an argument
1825      * to {@link String#format(String, Object...)}:
1826      *
1827      * &lt;pre&gt;
1828      *     Type          | Conversion
1829      * ------------------+-----------------
1830      *  java.lang.Class  | arg.getSimpleName()
1831      *                   |
1832      * &lt;/pre&gt;
1833      *
1834      * @see #timer(CharSequence)
1835      */
1836     public static TimerKey timer(String format, Object arg1, Object arg2) {
1837         return createTimer(format, arg1, arg2);
1838     }
1839 



















1840     /**
1841      * There are paths where construction of formatted class names are common and the code below is
1842      * surprisingly expensive, so compute it once and cache it.
1843      */
1844     private static final ClassValue&lt;String&gt; formattedClassName = new ClassValue&lt;String&gt;() {
1845         @Override
1846         protected String computeValue(Class&lt;?&gt; c) {
<span class="line-modified">1847             final String simpleName = c.getSimpleName();</span>




1848             Class&lt;?&gt; enclosingClass = c.getEnclosingClass();
1849             if (enclosingClass != null) {
1850                 String prefix = &quot;&quot;;
1851                 while (enclosingClass != null) {
<span class="line-modified">1852                     prefix = enclosingClass.getSimpleName() + &quot;_&quot; + prefix;</span>
1853                     enclosingClass = enclosingClass.getEnclosingClass();
1854                 }
<span class="line-modified">1855                 return prefix + simpleName;</span>
1856             } else {
<span class="line-modified">1857                 return simpleName;</span>
1858             }
1859         }
1860     };
1861 
1862     public static Object convertFormatArg(Object arg) {
1863         if (arg instanceof Class) {
1864             return formattedClassName.get((Class&lt;?&gt;) arg);
1865         }
1866         return arg;
1867     }
1868 
1869     static String formatDebugName(String format, Object arg1, Object arg2) {
1870         return String.format(format, convertFormatArg(arg1), convertFormatArg(arg2));
1871     }
1872 
1873     private static TimerKey createTimer(String format, Object arg1, Object arg2) {
1874         return new TimerKeyImpl(format, arg1, arg2);
1875     }
1876 
1877     /**
</pre>
<hr />
<pre>
2117                     valueString = ms + &quot;ms&quot;;
2118                 } else {
2119                     valueString = String.valueOf(value);
2120                 }
2121                 res.put(name, valueString);
2122                 maxKeyWidth = Math.max(maxKeyWidth, name.length());
2123             }
2124         }
2125 
2126         String title = String.format(&quot;%s [id:%s compilation:%d compilation_id:%s]&quot;, compilableName, identity, compilationNr, compilationId);
2127         out.println(new String(new char[title.length()]).replace(&#39;\0&#39;, &#39;#&#39;));
2128         out.printf(&quot;%s%n&quot;, title);
2129         out.println(new String(new char[title.length()]).replace(&#39;\0&#39;, &#39;~&#39;));
2130 
2131         for (Map.Entry&lt;String, String&gt; e : res.entrySet()) {
2132             out.printf(&quot;%-&quot; + String.valueOf(maxKeyWidth) + &quot;s = %20s%n&quot;, e.getKey(), e.getValue());
2133         }
2134         out.println();
2135     }
2136 












2137     @SuppressWarnings({&quot;unused&quot;, &quot;unchecked&quot;})
2138     private static &lt;E extends Exception&gt; E rethrowSilently(Class&lt;E&gt; type, Throwable ex) throws E {
2139         throw (E) ex;
2140     }
2141 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  36 import static org.graalvm.compiler.debug.DebugOptions.Log;
  37 import static org.graalvm.compiler.debug.DebugOptions.MemUseTrackers;
  38 import static org.graalvm.compiler.debug.DebugOptions.ShowDumpFiles;
  39 import static org.graalvm.compiler.debug.DebugOptions.Time;
  40 import static org.graalvm.compiler.debug.DebugOptions.Timers;
  41 import static org.graalvm.compiler.debug.DebugOptions.TrackMemUse;
  42 
  43 import java.io.ByteArrayOutputStream;
  44 import java.io.File;
  45 import java.io.IOException;
  46 import java.io.PrintStream;
  47 import java.nio.file.Files;
  48 import java.nio.file.Path;
  49 import java.nio.file.Paths;
  50 import java.nio.file.StandardOpenOption;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.Collection;
  54 import java.util.Collections;
  55 import java.util.Formatter;
<span class="line-added">  56 import java.util.HashMap;</span>
  57 import java.util.List;
  58 import java.util.Map;
  59 import java.util.SortedMap;
  60 import java.util.TreeMap;
  61 
  62 import jdk.internal.vm.compiler.collections.EconomicMap;
  63 import jdk.internal.vm.compiler.collections.EconomicSet;
  64 import jdk.internal.vm.compiler.collections.Pair;
  65 import org.graalvm.compiler.options.OptionKey;
  66 import org.graalvm.compiler.options.OptionValues;
  67 import org.graalvm.compiler.serviceprovider.GraalServices;
  68 import org.graalvm.graphio.GraphOutput;
  69 
  70 import jdk.vm.ci.meta.JavaMethod;
  71 
  72 /**
  73  * A facility for logging and dumping as well as a container for values associated with
  74  * {@link MetricKey}s.
  75  *
  76  * A {@code DebugContext} object must only be used on the thread that created it. This means it
</pre>
<hr />
<pre>
 223             }
 224             Immutable immutable = new Immutable(options);
 225             if (i &lt; CACHE.length) {
 226                 CACHE[i] = immutable;
 227             }
 228             return immutable;
 229         }
 230 
 231         private static boolean isNotEmpty(OptionKey&lt;String&gt; option, OptionValues options) {
 232             return option.getValue(options) != null &amp;&amp; !option.getValue(options).isEmpty();
 233         }
 234 
 235         private Immutable(OptionValues options) {
 236             this.options = options;
 237             String timeValue = Time.getValue(options);
 238             String trackMemUseValue = TrackMemUse.getValue(options);
 239             this.unscopedCounters = parseUnscopedMetricSpec(Counters.getValue(options), &quot;&quot;.equals(Count.getValue(options)), false);
 240             this.unscopedTimers = parseUnscopedMetricSpec(Timers.getValue(options), &quot;&quot;.equals(timeValue), true);
 241             this.unscopedMemUseTrackers = parseUnscopedMetricSpec(MemUseTrackers.getValue(options), &quot;&quot;.equals(trackMemUseValue), true);
 242 






 243             if (unscopedMemUseTrackers != null || trackMemUseValue != null) {
 244                 if (!GraalServices.isThreadAllocatedMemorySupported()) {
<span class="line-modified"> 245                     TTY.println(&quot;WARNING: Missing VM support for MemUseTrackers and TrackMemUse options so all reported memory usage will be 0&quot;);</span>
 246                 }
 247             }
 248 
 249             this.scopesEnabled = DumpOnError.getValue(options) ||
 250                             Dump.getValue(options) != null ||
 251                             Log.getValue(options) != null ||
 252                             isNotEmpty(DebugOptions.Count, options) ||
 253                             isNotEmpty(DebugOptions.Time, options) ||
 254                             isNotEmpty(DebugOptions.TrackMemUse, options) ||
 255                             DumpOnPhaseChange.getValue(options) != null;
 256             this.listMetrics = ListMetrics.getValue(options);
 257         }
 258 
 259         private Immutable() {
 260             this.options = new OptionValues(EconomicMap.create());
 261             this.unscopedCounters = null;
 262             this.unscopedTimers = null;
 263             this.unscopedMemUseTrackers = null;
 264             this.scopesEnabled = false;
 265             this.listMetrics = false;
</pre>
<hr />
<pre>
 295         @Override
 296         public void close() {
 297             activated.set(parent);
 298         }
 299     }
 300 
 301     /**
 302      * Activates this object as the debug context {@linkplain DebugContext#forCurrentThread for the
 303      * current thread}. This method should be used in a try-with-resources statement.
 304      *
 305      * @return an object that will deactivate the debug context for the current thread when
 306      *         {@link Activation#close()} is called on it
 307      */
 308     public Activation activate() {
 309         Activation res = new Activation(activated.get());
 310         activated.set(this);
 311         return res;
 312     }
 313 
 314     /**
<span class="line-modified"> 315      * Singleton used to represent a disabled debug context.</span>
 316      */
<span class="line-modified"> 317     private static final DebugContext DISABLED = new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, new Immutable(), NO_CONFIG_CUSTOMIZERS);</span>
<span class="line-added"> 318 </span>
<span class="line-added"> 319     /**</span>
<span class="line-added"> 320      * Create a DebugContext with debugging disabled.</span>
<span class="line-added"> 321      */</span>
<span class="line-added"> 322     public static DebugContext disabled(OptionValues options) {</span>
<span class="line-added"> 323         if (options == null || options.getMap().isEmpty()) {</span>
<span class="line-added"> 324             return DISABLED;</span>
<span class="line-added"> 325         }</span>
<span class="line-added"> 326         return new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, Immutable.create(options), NO_CONFIG_CUSTOMIZERS);</span>
<span class="line-added"> 327     }</span>
 328 
 329     /**
 330      * Gets the debug context for the current thread. This should only be used when there is no
 331      * other reasonable means to get a hold of a debug context.
 332      */
 333     public static DebugContext forCurrentThread() {
 334         DebugContext current = activated.get();
 335         if (current == null) {
 336             return DISABLED;
 337         }
 338         return current;
 339     }
 340 
 341     private final GlobalMetrics globalMetrics;
 342 
 343     /**
 344      * Describes the computation associated with a {@link DebugContext}.
 345      */
 346     public static class Description {
 347         /**
</pre>
<hr />
<pre>
1825      * Debug.timer(String.format(format, arg1, arg2))
1826      * &lt;/pre&gt;
1827      *
1828      * except that the string formatting only happens if timing is enabled. In addition, each
1829      * argument is subject to the following type based conversion before being passed as an argument
1830      * to {@link String#format(String, Object...)}:
1831      *
1832      * &lt;pre&gt;
1833      *     Type          | Conversion
1834      * ------------------+-----------------
1835      *  java.lang.Class  | arg.getSimpleName()
1836      *                   |
1837      * &lt;/pre&gt;
1838      *
1839      * @see #timer(CharSequence)
1840      */
1841     public static TimerKey timer(String format, Object arg1, Object arg2) {
1842         return createTimer(format, arg1, arg2);
1843     }
1844 
<span class="line-added">1845     /**</span>
<span class="line-added">1846      * Gets the name to use for a class based on whether it appears to be an obfuscated name. The</span>
<span class="line-added">1847      * heuristic for an obfuscated name is that it is less than 6 characters in length and consists</span>
<span class="line-added">1848      * only of lower case letters.</span>
<span class="line-added">1849      */</span>
<span class="line-added">1850     private static String getBaseName(Class&lt;?&gt; c) {</span>
<span class="line-added">1851         String simpleName = c.getSimpleName();</span>
<span class="line-added">1852         if (simpleName.length() &lt; 6) {</span>
<span class="line-added">1853             for (int i = 0; i &lt; simpleName.length(); i++) {</span>
<span class="line-added">1854                 if (!Character.isLowerCase(simpleName.charAt(0))) {</span>
<span class="line-added">1855                     return simpleName;</span>
<span class="line-added">1856                 }</span>
<span class="line-added">1857             }</span>
<span class="line-added">1858             // Looks like an obfuscated simple class name so use qualified class name</span>
<span class="line-added">1859             return c.getName();</span>
<span class="line-added">1860         }</span>
<span class="line-added">1861         return simpleName;</span>
<span class="line-added">1862     }</span>
<span class="line-added">1863 </span>
1864     /**
1865      * There are paths where construction of formatted class names are common and the code below is
1866      * surprisingly expensive, so compute it once and cache it.
1867      */
1868     private static final ClassValue&lt;String&gt; formattedClassName = new ClassValue&lt;String&gt;() {
1869         @Override
1870         protected String computeValue(Class&lt;?&gt; c) {
<span class="line-modified">1871             String baseName = getBaseName(c);</span>
<span class="line-added">1872             if (Character.isLowerCase(baseName.charAt(0))) {</span>
<span class="line-added">1873                 // Looks like an obfuscated simple class name so use qualified class name</span>
<span class="line-added">1874                 baseName = c.getName();</span>
<span class="line-added">1875             }</span>
1876             Class&lt;?&gt; enclosingClass = c.getEnclosingClass();
1877             if (enclosingClass != null) {
1878                 String prefix = &quot;&quot;;
1879                 while (enclosingClass != null) {
<span class="line-modified">1880                     prefix = getBaseName(enclosingClass) + &quot;_&quot; + prefix;</span>
1881                     enclosingClass = enclosingClass.getEnclosingClass();
1882                 }
<span class="line-modified">1883                 return prefix + baseName;</span>
1884             } else {
<span class="line-modified">1885                 return baseName;</span>
1886             }
1887         }
1888     };
1889 
1890     public static Object convertFormatArg(Object arg) {
1891         if (arg instanceof Class) {
1892             return formattedClassName.get((Class&lt;?&gt;) arg);
1893         }
1894         return arg;
1895     }
1896 
1897     static String formatDebugName(String format, Object arg1, Object arg2) {
1898         return String.format(format, convertFormatArg(arg1), convertFormatArg(arg2));
1899     }
1900 
1901     private static TimerKey createTimer(String format, Object arg1, Object arg2) {
1902         return new TimerKeyImpl(format, arg1, arg2);
1903     }
1904 
1905     /**
</pre>
<hr />
<pre>
2145                     valueString = ms + &quot;ms&quot;;
2146                 } else {
2147                     valueString = String.valueOf(value);
2148                 }
2149                 res.put(name, valueString);
2150                 maxKeyWidth = Math.max(maxKeyWidth, name.length());
2151             }
2152         }
2153 
2154         String title = String.format(&quot;%s [id:%s compilation:%d compilation_id:%s]&quot;, compilableName, identity, compilationNr, compilationId);
2155         out.println(new String(new char[title.length()]).replace(&#39;\0&#39;, &#39;#&#39;));
2156         out.printf(&quot;%s%n&quot;, title);
2157         out.println(new String(new char[title.length()]).replace(&#39;\0&#39;, &#39;~&#39;));
2158 
2159         for (Map.Entry&lt;String, String&gt; e : res.entrySet()) {
2160             out.printf(&quot;%-&quot; + String.valueOf(maxKeyWidth) + &quot;s = %20s%n&quot;, e.getKey(), e.getValue());
2161         }
2162         out.println();
2163     }
2164 
<span class="line-added">2165     public Map&lt;MetricKey, Long&gt; getMetricsSnapshot() {</span>
<span class="line-added">2166         Map&lt;MetricKey, Long&gt; res = new HashMap&lt;&gt;();</span>
<span class="line-added">2167         for (MetricKey key : KeyRegistry.getKeys()) {</span>
<span class="line-added">2168             int index = ((AbstractKey) key).getIndex();</span>
<span class="line-added">2169             if (index &lt; metricValues.length &amp;&amp; metricValues[index] != 0) {</span>
<span class="line-added">2170                 long value = metricValues[index];</span>
<span class="line-added">2171                 res.put(key, value);</span>
<span class="line-added">2172             }</span>
<span class="line-added">2173         }</span>
<span class="line-added">2174         return res;</span>
<span class="line-added">2175     }</span>
<span class="line-added">2176 </span>
2177     @SuppressWarnings({&quot;unused&quot;, &quot;unchecked&quot;})
2178     private static &lt;E extends Exception&gt; E rethrowSilently(Class&lt;E&gt; type, Throwable ex) throws E {
2179         throw (E) ex;
2180     }
2181 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../org.graalvm.compiler.core/src/org/graalvm/compiler/core/target/Backend.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DebugOptions.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
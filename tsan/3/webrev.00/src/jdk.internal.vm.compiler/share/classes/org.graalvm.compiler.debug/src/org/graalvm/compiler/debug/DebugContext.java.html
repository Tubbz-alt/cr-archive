<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.debug/src/org/graalvm/compiler/debug/DebugContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.debug;
  26 
  27 import static java.util.FormattableFlags.LEFT_JUSTIFY;
  28 import static java.util.FormattableFlags.UPPERCASE;
  29 import static org.graalvm.compiler.debug.DebugOptions.Count;
  30 import static org.graalvm.compiler.debug.DebugOptions.Counters;
  31 import static org.graalvm.compiler.debug.DebugOptions.Dump;
  32 import static org.graalvm.compiler.debug.DebugOptions.DumpOnError;
  33 import static org.graalvm.compiler.debug.DebugOptions.DumpOnPhaseChange;
  34 import static org.graalvm.compiler.debug.DebugOptions.DumpPath;
  35 import static org.graalvm.compiler.debug.DebugOptions.ListMetrics;
  36 import static org.graalvm.compiler.debug.DebugOptions.Log;
  37 import static org.graalvm.compiler.debug.DebugOptions.MemUseTrackers;
  38 import static org.graalvm.compiler.debug.DebugOptions.ShowDumpFiles;
  39 import static org.graalvm.compiler.debug.DebugOptions.Time;
  40 import static org.graalvm.compiler.debug.DebugOptions.Timers;
  41 import static org.graalvm.compiler.debug.DebugOptions.TrackMemUse;
  42 
  43 import java.io.ByteArrayOutputStream;
  44 import java.io.File;
  45 import java.io.IOException;
  46 import java.io.PrintStream;
  47 import java.nio.file.Files;
  48 import java.nio.file.Path;
  49 import java.nio.file.Paths;
  50 import java.nio.file.StandardOpenOption;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.Collection;
  54 import java.util.Collections;
  55 import java.util.Formatter;
  56 import java.util.HashMap;
  57 import java.util.List;
  58 import java.util.Map;
  59 import java.util.SortedMap;
  60 import java.util.TreeMap;
  61 
  62 import jdk.internal.vm.compiler.collections.EconomicMap;
  63 import jdk.internal.vm.compiler.collections.EconomicSet;
  64 import jdk.internal.vm.compiler.collections.Pair;
  65 import org.graalvm.compiler.options.OptionKey;
  66 import org.graalvm.compiler.options.OptionValues;
  67 import org.graalvm.compiler.serviceprovider.GraalServices;
  68 import org.graalvm.graphio.GraphOutput;
  69 
  70 import jdk.vm.ci.meta.JavaMethod;
  71 
  72 /**
  73  * A facility for logging and dumping as well as a container for values associated with
  74  * {@link MetricKey}s.
  75  *
  76  * A {@code DebugContext} object must only be used on the thread that created it. This means it
  77  * needs to be passed around as a parameter. For convenience, it can be encapsulated in a widely
  78  * used object that is in scope wherever a {@code DebugContext} is needed. However, care must be
  79  * taken when such objects can be exposed to multiple threads (e.g., they are in a non-thread-local
  80  * cache).
  81  */
  82 public final class DebugContext implements AutoCloseable {
  83 
  84     public static final Description NO_DESCRIPTION = new Description(null, &quot;NO_DESCRIPTION&quot;);
  85     public static final GlobalMetrics NO_GLOBAL_METRIC_VALUES = null;
  86     public static final Iterable&lt;DebugHandlersFactory&gt; NO_CONFIG_CUSTOMIZERS = Collections.emptyList();
  87 
  88     public static final PrintStream DEFAULT_LOG_STREAM = TTY.out;
  89 
  90     /**
  91      * Contains the immutable parts of a debug context. This separation allows the immutable parts
  92      * to be shared and reduces the overhead of initialization since most immutable fields are
  93      * configured by parsing options.
  94      */
  95     final Immutable immutable;
  96 
  97     /**
  98      * Determines whether metrics are enabled.
  99      */
 100     boolean metricsEnabled;
 101 
 102     DebugConfigImpl currentConfig;
 103     ScopeImpl currentScope;
 104     CloseableCounter currentTimer;
 105     CloseableCounter currentMemUseTracker;
 106     Scope lastClosedScope;
 107     Throwable lastExceptionThrown;
 108     private IgvDumpChannel sharedChannel;
 109     private GraphOutput&lt;?, ?&gt; parentOutput;
 110 
 111     /**
 112      * Stores the {@link MetricKey} values.
 113      */
 114     private long[] metricValues;
 115 
 116     /**
 117      * Determines if dynamic scopes are enabled.
 118      */
 119     public boolean areScopesEnabled() {
 120         return immutable.scopesEnabled;
 121     }
 122 
 123     public &lt;G, N, M&gt; GraphOutput&lt;G, M&gt; buildOutput(GraphOutput.Builder&lt;G, N, M&gt; builder) throws IOException {
 124         if (parentOutput != null) {
 125             return builder.build(parentOutput);
 126         } else {
 127             if (sharedChannel == null) {
 128                 sharedChannel = new IgvDumpChannel(() -&gt; getDumpPath(&quot;.bgv&quot;, false), immutable.options);
 129             }
 130             final GraphOutput&lt;G, M&gt; output = builder.build(sharedChannel);
 131             parentOutput = output;
 132             return output;
 133         }
 134     }
 135 
 136     /**
 137      * Adds version properties to the provided map. The version properties are read at a start of
 138      * the JVM from a JVM specific location. Each property identifiers a commit of a certain
 139      * component in the system. The properties added to the {@code properties} map are prefixed with
 140      * {@code &quot;version.&quot;} prefix.
 141      *
 142      * @param properties map to add the version properties to or {@code null}
 143      * @return {@code properties} with version properties added or an unmodifiable map containing
 144      *         the version properties if {@code properties == null}
 145      */
 146     public static Map&lt;Object, Object&gt; addVersionProperties(Map&lt;Object, Object&gt; properties) {
 147         return Versions.VERSIONS.withVersions(properties);
 148     }
 149 
 150     /**
 151      * The immutable configuration that can be shared between {@link DebugContext} objects.
 152      */
 153     static final class Immutable {
 154 
 155         private static final Immutable[] CACHE = new Immutable[5];
 156 
 157         /**
 158          * The options from which this object was configured.
 159          */
 160         final OptionValues options;
 161 
 162         /**
 163          * Specifies if dynamic scopes are enabled.
 164          */
 165         final boolean scopesEnabled;
 166 
 167         final boolean listMetrics;
 168 
 169         /**
 170          * Names of unscoped counters. A counter is unscoped if this set is empty or contains the
 171          * counter&#39;s name.
 172          */
 173         final EconomicSet&lt;String&gt; unscopedCounters;
 174 
 175         /**
 176          * Names of unscoped timers. A timer is unscoped if this set is empty or contains the
 177          * timer&#39;s name.
 178          */
 179         final EconomicSet&lt;String&gt; unscopedTimers;
 180 
 181         /**
 182          * Names of unscoped memory usage trackers. A memory usage tracker is unscoped if this set
 183          * is empty or contains the memory usage tracker&#39;s name.
 184          */
 185         final EconomicSet&lt;String&gt; unscopedMemUseTrackers;
 186 
 187         private static EconomicSet&lt;String&gt; parseUnscopedMetricSpec(String spec, boolean unconditional, boolean accumulatedKey) {
 188             EconomicSet&lt;String&gt; res;
 189             if (spec == null) {
 190                 if (!unconditional) {
 191                     res = null;
 192                 } else {
 193                     res = EconomicSet.create();
 194                 }
 195             } else {
 196                 res = EconomicSet.create();
 197                 if (!spec.isEmpty()) {
 198                     if (!accumulatedKey) {
 199                         res.addAll(Arrays.asList(spec.split(&quot;,&quot;)));
 200                     } else {
 201                         for (String n : spec.split(&quot;,&quot;)) {
 202                             res.add(n + AccumulatedKey.ACCUMULATED_KEY_SUFFIX);
 203                             res.add(n + AccumulatedKey.FLAT_KEY_SUFFIX);
 204                         }
 205                     }
 206 
 207                 }
 208             }
 209             return res;
 210         }
 211 
 212         static Immutable create(OptionValues options) {
 213             int i = 0;
 214             while (i &lt; CACHE.length) {
 215                 Immutable immutable = CACHE[i];
 216                 if (immutable == null) {
 217                     break;
 218                 }
 219                 if (immutable.options == options) {
 220                     return immutable;
 221                 }
 222                 i++;
 223             }
 224             Immutable immutable = new Immutable(options);
 225             if (i &lt; CACHE.length) {
 226                 CACHE[i] = immutable;
 227             }
 228             return immutable;
 229         }
 230 
 231         private static boolean isNotEmpty(OptionKey&lt;String&gt; option, OptionValues options) {
 232             return option.getValue(options) != null &amp;&amp; !option.getValue(options).isEmpty();
 233         }
 234 
 235         private Immutable(OptionValues options) {
 236             this.options = options;
 237             String timeValue = Time.getValue(options);
 238             String trackMemUseValue = TrackMemUse.getValue(options);
 239             this.unscopedCounters = parseUnscopedMetricSpec(Counters.getValue(options), &quot;&quot;.equals(Count.getValue(options)), false);
 240             this.unscopedTimers = parseUnscopedMetricSpec(Timers.getValue(options), &quot;&quot;.equals(timeValue), true);
 241             this.unscopedMemUseTrackers = parseUnscopedMetricSpec(MemUseTrackers.getValue(options), &quot;&quot;.equals(trackMemUseValue), true);
 242 
 243             if (unscopedMemUseTrackers != null || trackMemUseValue != null) {
 244                 if (!GraalServices.isThreadAllocatedMemorySupported()) {
 245                     TTY.println(&quot;WARNING: Missing VM support for MemUseTrackers and TrackMemUse options so all reported memory usage will be 0&quot;);
 246                 }
 247             }
 248 
 249             this.scopesEnabled = DumpOnError.getValue(options) ||
 250                             Dump.getValue(options) != null ||
 251                             Log.getValue(options) != null ||
 252                             isNotEmpty(DebugOptions.Count, options) ||
 253                             isNotEmpty(DebugOptions.Time, options) ||
 254                             isNotEmpty(DebugOptions.TrackMemUse, options) ||
 255                             DumpOnPhaseChange.getValue(options) != null;
 256             this.listMetrics = ListMetrics.getValue(options);
 257         }
 258 
 259         private Immutable() {
 260             this.options = new OptionValues(EconomicMap.create());
 261             this.unscopedCounters = null;
 262             this.unscopedTimers = null;
 263             this.unscopedMemUseTrackers = null;
 264             this.scopesEnabled = false;
 265             this.listMetrics = false;
 266         }
 267 
 268         public boolean hasUnscopedMetrics() {
 269             return unscopedCounters != null || unscopedTimers != null || unscopedMemUseTrackers != null;
 270         }
 271     }
 272 
 273     /**
 274      * Gets the options this debug context was constructed with.
 275      */
 276     public OptionValues getOptions() {
 277         return immutable.options;
 278     }
 279 
 280     static class Activated extends ThreadLocal&lt;DebugContext&gt; {
 281     }
 282 
 283     private static final Activated activated = new Activated();
 284 
 285     /**
 286      * An object used to undo the changes made by DebugContext#activate().
 287      */
 288     public static class Activation implements AutoCloseable {
 289         private final DebugContext parent;
 290 
 291         Activation(DebugContext parent) {
 292             this.parent = parent;
 293         }
 294 
 295         @Override
 296         public void close() {
 297             activated.set(parent);
 298         }
 299     }
 300 
 301     /**
 302      * Activates this object as the debug context {@linkplain DebugContext#forCurrentThread for the
 303      * current thread}. This method should be used in a try-with-resources statement.
 304      *
 305      * @return an object that will deactivate the debug context for the current thread when
 306      *         {@link Activation#close()} is called on it
 307      */
 308     public Activation activate() {
 309         Activation res = new Activation(activated.get());
 310         activated.set(this);
 311         return res;
 312     }
 313 
 314     /**
 315      * Singleton used to represent a disabled debug context.
 316      */
 317     private static final DebugContext DISABLED = new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, new Immutable(), NO_CONFIG_CUSTOMIZERS);
 318 
 319     /**
 320      * Create a DebugContext with debugging disabled.
 321      */
 322     public static DebugContext disabled(OptionValues options) {
 323         if (options == null || options.getMap().isEmpty()) {
 324             return DISABLED;
 325         }
 326         return new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, Immutable.create(options), NO_CONFIG_CUSTOMIZERS);
 327     }
 328 
 329     /**
 330      * Gets the debug context for the current thread. This should only be used when there is no
 331      * other reasonable means to get a hold of a debug context.
 332      */
 333     public static DebugContext forCurrentThread() {
 334         DebugContext current = activated.get();
 335         if (current == null) {
 336             return DISABLED;
 337         }
 338         return current;
 339     }
 340 
 341     private final GlobalMetrics globalMetrics;
 342 
 343     /**
 344      * Describes the computation associated with a {@link DebugContext}.
 345      */
 346     public static class Description {
 347         /**
 348          * The primary input to the computation.
 349          */
 350         final Object compilable;
 351 
 352         /**
 353          * A runtime based identifier that is most likely to be unique.
 354          */
 355         final String identifier;
 356 
 357         public Description(Object compilable, String identifier) {
 358             this.compilable = compilable;
 359             this.identifier = identifier;
 360         }
 361 
 362         @Override
 363         public String toString() {
 364             String compilableName = compilable instanceof JavaMethod ? ((JavaMethod) compilable).format(&quot;%H.%n(%p)%R&quot;) : String.valueOf(compilable);
 365             return identifier + &quot;:&quot; + compilableName;
 366         }
 367 
 368         final String getLabel() {
 369             if (compilable instanceof JavaMethod) {
 370                 JavaMethod method = (JavaMethod) compilable;
 371                 return method.format(&quot;%h.%n(%p)%r&quot;);
 372             }
 373             return String.valueOf(compilable);
 374         }
 375     }
 376 
 377     private final Description description;
 378 
 379     /**
 380      * Gets a description of the computation associated with this debug context.
 381      *
 382      * @return {@code null} if no description is available
 383      */
 384     public Description getDescription() {
 385         return description;
 386     }
 387 
 388     /**
 389      * Gets the global metrics associated with this debug context.
 390      *
 391      * @return {@code null} if no global metrics are available
 392      */
 393     public GlobalMetrics getGlobalMetrics() {
 394         return globalMetrics;
 395     }
 396 
 397     /**
 398      * Creates a {@link DebugContext} based on a given set of option values and {@code factory}.
 399      */
 400     public static DebugContext create(OptionValues options, DebugHandlersFactory factory) {
 401         return new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, Immutable.create(options), Collections.singletonList(factory));
 402     }
 403 
 404     /**
 405      * Creates a {@link DebugContext} based on a given set of option values and {@code factories}.
 406      * The {@link DebugHandlersFactory#LOADER} can be used for the latter.
 407      */
 408     public static DebugContext create(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories) {
 409         return new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, Immutable.create(options), factories);
 410     }
 411 
 412     public static DebugContext create(OptionValues options, PrintStream logStream, DebugHandlersFactory factory) {
 413         return new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, logStream, Immutable.create(options), Collections.singletonList(factory));
 414     }
 415 
 416     /**
 417      * Creates a {@link DebugContext} based on a given set of option values and {@code factories}.
 418      * The {@link DebugHandlersFactory#LOADER} can be used for the latter.
 419      */
 420     public static DebugContext create(OptionValues options, Description description, Iterable&lt;DebugHandlersFactory&gt; factories) {
 421         return new DebugContext(description, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, Immutable.create(options), factories);
 422     }
 423 
 424     /**
 425      * Creates a {@link DebugContext}.
 426      */
 427     public static DebugContext create(OptionValues options, Description description, GlobalMetrics globalMetrics, PrintStream logStream, Iterable&lt;DebugHandlersFactory&gt; factories) {
 428         return new DebugContext(description, globalMetrics, logStream, Immutable.create(options), factories);
 429     }
 430 
 431     private DebugContext(Description description, GlobalMetrics globalMetrics, PrintStream logStream, Immutable immutable, Iterable&lt;DebugHandlersFactory&gt; factories) {
 432         this.immutable = immutable;
 433         this.description = description;
 434         this.globalMetrics = globalMetrics;
 435         if (immutable.scopesEnabled) {
 436             OptionValues options = immutable.options;
 437             List&lt;DebugDumpHandler&gt; dumpHandlers = new ArrayList&lt;&gt;();
 438             List&lt;DebugVerifyHandler&gt; verifyHandlers = new ArrayList&lt;&gt;();
 439             for (DebugHandlersFactory factory : factories) {
 440                 for (DebugHandler handler : factory.createHandlers(options)) {
 441                     if (handler instanceof DebugDumpHandler) {
 442                         dumpHandlers.add((DebugDumpHandler) handler);
 443                     } else {
 444                         assert handler instanceof DebugVerifyHandler;
 445                         verifyHandlers.add((DebugVerifyHandler) handler);
 446                     }
 447                 }
 448             }
 449             currentConfig = new DebugConfigImpl(options, logStream, dumpHandlers, verifyHandlers);
 450             currentScope = new ScopeImpl(this, Thread.currentThread());
 451             currentScope.updateFlags(currentConfig);
 452             metricsEnabled = true;
 453         } else {
 454             metricsEnabled = immutable.hasUnscopedMetrics() || immutable.listMetrics;
 455         }
 456     }
 457 
 458     public Path getDumpPath(String extension, boolean createMissingDirectory) {
 459         try {
 460             String id = description == null ? null : description.identifier;
 461             String label = description == null ? null : description.getLabel();
 462             Path result = PathUtilities.createUnique(immutable.options, DumpPath, id, label, extension, createMissingDirectory);
 463             if (ShowDumpFiles.getValue(immutable.options)) {
 464                 TTY.println(&quot;Dumping debug output to %s&quot;, result.toAbsolutePath().toString());
 465             }
 466             return result;
 467         } catch (IOException ex) {
 468             throw rethrowSilently(RuntimeException.class, ex);
 469         }
 470     }
 471 
 472     /**
 473      * A special dump level that indicates the dumping machinery is enabled but no dumps will be
 474      * produced except through other options.
 475      */
 476     public static final int ENABLED_LEVEL = 0;
 477 
 478     /**
 479      * Basic debug level.
 480      *
 481      * For HIR dumping, only ~5 graphs per method: after parsing, after inlining, after high tier,
 482      * after mid tier, after low tier.
 483      *
 484      * LIR dumping: After LIR generation, after each pre-allocation, allocation and post allocation
 485      * stage, and after code installation.
 486      */
 487     public static final int BASIC_LEVEL = 1;
 488 
 489     /**
 490      * Informational debug level.
 491      *
 492      * HIR dumping: One graph after each applied top-level phase.
 493      *
 494      * LIR dumping: After each applied phase.
 495      */
 496     public static final int INFO_LEVEL = 2;
 497 
 498     /**
 499      * Verbose debug level.
 500      *
 501      * HIR dumping: One graph after each phase (including sub phases).
 502      *
 503      * LIR dumping: After each phase including sub phases.
 504      */
 505     public static final int VERBOSE_LEVEL = 3;
 506 
 507     /**
 508      * Detailed debug level.
 509      *
 510      * HIR dumping: Graphs within phases where interesting for a phase, max ~5 per phase.
 511      *
 512      * LIR dumping: Dump CFG within phases where interesting.
 513      */
 514     public static final int DETAILED_LEVEL = 4;
 515 
 516     /**
 517      * Very detailed debug level.
 518      *
 519      * HIR dumping: Graphs per node granularity graph change (before/after change).
 520      *
 521      * LIR dumping: Intermediate CFGs of phases where interesting.
 522      */
 523     public static final int VERY_DETAILED_LEVEL = 5;
 524 
 525     public boolean isDumpEnabled(int dumpLevel) {
 526         return currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel);
 527     }
 528 
 529     /**
 530      * Determines if verification is enabled for any {@link JavaMethod} in the current scope.
 531      *
 532      * @see DebugContext#verify(Object, String)
 533      */
 534     public boolean isVerifyEnabledForMethod() {
 535         if (currentScope == null) {
 536             return false;
 537         }
 538         if (currentConfig == null) {
 539             return false;
 540         }
 541         return currentConfig.isVerifyEnabledForMethod(currentScope);
 542     }
 543 
 544     /**
 545      * Determines if verification is enabled in the current scope.
 546      *
 547      * @see DebugContext#verify(Object, String)
 548      */
 549     public boolean isVerifyEnabled() {
 550         return currentScope != null &amp;&amp; currentScope.isVerifyEnabled();
 551     }
 552 
 553     public boolean isCountEnabled() {
 554         return currentScope != null &amp;&amp; currentScope.isCountEnabled();
 555     }
 556 
 557     public boolean isTimeEnabled() {
 558         return currentScope != null &amp;&amp; currentScope.isTimeEnabled();
 559     }
 560 
 561     public boolean isMemUseTrackingEnabled() {
 562         return currentScope != null &amp;&amp; currentScope.isMemUseTrackingEnabled();
 563     }
 564 
 565     public boolean isDumpEnabledForMethod() {
 566         if (currentConfig == null) {
 567             return false;
 568         }
 569         return currentConfig.isDumpEnabledForMethod(currentScope);
 570     }
 571 
 572     public boolean isLogEnabledForMethod() {
 573         if (currentScope == null) {
 574             return false;
 575         }
 576         if (currentConfig == null) {
 577             return false;
 578         }
 579         return currentConfig.isLogEnabledForMethod(currentScope);
 580     }
 581 
 582     public boolean isLogEnabled() {
 583         return currentScope != null &amp;&amp; isLogEnabled(BASIC_LEVEL);
 584     }
 585 
 586     public boolean isLogEnabled(int logLevel) {
 587         return currentScope != null &amp;&amp; currentScope.isLogEnabled(logLevel);
 588     }
 589 
 590     /**
 591      * Gets a string composed of the names in the current nesting of debug
 592      * {@linkplain #scope(Object) scopes} separated by {@code &#39;.&#39;}.
 593      */
 594     public String getCurrentScopeName() {
 595         if (currentScope != null) {
 596             return currentScope.getQualifiedName();
 597         } else {
 598             return &quot;&quot;;
 599         }
 600     }
 601 
 602     /**
 603      * Creates and enters a new debug scope which will be a child of the current debug scope.
 604      * &lt;p&gt;
 605      * It is recommended to use the try-with-resource statement for managing entering and leaving
 606      * debug scopes. For example:
 607      *
 608      * &lt;pre&gt;
 609      * try (Scope s = Debug.scope(&amp;quot;InliningGraph&amp;quot;, inlineeGraph)) {
 610      *     ...
 611      * } catch (Throwable e) {
 612      *     throw Debug.handle(e);
 613      * }
 614      * &lt;/pre&gt;
 615      *
 616      * The {@code name} argument is subject to the following type based conversion before having
 617      * {@link Object#toString()} called on it:
 618      *
 619      * &lt;pre&gt;
 620      *     Type          | Conversion
 621      * ------------------+-----------------
 622      *  java.lang.Class  | arg.getSimpleName()
 623      *                   |
 624      * &lt;/pre&gt;
 625      *
 626      * @param name the name of the new scope
 627      * @param contextObjects an array of object to be appended to the {@linkplain #context()
 628      *            current} debug context
 629      * @throws Throwable used to enforce a catch block.
 630      * @return the scope entered by this method which will be exited when its {@link Scope#close()}
 631      *         method is called
 632      */
 633     public DebugContext.Scope scope(Object name, Object[] contextObjects) throws Throwable {
 634         if (currentScope != null) {
 635             return enterScope(convertFormatArg(name).toString(), null, contextObjects);
 636         } else {
 637             return null;
 638         }
 639     }
 640 
 641     /**
 642      * Similar to {@link #scope(Object, Object[])} but without context objects. Therefore the catch
 643      * block can be omitted.
 644      *
 645      * @see #scope(Object, Object[])
 646      */
 647     public DebugContext.Scope scope(Object name) {
 648         if (currentScope != null) {
 649             return enterScope(convertFormatArg(name).toString(), null);
 650         } else {
 651             return null;
 652         }
 653     }
 654 
 655     private final Invariants invariants = Assertions.assertionsEnabled() ? new Invariants() : null;
 656 
 657     static StackTraceElement[] getStackTrace(Thread thread) {
 658         return thread.getStackTrace();
 659     }
 660 
 661     /**
 662      * Utility for enforcing {@link DebugContext} invariants via assertions.
 663      */
 664     static class Invariants {
 665         private final Thread thread;
 666         private final StackTraceElement[] origin;
 667 
 668         Invariants() {
 669             thread = Thread.currentThread();
 670             origin = getStackTrace(thread);
 671         }
 672 
 673         boolean checkNoConcurrentAccess() {
 674             Thread currentThread = Thread.currentThread();
 675             if (currentThread != thread) {
 676                 Formatter buf = new Formatter();
 677                 buf.format(&quot;Thread local %s object was created on thread %s but is being accessed by thread %s. The most likely cause is &quot; +
 678                                 &quot;that the object is being retrieved from a non-thread-local cache.&quot;,
 679                                 DebugContext.class.getName(), thread, currentThread);
 680                 int debugContextConstructors = 0;
 681                 boolean addedHeader = false;
 682                 for (StackTraceElement e : origin) {
 683                     if (e.getMethodName().equals(&quot;&lt;init&gt;&quot;) &amp;&amp; e.getClassName().equals(DebugContext.class.getName())) {
 684                         debugContextConstructors++;
 685                     } else if (debugContextConstructors != 0) {
 686                         if (!addedHeader) {
 687                             addedHeader = true;
 688                             buf.format(&quot; The object was instantiated here:&quot;);
 689                         }
 690                         // Distinguish from assertion stack trace by using double indent and
 691                         // &quot;in&quot; instead of &quot;at&quot; prefix.
 692                         buf.format(&quot;%n\t\tin %s&quot;, e);
 693                     }
 694                 }
 695                 if (addedHeader) {
 696                     buf.format(&quot;%n&quot;);
 697                 }
 698 
 699                 throw new AssertionError(buf.toString());
 700             }
 701             return true;
 702         }
 703     }
 704 
 705     boolean checkNoConcurrentAccess() {
 706         assert invariants == null || invariants.checkNoConcurrentAccess();
 707         return true;
 708     }
 709 
 710     private DebugContext.Scope enterScope(CharSequence name, DebugConfig sandboxConfig, Object... newContextObjects) {
 711         assert checkNoConcurrentAccess();
 712         currentScope = currentScope.scope(name, sandboxConfig, newContextObjects);
 713         return currentScope;
 714     }
 715 
 716     /**
 717      * @see #scope(Object, Object[])
 718      * @param context an object to be appended to the {@linkplain #context() current} debug context
 719      */
 720     public DebugContext.Scope scope(Object name, Object context) throws Throwable {
 721         if (currentScope != null) {
 722             return enterScope(convertFormatArg(name).toString(), null, context);
 723         } else {
 724             return null;
 725         }
 726     }
 727 
 728     /**
 729      * @see #scope(Object, Object[])
 730      * @param context1 first object to be appended to the {@linkplain #context() current} debug
 731      *            context
 732      * @param context2 second object to be appended to the {@linkplain #context() current} debug
 733      *            context
 734      */
 735     public DebugContext.Scope scope(Object name, Object context1, Object context2) throws Throwable {
 736         if (currentScope != null) {
 737             return enterScope(convertFormatArg(name).toString(), null, context1, context2);
 738         } else {
 739             return null;
 740         }
 741     }
 742 
 743     /**
 744      * @see #scope(Object, Object[])
 745      * @param context1 first object to be appended to the {@linkplain #context() current} debug
 746      *            context
 747      * @param context2 second object to be appended to the {@linkplain #context() current} debug
 748      *            context
 749      * @param context3 third object to be appended to the {@linkplain #context() current} debug
 750      *            context
 751      */
 752     public DebugContext.Scope scope(Object name, Object context1, Object context2, Object context3) throws Throwable {
 753         if (currentScope != null) {
 754             return enterScope(convertFormatArg(name).toString(), null, context1, context2, context3);
 755         } else {
 756             return null;
 757         }
 758     }
 759 
 760     /**
 761      * Create an unnamed scope that appends some context to the current scope.
 762      *
 763      * @param context an object to be appended to the {@linkplain #context() current} debug context
 764      */
 765     public DebugContext.Scope withContext(Object context) throws Throwable {
 766         if (currentScope != null) {
 767             return enterScope(&quot;&quot;, null, context);
 768         } else {
 769             return null;
 770         }
 771     }
 772 
 773     /**
 774      * Creates and enters a new debug scope which will be disjoint from the current debug scope.
 775      * &lt;p&gt;
 776      * It is recommended to use the try-with-resource statement for managing entering and leaving
 777      * debug scopes. For example:
 778      *
 779      * &lt;pre&gt;
 780      * try (Scope s = Debug.sandbox(&amp;quot;CompilingStub&amp;quot;, null, stubGraph)) {
 781      *     ...
 782      * } catch (Throwable e) {
 783      *     throw Debug.handle(e);
 784      * }
 785      * &lt;/pre&gt;
 786      *
 787      * @param name the name of the new scope
 788      * @param config the debug configuration to use for the new scope or {@code null} to disable the
 789      *            scoping mechanism within the sandbox scope
 790      * @param context objects to be appended to the {@linkplain #context() current} debug context
 791      * @return the scope entered by this method which will be exited when its {@link Scope#close()}
 792      *         method is called
 793      */
 794     public DebugContext.Scope sandbox(CharSequence name, DebugConfig config, Object... context) throws Throwable {
 795         if (config == null) {
 796             return disable();
 797         }
 798         if (currentScope != null) {
 799             return enterScope(name, config, context);
 800         } else {
 801             return null;
 802         }
 803     }
 804 
 805     /**
 806      * Determines if scopes are enabled and this context is in a non-top-level scope.
 807      */
 808     public boolean inNestedScope() {
 809         if (immutable.scopesEnabled) {
 810             if (currentScope == null) {
 811                 // In an active DisabledScope
 812                 return true;
 813             }
 814             return !currentScope.isTopLevel();
 815         } else {
 816             return false;
 817         }
 818     }
 819 
 820     class DisabledScope implements DebugContext.Scope {
 821         final boolean savedMetricsEnabled;
 822         final ScopeImpl savedScope;
 823         final DebugConfigImpl savedConfig;
 824 
 825         DisabledScope() {
 826             this.savedMetricsEnabled = metricsEnabled;
 827             this.savedScope = currentScope;
 828             this.savedConfig = currentConfig;
 829             metricsEnabled = false;
 830             currentScope = null;
 831             currentConfig = null;
 832         }
 833 
 834         @Override
 835         public String getQualifiedName() {
 836             return &quot;&quot;;
 837         }
 838 
 839         @Override
 840         public Iterable&lt;Object&gt; getCurrentContext() {
 841             return Collections.emptyList();
 842         }
 843 
 844         @Override
 845         public void close() {
 846             metricsEnabled = savedMetricsEnabled;
 847             currentScope = savedScope;
 848             currentConfig = savedConfig;
 849             lastClosedScope = this;
 850         }
 851     }
 852 
 853     /**
 854      * Disables all metrics and scope related functionality until {@code close()} is called on the
 855      * returned object.
 856      */
 857     public DebugContext.Scope disable() {
 858         if (currentScope != null) {
 859             return new DisabledScope();
 860         } else {
 861             return null;
 862         }
 863     }
 864 
 865     public DebugContext.Scope forceLog() throws Throwable {
 866         if (currentConfig != null) {
 867             ArrayList&lt;Object&gt; context = new ArrayList&lt;&gt;();
 868             for (Object obj : context()) {
 869                 context.add(obj);
 870             }
 871             DebugConfigImpl config = new DebugConfigImpl(new OptionValues(currentConfig.getOptions(), DebugOptions.Log, &quot;:1000&quot;));
 872             return sandbox(&quot;forceLog&quot;, config, context.toArray());
 873         }
 874         return null;
 875     }
 876 
 877     /**
 878      * Opens a scope in which exception
 879      * {@linkplain DebugConfig#interceptException(DebugContext, Throwable) interception} is
 880      * disabled. The current state of interception is restored when {@link DebugCloseable#close()}
 881      * is called on the returned object.
 882      *
 883      * This is particularly useful to suppress extraneous output in JUnit tests that are expected to
 884      * throw an exception.
 885      */
 886     public DebugCloseable disableIntercept() {
 887         if (currentScope != null) {
 888             return currentScope.disableIntercept();
 889         }
 890         return null;
 891     }
 892 
 893     /**
 894      * Handles an exception in the context of the debug scope just exited. The just exited scope
 895      * must have the current scope as its parent which will be the case if the try-with-resource
 896      * pattern recommended by {@link #scope(Object)} and
 897      * {@link #sandbox(CharSequence, DebugConfig, Object...)} is used
 898      *
 899      * @see #scope(Object, Object[])
 900      * @see #sandbox(CharSequence, DebugConfig, Object...)
 901      */
 902     public RuntimeException handle(Throwable exception) {
 903         if (currentScope != null) {
 904             return currentScope.handle(exception);
 905         } else {
 906             if (exception instanceof Error) {
 907                 throw (Error) exception;
 908             }
 909             if (exception instanceof RuntimeException) {
 910                 throw (RuntimeException) exception;
 911             }
 912             throw new RuntimeException(exception);
 913         }
 914     }
 915 
 916     public void log(String msg) {
 917         log(BASIC_LEVEL, msg);
 918     }
 919 
 920     /**
 921      * Prints a message to the current debug scope&#39;s logging stream if logging is enabled.
 922      *
 923      * @param msg the message to log
 924      */
 925     public void log(int logLevel, String msg) {
 926         if (currentScope != null) {
 927             currentScope.log(logLevel, msg);
 928         }
 929     }
 930 
 931     public void log(String format, Object arg) {
 932         log(BASIC_LEVEL, format, arg);
 933     }
 934 
 935     /**
 936      * Prints a message to the current debug scope&#39;s logging stream if logging is enabled.
 937      *
 938      * @param format a format string
 939      * @param arg the argument referenced by the format specifiers in {@code format}
 940      */
 941     public void log(int logLevel, String format, Object arg) {
 942         if (currentScope != null) {
 943             currentScope.log(logLevel, format, arg);
 944         }
 945     }
 946 
 947     public void log(String format, int arg) {
 948         log(BASIC_LEVEL, format, arg);
 949     }
 950 
 951     /**
 952      * Prints a message to the current debug scope&#39;s logging stream if logging is enabled.
 953      *
 954      * @param format a format string
 955      * @param arg the argument referenced by the format specifiers in {@code format}
 956      */
 957     public void log(int logLevel, String format, int arg) {
 958         if (currentScope != null) {
 959             currentScope.log(logLevel, format, arg);
 960         }
 961     }
 962 
 963     public void log(String format, Object arg1, Object arg2) {
 964         log(BASIC_LEVEL, format, arg1, arg2);
 965     }
 966 
 967     /**
 968      * @see #log(int, String, Object)
 969      */
 970     public void log(int logLevel, String format, Object arg1, Object arg2) {
 971         if (currentScope != null) {
 972             currentScope.log(logLevel, format, arg1, arg2);
 973         }
 974     }
 975 
 976     public void log(String format, int arg1, Object arg2) {
 977         log(BASIC_LEVEL, format, arg1, arg2);
 978     }
 979 
 980     /**
 981      * @see #log(int, String, Object)
 982      */
 983     public void log(int logLevel, String format, int arg1, Object arg2) {
 984         if (currentScope != null) {
 985             currentScope.log(logLevel, format, arg1, arg2);
 986         }
 987     }
 988 
 989     public void log(String format, Object arg1, int arg2) {
 990         log(BASIC_LEVEL, format, arg1, arg2);
 991     }
 992 
 993     /**
 994      * @see #log(int, String, Object)
 995      */
 996     public void log(int logLevel, String format, Object arg1, int arg2) {
 997         if (currentScope != null) {
 998             currentScope.log(logLevel, format, arg1, arg2);
 999         }
1000     }
1001 
1002     public void log(String format, int arg1, int arg2) {
1003         log(BASIC_LEVEL, format, arg1, arg2);
1004     }
1005 
1006     /**
1007      * @see #log(int, String, Object)
1008      */
1009     public void log(int logLevel, String format, int arg1, int arg2) {
1010         if (currentScope != null) {
1011             currentScope.log(logLevel, format, arg1, arg2);
1012         }
1013     }
1014 
1015     public void log(String format, Object arg1, Object arg2, Object arg3) {
1016         log(BASIC_LEVEL, format, arg1, arg2, arg3);
1017     }
1018 
1019     /**
1020      * @see #log(int, String, Object)
1021      */
1022     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3) {
1023         if (currentScope != null) {
1024             currentScope.log(logLevel, format, arg1, arg2, arg3);
1025         }
1026     }
1027 
1028     public void log(String format, int arg1, int arg2, int arg3) {
1029         log(BASIC_LEVEL, format, arg1, arg2, arg3);
1030     }
1031 
1032     /**
1033      * @see #log(int, String, Object)
1034      */
1035     public void log(int logLevel, String format, int arg1, int arg2, int arg3) {
1036         if (currentScope != null) {
1037             currentScope.log(logLevel, format, arg1, arg2, arg3);
1038         }
1039     }
1040 
1041     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4) {
1042         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4);
1043     }
1044 
1045     /**
1046      * @see #log(int, String, Object)
1047      */
1048     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4) {
1049         if (currentScope != null) {
1050             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4);
1051         }
1052     }
1053 
1054     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {
1055         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5);
1056     }
1057 
1058     /**
1059      * @see #log(int, String, Object)
1060      */
1061     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {
1062         if (currentScope != null) {
1063             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5);
1064         }
1065     }
1066 
1067     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6) {
1068         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6);
1069     }
1070 
1071     /**
1072      * @see #log(int, String, Object)
1073      */
1074     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6) {
1075         if (currentScope != null) {
1076             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6);
1077         }
1078     }
1079 
1080     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7) {
1081         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
1082     }
1083 
1084     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8) {
1085         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
1086     }
1087 
1088     /**
1089      * @see #log(int, String, Object)
1090      */
1091     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7) {
1092         if (currentScope != null) {
1093             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
1094         }
1095     }
1096 
1097     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8) {
1098         if (currentScope != null) {
1099             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
1100         }
1101     }
1102 
1103     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8, Object arg9) {
1104         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
1105     }
1106 
1107     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8, Object arg9) {
1108         if (currentScope != null) {
1109             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
1110         }
1111     }
1112 
1113     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8, Object arg9, Object arg10) {
1114         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
1115     }
1116 
1117     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8, Object arg9, Object arg10) {
1118         if (currentScope != null) {
1119             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
1120         }
1121     }
1122 
1123     public void logv(String format, Object... args) {
1124         logv(BASIC_LEVEL, format, args);
1125     }
1126 
1127     /**
1128      * Prints a message to the current debug scope&#39;s logging stream. This method must only be called
1129      * if debugging scopes are {@linkplain DebugContext#areScopesEnabled() enabled} as it incurs
1130      * allocation at the call site. If possible, call one of the other {@code log()} methods in this
1131      * class that take a fixed number of parameters.
1132      *
1133      * @param format a format string
1134      * @param args the arguments referenced by the format specifiers in {@code format}
1135      */
1136     public void logv(int logLevel, String format, Object... args) {
1137         if (currentScope == null) {
1138             throw new InternalError(&quot;Use of Debug.logv() must be guarded by a test of Debug.isEnabled()&quot;);
1139         }
1140         currentScope.log(logLevel, format, args);
1141     }
1142 
1143     /**
1144      * This override exists to catch cases when {@link #log(String, Object)} is called with one
1145      * argument bound to a varargs method parameter. It will bind to this method instead of the
1146      * single arg variant and produce a deprecation warning instead of silently wrapping the
1147      * Object[] inside of another Object[].
1148      */
1149     @Deprecated
1150     public void log(String format, Object[] args) {
1151         assert false : &quot;shouldn&#39;t use this&quot;;
1152         log(BASIC_LEVEL, format, args);
1153     }
1154 
1155     /**
1156      * This override exists to catch cases when {@link #log(int, String, Object)} is called with one
1157      * argument bound to a varargs method parameter. It will bind to this method instead of the
1158      * single arg variant and produce a deprecation warning instead of silently wrapping the
1159      * Object[] inside of another Object[].
1160      */
1161     @Deprecated
1162     public void log(int logLevel, String format, Object[] args) {
1163         assert false : &quot;shouldn&#39;t use this&quot;;
1164         logv(logLevel, format, args);
1165     }
1166 
1167     /**
1168      * Forces an unconditional dump. This method exists mainly for debugging. It can also be used to
1169      * force a graph dump from IDEs that support invoking a Java method while at a breakpoint.
1170      */
1171     public void forceDump(Object object, String format, Object... args) {
1172         DebugConfig config = currentConfig;
1173         Collection&lt;DebugDumpHandler&gt; dumpHandlers;
1174         boolean closeAfterDump;
1175         if (config != null) {
1176             dumpHandlers = config.dumpHandlers();
1177             closeAfterDump = false;
1178         } else {
1179             OptionValues options = getOptions();
1180             dumpHandlers = new ArrayList&lt;&gt;();
1181             for (DebugHandlersFactory factory : DebugHandlersFactory.LOADER) {
1182                 for (DebugHandler handler : factory.createHandlers(options)) {
1183                     if (handler instanceof DebugDumpHandler) {
1184                         dumpHandlers.add((DebugDumpHandler) handler);
1185                     }
1186                 }
1187             }
1188             closeAfterDump = true;
1189         }
1190         for (DebugDumpHandler dumpHandler : dumpHandlers) {
1191             dumpHandler.dump(this, object, format, args);
1192             if (closeAfterDump) {
1193                 dumpHandler.close();
1194             }
1195         }
1196     }
1197 
1198     public void dump(int dumpLevel, Object object, String msg) {
1199         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1200             currentScope.dump(dumpLevel, object, msg);
1201         }
1202     }
1203 
1204     public void dump(int dumpLevel, Object object, String format, Object arg) {
1205         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1206             currentScope.dump(dumpLevel, object, format, arg);
1207         }
1208     }
1209 
1210     public void dump(int dumpLevel, Object object, String format, Object arg1, Object arg2) {
1211         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1212             currentScope.dump(dumpLevel, object, format, arg1, arg2);
1213         }
1214     }
1215 
1216     public void dump(int dumpLevel, Object object, String format, Object arg1, Object arg2, Object arg3) {
1217         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1218             currentScope.dump(dumpLevel, object, format, arg1, arg2, arg3);
1219         }
1220     }
1221 
1222     /**
1223      * This override exists to catch cases when {@link #dump(int, Object, String, Object)} is called
1224      * with one argument bound to a varargs method parameter. It will bind to this method instead of
1225      * the single arg variant and produce a deprecation warning instead of silently wrapping the
1226      * Object[] inside of another Object[].
1227      */
1228     @Deprecated
1229     public void dump(int dumpLevel, Object object, String format, Object[] args) {
1230         assert false : &quot;shouldn&#39;t use this&quot;;
1231         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1232             currentScope.dump(dumpLevel, object, format, args);
1233         }
1234     }
1235 
1236     /**
1237      * Calls all {@link DebugVerifyHandler}s in the current {@linkplain #getConfig() config} to
1238      * perform verification on a given object.
1239      *
1240      * @param object object to verify
1241      * @param message description of verification context
1242      *
1243      * @see DebugVerifyHandler#verify
1244      */
1245     public void verify(Object object, String message) {
1246         if (currentScope != null &amp;&amp; currentScope.isVerifyEnabled()) {
1247             currentScope.verify(object, message);
1248         }
1249     }
1250 
1251     /**
1252      * Calls all {@link DebugVerifyHandler}s in the current {@linkplain #getConfig() config} to
1253      * perform verification on a given object.
1254      *
1255      * @param object object to verify
1256      * @param format a format string for the description of the verification context
1257      * @param arg the argument referenced by the format specifiers in {@code format}
1258      *
1259      * @see DebugVerifyHandler#verify
1260      */
1261     public void verify(Object object, String format, Object arg) {
1262         if (currentScope != null &amp;&amp; currentScope.isVerifyEnabled()) {
1263             currentScope.verify(object, format, arg);
1264         }
1265     }
1266 
1267     /**
1268      * This override exists to catch cases when {@link #verify(Object, String, Object)} is called
1269      * with one argument bound to a varargs method parameter. It will bind to this method instead of
1270      * the single arg variant and produce a deprecation warning instead of silently wrapping the
1271      * Object[] inside of another Object[].
1272      */
1273     @Deprecated
1274     public void verify(Object object, String format, Object[] args) {
1275         assert false : &quot;shouldn&#39;t use this&quot;;
1276         if (currentScope != null &amp;&amp; currentScope.isVerifyEnabled()) {
1277             currentScope.verify(object, format, args);
1278         }
1279     }
1280 
1281     /**
1282      * Opens a new indentation level (by adding some spaces) based on the current indentation level.
1283      * This should be used in a {@linkplain Indent try-with-resources} pattern.
1284      *
1285      * @return an object that reverts to the current indentation level when
1286      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1287      * @see #logAndIndent(int, String)
1288      * @see #logAndIndent(int, String, Object)
1289      */
1290     public Indent indent() {
1291         if (currentScope != null) {
1292             return currentScope.pushIndentLogger();
1293         }
1294         return null;
1295     }
1296 
1297     public Indent logAndIndent(String msg) {
1298         return logAndIndent(BASIC_LEVEL, msg);
1299     }
1300 
1301     /**
1302      * A convenience function which combines {@link #log(String)} and {@link #indent()}.
1303      *
1304      * @param msg the message to log
1305      * @return an object that reverts to the current indentation level when
1306      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1307      */
1308     public Indent logAndIndent(int logLevel, String msg) {
1309         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1310             return logvAndIndentInternal(logLevel, msg);
1311         }
1312         return null;
1313     }
1314 
1315     public Indent logAndIndent(String format, Object arg) {
1316         return logAndIndent(BASIC_LEVEL, format, arg);
1317     }
1318 
1319     /**
1320      * A convenience function which combines {@link #log(String, Object)} and {@link #indent()}.
1321      *
1322      * @param format a format string
1323      * @param arg the argument referenced by the format specifiers in {@code format}
1324      * @return an object that reverts to the current indentation level when
1325      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1326      */
1327     public Indent logAndIndent(int logLevel, String format, Object arg) {
1328         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1329             return logvAndIndentInternal(logLevel, format, arg);
1330         }
1331         return null;
1332     }
1333 
1334     public Indent logAndIndent(String format, int arg) {
1335         return logAndIndent(BASIC_LEVEL, format, arg);
1336     }
1337 
1338     /**
1339      * A convenience function which combines {@link #log(String, Object)} and {@link #indent()}.
1340      *
1341      * @param format a format string
1342      * @param arg the argument referenced by the format specifiers in {@code format}
1343      * @return an object that reverts to the current indentation level when
1344      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1345      */
1346     public Indent logAndIndent(int logLevel, String format, int arg) {
1347         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1348             return logvAndIndentInternal(logLevel, format, arg);
1349         }
1350         return null;
1351     }
1352 
1353     public Indent logAndIndent(String format, int arg1, Object arg2) {
1354         return logAndIndent(BASIC_LEVEL, format, arg1, arg2);
1355     }
1356 
1357     /**
1358      * @see #logAndIndent(int, String, Object)
1359      */
1360     public Indent logAndIndent(int logLevel, String format, int arg1, Object arg2) {
1361         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1362             return logvAndIndentInternal(logLevel, format, arg1, arg2);
1363         }
1364         return null;
1365     }
1366 
1367     public Indent logAndIndent(String format, Object arg1, int arg2) {
1368         return logAndIndent(BASIC_LEVEL, format, arg1, arg2);
1369     }
1370 
1371     /**
1372      * @see #logAndIndent(int, String, Object)
1373      */
1374     public Indent logAndIndent(int logLevel, String format, Object arg1, int arg2) {
1375         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1376             return logvAndIndentInternal(logLevel, format, arg1, arg2);
1377         }
1378         return null;
1379     }
1380 
1381     public Indent logAndIndent(String format, int arg1, int arg2) {
1382         return logAndIndent(BASIC_LEVEL, format, arg1, arg2);
1383     }
1384 
1385     /**
1386      * @see #logAndIndent(int, String, Object)
1387      */
1388     public Indent logAndIndent(int logLevel, String format, int arg1, int arg2) {
1389         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1390             return logvAndIndentInternal(logLevel, format, arg1, arg2);
1391         }
1392         return null;
1393     }
1394 
1395     public Indent logAndIndent(String format, Object arg1, Object arg2) {
1396         return logAndIndent(BASIC_LEVEL, format, arg1, arg2);
1397     }
1398 
1399     /**
1400      * @see #logAndIndent(int, String, Object)
1401      */
1402     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2) {
1403         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1404             return logvAndIndentInternal(logLevel, format, arg1, arg2);
1405         }
1406         return null;
1407     }
1408 
1409     public Indent logAndIndent(String format, Object arg1, Object arg2, Object arg3) {
1410         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3);
1411     }
1412 
1413     /**
1414      * @see #logAndIndent(int, String, Object)
1415      */
1416     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2, Object arg3) {
1417         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1418             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3);
1419         }
1420         return null;
1421     }
1422 
1423     public Indent logAndIndent(String format, int arg1, int arg2, int arg3) {
1424         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3);
1425     }
1426 
1427     /**
1428      * @see #logAndIndent(int, String, Object)
1429      */
1430     public Indent logAndIndent(int logLevel, String format, int arg1, int arg2, int arg3) {
1431         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1432             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3);
1433         }
1434         return null;
1435     }
1436 
1437     public Indent logAndIndent(String format, Object arg1, int arg2, int arg3) {
1438         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3);
1439     }
1440 
1441     /**
1442      * @see #logAndIndent(int, String, Object)
1443      */
1444     public Indent logAndIndent(int logLevel, String format, Object arg1, int arg2, int arg3) {
1445         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1446             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3);
1447         }
1448         return null;
1449     }
1450 
1451     public Indent logAndIndent(String format, Object arg1, Object arg2, Object arg3, Object arg4) {
1452         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3, arg4);
1453     }
1454 
1455     /**
1456      * @see #logAndIndent(int, String, Object)
1457      */
1458     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4) {
1459         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1460             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3, arg4);
1461         }
1462         return null;
1463     }
1464 
1465     public Indent logAndIndent(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {
1466         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5);
1467     }
1468 
1469     /**
1470      * @see #logAndIndent(int, String, Object)
1471      */
1472     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {
1473         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1474             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3, arg4, arg5);
1475         }
1476         return null;
1477     }
1478 
1479     public Indent logAndIndent(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6) {
1480         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6);
1481     }
1482 
1483     /**
1484      * @see #logAndIndent(int, String, Object)
1485      */
1486     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6) {
1487         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1488             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6);
1489         }
1490         return null;
1491     }
1492 
1493     /**
1494      * A convenience function which combines {@link #logv(int, String, Object...)} and
1495      * {@link #indent()}.
1496      *
1497      * @param format a format string
1498      * @param args the arguments referenced by the format specifiers in {@code format}
1499      * @return an object that reverts to the current indentation level when
1500      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1501      */
1502     public Indent logvAndIndent(int logLevel, String format, Object... args) {
1503         if (currentScope != null) {
1504             if (isLogEnabled(logLevel)) {
1505                 return logvAndIndentInternal(logLevel, format, args);
1506             }
1507             return null;
1508         }
1509         throw new InternalError(&quot;Use of Debug.logvAndIndent() must be guarded by a test of Debug.isEnabled()&quot;);
1510     }
1511 
1512     private Indent logvAndIndentInternal(int logLevel, String format, Object... args) {
1513         assert currentScope != null &amp;&amp; isLogEnabled(logLevel) : &quot;must have checked Debug.isLogEnabled()&quot;;
1514         currentScope.log(logLevel, format, args);
1515         return currentScope.pushIndentLogger();
1516     }
1517 
1518     /**
1519      * This override exists to catch cases when {@link #logAndIndent(String, Object)} is called with
1520      * one argument bound to a varargs method parameter. It will bind to this method instead of the
1521      * single arg variant and produce a deprecation warning instead of silently wrapping the
1522      * Object[] inside of another Object[].
1523      */
1524     @Deprecated
1525     public void logAndIndent(String format, Object[] args) {
1526         assert false : &quot;shouldn&#39;t use this&quot;;
1527         logAndIndent(BASIC_LEVEL, format, args);
1528     }
1529 
1530     /**
1531      * This override exists to catch cases when {@link #logAndIndent(int, String, Object)} is called
1532      * with one argument bound to a varargs method parameter. It will bind to this method instead of
1533      * the single arg variant and produce a deprecation warning instead of silently wrapping the
1534      * Object[] inside of another Object[].
1535      */
1536     @Deprecated
1537     public void logAndIndent(int logLevel, String format, Object[] args) {
1538         assert false : &quot;shouldn&#39;t use this&quot;;
1539         logvAndIndent(logLevel, format, args);
1540     }
1541 
1542     public Iterable&lt;Object&gt; context() {
1543         if (currentScope != null) {
1544             return currentScope.getCurrentContext();
1545         } else {
1546             return Collections.emptyList();
1547         }
1548     }
1549 
1550     @SuppressWarnings(&quot;unchecked&quot;)
1551     public &lt;T&gt; List&lt;T&gt; contextSnapshot(Class&lt;T&gt; clazz) {
1552         if (currentScope != null) {
1553             List&lt;T&gt; result = new ArrayList&lt;&gt;();
1554             for (Object o : context()) {
1555                 if (clazz.isInstance(o)) {
1556                     result.add((T) o);
1557                 }
1558             }
1559             return result;
1560         } else {
1561             return Collections.emptyList();
1562         }
1563     }
1564 
1565     /**
1566      * Searches the current debug scope, bottom up, for a context object that is an instance of a
1567      * given type. The first such object found is returned.
1568      */
1569     @SuppressWarnings(&quot;unchecked&quot;)
1570     public &lt;T&gt; T contextLookup(Class&lt;T&gt; clazz) {
1571         if (currentScope != null) {
1572             for (Object o : context()) {
1573                 if (clazz.isInstance(o)) {
1574                     return ((T) o);
1575                 }
1576             }
1577         }
1578         return null;
1579     }
1580 
1581     /**
1582      * Searches the current debug scope, top down, for a context object that is an instance of a
1583      * given type. The first such object found is returned.
1584      */
1585     @SuppressWarnings(&quot;unchecked&quot;)
1586     public &lt;T&gt; T contextLookupTopdown(Class&lt;T&gt; clazz) {
1587         if (currentScope != null) {
1588             T found = null;
1589             for (Object o : context()) {
1590                 if (clazz.isInstance(o)) {
1591                     found = (T) o;
1592                 }
1593             }
1594             return found;
1595         }
1596         return null;
1597     }
1598 
1599     /**
1600      * Creates a {@linkplain MemUseTrackerKey memory use tracker}.
1601      */
1602     public static MemUseTrackerKey memUseTracker(CharSequence name) {
1603         return createMemUseTracker(&quot;%s&quot;, name, null);
1604     }
1605 
1606     /**
1607      * Creates a debug memory use tracker. Invoking this method is equivalent to:
1608      *
1609      * &lt;pre&gt;
1610      * Debug.memUseTracker(format, arg, null)
1611      * &lt;/pre&gt;
1612      *
1613      * except that the string formatting only happens if mem tracking is enabled.
1614      *
1615      * @see #counter(String, Object, Object)
1616      */
1617     public static MemUseTrackerKey memUseTracker(String format, Object arg) {
1618         return createMemUseTracker(format, arg, null);
1619     }
1620 
1621     /**
1622      * Creates a debug memory use tracker. Invoking this method is equivalent to:
1623      *
1624      * &lt;pre&gt;
1625      * Debug.memUseTracker(String.format(format, arg1, arg2))
1626      * &lt;/pre&gt;
1627      *
1628      * except that the string formatting only happens if memory use tracking is enabled. In
1629      * addition, each argument is subject to the following type based conversion before being passed
1630      * as an argument to {@link String#format(String, Object...)}:
1631      *
1632      * &lt;pre&gt;
1633      *     Type          | Conversion
1634      * ------------------+-----------------
1635      *  java.lang.Class  | arg.getSimpleName()
1636      *                   |
1637      * &lt;/pre&gt;
1638      *
1639      * @see #memUseTracker(CharSequence)
1640      */
1641     public static MemUseTrackerKey memUseTracker(String format, Object arg1, Object arg2) {
1642         return createMemUseTracker(format, arg1, arg2);
1643     }
1644 
1645     private static MemUseTrackerKey createMemUseTracker(String format, Object arg1, Object arg2) {
1646         return new MemUseTrackerKeyImpl(format, arg1, arg2);
1647     }
1648 
1649     /**
1650      * Creates a {@linkplain CounterKey counter}.
1651      */
1652     public static CounterKey counter(CharSequence name) {
1653         return createCounter(&quot;%s&quot;, name, null);
1654     }
1655 
1656     /**
1657      * Gets a tally of the metric values in this context and a given tally.
1658      *
1659      * @param tally the tally to which the metrics should be added
1660      * @return a tally of the metric values in this context and {@code tally}. This will be
1661      *         {@code tally} if this context has no metric values or {@code tally} is wide enough to
1662      *         hold all the metric values in this context otherwise it will be a new array.
1663      */
1664     public long[] addValuesTo(long[] tally) {
1665         if (metricValues == null) {
1666             return tally;
1667         }
1668         if (tally == null) {
1669             return metricValues.clone();
1670         } else if (metricValues.length &gt;= tally.length) {
1671             long[] newTally = metricValues.clone();
1672             for (int i = 0; i &lt; tally.length; i++) {
1673                 newTally[i] += tally[i];
1674             }
1675             return newTally;
1676         } else {
1677             for (int i = 0; i &lt; metricValues.length; i++) {
1678                 tally[i] += metricValues[i];
1679             }
1680             return tally;
1681         }
1682     }
1683 
1684     /**
1685      * Creates and returns a sorted map from metric names to their values in {@code values}.
1686      *
1687      * @param values values for metrics in the {@link KeyRegistry}.
1688      */
1689     public static EconomicMap&lt;MetricKey, Long&gt; convertValuesToKeyValueMap(long[] values) {
1690         List&lt;MetricKey&gt; keys = KeyRegistry.getKeys();
1691         Collections.sort(keys, MetricKey.NAME_COMPARATOR);
1692         EconomicMap&lt;MetricKey, Long&gt; res = EconomicMap.create(keys.size());
1693         for (MetricKey key : keys) {
1694             int index = ((AbstractKey) key).getIndex();
1695             if (index &gt;= values.length) {
1696                 res.put(key, 0L);
1697             } else {
1698                 res.put(key, values[index]);
1699             }
1700         }
1701         return res;
1702     }
1703 
1704     void setMetricValue(int keyIndex, long l) {
1705         ensureMetricValuesSize(keyIndex);
1706         metricValues[keyIndex] = l;
1707     }
1708 
1709     long getMetricValue(int keyIndex) {
1710         if (metricValues == null || metricValues.length &lt;= keyIndex) {
1711             return 0L;
1712         }
1713         return metricValues[keyIndex];
1714     }
1715 
1716     private void ensureMetricValuesSize(int index) {
1717         if (metricValues == null) {
1718             metricValues = new long[index + 1];
1719         }
1720         if (metricValues.length &lt;= index) {
1721             metricValues = Arrays.copyOf(metricValues, index + 1);
1722         }
1723     }
1724 
1725     public static String applyFormattingFlagsAndWidth(String s, int flags, int width) {
1726         if (flags == 0 &amp;&amp; width &lt; 0) {
1727             return s;
1728         }
1729         StringBuilder sb = new StringBuilder(s);
1730 
1731         // apply width and justification
1732         int len = sb.length();
1733         if (len &lt; width) {
1734             for (int i = 0; i &lt; width - len; i++) {
1735                 if ((flags &amp; LEFT_JUSTIFY) == LEFT_JUSTIFY) {
1736                     sb.append(&#39; &#39;);
1737                 } else {
1738                     sb.insert(0, &#39; &#39;);
1739                 }
1740             }
1741         }
1742 
1743         String res = sb.toString();
1744         if ((flags &amp; UPPERCASE) == UPPERCASE) {
1745             res = res.toUpperCase();
1746         }
1747         return res;
1748     }
1749 
1750     /**
1751      * Creates a debug counter. Invoking this method is equivalent to:
1752      *
1753      * &lt;pre&gt;
1754      * Debug.counter(format, arg, null)
1755      * &lt;/pre&gt;
1756      *
1757      * except that the string formatting only happens if count is enabled.
1758      *
1759      * @see #counter(String, Object, Object)
1760      */
1761     public static CounterKey counter(String format, Object arg) {
1762         return createCounter(format, arg, null);
1763     }
1764 
1765     /**
1766      * Creates a debug counter. Invoking this method is equivalent to:
1767      *
1768      * &lt;pre&gt;
1769      * Debug.counter(String.format(format, arg1, arg2))
1770      * &lt;/pre&gt;
1771      *
1772      * except that the string formatting only happens if count is enabled. In addition, each
1773      * argument is subject to the following type based conversion before being passed as an argument
1774      * to {@link String#format(String, Object...)}:
1775      *
1776      * &lt;pre&gt;
1777      *     Type          | Conversion
1778      * ------------------+-----------------
1779      *  java.lang.Class  | arg.getSimpleName()
1780      *                   |
1781      * &lt;/pre&gt;
1782      *
1783      * @see #counter(CharSequence)
1784      */
1785     public static CounterKey counter(String format, Object arg1, Object arg2) {
1786         return createCounter(format, arg1, arg2);
1787     }
1788 
1789     private static CounterKey createCounter(String format, Object arg1, Object arg2) {
1790         return new CounterKeyImpl(format, arg1, arg2);
1791     }
1792 
1793     public DebugConfig getConfig() {
1794         return currentConfig;
1795     }
1796 
1797     /**
1798      * Creates a {@linkplain TimerKey timer}.
1799      * &lt;p&gt;
1800      * A disabled timer has virtually no overhead.
1801      */
1802     public static TimerKey timer(CharSequence name) {
1803         return createTimer(&quot;%s&quot;, name, null);
1804     }
1805 
1806     /**
1807      * Creates a debug timer. Invoking this method is equivalent to:
1808      *
1809      * &lt;pre&gt;
1810      * Debug.timer(format, arg, null)
1811      * &lt;/pre&gt;
1812      *
1813      * except that the string formatting only happens if timing is enabled.
1814      *
1815      * @see #timer(String, Object, Object)
1816      */
1817     public static TimerKey timer(String format, Object arg) {
1818         return createTimer(format, arg, null);
1819     }
1820 
1821     /**
1822      * Creates a debug timer. Invoking this method is equivalent to:
1823      *
1824      * &lt;pre&gt;
1825      * Debug.timer(String.format(format, arg1, arg2))
1826      * &lt;/pre&gt;
1827      *
1828      * except that the string formatting only happens if timing is enabled. In addition, each
1829      * argument is subject to the following type based conversion before being passed as an argument
1830      * to {@link String#format(String, Object...)}:
1831      *
1832      * &lt;pre&gt;
1833      *     Type          | Conversion
1834      * ------------------+-----------------
1835      *  java.lang.Class  | arg.getSimpleName()
1836      *                   |
1837      * &lt;/pre&gt;
1838      *
1839      * @see #timer(CharSequence)
1840      */
1841     public static TimerKey timer(String format, Object arg1, Object arg2) {
1842         return createTimer(format, arg1, arg2);
1843     }
1844 
1845     /**
1846      * Gets the name to use for a class based on whether it appears to be an obfuscated name. The
1847      * heuristic for an obfuscated name is that it is less than 6 characters in length and consists
1848      * only of lower case letters.
1849      */
1850     private static String getBaseName(Class&lt;?&gt; c) {
1851         String simpleName = c.getSimpleName();
1852         if (simpleName.length() &lt; 6) {
1853             for (int i = 0; i &lt; simpleName.length(); i++) {
1854                 if (!Character.isLowerCase(simpleName.charAt(0))) {
1855                     return simpleName;
1856                 }
1857             }
1858             // Looks like an obfuscated simple class name so use qualified class name
1859             return c.getName();
1860         }
1861         return simpleName;
1862     }
1863 
1864     /**
1865      * There are paths where construction of formatted class names are common and the code below is
1866      * surprisingly expensive, so compute it once and cache it.
1867      */
1868     private static final ClassValue&lt;String&gt; formattedClassName = new ClassValue&lt;String&gt;() {
1869         @Override
1870         protected String computeValue(Class&lt;?&gt; c) {
1871             String baseName = getBaseName(c);
1872             if (Character.isLowerCase(baseName.charAt(0))) {
1873                 // Looks like an obfuscated simple class name so use qualified class name
1874                 baseName = c.getName();
1875             }
1876             Class&lt;?&gt; enclosingClass = c.getEnclosingClass();
1877             if (enclosingClass != null) {
1878                 String prefix = &quot;&quot;;
1879                 while (enclosingClass != null) {
1880                     prefix = getBaseName(enclosingClass) + &quot;_&quot; + prefix;
1881                     enclosingClass = enclosingClass.getEnclosingClass();
1882                 }
1883                 return prefix + baseName;
1884             } else {
1885                 return baseName;
1886             }
1887         }
1888     };
1889 
1890     public static Object convertFormatArg(Object arg) {
1891         if (arg instanceof Class) {
1892             return formattedClassName.get((Class&lt;?&gt;) arg);
1893         }
1894         return arg;
1895     }
1896 
1897     static String formatDebugName(String format, Object arg1, Object arg2) {
1898         return String.format(format, convertFormatArg(arg1), convertFormatArg(arg2));
1899     }
1900 
1901     private static TimerKey createTimer(String format, Object arg1, Object arg2) {
1902         return new TimerKeyImpl(format, arg1, arg2);
1903     }
1904 
1905     /**
1906      * Represents a debug scope entered by {@link DebugContext#scope(Object)} or
1907      * {@link DebugContext#sandbox(CharSequence, DebugConfig, Object...)}. Leaving the scope is
1908      * achieved via {@link #close()}.
1909      */
1910     public interface Scope extends AutoCloseable {
1911         /**
1912          * Gets the names of this scope and its ancestors separated by {@code &#39;.&#39;}.
1913          */
1914         String getQualifiedName();
1915 
1916         Iterable&lt;Object&gt; getCurrentContext();
1917 
1918         @Override
1919         void close();
1920     }
1921 
1922     boolean isTimerEnabled(TimerKeyImpl key) {
1923         if (!metricsEnabled) {
1924             // Pulling this common case out of `isTimerEnabledSlow`
1925             // gives C1 a better chance to inline this method.
1926             return false;
1927         }
1928         return isTimerEnabledSlow(key);
1929     }
1930 
1931     private boolean isTimerEnabledSlow(AbstractKey key) {
1932         if (currentScope != null &amp;&amp; currentScope.isTimeEnabled()) {
1933             return true;
1934         }
1935         if (immutable.listMetrics) {
1936             key.ensureInitialized();
1937         }
1938         assert checkNoConcurrentAccess();
1939         EconomicSet&lt;String&gt; unscoped = immutable.unscopedTimers;
1940         return unscoped != null &amp;&amp; (unscoped.isEmpty() || unscoped.contains(key.getName()));
1941     }
1942 
1943     /**
1944      * Determines if a given timer is enabled in the current scope.
1945      */
1946     boolean isCounterEnabled(CounterKeyImpl key) {
1947         if (!metricsEnabled) {
1948             // Pulling this common case out of `isCounterEnabledSlow`
1949             // gives C1 a better chance to inline this method.
1950             return false;
1951         }
1952         return isCounterEnabledSlow(key);
1953     }
1954 
1955     private boolean isCounterEnabledSlow(AbstractKey key) {
1956         if (currentScope != null &amp;&amp; currentScope.isCountEnabled()) {
1957             return true;
1958         }
1959         if (immutable.listMetrics) {
1960             key.ensureInitialized();
1961         }
1962         assert checkNoConcurrentAccess();
1963         EconomicSet&lt;String&gt; unscoped = immutable.unscopedCounters;
1964         return unscoped != null &amp;&amp; (unscoped.isEmpty() || unscoped.contains(key.getName()));
1965     }
1966 
1967     boolean isMemUseTrackerEnabled(MemUseTrackerKeyImpl key) {
1968         if (!metricsEnabled) {
1969             // Pulling this common case out of `isMemUseTrackerEnabledSlow`
1970             // gives C1 a better chance to inline this method.
1971             return false;
1972         }
1973         return isMemUseTrackerEnabledSlow(key);
1974     }
1975 
1976     private boolean isMemUseTrackerEnabledSlow(AbstractKey key) {
1977         if (currentScope != null &amp;&amp; currentScope.isMemUseTrackingEnabled()) {
1978             return true;
1979         }
1980         if (immutable.listMetrics) {
1981             key.ensureInitialized();
1982         }
1983         assert checkNoConcurrentAccess();
1984         EconomicSet&lt;String&gt; unscoped = immutable.unscopedMemUseTrackers;
1985         return unscoped != null &amp;&amp; (unscoped.isEmpty() || unscoped.contains(key.getName()));
1986     }
1987 
1988     public boolean areMetricsEnabled() {
1989         return metricsEnabled;
1990     }
1991 
1992     @Override
1993     public void close() {
1994         closeDumpHandlers(false);
1995         if (description != null) {
1996             printMetrics(description);
1997         }
1998         if (metricsEnabled &amp;&amp; metricValues != null &amp;&amp; globalMetrics != null) {
1999             globalMetrics.add(this);
2000         }
2001         metricValues = null;
2002         if (sharedChannel != null) {
2003             try {
2004                 sharedChannel.realClose();
2005             } catch (IOException ex) {
2006                 // ignore.
2007             }
2008         }
2009     }
2010 
2011     public void closeDumpHandlers(boolean ignoreErrors) {
2012         if (currentConfig != null) {
2013             currentConfig.closeDumpHandlers(ignoreErrors);
2014         }
2015     }
2016 
2017     /**
2018      * Records how many times a given method has been compiled.
2019      */
2020     private static EconomicMap&lt;Integer, Integer&gt; compilations;
2021 
2022     /**
2023      * Maintains maximum buffer size used by {@link #printMetrics(Description)} to minimize buffer
2024      * resizing during subsequent calls to this method.
2025      */
2026     private static int metricsBufSize = 50_000;
2027 
2028     /**
2029      * Flag that allows the first call to {@link #printMetrics(Description)} to delete the file that
2030      * will be appended to.
2031      */
2032     private static boolean metricsFileDeleteCheckPerformed;
2033 
2034     /**
2035      * Prints metric values in this object to the file (if any) specified by
2036      * {@link DebugOptions#MetricsFile}.
2037      */
2038     public void printMetrics(Description desc) {
2039         if (metricValues == null) {
2040             return;
2041         }
2042         String metricsFile = DebugOptions.MetricsFile.getValue(getOptions());
2043         if (metricsFile != null) {
2044             // Use identity to distinguish methods that have been redefined
2045             // or loaded by different class loaders.
2046             Object compilable = desc.compilable;
2047             Integer identity = System.identityHashCode(compilable);
2048             int compilationNr;
2049             synchronized (PRINT_METRICS_LOCK) {
2050                 if (!metricsFileDeleteCheckPerformed) {
2051                     metricsFileDeleteCheckPerformed = true;
2052                     File file = new File(metricsFile);
2053                     if (file.exists()) {
2054                         // This can return false in case something like /dev/stdout
2055                         // is specified. If the file is unwriteable, the file open
2056                         // below will fail.
2057                         file.delete();
2058                     }
2059                 }
2060                 if (compilations == null) {
2061                     compilationNr = 0;
2062                     compilations = EconomicMap.create();
2063                 } else {
2064                     Integer value = compilations.get(identity);
2065                     compilationNr = value == null ? 0 : value + 1;
2066                 }
2067                 compilations.put(identity, compilationNr);
2068             }
2069 
2070             // Release the lock while generating the content to reduce contention.
2071             // This means `compilationNr` fields may show up out of order in the file.
2072             ByteArrayOutputStream baos = new ByteArrayOutputStream(metricsBufSize);
2073             PrintStream out = new PrintStream(baos);
2074             if (metricsFile.endsWith(&quot;.csv&quot;) || metricsFile.endsWith(&quot;.CSV&quot;)) {
2075                 printMetricsCSV(out, compilable, identity, compilationNr, desc.identifier);
2076             } else {
2077                 printMetrics(out, compilable, identity, compilationNr, desc.identifier);
2078             }
2079 
2080             byte[] content = baos.toByteArray();
2081             Path path = Paths.get(metricsFile);
2082             synchronized (PRINT_METRICS_LOCK) {
2083                 metricsBufSize = Math.max(metricsBufSize, content.length);
2084                 try {
2085                     Files.write(path, content, StandardOpenOption.CREATE, StandardOpenOption.APPEND);
2086                 } catch (IOException e) {
2087                 }
2088             }
2089         }
2090     }
2091 
2092     /**
2093      * Lock to serialize writes to {@link DebugOptions#MetricsFile}.
2094      */
2095     private static final Object PRINT_METRICS_LOCK = new Object();
2096 
2097     /**
2098      * Appends metrics in CSV format to {@code out} for a single method compilation.
2099      *
2100      * @param identity the identity hash code of {@code compilable}
2101      * @param compilationNr where this compilation lies in the ordered sequence of all compilations
2102      *            identified by {@code identity}
2103      * @param compilationId the runtime issued identifier for the compilation
2104      */
2105     private void printMetricsCSV(PrintStream out, Object compilable, Integer identity, int compilationNr, String compilationId) {
2106         String compilableName = compilable instanceof JavaMethod ? ((JavaMethod) compilable).format(&quot;%H.%n(%p)%R&quot;) : String.valueOf(compilable);
2107         String csvFormat = CSVUtil.buildFormatString(&quot;%s&quot;, &quot;%s&quot;, &quot;%d&quot;, &quot;%s&quot;);
2108         String format = String.format(csvFormat, CSVUtil.Escape.escapeArgs(compilableName, identity, compilationNr, compilationId));
2109         char sep = CSVUtil.SEPARATOR;
2110         format += sep + &quot;%s&quot; + sep + &quot;%s&quot; + sep + &quot;%s&quot;;
2111         for (MetricKey key : KeyRegistry.getKeys()) {
2112             int index = ((AbstractKey) key).getIndex();
2113             if (index &lt; metricValues.length) {
2114                 Pair&lt;String, String&gt; valueAndUnit = key.toCSVFormat(metricValues[index]);
2115                 CSVUtil.Escape.println(out, format, CSVUtil.Escape.escape(key.getName()), valueAndUnit.getLeft(), valueAndUnit.getRight());
2116             }
2117         }
2118     }
2119 
2120     /**
2121      * Appends metrics in a human readable format to {@code out} for a single method compilation.
2122      *
2123      * @param identity the identity hash code of {@code compilable}
2124      * @param compilationNr where this compilation lies in the ordered sequence of all compilations
2125      *            identified by {@code identity}
2126      * @param compilationId the runtime issued identifier for the compilation
2127      */
2128     private void printMetrics(PrintStream out, Object compilable, Integer identity, int compilationNr, String compilationId) {
2129         String compilableName = compilable instanceof JavaMethod ? ((JavaMethod) compilable).format(&quot;%H.%n(%p)%R&quot;) : String.valueOf(compilable);
2130         int maxKeyWidth = compilableName.length();
2131         SortedMap&lt;String, String&gt; res = new TreeMap&lt;&gt;();
2132         for (MetricKey key : KeyRegistry.getKeys()) {
2133             int index = ((AbstractKey) key).getIndex();
2134             if (index &lt; metricValues.length &amp;&amp; metricValues[index] != 0) {
2135                 String name = key.getName();
2136                 long value = metricValues[index];
2137                 String valueString;
2138                 if (key instanceof TimerKey) {
2139                     // Report timers in ms
2140                     TimerKey timer = (TimerKey) key;
2141                     long ms = timer.getTimeUnit().toMillis(value);
2142                     if (ms == 0) {
2143                         continue;
2144                     }
2145                     valueString = ms + &quot;ms&quot;;
2146                 } else {
2147                     valueString = String.valueOf(value);
2148                 }
2149                 res.put(name, valueString);
2150                 maxKeyWidth = Math.max(maxKeyWidth, name.length());
2151             }
2152         }
2153 
2154         String title = String.format(&quot;%s [id:%s compilation:%d compilation_id:%s]&quot;, compilableName, identity, compilationNr, compilationId);
2155         out.println(new String(new char[title.length()]).replace(&#39;\0&#39;, &#39;#&#39;));
2156         out.printf(&quot;%s%n&quot;, title);
2157         out.println(new String(new char[title.length()]).replace(&#39;\0&#39;, &#39;~&#39;));
2158 
2159         for (Map.Entry&lt;String, String&gt; e : res.entrySet()) {
2160             out.printf(&quot;%-&quot; + String.valueOf(maxKeyWidth) + &quot;s = %20s%n&quot;, e.getKey(), e.getValue());
2161         }
2162         out.println();
2163     }
2164 
2165     public Map&lt;MetricKey, Long&gt; getMetricsSnapshot() {
2166         Map&lt;MetricKey, Long&gt; res = new HashMap&lt;&gt;();
2167         for (MetricKey key : KeyRegistry.getKeys()) {
2168             int index = ((AbstractKey) key).getIndex();
2169             if (index &lt; metricValues.length &amp;&amp; metricValues[index] != 0) {
2170                 long value = metricValues[index];
2171                 res.put(key, value);
2172             }
2173         }
2174         return res;
2175     }
2176 
2177     @SuppressWarnings({&quot;unused&quot;, &quot;unchecked&quot;})
2178     private static &lt;E extends Exception&gt; E rethrowSilently(Class&lt;E&gt; type, Throwable ex) throws E {
2179         throw (E) ex;
2180     }
2181 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.amd64;
 26 
 27 import static jdk.vm.ci.amd64.AMD64.rbp;
 28 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 29 import static org.graalvm.compiler.hotspot.HotSpotBackend.INITIALIZE_KLASS_BY_SYMBOL;
 30 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_DYNAMIC_INVOKE;
 31 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_KLASS_BY_SYMBOL;
 32 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_METHOD_BY_SYMBOL_AND_LOAD_COUNTERS;
 33 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_STRING_BY_SYMBOL;
 34 import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.INITIALIZE;
 35 import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.LOAD_COUNTERS;
 36 import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.RESOLVE;
 37 
 38 import java.util.ArrayList;
 39 import java.util.List;
 40 
 41 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
 42 import org.graalvm.compiler.core.amd64.AMD64ArithmeticLIRGenerator;
 43 import org.graalvm.compiler.core.amd64.AMD64LIRGenerator;
 44 import org.graalvm.compiler.core.amd64.AMD64MoveFactoryBase.BackupSlotProvider;
 45 import org.graalvm.compiler.core.common.CompressEncoding;
 46 import org.graalvm.compiler.core.common.LIRKind;
 47 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 48 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 49 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 50 import org.graalvm.compiler.debug.DebugContext;
 51 import org.graalvm.compiler.debug.GraalError;
 52 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 53 import org.graalvm.compiler.hotspot.HotSpotBackend;
 54 import org.graalvm.compiler.hotspot.HotSpotDebugInfoBuilder;
 55 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 56 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 57 import org.graalvm.compiler.hotspot.HotSpotLIRGenerator;
 58 import org.graalvm.compiler.hotspot.HotSpotLockStack;
 59 import org.graalvm.compiler.hotspot.debug.BenchmarkCounters;
 60 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 61 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 62 import org.graalvm.compiler.hotspot.stubs.Stub;
 63 import org.graalvm.compiler.lir.LIR;
 64 import org.graalvm.compiler.lir.LIRFrameState;
 65 import org.graalvm.compiler.lir.LIRInstruction;
 66 import org.graalvm.compiler.lir.LIRInstructionClass;
 67 import org.graalvm.compiler.lir.LabelRef;
 68 import org.graalvm.compiler.lir.StandardOp.NoOp;
 69 import org.graalvm.compiler.lir.SwitchStrategy;
 70 import org.graalvm.compiler.lir.Variable;
 71 import org.graalvm.compiler.lir.VirtualStackSlot;
 72 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 73 import org.graalvm.compiler.lir.amd64.AMD64CCall;
 74 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp;
 75 import org.graalvm.compiler.lir.amd64.AMD64FrameMapBuilder;
 76 import org.graalvm.compiler.lir.amd64.AMD64Move;
 77 import org.graalvm.compiler.lir.amd64.AMD64Move.MoveFromRegOp;
 78 import org.graalvm.compiler.lir.amd64.AMD64PrefetchOp;
 79 import org.graalvm.compiler.lir.amd64.AMD64ReadTimestampCounter;
 80 import org.graalvm.compiler.lir.amd64.AMD64RestoreRegistersOp;
 81 import org.graalvm.compiler.lir.amd64.AMD64SaveRegistersOp;
 82 import org.graalvm.compiler.lir.amd64.AMD64VZeroUpper;
 83 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 84 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 85 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 86 import org.graalvm.compiler.options.OptionValues;
 87 
 88 import jdk.vm.ci.amd64.AMD64;
 89 import jdk.vm.ci.amd64.AMD64Kind;
 90 import jdk.vm.ci.code.CallingConvention;
 91 import jdk.vm.ci.code.Register;
 92 import jdk.vm.ci.code.RegisterConfig;
 93 import jdk.vm.ci.code.RegisterValue;
 94 import jdk.vm.ci.code.StackSlot;
 95 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 96 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 97 import jdk.vm.ci.meta.AllocatableValue;
 98 import jdk.vm.ci.meta.Constant;
 99 import jdk.vm.ci.meta.DeoptimizationAction;
100 import jdk.vm.ci.meta.DeoptimizationReason;
101 import jdk.vm.ci.meta.JavaConstant;
102 import jdk.vm.ci.meta.JavaKind;
103 import jdk.vm.ci.meta.PlatformKind;
104 import jdk.vm.ci.meta.PrimitiveConstant;
105 import jdk.vm.ci.meta.SpeculationLog;
106 import jdk.vm.ci.meta.Value;
107 
108 /**
109  * LIR generator specialized for AMD64 HotSpot.
110  */
111 public class AMD64HotSpotLIRGenerator extends AMD64LIRGenerator implements HotSpotLIRGenerator {
112 
113     final GraalHotSpotVMConfig config;
114     private HotSpotDebugInfoBuilder debugInfoBuilder;
115 
116     protected AMD64HotSpotLIRGenerator(HotSpotProviders providers, GraalHotSpotVMConfig config, LIRGenerationResult lirGenRes) {
117         this(providers, config, lirGenRes, new BackupSlotProvider(lirGenRes.getFrameMapBuilder()));
118     }
119 
120     private AMD64HotSpotLIRGenerator(HotSpotProviders providers, GraalHotSpotVMConfig config, LIRGenerationResult lirGenRes, BackupSlotProvider backupSlotProvider) {
121         this(new AMD64HotSpotLIRKindTool(), new AMD64ArithmeticLIRGenerator(null), new AMD64HotSpotMoveFactory(backupSlotProvider), providers, config, lirGenRes);
122     }
123 
124     protected AMD64HotSpotLIRGenerator(LIRKindTool lirKindTool, AMD64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, HotSpotProviders providers, GraalHotSpotVMConfig config,
125                     LIRGenerationResult lirGenRes) {
126         super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
127         assert config.basicLockSize == 8;
128         this.config = config;
129     }
130 
131     @Override
132     public HotSpotProviders getProviders() {
133         return (HotSpotProviders) super.getProviders();
134     }
135 
136     @Override
137     protected int getMaxVectorSize() {
138         return config.maxVectorSize;
139     }
140 
141     /**
142      * Utility for emitting the instruction to save RBP.
143      */
144     class SaveRbp {
145 
146         final NoOp placeholder;
147 
148         /**
149          * The slot reserved for saving RBP.
150          */
151         final StackSlot reservedSlot;
152 
153         SaveRbp(NoOp placeholder) {
154             this.placeholder = placeholder;
155             AMD64FrameMapBuilder frameMapBuilder = (AMD64FrameMapBuilder) getResult().getFrameMapBuilder();
156             this.reservedSlot = frameMapBuilder.allocateRBPSpillSlot();
157         }
158 
159         /**
160          * Replaces this operation with the appropriate move for saving rbp.
161          *
162          * @param useStack specifies if rbp must be saved to the stack
163          */
164         public AllocatableValue finalize(boolean useStack) {
165             AllocatableValue dst;
166             if (useStack) {
167                 dst = reservedSlot;
168             } else {
169                 ((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).freeRBPSpillSlot();
170                 dst = newVariable(LIRKind.value(AMD64Kind.QWORD));
171             }
172 
173             placeholder.replace(getResult().getLIR(), new MoveFromRegOp(AMD64Kind.QWORD, dst, rbp.asValue(LIRKind.value(AMD64Kind.QWORD))));
174             return dst;
175         }
176     }
177 
178     private SaveRbp saveRbp;
179 
180     protected void emitSaveRbp() {
181         NoOp placeholder = new NoOp(getCurrentBlock(), getResult().getLIR().getLIRforBlock(getCurrentBlock()).size());
182         append(placeholder);
183         saveRbp = new SaveRbp(placeholder);
184     }
185 
186     protected SaveRbp getSaveRbp() {
187         return saveRbp;
188     }
189 
190     /**
191      * Helper instruction to reserve a stack slot for the whole method. Note that the actual users
192      * of the stack slot might be inserted after stack slot allocation. This dummy instruction
193      * ensures that the stack slot is alive and gets a real stack slot assigned.
194      */
195     private static final class RescueSlotDummyOp extends LIRInstruction {
196         public static final LIRInstructionClass&lt;RescueSlotDummyOp&gt; TYPE = LIRInstructionClass.create(RescueSlotDummyOp.class);
197 
198         @Alive({OperandFlag.STACK, OperandFlag.UNINITIALIZED}) private AllocatableValue slot;
199 
200         RescueSlotDummyOp(FrameMapBuilder frameMapBuilder, LIRKind kind) {
201             super(TYPE);
202             slot = frameMapBuilder.allocateSpillSlot(kind);
203         }
204 
205         public AllocatableValue getSlot() {
206             return slot;
207         }
208 
209         @Override
210         public void emitCode(CompilationResultBuilder crb) {
211         }
212     }
213 
214     private RescueSlotDummyOp rescueSlotOp;
215 
216     private AllocatableValue getOrInitRescueSlot() {
217         RescueSlotDummyOp op = getOrInitRescueSlotOp();
218         return op.getSlot();
219     }
220 
221     private RescueSlotDummyOp getOrInitRescueSlotOp() {
222         if (rescueSlotOp == null) {
223             // create dummy instruction to keep the rescue slot alive
224             rescueSlotOp = new RescueSlotDummyOp(getResult().getFrameMapBuilder(), getLIRKindTool().getWordKind());
225         }
226         return rescueSlotOp;
227     }
228 
229     /**
230      * List of epilogue operations that need to restore RBP.
231      */
232     List&lt;AMD64HotSpotRestoreRbpOp&gt; epilogueOps = new ArrayList&lt;&gt;(2);
233 
234     @Override
235     public &lt;I extends LIRInstruction&gt; I append(I op) {
236         I ret = super.append(op);
237         if (op instanceof AMD64HotSpotRestoreRbpOp) {
238             epilogueOps.add((AMD64HotSpotRestoreRbpOp) op);
239         }
240         return ret;
241     }
242 
243     @Override
244     public VirtualStackSlot getLockSlot(int lockDepth) {
245         return getLockStack().makeLockSlot(lockDepth);
246     }
247 
248     private HotSpotLockStack getLockStack() {
249         assert debugInfoBuilder != null &amp;&amp; debugInfoBuilder.lockStack() != null;
250         return debugInfoBuilder.lockStack();
251     }
252 
253     private Register findPollOnReturnScratchRegister() {
254         RegisterConfig regConfig = getProviders().getCodeCache().getRegisterConfig();
255         for (Register r : regConfig.getAllocatableRegisters()) {
256             if (!r.equals(regConfig.getReturnRegister(JavaKind.Long)) &amp;&amp; !r.equals(AMD64.rbp)) {
257                 return r;
258             }
259         }
260         throw GraalError.shouldNotReachHere();
261     }
262 
263     private Register pollOnReturnScratchRegister;
264 
265     @Override
266     public void emitReturn(JavaKind kind, Value input) {
267         AllocatableValue operand = Value.ILLEGAL;
268         if (input != null) {
269             operand = resultOperandFor(kind, input.getValueKind());
270             emitMove(operand, input);
271         }
272         if (pollOnReturnScratchRegister == null) {
273             pollOnReturnScratchRegister = findPollOnReturnScratchRegister();
274         }
275         Register thread = getProviders().getRegisters().getThreadRegister();
276         append(new AMD64HotSpotReturnOp(operand, getStub() != null, thread, pollOnReturnScratchRegister, config, getResult().requiresReservedStackAccessCheck()));
277     }
278 
279     @Override
280     public boolean needOnlyOopMaps() {
281         // Stubs only need oop maps
282         return getResult().getStub() != null;
283     }
284 
285     private LIRFrameState currentRuntimeCallInfo;
286 
287     @Override
288     protected void emitForeignCallOp(ForeignCallLinkage linkage, Value result, Value[] arguments, Value[] temps, LIRFrameState info) {
289         currentRuntimeCallInfo = info;
290         HotSpotForeignCallLinkage hsLinkage = (HotSpotForeignCallLinkage) linkage;
291         AMD64 arch = (AMD64) target().arch;
292         if (arch.getFeatures().contains(AMD64.CPUFeature.AVX) &amp;&amp; hsLinkage.mayContainFP() &amp;&amp; !hsLinkage.isCompiledStub()) {
293             /*
294              * If the target may contain FP ops, and it is not compiled by us, we may have an
295              * AVX-SSE transition.
296              *
297              * We exclude the argument registers from the zeroing LIR instruction since it violates
298              * the LIR semantics of @Temp that values must not be live. Note that the emitted
299              * machine instruction actually zeros _all_ XMM registers which is fine since we know
300              * that their upper half is not used.
301              */
302             append(new AMD64VZeroUpper(arguments));
303         }
304         super.emitForeignCallOp(linkage, result, arguments, temps, info);
305     }
306 
307     /**
308      * @param savedRegisters the registers saved by this operation which may be subject to pruning
309      * @param savedRegisterLocations the slots to which the registers are saved
310      * @param supportsRemove determines if registers can be pruned
311      */
312     protected AMD64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations, boolean supportsRemove) {
313         AMD64SaveRegistersOp save = new AMD64SaveRegistersOp(savedRegisters, savedRegisterLocations, supportsRemove);
314         append(save);
315         return save;
316     }
317 
318     /**
319      * Allocate a stack slot for saving a register.
320      */
321     protected VirtualStackSlot allocateSaveRegisterLocation(Register register) {
322         PlatformKind kind = target().arch.getLargestStorableKind(register.getRegisterCategory());
323         if (kind.getVectorLength() &gt; 1) {
324             // we don&#39;t use vector registers, so there is no need to save them
325             kind = AMD64Kind.DOUBLE;
326         }
327         return getResult().getFrameMapBuilder().allocateSpillSlot(LIRKind.value(kind));
328     }
329 
330     /**
331      * Adds a node to the graph that saves all allocatable registers to the stack.
332      *
333      * @param supportsRemove determines if registers can be pruned
334      * @return the register save node
335      */
336     private AMD64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters, boolean supportsRemove) {
337         AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];
338         for (int i = 0; i &lt; savedRegisters.length; i++) {
339             savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);
340         }
341         return emitSaveRegisters(savedRegisters, savedRegisterLocations, supportsRemove);
342     }
343 
344     protected void emitRestoreRegisters(AMD64SaveRegistersOp save) {
345         append(new AMD64RestoreRegistersOp(save.getSlots().clone(), save));
346     }
347 
348     /**
349      * Gets the {@link Stub} this generator is generating code for or {@code null} if a stub is not
350      * being generated.
351      */
352     public Stub getStub() {
353         return getResult().getStub();
354     }
355 
356     @Override
357     public HotSpotLIRGenerationResult getResult() {
358         return ((HotSpotLIRGenerationResult) super.getResult());
359     }
360 
361     public void setDebugInfoBuilder(HotSpotDebugInfoBuilder debugInfoBuilder) {
362         this.debugInfoBuilder = debugInfoBuilder;
363     }
364 
365     @Override
366     public Variable emitForeignCall(ForeignCallLinkage linkage, LIRFrameState state, Value... args) {
367         HotSpotForeignCallLinkage hotspotLinkage = (HotSpotForeignCallLinkage) linkage;
368         boolean destroysRegisters = hotspotLinkage.destroysRegisters();
369 
370         AMD64SaveRegistersOp save = null;
371         Stub stub = getStub();
372         if (destroysRegisters) {
373             if (stub != null &amp;&amp; stub.preservesRegisters()) {
374                 Register[] savedRegisters = getRegisterConfig().getAllocatableRegisters().toArray();
375                 save = emitSaveAllRegisters(savedRegisters, true);
376             }
377         }
378 
379         Variable result;
380         LIRFrameState debugInfo = null;
381         if (hotspotLinkage.needsDebugInfo()) {
382             debugInfo = state;
383             assert debugInfo != null || stub != null;
384         }
385 
386         if (hotspotLinkage.needsJavaFrameAnchor()) {
387             Register thread = getProviders().getRegisters().getThreadRegister();
388             append(new AMD64HotSpotCRuntimeCallPrologueOp(config.threadLastJavaSpOffset(), thread));
389             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
390             append(new AMD64HotSpotCRuntimeCallEpilogueOp(config.threadLastJavaSpOffset(), config.threadLastJavaFpOffset(), config.threadLastJavaPcOffset(), thread));
391         } else {
392             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
393         }
394 
395         if (destroysRegisters) {
396             if (stub != null) {
397                 if (stub.preservesRegisters()) {
398                     HotSpotLIRGenerationResult generationResult = getResult();
399                     LIRFrameState key = currentRuntimeCallInfo;
400                     if (key == null) {
401                         key = LIRFrameState.NO_STATE;
402                     }
403                     assert !generationResult.getCalleeSaveInfo().containsKey(key);
404                     generationResult.getCalleeSaveInfo().put(key, save);
405                     emitRestoreRegisters(save);
406                 }
407             }
408         }
409 
410         return result;
411     }
412 
413     @Override
414     public Value emitLoadObjectAddress(Constant constant) {
415         HotSpotObjectConstant objectConstant = (HotSpotObjectConstant) constant;
416         LIRKind kind = objectConstant.isCompressed() ? getLIRKindTool().getNarrowOopKind() : getLIRKindTool().getObjectKind();
417         Variable result = newVariable(kind);
418         append(new AMD64HotSpotLoadAddressOp(result, constant, HotSpotConstantLoadAction.RESOLVE));
419         return result;
420     }
421 
422     @Override
423     public Value emitLoadMetaspaceAddress(Constant constant, HotSpotConstantLoadAction action) {
424         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) constant;
425         LIRKind kind = metaspaceConstant.isCompressed() ? getLIRKindTool().getNarrowPointerKind() : getLIRKindTool().getWordKind();
426         Variable result = newVariable(kind);
427         append(new AMD64HotSpotLoadAddressOp(result, constant, action));
428         return result;
429     }
430 
431     private Value emitConstantRetrieval(ForeignCallDescriptor foreignCall, Object[] notes, Constant[] constants, AllocatableValue[] constantDescriptions, LIRFrameState frameState) {
432         ForeignCallLinkage linkage = getForeignCalls().lookupForeignCall(foreignCall);
433         append(new AMD64HotSpotConstantRetrievalOp(constants, constantDescriptions, frameState, linkage, notes));
434         AllocatableValue result = linkage.getOutgoingCallingConvention().getReturn();
435         return emitMove(result);
436     }
437 
438     private Value emitConstantRetrieval(ForeignCallDescriptor foreignCall, HotSpotConstantLoadAction action, Constant constant, AllocatableValue[] constantDescriptions, LIRFrameState frameState) {
439         Constant[] constants = new Constant[]{constant};
440         Object[] notes = new Object[]{action};
441         return emitConstantRetrieval(foreignCall, notes, constants, constantDescriptions, frameState);
442     }
443 
444     private Value emitConstantRetrieval(ForeignCallDescriptor foreignCall, HotSpotConstantLoadAction action, Constant constant, Value constantDescription, LIRFrameState frameState) {
445         AllocatableValue[] constantDescriptions = new AllocatableValue[]{asAllocatable(constantDescription)};
446         return emitConstantRetrieval(foreignCall, action, constant, constantDescriptions, frameState);
447     }
448 
449     @Override
450     public Value emitObjectConstantRetrieval(Constant constant, Value constantDescription, LIRFrameState frameState) {
451         return emitConstantRetrieval(RESOLVE_STRING_BY_SYMBOL, RESOLVE, constant, constantDescription, frameState);
452     }
453 
454     @Override
455     public Value emitMetaspaceConstantRetrieval(Constant constant, Value constantDescription, LIRFrameState frameState) {
456         return emitConstantRetrieval(RESOLVE_KLASS_BY_SYMBOL, RESOLVE, constant, constantDescription, frameState);
457     }
458 
459     @Override
460     public Value emitKlassInitializationAndRetrieval(Constant constant, Value constantDescription, LIRFrameState frameState) {
461         return emitConstantRetrieval(INITIALIZE_KLASS_BY_SYMBOL, INITIALIZE, constant, constantDescription, frameState);
462     }
463 
464     @Override
465     public Value emitResolveMethodAndLoadCounters(Constant method, Value klassHint, Value methodDescription, LIRFrameState frameState) {
466         AllocatableValue[] constantDescriptions = new AllocatableValue[]{asAllocatable(klassHint), asAllocatable(methodDescription)};
467         return emitConstantRetrieval(RESOLVE_METHOD_BY_SYMBOL_AND_LOAD_COUNTERS, LOAD_COUNTERS, method, constantDescriptions, frameState);
468     }
469 
470     @Override
471     public Value emitResolveDynamicInvoke(Constant appendix, LIRFrameState frameState) {
472         AllocatableValue[] constantDescriptions = new AllocatableValue[0];
473         return emitConstantRetrieval(RESOLVE_DYNAMIC_INVOKE, INITIALIZE, appendix, constantDescriptions, frameState);
474     }
475 
476     @Override
477     public Value emitLoadConfigValue(int markId, LIRKind kind) {
478         Variable result = newVariable(kind);
479         append(new AMD64HotSpotLoadConfigValueOp(markId, result));
480         return result;
481     }
482 
483     @Override
484     public Value emitRandomSeed() {
485         AMD64ReadTimestampCounter timestamp = new AMD64ReadTimestampCounter();
486         append(timestamp);
487         return emitMove(timestamp.getLowResult());
488     }
489 
490     @Override
491     public void emitTailcall(Value[] args, Value address) {
492         append(new AMD64TailcallOp(args, address));
493     }
494 
495     @Override
496     public void emitCCall(long address, CallingConvention nativeCallingConvention, Value[] args, int numberOfFloatingPointArguments) {
497         Value[] argLocations = new Value[args.length];
498         getResult().getFrameMapBuilder().callsMethod(nativeCallingConvention);
499         // TODO(mg): in case a native function uses floating point varargs, the ABI requires that
500         // RAX contains the length of the varargs
501         PrimitiveConstant intConst = JavaConstant.forInt(numberOfFloatingPointArguments);
502         AllocatableValue numberOfFloatingPointArgumentsRegister = AMD64.rax.asValue(LIRKind.value(AMD64Kind.DWORD));
503         emitMoveConstant(numberOfFloatingPointArgumentsRegister, intConst);
504         for (int i = 0; i &lt; args.length; i++) {
505             Value arg = args[i];
506             AllocatableValue loc = nativeCallingConvention.getArgument(i);
507             emitMove(loc, arg);
508             argLocations[i] = loc;
509         }
510         Value ptr = emitLoadConstant(LIRKind.value(AMD64Kind.QWORD), JavaConstant.forLong(address));
511         append(new AMD64CCall(nativeCallingConvention.getReturn(), ptr, numberOfFloatingPointArgumentsRegister, argLocations));
512     }
513 
514     @Override
515     public void emitUnwind(Value exception) {
516         ForeignCallLinkage linkage = getForeignCalls().lookupForeignCall(HotSpotBackend.UNWIND_EXCEPTION_TO_CALLER);
517         CallingConvention outgoingCc = linkage.getOutgoingCallingConvention();
518         assert outgoingCc.getArgumentCount() == 2;
519         RegisterValue exceptionParameter = (RegisterValue) outgoingCc.getArgument(0);
520         emitMove(exceptionParameter, exception);
521         append(new AMD64HotSpotUnwindOp(exceptionParameter));
522     }
523 
524     private void moveDeoptValuesToThread(Value actionAndReason, Value speculation) {
525         moveValueToThread(actionAndReason, config.pendingDeoptimizationOffset);
526         moveValueToThread(speculation, config.pendingFailedSpeculationOffset);
527     }
528 
529     private void moveValueToThread(Value v, int offset) {
530         LIRKind wordKind = LIRKind.value(target().arch.getWordKind());
531         RegisterValue thread = getProviders().getRegisters().getThreadRegister().asValue(wordKind);
532         AMD64AddressValue address = new AMD64AddressValue(wordKind, thread, offset);
533         arithmeticLIRGen.emitStore(v.getValueKind(), address, v, null);
534     }
535 
536     @Override
537     public void emitDeoptimize(Value actionAndReason, Value speculation, LIRFrameState state) {
538         moveDeoptValuesToThread(actionAndReason, speculation);
539         append(new AMD64DeoptimizeOp(state));
540     }
541 
542     @Override
543     public void emitDeoptimizeCaller(DeoptimizationAction action, DeoptimizationReason reason) {
544         Value actionAndReason = emitJavaConstant(getMetaAccess().encodeDeoptActionAndReason(action, reason, 0));
545         Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
546         moveDeoptValuesToThread(actionAndReason, speculation);
547         append(new AMD64HotSpotDeoptimizeCallerOp());
548     }
549 
550     @Override
551     public void beforeRegisterAllocation() {
552         super.beforeRegisterAllocation();
553         boolean hasDebugInfo = getResult().getLIR().hasDebugInfo();
554         AllocatableValue savedRbp = saveRbp.finalize(hasDebugInfo);
555         if (hasDebugInfo) {
556             getResult().setDeoptimizationRescueSlot(((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).allocateDeoptimizationRescueSlot());
557         }
558 
559         getResult().setMaxInterpreterFrameSize(debugInfoBuilder.maxInterpreterFrameSize());
560 
561         for (AMD64HotSpotRestoreRbpOp op : epilogueOps) {
562             op.setSavedRbp(savedRbp);
563         }
564         if (BenchmarkCounters.enabled) {
565             // ensure that the rescue slot is available
566             LIRInstruction op = getOrInitRescueSlotOp();
567             // insert dummy instruction into the start block
568             LIR lir = getResult().getLIR();
569             ArrayList&lt;LIRInstruction&gt; instructions = lir.getLIRforBlock(lir.getControlFlowGraph().getStartBlock());
570             instructions.add(1, op);
571             lir.getDebug().dump(DebugContext.INFO_LEVEL, lir, &quot;created rescue dummy op&quot;);
572         }
573     }
574 
575     @Override
576     public Value emitCompress(Value pointer, CompressEncoding encoding, boolean nonNull) {
577         LIRKind inputKind = pointer.getValueKind(LIRKind.class);
578         LIRKindTool lirKindTool = getLIRKindTool();
579         assert inputKind.getPlatformKind() == lirKindTool.getObjectKind().getPlatformKind();
580         if (inputKind.isReference(0)) {
581             // oop
582             Variable result = newVariable(lirKindTool.getNarrowOopKind());
583             append(new AMD64Move.CompressPointerOp(result, asAllocatable(pointer), getProviders().getRegisters().getHeapBaseRegister().asValue(), encoding, nonNull, getLIRKindTool()));
584             return result;
585         } else {
586             // metaspace pointer
587             Variable result = newVariable(lirKindTool.getNarrowPointerKind());
588             AllocatableValue base = Value.ILLEGAL;
589             OptionValues options = getResult().getLIR().getOptions();
590             if (encoding.hasBase() || GeneratePIC.getValue(options)) {
591                 if (GeneratePIC.getValue(options)) {
592                     Variable baseAddress = newVariable(lirKindTool.getWordKind());
593                     AMD64HotSpotMove.BaseMove move = new AMD64HotSpotMove.BaseMove(baseAddress, config);
594                     append(move);
595                     base = baseAddress;
596                 } else {
597                     base = emitLoadConstant(lirKindTool.getWordKind(), JavaConstant.forLong(encoding.getBase()));
598                 }
599             }
600             append(new AMD64Move.CompressPointerOp(result, asAllocatable(pointer), base, encoding, nonNull, getLIRKindTool()));
601             return result;
602         }
603     }
604 
605     @Override
606     public Value emitUncompress(Value pointer, CompressEncoding encoding, boolean nonNull) {
607         LIRKind inputKind = pointer.getValueKind(LIRKind.class);
608         LIRKindTool lirKindTool = getLIRKindTool();
609         assert inputKind.getPlatformKind() == lirKindTool.getNarrowOopKind().getPlatformKind();
610         if (inputKind.isReference(0)) {
611             // oop
612             Variable result = newVariable(lirKindTool.getObjectKind());
613             append(new AMD64Move.UncompressPointerOp(result, asAllocatable(pointer), getProviders().getRegisters().getHeapBaseRegister().asValue(), encoding, nonNull, lirKindTool));
614             return result;
615         } else {
616             // metaspace pointer
617             LIRKind uncompressedKind = lirKindTool.getWordKind();
618             Variable result = newVariable(uncompressedKind);
619             AllocatableValue base = Value.ILLEGAL;
620             OptionValues options = getResult().getLIR().getOptions();
621             if (encoding.hasBase() || GeneratePIC.getValue(options)) {
622                 if (GeneratePIC.getValue(options)) {
623                     Variable baseAddress = newVariable(uncompressedKind);
624                     AMD64HotSpotMove.BaseMove move = new AMD64HotSpotMove.BaseMove(baseAddress, config);
625                     append(move);
626                     base = baseAddress;
627                 } else {
628                     base = emitLoadConstant(uncompressedKind, JavaConstant.forLong(encoding.getBase()));
629                 }
630             }
631             append(new AMD64Move.UncompressPointerOp(result, asAllocatable(pointer), base, encoding, nonNull, lirKindTool));
632             return result;
633         }
634     }
635 
636     @Override
637     public void emitNullCheck(Value address, LIRFrameState state) {
638         if (address.getValueKind().getPlatformKind() == getLIRKindTool().getNarrowOopKind().getPlatformKind()) {
639             CompressEncoding encoding = config.getOopEncoding();
640             Value uncompressed;
641             if (encoding.getShift() &lt;= 3) {
642                 LIRKind wordKind = LIRKind.unknownReference(target().arch.getWordKind());
643                 uncompressed = new AMD64AddressValue(wordKind, getProviders().getRegisters().getHeapBaseRegister().asValue(wordKind), asAllocatable(address), Scale.fromInt(1 &lt;&lt; encoding.getShift()),
644                                 0);
645             } else {
646                 uncompressed = emitUncompress(address, encoding, false);
647             }
648             append(new AMD64Move.NullCheckOp(asAddressValue(uncompressed), state));
649             return;
650         }
651         super.emitNullCheck(address, state);
652     }
653 
654     @Override
655     public LIRInstruction createBenchmarkCounter(String name, String group, Value increment) {
656         if (BenchmarkCounters.enabled) {
657             return new AMD64HotSpotCounterOp(name, group, increment, getProviders().getRegisters(), config, getOrInitRescueSlot());
658         }
659         throw GraalError.shouldNotReachHere(&quot;BenchmarkCounters are not enabled!&quot;);
660     }
661 
662     @Override
663     public LIRInstruction createMultiBenchmarkCounter(String[] names, String[] groups, Value[] increments) {
664         if (BenchmarkCounters.enabled) {
665             return new AMD64HotSpotCounterOp(names, groups, increments, getProviders().getRegisters(), config, getOrInitRescueSlot());
666         }
667         throw GraalError.shouldNotReachHere(&quot;BenchmarkCounters are not enabled!&quot;);
668     }
669 
670     @Override
671     public void emitPrefetchAllocate(Value address) {
672         append(new AMD64PrefetchOp(asAddressValue(address), config.allocatePrefetchInstr));
673     }
674 
675     @Override
676     protected StrategySwitchOp createStrategySwitchOp(SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Variable key, AllocatableValue temp) {
677         return new AMD64HotSpotStrategySwitchOp(strategy, keyTargets, defaultTarget, key, temp);
678     }
679 }
    </pre>
  </body>
</html>
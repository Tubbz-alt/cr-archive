<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotNodeLIRBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.amd64;
 26 
 27 import static jdk.vm.ci.amd64.AMD64.rbp;
 28 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 29 import static org.graalvm.compiler.hotspot.HotSpotBackend.EXCEPTION_HANDLER_IN_CALLER;
 30 
<a name="2" id="anc2"></a><span class="line-added"> 31 import org.graalvm.compiler.api.replacements.Snippet;</span>
 32 import org.graalvm.compiler.core.amd64.AMD64NodeLIRBuilder;
 33 import org.graalvm.compiler.core.amd64.AMD64NodeMatchRules;
 34 import org.graalvm.compiler.core.common.LIRKind;
<a name="3" id="anc3"></a><span class="line-added"> 35 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;</span>
 36 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 37 import org.graalvm.compiler.core.gen.DebugInfoBuilder;
 38 import org.graalvm.compiler.hotspot.HotSpotDebugInfoBuilder;
 39 import org.graalvm.compiler.hotspot.HotSpotLIRGenerator;
 40 import org.graalvm.compiler.hotspot.HotSpotLockStack;
 41 import org.graalvm.compiler.hotspot.HotSpotNodeLIRBuilder;
 42 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 43 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
 44 import org.graalvm.compiler.lir.LIRFrameState;
 45 import org.graalvm.compiler.lir.Variable;
 46 import org.graalvm.compiler.lir.amd64.AMD64BreakpointOp;
 47 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 48 import org.graalvm.compiler.nodes.BreakpointNode;
 49 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 50 import org.graalvm.compiler.nodes.DirectCallTargetNode;
 51 import org.graalvm.compiler.nodes.FullInfopointNode;
 52 import org.graalvm.compiler.nodes.IndirectCallTargetNode;
 53 import org.graalvm.compiler.nodes.NodeView;
 54 import org.graalvm.compiler.nodes.ParameterNode;
 55 import org.graalvm.compiler.nodes.SafepointNode;
 56 import org.graalvm.compiler.nodes.StructuredGraph;
 57 import org.graalvm.compiler.nodes.ValueNode;
 58 import org.graalvm.compiler.nodes.spi.NodeValueMap;
<a name="4" id="anc4"></a><span class="line-added"> 59 import org.graalvm.compiler.replacements.nodes.ArrayCompareToNode;</span>
<span class="line-added"> 60 import org.graalvm.compiler.replacements.nodes.ArrayEqualsNode;</span>
 61 
 62 import jdk.vm.ci.amd64.AMD64;
 63 import jdk.vm.ci.amd64.AMD64Kind;
 64 import jdk.vm.ci.code.BytecodeFrame;
 65 import jdk.vm.ci.code.CallingConvention;
 66 import jdk.vm.ci.code.Register;
 67 import jdk.vm.ci.code.RegisterValue;
 68 import jdk.vm.ci.code.StackSlot;
 69 import jdk.vm.ci.code.ValueUtil;
 70 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 71 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 72 import jdk.vm.ci.meta.AllocatableValue;
<a name="5" id="anc5"></a><span class="line-added"> 73 import jdk.vm.ci.meta.JavaKind;</span>
 74 import jdk.vm.ci.meta.JavaType;
<a name="6" id="anc6"></a><span class="line-added"> 75 import jdk.vm.ci.meta.ResolvedJavaMethod;</span>
 76 import jdk.vm.ci.meta.Value;
<a name="7" id="anc7"></a><span class="line-added"> 77 import org.graalvm.compiler.replacements.nodes.ArrayRegionEqualsNode;</span>
 78 
 79 /**
 80  * LIR generator specialized for AMD64 HotSpot.
 81  */
 82 public class AMD64HotSpotNodeLIRBuilder extends AMD64NodeLIRBuilder implements HotSpotNodeLIRBuilder {
 83 
 84     public AMD64HotSpotNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool gen, AMD64NodeMatchRules nodeMatchRules) {
 85         super(graph, gen, nodeMatchRules);
 86         assert gen instanceof AMD64HotSpotLIRGenerator;
 87         assert getDebugInfoBuilder() instanceof HotSpotDebugInfoBuilder;
 88         ((AMD64HotSpotLIRGenerator) gen).setDebugInfoBuilder(((HotSpotDebugInfoBuilder) getDebugInfoBuilder()));
 89     }
 90 
 91     private AMD64HotSpotLIRGenerator getGen() {
 92         return (AMD64HotSpotLIRGenerator) gen;
 93     }
 94 
 95     @Override
 96     protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeValueMap nodeValueMap) {
 97         HotSpotLockStack lockStack = new HotSpotLockStack(gen.getResult().getFrameMapBuilder(), LIRKind.value(AMD64Kind.QWORD));
 98         return new HotSpotDebugInfoBuilder(nodeValueMap, lockStack, (HotSpotLIRGenerator) gen);
 99     }
100 
101     @Override
102     protected void emitPrologue(StructuredGraph graph) {
103 
104         CallingConvention incomingArguments = gen.getResult().getCallingConvention();
105 
106         Value[] params = new Value[incomingArguments.getArgumentCount() + 1];
107         for (int i = 0; i &lt; params.length - 1; i++) {
108             params[i] = incomingArguments.getArgument(i);
109             if (isStackSlot(params[i])) {
110                 StackSlot slot = ValueUtil.asStackSlot(params[i]);
111                 if (slot.isInCallerFrame() &amp;&amp; !gen.getResult().getLIR().hasArgInCallerFrame()) {
112                     gen.getResult().getLIR().setHasArgInCallerFrame();
113                 }
114             }
115         }
116         params[params.length - 1] = rbp.asValue(LIRKind.value(AMD64Kind.QWORD));
117 
118         gen.emitIncomingValues(params);
119 
120         getGen().emitSaveRbp();
121 
122         getGen().append(((HotSpotDebugInfoBuilder) getDebugInfoBuilder()).lockStack());
123 
124         for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
125             Value paramValue = params[param.index()];
126             assert paramValue.getValueKind().equals(getLIRGeneratorTool().getLIRKind(param.stamp(NodeView.DEFAULT))) : paramValue.getValueKind() + &quot; != &quot; + param.stamp(NodeView.DEFAULT);
127             setResult(param, gen.emitMove(paramValue));
128         }
129     }
130 
131     @Override
132     public void visitSafepointNode(SafepointNode i) {
133         LIRFrameState info = state(i);
134         Register thread = getGen().getProviders().getRegisters().getThreadRegister();
135         append(new AMD64HotSpotSafepointOp(info, getGen().config, this, thread));
136     }
137 
138     @Override
139     protected void emitDirectCall(DirectCallTargetNode callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState callState) {
140         InvokeKind invokeKind = ((HotSpotDirectCallTargetNode) callTarget).invokeKind();
141         if (invokeKind.isIndirect()) {
142             append(new AMD64HotspotDirectVirtualCallOp(callTarget.targetMethod(), result, parameters, temps, callState, invokeKind, getGen().config));
143         } else {
144             assert invokeKind.isDirect();
145             HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();
146             assert resolvedMethod.isConcrete() : &quot;Cannot make direct call to abstract method.&quot;;
147             append(new AMD64HotSpotDirectStaticCallOp(callTarget.targetMethod(), result, parameters, temps, callState, invokeKind, getGen().config));
148         }
149     }
150 
151     @Override
152     protected void emitIndirectCall(IndirectCallTargetNode callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState callState) {
153         if (callTarget instanceof HotSpotIndirectCallTargetNode) {
154             Value metaspaceMethodSrc = operand(((HotSpotIndirectCallTargetNode) callTarget).metaspaceMethod());
155             Value targetAddressSrc = operand(callTarget.computedAddress());
156             AllocatableValue metaspaceMethodDst = AMD64.rbx.asValue(metaspaceMethodSrc.getValueKind());
157             AllocatableValue targetAddressDst = AMD64.rax.asValue(targetAddressSrc.getValueKind());
158             gen.emitMove(metaspaceMethodDst, metaspaceMethodSrc);
159             gen.emitMove(targetAddressDst, targetAddressSrc);
160             append(new AMD64IndirectCallOp(callTarget.targetMethod(), result, parameters, temps, metaspaceMethodDst, targetAddressDst, callState, getGen().config));
161         } else {
162             super.emitIndirectCall(callTarget, result, parameters, temps, callState);
163         }
164     }
165 
166     @Override
167     public void emitPatchReturnAddress(ValueNode address) {
168         append(new AMD64HotSpotPatchReturnAddressOp(gen.load(operand(address))));
169     }
170 
171     @Override
172     public void emitJumpToExceptionHandlerInCaller(ValueNode handlerInCallerPc, ValueNode exception, ValueNode exceptionPc) {
173         Variable handler = gen.load(operand(handlerInCallerPc));
174         ForeignCallLinkage linkage = gen.getForeignCalls().lookupForeignCall(EXCEPTION_HANDLER_IN_CALLER);
175         CallingConvention outgoingCc = linkage.getOutgoingCallingConvention();
176         assert outgoingCc.getArgumentCount() == 2;
177         RegisterValue exceptionFixed = (RegisterValue) outgoingCc.getArgument(0);
178         RegisterValue exceptionPcFixed = (RegisterValue) outgoingCc.getArgument(1);
179         gen.emitMove(exceptionFixed, operand(exception));
180         gen.emitMove(exceptionPcFixed, operand(exceptionPc));
181         Register thread = getGen().getProviders().getRegisters().getThreadRegister();
182         AMD64HotSpotJumpToExceptionHandlerInCallerOp op = new AMD64HotSpotJumpToExceptionHandlerInCallerOp(handler, exceptionFixed, exceptionPcFixed, getGen().config.threadIsMethodHandleReturnOffset,
183                         thread);
184         append(op);
185     }
186 
187     @Override
188     public void visitFullInfopointNode(FullInfopointNode i) {
189         if (i.getState() != null &amp;&amp; i.getState().bci == BytecodeFrame.AFTER_BCI) {
190             i.getDebug().log(&quot;Ignoring InfopointNode for AFTER_BCI&quot;);
191         } else {
192             super.visitFullInfopointNode(i);
193         }
194     }
195 
196     @Override
197     public void visitBreakpointNode(BreakpointNode node) {
198         JavaType[] sig = new JavaType[node.arguments().size()];
199         for (int i = 0; i &lt; sig.length; i++) {
200             sig[i] = node.arguments().get(i).stamp(NodeView.DEFAULT).javaType(gen.getMetaAccess());
201         }
202 
203         Value[] parameters = visitInvokeArguments(gen.getRegisterConfig().getCallingConvention(HotSpotCallingConventionType.JavaCall, null, sig, gen), node.arguments());
204         append(new AMD64BreakpointOp(parameters));
205     }
<a name="8" id="anc8"></a><span class="line-added">206 </span>
<span class="line-added">207     private ForeignCallLinkage lookupForeignCall(ForeignCallDescriptor descriptor) {</span>
<span class="line-added">208         return getGen().getForeignCalls().lookupForeignCall(descriptor);</span>
<span class="line-added">209     }</span>
<span class="line-added">210 </span>
<span class="line-added">211     @Override</span>
<span class="line-added">212     public ForeignCallLinkage lookupGraalStub(ValueNode valueNode) {</span>
<span class="line-added">213         ResolvedJavaMethod method = valueNode.graph().method();</span>
<span class="line-added">214         if (method == null || method.getAnnotation(Snippet.class) != null) {</span>
<span class="line-added">215             // Emit assembly for snippet stubs</span>
<span class="line-added">216             return null;</span>
<span class="line-added">217         }</span>
<span class="line-added">218 </span>
<span class="line-added">219         if (valueNode instanceof ArrayEqualsNode) {</span>
<span class="line-added">220             ArrayEqualsNode arrayEqualsNode = (ArrayEqualsNode) valueNode;</span>
<span class="line-added">221             JavaKind kind = arrayEqualsNode.getKind();</span>
<span class="line-added">222             ValueNode length = arrayEqualsNode.getLength();</span>
<span class="line-added">223 </span>
<span class="line-added">224             if (length.isConstant()) {</span>
<span class="line-added">225                 int constantLength = length.asJavaConstant().asInt();</span>
<span class="line-added">226                 if (constantLength &gt;= 0 &amp;&amp; constantLength * kind.getByteCount() &lt; 2 * getGen().getMaxVectorSize()) {</span>
<span class="line-added">227                     // Yield constant-length arrays comparison assembly</span>
<span class="line-added">228                     return null;</span>
<span class="line-added">229                 }</span>
<span class="line-added">230             }</span>
<span class="line-added">231 </span>
<span class="line-added">232             switch (kind) {</span>
<span class="line-added">233                 case Boolean:</span>
<span class="line-added">234                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_BOOLEAN_ARRAY_EQUALS);</span>
<span class="line-added">235                 case Byte:</span>
<span class="line-added">236                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_BYTE_ARRAY_EQUALS);</span>
<span class="line-added">237                 case Char:</span>
<span class="line-added">238                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_CHAR_ARRAY_EQUALS);</span>
<span class="line-added">239                 case Short:</span>
<span class="line-added">240                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_SHORT_ARRAY_EQUALS);</span>
<span class="line-added">241                 case Int:</span>
<span class="line-added">242                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_INT_ARRAY_EQUALS);</span>
<span class="line-added">243                 case Long:</span>
<span class="line-added">244                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_LONG_ARRAY_EQUALS);</span>
<span class="line-added">245                 case Float:</span>
<span class="line-added">246                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_FLOAT_ARRAY_EQUALS);</span>
<span class="line-added">247                 case Double:</span>
<span class="line-added">248                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_DOUBLE_ARRAY_EQUALS);</span>
<span class="line-added">249                 default:</span>
<span class="line-added">250                     return null;</span>
<span class="line-added">251             }</span>
<span class="line-added">252         } else if (valueNode instanceof ArrayCompareToNode) {</span>
<span class="line-added">253             ArrayCompareToNode arrayCompareToNode = (ArrayCompareToNode) valueNode;</span>
<span class="line-added">254             JavaKind kind1 = arrayCompareToNode.getKind1();</span>
<span class="line-added">255             JavaKind kind2 = arrayCompareToNode.getKind2();</span>
<span class="line-added">256 </span>
<span class="line-added">257             if (kind1 == JavaKind.Byte) {</span>
<span class="line-added">258                 if (kind2 == JavaKind.Byte) {</span>
<span class="line-added">259                     return lookupForeignCall(AMD64ArrayCompareToStub.STUB_BYTE_ARRAY_COMPARE_TO_BYTE_ARRAY);</span>
<span class="line-added">260                 } else if (kind2 == JavaKind.Char) {</span>
<span class="line-added">261                     return lookupForeignCall(AMD64ArrayCompareToStub.STUB_BYTE_ARRAY_COMPARE_TO_CHAR_ARRAY);</span>
<span class="line-added">262                 }</span>
<span class="line-added">263             } else if (kind1 == JavaKind.Char) {</span>
<span class="line-added">264                 if (kind2 == JavaKind.Byte) {</span>
<span class="line-added">265                     return lookupForeignCall(AMD64ArrayCompareToStub.STUB_CHAR_ARRAY_COMPARE_TO_BYTE_ARRAY);</span>
<span class="line-added">266                 } else if (kind2 == JavaKind.Char) {</span>
<span class="line-added">267                     return lookupForeignCall(AMD64ArrayCompareToStub.STUB_CHAR_ARRAY_COMPARE_TO_CHAR_ARRAY);</span>
<span class="line-added">268                 }</span>
<span class="line-added">269             }</span>
<span class="line-added">270         } else if (valueNode instanceof ArrayRegionEqualsNode) {</span>
<span class="line-added">271             ArrayRegionEqualsNode arrayRegionEqualsNode = (ArrayRegionEqualsNode) valueNode;</span>
<span class="line-added">272             JavaKind kind1 = arrayRegionEqualsNode.getKind1();</span>
<span class="line-added">273             JavaKind kind2 = arrayRegionEqualsNode.getKind2();</span>
<span class="line-added">274             ValueNode length = arrayRegionEqualsNode.getLength();</span>
<span class="line-added">275 </span>
<span class="line-added">276             if (length.isConstant()) {</span>
<span class="line-added">277                 int constantLength = length.asJavaConstant().asInt();</span>
<span class="line-added">278                 if (constantLength &gt;= 0 &amp;&amp; constantLength * (Math.max(kind1.getByteCount(), kind2.getByteCount())) &lt; 2 * getGen().getMaxVectorSize()) {</span>
<span class="line-added">279                     // Yield constant-length arrays comparison assembly</span>
<span class="line-added">280                     return null;</span>
<span class="line-added">281                 }</span>
<span class="line-added">282             }</span>
<span class="line-added">283 </span>
<span class="line-added">284             if (kind1 == kind2) {</span>
<span class="line-added">285                 switch (kind1) {</span>
<span class="line-added">286                     case Byte:</span>
<span class="line-added">287                         return lookupForeignCall(AMD64ArrayEqualsStub.STUB_BYTE_ARRAY_EQUALS_DIRECT);</span>
<span class="line-added">288                     case Char:</span>
<span class="line-added">289                         return lookupForeignCall(AMD64ArrayEqualsStub.STUB_CHAR_ARRAY_EQUALS_DIRECT);</span>
<span class="line-added">290                     default:</span>
<span class="line-added">291                         return null;</span>
<span class="line-added">292                 }</span>
<span class="line-added">293             } else if (kind1 == JavaKind.Char &amp;&amp; kind2 == JavaKind.Byte) {</span>
<span class="line-added">294                 return lookupForeignCall(AMD64ArrayEqualsStub.STUB_CHAR_ARRAY_EQUALS_BYTE_ARRAY);</span>
<span class="line-added">295             }</span>
<span class="line-added">296         }</span>
<span class="line-added">297 </span>
<span class="line-added">298         return null;</span>
<span class="line-added">299     }</span>
300 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
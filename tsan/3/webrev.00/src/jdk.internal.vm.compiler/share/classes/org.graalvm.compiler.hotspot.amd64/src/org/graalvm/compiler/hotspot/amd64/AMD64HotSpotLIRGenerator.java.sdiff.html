<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64HotSpotJumpToExceptionHandlerInCallerOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64HotSpotLoweringProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotLIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
136     @Override
137     protected int getMaxVectorSize() {
138         return config.maxVectorSize;
139     }
140 
141     /**
142      * Utility for emitting the instruction to save RBP.
143      */
144     class SaveRbp {
145 
146         final NoOp placeholder;
147 
148         /**
149          * The slot reserved for saving RBP.
150          */
151         final StackSlot reservedSlot;
152 
153         SaveRbp(NoOp placeholder) {
154             this.placeholder = placeholder;
155             AMD64FrameMapBuilder frameMapBuilder = (AMD64FrameMapBuilder) getResult().getFrameMapBuilder();
<span class="line-modified">156             this.reservedSlot = frameMapBuilder.allocateRBPSpillSlot();</span>
157         }
158 
159         /**
160          * Replaces this operation with the appropriate move for saving rbp.
161          *
162          * @param useStack specifies if rbp must be saved to the stack
163          */
164         public AllocatableValue finalize(boolean useStack) {

165             AllocatableValue dst;
166             if (useStack) {
167                 dst = reservedSlot;
168             } else {
169                 ((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).freeRBPSpillSlot();
170                 dst = newVariable(LIRKind.value(AMD64Kind.QWORD));
171             }
172 
173             placeholder.replace(getResult().getLIR(), new MoveFromRegOp(AMD64Kind.QWORD, dst, rbp.asValue(LIRKind.value(AMD64Kind.QWORD))));
174             return dst;
175         }




176     }
177 
178     private SaveRbp saveRbp;
179 
180     protected void emitSaveRbp() {
181         NoOp placeholder = new NoOp(getCurrentBlock(), getResult().getLIR().getLIRforBlock(getCurrentBlock()).size());
182         append(placeholder);
183         saveRbp = new SaveRbp(placeholder);
184     }
185 
<span class="line-removed">186     protected SaveRbp getSaveRbp() {</span>
<span class="line-removed">187         return saveRbp;</span>
<span class="line-removed">188     }</span>
<span class="line-removed">189 </span>
190     /**
191      * Helper instruction to reserve a stack slot for the whole method. Note that the actual users
192      * of the stack slot might be inserted after stack slot allocation. This dummy instruction
193      * ensures that the stack slot is alive and gets a real stack slot assigned.
194      */
195     private static final class RescueSlotDummyOp extends LIRInstruction {
196         public static final LIRInstructionClass&lt;RescueSlotDummyOp&gt; TYPE = LIRInstructionClass.create(RescueSlotDummyOp.class);
197 
198         @Alive({OperandFlag.STACK, OperandFlag.UNINITIALIZED}) private AllocatableValue slot;
199 
200         RescueSlotDummyOp(FrameMapBuilder frameMapBuilder, LIRKind kind) {
201             super(TYPE);
202             slot = frameMapBuilder.allocateSpillSlot(kind);
203         }
204 
205         public AllocatableValue getSlot() {
206             return slot;
207         }
208 
209         @Override
</pre>
<hr />
<pre>
282         return getResult().getStub() != null;
283     }
284 
285     private LIRFrameState currentRuntimeCallInfo;
286 
287     @Override
288     protected void emitForeignCallOp(ForeignCallLinkage linkage, Value result, Value[] arguments, Value[] temps, LIRFrameState info) {
289         currentRuntimeCallInfo = info;
290         HotSpotForeignCallLinkage hsLinkage = (HotSpotForeignCallLinkage) linkage;
291         AMD64 arch = (AMD64) target().arch;
292         if (arch.getFeatures().contains(AMD64.CPUFeature.AVX) &amp;&amp; hsLinkage.mayContainFP() &amp;&amp; !hsLinkage.isCompiledStub()) {
293             /*
294              * If the target may contain FP ops, and it is not compiled by us, we may have an
295              * AVX-SSE transition.
296              *
297              * We exclude the argument registers from the zeroing LIR instruction since it violates
298              * the LIR semantics of @Temp that values must not be live. Note that the emitted
299              * machine instruction actually zeros _all_ XMM registers which is fine since we know
300              * that their upper half is not used.
301              */
<span class="line-modified">302             append(new AMD64VZeroUpper(arguments));</span>
303         }
304         super.emitForeignCallOp(linkage, result, arguments, temps, info);
305     }
306 
307     /**
308      * @param savedRegisters the registers saved by this operation which may be subject to pruning
309      * @param savedRegisterLocations the slots to which the registers are saved
<span class="line-removed">310      * @param supportsRemove determines if registers can be pruned</span>
311      */
<span class="line-modified">312     protected AMD64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations, boolean supportsRemove) {</span>
<span class="line-modified">313         AMD64SaveRegistersOp save = new AMD64SaveRegistersOp(savedRegisters, savedRegisterLocations, supportsRemove);</span>
314         append(save);
315         return save;
316     }
317 
318     /**
319      * Allocate a stack slot for saving a register.
320      */
321     protected VirtualStackSlot allocateSaveRegisterLocation(Register register) {
322         PlatformKind kind = target().arch.getLargestStorableKind(register.getRegisterCategory());
323         if (kind.getVectorLength() &gt; 1) {
324             // we don&#39;t use vector registers, so there is no need to save them
325             kind = AMD64Kind.DOUBLE;
326         }
327         return getResult().getFrameMapBuilder().allocateSpillSlot(LIRKind.value(kind));
328     }
329 
330     /**
331      * Adds a node to the graph that saves all allocatable registers to the stack.
332      *
<span class="line-removed">333      * @param supportsRemove determines if registers can be pruned</span>
334      * @return the register save node
335      */
<span class="line-modified">336     private AMD64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters, boolean supportsRemove) {</span>

337         AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];
338         for (int i = 0; i &lt; savedRegisters.length; i++) {
339             savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);
340         }
<span class="line-modified">341         return emitSaveRegisters(savedRegisters, savedRegisterLocations, supportsRemove);</span>




342     }
343 
344     protected void emitRestoreRegisters(AMD64SaveRegistersOp save) {
345         append(new AMD64RestoreRegistersOp(save.getSlots().clone(), save));
346     }
347 
348     /**
349      * Gets the {@link Stub} this generator is generating code for or {@code null} if a stub is not
350      * being generated.
351      */
352     public Stub getStub() {
353         return getResult().getStub();
354     }
355 
356     @Override
357     public HotSpotLIRGenerationResult getResult() {
358         return ((HotSpotLIRGenerationResult) super.getResult());
359     }
360 
361     public void setDebugInfoBuilder(HotSpotDebugInfoBuilder debugInfoBuilder) {
362         this.debugInfoBuilder = debugInfoBuilder;
363     }
364 
365     @Override
366     public Variable emitForeignCall(ForeignCallLinkage linkage, LIRFrameState state, Value... args) {
367         HotSpotForeignCallLinkage hotspotLinkage = (HotSpotForeignCallLinkage) linkage;
368         boolean destroysRegisters = hotspotLinkage.destroysRegisters();
369 
370         AMD64SaveRegistersOp save = null;
371         Stub stub = getStub();
<span class="line-modified">372         if (destroysRegisters) {</span>
<span class="line-modified">373             if (stub != null &amp;&amp; stub.preservesRegisters()) {</span>
<span class="line-removed">374                 Register[] savedRegisters = getRegisterConfig().getAllocatableRegisters().toArray();</span>
<span class="line-removed">375                 save = emitSaveAllRegisters(savedRegisters, true);</span>
<span class="line-removed">376             }</span>
377         }
378 
379         Variable result;
380         LIRFrameState debugInfo = null;
381         if (hotspotLinkage.needsDebugInfo()) {
382             debugInfo = state;
383             assert debugInfo != null || stub != null;
384         }
385 
386         if (hotspotLinkage.needsJavaFrameAnchor()) {
387             Register thread = getProviders().getRegisters().getThreadRegister();
388             append(new AMD64HotSpotCRuntimeCallPrologueOp(config.threadLastJavaSpOffset(), thread));
389             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
390             append(new AMD64HotSpotCRuntimeCallEpilogueOp(config.threadLastJavaSpOffset(), config.threadLastJavaFpOffset(), config.threadLastJavaPcOffset(), thread));
391         } else {
392             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
393         }
394 
<span class="line-modified">395         if (destroysRegisters) {</span>
<span class="line-modified">396             if (stub != null) {</span>
<span class="line-modified">397                 if (stub.preservesRegisters()) {</span>
<span class="line-modified">398                     HotSpotLIRGenerationResult generationResult = getResult();</span>
<span class="line-modified">399                     LIRFrameState key = currentRuntimeCallInfo;</span>
<span class="line-removed">400                     if (key == null) {</span>
<span class="line-removed">401                         key = LIRFrameState.NO_STATE;</span>
<span class="line-removed">402                     }</span>
<span class="line-removed">403                     assert !generationResult.getCalleeSaveInfo().containsKey(key);</span>
<span class="line-removed">404                     generationResult.getCalleeSaveInfo().put(key, save);</span>
<span class="line-removed">405                     emitRestoreRegisters(save);</span>
<span class="line-removed">406                 }</span>
407             }



408         }
409 
410         return result;
411     }
412 
413     @Override
414     public Value emitLoadObjectAddress(Constant constant) {
415         HotSpotObjectConstant objectConstant = (HotSpotObjectConstant) constant;
416         LIRKind kind = objectConstant.isCompressed() ? getLIRKindTool().getNarrowOopKind() : getLIRKindTool().getObjectKind();
417         Variable result = newVariable(kind);
418         append(new AMD64HotSpotLoadAddressOp(result, constant, HotSpotConstantLoadAction.RESOLVE));
419         return result;
420     }
421 
422     @Override
423     public Value emitLoadMetaspaceAddress(Constant constant, HotSpotConstantLoadAction action) {
424         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) constant;
425         LIRKind kind = metaspaceConstant.isCompressed() ? getLIRKindTool().getNarrowPointerKind() : getLIRKindTool().getWordKind();
426         Variable result = newVariable(kind);
427         append(new AMD64HotSpotLoadAddressOp(result, constant, action));
</pre>
<hr />
<pre>
530         LIRKind wordKind = LIRKind.value(target().arch.getWordKind());
531         RegisterValue thread = getProviders().getRegisters().getThreadRegister().asValue(wordKind);
532         AMD64AddressValue address = new AMD64AddressValue(wordKind, thread, offset);
533         arithmeticLIRGen.emitStore(v.getValueKind(), address, v, null);
534     }
535 
536     @Override
537     public void emitDeoptimize(Value actionAndReason, Value speculation, LIRFrameState state) {
538         moveDeoptValuesToThread(actionAndReason, speculation);
539         append(new AMD64DeoptimizeOp(state));
540     }
541 
542     @Override
543     public void emitDeoptimizeCaller(DeoptimizationAction action, DeoptimizationReason reason) {
544         Value actionAndReason = emitJavaConstant(getMetaAccess().encodeDeoptActionAndReason(action, reason, 0));
545         Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
546         moveDeoptValuesToThread(actionAndReason, speculation);
547         append(new AMD64HotSpotDeoptimizeCallerOp());
548     }
549 





550     @Override
551     public void beforeRegisterAllocation() {
552         super.beforeRegisterAllocation();
553         boolean hasDebugInfo = getResult().getLIR().hasDebugInfo();
<span class="line-modified">554         AllocatableValue savedRbp = saveRbp.finalize(hasDebugInfo);</span>









555         if (hasDebugInfo) {
556             getResult().setDeoptimizationRescueSlot(((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).allocateDeoptimizationRescueSlot());
557         }
<span class="line-removed">558 </span>
559         getResult().setMaxInterpreterFrameSize(debugInfoBuilder.maxInterpreterFrameSize());
560 
<span class="line-removed">561         for (AMD64HotSpotRestoreRbpOp op : epilogueOps) {</span>
<span class="line-removed">562             op.setSavedRbp(savedRbp);</span>
<span class="line-removed">563         }</span>
564         if (BenchmarkCounters.enabled) {
565             // ensure that the rescue slot is available
566             LIRInstruction op = getOrInitRescueSlotOp();
567             // insert dummy instruction into the start block
568             LIR lir = getResult().getLIR();
569             ArrayList&lt;LIRInstruction&gt; instructions = lir.getLIRforBlock(lir.getControlFlowGraph().getStartBlock());
570             instructions.add(1, op);
571             lir.getDebug().dump(DebugContext.INFO_LEVEL, lir, &quot;created rescue dummy op&quot;);
572         }
573     }
574 
575     @Override
576     public Value emitCompress(Value pointer, CompressEncoding encoding, boolean nonNull) {
577         LIRKind inputKind = pointer.getValueKind(LIRKind.class);
578         LIRKindTool lirKindTool = getLIRKindTool();
579         assert inputKind.getPlatformKind() == lirKindTool.getObjectKind().getPlatformKind();
580         if (inputKind.isReference(0)) {
581             // oop
582             Variable result = newVariable(lirKindTool.getNarrowOopKind());
583             append(new AMD64Move.CompressPointerOp(result, asAllocatable(pointer), getProviders().getRegisters().getHeapBaseRegister().asValue(), encoding, nonNull, getLIRKindTool()));
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
136     @Override
137     protected int getMaxVectorSize() {
138         return config.maxVectorSize;
139     }
140 
141     /**
142      * Utility for emitting the instruction to save RBP.
143      */
144     class SaveRbp {
145 
146         final NoOp placeholder;
147 
148         /**
149          * The slot reserved for saving RBP.
150          */
151         final StackSlot reservedSlot;
152 
153         SaveRbp(NoOp placeholder) {
154             this.placeholder = placeholder;
155             AMD64FrameMapBuilder frameMapBuilder = (AMD64FrameMapBuilder) getResult().getFrameMapBuilder();
<span class="line-modified">156             this.reservedSlot = config.preserveFramePointer ? null : frameMapBuilder.allocateRBPSpillSlot();</span>
157         }
158 
159         /**
160          * Replaces this operation with the appropriate move for saving rbp.
161          *
162          * @param useStack specifies if rbp must be saved to the stack
163          */
164         public AllocatableValue finalize(boolean useStack) {
<span class="line-added">165             assert !config.preserveFramePointer : &quot;rbp has been pushed onto the stack&quot;;</span>
166             AllocatableValue dst;
167             if (useStack) {
168                 dst = reservedSlot;
169             } else {
170                 ((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).freeRBPSpillSlot();
171                 dst = newVariable(LIRKind.value(AMD64Kind.QWORD));
172             }
173 
174             placeholder.replace(getResult().getLIR(), new MoveFromRegOp(AMD64Kind.QWORD, dst, rbp.asValue(LIRKind.value(AMD64Kind.QWORD))));
175             return dst;
176         }
<span class="line-added">177 </span>
<span class="line-added">178         public void remove() {</span>
<span class="line-added">179             placeholder.remove(getResult().getLIR());</span>
<span class="line-added">180         }</span>
181     }
182 
183     private SaveRbp saveRbp;
184 
185     protected void emitSaveRbp() {
186         NoOp placeholder = new NoOp(getCurrentBlock(), getResult().getLIR().getLIRforBlock(getCurrentBlock()).size());
187         append(placeholder);
188         saveRbp = new SaveRbp(placeholder);
189     }
190 




191     /**
192      * Helper instruction to reserve a stack slot for the whole method. Note that the actual users
193      * of the stack slot might be inserted after stack slot allocation. This dummy instruction
194      * ensures that the stack slot is alive and gets a real stack slot assigned.
195      */
196     private static final class RescueSlotDummyOp extends LIRInstruction {
197         public static final LIRInstructionClass&lt;RescueSlotDummyOp&gt; TYPE = LIRInstructionClass.create(RescueSlotDummyOp.class);
198 
199         @Alive({OperandFlag.STACK, OperandFlag.UNINITIALIZED}) private AllocatableValue slot;
200 
201         RescueSlotDummyOp(FrameMapBuilder frameMapBuilder, LIRKind kind) {
202             super(TYPE);
203             slot = frameMapBuilder.allocateSpillSlot(kind);
204         }
205 
206         public AllocatableValue getSlot() {
207             return slot;
208         }
209 
210         @Override
</pre>
<hr />
<pre>
283         return getResult().getStub() != null;
284     }
285 
286     private LIRFrameState currentRuntimeCallInfo;
287 
288     @Override
289     protected void emitForeignCallOp(ForeignCallLinkage linkage, Value result, Value[] arguments, Value[] temps, LIRFrameState info) {
290         currentRuntimeCallInfo = info;
291         HotSpotForeignCallLinkage hsLinkage = (HotSpotForeignCallLinkage) linkage;
292         AMD64 arch = (AMD64) target().arch;
293         if (arch.getFeatures().contains(AMD64.CPUFeature.AVX) &amp;&amp; hsLinkage.mayContainFP() &amp;&amp; !hsLinkage.isCompiledStub()) {
294             /*
295              * If the target may contain FP ops, and it is not compiled by us, we may have an
296              * AVX-SSE transition.
297              *
298              * We exclude the argument registers from the zeroing LIR instruction since it violates
299              * the LIR semantics of @Temp that values must not be live. Note that the emitted
300              * machine instruction actually zeros _all_ XMM registers which is fine since we know
301              * that their upper half is not used.
302              */
<span class="line-modified">303             append(new AMD64VZeroUpper(arguments, getRegisterConfig()));</span>
304         }
305         super.emitForeignCallOp(linkage, result, arguments, temps, info);
306     }
307 
308     /**
309      * @param savedRegisters the registers saved by this operation which may be subject to pruning
310      * @param savedRegisterLocations the slots to which the registers are saved

311      */
<span class="line-modified">312     protected AMD64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations) {</span>
<span class="line-modified">313         AMD64SaveRegistersOp save = new AMD64SaveRegistersOp(savedRegisters, savedRegisterLocations);</span>
314         append(save);
315         return save;
316     }
317 
318     /**
319      * Allocate a stack slot for saving a register.
320      */
321     protected VirtualStackSlot allocateSaveRegisterLocation(Register register) {
322         PlatformKind kind = target().arch.getLargestStorableKind(register.getRegisterCategory());
323         if (kind.getVectorLength() &gt; 1) {
324             // we don&#39;t use vector registers, so there is no need to save them
325             kind = AMD64Kind.DOUBLE;
326         }
327         return getResult().getFrameMapBuilder().allocateSpillSlot(LIRKind.value(kind));
328     }
329 
330     /**
331      * Adds a node to the graph that saves all allocatable registers to the stack.
332      *

333      * @return the register save node
334      */
<span class="line-modified">335     private AMD64SaveRegistersOp emitSaveAllRegisters() {</span>
<span class="line-added">336         Register[] savedRegisters = getSaveableRegisters();</span>
337         AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];
338         for (int i = 0; i &lt; savedRegisters.length; i++) {
339             savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);
340         }
<span class="line-modified">341         return emitSaveRegisters(savedRegisters, savedRegisterLocations);</span>
<span class="line-added">342     }</span>
<span class="line-added">343 </span>
<span class="line-added">344     protected Register[] getSaveableRegisters() {</span>
<span class="line-added">345         return getResult().getRegisterAllocationConfig().getAllocatableRegisters().toArray();</span>
346     }
347 
348     protected void emitRestoreRegisters(AMD64SaveRegistersOp save) {
349         append(new AMD64RestoreRegistersOp(save.getSlots().clone(), save));
350     }
351 
352     /**
353      * Gets the {@link Stub} this generator is generating code for or {@code null} if a stub is not
354      * being generated.
355      */
356     public Stub getStub() {
357         return getResult().getStub();
358     }
359 
360     @Override
361     public HotSpotLIRGenerationResult getResult() {
362         return ((HotSpotLIRGenerationResult) super.getResult());
363     }
364 
365     public void setDebugInfoBuilder(HotSpotDebugInfoBuilder debugInfoBuilder) {
366         this.debugInfoBuilder = debugInfoBuilder;
367     }
368 
369     @Override
370     public Variable emitForeignCall(ForeignCallLinkage linkage, LIRFrameState state, Value... args) {
371         HotSpotForeignCallLinkage hotspotLinkage = (HotSpotForeignCallLinkage) linkage;
372         boolean destroysRegisters = hotspotLinkage.destroysRegisters();
373 
374         AMD64SaveRegistersOp save = null;
375         Stub stub = getStub();
<span class="line-modified">376         if (destroysRegisters &amp;&amp; stub != null &amp;&amp; stub.shouldSaveRegistersAroundCalls()) {</span>
<span class="line-modified">377             save = emitSaveAllRegisters();</span>



378         }
379 
380         Variable result;
381         LIRFrameState debugInfo = null;
382         if (hotspotLinkage.needsDebugInfo()) {
383             debugInfo = state;
384             assert debugInfo != null || stub != null;
385         }
386 
387         if (hotspotLinkage.needsJavaFrameAnchor()) {
388             Register thread = getProviders().getRegisters().getThreadRegister();
389             append(new AMD64HotSpotCRuntimeCallPrologueOp(config.threadLastJavaSpOffset(), thread));
390             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
391             append(new AMD64HotSpotCRuntimeCallEpilogueOp(config.threadLastJavaSpOffset(), config.threadLastJavaFpOffset(), config.threadLastJavaPcOffset(), thread));
392         } else {
393             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
394         }
395 
<span class="line-modified">396         if (save != null) {</span>
<span class="line-modified">397             HotSpotLIRGenerationResult generationResult = getResult();</span>
<span class="line-modified">398             LIRFrameState key = currentRuntimeCallInfo;</span>
<span class="line-modified">399             if (key == null) {</span>
<span class="line-modified">400                 key = LIRFrameState.NO_STATE;</span>







401             }
<span class="line-added">402             assert !generationResult.getCalleeSaveInfo().containsKey(key);</span>
<span class="line-added">403             generationResult.getCalleeSaveInfo().put(key, save);</span>
<span class="line-added">404             emitRestoreRegisters(save);</span>
405         }
406 
407         return result;
408     }
409 
410     @Override
411     public Value emitLoadObjectAddress(Constant constant) {
412         HotSpotObjectConstant objectConstant = (HotSpotObjectConstant) constant;
413         LIRKind kind = objectConstant.isCompressed() ? getLIRKindTool().getNarrowOopKind() : getLIRKindTool().getObjectKind();
414         Variable result = newVariable(kind);
415         append(new AMD64HotSpotLoadAddressOp(result, constant, HotSpotConstantLoadAction.RESOLVE));
416         return result;
417     }
418 
419     @Override
420     public Value emitLoadMetaspaceAddress(Constant constant, HotSpotConstantLoadAction action) {
421         HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) constant;
422         LIRKind kind = metaspaceConstant.isCompressed() ? getLIRKindTool().getNarrowPointerKind() : getLIRKindTool().getWordKind();
423         Variable result = newVariable(kind);
424         append(new AMD64HotSpotLoadAddressOp(result, constant, action));
</pre>
<hr />
<pre>
527         LIRKind wordKind = LIRKind.value(target().arch.getWordKind());
528         RegisterValue thread = getProviders().getRegisters().getThreadRegister().asValue(wordKind);
529         AMD64AddressValue address = new AMD64AddressValue(wordKind, thread, offset);
530         arithmeticLIRGen.emitStore(v.getValueKind(), address, v, null);
531     }
532 
533     @Override
534     public void emitDeoptimize(Value actionAndReason, Value speculation, LIRFrameState state) {
535         moveDeoptValuesToThread(actionAndReason, speculation);
536         append(new AMD64DeoptimizeOp(state));
537     }
538 
539     @Override
540     public void emitDeoptimizeCaller(DeoptimizationAction action, DeoptimizationReason reason) {
541         Value actionAndReason = emitJavaConstant(getMetaAccess().encodeDeoptActionAndReason(action, reason, 0));
542         Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
543         moveDeoptValuesToThread(actionAndReason, speculation);
544         append(new AMD64HotSpotDeoptimizeCallerOp());
545     }
546 
<span class="line-added">547     @Override</span>
<span class="line-added">548     public void emitDeoptimizeWithExceptionInCaller(Value exception) {</span>
<span class="line-added">549         append(new AMD64HotSpotDeoptimizeWithExceptionCallerOp(config, exception));</span>
<span class="line-added">550     }</span>
<span class="line-added">551 </span>
552     @Override
553     public void beforeRegisterAllocation() {
554         super.beforeRegisterAllocation();
555         boolean hasDebugInfo = getResult().getLIR().hasDebugInfo();
<span class="line-modified">556 </span>
<span class="line-added">557         if (config.preserveFramePointer) {</span>
<span class="line-added">558             saveRbp.remove();</span>
<span class="line-added">559         } else {</span>
<span class="line-added">560             AllocatableValue savedRbp = saveRbp.finalize(hasDebugInfo);</span>
<span class="line-added">561             for (AMD64HotSpotRestoreRbpOp op : epilogueOps) {</span>
<span class="line-added">562                 op.setSavedRbp(savedRbp);</span>
<span class="line-added">563             }</span>
<span class="line-added">564         }</span>
<span class="line-added">565 </span>
566         if (hasDebugInfo) {
567             getResult().setDeoptimizationRescueSlot(((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).allocateDeoptimizationRescueSlot());
568         }

569         getResult().setMaxInterpreterFrameSize(debugInfoBuilder.maxInterpreterFrameSize());
570 



571         if (BenchmarkCounters.enabled) {
572             // ensure that the rescue slot is available
573             LIRInstruction op = getOrInitRescueSlotOp();
574             // insert dummy instruction into the start block
575             LIR lir = getResult().getLIR();
576             ArrayList&lt;LIRInstruction&gt; instructions = lir.getLIRforBlock(lir.getControlFlowGraph().getStartBlock());
577             instructions.add(1, op);
578             lir.getDebug().dump(DebugContext.INFO_LEVEL, lir, &quot;created rescue dummy op&quot;);
579         }
580     }
581 
582     @Override
583     public Value emitCompress(Value pointer, CompressEncoding encoding, boolean nonNull) {
584         LIRKind inputKind = pointer.getValueKind(LIRKind.class);
585         LIRKindTool lirKindTool = getLIRKindTool();
586         assert inputKind.getPlatformKind() == lirKindTool.getObjectKind().getPlatformKind();
587         if (inputKind.isReference(0)) {
588             // oop
589             Variable result = newVariable(lirKindTool.getNarrowOopKind());
590             append(new AMD64Move.CompressPointerOp(result, asAllocatable(pointer), getProviders().getRegisters().getHeapBaseRegister().asValue(), encoding, nonNull, getLIRKindTool()));
</pre>
</td>
</tr>
</table>
<center><a href="AMD64HotSpotJumpToExceptionHandlerInCallerOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64HotSpotLoweringProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
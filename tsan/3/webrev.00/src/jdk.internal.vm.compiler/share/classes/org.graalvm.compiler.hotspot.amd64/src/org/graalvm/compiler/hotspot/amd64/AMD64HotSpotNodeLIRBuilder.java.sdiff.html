<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotNodeLIRBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64HotSpotLoweringProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64HotSpotRegisterAllocationConfig.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotNodeLIRBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.amd64;
 26 
 27 import static jdk.vm.ci.amd64.AMD64.rbp;
 28 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 29 import static org.graalvm.compiler.hotspot.HotSpotBackend.EXCEPTION_HANDLER_IN_CALLER;
 30 

 31 import org.graalvm.compiler.core.amd64.AMD64NodeLIRBuilder;
 32 import org.graalvm.compiler.core.amd64.AMD64NodeMatchRules;
 33 import org.graalvm.compiler.core.common.LIRKind;

 34 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 35 import org.graalvm.compiler.core.gen.DebugInfoBuilder;
 36 import org.graalvm.compiler.hotspot.HotSpotDebugInfoBuilder;
 37 import org.graalvm.compiler.hotspot.HotSpotLIRGenerator;
 38 import org.graalvm.compiler.hotspot.HotSpotLockStack;
 39 import org.graalvm.compiler.hotspot.HotSpotNodeLIRBuilder;
 40 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 41 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
 42 import org.graalvm.compiler.lir.LIRFrameState;
 43 import org.graalvm.compiler.lir.Variable;
 44 import org.graalvm.compiler.lir.amd64.AMD64BreakpointOp;
 45 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 46 import org.graalvm.compiler.nodes.BreakpointNode;
 47 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 48 import org.graalvm.compiler.nodes.DirectCallTargetNode;
 49 import org.graalvm.compiler.nodes.FullInfopointNode;
 50 import org.graalvm.compiler.nodes.IndirectCallTargetNode;
 51 import org.graalvm.compiler.nodes.NodeView;
 52 import org.graalvm.compiler.nodes.ParameterNode;
 53 import org.graalvm.compiler.nodes.SafepointNode;
 54 import org.graalvm.compiler.nodes.StructuredGraph;
 55 import org.graalvm.compiler.nodes.ValueNode;
 56 import org.graalvm.compiler.nodes.spi.NodeValueMap;


 57 
 58 import jdk.vm.ci.amd64.AMD64;
 59 import jdk.vm.ci.amd64.AMD64Kind;
 60 import jdk.vm.ci.code.BytecodeFrame;
 61 import jdk.vm.ci.code.CallingConvention;
 62 import jdk.vm.ci.code.Register;
 63 import jdk.vm.ci.code.RegisterValue;
 64 import jdk.vm.ci.code.StackSlot;
 65 import jdk.vm.ci.code.ValueUtil;
 66 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 67 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 68 import jdk.vm.ci.meta.AllocatableValue;

 69 import jdk.vm.ci.meta.JavaType;

 70 import jdk.vm.ci.meta.Value;

 71 
 72 /**
 73  * LIR generator specialized for AMD64 HotSpot.
 74  */
 75 public class AMD64HotSpotNodeLIRBuilder extends AMD64NodeLIRBuilder implements HotSpotNodeLIRBuilder {
 76 
 77     public AMD64HotSpotNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool gen, AMD64NodeMatchRules nodeMatchRules) {
 78         super(graph, gen, nodeMatchRules);
 79         assert gen instanceof AMD64HotSpotLIRGenerator;
 80         assert getDebugInfoBuilder() instanceof HotSpotDebugInfoBuilder;
 81         ((AMD64HotSpotLIRGenerator) gen).setDebugInfoBuilder(((HotSpotDebugInfoBuilder) getDebugInfoBuilder()));
 82     }
 83 
 84     private AMD64HotSpotLIRGenerator getGen() {
 85         return (AMD64HotSpotLIRGenerator) gen;
 86     }
 87 
 88     @Override
 89     protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeValueMap nodeValueMap) {
 90         HotSpotLockStack lockStack = new HotSpotLockStack(gen.getResult().getFrameMapBuilder(), LIRKind.value(AMD64Kind.QWORD));
</pre>
<hr />
<pre>
179 
180     @Override
181     public void visitFullInfopointNode(FullInfopointNode i) {
182         if (i.getState() != null &amp;&amp; i.getState().bci == BytecodeFrame.AFTER_BCI) {
183             i.getDebug().log(&quot;Ignoring InfopointNode for AFTER_BCI&quot;);
184         } else {
185             super.visitFullInfopointNode(i);
186         }
187     }
188 
189     @Override
190     public void visitBreakpointNode(BreakpointNode node) {
191         JavaType[] sig = new JavaType[node.arguments().size()];
192         for (int i = 0; i &lt; sig.length; i++) {
193             sig[i] = node.arguments().get(i).stamp(NodeView.DEFAULT).javaType(gen.getMetaAccess());
194         }
195 
196         Value[] parameters = visitInvokeArguments(gen.getRegisterConfig().getCallingConvention(HotSpotCallingConventionType.JavaCall, null, sig, gen), node.arguments());
197         append(new AMD64BreakpointOp(parameters));
198     }






























































































199 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.amd64;
 26 
 27 import static jdk.vm.ci.amd64.AMD64.rbp;
 28 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 29 import static org.graalvm.compiler.hotspot.HotSpotBackend.EXCEPTION_HANDLER_IN_CALLER;
 30 
<span class="line-added"> 31 import org.graalvm.compiler.api.replacements.Snippet;</span>
 32 import org.graalvm.compiler.core.amd64.AMD64NodeLIRBuilder;
 33 import org.graalvm.compiler.core.amd64.AMD64NodeMatchRules;
 34 import org.graalvm.compiler.core.common.LIRKind;
<span class="line-added"> 35 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;</span>
 36 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 37 import org.graalvm.compiler.core.gen.DebugInfoBuilder;
 38 import org.graalvm.compiler.hotspot.HotSpotDebugInfoBuilder;
 39 import org.graalvm.compiler.hotspot.HotSpotLIRGenerator;
 40 import org.graalvm.compiler.hotspot.HotSpotLockStack;
 41 import org.graalvm.compiler.hotspot.HotSpotNodeLIRBuilder;
 42 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 43 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
 44 import org.graalvm.compiler.lir.LIRFrameState;
 45 import org.graalvm.compiler.lir.Variable;
 46 import org.graalvm.compiler.lir.amd64.AMD64BreakpointOp;
 47 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 48 import org.graalvm.compiler.nodes.BreakpointNode;
 49 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 50 import org.graalvm.compiler.nodes.DirectCallTargetNode;
 51 import org.graalvm.compiler.nodes.FullInfopointNode;
 52 import org.graalvm.compiler.nodes.IndirectCallTargetNode;
 53 import org.graalvm.compiler.nodes.NodeView;
 54 import org.graalvm.compiler.nodes.ParameterNode;
 55 import org.graalvm.compiler.nodes.SafepointNode;
 56 import org.graalvm.compiler.nodes.StructuredGraph;
 57 import org.graalvm.compiler.nodes.ValueNode;
 58 import org.graalvm.compiler.nodes.spi.NodeValueMap;
<span class="line-added"> 59 import org.graalvm.compiler.replacements.nodes.ArrayCompareToNode;</span>
<span class="line-added"> 60 import org.graalvm.compiler.replacements.nodes.ArrayEqualsNode;</span>
 61 
 62 import jdk.vm.ci.amd64.AMD64;
 63 import jdk.vm.ci.amd64.AMD64Kind;
 64 import jdk.vm.ci.code.BytecodeFrame;
 65 import jdk.vm.ci.code.CallingConvention;
 66 import jdk.vm.ci.code.Register;
 67 import jdk.vm.ci.code.RegisterValue;
 68 import jdk.vm.ci.code.StackSlot;
 69 import jdk.vm.ci.code.ValueUtil;
 70 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 71 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 72 import jdk.vm.ci.meta.AllocatableValue;
<span class="line-added"> 73 import jdk.vm.ci.meta.JavaKind;</span>
 74 import jdk.vm.ci.meta.JavaType;
<span class="line-added"> 75 import jdk.vm.ci.meta.ResolvedJavaMethod;</span>
 76 import jdk.vm.ci.meta.Value;
<span class="line-added"> 77 import org.graalvm.compiler.replacements.nodes.ArrayRegionEqualsNode;</span>
 78 
 79 /**
 80  * LIR generator specialized for AMD64 HotSpot.
 81  */
 82 public class AMD64HotSpotNodeLIRBuilder extends AMD64NodeLIRBuilder implements HotSpotNodeLIRBuilder {
 83 
 84     public AMD64HotSpotNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool gen, AMD64NodeMatchRules nodeMatchRules) {
 85         super(graph, gen, nodeMatchRules);
 86         assert gen instanceof AMD64HotSpotLIRGenerator;
 87         assert getDebugInfoBuilder() instanceof HotSpotDebugInfoBuilder;
 88         ((AMD64HotSpotLIRGenerator) gen).setDebugInfoBuilder(((HotSpotDebugInfoBuilder) getDebugInfoBuilder()));
 89     }
 90 
 91     private AMD64HotSpotLIRGenerator getGen() {
 92         return (AMD64HotSpotLIRGenerator) gen;
 93     }
 94 
 95     @Override
 96     protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeValueMap nodeValueMap) {
 97         HotSpotLockStack lockStack = new HotSpotLockStack(gen.getResult().getFrameMapBuilder(), LIRKind.value(AMD64Kind.QWORD));
</pre>
<hr />
<pre>
186 
187     @Override
188     public void visitFullInfopointNode(FullInfopointNode i) {
189         if (i.getState() != null &amp;&amp; i.getState().bci == BytecodeFrame.AFTER_BCI) {
190             i.getDebug().log(&quot;Ignoring InfopointNode for AFTER_BCI&quot;);
191         } else {
192             super.visitFullInfopointNode(i);
193         }
194     }
195 
196     @Override
197     public void visitBreakpointNode(BreakpointNode node) {
198         JavaType[] sig = new JavaType[node.arguments().size()];
199         for (int i = 0; i &lt; sig.length; i++) {
200             sig[i] = node.arguments().get(i).stamp(NodeView.DEFAULT).javaType(gen.getMetaAccess());
201         }
202 
203         Value[] parameters = visitInvokeArguments(gen.getRegisterConfig().getCallingConvention(HotSpotCallingConventionType.JavaCall, null, sig, gen), node.arguments());
204         append(new AMD64BreakpointOp(parameters));
205     }
<span class="line-added">206 </span>
<span class="line-added">207     private ForeignCallLinkage lookupForeignCall(ForeignCallDescriptor descriptor) {</span>
<span class="line-added">208         return getGen().getForeignCalls().lookupForeignCall(descriptor);</span>
<span class="line-added">209     }</span>
<span class="line-added">210 </span>
<span class="line-added">211     @Override</span>
<span class="line-added">212     public ForeignCallLinkage lookupGraalStub(ValueNode valueNode) {</span>
<span class="line-added">213         ResolvedJavaMethod method = valueNode.graph().method();</span>
<span class="line-added">214         if (method == null || method.getAnnotation(Snippet.class) != null) {</span>
<span class="line-added">215             // Emit assembly for snippet stubs</span>
<span class="line-added">216             return null;</span>
<span class="line-added">217         }</span>
<span class="line-added">218 </span>
<span class="line-added">219         if (valueNode instanceof ArrayEqualsNode) {</span>
<span class="line-added">220             ArrayEqualsNode arrayEqualsNode = (ArrayEqualsNode) valueNode;</span>
<span class="line-added">221             JavaKind kind = arrayEqualsNode.getKind();</span>
<span class="line-added">222             ValueNode length = arrayEqualsNode.getLength();</span>
<span class="line-added">223 </span>
<span class="line-added">224             if (length.isConstant()) {</span>
<span class="line-added">225                 int constantLength = length.asJavaConstant().asInt();</span>
<span class="line-added">226                 if (constantLength &gt;= 0 &amp;&amp; constantLength * kind.getByteCount() &lt; 2 * getGen().getMaxVectorSize()) {</span>
<span class="line-added">227                     // Yield constant-length arrays comparison assembly</span>
<span class="line-added">228                     return null;</span>
<span class="line-added">229                 }</span>
<span class="line-added">230             }</span>
<span class="line-added">231 </span>
<span class="line-added">232             switch (kind) {</span>
<span class="line-added">233                 case Boolean:</span>
<span class="line-added">234                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_BOOLEAN_ARRAY_EQUALS);</span>
<span class="line-added">235                 case Byte:</span>
<span class="line-added">236                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_BYTE_ARRAY_EQUALS);</span>
<span class="line-added">237                 case Char:</span>
<span class="line-added">238                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_CHAR_ARRAY_EQUALS);</span>
<span class="line-added">239                 case Short:</span>
<span class="line-added">240                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_SHORT_ARRAY_EQUALS);</span>
<span class="line-added">241                 case Int:</span>
<span class="line-added">242                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_INT_ARRAY_EQUALS);</span>
<span class="line-added">243                 case Long:</span>
<span class="line-added">244                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_LONG_ARRAY_EQUALS);</span>
<span class="line-added">245                 case Float:</span>
<span class="line-added">246                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_FLOAT_ARRAY_EQUALS);</span>
<span class="line-added">247                 case Double:</span>
<span class="line-added">248                     return lookupForeignCall(AMD64ArrayEqualsStub.STUB_DOUBLE_ARRAY_EQUALS);</span>
<span class="line-added">249                 default:</span>
<span class="line-added">250                     return null;</span>
<span class="line-added">251             }</span>
<span class="line-added">252         } else if (valueNode instanceof ArrayCompareToNode) {</span>
<span class="line-added">253             ArrayCompareToNode arrayCompareToNode = (ArrayCompareToNode) valueNode;</span>
<span class="line-added">254             JavaKind kind1 = arrayCompareToNode.getKind1();</span>
<span class="line-added">255             JavaKind kind2 = arrayCompareToNode.getKind2();</span>
<span class="line-added">256 </span>
<span class="line-added">257             if (kind1 == JavaKind.Byte) {</span>
<span class="line-added">258                 if (kind2 == JavaKind.Byte) {</span>
<span class="line-added">259                     return lookupForeignCall(AMD64ArrayCompareToStub.STUB_BYTE_ARRAY_COMPARE_TO_BYTE_ARRAY);</span>
<span class="line-added">260                 } else if (kind2 == JavaKind.Char) {</span>
<span class="line-added">261                     return lookupForeignCall(AMD64ArrayCompareToStub.STUB_BYTE_ARRAY_COMPARE_TO_CHAR_ARRAY);</span>
<span class="line-added">262                 }</span>
<span class="line-added">263             } else if (kind1 == JavaKind.Char) {</span>
<span class="line-added">264                 if (kind2 == JavaKind.Byte) {</span>
<span class="line-added">265                     return lookupForeignCall(AMD64ArrayCompareToStub.STUB_CHAR_ARRAY_COMPARE_TO_BYTE_ARRAY);</span>
<span class="line-added">266                 } else if (kind2 == JavaKind.Char) {</span>
<span class="line-added">267                     return lookupForeignCall(AMD64ArrayCompareToStub.STUB_CHAR_ARRAY_COMPARE_TO_CHAR_ARRAY);</span>
<span class="line-added">268                 }</span>
<span class="line-added">269             }</span>
<span class="line-added">270         } else if (valueNode instanceof ArrayRegionEqualsNode) {</span>
<span class="line-added">271             ArrayRegionEqualsNode arrayRegionEqualsNode = (ArrayRegionEqualsNode) valueNode;</span>
<span class="line-added">272             JavaKind kind1 = arrayRegionEqualsNode.getKind1();</span>
<span class="line-added">273             JavaKind kind2 = arrayRegionEqualsNode.getKind2();</span>
<span class="line-added">274             ValueNode length = arrayRegionEqualsNode.getLength();</span>
<span class="line-added">275 </span>
<span class="line-added">276             if (length.isConstant()) {</span>
<span class="line-added">277                 int constantLength = length.asJavaConstant().asInt();</span>
<span class="line-added">278                 if (constantLength &gt;= 0 &amp;&amp; constantLength * (Math.max(kind1.getByteCount(), kind2.getByteCount())) &lt; 2 * getGen().getMaxVectorSize()) {</span>
<span class="line-added">279                     // Yield constant-length arrays comparison assembly</span>
<span class="line-added">280                     return null;</span>
<span class="line-added">281                 }</span>
<span class="line-added">282             }</span>
<span class="line-added">283 </span>
<span class="line-added">284             if (kind1 == kind2) {</span>
<span class="line-added">285                 switch (kind1) {</span>
<span class="line-added">286                     case Byte:</span>
<span class="line-added">287                         return lookupForeignCall(AMD64ArrayEqualsStub.STUB_BYTE_ARRAY_EQUALS_DIRECT);</span>
<span class="line-added">288                     case Char:</span>
<span class="line-added">289                         return lookupForeignCall(AMD64ArrayEqualsStub.STUB_CHAR_ARRAY_EQUALS_DIRECT);</span>
<span class="line-added">290                     default:</span>
<span class="line-added">291                         return null;</span>
<span class="line-added">292                 }</span>
<span class="line-added">293             } else if (kind1 == JavaKind.Char &amp;&amp; kind2 == JavaKind.Byte) {</span>
<span class="line-added">294                 return lookupForeignCall(AMD64ArrayEqualsStub.STUB_CHAR_ARRAY_EQUALS_BYTE_ARRAY);</span>
<span class="line-added">295             }</span>
<span class="line-added">296         }</span>
<span class="line-added">297 </span>
<span class="line-added">298         return null;</span>
<span class="line-added">299     }</span>
300 }
</pre>
</td>
</tr>
</table>
<center><a href="AMD64HotSpotLoweringProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64HotSpotRegisterAllocationConfig.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
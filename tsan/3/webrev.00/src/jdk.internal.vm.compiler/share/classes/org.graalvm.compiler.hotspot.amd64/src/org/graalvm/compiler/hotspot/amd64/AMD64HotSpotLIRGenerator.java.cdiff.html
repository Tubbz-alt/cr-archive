<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64HotSpotJumpToExceptionHandlerInCallerOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64HotSpotLoweringProvider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotLIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,19 ***</span>
          final StackSlot reservedSlot;
  
          SaveRbp(NoOp placeholder) {
              this.placeholder = placeholder;
              AMD64FrameMapBuilder frameMapBuilder = (AMD64FrameMapBuilder) getResult().getFrameMapBuilder();
<span class="line-modified">!             this.reservedSlot = frameMapBuilder.allocateRBPSpillSlot();</span>
          }
  
          /**
           * Replaces this operation with the appropriate move for saving rbp.
           *
           * @param useStack specifies if rbp must be saved to the stack
           */
          public AllocatableValue finalize(boolean useStack) {
              AllocatableValue dst;
              if (useStack) {
                  dst = reservedSlot;
              } else {
                  ((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).freeRBPSpillSlot();
<span class="line-new-header">--- 151,20 ---</span>
          final StackSlot reservedSlot;
  
          SaveRbp(NoOp placeholder) {
              this.placeholder = placeholder;
              AMD64FrameMapBuilder frameMapBuilder = (AMD64FrameMapBuilder) getResult().getFrameMapBuilder();
<span class="line-modified">!             this.reservedSlot = config.preserveFramePointer ? null : frameMapBuilder.allocateRBPSpillSlot();</span>
          }
  
          /**
           * Replaces this operation with the appropriate move for saving rbp.
           *
           * @param useStack specifies if rbp must be saved to the stack
           */
          public AllocatableValue finalize(boolean useStack) {
<span class="line-added">+             assert !config.preserveFramePointer : &quot;rbp has been pushed onto the stack&quot;;</span>
              AllocatableValue dst;
              if (useStack) {
                  dst = reservedSlot;
              } else {
                  ((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).freeRBPSpillSlot();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,24 ***</span>
              }
  
              placeholder.replace(getResult().getLIR(), new MoveFromRegOp(AMD64Kind.QWORD, dst, rbp.asValue(LIRKind.value(AMD64Kind.QWORD))));
              return dst;
          }
      }
  
      private SaveRbp saveRbp;
  
      protected void emitSaveRbp() {
          NoOp placeholder = new NoOp(getCurrentBlock(), getResult().getLIR().getLIRforBlock(getCurrentBlock()).size());
          append(placeholder);
          saveRbp = new SaveRbp(placeholder);
      }
  
<span class="line-removed">-     protected SaveRbp getSaveRbp() {</span>
<span class="line-removed">-         return saveRbp;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Helper instruction to reserve a stack slot for the whole method. Note that the actual users
       * of the stack slot might be inserted after stack slot allocation. This dummy instruction
       * ensures that the stack slot is alive and gets a real stack slot assigned.
       */
<span class="line-new-header">--- 172,24 ---</span>
              }
  
              placeholder.replace(getResult().getLIR(), new MoveFromRegOp(AMD64Kind.QWORD, dst, rbp.asValue(LIRKind.value(AMD64Kind.QWORD))));
              return dst;
          }
<span class="line-added">+ </span>
<span class="line-added">+         public void remove() {</span>
<span class="line-added">+             placeholder.remove(getResult().getLIR());</span>
<span class="line-added">+         }</span>
      }
  
      private SaveRbp saveRbp;
  
      protected void emitSaveRbp() {
          NoOp placeholder = new NoOp(getCurrentBlock(), getResult().getLIR().getLIRforBlock(getCurrentBlock()).size());
          append(placeholder);
          saveRbp = new SaveRbp(placeholder);
      }
  
      /**
       * Helper instruction to reserve a stack slot for the whole method. Note that the actual users
       * of the stack slot might be inserted after stack slot allocation. This dummy instruction
       * ensures that the stack slot is alive and gets a real stack slot assigned.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,22 ***</span>
               * We exclude the argument registers from the zeroing LIR instruction since it violates
               * the LIR semantics of @Temp that values must not be live. Note that the emitted
               * machine instruction actually zeros _all_ XMM registers which is fine since we know
               * that their upper half is not used.
               */
<span class="line-modified">!             append(new AMD64VZeroUpper(arguments));</span>
          }
          super.emitForeignCallOp(linkage, result, arguments, temps, info);
      }
  
      /**
       * @param savedRegisters the registers saved by this operation which may be subject to pruning
       * @param savedRegisterLocations the slots to which the registers are saved
<span class="line-removed">-      * @param supportsRemove determines if registers can be pruned</span>
       */
<span class="line-modified">!     protected AMD64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations, boolean supportsRemove) {</span>
<span class="line-modified">!         AMD64SaveRegistersOp save = new AMD64SaveRegistersOp(savedRegisters, savedRegisterLocations, supportsRemove);</span>
          append(save);
          return save;
      }
  
      /**
<span class="line-new-header">--- 298,21 ---</span>
               * We exclude the argument registers from the zeroing LIR instruction since it violates
               * the LIR semantics of @Temp that values must not be live. Note that the emitted
               * machine instruction actually zeros _all_ XMM registers which is fine since we know
               * that their upper half is not used.
               */
<span class="line-modified">!             append(new AMD64VZeroUpper(arguments, getRegisterConfig()));</span>
          }
          super.emitForeignCallOp(linkage, result, arguments, temps, info);
      }
  
      /**
       * @param savedRegisters the registers saved by this operation which may be subject to pruning
       * @param savedRegisterLocations the slots to which the registers are saved
       */
<span class="line-modified">!     protected AMD64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations) {</span>
<span class="line-modified">!         AMD64SaveRegistersOp save = new AMD64SaveRegistersOp(savedRegisters, savedRegisterLocations);</span>
          append(save);
          return save;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,19 ***</span>
      }
  
      /**
       * Adds a node to the graph that saves all allocatable registers to the stack.
       *
<span class="line-removed">-      * @param supportsRemove determines if registers can be pruned</span>
       * @return the register save node
       */
<span class="line-modified">!     private AMD64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters, boolean supportsRemove) {</span>
          AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];
          for (int i = 0; i &lt; savedRegisters.length; i++) {
              savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);
          }
<span class="line-modified">!         return emitSaveRegisters(savedRegisters, savedRegisterLocations, supportsRemove);</span>
      }
  
      protected void emitRestoreRegisters(AMD64SaveRegistersOp save) {
          append(new AMD64RestoreRegistersOp(save.getSlots().clone(), save));
      }
<span class="line-new-header">--- 328,23 ---</span>
      }
  
      /**
       * Adds a node to the graph that saves all allocatable registers to the stack.
       *
       * @return the register save node
       */
<span class="line-modified">!     private AMD64SaveRegistersOp emitSaveAllRegisters() {</span>
<span class="line-added">+         Register[] savedRegisters = getSaveableRegisters();</span>
          AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];
          for (int i = 0; i &lt; savedRegisters.length; i++) {
              savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);
          }
<span class="line-modified">!         return emitSaveRegisters(savedRegisters, savedRegisterLocations);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected Register[] getSaveableRegisters() {</span>
<span class="line-added">+         return getResult().getRegisterAllocationConfig().getAllocatableRegisters().toArray();</span>
      }
  
      protected void emitRestoreRegisters(AMD64SaveRegistersOp save) {
          append(new AMD64RestoreRegistersOp(save.getSlots().clone(), save));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 367,15 ***</span>
          HotSpotForeignCallLinkage hotspotLinkage = (HotSpotForeignCallLinkage) linkage;
          boolean destroysRegisters = hotspotLinkage.destroysRegisters();
  
          AMD64SaveRegistersOp save = null;
          Stub stub = getStub();
<span class="line-modified">!         if (destroysRegisters) {</span>
<span class="line-modified">!             if (stub != null &amp;&amp; stub.preservesRegisters()) {</span>
<span class="line-removed">-                 Register[] savedRegisters = getRegisterConfig().getAllocatableRegisters().toArray();</span>
<span class="line-removed">-                 save = emitSaveAllRegisters(savedRegisters, true);</span>
<span class="line-removed">-             }</span>
          }
  
          Variable result;
          LIRFrameState debugInfo = null;
          if (hotspotLinkage.needsDebugInfo()) {
<span class="line-new-header">--- 371,12 ---</span>
          HotSpotForeignCallLinkage hotspotLinkage = (HotSpotForeignCallLinkage) linkage;
          boolean destroysRegisters = hotspotLinkage.destroysRegisters();
  
          AMD64SaveRegistersOp save = null;
          Stub stub = getStub();
<span class="line-modified">!         if (destroysRegisters &amp;&amp; stub != null &amp;&amp; stub.shouldSaveRegistersAroundCalls()) {</span>
<span class="line-modified">!             save = emitSaveAllRegisters();</span>
          }
  
          Variable result;
          LIRFrameState debugInfo = null;
          if (hotspotLinkage.needsDebugInfo()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,23 ***</span>
              append(new AMD64HotSpotCRuntimeCallEpilogueOp(config.threadLastJavaSpOffset(), config.threadLastJavaFpOffset(), config.threadLastJavaPcOffset(), thread));
          } else {
              result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
          }
  
<span class="line-modified">!         if (destroysRegisters) {</span>
<span class="line-modified">!             if (stub != null) {</span>
<span class="line-modified">!                 if (stub.preservesRegisters()) {</span>
<span class="line-modified">!                     HotSpotLIRGenerationResult generationResult = getResult();</span>
<span class="line-modified">!                     LIRFrameState key = currentRuntimeCallInfo;</span>
<span class="line-removed">-                     if (key == null) {</span>
<span class="line-removed">-                         key = LIRFrameState.NO_STATE;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     assert !generationResult.getCalleeSaveInfo().containsKey(key);</span>
<span class="line-removed">-                     generationResult.getCalleeSaveInfo().put(key, save);</span>
<span class="line-removed">-                     emitRestoreRegisters(save);</span>
<span class="line-removed">-                 }</span>
              }
          }
  
          return result;
      }
  
<span class="line-new-header">--- 391,19 ---</span>
              append(new AMD64HotSpotCRuntimeCallEpilogueOp(config.threadLastJavaSpOffset(), config.threadLastJavaFpOffset(), config.threadLastJavaPcOffset(), thread));
          } else {
              result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
          }
  
<span class="line-modified">!         if (save != null) {</span>
<span class="line-modified">!             HotSpotLIRGenerationResult generationResult = getResult();</span>
<span class="line-modified">!             LIRFrameState key = currentRuntimeCallInfo;</span>
<span class="line-modified">!             if (key == null) {</span>
<span class="line-modified">!                 key = LIRFrameState.NO_STATE;</span>
              }
<span class="line-added">+             assert !generationResult.getCalleeSaveInfo().containsKey(key);</span>
<span class="line-added">+             generationResult.getCalleeSaveInfo().put(key, save);</span>
<span class="line-added">+             emitRestoreRegisters(save);</span>
          }
  
          return result;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 545,24 ***</span>
          Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
          moveDeoptValuesToThread(actionAndReason, speculation);
          append(new AMD64HotSpotDeoptimizeCallerOp());
      }
  
      @Override
      public void beforeRegisterAllocation() {
          super.beforeRegisterAllocation();
          boolean hasDebugInfo = getResult().getLIR().hasDebugInfo();
<span class="line-modified">!         AllocatableValue savedRbp = saveRbp.finalize(hasDebugInfo);</span>
          if (hasDebugInfo) {
              getResult().setDeoptimizationRescueSlot(((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).allocateDeoptimizationRescueSlot());
          }
<span class="line-removed">- </span>
          getResult().setMaxInterpreterFrameSize(debugInfoBuilder.maxInterpreterFrameSize());
  
<span class="line-removed">-         for (AMD64HotSpotRestoreRbpOp op : epilogueOps) {</span>
<span class="line-removed">-             op.setSavedRbp(savedRbp);</span>
<span class="line-removed">-         }</span>
          if (BenchmarkCounters.enabled) {
              // ensure that the rescue slot is available
              LIRInstruction op = getOrInitRescueSlotOp();
              // insert dummy instruction into the start block
              LIR lir = getResult().getLIR();
<span class="line-new-header">--- 542,34 ---</span>
          Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
          moveDeoptValuesToThread(actionAndReason, speculation);
          append(new AMD64HotSpotDeoptimizeCallerOp());
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void emitDeoptimizeWithExceptionInCaller(Value exception) {</span>
<span class="line-added">+         append(new AMD64HotSpotDeoptimizeWithExceptionCallerOp(config, exception));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public void beforeRegisterAllocation() {
          super.beforeRegisterAllocation();
          boolean hasDebugInfo = getResult().getLIR().hasDebugInfo();
<span class="line-modified">! </span>
<span class="line-added">+         if (config.preserveFramePointer) {</span>
<span class="line-added">+             saveRbp.remove();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             AllocatableValue savedRbp = saveRbp.finalize(hasDebugInfo);</span>
<span class="line-added">+             for (AMD64HotSpotRestoreRbpOp op : epilogueOps) {</span>
<span class="line-added">+                 op.setSavedRbp(savedRbp);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          if (hasDebugInfo) {
              getResult().setDeoptimizationRescueSlot(((AMD64FrameMapBuilder) getResult().getFrameMapBuilder()).allocateDeoptimizationRescueSlot());
          }
          getResult().setMaxInterpreterFrameSize(debugInfoBuilder.maxInterpreterFrameSize());
  
          if (BenchmarkCounters.enabled) {
              // ensure that the rescue slot is available
              LIRInstruction op = getOrInitRescueSlotOp();
              // insert dummy instruction into the start block
              LIR lir = getResult().getLIR();
</pre>
<center><a href="AMD64HotSpotJumpToExceptionHandlerInCallerOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64HotSpotLoweringProvider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64HotSpotAddressLowering.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64HotSpotBackendFactory.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotBackend.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,10 +24,11 @@</span>
  
  package org.graalvm.compiler.hotspot.amd64;
  
  import static jdk.vm.ci.amd64.AMD64.r10;
  import static jdk.vm.ci.amd64.AMD64.rax;
<span class="udiff-line-added">+ import static jdk.vm.ci.amd64.AMD64.rbp;</span>
  import static jdk.vm.ci.amd64.AMD64.rsp;
  import static jdk.vm.ci.code.ValueUtil.asRegister;
  import static org.graalvm.compiler.core.common.GraalOptions.CanOmitFrame;
  import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
  import static org.graalvm.compiler.core.common.GraalOptions.ZapStackOnMethodEntry;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -38,11 +39,10 @@</span>
  import org.graalvm.compiler.asm.amd64.AMD64Address;
  import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
  import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
  import org.graalvm.compiler.code.CompilationResult;
  import org.graalvm.compiler.core.amd64.AMD64NodeMatchRules;
<span class="udiff-line-removed">- import org.graalvm.compiler.core.common.CompilationIdentifier;</span>
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;
  import org.graalvm.compiler.core.gen.LIRGenerationProvider;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -89,27 +89,22 @@</span>
  
      public AMD64HotSpotBackend(GraalHotSpotVMConfig config, HotSpotGraalRuntimeProvider runtime, HotSpotProviders providers) {
          super(config, runtime, providers);
      }
  
<span class="udiff-line-modified-removed">-     private FrameMapBuilder newFrameMapBuilder(RegisterConfig registerConfig) {</span>
<span class="udiff-line-modified-added">+     @Override</span>
<span class="udiff-line-added">+     protected FrameMapBuilder newFrameMapBuilder(RegisterConfig registerConfig) {</span>
          RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
<span class="udiff-line-modified-removed">-         FrameMap frameMap = new AMD64FrameMap(getCodeCache(), registerConfigNonNull, this);</span>
<span class="udiff-line-modified-added">+         FrameMap frameMap = new AMD64FrameMap(getCodeCache(), registerConfigNonNull, this, config.preserveFramePointer);</span>
          return new AMD64FrameMapBuilder(frameMap, getCodeCache(), registerConfigNonNull);
      }
  
      @Override
      public LIRGeneratorTool newLIRGenerator(LIRGenerationResult lirGenRes) {
          return new AMD64HotSpotLIRGenerator(getProviders(), config, lirGenRes);
      }
  
<span class="udiff-line-removed">-     @Override</span>
<span class="udiff-line-removed">-     public LIRGenerationResult newLIRGenerationResult(CompilationIdentifier compilationId, LIR lir, RegisterConfig registerConfig, StructuredGraph graph, Object stub) {</span>
<span class="udiff-line-removed">-         return new HotSpotLIRGenerationResult(compilationId, lir, newFrameMapBuilder(registerConfig), makeCallingConvention(graph, (Stub) stub), stub,</span>
<span class="udiff-line-removed">-                         config.requiresReservedStackCheck(graph.getMethods()));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      @Override
      public NodeLIRBuilderTool newNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool lirGen) {
          return new AMD64HotSpotNodeLIRBuilder(graph, lirGen, new AMD64NodeMatchRules(lirGen));
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134,14 +129,16 @@</span>
       */
      class HotSpotFrameContext implements FrameContext {
  
          final boolean isStub;
          final boolean omitFrame;
<span class="udiff-line-added">+         final boolean useStandardFrameProlog;</span>
  
<span class="udiff-line-modified-removed">-         HotSpotFrameContext(boolean isStub, boolean omitFrame) {</span>
<span class="udiff-line-modified-added">+         HotSpotFrameContext(boolean isStub, boolean omitFrame, boolean useStandardFrameProlog) {</span>
              this.isStub = isStub;
              this.omitFrame = omitFrame;
<span class="udiff-line-added">+             this.useStandardFrameProlog = useStandardFrameProlog;</span>
          }
  
          @Override
          public boolean hasFrame() {
              return !omitFrame;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161,10 +158,15 @@</span>
                  if (!isStub) {
                      emitStackOverflowCheck(crb);
                      // assert asm.position() - verifiedEntryPointOffset &gt;=
                      // PATCHED_VERIFIED_ENTRY_POINT_INSTRUCTION_SIZE;
                  }
<span class="udiff-line-added">+                 if (useStandardFrameProlog) {</span>
<span class="udiff-line-added">+                     // Stack-walking friendly instructions</span>
<span class="udiff-line-added">+                     asm.push(rbp);</span>
<span class="udiff-line-added">+                     asm.movq(rbp, rsp);</span>
<span class="udiff-line-added">+                 }</span>
                  if (!isStub &amp;&amp; asm.position() == verifiedEntryPointOffset) {
                      asm.subqWide(rsp, frameSize);
                      assert asm.position() - verifiedEntryPointOffset &gt;= PATCHED_VERIFIED_ENTRY_POINT_INSTRUCTION_SIZE;
                  } else {
                      asm.decrementq(rsp, frameSize);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -184,11 +186,16 @@</span>
              if (!omitFrame) {
                  AMD64MacroAssembler asm = (AMD64MacroAssembler) crb.asm;
                  assert crb.frameMap.getRegisterConfig().getCalleeSaveRegisters() == null;
  
                  int frameSize = crb.frameMap.frameSize();
<span class="udiff-line-modified-removed">-                 asm.incrementq(rsp, frameSize);</span>
<span class="udiff-line-modified-added">+                 if (useStandardFrameProlog) {</span>
<span class="udiff-line-added">+                     asm.movq(rsp, rbp);</span>
<span class="udiff-line-added">+                     asm.pop(rbp);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     asm.incrementq(rsp, frameSize);</span>
<span class="udiff-line-added">+                 }</span>
              }
          }
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -206,23 +213,22 @@</span>
          DebugContext debug = lir.getDebug();
          boolean omitFrame = CanOmitFrame.getValue(options) &amp;&amp; !frameMap.frameNeedsAllocating() &amp;&amp; !lir.hasArgInCallerFrame() &amp;&amp; !gen.hasForeignCall();
  
          Stub stub = gen.getStub();
          Assembler masm = new AMD64MacroAssembler(getTarget());
<span class="udiff-line-modified-removed">-         HotSpotFrameContext frameContext = new HotSpotFrameContext(stub != null, omitFrame);</span>
<span class="udiff-line-modified-added">+         HotSpotFrameContext frameContext = new HotSpotFrameContext(stub != null, omitFrame, config.preserveFramePointer);</span>
          DataBuilder dataBuilder = new HotSpotDataBuilder(getCodeCache().getTarget());
          CompilationResultBuilder crb = factory.createBuilder(getCodeCache(), getForeignCalls(), frameMap, masm, dataBuilder, frameContext, options, debug, compilationResult, Register.None);
          crb.setTotalFrameSize(frameMap.totalFrameSize());
          crb.setMaxInterpreterFrameSize(gen.getMaxInterpreterFrameSize());
          StackSlot deoptimizationRescueSlot = gen.getDeoptimizationRescueSlot();
          if (deoptimizationRescueSlot != null &amp;&amp; stub == null) {
              crb.compilationResult.setCustomStackAreaOffset(deoptimizationRescueSlot);
          }
  
          if (stub != null) {
<span class="udiff-line-modified-removed">-             EconomicSet&lt;Register&gt; destroyedCallerRegisters = gatherDestroyedCallerRegisters(lir);</span>
<span class="udiff-line-removed">-             updateStub(stub, destroyedCallerRegisters, gen.getCalleeSaveInfo(), frameMap);</span>
<span class="udiff-line-modified-added">+             updateStub(stub, gen, frameMap);</span>
          }
  
          return crb;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -261,18 +267,23 @@</span>
              Register receiver = asRegister(cc.getArgument(0));
              AMD64Address src = new AMD64Address(receiver, config.hubOffset);
  
              if (config.useCompressedClassPointers) {
                  Register register = r10;
<span class="udiff-line-modified-removed">-                 AMD64HotSpotMove.decodeKlassPointer(crb, asm, register, providers.getRegisters().getHeapBaseRegister(), src, config);</span>
<span class="udiff-line-modified-added">+                 Register heapBase = providers.getRegisters().getHeapBaseRegister();</span>
<span class="udiff-line-added">+                 AMD64HotSpotMove.decodeKlassPointer(crb, asm, register, heapBase, src, config);</span>
                  if (GeneratePIC.getValue(crb.getOptions())) {
<span class="udiff-line-modified-removed">-                     asm.movq(providers.getRegisters().getHeapBaseRegister(), asm.getPlaceholder(-1));</span>
<span class="udiff-line-modified-added">+                     asm.movq(heapBase, asm.getPlaceholder(-1));</span>
                      crb.recordMark(config.MARKID_NARROW_OOP_BASE_ADDRESS);
                  } else {
                      if (config.narrowKlassBase != 0) {
                          // The heap base register was destroyed above, so restore it
<span class="udiff-line-modified-removed">-                         asm.movq(providers.getRegisters().getHeapBaseRegister(), config.narrowOopBase);</span>
<span class="udiff-line-modified-added">+                         if (config.narrowOopBase == 0L) {</span>
<span class="udiff-line-added">+                             asm.xorq(heapBase, heapBase);</span>
<span class="udiff-line-added">+                         } else {</span>
<span class="udiff-line-added">+                             asm.movq(heapBase, config.narrowOopBase);</span>
<span class="udiff-line-added">+                         }</span>
                      }
                  }
                  asm.cmpq(inlineCacheKlass, register);
              } else {
                  asm.cmpq(inlineCacheKlass, src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -315,11 +326,11 @@</span>
          if (!frameContext.isStub) {
              HotSpotForeignCallsProvider foreignCalls = providers.getForeignCalls();
              crb.recordMark(config.MARKID_EXCEPTION_HANDLER_ENTRY);
              AMD64Call.directCall(crb, asm, foreignCalls.lookupForeignCall(EXCEPTION_HANDLER), null, false, null);
              crb.recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
<span class="udiff-line-modified-removed">-             AMD64Call.directCall(crb, asm, foreignCalls.lookupForeignCall(DEOPTIMIZATION_HANDLER), null, false, null);</span>
<span class="udiff-line-modified-added">+             AMD64Call.directCall(crb, asm, foreignCalls.lookupForeignCall(DEOPT_BLOB_UNPACK), null, false, null);</span>
          } else {
              // No need to emit the stubs for entries back into the method since
              // it has no calls that can cause such &quot;return&quot; entries
  
              if (frameContext.omitFrame) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -330,11 +341,11 @@</span>
      }
  
      @Override
      public RegisterAllocationConfig newRegisterAllocationConfig(RegisterConfig registerConfig, String[] allocationRestrictedTo) {
          RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
<span class="udiff-line-modified-removed">-         return new AMD64HotSpotRegisterAllocationConfig(registerConfigNonNull, allocationRestrictedTo);</span>
<span class="udiff-line-modified-added">+         return new AMD64HotSpotRegisterAllocationConfig(registerConfigNonNull, allocationRestrictedTo, config.preserveFramePointer);</span>
      }
  
      @Override
      public EconomicSet&lt;Register&gt; translateToCallerRegisters(EconomicSet&lt;Register&gt; calleeRegisters) {
          return calleeRegisters;
</pre>
<center><a href="AMD64HotSpotAddressLowering.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64HotSpotBackendFactory.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
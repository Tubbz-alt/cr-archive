<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.amd64/src/org/graalvm/compiler/hotspot/amd64/AMD64HotSpotNodeLIRBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.amd64;
 26 
 27 import static jdk.vm.ci.amd64.AMD64.rbp;
 28 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 29 import static org.graalvm.compiler.hotspot.HotSpotBackend.EXCEPTION_HANDLER_IN_CALLER;
 30 
<a name="2" id="anc2"></a>
 31 import org.graalvm.compiler.core.amd64.AMD64NodeLIRBuilder;
 32 import org.graalvm.compiler.core.amd64.AMD64NodeMatchRules;
 33 import org.graalvm.compiler.core.common.LIRKind;
<a name="3" id="anc3"></a>
 34 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 35 import org.graalvm.compiler.core.gen.DebugInfoBuilder;
 36 import org.graalvm.compiler.hotspot.HotSpotDebugInfoBuilder;
 37 import org.graalvm.compiler.hotspot.HotSpotLIRGenerator;
 38 import org.graalvm.compiler.hotspot.HotSpotLockStack;
 39 import org.graalvm.compiler.hotspot.HotSpotNodeLIRBuilder;
 40 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 41 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
 42 import org.graalvm.compiler.lir.LIRFrameState;
 43 import org.graalvm.compiler.lir.Variable;
 44 import org.graalvm.compiler.lir.amd64.AMD64BreakpointOp;
 45 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 46 import org.graalvm.compiler.nodes.BreakpointNode;
 47 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 48 import org.graalvm.compiler.nodes.DirectCallTargetNode;
 49 import org.graalvm.compiler.nodes.FullInfopointNode;
 50 import org.graalvm.compiler.nodes.IndirectCallTargetNode;
 51 import org.graalvm.compiler.nodes.NodeView;
 52 import org.graalvm.compiler.nodes.ParameterNode;
 53 import org.graalvm.compiler.nodes.SafepointNode;
 54 import org.graalvm.compiler.nodes.StructuredGraph;
 55 import org.graalvm.compiler.nodes.ValueNode;
 56 import org.graalvm.compiler.nodes.spi.NodeValueMap;
<a name="4" id="anc4"></a>

 57 
 58 import jdk.vm.ci.amd64.AMD64;
 59 import jdk.vm.ci.amd64.AMD64Kind;
 60 import jdk.vm.ci.code.BytecodeFrame;
 61 import jdk.vm.ci.code.CallingConvention;
 62 import jdk.vm.ci.code.Register;
 63 import jdk.vm.ci.code.RegisterValue;
 64 import jdk.vm.ci.code.StackSlot;
 65 import jdk.vm.ci.code.ValueUtil;
 66 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 67 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 68 import jdk.vm.ci.meta.AllocatableValue;
<a name="5" id="anc5"></a>
 69 import jdk.vm.ci.meta.JavaType;
<a name="6" id="anc6"></a>
 70 import jdk.vm.ci.meta.Value;
<a name="7" id="anc7"></a>
 71 
 72 /**
 73  * LIR generator specialized for AMD64 HotSpot.
 74  */
 75 public class AMD64HotSpotNodeLIRBuilder extends AMD64NodeLIRBuilder implements HotSpotNodeLIRBuilder {
 76 
 77     public AMD64HotSpotNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool gen, AMD64NodeMatchRules nodeMatchRules) {
 78         super(graph, gen, nodeMatchRules);
 79         assert gen instanceof AMD64HotSpotLIRGenerator;
 80         assert getDebugInfoBuilder() instanceof HotSpotDebugInfoBuilder;
 81         ((AMD64HotSpotLIRGenerator) gen).setDebugInfoBuilder(((HotSpotDebugInfoBuilder) getDebugInfoBuilder()));
 82     }
 83 
 84     private AMD64HotSpotLIRGenerator getGen() {
 85         return (AMD64HotSpotLIRGenerator) gen;
 86     }
 87 
 88     @Override
 89     protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeValueMap nodeValueMap) {
 90         HotSpotLockStack lockStack = new HotSpotLockStack(gen.getResult().getFrameMapBuilder(), LIRKind.value(AMD64Kind.QWORD));
 91         return new HotSpotDebugInfoBuilder(nodeValueMap, lockStack, (HotSpotLIRGenerator) gen);
 92     }
 93 
 94     @Override
 95     protected void emitPrologue(StructuredGraph graph) {
 96 
 97         CallingConvention incomingArguments = gen.getResult().getCallingConvention();
 98 
 99         Value[] params = new Value[incomingArguments.getArgumentCount() + 1];
100         for (int i = 0; i &lt; params.length - 1; i++) {
101             params[i] = incomingArguments.getArgument(i);
102             if (isStackSlot(params[i])) {
103                 StackSlot slot = ValueUtil.asStackSlot(params[i]);
104                 if (slot.isInCallerFrame() &amp;&amp; !gen.getResult().getLIR().hasArgInCallerFrame()) {
105                     gen.getResult().getLIR().setHasArgInCallerFrame();
106                 }
107             }
108         }
109         params[params.length - 1] = rbp.asValue(LIRKind.value(AMD64Kind.QWORD));
110 
111         gen.emitIncomingValues(params);
112 
113         getGen().emitSaveRbp();
114 
115         getGen().append(((HotSpotDebugInfoBuilder) getDebugInfoBuilder()).lockStack());
116 
117         for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
118             Value paramValue = params[param.index()];
119             assert paramValue.getValueKind().equals(getLIRGeneratorTool().getLIRKind(param.stamp(NodeView.DEFAULT))) : paramValue.getValueKind() + &quot; != &quot; + param.stamp(NodeView.DEFAULT);
120             setResult(param, gen.emitMove(paramValue));
121         }
122     }
123 
124     @Override
125     public void visitSafepointNode(SafepointNode i) {
126         LIRFrameState info = state(i);
127         Register thread = getGen().getProviders().getRegisters().getThreadRegister();
128         append(new AMD64HotSpotSafepointOp(info, getGen().config, this, thread));
129     }
130 
131     @Override
132     protected void emitDirectCall(DirectCallTargetNode callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState callState) {
133         InvokeKind invokeKind = ((HotSpotDirectCallTargetNode) callTarget).invokeKind();
134         if (invokeKind.isIndirect()) {
135             append(new AMD64HotspotDirectVirtualCallOp(callTarget.targetMethod(), result, parameters, temps, callState, invokeKind, getGen().config));
136         } else {
137             assert invokeKind.isDirect();
138             HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();
139             assert resolvedMethod.isConcrete() : &quot;Cannot make direct call to abstract method.&quot;;
140             append(new AMD64HotSpotDirectStaticCallOp(callTarget.targetMethod(), result, parameters, temps, callState, invokeKind, getGen().config));
141         }
142     }
143 
144     @Override
145     protected void emitIndirectCall(IndirectCallTargetNode callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState callState) {
146         if (callTarget instanceof HotSpotIndirectCallTargetNode) {
147             Value metaspaceMethodSrc = operand(((HotSpotIndirectCallTargetNode) callTarget).metaspaceMethod());
148             Value targetAddressSrc = operand(callTarget.computedAddress());
149             AllocatableValue metaspaceMethodDst = AMD64.rbx.asValue(metaspaceMethodSrc.getValueKind());
150             AllocatableValue targetAddressDst = AMD64.rax.asValue(targetAddressSrc.getValueKind());
151             gen.emitMove(metaspaceMethodDst, metaspaceMethodSrc);
152             gen.emitMove(targetAddressDst, targetAddressSrc);
153             append(new AMD64IndirectCallOp(callTarget.targetMethod(), result, parameters, temps, metaspaceMethodDst, targetAddressDst, callState, getGen().config));
154         } else {
155             super.emitIndirectCall(callTarget, result, parameters, temps, callState);
156         }
157     }
158 
159     @Override
160     public void emitPatchReturnAddress(ValueNode address) {
161         append(new AMD64HotSpotPatchReturnAddressOp(gen.load(operand(address))));
162     }
163 
164     @Override
165     public void emitJumpToExceptionHandlerInCaller(ValueNode handlerInCallerPc, ValueNode exception, ValueNode exceptionPc) {
166         Variable handler = gen.load(operand(handlerInCallerPc));
167         ForeignCallLinkage linkage = gen.getForeignCalls().lookupForeignCall(EXCEPTION_HANDLER_IN_CALLER);
168         CallingConvention outgoingCc = linkage.getOutgoingCallingConvention();
169         assert outgoingCc.getArgumentCount() == 2;
170         RegisterValue exceptionFixed = (RegisterValue) outgoingCc.getArgument(0);
171         RegisterValue exceptionPcFixed = (RegisterValue) outgoingCc.getArgument(1);
172         gen.emitMove(exceptionFixed, operand(exception));
173         gen.emitMove(exceptionPcFixed, operand(exceptionPc));
174         Register thread = getGen().getProviders().getRegisters().getThreadRegister();
175         AMD64HotSpotJumpToExceptionHandlerInCallerOp op = new AMD64HotSpotJumpToExceptionHandlerInCallerOp(handler, exceptionFixed, exceptionPcFixed, getGen().config.threadIsMethodHandleReturnOffset,
176                         thread);
177         append(op);
178     }
179 
180     @Override
181     public void visitFullInfopointNode(FullInfopointNode i) {
182         if (i.getState() != null &amp;&amp; i.getState().bci == BytecodeFrame.AFTER_BCI) {
183             i.getDebug().log(&quot;Ignoring InfopointNode for AFTER_BCI&quot;);
184         } else {
185             super.visitFullInfopointNode(i);
186         }
187     }
188 
189     @Override
190     public void visitBreakpointNode(BreakpointNode node) {
191         JavaType[] sig = new JavaType[node.arguments().size()];
192         for (int i = 0; i &lt; sig.length; i++) {
193             sig[i] = node.arguments().get(i).stamp(NodeView.DEFAULT).javaType(gen.getMetaAccess());
194         }
195 
196         Value[] parameters = visitInvokeArguments(gen.getRegisterConfig().getCallingConvention(HotSpotCallingConventionType.JavaCall, null, sig, gen), node.arguments());
197         append(new AMD64BreakpointOp(parameters));
198     }
<a name="8" id="anc8"></a>





























































































199 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
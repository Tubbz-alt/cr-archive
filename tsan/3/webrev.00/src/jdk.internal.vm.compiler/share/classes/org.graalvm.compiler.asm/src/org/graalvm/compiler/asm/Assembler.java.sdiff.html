<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm/src/org/graalvm/compiler/asm/Assembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.asm.test/src/org/graalvm/compiler/asm/test/AssemblerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Buffer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm/src/org/graalvm/compiler/asm/Assembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.asm;
 26 
 27 import java.util.ArrayList;
 28 import java.util.HashMap;
 29 import java.util.List;
 30 import java.util.Map;
 31 import java.util.function.Consumer;
 32 


 33 import jdk.vm.ci.code.Register;
 34 import jdk.vm.ci.code.StackSlot;
 35 import jdk.vm.ci.code.TargetDescription;
 36 
 37 /**
 38  * The platform-independent base class for the assembler.
 39  */
 40 public abstract class Assembler {
 41 
 42     public abstract static class CodeAnnotation {
 43         /**
 44          * The position (bytes from the beginning of the method) of the annotated instruction.
 45          */
 46         public final int instructionPosition;
 47 
 48         protected CodeAnnotation(int instructionStartPosition) {
 49             this.instructionPosition = instructionStartPosition;
 50         }
 51     }
 52 
 53     public final TargetDescription target;
 54     private List&lt;LabelHint&gt; jumpDisplacementHints;
 55 





 56     /**
 57      * Backing code buffer.
 58      */
 59     private final Buffer codeBuffer;
 60 
 61     protected Consumer&lt;CodeAnnotation&gt; codePatchingAnnotationConsumer;
 62 
 63     public Assembler(TargetDescription target) {
 64         this.target = target;
 65         this.codeBuffer = new Buffer(target.arch.getByteOrder());
 66     }
 67 
 68     public void setCodePatchingAnnotationConsumer(Consumer&lt;CodeAnnotation&gt; codeAnnotationConsumer) {
 69         assert this.codePatchingAnnotationConsumer == null : &quot;overwriting existing value&quot;;
 70         this.codePatchingAnnotationConsumer = codeAnnotationConsumer;
 71     }
 72 
 73     /**
 74      * Returns the current position of the underlying code buffer.
 75      *
</pre>
<hr />
<pre>
106     public final void emitInt(int b, int pos) {
107         codeBuffer.emitInt(b, pos);
108     }
109 
110     public final void emitLong(long b, int pos) {
111         codeBuffer.emitLong(b, pos);
112     }
113 
114     public final int getByte(int pos) {
115         return codeBuffer.getByte(pos);
116     }
117 
118     public final int getShort(int pos) {
119         return codeBuffer.getShort(pos);
120     }
121 
122     public final int getInt(int pos) {
123         return codeBuffer.getInt(pos);
124     }
125 
<span class="line-modified">126     private static final String NEWLINE = System.getProperty(&quot;line.separator&quot;);</span>
127 
128     /**
129      * Some GPU architectures have a text based encoding.
130      */
131     public final void emitString(String x) {
132         emitString0(&quot;\t&quot;);  // XXX REMOVE ME pretty-printing
133         emitString0(x);
134         emitString0(NEWLINE);
135     }
136 
137     // XXX for pretty-printing
138     public final void emitString0(String x) {
139         codeBuffer.emitBytes(x.getBytes(), 0, x.length());
140     }
141 
142     public void emitString(String s, int pos) {
143         codeBuffer.emitBytes(s.getBytes(), pos);
144     }
145 
146     /**
147      * Closes this assembler. No extra data can be written to this assembler after this call.
148      *
149      * @param trimmedCopy if {@code true}, then a copy of the underlying byte array up to (but not
150      *            including) {@code position()} is returned
151      * @return the data in this buffer or a trimmed copy if {@code trimmedCopy} is {@code true}
152      */
153     public byte[] close(boolean trimmedCopy) {

154         return codeBuffer.close(trimmedCopy);
155     }
156 

















157     public void bind(Label l) {
158         assert !l.isBound() : &quot;can bind label only once&quot;;
<span class="line-modified">159         l.bind(position());</span>
<span class="line-removed">160         l.patchInstructions(this);</span>
161     }
162 
163     public abstract void align(int modulus);
164 
165     public abstract void jmp(Label l);
166 
167     protected abstract void patchJumpTarget(int branch, int jumpTarget);
168 
169     private Map&lt;Label, String&gt; nameMap;
170 
171     /**
172      * Creates a name for a label.
173      *
174      * @param l the label for which a name is being created
175      * @param id a label identifier that is unique with the scope of this assembler
176      * @return a label name in the form of &quot;L123&quot;
177      */
178     protected String createLabelName(Label l, int id) {
179         return &quot;L&quot; + id;
180     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.asm;
 26 
 27 import java.util.ArrayList;
 28 import java.util.HashMap;
 29 import java.util.List;
 30 import java.util.Map;
 31 import java.util.function.Consumer;
 32 
<span class="line-added"> 33 import org.graalvm.compiler.debug.GraalError;</span>
<span class="line-added"> 34 </span>
 35 import jdk.vm.ci.code.Register;
 36 import jdk.vm.ci.code.StackSlot;
 37 import jdk.vm.ci.code.TargetDescription;
 38 
 39 /**
 40  * The platform-independent base class for the assembler.
 41  */
 42 public abstract class Assembler {
 43 
 44     public abstract static class CodeAnnotation {
 45         /**
 46          * The position (bytes from the beginning of the method) of the annotated instruction.
 47          */
 48         public final int instructionPosition;
 49 
 50         protected CodeAnnotation(int instructionStartPosition) {
 51             this.instructionPosition = instructionStartPosition;
 52         }
 53     }
 54 
 55     public final TargetDescription target;
 56     private List&lt;LabelHint&gt; jumpDisplacementHints;
 57 
<span class="line-added"> 58     /**</span>
<span class="line-added"> 59      * Labels with instructions to be patched when it is {@linkplain Label#bind bound}.</span>
<span class="line-added"> 60      */</span>
<span class="line-added"> 61     Label labelsWithPatches;</span>
<span class="line-added"> 62 </span>
 63     /**
 64      * Backing code buffer.
 65      */
 66     private final Buffer codeBuffer;
 67 
 68     protected Consumer&lt;CodeAnnotation&gt; codePatchingAnnotationConsumer;
 69 
 70     public Assembler(TargetDescription target) {
 71         this.target = target;
 72         this.codeBuffer = new Buffer(target.arch.getByteOrder());
 73     }
 74 
 75     public void setCodePatchingAnnotationConsumer(Consumer&lt;CodeAnnotation&gt; codeAnnotationConsumer) {
 76         assert this.codePatchingAnnotationConsumer == null : &quot;overwriting existing value&quot;;
 77         this.codePatchingAnnotationConsumer = codeAnnotationConsumer;
 78     }
 79 
 80     /**
 81      * Returns the current position of the underlying code buffer.
 82      *
</pre>
<hr />
<pre>
113     public final void emitInt(int b, int pos) {
114         codeBuffer.emitInt(b, pos);
115     }
116 
117     public final void emitLong(long b, int pos) {
118         codeBuffer.emitLong(b, pos);
119     }
120 
121     public final int getByte(int pos) {
122         return codeBuffer.getByte(pos);
123     }
124 
125     public final int getShort(int pos) {
126         return codeBuffer.getShort(pos);
127     }
128 
129     public final int getInt(int pos) {
130         return codeBuffer.getInt(pos);
131     }
132 
<span class="line-modified">133     private static final String NEWLINE = System.lineSeparator();</span>
134 
135     /**
136      * Some GPU architectures have a text based encoding.
137      */
138     public final void emitString(String x) {
139         emitString0(&quot;\t&quot;);  // XXX REMOVE ME pretty-printing
140         emitString0(x);
141         emitString0(NEWLINE);
142     }
143 
144     // XXX for pretty-printing
145     public final void emitString0(String x) {
146         codeBuffer.emitBytes(x.getBytes(), 0, x.length());
147     }
148 
149     public void emitString(String s, int pos) {
150         codeBuffer.emitBytes(s.getBytes(), pos);
151     }
152 
153     /**
154      * Closes this assembler. No extra data can be written to this assembler after this call.
155      *
156      * @param trimmedCopy if {@code true}, then a copy of the underlying byte array up to (but not
157      *            including) {@code position()} is returned
158      * @return the data in this buffer or a trimmed copy if {@code trimmedCopy} is {@code true}
159      */
160     public byte[] close(boolean trimmedCopy) {
<span class="line-added">161         checkAndClearLabelsWithPatches();</span>
162         return codeBuffer.close(trimmedCopy);
163     }
164 
<span class="line-added">165     public byte[] copy(int start, int end) {</span>
<span class="line-added">166         return codeBuffer.copyData(start, end);</span>
<span class="line-added">167     }</span>
<span class="line-added">168 </span>
<span class="line-added">169     private void checkAndClearLabelsWithPatches() throws InternalError {</span>
<span class="line-added">170         Label label = labelsWithPatches;</span>
<span class="line-added">171         while (label != null) {</span>
<span class="line-added">172             if (label.patchPositions != null) {</span>
<span class="line-added">173                 throw new GraalError(&quot;Label used by instructions at following offsets has not been bound: %s&quot;, label.patchPositions);</span>
<span class="line-added">174             }</span>
<span class="line-added">175             Label next = label.nextWithPatches;</span>
<span class="line-added">176             label.nextWithPatches = null;</span>
<span class="line-added">177             label = next;</span>
<span class="line-added">178         }</span>
<span class="line-added">179         labelsWithPatches = null;</span>
<span class="line-added">180     }</span>
<span class="line-added">181 </span>
182     public void bind(Label l) {
183         assert !l.isBound() : &quot;can bind label only once&quot;;
<span class="line-modified">184         l.bind(position(), this);</span>

185     }
186 
187     public abstract void align(int modulus);
188 
189     public abstract void jmp(Label l);
190 
191     protected abstract void patchJumpTarget(int branch, int jumpTarget);
192 
193     private Map&lt;Label, String&gt; nameMap;
194 
195     /**
196      * Creates a name for a label.
197      *
198      * @param l the label for which a name is being created
199      * @param id a label identifier that is unique with the scope of this assembler
200      * @return a label name in the form of &quot;L123&quot;
201      */
202     protected String createLabelName(Label l, int id) {
203         return &quot;L&quot; + id;
204     }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../org.graalvm.compiler.asm.test/src/org/graalvm/compiler/asm/test/AssemblerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Buffer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
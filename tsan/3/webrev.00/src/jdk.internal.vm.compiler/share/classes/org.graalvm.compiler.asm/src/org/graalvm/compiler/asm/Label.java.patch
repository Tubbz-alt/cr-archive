diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm/src/org/graalvm/compiler/asm/Label.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm/src/org/graalvm/compiler/asm/Label.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm/src/org/graalvm/compiler/asm/Label.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm/src/org/graalvm/compiler/asm/Label.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,23 +24,30 @@
 
 package org.graalvm.compiler.asm;
 
 import java.util.ArrayList;
 
+import org.graalvm.compiler.debug.GraalError;
+
 /**
  * This class represents a label within assembly code.
  */
 public final class Label {
 
     private int position = -1;
     private int blockId = -1;
 
     /**
-     * References to instructions that jump to this unresolved label. These instructions need to be
-     * patched when the label is bound using the {@link #patchInstructions(Assembler)} method.
+     * Positions of instructions that jump to this unresolved label. These instructions are patched
+     * when the label is bound.
+     */
+    ArrayList<Integer> patchPositions;
+
+    /**
+     * Link in list of labels with instructions to be patched.
      */
-    private ArrayList<Integer> patchPositions = null;
+    Label nextWithPatches;
 
     /**
      * Returns the position of this label in the code buffer.
      *
      * @return the position
@@ -60,40 +67,39 @@
     public int getBlockId() {
         return blockId;
     }
 
     /**
-     * Binds the label to the specified position.
-     *
-     * @param pos the position
+     * Binds the label to {@code pos} and patches all instructions added by
+     * {@link #addPatchAt(int, Assembler)}.
      */
-    protected void bind(int pos) {
+    protected void bind(int pos, Assembler asm) {
+        if (pos < 0) {
+            throw new GraalError("Cannot bind label to negative position %d", pos);
+        }
         this.position = pos;
-        assert isBound();
+        if (patchPositions != null) {
+            for (int i = 0; i < patchPositions.size(); ++i) {
+                asm.patchJumpTarget(patchPositions.get(i), position);
+            }
+            patchPositions = null;
+        }
     }
 
     public boolean isBound() {
         return position >= 0;
     }
 
-    public void addPatchAt(int branchLocation) {
+    public void addPatchAt(int branchLocation, Assembler asm) {
         assert !isBound() : "Label is already bound " + this + " " + branchLocation + " at position " + position;
         if (patchPositions == null) {
             patchPositions = new ArrayList<>(2);
+            nextWithPatches = asm.labelsWithPatches;
+            asm.labelsWithPatches = this;
         }
         patchPositions.add(branchLocation);
-    }
 
-    protected void patchInstructions(Assembler masm) {
-        assert isBound() : "Label should be bound";
-        if (patchPositions != null) {
-            int target = position;
-            for (int i = 0; i < patchPositions.size(); ++i) {
-                int pos = patchPositions.get(i);
-                masm.patchJumpTarget(pos, target);
-            }
-        }
     }
 
     public void reset() {
         if (this.patchPositions != null) {
             this.patchPositions.clear();

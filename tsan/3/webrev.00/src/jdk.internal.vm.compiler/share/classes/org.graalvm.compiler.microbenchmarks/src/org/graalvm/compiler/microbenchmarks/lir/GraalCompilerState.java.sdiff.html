<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.microbenchmarks/src/org/graalvm/compiler/microbenchmarks/lir/GraalCompilerState.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../graal/TestJMHWhitebox.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.nodes.test/src/org/graalvm/compiler/nodes/test/IfNodeCanonicalizationTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.microbenchmarks/src/org/graalvm/compiler/microbenchmarks/lir/GraalCompilerState.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 28 import static org.graalvm.compiler.microbenchmarks.graal.util.GraalUtil.getMethodFromMethodSpec;
 29 
 30 import java.lang.annotation.Annotation;
 31 import java.lang.annotation.ElementType;
 32 import java.lang.annotation.Inherited;
 33 import java.lang.annotation.Retention;
 34 import java.lang.annotation.RetentionPolicy;
 35 import java.lang.annotation.Target;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Method;
 38 
 39 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 40 import org.graalvm.compiler.api.test.Graal;
 41 import org.graalvm.compiler.code.CompilationResult;
 42 import org.graalvm.compiler.core.GraalCompiler;
 43 import org.graalvm.compiler.core.GraalCompiler.Request;
 44 import org.graalvm.compiler.core.LIRGenerationPhase;
 45 import org.graalvm.compiler.core.LIRGenerationPhase.LIRGenerationContext;
 46 import org.graalvm.compiler.core.common.CompilationIdentifier;
 47 import org.graalvm.compiler.core.common.alloc.ComputeBlockOrder;

 48 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 49 import org.graalvm.compiler.core.gen.LIRCompilerBackend;
 50 import org.graalvm.compiler.core.gen.LIRGenerationProvider;
 51 import org.graalvm.compiler.core.target.Backend;
 52 import org.graalvm.compiler.debug.DebugContext;
 53 import org.graalvm.compiler.debug.DebugHandlersFactory;
 54 import org.graalvm.compiler.lir.LIR;
 55 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 56 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 57 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 58 import org.graalvm.compiler.lir.phases.AllocationPhase.AllocationContext;
 59 import org.graalvm.compiler.lir.phases.LIRPhase;
 60 import org.graalvm.compiler.lir.phases.LIRSuites;
 61 import org.graalvm.compiler.lir.phases.PostAllocationOptimizationPhase.PostAllocationOptimizationContext;
 62 import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase.PreAllocationOptimizationContext;
 63 import org.graalvm.compiler.microbenchmarks.graal.util.GraalState;
 64 import org.graalvm.compiler.microbenchmarks.graal.util.GraalUtil;
 65 import org.graalvm.compiler.microbenchmarks.graal.util.MethodSpec;
 66 import org.graalvm.compiler.nodes.StructuredGraph;
 67 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
</pre>
<hr />
<pre>
360     }
361 
362     /**
363      * Sets up {@link LIR} generation.
364      */
365     protected final void preLIRGeneration() {
366         assert request.graph.isFrozen() : &quot;Graph not frozen.&quot;;
367         Object stub = null;
368         schedule = request.graph.getLastSchedule();
369         ControlFlowGraph cfg = deepCopy(schedule.getCFG());
370         Block[] blocks = cfg.getBlocks();
371         Block startBlock = cfg.getStartBlock();
372         assert startBlock != null;
373         assert startBlock.getPredecessorCount() == 0;
374 
375         codeEmittingOrder = ComputeBlockOrder.computeCodeEmittingOrder(blocks.length, startBlock);
376         linearScanOrder = ComputeBlockOrder.computeLinearScanOrder(blocks.length, startBlock);
377 
378         LIR lir = new LIR(cfg, linearScanOrder, codeEmittingOrder, getGraphOptions(), getGraphDebug());
379         LIRGenerationProvider lirBackend = (LIRGenerationProvider) request.backend;
<span class="line-modified">380         lirGenRes = lirBackend.newLIRGenerationResult(graph.compilationId(), lir, registerConfig, request.graph, stub);</span>

381         lirGenTool = lirBackend.newLIRGenerator(lirGenRes);
382         nodeLirGen = lirBackend.newNodeLIRBuilder(request.graph, lirGenTool);
383     }
384 
385     protected OptionValues getGraphOptions() {
386         return graph.getOptions();
387     }
388 
389     protected DebugContext getGraphDebug() {
390         return graph.getDebug();
391     }
392 
393     private static ControlFlowGraph deepCopy(ControlFlowGraph cfg) {
394         return ControlFlowGraph.compute(cfg.graph, true, true, true, true);
395     }
396 
397     /**
398      * Executes the {@link LIRGenerationPhase}.
399      */
400     protected final void lirGeneration() {
</pre>
<hr />
<pre>
424      * {@link LIRPhase phases} can be changed by overriding {@link #createLIRSuites}.
425      */
426     protected final void preAllocationStage() {
427         applyLIRPhase(getLIRSuites().getPreAllocationOptimizationStage(), createPreAllocationOptimizationContext());
428     }
429 
430     protected PreAllocationOptimizationContext createPreAllocationOptimizationContext() {
431         return new PreAllocationOptimizationContext(lirGenTool);
432     }
433 
434     /**
435      * Executes the {@link AllocationStage}.
436      *
437      * {@link LIRPhase phases} can be changed by overriding {@link #createLIRSuites}.
438      */
439     protected final void allocationStage() {
440         applyLIRPhase(getLIRSuites().getAllocationStage(), createAllocationContext());
441     }
442 
443     protected AllocationContext createAllocationContext() {
<span class="line-modified">444         return new AllocationContext(lirGenTool.getSpillMoveFactory(), request.backend.newRegisterAllocationConfig(registerConfig, null));</span>
445     }
446 
447     /**
448      * Executes the {@link PostAllocationStage}.
449      *
450      * {@link LIRPhase phases} can be changed by overriding {@link #createLIRSuites}.
451      */
452     protected final void postAllocationStage() {
453         applyLIRPhase(getLIRSuites().getPostAllocationOptimizationStage(), createPostAllocationOptimizationContext());
454     }
455 
456     protected PostAllocationOptimizationContext createPostAllocationOptimizationContext() {
457         return new PostAllocationOptimizationContext(lirGenTool);
458     }
459 
460     /**
461      * Emits the machine code.
462      */
463     protected final void emitCode() {
464         int bytecodeSize = request.graph.method() == null ? 0 : request.graph.getBytecodeSize();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 28 import static org.graalvm.compiler.microbenchmarks.graal.util.GraalUtil.getMethodFromMethodSpec;
 29 
 30 import java.lang.annotation.Annotation;
 31 import java.lang.annotation.ElementType;
 32 import java.lang.annotation.Inherited;
 33 import java.lang.annotation.Retention;
 34 import java.lang.annotation.RetentionPolicy;
 35 import java.lang.annotation.Target;
 36 import java.lang.reflect.Field;
 37 import java.lang.reflect.Method;
 38 
 39 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 40 import org.graalvm.compiler.api.test.Graal;
 41 import org.graalvm.compiler.code.CompilationResult;
 42 import org.graalvm.compiler.core.GraalCompiler;
 43 import org.graalvm.compiler.core.GraalCompiler.Request;
 44 import org.graalvm.compiler.core.LIRGenerationPhase;
 45 import org.graalvm.compiler.core.LIRGenerationPhase.LIRGenerationContext;
 46 import org.graalvm.compiler.core.common.CompilationIdentifier;
 47 import org.graalvm.compiler.core.common.alloc.ComputeBlockOrder;
<span class="line-added"> 48 import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;</span>
 49 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 50 import org.graalvm.compiler.core.gen.LIRCompilerBackend;
 51 import org.graalvm.compiler.core.gen.LIRGenerationProvider;
 52 import org.graalvm.compiler.core.target.Backend;
 53 import org.graalvm.compiler.debug.DebugContext;
 54 import org.graalvm.compiler.debug.DebugHandlersFactory;
 55 import org.graalvm.compiler.lir.LIR;
 56 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 57 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 58 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 59 import org.graalvm.compiler.lir.phases.AllocationPhase.AllocationContext;
 60 import org.graalvm.compiler.lir.phases.LIRPhase;
 61 import org.graalvm.compiler.lir.phases.LIRSuites;
 62 import org.graalvm.compiler.lir.phases.PostAllocationOptimizationPhase.PostAllocationOptimizationContext;
 63 import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase.PreAllocationOptimizationContext;
 64 import org.graalvm.compiler.microbenchmarks.graal.util.GraalState;
 65 import org.graalvm.compiler.microbenchmarks.graal.util.GraalUtil;
 66 import org.graalvm.compiler.microbenchmarks.graal.util.MethodSpec;
 67 import org.graalvm.compiler.nodes.StructuredGraph;
 68 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
</pre>
<hr />
<pre>
361     }
362 
363     /**
364      * Sets up {@link LIR} generation.
365      */
366     protected final void preLIRGeneration() {
367         assert request.graph.isFrozen() : &quot;Graph not frozen.&quot;;
368         Object stub = null;
369         schedule = request.graph.getLastSchedule();
370         ControlFlowGraph cfg = deepCopy(schedule.getCFG());
371         Block[] blocks = cfg.getBlocks();
372         Block startBlock = cfg.getStartBlock();
373         assert startBlock != null;
374         assert startBlock.getPredecessorCount() == 0;
375 
376         codeEmittingOrder = ComputeBlockOrder.computeCodeEmittingOrder(blocks.length, startBlock);
377         linearScanOrder = ComputeBlockOrder.computeLinearScanOrder(blocks.length, startBlock);
378 
379         LIR lir = new LIR(cfg, linearScanOrder, codeEmittingOrder, getGraphOptions(), getGraphDebug());
380         LIRGenerationProvider lirBackend = (LIRGenerationProvider) request.backend;
<span class="line-modified">381         RegisterAllocationConfig registerAllocationConfig = request.backend.newRegisterAllocationConfig(registerConfig, null);</span>
<span class="line-added">382         lirGenRes = lirBackend.newLIRGenerationResult(graph.compilationId(), lir, registerAllocationConfig, request.graph, stub);</span>
383         lirGenTool = lirBackend.newLIRGenerator(lirGenRes);
384         nodeLirGen = lirBackend.newNodeLIRBuilder(request.graph, lirGenTool);
385     }
386 
387     protected OptionValues getGraphOptions() {
388         return graph.getOptions();
389     }
390 
391     protected DebugContext getGraphDebug() {
392         return graph.getDebug();
393     }
394 
395     private static ControlFlowGraph deepCopy(ControlFlowGraph cfg) {
396         return ControlFlowGraph.compute(cfg.graph, true, true, true, true);
397     }
398 
399     /**
400      * Executes the {@link LIRGenerationPhase}.
401      */
402     protected final void lirGeneration() {
</pre>
<hr />
<pre>
426      * {@link LIRPhase phases} can be changed by overriding {@link #createLIRSuites}.
427      */
428     protected final void preAllocationStage() {
429         applyLIRPhase(getLIRSuites().getPreAllocationOptimizationStage(), createPreAllocationOptimizationContext());
430     }
431 
432     protected PreAllocationOptimizationContext createPreAllocationOptimizationContext() {
433         return new PreAllocationOptimizationContext(lirGenTool);
434     }
435 
436     /**
437      * Executes the {@link AllocationStage}.
438      *
439      * {@link LIRPhase phases} can be changed by overriding {@link #createLIRSuites}.
440      */
441     protected final void allocationStage() {
442         applyLIRPhase(getLIRSuites().getAllocationStage(), createAllocationContext());
443     }
444 
445     protected AllocationContext createAllocationContext() {
<span class="line-modified">446         return new AllocationContext(lirGenTool.getSpillMoveFactory(), lirGenRes.getRegisterAllocationConfig());</span>
447     }
448 
449     /**
450      * Executes the {@link PostAllocationStage}.
451      *
452      * {@link LIRPhase phases} can be changed by overriding {@link #createLIRSuites}.
453      */
454     protected final void postAllocationStage() {
455         applyLIRPhase(getLIRSuites().getPostAllocationOptimizationStage(), createPostAllocationOptimizationContext());
456     }
457 
458     protected PostAllocationOptimizationContext createPostAllocationOptimizationContext() {
459         return new PostAllocationOptimizationContext(lirGenTool);
460     }
461 
462     /**
463      * Emits the machine code.
464      */
465     protected final void emitCode() {
466         int bytecodeSize = request.graph.method() == null ? 0 : request.graph.getBytecodeSize();
</pre>
</td>
</tr>
</table>
<center><a href="../graal/TestJMHWhitebox.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.nodes.test/src/org/graalvm/compiler/nodes/test/IfNodeCanonicalizationTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
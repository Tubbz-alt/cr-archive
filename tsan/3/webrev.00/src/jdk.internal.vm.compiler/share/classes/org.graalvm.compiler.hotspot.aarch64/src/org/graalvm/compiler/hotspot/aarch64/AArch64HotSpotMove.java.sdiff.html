<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotMove.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64HotSpotLoweringProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotRegisterAllocationConfig.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotMove.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
177         @Alive({REG, ILLEGAL}) protected AllocatableValue baseRegister;
178 
179         public UncompressPointer(AllocatableValue result, AllocatableValue input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull) {
180             super(TYPE);
181             this.result = result;
182             this.input = input;
183             this.baseRegister = baseRegister;
184             this.encoding = encoding;
185             this.nonNull = nonNull;
186         }
187 
188         @Override
189         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
190             Register inputRegister = asRegister(input);
191             Register resultRegister = asRegister(result);
192             Register base = encoding.hasBase() ? asRegister(baseRegister) : null;
193             emitUncompressCode(masm, inputRegister, resultRegister, base, encoding.getShift(), nonNull);
194         }
195 
196         public static void emitUncompressCode(AArch64MacroAssembler masm, Register inputRegister, Register resReg, Register baseReg, int shift, boolean nonNull) {










197             // result = base + (ptr &lt;&lt; shift)
<span class="line-modified">198             if (nonNull || baseReg == null) {</span>
<span class="line-modified">199                 masm.add(64, resReg, baseReg == null ? zr : baseReg, inputRegister, AArch64Assembler.ShiftType.LSL, shift);</span>
200             } else {
201                 // if ptr is null it has to be null after decompression
202                 Label done = new Label();
203                 if (!resReg.equals(inputRegister)) {
204                     masm.mov(32, resReg, inputRegister);
205                 }
206                 masm.cbz(32, resReg, done);
207                 masm.add(64, resReg, baseReg, resReg, AArch64Assembler.ShiftType.LSL, shift);
208                 masm.bind(done);
209             }
210         }
211     }
212 
213     //
214     // private static void decompressPointer(CompilationResultBuilder crb, ARMv8MacroAssembler masm,
215     // Register result,
216     // Register ptr, long base, int shift, int alignment) {
217     // assert base != 0 || shift == 0 || alignment == shift;
218     // // result = heapBase + ptr &lt;&lt; alignment
219     // Register heapBase = ARMv8.heapBaseRegister;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
177         @Alive({REG, ILLEGAL}) protected AllocatableValue baseRegister;
178 
179         public UncompressPointer(AllocatableValue result, AllocatableValue input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull) {
180             super(TYPE);
181             this.result = result;
182             this.input = input;
183             this.baseRegister = baseRegister;
184             this.encoding = encoding;
185             this.nonNull = nonNull;
186         }
187 
188         @Override
189         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
190             Register inputRegister = asRegister(input);
191             Register resultRegister = asRegister(result);
192             Register base = encoding.hasBase() ? asRegister(baseRegister) : null;
193             emitUncompressCode(masm, inputRegister, resultRegister, base, encoding.getShift(), nonNull);
194         }
195 
196         public static void emitUncompressCode(AArch64MacroAssembler masm, Register inputRegister, Register resReg, Register baseReg, int shift, boolean nonNull) {
<span class="line-added">197             // result = ptr &lt;&lt; shift</span>
<span class="line-added">198             if (baseReg == null) {</span>
<span class="line-added">199                 if (shift != 0) {</span>
<span class="line-added">200                     masm.shl(64, resReg, inputRegister, shift);</span>
<span class="line-added">201                 } else if (!resReg.equals(inputRegister)) {</span>
<span class="line-added">202                     masm.movx(resReg, inputRegister);</span>
<span class="line-added">203                 }</span>
<span class="line-added">204                 return;</span>
<span class="line-added">205             }</span>
<span class="line-added">206 </span>
207             // result = base + (ptr &lt;&lt; shift)
<span class="line-modified">208             if (nonNull) {</span>
<span class="line-modified">209                 masm.add(64, resReg, baseReg, inputRegister, AArch64Assembler.ShiftType.LSL, shift);</span>
210             } else {
211                 // if ptr is null it has to be null after decompression
212                 Label done = new Label();
213                 if (!resReg.equals(inputRegister)) {
214                     masm.mov(32, resReg, inputRegister);
215                 }
216                 masm.cbz(32, resReg, done);
217                 masm.add(64, resReg, baseReg, resReg, AArch64Assembler.ShiftType.LSL, shift);
218                 masm.bind(done);
219             }
220         }
221     }
222 
223     //
224     // private static void decompressPointer(CompilationResultBuilder crb, ARMv8MacroAssembler masm,
225     // Register result,
226     // Register ptr, long base, int shift, int alignment) {
227     // assert base != 0 || shift == 0 || alignment == shift;
228     // // result = heapBase + ptr &lt;&lt; alignment
229     // Register heapBase = ARMv8.heapBaseRegister;
</pre>
</td>
</tr>
</table>
<center><a href="AArch64HotSpotLoweringProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotRegisterAllocationConfig.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
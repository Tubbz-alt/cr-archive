<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64HotSpotJumpToExceptionHandlerInCallerOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotLoweringProvider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotLIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2018, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * Copyright (c) 2018, Red Hat Inc. All rights reserved.
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,20 ***</span>
<span class="line-new-header">--- 36,22 ---</span>
  import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.LOAD_COUNTERS;
  import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.RESOLVE;
  import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
  import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
  
<span class="line-added">+ import java.util.EnumSet;</span>
  import java.util.function.Function;
  
  import org.graalvm.compiler.asm.Label;
  import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
  import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ConditionFlag;
  import org.graalvm.compiler.asm.aarch64.AArch64Assembler.PrefetchMode;
  import org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator;
  import org.graalvm.compiler.core.aarch64.AArch64LIRGenerator;
  import org.graalvm.compiler.core.aarch64.AArch64LIRKindTool;
  import org.graalvm.compiler.core.common.CompressEncoding;
<span class="line-added">+ import org.graalvm.compiler.core.common.GraalOptions;</span>
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
  import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
  import org.graalvm.compiler.core.common.spi.LIRKindTool;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
  import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
  import org.graalvm.compiler.hotspot.stubs.Stub;
  import org.graalvm.compiler.lir.LIRFrameState;
  import org.graalvm.compiler.lir.LIRInstruction;
  import org.graalvm.compiler.lir.LabelRef;
<span class="line-modified">! import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>
  import org.graalvm.compiler.lir.SwitchStrategy;
  import org.graalvm.compiler.lir.Variable;
  import org.graalvm.compiler.lir.VirtualStackSlot;
  import org.graalvm.compiler.lir.aarch64.AArch64AddressValue;
  import org.graalvm.compiler.lir.aarch64.AArch64CCall;
<span class="line-new-header">--- 68,11 ---</span>
  import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
  import org.graalvm.compiler.hotspot.stubs.Stub;
  import org.graalvm.compiler.lir.LIRFrameState;
  import org.graalvm.compiler.lir.LIRInstruction;
  import org.graalvm.compiler.lir.LabelRef;
<span class="line-modified">! import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;</span>
  import org.graalvm.compiler.lir.SwitchStrategy;
  import org.graalvm.compiler.lir.Variable;
  import org.graalvm.compiler.lir.VirtualStackSlot;
  import org.graalvm.compiler.lir.aarch64.AArch64AddressValue;
  import org.graalvm.compiler.lir.aarch64.AArch64CCall;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,11 ***</span>
  
      final GraalHotSpotVMConfig config;
      private HotSpotDebugInfoBuilder debugInfoBuilder;
  
      protected AArch64HotSpotLIRGenerator(HotSpotProviders providers, GraalHotSpotVMConfig config, LIRGenerationResult lirGenRes) {
<span class="line-modified">!         this(new AArch64LIRKindTool(), new AArch64ArithmeticLIRGenerator(), new AArch64HotSpotMoveFactory(), providers, config, lirGenRes);</span>
      }
  
      protected AArch64HotSpotLIRGenerator(LIRKindTool lirKindTool, AArch64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, HotSpotProviders providers, GraalHotSpotVMConfig config,
                      LIRGenerationResult lirGenRes) {
          super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
<span class="line-new-header">--- 113,11 ---</span>
  
      final GraalHotSpotVMConfig config;
      private HotSpotDebugInfoBuilder debugInfoBuilder;
  
      protected AArch64HotSpotLIRGenerator(HotSpotProviders providers, GraalHotSpotVMConfig config, LIRGenerationResult lirGenRes) {
<span class="line-modified">!         this(new AArch64LIRKindTool(), new AArch64ArithmeticLIRGenerator(null), new AArch64HotSpotMoveFactory(), providers, config, lirGenRes);</span>
      }
  
      protected AArch64HotSpotLIRGenerator(LIRKindTool lirKindTool, AArch64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, HotSpotProviders providers, GraalHotSpotVMConfig config,
                      LIRGenerationResult lirGenRes) {
          super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,14 ***</span>
      }
  
      /**
       * @param savedRegisters the registers saved by this operation which may be subject to pruning
       * @param savedRegisterLocations the slots to which the registers are saved
<span class="line-removed">-      * @param supportsRemove determines if registers can be pruned</span>
       */
<span class="line-modified">!     protected AArch64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations, boolean supportsRemove) {</span>
<span class="line-modified">!         AArch64SaveRegistersOp save = new AArch64SaveRegistersOp(savedRegisters, savedRegisterLocations, supportsRemove);</span>
          append(save);
          return save;
      }
  
      /**
<span class="line-new-header">--- 167,13 ---</span>
      }
  
      /**
       * @param savedRegisters the registers saved by this operation which may be subject to pruning
       * @param savedRegisterLocations the slots to which the registers are saved
       */
<span class="line-modified">!     protected AArch64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations) {</span>
<span class="line-modified">!         AArch64SaveRegistersOp save = new AArch64SaveRegistersOp(savedRegisters, savedRegisterLocations);</span>
          append(save);
          return save;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,27 ***</span>
       */
      protected VirtualStackSlot allocateSaveRegisterLocation(Register register) {
          PlatformKind kind = target().arch.getLargestStorableKind(register.getRegisterCategory());
          if (kind.getVectorLength() &gt; 1) {
              // we don&#39;t use vector registers, so there is no need to save them
<span class="line-modified">!             kind = AArch64Kind.QWORD;</span>
          }
          return getResult().getFrameMapBuilder().allocateSpillSlot(LIRKind.value(kind));
      }
  
      /**
       * Adds a node to the graph that saves all allocatable registers to the stack.
       *
<span class="line-removed">-      * @param supportsRemove determines if registers can be pruned</span>
       * @return the register save node
       */
<span class="line-modified">!     private AArch64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters, boolean supportsRemove) {</span>
          AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];
          for (int i = 0; i &lt; savedRegisters.length; i++) {
              savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);
          }
<span class="line-modified">!         return emitSaveRegisters(savedRegisters, savedRegisterLocations, supportsRemove);</span>
      }
  
      protected void emitRestoreRegisters(AArch64SaveRegistersOp save) {
          append(new AArch64RestoreRegistersOp(save.getSlots().clone(), save));
      }
<span class="line-new-header">--- 181,26 ---</span>
       */
      protected VirtualStackSlot allocateSaveRegisterLocation(Register register) {
          PlatformKind kind = target().arch.getLargestStorableKind(register.getRegisterCategory());
          if (kind.getVectorLength() &gt; 1) {
              // we don&#39;t use vector registers, so there is no need to save them
<span class="line-modified">!             kind = AArch64Kind.DOUBLE;</span>
          }
          return getResult().getFrameMapBuilder().allocateSpillSlot(LIRKind.value(kind));
      }
  
      /**
       * Adds a node to the graph that saves all allocatable registers to the stack.
       *
       * @return the register save node
       */
<span class="line-modified">!     private AArch64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters) {</span>
          AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];
          for (int i = 0; i &lt; savedRegisters.length; i++) {
              savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);
          }
<span class="line-modified">!         return emitSaveRegisters(savedRegisters, savedRegisterLocations);</span>
      }
  
      protected void emitRestoreRegisters(AArch64SaveRegistersOp save) {
          append(new AArch64RestoreRegistersOp(save.getSlots().clone(), save));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,15 ***</span>
          HotSpotForeignCallLinkage hotspotLinkage = (HotSpotForeignCallLinkage) linkage;
          boolean destroysRegisters = hotspotLinkage.destroysRegisters();
  
          AArch64SaveRegistersOp save = null;
          Stub stub = getStub();
<span class="line-modified">!         if (destroysRegisters) {</span>
<span class="line-modified">!             if (stub != null &amp;&amp; stub.preservesRegisters()) {</span>
<span class="line-modified">!                 Register[] savedRegisters = getRegisterConfig().getAllocatableRegisters().toArray();</span>
<span class="line-removed">-                 save = emitSaveAllRegisters(savedRegisters, true);</span>
<span class="line-removed">-             }</span>
          }
  
          Variable result;
          LIRFrameState debugInfo = null;
          if (hotspotLinkage.needsDebugInfo()) {
<span class="line-new-header">--- 345,13 ---</span>
          HotSpotForeignCallLinkage hotspotLinkage = (HotSpotForeignCallLinkage) linkage;
          boolean destroysRegisters = hotspotLinkage.destroysRegisters();
  
          AArch64SaveRegistersOp save = null;
          Stub stub = getStub();
<span class="line-modified">!         if (destroysRegisters &amp;&amp; stub != null &amp;&amp; stub.shouldSaveRegistersAroundCalls()) {</span>
<span class="line-modified">!             Register[] savedRegisters = getRegisterConfig().getAllocatableRegisters().toArray();</span>
<span class="line-modified">!             save = emitSaveAllRegisters(savedRegisters);</span>
          }
  
          Variable result;
          LIRFrameState debugInfo = null;
          if (hotspotLinkage.needsDebugInfo()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 377,23 ***</span>
              label = null;
          } else {
              result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
          }
  
<span class="line-modified">!         if (destroysRegisters) {</span>
<span class="line-modified">!             if (stub != null) {</span>
<span class="line-modified">!                 if (stub.preservesRegisters()) {</span>
<span class="line-modified">!                     HotSpotLIRGenerationResult generationResult = getResult();</span>
<span class="line-modified">!                     LIRFrameState key = currentRuntimeCallInfo;</span>
<span class="line-removed">-                     if (key == null) {</span>
<span class="line-removed">-                         key = LIRFrameState.NO_STATE;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     assert !generationResult.getCalleeSaveInfo().containsKey(key);</span>
<span class="line-removed">-                     generationResult.getCalleeSaveInfo().put(key, save);</span>
<span class="line-removed">-                     emitRestoreRegisters(save);</span>
<span class="line-removed">-                 }</span>
              }
          }
  
          return result;
      }
  
<span class="line-new-header">--- 375,19 ---</span>
              label = null;
          } else {
              result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
          }
  
<span class="line-modified">!         if (save != null) {</span>
<span class="line-modified">!             HotSpotLIRGenerationResult generationResult = getResult();</span>
<span class="line-modified">!             LIRFrameState key = currentRuntimeCallInfo;</span>
<span class="line-modified">!             if (key == null) {</span>
<span class="line-modified">!                 key = LIRFrameState.NO_STATE;</span>
              }
<span class="line-added">+             assert !generationResult.getCalleeSaveInfo().containsKey(key);</span>
<span class="line-added">+             generationResult.getCalleeSaveInfo().put(key, save);</span>
<span class="line-added">+             emitRestoreRegisters(save);</span>
          }
  
          return result;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,10 ***</span>
<span class="line-new-header">--- 397,16 ---</span>
          Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
          moveDeoptValuesToThread(actionAndReason, speculation);
          append(new AArch64HotSpotDeoptimizeCallerOp(config));
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void emitDeoptimizeWithExceptionInCaller(Value exception) {</span>
<span class="line-added">+         Register thread = getProviders().getRegisters().getThreadRegister();</span>
<span class="line-added">+         append(new AArch64HotSpotDeoptimizeWithExceptionCallerOp(config, exception, thread));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public void emitDeoptimize(Value actionAndReason, Value failedSpeculation, LIRFrameState state) {
          moveDeoptValuesToThread(actionAndReason, failedSpeculation);
          append(new AArch64HotSpotDeoptimizeOp(state));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 537,14 ***</span>
      public void setDebugInfoBuilder(HotSpotDebugInfoBuilder debugInfoBuilder) {
          this.debugInfoBuilder = debugInfoBuilder;
      }
  
      @Override
<span class="line-modified">!     public SaveRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
          throw GraalError.unimplemented();
      }
  
      @Override
      public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
          throw GraalError.unimplemented();
      }
  }
<span class="line-new-header">--- 537,37 ---</span>
      public void setDebugInfoBuilder(HotSpotDebugInfoBuilder debugInfoBuilder) {
          this.debugInfoBuilder = debugInfoBuilder;
      }
  
      @Override
<span class="line-modified">!     public ZapRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
          throw GraalError.unimplemented();
      }
  
      @Override
      public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
          throw GraalError.unimplemented();
      }
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void emitZeroMemory(Value address, Value length, boolean isAligned) {</span>
<span class="line-added">+         int dczidValue = config.psrInfoDczidValue;</span>
<span class="line-added">+         EnumSet&lt;AArch64.Flag&gt; flags = ((AArch64) target().arch).getFlags();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:</span>
<span class="line-added">+         // * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.</span>
<span class="line-added">+         // * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.</span>
<span class="line-added">+         int zvaLength = 4 &lt;&lt; (dczidValue &amp; 0xF);</span>
<span class="line-added">+         boolean isDcZvaProhibited = ((dczidValue &amp; 0x10) != 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Use DC ZVA if it&#39;s not prohibited and AArch64 HotSpot flag UseBlockZeroing is on.</span>
<span class="line-added">+         boolean useDcZva = !isDcZvaProhibited &amp;&amp; flags.contains(AArch64.Flag.UseBlockZeroing);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Set zva length negative (unknown at compile-time) for AOT compilation, since the value</span>
<span class="line-added">+         // could be different on different AArch64 CPU implementations.</span>
<span class="line-added">+         if (GraalOptions.ImmutableCode.getValue(getResult().getLIR().getOptions())) {</span>
<span class="line-added">+             useDcZva = false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         emitZeroMemory(address, length, isAligned, useDcZva, zvaLength);</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="AArch64HotSpotJumpToExceptionHandlerInCallerOp.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotLoweringProvider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64HotSpotJumpToExceptionHandlerInCallerOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotLoweringProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotLIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2018, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 
 27 package org.graalvm.compiler.hotspot.aarch64;
 28 
 29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 30 import static org.graalvm.compiler.hotspot.HotSpotBackend.INITIALIZE_KLASS_BY_SYMBOL;
 31 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_DYNAMIC_INVOKE;
 32 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_KLASS_BY_SYMBOL;
 33 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_METHOD_BY_SYMBOL_AND_LOAD_COUNTERS;
 34 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_STRING_BY_SYMBOL;
 35 import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.INITIALIZE;
 36 import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.LOAD_COUNTERS;
 37 import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.RESOLVE;
 38 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 39 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 40 

 41 import java.util.function.Function;
 42 
 43 import org.graalvm.compiler.asm.Label;
 44 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
 45 import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ConditionFlag;
 46 import org.graalvm.compiler.asm.aarch64.AArch64Assembler.PrefetchMode;
 47 import org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator;
 48 import org.graalvm.compiler.core.aarch64.AArch64LIRGenerator;
 49 import org.graalvm.compiler.core.aarch64.AArch64LIRKindTool;
 50 import org.graalvm.compiler.core.common.CompressEncoding;

 51 import org.graalvm.compiler.core.common.LIRKind;
 52 import org.graalvm.compiler.core.common.calc.Condition;
 53 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 54 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 55 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 56 import org.graalvm.compiler.debug.GraalError;
 57 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 58 import org.graalvm.compiler.hotspot.HotSpotBackend;
 59 import org.graalvm.compiler.hotspot.HotSpotDebugInfoBuilder;
 60 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 61 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 62 import org.graalvm.compiler.hotspot.HotSpotLIRGenerator;
 63 import org.graalvm.compiler.hotspot.HotSpotLockStack;
 64 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 65 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 66 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
 67 import org.graalvm.compiler.hotspot.stubs.Stub;
 68 import org.graalvm.compiler.lir.LIRFrameState;
 69 import org.graalvm.compiler.lir.LIRInstruction;
 70 import org.graalvm.compiler.lir.LabelRef;
<span class="line-modified"> 71 import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>
 72 import org.graalvm.compiler.lir.SwitchStrategy;
 73 import org.graalvm.compiler.lir.Variable;
 74 import org.graalvm.compiler.lir.VirtualStackSlot;
 75 import org.graalvm.compiler.lir.aarch64.AArch64AddressValue;
 76 import org.graalvm.compiler.lir.aarch64.AArch64CCall;
 77 import org.graalvm.compiler.lir.aarch64.AArch64Call;
 78 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.StrategySwitchOp;
 79 import org.graalvm.compiler.lir.aarch64.AArch64FrameMapBuilder;
 80 import org.graalvm.compiler.lir.aarch64.AArch64Move;
 81 import org.graalvm.compiler.lir.aarch64.AArch64Move.StoreOp;
 82 import org.graalvm.compiler.lir.aarch64.AArch64PrefetchOp;
 83 import org.graalvm.compiler.lir.aarch64.AArch64RestoreRegistersOp;
 84 import org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp;
 85 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 86 import org.graalvm.compiler.options.OptionValues;
 87 
 88 import jdk.vm.ci.aarch64.AArch64;
 89 import jdk.vm.ci.aarch64.AArch64Kind;
 90 import jdk.vm.ci.code.CallingConvention;
 91 import jdk.vm.ci.code.Register;
</pre>
<hr />
<pre>
 96 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 97 import jdk.vm.ci.meta.AllocatableValue;
 98 import jdk.vm.ci.meta.Constant;
 99 import jdk.vm.ci.meta.DeoptimizationAction;
100 import jdk.vm.ci.meta.DeoptimizationReason;
101 import jdk.vm.ci.meta.JavaConstant;
102 import jdk.vm.ci.meta.JavaKind;
103 import jdk.vm.ci.meta.PlatformKind;
104 import jdk.vm.ci.meta.SpeculationLog;
105 import jdk.vm.ci.meta.Value;
106 
107 /**
108  * LIR generator specialized for AArch64 HotSpot.
109  */
110 public class AArch64HotSpotLIRGenerator extends AArch64LIRGenerator implements HotSpotLIRGenerator {
111 
112     final GraalHotSpotVMConfig config;
113     private HotSpotDebugInfoBuilder debugInfoBuilder;
114 
115     protected AArch64HotSpotLIRGenerator(HotSpotProviders providers, GraalHotSpotVMConfig config, LIRGenerationResult lirGenRes) {
<span class="line-modified">116         this(new AArch64LIRKindTool(), new AArch64ArithmeticLIRGenerator(), new AArch64HotSpotMoveFactory(), providers, config, lirGenRes);</span>
117     }
118 
119     protected AArch64HotSpotLIRGenerator(LIRKindTool lirKindTool, AArch64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, HotSpotProviders providers, GraalHotSpotVMConfig config,
120                     LIRGenerationResult lirGenRes) {
121         super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
122         this.config = config;
123     }
124 
125     @Override
126     public HotSpotProviders getProviders() {
127         return (HotSpotProviders) super.getProviders();
128     }
129 
130     @Override
131     public boolean needOnlyOopMaps() {
132         // Stubs only need oop maps
133         return getResult().getStub() != null;
134     }
135 
136     private LIRFrameState currentRuntimeCallInfo;
</pre>
<hr />
<pre>
150         throw GraalError.unimplemented();
151     }
152 
153     @Override
154     public void emitCCall(long address, CallingConvention nativeCallingConvention, Value[] args) {
155         Value[] argLocations = new Value[args.length];
156         getResult().getFrameMapBuilder().callsMethod(nativeCallingConvention);
157         for (int i = 0; i &lt; args.length; i++) {
158             Value arg = args[i];
159             AllocatableValue loc = nativeCallingConvention.getArgument(i);
160             emitMove(loc, arg);
161             argLocations[i] = loc;
162         }
163         Value ptr = emitLoadConstant(LIRKind.value(AArch64Kind.QWORD), JavaConstant.forLong(address));
164         append(new AArch64CCall(nativeCallingConvention.getReturn(), ptr, argLocations));
165     }
166 
167     /**
168      * @param savedRegisters the registers saved by this operation which may be subject to pruning
169      * @param savedRegisterLocations the slots to which the registers are saved
<span class="line-removed">170      * @param supportsRemove determines if registers can be pruned</span>
171      */
<span class="line-modified">172     protected AArch64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations, boolean supportsRemove) {</span>
<span class="line-modified">173         AArch64SaveRegistersOp save = new AArch64SaveRegistersOp(savedRegisters, savedRegisterLocations, supportsRemove);</span>
174         append(save);
175         return save;
176     }
177 
178     /**
179      * Allocate a stack slot for saving a register.
180      */
181     protected VirtualStackSlot allocateSaveRegisterLocation(Register register) {
182         PlatformKind kind = target().arch.getLargestStorableKind(register.getRegisterCategory());
183         if (kind.getVectorLength() &gt; 1) {
184             // we don&#39;t use vector registers, so there is no need to save them
<span class="line-modified">185             kind = AArch64Kind.QWORD;</span>
186         }
187         return getResult().getFrameMapBuilder().allocateSpillSlot(LIRKind.value(kind));
188     }
189 
190     /**
191      * Adds a node to the graph that saves all allocatable registers to the stack.
192      *
<span class="line-removed">193      * @param supportsRemove determines if registers can be pruned</span>
194      * @return the register save node
195      */
<span class="line-modified">196     private AArch64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters, boolean supportsRemove) {</span>
197         AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];
198         for (int i = 0; i &lt; savedRegisters.length; i++) {
199             savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);
200         }
<span class="line-modified">201         return emitSaveRegisters(savedRegisters, savedRegisterLocations, supportsRemove);</span>
202     }
203 
204     protected void emitRestoreRegisters(AArch64SaveRegistersOp save) {
205         append(new AArch64RestoreRegistersOp(save.getSlots().clone(), save));
206     }
207 
208     @Override
209     public VirtualStackSlot getLockSlot(int lockDepth) {
210         return getLockStack().makeLockSlot(lockDepth);
211     }
212 
213     private HotSpotLockStack getLockStack() {
214         assert debugInfoBuilder != null &amp;&amp; debugInfoBuilder.lockStack() != null;
215         return debugInfoBuilder.lockStack();
216     }
217 
218     @Override
219     public void emitCompareBranch(PlatformKind cmpKind, Value x, Value y, Condition cond, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination,
220                     double trueDestinationProbability) {
221         Value localX = x;
</pre>
<hr />
<pre>
330     @Override
331     public void beforeRegisterAllocation() {
332         super.beforeRegisterAllocation();
333         boolean hasDebugInfo = getResult().getLIR().hasDebugInfo();
334         if (hasDebugInfo) {
335             getResult().setDeoptimizationRescueSlot(((AArch64FrameMapBuilder) getResult().getFrameMapBuilder()).allocateDeoptimizationRescueSlot());
336         }
337 
338         getResult().setMaxInterpreterFrameSize(debugInfoBuilder.maxInterpreterFrameSize());
339     }
340 
341     private Label label;
342 
343     @Override
344     public Variable emitForeignCall(ForeignCallLinkage linkage, LIRFrameState state, Value... args) {
345         HotSpotForeignCallLinkage hotspotLinkage = (HotSpotForeignCallLinkage) linkage;
346         boolean destroysRegisters = hotspotLinkage.destroysRegisters();
347 
348         AArch64SaveRegistersOp save = null;
349         Stub stub = getStub();
<span class="line-modified">350         if (destroysRegisters) {</span>
<span class="line-modified">351             if (stub != null &amp;&amp; stub.preservesRegisters()) {</span>
<span class="line-modified">352                 Register[] savedRegisters = getRegisterConfig().getAllocatableRegisters().toArray();</span>
<span class="line-removed">353                 save = emitSaveAllRegisters(savedRegisters, true);</span>
<span class="line-removed">354             }</span>
355         }
356 
357         Variable result;
358         LIRFrameState debugInfo = null;
359         if (hotspotLinkage.needsDebugInfo()) {
360             debugInfo = state;
361             assert debugInfo != null || getStub() != null;
362         }
363 
364         if (destroysRegisters || hotspotLinkage.needsJavaFrameAnchor()) {
365             HotSpotRegistersProvider registers = getProviders().getRegisters();
366             Register thread = registers.getThreadRegister();
367             Variable scratch = newVariable(LIRKind.value(target().arch.getWordKind()));
368 
369             // We need a label for the return address.
370             label = new Label();
371 
372             append(new AArch64HotSpotCRuntimeCallPrologueOp(config.threadLastJavaSpOffset(), config.threadLastJavaPcOffset(), thread, scratch, label));
373             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
374             append(new AArch64HotSpotCRuntimeCallEpilogueOp(config.threadLastJavaSpOffset(), config.threadLastJavaPcOffset(), thread, label));
375 
376             // Clear it out so it&#39;s not being reused later.
377             label = null;
378         } else {
379             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
380         }
381 
<span class="line-modified">382         if (destroysRegisters) {</span>
<span class="line-modified">383             if (stub != null) {</span>
<span class="line-modified">384                 if (stub.preservesRegisters()) {</span>
<span class="line-modified">385                     HotSpotLIRGenerationResult generationResult = getResult();</span>
<span class="line-modified">386                     LIRFrameState key = currentRuntimeCallInfo;</span>
<span class="line-removed">387                     if (key == null) {</span>
<span class="line-removed">388                         key = LIRFrameState.NO_STATE;</span>
<span class="line-removed">389                     }</span>
<span class="line-removed">390                     assert !generationResult.getCalleeSaveInfo().containsKey(key);</span>
<span class="line-removed">391                     generationResult.getCalleeSaveInfo().put(key, save);</span>
<span class="line-removed">392                     emitRestoreRegisters(save);</span>
<span class="line-removed">393                 }</span>
394             }



395         }
396 
397         return result;
398     }
399 
400     @Override
401     public void emitDeoptimizeCaller(DeoptimizationAction action, DeoptimizationReason reason) {
402         Value actionAndReason = emitJavaConstant(getMetaAccess().encodeDeoptActionAndReason(action, reason, 0));
403         Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
404         moveDeoptValuesToThread(actionAndReason, speculation);
405         append(new AArch64HotSpotDeoptimizeCallerOp(config));
406     }
407 






408     @Override
409     public void emitDeoptimize(Value actionAndReason, Value failedSpeculation, LIRFrameState state) {
410         moveDeoptValuesToThread(actionAndReason, failedSpeculation);
411         append(new AArch64HotSpotDeoptimizeOp(state));
412     }
413 
414     private void moveDeoptValuesToThread(Value actionAndReason, Value speculation) {
415         moveValueToThread(actionAndReason, config.pendingDeoptimizationOffset);
416         moveValueToThread(speculation, config.pendingFailedSpeculationOffset);
417     }
418 
419     private void moveValueToThread(Value value, int offset) {
420         LIRKind wordKind = LIRKind.value(target().arch.getWordKind());
421         RegisterValue thread = getProviders().getRegisters().getThreadRegister().asValue(wordKind);
422         final int transferSize = value.getValueKind().getPlatformKind().getSizeInBytes();
423         AArch64AddressValue address = new AArch64AddressValue(value.getValueKind(), thread, Value.ILLEGAL, offset, transferSize, AddressingMode.IMMEDIATE_SCALED);
424         append(new StoreOp((AArch64Kind) value.getPlatformKind(), address, loadReg(value), null));
425     }
426 
427     @Override
</pre>
<hr />
<pre>
522     public Stub getStub() {
523         return getResult().getStub();
524     }
525 
526     @Override
527     public HotSpotLIRGenerationResult getResult() {
528         return ((HotSpotLIRGenerationResult) super.getResult());
529     }
530 
531     @Override
532     protected StrategySwitchOp createStrategySwitchOp(SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Variable key, AllocatableValue scratchValue,
533                     Function&lt;Condition, ConditionFlag&gt; converter) {
534         return new AArch64HotSpotStrategySwitchOp(strategy, keyTargets, defaultTarget, key, scratchValue, converter);
535     }
536 
537     public void setDebugInfoBuilder(HotSpotDebugInfoBuilder debugInfoBuilder) {
538         this.debugInfoBuilder = debugInfoBuilder;
539     }
540 
541     @Override
<span class="line-modified">542     public SaveRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
543         throw GraalError.unimplemented();
544     }
545 
546     @Override
547     public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
548         throw GraalError.unimplemented();
549     }























550 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2018, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 
 27 package org.graalvm.compiler.hotspot.aarch64;
 28 
 29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 30 import static org.graalvm.compiler.hotspot.HotSpotBackend.INITIALIZE_KLASS_BY_SYMBOL;
 31 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_DYNAMIC_INVOKE;
 32 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_KLASS_BY_SYMBOL;
 33 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_METHOD_BY_SYMBOL_AND_LOAD_COUNTERS;
 34 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_STRING_BY_SYMBOL;
 35 import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.INITIALIZE;
 36 import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.LOAD_COUNTERS;
 37 import static org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction.RESOLVE;
 38 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 39 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 40 
<span class="line-added"> 41 import java.util.EnumSet;</span>
 42 import java.util.function.Function;
 43 
 44 import org.graalvm.compiler.asm.Label;
 45 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
 46 import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ConditionFlag;
 47 import org.graalvm.compiler.asm.aarch64.AArch64Assembler.PrefetchMode;
 48 import org.graalvm.compiler.core.aarch64.AArch64ArithmeticLIRGenerator;
 49 import org.graalvm.compiler.core.aarch64.AArch64LIRGenerator;
 50 import org.graalvm.compiler.core.aarch64.AArch64LIRKindTool;
 51 import org.graalvm.compiler.core.common.CompressEncoding;
<span class="line-added"> 52 import org.graalvm.compiler.core.common.GraalOptions;</span>
 53 import org.graalvm.compiler.core.common.LIRKind;
 54 import org.graalvm.compiler.core.common.calc.Condition;
 55 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 56 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 57 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 58 import org.graalvm.compiler.debug.GraalError;
 59 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 60 import org.graalvm.compiler.hotspot.HotSpotBackend;
 61 import org.graalvm.compiler.hotspot.HotSpotDebugInfoBuilder;
 62 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 63 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 64 import org.graalvm.compiler.hotspot.HotSpotLIRGenerator;
 65 import org.graalvm.compiler.hotspot.HotSpotLockStack;
 66 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 67 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 68 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
 69 import org.graalvm.compiler.hotspot.stubs.Stub;
 70 import org.graalvm.compiler.lir.LIRFrameState;
 71 import org.graalvm.compiler.lir.LIRInstruction;
 72 import org.graalvm.compiler.lir.LabelRef;
<span class="line-modified"> 73 import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;</span>
 74 import org.graalvm.compiler.lir.SwitchStrategy;
 75 import org.graalvm.compiler.lir.Variable;
 76 import org.graalvm.compiler.lir.VirtualStackSlot;
 77 import org.graalvm.compiler.lir.aarch64.AArch64AddressValue;
 78 import org.graalvm.compiler.lir.aarch64.AArch64CCall;
 79 import org.graalvm.compiler.lir.aarch64.AArch64Call;
 80 import org.graalvm.compiler.lir.aarch64.AArch64ControlFlow.StrategySwitchOp;
 81 import org.graalvm.compiler.lir.aarch64.AArch64FrameMapBuilder;
 82 import org.graalvm.compiler.lir.aarch64.AArch64Move;
 83 import org.graalvm.compiler.lir.aarch64.AArch64Move.StoreOp;
 84 import org.graalvm.compiler.lir.aarch64.AArch64PrefetchOp;
 85 import org.graalvm.compiler.lir.aarch64.AArch64RestoreRegistersOp;
 86 import org.graalvm.compiler.lir.aarch64.AArch64SaveRegistersOp;
 87 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 88 import org.graalvm.compiler.options.OptionValues;
 89 
 90 import jdk.vm.ci.aarch64.AArch64;
 91 import jdk.vm.ci.aarch64.AArch64Kind;
 92 import jdk.vm.ci.code.CallingConvention;
 93 import jdk.vm.ci.code.Register;
</pre>
<hr />
<pre>
 98 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 99 import jdk.vm.ci.meta.AllocatableValue;
100 import jdk.vm.ci.meta.Constant;
101 import jdk.vm.ci.meta.DeoptimizationAction;
102 import jdk.vm.ci.meta.DeoptimizationReason;
103 import jdk.vm.ci.meta.JavaConstant;
104 import jdk.vm.ci.meta.JavaKind;
105 import jdk.vm.ci.meta.PlatformKind;
106 import jdk.vm.ci.meta.SpeculationLog;
107 import jdk.vm.ci.meta.Value;
108 
109 /**
110  * LIR generator specialized for AArch64 HotSpot.
111  */
112 public class AArch64HotSpotLIRGenerator extends AArch64LIRGenerator implements HotSpotLIRGenerator {
113 
114     final GraalHotSpotVMConfig config;
115     private HotSpotDebugInfoBuilder debugInfoBuilder;
116 
117     protected AArch64HotSpotLIRGenerator(HotSpotProviders providers, GraalHotSpotVMConfig config, LIRGenerationResult lirGenRes) {
<span class="line-modified">118         this(new AArch64LIRKindTool(), new AArch64ArithmeticLIRGenerator(null), new AArch64HotSpotMoveFactory(), providers, config, lirGenRes);</span>
119     }
120 
121     protected AArch64HotSpotLIRGenerator(LIRKindTool lirKindTool, AArch64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, HotSpotProviders providers, GraalHotSpotVMConfig config,
122                     LIRGenerationResult lirGenRes) {
123         super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
124         this.config = config;
125     }
126 
127     @Override
128     public HotSpotProviders getProviders() {
129         return (HotSpotProviders) super.getProviders();
130     }
131 
132     @Override
133     public boolean needOnlyOopMaps() {
134         // Stubs only need oop maps
135         return getResult().getStub() != null;
136     }
137 
138     private LIRFrameState currentRuntimeCallInfo;
</pre>
<hr />
<pre>
152         throw GraalError.unimplemented();
153     }
154 
155     @Override
156     public void emitCCall(long address, CallingConvention nativeCallingConvention, Value[] args) {
157         Value[] argLocations = new Value[args.length];
158         getResult().getFrameMapBuilder().callsMethod(nativeCallingConvention);
159         for (int i = 0; i &lt; args.length; i++) {
160             Value arg = args[i];
161             AllocatableValue loc = nativeCallingConvention.getArgument(i);
162             emitMove(loc, arg);
163             argLocations[i] = loc;
164         }
165         Value ptr = emitLoadConstant(LIRKind.value(AArch64Kind.QWORD), JavaConstant.forLong(address));
166         append(new AArch64CCall(nativeCallingConvention.getReturn(), ptr, argLocations));
167     }
168 
169     /**
170      * @param savedRegisters the registers saved by this operation which may be subject to pruning
171      * @param savedRegisterLocations the slots to which the registers are saved

172      */
<span class="line-modified">173     protected AArch64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations) {</span>
<span class="line-modified">174         AArch64SaveRegistersOp save = new AArch64SaveRegistersOp(savedRegisters, savedRegisterLocations);</span>
175         append(save);
176         return save;
177     }
178 
179     /**
180      * Allocate a stack slot for saving a register.
181      */
182     protected VirtualStackSlot allocateSaveRegisterLocation(Register register) {
183         PlatformKind kind = target().arch.getLargestStorableKind(register.getRegisterCategory());
184         if (kind.getVectorLength() &gt; 1) {
185             // we don&#39;t use vector registers, so there is no need to save them
<span class="line-modified">186             kind = AArch64Kind.DOUBLE;</span>
187         }
188         return getResult().getFrameMapBuilder().allocateSpillSlot(LIRKind.value(kind));
189     }
190 
191     /**
192      * Adds a node to the graph that saves all allocatable registers to the stack.
193      *

194      * @return the register save node
195      */
<span class="line-modified">196     private AArch64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters) {</span>
197         AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];
198         for (int i = 0; i &lt; savedRegisters.length; i++) {
199             savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);
200         }
<span class="line-modified">201         return emitSaveRegisters(savedRegisters, savedRegisterLocations);</span>
202     }
203 
204     protected void emitRestoreRegisters(AArch64SaveRegistersOp save) {
205         append(new AArch64RestoreRegistersOp(save.getSlots().clone(), save));
206     }
207 
208     @Override
209     public VirtualStackSlot getLockSlot(int lockDepth) {
210         return getLockStack().makeLockSlot(lockDepth);
211     }
212 
213     private HotSpotLockStack getLockStack() {
214         assert debugInfoBuilder != null &amp;&amp; debugInfoBuilder.lockStack() != null;
215         return debugInfoBuilder.lockStack();
216     }
217 
218     @Override
219     public void emitCompareBranch(PlatformKind cmpKind, Value x, Value y, Condition cond, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination,
220                     double trueDestinationProbability) {
221         Value localX = x;
</pre>
<hr />
<pre>
330     @Override
331     public void beforeRegisterAllocation() {
332         super.beforeRegisterAllocation();
333         boolean hasDebugInfo = getResult().getLIR().hasDebugInfo();
334         if (hasDebugInfo) {
335             getResult().setDeoptimizationRescueSlot(((AArch64FrameMapBuilder) getResult().getFrameMapBuilder()).allocateDeoptimizationRescueSlot());
336         }
337 
338         getResult().setMaxInterpreterFrameSize(debugInfoBuilder.maxInterpreterFrameSize());
339     }
340 
341     private Label label;
342 
343     @Override
344     public Variable emitForeignCall(ForeignCallLinkage linkage, LIRFrameState state, Value... args) {
345         HotSpotForeignCallLinkage hotspotLinkage = (HotSpotForeignCallLinkage) linkage;
346         boolean destroysRegisters = hotspotLinkage.destroysRegisters();
347 
348         AArch64SaveRegistersOp save = null;
349         Stub stub = getStub();
<span class="line-modified">350         if (destroysRegisters &amp;&amp; stub != null &amp;&amp; stub.shouldSaveRegistersAroundCalls()) {</span>
<span class="line-modified">351             Register[] savedRegisters = getRegisterConfig().getAllocatableRegisters().toArray();</span>
<span class="line-modified">352             save = emitSaveAllRegisters(savedRegisters);</span>


353         }
354 
355         Variable result;
356         LIRFrameState debugInfo = null;
357         if (hotspotLinkage.needsDebugInfo()) {
358             debugInfo = state;
359             assert debugInfo != null || getStub() != null;
360         }
361 
362         if (destroysRegisters || hotspotLinkage.needsJavaFrameAnchor()) {
363             HotSpotRegistersProvider registers = getProviders().getRegisters();
364             Register thread = registers.getThreadRegister();
365             Variable scratch = newVariable(LIRKind.value(target().arch.getWordKind()));
366 
367             // We need a label for the return address.
368             label = new Label();
369 
370             append(new AArch64HotSpotCRuntimeCallPrologueOp(config.threadLastJavaSpOffset(), config.threadLastJavaPcOffset(), thread, scratch, label));
371             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
372             append(new AArch64HotSpotCRuntimeCallEpilogueOp(config.threadLastJavaSpOffset(), config.threadLastJavaPcOffset(), thread, label));
373 
374             // Clear it out so it&#39;s not being reused later.
375             label = null;
376         } else {
377             result = super.emitForeignCall(hotspotLinkage, debugInfo, args);
378         }
379 
<span class="line-modified">380         if (save != null) {</span>
<span class="line-modified">381             HotSpotLIRGenerationResult generationResult = getResult();</span>
<span class="line-modified">382             LIRFrameState key = currentRuntimeCallInfo;</span>
<span class="line-modified">383             if (key == null) {</span>
<span class="line-modified">384                 key = LIRFrameState.NO_STATE;</span>







385             }
<span class="line-added">386             assert !generationResult.getCalleeSaveInfo().containsKey(key);</span>
<span class="line-added">387             generationResult.getCalleeSaveInfo().put(key, save);</span>
<span class="line-added">388             emitRestoreRegisters(save);</span>
389         }
390 
391         return result;
392     }
393 
394     @Override
395     public void emitDeoptimizeCaller(DeoptimizationAction action, DeoptimizationReason reason) {
396         Value actionAndReason = emitJavaConstant(getMetaAccess().encodeDeoptActionAndReason(action, reason, 0));
397         Value speculation = emitJavaConstant(getMetaAccess().encodeSpeculation(SpeculationLog.NO_SPECULATION));
398         moveDeoptValuesToThread(actionAndReason, speculation);
399         append(new AArch64HotSpotDeoptimizeCallerOp(config));
400     }
401 
<span class="line-added">402     @Override</span>
<span class="line-added">403     public void emitDeoptimizeWithExceptionInCaller(Value exception) {</span>
<span class="line-added">404         Register thread = getProviders().getRegisters().getThreadRegister();</span>
<span class="line-added">405         append(new AArch64HotSpotDeoptimizeWithExceptionCallerOp(config, exception, thread));</span>
<span class="line-added">406     }</span>
<span class="line-added">407 </span>
408     @Override
409     public void emitDeoptimize(Value actionAndReason, Value failedSpeculation, LIRFrameState state) {
410         moveDeoptValuesToThread(actionAndReason, failedSpeculation);
411         append(new AArch64HotSpotDeoptimizeOp(state));
412     }
413 
414     private void moveDeoptValuesToThread(Value actionAndReason, Value speculation) {
415         moveValueToThread(actionAndReason, config.pendingDeoptimizationOffset);
416         moveValueToThread(speculation, config.pendingFailedSpeculationOffset);
417     }
418 
419     private void moveValueToThread(Value value, int offset) {
420         LIRKind wordKind = LIRKind.value(target().arch.getWordKind());
421         RegisterValue thread = getProviders().getRegisters().getThreadRegister().asValue(wordKind);
422         final int transferSize = value.getValueKind().getPlatformKind().getSizeInBytes();
423         AArch64AddressValue address = new AArch64AddressValue(value.getValueKind(), thread, Value.ILLEGAL, offset, transferSize, AddressingMode.IMMEDIATE_SCALED);
424         append(new StoreOp((AArch64Kind) value.getPlatformKind(), address, loadReg(value), null));
425     }
426 
427     @Override
</pre>
<hr />
<pre>
522     public Stub getStub() {
523         return getResult().getStub();
524     }
525 
526     @Override
527     public HotSpotLIRGenerationResult getResult() {
528         return ((HotSpotLIRGenerationResult) super.getResult());
529     }
530 
531     @Override
532     protected StrategySwitchOp createStrategySwitchOp(SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Variable key, AllocatableValue scratchValue,
533                     Function&lt;Condition, ConditionFlag&gt; converter) {
534         return new AArch64HotSpotStrategySwitchOp(strategy, keyTargets, defaultTarget, key, scratchValue, converter);
535     }
536 
537     public void setDebugInfoBuilder(HotSpotDebugInfoBuilder debugInfoBuilder) {
538         this.debugInfoBuilder = debugInfoBuilder;
539     }
540 
541     @Override
<span class="line-modified">542     public ZapRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues) {</span>
543         throw GraalError.unimplemented();
544     }
545 
546     @Override
547     public LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues) {
548         throw GraalError.unimplemented();
549     }
<span class="line-added">550 </span>
<span class="line-added">551     @Override</span>
<span class="line-added">552     public void emitZeroMemory(Value address, Value length, boolean isAligned) {</span>
<span class="line-added">553         int dczidValue = config.psrInfoDczidValue;</span>
<span class="line-added">554         EnumSet&lt;AArch64.Flag&gt; flags = ((AArch64) target().arch).getFlags();</span>
<span class="line-added">555 </span>
<span class="line-added">556         // ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:</span>
<span class="line-added">557         // * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.</span>
<span class="line-added">558         // * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.</span>
<span class="line-added">559         int zvaLength = 4 &lt;&lt; (dczidValue &amp; 0xF);</span>
<span class="line-added">560         boolean isDcZvaProhibited = ((dczidValue &amp; 0x10) != 0);</span>
<span class="line-added">561 </span>
<span class="line-added">562         // Use DC ZVA if it&#39;s not prohibited and AArch64 HotSpot flag UseBlockZeroing is on.</span>
<span class="line-added">563         boolean useDcZva = !isDcZvaProhibited &amp;&amp; flags.contains(AArch64.Flag.UseBlockZeroing);</span>
<span class="line-added">564 </span>
<span class="line-added">565         // Set zva length negative (unknown at compile-time) for AOT compilation, since the value</span>
<span class="line-added">566         // could be different on different AArch64 CPU implementations.</span>
<span class="line-added">567         if (GraalOptions.ImmutableCode.getValue(getResult().getLIR().getOptions())) {</span>
<span class="line-added">568             useDcZva = false;</span>
<span class="line-added">569         }</span>
<span class="line-added">570 </span>
<span class="line-added">571         emitZeroMemory(address, length, isAligned, useDcZva, zvaLength);</span>
<span class="line-added">572     }</span>
573 }
</pre>
</td>
</tr>
</table>
<center><a href="AArch64HotSpotJumpToExceptionHandlerInCallerOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotLoweringProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
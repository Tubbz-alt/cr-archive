<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/spi/Canonicalizable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotBackendFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotBackend.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 27 import static java.lang.reflect.Modifier.isStatic;
 28 import static jdk.vm.ci.aarch64.AArch64.lr;
 29 import static jdk.vm.ci.aarch64.AArch64.r10;
 30 import static jdk.vm.ci.aarch64.AArch64.sp;
 31 import static jdk.vm.ci.aarch64.AArch64.zr;
 32 import static jdk.vm.ci.code.ValueUtil.asRegister;
 33 import static jdk.vm.ci.hotspot.aarch64.AArch64HotSpotRegisterConfig.fp;
 34 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 35 import static org.graalvm.compiler.core.common.GraalOptions.ZapStackOnMethodEntry;
 36 
 37 import jdk.internal.vm.compiler.collections.EconomicSet;
 38 import org.graalvm.compiler.asm.Assembler;
 39 import org.graalvm.compiler.asm.BranchTargetOutOfBoundsException;
 40 import org.graalvm.compiler.asm.Label;
 41 import org.graalvm.compiler.asm.aarch64.AArch64Address;
 42 import org.graalvm.compiler.asm.aarch64.AArch64Assembler;
 43 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 44 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;
 45 import org.graalvm.compiler.code.CompilationResult;
 46 import org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules;
<span class="line-removed"> 47 import org.graalvm.compiler.core.common.CompilationIdentifier;</span>
 48 import org.graalvm.compiler.core.common.LIRKind;
 49 import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;
 50 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 51 import org.graalvm.compiler.core.gen.LIRGenerationProvider;

 52 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 53 import org.graalvm.compiler.hotspot.HotSpotDataBuilder;
 54 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 55 import org.graalvm.compiler.hotspot.HotSpotHostBackend;
 56 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 57 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 58 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
 59 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 60 import org.graalvm.compiler.hotspot.stubs.Stub;
 61 import org.graalvm.compiler.lir.LIR;
 62 import org.graalvm.compiler.lir.aarch64.AArch64Call;
 63 import org.graalvm.compiler.lir.aarch64.AArch64FrameMap;
 64 import org.graalvm.compiler.lir.aarch64.AArch64FrameMapBuilder;
 65 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 66 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 67 import org.graalvm.compiler.lir.asm.DataBuilder;
 68 import org.graalvm.compiler.lir.asm.FrameContext;
 69 import org.graalvm.compiler.lir.framemap.FrameMap;
 70 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 71 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 72 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 73 import org.graalvm.compiler.nodes.StructuredGraph;
 74 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;

 75 
 76 import jdk.vm.ci.aarch64.AArch64Kind;
 77 import jdk.vm.ci.code.CallingConvention;


 78 import jdk.vm.ci.code.Register;
 79 import jdk.vm.ci.code.RegisterConfig;
 80 import jdk.vm.ci.code.StackSlot;

 81 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 82 import jdk.vm.ci.hotspot.HotSpotSentinelConstant;
 83 import jdk.vm.ci.hotspot.aarch64.AArch64HotSpotRegisterConfig;
 84 import jdk.vm.ci.meta.JavaKind;
 85 import jdk.vm.ci.meta.JavaType;
 86 import jdk.vm.ci.meta.ResolvedJavaMethod;

 87 
 88 /**
 89  * HotSpot AArch64 specific backend.
 90  */
 91 public class AArch64HotSpotBackend extends HotSpotHostBackend implements LIRGenerationProvider {
 92 
 93     public AArch64HotSpotBackend(GraalHotSpotVMConfig config, HotSpotGraalRuntimeProvider runtime, HotSpotProviders providers) {
 94         super(config, runtime, providers);
 95     }
 96 
<span class="line-modified"> 97     private FrameMapBuilder newFrameMapBuilder(RegisterConfig registerConfig) {</span>

 98         RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
 99         FrameMap frameMap = new AArch64FrameMap(getCodeCache(), registerConfigNonNull, this);
100         return new AArch64FrameMapBuilder(frameMap, getCodeCache(), registerConfigNonNull);
101     }
102 
103     @Override
104     public LIRGeneratorTool newLIRGenerator(LIRGenerationResult lirGenRes) {
105         return new AArch64HotSpotLIRGenerator(getProviders(), config, lirGenRes);
106     }
107 
<span class="line-removed">108     @Override</span>
<span class="line-removed">109     public LIRGenerationResult newLIRGenerationResult(CompilationIdentifier compilationId, LIR lir, RegisterConfig registerConfig, StructuredGraph graph, Object stub) {</span>
<span class="line-removed">110         return new HotSpotLIRGenerationResult(compilationId, lir, newFrameMapBuilder(registerConfig), makeCallingConvention(graph, (Stub) stub), stub,</span>
<span class="line-removed">111                         config.requiresReservedStackCheck(graph.getMethods()));</span>
<span class="line-removed">112     }</span>
<span class="line-removed">113 </span>
114     @Override
115     public NodeLIRBuilderTool newNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool lirGen) {
116         return new AArch64HotSpotNodeLIRBuilder(graph, lirGen, new AArch64NodeMatchRules(lirGen));
117     }
118 
119     @Override
120     protected void bangStackWithOffset(CompilationResultBuilder crb, int bangOffset) {
121         AArch64MacroAssembler masm = (AArch64MacroAssembler) crb.asm;
122         try (ScratchRegister sc = masm.getScratchRegister()) {
123             Register scratch = sc.getRegister();
124             AArch64Address address = masm.makeAddress(sp, -bangOffset, scratch, 8, /* allowOverwrite */false);
125             masm.str(64, zr, address);
126         }
127     }
128 








































129     private class HotSpotFrameContext implements FrameContext {
130         final boolean isStub;
131 
132         HotSpotFrameContext(boolean isStub) {
133             this.isStub = isStub;
134         }
135 
136         @Override
137         public void enter(CompilationResultBuilder crb) {
138             FrameMap frameMap = crb.frameMap;
139             final int frameSize = frameMap.frameSize();
140             final int totalFrameSize = frameMap.totalFrameSize();
141             assert frameSize + 2 * crb.target.arch.getWordSize() == totalFrameSize : &quot;total framesize should be framesize + 2 words&quot;;
142             AArch64MacroAssembler masm = (AArch64MacroAssembler) crb.asm;
143             if (!isStub) {
144                 emitStackOverflowCheck(crb);
145             }
146             crb.blockComment(&quot;[method prologue]&quot;);
147 
148             try (ScratchRegister sc = masm.getScratchRegister()) {
</pre>
<hr />
<pre>
220     public CompilationResultBuilder newCompilationResultBuilder(LIRGenerationResult lirGenRen, FrameMap frameMap, CompilationResult compilationResult, CompilationResultBuilderFactory factory) {
221         HotSpotLIRGenerationResult gen = (HotSpotLIRGenerationResult) lirGenRen;
222         LIR lir = gen.getLIR();
223         assert gen.getDeoptimizationRescueSlot() == null || frameMap.frameNeedsAllocating() : &quot;method that can deoptimize must have a frame&quot;;
224 
225         Stub stub = gen.getStub();
226         Assembler masm = new AArch64MacroAssembler(getTarget());
227         HotSpotFrameContext frameContext = new HotSpotFrameContext(stub != null);
228 
229         DataBuilder dataBuilder = new HotSpotDataBuilder(getCodeCache().getTarget());
230         CompilationResultBuilder crb = factory.createBuilder(getCodeCache(), getForeignCalls(), frameMap, masm, dataBuilder, frameContext, lir.getOptions(), lir.getDebug(), compilationResult,
231                         Register.None);
232         crb.setTotalFrameSize(frameMap.totalFrameSize());
233         crb.setMaxInterpreterFrameSize(gen.getMaxInterpreterFrameSize());
234         StackSlot deoptimizationRescueSlot = gen.getDeoptimizationRescueSlot();
235         if (deoptimizationRescueSlot != null &amp;&amp; stub == null) {
236             crb.compilationResult.setCustomStackAreaOffset(deoptimizationRescueSlot);
237         }
238 
239         if (stub != null) {
<span class="line-modified">240             EconomicSet&lt;Register&gt; destroyedCallerRegisters = gatherDestroyedCallerRegisters(lir);</span>
<span class="line-removed">241             updateStub(stub, destroyedCallerRegisters, gen.getCalleeSaveInfo(), frameMap);</span>
242         }
243         return crb;
244     }
245 
246     @Override
247     public void emitCode(CompilationResultBuilder crb, LIR lir, ResolvedJavaMethod installedCodeOwner) {
248         Label verifiedStub = new Label();
249         crb.buildLabelOffsets(lir);
250         try {
251             emitCode(crb, lir, installedCodeOwner, verifiedStub);
252         } catch (BranchTargetOutOfBoundsException e) {
253             // A branch estimation was wrong, now retry with conservative label ranges, this
254             // should always work
255             crb.setConservativeLabelRanges();
256             crb.resetForEmittingCode();
257             lir.resetLabels();
258             verifiedStub.reset();
259             emitCode(crb, lir, installedCodeOwner, verifiedStub);
260         }
261     }
</pre>
<hr />
<pre>
334     public static void emitInvalidatePlaceholder(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
335         if (!GeneratePIC.getValue(crb.getOptions())) {
336             crb.blockComment(&quot;[nop for method invalidation]&quot;);
337             masm.nop();
338         }
339     }
340 
341     private void emitCodeSuffix(CompilationResultBuilder crb, AArch64MacroAssembler masm, FrameMap frameMap) {
342         HotSpotProviders providers = getProviders();
343         HotSpotFrameContext frameContext = (HotSpotFrameContext) crb.frameContext;
344         if (!frameContext.isStub) {
345             HotSpotForeignCallsProvider foreignCalls = providers.getForeignCalls();
346             try (ScratchRegister sc = masm.getScratchRegister()) {
347                 Register scratch = sc.getRegister();
348                 crb.recordMark(config.MARKID_EXCEPTION_HANDLER_ENTRY);
349                 ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(EXCEPTION_HANDLER);
350                 Register helper = AArch64Call.isNearCall(linkage) ? null : scratch;
351                 AArch64Call.directCall(crb, masm, linkage, helper, null);
352             }
353             crb.recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
<span class="line-modified">354             ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(DEOPTIMIZATION_HANDLER);</span>
355             masm.adr(lr, 0); // Warning: the argument is an offset from the instruction!
356             AArch64Call.directJmp(crb, masm, linkage);
357         } else {
358             // No need to emit the stubs for entries back into the method since
359             // it has no calls that can cause such &quot;return&quot; entries
360             assert !frameMap.accessesCallerFrame();
361         }
362     }
363 
364     @Override
365     public RegisterAllocationConfig newRegisterAllocationConfig(RegisterConfig registerConfig, String[] allocationRestrictedTo) {
366         RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
367         return new AArch64HotSpotRegisterAllocationConfig(registerConfigNonNull, allocationRestrictedTo);
368     }
369 
370     @Override
371     public EconomicSet&lt;Register&gt; translateToCallerRegisters(EconomicSet&lt;Register&gt; calleeRegisters) {
372         return calleeRegisters;
373     }
374 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 27 import static java.lang.reflect.Modifier.isStatic;
 28 import static jdk.vm.ci.aarch64.AArch64.lr;
 29 import static jdk.vm.ci.aarch64.AArch64.r10;
 30 import static jdk.vm.ci.aarch64.AArch64.sp;
 31 import static jdk.vm.ci.aarch64.AArch64.zr;
 32 import static jdk.vm.ci.code.ValueUtil.asRegister;
 33 import static jdk.vm.ci.hotspot.aarch64.AArch64HotSpotRegisterConfig.fp;
 34 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 35 import static org.graalvm.compiler.core.common.GraalOptions.ZapStackOnMethodEntry;
 36 
 37 import jdk.internal.vm.compiler.collections.EconomicSet;
 38 import org.graalvm.compiler.asm.Assembler;
 39 import org.graalvm.compiler.asm.BranchTargetOutOfBoundsException;
 40 import org.graalvm.compiler.asm.Label;
 41 import org.graalvm.compiler.asm.aarch64.AArch64Address;
 42 import org.graalvm.compiler.asm.aarch64.AArch64Assembler;
 43 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 44 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;
 45 import org.graalvm.compiler.code.CompilationResult;
 46 import org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules;

 47 import org.graalvm.compiler.core.common.LIRKind;
 48 import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;
 49 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 50 import org.graalvm.compiler.core.gen.LIRGenerationProvider;
<span class="line-added"> 51 import org.graalvm.compiler.debug.DebugContext;</span>
 52 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 53 import org.graalvm.compiler.hotspot.HotSpotDataBuilder;
 54 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 55 import org.graalvm.compiler.hotspot.HotSpotHostBackend;
 56 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 57 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 58 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
 59 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 60 import org.graalvm.compiler.hotspot.stubs.Stub;
 61 import org.graalvm.compiler.lir.LIR;
 62 import org.graalvm.compiler.lir.aarch64.AArch64Call;
 63 import org.graalvm.compiler.lir.aarch64.AArch64FrameMap;
 64 import org.graalvm.compiler.lir.aarch64.AArch64FrameMapBuilder;
 65 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 66 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 67 import org.graalvm.compiler.lir.asm.DataBuilder;
 68 import org.graalvm.compiler.lir.asm.FrameContext;
 69 import org.graalvm.compiler.lir.framemap.FrameMap;
 70 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 71 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 72 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 73 import org.graalvm.compiler.nodes.StructuredGraph;
 74 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<span class="line-added"> 75 import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;</span>
 76 
 77 import jdk.vm.ci.aarch64.AArch64Kind;
 78 import jdk.vm.ci.code.CallingConvention;
<span class="line-added"> 79 import jdk.vm.ci.code.CompilationRequest;</span>
<span class="line-added"> 80 import jdk.vm.ci.code.InstalledCode;</span>
 81 import jdk.vm.ci.code.Register;
 82 import jdk.vm.ci.code.RegisterConfig;
 83 import jdk.vm.ci.code.StackSlot;
<span class="line-added"> 84 import jdk.vm.ci.code.site.Mark;</span>
 85 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 86 import jdk.vm.ci.hotspot.HotSpotSentinelConstant;
 87 import jdk.vm.ci.hotspot.aarch64.AArch64HotSpotRegisterConfig;
 88 import jdk.vm.ci.meta.JavaKind;
 89 import jdk.vm.ci.meta.JavaType;
 90 import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-added"> 91 import sun.misc.Unsafe;</span>
 92 
 93 /**
 94  * HotSpot AArch64 specific backend.
 95  */
 96 public class AArch64HotSpotBackend extends HotSpotHostBackend implements LIRGenerationProvider {
 97 
 98     public AArch64HotSpotBackend(GraalHotSpotVMConfig config, HotSpotGraalRuntimeProvider runtime, HotSpotProviders providers) {
 99         super(config, runtime, providers);
100     }
101 
<span class="line-modified">102     @Override</span>
<span class="line-added">103     protected FrameMapBuilder newFrameMapBuilder(RegisterConfig registerConfig) {</span>
104         RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
105         FrameMap frameMap = new AArch64FrameMap(getCodeCache(), registerConfigNonNull, this);
106         return new AArch64FrameMapBuilder(frameMap, getCodeCache(), registerConfigNonNull);
107     }
108 
109     @Override
110     public LIRGeneratorTool newLIRGenerator(LIRGenerationResult lirGenRes) {
111         return new AArch64HotSpotLIRGenerator(getProviders(), config, lirGenRes);
112     }
113 






114     @Override
115     public NodeLIRBuilderTool newNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool lirGen) {
116         return new AArch64HotSpotNodeLIRBuilder(graph, lirGen, new AArch64NodeMatchRules(lirGen));
117     }
118 
119     @Override
120     protected void bangStackWithOffset(CompilationResultBuilder crb, int bangOffset) {
121         AArch64MacroAssembler masm = (AArch64MacroAssembler) crb.asm;
122         try (ScratchRegister sc = masm.getScratchRegister()) {
123             Register scratch = sc.getRegister();
124             AArch64Address address = masm.makeAddress(sp, -bangOffset, scratch, 8, /* allowOverwrite */false);
125             masm.str(64, zr, address);
126         }
127     }
128 
<span class="line-added">129     @Override</span>
<span class="line-added">130     public InstalledCode createInstalledCode(DebugContext debug,</span>
<span class="line-added">131                     ResolvedJavaMethod method,</span>
<span class="line-added">132                     CompilationRequest compilationRequest,</span>
<span class="line-added">133                     CompilationResult compilationResult,</span>
<span class="line-added">134                     InstalledCode predefinedInstalledCode,</span>
<span class="line-added">135                     boolean isDefault,</span>
<span class="line-added">136                     Object[] context) {</span>
<span class="line-added">137         boolean isStub = (method == null);</span>
<span class="line-added">138         boolean isAOT = compilationResult.isImmutablePIC();</span>
<span class="line-added">139         if (!isStub &amp;&amp; !isAOT) {</span>
<span class="line-added">140             // Non-stub compilation results are installed into HotSpot as nmethods. As AArch64 has</span>
<span class="line-added">141             // a constraint that the instruction at nmethod verified entry point should be a nop or</span>
<span class="line-added">142             // jump, AArch64HotSpotBackend always generate a nop placeholder before the code body</span>
<span class="line-added">143             // for non-AOT compilations. See AArch64HotSpotBackend.emitInvalidatePlaceholder(). This</span>
<span class="line-added">144             // assert checks if the nop placeholder is generated at all required places, including</span>
<span class="line-added">145             // in manually assembled code in CodeGenTest cases.</span>
<span class="line-added">146             assert hasInvalidatePlaceholder(compilationResult);</span>
<span class="line-added">147         }</span>
<span class="line-added">148         return super.createInstalledCode(debug, method, compilationRequest, compilationResult, predefinedInstalledCode, isDefault, context);</span>
<span class="line-added">149     }</span>
<span class="line-added">150 </span>
<span class="line-added">151     private boolean hasInvalidatePlaceholder(CompilationResult compilationResult) {</span>
<span class="line-added">152         byte[] targetCode = compilationResult.getTargetCode();</span>
<span class="line-added">153         int verifiedEntryOffset = 0;</span>
<span class="line-added">154         for (Mark mark : compilationResult.getMarks()) {</span>
<span class="line-added">155             Object markId = mark.id;</span>
<span class="line-added">156             if (markId instanceof Integer &amp;&amp; (int) markId == config.MARKID_VERIFIED_ENTRY) {</span>
<span class="line-added">157                 // The nmethod verified entry is located at some pc offset.</span>
<span class="line-added">158                 verifiedEntryOffset = mark.pcOffset;</span>
<span class="line-added">159                 break;</span>
<span class="line-added">160             }</span>
<span class="line-added">161         }</span>
<span class="line-added">162         Unsafe unsafe = GraalUnsafeAccess.getUnsafe();</span>
<span class="line-added">163         int instruction = unsafe.getIntVolatile(targetCode, unsafe.arrayBaseOffset(byte[].class) + verifiedEntryOffset);</span>
<span class="line-added">164         AArch64MacroAssembler masm = new AArch64MacroAssembler(getTarget());</span>
<span class="line-added">165         masm.nop();</span>
<span class="line-added">166         return instruction == masm.getInt(0);</span>
<span class="line-added">167     }</span>
<span class="line-added">168 </span>
169     private class HotSpotFrameContext implements FrameContext {
170         final boolean isStub;
171 
172         HotSpotFrameContext(boolean isStub) {
173             this.isStub = isStub;
174         }
175 
176         @Override
177         public void enter(CompilationResultBuilder crb) {
178             FrameMap frameMap = crb.frameMap;
179             final int frameSize = frameMap.frameSize();
180             final int totalFrameSize = frameMap.totalFrameSize();
181             assert frameSize + 2 * crb.target.arch.getWordSize() == totalFrameSize : &quot;total framesize should be framesize + 2 words&quot;;
182             AArch64MacroAssembler masm = (AArch64MacroAssembler) crb.asm;
183             if (!isStub) {
184                 emitStackOverflowCheck(crb);
185             }
186             crb.blockComment(&quot;[method prologue]&quot;);
187 
188             try (ScratchRegister sc = masm.getScratchRegister()) {
</pre>
<hr />
<pre>
260     public CompilationResultBuilder newCompilationResultBuilder(LIRGenerationResult lirGenRen, FrameMap frameMap, CompilationResult compilationResult, CompilationResultBuilderFactory factory) {
261         HotSpotLIRGenerationResult gen = (HotSpotLIRGenerationResult) lirGenRen;
262         LIR lir = gen.getLIR();
263         assert gen.getDeoptimizationRescueSlot() == null || frameMap.frameNeedsAllocating() : &quot;method that can deoptimize must have a frame&quot;;
264 
265         Stub stub = gen.getStub();
266         Assembler masm = new AArch64MacroAssembler(getTarget());
267         HotSpotFrameContext frameContext = new HotSpotFrameContext(stub != null);
268 
269         DataBuilder dataBuilder = new HotSpotDataBuilder(getCodeCache().getTarget());
270         CompilationResultBuilder crb = factory.createBuilder(getCodeCache(), getForeignCalls(), frameMap, masm, dataBuilder, frameContext, lir.getOptions(), lir.getDebug(), compilationResult,
271                         Register.None);
272         crb.setTotalFrameSize(frameMap.totalFrameSize());
273         crb.setMaxInterpreterFrameSize(gen.getMaxInterpreterFrameSize());
274         StackSlot deoptimizationRescueSlot = gen.getDeoptimizationRescueSlot();
275         if (deoptimizationRescueSlot != null &amp;&amp; stub == null) {
276             crb.compilationResult.setCustomStackAreaOffset(deoptimizationRescueSlot);
277         }
278 
279         if (stub != null) {
<span class="line-modified">280             updateStub(stub, gen, frameMap);</span>

281         }
282         return crb;
283     }
284 
285     @Override
286     public void emitCode(CompilationResultBuilder crb, LIR lir, ResolvedJavaMethod installedCodeOwner) {
287         Label verifiedStub = new Label();
288         crb.buildLabelOffsets(lir);
289         try {
290             emitCode(crb, lir, installedCodeOwner, verifiedStub);
291         } catch (BranchTargetOutOfBoundsException e) {
292             // A branch estimation was wrong, now retry with conservative label ranges, this
293             // should always work
294             crb.setConservativeLabelRanges();
295             crb.resetForEmittingCode();
296             lir.resetLabels();
297             verifiedStub.reset();
298             emitCode(crb, lir, installedCodeOwner, verifiedStub);
299         }
300     }
</pre>
<hr />
<pre>
373     public static void emitInvalidatePlaceholder(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
374         if (!GeneratePIC.getValue(crb.getOptions())) {
375             crb.blockComment(&quot;[nop for method invalidation]&quot;);
376             masm.nop();
377         }
378     }
379 
380     private void emitCodeSuffix(CompilationResultBuilder crb, AArch64MacroAssembler masm, FrameMap frameMap) {
381         HotSpotProviders providers = getProviders();
382         HotSpotFrameContext frameContext = (HotSpotFrameContext) crb.frameContext;
383         if (!frameContext.isStub) {
384             HotSpotForeignCallsProvider foreignCalls = providers.getForeignCalls();
385             try (ScratchRegister sc = masm.getScratchRegister()) {
386                 Register scratch = sc.getRegister();
387                 crb.recordMark(config.MARKID_EXCEPTION_HANDLER_ENTRY);
388                 ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(EXCEPTION_HANDLER);
389                 Register helper = AArch64Call.isNearCall(linkage) ? null : scratch;
390                 AArch64Call.directCall(crb, masm, linkage, helper, null);
391             }
392             crb.recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
<span class="line-modified">393             ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(DEOPT_BLOB_UNPACK);</span>
394             masm.adr(lr, 0); // Warning: the argument is an offset from the instruction!
395             AArch64Call.directJmp(crb, masm, linkage);
396         } else {
397             // No need to emit the stubs for entries back into the method since
398             // it has no calls that can cause such &quot;return&quot; entries
399             assert !frameMap.accessesCallerFrame();
400         }
401     }
402 
403     @Override
404     public RegisterAllocationConfig newRegisterAllocationConfig(RegisterConfig registerConfig, String[] allocationRestrictedTo) {
405         RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
406         return new AArch64HotSpotRegisterAllocationConfig(registerConfigNonNull, allocationRestrictedTo);
407     }
408 
409     @Override
410     public EconomicSet&lt;Register&gt; translateToCallerRegisters(EconomicSet&lt;Register&gt; calleeRegisters) {
411         return calleeRegisters;
412     }
413 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/spi/Canonicalizable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotBackendFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
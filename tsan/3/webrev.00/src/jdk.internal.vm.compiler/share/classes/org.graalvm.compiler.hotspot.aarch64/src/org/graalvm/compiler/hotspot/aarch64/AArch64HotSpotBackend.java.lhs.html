<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.aarch64;
 26 
 27 import static java.lang.reflect.Modifier.isStatic;
 28 import static jdk.vm.ci.aarch64.AArch64.lr;
 29 import static jdk.vm.ci.aarch64.AArch64.r10;
 30 import static jdk.vm.ci.aarch64.AArch64.sp;
 31 import static jdk.vm.ci.aarch64.AArch64.zr;
 32 import static jdk.vm.ci.code.ValueUtil.asRegister;
 33 import static jdk.vm.ci.hotspot.aarch64.AArch64HotSpotRegisterConfig.fp;
 34 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 35 import static org.graalvm.compiler.core.common.GraalOptions.ZapStackOnMethodEntry;
 36 
 37 import jdk.internal.vm.compiler.collections.EconomicSet;
 38 import org.graalvm.compiler.asm.Assembler;
 39 import org.graalvm.compiler.asm.BranchTargetOutOfBoundsException;
 40 import org.graalvm.compiler.asm.Label;
 41 import org.graalvm.compiler.asm.aarch64.AArch64Address;
 42 import org.graalvm.compiler.asm.aarch64.AArch64Assembler;
 43 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 44 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;
 45 import org.graalvm.compiler.code.CompilationResult;
 46 import org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules;
<a name="2" id="anc2"></a><span class="line-removed"> 47 import org.graalvm.compiler.core.common.CompilationIdentifier;</span>
 48 import org.graalvm.compiler.core.common.LIRKind;
 49 import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;
 50 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 51 import org.graalvm.compiler.core.gen.LIRGenerationProvider;
<a name="3" id="anc3"></a>
 52 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 53 import org.graalvm.compiler.hotspot.HotSpotDataBuilder;
 54 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 55 import org.graalvm.compiler.hotspot.HotSpotHostBackend;
 56 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 57 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 58 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
 59 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 60 import org.graalvm.compiler.hotspot.stubs.Stub;
 61 import org.graalvm.compiler.lir.LIR;
 62 import org.graalvm.compiler.lir.aarch64.AArch64Call;
 63 import org.graalvm.compiler.lir.aarch64.AArch64FrameMap;
 64 import org.graalvm.compiler.lir.aarch64.AArch64FrameMapBuilder;
 65 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 66 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 67 import org.graalvm.compiler.lir.asm.DataBuilder;
 68 import org.graalvm.compiler.lir.asm.FrameContext;
 69 import org.graalvm.compiler.lir.framemap.FrameMap;
 70 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 71 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 72 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 73 import org.graalvm.compiler.nodes.StructuredGraph;
 74 import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<a name="4" id="anc4"></a>
 75 
 76 import jdk.vm.ci.aarch64.AArch64Kind;
 77 import jdk.vm.ci.code.CallingConvention;
<a name="5" id="anc5"></a>

 78 import jdk.vm.ci.code.Register;
 79 import jdk.vm.ci.code.RegisterConfig;
 80 import jdk.vm.ci.code.StackSlot;
<a name="6" id="anc6"></a>
 81 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 82 import jdk.vm.ci.hotspot.HotSpotSentinelConstant;
 83 import jdk.vm.ci.hotspot.aarch64.AArch64HotSpotRegisterConfig;
 84 import jdk.vm.ci.meta.JavaKind;
 85 import jdk.vm.ci.meta.JavaType;
 86 import jdk.vm.ci.meta.ResolvedJavaMethod;
<a name="7" id="anc7"></a>
 87 
 88 /**
 89  * HotSpot AArch64 specific backend.
 90  */
 91 public class AArch64HotSpotBackend extends HotSpotHostBackend implements LIRGenerationProvider {
 92 
 93     public AArch64HotSpotBackend(GraalHotSpotVMConfig config, HotSpotGraalRuntimeProvider runtime, HotSpotProviders providers) {
 94         super(config, runtime, providers);
 95     }
 96 
<a name="8" id="anc8"></a><span class="line-modified"> 97     private FrameMapBuilder newFrameMapBuilder(RegisterConfig registerConfig) {</span>

 98         RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
 99         FrameMap frameMap = new AArch64FrameMap(getCodeCache(), registerConfigNonNull, this);
100         return new AArch64FrameMapBuilder(frameMap, getCodeCache(), registerConfigNonNull);
101     }
102 
103     @Override
104     public LIRGeneratorTool newLIRGenerator(LIRGenerationResult lirGenRes) {
105         return new AArch64HotSpotLIRGenerator(getProviders(), config, lirGenRes);
106     }
107 
<a name="9" id="anc9"></a><span class="line-removed">108     @Override</span>
<span class="line-removed">109     public LIRGenerationResult newLIRGenerationResult(CompilationIdentifier compilationId, LIR lir, RegisterConfig registerConfig, StructuredGraph graph, Object stub) {</span>
<span class="line-removed">110         return new HotSpotLIRGenerationResult(compilationId, lir, newFrameMapBuilder(registerConfig), makeCallingConvention(graph, (Stub) stub), stub,</span>
<span class="line-removed">111                         config.requiresReservedStackCheck(graph.getMethods()));</span>
<span class="line-removed">112     }</span>
<span class="line-removed">113 </span>
114     @Override
115     public NodeLIRBuilderTool newNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool lirGen) {
116         return new AArch64HotSpotNodeLIRBuilder(graph, lirGen, new AArch64NodeMatchRules(lirGen));
117     }
118 
119     @Override
120     protected void bangStackWithOffset(CompilationResultBuilder crb, int bangOffset) {
121         AArch64MacroAssembler masm = (AArch64MacroAssembler) crb.asm;
122         try (ScratchRegister sc = masm.getScratchRegister()) {
123             Register scratch = sc.getRegister();
124             AArch64Address address = masm.makeAddress(sp, -bangOffset, scratch, 8, /* allowOverwrite */false);
125             masm.str(64, zr, address);
126         }
127     }
128 
<a name="10" id="anc10"></a>







































129     private class HotSpotFrameContext implements FrameContext {
130         final boolean isStub;
131 
132         HotSpotFrameContext(boolean isStub) {
133             this.isStub = isStub;
134         }
135 
136         @Override
137         public void enter(CompilationResultBuilder crb) {
138             FrameMap frameMap = crb.frameMap;
139             final int frameSize = frameMap.frameSize();
140             final int totalFrameSize = frameMap.totalFrameSize();
141             assert frameSize + 2 * crb.target.arch.getWordSize() == totalFrameSize : &quot;total framesize should be framesize + 2 words&quot;;
142             AArch64MacroAssembler masm = (AArch64MacroAssembler) crb.asm;
143             if (!isStub) {
144                 emitStackOverflowCheck(crb);
145             }
146             crb.blockComment(&quot;[method prologue]&quot;);
147 
148             try (ScratchRegister sc = masm.getScratchRegister()) {
149                 int wordSize = crb.target.arch.getWordSize();
150                 Register rscratch1 = sc.getRegister();
151                 assert totalFrameSize &gt; 0;
152                 if (frameSize &lt; 1 &lt;&lt; 9) {
153                     masm.sub(64, sp, sp, totalFrameSize);
154                     masm.stp(64, fp, lr, AArch64Address.createScaledImmediateAddress(sp, frameSize / wordSize));
155                 } else {
156                     masm.stp(64, fp, lr, AArch64Address.createPreIndexedImmediateAddress(sp, -2));
157                     if (frameSize &lt; 1 &lt;&lt; 12) {
158                         masm.sub(64, sp, sp, totalFrameSize - 2 * wordSize);
159                     } else {
160                         masm.mov(rscratch1, totalFrameSize - 2 * wordSize);
161                         masm.sub(64, sp, sp, rscratch1);
162                     }
163                 }
164             }
165             if (ZapStackOnMethodEntry.getValue(crb.getOptions())) {
166                 try (ScratchRegister sc = masm.getScratchRegister()) {
167                     Register scratch = sc.getRegister();
168                     int longSize = 8;
169                     masm.mov(64, scratch, sp);
170                     AArch64Address address = AArch64Address.createPostIndexedImmediateAddress(scratch, longSize);
171                     try (ScratchRegister sc2 = masm.getScratchRegister()) {
172                         Register value = sc2.getRegister();
173                         masm.mov(value, 0xBADDECAFFC0FFEEL);
174                         for (int i = 0; i &lt; frameSize; i += longSize) {
175                             masm.str(64, value, address);
176                         }
177                     }
178 
179                 }
180             }
181             crb.blockComment(&quot;[code body]&quot;);
182         }
183 
184         @Override
185         public void leave(CompilationResultBuilder crb) {
186             AArch64MacroAssembler masm = (AArch64MacroAssembler) crb.asm;
187             FrameMap frameMap = crb.frameMap;
188             final int totalFrameSize = frameMap.totalFrameSize();
189 
190             crb.blockComment(&quot;[method epilogue]&quot;);
191             try (ScratchRegister sc = masm.getScratchRegister()) {
192                 int wordSize = crb.target.arch.getWordSize();
193                 Register rscratch1 = sc.getRegister();
194                 final int frameSize = frameMap.frameSize();
195                 assert totalFrameSize &gt; 0;
196                 if (frameSize &lt; 1 &lt;&lt; 9) {
197                     masm.ldp(64, fp, lr, AArch64Address.createScaledImmediateAddress(sp, frameSize / wordSize));
198                     masm.add(64, sp, sp, totalFrameSize);
199                 } else {
200                     if (frameSize &lt; 1 &lt;&lt; 12) {
201                         masm.add(64, sp, sp, totalFrameSize - 2 * wordSize);
202                     } else {
203                         masm.mov(rscratch1, totalFrameSize - 2 * wordSize);
204                         masm.add(64, sp, sp, rscratch1);
205                     }
206                     masm.ldp(64, fp, lr, AArch64Address.createPostIndexedImmediateAddress(sp, 2));
207                 }
208             }
209 
210         }
211 
212         @Override
213         public boolean hasFrame() {
214             return true;
215         }
216 
217     }
218 
219     @Override
220     public CompilationResultBuilder newCompilationResultBuilder(LIRGenerationResult lirGenRen, FrameMap frameMap, CompilationResult compilationResult, CompilationResultBuilderFactory factory) {
221         HotSpotLIRGenerationResult gen = (HotSpotLIRGenerationResult) lirGenRen;
222         LIR lir = gen.getLIR();
223         assert gen.getDeoptimizationRescueSlot() == null || frameMap.frameNeedsAllocating() : &quot;method that can deoptimize must have a frame&quot;;
224 
225         Stub stub = gen.getStub();
226         Assembler masm = new AArch64MacroAssembler(getTarget());
227         HotSpotFrameContext frameContext = new HotSpotFrameContext(stub != null);
228 
229         DataBuilder dataBuilder = new HotSpotDataBuilder(getCodeCache().getTarget());
230         CompilationResultBuilder crb = factory.createBuilder(getCodeCache(), getForeignCalls(), frameMap, masm, dataBuilder, frameContext, lir.getOptions(), lir.getDebug(), compilationResult,
231                         Register.None);
232         crb.setTotalFrameSize(frameMap.totalFrameSize());
233         crb.setMaxInterpreterFrameSize(gen.getMaxInterpreterFrameSize());
234         StackSlot deoptimizationRescueSlot = gen.getDeoptimizationRescueSlot();
235         if (deoptimizationRescueSlot != null &amp;&amp; stub == null) {
236             crb.compilationResult.setCustomStackAreaOffset(deoptimizationRescueSlot);
237         }
238 
239         if (stub != null) {
<a name="11" id="anc11"></a><span class="line-modified">240             EconomicSet&lt;Register&gt; destroyedCallerRegisters = gatherDestroyedCallerRegisters(lir);</span>
<span class="line-removed">241             updateStub(stub, destroyedCallerRegisters, gen.getCalleeSaveInfo(), frameMap);</span>
242         }
243         return crb;
244     }
245 
246     @Override
247     public void emitCode(CompilationResultBuilder crb, LIR lir, ResolvedJavaMethod installedCodeOwner) {
248         Label verifiedStub = new Label();
249         crb.buildLabelOffsets(lir);
250         try {
251             emitCode(crb, lir, installedCodeOwner, verifiedStub);
252         } catch (BranchTargetOutOfBoundsException e) {
253             // A branch estimation was wrong, now retry with conservative label ranges, this
254             // should always work
255             crb.setConservativeLabelRanges();
256             crb.resetForEmittingCode();
257             lir.resetLabels();
258             verifiedStub.reset();
259             emitCode(crb, lir, installedCodeOwner, verifiedStub);
260         }
261     }
262 
263     private void emitCode(CompilationResultBuilder crb, LIR lir, ResolvedJavaMethod installedCodeOwner, Label verifiedStub) {
264         AArch64MacroAssembler masm = (AArch64MacroAssembler) crb.asm;
265         FrameMap frameMap = crb.frameMap;
266         RegisterConfig regConfig = frameMap.getRegisterConfig();
267         emitCodePrefix(crb, installedCodeOwner, masm, regConfig, verifiedStub);
268         emitCodeBody(crb, lir, masm);
269         emitCodeSuffix(crb, masm, frameMap);
270     }
271 
272     private void emitCodePrefix(CompilationResultBuilder crb, ResolvedJavaMethod installedCodeOwner, AArch64MacroAssembler masm, RegisterConfig regConfig, Label verifiedStub) {
273         HotSpotProviders providers = getProviders();
274         if (installedCodeOwner != null &amp;&amp; !isStatic(installedCodeOwner.getModifiers())) {
275             crb.recordMark(config.MARKID_UNVERIFIED_ENTRY);
276             CallingConvention cc = regConfig.getCallingConvention(HotSpotCallingConventionType.JavaCallee, null, new JavaType[]{providers.getMetaAccess().lookupJavaType(Object.class)}, this);
277             // See definition of IC_Klass in c1_LIRAssembler_aarch64.cpp
278             // equal to scratch(1) careful!
279             Register inlineCacheKlass = AArch64HotSpotRegisterConfig.inlineCacheRegister;
280             Register receiver = asRegister(cc.getArgument(0));
281             int transferSize = config.useCompressedClassPointers ? 4 : 8;
282             AArch64Address klassAddress = masm.makeAddress(receiver, config.hubOffset, transferSize);
283 
284             // Are r10 and r11 available scratch registers here? One would hope so.
285             Register klass = r10;
286             if (config.useCompressedClassPointers) {
287                 masm.ldr(32, klass, klassAddress);
288                 AArch64HotSpotMove.decodeKlassPointer(crb, masm, klass, klass, config.getKlassEncoding(), config);
289             } else {
290                 masm.ldr(64, klass, klassAddress);
291             }
292             masm.cmp(64, inlineCacheKlass, klass);
293             /*
294              * Conditional jumps have a much lower range than unconditional ones, which can be a
295              * problem because the miss handler could be out of range.
296              */
297             masm.branchConditionally(AArch64Assembler.ConditionFlag.EQ, verifiedStub);
298             AArch64Call.directJmp(crb, masm, getForeignCalls().lookupForeignCall(IC_MISS_HANDLER));
299         }
300         masm.align(config.codeEntryAlignment);
301         crb.recordMark(config.MARKID_OSR_ENTRY);
302         masm.bind(verifiedStub);
303         crb.recordMark(config.MARKID_VERIFIED_ENTRY);
304 
305         if (GeneratePIC.getValue(crb.getOptions())) {
306             // Check for method state
307             HotSpotFrameContext frameContext = (HotSpotFrameContext) crb.frameContext;
308             if (!frameContext.isStub) {
309                 crb.recordInlineDataInCodeWithNote(new HotSpotSentinelConstant(LIRKind.value(AArch64Kind.QWORD), JavaKind.Long), HotSpotConstantLoadAction.MAKE_NOT_ENTRANT);
310                 try (ScratchRegister sc = masm.getScratchRegister()) {
311                     Register scratch = sc.getRegister();
312                     masm.addressOf(scratch);
313                     masm.ldr(64, scratch, AArch64Address.createBaseRegisterOnlyAddress(scratch));
314                     Label noCall = new Label();
315                     masm.cbz(64, scratch, noCall);
316                     AArch64Call.directJmp(crb, masm, getForeignCalls().lookupForeignCall(WRONG_METHOD_HANDLER));
317                     masm.bind(noCall);
318                 }
319             }
320         }
321     }
322 
323     private static void emitCodeBody(CompilationResultBuilder crb, LIR lir, AArch64MacroAssembler masm) {
324         emitInvalidatePlaceholder(crb, masm);
325         crb.emit(lir);
326     }
327 
328     /**
329      * Insert a nop at the start of the prolog so we can patch in a branch if we need to invalidate
330      * the method later.
331      *
332      * @see &quot;http://mail.openjdk.java.net/pipermail/aarch64-port-dev/2013-September/000273.html&quot;
333      */
334     public static void emitInvalidatePlaceholder(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
335         if (!GeneratePIC.getValue(crb.getOptions())) {
336             crb.blockComment(&quot;[nop for method invalidation]&quot;);
337             masm.nop();
338         }
339     }
340 
341     private void emitCodeSuffix(CompilationResultBuilder crb, AArch64MacroAssembler masm, FrameMap frameMap) {
342         HotSpotProviders providers = getProviders();
343         HotSpotFrameContext frameContext = (HotSpotFrameContext) crb.frameContext;
344         if (!frameContext.isStub) {
345             HotSpotForeignCallsProvider foreignCalls = providers.getForeignCalls();
346             try (ScratchRegister sc = masm.getScratchRegister()) {
347                 Register scratch = sc.getRegister();
348                 crb.recordMark(config.MARKID_EXCEPTION_HANDLER_ENTRY);
349                 ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(EXCEPTION_HANDLER);
350                 Register helper = AArch64Call.isNearCall(linkage) ? null : scratch;
351                 AArch64Call.directCall(crb, masm, linkage, helper, null);
352             }
353             crb.recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
<a name="12" id="anc12"></a><span class="line-modified">354             ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(DEOPTIMIZATION_HANDLER);</span>
355             masm.adr(lr, 0); // Warning: the argument is an offset from the instruction!
356             AArch64Call.directJmp(crb, masm, linkage);
357         } else {
358             // No need to emit the stubs for entries back into the method since
359             // it has no calls that can cause such &quot;return&quot; entries
360             assert !frameMap.accessesCallerFrame();
361         }
362     }
363 
364     @Override
365     public RegisterAllocationConfig newRegisterAllocationConfig(RegisterConfig registerConfig, String[] allocationRestrictedTo) {
366         RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
367         return new AArch64HotSpotRegisterAllocationConfig(registerConfigNonNull, allocationRestrictedTo);
368     }
369 
370     @Override
371     public EconomicSet&lt;Register&gt; translateToCallerRegisters(EconomicSet&lt;Register&gt; calleeRegisters) {
372         return calleeRegisters;
373     }
374 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
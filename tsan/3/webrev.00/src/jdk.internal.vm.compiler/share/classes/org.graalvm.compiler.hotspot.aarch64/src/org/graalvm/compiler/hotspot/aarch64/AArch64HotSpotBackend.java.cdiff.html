<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/spi/Canonicalizable.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotBackendFactory.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.aarch64/src/org/graalvm/compiler/hotspot/aarch64/AArch64HotSpotBackend.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,15 ***</span>
  import org.graalvm.compiler.asm.aarch64.AArch64Assembler;
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;
  import org.graalvm.compiler.code.CompilationResult;
  import org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules;
<span class="line-removed">- import org.graalvm.compiler.core.common.CompilationIdentifier;</span>
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;
  import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
  import org.graalvm.compiler.core.gen.LIRGenerationProvider;
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  import org.graalvm.compiler.hotspot.HotSpotDataBuilder;
  import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
  import org.graalvm.compiler.hotspot.HotSpotHostBackend;
  import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
<span class="line-new-header">--- 42,15 ---</span>
  import org.graalvm.compiler.asm.aarch64.AArch64Assembler;
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
  import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;
  import org.graalvm.compiler.code.CompilationResult;
  import org.graalvm.compiler.core.aarch64.AArch64NodeMatchRules;
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;
  import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
  import org.graalvm.compiler.core.gen.LIRGenerationProvider;
<span class="line-added">+ import org.graalvm.compiler.debug.DebugContext;</span>
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  import org.graalvm.compiler.hotspot.HotSpotDataBuilder;
  import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
  import org.graalvm.compiler.hotspot.HotSpotHostBackend;
  import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,49 ***</span>
  import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
  import org.graalvm.compiler.lir.gen.LIRGenerationResult;
  import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
  
  import jdk.vm.ci.aarch64.AArch64Kind;
  import jdk.vm.ci.code.CallingConvention;
  import jdk.vm.ci.code.Register;
  import jdk.vm.ci.code.RegisterConfig;
  import jdk.vm.ci.code.StackSlot;
  import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
  import jdk.vm.ci.hotspot.HotSpotSentinelConstant;
  import jdk.vm.ci.hotspot.aarch64.AArch64HotSpotRegisterConfig;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.JavaType;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  
  /**
   * HotSpot AArch64 specific backend.
   */
  public class AArch64HotSpotBackend extends HotSpotHostBackend implements LIRGenerationProvider {
  
      public AArch64HotSpotBackend(GraalHotSpotVMConfig config, HotSpotGraalRuntimeProvider runtime, HotSpotProviders providers) {
          super(config, runtime, providers);
      }
  
<span class="line-modified">!     private FrameMapBuilder newFrameMapBuilder(RegisterConfig registerConfig) {</span>
          RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
          FrameMap frameMap = new AArch64FrameMap(getCodeCache(), registerConfigNonNull, this);
          return new AArch64FrameMapBuilder(frameMap, getCodeCache(), registerConfigNonNull);
      }
  
      @Override
      public LIRGeneratorTool newLIRGenerator(LIRGenerationResult lirGenRes) {
          return new AArch64HotSpotLIRGenerator(getProviders(), config, lirGenRes);
      }
  
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     public LIRGenerationResult newLIRGenerationResult(CompilationIdentifier compilationId, LIR lir, RegisterConfig registerConfig, StructuredGraph graph, Object stub) {</span>
<span class="line-removed">-         return new HotSpotLIRGenerationResult(compilationId, lir, newFrameMapBuilder(registerConfig), makeCallingConvention(graph, (Stub) stub), stub,</span>
<span class="line-removed">-                         config.requiresReservedStackCheck(graph.getMethods()));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      @Override
      public NodeLIRBuilderTool newNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool lirGen) {
          return new AArch64HotSpotNodeLIRBuilder(graph, lirGen, new AArch64NodeMatchRules(lirGen));
      }
  
<span class="line-new-header">--- 70,49 ---</span>
  import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
  import org.graalvm.compiler.lir.gen.LIRGenerationResult;
  import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;
<span class="line-added">+ import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;</span>
  
  import jdk.vm.ci.aarch64.AArch64Kind;
  import jdk.vm.ci.code.CallingConvention;
<span class="line-added">+ import jdk.vm.ci.code.CompilationRequest;</span>
<span class="line-added">+ import jdk.vm.ci.code.InstalledCode;</span>
  import jdk.vm.ci.code.Register;
  import jdk.vm.ci.code.RegisterConfig;
  import jdk.vm.ci.code.StackSlot;
<span class="line-added">+ import jdk.vm.ci.code.site.Mark;</span>
  import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
  import jdk.vm.ci.hotspot.HotSpotSentinelConstant;
  import jdk.vm.ci.hotspot.aarch64.AArch64HotSpotRegisterConfig;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.JavaType;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-added">+ import sun.misc.Unsafe;</span>
  
  /**
   * HotSpot AArch64 specific backend.
   */
  public class AArch64HotSpotBackend extends HotSpotHostBackend implements LIRGenerationProvider {
  
      public AArch64HotSpotBackend(GraalHotSpotVMConfig config, HotSpotGraalRuntimeProvider runtime, HotSpotProviders providers) {
          super(config, runtime, providers);
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-added">+     protected FrameMapBuilder newFrameMapBuilder(RegisterConfig registerConfig) {</span>
          RegisterConfig registerConfigNonNull = registerConfig == null ? getCodeCache().getRegisterConfig() : registerConfig;
          FrameMap frameMap = new AArch64FrameMap(getCodeCache(), registerConfigNonNull, this);
          return new AArch64FrameMapBuilder(frameMap, getCodeCache(), registerConfigNonNull);
      }
  
      @Override
      public LIRGeneratorTool newLIRGenerator(LIRGenerationResult lirGenRes) {
          return new AArch64HotSpotLIRGenerator(getProviders(), config, lirGenRes);
      }
  
      @Override
      public NodeLIRBuilderTool newNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool lirGen) {
          return new AArch64HotSpotNodeLIRBuilder(graph, lirGen, new AArch64NodeMatchRules(lirGen));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,10 ***</span>
<span class="line-new-header">--- 124,50 ---</span>
              AArch64Address address = masm.makeAddress(sp, -bangOffset, scratch, 8, /* allowOverwrite */false);
              masm.str(64, zr, address);
          }
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     public InstalledCode createInstalledCode(DebugContext debug,</span>
<span class="line-added">+                     ResolvedJavaMethod method,</span>
<span class="line-added">+                     CompilationRequest compilationRequest,</span>
<span class="line-added">+                     CompilationResult compilationResult,</span>
<span class="line-added">+                     InstalledCode predefinedInstalledCode,</span>
<span class="line-added">+                     boolean isDefault,</span>
<span class="line-added">+                     Object[] context) {</span>
<span class="line-added">+         boolean isStub = (method == null);</span>
<span class="line-added">+         boolean isAOT = compilationResult.isImmutablePIC();</span>
<span class="line-added">+         if (!isStub &amp;&amp; !isAOT) {</span>
<span class="line-added">+             // Non-stub compilation results are installed into HotSpot as nmethods. As AArch64 has</span>
<span class="line-added">+             // a constraint that the instruction at nmethod verified entry point should be a nop or</span>
<span class="line-added">+             // jump, AArch64HotSpotBackend always generate a nop placeholder before the code body</span>
<span class="line-added">+             // for non-AOT compilations. See AArch64HotSpotBackend.emitInvalidatePlaceholder(). This</span>
<span class="line-added">+             // assert checks if the nop placeholder is generated at all required places, including</span>
<span class="line-added">+             // in manually assembled code in CodeGenTest cases.</span>
<span class="line-added">+             assert hasInvalidatePlaceholder(compilationResult);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return super.createInstalledCode(debug, method, compilationRequest, compilationResult, predefinedInstalledCode, isDefault, context);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private boolean hasInvalidatePlaceholder(CompilationResult compilationResult) {</span>
<span class="line-added">+         byte[] targetCode = compilationResult.getTargetCode();</span>
<span class="line-added">+         int verifiedEntryOffset = 0;</span>
<span class="line-added">+         for (Mark mark : compilationResult.getMarks()) {</span>
<span class="line-added">+             Object markId = mark.id;</span>
<span class="line-added">+             if (markId instanceof Integer &amp;&amp; (int) markId == config.MARKID_VERIFIED_ENTRY) {</span>
<span class="line-added">+                 // The nmethod verified entry is located at some pc offset.</span>
<span class="line-added">+                 verifiedEntryOffset = mark.pcOffset;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Unsafe unsafe = GraalUnsafeAccess.getUnsafe();</span>
<span class="line-added">+         int instruction = unsafe.getIntVolatile(targetCode, unsafe.arrayBaseOffset(byte[].class) + verifiedEntryOffset);</span>
<span class="line-added">+         AArch64MacroAssembler masm = new AArch64MacroAssembler(getTarget());</span>
<span class="line-added">+         masm.nop();</span>
<span class="line-added">+         return instruction == masm.getInt(0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private class HotSpotFrameContext implements FrameContext {
          final boolean isStub;
  
          HotSpotFrameContext(boolean isStub) {
              this.isStub = isStub;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,12 ***</span>
          if (deoptimizationRescueSlot != null &amp;&amp; stub == null) {
              crb.compilationResult.setCustomStackAreaOffset(deoptimizationRescueSlot);
          }
  
          if (stub != null) {
<span class="line-modified">!             EconomicSet&lt;Register&gt; destroyedCallerRegisters = gatherDestroyedCallerRegisters(lir);</span>
<span class="line-removed">-             updateStub(stub, destroyedCallerRegisters, gen.getCalleeSaveInfo(), frameMap);</span>
          }
          return crb;
      }
  
      @Override
<span class="line-new-header">--- 275,11 ---</span>
          if (deoptimizationRescueSlot != null &amp;&amp; stub == null) {
              crb.compilationResult.setCustomStackAreaOffset(deoptimizationRescueSlot);
          }
  
          if (stub != null) {
<span class="line-modified">!             updateStub(stub, gen, frameMap);</span>
          }
          return crb;
      }
  
      @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,11 ***</span>
                  ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(EXCEPTION_HANDLER);
                  Register helper = AArch64Call.isNearCall(linkage) ? null : scratch;
                  AArch64Call.directCall(crb, masm, linkage, helper, null);
              }
              crb.recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
<span class="line-modified">!             ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(DEOPTIMIZATION_HANDLER);</span>
              masm.adr(lr, 0); // Warning: the argument is an offset from the instruction!
              AArch64Call.directJmp(crb, masm, linkage);
          } else {
              // No need to emit the stubs for entries back into the method since
              // it has no calls that can cause such &quot;return&quot; entries
<span class="line-new-header">--- 388,11 ---</span>
                  ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(EXCEPTION_HANDLER);
                  Register helper = AArch64Call.isNearCall(linkage) ? null : scratch;
                  AArch64Call.directCall(crb, masm, linkage, helper, null);
              }
              crb.recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);
<span class="line-modified">!             ForeignCallLinkage linkage = foreignCalls.lookupForeignCall(DEOPT_BLOB_UNPACK);</span>
              masm.adr(lr, 0); // Warning: the argument is an offset from the instruction!
              AArch64Call.directJmp(crb, masm, linkage);
          } else {
              // No need to emit the stubs for entries back into the method since
              // it has no calls that can cause such &quot;return&quot; entries
</pre>
<center><a href="../../../../../../../org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/spi/Canonicalizable.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64HotSpotBackendFactory.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
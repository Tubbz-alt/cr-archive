<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/WriteBarrierAdditionTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TestSHASubstitutions.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/BootstrapWatchDog.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/WriteBarrierAdditionTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,90 ***</span>
   */
  
  
  package org.graalvm.compiler.hotspot.test;
  
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.referentOffset;
  
  import java.lang.ref.WeakReference;
  
<span class="line-modified">! import org.graalvm.compiler.api.replacements.Fold;</span>
<span class="line-removed">- import org.graalvm.compiler.debug.DebugContext;</span>
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<span class="line-modified">! import org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase;</span>
<span class="line-modified">! import org.graalvm.compiler.hotspot.gc.g1.G1PostWriteBarrier;</span>
<span class="line-modified">! import org.graalvm.compiler.hotspot.gc.g1.G1PreWriteBarrier;</span>
<span class="line-modified">! import org.graalvm.compiler.hotspot.gc.g1.G1ReferentFieldReadBarrier;</span>
<span class="line-removed">- import org.graalvm.compiler.hotspot.gc.shared.SerialWriteBarrier;</span>
<span class="line-removed">- import org.graalvm.compiler.hotspot.phases.WriteBarrierAdditionPhase;</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
<span class="line-modified">! import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;</span>
<span class="line-modified">! import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;</span>
<span class="line-modified">! import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;</span>
<span class="line-modified">! import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;</span>
  import org.graalvm.compiler.nodes.memory.ReadNode;
  import org.graalvm.compiler.nodes.memory.WriteNode;
  import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-modified">! import org.graalvm.compiler.nodes.spi.LoweringTool;</span>
<span class="line-modified">! import org.graalvm.compiler.phases.OptimisticOptimizations;</span>
<span class="line-modified">! import org.graalvm.compiler.phases.common.CanonicalizerPhase;</span>
<span class="line-modified">! import org.graalvm.compiler.phases.common.GuardLoweringPhase;</span>
<span class="line-removed">- import org.graalvm.compiler.phases.common.LoweringPhase;</span>
<span class="line-removed">- import org.graalvm.compiler.phases.common.inlining.InliningPhase;</span>
<span class="line-removed">- import org.graalvm.compiler.phases.common.inlining.policy.InlineEverythingPolicy;</span>
<span class="line-removed">- import org.graalvm.compiler.phases.tiers.HighTierContext;</span>
  import org.graalvm.compiler.phases.tiers.MidTierContext;
<span class="line-modified">! import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;</span>
  import org.junit.Assert;
  import org.junit.Test;
  
<span class="line-removed">- import jdk.vm.ci.hotspot.HotSpotInstalledCode;</span>
  import jdk.vm.ci.meta.JavaConstant;
<span class="line-modified">! import jdk.vm.ci.meta.ResolvedJavaMethod;</span>
<span class="line-removed">- import sun.misc.Unsafe;</span>
  
  /**
<span class="line-modified">!  * The following unit tests assert the presence of write barriers for both Serial and G1 GCs.</span>
<span class="line-modified">!  * Normally, the tests check for compile time inserted barriers. However, there are the cases of</span>
<span class="line-modified">!  * unsafe loads of the java.lang.ref.Reference.referent field where runtime checks have to be</span>
<span class="line-modified">!  * performed also. For those cases, the unit tests check the presence of the compile-time inserted</span>
<span class="line-modified">!  * barriers. Concerning the runtime checks, the results of variable inputs (object types and</span>
<span class="line-modified">!  * offsets) passed as input parameters can be checked against printed output from the G1 write</span>
<span class="line-modified">!  * barrier snippets. The runtime checks have been validated offline.</span>
   */
  public class WriteBarrierAdditionTest extends HotSpotGraalCompilerTest {
  
      private final GraalHotSpotVMConfig config = runtime().getVMConfig();
  
      public static class Container {
  
          public Container a;
          public Container b;
      }
  
      /**
<span class="line-modified">!      * Expected 2 barriers for the Serial GC and 4 for G1 (2 pre + 2 post).</span>
       */
      @Test
<span class="line-modified">!     public void test1() throws Exception {</span>
<span class="line-modified">!         testHelper(&quot;test1Snippet&quot;, (config.useG1GC) ? 4 : 2);</span>
      }
  
<span class="line-modified">!     public static void test1Snippet() {</span>
          Container main = new Container();
          Container temp1 = new Container();
          Container temp2 = new Container();
          main.a = temp1;
          main.b = temp2;
      }
  
      /**
<span class="line-modified">!      * Expected 4 barriers for the Serial GC and 8 for G1 (4 pre + 4 post).</span>
       */
      @Test
<span class="line-modified">!     public void test2() throws Exception {</span>
<span class="line-modified">!         testHelper(&quot;test2Snippet&quot;, config.useG1GC ? 8 : 4);</span>
      }
  
      public static void test2Snippet(boolean test) {
          Container main = new Container();
          Container temp1 = new Container();
<span class="line-new-header">--- 22,121 ---</span>
   */
  
  
  package org.graalvm.compiler.hotspot.test;
  
<span class="line-added">+ import static org.graalvm.compiler.core.common.GraalOptions.FullUnroll;</span>
<span class="line-added">+ import static org.graalvm.compiler.core.common.GraalOptions.LoopPeeling;</span>
<span class="line-added">+ import static org.graalvm.compiler.core.common.GraalOptions.PartialEscapeAnalysis;</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.referentOffset;
  
<span class="line-added">+ import java.lang.ref.Reference;</span>
  import java.lang.ref.WeakReference;
<span class="line-added">+ import java.util.EnumSet;</span>
<span class="line-added">+ import java.util.ListIterator;</span>
<span class="line-added">+ import java.util.Objects;</span>
  
<span class="line-modified">! import org.graalvm.compiler.api.test.Graal;</span>
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<span class="line-modified">! import org.graalvm.compiler.hotspot.HotSpotBackend;</span>
<span class="line-modified">! import org.graalvm.compiler.hotspot.HotSpotGraalRuntime.HotSpotGC;</span>
<span class="line-modified">! import org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil;</span>
<span class="line-modified">! import org.graalvm.compiler.nodeinfo.NodeSize;</span>
  import org.graalvm.compiler.nodes.StructuredGraph;
<span class="line-modified">! import org.graalvm.compiler.nodes.gc.G1PostWriteBarrier;</span>
<span class="line-modified">! import org.graalvm.compiler.nodes.gc.G1PreWriteBarrier;</span>
<span class="line-modified">! import org.graalvm.compiler.nodes.gc.G1ReferentFieldReadBarrier;</span>
<span class="line-modified">! import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.memory.HeapAccess;</span>
  import org.graalvm.compiler.nodes.memory.ReadNode;
  import org.graalvm.compiler.nodes.memory.WriteNode;
  import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-modified">! import org.graalvm.compiler.options.OptionValues;</span>
<span class="line-modified">! import org.graalvm.compiler.phases.BasePhase;</span>
<span class="line-modified">! import org.graalvm.compiler.phases.Phase;</span>
<span class="line-modified">! import org.graalvm.compiler.phases.common.WriteBarrierAdditionPhase;</span>
  import org.graalvm.compiler.phases.tiers.MidTierContext;
<span class="line-modified">! import org.graalvm.compiler.phases.tiers.Suites;</span>
<span class="line-added">+ import org.graalvm.compiler.runtime.RuntimeProvider;</span>
  import org.junit.Assert;
<span class="line-added">+ import org.junit.Before;</span>
  import org.junit.Test;
  
  import jdk.vm.ci.meta.JavaConstant;
<span class="line-modified">! import jdk.vm.ci.meta.MetaAccessProvider;</span>
  
  /**
<span class="line-modified">!  * The following unit tests assert the presence of write barriers for G1 and for the other GCs that</span>
<span class="line-modified">!  * use a simple card mark barrier, like Serial, CMS, ParallelGC and Pthe arNew/ParOld GCs. Normally,</span>
<span class="line-modified">!  * the tests check for compile time inserted barriers. However, there are the cases of unsafe loads</span>
<span class="line-modified">!  * of the java.lang.ref.Reference.referent field where runtime checks have to be performed also. For</span>
<span class="line-modified">!  * those cases, the unit tests check the presence of the compile-time inserted barriers. Concerning</span>
<span class="line-modified">!  * the runtime checks, the results of variable inputs (object types and offsets) passed as input</span>
<span class="line-modified">!  * parameters can be checked against printed output from the G1 write barrier snippets. The runtime</span>
<span class="line-added">+  * checks have been validated offline.</span>
   */
  public class WriteBarrierAdditionTest extends HotSpotGraalCompilerTest {
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * The set of GCs known at the time of writing of this test. The number of expected barrier</span>
<span class="line-added">+      * might need to be adjusted for new GCs implementations.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static EnumSet&lt;HotSpotGC&gt; knownSupport = EnumSet.of(HotSpotGC.G1, HotSpotGC.CMS, HotSpotGC.Parallel, HotSpotGC.Serial);</span>
<span class="line-added">+ </span>
      private final GraalHotSpotVMConfig config = runtime().getVMConfig();
  
      public static class Container {
  
          public Container a;
          public Container b;
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public boolean equals(Object o) {</span>
<span class="line-added">+             if (this == o) {</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (o == null || getClass() != o.getClass()) {</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             Container container = (Container) o;</span>
<span class="line-added">+             return Objects.equals(a, container.a) &amp;&amp; Objects.equals(b, container.b);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public int hashCode() {</span>
<span class="line-added">+             return Objects.hash(a, b);</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-added">+     private int expectedBarriers;</span>
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Expected 2 barriers for the card mark GCs and 4 for G1 (2 pre + 2 post).</span>
       */
      @Test
<span class="line-modified">!     public void testAllocation() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = (config.useG1GC) ? 4 : 2;</span>
<span class="line-added">+         testWithoutPEA(&quot;testAllocationSnippet&quot;);</span>
      }
  
<span class="line-modified">!     public static Container testAllocationSnippet() {</span>
          Container main = new Container();
          Container temp1 = new Container();
          Container temp2 = new Container();
          main.a = temp1;
          main.b = temp2;
<span class="line-added">+         return main;</span>
      }
  
      /**
<span class="line-modified">!      * Expected 4 barriers for the card mark GCs and 8 for G1 (4 pre + 4 post).</span>
       */
      @Test
<span class="line-modified">!     public void testLoopAllocation1() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = config.useG1GC ? 8 : 4;</span>
<span class="line-added">+         testWithoutPEA(&quot;test2Snippet&quot;, false);</span>
<span class="line-added">+         testWithoutPEA(&quot;test2Snippet&quot;, true);</span>
      }
  
      public static void test2Snippet(boolean test) {
          Container main = new Container();
          Container temp1 = new Container();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,15 ***</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * Expected 4 barriers for the Serial GC and 8 for G1 (4 pre + 4 post).</span>
       */
      @Test
<span class="line-modified">!     public void test3() throws Exception {</span>
<span class="line-modified">!         testHelper(&quot;test3Snippet&quot;, config.useG1GC ? 8 : 4);</span>
      }
  
      public static void test3Snippet() {
          Container[] main = new Container[10];
          Container temp1 = new Container();
<span class="line-new-header">--- 151,16 ---</span>
              }
          }
      }
  
      /**
<span class="line-modified">!      * Expected 4 barriers for the card mark GCs and 8 for G1 (4 pre + 4 post).</span>
       */
      @Test
<span class="line-modified">!     public void testLoopAllocation2() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = config.useG1GC ? 8 : 4;</span>
<span class="line-added">+         testWithoutPEA(&quot;test3Snippet&quot;);</span>
      }
  
      public static void test3Snippet() {
          Container[] main = new Container[10];
          Container temp1 = new Container();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,99 ***</span>
              main[i].a = main[i].b = temp2;
          }
      }
  
      /**
<span class="line-modified">!      * Expected 2 barriers for the Serial GC and 5 for G1 (3 pre + 2 post) The (2 or 4) barriers are</span>
<span class="line-modified">!      * emitted while initializing the fields of the WeakReference instance. The extra pre barrier of</span>
<span class="line-modified">!      * G1 concerns the read of the referent field.</span>
       */
      @Test
<span class="line-modified">!     public void test4() throws Exception {</span>
<span class="line-modified">!         testHelper(&quot;test4Snippet&quot;, config.useG1GC ? 5 : 2);</span>
      }
  
<span class="line-modified">!     public static Object test4Snippet() {</span>
<span class="line-modified">!         WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-removed">-         return weakRef.get();</span>
      }
  
<span class="line-modified">!     static WeakReference&lt;Object&gt; wr = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-modified">!     static Container con = new Container();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Expected 4 barriers for the Serial GC and 9 for G1 (1 ref + 4 pre + 4 post). In this test, we</span>
<span class="line-removed">-      * load the correct offset of the WeakReference object so naturally we assert the presence of</span>
<span class="line-removed">-      * the pre barrier.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     @Test</span>
<span class="line-removed">-     public void test5() throws Exception {</span>
<span class="line-removed">-         testHelper(&quot;test5Snippet&quot;, config.useG1GC ? 1 : 0);</span>
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {</span>
<span class="line-removed">-         NodeIntrinsicPluginFactory.InjectionProvider injection = new NodeIntrinsificationProvider(getMetaAccess(), getSnippetReflection(), getProviders().getForeignCalls(), null);</span>
<span class="line-removed">-         new PluginFactory_WriteBarrierAdditionTest().registerPlugins(invocationPlugins, injection);</span>
<span class="line-removed">-         super.registerInvocationPlugins(invocationPlugins);</span>
      }
  
<span class="line-modified">!     @Fold</span>
<span class="line-modified">!     public static boolean useCompressedOops(@Fold.InjectedParameter GraalHotSpotVMConfig config) {</span>
<span class="line-modified">!         return config.useCompressedOops;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     public static Object test5Snippet() throws Exception {</span>
<span class="line-modified">!         return UNSAFE.getObject(wr, useCompressedOops(GraalHotSpotVMConfigBase.INJECTED_VMCONFIG) ? 12L : 16L);</span>
<span class="line-removed">-     }</span>
  
      /**
<span class="line-modified">!      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">!      * load the java.lang.ref.Reference.referent field so the pre barier has to be executed.</span>
       */
      @Test
<span class="line-modified">!     public void test6() throws Exception {</span>
<span class="line-modified">!         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(referentOffset(getMetaAccess())), null);</span>
      }
  
      /**
<span class="line-modified">!      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">!      * load a matching offset of a wrong object so the pre barier must not be executed.</span>
       */
      @Test
<span class="line-modified">!     public void test7() throws Exception {</span>
<span class="line-modified">!         test2(&quot;testUnsafeLoad&quot;, UNSAFE, con, Long.valueOf(referentOffset(getMetaAccess())), null);</span>
      }
  
      /**
<span class="line-modified">!      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">!      * load a non-matching offset field of the java.lang.ref.Reference object so the pre barier must</span>
<span class="line-removed">-      * not be executed.</span>
       */
      @Test
<span class="line-modified">!     public void test8() throws Exception {</span>
<span class="line-modified">!         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 20 : 32), null);</span>
      }
  
      /**
<span class="line-modified">!      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">!      * load a matching offset+disp field of the java.lang.ref.Reference object so the pre barier</span>
<span class="line-modified">!      * must be executed.</span>
       */
      @Test
<span class="line-modified">!     public void test10() throws Exception {</span>
<span class="line-modified">!         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 6 : 8), Integer.valueOf(config.useCompressedOops ? 6 : 8));</span>
      }
  
      /**
<span class="line-modified">!      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">!      * load a non-matching offset+disp field of the java.lang.ref.Reference object so the pre barier</span>
<span class="line-removed">-      * must not be executed.</span>
       */
      @Test
<span class="line-modified">!     public void test9() throws Exception {</span>
<span class="line-modified">!         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 10 : 16), Integer.valueOf(config.useCompressedOops ? 10 : 16));</span>
      }
  
      static Object[] src = new Object[1];
      static Object[] dst = new Object[1];
  
<span class="line-new-header">--- 173,113 ---</span>
              main[i].a = main[i].b = temp2;
          }
      }
  
      /**
<span class="line-modified">!      * Expected 2 barriers for the card mark GCs and 5 for G1 (3 pre + 2 post) The (2 or 4) barriers</span>
<span class="line-modified">!      * are emitted while initializing the fields of the WeakReference instance. The extra pre</span>
<span class="line-modified">!      * barrier of G1 concerns the read of the referent field.</span>
       */
      @Test
<span class="line-modified">!     public void testReferenceGet() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">+         test(&quot;testReferenceGetSnippet&quot;);</span>
      }
  
<span class="line-modified">!     public static Object testReferenceGetSnippet() {</span>
<span class="line-modified">!         return weakReference.get();</span>
      }
  
<span class="line-modified">!     static class DummyReference {</span>
<span class="line-modified">!         Object referent;</span>
      }
  
<span class="line-modified">!     private static MetaAccessProvider getStaticMetaAccess() {</span>
<span class="line-modified">!         return ((HotSpotBackend) Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend()).getRuntime().getHostProviders().getMetaAccess();</span>
      }
  
<span class="line-modified">!     private static final WeakReference&lt;?&gt; weakReference = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-modified">!     private static final Object weakReferenceAsObject = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-modified">!     private static final long referenceReferentFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(Reference.class), &quot;referent&quot;);</span>
<span class="line-modified">!     private static final long referenceQueueFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(Reference.class), &quot;queue&quot;);</span>
  
<span class="line-modified">!     private static final DummyReference dummyReference = new DummyReference();</span>
<span class="line-modified">!     private static final long dummyReferenceReferentFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(DummyReference.class), &quot;referent&quot;);</span>
  
      /**
<span class="line-modified">!      * The type is known to be WeakReference and the offset is a constant, so the</span>
<span class="line-modified">!      * {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is converted back into a normal</span>
<span class="line-added">+      * LoadFieldNode and the lowering of the field node inserts the proper barrier.</span>
       */
      @Test
<span class="line-modified">!     public void testReferenceReferent1() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">+         test(&quot;testReferenceReferentSnippet&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public Object testReferenceReferentSnippet() {</span>
<span class="line-added">+         return UNSAFE.getObject(weakReference, referenceReferentFieldOffset);</span>
      }
  
      /**
<span class="line-modified">!      * The type is known to be WeakReference and the offset is non-constant, so the lowering of the</span>
<span class="line-modified">!      * {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is guarded by a check that the offset</span>
<span class="line-added">+      * is the same as {@link #referenceReferentFieldOffset} which does a barrier if requires it.</span>
       */
      @Test
<span class="line-modified">!     public void testReferenceReferent2() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">+         test(&quot;testReferenceReferent2Snippet&quot;, referenceReferentFieldOffset);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public Object testReferenceReferent2Snippet(long offset) {</span>
<span class="line-added">+         return UNSAFE.getObject(weakReference, offset);</span>
      }
  
      /**
<span class="line-modified">!      * The type is known to be WeakReference and the offset is constant but not the referent field,</span>
<span class="line-modified">!      * so no barrier is required.</span>
       */
      @Test
<span class="line-modified">!     public void testReferenceReferent3() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = 0;</span>
<span class="line-added">+         test(&quot;testReferenceReferent3Snippet&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public Object testReferenceReferent3Snippet() {</span>
<span class="line-added">+         return UNSAFE.getObject(weakReference, referenceQueueFieldOffset);</span>
      }
  
      /**
<span class="line-modified">!      * The type is a super class of WeakReference and the offset is non-constant, so the lowering of</span>
<span class="line-modified">!      * the {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is guarded by a check that the</span>
<span class="line-modified">!      * offset is the same as {@link #referenceReferentFieldOffset} and the base object is a</span>
<span class="line-added">+      * subclasses of {@link java.lang.ref.Reference} and does a barrier if requires it.</span>
       */
      @Test
<span class="line-modified">!     public void testReferenceReferent4() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">+         test(&quot;testReferenceReferent4Snippet&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public Object testReferenceReferent4Snippet() {</span>
<span class="line-added">+         return UNSAFE.getObject(weakReferenceAsObject, referenceReferentFieldOffset);</span>
      }
  
      /**
<span class="line-modified">!      * The type is not related to Reference at all so no barrier check is required. This should be</span>
<span class="line-modified">!      * statically detectable.</span>
       */
      @Test
<span class="line-modified">!     public void testReferenceReferent5() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = 0;</span>
<span class="line-added">+         Assert.assertEquals(&quot;expected fields to have the same offset&quot;, referenceReferentFieldOffset, dummyReferenceReferentFieldOffset);</span>
<span class="line-added">+         test(&quot;testReferenceReferent5Snippet&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public Object testReferenceReferent5Snippet() {</span>
<span class="line-added">+         return UNSAFE.getObject(dummyReference, referenceReferentFieldOffset);</span>
      }
  
      static Object[] src = new Object[1];
      static Object[] dst = new Object[1];
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,89 ***</span>
          for (int i = 0; i &lt; dst.length; i++) {
              dst[i] = new Object();
          }
      }
  
<span class="line-modified">!     public static void testArrayCopy(Object a, Object b, Object c) throws Exception {</span>
          System.arraycopy(a, 0, b, 0, (int) c);
      }
  
      @Test
<span class="line-modified">!     public void test11() throws Exception {</span>
<span class="line-modified">!         test2(&quot;testArrayCopy&quot;, src, dst, dst.length);</span>
      }
  
<span class="line-modified">!     public static Object testUnsafeLoad(Unsafe theUnsafe, Object a, Object b, Object c) throws Exception {</span>
<span class="line-modified">!         final int offset = (c == null ? 0 : ((Integer) c).intValue());</span>
<span class="line-modified">!         final long displacement = (b == null ? 0 : ((Long) b).longValue());</span>
<span class="line-modified">!         return theUnsafe.getObject(a, offset + displacement);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private HotSpotInstalledCode getInstalledCode(String name, boolean withUnsafePrefix) throws Exception {</span>
<span class="line-modified">!         final ResolvedJavaMethod javaMethod = withUnsafePrefix ? getResolvedJavaMethod(WriteBarrierAdditionTest.class, name, Unsafe.class, Object.class, Object.class, Object.class)</span>
<span class="line-modified">!                         : getResolvedJavaMethod(WriteBarrierAdditionTest.class, name, Object.class, Object.class, Object.class);</span>
<span class="line-modified">!         final HotSpotInstalledCode installedCode = (HotSpotInstalledCode) getCode(javaMethod);</span>
<span class="line-modified">!         return installedCode;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-removed">-     private void testHelper(final String snippetName, final int expectedBarriers) throws Exception, SecurityException {</span>
<span class="line-removed">-         ResolvedJavaMethod snippet = getResolvedJavaMethod(snippetName);</span>
<span class="line-removed">-         DebugContext debug = getDebugContext();</span>
<span class="line-removed">-         try (DebugContext.Scope s = debug.scope(&quot;WriteBarrierAdditionTest&quot;, snippet)) {</span>
<span class="line-removed">-             StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO, debug);</span>
<span class="line-removed">-             HighTierContext highContext = getDefaultHighTierContext();</span>
<span class="line-removed">-             MidTierContext midContext = new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, graph.getProfilingInfo());</span>
<span class="line-removed">-             new InliningPhase(new InlineEverythingPolicy(), new CanonicalizerPhase()).apply(graph, highContext);</span>
<span class="line-removed">-             new CanonicalizerPhase().apply(graph, highContext);</span>
<span class="line-removed">-             new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, highContext);</span>
<span class="line-removed">-             new GuardLoweringPhase().apply(graph, midContext);</span>
<span class="line-removed">-             new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.MID_TIER).apply(graph, midContext);</span>
<span class="line-removed">-             new WriteBarrierAdditionPhase(config).apply(graph);</span>
<span class="line-removed">-             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;After Write Barrier Addition&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             int barriers = 0;</span>
              if (config.useG1GC) {
<span class="line-modified">!                 barriers = graph.getNodes().filter(G1ReferentFieldReadBarrier.class).count() + graph.getNodes().filter(G1PreWriteBarrier.class).count() +</span>
<span class="line-modified">!                                 graph.getNodes().filter(G1PostWriteBarrier.class).count();</span>
              } else {
<span class="line-modified">!                 barriers = graph.getNodes().filter(SerialWriteBarrier.class).count();</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if (expectedBarriers != barriers) {</span>
<span class="line-removed">-                 Assert.assertEquals(getScheduledGraphString(graph), expectedBarriers, barriers);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             for (WriteNode write : graph.getNodes().filter(WriteNode.class)) {</span>
<span class="line-removed">-                 if (config.useG1GC) {</span>
<span class="line-removed">-                     if (write.getBarrierType() != BarrierType.NONE) {</span>
<span class="line-removed">-                         Assert.assertEquals(1, write.successors().count());</span>
<span class="line-removed">-                         Assert.assertTrue(write.next() instanceof G1PostWriteBarrier);</span>
<span class="line-removed">-                         Assert.assertTrue(write.predecessor() instanceof G1PreWriteBarrier);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     if (write.getBarrierType() != BarrierType.NONE) {</span>
<span class="line-removed">-                         Assert.assertEquals(1, write.successors().count());</span>
<span class="line-removed">-                         Assert.assertTrue(write.next() instanceof SerialWriteBarrier);</span>
<span class="line-removed">-                     }</span>
                  }
              }
  
<span class="line-modified">!             for (ReadNode read : graph.getNodes().filter(ReadNode.class)) {</span>
<span class="line-modified">!                 if (read.getBarrierType() != BarrierType.NONE) {</span>
<span class="line-modified">!                     Assert.assertTrue(read.getAddress() instanceof OffsetAddressNode);</span>
                      JavaConstant constDisp = ((OffsetAddressNode) read.getAddress()).getOffset().asJavaConstant();
<span class="line-modified">!                     Assert.assertNotNull(constDisp);</span>
<span class="line-modified">!                     Assert.assertEquals(referentOffset(getMetaAccess()), constDisp.asLong());</span>
<span class="line-modified">!                     Assert.assertTrue(config.useG1GC);</span>
<span class="line-modified">!                     Assert.assertEquals(BarrierType.PRECISE, read.getBarrierType());</span>
                      Assert.assertTrue(read.next() instanceof G1ReferentFieldReadBarrier);
                  }
              }
<span class="line-removed">-         } catch (Throwable e) {</span>
<span class="line-removed">-             throw debug.handle(e);</span>
          }
      }
  
<span class="line-modified">!     private void test2(final String snippet, Object... args) throws Exception {</span>
<span class="line-modified">!         HotSpotInstalledCode code = getInstalledCode(snippet, args[0] instanceof Unsafe);</span>
<span class="line-modified">!         code.executeVarargs(args);</span>
      }
  }
<span class="line-new-header">--- 290,95 ---</span>
          for (int i = 0; i &lt; dst.length; i++) {
              dst[i] = new Object();
          }
      }
  
<span class="line-modified">!     public static void testArrayCopySnippet(Object a, Object b, Object c) throws Exception {</span>
          System.arraycopy(a, 0, b, 0, (int) c);
      }
  
      @Test
<span class="line-modified">!     public void testArrayCopy() throws Exception {</span>
<span class="line-modified">!         this.expectedBarriers = 0;</span>
<span class="line-added">+         test(&quot;testArrayCopySnippet&quot;, src, dst, dst.length);</span>
      }
  
<span class="line-modified">!     private void verifyBarriers(StructuredGraph graph) {</span>
<span class="line-modified">!         Assert.assertTrue(&quot;Unknown collector selected&quot;, knownSupport.contains(runtime().getGarbageCollector()));</span>
<span class="line-modified">!         Assert.assertNotEquals(&quot;test must set expected barrier count&quot;, expectedBarriers, -1);</span>
<span class="line-modified">!         int barriers = 0;</span>
<span class="line-modified">!         if (config.useG1GC) {</span>
<span class="line-modified">!             barriers = graph.getNodes().filter(G1ReferentFieldReadBarrier.class).count() + graph.getNodes().filter(G1PreWriteBarrier.class).count() +</span>
<span class="line-modified">!                             graph.getNodes().filter(G1PostWriteBarrier.class).count();</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             barriers = graph.getNodes().filter(SerialWriteBarrier.class).count();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (expectedBarriers != barriers) {</span>
<span class="line-modified">!             Assert.assertEquals(expectedBarriers, barriers);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         for (WriteNode write : graph.getNodes().filter(WriteNode.class)) {</span>
              if (config.useG1GC) {
<span class="line-modified">!                 if (write.getBarrierType() != HeapAccess.BarrierType.NONE) {</span>
<span class="line-modified">!                     Assert.assertEquals(1, write.successors().count());</span>
<span class="line-added">+                     Assert.assertTrue(write.next() instanceof G1PostWriteBarrier);</span>
<span class="line-added">+                     Assert.assertTrue(write.predecessor() instanceof G1PreWriteBarrier || write.getLocationIdentity().isImmutable());</span>
<span class="line-added">+                 }</span>
              } else {
<span class="line-modified">!                 if (write.getBarrierType() != HeapAccess.BarrierType.NONE) {</span>
<span class="line-modified">!                     Assert.assertEquals(1, write.successors().count());</span>
<span class="line-modified">!                     Assert.assertTrue(write.next() instanceof SerialWriteBarrier);</span>
                  }
              }
<span class="line-added">+         }</span>
  
<span class="line-modified">!         for (ReadNode read : graph.getNodes().filter(ReadNode.class)) {</span>
<span class="line-modified">!             if (read.getBarrierType() != HeapAccess.BarrierType.NONE) {</span>
<span class="line-modified">!                 if (read.getAddress() instanceof OffsetAddressNode) {</span>
                      JavaConstant constDisp = ((OffsetAddressNode) read.getAddress()).getOffset().asJavaConstant();
<span class="line-modified">!                     if (constDisp != null) {</span>
<span class="line-modified">!                         Assert.assertEquals(referentOffset(getMetaAccess()), constDisp.asLong());</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-added">+                 Assert.assertTrue(HeapAccess.BarrierType.WEAK_FIELD == read.getBarrierType() || HeapAccess.BarrierType.MAYBE_WEAK_FIELD == read.getBarrierType());</span>
<span class="line-added">+                 if (config.useG1GC) {</span>
                      Assert.assertTrue(read.next() instanceof G1ReferentFieldReadBarrier);
                  }
              }
          }
      }
  
<span class="line-modified">!     protected Result testWithoutPEA(String name, Object... args) {</span>
<span class="line-modified">!         return test(new OptionValues(getInitialOptions(), PartialEscapeAnalysis, false, FullUnroll, false, LoopPeeling, false), name, args);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Before</span>
<span class="line-added">+     public void before() {</span>
<span class="line-added">+         expectedBarriers = -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * Check the state of the barriers immediately after insertion.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected Suites createSuites(OptionValues opts) {</span>
<span class="line-added">+         Suites ret = getBackend().getSuites().getDefaultSuites(opts).copy();</span>
<span class="line-added">+         ListIterator&lt;BasePhase&lt;? super MidTierContext&gt;&gt; iter = ret.getMidTier().findPhase(WriteBarrierAdditionPhase.class, true);</span>
<span class="line-added">+         iter.add(new Phase() {</span>
<span class="line-added">+ </span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             protected void run(StructuredGraph graph) {</span>
<span class="line-added">+                 verifyBarriers(graph);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public float codeSizeIncrease() {</span>
<span class="line-added">+                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             protected CharSequence getName() {</span>
<span class="line-added">+                 return &quot;VerifyBarriersPhase&quot;;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return ret;</span>
      }
  }
</pre>
<center><a href="TestSHASubstitutions.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/BootstrapWatchDog.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
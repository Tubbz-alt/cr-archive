<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot.test;
  26 
  27 import static java.util.Collections.singletonList;
  28 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Print;
<a name="2" id="anc2"></a><span class="line-modified">  29 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAsFailure;</span>
  30 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
  31 import static org.graalvm.compiler.core.test.ReflectionOptionDescriptors.extractEntries;
  32 import static org.graalvm.compiler.debug.MemUseTrackerKey.getCurrentThreadAllocatedBytes;
<a name="3" id="anc3"></a><span class="line-added">  33 import static org.graalvm.compiler.hotspot.CompilationTask.CompilationTime;</span>
<span class="line-added">  34 import static org.graalvm.compiler.hotspot.CompilationTask.CompiledAndInstalledBytecodes;</span>
  35 import static org.graalvm.compiler.hotspot.test.CompileTheWorld.Options.DESCRIPTORS;
<a name="4" id="anc4"></a><span class="line-modified">  36 import static org.graalvm.compiler.hotspot.test.CompileTheWorld.Options.InvalidateInstalledCode;</span>
<span class="line-added">  37 import static sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;</span>
  38 
<a name="5" id="anc5"></a><span class="line-added">  39 import java.io.ByteArrayOutputStream;</span>
  40 import java.io.Closeable;
  41 import java.io.File;
  42 import java.io.IOException;
  43 import java.lang.annotation.Annotation;
  44 import java.lang.reflect.Constructor;
  45 import java.lang.reflect.Method;
  46 import java.lang.reflect.Modifier;
  47 import java.net.URI;
  48 import java.net.URL;
  49 import java.net.URLClassLoader;
  50 import java.nio.file.FileSystem;
  51 import java.nio.file.FileSystems;
  52 import java.nio.file.FileVisitResult;
  53 import java.nio.file.Files;
  54 import java.nio.file.Path;
  55 import java.nio.file.SimpleFileVisitor;
  56 import java.nio.file.attribute.BasicFileAttributes;
  57 import java.util.ArrayList;
  58 import java.util.Arrays;
  59 import java.util.Collections;
  60 import java.util.Enumeration;
  61 import java.util.HashMap;
  62 import java.util.HashSet;
  63 import java.util.List;
  64 import java.util.Map;
  65 import java.util.ServiceLoader;
  66 import java.util.Set;
  67 import java.util.concurrent.ExecutionException;
  68 import java.util.concurrent.Future;
  69 import java.util.concurrent.LinkedBlockingQueue;
  70 import java.util.concurrent.ThreadPoolExecutor;
  71 import java.util.concurrent.TimeUnit;
  72 import java.util.concurrent.atomic.AtomicLong;
  73 import java.util.jar.JarEntry;
  74 import java.util.jar.JarFile;
  75 import java.util.regex.Matcher;
  76 import java.util.regex.Pattern;
  77 import java.util.stream.Collectors;
  78 
  79 import jdk.internal.vm.compiler.collections.EconomicMap;
<a name="6" id="anc6"></a><span class="line-modified">  80 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;</span>
  81 import org.graalvm.compiler.api.replacements.Snippet;
  82 import org.graalvm.compiler.bytecode.Bytecodes;
  83 import org.graalvm.compiler.core.CompilerThreadFactory;
<a name="7" id="anc7"></a><span class="line-added">  84 import org.graalvm.compiler.core.phases.HighTier;</span>
  85 import org.graalvm.compiler.core.test.ReflectionOptionDescriptors;
  86 import org.graalvm.compiler.debug.DebugOptions;
<a name="8" id="anc8"></a><span class="line-added">  87 import org.graalvm.compiler.debug.GlobalMetrics;</span>
  88 import org.graalvm.compiler.debug.GraalError;
  89 import org.graalvm.compiler.debug.MethodFilter;
<a name="9" id="anc9"></a><span class="line-added">  90 import org.graalvm.compiler.debug.MetricKey;</span>
  91 import org.graalvm.compiler.debug.TTY;
  92 import org.graalvm.compiler.hotspot.CompilationTask;
  93 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  94 import org.graalvm.compiler.hotspot.HotSpotGraalCompiler;
<a name="10" id="anc10"></a><span class="line-added">  95 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime;</span>
  96 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
<a name="11" id="anc11"></a><span class="line-added">  97 import org.graalvm.compiler.hotspot.test.CompileTheWorld.LibGraalParams.StackTraceBuffer;</span>
  98 import org.graalvm.compiler.options.OptionDescriptors;
  99 import org.graalvm.compiler.options.OptionKey;
 100 import org.graalvm.compiler.options.OptionValues;
 101 import org.graalvm.compiler.options.OptionsParser;
<a name="12" id="anc12"></a><span class="line-added"> 102 import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;</span>
 103 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
<a name="13" id="anc13"></a><span class="line-added"> 104 import org.graalvm.compiler.api.test.ModuleSupport;</span>
<span class="line-added"> 105 import jdk.internal.vm.compiler.libgraal.LibGraal;</span>
<span class="line-added"> 106 import jdk.internal.vm.compiler.libgraal.LibGraalScope;</span>
<span class="line-added"> 107 import org.graalvm.util.OptionsEncoder;</span>
 108 
 109 import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;
 110 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 111 import jdk.vm.ci.hotspot.HotSpotInstalledCode;
 112 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 113 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 114 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 115 import jdk.vm.ci.meta.ConstantPool;
 116 import jdk.vm.ci.meta.MetaAccessProvider;
 117 import jdk.vm.ci.runtime.JVMCI;
 118 import jdk.vm.ci.runtime.JVMCICompiler;
<a name="14" id="anc14"></a><span class="line-added"> 119 import sun.misc.Unsafe;</span>
 120 
 121 /**
 122  * This class implements compile-the-world functionality with JVMCI.
 123  */
 124 public final class CompileTheWorld {
 125 
<a name="15" id="anc15"></a><span class="line-added"> 126     static {</span>
<span class="line-added"> 127         ModuleSupport.exportAndOpenAllPackagesToUnnamed(&quot;jdk.internal.vm.compiler&quot;);</span>
<span class="line-added"> 128     }</span>
<span class="line-added"> 129 </span>
 130     /**
<a name="16" id="anc16"></a><span class="line-modified"> 131      * Magic token to denote that JDK classes are to be compiled. For JDK 8, the classes in</span>
<span class="line-modified"> 132      * {@code rt.jar} are compiled. Otherwise the classes in the Java runtime image are compiled.</span>

 133      */
 134     public static final String SUN_BOOT_CLASS_PATH = &quot;sun.boot.class.path&quot;;
 135 
 136     /**
 137      * Magic token to denote the classes in the Java runtime image (i.e. in the {@code jrt:/} file
 138      * system).
 139      */
 140     public static final String JRT_CLASS_PATH_ENTRY = &quot;&lt;jrt&gt;&quot;;
 141 
 142     /**
 143      * @param options a space separated set of option value settings with each option setting in a
 144      *            {@code -Dgraal.&lt;name&gt;=&lt;value&gt;} format but without the leading {@code -Dgraal.}.
 145      *            Ignored if null.
 146      */
 147     public static EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; parseOptions(String options) {
<a name="17" id="anc17"></a><span class="line-added"> 148         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; values = OptionValues.newOptionMap();</span>
 149         if (options != null) {
 150             EconomicMap&lt;String, String&gt; optionSettings = EconomicMap.create();
 151             for (String optionSetting : options.split(&quot;\\s+|#&quot;)) {
 152                 OptionsParser.parseOptionSettingTo(optionSetting, optionSettings);
 153             }
<a name="18" id="anc18"></a>
 154             ServiceLoader&lt;OptionDescriptors&gt; loader = ServiceLoader.load(OptionDescriptors.class, OptionDescriptors.class.getClassLoader());
 155             OptionsParser.parseOptions(optionSettings, values, loader);
<a name="19" id="anc19"></a>
 156         }
<a name="20" id="anc20"></a><span class="line-modified"> 157         if (!values.containsKey(HighTier.Options.Inline)) {</span>
<span class="line-added"> 158             values.put(HighTier.Options.Inline, false);</span>
<span class="line-added"> 159         }</span>
<span class="line-added"> 160         return values;</span>
 161     }
 162 
 163     private final HotSpotJVMCIRuntime jvmciRuntime;
 164 
 165     private final HotSpotGraalCompiler compiler;
 166 
 167     /**
 168      * Class path denoting classes to compile.
 169      *
 170      * @see Options#Classpath
 171      */
 172     private final String inputClassPath;
 173 
 174     /**
 175      * Class index to start compilation at.
 176      *
 177      * @see Options#StartAt
 178      */
 179     private final int startAt;
 180 
 181     /**
 182      * Class index to stop compilation at.
 183      *
 184      * @see Options#StopAt
 185      */
 186     private final int stopAt;
 187 
<a name="21" id="anc21"></a><span class="line-added"> 188     /**</span>
<span class="line-added"> 189      * Max classes to compile.</span>
<span class="line-added"> 190      *</span>
<span class="line-added"> 191      * @see Options#MaxClasses</span>
<span class="line-added"> 192      */</span>
<span class="line-added"> 193     private final int maxClasses;</span>
<span class="line-added"> 194 </span>
 195     /** Only compile methods matching one of the filters in this array if the array is non-null. */
 196     private final MethodFilter[] methodFilters;
 197 
 198     /** Exclude methods matching one of the filters in this array if the array is non-null. */
 199     private final MethodFilter[] excludeMethodFilters;
 200 
 201     // Counters
 202     private int classFileCounter = 0;
 203     private AtomicLong compiledMethodsCounter = new AtomicLong();
 204     private AtomicLong compileTime = new AtomicLong();
 205     private AtomicLong memoryUsed = new AtomicLong();
 206 
 207     private boolean verbose;
 208 
 209     /**
 210      * Signal that the threads should start compiling in multithreaded mode.
 211      */
 212     private boolean running;
 213 
 214     private ThreadPoolExecutor threadPool;
 215 
<a name="22" id="anc22"></a><span class="line-modified"> 216     /**</span>
<span class="line-modified"> 217      * Values for {@link CompileTheWorld.Options}.</span>
<span class="line-added"> 218      */</span>
<span class="line-added"> 219     private final OptionValues harnessOptions;</span>
<span class="line-added"> 220 </span>
<span class="line-added"> 221     /**</span>
<span class="line-added"> 222      * Option values used during compilation.</span>
<span class="line-added"> 223      */</span>
<span class="line-added"> 224     private final OptionValues compilerOptions;</span>
<span class="line-added"> 225 </span>
<span class="line-added"> 226     /**</span>
<span class="line-added"> 227      * Manages native memory buffers for passing arguments into libgraal and receiving return</span>
<span class="line-added"> 228      * values. The native memory buffers are freed when this object is {@linkplain #close() closed}.</span>
<span class="line-added"> 229      */</span>
<span class="line-added"> 230     static class LibGraalParams implements AutoCloseable {</span>
<span class="line-added"> 231 </span>
<span class="line-added"> 232         static {</span>
<span class="line-added"> 233             LibGraal.registerNativeMethods(HotSpotJVMCIRuntime.runtime(), CompileTheWorld.class);</span>
<span class="line-added"> 234         }</span>
<span class="line-added"> 235 </span>
<span class="line-added"> 236         /**</span>
<span class="line-added"> 237          * Native memory containing {@linkplain OptionsEncoder encoded} {@link OptionValues}.</span>
<span class="line-added"> 238          */</span>
<span class="line-added"> 239         static class OptionsBuffer {</span>
<span class="line-added"> 240             private long address;</span>
<span class="line-added"> 241             final int size;</span>
<span class="line-added"> 242             final int hash;</span>
<span class="line-added"> 243 </span>
<span class="line-added"> 244             OptionsBuffer(OptionValues options) {</span>
<span class="line-added"> 245                 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span>
<span class="line-added"> 246                 UnmodifiableMapCursor&lt;OptionKey&lt;?&gt;, Object&gt; cursor = options.getMap().getEntries();</span>
<span class="line-added"> 247                 while (cursor.advance()) {</span>
<span class="line-added"> 248                     final OptionKey&lt;?&gt; key = cursor.getKey();</span>
<span class="line-added"> 249                     Object value = cursor.getValue();</span>
<span class="line-added"> 250                     map.put(key.getName(), value);</span>
<span class="line-added"> 251                 }</span>
<span class="line-added"> 252 </span>
<span class="line-added"> 253                 byte[] encoded = OptionsEncoder.encode(map);</span>
<span class="line-added"> 254                 size = encoded.length;</span>
<span class="line-added"> 255                 hash = Arrays.hashCode(encoded);</span>
<span class="line-added"> 256                 address = UNSAFE.allocateMemory(encoded.length);</span>
<span class="line-added"> 257                 UNSAFE.copyMemory(encoded, ARRAY_BYTE_BASE_OFFSET, null, address, size);</span>
<span class="line-added"> 258             }</span>
<span class="line-added"> 259 </span>
<span class="line-added"> 260             long getAddress() {</span>
<span class="line-added"> 261                 if (address == 0) {</span>
<span class="line-added"> 262                     throw new IllegalStateException();</span>
<span class="line-added"> 263                 }</span>
<span class="line-added"> 264                 return address;</span>
<span class="line-added"> 265             }</span>
<span class="line-added"> 266 </span>
<span class="line-added"> 267             void free() {</span>
<span class="line-added"> 268                 if (address != 0) {</span>
<span class="line-added"> 269                     UNSAFE.freeMemory(address);</span>
<span class="line-added"> 270                     address = 0;</span>
<span class="line-added"> 271                 }</span>
<span class="line-added"> 272             }</span>
<span class="line-added"> 273         }</span>
<span class="line-added"> 274 </span>
<span class="line-added"> 275         /**</span>
<span class="line-added"> 276          * Manages native memory for receiving a {@linkplain Throwable#printStackTrace() stack</span>
<span class="line-added"> 277          * trace} from libgraal serialized via {@link ByteArrayOutputStream} to a byte array.</span>
<span class="line-added"> 278          */</span>
<span class="line-added"> 279         static class StackTraceBuffer {</span>
<span class="line-added"> 280             final int size;</span>
<span class="line-added"> 281             private long address;</span>
<span class="line-added"> 282 </span>
<span class="line-added"> 283             StackTraceBuffer(int size) {</span>
<span class="line-added"> 284                 this.size = size;</span>
<span class="line-added"> 285                 address = UNSAFE.allocateMemory(size);</span>
<span class="line-added"> 286             }</span>
<span class="line-added"> 287 </span>
<span class="line-added"> 288             void free() {</span>
<span class="line-added"> 289                 if (address != 0L) {</span>
<span class="line-added"> 290                     UNSAFE.freeMemory(address);</span>
<span class="line-added"> 291                     address = 0L;</span>
<span class="line-added"> 292                 }</span>
<span class="line-added"> 293             }</span>
<span class="line-added"> 294 </span>
<span class="line-added"> 295             long getAddress() {</span>
<span class="line-added"> 296                 if (address == 0) {</span>
<span class="line-added"> 297                     throw new IllegalStateException();</span>
<span class="line-added"> 298                 }</span>
<span class="line-added"> 299                 return address;</span>
<span class="line-added"> 300             }</span>
<span class="line-added"> 301         }</span>
<span class="line-added"> 302 </span>
<span class="line-added"> 303         final OptionsBuffer options;</span>
<span class="line-added"> 304 </span>
<span class="line-added"> 305         private final List&lt;StackTraceBuffer&gt; stackTraceBuffers = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 306 </span>
<span class="line-added"> 307         /**</span>
<span class="line-added"> 308          * Gets a stack trace buffer for the current thread.</span>
<span class="line-added"> 309          */</span>
<span class="line-added"> 310         StackTraceBuffer getStackTraceBuffer() {</span>
<span class="line-added"> 311             return stackTraceBuffer.get();</span>
<span class="line-added"> 312         }</span>
<span class="line-added"> 313 </span>
<span class="line-added"> 314         private final ThreadLocal&lt;StackTraceBuffer&gt; stackTraceBuffer = new ThreadLocal&lt;StackTraceBuffer&gt;() {</span>
<span class="line-added"> 315             @Override</span>
<span class="line-added"> 316             protected StackTraceBuffer initialValue() {</span>
<span class="line-added"> 317                 StackTraceBuffer buffer = new StackTraceBuffer(10_000);</span>
<span class="line-added"> 318                 synchronized (stackTraceBuffers) {</span>
<span class="line-added"> 319                     stackTraceBuffers.add(buffer);</span>
<span class="line-added"> 320                 }</span>
<span class="line-added"> 321                 return buffer;</span>
<span class="line-added"> 322             }</span>
<span class="line-added"> 323         };</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325         LibGraalParams(OptionValues options) {</span>
<span class="line-added"> 326             this.options = new OptionsBuffer(options);</span>
<span class="line-added"> 327         }</span>
<span class="line-added"> 328 </span>
<span class="line-added"> 329         @Override</span>
<span class="line-added"> 330         public void close() {</span>
<span class="line-added"> 331             options.free();</span>
<span class="line-added"> 332             synchronized (stackTraceBuffers) {</span>
<span class="line-added"> 333                 for (StackTraceBuffer buffer : stackTraceBuffers) {</span>
<span class="line-added"> 334                     buffer.free();</span>
<span class="line-added"> 335                 }</span>
<span class="line-added"> 336                 stackTraceBuffers.clear();</span>
<span class="line-added"> 337             }</span>
<span class="line-added"> 338         }</span>
<span class="line-added"> 339     }</span>
 340 
 341     /**
 342      * Creates a compile-the-world instance.
 343      *
 344      * @param files {@link File#pathSeparator} separated list of Zip/Jar files to compile
 345      * @param startAt index of the class file to start compilation at
 346      * @param stopAt index of the class file to stop compilation at
<a name="23" id="anc23"></a><span class="line-added"> 347      * @param maxClasses maximum number of classes to process</span>
 348      * @param methodFilters
 349      * @param excludeMethodFilters
<a name="24" id="anc24"></a><span class="line-added"> 350      * @param harnessOptions values for {@link CompileTheWorld.Options}</span>
<span class="line-added"> 351      * @param compilerOptions option values used by the compiler</span>
 352      */
<a name="25" id="anc25"></a><span class="line-modified"> 353     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,</span>
<span class="line-modified"> 354                     HotSpotGraalCompiler compiler,</span>
<span class="line-added"> 355                     String files,</span>
<span class="line-added"> 356                     int startAt,</span>
<span class="line-added"> 357                     int stopAt,</span>
<span class="line-added"> 358                     int maxClasses,</span>
<span class="line-added"> 359                     String methodFilters,</span>
<span class="line-added"> 360                     String excludeMethodFilters,</span>
<span class="line-added"> 361                     boolean verbose,</span>
<span class="line-added"> 362                     OptionValues harnessOptions,</span>
<span class="line-added"> 363                     OptionValues compilerOptions) {</span>
 364         this.jvmciRuntime = jvmciRuntime;
 365         this.compiler = compiler;
 366         this.inputClassPath = files;
<a name="26" id="anc26"></a><span class="line-modified"> 367         this.startAt = Math.max(startAt, 1);</span>
<span class="line-modified"> 368         this.stopAt = Math.max(stopAt, 1);</span>
<span class="line-added"> 369         this.maxClasses = Math.max(maxClasses, 1);</span>
 370         this.methodFilters = methodFilters == null || methodFilters.isEmpty() ? null : MethodFilter.parse(methodFilters);
 371         this.excludeMethodFilters = excludeMethodFilters == null || excludeMethodFilters.isEmpty() ? null : MethodFilter.parse(excludeMethodFilters);
 372         this.verbose = verbose;
<a name="27" id="anc27"></a><span class="line-modified"> 373         this.harnessOptions = harnessOptions;</span>
 374 
 375         // Copy the initial options and add in any extra options
<a name="28" id="anc28"></a><span class="line-modified"> 376         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; compilerOptionsMap = EconomicMap.create(compilerOptions.getMap());</span>

 377 
 378         // We want to see stack traces when a method fails to compile
<a name="29" id="anc29"></a><span class="line-modified"> 379         CompilationBailoutAsFailure.putIfAbsent(compilerOptionsMap, true);</span>
<span class="line-modified"> 380         CompilationFailureAction.putIfAbsent(compilerOptionsMap, Print);</span>
 381 
 382         // By default only report statistics for the CTW threads themselves
<a name="30" id="anc30"></a><span class="line-modified"> 383         DebugOptions.MetricsThreadFilter.putIfAbsent(compilerOptionsMap, &quot;^CompileTheWorld&quot;);</span>
<span class="line-modified"> 384         this.compilerOptions = new OptionValues(compilerOptionsMap);</span>
 385     }
 386 
<a name="31" id="anc31"></a><span class="line-modified"> 387     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,</span>
<span class="line-modified"> 388                     HotSpotGraalCompiler compiler,</span>
<span class="line-modified"> 389                     OptionValues harnessOptions,</span>
<span class="line-modified"> 390                     OptionValues compilerOptions) {</span>
<span class="line-modified"> 391         this(jvmciRuntime, compiler, Options.Classpath.getValue(harnessOptions),</span>
<span class="line-modified"> 392                         Options.StartAt.getValue(harnessOptions),</span>
<span class="line-modified"> 393                         Options.StopAt.getValue(harnessOptions),</span>
<span class="line-modified"> 394                         Options.MaxClasses.getValue(harnessOptions),</span>
<span class="line-modified"> 395                         Options.MethodFilter.getValue(harnessOptions),</span>
<span class="line-added"> 396                         Options.ExcludeMethodFilter.getValue(harnessOptions),</span>
<span class="line-added"> 397                         Options.Verbose.hasBeenSet(harnessOptions) ? Options.Verbose.getValue(harnessOptions) : !Options.MultiThreaded.getValue(harnessOptions),</span>
<span class="line-added"> 398                         harnessOptions,</span>
<span class="line-added"> 399                         new OptionValues(compilerOptions, parseOptions(Options.Config.getValue(harnessOptions))));</span>
 400     }
 401 
 402     /**
 403      * Compiles all methods in all classes in {@link #inputClassPath}. If {@link #inputClassPath}
 404      * equals {@link #SUN_BOOT_CLASS_PATH} the boot classes are used.
 405      */
<a name="32" id="anc32"></a><span class="line-added"> 406     @SuppressWarnings(&quot;try&quot;)</span>
 407     public void compile() throws Throwable {
<a name="33" id="anc33"></a><span class="line-modified"> 408         try (LibGraalParams libgraal = LibGraal.isAvailable() ? new LibGraalParams(compilerOptions) : null) {</span>
<span class="line-modified"> 409             if (SUN_BOOT_CLASS_PATH.equals(inputClassPath)) {</span>
<span class="line-modified"> 410                 String bcpEntry = null;</span>
<span class="line-modified"> 411                 if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-modified"> 412                     final String[] entries = System.getProperty(SUN_BOOT_CLASS_PATH).split(File.pathSeparator);</span>
<span class="line-modified"> 413                     for (int i = 0; i &lt; entries.length &amp;&amp; bcpEntry == null; i++) {</span>
<span class="line-modified"> 414                         String entry = entries[i];</span>
<span class="line-modified"> 415                         File entryFile = new File(entry);</span>
<span class="line-modified"> 416                         if (entryFile.getName().endsWith(&quot;rt.jar&quot;) &amp;&amp; entryFile.isFile()) {</span>
<span class="line-added"> 417                             bcpEntry = entry;</span>
<span class="line-added"> 418                         }</span>
 419                     }
<a name="34" id="anc34"></a><span class="line-added"> 420                     if (bcpEntry == null) {</span>
<span class="line-added"> 421                         throw new GraalError(&quot;Could not find rt.jar on boot class path %s&quot;, System.getProperty(SUN_BOOT_CLASS_PATH));</span>
<span class="line-added"> 422                     }</span>
<span class="line-added"> 423                 } else {</span>
<span class="line-added"> 424                     bcpEntry = JRT_CLASS_PATH_ENTRY;</span>
 425                 }
<a name="35" id="anc35"></a><span class="line-modified"> 426                 compile(bcpEntry, libgraal);</span>


 427             } else {
<a name="36" id="anc36"></a><span class="line-modified"> 428                 compile(inputClassPath, libgraal);</span>
 429             }
<a name="37" id="anc37"></a>


 430         }
 431     }
 432 
 433     public void println() {
 434         println(&quot;&quot;);
 435     }
 436 
 437     public void println(String format, Object... args) {
 438         println(String.format(format, args));
 439     }
 440 
 441     public void println(String s) {
 442         println(verbose, s);
 443     }
 444 
 445     public static void println(boolean cond, String s) {
 446         if (cond) {
 447             TTY.println(s);
 448         }
 449     }
 450 
 451     public void printStackTrace(Throwable t) {
 452         if (verbose) {
 453             t.printStackTrace(TTY.out);
 454         }
 455     }
 456 
 457     @SuppressWarnings(&quot;unused&quot;)
 458     private static void dummy() {
 459     }
 460 
 461     /**
 462      * Abstraction over different types of class path entries.
 463      */
 464     abstract static class ClassPathEntry implements Closeable {
 465         final String name;
 466 
 467         ClassPathEntry(String name) {
 468             this.name = name;
 469         }
 470 
 471         /**
 472          * Creates a {@link ClassLoader} for loading classes from this entry.
 473          */
 474         public abstract ClassLoader createClassLoader() throws IOException;
 475 
 476         /**
 477          * Gets the list of classes available under this entry.
 478          */
 479         public abstract List&lt;String&gt; getClassNames() throws IOException;
 480 
 481         @Override
 482         public String toString() {
 483             return name;
 484         }
 485 
 486         @Override
 487         public void close() throws IOException {
 488         }
 489     }
 490 
 491     /**
 492      * A class path entry that is a normal file system directory.
 493      */
 494     static class DirClassPathEntry extends ClassPathEntry {
 495 
 496         private final File dir;
 497 
 498         DirClassPathEntry(String name) {
 499             super(name);
 500             dir = new File(name);
 501             assert dir.isDirectory();
 502         }
 503 
 504         @Override
 505         public ClassLoader createClassLoader() throws IOException {
 506             URL url = dir.toURI().toURL();
 507             return new URLClassLoader(new URL[]{url});
 508         }
 509 
 510         @Override
 511         public List&lt;String&gt; getClassNames() throws IOException {
 512             List&lt;String&gt; classNames = new ArrayList&lt;&gt;();
 513             String root = dir.getPath();
 514             SimpleFileVisitor&lt;Path&gt; visitor = new SimpleFileVisitor&lt;Path&gt;() {
 515                 @Override
 516                 public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
 517                     if (attrs.isRegularFile()) {
 518                         File path = file.toFile();
 519                         if (path.getName().endsWith(&quot;.class&quot;)) {
 520                             String pathString = path.getPath();
 521                             assert pathString.startsWith(root);
 522                             String classFile = pathString.substring(root.length() + 1);
 523                             String className = classFile.replace(File.separatorChar, &#39;.&#39;);
 524                             classNames.add(className.replace(&#39;/&#39;, &#39;.&#39;).substring(0, className.length() - &quot;.class&quot;.length()));
 525                         }
 526                     }
 527                     return super.visitFile(file, attrs);
 528                 }
 529             };
 530             Files.walkFileTree(dir.toPath(), visitor);
 531             return classNames;
 532         }
 533     }
 534 
 535     /**
 536      * A class path entry that is a jar or zip file.
 537      */
 538     static class JarClassPathEntry extends ClassPathEntry {
 539 
 540         private final JarFile jarFile;
 541 
 542         JarClassPathEntry(String name) throws IOException {
 543             super(name);
 544             jarFile = new JarFile(name);
 545         }
 546 
 547         @Override
 548         public ClassLoader createClassLoader() throws IOException {
 549             URL url = new URL(&quot;jar&quot;, &quot;&quot;, &quot;file:&quot; + name + &quot;!/&quot;);
 550             return new URLClassLoader(new URL[]{url});
 551         }
 552 
 553         /**
 554          * @see &quot;https://docs.oracle.com/javase/9/docs/specs/jar/jar.html#Multi-release&quot;
 555          */
 556         static Pattern MultiReleaseJarVersionedClassRE = Pattern.compile(&quot;META-INF/versions/[1-9][0-9]*/(.+)&quot;);
 557 
 558         @Override
 559         public List&lt;String&gt; getClassNames() throws IOException {
 560             Enumeration&lt;JarEntry&gt; e = jarFile.entries();
 561             List&lt;String&gt; classNames = new ArrayList&lt;&gt;(jarFile.size());
 562             while (e.hasMoreElements()) {
 563                 JarEntry je = e.nextElement();
 564                 if (je.isDirectory() || !je.getName().endsWith(&quot;.class&quot;)) {
 565                     continue;
 566                 }
 567                 String className = je.getName().substring(0, je.getName().length() - &quot;.class&quot;.length());
 568                 if (className.equals(&quot;module-info&quot;)) {
 569                     continue;
 570                 }
 571                 if (className.startsWith(&quot;META-INF/versions/&quot;)) {
 572                     Matcher m = MultiReleaseJarVersionedClassRE.matcher(className);
 573                     if (m.matches()) {
 574                         className = m.group(1);
 575                     } else {
 576                         continue;
 577                     }
 578                 }
 579                 classNames.add(className.replace(&#39;/&#39;, &#39;.&#39;));
 580             }
 581             return classNames;
 582         }
 583 
 584         @Override
 585         public void close() throws IOException {
 586             jarFile.close();
 587         }
 588     }
 589 
 590     /**
 591      * A class path entry representing the {@code jrt:/} file system.
 592      */
 593     static class JRTClassPathEntry extends ClassPathEntry {
 594 
 595         private final String limitModules;
 596 
 597         JRTClassPathEntry(String name, String limitModules) {
 598             super(name);
 599             this.limitModules = limitModules;
 600         }
 601 
 602         @Override
 603         public ClassLoader createClassLoader() throws IOException {
 604             URL url = URI.create(&quot;jrt:/&quot;).toURL();
 605             return new URLClassLoader(new URL[]{url});
 606         }
 607 
 608         @Override
 609         public List&lt;String&gt; getClassNames() throws IOException {
 610             Set&lt;String&gt; negative = new HashSet&lt;&gt;();
 611             Set&lt;String&gt; positive = new HashSet&lt;&gt;();
 612             if (limitModules != null &amp;&amp; !limitModules.isEmpty()) {
 613                 for (String s : limitModules.split(&quot;,&quot;)) {
 614                     if (s.startsWith(&quot;~&quot;)) {
 615                         negative.add(s.substring(1));
 616                     } else {
 617                         positive.add(s);
 618                     }
 619                 }
 620             }
 621             List&lt;String&gt; classNames = new ArrayList&lt;&gt;();
 622             FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;), Collections.emptyMap());
 623             Path top = fs.getPath(&quot;/modules/&quot;);
 624             Files.find(top, Integer.MAX_VALUE,
 625                             (path, attrs) -&gt; attrs.isRegularFile()).forEach(p -&gt; {
 626                                 int nameCount = p.getNameCount();
 627                                 if (nameCount &gt; 2) {
 628                                     String base = p.getName(nameCount - 1).toString();
 629                                     if (base.endsWith(&quot;.class&quot;) &amp;&amp; !base.equals(&quot;module-info.class&quot;)) {
 630                                         String module = p.getName(1).toString();
 631                                         if (positive.isEmpty() || positive.contains(module)) {
 632                                             if (negative.isEmpty() || !negative.contains(module)) {
 633                                                 // Strip module prefix and convert to dotted form
 634                                                 String className = p.subpath(2, nameCount).toString().replace(&#39;/&#39;, &#39;.&#39;);
 635                                                 // Strip &quot;.class&quot; suffix
 636                                                 className = className.replace(&#39;/&#39;, &#39;.&#39;).substring(0, className.length() - &quot;.class&quot;.length());
 637                                                 classNames.add(className);
 638                                             }
 639                                         }
 640                                     }
 641                                 }
 642                             });
 643             return classNames;
 644         }
 645     }
 646 
 647     private boolean isClassIncluded(String className) {
 648         if (methodFilters != null &amp;&amp; !MethodFilter.matchesClassName(methodFilters, className)) {
 649             return false;
 650         }
 651         if (excludeMethodFilters != null &amp;&amp; MethodFilter.matchesClassName(excludeMethodFilters, className)) {
 652             return false;
 653         }
 654         return true;
 655     }
 656 
<a name="38" id="anc38"></a><span class="line-added"> 657     private ClassPathEntry openClassPathEntry(String entry) throws IOException {</span>
<span class="line-added"> 658         if (entry.endsWith(&quot;.zip&quot;) || entry.endsWith(&quot;.jar&quot;)) {</span>
<span class="line-added"> 659             return new JarClassPathEntry(entry);</span>
<span class="line-added"> 660         } else if (entry.equals(JRT_CLASS_PATH_ENTRY)) {</span>
<span class="line-added"> 661             return new JRTClassPathEntry(entry, Options.LimitModules.getValue(harnessOptions));</span>
<span class="line-added"> 662         } else {</span>
<span class="line-added"> 663             if (!new File(entry).isDirectory()) {</span>
<span class="line-added"> 664                 return null;</span>
<span class="line-added"> 665             }</span>
<span class="line-added"> 666             return new DirClassPathEntry(entry);</span>
<span class="line-added"> 667         }</span>
<span class="line-added"> 668     }</span>
<span class="line-added"> 669 </span>
 670     /**
 671      * Compiles all methods in all classes in a given class path.
 672      *
 673      * @param classPath class path denoting classes to compile
 674      * @throws IOException
 675      */
 676     @SuppressWarnings(&quot;try&quot;)
<a name="39" id="anc39"></a><span class="line-modified"> 677     private void compile(String classPath, LibGraalParams libgraal) throws IOException {</span>
 678         final String[] entries = classPath.split(File.pathSeparator);
<a name="40" id="anc40"></a><span class="line-modified"> 679         long start = System.nanoTime();</span>
 680         Map&lt;Thread, StackTraceElement[]&gt; initialThreads = Thread.getAllStackTraces();
 681 
<a name="41" id="anc41"></a><span class="line-modified"> 682         if (libgraal == null) {</span>
<span class="line-modified"> 683             try {</span>
<span class="line-modified"> 684                 // compile dummy method to get compiler initialized outside of the</span>
<span class="line-modified"> 685                 // config debug override.</span>
<span class="line-modified"> 686                 HotSpotResolvedJavaMethod dummyMethod = (HotSpotResolvedJavaMethod) JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(</span>
<span class="line-modified"> 687                                 CompileTheWorld.class.getDeclaredMethod(&quot;dummy&quot;));</span>
<span class="line-modified"> 688                 int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;</span>
<span class="line-modified"> 689                 boolean useProfilingInfo = false;</span>
<span class="line-modified"> 690                 boolean installAsDefault = false;</span>
<span class="line-modified"> 691                 CompilationTask task = new CompilationTask(jvmciRuntime, compiler, new HotSpotCompilationRequest(dummyMethod, entryBCI, 0L), useProfilingInfo, installAsDefault);</span>
<span class="line-modified"> 692                 task.runCompilation(compilerOptions);</span>
<span class="line-modified"> 693             } catch (NoSuchMethodException | SecurityException e1) {</span>
<span class="line-added"> 694                 printStackTrace(e1);</span>
<span class="line-added"> 695             }</span>
 696         }
 697 
 698         /*
 699          * Always use a thread pool, even for single threaded mode since it simplifies the use of
 700          * DebugValueThreadFilter to filter on the thread names.
 701          */
 702         int threadCount = 1;
<a name="42" id="anc42"></a><span class="line-modified"> 703         if (Options.MultiThreaded.getValue(harnessOptions)) {</span>
<span class="line-modified"> 704             threadCount = Options.Threads.getValue(harnessOptions);</span>
 705             if (threadCount == 0) {
 706                 threadCount = Runtime.getRuntime().availableProcessors();
 707             }
 708         } else {
 709             running = true;
 710         }
 711 
<a name="43" id="anc43"></a>

 712         threadPool = new ThreadPoolExecutor(threadCount, threadCount, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), new CompilerThreadFactory(&quot;CompileTheWorld&quot;));
 713 
<a name="44" id="anc44"></a><span class="line-modified"> 714         int compileStartAt = startAt;</span>
<span class="line-modified"> 715         int compileStopAt = stopAt;</span>
<span class="line-modified"> 716         int compileStep = 1;</span>
<span class="line-modified"> 717         if (maxClasses != Integer.MAX_VALUE) {</span>
<span class="line-modified"> 718             int totalClassFileCount = 0;</span>
<span class="line-modified"> 719             for (String entry : entries) {</span>
<span class="line-modified"> 720                 try (ClassPathEntry cpe = openClassPathEntry(entry)) {</span>
<span class="line-modified"> 721                     if (cpe != null) {</span>
<span class="line-modified"> 722                         totalClassFileCount += cpe.getClassNames().size();</span>





 723                     }
<a name="45" id="anc45"></a><span class="line-modified"> 724                 }</span>
<span class="line-added"> 725             }</span>
<span class="line-added"> 726 </span>
<span class="line-added"> 727             int lastClassFile = totalClassFileCount - 1;</span>
<span class="line-added"> 728             compileStartAt = Math.min(startAt, lastClassFile);</span>
<span class="line-added"> 729             compileStopAt = Math.min(stopAt, lastClassFile);</span>
<span class="line-added"> 730             int range = compileStopAt - compileStartAt + 1;</span>
<span class="line-added"> 731             if (maxClasses &lt; range) {</span>
<span class="line-added"> 732                 compileStep = range / maxClasses;</span>
<span class="line-added"> 733             }</span>
<span class="line-added"> 734         }</span>
<span class="line-added"> 735 </span>
<span class="line-added"> 736         for (int i = 0; i &lt; entries.length; i++) {</span>
<span class="line-added"> 737             final String entry = entries[i];</span>
<span class="line-added"> 738             try (ClassPathEntry cpe = openClassPathEntry(entry)) {</span>
<span class="line-added"> 739                 if (cpe == null) {</span>
<span class="line-added"> 740                     println(&quot;CompileTheWorld : Skipped classes in &quot; + entry);</span>
<span class="line-added"> 741                     println();</span>
<span class="line-added"> 742                     continue;</span>
 743                 }
 744 
 745                 if (methodFilters == null || methodFilters.length == 0) {
 746                     println(&quot;CompileTheWorld : Compiling all classes in &quot; + entry);
 747                 } else {
 748                     String include = Arrays.asList(methodFilters).stream().map(MethodFilter::toString).collect(Collectors.joining(&quot;, &quot;));
 749                     println(&quot;CompileTheWorld : Compiling all methods in &quot; + entry + &quot; matching one of the following filters: &quot; + include);
 750                 }
 751                 if (excludeMethodFilters != null &amp;&amp; excludeMethodFilters.length &gt; 0) {
 752                     String exclude = Arrays.asList(excludeMethodFilters).stream().map(MethodFilter::toString).collect(Collectors.joining(&quot;, &quot;));
 753                     println(&quot;CompileTheWorld : Excluding all methods matching one of the following filters: &quot; + exclude);
 754                 }
 755                 println();
 756 
 757                 ClassLoader loader = cpe.createClassLoader();
 758 
 759                 for (String className : cpe.getClassNames()) {
 760 
 761                     // Are we done?
<a name="46" id="anc46"></a><span class="line-modified"> 762                     if (classFileCounter &gt;= compileStopAt) {</span>
 763                         break;
 764                     }
 765 
 766                     classFileCounter++;
 767 
<a name="47" id="anc47"></a><span class="line-added"> 768                     if (compileStep &gt; 1 &amp;&amp; ((classFileCounter - compileStartAt) % compileStep) != 0) {</span>
<span class="line-added"> 769                         continue;</span>
<span class="line-added"> 770                     }</span>
<span class="line-added"> 771 </span>
 772                     if (className.startsWith(&quot;jdk.management.&quot;) ||
 773                                     className.startsWith(&quot;jdk.internal.cmm.*&quot;) ||
 774                                     // GR-5881: The class initializer for
 775                                     // sun.tools.jconsole.OutputViewer
 776                                     // spawns non-daemon threads for redirecting sysout and syserr.
 777                                     // These threads tend to cause deadlock at VM exit
 778                                     className.startsWith(&quot;sun.tools.jconsole.&quot;)) {
 779                         continue;
 780                     }
 781 
 782                     if (!isClassIncluded(className)) {
 783                         continue;
 784                     }
 785 
 786                     try {
 787                         // Load and initialize class
 788                         Class&lt;?&gt; javaClass = Class.forName(className, true, loader);
 789                         MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
 790 
 791                         // Pre-load all classes in the constant pool.
 792                         try {
 793                             HotSpotResolvedObjectType objectType = (HotSpotResolvedObjectType) metaAccess.lookupJavaType(javaClass);
 794                             ConstantPool constantPool = objectType.getConstantPool();
 795                             for (int cpi = 1; cpi &lt; constantPool.length(); cpi++) {
 796                                 constantPool.loadReferencedType(cpi, Bytecodes.LDC);
 797                             }
 798                         } catch (Throwable t) {
 799                             // If something went wrong during pre-loading we just ignore it.
 800                             if (isClassIncluded(className)) {
 801                                 println(&quot;Preloading failed for (%d) %s: %s&quot;, classFileCounter, className, t);
 802                             }
 803                             continue;
 804                         }
 805 
 806                         // Are we compiling this class?
<a name="48" id="anc48"></a><span class="line-modified"> 807                         if (classFileCounter &gt;= compileStartAt) {</span>

 808 
<a name="49" id="anc49"></a><span class="line-added"> 809                             long start0 = System.nanoTime();</span>
 810                             // Compile each constructor/method in the class.
 811                             for (Constructor&lt;?&gt; constructor : javaClass.getDeclaredConstructors()) {
 812                                 HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(constructor);
 813                                 if (canBeCompiled(javaMethod, constructor.getModifiers())) {
<a name="50" id="anc50"></a><span class="line-modified"> 814                                     compileMethod(javaMethod, libgraal);</span>
 815                                 }
 816                             }
 817                             for (Method method : javaClass.getDeclaredMethods()) {
 818                                 HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(method);
 819                                 if (canBeCompiled(javaMethod, method.getModifiers())) {
<a name="51" id="anc51"></a><span class="line-modified"> 820                                     compileMethod(javaMethod, libgraal);</span>
 821                                 }
 822                             }
 823 
 824                             // Also compile the class initializer if it exists
 825                             HotSpotResolvedJavaMethod clinit = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaType(javaClass).getClassInitializer();
 826                             if (clinit != null &amp;&amp; canBeCompiled(clinit, clinit.getModifiers())) {
<a name="52" id="anc52"></a><span class="line-modified"> 827                                 compileMethod(clinit, libgraal);</span>
 828                             }
<a name="53" id="anc53"></a><span class="line-added"> 829                             println(&quot;CompileTheWorld (%d) : %s (%d us)&quot;, classFileCounter, className, (System.nanoTime() - start0) / 1000);</span>
 830                         }
 831                     } catch (Throwable t) {
 832                         if (isClassIncluded(className)) {
 833                             println(&quot;CompileTheWorld (%d) : Skipping %s %s&quot;, classFileCounter, className, t.toString());
 834                             printStackTrace(t);
 835                         }
 836                     }
 837                 }
<a name="54" id="anc54"></a>
 838             }
<a name="55" id="anc55"></a>

 839         }
 840 
 841         if (!running) {
 842             startThreads();
 843         }
 844         int wakeups = 0;
<a name="56" id="anc56"></a><span class="line-modified"> 845         long lastCompletedTaskCount = 0;</span>
<span class="line-added"> 846         for (long completedTaskCount = threadPool.getCompletedTaskCount(); completedTaskCount != threadPool.getTaskCount(); completedTaskCount = threadPool.getCompletedTaskCount()) {</span>
 847             if (wakeups % 15 == 0) {
<a name="57" id="anc57"></a><span class="line-modified"> 848                 TTY.printf(&quot;CompileTheWorld : Waiting for %d compiles, just completed %d compiles%n&quot;, threadPool.getTaskCount() - completedTaskCount, completedTaskCount - lastCompletedTaskCount);</span>
<span class="line-added"> 849                 lastCompletedTaskCount = completedTaskCount;</span>
 850             }
 851             try {
 852                 threadPool.awaitTermination(1, TimeUnit.SECONDS);
 853                 wakeups++;
 854             } catch (InterruptedException e) {
 855             }
 856         }
<a name="58" id="anc58"></a><span class="line-added"> 857         threadPool.shutdown();</span>
 858         threadPool = null;
 859 
<a name="59" id="anc59"></a><span class="line-modified"> 860         long elapsedTime = System.nanoTime() - start;</span>
 861 
 862         println();
<a name="60" id="anc60"></a><span class="line-modified"> 863         int compiledClasses = classFileCounter &gt; compileStartAt ? classFileCounter - compileStartAt : 0;</span>
<span class="line-modified"> 864         if (Options.MultiThreaded.getValue(harnessOptions)) {</span>
<span class="line-modified"> 865             TTY.println(&quot;CompileTheWorld : Done (%d classes, %d methods, %d ms elapsed, %d ms compile time, %d bytes of memory used)&quot;, compiledClasses, compiledMethodsCounter.get(), elapsedTime,</span>
<span class="line-added"> 866                             compileTime.get() / 1000000, memoryUsed.get());</span>
 867         } else {
<a name="61" id="anc61"></a><span class="line-modified"> 868             TTY.println(&quot;CompileTheWorld : Done (%d classes, %d methods, %d ms, %d bytes of memory used)&quot;, compiledClasses, compiledMethodsCounter.get(), compileTime.get(), memoryUsed.get());</span>
 869         }
 870 
<a name="62" id="anc62"></a><span class="line-added"> 871         GlobalMetrics metricValues = ((HotSpotGraalRuntime) compiler.getGraalRuntime()).getMetricValues();</span>
<span class="line-added"> 872         EconomicMap&lt;MetricKey, Long&gt; map = metricValues.asKeyValueMap();</span>
<span class="line-added"> 873         Long compiledAndInstalledBytecodes = map.get(CompiledAndInstalledBytecodes);</span>
<span class="line-added"> 874         Long compilationTime = map.get(CompilationTime);</span>
<span class="line-added"> 875         if (compiledAndInstalledBytecodes != null &amp;&amp; compilationTime != null) {</span>
<span class="line-added"> 876             TTY.println(&quot;CompileTheWorld : Aggregate compile speed %d bytecodes per second (%d / %d)&quot;, (int) (compiledAndInstalledBytecodes / (compilationTime / 1000000000.0)),</span>
<span class="line-added"> 877                             compiledAndInstalledBytecodes, compilationTime);</span>
<span class="line-added"> 878         }</span>
<span class="line-added"> 879 </span>
<span class="line-added"> 880         metricValues.print(compilerOptions);</span>
<span class="line-added"> 881         metricValues.clear();</span>
<span class="line-added"> 882 </span>
 883         // Apart from the main thread, there should be only be daemon threads
 884         // alive now. If not, then a class initializer has probably started
 885         // a thread that could cause a deadlock while trying to exit the VM.
 886         // One known example of this is sun.tools.jconsole.OutputViewer which
 887         // spawns threads to redirect sysout and syserr. To help debug such
 888         // scenarios, the stacks of potentially problematic threads are dumped.
 889         Map&lt;Thread, StackTraceElement[]&gt; suspiciousThreads = new HashMap&lt;&gt;();
 890         for (Map.Entry&lt;Thread, StackTraceElement[]&gt; e : Thread.getAllStackTraces().entrySet()) {
 891             Thread thread = e.getKey();
 892             if (thread != Thread.currentThread() &amp;&amp; !initialThreads.containsKey(thread) &amp;&amp; !thread.isDaemon() &amp;&amp; thread.isAlive()) {
 893                 suspiciousThreads.put(thread, e.getValue());
 894             }
 895         }
 896         if (!suspiciousThreads.isEmpty()) {
 897             TTY.println(&quot;--- Non-daemon threads started during CTW ---&quot;);
 898             for (Map.Entry&lt;Thread, StackTraceElement[]&gt; e : suspiciousThreads.entrySet()) {
 899                 Thread thread = e.getKey();
 900                 if (thread.isAlive()) {
 901                     TTY.println(thread.toString() + &quot; &quot; + thread.getState());
 902                     for (StackTraceElement ste : e.getValue()) {
 903                         TTY.println(&quot;\tat &quot; + ste);
 904                     }
 905                 }
 906             }
 907             TTY.println(&quot;---------------------------------------------&quot;);
 908         }
 909     }
 910 
 911     private synchronized void startThreads() {
 912         running = true;
 913         // Wake up any waiting threads
 914         notifyAll();
 915     }
 916 
 917     private synchronized void waitToRun() {
 918         while (!running) {
 919             try {
 920                 wait();
 921             } catch (InterruptedException e) {
 922             }
 923         }
 924     }
 925 
 926     @SuppressWarnings(&quot;try&quot;)
<a name="63" id="anc63"></a><span class="line-modified"> 927     private void compileMethod(HotSpotResolvedJavaMethod method, LibGraalParams libgraal) throws InterruptedException, ExecutionException {</span>
 928         if (methodFilters != null &amp;&amp; !MethodFilter.matches(methodFilters, method)) {
 929             return;
 930         }
 931         if (excludeMethodFilters != null &amp;&amp; MethodFilter.matches(excludeMethodFilters, method)) {
 932             return;
 933         }
 934         Future&lt;?&gt; task = threadPool.submit(new Runnable() {
 935             @Override
 936             public void run() {
 937                 waitToRun();
<a name="64" id="anc64"></a><span class="line-modified"> 938                 compileMethod(method, classFileCounter, libgraal);</span>






 939             }
 940         });
 941         if (threadPool.getCorePoolSize() == 1) {
 942             task.get();
 943         }
 944     }
 945 
<a name="65" id="anc65"></a><span class="line-added"> 946     private static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();</span>
<span class="line-added"> 947 </span>
<span class="line-added"> 948     /**</span>
<span class="line-added"> 949      * Implemented by</span>
<span class="line-added"> 950      * {@code com.oracle.svm.graal.hotspot.libgraal.LibGraalEntryPoints.compileMethod}.</span>
<span class="line-added"> 951      */</span>
<span class="line-added"> 952     static native long compileMethodInLibgraal(long isolateThread,</span>
<span class="line-added"> 953                     long methodHandle,</span>
<span class="line-added"> 954                     boolean useProfilingInfo,</span>
<span class="line-added"> 955                     boolean installAsDefault,</span>
<span class="line-added"> 956                     long optionsAddress,</span>
<span class="line-added"> 957                     int optionsSize,</span>
<span class="line-added"> 958                     int optionsHash,</span>
<span class="line-added"> 959                     long encodedThrowableBufferAddress,</span>
<span class="line-added"> 960                     int encodedThrowableBufferSize);</span>
<span class="line-added"> 961 </span>
 962     /**
 963      * Compiles a method and gathers some statistics.
 964      */
<a name="66" id="anc66"></a><span class="line-modified"> 965     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-added"> 966     private void compileMethod(HotSpotResolvedJavaMethod method, int counter, LibGraalParams libgraal) {</span>
 967         try {
<a name="67" id="anc67"></a><span class="line-modified"> 968             long start = System.nanoTime();</span>
 969             long allocatedAtStart = getCurrentThreadAllocatedBytes();
<a name="68" id="anc68"></a>

 970             // For more stable CTW execution, disable use of profiling information
 971             boolean useProfilingInfo = false;
 972             boolean installAsDefault = false;
<a name="69" id="anc69"></a><span class="line-modified"> 973             HotSpotInstalledCode installedCode;</span>
<span class="line-modified"> 974             if (libgraal != null) {</span>
<span class="line-added"> 975                 HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();</span>
<span class="line-added"> 976                 try (LibGraalScope scope = new LibGraalScope(runtime)) {</span>
<span class="line-added"> 977                     long methodHandle = LibGraal.translate(runtime, method);</span>
<span class="line-added"> 978                     long isolateThread = LibGraalScope.getIsolateThread();</span>
<span class="line-added"> 979 </span>
<span class="line-added"> 980                     StackTraceBuffer stackTraceBuffer = libgraal.getStackTraceBuffer();</span>
<span class="line-added"> 981 </span>
<span class="line-added"> 982                     long stackTraceBufferAddress = stackTraceBuffer.getAddress();</span>
<span class="line-added"> 983                     long installedCodeHandle = compileMethodInLibgraal(isolateThread,</span>
<span class="line-added"> 984                                     methodHandle,</span>
<span class="line-added"> 985                                     useProfilingInfo,</span>
<span class="line-added"> 986                                     installAsDefault,</span>
<span class="line-added"> 987                                     libgraal.options.getAddress(),</span>
<span class="line-added"> 988                                     libgraal.options.size,</span>
<span class="line-added"> 989                                     libgraal.options.hash,</span>
<span class="line-added"> 990                                     stackTraceBufferAddress,</span>
<span class="line-added"> 991                                     stackTraceBuffer.size);</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993                     installedCode = LibGraal.unhand(runtime, HotSpotInstalledCode.class, installedCodeHandle);</span>
<span class="line-added"> 994                     if (installedCode == null) {</span>
<span class="line-added"> 995                         int length = UNSAFE.getInt(stackTraceBufferAddress);</span>
<span class="line-added"> 996                         byte[] data = new byte[length];</span>
<span class="line-added"> 997                         UNSAFE.copyMemory(null, stackTraceBufferAddress + Integer.BYTES, data, ARRAY_BYTE_BASE_OFFSET, length);</span>
<span class="line-added"> 998                         String stackTrace = new String(data).trim();</span>
<span class="line-added"> 999                         println(true, String.format(&quot;CompileTheWorld (%d) : Error compiling method: %s&quot;, counter, method.format(&quot;%H.%n(%p):%r&quot;)));</span>
<span class="line-added">1000                         println(true, stackTrace);</span>
<span class="line-added">1001                     }</span>
<span class="line-added">1002                 }</span>
<span class="line-added">1003             } else {</span>
<span class="line-added">1004                 int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;</span>
<span class="line-added">1005                 HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, 0L);</span>
<span class="line-added">1006                 CompilationTask task = new CompilationTask(jvmciRuntime, compiler, request, useProfilingInfo, installAsDefault);</span>
<span class="line-added">1007                 task.runCompilation(compilerOptions);</span>
<span class="line-added">1008                 installedCode = task.getInstalledCode();</span>
<span class="line-added">1009             }</span>
1010 
1011             // Invalidate the generated code so the code cache doesn&#39;t fill up
<a name="70" id="anc70"></a><span class="line-modified">1012             if (installedCode != null &amp;&amp; InvalidateInstalledCode.getValue(compilerOptions)) {</span>

1013                 installedCode.invalidate();
1014             }
1015 
1016             memoryUsed.getAndAdd(getCurrentThreadAllocatedBytes() - allocatedAtStart);
<a name="71" id="anc71"></a><span class="line-modified">1017             compileTime.getAndAdd(System.nanoTime() - start);</span>
1018             compiledMethodsCounter.incrementAndGet();
1019         } catch (Throwable t) {
1020             // Catch everything and print a message
1021             println(&quot;CompileTheWorld (%d) : Error compiling method: %s&quot;, counter, method.format(&quot;%H.%n(%p):%r&quot;));
1022             printStackTrace(t);
1023         }
1024     }
1025 
1026     /**
1027      * Determines if a method should be compiled (Cf. CompilationPolicy::can_be_compiled).
1028      *
1029      * @return true if it can be compiled, false otherwise
1030      */
1031     private boolean canBeCompiled(HotSpotResolvedJavaMethod javaMethod, int modifiers) {
1032         if (Modifier.isAbstract(modifiers) || Modifier.isNative(modifiers)) {
1033             return false;
1034         }
1035         GraalHotSpotVMConfig c = compiler.getGraalRuntime().getVMConfig();
1036         if (c.dontCompileHugeMethods &amp;&amp; javaMethod.getCodeSize() &gt; c.hugeMethodLimit) {
1037             println(verbose || methodFilters != null,
1038                             String.format(&quot;CompileTheWorld (%d) : Skipping huge method %s (use -XX:-DontCompileHugeMethods or -XX:HugeMethodLimit=%d to include it)&quot;, classFileCounter,
1039                                             javaMethod.format(&quot;%H.%n(%p):%r&quot;),
1040                                             javaMethod.getCodeSize()));
1041             return false;
1042         }
1043         // Allow use of -XX:CompileCommand=dontinline to exclude problematic methods
1044         if (!javaMethod.canBeInlined()) {
1045             return false;
1046         }
1047         // Skip @Snippets for now
1048         for (Annotation annotation : javaMethod.getAnnotations()) {
1049             if (annotation.annotationType().equals(Snippet.class)) {
1050                 return false;
1051             }
1052         }
1053         return true;
1054     }
1055 
1056     static class Options {
<a name="72" id="anc72"></a>
1057         public static final OptionKey&lt;Boolean&gt; Help = new OptionKey&lt;&gt;(false);
1058         public static final OptionKey&lt;String&gt; Classpath = new OptionKey&lt;&gt;(CompileTheWorld.SUN_BOOT_CLASS_PATH);
1059         public static final OptionKey&lt;Boolean&gt; Verbose = new OptionKey&lt;&gt;(true);
1060         /**
<a name="73" id="anc73"></a><span class="line-modified">1061          * Ignore Graal classes by default to avoid problems associated with compiling snippets and</span>
<span class="line-modified">1062          * method substitutions.</span>
1063          */
1064         public static final OptionKey&lt;String&gt; LimitModules = new OptionKey&lt;&gt;(&quot;~jdk.internal.vm.compiler&quot;);
1065         public static final OptionKey&lt;Integer&gt; Iterations = new OptionKey&lt;&gt;(1);
1066         public static final OptionKey&lt;String&gt; MethodFilter = new OptionKey&lt;&gt;(null);
1067         public static final OptionKey&lt;String&gt; ExcludeMethodFilter = new OptionKey&lt;&gt;(null);
1068         public static final OptionKey&lt;Integer&gt; StartAt = new OptionKey&lt;&gt;(1);
1069         public static final OptionKey&lt;Integer&gt; StopAt = new OptionKey&lt;&gt;(Integer.MAX_VALUE);
<a name="74" id="anc74"></a><span class="line-added">1070         public static final OptionKey&lt;Integer&gt; MaxClasses = new OptionKey&lt;&gt;(Integer.MAX_VALUE);</span>
1071         public static final OptionKey&lt;String&gt; Config = new OptionKey&lt;&gt;(null);
1072         public static final OptionKey&lt;Boolean&gt; MultiThreaded = new OptionKey&lt;&gt;(false);
1073         public static final OptionKey&lt;Integer&gt; Threads = new OptionKey&lt;&gt;(0);
<a name="75" id="anc75"></a><span class="line-added">1074         public static final OptionKey&lt;Boolean&gt; InvalidateInstalledCode = new OptionKey&lt;&gt;(false);</span>
1075 
<a name="76" id="anc76"></a><span class="line-added">1076         // @formatter:off</span>
1077         static final ReflectionOptionDescriptors DESCRIPTORS = new ReflectionOptionDescriptors(Options.class,
1078                            &quot;Help&quot;, &quot;List options and their help messages and then exit.&quot;,
1079                       &quot;Classpath&quot;, &quot;Class path denoting methods to compile. Default is to compile boot classes.&quot;,
<a name="77" id="anc77"></a><span class="line-modified">1080                         &quot;Verbose&quot;, &quot;Verbose operation. Default is !MultiThreaded.&quot;,</span>
1081                    &quot;LimitModules&quot;, &quot;Comma separated list of module names to which compilation should be limited. &quot; +
1082                                    &quot;Module names can be prefixed with \&quot;~\&quot; to exclude the named module.&quot;,
1083                      &quot;Iterations&quot;, &quot;The number of iterations to perform.&quot;,
1084                    &quot;MethodFilter&quot;, &quot;Only compile methods matching this filter.&quot;,
1085             &quot;ExcludeMethodFilter&quot;, &quot;Exclude methods matching this filter from compilation.&quot;,
<a name="78" id="anc78"></a><span class="line-modified">1086                         &quot;StartAt&quot;, &quot;First class to consider for compilation (default = 1).&quot;,</span>
<span class="line-modified">1087                          &quot;StopAt&quot;, &quot;Last class to consider for compilation (default = &lt;number of classes&gt;).&quot;,</span>
<span class="line-modified">1088                      &quot;MaxClasses&quot;, &quot;Maximum number of classes to process (default = &lt;number of classes&gt;). &quot; +</span>
<span class="line-modified">1089                                    &quot;Ignored if less than (StopAt - StartAt + 1).&quot;,</span>
<span class="line-modified">1090                          &quot;Config&quot;, &quot;Option values to use during compile the world compilations. For example, &quot; +</span>
<span class="line-added">1091                                    &quot;to disable partial escape analysis and print compilations specify &quot; +</span>
<span class="line-added">1092                                    &quot;&#39;PartialEscapeAnalysis=false PrintCompilation=true&#39;. &quot; +</span>
<span class="line-added">1093                                    &quot;Unless explicitly enabled with &#39;Inline=true&#39; here, inlining is disabled.&quot;,</span>
1094                   &quot;MultiThreaded&quot;, &quot;Run using multiple threads for compilation.&quot;,
<a name="79" id="anc79"></a><span class="line-modified">1095                         &quot;Threads&quot;, &quot;Number of threads to use for multithreaded execution. Defaults to Runtime.getRuntime().availableProcessors().&quot;,</span>
<span class="line-added">1096         &quot;InvalidateInstalledCode&quot;, &quot;Invalidate the generated code so the code cache doesn&#39;t fill up.&quot;);</span>
1097         // @formatter:on
1098     }
1099 
<a name="80" id="anc80"></a><span class="line-modified">1100     public static OptionValues loadHarnessOptions() {</span>
1101         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; values = OptionValues.newOptionMap();
1102         List&lt;OptionDescriptors&gt; loader = singletonList(DESCRIPTORS);
1103         OptionsParser.parseOptions(extractEntries(System.getProperties(), &quot;CompileTheWorld.&quot;, true), values, loader);
<a name="81" id="anc81"></a><span class="line-modified">1104         OptionValues options = new OptionValues(values);</span>
1105         if (Options.Help.getValue(options)) {
1106             options.printHelp(loader, System.out, &quot;CompileTheWorld.&quot;);
1107             System.exit(0);
1108         }
1109         return options;
1110     }
1111 
1112     public static void main(String[] args) throws Throwable {
1113         HotSpotJVMCIRuntime jvmciRuntime = HotSpotJVMCIRuntime.runtime();
1114         HotSpotGraalCompiler compiler = (HotSpotGraalCompiler) jvmciRuntime.getCompiler();
1115         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
1116         HotSpotCodeCacheProvider codeCache = graalRuntime.getHostProviders().getCodeCache();
<a name="82" id="anc82"></a><span class="line-modified">1117         OptionValues harnessOptions = loadHarnessOptions();</span>
1118 
<a name="83" id="anc83"></a><span class="line-modified">1119         int iterations = Options.Iterations.getValue(harnessOptions);</span>
1120         for (int i = 0; i &lt; iterations; i++) {
1121             codeCache.resetCompilationStatistics();
1122             TTY.println(&quot;CompileTheWorld : iteration &quot; + i);
1123 
<a name="84" id="anc84"></a><span class="line-modified">1124             CompileTheWorld ctw = new CompileTheWorld(jvmciRuntime, compiler, harnessOptions, graalRuntime.getOptions());</span>
1125             ctw.compile();
<a name="85" id="anc85"></a><span class="line-added">1126             if (iterations &gt; 1) {</span>
<span class="line-added">1127                 // Force a GC to encourage reclamation of nmethods when their InstalledCode</span>
<span class="line-added">1128                 // reference has been dropped.</span>
<span class="line-added">1129                 System.gc();</span>
<span class="line-added">1130             }</span>
1131         }
1132         // This is required as non-daemon threads can be started by class initializers
1133         System.exit(0);
1134     }
1135 }
<a name="86" id="anc86"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="86" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/WriteBarrierAdditionTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
 27 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.referentOffset;
 28 
 29 import java.lang.ref.WeakReference;
 30 
 31 import org.graalvm.compiler.api.replacements.Fold;
 32 import org.graalvm.compiler.debug.DebugContext;
 33 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 34 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase;
 35 import org.graalvm.compiler.hotspot.gc.g1.G1PostWriteBarrier;
 36 import org.graalvm.compiler.hotspot.gc.g1.G1PreWriteBarrier;
 37 import org.graalvm.compiler.hotspot.gc.g1.G1ReferentFieldReadBarrier;
 38 import org.graalvm.compiler.hotspot.gc.shared.SerialWriteBarrier;
 39 import org.graalvm.compiler.hotspot.phases.WriteBarrierAdditionPhase;
 40 import org.graalvm.compiler.nodes.StructuredGraph;
 41 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 42 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 43 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;
 44 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
 45 import org.graalvm.compiler.nodes.memory.ReadNode;
 46 import org.graalvm.compiler.nodes.memory.WriteNode;
 47 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 48 import org.graalvm.compiler.nodes.spi.LoweringTool;
 49 import org.graalvm.compiler.phases.OptimisticOptimizations;
 50 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 51 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 52 import org.graalvm.compiler.phases.common.LoweringPhase;
 53 import org.graalvm.compiler.phases.common.inlining.InliningPhase;
 54 import org.graalvm.compiler.phases.common.inlining.policy.InlineEverythingPolicy;
 55 import org.graalvm.compiler.phases.tiers.HighTierContext;
 56 import org.graalvm.compiler.phases.tiers.MidTierContext;
 57 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;
 58 import org.junit.Assert;
 59 import org.junit.Test;
 60 
 61 import jdk.vm.ci.hotspot.HotSpotInstalledCode;
 62 import jdk.vm.ci.meta.JavaConstant;
 63 import jdk.vm.ci.meta.ResolvedJavaMethod;
 64 import sun.misc.Unsafe;
 65 
 66 /**
 67  * The following unit tests assert the presence of write barriers for both Serial and G1 GCs.
 68  * Normally, the tests check for compile time inserted barriers. However, there are the cases of
 69  * unsafe loads of the java.lang.ref.Reference.referent field where runtime checks have to be
 70  * performed also. For those cases, the unit tests check the presence of the compile-time inserted
 71  * barriers. Concerning the runtime checks, the results of variable inputs (object types and
 72  * offsets) passed as input parameters can be checked against printed output from the G1 write
 73  * barrier snippets. The runtime checks have been validated offline.
 74  */
 75 public class WriteBarrierAdditionTest extends HotSpotGraalCompilerTest {
 76 
 77     private final GraalHotSpotVMConfig config = runtime().getVMConfig();
 78 
 79     public static class Container {
 80 
 81         public Container a;
 82         public Container b;
 83     }
 84 
 85     /**
 86      * Expected 2 barriers for the Serial GC and 4 for G1 (2 pre + 2 post).
 87      */
 88     @Test
 89     public void test1() throws Exception {
 90         testHelper(&quot;test1Snippet&quot;, (config.useG1GC) ? 4 : 2);
 91     }
 92 
 93     public static void test1Snippet() {
 94         Container main = new Container();
 95         Container temp1 = new Container();
 96         Container temp2 = new Container();
 97         main.a = temp1;
 98         main.b = temp2;
 99     }
100 
101     /**
102      * Expected 4 barriers for the Serial GC and 8 for G1 (4 pre + 4 post).
103      */
104     @Test
105     public void test2() throws Exception {
106         testHelper(&quot;test2Snippet&quot;, config.useG1GC ? 8 : 4);
107     }
108 
109     public static void test2Snippet(boolean test) {
110         Container main = new Container();
111         Container temp1 = new Container();
112         Container temp2 = new Container();
113         for (int i = 0; i &lt; 10; i++) {
114             if (test) {
115                 main.a = temp1;
116                 main.b = temp2;
117             } else {
118                 main.a = temp2;
119                 main.b = temp1;
120             }
121         }
122     }
123 
124     /**
125      * Expected 4 barriers for the Serial GC and 8 for G1 (4 pre + 4 post).
126      */
127     @Test
128     public void test3() throws Exception {
129         testHelper(&quot;test3Snippet&quot;, config.useG1GC ? 8 : 4);
130     }
131 
132     public static void test3Snippet() {
133         Container[] main = new Container[10];
134         Container temp1 = new Container();
135         Container temp2 = new Container();
136         for (int i = 0; i &lt; 10; i++) {
137             main[i].a = main[i].b = temp1;
138         }
139 
140         for (int i = 0; i &lt; 10; i++) {
141             main[i].a = main[i].b = temp2;
142         }
143     }
144 
145     /**
146      * Expected 2 barriers for the Serial GC and 5 for G1 (3 pre + 2 post) The (2 or 4) barriers are
147      * emitted while initializing the fields of the WeakReference instance. The extra pre barrier of
148      * G1 concerns the read of the referent field.
149      */
150     @Test
151     public void test4() throws Exception {
152         testHelper(&quot;test4Snippet&quot;, config.useG1GC ? 5 : 2);
153     }
154 
155     public static Object test4Snippet() {
156         WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(new Object());
157         return weakRef.get();
158     }
159 
160     static WeakReference&lt;Object&gt; wr = new WeakReference&lt;&gt;(new Object());
161     static Container con = new Container();
162 
163     /**
164      * Expected 4 barriers for the Serial GC and 9 for G1 (1 ref + 4 pre + 4 post). In this test, we
165      * load the correct offset of the WeakReference object so naturally we assert the presence of
166      * the pre barrier.
167      */
168     @Test
169     public void test5() throws Exception {
170         testHelper(&quot;test5Snippet&quot;, config.useG1GC ? 1 : 0);
171     }
172 
173     @Override
174     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
175         NodeIntrinsicPluginFactory.InjectionProvider injection = new NodeIntrinsificationProvider(getMetaAccess(), getSnippetReflection(), getProviders().getForeignCalls(), null);
176         new PluginFactory_WriteBarrierAdditionTest().registerPlugins(invocationPlugins, injection);
177         super.registerInvocationPlugins(invocationPlugins);
178     }
179 
180     @Fold
181     public static boolean useCompressedOops(@Fold.InjectedParameter GraalHotSpotVMConfig config) {
182         return config.useCompressedOops;
183     }
184 
185     public static Object test5Snippet() throws Exception {
186         return UNSAFE.getObject(wr, useCompressedOops(GraalHotSpotVMConfigBase.INJECTED_VMCONFIG) ? 12L : 16L);
187     }
188 
189     /**
190      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely
191      * load the java.lang.ref.Reference.referent field so the pre barier has to be executed.
192      */
193     @Test
194     public void test6() throws Exception {
195         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(referentOffset(getMetaAccess())), null);
196     }
197 
198     /**
199      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely
200      * load a matching offset of a wrong object so the pre barier must not be executed.
201      */
202     @Test
203     public void test7() throws Exception {
204         test2(&quot;testUnsafeLoad&quot;, UNSAFE, con, Long.valueOf(referentOffset(getMetaAccess())), null);
205     }
206 
207     /**
208      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely
209      * load a non-matching offset field of the java.lang.ref.Reference object so the pre barier must
210      * not be executed.
211      */
212     @Test
213     public void test8() throws Exception {
214         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 20 : 32), null);
215     }
216 
217     /**
218      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely
219      * load a matching offset+disp field of the java.lang.ref.Reference object so the pre barier
220      * must be executed.
221      */
222     @Test
223     public void test10() throws Exception {
224         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 6 : 8), Integer.valueOf(config.useCompressedOops ? 6 : 8));
225     }
226 
227     /**
228      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely
229      * load a non-matching offset+disp field of the java.lang.ref.Reference object so the pre barier
230      * must not be executed.
231      */
232     @Test
233     public void test9() throws Exception {
234         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 10 : 16), Integer.valueOf(config.useCompressedOops ? 10 : 16));
235     }
236 
237     static Object[] src = new Object[1];
238     static Object[] dst = new Object[1];
239 
240     static {
241         for (int i = 0; i &lt; src.length; i++) {
242             src[i] = new Object();
243         }
244         for (int i = 0; i &lt; dst.length; i++) {
245             dst[i] = new Object();
246         }
247     }
248 
249     public static void testArrayCopy(Object a, Object b, Object c) throws Exception {
250         System.arraycopy(a, 0, b, 0, (int) c);
251     }
252 
253     @Test
254     public void test11() throws Exception {
255         test2(&quot;testArrayCopy&quot;, src, dst, dst.length);
256     }
257 
258     public static Object testUnsafeLoad(Unsafe theUnsafe, Object a, Object b, Object c) throws Exception {
259         final int offset = (c == null ? 0 : ((Integer) c).intValue());
260         final long displacement = (b == null ? 0 : ((Long) b).longValue());
261         return theUnsafe.getObject(a, offset + displacement);
262     }
263 
264     private HotSpotInstalledCode getInstalledCode(String name, boolean withUnsafePrefix) throws Exception {
265         final ResolvedJavaMethod javaMethod = withUnsafePrefix ? getResolvedJavaMethod(WriteBarrierAdditionTest.class, name, Unsafe.class, Object.class, Object.class, Object.class)
266                         : getResolvedJavaMethod(WriteBarrierAdditionTest.class, name, Object.class, Object.class, Object.class);
267         final HotSpotInstalledCode installedCode = (HotSpotInstalledCode) getCode(javaMethod);
268         return installedCode;
269     }
270 
271     @SuppressWarnings(&quot;try&quot;)
272     private void testHelper(final String snippetName, final int expectedBarriers) throws Exception, SecurityException {
273         ResolvedJavaMethod snippet = getResolvedJavaMethod(snippetName);
274         DebugContext debug = getDebugContext();
275         try (DebugContext.Scope s = debug.scope(&quot;WriteBarrierAdditionTest&quot;, snippet)) {
276             StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO, debug);
277             HighTierContext highContext = getDefaultHighTierContext();
278             MidTierContext midContext = new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, graph.getProfilingInfo());
279             new InliningPhase(new InlineEverythingPolicy(), new CanonicalizerPhase()).apply(graph, highContext);
280             new CanonicalizerPhase().apply(graph, highContext);
281             new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, highContext);
282             new GuardLoweringPhase().apply(graph, midContext);
283             new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.MID_TIER).apply(graph, midContext);
284             new WriteBarrierAdditionPhase(config).apply(graph);
285             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;After Write Barrier Addition&quot;);
286 
287             int barriers = 0;
288             if (config.useG1GC) {
289                 barriers = graph.getNodes().filter(G1ReferentFieldReadBarrier.class).count() + graph.getNodes().filter(G1PreWriteBarrier.class).count() +
290                                 graph.getNodes().filter(G1PostWriteBarrier.class).count();
291             } else {
292                 barriers = graph.getNodes().filter(SerialWriteBarrier.class).count();
293             }
294             if (expectedBarriers != barriers) {
295                 Assert.assertEquals(getScheduledGraphString(graph), expectedBarriers, barriers);
296             }
297             for (WriteNode write : graph.getNodes().filter(WriteNode.class)) {
298                 if (config.useG1GC) {
299                     if (write.getBarrierType() != BarrierType.NONE) {
300                         Assert.assertEquals(1, write.successors().count());
301                         Assert.assertTrue(write.next() instanceof G1PostWriteBarrier);
302                         Assert.assertTrue(write.predecessor() instanceof G1PreWriteBarrier);
303                     }
304                 } else {
305                     if (write.getBarrierType() != BarrierType.NONE) {
306                         Assert.assertEquals(1, write.successors().count());
307                         Assert.assertTrue(write.next() instanceof SerialWriteBarrier);
308                     }
309                 }
310             }
311 
312             for (ReadNode read : graph.getNodes().filter(ReadNode.class)) {
313                 if (read.getBarrierType() != BarrierType.NONE) {
314                     Assert.assertTrue(read.getAddress() instanceof OffsetAddressNode);
315                     JavaConstant constDisp = ((OffsetAddressNode) read.getAddress()).getOffset().asJavaConstant();
316                     Assert.assertNotNull(constDisp);
317                     Assert.assertEquals(referentOffset(getMetaAccess()), constDisp.asLong());
318                     Assert.assertTrue(config.useG1GC);
319                     Assert.assertEquals(BarrierType.PRECISE, read.getBarrierType());
320                     Assert.assertTrue(read.next() instanceof G1ReferentFieldReadBarrier);
321                 }
322             }
323         } catch (Throwable e) {
324             throw debug.handle(e);
325         }
326     }
327 
328     private void test2(final String snippet, Object... args) throws Exception {
329         HotSpotInstalledCode code = getInstalledCode(snippet, args[0] instanceof Unsafe);
330         code.executeVarargs(args);
331     }
332 }
    </pre>
  </body>
</html>
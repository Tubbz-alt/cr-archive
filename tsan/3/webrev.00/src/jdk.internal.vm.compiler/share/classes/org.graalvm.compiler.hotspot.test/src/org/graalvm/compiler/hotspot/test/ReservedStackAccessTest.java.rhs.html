<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/ReservedStackAccessTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
 27 import java.io.IOException;
<a name="2" id="anc2"></a>
 28 import java.util.List;
<a name="3" id="anc3"></a><span class="line-added"> 29 import java.util.concurrent.locks.ReentrantLock;</span>
 30 
 31 import org.graalvm.compiler.test.SubprocessUtil;
 32 import org.graalvm.compiler.test.SubprocessUtil.Subprocess;
<a name="4" id="anc4"></a>
 33 import org.junit.Assume;
 34 import org.junit.Before;
 35 import org.junit.Test;
 36 
 37 public class ReservedStackAccessTest extends HotSpotGraalCompilerTest {
 38     @Before
 39     public void check() {
 40         Assume.assumeTrue(runtime().getVMConfig().enableStackReservedZoneAddress != 0);
 41     }
 42 
 43     public void stackAccessTest() {
 44         Assume.assumeTrue(runtime().getVMConfig().enableStackReservedZoneAddress != 0);
 45 
 46         int passed = 0;
 47         for (int i = 0; i &lt; 1000; i++) {
 48             // Each iteration has to be executed by a new thread. The test
 49             // relies on the random size area pushed by the VM at the beginning
 50             // of the stack of each Java thread it creates.
 51             RunWithSOEContext r = new RunWithSOEContext(new ReentrantLockTest(), 256);
 52             Thread thread = new Thread(r);
 53             thread.start();
 54             try {
 55                 thread.join();
 56                 assertTrue(r.result.equals(&quot;PASSED&quot;), r.result);
 57                 ++passed;
 58             } catch (InterruptedException ex) {
 59             }
 60         }
 61         System.out.println(&quot;RESULT: &quot; + (passed == 1000 ? &quot;PASSED&quot; : &quot;FAILED&quot;));
 62     }
 63 
 64     public static void main(String[] args) {
 65         new ReservedStackAccessTest().stackAccessTest();
 66     }
 67 
 68     @Test
 69     public void run() throws IOException, InterruptedException {
<a name="5" id="anc5"></a><span class="line-added"> 70         Assume.assumeFalse(&quot;GR-19833&quot;, runtime().getVMConfig().osName.equals(&quot;windows&quot;));</span>
 71         Assume.assumeTrue(runtime().getVMConfig().enableStackReservedZoneAddress != 0);
 72         List&lt;String&gt; vmArgs = SubprocessUtil.withoutDebuggerArguments(SubprocessUtil.getVMCommandLine());
 73         vmArgs.add(&quot;-XX:+UseJVMCICompiler&quot;);
 74         vmArgs.add(&quot;-Dgraal.Inline=false&quot;);
 75         vmArgs.add(&quot;-XX:CompileCommand=exclude,java/util/concurrent/locks/AbstractOwnableSynchronizer.setExclusiveOwnerThread&quot;);
<a name="6" id="anc6"></a><span class="line-added"> 76         vmArgs.add(SubprocessUtil.PACKAGE_OPENING_OPTIONS);</span>
 77 
 78         // Avoid SOE in HotSpotJVMCIRuntime.adjustCompilationLevel
 79         vmArgs.add(&quot;-Dgraal.CompileGraalWithC1Only=false&quot;);
 80 
 81         Subprocess proc = SubprocessUtil.java(vmArgs, ReservedStackAccessTest.class.getName());
 82         boolean passed = false;
 83         for (String line : proc.output) {
 84             if (line.equals(&quot;RESULT: PASSED&quot;)) {
 85                 passed = true;
 86             }
 87         }
 88         if (!passed) {
 89             System.err.println(proc);
 90         }
 91         assertTrue(passed);
 92     }
 93 
 94     static class ReentrantLockTest {
 95 
 96         private ReentrantLock[] lockArray;
 97         // Frame sizes vary a lot between interpreted code and compiled code
 98         // so the lock array has to be big enough to cover all cases.
 99         // If test fails with message &quot;Not conclusive test&quot;, try to increase
100         // LOCK_ARRAY_SIZE value
101         private static final int LOCK_ARRAY_SIZE = 8192;
102         private boolean stackOverflowErrorReceived;
103         StackOverflowError soe = null;
104         int index = -1;
105 
106         public void initialize() {
107             lockArray = new ReentrantLock[LOCK_ARRAY_SIZE];
108             for (int i = 0; i &lt; LOCK_ARRAY_SIZE; i++) {
109                 lockArray[i] = new ReentrantLock();
110             }
111             stackOverflowErrorReceived = false;
112         }
113 
114         public String getResult() {
115             if (!stackOverflowErrorReceived) {
116                 return &quot;ERROR: Not conclusive test: no StackOverflowError received&quot;;
117             }
118             for (int i = 0; i &lt; LOCK_ARRAY_SIZE; i++) {
119                 if (lockArray[i].isLocked()) {
120                     if (!lockArray[i].isHeldByCurrentThread()) {
121                         StringBuilder s = new StringBuilder();
122                         s.append(&quot;FAILED: ReentrantLock &quot;);
123                         s.append(i);
124                         s.append(&quot; looks corrupted&quot;);
125                         return s.toString();
126                     }
127                 }
128             }
129             return &quot;PASSED&quot;;
130         }
131 
132         public void run() {
133             try {
134                 lockAndCall(0);
135             } catch (StackOverflowError e) {
136                 soe = e;
137                 stackOverflowErrorReceived = true;
138             }
139         }
140 
141         private void lockAndCall(int i) {
142             index = i;
143             if (i &lt; LOCK_ARRAY_SIZE) {
144                 lockArray[i].lock();
145                 lockAndCall(i + 1);
146             }
147         }
148     }
149 
150     static class RunWithSOEContext implements Runnable {
151 
152         int counter;
153         int deframe;
154         int decounter;
155         int setupSOEFrame;
156         int testStartFrame;
157         ReentrantLockTest test;
158         String result = &quot;FAILED: no result&quot;;
159 
160         RunWithSOEContext(ReentrantLockTest test, int deframe) {
161             this.test = test;
162             this.deframe = deframe;
163         }
164 
165         @Override
166         public void run() {
167             counter = 0;
168             decounter = deframe;
169             test.initialize();
170             recursiveCall();
171             System.out.println(&quot;Framework got StackOverflowError at frame = &quot; + counter);
172             System.out.println(&quot;Test started execution at frame = &quot; + (counter - deframe));
173             result = test.getResult();
174         }
175 
176         @SuppressWarnings(&quot;unused&quot;)
177         void recursiveCall() {
178             // Unused local variables to increase the frame size
179             long l1;
180             long l2;
181             long l3;
182             long l4;
183             long l5;
184             long l6;
185             long l7;
186             long l8;
187             long l9;
188             long l10;
189             long l11;
190             long l12;
191             long l13;
192             long l14;
193             long l15;
194             long l16;
195             long l17;
196             long l18;
197             long l19;
198             long l20;
199             long l21;
200             long l22;
201             long l23;
202             long l24;
203             long l25;
204             long l26;
205             long l27;
206             long l28;
207             long l30;
208             long l31;
209             long l32;
210             long l33;
211             long l34;
212             long l35;
213             long l36;
214             long l37;
215             counter++;
216             try {
217                 recursiveCall();
218             } catch (StackOverflowError e) {
219             }
220             decounter--;
221             if (decounter == 0) {
222                 setupSOEFrame = counter;
223                 testStartFrame = counter - deframe;
224                 test.run();
225             }
226         }
227     }
228 
229 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilationWrapperTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompileTheWorldTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,17 ***</span>
  
  package org.graalvm.compiler.hotspot.test;
  
  import static java.util.Collections.singletonList;
  import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Print;
<span class="line-modified">! import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAction;</span>
  import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
  import static org.graalvm.compiler.core.test.ReflectionOptionDescriptors.extractEntries;
  import static org.graalvm.compiler.debug.MemUseTrackerKey.getCurrentThreadAllocatedBytes;
  import static org.graalvm.compiler.hotspot.test.CompileTheWorld.Options.DESCRIPTORS;
<span class="line-modified">! import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;</span>
  
  import java.io.Closeable;
  import java.io.File;
  import java.io.IOException;
  import java.lang.annotation.Annotation;
  import java.lang.reflect.Constructor;
<span class="line-new-header">--- 24,21 ---</span>
  
  package org.graalvm.compiler.hotspot.test;
  
  import static java.util.Collections.singletonList;
  import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Print;
<span class="line-modified">! import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAsFailure;</span>
  import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
  import static org.graalvm.compiler.core.test.ReflectionOptionDescriptors.extractEntries;
  import static org.graalvm.compiler.debug.MemUseTrackerKey.getCurrentThreadAllocatedBytes;
<span class="line-added">+ import static org.graalvm.compiler.hotspot.CompilationTask.CompilationTime;</span>
<span class="line-added">+ import static org.graalvm.compiler.hotspot.CompilationTask.CompiledAndInstalledBytecodes;</span>
  import static org.graalvm.compiler.hotspot.test.CompileTheWorld.Options.DESCRIPTORS;
<span class="line-modified">! import static org.graalvm.compiler.hotspot.test.CompileTheWorld.Options.InvalidateInstalledCode;</span>
<span class="line-added">+ import static sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;</span>
  
<span class="line-added">+ import java.io.ByteArrayOutputStream;</span>
  import java.io.Closeable;
  import java.io.File;
  import java.io.IOException;
  import java.lang.annotation.Annotation;
  import java.lang.reflect.Constructor;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,28 ***</span>
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;
  import java.util.stream.Collectors;
  
  import jdk.internal.vm.compiler.collections.EconomicMap;
<span class="line-modified">! import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;</span>
  import org.graalvm.compiler.api.replacements.Snippet;
  import org.graalvm.compiler.bytecode.Bytecodes;
  import org.graalvm.compiler.core.CompilerThreadFactory;
  import org.graalvm.compiler.core.test.ReflectionOptionDescriptors;
  import org.graalvm.compiler.debug.DebugOptions;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.debug.MethodFilter;
  import org.graalvm.compiler.debug.TTY;
  import org.graalvm.compiler.hotspot.CompilationTask;
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  import org.graalvm.compiler.hotspot.HotSpotGraalCompiler;
  import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
  import org.graalvm.compiler.options.OptionDescriptors;
  import org.graalvm.compiler.options.OptionKey;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.options.OptionsParser;
  import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
  
  import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;
  import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
  import jdk.vm.ci.hotspot.HotSpotInstalledCode;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
<span class="line-new-header">--- 75,38 ---</span>
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;
  import java.util.stream.Collectors;
  
  import jdk.internal.vm.compiler.collections.EconomicMap;
<span class="line-modified">! import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;</span>
  import org.graalvm.compiler.api.replacements.Snippet;
  import org.graalvm.compiler.bytecode.Bytecodes;
  import org.graalvm.compiler.core.CompilerThreadFactory;
<span class="line-added">+ import org.graalvm.compiler.core.phases.HighTier;</span>
  import org.graalvm.compiler.core.test.ReflectionOptionDescriptors;
  import org.graalvm.compiler.debug.DebugOptions;
<span class="line-added">+ import org.graalvm.compiler.debug.GlobalMetrics;</span>
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.debug.MethodFilter;
<span class="line-added">+ import org.graalvm.compiler.debug.MetricKey;</span>
  import org.graalvm.compiler.debug.TTY;
  import org.graalvm.compiler.hotspot.CompilationTask;
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  import org.graalvm.compiler.hotspot.HotSpotGraalCompiler;
<span class="line-added">+ import org.graalvm.compiler.hotspot.HotSpotGraalRuntime;</span>
  import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
<span class="line-added">+ import org.graalvm.compiler.hotspot.test.CompileTheWorld.LibGraalParams.StackTraceBuffer;</span>
  import org.graalvm.compiler.options.OptionDescriptors;
  import org.graalvm.compiler.options.OptionKey;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.options.OptionsParser;
<span class="line-added">+ import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;</span>
  import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
<span class="line-added">+ import org.graalvm.compiler.api.test.ModuleSupport;</span>
<span class="line-added">+ import jdk.internal.vm.compiler.libgraal.LibGraal;</span>
<span class="line-added">+ import jdk.internal.vm.compiler.libgraal.LibGraalScope;</span>
<span class="line-added">+ import org.graalvm.util.OptionsEncoder;</span>
  
  import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;
  import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
  import jdk.vm.ci.hotspot.HotSpotInstalledCode;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,20 ***</span>
  import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
  import jdk.vm.ci.meta.ConstantPool;
  import jdk.vm.ci.meta.MetaAccessProvider;
  import jdk.vm.ci.runtime.JVMCI;
  import jdk.vm.ci.runtime.JVMCICompiler;
  
  /**
   * This class implements compile-the-world functionality with JVMCI.
   */
  public final class CompileTheWorld {
  
      /**
<span class="line-modified">!      * Magic token to denote that JDK classes are to be compiled. If</span>
<span class="line-modified">!      * {@link JavaVersionUtil#Java8OrEarlier}, then the classes in {@code rt.jar} are compiled.</span>
<span class="line-removed">-      * Otherwise the classes in the Java runtime image are compiled.</span>
       */
      public static final String SUN_BOOT_CLASS_PATH = &quot;sun.boot.class.path&quot;;
  
      /**
       * Magic token to denote the classes in the Java runtime image (i.e. in the {@code jrt:/} file
<span class="line-new-header">--- 114,24 ---</span>
  import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
  import jdk.vm.ci.meta.ConstantPool;
  import jdk.vm.ci.meta.MetaAccessProvider;
  import jdk.vm.ci.runtime.JVMCI;
  import jdk.vm.ci.runtime.JVMCICompiler;
<span class="line-added">+ import sun.misc.Unsafe;</span>
  
  /**
   * This class implements compile-the-world functionality with JVMCI.
   */
  public final class CompileTheWorld {
  
<span class="line-added">+     static {</span>
<span class="line-added">+         ModuleSupport.exportAndOpenAllPackagesToUnnamed(&quot;jdk.internal.vm.compiler&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Magic token to denote that JDK classes are to be compiled. For JDK 8, the classes in</span>
<span class="line-modified">!      * {@code rt.jar} are compiled. Otherwise the classes in the Java runtime image are compiled.</span>
       */
      public static final String SUN_BOOT_CLASS_PATH = &quot;sun.boot.class.path&quot;;
  
      /**
       * Magic token to denote the classes in the Java runtime image (i.e. in the {@code jrt:/} file
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,21 ***</span>
       * @param options a space separated set of option value settings with each option setting in a
       *            {@code -Dgraal.&lt;name&gt;=&lt;value&gt;} format but without the leading {@code -Dgraal.}.
       *            Ignored if null.
       */
      public static EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; parseOptions(String options) {
          if (options != null) {
              EconomicMap&lt;String, String&gt; optionSettings = EconomicMap.create();
              for (String optionSetting : options.split(&quot;\\s+|#&quot;)) {
                  OptionsParser.parseOptionSettingTo(optionSetting, optionSettings);
              }
<span class="line-removed">-             EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; values = OptionValues.newOptionMap();</span>
              ServiceLoader&lt;OptionDescriptors&gt; loader = ServiceLoader.load(OptionDescriptors.class, OptionDescriptors.class.getClassLoader());
              OptionsParser.parseOptions(optionSettings, values, loader);
<span class="line-removed">-             return values;</span>
          }
<span class="line-modified">!         return EconomicMap.create();</span>
      }
  
      private final HotSpotJVMCIRuntime jvmciRuntime;
  
      private final HotSpotGraalCompiler compiler;
<span class="line-new-header">--- 143,23 ---</span>
       * @param options a space separated set of option value settings with each option setting in a
       *            {@code -Dgraal.&lt;name&gt;=&lt;value&gt;} format but without the leading {@code -Dgraal.}.
       *            Ignored if null.
       */
      public static EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; parseOptions(String options) {
<span class="line-added">+         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; values = OptionValues.newOptionMap();</span>
          if (options != null) {
              EconomicMap&lt;String, String&gt; optionSettings = EconomicMap.create();
              for (String optionSetting : options.split(&quot;\\s+|#&quot;)) {
                  OptionsParser.parseOptionSettingTo(optionSetting, optionSettings);
              }
              ServiceLoader&lt;OptionDescriptors&gt; loader = ServiceLoader.load(OptionDescriptors.class, OptionDescriptors.class.getClassLoader());
              OptionsParser.parseOptions(optionSettings, values, loader);
          }
<span class="line-modified">!         if (!values.containsKey(HighTier.Options.Inline)) {</span>
<span class="line-added">+             values.put(HighTier.Options.Inline, false);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return values;</span>
      }
  
      private final HotSpotJVMCIRuntime jvmciRuntime;
  
      private final HotSpotGraalCompiler compiler;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,10 ***</span>
<span class="line-new-header">--- 183,17 ---</span>
       *
       * @see Options#StopAt
       */
      private final int stopAt;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Max classes to compile.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @see Options#MaxClasses</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final int maxClasses;</span>
<span class="line-added">+ </span>
      /** Only compile methods matching one of the filters in this array if the array is non-null. */
      private final MethodFilter[] methodFilters;
  
      /** Exclude methods matching one of the filters in this array if the array is non-null. */
      private final MethodFilter[] excludeMethodFilters;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,83 ***</span>
       */
      private boolean running;
  
      private ThreadPoolExecutor threadPool;
  
<span class="line-modified">!     private OptionValues currentOptions;</span>
<span class="line-modified">!     private final UnmodifiableEconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; compilationOptions;</span>
  
      /**
       * Creates a compile-the-world instance.
       *
       * @param files {@link File#pathSeparator} separated list of Zip/Jar files to compile
       * @param startAt index of the class file to start compilation at
       * @param stopAt index of the class file to stop compilation at
       * @param methodFilters
       * @param excludeMethodFilters
       */
<span class="line-modified">!     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalCompiler compiler, String files, int startAt, int stopAt, String methodFilters, String excludeMethodFilters,</span>
<span class="line-modified">!                     boolean verbose, OptionValues initialOptions, EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; compilationOptions) {</span>
          this.jvmciRuntime = jvmciRuntime;
          this.compiler = compiler;
          this.inputClassPath = files;
<span class="line-modified">!         this.startAt = startAt;</span>
<span class="line-modified">!         this.stopAt = stopAt;</span>
          this.methodFilters = methodFilters == null || methodFilters.isEmpty() ? null : MethodFilter.parse(methodFilters);
          this.excludeMethodFilters = excludeMethodFilters == null || excludeMethodFilters.isEmpty() ? null : MethodFilter.parse(excludeMethodFilters);
          this.verbose = verbose;
<span class="line-modified">!         this.currentOptions = initialOptions;</span>
  
          // Copy the initial options and add in any extra options
<span class="line-modified">!         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; compilationOptionsCopy = EconomicMap.create(initialOptions.getMap());</span>
<span class="line-removed">-         compilationOptionsCopy.putAll(compilationOptions);</span>
  
          // We want to see stack traces when a method fails to compile
<span class="line-modified">!         CompilationBailoutAction.putIfAbsent(compilationOptionsCopy, Print);</span>
<span class="line-modified">!         CompilationFailureAction.putIfAbsent(compilationOptionsCopy, Print);</span>
  
          // By default only report statistics for the CTW threads themselves
<span class="line-modified">!         DebugOptions.MetricsThreadFilter.putIfAbsent(compilationOptionsCopy, &quot;^CompileTheWorld&quot;);</span>
<span class="line-modified">!         this.compilationOptions = compilationOptionsCopy;</span>
      }
  
<span class="line-modified">!     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalCompiler compiler, OptionValues options) {</span>
<span class="line-modified">!         this(jvmciRuntime, compiler, Options.Classpath.getValue(options),</span>
<span class="line-modified">!                         Options.StartAt.getValue(options),</span>
<span class="line-modified">!                         Options.StopAt.getValue(options),</span>
<span class="line-modified">!                         Options.MethodFilter.getValue(options),</span>
<span class="line-modified">!                         Options.ExcludeMethodFilter.getValue(options),</span>
<span class="line-modified">!                         Options.Verbose.getValue(options),</span>
<span class="line-modified">!                         options,</span>
<span class="line-modified">!                         parseOptions(Options.Config.getValue(options)));</span>
      }
  
      /**
       * Compiles all methods in all classes in {@link #inputClassPath}. If {@link #inputClassPath}
       * equals {@link #SUN_BOOT_CLASS_PATH} the boot classes are used.
       */
      public void compile() throws Throwable {
<span class="line-modified">!         if (SUN_BOOT_CLASS_PATH.equals(inputClassPath)) {</span>
<span class="line-modified">!             String bcpEntry = null;</span>
<span class="line-modified">!             if (Java8OrEarlier) {</span>
<span class="line-modified">!                 final String[] entries = System.getProperty(SUN_BOOT_CLASS_PATH).split(File.pathSeparator);</span>
<span class="line-modified">!                 for (int i = 0; i &lt; entries.length &amp;&amp; bcpEntry == null; i++) {</span>
<span class="line-modified">!                     String entry = entries[i];</span>
<span class="line-modified">!                     File entryFile = new File(entry);</span>
<span class="line-modified">!                     if (entryFile.getName().endsWith(&quot;rt.jar&quot;) &amp;&amp; entryFile.isFile()) {</span>
<span class="line-modified">!                         bcpEntry = entry;</span>
                      }
                  }
<span class="line-modified">!                 if (bcpEntry == null) {</span>
<span class="line-removed">-                     throw new GraalError(&quot;Could not find rt.jar on boot class path %s&quot;, System.getProperty(SUN_BOOT_CLASS_PATH));</span>
<span class="line-removed">-                 }</span>
              } else {
<span class="line-modified">!                 bcpEntry = JRT_CLASS_PATH_ENTRY;</span>
              }
<span class="line-removed">-             compile(bcpEntry);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             compile(inputClassPath);</span>
          }
      }
  
      public void println() {
          println(&quot;&quot;);
<span class="line-new-header">--- 211,224 ---</span>
       */
      private boolean running;
  
      private ThreadPoolExecutor threadPool;
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Values for {@link CompileTheWorld.Options}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final OptionValues harnessOptions;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Option values used during compilation.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final OptionValues compilerOptions;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Manages native memory buffers for passing arguments into libgraal and receiving return</span>
<span class="line-added">+      * values. The native memory buffers are freed when this object is {@linkplain #close() closed}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static class LibGraalParams implements AutoCloseable {</span>
<span class="line-added">+ </span>
<span class="line-added">+         static {</span>
<span class="line-added">+             LibGraal.registerNativeMethods(HotSpotJVMCIRuntime.runtime(), CompileTheWorld.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Native memory containing {@linkplain OptionsEncoder encoded} {@link OptionValues}.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         static class OptionsBuffer {</span>
<span class="line-added">+             private long address;</span>
<span class="line-added">+             final int size;</span>
<span class="line-added">+             final int hash;</span>
<span class="line-added">+ </span>
<span class="line-added">+             OptionsBuffer(OptionValues options) {</span>
<span class="line-added">+                 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span>
<span class="line-added">+                 UnmodifiableMapCursor&lt;OptionKey&lt;?&gt;, Object&gt; cursor = options.getMap().getEntries();</span>
<span class="line-added">+                 while (cursor.advance()) {</span>
<span class="line-added">+                     final OptionKey&lt;?&gt; key = cursor.getKey();</span>
<span class="line-added">+                     Object value = cursor.getValue();</span>
<span class="line-added">+                     map.put(key.getName(), value);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 byte[] encoded = OptionsEncoder.encode(map);</span>
<span class="line-added">+                 size = encoded.length;</span>
<span class="line-added">+                 hash = Arrays.hashCode(encoded);</span>
<span class="line-added">+                 address = UNSAFE.allocateMemory(encoded.length);</span>
<span class="line-added">+                 UNSAFE.copyMemory(encoded, ARRAY_BYTE_BASE_OFFSET, null, address, size);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             long getAddress() {</span>
<span class="line-added">+                 if (address == 0) {</span>
<span class="line-added">+                     throw new IllegalStateException();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return address;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             void free() {</span>
<span class="line-added">+                 if (address != 0) {</span>
<span class="line-added">+                     UNSAFE.freeMemory(address);</span>
<span class="line-added">+                     address = 0;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Manages native memory for receiving a {@linkplain Throwable#printStackTrace() stack</span>
<span class="line-added">+          * trace} from libgraal serialized via {@link ByteArrayOutputStream} to a byte array.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         static class StackTraceBuffer {</span>
<span class="line-added">+             final int size;</span>
<span class="line-added">+             private long address;</span>
<span class="line-added">+ </span>
<span class="line-added">+             StackTraceBuffer(int size) {</span>
<span class="line-added">+                 this.size = size;</span>
<span class="line-added">+                 address = UNSAFE.allocateMemory(size);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             void free() {</span>
<span class="line-added">+                 if (address != 0L) {</span>
<span class="line-added">+                     UNSAFE.freeMemory(address);</span>
<span class="line-added">+                     address = 0L;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             long getAddress() {</span>
<span class="line-added">+                 if (address == 0) {</span>
<span class="line-added">+                     throw new IllegalStateException();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return address;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         final OptionsBuffer options;</span>
<span class="line-added">+ </span>
<span class="line-added">+         private final List&lt;StackTraceBuffer&gt; stackTraceBuffers = new ArrayList&lt;&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Gets a stack trace buffer for the current thread.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         StackTraceBuffer getStackTraceBuffer() {</span>
<span class="line-added">+             return stackTraceBuffer.get();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private final ThreadLocal&lt;StackTraceBuffer&gt; stackTraceBuffer = new ThreadLocal&lt;StackTraceBuffer&gt;() {</span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             protected StackTraceBuffer initialValue() {</span>
<span class="line-added">+                 StackTraceBuffer buffer = new StackTraceBuffer(10_000);</span>
<span class="line-added">+                 synchronized (stackTraceBuffers) {</span>
<span class="line-added">+                     stackTraceBuffers.add(buffer);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return buffer;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         LibGraalParams(OptionValues options) {</span>
<span class="line-added">+             this.options = new OptionsBuffer(options);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void close() {</span>
<span class="line-added">+             options.free();</span>
<span class="line-added">+             synchronized (stackTraceBuffers) {</span>
<span class="line-added">+                 for (StackTraceBuffer buffer : stackTraceBuffers) {</span>
<span class="line-added">+                     buffer.free();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 stackTraceBuffers.clear();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      /**
       * Creates a compile-the-world instance.
       *
       * @param files {@link File#pathSeparator} separated list of Zip/Jar files to compile
       * @param startAt index of the class file to start compilation at
       * @param stopAt index of the class file to stop compilation at
<span class="line-added">+      * @param maxClasses maximum number of classes to process</span>
       * @param methodFilters
       * @param excludeMethodFilters
<span class="line-added">+      * @param harnessOptions values for {@link CompileTheWorld.Options}</span>
<span class="line-added">+      * @param compilerOptions option values used by the compiler</span>
       */
<span class="line-modified">!     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,</span>
<span class="line-modified">!                     HotSpotGraalCompiler compiler,</span>
<span class="line-added">+                     String files,</span>
<span class="line-added">+                     int startAt,</span>
<span class="line-added">+                     int stopAt,</span>
<span class="line-added">+                     int maxClasses,</span>
<span class="line-added">+                     String methodFilters,</span>
<span class="line-added">+                     String excludeMethodFilters,</span>
<span class="line-added">+                     boolean verbose,</span>
<span class="line-added">+                     OptionValues harnessOptions,</span>
<span class="line-added">+                     OptionValues compilerOptions) {</span>
          this.jvmciRuntime = jvmciRuntime;
          this.compiler = compiler;
          this.inputClassPath = files;
<span class="line-modified">!         this.startAt = Math.max(startAt, 1);</span>
<span class="line-modified">!         this.stopAt = Math.max(stopAt, 1);</span>
<span class="line-added">+         this.maxClasses = Math.max(maxClasses, 1);</span>
          this.methodFilters = methodFilters == null || methodFilters.isEmpty() ? null : MethodFilter.parse(methodFilters);
          this.excludeMethodFilters = excludeMethodFilters == null || excludeMethodFilters.isEmpty() ? null : MethodFilter.parse(excludeMethodFilters);
          this.verbose = verbose;
<span class="line-modified">!         this.harnessOptions = harnessOptions;</span>
  
          // Copy the initial options and add in any extra options
<span class="line-modified">!         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; compilerOptionsMap = EconomicMap.create(compilerOptions.getMap());</span>
  
          // We want to see stack traces when a method fails to compile
<span class="line-modified">!         CompilationBailoutAsFailure.putIfAbsent(compilerOptionsMap, true);</span>
<span class="line-modified">!         CompilationFailureAction.putIfAbsent(compilerOptionsMap, Print);</span>
  
          // By default only report statistics for the CTW threads themselves
<span class="line-modified">!         DebugOptions.MetricsThreadFilter.putIfAbsent(compilerOptionsMap, &quot;^CompileTheWorld&quot;);</span>
<span class="line-modified">!         this.compilerOptions = new OptionValues(compilerOptionsMap);</span>
      }
  
<span class="line-modified">!     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,</span>
<span class="line-modified">!                     HotSpotGraalCompiler compiler,</span>
<span class="line-modified">!                     OptionValues harnessOptions,</span>
<span class="line-modified">!                     OptionValues compilerOptions) {</span>
<span class="line-modified">!         this(jvmciRuntime, compiler, Options.Classpath.getValue(harnessOptions),</span>
<span class="line-modified">!                         Options.StartAt.getValue(harnessOptions),</span>
<span class="line-modified">!                         Options.StopAt.getValue(harnessOptions),</span>
<span class="line-modified">!                         Options.MaxClasses.getValue(harnessOptions),</span>
<span class="line-modified">!                         Options.MethodFilter.getValue(harnessOptions),</span>
<span class="line-added">+                         Options.ExcludeMethodFilter.getValue(harnessOptions),</span>
<span class="line-added">+                         Options.Verbose.hasBeenSet(harnessOptions) ? Options.Verbose.getValue(harnessOptions) : !Options.MultiThreaded.getValue(harnessOptions),</span>
<span class="line-added">+                         harnessOptions,</span>
<span class="line-added">+                         new OptionValues(compilerOptions, parseOptions(Options.Config.getValue(harnessOptions))));</span>
      }
  
      /**
       * Compiles all methods in all classes in {@link #inputClassPath}. If {@link #inputClassPath}
       * equals {@link #SUN_BOOT_CLASS_PATH} the boot classes are used.
       */
<span class="line-added">+     @SuppressWarnings(&quot;try&quot;)</span>
      public void compile() throws Throwable {
<span class="line-modified">!         try (LibGraalParams libgraal = LibGraal.isAvailable() ? new LibGraalParams(compilerOptions) : null) {</span>
<span class="line-modified">!             if (SUN_BOOT_CLASS_PATH.equals(inputClassPath)) {</span>
<span class="line-modified">!                 String bcpEntry = null;</span>
<span class="line-modified">!                 if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-modified">!                     final String[] entries = System.getProperty(SUN_BOOT_CLASS_PATH).split(File.pathSeparator);</span>
<span class="line-modified">!                     for (int i = 0; i &lt; entries.length &amp;&amp; bcpEntry == null; i++) {</span>
<span class="line-modified">!                         String entry = entries[i];</span>
<span class="line-modified">!                         File entryFile = new File(entry);</span>
<span class="line-modified">!                         if (entryFile.getName().endsWith(&quot;rt.jar&quot;) &amp;&amp; entryFile.isFile()) {</span>
<span class="line-added">+                             bcpEntry = entry;</span>
<span class="line-added">+                         }</span>
                      }
<span class="line-added">+                     if (bcpEntry == null) {</span>
<span class="line-added">+                         throw new GraalError(&quot;Could not find rt.jar on boot class path %s&quot;, System.getProperty(SUN_BOOT_CLASS_PATH));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     bcpEntry = JRT_CLASS_PATH_ENTRY;</span>
                  }
<span class="line-modified">!                 compile(bcpEntry, libgraal);</span>
              } else {
<span class="line-modified">!                 compile(inputClassPath, libgraal);</span>
              }
          }
      }
  
      public void println() {
          println(&quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 484,70 ***</span>
              return false;
          }
          return true;
      }
  
      /**
       * Compiles all methods in all classes in a given class path.
       *
       * @param classPath class path denoting classes to compile
       * @throws IOException
       */
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     private void compile(String classPath) throws IOException {</span>
          final String[] entries = classPath.split(File.pathSeparator);
<span class="line-modified">!         long start = System.currentTimeMillis();</span>
          Map&lt;Thread, StackTraceElement[]&gt; initialThreads = Thread.getAllStackTraces();
  
<span class="line-modified">!         try {</span>
<span class="line-modified">!             // compile dummy method to get compiler initialized outside of the</span>
<span class="line-modified">!             // config debug override.</span>
<span class="line-modified">!             HotSpotResolvedJavaMethod dummyMethod = (HotSpotResolvedJavaMethod) JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(</span>
<span class="line-modified">!                             CompileTheWorld.class.getDeclaredMethod(&quot;dummy&quot;));</span>
<span class="line-modified">!             int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;</span>
<span class="line-modified">!             boolean useProfilingInfo = false;</span>
<span class="line-modified">!             boolean installAsDefault = false;</span>
<span class="line-modified">!             CompilationTask task = new CompilationTask(jvmciRuntime, compiler, new HotSpotCompilationRequest(dummyMethod, entryBCI, 0L), useProfilingInfo, installAsDefault, currentOptions);</span>
<span class="line-modified">!             task.runCompilation();</span>
<span class="line-modified">!         } catch (NoSuchMethodException | SecurityException e1) {</span>
<span class="line-modified">!             printStackTrace(e1);</span>
          }
  
          /*
           * Always use a thread pool, even for single threaded mode since it simplifies the use of
           * DebugValueThreadFilter to filter on the thread names.
           */
          int threadCount = 1;
<span class="line-modified">!         if (Options.MultiThreaded.getValue(currentOptions)) {</span>
<span class="line-modified">!             threadCount = Options.Threads.getValue(currentOptions);</span>
              if (threadCount == 0) {
                  threadCount = Runtime.getRuntime().availableProcessors();
              }
          } else {
              running = true;
          }
  
<span class="line-removed">-         OptionValues savedOptions = currentOptions;</span>
<span class="line-removed">-         currentOptions = new OptionValues(compilationOptions);</span>
          threadPool = new ThreadPoolExecutor(threadCount, threadCount, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), new CompilerThreadFactory(&quot;CompileTheWorld&quot;));
  
<span class="line-modified">!         try {</span>
<span class="line-modified">!             for (int i = 0; i &lt; entries.length; i++) {</span>
<span class="line-modified">!                 final String entry = entries[i];</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 ClassPathEntry cpe;</span>
<span class="line-modified">!                 if (entry.endsWith(&quot;.zip&quot;) || entry.endsWith(&quot;.jar&quot;)) {</span>
<span class="line-modified">!                     cpe = new JarClassPathEntry(entry);</span>
<span class="line-modified">!                 } else if (entry.equals(JRT_CLASS_PATH_ENTRY)) {</span>
<span class="line-modified">!                     cpe = new JRTClassPathEntry(entry, Options.LimitModules.getValue(currentOptions));</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     if (!new File(entry).isDirectory()) {</span>
<span class="line-removed">-                         println(&quot;CompileTheWorld : Skipped classes in &quot; + entry);</span>
<span class="line-removed">-                         println();</span>
<span class="line-removed">-                         continue;</span>
                      }
<span class="line-modified">!                     cpe = new DirClassPathEntry(entry);</span>
                  }
  
                  if (methodFilters == null || methodFilters.length == 0) {
                      println(&quot;CompileTheWorld : Compiling all classes in &quot; + entry);
                  } else {
<span class="line-new-header">--- 652,96 ---</span>
              return false;
          }
          return true;
      }
  
<span class="line-added">+     private ClassPathEntry openClassPathEntry(String entry) throws IOException {</span>
<span class="line-added">+         if (entry.endsWith(&quot;.zip&quot;) || entry.endsWith(&quot;.jar&quot;)) {</span>
<span class="line-added">+             return new JarClassPathEntry(entry);</span>
<span class="line-added">+         } else if (entry.equals(JRT_CLASS_PATH_ENTRY)) {</span>
<span class="line-added">+             return new JRTClassPathEntry(entry, Options.LimitModules.getValue(harnessOptions));</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             if (!new File(entry).isDirectory()) {</span>
<span class="line-added">+                 return null;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return new DirClassPathEntry(entry);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Compiles all methods in all classes in a given class path.
       *
       * @param classPath class path denoting classes to compile
       * @throws IOException
       */
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     private void compile(String classPath, LibGraalParams libgraal) throws IOException {</span>
          final String[] entries = classPath.split(File.pathSeparator);
<span class="line-modified">!         long start = System.nanoTime();</span>
          Map&lt;Thread, StackTraceElement[]&gt; initialThreads = Thread.getAllStackTraces();
  
<span class="line-modified">!         if (libgraal == null) {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 // compile dummy method to get compiler initialized outside of the</span>
<span class="line-modified">!                 // config debug override.</span>
<span class="line-modified">!                 HotSpotResolvedJavaMethod dummyMethod = (HotSpotResolvedJavaMethod) JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(</span>
<span class="line-modified">!                                 CompileTheWorld.class.getDeclaredMethod(&quot;dummy&quot;));</span>
<span class="line-modified">!                 int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;</span>
<span class="line-modified">!                 boolean useProfilingInfo = false;</span>
<span class="line-modified">!                 boolean installAsDefault = false;</span>
<span class="line-modified">!                 CompilationTask task = new CompilationTask(jvmciRuntime, compiler, new HotSpotCompilationRequest(dummyMethod, entryBCI, 0L), useProfilingInfo, installAsDefault);</span>
<span class="line-modified">!                 task.runCompilation(compilerOptions);</span>
<span class="line-modified">!             } catch (NoSuchMethodException | SecurityException e1) {</span>
<span class="line-added">+                 printStackTrace(e1);</span>
<span class="line-added">+             }</span>
          }
  
          /*
           * Always use a thread pool, even for single threaded mode since it simplifies the use of
           * DebugValueThreadFilter to filter on the thread names.
           */
          int threadCount = 1;
<span class="line-modified">!         if (Options.MultiThreaded.getValue(harnessOptions)) {</span>
<span class="line-modified">!             threadCount = Options.Threads.getValue(harnessOptions);</span>
              if (threadCount == 0) {
                  threadCount = Runtime.getRuntime().availableProcessors();
              }
          } else {
              running = true;
          }
  
          threadPool = new ThreadPoolExecutor(threadCount, threadCount, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), new CompilerThreadFactory(&quot;CompileTheWorld&quot;));
  
<span class="line-modified">!         int compileStartAt = startAt;</span>
<span class="line-modified">!         int compileStopAt = stopAt;</span>
<span class="line-modified">!         int compileStep = 1;</span>
<span class="line-modified">!         if (maxClasses != Integer.MAX_VALUE) {</span>
<span class="line-modified">!             int totalClassFileCount = 0;</span>
<span class="line-modified">!             for (String entry : entries) {</span>
<span class="line-modified">!                 try (ClassPathEntry cpe = openClassPathEntry(entry)) {</span>
<span class="line-modified">!                     if (cpe != null) {</span>
<span class="line-modified">!                         totalClassFileCount += cpe.getClassNames().size();</span>
                      }
<span class="line-modified">!                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             int lastClassFile = totalClassFileCount - 1;</span>
<span class="line-added">+             compileStartAt = Math.min(startAt, lastClassFile);</span>
<span class="line-added">+             compileStopAt = Math.min(stopAt, lastClassFile);</span>
<span class="line-added">+             int range = compileStopAt - compileStartAt + 1;</span>
<span class="line-added">+             if (maxClasses &lt; range) {</span>
<span class="line-added">+                 compileStep = range / maxClasses;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (int i = 0; i &lt; entries.length; i++) {</span>
<span class="line-added">+             final String entry = entries[i];</span>
<span class="line-added">+             try (ClassPathEntry cpe = openClassPathEntry(entry)) {</span>
<span class="line-added">+                 if (cpe == null) {</span>
<span class="line-added">+                     println(&quot;CompileTheWorld : Skipped classes in &quot; + entry);</span>
<span class="line-added">+                     println();</span>
<span class="line-added">+                     continue;</span>
                  }
  
                  if (methodFilters == null || methodFilters.length == 0) {
                      println(&quot;CompileTheWorld : Compiling all classes in &quot; + entry);
                  } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 563,16 ***</span>
                  ClassLoader loader = cpe.createClassLoader();
  
                  for (String className : cpe.getClassNames()) {
  
                      // Are we done?
<span class="line-modified">!                     if (classFileCounter &gt;= stopAt) {</span>
                          break;
                      }
  
                      classFileCounter++;
  
                      if (className.startsWith(&quot;jdk.management.&quot;) ||
                                      className.startsWith(&quot;jdk.internal.cmm.*&quot;) ||
                                      // GR-5881: The class initializer for
                                      // sun.tools.jconsole.OutputViewer
                                      // spawns non-daemon threads for redirecting sysout and syserr.
<span class="line-new-header">--- 757,20 ---</span>
                  ClassLoader loader = cpe.createClassLoader();
  
                  for (String className : cpe.getClassNames()) {
  
                      // Are we done?
<span class="line-modified">!                     if (classFileCounter &gt;= compileStopAt) {</span>
                          break;
                      }
  
                      classFileCounter++;
  
<span class="line-added">+                     if (compileStep &gt; 1 &amp;&amp; ((classFileCounter - compileStartAt) % compileStep) != 0) {</span>
<span class="line-added">+                         continue;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
                      if (className.startsWith(&quot;jdk.management.&quot;) ||
                                      className.startsWith(&quot;jdk.internal.cmm.*&quot;) ||
                                      // GR-5881: The class initializer for
                                      // sun.tools.jconsole.OutputViewer
                                      // spawns non-daemon threads for redirecting sysout and syserr.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 604,72 ***</span>
                              }
                              continue;
                          }
  
                          // Are we compiling this class?
<span class="line-modified">!                         if (classFileCounter &gt;= startAt) {</span>
<span class="line-removed">-                             println(&quot;CompileTheWorld (%d) : %s&quot;, classFileCounter, className);</span>
  
                              // Compile each constructor/method in the class.
                              for (Constructor&lt;?&gt; constructor : javaClass.getDeclaredConstructors()) {
                                  HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(constructor);
                                  if (canBeCompiled(javaMethod, constructor.getModifiers())) {
<span class="line-modified">!                                     compileMethod(javaMethod);</span>
                                  }
                              }
                              for (Method method : javaClass.getDeclaredMethods()) {
                                  HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(method);
                                  if (canBeCompiled(javaMethod, method.getModifiers())) {
<span class="line-modified">!                                     compileMethod(javaMethod);</span>
                                  }
                              }
  
                              // Also compile the class initializer if it exists
                              HotSpotResolvedJavaMethod clinit = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaType(javaClass).getClassInitializer();
                              if (clinit != null &amp;&amp; canBeCompiled(clinit, clinit.getModifiers())) {
<span class="line-modified">!                                 compileMethod(clinit);</span>
                              }
                          }
                      } catch (Throwable t) {
                          if (isClassIncluded(className)) {
                              println(&quot;CompileTheWorld (%d) : Skipping %s %s&quot;, classFileCounter, className, t.toString());
                              printStackTrace(t);
                          }
                      }
                  }
<span class="line-removed">-                 cpe.close();</span>
              }
<span class="line-removed">-         } finally {</span>
<span class="line-removed">-             currentOptions = savedOptions;</span>
          }
  
          if (!running) {
              startThreads();
          }
          int wakeups = 0;
<span class="line-modified">!         while (threadPool.getCompletedTaskCount() != threadPool.getTaskCount()) {</span>
              if (wakeups % 15 == 0) {
<span class="line-modified">!                 TTY.println(&quot;CompileTheWorld : Waiting for &quot; + (threadPool.getTaskCount() - threadPool.getCompletedTaskCount()) + &quot; compiles&quot;);</span>
              }
              try {
                  threadPool.awaitTermination(1, TimeUnit.SECONDS);
                  wakeups++;
              } catch (InterruptedException e) {
              }
          }
          threadPool = null;
  
<span class="line-modified">!         long elapsedTime = System.currentTimeMillis() - start;</span>
  
          println();
<span class="line-modified">!         if (Options.MultiThreaded.getValue(currentOptions)) {</span>
<span class="line-modified">!             TTY.println(&quot;CompileTheWorld : Done (%d classes, %d methods, %d ms elapsed, %d ms compile time, %d bytes of memory used)&quot;, classFileCounter, compiledMethodsCounter.get(), elapsedTime,</span>
<span class="line-modified">!                             compileTime.get(), memoryUsed.get());</span>
          } else {
<span class="line-modified">!             TTY.println(&quot;CompileTheWorld : Done (%d classes, %d methods, %d ms, %d bytes of memory used)&quot;, classFileCounter, compiledMethodsCounter.get(), compileTime.get(), memoryUsed.get());</span>
          }
  
          // Apart from the main thread, there should be only be daemon threads
          // alive now. If not, then a class initializer has probably started
          // a thread that could cause a deadlock while trying to exit the VM.
          // One known example of this is sun.tools.jconsole.OutputViewer which
          // spawns threads to redirect sysout and syserr. To help debug such
<span class="line-new-header">--- 802,86 ---</span>
                              }
                              continue;
                          }
  
                          // Are we compiling this class?
<span class="line-modified">!                         if (classFileCounter &gt;= compileStartAt) {</span>
  
<span class="line-added">+                             long start0 = System.nanoTime();</span>
                              // Compile each constructor/method in the class.
                              for (Constructor&lt;?&gt; constructor : javaClass.getDeclaredConstructors()) {
                                  HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(constructor);
                                  if (canBeCompiled(javaMethod, constructor.getModifiers())) {
<span class="line-modified">!                                     compileMethod(javaMethod, libgraal);</span>
                                  }
                              }
                              for (Method method : javaClass.getDeclaredMethods()) {
                                  HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(method);
                                  if (canBeCompiled(javaMethod, method.getModifiers())) {
<span class="line-modified">!                                     compileMethod(javaMethod, libgraal);</span>
                                  }
                              }
  
                              // Also compile the class initializer if it exists
                              HotSpotResolvedJavaMethod clinit = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaType(javaClass).getClassInitializer();
                              if (clinit != null &amp;&amp; canBeCompiled(clinit, clinit.getModifiers())) {
<span class="line-modified">!                                 compileMethod(clinit, libgraal);</span>
                              }
<span class="line-added">+                             println(&quot;CompileTheWorld (%d) : %s (%d us)&quot;, classFileCounter, className, (System.nanoTime() - start0) / 1000);</span>
                          }
                      } catch (Throwable t) {
                          if (isClassIncluded(className)) {
                              println(&quot;CompileTheWorld (%d) : Skipping %s %s&quot;, classFileCounter, className, t.toString());
                              printStackTrace(t);
                          }
                      }
                  }
              }
          }
  
          if (!running) {
              startThreads();
          }
          int wakeups = 0;
<span class="line-modified">!         long lastCompletedTaskCount = 0;</span>
<span class="line-added">+         for (long completedTaskCount = threadPool.getCompletedTaskCount(); completedTaskCount != threadPool.getTaskCount(); completedTaskCount = threadPool.getCompletedTaskCount()) {</span>
              if (wakeups % 15 == 0) {
<span class="line-modified">!                 TTY.printf(&quot;CompileTheWorld : Waiting for %d compiles, just completed %d compiles%n&quot;, threadPool.getTaskCount() - completedTaskCount, completedTaskCount - lastCompletedTaskCount);</span>
<span class="line-added">+                 lastCompletedTaskCount = completedTaskCount;</span>
              }
              try {
                  threadPool.awaitTermination(1, TimeUnit.SECONDS);
                  wakeups++;
              } catch (InterruptedException e) {
              }
          }
<span class="line-added">+         threadPool.shutdown();</span>
          threadPool = null;
  
<span class="line-modified">!         long elapsedTime = System.nanoTime() - start;</span>
  
          println();
<span class="line-modified">!         int compiledClasses = classFileCounter &gt; compileStartAt ? classFileCounter - compileStartAt : 0;</span>
<span class="line-modified">!         if (Options.MultiThreaded.getValue(harnessOptions)) {</span>
<span class="line-modified">!             TTY.println(&quot;CompileTheWorld : Done (%d classes, %d methods, %d ms elapsed, %d ms compile time, %d bytes of memory used)&quot;, compiledClasses, compiledMethodsCounter.get(), elapsedTime,</span>
<span class="line-added">+                             compileTime.get() / 1000000, memoryUsed.get());</span>
          } else {
<span class="line-modified">!             TTY.println(&quot;CompileTheWorld : Done (%d classes, %d methods, %d ms, %d bytes of memory used)&quot;, compiledClasses, compiledMethodsCounter.get(), compileTime.get(), memoryUsed.get());</span>
          }
  
<span class="line-added">+         GlobalMetrics metricValues = ((HotSpotGraalRuntime) compiler.getGraalRuntime()).getMetricValues();</span>
<span class="line-added">+         EconomicMap&lt;MetricKey, Long&gt; map = metricValues.asKeyValueMap();</span>
<span class="line-added">+         Long compiledAndInstalledBytecodes = map.get(CompiledAndInstalledBytecodes);</span>
<span class="line-added">+         Long compilationTime = map.get(CompilationTime);</span>
<span class="line-added">+         if (compiledAndInstalledBytecodes != null &amp;&amp; compilationTime != null) {</span>
<span class="line-added">+             TTY.println(&quot;CompileTheWorld : Aggregate compile speed %d bytecodes per second (%d / %d)&quot;, (int) (compiledAndInstalledBytecodes / (compilationTime / 1000000000.0)),</span>
<span class="line-added">+                             compiledAndInstalledBytecodes, compilationTime);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         metricValues.print(compilerOptions);</span>
<span class="line-added">+         metricValues.clear();</span>
<span class="line-added">+ </span>
          // Apart from the main thread, there should be only be daemon threads
          // alive now. If not, then a class initializer has probably started
          // a thread that could cause a deadlock while trying to exit the VM.
          // One known example of this is sun.tools.jconsole.OutputViewer which
          // spawns threads to redirect sysout and syserr. To help debug such
</pre>
<hr />
<pre>
<span class="line-old-header">*** 710,58 ***</span>
              }
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     private void compileMethod(HotSpotResolvedJavaMethod method) throws InterruptedException, ExecutionException {</span>
          if (methodFilters != null &amp;&amp; !MethodFilter.matches(methodFilters, method)) {
              return;
          }
          if (excludeMethodFilters != null &amp;&amp; MethodFilter.matches(excludeMethodFilters, method)) {
              return;
          }
          Future&lt;?&gt; task = threadPool.submit(new Runnable() {
              @Override
              public void run() {
                  waitToRun();
<span class="line-modified">!                 OptionValues savedOptions = currentOptions;</span>
<span class="line-removed">-                 currentOptions = new OptionValues(compilationOptions);</span>
<span class="line-removed">-                 try {</span>
<span class="line-removed">-                     compileMethod(method, classFileCounter);</span>
<span class="line-removed">-                 } finally {</span>
<span class="line-removed">-                     currentOptions = savedOptions;</span>
<span class="line-removed">-                 }</span>
              }
          });
          if (threadPool.getCorePoolSize() == 1) {
              task.get();
          }
      }
  
      /**
       * Compiles a method and gathers some statistics.
       */
<span class="line-modified">!     private void compileMethod(HotSpotResolvedJavaMethod method, int counter) {</span>
          try {
<span class="line-modified">!             long start = System.currentTimeMillis();</span>
              long allocatedAtStart = getCurrentThreadAllocatedBytes();
<span class="line-removed">-             int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;</span>
<span class="line-removed">-             HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, 0L);</span>
              // For more stable CTW execution, disable use of profiling information
              boolean useProfilingInfo = false;
              boolean installAsDefault = false;
<span class="line-modified">!             CompilationTask task = new CompilationTask(jvmciRuntime, compiler, request, useProfilingInfo, installAsDefault, currentOptions);</span>
<span class="line-modified">!             task.runCompilation();</span>
  
              // Invalidate the generated code so the code cache doesn&#39;t fill up
<span class="line-modified">!             HotSpotInstalledCode installedCode = task.getInstalledCode();</span>
<span class="line-removed">-             if (installedCode != null) {</span>
                  installedCode.invalidate();
              }
  
              memoryUsed.getAndAdd(getCurrentThreadAllocatedBytes() - allocatedAtStart);
<span class="line-modified">!             compileTime.getAndAdd(System.currentTimeMillis() - start);</span>
              compiledMethodsCounter.incrementAndGet();
          } catch (Throwable t) {
              // Catch everything and print a message
              println(&quot;CompileTheWorld (%d) : Error compiling method: %s&quot;, counter, method.format(&quot;%H.%n(%p):%r&quot;));
              printStackTrace(t);
<span class="line-new-header">--- 922,101 ---</span>
              }
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     private void compileMethod(HotSpotResolvedJavaMethod method, LibGraalParams libgraal) throws InterruptedException, ExecutionException {</span>
          if (methodFilters != null &amp;&amp; !MethodFilter.matches(methodFilters, method)) {
              return;
          }
          if (excludeMethodFilters != null &amp;&amp; MethodFilter.matches(excludeMethodFilters, method)) {
              return;
          }
          Future&lt;?&gt; task = threadPool.submit(new Runnable() {
              @Override
              public void run() {
                  waitToRun();
<span class="line-modified">!                 compileMethod(method, classFileCounter, libgraal);</span>
              }
          });
          if (threadPool.getCorePoolSize() == 1) {
              task.get();
          }
      }
  
<span class="line-added">+     private static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Implemented by</span>
<span class="line-added">+      * {@code com.oracle.svm.graal.hotspot.libgraal.LibGraalEntryPoints.compileMethod}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static native long compileMethodInLibgraal(long isolateThread,</span>
<span class="line-added">+                     long methodHandle,</span>
<span class="line-added">+                     boolean useProfilingInfo,</span>
<span class="line-added">+                     boolean installAsDefault,</span>
<span class="line-added">+                     long optionsAddress,</span>
<span class="line-added">+                     int optionsSize,</span>
<span class="line-added">+                     int optionsHash,</span>
<span class="line-added">+                     long encodedThrowableBufferAddress,</span>
<span class="line-added">+                     int encodedThrowableBufferSize);</span>
<span class="line-added">+ </span>
      /**
       * Compiles a method and gathers some statistics.
       */
<span class="line-modified">!     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-added">+     private void compileMethod(HotSpotResolvedJavaMethod method, int counter, LibGraalParams libgraal) {</span>
          try {
<span class="line-modified">!             long start = System.nanoTime();</span>
              long allocatedAtStart = getCurrentThreadAllocatedBytes();
              // For more stable CTW execution, disable use of profiling information
              boolean useProfilingInfo = false;
              boolean installAsDefault = false;
<span class="line-modified">!             HotSpotInstalledCode installedCode;</span>
<span class="line-modified">!             if (libgraal != null) {</span>
<span class="line-added">+                 HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();</span>
<span class="line-added">+                 try (LibGraalScope scope = new LibGraalScope(runtime)) {</span>
<span class="line-added">+                     long methodHandle = LibGraal.translate(runtime, method);</span>
<span class="line-added">+                     long isolateThread = LibGraalScope.getIsolateThread();</span>
<span class="line-added">+ </span>
<span class="line-added">+                     StackTraceBuffer stackTraceBuffer = libgraal.getStackTraceBuffer();</span>
<span class="line-added">+ </span>
<span class="line-added">+                     long stackTraceBufferAddress = stackTraceBuffer.getAddress();</span>
<span class="line-added">+                     long installedCodeHandle = compileMethodInLibgraal(isolateThread,</span>
<span class="line-added">+                                     methodHandle,</span>
<span class="line-added">+                                     useProfilingInfo,</span>
<span class="line-added">+                                     installAsDefault,</span>
<span class="line-added">+                                     libgraal.options.getAddress(),</span>
<span class="line-added">+                                     libgraal.options.size,</span>
<span class="line-added">+                                     libgraal.options.hash,</span>
<span class="line-added">+                                     stackTraceBufferAddress,</span>
<span class="line-added">+                                     stackTraceBuffer.size);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     installedCode = LibGraal.unhand(runtime, HotSpotInstalledCode.class, installedCodeHandle);</span>
<span class="line-added">+                     if (installedCode == null) {</span>
<span class="line-added">+                         int length = UNSAFE.getInt(stackTraceBufferAddress);</span>
<span class="line-added">+                         byte[] data = new byte[length];</span>
<span class="line-added">+                         UNSAFE.copyMemory(null, stackTraceBufferAddress + Integer.BYTES, data, ARRAY_BYTE_BASE_OFFSET, length);</span>
<span class="line-added">+                         String stackTrace = new String(data).trim();</span>
<span class="line-added">+                         println(true, String.format(&quot;CompileTheWorld (%d) : Error compiling method: %s&quot;, counter, method.format(&quot;%H.%n(%p):%r&quot;)));</span>
<span class="line-added">+                         println(true, stackTrace);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;</span>
<span class="line-added">+                 HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, 0L);</span>
<span class="line-added">+                 CompilationTask task = new CompilationTask(jvmciRuntime, compiler, request, useProfilingInfo, installAsDefault);</span>
<span class="line-added">+                 task.runCompilation(compilerOptions);</span>
<span class="line-added">+                 installedCode = task.getInstalledCode();</span>
<span class="line-added">+             }</span>
  
              // Invalidate the generated code so the code cache doesn&#39;t fill up
<span class="line-modified">!             if (installedCode != null &amp;&amp; InvalidateInstalledCode.getValue(compilerOptions)) {</span>
                  installedCode.invalidate();
              }
  
              memoryUsed.getAndAdd(getCurrentThreadAllocatedBytes() - allocatedAtStart);
<span class="line-modified">!             compileTime.getAndAdd(System.nanoTime() - start);</span>
              compiledMethodsCounter.incrementAndGet();
          } catch (Throwable t) {
              // Catch everything and print a message
              println(&quot;CompileTheWorld (%d) : Error compiling method: %s&quot;, counter, method.format(&quot;%H.%n(%p):%r&quot;));
              printStackTrace(t);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 797,52 ***</span>
          }
          return true;
      }
  
      static class Options {
<span class="line-removed">-         // @formatter:off</span>
          public static final OptionKey&lt;Boolean&gt; Help = new OptionKey&lt;&gt;(false);
          public static final OptionKey&lt;String&gt; Classpath = new OptionKey&lt;&gt;(CompileTheWorld.SUN_BOOT_CLASS_PATH);
          public static final OptionKey&lt;Boolean&gt; Verbose = new OptionKey&lt;&gt;(true);
          /**
<span class="line-modified">!          * Ignore Graal classes by default to avoid problems associated with compiling</span>
<span class="line-modified">!          * snippets and method substitutions.</span>
           */
          public static final OptionKey&lt;String&gt; LimitModules = new OptionKey&lt;&gt;(&quot;~jdk.internal.vm.compiler&quot;);
          public static final OptionKey&lt;Integer&gt; Iterations = new OptionKey&lt;&gt;(1);
          public static final OptionKey&lt;String&gt; MethodFilter = new OptionKey&lt;&gt;(null);
          public static final OptionKey&lt;String&gt; ExcludeMethodFilter = new OptionKey&lt;&gt;(null);
          public static final OptionKey&lt;Integer&gt; StartAt = new OptionKey&lt;&gt;(1);
          public static final OptionKey&lt;Integer&gt; StopAt = new OptionKey&lt;&gt;(Integer.MAX_VALUE);
          public static final OptionKey&lt;String&gt; Config = new OptionKey&lt;&gt;(null);
          public static final OptionKey&lt;Boolean&gt; MultiThreaded = new OptionKey&lt;&gt;(false);
          public static final OptionKey&lt;Integer&gt; Threads = new OptionKey&lt;&gt;(0);
  
          static final ReflectionOptionDescriptors DESCRIPTORS = new ReflectionOptionDescriptors(Options.class,
                             &quot;Help&quot;, &quot;List options and their help messages and then exit.&quot;,
                        &quot;Classpath&quot;, &quot;Class path denoting methods to compile. Default is to compile boot classes.&quot;,
<span class="line-modified">!                         &quot;Verbose&quot;, &quot;Verbose operation.&quot;,</span>
                     &quot;LimitModules&quot;, &quot;Comma separated list of module names to which compilation should be limited. &quot; +
                                     &quot;Module names can be prefixed with \&quot;~\&quot; to exclude the named module.&quot;,
                       &quot;Iterations&quot;, &quot;The number of iterations to perform.&quot;,
                     &quot;MethodFilter&quot;, &quot;Only compile methods matching this filter.&quot;,
              &quot;ExcludeMethodFilter&quot;, &quot;Exclude methods matching this filter from compilation.&quot;,
<span class="line-modified">!                         &quot;StartAt&quot;, &quot;First class to consider for compilation.&quot;,</span>
<span class="line-modified">!                          &quot;StopAt&quot;, &quot;Last class to consider for compilation.&quot;,</span>
<span class="line-modified">!                          &quot;Config&quot;, &quot;Option value overrides to use during compile the world. For example, &quot; +</span>
<span class="line-modified">!                                    &quot;to disable inlining and partial escape analysis specify &#39;PartialEscapeAnalysis=false Inline=false&#39;. &quot; +</span>
<span class="line-modified">!                                    &quot;The format for each option is the same as on the command line just without the &#39;-Dgraal.&#39; prefix.&quot;,</span>
                    &quot;MultiThreaded&quot;, &quot;Run using multiple threads for compilation.&quot;,
<span class="line-modified">!                         &quot;Threads&quot;, &quot;Number of threads to use for multithreaded execution. Defaults to Runtime.getRuntime().availableProcessors().&quot;);</span>
          // @formatter:on
      }
  
<span class="line-modified">!     public static OptionValues loadOptions(OptionValues initialValues) {</span>
          EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; values = OptionValues.newOptionMap();
          List&lt;OptionDescriptors&gt; loader = singletonList(DESCRIPTORS);
          OptionsParser.parseOptions(extractEntries(System.getProperties(), &quot;CompileTheWorld.&quot;, true), values, loader);
<span class="line-modified">!         OptionValues options = new OptionValues(initialValues, values);</span>
          if (Options.Help.getValue(options)) {
              options.printHelp(loader, System.out, &quot;CompileTheWorld.&quot;);
              System.exit(0);
          }
          return options;
<span class="line-new-header">--- 1052,58 ---</span>
          }
          return true;
      }
  
      static class Options {
          public static final OptionKey&lt;Boolean&gt; Help = new OptionKey&lt;&gt;(false);
          public static final OptionKey&lt;String&gt; Classpath = new OptionKey&lt;&gt;(CompileTheWorld.SUN_BOOT_CLASS_PATH);
          public static final OptionKey&lt;Boolean&gt; Verbose = new OptionKey&lt;&gt;(true);
          /**
<span class="line-modified">!          * Ignore Graal classes by default to avoid problems associated with compiling snippets and</span>
<span class="line-modified">!          * method substitutions.</span>
           */
          public static final OptionKey&lt;String&gt; LimitModules = new OptionKey&lt;&gt;(&quot;~jdk.internal.vm.compiler&quot;);
          public static final OptionKey&lt;Integer&gt; Iterations = new OptionKey&lt;&gt;(1);
          public static final OptionKey&lt;String&gt; MethodFilter = new OptionKey&lt;&gt;(null);
          public static final OptionKey&lt;String&gt; ExcludeMethodFilter = new OptionKey&lt;&gt;(null);
          public static final OptionKey&lt;Integer&gt; StartAt = new OptionKey&lt;&gt;(1);
          public static final OptionKey&lt;Integer&gt; StopAt = new OptionKey&lt;&gt;(Integer.MAX_VALUE);
<span class="line-added">+         public static final OptionKey&lt;Integer&gt; MaxClasses = new OptionKey&lt;&gt;(Integer.MAX_VALUE);</span>
          public static final OptionKey&lt;String&gt; Config = new OptionKey&lt;&gt;(null);
          public static final OptionKey&lt;Boolean&gt; MultiThreaded = new OptionKey&lt;&gt;(false);
          public static final OptionKey&lt;Integer&gt; Threads = new OptionKey&lt;&gt;(0);
<span class="line-added">+         public static final OptionKey&lt;Boolean&gt; InvalidateInstalledCode = new OptionKey&lt;&gt;(false);</span>
  
<span class="line-added">+         // @formatter:off</span>
          static final ReflectionOptionDescriptors DESCRIPTORS = new ReflectionOptionDescriptors(Options.class,
                             &quot;Help&quot;, &quot;List options and their help messages and then exit.&quot;,
                        &quot;Classpath&quot;, &quot;Class path denoting methods to compile. Default is to compile boot classes.&quot;,
<span class="line-modified">!                         &quot;Verbose&quot;, &quot;Verbose operation. Default is !MultiThreaded.&quot;,</span>
                     &quot;LimitModules&quot;, &quot;Comma separated list of module names to which compilation should be limited. &quot; +
                                     &quot;Module names can be prefixed with \&quot;~\&quot; to exclude the named module.&quot;,
                       &quot;Iterations&quot;, &quot;The number of iterations to perform.&quot;,
                     &quot;MethodFilter&quot;, &quot;Only compile methods matching this filter.&quot;,
              &quot;ExcludeMethodFilter&quot;, &quot;Exclude methods matching this filter from compilation.&quot;,
<span class="line-modified">!                         &quot;StartAt&quot;, &quot;First class to consider for compilation (default = 1).&quot;,</span>
<span class="line-modified">!                          &quot;StopAt&quot;, &quot;Last class to consider for compilation (default = &lt;number of classes&gt;).&quot;,</span>
<span class="line-modified">!                      &quot;MaxClasses&quot;, &quot;Maximum number of classes to process (default = &lt;number of classes&gt;). &quot; +</span>
<span class="line-modified">!                                    &quot;Ignored if less than (StopAt - StartAt + 1).&quot;,</span>
<span class="line-modified">!                          &quot;Config&quot;, &quot;Option values to use during compile the world compilations. For example, &quot; +</span>
<span class="line-added">+                                    &quot;to disable partial escape analysis and print compilations specify &quot; +</span>
<span class="line-added">+                                    &quot;&#39;PartialEscapeAnalysis=false PrintCompilation=true&#39;. &quot; +</span>
<span class="line-added">+                                    &quot;Unless explicitly enabled with &#39;Inline=true&#39; here, inlining is disabled.&quot;,</span>
                    &quot;MultiThreaded&quot;, &quot;Run using multiple threads for compilation.&quot;,
<span class="line-modified">!                         &quot;Threads&quot;, &quot;Number of threads to use for multithreaded execution. Defaults to Runtime.getRuntime().availableProcessors().&quot;,</span>
<span class="line-added">+         &quot;InvalidateInstalledCode&quot;, &quot;Invalidate the generated code so the code cache doesn&#39;t fill up.&quot;);</span>
          // @formatter:on
      }
  
<span class="line-modified">!     public static OptionValues loadHarnessOptions() {</span>
          EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; values = OptionValues.newOptionMap();
          List&lt;OptionDescriptors&gt; loader = singletonList(DESCRIPTORS);
          OptionsParser.parseOptions(extractEntries(System.getProperties(), &quot;CompileTheWorld.&quot;, true), values, loader);
<span class="line-modified">!         OptionValues options = new OptionValues(values);</span>
          if (Options.Help.getValue(options)) {
              options.printHelp(loader, System.out, &quot;CompileTheWorld.&quot;);
              System.exit(0);
          }
          return options;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 851,19 ***</span>
      public static void main(String[] args) throws Throwable {
          HotSpotJVMCIRuntime jvmciRuntime = HotSpotJVMCIRuntime.runtime();
          HotSpotGraalCompiler compiler = (HotSpotGraalCompiler) jvmciRuntime.getCompiler();
          HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
          HotSpotCodeCacheProvider codeCache = graalRuntime.getHostProviders().getCodeCache();
<span class="line-modified">!         OptionValues options = loadOptions(graalRuntime.getOptions());</span>
  
<span class="line-modified">!         int iterations = Options.Iterations.getValue(options);</span>
          for (int i = 0; i &lt; iterations; i++) {
              codeCache.resetCompilationStatistics();
              TTY.println(&quot;CompileTheWorld : iteration &quot; + i);
  
<span class="line-modified">!             CompileTheWorld ctw = new CompileTheWorld(jvmciRuntime, compiler, options);</span>
              ctw.compile();
          }
          // This is required as non-daemon threads can be started by class initializers
          System.exit(0);
      }
  }
<span class="line-new-header">--- 1112,24 ---</span>
      public static void main(String[] args) throws Throwable {
          HotSpotJVMCIRuntime jvmciRuntime = HotSpotJVMCIRuntime.runtime();
          HotSpotGraalCompiler compiler = (HotSpotGraalCompiler) jvmciRuntime.getCompiler();
          HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
          HotSpotCodeCacheProvider codeCache = graalRuntime.getHostProviders().getCodeCache();
<span class="line-modified">!         OptionValues harnessOptions = loadHarnessOptions();</span>
  
<span class="line-modified">!         int iterations = Options.Iterations.getValue(harnessOptions);</span>
          for (int i = 0; i &lt; iterations; i++) {
              codeCache.resetCompilationStatistics();
              TTY.println(&quot;CompileTheWorld : iteration &quot; + i);
  
<span class="line-modified">!             CompileTheWorld ctw = new CompileTheWorld(jvmciRuntime, compiler, harnessOptions, graalRuntime.getOptions());</span>
              ctw.compile();
<span class="line-added">+             if (iterations &gt; 1) {</span>
<span class="line-added">+                 // Force a GC to encourage reclamation of nmethods when their InstalledCode</span>
<span class="line-added">+                 // reference has been dropped.</span>
<span class="line-added">+                 System.gc();</span>
<span class="line-added">+             }</span>
          }
          // This is required as non-daemon threads can be started by class initializers
          System.exit(0);
      }
  }
</pre>
<center><a href="CompilationWrapperTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompileTheWorldTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/MethodSubstitutionForeignCallTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
 27 import static org.graalvm.compiler.debug.DebugOptions.DumpOnError;
 28 
 29 import org.graalvm.compiler.api.directives.GraalDirectives;
 30 import org.graalvm.compiler.api.replacements.ClassSubstitution;
 31 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 32 import org.graalvm.compiler.api.test.Graal;
 33 import org.graalvm.compiler.core.common.LIRKind;
 34 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 35 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 37 import org.graalvm.compiler.core.test.GraalCompilerTest;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.debug.TTY;
 40 import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
 41 import org.graalvm.compiler.nodes.StructuredGraph;
 42 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 43 import org.graalvm.compiler.nodes.ValueNode;
 44 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 45 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 46 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 47 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 48 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 49 import org.graalvm.compiler.options.OptionValues;
 50 import org.graalvm.compiler.phases.tiers.Suites;
 51 import org.graalvm.compiler.replacements.ReplacementsImpl;
 52 import org.graalvm.compiler.replacements.classfile.ClassfileBytecodeProvider;
 53 import org.graalvm.compiler.runtime.RuntimeProvider;
 54 import jdk.internal.vm.compiler.word.LocationIdentity;
 55 import org.junit.Assert;
 56 import org.junit.Test;
 57 
 58 import jdk.vm.ci.meta.JavaKind;
 59 import jdk.vm.ci.meta.MetaAccessProvider;
 60 import jdk.vm.ci.meta.ResolvedJavaMethod;
 61 
 62 public class MethodSubstitutionForeignCallTest extends GraalCompilerTest {
 63     public static final ForeignCallDescriptor TEST_CALL = new ForeignCallDescriptor(&quot;test&quot;, int.class, int.class);
 64 
 65     public static class A {
 66         static void invalidConsecutiveForeignCall1(@SuppressWarnings(&quot;unused&quot;) int phi) {
 67 
 68         }
 69 
 70         static void invalidConsecutiveForeignCall2(@SuppressWarnings(&quot;unused&quot;) int phi) {
 71 
 72         }
 73 
 74         static void validConsecutiveForeignCallReexecutable(@SuppressWarnings(&quot;unused&quot;) int phi) {
 75 
 76         }
 77 
 78         static void splitForeignCallInvalid(@SuppressWarnings(&quot;unused&quot;) int phi) {
 79 
 80         }
 81     }
 82 
 83     @ClassSubstitution(A.class)
 84     public static class ASubstitutions {
 85 
 86         /*
 87          * Invalid: two consecutive states, deopt could float in between.
 88          */
 89         @MethodSubstitution
 90         static void invalidConsecutiveForeignCall1(int phi) {
 91             testDeopt(phi);
 92             // invalid two consecutive calls
 93             testDeopt(phi);
 94         }
 95 
 96         /*
 97          * Invalid: two consecutive states, deopt could float in between. Same applies for
 98          * non-deopting framestates if they are not re-executable. If they are, we are good.
 99          */
100         @MethodSubstitution
101         static void invalidConsecutiveForeignCall2(int phi) {
102             testNonDeopting(phi);
103             testNonDeopting(phi);
104         }
105 
106         /*
107          * Valid, the foreign calls are re-executable and non-deopting (thus completely side-effect
108          * free), they do not need a state.
109          */
110         @MethodSubstitution
111         static void validConsecutiveForeignCallReexecutable(int phi) {
112             testPureReexectuable(phi);
113             testPureReexectuable(phi);
114         }
115 
116         /**
117          * Invalid: Splitting effect in a method substitution is allowed as long as it is just one
118          * effect per call. This is not the case here.
119          */
120         @MethodSubstitution
121         static void splitForeignCallInvalid(int phi) {
122             if (SideEffect == 0) {
123                 testDeopt(phi);
124             } else {
125                 CurrentJavaThreadNode.get().writeByte(0, (byte) 0);
126                 testDeopt(phi);
127             }
128         }
129     }
130 
131     @Override
132     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
133 
134         invocationPlugins.register(new InvocationPlugin() {
135 
136             @Override
137             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg) {
138                 ForeignCallsProvider foreignCalls = new ForeignCallsProvider() {
139 
140                     @Override
141                     public LIRKind getValueKind(JavaKind javaKind) {
142                         return LIRKind.fromJavaKind(getTarget().arch, javaKind);
143                     }
144 
145                     @Override
146                     public ForeignCallLinkage lookupForeignCall(ForeignCallDescriptor descriptor) {
147                         throw GraalError.shouldNotReachHere(&quot;Test code must not need this method&quot;);
148                     }
149 
150                     @Override
151                     public boolean isReexecutable(ForeignCallDescriptor descriptor) {
152                         return false;
153                     }
154 
155                     @Override
156                     public boolean isGuaranteedSafepoint(ForeignCallDescriptor descriptor) {
157                         return true;
158                     }
159 
160                     @Override
161                     public boolean isAvailable(ForeignCallDescriptor descriptor) {
162                         return true;
163                     }
164 
165                     @Override
166                     public LocationIdentity[] getKilledLocations(ForeignCallDescriptor descriptor) {
167                         return new LocationIdentity[]{LocationIdentity.any()};
168                     }
169 
170                     @Override
171                     public boolean canDeoptimize(ForeignCallDescriptor descriptor) {
172                         return true;
173                     }
174                 };
175                 ForeignCallNode node = new ForeignCallNode(foreignCalls, TEST_CALL, arg);
176                 node.setBci(b.bci());
177                 b.addPush(JavaKind.Int, node);
178                 return true;
179             }
180         }, MethodSubstitutionForeignCallTest.class, &quot;testDeopt&quot;, int.class);
181         invocationPlugins.register(new InvocationPlugin() {
182 
183             @Override
184             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg) {
185                 ForeignCallsProvider foreignCalls = new ForeignCallsProvider() {
186 
187                     @Override
188                     public LIRKind getValueKind(JavaKind javaKind) {
189                         return LIRKind.fromJavaKind(getTarget().arch, javaKind);
190                     }
191 
192                     @Override
193                     public ForeignCallLinkage lookupForeignCall(ForeignCallDescriptor descriptor) {
194                         throw GraalError.shouldNotReachHere(&quot;Test code must not need this method&quot;);
195                     }
196 
197                     @Override
198                     public boolean isReexecutable(ForeignCallDescriptor descriptor) {
199                         return false;
200                     }
201 
202                     @Override
203                     public boolean isGuaranteedSafepoint(ForeignCallDescriptor descriptor) {
204                         return false;
205                     }
206 
207                     @Override
208                     public boolean isAvailable(ForeignCallDescriptor descriptor) {
209                         return true;
210                     }
211 
212                     @Override
213                     public LocationIdentity[] getKilledLocations(ForeignCallDescriptor descriptor) {
214                         return new LocationIdentity[]{LocationIdentity.any()};
215                     }
216 
217                     @Override
218                     public boolean canDeoptimize(ForeignCallDescriptor descriptor) {
219                         return false;
220                     }
221                 };
222                 ForeignCallNode node = new ForeignCallNode(foreignCalls, TEST_CALL, arg);
223                 node.setBci(b.bci());
224                 b.addPush(JavaKind.Int, node);
225                 return true;
226             }
227         }, MethodSubstitutionForeignCallTest.class, &quot;testNonDeopting&quot;, int.class);
228         invocationPlugins.register(new InvocationPlugin() {
229 
230             @Override
231             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg) {
232                 ForeignCallsProvider foreignCalls = new ForeignCallsProvider() {
233 
234                     @Override
235                     public LIRKind getValueKind(JavaKind javaKind) {
236                         return LIRKind.fromJavaKind(getTarget().arch, javaKind);
237                     }
238 
239                     @Override
240                     public ForeignCallLinkage lookupForeignCall(ForeignCallDescriptor descriptor) {
241                         throw GraalError.shouldNotReachHere(&quot;Test code must not need this method&quot;);
242                     }
243 
244                     @Override
245                     public boolean isReexecutable(ForeignCallDescriptor descriptor) {
246                         return true;
247                     }
248 
249                     @Override
250                     public boolean isGuaranteedSafepoint(ForeignCallDescriptor descriptor) {
251                         return false;
252                     }
253 
254                     @Override
255                     public boolean isAvailable(ForeignCallDescriptor descriptor) {
256                         return true;
257                     }
258 
259                     @Override
260                     public LocationIdentity[] getKilledLocations(ForeignCallDescriptor descriptor) {
261                         return new LocationIdentity[]{LocationIdentity.any()};
262                     }
263 
264                     @Override
265                     public boolean canDeoptimize(ForeignCallDescriptor descriptor) {
266                         return false;
267                     }
268                 };
269                 ForeignCallNode node = new ForeignCallNode(foreignCalls, TEST_CALL, arg);
270                 node.setBci(b.bci());
271                 b.addPush(JavaKind.Int, node);
272                 return true;
273             }
274         }, MethodSubstitutionForeignCallTest.class, &quot;testPureReexectuable&quot;, int.class);
275         ClassfileBytecodeProvider bytecodeProvider = getSystemClassLoaderBytecodeProvider();
276         Registration r = new Registration(invocationPlugins, A.class, getReplacements(), bytecodeProvider);
277         r.registerMethodSubstitution(ASubstitutions.class, &quot;invalidConsecutiveForeignCall1&quot;, int.class);
278         r.registerMethodSubstitution(ASubstitutions.class, &quot;invalidConsecutiveForeignCall2&quot;, int.class);
279         r.registerMethodSubstitution(ASubstitutions.class, &quot;validConsecutiveForeignCallReexecutable&quot;, int.class);
280         r.registerMethodSubstitution(ASubstitutions.class, &quot;splitForeignCallInvalid&quot;, int.class);
281         super.registerInvocationPlugins(invocationPlugins);
282     }
283 
284     private ClassfileBytecodeProvider getSystemClassLoaderBytecodeProvider() {
285         ReplacementsImpl d = (ReplacementsImpl) getReplacements();
286         MetaAccessProvider metaAccess = d.getProviders().getMetaAccess();
287         ClassfileBytecodeProvider bytecodeProvider = new ClassfileBytecodeProvider(metaAccess, d.snippetReflection, ClassLoader.getSystemClassLoader());
288         return bytecodeProvider;
289     }
290 
291     public static int SideEffect;
292 
293     public static int testDeopt(int value) {
294         SideEffect = value;
295         return value;
296     }
297 
298     public static int testNonDeopting(int value) {
299         return value;
300     }
301 
302     public static int testPureReexectuable(int value) {
303         return value;
304     }
305 
306     public static void testSnippetInvalidSequential() {
307         A.invalidConsecutiveForeignCall1(SideEffect);
308         if (SideEffect == 1) {
309             GraalDirectives.deoptimize();
310         }
311     }
312 
313     public static void testNonDeoptingInvalid() {
314         A.invalidConsecutiveForeignCall2(SideEffect);
315         if (SideEffect == 1) {
316             GraalDirectives.deoptimize();
317         }
318     }
319 
320     public static void testNonDeoptingSplit() {
321         A.splitForeignCallInvalid(SideEffect);
322         if (SideEffect == 1) {
323             GraalDirectives.deoptimize();
324         }
325     }
326 
327     public static void testNonDeoptingReexectuable() {
328         A.validConsecutiveForeignCallReexecutable(SideEffect);
329         if (SideEffect == 1) {
330             GraalDirectives.deoptimize();
331         }
332     }
333 
334     @Test
335     @SuppressWarnings(&quot;try&quot;)
336     public void test1() {
337         try (AutoCloseable c = new TTY.Filter()) {
338             OptionValues options = new OptionValues(getInitialOptions(), DumpOnError, false);
339             StructuredGraph g = parseEager(getResolvedJavaMethod(&quot;testSnippetInvalidSequential&quot;), AllowAssumptions.NO, options);
340             Suites s = Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend().getSuites().getDefaultSuites(getInitialOptions());
341             s.getHighTier().apply(g, getDefaultHighTierContext());
342             s.getMidTier().apply(g, getDefaultMidTierContext());
343             Assert.fail(&quot;Compilation should not reach this point, must throw an exception before&quot;);
344         } catch (Throwable t) {
345             if ((t.getCause() instanceof GraalError || t instanceof GraalError) &amp;&amp; t.getMessage().contains(&quot;invalid framestate&quot;)) {
346                 return;
347             }
348             throw new AssertionError(t);
349         }
350     }
351 
352     @Test
353     @SuppressWarnings(&quot;try&quot;)
354     public void test2() {
355         try (AutoCloseable c = new TTY.Filter()) {
356             OptionValues options = new OptionValues(getInitialOptions(), DumpOnError, false);
357             StructuredGraph g = parseEager(getResolvedJavaMethod(&quot;testSnippetInvalidSequential&quot;), AllowAssumptions.NO, options);
358             Suites s = Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend().getSuites().getDefaultSuites(getInitialOptions());
359             s.getHighTier().apply(g, getDefaultHighTierContext());
360             s.getMidTier().apply(g, getDefaultMidTierContext());
361             Assert.fail(&quot;Compilation should not reach this point, must throw an exception before&quot;);
362         } catch (Throwable t) {
363             if ((t.getCause() instanceof GraalError || t instanceof GraalError) &amp;&amp; t.getMessage().contains(&quot;invalid framestate&quot;)) {
364                 return;
365             }
366             throw new AssertionError(t);
367         }
368     }
369 
370     @Test
371     @SuppressWarnings(&quot;try&quot;)
372     public void test3() {
373         try (AutoCloseable c = new TTY.Filter()) {
374             OptionValues options = new OptionValues(getInitialOptions(), DumpOnError, false);
375             StructuredGraph g = parseEager(getResolvedJavaMethod(&quot;testNonDeoptingSplit&quot;), AllowAssumptions.NO, options);
376             Suites s = Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend().getSuites().getDefaultSuites(getInitialOptions());
377             s.getHighTier().apply(g, getDefaultHighTierContext());
378             s.getMidTier().apply(g, getDefaultMidTierContext());
379             Assert.fail(&quot;Compilation should not reach this point, must throw an exception before&quot;);
380         } catch (Throwable t) {
381             if ((t.getCause() instanceof GraalError || t instanceof GraalError) &amp;&amp; t.getMessage().contains(&quot;invalid framestate&quot;)) {
382                 return;
383             }
384             throw new AssertionError(t);
385         }
386     }
387 
388     @Test
389     public void test4() {
390         StructuredGraph g = parseEager(getResolvedJavaMethod(&quot;testNonDeoptingReexectuable&quot;), AllowAssumptions.NO);
391         Suites s = Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend().getSuites().getDefaultSuites(getInitialOptions());
392         s.getHighTier().apply(g, getDefaultHighTierContext());
393         s.getMidTier().apply(g, getDefaultMidTierContext());
394     }
395 
396 }
    </pre>
  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,17 +24,21 @@
 
 package org.graalvm.compiler.hotspot.test;
 
 import static java.util.Collections.singletonList;
 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Print;
-import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAction;
+import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAsFailure;
 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
 import static org.graalvm.compiler.core.test.ReflectionOptionDescriptors.extractEntries;
 import static org.graalvm.compiler.debug.MemUseTrackerKey.getCurrentThreadAllocatedBytes;
+import static org.graalvm.compiler.hotspot.CompilationTask.CompilationTime;
+import static org.graalvm.compiler.hotspot.CompilationTask.CompiledAndInstalledBytecodes;
 import static org.graalvm.compiler.hotspot.test.CompileTheWorld.Options.DESCRIPTORS;
-import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;
+import static org.graalvm.compiler.hotspot.test.CompileTheWorld.Options.InvalidateInstalledCode;
+import static sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;
 
+import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.File;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
@@ -71,28 +75,38 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
 import jdk.internal.vm.compiler.collections.EconomicMap;
-import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
+import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
 import org.graalvm.compiler.api.replacements.Snippet;
 import org.graalvm.compiler.bytecode.Bytecodes;
 import org.graalvm.compiler.core.CompilerThreadFactory;
+import org.graalvm.compiler.core.phases.HighTier;
 import org.graalvm.compiler.core.test.ReflectionOptionDescriptors;
 import org.graalvm.compiler.debug.DebugOptions;
+import org.graalvm.compiler.debug.GlobalMetrics;
 import org.graalvm.compiler.debug.GraalError;
 import org.graalvm.compiler.debug.MethodFilter;
+import org.graalvm.compiler.debug.MetricKey;
 import org.graalvm.compiler.debug.TTY;
 import org.graalvm.compiler.hotspot.CompilationTask;
 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 import org.graalvm.compiler.hotspot.HotSpotGraalCompiler;
+import org.graalvm.compiler.hotspot.HotSpotGraalRuntime;
 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
+import org.graalvm.compiler.hotspot.test.CompileTheWorld.LibGraalParams.StackTraceBuffer;
 import org.graalvm.compiler.options.OptionDescriptors;
 import org.graalvm.compiler.options.OptionKey;
 import org.graalvm.compiler.options.OptionValues;
 import org.graalvm.compiler.options.OptionsParser;
+import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;
 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
+import org.graalvm.compiler.api.test.ModuleSupport;
+import jdk.internal.vm.compiler.libgraal.LibGraal;
+import jdk.internal.vm.compiler.libgraal.LibGraalScope;
+import org.graalvm.util.OptionsEncoder;
 
 import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;
 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 import jdk.vm.ci.hotspot.HotSpotInstalledCode;
 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
@@ -100,20 +114,24 @@
 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 import jdk.vm.ci.meta.ConstantPool;
 import jdk.vm.ci.meta.MetaAccessProvider;
 import jdk.vm.ci.runtime.JVMCI;
 import jdk.vm.ci.runtime.JVMCICompiler;
+import sun.misc.Unsafe;
 
 /**
  * This class implements compile-the-world functionality with JVMCI.
  */
 public final class CompileTheWorld {
 
+    static {
+        ModuleSupport.exportAndOpenAllPackagesToUnnamed("jdk.internal.vm.compiler");
+    }
+
     /**
-     * Magic token to denote that JDK classes are to be compiled. If
-     * {@link JavaVersionUtil#Java8OrEarlier}, then the classes in {@code rt.jar} are compiled.
-     * Otherwise the classes in the Java runtime image are compiled.
+     * Magic token to denote that JDK classes are to be compiled. For JDK 8, the classes in
+     * {@code rt.jar} are compiled. Otherwise the classes in the Java runtime image are compiled.
      */
     public static final String SUN_BOOT_CLASS_PATH = "sun.boot.class.path";
 
     /**
      * Magic token to denote the classes in the Java runtime image (i.e. in the {@code jrt:/} file
@@ -125,21 +143,23 @@
      * @param options a space separated set of option value settings with each option setting in a
      *            {@code -Dgraal.<name>=<value>} format but without the leading {@code -Dgraal.}.
      *            Ignored if null.
      */
     public static EconomicMap<OptionKey<?>, Object> parseOptions(String options) {
+        EconomicMap<OptionKey<?>, Object> values = OptionValues.newOptionMap();
         if (options != null) {
             EconomicMap<String, String> optionSettings = EconomicMap.create();
             for (String optionSetting : options.split("\\s+|#")) {
                 OptionsParser.parseOptionSettingTo(optionSetting, optionSettings);
             }
-            EconomicMap<OptionKey<?>, Object> values = OptionValues.newOptionMap();
             ServiceLoader<OptionDescriptors> loader = ServiceLoader.load(OptionDescriptors.class, OptionDescriptors.class.getClassLoader());
             OptionsParser.parseOptions(optionSettings, values, loader);
-            return values;
         }
-        return EconomicMap.create();
+        if (!values.containsKey(HighTier.Options.Inline)) {
+            values.put(HighTier.Options.Inline, false);
+        }
+        return values;
     }
 
     private final HotSpotJVMCIRuntime jvmciRuntime;
 
     private final HotSpotGraalCompiler compiler;
@@ -163,10 +183,17 @@
      *
      * @see Options#StopAt
      */
     private final int stopAt;
 
+    /**
+     * Max classes to compile.
+     *
+     * @see Options#MaxClasses
+     */
+    private final int maxClasses;
+
     /** Only compile methods matching one of the filters in this array if the array is non-null. */
     private final MethodFilter[] methodFilters;
 
     /** Exclude methods matching one of the filters in this array if the array is non-null. */
     private final MethodFilter[] excludeMethodFilters;
@@ -184,83 +211,224 @@
      */
     private boolean running;
 
     private ThreadPoolExecutor threadPool;
 
-    private OptionValues currentOptions;
-    private final UnmodifiableEconomicMap<OptionKey<?>, Object> compilationOptions;
+    /**
+     * Values for {@link CompileTheWorld.Options}.
+     */
+    private final OptionValues harnessOptions;
+
+    /**
+     * Option values used during compilation.
+     */
+    private final OptionValues compilerOptions;
+
+    /**
+     * Manages native memory buffers for passing arguments into libgraal and receiving return
+     * values. The native memory buffers are freed when this object is {@linkplain #close() closed}.
+     */
+    static class LibGraalParams implements AutoCloseable {
+
+        static {
+            LibGraal.registerNativeMethods(HotSpotJVMCIRuntime.runtime(), CompileTheWorld.class);
+        }
+
+        /**
+         * Native memory containing {@linkplain OptionsEncoder encoded} {@link OptionValues}.
+         */
+        static class OptionsBuffer {
+            private long address;
+            final int size;
+            final int hash;
+
+            OptionsBuffer(OptionValues options) {
+                Map<String, Object> map = new HashMap<>();
+                UnmodifiableMapCursor<OptionKey<?>, Object> cursor = options.getMap().getEntries();
+                while (cursor.advance()) {
+                    final OptionKey<?> key = cursor.getKey();
+                    Object value = cursor.getValue();
+                    map.put(key.getName(), value);
+                }
+
+                byte[] encoded = OptionsEncoder.encode(map);
+                size = encoded.length;
+                hash = Arrays.hashCode(encoded);
+                address = UNSAFE.allocateMemory(encoded.length);
+                UNSAFE.copyMemory(encoded, ARRAY_BYTE_BASE_OFFSET, null, address, size);
+            }
+
+            long getAddress() {
+                if (address == 0) {
+                    throw new IllegalStateException();
+                }
+                return address;
+            }
+
+            void free() {
+                if (address != 0) {
+                    UNSAFE.freeMemory(address);
+                    address = 0;
+                }
+            }
+        }
+
+        /**
+         * Manages native memory for receiving a {@linkplain Throwable#printStackTrace() stack
+         * trace} from libgraal serialized via {@link ByteArrayOutputStream} to a byte array.
+         */
+        static class StackTraceBuffer {
+            final int size;
+            private long address;
+
+            StackTraceBuffer(int size) {
+                this.size = size;
+                address = UNSAFE.allocateMemory(size);
+            }
+
+            void free() {
+                if (address != 0L) {
+                    UNSAFE.freeMemory(address);
+                    address = 0L;
+                }
+            }
+
+            long getAddress() {
+                if (address == 0) {
+                    throw new IllegalStateException();
+                }
+                return address;
+            }
+        }
+
+        final OptionsBuffer options;
+
+        private final List<StackTraceBuffer> stackTraceBuffers = new ArrayList<>();
+
+        /**
+         * Gets a stack trace buffer for the current thread.
+         */
+        StackTraceBuffer getStackTraceBuffer() {
+            return stackTraceBuffer.get();
+        }
+
+        private final ThreadLocal<StackTraceBuffer> stackTraceBuffer = new ThreadLocal<StackTraceBuffer>() {
+            @Override
+            protected StackTraceBuffer initialValue() {
+                StackTraceBuffer buffer = new StackTraceBuffer(10_000);
+                synchronized (stackTraceBuffers) {
+                    stackTraceBuffers.add(buffer);
+                }
+                return buffer;
+            }
+        };
+
+        LibGraalParams(OptionValues options) {
+            this.options = new OptionsBuffer(options);
+        }
+
+        @Override
+        public void close() {
+            options.free();
+            synchronized (stackTraceBuffers) {
+                for (StackTraceBuffer buffer : stackTraceBuffers) {
+                    buffer.free();
+                }
+                stackTraceBuffers.clear();
+            }
+        }
+    }
 
     /**
      * Creates a compile-the-world instance.
      *
      * @param files {@link File#pathSeparator} separated list of Zip/Jar files to compile
      * @param startAt index of the class file to start compilation at
      * @param stopAt index of the class file to stop compilation at
+     * @param maxClasses maximum number of classes to process
      * @param methodFilters
      * @param excludeMethodFilters
+     * @param harnessOptions values for {@link CompileTheWorld.Options}
+     * @param compilerOptions option values used by the compiler
      */
-    public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalCompiler compiler, String files, int startAt, int stopAt, String methodFilters, String excludeMethodFilters,
-                    boolean verbose, OptionValues initialOptions, EconomicMap<OptionKey<?>, Object> compilationOptions) {
+    public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,
+                    HotSpotGraalCompiler compiler,
+                    String files,
+                    int startAt,
+                    int stopAt,
+                    int maxClasses,
+                    String methodFilters,
+                    String excludeMethodFilters,
+                    boolean verbose,
+                    OptionValues harnessOptions,
+                    OptionValues compilerOptions) {
         this.jvmciRuntime = jvmciRuntime;
         this.compiler = compiler;
         this.inputClassPath = files;
-        this.startAt = startAt;
-        this.stopAt = stopAt;
+        this.startAt = Math.max(startAt, 1);
+        this.stopAt = Math.max(stopAt, 1);
+        this.maxClasses = Math.max(maxClasses, 1);
         this.methodFilters = methodFilters == null || methodFilters.isEmpty() ? null : MethodFilter.parse(methodFilters);
         this.excludeMethodFilters = excludeMethodFilters == null || excludeMethodFilters.isEmpty() ? null : MethodFilter.parse(excludeMethodFilters);
         this.verbose = verbose;
-        this.currentOptions = initialOptions;
+        this.harnessOptions = harnessOptions;
 
         // Copy the initial options and add in any extra options
-        EconomicMap<OptionKey<?>, Object> compilationOptionsCopy = EconomicMap.create(initialOptions.getMap());
-        compilationOptionsCopy.putAll(compilationOptions);
+        EconomicMap<OptionKey<?>, Object> compilerOptionsMap = EconomicMap.create(compilerOptions.getMap());
 
         // We want to see stack traces when a method fails to compile
-        CompilationBailoutAction.putIfAbsent(compilationOptionsCopy, Print);
-        CompilationFailureAction.putIfAbsent(compilationOptionsCopy, Print);
+        CompilationBailoutAsFailure.putIfAbsent(compilerOptionsMap, true);
+        CompilationFailureAction.putIfAbsent(compilerOptionsMap, Print);
 
         // By default only report statistics for the CTW threads themselves
-        DebugOptions.MetricsThreadFilter.putIfAbsent(compilationOptionsCopy, "^CompileTheWorld");
-        this.compilationOptions = compilationOptionsCopy;
+        DebugOptions.MetricsThreadFilter.putIfAbsent(compilerOptionsMap, "^CompileTheWorld");
+        this.compilerOptions = new OptionValues(compilerOptionsMap);
     }
 
-    public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalCompiler compiler, OptionValues options) {
-        this(jvmciRuntime, compiler, Options.Classpath.getValue(options),
-                        Options.StartAt.getValue(options),
-                        Options.StopAt.getValue(options),
-                        Options.MethodFilter.getValue(options),
-                        Options.ExcludeMethodFilter.getValue(options),
-                        Options.Verbose.getValue(options),
-                        options,
-                        parseOptions(Options.Config.getValue(options)));
+    public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,
+                    HotSpotGraalCompiler compiler,
+                    OptionValues harnessOptions,
+                    OptionValues compilerOptions) {
+        this(jvmciRuntime, compiler, Options.Classpath.getValue(harnessOptions),
+                        Options.StartAt.getValue(harnessOptions),
+                        Options.StopAt.getValue(harnessOptions),
+                        Options.MaxClasses.getValue(harnessOptions),
+                        Options.MethodFilter.getValue(harnessOptions),
+                        Options.ExcludeMethodFilter.getValue(harnessOptions),
+                        Options.Verbose.hasBeenSet(harnessOptions) ? Options.Verbose.getValue(harnessOptions) : !Options.MultiThreaded.getValue(harnessOptions),
+                        harnessOptions,
+                        new OptionValues(compilerOptions, parseOptions(Options.Config.getValue(harnessOptions))));
     }
 
     /**
      * Compiles all methods in all classes in {@link #inputClassPath}. If {@link #inputClassPath}
      * equals {@link #SUN_BOOT_CLASS_PATH} the boot classes are used.
      */
+    @SuppressWarnings("try")
     public void compile() throws Throwable {
-        if (SUN_BOOT_CLASS_PATH.equals(inputClassPath)) {
-            String bcpEntry = null;
-            if (Java8OrEarlier) {
-                final String[] entries = System.getProperty(SUN_BOOT_CLASS_PATH).split(File.pathSeparator);
-                for (int i = 0; i < entries.length && bcpEntry == null; i++) {
-                    String entry = entries[i];
-                    File entryFile = new File(entry);
-                    if (entryFile.getName().endsWith("rt.jar") && entryFile.isFile()) {
-                        bcpEntry = entry;
+        try (LibGraalParams libgraal = LibGraal.isAvailable() ? new LibGraalParams(compilerOptions) : null) {
+            if (SUN_BOOT_CLASS_PATH.equals(inputClassPath)) {
+                String bcpEntry = null;
+                if (JavaVersionUtil.JAVA_SPEC <= 8) {
+                    final String[] entries = System.getProperty(SUN_BOOT_CLASS_PATH).split(File.pathSeparator);
+                    for (int i = 0; i < entries.length && bcpEntry == null; i++) {
+                        String entry = entries[i];
+                        File entryFile = new File(entry);
+                        if (entryFile.getName().endsWith("rt.jar") && entryFile.isFile()) {
+                            bcpEntry = entry;
+                        }
                     }
+                    if (bcpEntry == null) {
+                        throw new GraalError("Could not find rt.jar on boot class path %s", System.getProperty(SUN_BOOT_CLASS_PATH));
+                    }
+                } else {
+                    bcpEntry = JRT_CLASS_PATH_ENTRY;
                 }
-                if (bcpEntry == null) {
-                    throw new GraalError("Could not find rt.jar on boot class path %s", System.getProperty(SUN_BOOT_CLASS_PATH));
-                }
+                compile(bcpEntry, libgraal);
             } else {
-                bcpEntry = JRT_CLASS_PATH_ENTRY;
+                compile(inputClassPath, libgraal);
             }
-            compile(bcpEntry);
-        } else {
-            compile(inputClassPath);
         }
     }
 
     public void println() {
         println("");
@@ -484,70 +652,96 @@
             return false;
         }
         return true;
     }
 
+    private ClassPathEntry openClassPathEntry(String entry) throws IOException {
+        if (entry.endsWith(".zip") || entry.endsWith(".jar")) {
+            return new JarClassPathEntry(entry);
+        } else if (entry.equals(JRT_CLASS_PATH_ENTRY)) {
+            return new JRTClassPathEntry(entry, Options.LimitModules.getValue(harnessOptions));
+        } else {
+            if (!new File(entry).isDirectory()) {
+                return null;
+            }
+            return new DirClassPathEntry(entry);
+        }
+    }
+
     /**
      * Compiles all methods in all classes in a given class path.
      *
      * @param classPath class path denoting classes to compile
      * @throws IOException
      */
     @SuppressWarnings("try")
-    private void compile(String classPath) throws IOException {
+    private void compile(String classPath, LibGraalParams libgraal) throws IOException {
         final String[] entries = classPath.split(File.pathSeparator);
-        long start = System.currentTimeMillis();
+        long start = System.nanoTime();
         Map<Thread, StackTraceElement[]> initialThreads = Thread.getAllStackTraces();
 
-        try {
-            // compile dummy method to get compiler initialized outside of the
-            // config debug override.
-            HotSpotResolvedJavaMethod dummyMethod = (HotSpotResolvedJavaMethod) JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(
-                            CompileTheWorld.class.getDeclaredMethod("dummy"));
-            int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;
-            boolean useProfilingInfo = false;
-            boolean installAsDefault = false;
-            CompilationTask task = new CompilationTask(jvmciRuntime, compiler, new HotSpotCompilationRequest(dummyMethod, entryBCI, 0L), useProfilingInfo, installAsDefault, currentOptions);
-            task.runCompilation();
-        } catch (NoSuchMethodException | SecurityException e1) {
-            printStackTrace(e1);
+        if (libgraal == null) {
+            try {
+                // compile dummy method to get compiler initialized outside of the
+                // config debug override.
+                HotSpotResolvedJavaMethod dummyMethod = (HotSpotResolvedJavaMethod) JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(
+                                CompileTheWorld.class.getDeclaredMethod("dummy"));
+                int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;
+                boolean useProfilingInfo = false;
+                boolean installAsDefault = false;
+                CompilationTask task = new CompilationTask(jvmciRuntime, compiler, new HotSpotCompilationRequest(dummyMethod, entryBCI, 0L), useProfilingInfo, installAsDefault);
+                task.runCompilation(compilerOptions);
+            } catch (NoSuchMethodException | SecurityException e1) {
+                printStackTrace(e1);
+            }
         }
 
         /*
          * Always use a thread pool, even for single threaded mode since it simplifies the use of
          * DebugValueThreadFilter to filter on the thread names.
          */
         int threadCount = 1;
-        if (Options.MultiThreaded.getValue(currentOptions)) {
-            threadCount = Options.Threads.getValue(currentOptions);
+        if (Options.MultiThreaded.getValue(harnessOptions)) {
+            threadCount = Options.Threads.getValue(harnessOptions);
             if (threadCount == 0) {
                 threadCount = Runtime.getRuntime().availableProcessors();
             }
         } else {
             running = true;
         }
 
-        OptionValues savedOptions = currentOptions;
-        currentOptions = new OptionValues(compilationOptions);
         threadPool = new ThreadPoolExecutor(threadCount, threadCount, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(), new CompilerThreadFactory("CompileTheWorld"));
 
-        try {
-            for (int i = 0; i < entries.length; i++) {
-                final String entry = entries[i];
-
-                ClassPathEntry cpe;
-                if (entry.endsWith(".zip") || entry.endsWith(".jar")) {
-                    cpe = new JarClassPathEntry(entry);
-                } else if (entry.equals(JRT_CLASS_PATH_ENTRY)) {
-                    cpe = new JRTClassPathEntry(entry, Options.LimitModules.getValue(currentOptions));
-                } else {
-                    if (!new File(entry).isDirectory()) {
-                        println("CompileTheWorld : Skipped classes in " + entry);
-                        println();
-                        continue;
+        int compileStartAt = startAt;
+        int compileStopAt = stopAt;
+        int compileStep = 1;
+        if (maxClasses != Integer.MAX_VALUE) {
+            int totalClassFileCount = 0;
+            for (String entry : entries) {
+                try (ClassPathEntry cpe = openClassPathEntry(entry)) {
+                    if (cpe != null) {
+                        totalClassFileCount += cpe.getClassNames().size();
                     }
-                    cpe = new DirClassPathEntry(entry);
+                }
+            }
+
+            int lastClassFile = totalClassFileCount - 1;
+            compileStartAt = Math.min(startAt, lastClassFile);
+            compileStopAt = Math.min(stopAt, lastClassFile);
+            int range = compileStopAt - compileStartAt + 1;
+            if (maxClasses < range) {
+                compileStep = range / maxClasses;
+            }
+        }
+
+        for (int i = 0; i < entries.length; i++) {
+            final String entry = entries[i];
+            try (ClassPathEntry cpe = openClassPathEntry(entry)) {
+                if (cpe == null) {
+                    println("CompileTheWorld : Skipped classes in " + entry);
+                    println();
+                    continue;
                 }
 
                 if (methodFilters == null || methodFilters.length == 0) {
                     println("CompileTheWorld : Compiling all classes in " + entry);
                 } else {
@@ -563,16 +757,20 @@
                 ClassLoader loader = cpe.createClassLoader();
 
                 for (String className : cpe.getClassNames()) {
 
                     // Are we done?
-                    if (classFileCounter >= stopAt) {
+                    if (classFileCounter >= compileStopAt) {
                         break;
                     }
 
                     classFileCounter++;
 
+                    if (compileStep > 1 && ((classFileCounter - compileStartAt) % compileStep) != 0) {
+                        continue;
+                    }
+
                     if (className.startsWith("jdk.management.") ||
                                     className.startsWith("jdk.internal.cmm.*") ||
                                     // GR-5881: The class initializer for
                                     // sun.tools.jconsole.OutputViewer
                                     // spawns non-daemon threads for redirecting sysout and syserr.
@@ -604,72 +802,86 @@
                             }
                             continue;
                         }
 
                         // Are we compiling this class?
-                        if (classFileCounter >= startAt) {
-                            println("CompileTheWorld (%d) : %s", classFileCounter, className);
+                        if (classFileCounter >= compileStartAt) {
 
+                            long start0 = System.nanoTime();
                             // Compile each constructor/method in the class.
                             for (Constructor<?> constructor : javaClass.getDeclaredConstructors()) {
                                 HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(constructor);
                                 if (canBeCompiled(javaMethod, constructor.getModifiers())) {
-                                    compileMethod(javaMethod);
+                                    compileMethod(javaMethod, libgraal);
                                 }
                             }
                             for (Method method : javaClass.getDeclaredMethods()) {
                                 HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(method);
                                 if (canBeCompiled(javaMethod, method.getModifiers())) {
-                                    compileMethod(javaMethod);
+                                    compileMethod(javaMethod, libgraal);
                                 }
                             }
 
                             // Also compile the class initializer if it exists
                             HotSpotResolvedJavaMethod clinit = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaType(javaClass).getClassInitializer();
                             if (clinit != null && canBeCompiled(clinit, clinit.getModifiers())) {
-                                compileMethod(clinit);
+                                compileMethod(clinit, libgraal);
                             }
+                            println("CompileTheWorld (%d) : %s (%d us)", classFileCounter, className, (System.nanoTime() - start0) / 1000);
                         }
                     } catch (Throwable t) {
                         if (isClassIncluded(className)) {
                             println("CompileTheWorld (%d) : Skipping %s %s", classFileCounter, className, t.toString());
                             printStackTrace(t);
                         }
                     }
                 }
-                cpe.close();
             }
-        } finally {
-            currentOptions = savedOptions;
         }
 
         if (!running) {
             startThreads();
         }
         int wakeups = 0;
-        while (threadPool.getCompletedTaskCount() != threadPool.getTaskCount()) {
+        long lastCompletedTaskCount = 0;
+        for (long completedTaskCount = threadPool.getCompletedTaskCount(); completedTaskCount != threadPool.getTaskCount(); completedTaskCount = threadPool.getCompletedTaskCount()) {
             if (wakeups % 15 == 0) {
-                TTY.println("CompileTheWorld : Waiting for " + (threadPool.getTaskCount() - threadPool.getCompletedTaskCount()) + " compiles");
+                TTY.printf("CompileTheWorld : Waiting for %d compiles, just completed %d compiles%n", threadPool.getTaskCount() - completedTaskCount, completedTaskCount - lastCompletedTaskCount);
+                lastCompletedTaskCount = completedTaskCount;
             }
             try {
                 threadPool.awaitTermination(1, TimeUnit.SECONDS);
                 wakeups++;
             } catch (InterruptedException e) {
             }
         }
+        threadPool.shutdown();
         threadPool = null;
 
-        long elapsedTime = System.currentTimeMillis() - start;
+        long elapsedTime = System.nanoTime() - start;
 
         println();
-        if (Options.MultiThreaded.getValue(currentOptions)) {
-            TTY.println("CompileTheWorld : Done (%d classes, %d methods, %d ms elapsed, %d ms compile time, %d bytes of memory used)", classFileCounter, compiledMethodsCounter.get(), elapsedTime,
-                            compileTime.get(), memoryUsed.get());
+        int compiledClasses = classFileCounter > compileStartAt ? classFileCounter - compileStartAt : 0;
+        if (Options.MultiThreaded.getValue(harnessOptions)) {
+            TTY.println("CompileTheWorld : Done (%d classes, %d methods, %d ms elapsed, %d ms compile time, %d bytes of memory used)", compiledClasses, compiledMethodsCounter.get(), elapsedTime,
+                            compileTime.get() / 1000000, memoryUsed.get());
         } else {
-            TTY.println("CompileTheWorld : Done (%d classes, %d methods, %d ms, %d bytes of memory used)", classFileCounter, compiledMethodsCounter.get(), compileTime.get(), memoryUsed.get());
+            TTY.println("CompileTheWorld : Done (%d classes, %d methods, %d ms, %d bytes of memory used)", compiledClasses, compiledMethodsCounter.get(), compileTime.get(), memoryUsed.get());
         }
 
+        GlobalMetrics metricValues = ((HotSpotGraalRuntime) compiler.getGraalRuntime()).getMetricValues();
+        EconomicMap<MetricKey, Long> map = metricValues.asKeyValueMap();
+        Long compiledAndInstalledBytecodes = map.get(CompiledAndInstalledBytecodes);
+        Long compilationTime = map.get(CompilationTime);
+        if (compiledAndInstalledBytecodes != null && compilationTime != null) {
+            TTY.println("CompileTheWorld : Aggregate compile speed %d bytecodes per second (%d / %d)", (int) (compiledAndInstalledBytecodes / (compilationTime / 1000000000.0)),
+                            compiledAndInstalledBytecodes, compilationTime);
+        }
+
+        metricValues.print(compilerOptions);
+        metricValues.clear();
+
         // Apart from the main thread, there should be only be daemon threads
         // alive now. If not, then a class initializer has probably started
         // a thread that could cause a deadlock while trying to exit the VM.
         // One known example of this is sun.tools.jconsole.OutputViewer which
         // spawns threads to redirect sysout and syserr. To help debug such
@@ -710,58 +922,101 @@
             }
         }
     }
 
     @SuppressWarnings("try")
-    private void compileMethod(HotSpotResolvedJavaMethod method) throws InterruptedException, ExecutionException {
+    private void compileMethod(HotSpotResolvedJavaMethod method, LibGraalParams libgraal) throws InterruptedException, ExecutionException {
         if (methodFilters != null && !MethodFilter.matches(methodFilters, method)) {
             return;
         }
         if (excludeMethodFilters != null && MethodFilter.matches(excludeMethodFilters, method)) {
             return;
         }
         Future<?> task = threadPool.submit(new Runnable() {
             @Override
             public void run() {
                 waitToRun();
-                OptionValues savedOptions = currentOptions;
-                currentOptions = new OptionValues(compilationOptions);
-                try {
-                    compileMethod(method, classFileCounter);
-                } finally {
-                    currentOptions = savedOptions;
-                }
+                compileMethod(method, classFileCounter, libgraal);
             }
         });
         if (threadPool.getCorePoolSize() == 1) {
             task.get();
         }
     }
 
+    private static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();
+
+    /**
+     * Implemented by
+     * {@code com.oracle.svm.graal.hotspot.libgraal.LibGraalEntryPoints.compileMethod}.
+     */
+    static native long compileMethodInLibgraal(long isolateThread,
+                    long methodHandle,
+                    boolean useProfilingInfo,
+                    boolean installAsDefault,
+                    long optionsAddress,
+                    int optionsSize,
+                    int optionsHash,
+                    long encodedThrowableBufferAddress,
+                    int encodedThrowableBufferSize);
+
     /**
      * Compiles a method and gathers some statistics.
      */
-    private void compileMethod(HotSpotResolvedJavaMethod method, int counter) {
+    @SuppressWarnings("try")
+    private void compileMethod(HotSpotResolvedJavaMethod method, int counter, LibGraalParams libgraal) {
         try {
-            long start = System.currentTimeMillis();
+            long start = System.nanoTime();
             long allocatedAtStart = getCurrentThreadAllocatedBytes();
-            int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;
-            HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, 0L);
             // For more stable CTW execution, disable use of profiling information
             boolean useProfilingInfo = false;
             boolean installAsDefault = false;
-            CompilationTask task = new CompilationTask(jvmciRuntime, compiler, request, useProfilingInfo, installAsDefault, currentOptions);
-            task.runCompilation();
+            HotSpotInstalledCode installedCode;
+            if (libgraal != null) {
+                HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();
+                try (LibGraalScope scope = new LibGraalScope(runtime)) {
+                    long methodHandle = LibGraal.translate(runtime, method);
+                    long isolateThread = LibGraalScope.getIsolateThread();
+
+                    StackTraceBuffer stackTraceBuffer = libgraal.getStackTraceBuffer();
+
+                    long stackTraceBufferAddress = stackTraceBuffer.getAddress();
+                    long installedCodeHandle = compileMethodInLibgraal(isolateThread,
+                                    methodHandle,
+                                    useProfilingInfo,
+                                    installAsDefault,
+                                    libgraal.options.getAddress(),
+                                    libgraal.options.size,
+                                    libgraal.options.hash,
+                                    stackTraceBufferAddress,
+                                    stackTraceBuffer.size);
+
+                    installedCode = LibGraal.unhand(runtime, HotSpotInstalledCode.class, installedCodeHandle);
+                    if (installedCode == null) {
+                        int length = UNSAFE.getInt(stackTraceBufferAddress);
+                        byte[] data = new byte[length];
+                        UNSAFE.copyMemory(null, stackTraceBufferAddress + Integer.BYTES, data, ARRAY_BYTE_BASE_OFFSET, length);
+                        String stackTrace = new String(data).trim();
+                        println(true, String.format("CompileTheWorld (%d) : Error compiling method: %s", counter, method.format("%H.%n(%p):%r")));
+                        println(true, stackTrace);
+                    }
+                }
+            } else {
+                int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;
+                HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, 0L);
+                CompilationTask task = new CompilationTask(jvmciRuntime, compiler, request, useProfilingInfo, installAsDefault);
+                task.runCompilation(compilerOptions);
+                installedCode = task.getInstalledCode();
+            }
 
             // Invalidate the generated code so the code cache doesn't fill up
-            HotSpotInstalledCode installedCode = task.getInstalledCode();
-            if (installedCode != null) {
+            if (installedCode != null && InvalidateInstalledCode.getValue(compilerOptions)) {
                 installedCode.invalidate();
             }
 
             memoryUsed.getAndAdd(getCurrentThreadAllocatedBytes() - allocatedAtStart);
-            compileTime.getAndAdd(System.currentTimeMillis() - start);
+            compileTime.getAndAdd(System.nanoTime() - start);
             compiledMethodsCounter.incrementAndGet();
         } catch (Throwable t) {
             // Catch everything and print a message
             println("CompileTheWorld (%d) : Error compiling method: %s", counter, method.format("%H.%n(%p):%r"));
             printStackTrace(t);
@@ -797,52 +1052,58 @@
         }
         return true;
     }
 
     static class Options {
-        // @formatter:off
         public static final OptionKey<Boolean> Help = new OptionKey<>(false);
         public static final OptionKey<String> Classpath = new OptionKey<>(CompileTheWorld.SUN_BOOT_CLASS_PATH);
         public static final OptionKey<Boolean> Verbose = new OptionKey<>(true);
         /**
-         * Ignore Graal classes by default to avoid problems associated with compiling
-         * snippets and method substitutions.
+         * Ignore Graal classes by default to avoid problems associated with compiling snippets and
+         * method substitutions.
          */
         public static final OptionKey<String> LimitModules = new OptionKey<>("~jdk.internal.vm.compiler");
         public static final OptionKey<Integer> Iterations = new OptionKey<>(1);
         public static final OptionKey<String> MethodFilter = new OptionKey<>(null);
         public static final OptionKey<String> ExcludeMethodFilter = new OptionKey<>(null);
         public static final OptionKey<Integer> StartAt = new OptionKey<>(1);
         public static final OptionKey<Integer> StopAt = new OptionKey<>(Integer.MAX_VALUE);
+        public static final OptionKey<Integer> MaxClasses = new OptionKey<>(Integer.MAX_VALUE);
         public static final OptionKey<String> Config = new OptionKey<>(null);
         public static final OptionKey<Boolean> MultiThreaded = new OptionKey<>(false);
         public static final OptionKey<Integer> Threads = new OptionKey<>(0);
+        public static final OptionKey<Boolean> InvalidateInstalledCode = new OptionKey<>(false);
 
+        // @formatter:off
         static final ReflectionOptionDescriptors DESCRIPTORS = new ReflectionOptionDescriptors(Options.class,
                            "Help", "List options and their help messages and then exit.",
                       "Classpath", "Class path denoting methods to compile. Default is to compile boot classes.",
-                        "Verbose", "Verbose operation.",
+                        "Verbose", "Verbose operation. Default is !MultiThreaded.",
                    "LimitModules", "Comma separated list of module names to which compilation should be limited. " +
                                    "Module names can be prefixed with \"~\" to exclude the named module.",
                      "Iterations", "The number of iterations to perform.",
                    "MethodFilter", "Only compile methods matching this filter.",
             "ExcludeMethodFilter", "Exclude methods matching this filter from compilation.",
-                        "StartAt", "First class to consider for compilation.",
-                         "StopAt", "Last class to consider for compilation.",
-                         "Config", "Option value overrides to use during compile the world. For example, " +
-                                   "to disable inlining and partial escape analysis specify 'PartialEscapeAnalysis=false Inline=false'. " +
-                                   "The format for each option is the same as on the command line just without the '-Dgraal.' prefix.",
+                        "StartAt", "First class to consider for compilation (default = 1).",
+                         "StopAt", "Last class to consider for compilation (default = <number of classes>).",
+                     "MaxClasses", "Maximum number of classes to process (default = <number of classes>). " +
+                                   "Ignored if less than (StopAt - StartAt + 1).",
+                         "Config", "Option values to use during compile the world compilations. For example, " +
+                                   "to disable partial escape analysis and print compilations specify " +
+                                   "'PartialEscapeAnalysis=false PrintCompilation=true'. " +
+                                   "Unless explicitly enabled with 'Inline=true' here, inlining is disabled.",
                   "MultiThreaded", "Run using multiple threads for compilation.",
-                        "Threads", "Number of threads to use for multithreaded execution. Defaults to Runtime.getRuntime().availableProcessors().");
+                        "Threads", "Number of threads to use for multithreaded execution. Defaults to Runtime.getRuntime().availableProcessors().",
+        "InvalidateInstalledCode", "Invalidate the generated code so the code cache doesn't fill up.");
         // @formatter:on
     }
 
-    public static OptionValues loadOptions(OptionValues initialValues) {
+    public static OptionValues loadHarnessOptions() {
         EconomicMap<OptionKey<?>, Object> values = OptionValues.newOptionMap();
         List<OptionDescriptors> loader = singletonList(DESCRIPTORS);
         OptionsParser.parseOptions(extractEntries(System.getProperties(), "CompileTheWorld.", true), values, loader);
-        OptionValues options = new OptionValues(initialValues, values);
+        OptionValues options = new OptionValues(values);
         if (Options.Help.getValue(options)) {
             options.printHelp(loader, System.out, "CompileTheWorld.");
             System.exit(0);
         }
         return options;
@@ -851,19 +1112,24 @@
     public static void main(String[] args) throws Throwable {
         HotSpotJVMCIRuntime jvmciRuntime = HotSpotJVMCIRuntime.runtime();
         HotSpotGraalCompiler compiler = (HotSpotGraalCompiler) jvmciRuntime.getCompiler();
         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
         HotSpotCodeCacheProvider codeCache = graalRuntime.getHostProviders().getCodeCache();
-        OptionValues options = loadOptions(graalRuntime.getOptions());
+        OptionValues harnessOptions = loadHarnessOptions();
 
-        int iterations = Options.Iterations.getValue(options);
+        int iterations = Options.Iterations.getValue(harnessOptions);
         for (int i = 0; i < iterations; i++) {
             codeCache.resetCompilationStatistics();
             TTY.println("CompileTheWorld : iteration " + i);
 
-            CompileTheWorld ctw = new CompileTheWorld(jvmciRuntime, compiler, options);
+            CompileTheWorld ctw = new CompileTheWorld(jvmciRuntime, compiler, harnessOptions, graalRuntime.getOptions());
             ctw.compile();
+            if (iterations > 1) {
+                // Force a GC to encourage reclamation of nmethods when their InstalledCode
+                // reference has been dropped.
+                System.gc();
+            }
         }
         // This is required as non-daemon threads can be started by class initializers
         System.exit(0);
     }
 }

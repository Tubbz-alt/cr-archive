<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/WriteBarrierAdditionTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
<a name="2" id="anc2"></a>


 27 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.referentOffset;
 28 
<a name="3" id="anc3"></a>
 29 import java.lang.ref.WeakReference;
<a name="4" id="anc4"></a>


 30 
<a name="5" id="anc5"></a><span class="line-modified"> 31 import org.graalvm.compiler.api.replacements.Fold;</span>
<span class="line-removed"> 32 import org.graalvm.compiler.debug.DebugContext;</span>
 33 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<a name="6" id="anc6"></a><span class="line-modified"> 34 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase;</span>
<span class="line-modified"> 35 import org.graalvm.compiler.hotspot.gc.g1.G1PostWriteBarrier;</span>
<span class="line-modified"> 36 import org.graalvm.compiler.hotspot.gc.g1.G1PreWriteBarrier;</span>
<span class="line-modified"> 37 import org.graalvm.compiler.hotspot.gc.g1.G1ReferentFieldReadBarrier;</span>
<span class="line-removed"> 38 import org.graalvm.compiler.hotspot.gc.shared.SerialWriteBarrier;</span>
<span class="line-removed"> 39 import org.graalvm.compiler.hotspot.phases.WriteBarrierAdditionPhase;</span>
 40 import org.graalvm.compiler.nodes.StructuredGraph;
<a name="7" id="anc7"></a><span class="line-modified"> 41 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;</span>
<span class="line-modified"> 42 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;</span>
<span class="line-modified"> 43 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;</span>
<span class="line-modified"> 44 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;</span>

 45 import org.graalvm.compiler.nodes.memory.ReadNode;
 46 import org.graalvm.compiler.nodes.memory.WriteNode;
 47 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<a name="8" id="anc8"></a><span class="line-modified"> 48 import org.graalvm.compiler.nodes.spi.LoweringTool;</span>
<span class="line-modified"> 49 import org.graalvm.compiler.phases.OptimisticOptimizations;</span>
<span class="line-modified"> 50 import org.graalvm.compiler.phases.common.CanonicalizerPhase;</span>
<span class="line-modified"> 51 import org.graalvm.compiler.phases.common.GuardLoweringPhase;</span>
<span class="line-removed"> 52 import org.graalvm.compiler.phases.common.LoweringPhase;</span>
<span class="line-removed"> 53 import org.graalvm.compiler.phases.common.inlining.InliningPhase;</span>
<span class="line-removed"> 54 import org.graalvm.compiler.phases.common.inlining.policy.InlineEverythingPolicy;</span>
<span class="line-removed"> 55 import org.graalvm.compiler.phases.tiers.HighTierContext;</span>
 56 import org.graalvm.compiler.phases.tiers.MidTierContext;
<a name="9" id="anc9"></a><span class="line-modified"> 57 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;</span>

 58 import org.junit.Assert;
<a name="10" id="anc10"></a>
 59 import org.junit.Test;
 60 
<a name="11" id="anc11"></a><span class="line-removed"> 61 import jdk.vm.ci.hotspot.HotSpotInstalledCode;</span>
 62 import jdk.vm.ci.meta.JavaConstant;
<a name="12" id="anc12"></a><span class="line-modified"> 63 import jdk.vm.ci.meta.ResolvedJavaMethod;</span>
<span class="line-removed"> 64 import sun.misc.Unsafe;</span>
 65 
 66 /**
<a name="13" id="anc13"></a><span class="line-modified"> 67  * The following unit tests assert the presence of write barriers for both Serial and G1 GCs.</span>
<span class="line-modified"> 68  * Normally, the tests check for compile time inserted barriers. However, there are the cases of</span>
<span class="line-modified"> 69  * unsafe loads of the java.lang.ref.Reference.referent field where runtime checks have to be</span>
<span class="line-modified"> 70  * performed also. For those cases, the unit tests check the presence of the compile-time inserted</span>
<span class="line-modified"> 71  * barriers. Concerning the runtime checks, the results of variable inputs (object types and</span>
<span class="line-modified"> 72  * offsets) passed as input parameters can be checked against printed output from the G1 write</span>
<span class="line-modified"> 73  * barrier snippets. The runtime checks have been validated offline.</span>

 74  */
 75 public class WriteBarrierAdditionTest extends HotSpotGraalCompilerTest {
 76 
<a name="14" id="anc14"></a>





 77     private final GraalHotSpotVMConfig config = runtime().getVMConfig();
 78 
 79     public static class Container {
 80 
 81         public Container a;
 82         public Container b;
<a name="15" id="anc15"></a>
















 83     }
 84 
<a name="16" id="anc16"></a>

 85     /**
<a name="17" id="anc17"></a><span class="line-modified"> 86      * Expected 2 barriers for the Serial GC and 4 for G1 (2 pre + 2 post).</span>
 87      */
 88     @Test
<a name="18" id="anc18"></a><span class="line-modified"> 89     public void test1() throws Exception {</span>
<span class="line-modified"> 90         testHelper(&quot;test1Snippet&quot;, (config.useG1GC) ? 4 : 2);</span>

 91     }
 92 
<a name="19" id="anc19"></a><span class="line-modified"> 93     public static void test1Snippet() {</span>
 94         Container main = new Container();
 95         Container temp1 = new Container();
 96         Container temp2 = new Container();
 97         main.a = temp1;
 98         main.b = temp2;
<a name="20" id="anc20"></a>
 99     }
100 
101     /**
<a name="21" id="anc21"></a><span class="line-modified">102      * Expected 4 barriers for the Serial GC and 8 for G1 (4 pre + 4 post).</span>
103      */
104     @Test
<a name="22" id="anc22"></a><span class="line-modified">105     public void test2() throws Exception {</span>
<span class="line-modified">106         testHelper(&quot;test2Snippet&quot;, config.useG1GC ? 8 : 4);</span>


107     }
108 
109     public static void test2Snippet(boolean test) {
110         Container main = new Container();
111         Container temp1 = new Container();
112         Container temp2 = new Container();
113         for (int i = 0; i &lt; 10; i++) {
114             if (test) {
115                 main.a = temp1;
116                 main.b = temp2;
117             } else {
118                 main.a = temp2;
119                 main.b = temp1;
120             }
121         }
122     }
123 
124     /**
<a name="23" id="anc23"></a><span class="line-modified">125      * Expected 4 barriers for the Serial GC and 8 for G1 (4 pre + 4 post).</span>
126      */
127     @Test
<a name="24" id="anc24"></a><span class="line-modified">128     public void test3() throws Exception {</span>
<span class="line-modified">129         testHelper(&quot;test3Snippet&quot;, config.useG1GC ? 8 : 4);</span>

130     }
131 
132     public static void test3Snippet() {
133         Container[] main = new Container[10];
134         Container temp1 = new Container();
135         Container temp2 = new Container();
136         for (int i = 0; i &lt; 10; i++) {
137             main[i].a = main[i].b = temp1;
138         }
139 
140         for (int i = 0; i &lt; 10; i++) {
141             main[i].a = main[i].b = temp2;
142         }
143     }
144 
145     /**
<a name="25" id="anc25"></a><span class="line-modified">146      * Expected 2 barriers for the Serial GC and 5 for G1 (3 pre + 2 post) The (2 or 4) barriers are</span>
<span class="line-modified">147      * emitted while initializing the fields of the WeakReference instance. The extra pre barrier of</span>
<span class="line-modified">148      * G1 concerns the read of the referent field.</span>
149      */
150     @Test
<a name="26" id="anc26"></a><span class="line-modified">151     public void test4() throws Exception {</span>
<span class="line-modified">152         testHelper(&quot;test4Snippet&quot;, config.useG1GC ? 5 : 2);</span>

153     }
154 
<a name="27" id="anc27"></a><span class="line-modified">155     public static Object test4Snippet() {</span>
<span class="line-modified">156         WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-removed">157         return weakRef.get();</span>
158     }
159 
<a name="28" id="anc28"></a><span class="line-modified">160     static WeakReference&lt;Object&gt; wr = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-modified">161     static Container con = new Container();</span>
<span class="line-removed">162 </span>
<span class="line-removed">163     /**</span>
<span class="line-removed">164      * Expected 4 barriers for the Serial GC and 9 for G1 (1 ref + 4 pre + 4 post). In this test, we</span>
<span class="line-removed">165      * load the correct offset of the WeakReference object so naturally we assert the presence of</span>
<span class="line-removed">166      * the pre barrier.</span>
<span class="line-removed">167      */</span>
<span class="line-removed">168     @Test</span>
<span class="line-removed">169     public void test5() throws Exception {</span>
<span class="line-removed">170         testHelper(&quot;test5Snippet&quot;, config.useG1GC ? 1 : 0);</span>
171     }
172 
<a name="29" id="anc29"></a><span class="line-modified">173     @Override</span>
<span class="line-modified">174     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {</span>
<span class="line-removed">175         NodeIntrinsicPluginFactory.InjectionProvider injection = new NodeIntrinsificationProvider(getMetaAccess(), getSnippetReflection(), getProviders().getForeignCalls(), null);</span>
<span class="line-removed">176         new PluginFactory_WriteBarrierAdditionTest().registerPlugins(invocationPlugins, injection);</span>
<span class="line-removed">177         super.registerInvocationPlugins(invocationPlugins);</span>
178     }
179 
<a name="30" id="anc30"></a><span class="line-modified">180     @Fold</span>
<span class="line-modified">181     public static boolean useCompressedOops(@Fold.InjectedParameter GraalHotSpotVMConfig config) {</span>
<span class="line-modified">182         return config.useCompressedOops;</span>
<span class="line-modified">183     }</span>
184 
<a name="31" id="anc31"></a><span class="line-modified">185     public static Object test5Snippet() throws Exception {</span>
<span class="line-modified">186         return UNSAFE.getObject(wr, useCompressedOops(GraalHotSpotVMConfigBase.INJECTED_VMCONFIG) ? 12L : 16L);</span>
<span class="line-removed">187     }</span>
188 
189     /**
<a name="32" id="anc32"></a><span class="line-modified">190      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">191      * load the java.lang.ref.Reference.referent field so the pre barier has to be executed.</span>

192      */
193     @Test
<a name="33" id="anc33"></a><span class="line-modified">194     public void test6() throws Exception {</span>
<span class="line-modified">195         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(referentOffset(getMetaAccess())), null);</span>





196     }
197 
198     /**
<a name="34" id="anc34"></a><span class="line-modified">199      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">200      * load a matching offset of a wrong object so the pre barier must not be executed.</span>

201      */
202     @Test
<a name="35" id="anc35"></a><span class="line-modified">203     public void test7() throws Exception {</span>
<span class="line-modified">204         test2(&quot;testUnsafeLoad&quot;, UNSAFE, con, Long.valueOf(referentOffset(getMetaAccess())), null);</span>





205     }
206 
207     /**
<a name="36" id="anc36"></a><span class="line-modified">208      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">209      * load a non-matching offset field of the java.lang.ref.Reference object so the pre barier must</span>
<span class="line-removed">210      * not be executed.</span>
211      */
212     @Test
<a name="37" id="anc37"></a><span class="line-modified">213     public void test8() throws Exception {</span>
<span class="line-modified">214         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 20 : 32), null);</span>





215     }
216 
217     /**
<a name="38" id="anc38"></a><span class="line-modified">218      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">219      * load a matching offset+disp field of the java.lang.ref.Reference object so the pre barier</span>
<span class="line-modified">220      * must be executed.</span>

221      */
222     @Test
<a name="39" id="anc39"></a><span class="line-modified">223     public void test10() throws Exception {</span>
<span class="line-modified">224         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 6 : 8), Integer.valueOf(config.useCompressedOops ? 6 : 8));</span>





225     }
226 
227     /**
<a name="40" id="anc40"></a><span class="line-modified">228      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">229      * load a non-matching offset+disp field of the java.lang.ref.Reference object so the pre barier</span>
<span class="line-removed">230      * must not be executed.</span>
231      */
232     @Test
<a name="41" id="anc41"></a><span class="line-modified">233     public void test9() throws Exception {</span>
<span class="line-modified">234         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 10 : 16), Integer.valueOf(config.useCompressedOops ? 10 : 16));</span>






235     }
236 
237     static Object[] src = new Object[1];
238     static Object[] dst = new Object[1];
239 
240     static {
241         for (int i = 0; i &lt; src.length; i++) {
242             src[i] = new Object();
243         }
244         for (int i = 0; i &lt; dst.length; i++) {
245             dst[i] = new Object();
246         }
247     }
248 
<a name="42" id="anc42"></a><span class="line-modified">249     public static void testArrayCopy(Object a, Object b, Object c) throws Exception {</span>
250         System.arraycopy(a, 0, b, 0, (int) c);
251     }
252 
253     @Test
<a name="43" id="anc43"></a><span class="line-modified">254     public void test11() throws Exception {</span>
<span class="line-modified">255         test2(&quot;testArrayCopy&quot;, src, dst, dst.length);</span>

256     }
257 
<a name="44" id="anc44"></a><span class="line-modified">258     public static Object testUnsafeLoad(Unsafe theUnsafe, Object a, Object b, Object c) throws Exception {</span>
<span class="line-modified">259         final int offset = (c == null ? 0 : ((Integer) c).intValue());</span>
<span class="line-modified">260         final long displacement = (b == null ? 0 : ((Long) b).longValue());</span>
<span class="line-modified">261         return theUnsafe.getObject(a, offset + displacement);</span>
<span class="line-modified">262     }</span>
<span class="line-modified">263 </span>
<span class="line-modified">264     private HotSpotInstalledCode getInstalledCode(String name, boolean withUnsafePrefix) throws Exception {</span>
<span class="line-modified">265         final ResolvedJavaMethod javaMethod = withUnsafePrefix ? getResolvedJavaMethod(WriteBarrierAdditionTest.class, name, Unsafe.class, Object.class, Object.class, Object.class)</span>
<span class="line-modified">266                         : getResolvedJavaMethod(WriteBarrierAdditionTest.class, name, Object.class, Object.class, Object.class);</span>
<span class="line-modified">267         final HotSpotInstalledCode installedCode = (HotSpotInstalledCode) getCode(javaMethod);</span>
<span class="line-modified">268         return installedCode;</span>
<span class="line-modified">269     }</span>
<span class="line-modified">270 </span>
<span class="line-modified">271     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-removed">272     private void testHelper(final String snippetName, final int expectedBarriers) throws Exception, SecurityException {</span>
<span class="line-removed">273         ResolvedJavaMethod snippet = getResolvedJavaMethod(snippetName);</span>
<span class="line-removed">274         DebugContext debug = getDebugContext();</span>
<span class="line-removed">275         try (DebugContext.Scope s = debug.scope(&quot;WriteBarrierAdditionTest&quot;, snippet)) {</span>
<span class="line-removed">276             StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO, debug);</span>
<span class="line-removed">277             HighTierContext highContext = getDefaultHighTierContext();</span>
<span class="line-removed">278             MidTierContext midContext = new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, graph.getProfilingInfo());</span>
<span class="line-removed">279             new InliningPhase(new InlineEverythingPolicy(), new CanonicalizerPhase()).apply(graph, highContext);</span>
<span class="line-removed">280             new CanonicalizerPhase().apply(graph, highContext);</span>
<span class="line-removed">281             new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, highContext);</span>
<span class="line-removed">282             new GuardLoweringPhase().apply(graph, midContext);</span>
<span class="line-removed">283             new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.MID_TIER).apply(graph, midContext);</span>
<span class="line-removed">284             new WriteBarrierAdditionPhase(config).apply(graph);</span>
<span class="line-removed">285             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;After Write Barrier Addition&quot;);</span>
<span class="line-removed">286 </span>
<span class="line-removed">287             int barriers = 0;</span>
288             if (config.useG1GC) {
<a name="45" id="anc45"></a><span class="line-modified">289                 barriers = graph.getNodes().filter(G1ReferentFieldReadBarrier.class).count() + graph.getNodes().filter(G1PreWriteBarrier.class).count() +</span>
<span class="line-modified">290                                 graph.getNodes().filter(G1PostWriteBarrier.class).count();</span>



291             } else {
<a name="46" id="anc46"></a><span class="line-modified">292                 barriers = graph.getNodes().filter(SerialWriteBarrier.class).count();</span>
<span class="line-modified">293             }</span>
<span class="line-modified">294             if (expectedBarriers != barriers) {</span>
<span class="line-removed">295                 Assert.assertEquals(getScheduledGraphString(graph), expectedBarriers, barriers);</span>
<span class="line-removed">296             }</span>
<span class="line-removed">297             for (WriteNode write : graph.getNodes().filter(WriteNode.class)) {</span>
<span class="line-removed">298                 if (config.useG1GC) {</span>
<span class="line-removed">299                     if (write.getBarrierType() != BarrierType.NONE) {</span>
<span class="line-removed">300                         Assert.assertEquals(1, write.successors().count());</span>
<span class="line-removed">301                         Assert.assertTrue(write.next() instanceof G1PostWriteBarrier);</span>
<span class="line-removed">302                         Assert.assertTrue(write.predecessor() instanceof G1PreWriteBarrier);</span>
<span class="line-removed">303                     }</span>
<span class="line-removed">304                 } else {</span>
<span class="line-removed">305                     if (write.getBarrierType() != BarrierType.NONE) {</span>
<span class="line-removed">306                         Assert.assertEquals(1, write.successors().count());</span>
<span class="line-removed">307                         Assert.assertTrue(write.next() instanceof SerialWriteBarrier);</span>
<span class="line-removed">308                     }</span>
309                 }
310             }
<a name="47" id="anc47"></a>
311 
<a name="48" id="anc48"></a><span class="line-modified">312             for (ReadNode read : graph.getNodes().filter(ReadNode.class)) {</span>
<span class="line-modified">313                 if (read.getBarrierType() != BarrierType.NONE) {</span>
<span class="line-modified">314                     Assert.assertTrue(read.getAddress() instanceof OffsetAddressNode);</span>
315                     JavaConstant constDisp = ((OffsetAddressNode) read.getAddress()).getOffset().asJavaConstant();
<a name="49" id="anc49"></a><span class="line-modified">316                     Assert.assertNotNull(constDisp);</span>
<span class="line-modified">317                     Assert.assertEquals(referentOffset(getMetaAccess()), constDisp.asLong());</span>
<span class="line-modified">318                     Assert.assertTrue(config.useG1GC);</span>
<span class="line-modified">319                     Assert.assertEquals(BarrierType.PRECISE, read.getBarrierType());</span>


320                     Assert.assertTrue(read.next() instanceof G1ReferentFieldReadBarrier);
321                 }
322             }
<a name="50" id="anc50"></a><span class="line-removed">323         } catch (Throwable e) {</span>
<span class="line-removed">324             throw debug.handle(e);</span>
325         }
326     }
327 
<a name="51" id="anc51"></a><span class="line-modified">328     private void test2(final String snippet, Object... args) throws Exception {</span>
<span class="line-modified">329         HotSpotInstalledCode code = getInstalledCode(snippet, args[0] instanceof Unsafe);</span>
<span class="line-modified">330         code.executeVarargs(args);</span>































331     }
332 }
<a name="52" id="anc52"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="52" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/WriteBarrierAdditionTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
<a name="2" id="anc2"></a><span class="line-added"> 27 import static org.graalvm.compiler.core.common.GraalOptions.FullUnroll;</span>
<span class="line-added"> 28 import static org.graalvm.compiler.core.common.GraalOptions.LoopPeeling;</span>
<span class="line-added"> 29 import static org.graalvm.compiler.core.common.GraalOptions.PartialEscapeAnalysis;</span>
 30 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.referentOffset;
 31 
<a name="3" id="anc3"></a><span class="line-added"> 32 import java.lang.ref.Reference;</span>
 33 import java.lang.ref.WeakReference;
<a name="4" id="anc4"></a><span class="line-added"> 34 import java.util.EnumSet;</span>
<span class="line-added"> 35 import java.util.ListIterator;</span>
<span class="line-added"> 36 import java.util.Objects;</span>
 37 
<a name="5" id="anc5"></a><span class="line-modified"> 38 import org.graalvm.compiler.api.test.Graal;</span>

 39 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<a name="6" id="anc6"></a><span class="line-modified"> 40 import org.graalvm.compiler.hotspot.HotSpotBackend;</span>
<span class="line-modified"> 41 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime.HotSpotGC;</span>
<span class="line-modified"> 42 import org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil;</span>
<span class="line-modified"> 43 import org.graalvm.compiler.nodeinfo.NodeSize;</span>


 44 import org.graalvm.compiler.nodes.StructuredGraph;
<a name="7" id="anc7"></a><span class="line-modified"> 45 import org.graalvm.compiler.nodes.gc.G1PostWriteBarrier;</span>
<span class="line-modified"> 46 import org.graalvm.compiler.nodes.gc.G1PreWriteBarrier;</span>
<span class="line-modified"> 47 import org.graalvm.compiler.nodes.gc.G1ReferentFieldReadBarrier;</span>
<span class="line-modified"> 48 import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;</span>
<span class="line-added"> 49 import org.graalvm.compiler.nodes.memory.HeapAccess;</span>
 50 import org.graalvm.compiler.nodes.memory.ReadNode;
 51 import org.graalvm.compiler.nodes.memory.WriteNode;
 52 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<a name="8" id="anc8"></a><span class="line-modified"> 53 import org.graalvm.compiler.options.OptionValues;</span>
<span class="line-modified"> 54 import org.graalvm.compiler.phases.BasePhase;</span>
<span class="line-modified"> 55 import org.graalvm.compiler.phases.Phase;</span>
<span class="line-modified"> 56 import org.graalvm.compiler.phases.common.WriteBarrierAdditionPhase;</span>




 57 import org.graalvm.compiler.phases.tiers.MidTierContext;
<a name="9" id="anc9"></a><span class="line-modified"> 58 import org.graalvm.compiler.phases.tiers.Suites;</span>
<span class="line-added"> 59 import org.graalvm.compiler.runtime.RuntimeProvider;</span>
 60 import org.junit.Assert;
<a name="10" id="anc10"></a><span class="line-added"> 61 import org.junit.Before;</span>
 62 import org.junit.Test;
 63 
<a name="11" id="anc11"></a>
 64 import jdk.vm.ci.meta.JavaConstant;
<a name="12" id="anc12"></a><span class="line-modified"> 65 import jdk.vm.ci.meta.MetaAccessProvider;</span>

 66 
 67 /**
<a name="13" id="anc13"></a><span class="line-modified"> 68  * The following unit tests assert the presence of write barriers for G1 and for the other GCs that</span>
<span class="line-modified"> 69  * use a simple card mark barrier, like Serial, CMS, ParallelGC and Pthe arNew/ParOld GCs. Normally,</span>
<span class="line-modified"> 70  * the tests check for compile time inserted barriers. However, there are the cases of unsafe loads</span>
<span class="line-modified"> 71  * of the java.lang.ref.Reference.referent field where runtime checks have to be performed also. For</span>
<span class="line-modified"> 72  * those cases, the unit tests check the presence of the compile-time inserted barriers. Concerning</span>
<span class="line-modified"> 73  * the runtime checks, the results of variable inputs (object types and offsets) passed as input</span>
<span class="line-modified"> 74  * parameters can be checked against printed output from the G1 write barrier snippets. The runtime</span>
<span class="line-added"> 75  * checks have been validated offline.</span>
 76  */
 77 public class WriteBarrierAdditionTest extends HotSpotGraalCompilerTest {
 78 
<a name="14" id="anc14"></a><span class="line-added"> 79     /**</span>
<span class="line-added"> 80      * The set of GCs known at the time of writing of this test. The number of expected barrier</span>
<span class="line-added"> 81      * might need to be adjusted for new GCs implementations.</span>
<span class="line-added"> 82      */</span>
<span class="line-added"> 83     private static EnumSet&lt;HotSpotGC&gt; knownSupport = EnumSet.of(HotSpotGC.G1, HotSpotGC.CMS, HotSpotGC.Parallel, HotSpotGC.Serial);</span>
<span class="line-added"> 84 </span>
 85     private final GraalHotSpotVMConfig config = runtime().getVMConfig();
 86 
 87     public static class Container {
 88 
 89         public Container a;
 90         public Container b;
<a name="15" id="anc15"></a><span class="line-added"> 91 </span>
<span class="line-added"> 92         @Override</span>
<span class="line-added"> 93         public boolean equals(Object o) {</span>
<span class="line-added"> 94             if (this == o) {</span>
<span class="line-added"> 95                 return true;</span>
<span class="line-added"> 96             }</span>
<span class="line-added"> 97             if (o == null || getClass() != o.getClass()) {</span>
<span class="line-added"> 98                 return false;</span>
<span class="line-added"> 99             }</span>
<span class="line-added">100             Container container = (Container) o;</span>
<span class="line-added">101             return Objects.equals(a, container.a) &amp;&amp; Objects.equals(b, container.b);</span>
<span class="line-added">102         }</span>
<span class="line-added">103 </span>
<span class="line-added">104         @Override</span>
<span class="line-added">105         public int hashCode() {</span>
<span class="line-added">106             return Objects.hash(a, b);</span>
<span class="line-added">107         }</span>
108     }
109 
<a name="16" id="anc16"></a><span class="line-added">110     private int expectedBarriers;</span>
<span class="line-added">111 </span>
112     /**
<a name="17" id="anc17"></a><span class="line-modified">113      * Expected 2 barriers for the card mark GCs and 4 for G1 (2 pre + 2 post).</span>
114      */
115     @Test
<a name="18" id="anc18"></a><span class="line-modified">116     public void testAllocation() throws Exception {</span>
<span class="line-modified">117         this.expectedBarriers = (config.useG1GC) ? 4 : 2;</span>
<span class="line-added">118         testWithoutPEA(&quot;testAllocationSnippet&quot;);</span>
119     }
120 
<a name="19" id="anc19"></a><span class="line-modified">121     public static Container testAllocationSnippet() {</span>
122         Container main = new Container();
123         Container temp1 = new Container();
124         Container temp2 = new Container();
125         main.a = temp1;
126         main.b = temp2;
<a name="20" id="anc20"></a><span class="line-added">127         return main;</span>
128     }
129 
130     /**
<a name="21" id="anc21"></a><span class="line-modified">131      * Expected 4 barriers for the card mark GCs and 8 for G1 (4 pre + 4 post).</span>
132      */
133     @Test
<a name="22" id="anc22"></a><span class="line-modified">134     public void testLoopAllocation1() throws Exception {</span>
<span class="line-modified">135         this.expectedBarriers = config.useG1GC ? 8 : 4;</span>
<span class="line-added">136         testWithoutPEA(&quot;test2Snippet&quot;, false);</span>
<span class="line-added">137         testWithoutPEA(&quot;test2Snippet&quot;, true);</span>
138     }
139 
140     public static void test2Snippet(boolean test) {
141         Container main = new Container();
142         Container temp1 = new Container();
143         Container temp2 = new Container();
144         for (int i = 0; i &lt; 10; i++) {
145             if (test) {
146                 main.a = temp1;
147                 main.b = temp2;
148             } else {
149                 main.a = temp2;
150                 main.b = temp1;
151             }
152         }
153     }
154 
155     /**
<a name="23" id="anc23"></a><span class="line-modified">156      * Expected 4 barriers for the card mark GCs and 8 for G1 (4 pre + 4 post).</span>
157      */
158     @Test
<a name="24" id="anc24"></a><span class="line-modified">159     public void testLoopAllocation2() throws Exception {</span>
<span class="line-modified">160         this.expectedBarriers = config.useG1GC ? 8 : 4;</span>
<span class="line-added">161         testWithoutPEA(&quot;test3Snippet&quot;);</span>
162     }
163 
164     public static void test3Snippet() {
165         Container[] main = new Container[10];
166         Container temp1 = new Container();
167         Container temp2 = new Container();
168         for (int i = 0; i &lt; 10; i++) {
169             main[i].a = main[i].b = temp1;
170         }
171 
172         for (int i = 0; i &lt; 10; i++) {
173             main[i].a = main[i].b = temp2;
174         }
175     }
176 
177     /**
<a name="25" id="anc25"></a><span class="line-modified">178      * Expected 2 barriers for the card mark GCs and 5 for G1 (3 pre + 2 post) The (2 or 4) barriers</span>
<span class="line-modified">179      * are emitted while initializing the fields of the WeakReference instance. The extra pre</span>
<span class="line-modified">180      * barrier of G1 concerns the read of the referent field.</span>
181      */
182     @Test
<a name="26" id="anc26"></a><span class="line-modified">183     public void testReferenceGet() throws Exception {</span>
<span class="line-modified">184         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">185         test(&quot;testReferenceGetSnippet&quot;);</span>
186     }
187 
<a name="27" id="anc27"></a><span class="line-modified">188     public static Object testReferenceGetSnippet() {</span>
<span class="line-modified">189         return weakReference.get();</span>

190     }
191 
<a name="28" id="anc28"></a><span class="line-modified">192     static class DummyReference {</span>
<span class="line-modified">193         Object referent;</span>









194     }
195 
<a name="29" id="anc29"></a><span class="line-modified">196     private static MetaAccessProvider getStaticMetaAccess() {</span>
<span class="line-modified">197         return ((HotSpotBackend) Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend()).getRuntime().getHostProviders().getMetaAccess();</span>



198     }
199 
<a name="30" id="anc30"></a><span class="line-modified">200     private static final WeakReference&lt;?&gt; weakReference = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-modified">201     private static final Object weakReferenceAsObject = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-modified">202     private static final long referenceReferentFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(Reference.class), &quot;referent&quot;);</span>
<span class="line-modified">203     private static final long referenceQueueFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(Reference.class), &quot;queue&quot;);</span>
204 
<a name="31" id="anc31"></a><span class="line-modified">205     private static final DummyReference dummyReference = new DummyReference();</span>
<span class="line-modified">206     private static final long dummyReferenceReferentFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(DummyReference.class), &quot;referent&quot;);</span>

207 
208     /**
<a name="32" id="anc32"></a><span class="line-modified">209      * The type is known to be WeakReference and the offset is a constant, so the</span>
<span class="line-modified">210      * {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is converted back into a normal</span>
<span class="line-added">211      * LoadFieldNode and the lowering of the field node inserts the proper barrier.</span>
212      */
213     @Test
<a name="33" id="anc33"></a><span class="line-modified">214     public void testReferenceReferent1() throws Exception {</span>
<span class="line-modified">215         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">216         test(&quot;testReferenceReferentSnippet&quot;);</span>
<span class="line-added">217     }</span>
<span class="line-added">218 </span>
<span class="line-added">219     public Object testReferenceReferentSnippet() {</span>
<span class="line-added">220         return UNSAFE.getObject(weakReference, referenceReferentFieldOffset);</span>
221     }
222 
223     /**
<a name="34" id="anc34"></a><span class="line-modified">224      * The type is known to be WeakReference and the offset is non-constant, so the lowering of the</span>
<span class="line-modified">225      * {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is guarded by a check that the offset</span>
<span class="line-added">226      * is the same as {@link #referenceReferentFieldOffset} which does a barrier if requires it.</span>
227      */
228     @Test
<a name="35" id="anc35"></a><span class="line-modified">229     public void testReferenceReferent2() throws Exception {</span>
<span class="line-modified">230         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">231         test(&quot;testReferenceReferent2Snippet&quot;, referenceReferentFieldOffset);</span>
<span class="line-added">232     }</span>
<span class="line-added">233 </span>
<span class="line-added">234     public Object testReferenceReferent2Snippet(long offset) {</span>
<span class="line-added">235         return UNSAFE.getObject(weakReference, offset);</span>
236     }
237 
238     /**
<a name="36" id="anc36"></a><span class="line-modified">239      * The type is known to be WeakReference and the offset is constant but not the referent field,</span>
<span class="line-modified">240      * so no barrier is required.</span>

241      */
242     @Test
<a name="37" id="anc37"></a><span class="line-modified">243     public void testReferenceReferent3() throws Exception {</span>
<span class="line-modified">244         this.expectedBarriers = 0;</span>
<span class="line-added">245         test(&quot;testReferenceReferent3Snippet&quot;);</span>
<span class="line-added">246     }</span>
<span class="line-added">247 </span>
<span class="line-added">248     public Object testReferenceReferent3Snippet() {</span>
<span class="line-added">249         return UNSAFE.getObject(weakReference, referenceQueueFieldOffset);</span>
250     }
251 
252     /**
<a name="38" id="anc38"></a><span class="line-modified">253      * The type is a super class of WeakReference and the offset is non-constant, so the lowering of</span>
<span class="line-modified">254      * the {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is guarded by a check that the</span>
<span class="line-modified">255      * offset is the same as {@link #referenceReferentFieldOffset} and the base object is a</span>
<span class="line-added">256      * subclasses of {@link java.lang.ref.Reference} and does a barrier if requires it.</span>
257      */
258     @Test
<a name="39" id="anc39"></a><span class="line-modified">259     public void testReferenceReferent4() throws Exception {</span>
<span class="line-modified">260         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">261         test(&quot;testReferenceReferent4Snippet&quot;);</span>
<span class="line-added">262     }</span>
<span class="line-added">263 </span>
<span class="line-added">264     public Object testReferenceReferent4Snippet() {</span>
<span class="line-added">265         return UNSAFE.getObject(weakReferenceAsObject, referenceReferentFieldOffset);</span>
266     }
267 
268     /**
<a name="40" id="anc40"></a><span class="line-modified">269      * The type is not related to Reference at all so no barrier check is required. This should be</span>
<span class="line-modified">270      * statically detectable.</span>

271      */
272     @Test
<a name="41" id="anc41"></a><span class="line-modified">273     public void testReferenceReferent5() throws Exception {</span>
<span class="line-modified">274         this.expectedBarriers = 0;</span>
<span class="line-added">275         Assert.assertEquals(&quot;expected fields to have the same offset&quot;, referenceReferentFieldOffset, dummyReferenceReferentFieldOffset);</span>
<span class="line-added">276         test(&quot;testReferenceReferent5Snippet&quot;);</span>
<span class="line-added">277     }</span>
<span class="line-added">278 </span>
<span class="line-added">279     public Object testReferenceReferent5Snippet() {</span>
<span class="line-added">280         return UNSAFE.getObject(dummyReference, referenceReferentFieldOffset);</span>
281     }
282 
283     static Object[] src = new Object[1];
284     static Object[] dst = new Object[1];
285 
286     static {
287         for (int i = 0; i &lt; src.length; i++) {
288             src[i] = new Object();
289         }
290         for (int i = 0; i &lt; dst.length; i++) {
291             dst[i] = new Object();
292         }
293     }
294 
<a name="42" id="anc42"></a><span class="line-modified">295     public static void testArrayCopySnippet(Object a, Object b, Object c) throws Exception {</span>
296         System.arraycopy(a, 0, b, 0, (int) c);
297     }
298 
299     @Test
<a name="43" id="anc43"></a><span class="line-modified">300     public void testArrayCopy() throws Exception {</span>
<span class="line-modified">301         this.expectedBarriers = 0;</span>
<span class="line-added">302         test(&quot;testArrayCopySnippet&quot;, src, dst, dst.length);</span>
303     }
304 
<a name="44" id="anc44"></a><span class="line-modified">305     private void verifyBarriers(StructuredGraph graph) {</span>
<span class="line-modified">306         Assert.assertTrue(&quot;Unknown collector selected&quot;, knownSupport.contains(runtime().getGarbageCollector()));</span>
<span class="line-modified">307         Assert.assertNotEquals(&quot;test must set expected barrier count&quot;, expectedBarriers, -1);</span>
<span class="line-modified">308         int barriers = 0;</span>
<span class="line-modified">309         if (config.useG1GC) {</span>
<span class="line-modified">310             barriers = graph.getNodes().filter(G1ReferentFieldReadBarrier.class).count() + graph.getNodes().filter(G1PreWriteBarrier.class).count() +</span>
<span class="line-modified">311                             graph.getNodes().filter(G1PostWriteBarrier.class).count();</span>
<span class="line-modified">312         } else {</span>
<span class="line-modified">313             barriers = graph.getNodes().filter(SerialWriteBarrier.class).count();</span>
<span class="line-modified">314         }</span>
<span class="line-modified">315         if (expectedBarriers != barriers) {</span>
<span class="line-modified">316             Assert.assertEquals(expectedBarriers, barriers);</span>
<span class="line-modified">317         }</span>
<span class="line-modified">318         for (WriteNode write : graph.getNodes().filter(WriteNode.class)) {</span>
















319             if (config.useG1GC) {
<a name="45" id="anc45"></a><span class="line-modified">320                 if (write.getBarrierType() != HeapAccess.BarrierType.NONE) {</span>
<span class="line-modified">321                     Assert.assertEquals(1, write.successors().count());</span>
<span class="line-added">322                     Assert.assertTrue(write.next() instanceof G1PostWriteBarrier);</span>
<span class="line-added">323                     Assert.assertTrue(write.predecessor() instanceof G1PreWriteBarrier || write.getLocationIdentity().isImmutable());</span>
<span class="line-added">324                 }</span>
325             } else {
<a name="46" id="anc46"></a><span class="line-modified">326                 if (write.getBarrierType() != HeapAccess.BarrierType.NONE) {</span>
<span class="line-modified">327                     Assert.assertEquals(1, write.successors().count());</span>
<span class="line-modified">328                     Assert.assertTrue(write.next() instanceof SerialWriteBarrier);</span>














329                 }
330             }
<a name="47" id="anc47"></a><span class="line-added">331         }</span>
332 
<a name="48" id="anc48"></a><span class="line-modified">333         for (ReadNode read : graph.getNodes().filter(ReadNode.class)) {</span>
<span class="line-modified">334             if (read.getBarrierType() != HeapAccess.BarrierType.NONE) {</span>
<span class="line-modified">335                 if (read.getAddress() instanceof OffsetAddressNode) {</span>
336                     JavaConstant constDisp = ((OffsetAddressNode) read.getAddress()).getOffset().asJavaConstant();
<a name="49" id="anc49"></a><span class="line-modified">337                     if (constDisp != null) {</span>
<span class="line-modified">338                         Assert.assertEquals(referentOffset(getMetaAccess()), constDisp.asLong());</span>
<span class="line-modified">339                     }</span>
<span class="line-modified">340                 }</span>
<span class="line-added">341                 Assert.assertTrue(HeapAccess.BarrierType.WEAK_FIELD == read.getBarrierType() || HeapAccess.BarrierType.MAYBE_WEAK_FIELD == read.getBarrierType());</span>
<span class="line-added">342                 if (config.useG1GC) {</span>
343                     Assert.assertTrue(read.next() instanceof G1ReferentFieldReadBarrier);
344                 }
345             }
<a name="50" id="anc50"></a>

346         }
347     }
348 
<a name="51" id="anc51"></a><span class="line-modified">349     protected Result testWithoutPEA(String name, Object... args) {</span>
<span class="line-modified">350         return test(new OptionValues(getInitialOptions(), PartialEscapeAnalysis, false, FullUnroll, false, LoopPeeling, false), name, args);</span>
<span class="line-modified">351     }</span>
<span class="line-added">352 </span>
<span class="line-added">353     @Before</span>
<span class="line-added">354     public void before() {</span>
<span class="line-added">355         expectedBarriers = -1;</span>
<span class="line-added">356     }</span>
<span class="line-added">357 </span>
<span class="line-added">358     /*</span>
<span class="line-added">359      * Check the state of the barriers immediately after insertion.</span>
<span class="line-added">360      */</span>
<span class="line-added">361     @Override</span>
<span class="line-added">362     protected Suites createSuites(OptionValues opts) {</span>
<span class="line-added">363         Suites ret = getBackend().getSuites().getDefaultSuites(opts).copy();</span>
<span class="line-added">364         ListIterator&lt;BasePhase&lt;? super MidTierContext&gt;&gt; iter = ret.getMidTier().findPhase(WriteBarrierAdditionPhase.class, true);</span>
<span class="line-added">365         iter.add(new Phase() {</span>
<span class="line-added">366 </span>
<span class="line-added">367             @Override</span>
<span class="line-added">368             protected void run(StructuredGraph graph) {</span>
<span class="line-added">369                 verifyBarriers(graph);</span>
<span class="line-added">370             }</span>
<span class="line-added">371 </span>
<span class="line-added">372             @Override</span>
<span class="line-added">373             public float codeSizeIncrease() {</span>
<span class="line-added">374                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;</span>
<span class="line-added">375             }</span>
<span class="line-added">376 </span>
<span class="line-added">377             @Override</span>
<span class="line-added">378             protected CharSequence getName() {</span>
<span class="line-added">379                 return &quot;VerifyBarriersPhase&quot;;</span>
<span class="line-added">380             }</span>
<span class="line-added">381         });</span>
<span class="line-added">382         return ret;</span>
383     }
384 }
<a name="52" id="anc52"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="52" type="hidden" />
</body>
</html>
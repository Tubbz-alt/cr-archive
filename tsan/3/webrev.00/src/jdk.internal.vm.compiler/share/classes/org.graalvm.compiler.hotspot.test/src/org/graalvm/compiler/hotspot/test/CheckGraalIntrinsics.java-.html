<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CheckGraalIntrinsics.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
 27 import java.lang.reflect.Method;
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.Collection;
 31 import java.util.Collections;
 32 import java.util.Formatter;
 33 import java.util.List;
 34 import java.util.ServiceLoader;
 35 import java.util.Set;
 36 import java.util.TreeSet;
 37 import java.util.stream.Collectors;
 38 
 39 import jdk.internal.vm.compiler.collections.EconomicMap;
 40 import jdk.internal.vm.compiler.collections.MapCursor;
 41 import org.graalvm.compiler.api.test.Graal;
 42 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 43 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 44 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 45 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 46 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 47 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 48 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Binding;
 49 import org.graalvm.compiler.runtime.RuntimeProvider;
 50 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 51 import org.graalvm.compiler.test.GraalTest;
 52 import org.junit.Test;
 53 
 54 import jdk.vm.ci.aarch64.AArch64;
 55 import jdk.vm.ci.amd64.AMD64;
 56 import jdk.vm.ci.code.Architecture;
 57 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
 58 import jdk.vm.ci.hotspot.VMIntrinsicMethod;
 59 import jdk.vm.ci.meta.MetaAccessProvider;
 60 import jdk.vm.ci.meta.MetaUtil;
 61 import jdk.vm.ci.meta.MethodHandleAccessProvider.IntrinsicMethod;
 62 import jdk.vm.ci.meta.ResolvedJavaMethod;
 63 
 64 /**
 65  * Checks the intrinsics implemented by Graal against the set of intrinsics declared by HotSpot. The
 66  * purpose of this test is to detect when new intrinsics are added to HotSpot and process them
 67  * appropriately in Graal. This will be achieved by working through {@link #toBeInvestigated} and
 68  * either implementing the intrinsic or moving it to {@link #ignore} .
 69  */
 70 public class CheckGraalIntrinsics extends GraalTest {
 71 
 72     public static boolean match(String type, Binding binding, VMIntrinsicMethod intrinsic) {
 73         if (intrinsic.name.equals(binding.name)) {
 74             if (intrinsic.descriptor.startsWith(binding.argumentsDescriptor)) {
 75                 if (type.equals(intrinsic.declaringClass)) {
 76                     return true;
 77                 }
 78             }
 79         }
 80         return false;
 81     }
 82 
 83     public static InvocationPlugin findPlugin(EconomicMap&lt;String, List&lt;Binding&gt;&gt; bindings, VMIntrinsicMethod intrinsic) {
 84         MapCursor&lt;String, List&lt;Binding&gt;&gt; cursor = bindings.getEntries();
 85         while (cursor.advance()) {
 86             // Match format of VMIntrinsicMethod.declaringClass
 87             String type = MetaUtil.internalNameToJava(cursor.getKey(), true, false).replace(&#39;.&#39;, &#39;/&#39;);
 88             for (Binding binding : cursor.getValue()) {
 89                 if (match(type, binding, intrinsic)) {
 90                     return binding.plugin;
 91                 }
 92             }
 93         }
 94         return null;
 95     }
 96 
 97     public static ResolvedJavaMethod resolveIntrinsic(MetaAccessProvider metaAccess, VMIntrinsicMethod intrinsic) throws ClassNotFoundException {
 98         Class&lt;?&gt; c;
 99         try {
100             c = Class.forName(intrinsic.declaringClass.replace(&#39;/&#39;, &#39;.&#39;), false, CheckGraalIntrinsics.class.getClassLoader());
101         } catch (ClassNotFoundException ex) {
102             try {
103                 Class.forName(&quot;javax.naming.Reference&quot;);
104             } catch (ClassNotFoundException coreNamingMissing) {
105                 // if core JDK classes aren&#39;t found, we are probably running in a
106                 // JDK9 java.base environment and then missing class is OK
107                 return null;
108             }
109             throw ex;
110         }
111         for (Method javaMethod : c.getDeclaredMethods()) {
112             if (javaMethod.getName().equals(intrinsic.name)) {
113                 ResolvedJavaMethod method = metaAccess.lookupJavaMethod(javaMethod);
114                 if (intrinsic.descriptor.equals(&quot;*&quot;)) {
115                     // Signature polymorphic method - name match is enough
116                     return method;
117                 } else {
118                     if (method.getSignature().toMethodDescriptor().equals(intrinsic.descriptor)) {
119                         return method;
120                     }
121                 }
122             }
123         }
124         return null;
125     }
126 
127     /**
128      * The HotSpot intrinsics that:
129      * &lt;ul&gt;
130      * &lt;li&gt;will never implemented by Graal (comments must explain why)&lt;/li&gt;
131      * &lt;li&gt;are implemented without {@link InvocationPlugin}s, or&lt;/li&gt;
132      * &lt;li&gt;whose {@link InvocationPlugin} registration is guarded by a condition that is false in
133      * the current VM context.&lt;/li&gt;
134      * &lt;/ul&gt;
135      */
136     public final Set&lt;String&gt; ignore = new TreeSet&lt;&gt;();
137 
138     /**
139      * The HotSpot intrinsics whose {@link InvocationPlugin} registration is guarded by a condition
140      * too complex to duplicate here.
141      * &lt;/ul&gt;
142      */
143     public final Set&lt;String&gt; complexGuard = new TreeSet&lt;&gt;();
144 
145     /**
146      * The HotSpot intrinsics implemented downstream.
147      * &lt;/ul&gt;
148      */
149     public final Set&lt;String&gt; downstream = new TreeSet&lt;&gt;();
150 
151     /**
152      * The HotSpot intrinsics yet to be implemented or moved to {@link #ignore}.
153      */
154     public final Set&lt;String&gt; toBeInvestigated = new TreeSet&lt;&gt;();
155 
156     private static Collection&lt;String&gt; add(Collection&lt;String&gt; c, String... elements) {
157         String[] sorted = elements.clone();
158         Arrays.sort(sorted);
159         for (int i = 0; i &lt; elements.length; i++) {
160             if (!elements[i].equals(sorted[i])) {
161                 // Let&#39;s keep the list sorted for easier visual inspection
162                 fail(&quot;Element %d is out of order, \&quot;%s\&quot;&quot;, i, elements[i]);
163             }
164         }
165         c.addAll(Arrays.asList(elements));
166         return c;
167     }
168 
169     public final HotSpotGraalRuntimeProvider rt = (HotSpotGraalRuntimeProvider) Graal.getRequiredCapability(RuntimeProvider.class);
170     public final Architecture arch = rt.getHostBackend().getTarget().arch;
171     public final GraalHotSpotVMConfig config = rt.getVMConfig();
172 
173     public CheckGraalIntrinsics() {
174         // These are dead
175         add(ignore,
176                         &quot;java/lang/Math.atan2(DD)D&quot;,
177                         &quot;jdk/internal/misc/Unsafe.park(ZJ)V&quot;,
178                         &quot;jdk/internal/misc/Unsafe.unpark(Ljava/lang/Object;)V&quot;,
179                         &quot;sun/misc/Unsafe.park(ZJ)V&quot;,
180                         &quot;sun/misc/Unsafe.prefetchRead(Ljava/lang/Object;J)V&quot;,
181                         &quot;sun/misc/Unsafe.prefetchReadStatic(Ljava/lang/Object;J)V&quot;,
182                         &quot;sun/misc/Unsafe.prefetchWrite(Ljava/lang/Object;J)V&quot;,
183                         &quot;sun/misc/Unsafe.prefetchWriteStatic(Ljava/lang/Object;J)V&quot;,
184                         &quot;sun/misc/Unsafe.unpark(Ljava/lang/Object;)V&quot;);
185 
186         // These only exist to assist escape analysis in C2
187         add(ignore,
188                         &quot;java/lang/Throwable.fillInStackTrace()Ljava/lang/Throwable;&quot;);
189 
190         // These are only used for the security handling during stack walking
191         add(ignore,
192                         &quot;java/lang/reflect/Method.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;);
193 
194         // These are marker intrinsic ids only
195         add(ignore,
196                         &quot;java/lang/invoke/MethodHandle.&lt;compiledLambdaForm&gt;*&quot;,
197                         &quot;java/lang/invoke/MethodHandle.invoke*&quot;);
198 
199         // These are implemented through lowering
200         add(ignore,
201                         &quot;java/lang/ref/Reference.get()Ljava/lang/Object;&quot;);
202 
203         // These are only used by C1
204         add(ignore,
205                         &quot;java/nio/Buffer.checkIndex(I)I&quot;);
206 
207         // These do general compiler optimizations and convert min/max to cmov instructions. We are
208         // ignoring them as cmovs are not necessarily beneficial.
209         add(ignore,
210                         &quot;java/lang/Math.max(II)I&quot;,
211                         &quot;java/lang/Math.min(II)I&quot;);
212 
213         // These are known to be implemented down stream
214         add(downstream,
215                         &quot;java/lang/Integer.toString(I)Ljava/lang/String;&quot;,
216                         &quot;java/lang/String.&lt;init&gt;(Ljava/lang/String;)V&quot;,
217                         &quot;java/lang/StringBuffer.&lt;init&gt;()V&quot;,
218                         &quot;java/lang/StringBuffer.&lt;init&gt;(I)V&quot;,
219                         &quot;java/lang/StringBuffer.&lt;init&gt;(Ljava/lang/String;)V&quot;,
220                         &quot;java/lang/StringBuffer.append(C)Ljava/lang/StringBuffer;&quot;,
221                         &quot;java/lang/StringBuffer.append(I)Ljava/lang/StringBuffer;&quot;,
222                         &quot;java/lang/StringBuffer.append(Ljava/lang/String;)Ljava/lang/StringBuffer;&quot;,
223                         &quot;java/lang/StringBuffer.toString()Ljava/lang/String;&quot;,
224                         &quot;java/lang/StringBuilder.&lt;init&gt;()V&quot;,
225                         &quot;java/lang/StringBuilder.&lt;init&gt;(I)V&quot;,
226                         &quot;java/lang/StringBuilder.&lt;init&gt;(Ljava/lang/String;)V&quot;,
227                         &quot;java/lang/StringBuilder.append(C)Ljava/lang/StringBuilder;&quot;,
228                         &quot;java/lang/StringBuilder.append(I)Ljava/lang/StringBuilder;&quot;,
229                         &quot;java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;,
230                         &quot;java/lang/StringBuilder.toString()Ljava/lang/String;&quot;,
231                         &quot;java/util/Arrays.copyOf([Ljava/lang/Object;ILjava/lang/Class;)[Ljava/lang/Object;&quot;,
232                         &quot;java/util/Arrays.copyOfRange([Ljava/lang/Object;IILjava/lang/Class;)[Ljava/lang/Object;&quot;);
233 
234         add(complexGuard,
235                         &quot;java/lang/Integer.bitCount(I)I&quot;,
236                         &quot;java/lang/Integer.numberOfLeadingZeros(I)I&quot;,
237                         &quot;java/lang/Integer.numberOfTrailingZeros(I)I&quot;,
238                         &quot;java/lang/Long.bitCount(J)I&quot;,
239                         &quot;java/lang/Long.numberOfLeadingZeros(J)I&quot;,
240                         &quot;java/lang/Long.numberOfTrailingZeros(J)I&quot;);
241 
242         // Relevant for Java flight recorder
243         add(toBeInvestigated,
244                         &quot;oracle/jrockit/jfr/Timing.counterTime()J&quot;,
245                         &quot;oracle/jrockit/jfr/VMJFR.classID0(Ljava/lang/Class;)J&quot;,
246                         &quot;oracle/jrockit/jfr/VMJFR.threadID()I&quot;);
247 
248         add(toBeInvestigated,
249                         // Similar to addExact
250                         &quot;java/lang/Math.negateExact(I)I&quot;,
251                         // Similar to addExact
252                         &quot;java/lang/Math.negateExact(J)J&quot;,
253                         // HotSpot MacroAssembler-based intrinsic
254                         &quot;java/lang/String.indexOf(Ljava/lang/String;)I&quot;,
255                         // Can share most implementation parts with with
256                         // Unsafe.allocateUninitializedArray0
257                         &quot;java/lang/reflect/Array.newArray(Ljava/lang/Class;I)Ljava/lang/Object;&quot;,
258                         // HotSpot MacroAssembler-based intrinsic
259                         &quot;sun/nio/cs/ISO_8859_1$Encoder.encodeISOArray([CI[BII)I&quot;,
260                         // We have implemented implCompressMultiBlock0 on JDK9+. Does it worth
261                         // backporting as corresponding HotSpot stubs are only generated on SPARC?
262                         &quot;sun/security/provider/DigestBase.implCompressMultiBlock([BII)I&quot;);
263 
264         // See JDK-8207146.
265         String oopName = isJDK12OrHigher() ? &quot;Reference&quot; : &quot;Object&quot;;
266 
267         if (isJDK9OrHigher()) {
268             // Relevant for Java flight recorder
269             add(toBeInvestigated,
270                             &quot;jdk/jfr/internal/JVM.counterTime()J&quot;,
271                             &quot;jdk/jfr/internal/JVM.getBufferWriter()Ljava/lang/Object;&quot;,
272                             &quot;jdk/jfr/internal/JVM.getClassId(Ljava/lang/Class;)J&quot;);
273 
274             add(toBeInvestigated,
275                             // HotSpot MacroAssembler-based intrinsic
276                             &quot;java/lang/Math.fma(DDD)D&quot;,
277                             // HotSpot MacroAssembler-based intrinsic
278                             &quot;java/lang/Math.fma(FFF)F&quot;,
279                             // Just check if the argument is a compile time constant
280                             &quot;java/lang/invoke/MethodHandleImpl.isCompileConstant(Ljava/lang/Object;)Z&quot;,
281                             // Only used as a marker for vectorization?
282                             &quot;java/util/stream/Streams$RangeIntSpliterator.forEachRemaining(Ljava/util/function/IntConsumer;)V&quot;,
283                             // Only implemented on non-AMD64 platforms (some logic and runtime call)
284                             &quot;java/util/zip/Adler32.updateByteBuffer(IJII)I&quot;,
285                             // Only implemented on non-AMD64 platforms (some logic and runtime call)
286                             &quot;java/util/zip/Adler32.updateBytes(I[BII)I&quot;,
287                             // Emits a slow and a fast path and some dispatching logic
288                             &quot;jdk/internal/misc/Unsafe.allocateUninitializedArray0(Ljava/lang/Class;I)Ljava/lang/Object;&quot;,
289 
290                             // Control flow, deopts, and a cast
291                             &quot;jdk/internal/util/Preconditions.checkIndex(IILjava/util/function/BiFunction;)I&quot;,
292                             // HotSpot MacroAssembler-based intrinsic
293                             &quot;sun/nio/cs/ISO_8859_1$Encoder.implEncodeISOArray([CI[BII)I&quot;);
294 
295             /*
296              * Per default, all these operations are mapped to some generic method for which we
297              * already have compiler intrinsics. Performance-wise it would be better to support them
298              * explicitly as the more generic method might be more restrictive and therefore slower
299              * than necessary.
300              */
301 
302             add(toBeInvestigated,
303                             // Mapped to compareAndExchange*
304                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeByteAcquire(Ljava/lang/Object;JBB)B&quot;,
305                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeByteRelease(Ljava/lang/Object;JBB)B&quot;,
306                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeIntAcquire(Ljava/lang/Object;JII)I&quot;,
307                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeIntRelease(Ljava/lang/Object;JII)I&quot;,
308                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeLongAcquire(Ljava/lang/Object;JJJ)J&quot;,
309                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeLongRelease(Ljava/lang/Object;JJJ)J&quot;,
310                             &quot;jdk/internal/misc/Unsafe.compareAndExchange&quot; + oopName + &quot;Acquire(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;,
311                             &quot;jdk/internal/misc/Unsafe.compareAndExchange&quot; + oopName + &quot;Release(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;,
312                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeShortAcquire(Ljava/lang/Object;JSS)S&quot;,
313                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeShortRelease(Ljava/lang/Object;JSS)S&quot;,
314 
315                             // Mapped to compareAndSet*
316                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetByte(Ljava/lang/Object;JBB)Z&quot;,
317                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetByteAcquire(Ljava/lang/Object;JBB)Z&quot;,
318                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetBytePlain(Ljava/lang/Object;JBB)Z&quot;,
319                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetByteRelease(Ljava/lang/Object;JBB)Z&quot;,
320                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetInt(Ljava/lang/Object;JII)Z&quot;,
321                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetIntAcquire(Ljava/lang/Object;JII)Z&quot;,
322                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetIntPlain(Ljava/lang/Object;JII)Z&quot;,
323                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetIntRelease(Ljava/lang/Object;JII)Z&quot;,
324                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLong(Ljava/lang/Object;JJJ)Z&quot;,
325                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLongAcquire(Ljava/lang/Object;JJJ)Z&quot;,
326                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLongPlain(Ljava/lang/Object;JJJ)Z&quot;,
327                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLongRelease(Ljava/lang/Object;JJJ)Z&quot;,
328                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
329                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;Acquire(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
330                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;Plain(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
331                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;Release(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
332                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShort(Ljava/lang/Object;JSS)Z&quot;,
333                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShortAcquire(Ljava/lang/Object;JSS)Z&quot;,
334                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShortPlain(Ljava/lang/Object;JSS)Z&quot;,
335                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShortRelease(Ljava/lang/Object;JSS)Z&quot;);
336 
337             // Compact string support - HotSpot MacroAssembler-based intrinsic or complex C2 logic.
338             add(toBeInvestigated,
339                             &quot;java/lang/StringCoding.hasNegatives([BII)Z&quot;,
340                             &quot;java/lang/StringCoding.implEncodeISOArray([BI[BII)I&quot;);
341             add(ignore,
342                             // handled through an intrinsic for String.equals itself
343                             &quot;java/lang/StringLatin1.equals([B[B)Z&quot;,
344 
345                             // handled by an intrinsic for StringLatin1.indexOf([BI[BII)I
346                             &quot;java/lang/StringLatin1.indexOf([B[B)I&quot;,
347 
348                             // handled through an intrinsic for String.equals itself
349                             &quot;java/lang/StringUTF16.equals([B[B)Z&quot;,
350 
351                             // handled by an intrinsic for StringUTF16.indexOfUnsafe
352                             &quot;java/lang/StringUTF16.indexOf([BI[BII)I&quot;,
353                             &quot;java/lang/StringUTF16.indexOf([B[B)I&quot;,
354 
355                             // handled by an intrinsic for StringUTF16.indexOfCharUnsafe
356                             &quot;java/lang/StringUTF16.indexOfChar([BIII)I&quot;,
357 
358                             // handled by an intrinsic for StringUTF16.indexOfLatin1Unsafe
359                             &quot;java/lang/StringUTF16.indexOfLatin1([BI[BII)I&quot;,
360                             &quot;java/lang/StringUTF16.indexOfLatin1([B[B)I&quot;);
361 
362             if (!config.useAESCTRIntrinsics) {
363                 add(ignore,
364                                 &quot;com/sun/crypto/provider/CounterMode.implCrypt([BII[BI)I&quot;);
365             }
366             if (!config.useGHASHIntrinsics()) {
367                 add(ignore,
368                                 &quot;com/sun/crypto/provider/GHASH.processBlocks([BII[J[J)V&quot;);
369             }
370             if (!(config.useSHA1Intrinsics() || config.useSHA256Intrinsics() || config.useSHA512Intrinsics())) {
371                 add(ignore,
372                                 &quot;sun/security/provider/DigestBase.implCompressMultiBlock0([BII)I&quot;);
373             }
374         }
375 
376         if (isJDK10OrHigher()) {
377             add(toBeInvestigated,
378                             &quot;java/lang/Math.multiplyHigh(JJ)J&quot;);
379         }
380 
381         if (isJDK11OrHigher()) {
382             // Relevant for Java flight recorder
383             add(toBeInvestigated,
384                             &quot;java/util/Base64$Encoder.encodeBlock([BII[BIZ)V&quot;,
385                             &quot;jdk/jfr/internal/JVM.getEventWriter()Ljava/lang/Object;&quot;);
386         }
387 
388         if (isJDK12OrHigher()) {
389             add(toBeInvestigated,
390                             &quot;java/lang/CharacterDataLatin1.isDigit(I)Z&quot;,
391                             &quot;java/lang/CharacterDataLatin1.isLowerCase(I)Z&quot;,
392                             &quot;java/lang/CharacterDataLatin1.isUpperCase(I)Z&quot;,
393                             &quot;java/lang/CharacterDataLatin1.isWhitespace(I)Z&quot;);
394         }
395 
396         if (isJDK13OrHigher()) {
397             add(toBeInvestigated,
398                             &quot;java/lang/Math.max(DD)D&quot;,
399                             &quot;java/lang/Math.max(FF)F&quot;,
400                             &quot;java/lang/Math.min(DD)D&quot;,
401                             &quot;java/lang/Math.min(FF)F&quot;);
402         }
403 
404         if (!config.inlineNotify()) {
405             add(ignore, &quot;java/lang/Object.notify()V&quot;);
406         }
407         if (!config.inlineNotifyAll()) {
408             add(ignore, &quot;java/lang/Object.notifyAll()V&quot;);
409         }
410 
411         if (!(arch instanceof AMD64)) {
412             // Can we implement these on non-AMD64 platforms? C2 seems to.
413             add(toBeInvestigated,
414                             &quot;java/lang/String.compareTo(Ljava/lang/String;)I&quot;,
415                             &quot;java/lang/StringLatin1.indexOf([B[B)I&quot;,
416                             &quot;java/lang/StringLatin1.inflate([BI[BII)V&quot;,
417                             &quot;java/lang/StringLatin1.inflate([BI[CII)V&quot;,
418                             &quot;java/lang/StringUTF16.compress([BI[BII)I&quot;,
419                             &quot;java/lang/StringUTF16.compress([CI[BII)I&quot;,
420                             &quot;java/lang/StringUTF16.indexOf([BI[BII)I&quot;,
421                             &quot;java/lang/StringUTF16.indexOf([B[B)I&quot;,
422                             &quot;java/lang/StringUTF16.indexOfChar([BIII)I&quot;,
423                             &quot;java/lang/StringUTF16.indexOfLatin1([BI[BII)I&quot;,
424                             &quot;java/lang/StringUTF16.indexOfLatin1([B[B)I&quot;,
425                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeByte(Ljava/lang/Object;JBB)B&quot;,
426                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeShort(Ljava/lang/Object;JSS)S&quot;,
427                             &quot;jdk/internal/misc/Unsafe.compareAndSetByte(Ljava/lang/Object;JBB)Z&quot;,
428                             &quot;jdk/internal/misc/Unsafe.compareAndSetShort(Ljava/lang/Object;JSS)Z&quot;,
429                             &quot;jdk/internal/misc/Unsafe.getAndAddByte(Ljava/lang/Object;JB)B&quot;,
430                             &quot;jdk/internal/misc/Unsafe.getAndAddShort(Ljava/lang/Object;JS)S&quot;,
431                             &quot;jdk/internal/misc/Unsafe.getAndSetByte(Ljava/lang/Object;JB)B&quot;,
432                             &quot;jdk/internal/misc/Unsafe.getAndSetShort(Ljava/lang/Object;JS)S&quot;,
433                             &quot;sun/misc/Unsafe.getAndAddInt(Ljava/lang/Object;JI)I&quot;,
434                             &quot;sun/misc/Unsafe.getAndAddLong(Ljava/lang/Object;JJ)J&quot;,
435                             &quot;sun/misc/Unsafe.getAndSetInt(Ljava/lang/Object;JI)I&quot;,
436                             &quot;sun/misc/Unsafe.getAndSetLong(Ljava/lang/Object;JJ)J&quot;,
437                             &quot;sun/misc/Unsafe.getAndSet&quot; + oopName + &quot;(Ljava/lang/Object;JLjava/lang/Object;)Ljava/lang/Object;&quot;);
438 
439             if (isJDK9OrHigher()) {
440                 if (!(arch instanceof AArch64)) {
441                     add(toBeInvestigated,
442                                     &quot;java/lang/StringLatin1.compareTo([B[B)I&quot;,
443                                     &quot;java/lang/StringLatin1.compareToUTF16([B[B)I&quot;,
444                                     &quot;java/lang/StringUTF16.compareTo([B[B)I&quot;,
445                                     &quot;java/lang/StringUTF16.compareToLatin1([B[B)I&quot;,
446                                     &quot;jdk/internal/misc/Unsafe.getAndAddInt(Ljava/lang/Object;JI)I&quot;,
447                                     &quot;jdk/internal/misc/Unsafe.getAndAddLong(Ljava/lang/Object;JJ)J&quot;,
448                                     &quot;jdk/internal/misc/Unsafe.getAndSetInt(Ljava/lang/Object;JI)I&quot;,
449                                     &quot;jdk/internal/misc/Unsafe.getAndSetLong(Ljava/lang/Object;JJ)J&quot;,
450                                     &quot;jdk/internal/misc/Unsafe.getAndSet&quot; + oopName + &quot;(Ljava/lang/Object;JLjava/lang/Object;)Ljava/lang/Object;&quot;);
451                 }
452                 add(toBeInvestigated,
453                                 &quot;com/sun/crypto/provider/CounterMode.implCrypt([BII[BI)I&quot;,
454                                 &quot;java/lang/Thread.onSpinWait()V&quot;,
455                                 &quot;java/util/ArraysSupport.vectorizedMismatch(Ljava/lang/Object;JLjava/lang/Object;JII)I&quot;,
456                                 &quot;jdk/internal/misc/Unsafe.getCharUnaligned(Ljava/lang/Object;J)C&quot;,
457                                 &quot;jdk/internal/misc/Unsafe.getIntUnaligned(Ljava/lang/Object;J)I&quot;,
458                                 &quot;jdk/internal/misc/Unsafe.getLongUnaligned(Ljava/lang/Object;J)J&quot;,
459                                 &quot;jdk/internal/misc/Unsafe.getShortUnaligned(Ljava/lang/Object;J)S&quot;,
460                                 &quot;jdk/internal/misc/Unsafe.putCharUnaligned(Ljava/lang/Object;JC)V&quot;,
461                                 &quot;jdk/internal/misc/Unsafe.putIntUnaligned(Ljava/lang/Object;JI)V&quot;,
462                                 &quot;jdk/internal/misc/Unsafe.putLongUnaligned(Ljava/lang/Object;JJ)V&quot;,
463                                 &quot;jdk/internal/misc/Unsafe.putShortUnaligned(Ljava/lang/Object;JS)V&quot;);
464             }
465             if (isJDK10OrHigher()) {
466                 add(toBeInvestigated,
467                                 &quot;jdk/internal/util/ArraysSupport.vectorizedMismatch(Ljava/lang/Object;JLjava/lang/Object;JII)I&quot;);
468             }
469         }
470 
471         /*
472          * The intrinsics down here are known to be implemented but they are not always enabled on
473          * the HotSpot side (e.g., because they require certain CPU features). So, we are ignoring
474          * them if the HotSpot config tells us that they can&#39;t be used.
475          */
476 
477         // CRC32 intrinsics
478         if (!config.useCRC32Intrinsics) {
479             add(ignore, &quot;java/util/zip/CRC32.update(II)I&quot;);
480             if (isJDK9OrHigher()) {
481                 add(ignore,
482                                 &quot;java/util/zip/CRC32.updateByteBuffer0(IJII)I&quot;,
483                                 &quot;java/util/zip/CRC32.updateBytes0(I[BII)I&quot;);
484             } else {
485                 add(ignore,
486                                 &quot;java/util/zip/CRC32.updateByteBuffer(IJII)I&quot;,
487                                 &quot;java/util/zip/CRC32.updateBytes(I[BII)I&quot;);
488             }
489         }
490 
491         // CRC32C intrinsics
492         if (!config.useCRC32CIntrinsics) {
493             add(ignore,
494                             &quot;java/util/zip/CRC32C.updateBytes(I[BII)I&quot;,
495                             &quot;java/util/zip/CRC32C.updateDirectByteBuffer(IJII)I&quot;);
496         }
497 
498         // AES intrinsics
499         if (!config.useAESIntrinsics) {
500             if (isJDK9OrHigher()) {
501                 add(ignore,
502                                 &quot;com/sun/crypto/provider/AESCrypt.implDecryptBlock([BI[BI)V&quot;,
503                                 &quot;com/sun/crypto/provider/AESCrypt.implEncryptBlock([BI[BI)V&quot;,
504                                 &quot;com/sun/crypto/provider/CipherBlockChaining.implDecrypt([BII[BI)I&quot;,
505                                 &quot;com/sun/crypto/provider/CipherBlockChaining.implEncrypt([BII[BI)I&quot;);
506             } else {
507                 add(ignore,
508                                 &quot;com/sun/crypto/provider/AESCrypt.decryptBlock([BI[BI)V&quot;,
509                                 &quot;com/sun/crypto/provider/AESCrypt.encryptBlock([BI[BI)V&quot;,
510                                 &quot;com/sun/crypto/provider/CipherBlockChaining.decrypt([BII[BI)I&quot;,
511                                 &quot;com/sun/crypto/provider/CipherBlockChaining.encrypt([BII[BI)I&quot;);
512             }
513         }
514 
515         // BigInteger intrinsics
516         if (!config.useMultiplyToLenIntrinsic()) {
517             if (isJDK9OrHigher()) {
518                 add(ignore, &quot;java/math/BigInteger.implMultiplyToLen([II[II[I)[I&quot;);
519             } else {
520                 add(ignore, &quot;java/math/BigInteger.multiplyToLen([II[II[I)[I&quot;);
521             }
522         }
523         if (!config.useMulAddIntrinsic()) {
524             add(ignore, &quot;java/math/BigInteger.implMulAdd([I[IIII)I&quot;);
525         }
526         if (!config.useMontgomeryMultiplyIntrinsic()) {
527             add(ignore, &quot;java/math/BigInteger.implMontgomeryMultiply([I[I[IIJ[I)[I&quot;);
528         }
529         if (!config.useMontgomerySquareIntrinsic()) {
530             add(ignore, &quot;java/math/BigInteger.implMontgomerySquare([I[IIJ[I)[I&quot;);
531         }
532         if (!config.useSquareToLenIntrinsic()) {
533             add(ignore, &quot;java/math/BigInteger.implSquareToLen([II[II)[I&quot;);
534         }
535 
536         // SHA intrinsics
537         if (!config.useSHA1Intrinsics()) {
538             if (isJDK9OrHigher()) {
539                 add(ignore, &quot;sun/security/provider/SHA.implCompress0([BI)V&quot;);
540             } else {
541                 add(ignore, &quot;sun/security/provider/SHA.implCompress([BI)V&quot;);
542             }
543         }
544         if (!config.useSHA256Intrinsics()) {
545             if (isJDK9OrHigher()) {
546                 add(ignore, &quot;sun/security/provider/SHA2.implCompress0([BI)V&quot;);
547             } else {
548                 add(ignore, &quot;sun/security/provider/SHA2.implCompress([BI)V&quot;);
549             }
550         }
551         if (!config.useSHA512Intrinsics()) {
552             if (isJDK9OrHigher()) {
553                 add(ignore, &quot;sun/security/provider/SHA5.implCompress0([BI)V&quot;);
554             } else {
555                 add(ignore, &quot;sun/security/provider/SHA5.implCompress([BI)V&quot;);
556             }
557         }
558     }
559 
560     private static boolean isJDK9OrHigher() {
561         return JavaVersionUtil.JAVA_SPECIFICATION_VERSION &gt;= 9;
562     }
563 
564     private static boolean isJDK10OrHigher() {
565         return JavaVersionUtil.JAVA_SPECIFICATION_VERSION &gt;= 10;
566     }
567 
568     private static boolean isJDK11OrHigher() {
569         return JavaVersionUtil.JAVA_SPECIFICATION_VERSION &gt;= 11;
570     }
571 
572     private static boolean isJDK12OrHigher() {
573         return JavaVersionUtil.JAVA_SPECIFICATION_VERSION &gt;= 12;
574     }
575 
576     private static boolean isJDK13OrHigher() {
577         return JavaVersionUtil.JAVA_SPECIFICATION_VERSION &gt;= 13;
578     }
579 
580     public interface Refiner {
581         void refine(CheckGraalIntrinsics checker);
582     }
583 
584     @Test
585     @SuppressWarnings(&quot;try&quot;)
586     public void test() throws ClassNotFoundException {
587         HotSpotProviders providers = rt.getHostBackend().getProviders();
588         Plugins graphBuilderPlugins = providers.getGraphBuilderPlugins();
589         InvocationPlugins invocationPlugins = graphBuilderPlugins.getInvocationPlugins();
590 
591         HotSpotVMConfigStore store = config.getStore();
592         List&lt;VMIntrinsicMethod&gt; intrinsics = store.getIntrinsics();
593 
594         for (Refiner refiner : ServiceLoader.load(Refiner.class)) {
595             refiner.refine(this);
596         }
597 
598         List&lt;String&gt; missing = new ArrayList&lt;&gt;();
599         List&lt;String&gt; mischaracterizedAsToBeInvestigated = new ArrayList&lt;&gt;();
600         List&lt;String&gt; mischaracterizedAsIgnored = new ArrayList&lt;&gt;();
601         EconomicMap&lt;String, List&lt;Binding&gt;&gt; bindings = invocationPlugins.getBindings(true);
602         for (VMIntrinsicMethod intrinsic : intrinsics) {
603             InvocationPlugin plugin = findPlugin(bindings, intrinsic);
604             String m = String.format(&quot;%s.%s%s&quot;, intrinsic.declaringClass, intrinsic.name, intrinsic.descriptor);
605             if (plugin == null) {
606                 ResolvedJavaMethod method = resolveIntrinsic(providers.getMetaAccess(), intrinsic);
607                 if (method != null) {
608                     IntrinsicMethod intrinsicMethod = providers.getConstantReflection().getMethodHandleAccess().lookupMethodHandleIntrinsic(method);
609                     if (intrinsicMethod != null) {
610                         continue;
611                     }
612                 }
613                 if (!toBeInvestigated.contains(m) &amp;&amp; !ignore.contains(m) &amp;&amp; !complexGuard.contains(m) &amp;&amp; !downstream.contains(m)) {
614                     missing.add(m);
615                 }
616             } else {
617                 if (toBeInvestigated.contains(m)) {
618                     mischaracterizedAsToBeInvestigated.add(m);
619                 } else if (ignore.contains(m)) {
620                     mischaracterizedAsIgnored.add(m);
621                 }
622             }
623         }
624 
625         Formatter errorMsgBuf = new Formatter();
626         if (!missing.isEmpty()) {
627             Collections.sort(missing);
628             String missingString = missing.stream().collect(Collectors.joining(String.format(&quot;%n    &quot;)));
629             errorMsgBuf.format(&quot;missing Graal intrinsics for:%n    %s%n&quot;, missingString);
630         }
631         if (!mischaracterizedAsToBeInvestigated.isEmpty()) {
632             Collections.sort(mischaracterizedAsToBeInvestigated);
633             String missingString = mischaracterizedAsToBeInvestigated.stream().collect(Collectors.joining(String.format(&quot;%n    &quot;)));
634             errorMsgBuf.format(&quot;found plugins for intrinsics characterized as toBeInvestigated:%n    %s%n&quot;, missingString);
635         }
636         if (!mischaracterizedAsIgnored.isEmpty()) {
637             Collections.sort(mischaracterizedAsIgnored);
638             String missingString = mischaracterizedAsIgnored.stream().collect(Collectors.joining(String.format(&quot;%n    &quot;)));
639             errorMsgBuf.format(&quot;found plugins for intrinsics characterized as IGNORED:%n    %s%n&quot;, missingString);
640         }
641         String errorMsg = errorMsgBuf.toString();
642         if (!errorMsg.isEmpty()) {
643             fail(errorMsg);
644         }
645     }
646 }
    </pre>
  </body>
</html>
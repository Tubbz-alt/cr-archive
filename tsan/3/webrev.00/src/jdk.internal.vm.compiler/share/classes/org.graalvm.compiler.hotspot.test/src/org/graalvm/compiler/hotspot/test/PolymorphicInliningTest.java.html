<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/PolymorphicInliningTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
 27 import org.graalvm.compiler.core.test.GraalCompilerTest;
 28 import org.graalvm.compiler.graph.Node;
 29 import org.graalvm.compiler.java.BytecodeParserOptions;
 30 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
 31 import org.graalvm.compiler.nodes.InvokeNode;
 32 import org.graalvm.compiler.nodes.StructuredGraph;
 33 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 34 import org.graalvm.compiler.nodes.java.TypeSwitchNode;
 35 import org.graalvm.compiler.options.OptionValues;
 36 import org.junit.Before;
 37 import org.junit.Test;
 38 
 39 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 40 import jdk.vm.ci.meta.JavaTypeProfile;
 41 import jdk.vm.ci.meta.JavaTypeProfile.ProfiledType;
 42 import jdk.vm.ci.meta.MetaAccessProvider;
 43 import jdk.vm.ci.meta.ResolvedJavaMethod;
 44 import jdk.vm.ci.meta.TriState;
 45 
 46 public class PolymorphicInliningTest extends GraalCompilerTest {
 47 
 48     @Before
 49     public void initializeNotInlinableMethod() {
 50         ((HotSpotResolvedJavaMethod) getResolvedJavaMethod(NotInlinableSubClass.class, &quot;foo&quot;)).setNotInlinableOrCompilable();
 51         // Resolve classes
 52         new A().foo();
 53         new B().foo();
 54         new NotInlinableSubClass().foo();
 55     }
 56 
 57     public int snippet(SuperClass receiver) {
 58         return receiver.foo();
 59     }
 60 
 61     @Test
 62     public void testBimorphicInlined() {
 63         ResolvedJavaMethod method = getResolvedJavaMethod(&quot;snippet&quot;);
 64         StructuredGraph graph = parseForCompile(method, disableInlineDuringParsing());
 65 
 66         MetaAccessProvider metaAccess = getMetaAccess();
 67         ProfiledType[] injectedProfile = {
 68                         new ProfiledType(metaAccess.lookupJavaType(A.class), 0.5D),
 69                         new ProfiledType(metaAccess.lookupJavaType(B.class), 0.5D)};
 70         injectTypeProfile(graph, &quot;PolymorphicInliningTest$SuperClass.foo&quot;, new JavaTypeProfile(TriState.FALSE, 0.0D, injectedProfile));
 71 
 72         createInliningPhase().apply(graph, getDefaultHighTierContext());
 73 
 74         // This callsite should be inlined with a TypeCheckedInliningViolated deoptimization.
 75         assertTrue(getNodeCount(graph, InvokeNode.class) == 0);
 76         assertTrue(getNodeCount(graph, TypeSwitchNode.class) == 1);
 77         assertTrue(getNodeCount(graph, AbstractDeoptimizeNode.class) == 1);
 78     }
 79 
 80     @Test
 81     public void testBimorphicNotInlined() {
 82         ResolvedJavaMethod method = getResolvedJavaMethod(&quot;snippet&quot;);
 83         StructuredGraph graph = parseForCompile(method, disableInlineDuringParsing());
 84 
 85         MetaAccessProvider metaAccess = getMetaAccess();
 86         ProfiledType[] injectedProfile = {
 87                         new ProfiledType(metaAccess.lookupJavaType(A.class), 0.8D),
 88                         new ProfiledType(metaAccess.lookupJavaType(NotInlinableSubClass.class), 0.2D)};
 89         injectTypeProfile(graph, &quot;PolymorphicInliningTest$SuperClass.foo&quot;, new JavaTypeProfile(TriState.FALSE, 0.0D, injectedProfile));
 90 
 91         createInliningPhase().apply(graph, getDefaultHighTierContext());
 92 
 93         // This callsite is not inlined due to one of the potential callee method is not inlinable.
 94         assertTrue(getNodeCount(graph, InvokeNode.class) == 1);
 95         assertTrue(getNodeCount(graph, TypeSwitchNode.class) == 0);
 96         assertTrue(getNodeCount(graph, AbstractDeoptimizeNode.class) == 0);
 97     }
 98 
 99     @Test
100     public void testMegamorphicInlined() {
101         ResolvedJavaMethod method = getResolvedJavaMethod(&quot;snippet&quot;);
102         StructuredGraph graph = parseForCompile(method, disableInlineDuringParsing());
103 
104         MetaAccessProvider metaAccess = getMetaAccess();
105         ProfiledType[] injectedProfile = {
106                         new ProfiledType(metaAccess.lookupJavaType(A.class), 0.79D),
107                         new ProfiledType(metaAccess.lookupJavaType(NotInlinableSubClass.class), 0.2D)};
108         injectTypeProfile(graph, &quot;PolymorphicInliningTest$SuperClass.foo&quot;, new JavaTypeProfile(TriState.FALSE, 0.01D, injectedProfile));
109 
110         createInliningPhase().apply(graph, getDefaultHighTierContext());
111 
112         assertTrue(getNodeCount(graph, InvokeNode.class) == 1);
113         assertTrue(getNodeCount(graph, TypeSwitchNode.class) == 1);
114         assertTrue(getNodeCount(graph, AbstractDeoptimizeNode.class) == 0);
115     }
116 
117     @Test
118     public void testMegamorphicNotInlined() {
119         ResolvedJavaMethod method = getResolvedJavaMethod(&quot;snippet&quot;);
120         StructuredGraph graph = parseForCompile(method, disableInlineDuringParsing());
121 
122         MetaAccessProvider metaAccess = getMetaAccess();
123         ProfiledType[] injectedProfile = {
124                         new ProfiledType(metaAccess.lookupJavaType(A.class), 0.3D),
125                         new ProfiledType(metaAccess.lookupJavaType(B.class), 0.3D),
126                         new ProfiledType(metaAccess.lookupJavaType(NotInlinableSubClass.class), 0.3D)};
127         injectTypeProfile(graph, &quot;PolymorphicInliningTest$SuperClass.foo&quot;, new JavaTypeProfile(TriState.FALSE, 0.1D, injectedProfile));
128 
129         createInliningPhase().apply(graph, getDefaultHighTierContext());
130 
131         // This callsite should not be inlined due to non of the potential callee method exceeds the
132         // probability specified by GraalOptions.MegamorphicInliningMinMethodProbability.
133         assertTrue(getNodeCount(graph, InvokeNode.class) == 1);
134         assertTrue(getNodeCount(graph, TypeSwitchNode.class) == 0);
135         assertTrue(getNodeCount(graph, AbstractDeoptimizeNode.class) == 0);
136     }
137 
138     private static OptionValues disableInlineDuringParsing() {
139         return new OptionValues(getInitialOptions(), BytecodeParserOptions.InlineDuringParsing, false, BytecodeParserOptions.InlineIntrinsicsDuringParsing, false);
140     }
141 
142     private static void injectTypeProfile(StructuredGraph graph, String targetMethod, JavaTypeProfile profile) {
143         for (MethodCallTargetNode callTargetNode : graph.getNodes(MethodCallTargetNode.TYPE)) {
144             if (targetMethod.equals(callTargetNode.targetName())) {
145                 callTargetNode.setJavaTypeProfile(profile);
146             }
147         }
148     }
149 
150     private static int getNodeCount(StructuredGraph graph, Class&lt;? extends Node&gt; nodeClass) {
151         return graph.getNodes().filter(nodeClass).count();
152     }
153 
154     private abstract static class SuperClass {
155         abstract int foo();
156     }
157 
158     private static class A extends SuperClass {
159         @Override
160         public int foo() {
161             return &#39;A&#39;;
162         }
163     }
164 
165     private static class B extends SuperClass {
166         @Override
167         public int foo() {
168             return &#39;B&#39;;
169         }
170     }
171 
172     private static class NotInlinableSubClass extends SuperClass {
173         @Override
174         public int foo() {
175             return &#39;X&#39;;
176         }
177     }
178 
179 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/WriteBarrierAdditionTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TestSHASubstitutions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/BootstrapWatchDog.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/WriteBarrierAdditionTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 



 27 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.referentOffset;
 28 

 29 import java.lang.ref.WeakReference;



 30 
<span class="line-modified"> 31 import org.graalvm.compiler.api.replacements.Fold;</span>
<span class="line-removed"> 32 import org.graalvm.compiler.debug.DebugContext;</span>
 33 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<span class="line-modified"> 34 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase;</span>
<span class="line-modified"> 35 import org.graalvm.compiler.hotspot.gc.g1.G1PostWriteBarrier;</span>
<span class="line-modified"> 36 import org.graalvm.compiler.hotspot.gc.g1.G1PreWriteBarrier;</span>
<span class="line-modified"> 37 import org.graalvm.compiler.hotspot.gc.g1.G1ReferentFieldReadBarrier;</span>
<span class="line-removed"> 38 import org.graalvm.compiler.hotspot.gc.shared.SerialWriteBarrier;</span>
<span class="line-removed"> 39 import org.graalvm.compiler.hotspot.phases.WriteBarrierAdditionPhase;</span>
 40 import org.graalvm.compiler.nodes.StructuredGraph;
<span class="line-modified"> 41 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;</span>
<span class="line-modified"> 42 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;</span>
<span class="line-modified"> 43 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;</span>
<span class="line-modified"> 44 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;</span>

 45 import org.graalvm.compiler.nodes.memory.ReadNode;
 46 import org.graalvm.compiler.nodes.memory.WriteNode;
 47 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-modified"> 48 import org.graalvm.compiler.nodes.spi.LoweringTool;</span>
<span class="line-modified"> 49 import org.graalvm.compiler.phases.OptimisticOptimizations;</span>
<span class="line-modified"> 50 import org.graalvm.compiler.phases.common.CanonicalizerPhase;</span>
<span class="line-modified"> 51 import org.graalvm.compiler.phases.common.GuardLoweringPhase;</span>
<span class="line-removed"> 52 import org.graalvm.compiler.phases.common.LoweringPhase;</span>
<span class="line-removed"> 53 import org.graalvm.compiler.phases.common.inlining.InliningPhase;</span>
<span class="line-removed"> 54 import org.graalvm.compiler.phases.common.inlining.policy.InlineEverythingPolicy;</span>
<span class="line-removed"> 55 import org.graalvm.compiler.phases.tiers.HighTierContext;</span>
 56 import org.graalvm.compiler.phases.tiers.MidTierContext;
<span class="line-modified"> 57 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;</span>

 58 import org.junit.Assert;

 59 import org.junit.Test;
 60 
<span class="line-removed"> 61 import jdk.vm.ci.hotspot.HotSpotInstalledCode;</span>
 62 import jdk.vm.ci.meta.JavaConstant;
<span class="line-modified"> 63 import jdk.vm.ci.meta.ResolvedJavaMethod;</span>
<span class="line-removed"> 64 import sun.misc.Unsafe;</span>
 65 
 66 /**
<span class="line-modified"> 67  * The following unit tests assert the presence of write barriers for both Serial and G1 GCs.</span>
<span class="line-modified"> 68  * Normally, the tests check for compile time inserted barriers. However, there are the cases of</span>
<span class="line-modified"> 69  * unsafe loads of the java.lang.ref.Reference.referent field where runtime checks have to be</span>
<span class="line-modified"> 70  * performed also. For those cases, the unit tests check the presence of the compile-time inserted</span>
<span class="line-modified"> 71  * barriers. Concerning the runtime checks, the results of variable inputs (object types and</span>
<span class="line-modified"> 72  * offsets) passed as input parameters can be checked against printed output from the G1 write</span>
<span class="line-modified"> 73  * barrier snippets. The runtime checks have been validated offline.</span>

 74  */
 75 public class WriteBarrierAdditionTest extends HotSpotGraalCompilerTest {
 76 






 77     private final GraalHotSpotVMConfig config = runtime().getVMConfig();
 78 
 79     public static class Container {
 80 
 81         public Container a;
 82         public Container b;

















 83     }
 84 


 85     /**
<span class="line-modified"> 86      * Expected 2 barriers for the Serial GC and 4 for G1 (2 pre + 2 post).</span>
 87      */
 88     @Test
<span class="line-modified"> 89     public void test1() throws Exception {</span>
<span class="line-modified"> 90         testHelper(&quot;test1Snippet&quot;, (config.useG1GC) ? 4 : 2);</span>

 91     }
 92 
<span class="line-modified"> 93     public static void test1Snippet() {</span>
 94         Container main = new Container();
 95         Container temp1 = new Container();
 96         Container temp2 = new Container();
 97         main.a = temp1;
 98         main.b = temp2;

 99     }
100 
101     /**
<span class="line-modified">102      * Expected 4 barriers for the Serial GC and 8 for G1 (4 pre + 4 post).</span>
103      */
104     @Test
<span class="line-modified">105     public void test2() throws Exception {</span>
<span class="line-modified">106         testHelper(&quot;test2Snippet&quot;, config.useG1GC ? 8 : 4);</span>


107     }
108 
109     public static void test2Snippet(boolean test) {
110         Container main = new Container();
111         Container temp1 = new Container();
112         Container temp2 = new Container();
113         for (int i = 0; i &lt; 10; i++) {
114             if (test) {
115                 main.a = temp1;
116                 main.b = temp2;
117             } else {
118                 main.a = temp2;
119                 main.b = temp1;
120             }
121         }
122     }
123 
124     /**
<span class="line-modified">125      * Expected 4 barriers for the Serial GC and 8 for G1 (4 pre + 4 post).</span>
126      */
127     @Test
<span class="line-modified">128     public void test3() throws Exception {</span>
<span class="line-modified">129         testHelper(&quot;test3Snippet&quot;, config.useG1GC ? 8 : 4);</span>

130     }
131 
132     public static void test3Snippet() {
133         Container[] main = new Container[10];
134         Container temp1 = new Container();
135         Container temp2 = new Container();
136         for (int i = 0; i &lt; 10; i++) {
137             main[i].a = main[i].b = temp1;
138         }
139 
140         for (int i = 0; i &lt; 10; i++) {
141             main[i].a = main[i].b = temp2;
142         }
143     }
144 
145     /**
<span class="line-modified">146      * Expected 2 barriers for the Serial GC and 5 for G1 (3 pre + 2 post) The (2 or 4) barriers are</span>
<span class="line-modified">147      * emitted while initializing the fields of the WeakReference instance. The extra pre barrier of</span>
<span class="line-modified">148      * G1 concerns the read of the referent field.</span>
149      */
150     @Test
<span class="line-modified">151     public void test4() throws Exception {</span>
<span class="line-modified">152         testHelper(&quot;test4Snippet&quot;, config.useG1GC ? 5 : 2);</span>

153     }
154 
<span class="line-modified">155     public static Object test4Snippet() {</span>
<span class="line-modified">156         WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-removed">157         return weakRef.get();</span>
158     }
159 
<span class="line-modified">160     static WeakReference&lt;Object&gt; wr = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-modified">161     static Container con = new Container();</span>
<span class="line-removed">162 </span>
<span class="line-removed">163     /**</span>
<span class="line-removed">164      * Expected 4 barriers for the Serial GC and 9 for G1 (1 ref + 4 pre + 4 post). In this test, we</span>
<span class="line-removed">165      * load the correct offset of the WeakReference object so naturally we assert the presence of</span>
<span class="line-removed">166      * the pre barrier.</span>
<span class="line-removed">167      */</span>
<span class="line-removed">168     @Test</span>
<span class="line-removed">169     public void test5() throws Exception {</span>
<span class="line-removed">170         testHelper(&quot;test5Snippet&quot;, config.useG1GC ? 1 : 0);</span>
171     }
172 
<span class="line-modified">173     @Override</span>
<span class="line-modified">174     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {</span>
<span class="line-removed">175         NodeIntrinsicPluginFactory.InjectionProvider injection = new NodeIntrinsificationProvider(getMetaAccess(), getSnippetReflection(), getProviders().getForeignCalls(), null);</span>
<span class="line-removed">176         new PluginFactory_WriteBarrierAdditionTest().registerPlugins(invocationPlugins, injection);</span>
<span class="line-removed">177         super.registerInvocationPlugins(invocationPlugins);</span>
178     }
179 
<span class="line-modified">180     @Fold</span>
<span class="line-modified">181     public static boolean useCompressedOops(@Fold.InjectedParameter GraalHotSpotVMConfig config) {</span>
<span class="line-modified">182         return config.useCompressedOops;</span>
<span class="line-modified">183     }</span>
184 
<span class="line-modified">185     public static Object test5Snippet() throws Exception {</span>
<span class="line-modified">186         return UNSAFE.getObject(wr, useCompressedOops(GraalHotSpotVMConfigBase.INJECTED_VMCONFIG) ? 12L : 16L);</span>
<span class="line-removed">187     }</span>
188 
189     /**
<span class="line-modified">190      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">191      * load the java.lang.ref.Reference.referent field so the pre barier has to be executed.</span>

192      */
193     @Test
<span class="line-modified">194     public void test6() throws Exception {</span>
<span class="line-modified">195         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(referentOffset(getMetaAccess())), null);</span>





196     }
197 
198     /**
<span class="line-modified">199      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">200      * load a matching offset of a wrong object so the pre barier must not be executed.</span>

201      */
202     @Test
<span class="line-modified">203     public void test7() throws Exception {</span>
<span class="line-modified">204         test2(&quot;testUnsafeLoad&quot;, UNSAFE, con, Long.valueOf(referentOffset(getMetaAccess())), null);</span>





205     }
206 
207     /**
<span class="line-modified">208      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">209      * load a non-matching offset field of the java.lang.ref.Reference object so the pre barier must</span>
<span class="line-removed">210      * not be executed.</span>
211      */
212     @Test
<span class="line-modified">213     public void test8() throws Exception {</span>
<span class="line-modified">214         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 20 : 32), null);</span>





215     }
216 
217     /**
<span class="line-modified">218      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">219      * load a matching offset+disp field of the java.lang.ref.Reference object so the pre barier</span>
<span class="line-modified">220      * must be executed.</span>

221      */
222     @Test
<span class="line-modified">223     public void test10() throws Exception {</span>
<span class="line-modified">224         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 6 : 8), Integer.valueOf(config.useCompressedOops ? 6 : 8));</span>





225     }
226 
227     /**
<span class="line-modified">228      * The following test concerns the runtime checks of the unsafe loads. In this test, we unsafely</span>
<span class="line-modified">229      * load a non-matching offset+disp field of the java.lang.ref.Reference object so the pre barier</span>
<span class="line-removed">230      * must not be executed.</span>
231      */
232     @Test
<span class="line-modified">233     public void test9() throws Exception {</span>
<span class="line-modified">234         test2(&quot;testUnsafeLoad&quot;, UNSAFE, wr, Long.valueOf(config.useCompressedOops ? 10 : 16), Integer.valueOf(config.useCompressedOops ? 10 : 16));</span>






235     }
236 
237     static Object[] src = new Object[1];
238     static Object[] dst = new Object[1];
239 
240     static {
241         for (int i = 0; i &lt; src.length; i++) {
242             src[i] = new Object();
243         }
244         for (int i = 0; i &lt; dst.length; i++) {
245             dst[i] = new Object();
246         }
247     }
248 
<span class="line-modified">249     public static void testArrayCopy(Object a, Object b, Object c) throws Exception {</span>
250         System.arraycopy(a, 0, b, 0, (int) c);
251     }
252 
253     @Test
<span class="line-modified">254     public void test11() throws Exception {</span>
<span class="line-modified">255         test2(&quot;testArrayCopy&quot;, src, dst, dst.length);</span>

256     }
257 
<span class="line-modified">258     public static Object testUnsafeLoad(Unsafe theUnsafe, Object a, Object b, Object c) throws Exception {</span>
<span class="line-modified">259         final int offset = (c == null ? 0 : ((Integer) c).intValue());</span>
<span class="line-modified">260         final long displacement = (b == null ? 0 : ((Long) b).longValue());</span>
<span class="line-modified">261         return theUnsafe.getObject(a, offset + displacement);</span>
<span class="line-modified">262     }</span>
<span class="line-modified">263 </span>
<span class="line-modified">264     private HotSpotInstalledCode getInstalledCode(String name, boolean withUnsafePrefix) throws Exception {</span>
<span class="line-modified">265         final ResolvedJavaMethod javaMethod = withUnsafePrefix ? getResolvedJavaMethod(WriteBarrierAdditionTest.class, name, Unsafe.class, Object.class, Object.class, Object.class)</span>
<span class="line-modified">266                         : getResolvedJavaMethod(WriteBarrierAdditionTest.class, name, Object.class, Object.class, Object.class);</span>
<span class="line-modified">267         final HotSpotInstalledCode installedCode = (HotSpotInstalledCode) getCode(javaMethod);</span>
<span class="line-modified">268         return installedCode;</span>
<span class="line-modified">269     }</span>
<span class="line-modified">270 </span>
<span class="line-modified">271     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-removed">272     private void testHelper(final String snippetName, final int expectedBarriers) throws Exception, SecurityException {</span>
<span class="line-removed">273         ResolvedJavaMethod snippet = getResolvedJavaMethod(snippetName);</span>
<span class="line-removed">274         DebugContext debug = getDebugContext();</span>
<span class="line-removed">275         try (DebugContext.Scope s = debug.scope(&quot;WriteBarrierAdditionTest&quot;, snippet)) {</span>
<span class="line-removed">276             StructuredGraph graph = parseEager(snippet, AllowAssumptions.NO, debug);</span>
<span class="line-removed">277             HighTierContext highContext = getDefaultHighTierContext();</span>
<span class="line-removed">278             MidTierContext midContext = new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, graph.getProfilingInfo());</span>
<span class="line-removed">279             new InliningPhase(new InlineEverythingPolicy(), new CanonicalizerPhase()).apply(graph, highContext);</span>
<span class="line-removed">280             new CanonicalizerPhase().apply(graph, highContext);</span>
<span class="line-removed">281             new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, highContext);</span>
<span class="line-removed">282             new GuardLoweringPhase().apply(graph, midContext);</span>
<span class="line-removed">283             new LoweringPhase(new CanonicalizerPhase(), LoweringTool.StandardLoweringStage.MID_TIER).apply(graph, midContext);</span>
<span class="line-removed">284             new WriteBarrierAdditionPhase(config).apply(graph);</span>
<span class="line-removed">285             debug.dump(DebugContext.BASIC_LEVEL, graph, &quot;After Write Barrier Addition&quot;);</span>
<span class="line-removed">286 </span>
<span class="line-removed">287             int barriers = 0;</span>
288             if (config.useG1GC) {
<span class="line-modified">289                 barriers = graph.getNodes().filter(G1ReferentFieldReadBarrier.class).count() + graph.getNodes().filter(G1PreWriteBarrier.class).count() +</span>
<span class="line-modified">290                                 graph.getNodes().filter(G1PostWriteBarrier.class).count();</span>



291             } else {
<span class="line-modified">292                 barriers = graph.getNodes().filter(SerialWriteBarrier.class).count();</span>
<span class="line-modified">293             }</span>
<span class="line-modified">294             if (expectedBarriers != barriers) {</span>
<span class="line-removed">295                 Assert.assertEquals(getScheduledGraphString(graph), expectedBarriers, barriers);</span>
<span class="line-removed">296             }</span>
<span class="line-removed">297             for (WriteNode write : graph.getNodes().filter(WriteNode.class)) {</span>
<span class="line-removed">298                 if (config.useG1GC) {</span>
<span class="line-removed">299                     if (write.getBarrierType() != BarrierType.NONE) {</span>
<span class="line-removed">300                         Assert.assertEquals(1, write.successors().count());</span>
<span class="line-removed">301                         Assert.assertTrue(write.next() instanceof G1PostWriteBarrier);</span>
<span class="line-removed">302                         Assert.assertTrue(write.predecessor() instanceof G1PreWriteBarrier);</span>
<span class="line-removed">303                     }</span>
<span class="line-removed">304                 } else {</span>
<span class="line-removed">305                     if (write.getBarrierType() != BarrierType.NONE) {</span>
<span class="line-removed">306                         Assert.assertEquals(1, write.successors().count());</span>
<span class="line-removed">307                         Assert.assertTrue(write.next() instanceof SerialWriteBarrier);</span>
<span class="line-removed">308                     }</span>
309                 }
310             }

311 
<span class="line-modified">312             for (ReadNode read : graph.getNodes().filter(ReadNode.class)) {</span>
<span class="line-modified">313                 if (read.getBarrierType() != BarrierType.NONE) {</span>
<span class="line-modified">314                     Assert.assertTrue(read.getAddress() instanceof OffsetAddressNode);</span>
315                     JavaConstant constDisp = ((OffsetAddressNode) read.getAddress()).getOffset().asJavaConstant();
<span class="line-modified">316                     Assert.assertNotNull(constDisp);</span>
<span class="line-modified">317                     Assert.assertEquals(referentOffset(getMetaAccess()), constDisp.asLong());</span>
<span class="line-modified">318                     Assert.assertTrue(config.useG1GC);</span>
<span class="line-modified">319                     Assert.assertEquals(BarrierType.PRECISE, read.getBarrierType());</span>


320                     Assert.assertTrue(read.next() instanceof G1ReferentFieldReadBarrier);
321                 }
322             }
<span class="line-removed">323         } catch (Throwable e) {</span>
<span class="line-removed">324             throw debug.handle(e);</span>
325         }
326     }
327 
<span class="line-modified">328     private void test2(final String snippet, Object... args) throws Exception {</span>
<span class="line-modified">329         HotSpotInstalledCode code = getInstalledCode(snippet, args[0] instanceof Unsafe);</span>
<span class="line-modified">330         code.executeVarargs(args);</span>































331     }
332 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
<span class="line-added"> 27 import static org.graalvm.compiler.core.common.GraalOptions.FullUnroll;</span>
<span class="line-added"> 28 import static org.graalvm.compiler.core.common.GraalOptions.LoopPeeling;</span>
<span class="line-added"> 29 import static org.graalvm.compiler.core.common.GraalOptions.PartialEscapeAnalysis;</span>
 30 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.referentOffset;
 31 
<span class="line-added"> 32 import java.lang.ref.Reference;</span>
 33 import java.lang.ref.WeakReference;
<span class="line-added"> 34 import java.util.EnumSet;</span>
<span class="line-added"> 35 import java.util.ListIterator;</span>
<span class="line-added"> 36 import java.util.Objects;</span>
 37 
<span class="line-modified"> 38 import org.graalvm.compiler.api.test.Graal;</span>

 39 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<span class="line-modified"> 40 import org.graalvm.compiler.hotspot.HotSpotBackend;</span>
<span class="line-modified"> 41 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime.HotSpotGC;</span>
<span class="line-modified"> 42 import org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil;</span>
<span class="line-modified"> 43 import org.graalvm.compiler.nodeinfo.NodeSize;</span>


 44 import org.graalvm.compiler.nodes.StructuredGraph;
<span class="line-modified"> 45 import org.graalvm.compiler.nodes.gc.G1PostWriteBarrier;</span>
<span class="line-modified"> 46 import org.graalvm.compiler.nodes.gc.G1PreWriteBarrier;</span>
<span class="line-modified"> 47 import org.graalvm.compiler.nodes.gc.G1ReferentFieldReadBarrier;</span>
<span class="line-modified"> 48 import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;</span>
<span class="line-added"> 49 import org.graalvm.compiler.nodes.memory.HeapAccess;</span>
 50 import org.graalvm.compiler.nodes.memory.ReadNode;
 51 import org.graalvm.compiler.nodes.memory.WriteNode;
 52 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-modified"> 53 import org.graalvm.compiler.options.OptionValues;</span>
<span class="line-modified"> 54 import org.graalvm.compiler.phases.BasePhase;</span>
<span class="line-modified"> 55 import org.graalvm.compiler.phases.Phase;</span>
<span class="line-modified"> 56 import org.graalvm.compiler.phases.common.WriteBarrierAdditionPhase;</span>




 57 import org.graalvm.compiler.phases.tiers.MidTierContext;
<span class="line-modified"> 58 import org.graalvm.compiler.phases.tiers.Suites;</span>
<span class="line-added"> 59 import org.graalvm.compiler.runtime.RuntimeProvider;</span>
 60 import org.junit.Assert;
<span class="line-added"> 61 import org.junit.Before;</span>
 62 import org.junit.Test;
 63 

 64 import jdk.vm.ci.meta.JavaConstant;
<span class="line-modified"> 65 import jdk.vm.ci.meta.MetaAccessProvider;</span>

 66 
 67 /**
<span class="line-modified"> 68  * The following unit tests assert the presence of write barriers for G1 and for the other GCs that</span>
<span class="line-modified"> 69  * use a simple card mark barrier, like Serial, CMS, ParallelGC and Pthe arNew/ParOld GCs. Normally,</span>
<span class="line-modified"> 70  * the tests check for compile time inserted barriers. However, there are the cases of unsafe loads</span>
<span class="line-modified"> 71  * of the java.lang.ref.Reference.referent field where runtime checks have to be performed also. For</span>
<span class="line-modified"> 72  * those cases, the unit tests check the presence of the compile-time inserted barriers. Concerning</span>
<span class="line-modified"> 73  * the runtime checks, the results of variable inputs (object types and offsets) passed as input</span>
<span class="line-modified"> 74  * parameters can be checked against printed output from the G1 write barrier snippets. The runtime</span>
<span class="line-added"> 75  * checks have been validated offline.</span>
 76  */
 77 public class WriteBarrierAdditionTest extends HotSpotGraalCompilerTest {
 78 
<span class="line-added"> 79     /**</span>
<span class="line-added"> 80      * The set of GCs known at the time of writing of this test. The number of expected barrier</span>
<span class="line-added"> 81      * might need to be adjusted for new GCs implementations.</span>
<span class="line-added"> 82      */</span>
<span class="line-added"> 83     private static EnumSet&lt;HotSpotGC&gt; knownSupport = EnumSet.of(HotSpotGC.G1, HotSpotGC.CMS, HotSpotGC.Parallel, HotSpotGC.Serial);</span>
<span class="line-added"> 84 </span>
 85     private final GraalHotSpotVMConfig config = runtime().getVMConfig();
 86 
 87     public static class Container {
 88 
 89         public Container a;
 90         public Container b;
<span class="line-added"> 91 </span>
<span class="line-added"> 92         @Override</span>
<span class="line-added"> 93         public boolean equals(Object o) {</span>
<span class="line-added"> 94             if (this == o) {</span>
<span class="line-added"> 95                 return true;</span>
<span class="line-added"> 96             }</span>
<span class="line-added"> 97             if (o == null || getClass() != o.getClass()) {</span>
<span class="line-added"> 98                 return false;</span>
<span class="line-added"> 99             }</span>
<span class="line-added">100             Container container = (Container) o;</span>
<span class="line-added">101             return Objects.equals(a, container.a) &amp;&amp; Objects.equals(b, container.b);</span>
<span class="line-added">102         }</span>
<span class="line-added">103 </span>
<span class="line-added">104         @Override</span>
<span class="line-added">105         public int hashCode() {</span>
<span class="line-added">106             return Objects.hash(a, b);</span>
<span class="line-added">107         }</span>
108     }
109 
<span class="line-added">110     private int expectedBarriers;</span>
<span class="line-added">111 </span>
112     /**
<span class="line-modified">113      * Expected 2 barriers for the card mark GCs and 4 for G1 (2 pre + 2 post).</span>
114      */
115     @Test
<span class="line-modified">116     public void testAllocation() throws Exception {</span>
<span class="line-modified">117         this.expectedBarriers = (config.useG1GC) ? 4 : 2;</span>
<span class="line-added">118         testWithoutPEA(&quot;testAllocationSnippet&quot;);</span>
119     }
120 
<span class="line-modified">121     public static Container testAllocationSnippet() {</span>
122         Container main = new Container();
123         Container temp1 = new Container();
124         Container temp2 = new Container();
125         main.a = temp1;
126         main.b = temp2;
<span class="line-added">127         return main;</span>
128     }
129 
130     /**
<span class="line-modified">131      * Expected 4 barriers for the card mark GCs and 8 for G1 (4 pre + 4 post).</span>
132      */
133     @Test
<span class="line-modified">134     public void testLoopAllocation1() throws Exception {</span>
<span class="line-modified">135         this.expectedBarriers = config.useG1GC ? 8 : 4;</span>
<span class="line-added">136         testWithoutPEA(&quot;test2Snippet&quot;, false);</span>
<span class="line-added">137         testWithoutPEA(&quot;test2Snippet&quot;, true);</span>
138     }
139 
140     public static void test2Snippet(boolean test) {
141         Container main = new Container();
142         Container temp1 = new Container();
143         Container temp2 = new Container();
144         for (int i = 0; i &lt; 10; i++) {
145             if (test) {
146                 main.a = temp1;
147                 main.b = temp2;
148             } else {
149                 main.a = temp2;
150                 main.b = temp1;
151             }
152         }
153     }
154 
155     /**
<span class="line-modified">156      * Expected 4 barriers for the card mark GCs and 8 for G1 (4 pre + 4 post).</span>
157      */
158     @Test
<span class="line-modified">159     public void testLoopAllocation2() throws Exception {</span>
<span class="line-modified">160         this.expectedBarriers = config.useG1GC ? 8 : 4;</span>
<span class="line-added">161         testWithoutPEA(&quot;test3Snippet&quot;);</span>
162     }
163 
164     public static void test3Snippet() {
165         Container[] main = new Container[10];
166         Container temp1 = new Container();
167         Container temp2 = new Container();
168         for (int i = 0; i &lt; 10; i++) {
169             main[i].a = main[i].b = temp1;
170         }
171 
172         for (int i = 0; i &lt; 10; i++) {
173             main[i].a = main[i].b = temp2;
174         }
175     }
176 
177     /**
<span class="line-modified">178      * Expected 2 barriers for the card mark GCs and 5 for G1 (3 pre + 2 post) The (2 or 4) barriers</span>
<span class="line-modified">179      * are emitted while initializing the fields of the WeakReference instance. The extra pre</span>
<span class="line-modified">180      * barrier of G1 concerns the read of the referent field.</span>
181      */
182     @Test
<span class="line-modified">183     public void testReferenceGet() throws Exception {</span>
<span class="line-modified">184         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">185         test(&quot;testReferenceGetSnippet&quot;);</span>
186     }
187 
<span class="line-modified">188     public static Object testReferenceGetSnippet() {</span>
<span class="line-modified">189         return weakReference.get();</span>

190     }
191 
<span class="line-modified">192     static class DummyReference {</span>
<span class="line-modified">193         Object referent;</span>









194     }
195 
<span class="line-modified">196     private static MetaAccessProvider getStaticMetaAccess() {</span>
<span class="line-modified">197         return ((HotSpotBackend) Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend()).getRuntime().getHostProviders().getMetaAccess();</span>



198     }
199 
<span class="line-modified">200     private static final WeakReference&lt;?&gt; weakReference = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-modified">201     private static final Object weakReferenceAsObject = new WeakReference&lt;&gt;(new Object());</span>
<span class="line-modified">202     private static final long referenceReferentFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(Reference.class), &quot;referent&quot;);</span>
<span class="line-modified">203     private static final long referenceQueueFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(Reference.class), &quot;queue&quot;);</span>
204 
<span class="line-modified">205     private static final DummyReference dummyReference = new DummyReference();</span>
<span class="line-modified">206     private static final long dummyReferenceReferentFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(DummyReference.class), &quot;referent&quot;);</span>

207 
208     /**
<span class="line-modified">209      * The type is known to be WeakReference and the offset is a constant, so the</span>
<span class="line-modified">210      * {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is converted back into a normal</span>
<span class="line-added">211      * LoadFieldNode and the lowering of the field node inserts the proper barrier.</span>
212      */
213     @Test
<span class="line-modified">214     public void testReferenceReferent1() throws Exception {</span>
<span class="line-modified">215         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">216         test(&quot;testReferenceReferentSnippet&quot;);</span>
<span class="line-added">217     }</span>
<span class="line-added">218 </span>
<span class="line-added">219     public Object testReferenceReferentSnippet() {</span>
<span class="line-added">220         return UNSAFE.getObject(weakReference, referenceReferentFieldOffset);</span>
221     }
222 
223     /**
<span class="line-modified">224      * The type is known to be WeakReference and the offset is non-constant, so the lowering of the</span>
<span class="line-modified">225      * {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is guarded by a check that the offset</span>
<span class="line-added">226      * is the same as {@link #referenceReferentFieldOffset} which does a barrier if requires it.</span>
227      */
228     @Test
<span class="line-modified">229     public void testReferenceReferent2() throws Exception {</span>
<span class="line-modified">230         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">231         test(&quot;testReferenceReferent2Snippet&quot;, referenceReferentFieldOffset);</span>
<span class="line-added">232     }</span>
<span class="line-added">233 </span>
<span class="line-added">234     public Object testReferenceReferent2Snippet(long offset) {</span>
<span class="line-added">235         return UNSAFE.getObject(weakReference, offset);</span>
236     }
237 
238     /**
<span class="line-modified">239      * The type is known to be WeakReference and the offset is constant but not the referent field,</span>
<span class="line-modified">240      * so no barrier is required.</span>

241      */
242     @Test
<span class="line-modified">243     public void testReferenceReferent3() throws Exception {</span>
<span class="line-modified">244         this.expectedBarriers = 0;</span>
<span class="line-added">245         test(&quot;testReferenceReferent3Snippet&quot;);</span>
<span class="line-added">246     }</span>
<span class="line-added">247 </span>
<span class="line-added">248     public Object testReferenceReferent3Snippet() {</span>
<span class="line-added">249         return UNSAFE.getObject(weakReference, referenceQueueFieldOffset);</span>
250     }
251 
252     /**
<span class="line-modified">253      * The type is a super class of WeakReference and the offset is non-constant, so the lowering of</span>
<span class="line-modified">254      * the {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is guarded by a check that the</span>
<span class="line-modified">255      * offset is the same as {@link #referenceReferentFieldOffset} and the base object is a</span>
<span class="line-added">256      * subclasses of {@link java.lang.ref.Reference} and does a barrier if requires it.</span>
257      */
258     @Test
<span class="line-modified">259     public void testReferenceReferent4() throws Exception {</span>
<span class="line-modified">260         this.expectedBarriers = config.useG1GC ? 1 : 0;</span>
<span class="line-added">261         test(&quot;testReferenceReferent4Snippet&quot;);</span>
<span class="line-added">262     }</span>
<span class="line-added">263 </span>
<span class="line-added">264     public Object testReferenceReferent4Snippet() {</span>
<span class="line-added">265         return UNSAFE.getObject(weakReferenceAsObject, referenceReferentFieldOffset);</span>
266     }
267 
268     /**
<span class="line-modified">269      * The type is not related to Reference at all so no barrier check is required. This should be</span>
<span class="line-modified">270      * statically detectable.</span>

271      */
272     @Test
<span class="line-modified">273     public void testReferenceReferent5() throws Exception {</span>
<span class="line-modified">274         this.expectedBarriers = 0;</span>
<span class="line-added">275         Assert.assertEquals(&quot;expected fields to have the same offset&quot;, referenceReferentFieldOffset, dummyReferenceReferentFieldOffset);</span>
<span class="line-added">276         test(&quot;testReferenceReferent5Snippet&quot;);</span>
<span class="line-added">277     }</span>
<span class="line-added">278 </span>
<span class="line-added">279     public Object testReferenceReferent5Snippet() {</span>
<span class="line-added">280         return UNSAFE.getObject(dummyReference, referenceReferentFieldOffset);</span>
281     }
282 
283     static Object[] src = new Object[1];
284     static Object[] dst = new Object[1];
285 
286     static {
287         for (int i = 0; i &lt; src.length; i++) {
288             src[i] = new Object();
289         }
290         for (int i = 0; i &lt; dst.length; i++) {
291             dst[i] = new Object();
292         }
293     }
294 
<span class="line-modified">295     public static void testArrayCopySnippet(Object a, Object b, Object c) throws Exception {</span>
296         System.arraycopy(a, 0, b, 0, (int) c);
297     }
298 
299     @Test
<span class="line-modified">300     public void testArrayCopy() throws Exception {</span>
<span class="line-modified">301         this.expectedBarriers = 0;</span>
<span class="line-added">302         test(&quot;testArrayCopySnippet&quot;, src, dst, dst.length);</span>
303     }
304 
<span class="line-modified">305     private void verifyBarriers(StructuredGraph graph) {</span>
<span class="line-modified">306         Assert.assertTrue(&quot;Unknown collector selected&quot;, knownSupport.contains(runtime().getGarbageCollector()));</span>
<span class="line-modified">307         Assert.assertNotEquals(&quot;test must set expected barrier count&quot;, expectedBarriers, -1);</span>
<span class="line-modified">308         int barriers = 0;</span>
<span class="line-modified">309         if (config.useG1GC) {</span>
<span class="line-modified">310             barriers = graph.getNodes().filter(G1ReferentFieldReadBarrier.class).count() + graph.getNodes().filter(G1PreWriteBarrier.class).count() +</span>
<span class="line-modified">311                             graph.getNodes().filter(G1PostWriteBarrier.class).count();</span>
<span class="line-modified">312         } else {</span>
<span class="line-modified">313             barriers = graph.getNodes().filter(SerialWriteBarrier.class).count();</span>
<span class="line-modified">314         }</span>
<span class="line-modified">315         if (expectedBarriers != barriers) {</span>
<span class="line-modified">316             Assert.assertEquals(expectedBarriers, barriers);</span>
<span class="line-modified">317         }</span>
<span class="line-modified">318         for (WriteNode write : graph.getNodes().filter(WriteNode.class)) {</span>
















319             if (config.useG1GC) {
<span class="line-modified">320                 if (write.getBarrierType() != HeapAccess.BarrierType.NONE) {</span>
<span class="line-modified">321                     Assert.assertEquals(1, write.successors().count());</span>
<span class="line-added">322                     Assert.assertTrue(write.next() instanceof G1PostWriteBarrier);</span>
<span class="line-added">323                     Assert.assertTrue(write.predecessor() instanceof G1PreWriteBarrier || write.getLocationIdentity().isImmutable());</span>
<span class="line-added">324                 }</span>
325             } else {
<span class="line-modified">326                 if (write.getBarrierType() != HeapAccess.BarrierType.NONE) {</span>
<span class="line-modified">327                     Assert.assertEquals(1, write.successors().count());</span>
<span class="line-modified">328                     Assert.assertTrue(write.next() instanceof SerialWriteBarrier);</span>














329                 }
330             }
<span class="line-added">331         }</span>
332 
<span class="line-modified">333         for (ReadNode read : graph.getNodes().filter(ReadNode.class)) {</span>
<span class="line-modified">334             if (read.getBarrierType() != HeapAccess.BarrierType.NONE) {</span>
<span class="line-modified">335                 if (read.getAddress() instanceof OffsetAddressNode) {</span>
336                     JavaConstant constDisp = ((OffsetAddressNode) read.getAddress()).getOffset().asJavaConstant();
<span class="line-modified">337                     if (constDisp != null) {</span>
<span class="line-modified">338                         Assert.assertEquals(referentOffset(getMetaAccess()), constDisp.asLong());</span>
<span class="line-modified">339                     }</span>
<span class="line-modified">340                 }</span>
<span class="line-added">341                 Assert.assertTrue(HeapAccess.BarrierType.WEAK_FIELD == read.getBarrierType() || HeapAccess.BarrierType.MAYBE_WEAK_FIELD == read.getBarrierType());</span>
<span class="line-added">342                 if (config.useG1GC) {</span>
343                     Assert.assertTrue(read.next() instanceof G1ReferentFieldReadBarrier);
344                 }
345             }


346         }
347     }
348 
<span class="line-modified">349     protected Result testWithoutPEA(String name, Object... args) {</span>
<span class="line-modified">350         return test(new OptionValues(getInitialOptions(), PartialEscapeAnalysis, false, FullUnroll, false, LoopPeeling, false), name, args);</span>
<span class="line-modified">351     }</span>
<span class="line-added">352 </span>
<span class="line-added">353     @Before</span>
<span class="line-added">354     public void before() {</span>
<span class="line-added">355         expectedBarriers = -1;</span>
<span class="line-added">356     }</span>
<span class="line-added">357 </span>
<span class="line-added">358     /*</span>
<span class="line-added">359      * Check the state of the barriers immediately after insertion.</span>
<span class="line-added">360      */</span>
<span class="line-added">361     @Override</span>
<span class="line-added">362     protected Suites createSuites(OptionValues opts) {</span>
<span class="line-added">363         Suites ret = getBackend().getSuites().getDefaultSuites(opts).copy();</span>
<span class="line-added">364         ListIterator&lt;BasePhase&lt;? super MidTierContext&gt;&gt; iter = ret.getMidTier().findPhase(WriteBarrierAdditionPhase.class, true);</span>
<span class="line-added">365         iter.add(new Phase() {</span>
<span class="line-added">366 </span>
<span class="line-added">367             @Override</span>
<span class="line-added">368             protected void run(StructuredGraph graph) {</span>
<span class="line-added">369                 verifyBarriers(graph);</span>
<span class="line-added">370             }</span>
<span class="line-added">371 </span>
<span class="line-added">372             @Override</span>
<span class="line-added">373             public float codeSizeIncrease() {</span>
<span class="line-added">374                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;</span>
<span class="line-added">375             }</span>
<span class="line-added">376 </span>
<span class="line-added">377             @Override</span>
<span class="line-added">378             protected CharSequence getName() {</span>
<span class="line-added">379                 return &quot;VerifyBarriersPhase&quot;;</span>
<span class="line-added">380             }</span>
<span class="line-added">381         });</span>
<span class="line-added">382         return ret;</span>
383     }
384 }
</pre>
</td>
</tr>
</table>
<center><a href="TestSHASubstitutions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/BootstrapWatchDog.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
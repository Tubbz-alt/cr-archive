<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilerConfigurationFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraalHotSpotVMConfigBase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 37 import jdk.vm.ci.meta.ResolvedJavaMethod;
 38 
 39 /**
 40  * Used to access native configuration details.
 41  */
 42 public class GraalHotSpotVMConfig extends GraalHotSpotVMConfigBase {
 43 
 44     GraalHotSpotVMConfig(HotSpotVMConfigStore store) {
 45         super(store);
 46 
 47         assert narrowKlassShift &lt;= logKlassAlignment;
 48         assert narrowOopShift &lt;= logMinObjAlignment();
 49         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift);
 50         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift);
 51 
 52         assert check();
 53     }
 54 
 55     private final CompressEncoding oopEncoding;
 56     private final CompressEncoding klassEncoding;

 57 
 58     public CompressEncoding getOopEncoding() {
 59         return oopEncoding;
 60     }
 61 
 62     public CompressEncoding getKlassEncoding() {
 63         return klassEncoding;
 64     }
 65 
 66     public final boolean cAssertions = getConstant(&quot;ASSERT&quot;, Boolean.class);
 67 
 68     public final int codeEntryAlignment = getFlag(&quot;CodeEntryAlignment&quot;, Integer.class);
 69     public final boolean enableContended = getFlag(&quot;EnableContended&quot;, Boolean.class);
 70     public final boolean restrictContended = getFlag(&quot;RestrictContended&quot;, Boolean.class);
 71     public final int contendedPaddingWidth = getFlag(&quot;ContendedPaddingWidth&quot;, Integer.class);
<span class="line-removed"> 72     public final int fieldsAllocationStyle = getFlag(&quot;FieldsAllocationStyle&quot;, Integer.class);</span>
<span class="line-removed"> 73     public final boolean compactFields = getFlag(&quot;CompactFields&quot;, Boolean.class);</span>
 74     public final boolean verifyOops = getFlag(&quot;VerifyOops&quot;, Boolean.class);
 75     public final boolean ciTime = getFlag(&quot;CITime&quot;, Boolean.class);
 76     public final boolean ciTimeEach = getFlag(&quot;CITimeEach&quot;, Boolean.class);
 77     public final boolean dontCompileHugeMethods = getFlag(&quot;DontCompileHugeMethods&quot;, Boolean.class);
 78     public final int hugeMethodLimit = getFlag(&quot;HugeMethodLimit&quot;, Integer.class);
 79     public final boolean printInlining = getFlag(&quot;PrintInlining&quot;, Boolean.class);
 80     public final boolean inline = getFlag(&quot;Inline&quot;, Boolean.class);
 81     public final boolean inlineNotify = versioned.inlineNotify;
 82     public final boolean useFastLocking = getFlag(&quot;JVMCIUseFastLocking&quot;, Boolean.class);
 83     public final boolean forceUnreachable = getFlag(&quot;ForceUnreachable&quot;, Boolean.class);
 84     public final int codeSegmentSize = getFlag(&quot;CodeCacheSegmentSize&quot;, Integer.class);
 85     public final boolean foldStableValues = getFlag(&quot;FoldStableValues&quot;, Boolean.class);
 86     public final int maxVectorSize = getFlag(&quot;MaxVectorSize&quot;, Integer.class);
 87 
 88     public final boolean verifyBeforeGC = getFlag(&quot;VerifyBeforeGC&quot;, Boolean.class);
 89     public final boolean verifyAfterGC = getFlag(&quot;VerifyAfterGC&quot;, Boolean.class);
 90 
 91     public final boolean useTLAB = getFlag(&quot;UseTLAB&quot;, Boolean.class);
 92     public final boolean useBiasedLocking = getFlag(&quot;UseBiasedLocking&quot;, Boolean.class);
 93     public final boolean usePopCountInstruction = getFlag(&quot;UsePopCountInstruction&quot;, Boolean.class);
 94     public final boolean useAESIntrinsics = getFlag(&quot;UseAESIntrinsics&quot;, Boolean.class);
 95     public final boolean useAESCTRIntrinsics = getFlag(&quot;UseAESCTRIntrinsics&quot;, Boolean.class, false);
 96     public final boolean useCRC32Intrinsics = getFlag(&quot;UseCRC32Intrinsics&quot;, Boolean.class);
 97     public final boolean useCRC32CIntrinsics = versioned.useCRC32CIntrinsics;
<span class="line-modified"> 98     public final boolean threadLocalHandshakes = getFlag(&quot;ThreadLocalHandshakes&quot;, Boolean.class, false);</span>
 99 
100     private final boolean useMultiplyToLenIntrinsic = getFlag(&quot;UseMultiplyToLenIntrinsic&quot;, Boolean.class);
101     private final boolean useSHA1Intrinsics = getFlag(&quot;UseSHA1Intrinsics&quot;, Boolean.class);
102     private final boolean useSHA256Intrinsics = getFlag(&quot;UseSHA256Intrinsics&quot;, Boolean.class);
103     private final boolean useSHA512Intrinsics = getFlag(&quot;UseSHA512Intrinsics&quot;, Boolean.class);
104     private final boolean useGHASHIntrinsics = getFlag(&quot;UseGHASHIntrinsics&quot;, Boolean.class, false);

105     private final boolean useMontgomeryMultiplyIntrinsic = getFlag(&quot;UseMontgomeryMultiplyIntrinsic&quot;, Boolean.class, false);
106     private final boolean useMontgomerySquareIntrinsic = getFlag(&quot;UseMontgomerySquareIntrinsic&quot;, Boolean.class, false);
107     private final boolean useMulAddIntrinsic = getFlag(&quot;UseMulAddIntrinsic&quot;, Boolean.class, false);
108     private final boolean useSquareToLenIntrinsic = getFlag(&quot;UseSquareToLenIntrinsic&quot;, Boolean.class, false);
109     public final boolean useVectorizedMismatchIntrinsic = getFlag(&quot;UseVectorizedMismatchIntrinsic&quot;, Boolean.class, false);



110 
111     /*
112      * These are methods because in some JDKs the flags are visible but the stubs themselves haven&#39;t
113      * been exported so we have to check both if the flag is on and if we have the stub.
114      */
115     public boolean useMultiplyToLenIntrinsic() {
116         return useMultiplyToLenIntrinsic &amp;&amp; multiplyToLen != 0;
117     }
118 
119     public boolean useSHA1Intrinsics() {
120         return useSHA1Intrinsics &amp;&amp; sha1ImplCompress != 0 &amp;&amp; sha1ImplCompressMultiBlock != 0;
121     }
122 
123     public boolean useSHA256Intrinsics() {
124         return useSHA256Intrinsics &amp;&amp; sha256ImplCompress != 0 &amp;&amp; sha256ImplCompressMultiBlock != 0;
125     }
126 
127     public boolean useSHA512Intrinsics() {
128         return useSHA512Intrinsics &amp;&amp; sha512ImplCompress != 0 &amp;&amp; sha512ImplCompressMultiBlock != 0;
129     }
130 
131     public boolean useGHASHIntrinsics() {
132         return useGHASHIntrinsics &amp;&amp; ghashProcessBlocks != 0;
133     }
134 




135     public boolean useMontgomeryMultiplyIntrinsic() {
136         return useMontgomeryMultiplyIntrinsic &amp;&amp; montgomeryMultiply != 0;
137     }
138 
139     public boolean useMontgomerySquareIntrinsic() {
140         return useMontgomerySquareIntrinsic &amp;&amp; montgomerySquare != 0;
141     }
142 
143     public boolean useMulAddIntrinsic() {
144         return useMulAddIntrinsic &amp;&amp; mulAdd != 0;
145     }
146 
147     public boolean useSquareToLenIntrinsic() {
148         return useSquareToLenIntrinsic &amp;&amp; squareToLen != 0;
149     }
150 
151     public boolean inlineNotify() {
152         return inlineNotify &amp;&amp; notifyAddress != 0;
153     }
154 
155     public boolean inlineNotifyAll() {
156         return inlineNotify &amp;&amp; notifyAllAddress != 0;
157     }
158 
159     public final boolean useG1GC = getFlag(&quot;UseG1GC&quot;, Boolean.class);
<span class="line-modified">160     public final boolean useCMSGC = getFlag(&quot;UseConcMarkSweepGC&quot;, Boolean.class);</span>
161 
162     public final int allocatePrefetchStyle = getFlag(&quot;AllocatePrefetchStyle&quot;, Integer.class);
163     public final int allocatePrefetchInstr = getFlag(&quot;AllocatePrefetchInstr&quot;, Integer.class);
164     public final int allocatePrefetchLines = getFlag(&quot;AllocatePrefetchLines&quot;, Integer.class);
165     public final int allocateInstancePrefetchLines = getFlag(&quot;AllocateInstancePrefetchLines&quot;, Integer.class);
166     public final int allocatePrefetchStepSize = getFlag(&quot;AllocatePrefetchStepSize&quot;, Integer.class);
167     public final int allocatePrefetchDistance = getFlag(&quot;AllocatePrefetchDistance&quot;, Integer.class);
168 
169     private final long universeCollectedHeap = getFieldValue(&quot;CompilerToVM::Data::Universe_collectedHeap&quot;, Long.class, &quot;CollectedHeap*&quot;);
170     private final int collectedHeapTotalCollectionsOffset = getFieldOffset(&quot;CollectedHeap::_total_collections&quot;, Integer.class, &quot;unsigned int&quot;);
171 
172     public long gcTotalCollectionsAddress() {
173         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
174     }
175 
176     public final boolean useDeferredInitBarriers = getFlag(&quot;ReduceInitialCardMarks&quot;, Boolean.class);
177 
178     // Compressed Oops related values.
179     public final boolean useCompressedOops = getFlag(&quot;UseCompressedOops&quot;, Boolean.class);
180     public final boolean useCompressedClassPointers = getFlag(&quot;UseCompressedClassPointers&quot;, Boolean.class);
</pre>
<hr />
<pre>
185 
186     public final int minObjAlignment() {
187         return objectAlignment / heapWordSize;
188     }
189 
190     public final int logMinObjAlignment() {
191         return (int) (Math.log(objectAlignment) / Math.log(2));
192     }
193 
194     public final int narrowKlassSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_narrowKlass&quot;, Integer.class, &quot;int&quot;);
195     public final long narrowKlassBase = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_base&quot;, Long.class, &quot;address&quot;);
196     public final int narrowKlassShift = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_shift&quot;, Integer.class, &quot;int&quot;);
197     public final int logKlassAlignment = getConstant(&quot;LogKlassAlignmentInBytes&quot;, Integer.class);
198 
199     public final int stackShadowPages = getFlag(&quot;StackShadowPages&quot;, Integer.class);
200     public final int stackReservedPages = getFlag(&quot;StackReservedPages&quot;, Integer.class, 0);
201     public final boolean useStackBanging = getFlag(&quot;UseStackBanging&quot;, Boolean.class);
202     public final int stackBias = getConstant(&quot;STACK_BIAS&quot;, Integer.class);
203     public final int vmPageSize = getFieldValue(&quot;CompilerToVM::Data::vm_page_size&quot;, Integer.class, &quot;int&quot;);
204 
<span class="line-modified">205     public final int markOffset = getFieldOffset(&quot;oopDesc::_mark&quot;, Integer.class, &quot;markOop&quot;);</span>
206     public final int hubOffset = getFieldOffset(&quot;oopDesc::_metadata._klass&quot;, Integer.class, &quot;Klass*&quot;);
207 
<span class="line-modified">208     public final int prototypeMarkWordOffset = getFieldOffset(&quot;Klass::_prototype_header&quot;, Integer.class, &quot;markOop&quot;);</span>
209     public final int subklassOffset = getFieldOffset(&quot;Klass::_subklass&quot;, Integer.class, &quot;Klass*&quot;);
210     public final int nextSiblingOffset = getFieldOffset(&quot;Klass::_next_sibling&quot;, Integer.class, &quot;Klass*&quot;);
211     public final int superCheckOffsetOffset = getFieldOffset(&quot;Klass::_super_check_offset&quot;, Integer.class, &quot;juint&quot;);
212     public final int secondarySuperCacheOffset = getFieldOffset(&quot;Klass::_secondary_super_cache&quot;, Integer.class, &quot;Klass*&quot;);
213     public final int secondarySupersOffset = getFieldOffset(&quot;Klass::_secondary_supers&quot;, Integer.class, &quot;Array&lt;Klass*&gt;*&quot;);
214 
<span class="line-modified">215     public final boolean classMirrorIsHandle;</span>
<span class="line-modified">216     public final int classMirrorOffset;</span>
<span class="line-removed">217     {</span>
<span class="line-removed">218         String name = &quot;Klass::_java_mirror&quot;;</span>
<span class="line-removed">219         int offset = -1;</span>
<span class="line-removed">220         boolean isHandle = false;</span>
<span class="line-removed">221         try {</span>
<span class="line-removed">222             offset = getFieldOffset(name, Integer.class, &quot;oop&quot;);</span>
<span class="line-removed">223         } catch (JVMCIError e) {</span>
<span class="line-removed">224 </span>
<span class="line-removed">225         }</span>
<span class="line-removed">226         if (offset == -1) {</span>
<span class="line-removed">227             try {</span>
<span class="line-removed">228                 offset = getFieldOffset(name, Integer.class, &quot;jobject&quot;);</span>
<span class="line-removed">229                 isHandle = true;</span>
<span class="line-removed">230             } catch (JVMCIError e) {</span>
<span class="line-removed">231                 try {</span>
<span class="line-removed">232                     // JDK-8186777</span>
<span class="line-removed">233                     offset = getFieldOffset(name, Integer.class, &quot;OopHandle&quot;);</span>
<span class="line-removed">234                     isHandle = true;</span>
<span class="line-removed">235                 } catch (JVMCIError e2) {</span>
<span class="line-removed">236                 }</span>
<span class="line-removed">237             }</span>
<span class="line-removed">238         }</span>
<span class="line-removed">239         if (offset == -1) {</span>
<span class="line-removed">240             throw new JVMCIError(&quot;cannot get offset of field &quot; + name + &quot; with type oop, jobject or OopHandle&quot;);</span>
<span class="line-removed">241         }</span>
<span class="line-removed">242         classMirrorOffset = offset;</span>
<span class="line-removed">243         classMirrorIsHandle = isHandle;</span>
<span class="line-removed">244     }</span>
245 
246     public final int klassSuperKlassOffset = getFieldOffset(&quot;Klass::_super&quot;, Integer.class, &quot;Klass*&quot;);
247     public final int klassModifierFlagsOffset = getFieldOffset(&quot;Klass::_modifier_flags&quot;, Integer.class, &quot;jint&quot;);
248     public final int klassAccessFlagsOffset = getFieldOffset(&quot;Klass::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
249     public final int klassLayoutHelperOffset = getFieldOffset(&quot;Klass::_layout_helper&quot;, Integer.class, &quot;jint&quot;);
250 
251     public final int klassLayoutHelperNeutralValue = getConstant(&quot;Klass::_lh_neutral_value&quot;, Integer.class);
252     public final int layoutHelperLog2ElementSizeShift = getConstant(&quot;Klass::_lh_log2_element_size_shift&quot;, Integer.class);
253     public final int layoutHelperLog2ElementSizeMask = getConstant(&quot;Klass::_lh_log2_element_size_mask&quot;, Integer.class);
254     public final int layoutHelperElementTypeShift = getConstant(&quot;Klass::_lh_element_type_shift&quot;, Integer.class);
255     public final int layoutHelperElementTypeMask = getConstant(&quot;Klass::_lh_element_type_mask&quot;, Integer.class);
256     public final int layoutHelperHeaderSizeShift = getConstant(&quot;Klass::_lh_header_size_shift&quot;, Integer.class);
257     public final int layoutHelperHeaderSizeMask = getConstant(&quot;Klass::_lh_header_size_mask&quot;, Integer.class);
258     public final int layoutHelperArrayTagShift = getConstant(&quot;Klass::_lh_array_tag_shift&quot;, Integer.class);
259     public final int layoutHelperArrayTagTypeValue = getConstant(&quot;Klass::_lh_array_tag_type_value&quot;, Integer.class);
260     public final int layoutHelperArrayTagObjectValue = getConstant(&quot;Klass::_lh_array_tag_obj_value&quot;, Integer.class);
261 
262     /**
263      * This filters out the bit that differentiates a type array from an object array.
264      */
265     public int layoutHelperElementTypePrimitiveInPlace() {
266         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
267     }
268 
269     public final int vtableEntrySize = getFieldValue(&quot;CompilerToVM::Data::sizeof_vtableEntry&quot;, Integer.class, &quot;int&quot;);
270     public final int vtableEntryMethodOffset = getFieldOffset(&quot;vtableEntry::_method&quot;, Integer.class, &quot;Method*&quot;);
271 
272     public final int instanceKlassInitStateOffset = getFieldOffset(&quot;InstanceKlass::_init_state&quot;, Integer.class, &quot;u1&quot;);

273     public final int instanceKlassConstantsOffset = getFieldOffset(&quot;InstanceKlass::_constants&quot;, Integer.class, &quot;ConstantPool*&quot;);
274     public final int instanceKlassFieldsOffset = getFieldOffset(&quot;InstanceKlass::_fields&quot;, Integer.class, &quot;Array&lt;u2&gt;*&quot;);
275     public final int klassVtableStartOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_start_offset&quot;, Integer.class, &quot;int&quot;);
276     public final int klassVtableLengthOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_length_offset&quot;, Integer.class, &quot;int&quot;);
277 
278     public final int instanceKlassStateLinked = getConstant(&quot;InstanceKlass::linked&quot;, Integer.class);

279     public final int instanceKlassStateFullyInitialized = getConstant(&quot;InstanceKlass::fully_initialized&quot;, Integer.class);
280 
281     public final int arrayOopDescSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_arrayOopDesc&quot;, Integer.class, &quot;int&quot;);
282 
283     /**
284      * The offset of the array length word in an array object&#39;s header.
285      *
286      * See {@code arrayOopDesc::length_offset_in_bytes()}.
287      */
288     public final int arrayOopDescLengthOffset() {
289         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
290     }
291 
292     public final int arrayU1LengthOffset = getFieldOffset(&quot;Array&lt;int&gt;::_length&quot;, Integer.class, &quot;int&quot;);
293     public final int arrayU1DataOffset = getFieldOffset(&quot;Array&lt;u1&gt;::_data&quot;, Integer.class);
294     public final int arrayU2DataOffset = getFieldOffset(&quot;Array&lt;u2&gt;::_data&quot;, Integer.class);
295     public final int metaspaceArrayLengthOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_length&quot;, Integer.class, &quot;int&quot;);
296     public final int metaspaceArrayBaseOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_data[0]&quot;, Integer.class, &quot;Klass*&quot;);
297 
298     public final int arrayClassElementOffset = getFieldOffset(&quot;ObjArrayKlass::_element_klass&quot;, Integer.class, &quot;Klass*&quot;);
299 
300     public final int fieldInfoAccessFlagsOffset = getConstant(&quot;FieldInfo::access_flags_offset&quot;, Integer.class);
301     public final int fieldInfoNameIndexOffset = getConstant(&quot;FieldInfo::name_index_offset&quot;, Integer.class);
302     public final int fieldInfoSignatureIndexOffset = getConstant(&quot;FieldInfo::signature_index_offset&quot;, Integer.class);
303     public final int fieldInfoInitvalIndexOffset = getConstant(&quot;FieldInfo::initval_index_offset&quot;, Integer.class);
304     public final int fieldInfoLowPackedOffset = getConstant(&quot;FieldInfo::low_packed_offset&quot;, Integer.class);
305     public final int fieldInfoHighPackedOffset = getConstant(&quot;FieldInfo::high_packed_offset&quot;, Integer.class);
306     public final int fieldInfoFieldSlots = getConstant(&quot;FieldInfo::field_slots&quot;, Integer.class);
307 
308     public final int fieldInfoTagSize = getConstant(&quot;FIELDINFO_TAG_SIZE&quot;, Integer.class);
309 
310     public final int jvmAccMonitorMatch = getConstant(&quot;JVM_ACC_MONITOR_MATCH&quot;, Integer.class);
311     public final int jvmAccHasMonitorBytecodes = getConstant(&quot;JVM_ACC_HAS_MONITOR_BYTECODES&quot;, Integer.class);
312     public final int jvmAccHasFinalizer = getConstant(&quot;JVM_ACC_HAS_FINALIZER&quot;, Integer.class);
313     public final int jvmAccFieldInternal = getConstant(&quot;JVM_ACC_FIELD_INTERNAL&quot;, Integer.class);
314     public final int jvmAccFieldStable = getConstant(&quot;JVM_ACC_FIELD_STABLE&quot;, Integer.class);
315     public final int jvmAccFieldHasGenericSignature = getConstant(&quot;JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE&quot;, Integer.class);
316     public final int jvmAccWrittenFlags = getConstant(&quot;JVM_ACC_WRITTEN_FLAGS&quot;, Integer.class);
317     public final int jvmAccSynthetic = getConstant(&quot;JVM_ACC_SYNTHETIC&quot;, Integer.class);
318 
<span class="line-modified">319     public final int jvmciCompileStateCanPostOnExceptionsOffset = getJvmciCompileStateCanPostOnExceptionsOffset();</span>


320 
321     // Integer.MIN_VALUE if not available
<span class="line-modified">322     private int getJvmciCompileStateCanPostOnExceptionsOffset() {</span>
<span class="line-modified">323         int offset = getFieldOffset(&quot;JVMCICompileState::_jvmti_can_post_on_exceptions&quot;, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);</span>
324         if (offset == Integer.MIN_VALUE) {
325             // JDK 12
<span class="line-modified">326             offset = getFieldOffset(&quot;JVMCIEnv::_jvmti_can_post_on_exceptions&quot;, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);</span>
327         }
328         return offset;
329     }
330 
331     public final int threadTlabOffset = getFieldOffset(&quot;Thread::_tlab&quot;, Integer.class, &quot;ThreadLocalAllocBuffer&quot;);
332     public final int javaThreadAnchorOffset = getFieldOffset(&quot;JavaThread::_anchor&quot;, Integer.class, &quot;JavaFrameAnchor&quot;);
333     public final int javaThreadShouldPostOnExceptionsFlagOffset = getFieldOffset(&quot;JavaThread::_should_post_on_exceptions_flag&quot;, Integer.class, &quot;int&quot;, Integer.MIN_VALUE);
334     public final int threadObjectOffset = getFieldOffset(&quot;JavaThread::_threadObj&quot;, Integer.class, &quot;oop&quot;);
<span class="line-modified">335     public final int osThreadOffset = getFieldOffset(&quot;JavaThread::_osthread&quot;, Integer.class, &quot;OSThread*&quot;);</span>
336     public final int threadIsMethodHandleReturnOffset = getFieldOffset(&quot;JavaThread::_is_method_handle_return&quot;, Integer.class, &quot;int&quot;);
337     public final int threadObjectResultOffset = getFieldOffset(&quot;JavaThread::_vm_result&quot;, Integer.class, &quot;oop&quot;);
338     public final int jvmciCountersThreadOffset = getFieldOffset(&quot;JavaThread::_jvmci_counters&quot;, Integer.class, &quot;jlong*&quot;);

339     public final int javaThreadReservedStackActivationOffset = versioned.javaThreadReservedStackActivationOffset;

340 
341     public boolean requiresReservedStackCheck(List&lt;ResolvedJavaMethod&gt; methods) {
342         if (enableStackReservedZoneAddress != 0 &amp;&amp; methods != null) {
343             for (ResolvedJavaMethod method : methods) {
344                 if (((HotSpotResolvedJavaMethod) method).hasReservedStackAccess()) {
345                     return true;
346                 }
347             }
348         }
349         return false;
350     }
351 
352     /**
353      * An invalid value for {@link #rtldDefault}.
354      */
355     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
356 
357     /**
358      * Address of the library lookup routine. The C signature of this routine is:
359      *
</pre>
<hr />
<pre>
417     }
418 
419     public int threadLastJavaPcOffset() {
420         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
421     }
422 
423     public int threadLastJavaFpOffset() {
424         assert osArch.equals(&quot;aarch64&quot;) || osArch.equals(&quot;amd64&quot;);
425         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_last_Java_fp&quot;, Integer.class, &quot;intptr_t*&quot;);
426     }
427 
428     public int threadJavaFrameAnchorFlagsOffset() {
429         assert osArch.equals(&quot;sparc&quot;);
430         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_flags&quot;, Integer.class, &quot;int&quot;);
431     }
432 
433     public final int runtimeCallStackSize = getConstant(&quot;frame::arg_reg_save_area_bytes&quot;, Integer.class, intRequiredOnAMD64);
434     public final int frameInterpreterFrameSenderSpOffset = getConstant(&quot;frame::interpreter_frame_sender_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
435     public final int frameInterpreterFrameLastSpOffset = getConstant(&quot;frame::interpreter_frame_last_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
436 
<span class="line-modified">437     public final int osThreadInterruptedOffset = getFieldOffset(&quot;OSThread::_interrupted&quot;, Integer.class, &quot;jint&quot;);</span>
438 
<span class="line-modified">439     public final long markOopDescHashShift = getConstant(&quot;markOopDesc::hash_shift&quot;, Long.class);</span>
440 
<span class="line-modified">441     public final int biasedLockMaskInPlace = getConstant(&quot;markOopDesc::biased_lock_mask_in_place&quot;, Integer.class);</span>
<span class="line-modified">442     public final int ageMaskInPlace = getConstant(&quot;markOopDesc::age_mask_in_place&quot;, Integer.class);</span>
<span class="line-modified">443     public final int epochMaskInPlace = getConstant(&quot;markOopDesc::epoch_mask_in_place&quot;, Integer.class);</span>
<span class="line-modified">444     public final long markOopDescHashMask = getConstant(&quot;markOopDesc::hash_mask&quot;, Long.class);</span>
<span class="line-modified">445     public final long markOopDescHashMaskInPlace = getConstant(&quot;markOopDesc::hash_mask_in_place&quot;, Long.class);</span>
446 
<span class="line-modified">447     public final int unlockedMask = getConstant(&quot;markOopDesc::unlocked_value&quot;, Integer.class);</span>
<span class="line-modified">448     public final int monitorMask = getConstant(&quot;markOopDesc::monitor_value&quot;, Integer.class, -1);</span>
<span class="line-modified">449     public final int biasedLockPattern = getConstant(&quot;markOopDesc::biased_lock_pattern&quot;, Integer.class);</span>
450 
451     // This field has no type in vmStructs.cpp
452     public final int objectMonitorOwner = getFieldOffset(&quot;ObjectMonitor::_owner&quot;, Integer.class, null, -1);
453     public final int objectMonitorRecursions = getFieldOffset(&quot;ObjectMonitor::_recursions&quot;, Integer.class, &quot;intptr_t&quot;, -1);
454     public final int objectMonitorCxq = getFieldOffset(&quot;ObjectMonitor::_cxq&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);
455     public final int objectMonitorEntryList = getFieldOffset(&quot;ObjectMonitor::_EntryList&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);

456 
<span class="line-modified">457     public final int markWordNoHashInPlace = getConstant(&quot;markOopDesc::no_hash_in_place&quot;, Integer.class);</span>
<span class="line-modified">458     public final int markWordNoLockInPlace = getConstant(&quot;markOopDesc::no_lock_in_place&quot;, Integer.class);</span>
459 
460     /**
<span class="line-modified">461      * See {@code markOopDesc::prototype()}.</span>
462      */
463     public long arrayPrototypeMarkWord() {
464         return markWordNoHashInPlace | markWordNoLockInPlace;
465     }
466 
467     /**
<span class="line-modified">468      * See {@code markOopDesc::copy_set_hash()}.</span>
469      */
470     public long tlabIntArrayMarkWord() {
<span class="line-modified">471         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);</span>
<span class="line-modified">472         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);</span>
473         return tmp;
474     }
475 




476     /**
477      * Mark word right shift to get identity hash code.
478      */
<span class="line-modified">479     public final int identityHashCodeShift = getConstant(&quot;markOopDesc::hash_shift&quot;, Integer.class);</span>
480 
481     /**
482      * Identity hash code value when uninitialized.
483      */
<span class="line-modified">484     public final int uninitializedIdentityHashCodeValue = getConstant(&quot;markOopDesc::no_hash&quot;, Integer.class);</span>
485 
486     public final int methodAccessFlagsOffset = getFieldOffset(&quot;Method::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
487     public final int methodConstMethodOffset = getFieldOffset(&quot;Method::_constMethod&quot;, Integer.class, &quot;ConstMethod*&quot;);
488     public final int methodIntrinsicIdOffset = versioned.methodIntrinsicIdOffset;
489     public final int methodFlagsOffset = versioned.methodFlagsOffset;
490     public final int methodVtableIndexOffset = getFieldOffset(&quot;Method::_vtable_index&quot;, Integer.class, &quot;int&quot;);
491 
492     public final int methodCountersOffset = getFieldOffset(&quot;Method::_method_counters&quot;, Integer.class, &quot;MethodCounters*&quot;);
493     public final int methodDataOffset = getFieldOffset(&quot;Method::_method_data&quot;, Integer.class, &quot;MethodData*&quot;);
494     public final int methodCompiledEntryOffset = getFieldOffset(&quot;Method::_from_compiled_entry&quot;, Integer.class, &quot;address&quot;);
495     public final int methodCodeOffset = versioned.methodCodeOffset;
496 
497     public final int methodFlagsCallerSensitive = getConstant(&quot;Method::_caller_sensitive&quot;, Integer.class);
498     public final int methodFlagsForceInline = getConstant(&quot;Method::_force_inline&quot;, Integer.class);
499     public final int methodFlagsDontInline = getConstant(&quot;Method::_dont_inline&quot;, Integer.class);
500     public final int methodFlagsHidden = getConstant(&quot;Method::_hidden&quot;, Integer.class);
501     public final int nonvirtualVtableIndex = getConstant(&quot;Method::nonvirtual_vtable_index&quot;, Integer.class);
502     public final int invalidVtableIndex = getConstant(&quot;Method::invalid_vtable_index&quot;, Integer.class);
503 
504     public final int invocationCounterOffset = getFieldOffset(&quot;MethodCounters::_invocation_counter&quot;, Integer.class, &quot;InvocationCounter&quot;);
</pre>
<hr />
<pre>
538      */
539     public final int maxOopMapStackOffset = getFieldValue(&quot;CompilerToVM::Data::_max_oop_map_stack_offset&quot;, Integer.class, &quot;int&quot;);
540 
541     public final long safepointPollingAddress = getFieldValue(&quot;os::_polling_page&quot;, Long.class, &quot;address&quot;);
542 
543     // G1 Collector Related Values.
544 
545     public final byte dirtyCardValue = versioned.dirtyCardValue;
546     public final byte g1YoungCardValue = versioned.g1YoungCardValue;
547 
548     public final int g1SATBQueueMarkingOffset = versioned.g1SATBQueueMarkingOffset;
549     public final int g1SATBQueueIndexOffset = versioned.g1SATBQueueIndexOffset;
550     public final int g1SATBQueueBufferOffset = versioned.g1SATBQueueBufferOffset;
551     public final int g1CardQueueIndexOffset = versioned.g1CardQueueIndexOffset;
552     public final int g1CardQueueBufferOffset = versioned.g1CardQueueBufferOffset;
553 
554     public final int klassOffset = getFieldValue(&quot;java_lang_Class::_klass_offset&quot;, Integer.class, &quot;int&quot;);
555     public final int arrayKlassOffset = getFieldValue(&quot;java_lang_Class::_array_klass_offset&quot;, Integer.class, &quot;int&quot;);
556 
557     public final int basicLockSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_BasicLock&quot;, Integer.class, &quot;int&quot;);
<span class="line-modified">558     public final int basicLockDisplacedHeaderOffset = getFieldOffset(&quot;BasicLock::_displaced_header&quot;, Integer.class, &quot;markOop&quot;);</span>
559 
560     public final int threadPollingPageOffset = getFieldOffset(&quot;Thread::_polling_page&quot;, Integer.class, &quot;address&quot;, -1);
561     public final int threadAllocatedBytesOffset = getFieldOffset(&quot;Thread::_allocated_bytes&quot;, Integer.class, &quot;jlong&quot;);
562 
563     public final int tlabRefillWasteIncrement = getFlag(&quot;TLABWasteIncrement&quot;, Integer.class);
564 
565     private final int threadLocalAllocBufferStartOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_start&quot;, Integer.class, &quot;HeapWord*&quot;);
566     private final int threadLocalAllocBufferEndOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_end&quot;, Integer.class, &quot;HeapWord*&quot;);
567     private final int threadLocalAllocBufferTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_top&quot;, Integer.class, &quot;HeapWord*&quot;);
568     private final int threadLocalAllocBufferPfTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_pf_top&quot;, Integer.class, &quot;HeapWord*&quot;);
569     private final int threadLocalAllocBufferSlowAllocationsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_slow_allocations&quot;, Integer.class, &quot;unsigned&quot;);
570     private final int threadLocalAllocBufferFastRefillWasteOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_fast_refill_waste&quot;, Integer.class, &quot;unsigned&quot;);
571     private final int threadLocalAllocBufferNumberOfRefillsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_number_of_refills&quot;, Integer.class, &quot;unsigned&quot;);
572     private final int threadLocalAllocBufferRefillWasteLimitOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_refill_waste_limit&quot;, Integer.class, &quot;size_t&quot;);
573     private final int threadLocalAllocBufferDesiredSizeOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_desired_size&quot;, Integer.class, &quot;size_t&quot;);
574 
575     public int tlabSlowAllocationsOffset() {
576         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
577     }
578 
</pre>
<hr />
<pre>
595     public int threadTlabStartOffset() {
596         return threadTlabOffset + threadLocalAllocBufferStartOffset;
597     }
598 
599     public int threadTlabEndOffset() {
600         return threadTlabOffset + threadLocalAllocBufferEndOffset;
601     }
602 
603     public int threadTlabTopOffset() {
604         return threadTlabOffset + threadLocalAllocBufferTopOffset;
605     }
606 
607     public int threadTlabPfTopOffset() {
608         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
609     }
610 
611     public final int tlabAlignmentReserve = getFieldValue(&quot;CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve&quot;, Integer.class, &quot;size_t&quot;);
612 
613     public final boolean tlabStats = getFlag(&quot;TLABStats&quot;, Boolean.class);
614 






615     // FIXME This is only temporary until the GC code is changed.
616     public final boolean inlineContiguousAllocationSupported = getFieldValue(&quot;CompilerToVM::Data::_supports_inline_contig_alloc&quot;, Boolean.class);
617     public final long heapEndAddress = getFieldValue(&quot;CompilerToVM::Data::_heap_end_addr&quot;, Long.class, &quot;HeapWord**&quot;);
618     public final long heapTopAddress = versioned.heapTopAddress;
619 
620     public final boolean cmsIncrementalMode = getFlag(&quot;CMSIncrementalMode&quot;, Boolean.class, false);
621 
622     public final long inlineCacheMissStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_ic_miss_stub&quot;, Long.class, &quot;address&quot;);
623     public final long handleWrongMethodStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub&quot;, Long.class, &quot;address&quot;);
624 
<span class="line-modified">625     public final long handleDeoptStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack&quot;, Long.class, &quot;address&quot;);</span>
<span class="line-modified">626     public final long uncommonTrapStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap&quot;, Long.class, &quot;address&quot;);</span>

627 
628     public final long codeCacheLowBound = versioned.codeCacheLowBound;
629     public final long codeCacheHighBound = versioned.codeCacheHighBound;
630 
631     public final long aescryptEncryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_encryptBlock&quot;, Long.class, &quot;address&quot;);
632     public final long aescryptDecryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_decryptBlock&quot;, Long.class, &quot;address&quot;);
633     public final long cipherBlockChainingEncryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_encryptAESCrypt&quot;, Long.class, &quot;address&quot;);
634     public final long cipherBlockChainingDecryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_decryptAESCrypt&quot;, Long.class, &quot;address&quot;);
635     public final long updateBytesCRC32Stub = getFieldValue(&quot;StubRoutines::_updateBytesCRC32&quot;, Long.class, &quot;address&quot;);
636     public final long crcTableAddress = getFieldValue(&quot;StubRoutines::_crc_table_adr&quot;, Long.class, &quot;address&quot;);
637 
638     public final long sha1ImplCompress = getFieldValue(&quot;StubRoutines::_sha1_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
639     public final long sha1ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha1_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
640     public final long sha256ImplCompress = getFieldValue(&quot;StubRoutines::_sha256_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
641     public final long sha256ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha256_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
642     public final long sha512ImplCompress = getFieldValue(&quot;StubRoutines::_sha512_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
643     public final long sha512ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha512_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
644     public final long multiplyToLen = getFieldValue(&quot;StubRoutines::_multiplyToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
645 
646     public final long counterModeAESCrypt = getFieldValue(&quot;StubRoutines::_counterMode_AESCrypt&quot;, Long.class, &quot;address&quot;, 0L);
647     public final long ghashProcessBlocks = getFieldValue(&quot;StubRoutines::_ghash_processBlocks&quot;, Long.class, &quot;address&quot;, 0L);

648     public final long crc32cTableTddr = getFieldValue(&quot;StubRoutines::_crc32c_table_addr&quot;, Long.class, &quot;address&quot;, 0L);
649     public final long updateBytesCRC32C = getFieldValue(&quot;StubRoutines::_updateBytesCRC32C&quot;, Long.class, &quot;address&quot;, 0L);
650     public final long updateBytesAdler32 = getFieldValue(&quot;StubRoutines::_updateBytesAdler32&quot;, Long.class, &quot;address&quot;, 0L);
651     public final long squareToLen = getFieldValue(&quot;StubRoutines::_squareToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
652     public final long mulAdd = getFieldValue(&quot;StubRoutines::_mulAdd&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
653     public final long montgomeryMultiply = getFieldValue(&quot;StubRoutines::_montgomeryMultiply&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
654     public final long montgomerySquare = getFieldValue(&quot;StubRoutines::_montgomerySquare&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
655     public final long vectorizedMismatch = getFieldValue(&quot;StubRoutines::_vectorizedMismatch&quot;, Long.class, &quot;address&quot;, 0L);
656 
657     public final long throwDelayedStackOverflowErrorEntry = versioned.throwDelayedStackOverflowErrorEntry;
658 
659     public final long jbyteArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_arraycopy&quot;, Long.class, &quot;address&quot;);
660     public final long jshortArraycopy = getFieldValue(&quot;StubRoutines::_jshort_arraycopy&quot;, Long.class, &quot;address&quot;);
661     public final long jintArraycopy = getFieldValue(&quot;StubRoutines::_jint_arraycopy&quot;, Long.class, &quot;address&quot;);
662     public final long jlongArraycopy = getFieldValue(&quot;StubRoutines::_jlong_arraycopy&quot;, Long.class, &quot;address&quot;);
663     public final long oopArraycopy = getFieldValue(&quot;StubRoutines::_oop_arraycopy&quot;, Long.class, &quot;address&quot;);
664     public final long oopArraycopyUninit = getFieldValue(&quot;StubRoutines::_oop_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
665     public final long jbyteDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
666     public final long jshortDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jshort_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
667     public final long jintDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jint_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
</pre>
<hr />
<pre>
700     public boolean areNullAllocationStubsAvailable() {
701         return newInstanceOrNullAddress != 0L;
702     }
703 
704     /**
705      * Checks that HotSpot implements all or none of the allocate-or-null stubs.
706      */
707     private boolean checkNullAllocationStubs() {
708         if (newInstanceOrNullAddress == 0L) {
709             assert newArrayOrNullAddress == 0L;
710             assert newMultiArrayOrNullAddress == 0L;
711             assert dynamicNewInstanceOrNullAddress == 0L;
712         } else {
713             assert newArrayOrNullAddress != 0L;
714             assert newMultiArrayOrNullAddress != 0L;
715             assert dynamicNewInstanceOrNullAddress != 0L;
716         }
717         return true;
718     }
719 
<span class="line-removed">720     public final long threadIsInterruptedAddress = getAddress(&quot;JVMCIRuntime::thread_is_interrupted&quot;);</span>
721     public final long vmMessageAddress = getAddress(&quot;JVMCIRuntime::vm_message&quot;);
722     public final long identityHashCodeAddress = getAddress(&quot;JVMCIRuntime::identity_hash_code&quot;);
723     public final long exceptionHandlerForPcAddress = getAddress(&quot;JVMCIRuntime::exception_handler_for_pc&quot;);
724     public final long monitorenterAddress = getAddress(&quot;JVMCIRuntime::monitorenter&quot;);
725     public final long monitorexitAddress = getAddress(&quot;JVMCIRuntime::monitorexit&quot;);
726     public final long notifyAddress = getAddress(&quot;JVMCIRuntime::object_notify&quot;, 0L);
727     public final long notifyAllAddress = getAddress(&quot;JVMCIRuntime::object_notifyAll&quot;, 0L);
728     public final long throwAndPostJvmtiExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_and_post_jvmti_exception&quot;);
729     public final long throwKlassExternalNameExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_klass_external_name_exception&quot;);
730     public final long throwClassCastExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_class_cast_exception&quot;);
731     public final long logPrimitiveAddress = getAddress(&quot;JVMCIRuntime::log_primitive&quot;);
732     public final long logObjectAddress = getAddress(&quot;JVMCIRuntime::log_object&quot;);
733     public final long logPrintfAddress = getAddress(&quot;JVMCIRuntime::log_printf&quot;);
734     public final long vmErrorAddress = getAddress(&quot;JVMCIRuntime::vm_error&quot;);
735     public final long loadAndClearExceptionAddress = getAddress(&quot;JVMCIRuntime::load_and_clear_exception&quot;);
736     public final long writeBarrierPreAddress = getAddress(&quot;JVMCIRuntime::write_barrier_pre&quot;);
737     public final long writeBarrierPostAddress = getAddress(&quot;JVMCIRuntime::write_barrier_post&quot;);
738     public final long validateObject = getAddress(&quot;JVMCIRuntime::validate_object&quot;);
739 
740     public final long testDeoptimizeCallInt = getAddress(&quot;JVMCIRuntime::test_deoptimize_call_int&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 37 import jdk.vm.ci.meta.ResolvedJavaMethod;
 38 
 39 /**
 40  * Used to access native configuration details.
 41  */
 42 public class GraalHotSpotVMConfig extends GraalHotSpotVMConfigBase {
 43 
 44     GraalHotSpotVMConfig(HotSpotVMConfigStore store) {
 45         super(store);
 46 
 47         assert narrowKlassShift &lt;= logKlassAlignment;
 48         assert narrowOopShift &lt;= logMinObjAlignment();
 49         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift);
 50         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift);
 51 
 52         assert check();
 53     }
 54 
 55     private final CompressEncoding oopEncoding;
 56     private final CompressEncoding klassEncoding;
<span class="line-added"> 57     private final String markWord = versioned.markWordFieldType;</span>
 58 
 59     public CompressEncoding getOopEncoding() {
 60         return oopEncoding;
 61     }
 62 
 63     public CompressEncoding getKlassEncoding() {
 64         return klassEncoding;
 65     }
 66 
 67     public final boolean cAssertions = getConstant(&quot;ASSERT&quot;, Boolean.class);
 68 
 69     public final int codeEntryAlignment = getFlag(&quot;CodeEntryAlignment&quot;, Integer.class);
 70     public final boolean enableContended = getFlag(&quot;EnableContended&quot;, Boolean.class);
 71     public final boolean restrictContended = getFlag(&quot;RestrictContended&quot;, Boolean.class);
 72     public final int contendedPaddingWidth = getFlag(&quot;ContendedPaddingWidth&quot;, Integer.class);


 73     public final boolean verifyOops = getFlag(&quot;VerifyOops&quot;, Boolean.class);
 74     public final boolean ciTime = getFlag(&quot;CITime&quot;, Boolean.class);
 75     public final boolean ciTimeEach = getFlag(&quot;CITimeEach&quot;, Boolean.class);
 76     public final boolean dontCompileHugeMethods = getFlag(&quot;DontCompileHugeMethods&quot;, Boolean.class);
 77     public final int hugeMethodLimit = getFlag(&quot;HugeMethodLimit&quot;, Integer.class);
 78     public final boolean printInlining = getFlag(&quot;PrintInlining&quot;, Boolean.class);
 79     public final boolean inline = getFlag(&quot;Inline&quot;, Boolean.class);
 80     public final boolean inlineNotify = versioned.inlineNotify;
 81     public final boolean useFastLocking = getFlag(&quot;JVMCIUseFastLocking&quot;, Boolean.class);
 82     public final boolean forceUnreachable = getFlag(&quot;ForceUnreachable&quot;, Boolean.class);
 83     public final int codeSegmentSize = getFlag(&quot;CodeCacheSegmentSize&quot;, Integer.class);
 84     public final boolean foldStableValues = getFlag(&quot;FoldStableValues&quot;, Boolean.class);
 85     public final int maxVectorSize = getFlag(&quot;MaxVectorSize&quot;, Integer.class);
 86 
 87     public final boolean verifyBeforeGC = getFlag(&quot;VerifyBeforeGC&quot;, Boolean.class);
 88     public final boolean verifyAfterGC = getFlag(&quot;VerifyAfterGC&quot;, Boolean.class);
 89 
 90     public final boolean useTLAB = getFlag(&quot;UseTLAB&quot;, Boolean.class);
 91     public final boolean useBiasedLocking = getFlag(&quot;UseBiasedLocking&quot;, Boolean.class);
 92     public final boolean usePopCountInstruction = getFlag(&quot;UsePopCountInstruction&quot;, Boolean.class);
 93     public final boolean useAESIntrinsics = getFlag(&quot;UseAESIntrinsics&quot;, Boolean.class);
 94     public final boolean useAESCTRIntrinsics = getFlag(&quot;UseAESCTRIntrinsics&quot;, Boolean.class, false);
 95     public final boolean useCRC32Intrinsics = getFlag(&quot;UseCRC32Intrinsics&quot;, Boolean.class);
 96     public final boolean useCRC32CIntrinsics = versioned.useCRC32CIntrinsics;
<span class="line-modified"> 97     public final boolean threadLocalHandshakes = versioned.threadLocalHandshakes;</span>
 98 
 99     private final boolean useMultiplyToLenIntrinsic = getFlag(&quot;UseMultiplyToLenIntrinsic&quot;, Boolean.class);
100     private final boolean useSHA1Intrinsics = getFlag(&quot;UseSHA1Intrinsics&quot;, Boolean.class);
101     private final boolean useSHA256Intrinsics = getFlag(&quot;UseSHA256Intrinsics&quot;, Boolean.class);
102     private final boolean useSHA512Intrinsics = getFlag(&quot;UseSHA512Intrinsics&quot;, Boolean.class);
103     private final boolean useGHASHIntrinsics = getFlag(&quot;UseGHASHIntrinsics&quot;, Boolean.class, false);
<span class="line-added">104     private final boolean useBase64Intrinsics = getFlag(&quot;UseBASE64Intrinsics&quot;, Boolean.class, false);</span>
105     private final boolean useMontgomeryMultiplyIntrinsic = getFlag(&quot;UseMontgomeryMultiplyIntrinsic&quot;, Boolean.class, false);
106     private final boolean useMontgomerySquareIntrinsic = getFlag(&quot;UseMontgomerySquareIntrinsic&quot;, Boolean.class, false);
107     private final boolean useMulAddIntrinsic = getFlag(&quot;UseMulAddIntrinsic&quot;, Boolean.class, false);
108     private final boolean useSquareToLenIntrinsic = getFlag(&quot;UseSquareToLenIntrinsic&quot;, Boolean.class, false);
109     public final boolean useVectorizedMismatchIntrinsic = getFlag(&quot;UseVectorizedMismatchIntrinsic&quot;, Boolean.class, false);
<span class="line-added">110     public final boolean useFMAIntrinsics = getFlag(&quot;UseFMA&quot;, Boolean.class, false);</span>
<span class="line-added">111 </span>
<span class="line-added">112     public final boolean preserveFramePointer = getFlag(&quot;PreserveFramePointer&quot;, Boolean.class, false);</span>
113 
114     /*
115      * These are methods because in some JDKs the flags are visible but the stubs themselves haven&#39;t
116      * been exported so we have to check both if the flag is on and if we have the stub.
117      */
118     public boolean useMultiplyToLenIntrinsic() {
119         return useMultiplyToLenIntrinsic &amp;&amp; multiplyToLen != 0;
120     }
121 
122     public boolean useSHA1Intrinsics() {
123         return useSHA1Intrinsics &amp;&amp; sha1ImplCompress != 0 &amp;&amp; sha1ImplCompressMultiBlock != 0;
124     }
125 
126     public boolean useSHA256Intrinsics() {
127         return useSHA256Intrinsics &amp;&amp; sha256ImplCompress != 0 &amp;&amp; sha256ImplCompressMultiBlock != 0;
128     }
129 
130     public boolean useSHA512Intrinsics() {
131         return useSHA512Intrinsics &amp;&amp; sha512ImplCompress != 0 &amp;&amp; sha512ImplCompressMultiBlock != 0;
132     }
133 
134     public boolean useGHASHIntrinsics() {
135         return useGHASHIntrinsics &amp;&amp; ghashProcessBlocks != 0;
136     }
137 
<span class="line-added">138     public boolean useBase64Intrinsics() {</span>
<span class="line-added">139         return useBase64Intrinsics &amp;&amp; base64EncodeBlock != 0;</span>
<span class="line-added">140     }</span>
<span class="line-added">141 </span>
142     public boolean useMontgomeryMultiplyIntrinsic() {
143         return useMontgomeryMultiplyIntrinsic &amp;&amp; montgomeryMultiply != 0;
144     }
145 
146     public boolean useMontgomerySquareIntrinsic() {
147         return useMontgomerySquareIntrinsic &amp;&amp; montgomerySquare != 0;
148     }
149 
150     public boolean useMulAddIntrinsic() {
151         return useMulAddIntrinsic &amp;&amp; mulAdd != 0;
152     }
153 
154     public boolean useSquareToLenIntrinsic() {
155         return useSquareToLenIntrinsic &amp;&amp; squareToLen != 0;
156     }
157 
158     public boolean inlineNotify() {
159         return inlineNotify &amp;&amp; notifyAddress != 0;
160     }
161 
162     public boolean inlineNotifyAll() {
163         return inlineNotify &amp;&amp; notifyAllAddress != 0;
164     }
165 
166     public final boolean useG1GC = getFlag(&quot;UseG1GC&quot;, Boolean.class);
<span class="line-modified">167     public final boolean useCMSGC = getFlag(&quot;UseConcMarkSweepGC&quot;, Boolean.class, false);</span>
168 
169     public final int allocatePrefetchStyle = getFlag(&quot;AllocatePrefetchStyle&quot;, Integer.class);
170     public final int allocatePrefetchInstr = getFlag(&quot;AllocatePrefetchInstr&quot;, Integer.class);
171     public final int allocatePrefetchLines = getFlag(&quot;AllocatePrefetchLines&quot;, Integer.class);
172     public final int allocateInstancePrefetchLines = getFlag(&quot;AllocateInstancePrefetchLines&quot;, Integer.class);
173     public final int allocatePrefetchStepSize = getFlag(&quot;AllocatePrefetchStepSize&quot;, Integer.class);
174     public final int allocatePrefetchDistance = getFlag(&quot;AllocatePrefetchDistance&quot;, Integer.class);
175 
176     private final long universeCollectedHeap = getFieldValue(&quot;CompilerToVM::Data::Universe_collectedHeap&quot;, Long.class, &quot;CollectedHeap*&quot;);
177     private final int collectedHeapTotalCollectionsOffset = getFieldOffset(&quot;CollectedHeap::_total_collections&quot;, Integer.class, &quot;unsigned int&quot;);
178 
179     public long gcTotalCollectionsAddress() {
180         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
181     }
182 
183     public final boolean useDeferredInitBarriers = getFlag(&quot;ReduceInitialCardMarks&quot;, Boolean.class);
184 
185     // Compressed Oops related values.
186     public final boolean useCompressedOops = getFlag(&quot;UseCompressedOops&quot;, Boolean.class);
187     public final boolean useCompressedClassPointers = getFlag(&quot;UseCompressedClassPointers&quot;, Boolean.class);
</pre>
<hr />
<pre>
192 
193     public final int minObjAlignment() {
194         return objectAlignment / heapWordSize;
195     }
196 
197     public final int logMinObjAlignment() {
198         return (int) (Math.log(objectAlignment) / Math.log(2));
199     }
200 
201     public final int narrowKlassSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_narrowKlass&quot;, Integer.class, &quot;int&quot;);
202     public final long narrowKlassBase = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_base&quot;, Long.class, &quot;address&quot;);
203     public final int narrowKlassShift = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_shift&quot;, Integer.class, &quot;int&quot;);
204     public final int logKlassAlignment = getConstant(&quot;LogKlassAlignmentInBytes&quot;, Integer.class);
205 
206     public final int stackShadowPages = getFlag(&quot;StackShadowPages&quot;, Integer.class);
207     public final int stackReservedPages = getFlag(&quot;StackReservedPages&quot;, Integer.class, 0);
208     public final boolean useStackBanging = getFlag(&quot;UseStackBanging&quot;, Boolean.class);
209     public final int stackBias = getConstant(&quot;STACK_BIAS&quot;, Integer.class);
210     public final int vmPageSize = getFieldValue(&quot;CompilerToVM::Data::vm_page_size&quot;, Integer.class, &quot;int&quot;);
211 
<span class="line-modified">212     public final int markOffset = getFieldOffset(&quot;oopDesc::_mark&quot;, Integer.class, markWord);</span>
213     public final int hubOffset = getFieldOffset(&quot;oopDesc::_metadata._klass&quot;, Integer.class, &quot;Klass*&quot;);
214 
<span class="line-modified">215     public final int prototypeMarkWordOffset = getFieldOffset(&quot;Klass::_prototype_header&quot;, Integer.class, markWord);</span>
216     public final int subklassOffset = getFieldOffset(&quot;Klass::_subklass&quot;, Integer.class, &quot;Klass*&quot;);
217     public final int nextSiblingOffset = getFieldOffset(&quot;Klass::_next_sibling&quot;, Integer.class, &quot;Klass*&quot;);
218     public final int superCheckOffsetOffset = getFieldOffset(&quot;Klass::_super_check_offset&quot;, Integer.class, &quot;juint&quot;);
219     public final int secondarySuperCacheOffset = getFieldOffset(&quot;Klass::_secondary_super_cache&quot;, Integer.class, &quot;Klass*&quot;);
220     public final int secondarySupersOffset = getFieldOffset(&quot;Klass::_secondary_supers&quot;, Integer.class, &quot;Array&lt;Klass*&gt;*&quot;);
221 
<span class="line-modified">222     public final boolean classMirrorIsHandle = versioned.classMirrorIsHandle;</span>
<span class="line-modified">223     public final int classMirrorOffset = versioned.classMirrorOffset;</span>




























224 
225     public final int klassSuperKlassOffset = getFieldOffset(&quot;Klass::_super&quot;, Integer.class, &quot;Klass*&quot;);
226     public final int klassModifierFlagsOffset = getFieldOffset(&quot;Klass::_modifier_flags&quot;, Integer.class, &quot;jint&quot;);
227     public final int klassAccessFlagsOffset = getFieldOffset(&quot;Klass::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
228     public final int klassLayoutHelperOffset = getFieldOffset(&quot;Klass::_layout_helper&quot;, Integer.class, &quot;jint&quot;);
229 
230     public final int klassLayoutHelperNeutralValue = getConstant(&quot;Klass::_lh_neutral_value&quot;, Integer.class);
231     public final int layoutHelperLog2ElementSizeShift = getConstant(&quot;Klass::_lh_log2_element_size_shift&quot;, Integer.class);
232     public final int layoutHelperLog2ElementSizeMask = getConstant(&quot;Klass::_lh_log2_element_size_mask&quot;, Integer.class);
233     public final int layoutHelperElementTypeShift = getConstant(&quot;Klass::_lh_element_type_shift&quot;, Integer.class);
234     public final int layoutHelperElementTypeMask = getConstant(&quot;Klass::_lh_element_type_mask&quot;, Integer.class);
235     public final int layoutHelperHeaderSizeShift = getConstant(&quot;Klass::_lh_header_size_shift&quot;, Integer.class);
236     public final int layoutHelperHeaderSizeMask = getConstant(&quot;Klass::_lh_header_size_mask&quot;, Integer.class);
237     public final int layoutHelperArrayTagShift = getConstant(&quot;Klass::_lh_array_tag_shift&quot;, Integer.class);
238     public final int layoutHelperArrayTagTypeValue = getConstant(&quot;Klass::_lh_array_tag_type_value&quot;, Integer.class);
239     public final int layoutHelperArrayTagObjectValue = getConstant(&quot;Klass::_lh_array_tag_obj_value&quot;, Integer.class);
240 
241     /**
242      * This filters out the bit that differentiates a type array from an object array.
243      */
244     public int layoutHelperElementTypePrimitiveInPlace() {
245         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
246     }
247 
248     public final int vtableEntrySize = getFieldValue(&quot;CompilerToVM::Data::sizeof_vtableEntry&quot;, Integer.class, &quot;int&quot;);
249     public final int vtableEntryMethodOffset = getFieldOffset(&quot;vtableEntry::_method&quot;, Integer.class, &quot;Method*&quot;);
250 
251     public final int instanceKlassInitStateOffset = getFieldOffset(&quot;InstanceKlass::_init_state&quot;, Integer.class, &quot;u1&quot;);
<span class="line-added">252     public final int instanceKlassInitThreadOffset = getFieldOffset(&quot;InstanceKlass::_init_thread&quot;, Integer.class, &quot;Thread*&quot;, -1);</span>
253     public final int instanceKlassConstantsOffset = getFieldOffset(&quot;InstanceKlass::_constants&quot;, Integer.class, &quot;ConstantPool*&quot;);
254     public final int instanceKlassFieldsOffset = getFieldOffset(&quot;InstanceKlass::_fields&quot;, Integer.class, &quot;Array&lt;u2&gt;*&quot;);
255     public final int klassVtableStartOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_start_offset&quot;, Integer.class, &quot;int&quot;);
256     public final int klassVtableLengthOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_length_offset&quot;, Integer.class, &quot;int&quot;);
257 
258     public final int instanceKlassStateLinked = getConstant(&quot;InstanceKlass::linked&quot;, Integer.class);
<span class="line-added">259     public final int instanceKlassStateBeingInitialized = getConstant(&quot;InstanceKlass::being_initialized&quot;, Integer.class, -1);</span>
260     public final int instanceKlassStateFullyInitialized = getConstant(&quot;InstanceKlass::fully_initialized&quot;, Integer.class);
261 
262     public final int arrayOopDescSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_arrayOopDesc&quot;, Integer.class, &quot;int&quot;);
263 
264     /**
265      * The offset of the array length word in an array object&#39;s header.
266      *
267      * See {@code arrayOopDesc::length_offset_in_bytes()}.
268      */
269     public final int arrayOopDescLengthOffset() {
270         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
271     }
272 
273     public final int arrayU1LengthOffset = getFieldOffset(&quot;Array&lt;int&gt;::_length&quot;, Integer.class, &quot;int&quot;);
274     public final int arrayU1DataOffset = getFieldOffset(&quot;Array&lt;u1&gt;::_data&quot;, Integer.class);
275     public final int arrayU2DataOffset = getFieldOffset(&quot;Array&lt;u2&gt;::_data&quot;, Integer.class);
276     public final int metaspaceArrayLengthOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_length&quot;, Integer.class, &quot;int&quot;);
277     public final int metaspaceArrayBaseOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_data[0]&quot;, Integer.class, &quot;Klass*&quot;);
278 
279     public final int arrayClassElementOffset = getFieldOffset(&quot;ObjArrayKlass::_element_klass&quot;, Integer.class, &quot;Klass*&quot;);
280 
281     public final int fieldInfoAccessFlagsOffset = getConstant(&quot;FieldInfo::access_flags_offset&quot;, Integer.class);
282     public final int fieldInfoNameIndexOffset = getConstant(&quot;FieldInfo::name_index_offset&quot;, Integer.class);
283     public final int fieldInfoSignatureIndexOffset = getConstant(&quot;FieldInfo::signature_index_offset&quot;, Integer.class);
284     public final int fieldInfoInitvalIndexOffset = getConstant(&quot;FieldInfo::initval_index_offset&quot;, Integer.class);
285     public final int fieldInfoLowPackedOffset = getConstant(&quot;FieldInfo::low_packed_offset&quot;, Integer.class);
286     public final int fieldInfoHighPackedOffset = getConstant(&quot;FieldInfo::high_packed_offset&quot;, Integer.class);
287     public final int fieldInfoFieldSlots = getConstant(&quot;FieldInfo::field_slots&quot;, Integer.class);
288 
289     public final int fieldInfoTagSize = getConstant(&quot;FIELDINFO_TAG_SIZE&quot;, Integer.class);
290 
291     public final int jvmAccMonitorMatch = getConstant(&quot;JVM_ACC_MONITOR_MATCH&quot;, Integer.class);
292     public final int jvmAccHasMonitorBytecodes = getConstant(&quot;JVM_ACC_HAS_MONITOR_BYTECODES&quot;, Integer.class);
293     public final int jvmAccHasFinalizer = getConstant(&quot;JVM_ACC_HAS_FINALIZER&quot;, Integer.class);
294     public final int jvmAccFieldInternal = getConstant(&quot;JVM_ACC_FIELD_INTERNAL&quot;, Integer.class);
295     public final int jvmAccFieldStable = getConstant(&quot;JVM_ACC_FIELD_STABLE&quot;, Integer.class);
296     public final int jvmAccFieldHasGenericSignature = getConstant(&quot;JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE&quot;, Integer.class);
297     public final int jvmAccWrittenFlags = getConstant(&quot;JVM_ACC_WRITTEN_FLAGS&quot;, Integer.class);
298     public final int jvmAccSynthetic = getConstant(&quot;JVM_ACC_SYNTHETIC&quot;, Integer.class);
299 
<span class="line-modified">300     public final int jvmciCompileStateCanPostOnExceptionsOffset = getJvmciJvmtiCapabilityOffset(&quot;_jvmti_can_post_on_exceptions&quot;);</span>
<span class="line-added">301     public final int jvmciCompileStateCanPopFrameOffset = getJvmciJvmtiCapabilityOffset(&quot;_jvmti_can_pop_frame&quot;);</span>
<span class="line-added">302     public final int jvmciCompileStateCanAccessLocalVariablesOffset = getJvmciJvmtiCapabilityOffset(&quot;_jvmti_can_access_local_variables&quot;);</span>
303 
304     // Integer.MIN_VALUE if not available
<span class="line-modified">305     private int getJvmciJvmtiCapabilityOffset(String name) {</span>
<span class="line-modified">306         int offset = getFieldOffset(&quot;JVMCICompileState::&quot; + name, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);</span>
307         if (offset == Integer.MIN_VALUE) {
308             // JDK 12
<span class="line-modified">309             offset = getFieldOffset(&quot;JVMCIEnv::&quot; + name, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);</span>
310         }
311         return offset;
312     }
313 
314     public final int threadTlabOffset = getFieldOffset(&quot;Thread::_tlab&quot;, Integer.class, &quot;ThreadLocalAllocBuffer&quot;);
315     public final int javaThreadAnchorOffset = getFieldOffset(&quot;JavaThread::_anchor&quot;, Integer.class, &quot;JavaFrameAnchor&quot;);
316     public final int javaThreadShouldPostOnExceptionsFlagOffset = getFieldOffset(&quot;JavaThread::_should_post_on_exceptions_flag&quot;, Integer.class, &quot;int&quot;, Integer.MIN_VALUE);
317     public final int threadObjectOffset = getFieldOffset(&quot;JavaThread::_threadObj&quot;, Integer.class, &quot;oop&quot;);
<span class="line-modified">318     public final int osThreadOffset = getFieldOffset(&quot;JavaThread::_osthread&quot;, Integer.class, &quot;OSThread*&quot;, Integer.MAX_VALUE);</span>
319     public final int threadIsMethodHandleReturnOffset = getFieldOffset(&quot;JavaThread::_is_method_handle_return&quot;, Integer.class, &quot;int&quot;);
320     public final int threadObjectResultOffset = getFieldOffset(&quot;JavaThread::_vm_result&quot;, Integer.class, &quot;oop&quot;);
321     public final int jvmciCountersThreadOffset = getFieldOffset(&quot;JavaThread::_jvmci_counters&quot;, Integer.class, &quot;jlong*&quot;);
<span class="line-added">322     public final int doingUnsafeAccessOffset = getFieldOffset(&quot;JavaThread::_doing_unsafe_access&quot;, Integer.class, &quot;bool&quot;, Integer.MAX_VALUE);</span>
323     public final int javaThreadReservedStackActivationOffset = versioned.javaThreadReservedStackActivationOffset;
<span class="line-added">324     public final int jniEnvironmentOffset = getFieldOffset(&quot;JavaThread::_jni_environment&quot;, Integer.class, &quot;JNIEnv&quot;, Integer.MIN_VALUE);</span>
325 
326     public boolean requiresReservedStackCheck(List&lt;ResolvedJavaMethod&gt; methods) {
327         if (enableStackReservedZoneAddress != 0 &amp;&amp; methods != null) {
328             for (ResolvedJavaMethod method : methods) {
329                 if (((HotSpotResolvedJavaMethod) method).hasReservedStackAccess()) {
330                     return true;
331                 }
332             }
333         }
334         return false;
335     }
336 
337     /**
338      * An invalid value for {@link #rtldDefault}.
339      */
340     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
341 
342     /**
343      * Address of the library lookup routine. The C signature of this routine is:
344      *
</pre>
<hr />
<pre>
402     }
403 
404     public int threadLastJavaPcOffset() {
405         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
406     }
407 
408     public int threadLastJavaFpOffset() {
409         assert osArch.equals(&quot;aarch64&quot;) || osArch.equals(&quot;amd64&quot;);
410         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_last_Java_fp&quot;, Integer.class, &quot;intptr_t*&quot;);
411     }
412 
413     public int threadJavaFrameAnchorFlagsOffset() {
414         assert osArch.equals(&quot;sparc&quot;);
415         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_flags&quot;, Integer.class, &quot;int&quot;);
416     }
417 
418     public final int runtimeCallStackSize = getConstant(&quot;frame::arg_reg_save_area_bytes&quot;, Integer.class, intRequiredOnAMD64);
419     public final int frameInterpreterFrameSenderSpOffset = getConstant(&quot;frame::interpreter_frame_sender_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
420     public final int frameInterpreterFrameLastSpOffset = getConstant(&quot;frame::interpreter_frame_last_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
421 
<span class="line-modified">422     public final int osThreadInterruptedOffset = getFieldOffset(&quot;OSThread::_interrupted&quot;, Integer.class, &quot;jint&quot;, Integer.MAX_VALUE);</span>
423 
<span class="line-modified">424     public final long markWordHashShift = getConstant(markWordField(&quot;hash_shift&quot;), Long.class);</span>
425 
<span class="line-modified">426     public final int biasedLockMaskInPlace = getConstant(markWordField(&quot;biased_lock_mask_in_place&quot;), Integer.class);</span>
<span class="line-modified">427     public final int ageMaskInPlace = getConstant(markWordField(&quot;age_mask_in_place&quot;), Integer.class);</span>
<span class="line-modified">428     public final int epochMaskInPlace = getConstant(markWordField(&quot;epoch_mask_in_place&quot;), Integer.class);</span>
<span class="line-modified">429     public final long markWordHashMask = getConstant(markWordField(&quot;hash_mask&quot;), Long.class);</span>
<span class="line-modified">430     public final long markWordHashMaskInPlace = getConstant(markWordField(&quot;hash_mask_in_place&quot;), Long.class);</span>
431 
<span class="line-modified">432     public final int unlockedMask = getConstant(markWordField(&quot;unlocked_value&quot;), Integer.class);</span>
<span class="line-modified">433     public final int monitorMask = getConstant(markWordField(&quot;monitor_value&quot;), Integer.class, -1);</span>
<span class="line-modified">434     public final int biasedLockPattern = getConstant(markWordField(&quot;biased_lock_pattern&quot;), Integer.class);</span>
435 
436     // This field has no type in vmStructs.cpp
437     public final int objectMonitorOwner = getFieldOffset(&quot;ObjectMonitor::_owner&quot;, Integer.class, null, -1);
438     public final int objectMonitorRecursions = getFieldOffset(&quot;ObjectMonitor::_recursions&quot;, Integer.class, &quot;intptr_t&quot;, -1);
439     public final int objectMonitorCxq = getFieldOffset(&quot;ObjectMonitor::_cxq&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);
440     public final int objectMonitorEntryList = getFieldOffset(&quot;ObjectMonitor::_EntryList&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);
<span class="line-added">441     public final int objectMonitorSucc = getFieldOffset(&quot;ObjectMonitor::_succ&quot;, Integer.class, &quot;Thread*&quot;, -1);</span>
442 
<span class="line-modified">443     public final int markWordNoHashInPlace = getConstant(markWordField(&quot;no_hash_in_place&quot;), Integer.class);</span>
<span class="line-modified">444     public final int markWordNoLockInPlace = getConstant(markWordField(&quot;no_lock_in_place&quot;), Integer.class);</span>
445 
446     /**
<span class="line-modified">447      * See {@code markOopDesc::prototype()}/{@code markWord::prototype()}.</span>
448      */
449     public long arrayPrototypeMarkWord() {
450         return markWordNoHashInPlace | markWordNoLockInPlace;
451     }
452 
453     /**
<span class="line-modified">454      * See {@code markOopDesc::copy_set_hash()}/{@code markWord::copy_set_hash()}.</span>
455      */
456     public long tlabIntArrayMarkWord() {
<span class="line-modified">457         long tmp = arrayPrototypeMarkWord() &amp; (~markWordHashMaskInPlace);</span>
<span class="line-modified">458         tmp |= ((0x2 &amp; markWordHashMask) &lt;&lt; markWordHashShift);</span>
459         return tmp;
460     }
461 
<span class="line-added">462     private String markWordField(String simpleName) {</span>
<span class="line-added">463         return versioned.markWordClassName + &quot;::&quot; + simpleName;</span>
<span class="line-added">464     }</span>
<span class="line-added">465 </span>
466     /**
467      * Mark word right shift to get identity hash code.
468      */
<span class="line-modified">469     public final int identityHashCodeShift = getConstant(markWordField(&quot;hash_shift&quot;), Integer.class);</span>
470 
471     /**
472      * Identity hash code value when uninitialized.
473      */
<span class="line-modified">474     public final int uninitializedIdentityHashCodeValue = getConstant(markWordField(&quot;no_hash&quot;), Integer.class);</span>
475 
476     public final int methodAccessFlagsOffset = getFieldOffset(&quot;Method::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
477     public final int methodConstMethodOffset = getFieldOffset(&quot;Method::_constMethod&quot;, Integer.class, &quot;ConstMethod*&quot;);
478     public final int methodIntrinsicIdOffset = versioned.methodIntrinsicIdOffset;
479     public final int methodFlagsOffset = versioned.methodFlagsOffset;
480     public final int methodVtableIndexOffset = getFieldOffset(&quot;Method::_vtable_index&quot;, Integer.class, &quot;int&quot;);
481 
482     public final int methodCountersOffset = getFieldOffset(&quot;Method::_method_counters&quot;, Integer.class, &quot;MethodCounters*&quot;);
483     public final int methodDataOffset = getFieldOffset(&quot;Method::_method_data&quot;, Integer.class, &quot;MethodData*&quot;);
484     public final int methodCompiledEntryOffset = getFieldOffset(&quot;Method::_from_compiled_entry&quot;, Integer.class, &quot;address&quot;);
485     public final int methodCodeOffset = versioned.methodCodeOffset;
486 
487     public final int methodFlagsCallerSensitive = getConstant(&quot;Method::_caller_sensitive&quot;, Integer.class);
488     public final int methodFlagsForceInline = getConstant(&quot;Method::_force_inline&quot;, Integer.class);
489     public final int methodFlagsDontInline = getConstant(&quot;Method::_dont_inline&quot;, Integer.class);
490     public final int methodFlagsHidden = getConstant(&quot;Method::_hidden&quot;, Integer.class);
491     public final int nonvirtualVtableIndex = getConstant(&quot;Method::nonvirtual_vtable_index&quot;, Integer.class);
492     public final int invalidVtableIndex = getConstant(&quot;Method::invalid_vtable_index&quot;, Integer.class);
493 
494     public final int invocationCounterOffset = getFieldOffset(&quot;MethodCounters::_invocation_counter&quot;, Integer.class, &quot;InvocationCounter&quot;);
</pre>
<hr />
<pre>
528      */
529     public final int maxOopMapStackOffset = getFieldValue(&quot;CompilerToVM::Data::_max_oop_map_stack_offset&quot;, Integer.class, &quot;int&quot;);
530 
531     public final long safepointPollingAddress = getFieldValue(&quot;os::_polling_page&quot;, Long.class, &quot;address&quot;);
532 
533     // G1 Collector Related Values.
534 
535     public final byte dirtyCardValue = versioned.dirtyCardValue;
536     public final byte g1YoungCardValue = versioned.g1YoungCardValue;
537 
538     public final int g1SATBQueueMarkingOffset = versioned.g1SATBQueueMarkingOffset;
539     public final int g1SATBQueueIndexOffset = versioned.g1SATBQueueIndexOffset;
540     public final int g1SATBQueueBufferOffset = versioned.g1SATBQueueBufferOffset;
541     public final int g1CardQueueIndexOffset = versioned.g1CardQueueIndexOffset;
542     public final int g1CardQueueBufferOffset = versioned.g1CardQueueBufferOffset;
543 
544     public final int klassOffset = getFieldValue(&quot;java_lang_Class::_klass_offset&quot;, Integer.class, &quot;int&quot;);
545     public final int arrayKlassOffset = getFieldValue(&quot;java_lang_Class::_array_klass_offset&quot;, Integer.class, &quot;int&quot;);
546 
547     public final int basicLockSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_BasicLock&quot;, Integer.class, &quot;int&quot;);
<span class="line-modified">548     public final int basicLockDisplacedHeaderOffset = getFieldOffset(&quot;BasicLock::_displaced_header&quot;, Integer.class, markWord);</span>
549 
550     public final int threadPollingPageOffset = getFieldOffset(&quot;Thread::_polling_page&quot;, Integer.class, &quot;address&quot;, -1);
551     public final int threadAllocatedBytesOffset = getFieldOffset(&quot;Thread::_allocated_bytes&quot;, Integer.class, &quot;jlong&quot;);
552 
553     public final int tlabRefillWasteIncrement = getFlag(&quot;TLABWasteIncrement&quot;, Integer.class);
554 
555     private final int threadLocalAllocBufferStartOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_start&quot;, Integer.class, &quot;HeapWord*&quot;);
556     private final int threadLocalAllocBufferEndOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_end&quot;, Integer.class, &quot;HeapWord*&quot;);
557     private final int threadLocalAllocBufferTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_top&quot;, Integer.class, &quot;HeapWord*&quot;);
558     private final int threadLocalAllocBufferPfTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_pf_top&quot;, Integer.class, &quot;HeapWord*&quot;);
559     private final int threadLocalAllocBufferSlowAllocationsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_slow_allocations&quot;, Integer.class, &quot;unsigned&quot;);
560     private final int threadLocalAllocBufferFastRefillWasteOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_fast_refill_waste&quot;, Integer.class, &quot;unsigned&quot;);
561     private final int threadLocalAllocBufferNumberOfRefillsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_number_of_refills&quot;, Integer.class, &quot;unsigned&quot;);
562     private final int threadLocalAllocBufferRefillWasteLimitOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_refill_waste_limit&quot;, Integer.class, &quot;size_t&quot;);
563     private final int threadLocalAllocBufferDesiredSizeOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_desired_size&quot;, Integer.class, &quot;size_t&quot;);
564 
565     public int tlabSlowAllocationsOffset() {
566         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
567     }
568 
</pre>
<hr />
<pre>
585     public int threadTlabStartOffset() {
586         return threadTlabOffset + threadLocalAllocBufferStartOffset;
587     }
588 
589     public int threadTlabEndOffset() {
590         return threadTlabOffset + threadLocalAllocBufferEndOffset;
591     }
592 
593     public int threadTlabTopOffset() {
594         return threadTlabOffset + threadLocalAllocBufferTopOffset;
595     }
596 
597     public int threadTlabPfTopOffset() {
598         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
599     }
600 
601     public final int tlabAlignmentReserve = getFieldValue(&quot;CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve&quot;, Integer.class, &quot;size_t&quot;);
602 
603     public final boolean tlabStats = getFlag(&quot;TLABStats&quot;, Boolean.class);
604 
<span class="line-added">605     // We set 0x10 as default value to disable DC ZVA if this field is not present in HotSpot.</span>
<span class="line-added">606     // ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:</span>
<span class="line-added">607     // * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.</span>
<span class="line-added">608     // * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.</span>
<span class="line-added">609     public final int psrInfoDczidValue = getFieldValue(&quot;VM_Version::_psr_info.dczid_el0&quot;, Integer.class, &quot;uint32_t&quot;, 0x10);</span>
<span class="line-added">610 </span>
611     // FIXME This is only temporary until the GC code is changed.
612     public final boolean inlineContiguousAllocationSupported = getFieldValue(&quot;CompilerToVM::Data::_supports_inline_contig_alloc&quot;, Boolean.class);
613     public final long heapEndAddress = getFieldValue(&quot;CompilerToVM::Data::_heap_end_addr&quot;, Long.class, &quot;HeapWord**&quot;);
614     public final long heapTopAddress = versioned.heapTopAddress;
615 
616     public final boolean cmsIncrementalMode = getFlag(&quot;CMSIncrementalMode&quot;, Boolean.class, false);
617 
618     public final long inlineCacheMissStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_ic_miss_stub&quot;, Long.class, &quot;address&quot;);
619     public final long handleWrongMethodStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub&quot;, Long.class, &quot;address&quot;);
620 
<span class="line-modified">621     public final long deoptBlobUnpack = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack&quot;, Long.class, &quot;address&quot;);</span>
<span class="line-modified">622     public final long deoptBlobUnpackWithExceptionInTLS = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack_with_exception_in_tls&quot;, Long.class, &quot;address&quot;, 0L);</span>
<span class="line-added">623     public final long deoptBlobUncommonTrap = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap&quot;, Long.class, &quot;address&quot;);</span>
624 
625     public final long codeCacheLowBound = versioned.codeCacheLowBound;
626     public final long codeCacheHighBound = versioned.codeCacheHighBound;
627 
628     public final long aescryptEncryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_encryptBlock&quot;, Long.class, &quot;address&quot;);
629     public final long aescryptDecryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_decryptBlock&quot;, Long.class, &quot;address&quot;);
630     public final long cipherBlockChainingEncryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_encryptAESCrypt&quot;, Long.class, &quot;address&quot;);
631     public final long cipherBlockChainingDecryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_decryptAESCrypt&quot;, Long.class, &quot;address&quot;);
632     public final long updateBytesCRC32Stub = getFieldValue(&quot;StubRoutines::_updateBytesCRC32&quot;, Long.class, &quot;address&quot;);
633     public final long crcTableAddress = getFieldValue(&quot;StubRoutines::_crc_table_adr&quot;, Long.class, &quot;address&quot;);
634 
635     public final long sha1ImplCompress = getFieldValue(&quot;StubRoutines::_sha1_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
636     public final long sha1ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha1_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
637     public final long sha256ImplCompress = getFieldValue(&quot;StubRoutines::_sha256_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
638     public final long sha256ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha256_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
639     public final long sha512ImplCompress = getFieldValue(&quot;StubRoutines::_sha512_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
640     public final long sha512ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha512_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
641     public final long multiplyToLen = getFieldValue(&quot;StubRoutines::_multiplyToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
642 
643     public final long counterModeAESCrypt = getFieldValue(&quot;StubRoutines::_counterMode_AESCrypt&quot;, Long.class, &quot;address&quot;, 0L);
644     public final long ghashProcessBlocks = getFieldValue(&quot;StubRoutines::_ghash_processBlocks&quot;, Long.class, &quot;address&quot;, 0L);
<span class="line-added">645     public final long base64EncodeBlock = getFieldValue(&quot;StubRoutines::_base64_encodeBlock&quot;, Long.class, &quot;address&quot;, 0L);</span>
646     public final long crc32cTableTddr = getFieldValue(&quot;StubRoutines::_crc32c_table_addr&quot;, Long.class, &quot;address&quot;, 0L);
647     public final long updateBytesCRC32C = getFieldValue(&quot;StubRoutines::_updateBytesCRC32C&quot;, Long.class, &quot;address&quot;, 0L);
648     public final long updateBytesAdler32 = getFieldValue(&quot;StubRoutines::_updateBytesAdler32&quot;, Long.class, &quot;address&quot;, 0L);
649     public final long squareToLen = getFieldValue(&quot;StubRoutines::_squareToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
650     public final long mulAdd = getFieldValue(&quot;StubRoutines::_mulAdd&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
651     public final long montgomeryMultiply = getFieldValue(&quot;StubRoutines::_montgomeryMultiply&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
652     public final long montgomerySquare = getFieldValue(&quot;StubRoutines::_montgomerySquare&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
653     public final long vectorizedMismatch = getFieldValue(&quot;StubRoutines::_vectorizedMismatch&quot;, Long.class, &quot;address&quot;, 0L);
654 
655     public final long throwDelayedStackOverflowErrorEntry = versioned.throwDelayedStackOverflowErrorEntry;
656 
657     public final long jbyteArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_arraycopy&quot;, Long.class, &quot;address&quot;);
658     public final long jshortArraycopy = getFieldValue(&quot;StubRoutines::_jshort_arraycopy&quot;, Long.class, &quot;address&quot;);
659     public final long jintArraycopy = getFieldValue(&quot;StubRoutines::_jint_arraycopy&quot;, Long.class, &quot;address&quot;);
660     public final long jlongArraycopy = getFieldValue(&quot;StubRoutines::_jlong_arraycopy&quot;, Long.class, &quot;address&quot;);
661     public final long oopArraycopy = getFieldValue(&quot;StubRoutines::_oop_arraycopy&quot;, Long.class, &quot;address&quot;);
662     public final long oopArraycopyUninit = getFieldValue(&quot;StubRoutines::_oop_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
663     public final long jbyteDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
664     public final long jshortDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jshort_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
665     public final long jintDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jint_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
</pre>
<hr />
<pre>
698     public boolean areNullAllocationStubsAvailable() {
699         return newInstanceOrNullAddress != 0L;
700     }
701 
702     /**
703      * Checks that HotSpot implements all or none of the allocate-or-null stubs.
704      */
705     private boolean checkNullAllocationStubs() {
706         if (newInstanceOrNullAddress == 0L) {
707             assert newArrayOrNullAddress == 0L;
708             assert newMultiArrayOrNullAddress == 0L;
709             assert dynamicNewInstanceOrNullAddress == 0L;
710         } else {
711             assert newArrayOrNullAddress != 0L;
712             assert newMultiArrayOrNullAddress != 0L;
713             assert dynamicNewInstanceOrNullAddress != 0L;
714         }
715         return true;
716     }
717 

718     public final long vmMessageAddress = getAddress(&quot;JVMCIRuntime::vm_message&quot;);
719     public final long identityHashCodeAddress = getAddress(&quot;JVMCIRuntime::identity_hash_code&quot;);
720     public final long exceptionHandlerForPcAddress = getAddress(&quot;JVMCIRuntime::exception_handler_for_pc&quot;);
721     public final long monitorenterAddress = getAddress(&quot;JVMCIRuntime::monitorenter&quot;);
722     public final long monitorexitAddress = getAddress(&quot;JVMCIRuntime::monitorexit&quot;);
723     public final long notifyAddress = getAddress(&quot;JVMCIRuntime::object_notify&quot;, 0L);
724     public final long notifyAllAddress = getAddress(&quot;JVMCIRuntime::object_notifyAll&quot;, 0L);
725     public final long throwAndPostJvmtiExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_and_post_jvmti_exception&quot;);
726     public final long throwKlassExternalNameExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_klass_external_name_exception&quot;);
727     public final long throwClassCastExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_class_cast_exception&quot;);
728     public final long logPrimitiveAddress = getAddress(&quot;JVMCIRuntime::log_primitive&quot;);
729     public final long logObjectAddress = getAddress(&quot;JVMCIRuntime::log_object&quot;);
730     public final long logPrintfAddress = getAddress(&quot;JVMCIRuntime::log_printf&quot;);
731     public final long vmErrorAddress = getAddress(&quot;JVMCIRuntime::vm_error&quot;);
732     public final long loadAndClearExceptionAddress = getAddress(&quot;JVMCIRuntime::load_and_clear_exception&quot;);
733     public final long writeBarrierPreAddress = getAddress(&quot;JVMCIRuntime::write_barrier_pre&quot;);
734     public final long writeBarrierPostAddress = getAddress(&quot;JVMCIRuntime::write_barrier_post&quot;);
735     public final long validateObject = getAddress(&quot;JVMCIRuntime::validate_object&quot;);
736 
737     public final long testDeoptimizeCallInt = getAddress(&quot;JVMCIRuntime::test_deoptimize_call_int&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="CompilerConfigurationFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraalHotSpotVMConfigBase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationWatchDog.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationWatchDog.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationWatchDog.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationWatchDog.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -26,17 +26,19 @@
 
 import static org.graalvm.compiler.hotspot.HotSpotGraalCompiler.fmt;
 
 import java.util.Arrays;
 
+import org.graalvm.compiler.core.GraalServiceThread;
 import org.graalvm.compiler.debug.TTY;
 import org.graalvm.compiler.options.Option;
 import org.graalvm.compiler.options.OptionKey;
 import org.graalvm.compiler.options.OptionType;
 import org.graalvm.compiler.options.OptionValues;
 
 import jdk.vm.ci.meta.ResolvedJavaMethod;
+import jdk.vm.ci.services.Services;
 
 /**
  * A watch dog for reporting long running compilations. This is designed to be an always on
  * mechanism for the purpose of getting better reports from customer sites. As such, it only exits
  * the VM when it is very sure about a stuck compilation as opposed to only observing a long running
@@ -46,14 +48,14 @@
  * {@value #SPIN_TIMEOUT_MS} milliseconds to observe the state of the compiler thread. After the
  * first {@link Options#CompilationWatchDogStartDelay} seconds of a specific compilation, the watch
  * dog reports a long running compilation. Every
  * {@link Options#CompilationWatchDogStackTraceInterval} seconds after that point in time where the
  * same compilation is still executing, the watch dog takes a stack trace of the compiler thread. If
- * more than {@value Options#NonFatalIdenticalCompilationSnapshots} contiguous identical stack
- * traces are seen, the watch dog reports a stuck compilation and exits the VM.
+ * more than {@link Options#NonFatalIdenticalCompilationSnapshots} contiguous identical stack traces
+ * are seen, the watch dog reports a stuck compilation and exits the VM.
  */
-class CompilationWatchDog extends Thread implements AutoCloseable {
+class CompilationWatchDog implements Runnable, AutoCloseable {
 
     public static class Options {
         // @formatter:off
         @Option(help = "Delay in seconds before watch dog monitoring a compilation (0 disables monitoring).", type = OptionType.Debug)
         public static final OptionKey<Double> CompilationWatchDogStartDelay = new OptionKey<>(0.0D);
@@ -109,13 +111,10 @@
     private int numberOfIdenticalStackTraces;
     private StackTraceElement[] lastStackTrace;
 
     CompilationWatchDog(Thread compilerThread, long startDelayMilliseconds, long stackTraceIntervalMilliseconds, int nonFatalIdenticalCompilationSnapshots) {
         this.compilerThread = compilerThread;
-        this.setName("WatchDog" + getId() + "[" + compilerThread.getName() + "]");
-        this.setPriority(Thread.MAX_PRIORITY);
-        this.setDaemon(true);
         this.startDelayMilliseconds = startDelayMilliseconds;
         this.stackTraceIntervalMilliseconds = stackTraceIntervalMilliseconds;
         this.nonFatalIdenticalCompilationSnapshots = nonFatalIdenticalCompilationSnapshots;
     }
 
@@ -164,11 +163,11 @@
     }
 
     /**
      * Set to true to debug the watch dog.
      */
-    private static final boolean DEBUG = Boolean.getBoolean("debug.graal.CompilationWatchDog");
+    private static final boolean DEBUG = Boolean.parseBoolean(Services.getSavedProperties().get("debug.graal.CompilationWatchDog"));
 
     private void trace(String format, Object... args) {
         if (DEBUG) {
             TTY.println(this + ": " + String.format(format, args));
         }
@@ -182,11 +181,11 @@
         return (double) ms / 1000;
     }
 
     @Override
     public String toString() {
-        return getName();
+        return "WatchDog[" + compilerThread.getName() + "]";
     }
 
     @Override
     public void run() {
         try {
@@ -237,11 +236,11 @@
                                     if (numberOfIdenticalStackTraces > nonFatalIdenticalCompilationSnapshots) {
                                         synchronized (CompilationWatchDog.class) {
                                             TTY.printf("======================= WATCH DOG THREAD =======================%n" +
                                                             "%s took %d identical stack traces, which indicates a stuck compilation (id=%d) of %s%n%sExiting VM%n", this,
                                                             numberOfIdenticalStackTraces, currentId, fmt(currentMethod), fmt(lastStackTrace));
-                                            System.exit(-1);
+                                            HotSpotGraalServices.exit(-1);
                                         }
                                     } else if (newStackTrace) {
                                         synchronized (CompilationWatchDog.class) {
                                             TTY.printf("======================= WATCH DOG THREAD =======================%n" +
                                                             "%s detected long running compilation (id=%d) of %s [%.2f seconds]%n%s", this, currentId, fmt(currentMethod),
@@ -302,16 +301,20 @@
         long startDelayMilliseconds = ms(Options.CompilationWatchDogStartDelay.getValue(options));
         if (startDelayMilliseconds > 0.0D) {
             // Lazily get a watch dog thread for the current compiler thread
             CompilationWatchDog watchDog = WATCH_DOGS.get();
             if (watchDog == null) {
-                Thread currentThread = currentThread();
+                Thread currentThread = Thread.currentThread();
                 long stackTraceIntervalMilliseconds = ms(Options.CompilationWatchDogStackTraceInterval.getValue(options));
                 int nonFatalIdenticalCompilationSnapshots = Options.NonFatalIdenticalCompilationSnapshots.getValue(options);
                 watchDog = new CompilationWatchDog(currentThread, startDelayMilliseconds, stackTraceIntervalMilliseconds, nonFatalIdenticalCompilationSnapshots);
                 WATCH_DOGS.set(watchDog);
-                watchDog.start();
+                GraalServiceThread thread = new GraalServiceThread(watchDog);
+                thread.setName(thread.getId() + " " + watchDog.toString());
+                thread.setPriority(Thread.MAX_PRIORITY);
+                thread.setDaemon(true);
+                thread.start();
             }
             watchDog.startCompilation(method, id);
             return watchDog;
         }
         return null;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationWatchDog.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilationTask.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilerConfigurationFactory.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationWatchDog.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,17 ***</span>
<span class="line-new-header">--- 26,19 ---</span>
  
  import static org.graalvm.compiler.hotspot.HotSpotGraalCompiler.fmt;
  
  import java.util.Arrays;
  
<span class="line-added">+ import org.graalvm.compiler.core.GraalServiceThread;</span>
  import org.graalvm.compiler.debug.TTY;
  import org.graalvm.compiler.options.Option;
  import org.graalvm.compiler.options.OptionKey;
  import org.graalvm.compiler.options.OptionType;
  import org.graalvm.compiler.options.OptionValues;
  
  import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-added">+ import jdk.vm.ci.services.Services;</span>
  
  /**
   * A watch dog for reporting long running compilations. This is designed to be an always on
   * mechanism for the purpose of getting better reports from customer sites. As such, it only exits
   * the VM when it is very sure about a stuck compilation as opposed to only observing a long running
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,14 ***</span>
   * {@value #SPIN_TIMEOUT_MS} milliseconds to observe the state of the compiler thread. After the
   * first {@link Options#CompilationWatchDogStartDelay} seconds of a specific compilation, the watch
   * dog reports a long running compilation. Every
   * {@link Options#CompilationWatchDogStackTraceInterval} seconds after that point in time where the
   * same compilation is still executing, the watch dog takes a stack trace of the compiler thread. If
<span class="line-modified">!  * more than {@value Options#NonFatalIdenticalCompilationSnapshots} contiguous identical stack</span>
<span class="line-modified">!  * traces are seen, the watch dog reports a stuck compilation and exits the VM.</span>
   */
<span class="line-modified">! class CompilationWatchDog extends Thread implements AutoCloseable {</span>
  
      public static class Options {
          // @formatter:off
          @Option(help = &quot;Delay in seconds before watch dog monitoring a compilation (0 disables monitoring).&quot;, type = OptionType.Debug)
          public static final OptionKey&lt;Double&gt; CompilationWatchDogStartDelay = new OptionKey&lt;&gt;(0.0D);
<span class="line-new-header">--- 48,14 ---</span>
   * {@value #SPIN_TIMEOUT_MS} milliseconds to observe the state of the compiler thread. After the
   * first {@link Options#CompilationWatchDogStartDelay} seconds of a specific compilation, the watch
   * dog reports a long running compilation. Every
   * {@link Options#CompilationWatchDogStackTraceInterval} seconds after that point in time where the
   * same compilation is still executing, the watch dog takes a stack trace of the compiler thread. If
<span class="line-modified">!  * more than {@link Options#NonFatalIdenticalCompilationSnapshots} contiguous identical stack traces</span>
<span class="line-modified">!  * are seen, the watch dog reports a stuck compilation and exits the VM.</span>
   */
<span class="line-modified">! class CompilationWatchDog implements Runnable, AutoCloseable {</span>
  
      public static class Options {
          // @formatter:off
          @Option(help = &quot;Delay in seconds before watch dog monitoring a compilation (0 disables monitoring).&quot;, type = OptionType.Debug)
          public static final OptionKey&lt;Double&gt; CompilationWatchDogStartDelay = new OptionKey&lt;&gt;(0.0D);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,13 ***</span>
      private int numberOfIdenticalStackTraces;
      private StackTraceElement[] lastStackTrace;
  
      CompilationWatchDog(Thread compilerThread, long startDelayMilliseconds, long stackTraceIntervalMilliseconds, int nonFatalIdenticalCompilationSnapshots) {
          this.compilerThread = compilerThread;
<span class="line-removed">-         this.setName(&quot;WatchDog&quot; + getId() + &quot;[&quot; + compilerThread.getName() + &quot;]&quot;);</span>
<span class="line-removed">-         this.setPriority(Thread.MAX_PRIORITY);</span>
<span class="line-removed">-         this.setDaemon(true);</span>
          this.startDelayMilliseconds = startDelayMilliseconds;
          this.stackTraceIntervalMilliseconds = stackTraceIntervalMilliseconds;
          this.nonFatalIdenticalCompilationSnapshots = nonFatalIdenticalCompilationSnapshots;
      }
  
<span class="line-new-header">--- 111,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,11 ***</span>
      }
  
      /**
       * Set to true to debug the watch dog.
       */
<span class="line-modified">!     private static final boolean DEBUG = Boolean.getBoolean(&quot;debug.graal.CompilationWatchDog&quot;);</span>
  
      private void trace(String format, Object... args) {
          if (DEBUG) {
              TTY.println(this + &quot;: &quot; + String.format(format, args));
          }
<span class="line-new-header">--- 163,11 ---</span>
      }
  
      /**
       * Set to true to debug the watch dog.
       */
<span class="line-modified">!     private static final boolean DEBUG = Boolean.parseBoolean(Services.getSavedProperties().get(&quot;debug.graal.CompilationWatchDog&quot;));</span>
  
      private void trace(String format, Object... args) {
          if (DEBUG) {
              TTY.println(this + &quot;: &quot; + String.format(format, args));
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,11 ***</span>
          return (double) ms / 1000;
      }
  
      @Override
      public String toString() {
<span class="line-modified">!         return getName();</span>
      }
  
      @Override
      public void run() {
          try {
<span class="line-new-header">--- 181,11 ---</span>
          return (double) ms / 1000;
      }
  
      @Override
      public String toString() {
<span class="line-modified">!         return &quot;WatchDog[&quot; + compilerThread.getName() + &quot;]&quot;;</span>
      }
  
      @Override
      public void run() {
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,11 ***</span>
                                      if (numberOfIdenticalStackTraces &gt; nonFatalIdenticalCompilationSnapshots) {
                                          synchronized (CompilationWatchDog.class) {
                                              TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
                                                              &quot;%s took %d identical stack traces, which indicates a stuck compilation (id=%d) of %s%n%sExiting VM%n&quot;, this,
                                                              numberOfIdenticalStackTraces, currentId, fmt(currentMethod), fmt(lastStackTrace));
<span class="line-modified">!                                             System.exit(-1);</span>
                                          }
                                      } else if (newStackTrace) {
                                          synchronized (CompilationWatchDog.class) {
                                              TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
                                                              &quot;%s detected long running compilation (id=%d) of %s [%.2f seconds]%n%s&quot;, this, currentId, fmt(currentMethod),
<span class="line-new-header">--- 236,11 ---</span>
                                      if (numberOfIdenticalStackTraces &gt; nonFatalIdenticalCompilationSnapshots) {
                                          synchronized (CompilationWatchDog.class) {
                                              TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
                                                              &quot;%s took %d identical stack traces, which indicates a stuck compilation (id=%d) of %s%n%sExiting VM%n&quot;, this,
                                                              numberOfIdenticalStackTraces, currentId, fmt(currentMethod), fmt(lastStackTrace));
<span class="line-modified">!                                             HotSpotGraalServices.exit(-1);</span>
                                          }
                                      } else if (newStackTrace) {
                                          synchronized (CompilationWatchDog.class) {
                                              TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
                                                              &quot;%s detected long running compilation (id=%d) of %s [%.2f seconds]%n%s&quot;, this, currentId, fmt(currentMethod),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,16 ***</span>
          long startDelayMilliseconds = ms(Options.CompilationWatchDogStartDelay.getValue(options));
          if (startDelayMilliseconds &gt; 0.0D) {
              // Lazily get a watch dog thread for the current compiler thread
              CompilationWatchDog watchDog = WATCH_DOGS.get();
              if (watchDog == null) {
<span class="line-modified">!                 Thread currentThread = currentThread();</span>
                  long stackTraceIntervalMilliseconds = ms(Options.CompilationWatchDogStackTraceInterval.getValue(options));
                  int nonFatalIdenticalCompilationSnapshots = Options.NonFatalIdenticalCompilationSnapshots.getValue(options);
                  watchDog = new CompilationWatchDog(currentThread, startDelayMilliseconds, stackTraceIntervalMilliseconds, nonFatalIdenticalCompilationSnapshots);
                  WATCH_DOGS.set(watchDog);
<span class="line-modified">!                 watchDog.start();</span>
              }
              watchDog.startCompilation(method, id);
              return watchDog;
          }
          return null;
<span class="line-new-header">--- 301,20 ---</span>
          long startDelayMilliseconds = ms(Options.CompilationWatchDogStartDelay.getValue(options));
          if (startDelayMilliseconds &gt; 0.0D) {
              // Lazily get a watch dog thread for the current compiler thread
              CompilationWatchDog watchDog = WATCH_DOGS.get();
              if (watchDog == null) {
<span class="line-modified">!                 Thread currentThread = Thread.currentThread();</span>
                  long stackTraceIntervalMilliseconds = ms(Options.CompilationWatchDogStackTraceInterval.getValue(options));
                  int nonFatalIdenticalCompilationSnapshots = Options.NonFatalIdenticalCompilationSnapshots.getValue(options);
                  watchDog = new CompilationWatchDog(currentThread, startDelayMilliseconds, stackTraceIntervalMilliseconds, nonFatalIdenticalCompilationSnapshots);
                  WATCH_DOGS.set(watchDog);
<span class="line-modified">!                 GraalServiceThread thread = new GraalServiceThread(watchDog);</span>
<span class="line-added">+                 thread.setName(thread.getId() + &quot; &quot; + watchDog.toString());</span>
<span class="line-added">+                 thread.setPriority(Thread.MAX_PRIORITY);</span>
<span class="line-added">+                 thread.setDaemon(true);</span>
<span class="line-added">+                 thread.start();</span>
              }
              watchDog.startCompilation(method, id);
              return watchDog;
          }
          return null;
</pre>
<center><a href="CompilationTask.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilerConfigurationFactory.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationStatistics.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import java.io.FileNotFoundException;
 28 import java.io.FileOutputStream;
 29 import java.io.PrintStream;
 30 import java.lang.annotation.ElementType;
 31 import java.lang.annotation.Retention;
 32 import java.lang.annotation.RetentionPolicy;
 33 import java.lang.annotation.Target;
 34 import java.lang.reflect.Field;
 35 import java.lang.reflect.Modifier;
 36 import java.util.ArrayDeque;
 37 import java.util.ArrayList;
 38 import java.util.Date;
 39 import java.util.Deque;
 40 import java.util.Locale;
 41 import java.util.concurrent.ConcurrentLinkedDeque;
 42 
 43 import org.graalvm.compiler.debug.CSVUtil;
 44 import org.graalvm.compiler.options.Option;
 45 import org.graalvm.compiler.options.OptionKey;
 46 import org.graalvm.compiler.options.OptionValues;
 47 import org.graalvm.compiler.serviceprovider.GraalServices;
 48 
 49 import jdk.vm.ci.hotspot.HotSpotInstalledCode;
 50 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
<a name="2" id="anc2"></a><span class="line-added"> 51 import jdk.vm.ci.services.Services;</span>
 52 
 53 @SuppressWarnings(&quot;unused&quot;)
 54 public final class CompilationStatistics {
 55 
 56     public static class Options {
 57         // @formatter:off
 58         @Option(help = &quot;Enables CompilationStatistics.&quot;)
 59         public static final OptionKey&lt;Boolean&gt; UseCompilationStatistics = new OptionKey&lt;&gt;(false);
 60         // @formatter:on
 61     }
 62 
 63     private static final long RESOLUTION = 100000000;
 64 
 65     private static final CompilationStatistics DUMMY = new CompilationStatistics(null, false);
 66 
 67     private static ConcurrentLinkedDeque&lt;CompilationStatistics&gt; list = new ConcurrentLinkedDeque&lt;&gt;();
 68 
 69     private static final ThreadLocal&lt;Deque&lt;CompilationStatistics&gt;&gt; current = new ThreadLocal&lt;Deque&lt;CompilationStatistics&gt;&gt;() {
 70 
 71         @Override
 72         protected Deque&lt;CompilationStatistics&gt; initialValue() {
 73             return new ArrayDeque&lt;&gt;();
 74         }
 75     };
 76 
 77     @Retention(RetentionPolicy.RUNTIME)
 78     @Target(ElementType.FIELD)
 79     private static @interface NotReported {
 80     }
 81 
 82     @Retention(RetentionPolicy.RUNTIME)
 83     @Target(ElementType.FIELD)
 84     private static @interface TimeValue {
 85     }
 86 
 87     private static long zeroTime = System.nanoTime();
 88 
 89     private static long getThreadAllocatedBytes() {
 90         return GraalServices.getCurrentThreadAllocatedBytes();
 91     }
 92 
 93     @NotReported private final long startTime;
 94     @NotReported private long threadAllocatedBytesStart;
 95 
 96     private int bytecodeCount;
 97     private int codeSize;
 98     @TimeValue private long duration;
 99     private long memoryUsed;
100     private final boolean osr;
101     private final String holder;
102     private final String name;
103     private final String signature;
104 
105     private CompilationStatistics(HotSpotResolvedJavaMethod method, boolean osr) {
106         this.osr = osr;
107         if (method != null) {
108             holder = method.getDeclaringClass().getName();
109             name = method.getName();
110             signature = method.getSignature().toMethodDescriptor();
111             startTime = System.nanoTime();
112             bytecodeCount = method.getCodeSize();
113             threadAllocatedBytesStart = getThreadAllocatedBytes();
114         } else {
115             assert DUMMY == null : &quot;only DUMMY has no method&quot;;
116             holder = &quot;&quot;;
117             name = &quot;&quot;;
118             signature = &quot;&quot;;
119             startTime = 0;
120         }
121     }
122 
123     public void finish(HotSpotResolvedJavaMethod method, HotSpotInstalledCode code) {
124         if (isEnabled()) {
125             duration = System.nanoTime() - startTime;
126             codeSize = (int) code.getCodeSize();
127             memoryUsed = getThreadAllocatedBytes() - threadAllocatedBytesStart;
128             if (current.get().getLast() != this) {
129                 throw new RuntimeException(&quot;mismatch in finish()&quot;);
130             }
131             current.get().removeLast();
132         }
133     }
134 
135     public static CompilationStatistics current() {
136         return current.get().isEmpty() ? null : current.get().getLast();
137     }
138 
139     public static CompilationStatistics create(OptionValues options, HotSpotResolvedJavaMethod method, boolean isOSR) {
140         if (Options.UseCompilationStatistics.getValue(options)) {
141             CompilationStatistics stats = new CompilationStatistics(method, isOSR);
142             list.add(stats);
143             current.get().addLast(stats);
144             return stats;
145         } else {
146             return DUMMY;
147         }
148     }
149 
150     public boolean isEnabled() {
151         return this != DUMMY;
152     }
153 
154     @SuppressWarnings(&quot;deprecation&quot;)
155     public static void clear(String dumpName) {
156         try {
157             ConcurrentLinkedDeque&lt;CompilationStatistics&gt; snapshot = list;
158             long snapshotZeroTime = zeroTime;
159 
160             list = new ConcurrentLinkedDeque&lt;&gt;();
161             zeroTime = System.nanoTime();
162 
163             Date now = new Date();
164             String dateString = (now.getYear() + 1900) + &quot;-&quot; + (now.getMonth() + 1) + &quot;-&quot; + now.getDate() + &quot;-&quot; + now.getHours() + &quot;&quot; + now.getMinutes();
165 
166             dumpCompilations(snapshot, dumpName, dateString);
167 
168             try (FileOutputStream fos = new FileOutputStream(&quot;timeline_&quot; + dateString + &quot;_&quot; + dumpName + &quot;.csv&quot;, true); PrintStream out = new PrintStream(fos)) {
169 
170                 long[] timeSpent = new long[10000];
171                 int maxTick = 0;
172                 for (CompilationStatistics stats : snapshot) {
173                     long start = stats.startTime - snapshotZeroTime;
174                     long duration = stats.duration;
175                     if (start &lt; 0) {
176                         duration -= -start;
177                         start = 0;
178                     }
179 
180                     int tick = (int) (start / RESOLUTION);
181                     long timeLeft = RESOLUTION - (start % RESOLUTION);
182 
183                     while (tick &lt; timeSpent.length &amp;&amp; duration &gt; 0) {
184                         if (tick &gt; maxTick) {
185                             maxTick = tick;
186                         }
187                         timeSpent[tick] += Math.min(timeLeft, duration);
188                         duration -= timeLeft;
189                         tick++;
190                         timeLeft = RESOLUTION;
191                     }
192                 }
<a name="3" id="anc3"></a><span class="line-modified">193                 String timelineName = Services.getSavedProperties().get(&quot;stats.timeline.name&quot;);</span>
194                 if (timelineName != null &amp;&amp; !timelineName.isEmpty()) {
195                     out.printf(&quot;%s%c&quot;, CSVUtil.Escape.escape(timelineName), CSVUtil.SEPARATOR);
196                 }
197                 for (int i = 0; i &lt; maxTick; i++) {
198                     out.printf(&quot;%d%c&quot;, normalize(timeSpent[i]), CSVUtil.SEPARATOR);
199                 }
200                 // print last column
201                 out.printf(&quot;%d&quot;, normalize(timeSpent[maxTick]));
202                 out.println();
203             }
204         } catch (Exception e) {
205             throw new RuntimeException(e);
206         }
207     }
208 
209     private static long normalize(long time) {
210         return time * 100 / RESOLUTION;
211     }
212 
213     protected static void dumpCompilations(ConcurrentLinkedDeque&lt;CompilationStatistics&gt; snapshot, String dumpName, String dateString) throws IllegalAccessException, FileNotFoundException {
214         String fileName = &quot;compilations_&quot; + dateString + &quot;_&quot; + dumpName + &quot;.csv&quot;;
215         char separator = &#39;\t&#39;;
216         try (PrintStream out = new PrintStream(fileName)) {
217             // output the list of all compilations
218 
219             Field[] declaredFields = CompilationStatistics.class.getDeclaredFields();
220             ArrayList&lt;Field&gt; fields = new ArrayList&lt;&gt;();
221             for (Field field : declaredFields) {
222                 if (!Modifier.isStatic(field.getModifiers()) &amp;&amp; !field.isAnnotationPresent(NotReported.class)) {
223                     fields.add(field);
224                 }
225             }
226             String format = CSVUtil.buildFormatString(&quot;%s&quot;, separator, fields.size());
227             CSVUtil.Escape.println(out, separator, CSVUtil.QUOTE, CSVUtil.ESCAPE, format, fields.toArray());
228             for (CompilationStatistics stats : snapshot) {
229                 Object[] values = new Object[fields.size()];
230                 for (int i = 0; i &lt; fields.size(); i++) {
231                     Field field = fields.get(i);
232                     if (field.isAnnotationPresent(TimeValue.class)) {
233                         double value = field.getLong(stats) / 1000000d;
234                         values[i] = String.format(Locale.ENGLISH, &quot;%.3f&quot;, value);
235                     } else {
236                         values[i] = field.get(stats);
237                     }
238                 }
239                 CSVUtil.Escape.println(out, separator, CSVUtil.QUOTE, CSVUtil.ESCAPE, format, values);
240             }
241         }
242     }
243 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/Stub.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SnippetStub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StubUtil.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/Stub.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.stubs;
 26 
 27 import static java.util.Collections.singletonList;
 28 import static org.graalvm.compiler.core.GraalCompiler.emitFrontEnd;
 29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;

 30 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
 31 import static org.graalvm.compiler.debug.DebugOptions.DebugStubsAndSnippets;
<span class="line-modified"> 32 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.UNCOMMON_TRAP_HANDLER;</span>
 33 import static org.graalvm.util.CollectionsUtil.allMatch;
 34 
 35 import java.util.ListIterator;
 36 import java.util.concurrent.atomic.AtomicInteger;
 37 
 38 import jdk.internal.vm.compiler.collections.EconomicSet;
 39 import org.graalvm.compiler.code.CompilationResult;
 40 import org.graalvm.compiler.core.common.CompilationIdentifier;
 41 import org.graalvm.compiler.core.common.GraalOptions;
 42 import org.graalvm.compiler.core.target.Backend;
 43 import org.graalvm.compiler.debug.DebugContext;
 44 import org.graalvm.compiler.debug.DebugContext.Description;
 45 import org.graalvm.compiler.hotspot.HotSpotCompiledCodeBuilder;
 46 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 47 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 48 import org.graalvm.compiler.hotspot.nodes.StubStartNode;
 49 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 50 import org.graalvm.compiler.lir.phases.LIRPhase;
 51 import org.graalvm.compiler.lir.phases.LIRSuites;
 52 import org.graalvm.compiler.lir.phases.PostAllocationOptimizationPhase.PostAllocationOptimizationContext;
</pre>
<hr />
<pre>
 59 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 60 
 61 import jdk.vm.ci.code.CodeCacheProvider;
 62 import jdk.vm.ci.code.InstalledCode;
 63 import jdk.vm.ci.code.Register;
 64 import jdk.vm.ci.code.RegisterConfig;
 65 import jdk.vm.ci.code.site.Call;
 66 import jdk.vm.ci.code.site.ConstantReference;
 67 import jdk.vm.ci.code.site.DataPatch;
 68 import jdk.vm.ci.code.site.Infopoint;
 69 import jdk.vm.ci.hotspot.HotSpotCompiledCode;
 70 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 71 import jdk.vm.ci.meta.DefaultProfilingInfo;
 72 import jdk.vm.ci.meta.ResolvedJavaMethod;
 73 import jdk.vm.ci.meta.TriState;
 74 
 75 //JaCoCo Exclude
 76 
 77 /**
 78  * Base class for implementing some low level code providing the out-of-line slow path for a snippet
<span class="line-modified"> 79  * and/or a callee saved call to a HotSpot C/C++ runtime function or even a another compiled Java</span>
 80  * method.
 81  */
 82 public abstract class Stub {
 83 
 84     /**
 85      * The linkage information for a call to this stub from compiled code.
 86      */
 87     protected final HotSpotForeignCallLinkage linkage;
 88 
 89     /**
 90      * The code installed for the stub.
 91      */
 92     protected InstalledCode code;
 93 
 94     /**
 95      * The registers destroyed by this stub (from the caller&#39;s perspective).
 96      */
 97     private EconomicSet&lt;Register&gt; destroyedCallerRegisters;
 98 
 99     private static boolean checkRegisterSetEquivalency(EconomicSet&lt;Register&gt; a, EconomicSet&lt;Register&gt; b) {
</pre>
<hr />
<pre>
104             return false;
105         }
106         return allMatch(a, e -&gt; b.contains(e));
107     }
108 
109     public void initDestroyedCallerRegisters(EconomicSet&lt;Register&gt; registers) {
110         assert registers != null;
111         assert destroyedCallerRegisters == null || checkRegisterSetEquivalency(registers, destroyedCallerRegisters) : &quot;cannot redefine&quot;;
112         destroyedCallerRegisters = registers;
113     }
114 
115     /**
116      * Gets the registers destroyed by this stub from a caller&#39;s perspective. These are the
117      * temporaries of this stub and must thus be caller saved by a callers of this stub.
118      */
119     public EconomicSet&lt;Register&gt; getDestroyedCallerRegisters() {
120         assert destroyedCallerRegisters != null : &quot;not yet initialized&quot;;
121         return destroyedCallerRegisters;
122     }
123 
<span class="line-modified">124     /**</span>
<span class="line-modified">125      * Determines if this stub preserves all registers apart from those it</span>
<span class="line-removed">126      * {@linkplain #getDestroyedCallerRegisters() destroys}.</span>
<span class="line-removed">127      */</span>
<span class="line-removed">128     public boolean preservesRegisters() {</span>
<span class="line-removed">129         return true;</span>
130     }
131 
132     protected final OptionValues options;
133     protected final HotSpotProviders providers;
134 
135     /**
136      * Creates a new stub.
137      *
138      * @param linkage linkage details for a call to the stub
139      */
140     public Stub(OptionValues options, HotSpotProviders providers, HotSpotForeignCallLinkage linkage) {
141         this.linkage = linkage;
<span class="line-modified">142         this.options = new OptionValues(options, GraalOptions.TraceInlining, GraalOptions.TraceInliningForStubsAndSnippets.getValue(options));</span>


143         this.providers = providers;
144     }
145 
146     /**
147      * Gets the linkage for a call to this stub from compiled code.
148      */
149     public HotSpotForeignCallLinkage getLinkage() {
150         return linkage;
151     }
152 
153     public RegisterConfig getRegisterConfig() {
154         return null;
155     }
156 
157     /**
158      * Gets the graph that from which the code for this stub will be compiled.
159      *
160      * @param compilationId unique compilation id for the stub
161      */
162     protected abstract StructuredGraph getGraph(DebugContext debug, CompilationIdentifier compilationId);
</pre>
<hr />
<pre>
166         return &quot;Stub&lt;&quot; + linkage.getDescriptor() + &quot;&gt;&quot;;
167     }
168 
169     /**
170      * Gets the method the stub&#39;s code will be associated with once installed. This may be null.
171      */
172     protected abstract ResolvedJavaMethod getInstalledCodeOwner();
173 
174     /**
175      * Gets a context object for the debug scope created when producing the code for this stub.
176      */
177     protected abstract Object debugScopeContext();
178 
179     private static final AtomicInteger nextStubId = new AtomicInteger();
180 
181     private DebugContext openDebugContext(DebugContext outer) {
182         if (DebugStubsAndSnippets.getValue(options)) {
183             Description description = new Description(linkage, &quot;Stub_&quot; + nextStubId.incrementAndGet());
184             return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, singletonList(new GraalDebugHandlersFactory(providers.getSnippetReflection())));
185         }
<span class="line-modified">186         return DebugContext.DISABLED;</span>
187     }
188 
189     /**
190      * Gets the code for this stub, compiling it first if necessary.
191      */
192     @SuppressWarnings(&quot;try&quot;)
193     public synchronized InstalledCode getCode(final Backend backend) {
194         if (code == null) {
195             try (DebugContext debug = openDebugContext(DebugContext.forCurrentThread())) {
196                 try (DebugContext.Scope d = debug.scope(&quot;CompilingStub&quot;, providers.getCodeCache(), debugScopeContext())) {
197                     CodeCacheProvider codeCache = providers.getCodeCache();
198                     CompilationResult compResult = buildCompilationResult(debug, backend);
199                     try (DebugContext.Scope s = debug.scope(&quot;CodeInstall&quot;, compResult);
200                                     DebugContext.Activation a = debug.activate()) {
201                         assert destroyedCallerRegisters != null;
202                         // Add a GeneratePIC check here later, we don&#39;t want to install
203                         // code if we don&#39;t have a corresponding VM global symbol.
204                         HotSpotCompiledCode compiledCode = HotSpotCompiledCodeBuilder.createCompiledCode(codeCache, null, null, compResult, options);
205                         code = codeCache.installCode(null, compiledCode, null, null, false);
206                     } catch (Throwable e) {
</pre>
<hr />
<pre>
272         for (DataPatch data : compResult.getDataPatches()) {
273             if (data.reference instanceof ConstantReference) {
274                 ConstantReference ref = (ConstantReference) data.reference;
275                 if (ref.getConstant() instanceof HotSpotMetaspaceConstant) {
276                     HotSpotMetaspaceConstant c = (HotSpotMetaspaceConstant) ref.getConstant();
277                     if (c.asResolvedJavaType() != null &amp;&amp; c.asResolvedJavaType().getName().equals(&quot;[I&quot;)) {
278                         // special handling for NewArrayStub
279                         // embedding the type &#39;[I&#39; is safe, since it is never unloaded
280                         continue;
281                     }
282                 }
283             }
284 
285             assert !(data.reference instanceof ConstantReference) : this + &quot; cannot have embedded object or metadata constant: &quot; + data.reference;
286         }
287         for (Infopoint infopoint : compResult.getInfopoints()) {
288             assert infopoint instanceof Call : this + &quot; cannot have non-call infopoint: &quot; + infopoint;
289             Call call = (Call) infopoint;
290             assert call.target instanceof HotSpotForeignCallLinkage : this + &quot; cannot have non runtime call: &quot; + call.target;
291             HotSpotForeignCallLinkage callLinkage = (HotSpotForeignCallLinkage) call.target;
<span class="line-modified">292             assert !callLinkage.isCompiledStub() || callLinkage.getDescriptor().equals(UNCOMMON_TRAP_HANDLER) : this + &quot; cannot call compiled stub &quot; + callLinkage;</span>
293         }
294         return true;
295     }
296 
297     protected Suites createSuites() {
298         Suites defaultSuites = providers.getSuites().getDefaultSuites(options);
299         return new Suites(new PhaseSuite&lt;&gt;(), defaultSuites.getMidTier(), defaultSuites.getLowTier());
300     }
301 
302     protected LIRSuites createLIRSuites() {
303         LIRSuites lirSuites = new LIRSuites(providers.getSuites().getDefaultLIRSuites(options));
304         ListIterator&lt;LIRPhase&lt;PostAllocationOptimizationContext&gt;&gt; moveProfiling = lirSuites.getPostAllocationOptimizationStage().findPhase(MoveProfilingPhase.class);
305         if (moveProfiling != null) {
306             moveProfiling.remove();
307         }
308         return lirSuites;
309     }
310 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.stubs;
 26 
 27 import static java.util.Collections.singletonList;
 28 import static org.graalvm.compiler.core.GraalCompiler.emitFrontEnd;
 29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
<span class="line-added"> 30 import static org.graalvm.compiler.core.common.GraalOptions.RegisterPressure;</span>
 31 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
 32 import static org.graalvm.compiler.debug.DebugOptions.DebugStubsAndSnippets;
<span class="line-modified"> 33 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.DEOPT_BLOB_UNCOMMON_TRAP;</span>
 34 import static org.graalvm.util.CollectionsUtil.allMatch;
 35 
 36 import java.util.ListIterator;
 37 import java.util.concurrent.atomic.AtomicInteger;
 38 
 39 import jdk.internal.vm.compiler.collections.EconomicSet;
 40 import org.graalvm.compiler.code.CompilationResult;
 41 import org.graalvm.compiler.core.common.CompilationIdentifier;
 42 import org.graalvm.compiler.core.common.GraalOptions;
 43 import org.graalvm.compiler.core.target.Backend;
 44 import org.graalvm.compiler.debug.DebugContext;
 45 import org.graalvm.compiler.debug.DebugContext.Description;
 46 import org.graalvm.compiler.hotspot.HotSpotCompiledCodeBuilder;
 47 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 48 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 49 import org.graalvm.compiler.hotspot.nodes.StubStartNode;
 50 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 51 import org.graalvm.compiler.lir.phases.LIRPhase;
 52 import org.graalvm.compiler.lir.phases.LIRSuites;
 53 import org.graalvm.compiler.lir.phases.PostAllocationOptimizationPhase.PostAllocationOptimizationContext;
</pre>
<hr />
<pre>
 60 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 61 
 62 import jdk.vm.ci.code.CodeCacheProvider;
 63 import jdk.vm.ci.code.InstalledCode;
 64 import jdk.vm.ci.code.Register;
 65 import jdk.vm.ci.code.RegisterConfig;
 66 import jdk.vm.ci.code.site.Call;
 67 import jdk.vm.ci.code.site.ConstantReference;
 68 import jdk.vm.ci.code.site.DataPatch;
 69 import jdk.vm.ci.code.site.Infopoint;
 70 import jdk.vm.ci.hotspot.HotSpotCompiledCode;
 71 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 72 import jdk.vm.ci.meta.DefaultProfilingInfo;
 73 import jdk.vm.ci.meta.ResolvedJavaMethod;
 74 import jdk.vm.ci.meta.TriState;
 75 
 76 //JaCoCo Exclude
 77 
 78 /**
 79  * Base class for implementing some low level code providing the out-of-line slow path for a snippet
<span class="line-modified"> 80  * and/or a callee saved call to a HotSpot C/C++ runtime function or even another compiled Java</span>
 81  * method.
 82  */
 83 public abstract class Stub {
 84 
 85     /**
 86      * The linkage information for a call to this stub from compiled code.
 87      */
 88     protected final HotSpotForeignCallLinkage linkage;
 89 
 90     /**
 91      * The code installed for the stub.
 92      */
 93     protected InstalledCode code;
 94 
 95     /**
 96      * The registers destroyed by this stub (from the caller&#39;s perspective).
 97      */
 98     private EconomicSet&lt;Register&gt; destroyedCallerRegisters;
 99 
100     private static boolean checkRegisterSetEquivalency(EconomicSet&lt;Register&gt; a, EconomicSet&lt;Register&gt; b) {
</pre>
<hr />
<pre>
105             return false;
106         }
107         return allMatch(a, e -&gt; b.contains(e));
108     }
109 
110     public void initDestroyedCallerRegisters(EconomicSet&lt;Register&gt; registers) {
111         assert registers != null;
112         assert destroyedCallerRegisters == null || checkRegisterSetEquivalency(registers, destroyedCallerRegisters) : &quot;cannot redefine&quot;;
113         destroyedCallerRegisters = registers;
114     }
115 
116     /**
117      * Gets the registers destroyed by this stub from a caller&#39;s perspective. These are the
118      * temporaries of this stub and must thus be caller saved by a callers of this stub.
119      */
120     public EconomicSet&lt;Register&gt; getDestroyedCallerRegisters() {
121         assert destroyedCallerRegisters != null : &quot;not yet initialized&quot;;
122         return destroyedCallerRegisters;
123     }
124 
<span class="line-modified">125     public boolean shouldSaveRegistersAroundCalls() {</span>
<span class="line-modified">126         return linkage.getEffect() == HotSpotForeignCallLinkage.RegisterEffect.COMPUTES_REGISTERS_KILLED;</span>




127     }
128 
129     protected final OptionValues options;
130     protected final HotSpotProviders providers;
131 
132     /**
133      * Creates a new stub.
134      *
135      * @param linkage linkage details for a call to the stub
136      */
137     public Stub(OptionValues options, HotSpotProviders providers, HotSpotForeignCallLinkage linkage) {
138         this.linkage = linkage;
<span class="line-modified">139         // The RegisterPressure flag can be ignored by a compilation that runs out of registers, so</span>
<span class="line-added">140         // the stub compilation must ignore the flag so that all allocatable registers are saved.</span>
<span class="line-added">141         this.options = new OptionValues(options, GraalOptions.TraceInlining, GraalOptions.TraceInliningForStubsAndSnippets.getValue(options), RegisterPressure, null);</span>
142         this.providers = providers;
143     }
144 
145     /**
146      * Gets the linkage for a call to this stub from compiled code.
147      */
148     public HotSpotForeignCallLinkage getLinkage() {
149         return linkage;
150     }
151 
152     public RegisterConfig getRegisterConfig() {
153         return null;
154     }
155 
156     /**
157      * Gets the graph that from which the code for this stub will be compiled.
158      *
159      * @param compilationId unique compilation id for the stub
160      */
161     protected abstract StructuredGraph getGraph(DebugContext debug, CompilationIdentifier compilationId);
</pre>
<hr />
<pre>
165         return &quot;Stub&lt;&quot; + linkage.getDescriptor() + &quot;&gt;&quot;;
166     }
167 
168     /**
169      * Gets the method the stub&#39;s code will be associated with once installed. This may be null.
170      */
171     protected abstract ResolvedJavaMethod getInstalledCodeOwner();
172 
173     /**
174      * Gets a context object for the debug scope created when producing the code for this stub.
175      */
176     protected abstract Object debugScopeContext();
177 
178     private static final AtomicInteger nextStubId = new AtomicInteger();
179 
180     private DebugContext openDebugContext(DebugContext outer) {
181         if (DebugStubsAndSnippets.getValue(options)) {
182             Description description = new Description(linkage, &quot;Stub_&quot; + nextStubId.incrementAndGet());
183             return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, singletonList(new GraalDebugHandlersFactory(providers.getSnippetReflection())));
184         }
<span class="line-modified">185         return DebugContext.disabled(options);</span>
186     }
187 
188     /**
189      * Gets the code for this stub, compiling it first if necessary.
190      */
191     @SuppressWarnings(&quot;try&quot;)
192     public synchronized InstalledCode getCode(final Backend backend) {
193         if (code == null) {
194             try (DebugContext debug = openDebugContext(DebugContext.forCurrentThread())) {
195                 try (DebugContext.Scope d = debug.scope(&quot;CompilingStub&quot;, providers.getCodeCache(), debugScopeContext())) {
196                     CodeCacheProvider codeCache = providers.getCodeCache();
197                     CompilationResult compResult = buildCompilationResult(debug, backend);
198                     try (DebugContext.Scope s = debug.scope(&quot;CodeInstall&quot;, compResult);
199                                     DebugContext.Activation a = debug.activate()) {
200                         assert destroyedCallerRegisters != null;
201                         // Add a GeneratePIC check here later, we don&#39;t want to install
202                         // code if we don&#39;t have a corresponding VM global symbol.
203                         HotSpotCompiledCode compiledCode = HotSpotCompiledCodeBuilder.createCompiledCode(codeCache, null, null, compResult, options);
204                         code = codeCache.installCode(null, compiledCode, null, null, false);
205                     } catch (Throwable e) {
</pre>
<hr />
<pre>
271         for (DataPatch data : compResult.getDataPatches()) {
272             if (data.reference instanceof ConstantReference) {
273                 ConstantReference ref = (ConstantReference) data.reference;
274                 if (ref.getConstant() instanceof HotSpotMetaspaceConstant) {
275                     HotSpotMetaspaceConstant c = (HotSpotMetaspaceConstant) ref.getConstant();
276                     if (c.asResolvedJavaType() != null &amp;&amp; c.asResolvedJavaType().getName().equals(&quot;[I&quot;)) {
277                         // special handling for NewArrayStub
278                         // embedding the type &#39;[I&#39; is safe, since it is never unloaded
279                         continue;
280                     }
281                 }
282             }
283 
284             assert !(data.reference instanceof ConstantReference) : this + &quot; cannot have embedded object or metadata constant: &quot; + data.reference;
285         }
286         for (Infopoint infopoint : compResult.getInfopoints()) {
287             assert infopoint instanceof Call : this + &quot; cannot have non-call infopoint: &quot; + infopoint;
288             Call call = (Call) infopoint;
289             assert call.target instanceof HotSpotForeignCallLinkage : this + &quot; cannot have non runtime call: &quot; + call.target;
290             HotSpotForeignCallLinkage callLinkage = (HotSpotForeignCallLinkage) call.target;
<span class="line-modified">291             assert !callLinkage.isCompiledStub() || callLinkage.getDescriptor().equals(DEOPT_BLOB_UNCOMMON_TRAP) : this + &quot; cannot call compiled stub &quot; + callLinkage;</span>
292         }
293         return true;
294     }
295 
296     protected Suites createSuites() {
297         Suites defaultSuites = providers.getSuites().getDefaultSuites(options);
298         return new Suites(new PhaseSuite&lt;&gt;(), defaultSuites.getMidTier(), defaultSuites.getLowTier());
299     }
300 
301     protected LIRSuites createLIRSuites() {
302         LIRSuites lirSuites = new LIRSuites(providers.getSuites().getDefaultLIRSuites(options));
303         ListIterator&lt;LIRPhase&lt;PostAllocationOptimizationContext&gt;&gt; moveProfiling = lirSuites.getPostAllocationOptimizationStage().findPhase(MoveProfilingPhase.class);
304         if (moveProfiling != null) {
305             moveProfiling.remove();
306         }
307         return lirSuites;
308     }
309 }
</pre>
</td>
</tr>
</table>
<center><a href="SnippetStub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StubUtil.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/HotSpotReplacementsUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.replacements;
 26 
 27 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_METAACCESS;
 28 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
 29 import static org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl.VERIFY_OOP;
 30 
 31 import java.lang.ref.Reference;
 32 
 33 import org.graalvm.compiler.api.replacements.Fold;
 34 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
 35 import org.graalvm.compiler.core.common.SuppressFBWarnings;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 37 import org.graalvm.compiler.core.common.type.ObjectStamp;
 38 import org.graalvm.compiler.core.common.type.TypeReference;
 39 import org.graalvm.compiler.debug.GraalError;
 40 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 41 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 42 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 43 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 44 import org.graalvm.compiler.hotspot.word.KlassPointer;
 45 import org.graalvm.compiler.nodes.CanonicalizableLocation;
 46 import org.graalvm.compiler.nodes.CompressionNode;
 47 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 48 import org.graalvm.compiler.nodes.ConstantNode;
 49 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 50 import org.graalvm.compiler.nodes.NodeView;
 51 import org.graalvm.compiler.nodes.ValueNode;
 52 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 53 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 54 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 55 import org.graalvm.compiler.nodes.extended.StoreHubNode;
 56 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 57 import org.graalvm.compiler.nodes.memory.Access;
 58 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 59 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 60 import org.graalvm.compiler.nodes.type.StampTool;
 61 import org.graalvm.compiler.replacements.ReplacementsUtil;
 62 import org.graalvm.compiler.replacements.nodes.ReadRegisterNode;
 63 import org.graalvm.compiler.replacements.nodes.WriteRegisterNode;
 64 import org.graalvm.compiler.word.Word;
 65 import jdk.internal.vm.compiler.word.LocationIdentity;
 66 import jdk.internal.vm.compiler.word.WordFactory;
 67 
 68 import jdk.vm.ci.code.Register;
 69 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 70 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 71 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 72 import jdk.vm.ci.meta.Assumptions;
 73 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 74 import jdk.vm.ci.meta.JavaKind;
 75 import jdk.vm.ci.meta.MetaAccessProvider;
 76 import jdk.vm.ci.meta.ResolvedJavaField;
 77 import jdk.vm.ci.meta.ResolvedJavaType;
 78 import jdk.vm.ci.meta.UnresolvedJavaType;
 79 
 80 //JaCoCo Exclude
 81 
 82 /**
 83  * A collection of methods used in HotSpot snippets, substitutions and stubs.
 84  */
 85 public class HotSpotReplacementsUtil {
 86 
 87     abstract static class HotSpotOptimizingLocationIdentity extends NamedLocationIdentity implements CanonicalizableLocation {
 88 
 89         HotSpotOptimizingLocationIdentity(String name) {
 90             super(name, true);
 91         }
 92 
 93         @Override
 94         public abstract ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool);
 95 
 96         protected ValueNode findReadHub(ValueNode object) {
 97             ValueNode base = object;
 98             if (base instanceof CompressionNode) {
 99                 base = ((CompressionNode) base).getValue();
100             }
101             if (base instanceof Access) {
102                 Access access = (Access) base;
103                 if (access.getLocationIdentity().equals(HUB_LOCATION) || access.getLocationIdentity().equals(COMPRESSED_HUB_LOCATION)) {
104                     AddressNode address = access.getAddress();
105                     if (address instanceof OffsetAddressNode) {
106                         OffsetAddressNode offset = (OffsetAddressNode) address;
107                         return offset.getBase();
108                     }
109                 }
110             } else if (base instanceof LoadHubNode) {
111                 LoadHubNode loadhub = (LoadHubNode) base;
112                 return loadhub.getValue();
113             }
114             return null;
115         }
116 
117         /**
118          * Fold reads that convert from Class -&gt; Hub -&gt; Class or vice versa.
119          *
120          * @param read
121          * @param object
122          * @param otherLocation
123          * @return an earlier read or the original {@code read}
124          */
125         protected static ValueNode foldIndirection(ValueNode read, ValueNode object, LocationIdentity otherLocation) {
126             if (object instanceof Access) {
127                 Access access = (Access) object;
128                 if (access.getLocationIdentity().equals(otherLocation)) {
129                     AddressNode address = access.getAddress();
130                     if (address instanceof OffsetAddressNode) {
131                         OffsetAddressNode offset = (OffsetAddressNode) address;
132                         assert offset.getBase().stamp(NodeView.DEFAULT).isCompatible(read.stamp(NodeView.DEFAULT));
133                         return offset.getBase();
134                     }
135                 }
136             }
137             return read;
138         }
139     }
140 
141     @Fold
142     public static ResolvedJavaType methodHolderClass(@InjectedParameter IntrinsicContext context) {
143         return context.getOriginalMethod().getDeclaringClass();
144     }
145 
146     @Fold
147     static ResolvedJavaType getType(@Fold.InjectedParameter IntrinsicContext context, String typeName) {
148         try {
149             UnresolvedJavaType unresolved = UnresolvedJavaType.create(typeName);
150             return unresolved.resolve(methodHolderClass(context));
151         } catch (LinkageError e) {
152             throw new GraalError(e);
153         }
154     }
155 
156     @Fold
157     static int getFieldOffset(ResolvedJavaType type, String fieldName) {
158         for (ResolvedJavaField field : type.getInstanceFields(true)) {
159             if (field.getName().equals(fieldName)) {
160                 return field.getOffset();
161             }
162         }
163         throw new GraalError(&quot;missing field &quot; + fieldName);
164     }
165 
166     public static HotSpotJVMCIRuntime runtime() {
167         return HotSpotJVMCIRuntime.runtime();
168     }
169 
170     @Fold
171     public static int getHeapWordSize(@InjectedParameter GraalHotSpotVMConfig injectedVMConfig) {
172         return injectedVMConfig.heapWordSize;
173     }
174 
175     @Fold
176     public static int klassLayoutHelperNeutralValue(@InjectedParameter GraalHotSpotVMConfig config) {
177         return config.klassLayoutHelperNeutralValue;
178     }
179 
180     @Fold
181     public static boolean useTLAB(@InjectedParameter GraalHotSpotVMConfig config) {
182         return config.useTLAB;
183     }
184 
185     @Fold
186     public static boolean verifyOops(@InjectedParameter GraalHotSpotVMConfig config) {
187         return config.verifyOops;
188     }
189 
190     public static final LocationIdentity EXCEPTION_OOP_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionOop&quot;);
191 
192     /**
193      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
194      */
195     @Fold
196     public static int threadExceptionOopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
197         return config.threadExceptionOopOffset;
198     }
199 
200     public static final LocationIdentity EXCEPTION_PC_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionPc&quot;);
201 
202     @Fold
203     public static int threadExceptionPcOffset(@InjectedParameter GraalHotSpotVMConfig config) {
204         return config.threadExceptionPcOffset;
205     }
206 
207     public static final LocationIdentity TLAB_TOP_LOCATION = NamedLocationIdentity.mutable(&quot;TlabTop&quot;);
208 
209     @Fold
210     public static int threadTlabTopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
211         return config.threadTlabTopOffset();
212     }
213 
214     public static final LocationIdentity TLAB_END_LOCATION = NamedLocationIdentity.mutable(&quot;TlabEnd&quot;);
215 
216     @Fold
217     static int threadTlabEndOffset(@InjectedParameter GraalHotSpotVMConfig config) {
218         return config.threadTlabEndOffset();
219     }
220 
221     public static final LocationIdentity PENDING_EXCEPTION_LOCATION = NamedLocationIdentity.mutable(&quot;PendingException&quot;);
222 
223     /**
224      * @see GraalHotSpotVMConfig#pendingExceptionOffset
225      */
226     @Fold
227     static int threadPendingExceptionOffset(@InjectedParameter GraalHotSpotVMConfig config) {
228         return config.pendingExceptionOffset;
229     }
230 
231     /**
232      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
233      */
234     public static Object readExceptionOop(Word thread) {
235         return thread.readObject(threadExceptionOopOffset(INJECTED_VMCONFIG), EXCEPTION_OOP_LOCATION);
236     }
237 
238     public static Word readExceptionPc(Word thread) {
239         return thread.readWord(threadExceptionPcOffset(INJECTED_VMCONFIG), EXCEPTION_PC_LOCATION);
240     }
241 
242     /**
243      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
244      */
245     public static void writeExceptionOop(Word thread, Object value) {
246         thread.writeObject(threadExceptionOopOffset(INJECTED_VMCONFIG), value, EXCEPTION_OOP_LOCATION);
247     }
248 
249     public static void writeExceptionPc(Word thread, Word value) {
250         thread.writeWord(threadExceptionPcOffset(INJECTED_VMCONFIG), value, EXCEPTION_PC_LOCATION);
251     }
252 
253     public static Word readTlabTop(Word thread) {
254         return thread.readWord(threadTlabTopOffset(INJECTED_VMCONFIG), TLAB_TOP_LOCATION);
255     }
256 
257     public static Word readTlabEnd(Word thread) {
258         return thread.readWord(threadTlabEndOffset(INJECTED_VMCONFIG), TLAB_END_LOCATION);
259     }
260 
261     public static void writeTlabTop(Word thread, Word top) {
262         thread.writeWord(threadTlabTopOffset(INJECTED_VMCONFIG), top, TLAB_TOP_LOCATION);
263     }
264 
265     /**
266      * Clears the pending exception for the given thread.
267      *
268      * @return the pending exception, or null if there was none
269      */
270     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
271     public static Object clearPendingException(Word thread) {
272         Object result = thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
273         thread.writeObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), null, PENDING_EXCEPTION_LOCATION);
274         return result;
275     }
276 
277     /**
278      * Gets the pending exception for the given thread.
279      *
280      * @return the pending exception, or null if there was none
281      */
282     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
283     public static Object getPendingException(Word thread) {
284         return thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
285     }
286 
287     /*
288      * As far as Java code is concerned this can be considered immutable: it is set just after the
289      * JavaThread is created, before it is published. After that, it is never changed.
290      */
291     public static final LocationIdentity JAVA_THREAD_THREAD_OBJECT_LOCATION = NamedLocationIdentity.immutable(&quot;JavaThread::_threadObj&quot;);
292 
293     @Fold
294     public static int threadObjectOffset(@InjectedParameter GraalHotSpotVMConfig config) {
295         return config.threadObjectOffset;
296     }
297 
298     public static final LocationIdentity JAVA_THREAD_OSTHREAD_LOCATION = NamedLocationIdentity.mutable(&quot;JavaThread::_osthread&quot;);
299 
300     @Fold
301     public static int osThreadOffset(@InjectedParameter GraalHotSpotVMConfig config) {
302         return config.osThreadOffset;
303     }
304 
305     @Fold
306     public static int osThreadInterruptedOffset(@InjectedParameter GraalHotSpotVMConfig config) {
307         return config.osThreadInterruptedOffset;
308     }
309 
310     @Fold
311     public static JavaKind getWordKind() {
312         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
313     }
314 
315     @Fold
316     public static int wordSize() {
317         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordSize;
318     }
319 
320     @Fold
321     public static int pageSize(@InjectedParameter GraalHotSpotVMConfig config) {
322         return config.vmPageSize;
323     }
324 
325     public static final LocationIdentity PROTOTYPE_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;PrototypeMarkWord&quot;);
326 
327     @Fold
328     public static int prototypeMarkWordOffset(@InjectedParameter GraalHotSpotVMConfig config) {
329         return config.prototypeMarkWordOffset;
330     }
331 
332     public static final LocationIdentity KLASS_ACCESS_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_access_flags&quot;);
333 
334     @Fold
335     public static int klassAccessFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
336         return config.klassAccessFlagsOffset;
337     }
338 
339     @Fold
340     public static int jvmAccWrittenFlags(@InjectedParameter GraalHotSpotVMConfig config) {
341         return config.jvmAccWrittenFlags;
342     }
343 
344     public static final LocationIdentity KLASS_LAYOUT_HELPER_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Klass::_layout_helper&quot;) {
345         @Override
346         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
347             ValueNode javaObject = findReadHub(object);
348             if (javaObject != null) {
349                 if (javaObject.stamp(NodeView.DEFAULT) instanceof ObjectStamp) {
350                     ObjectStamp stamp = (ObjectStamp) javaObject.stamp(NodeView.DEFAULT);
351                     HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) stamp.javaType(tool.getMetaAccess());
352                     if (type.isArray() &amp;&amp; !type.getComponentType().isPrimitive()) {
353                         int layout = type.layoutHelper();
354                         return ConstantNode.forInt(layout);
355                     }
356                 }
357             }
358             return read;
359         }
360     };
361 
362     @Fold
363     public static int allocatePrefetchStyle(@InjectedParameter GraalHotSpotVMConfig config) {
364         return config.allocatePrefetchStyle;
365     }
366 
367     @Fold
368     public static int allocatePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
369         return config.allocatePrefetchLines;
370     }
371 
372     @Fold
373     public static int allocatePrefetchDistance(@InjectedParameter GraalHotSpotVMConfig config) {
374         return config.allocatePrefetchDistance;
375     }
376 
377     @Fold
378     public static int allocateInstancePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
379         return config.allocateInstancePrefetchLines;
380     }
381 
382     @Fold
383     public static int allocatePrefetchStepSize(@InjectedParameter GraalHotSpotVMConfig config) {
384         return config.allocatePrefetchStepSize;
385     }
386 
387     @Fold
388     public static int invocationCounterIncrement(@InjectedParameter GraalHotSpotVMConfig config) {
389         return config.invocationCounterIncrement;
390     }
391 
392     @Fold
393     public static int invocationCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
394         return config.invocationCounterOffset;
395     }
396 
397     @Fold
398     public static int backedgeCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
399         return config.backedgeCounterOffset;
400     }
401 
402     @Fold
403     public static int invocationCounterShift(@InjectedParameter GraalHotSpotVMConfig config) {
404         return config.invocationCounterShift;
405     }
406 
407     @Fold
408     public static int stackBias(@InjectedParameter GraalHotSpotVMConfig config) {
409         return config.stackBias;
410     }
411 
412     @NodeIntrinsic(value = KlassLayoutHelperNode.class)
413     public static native int readLayoutHelper(KlassPointer object);
414 
415     /**
416      * Checks if class {@code klass} is an array.
417      *
418      * See: Klass::layout_helper_is_array
419      *
420      * @param klassNonNull the class to be checked
421      * @return true if klassNonNull is an array, false otherwise
422      */
423     public static boolean klassIsArray(KlassPointer klassNonNull) {
424         /*
425          * The less-than check only works if both values are ints. We use local variables to make
426          * sure these are still ints and haven&#39;t changed.
427          */
428         final int layoutHelper = readLayoutHelper(klassNonNull);
429         final int layoutHelperNeutralValue = klassLayoutHelperNeutralValue(INJECTED_VMCONFIG);
430         return (layoutHelper &lt; layoutHelperNeutralValue);
431     }
432 
433     public static final LocationIdentity ARRAY_KLASS_COMPONENT_MIRROR = NamedLocationIdentity.immutable(&quot;ArrayKlass::_component_mirror&quot;);
434 
435     @Fold
436     public static int arrayKlassComponentMirrorOffset(@InjectedParameter GraalHotSpotVMConfig config) {
437         return config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;);
438     }
439 
440     public static final LocationIdentity KLASS_SUPER_KLASS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super&quot;);
441 
442     @Fold
443     public static int klassSuperKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
444         return config.klassSuperKlassOffset;
445     }
446 
447     public static final LocationIdentity MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;MarkWord&quot;);
448 
449     @Fold
450     public static int markOffset(@InjectedParameter GraalHotSpotVMConfig config) {
451         return config.markOffset;
452     }
453 
454     public static final LocationIdentity HUB_WRITE_LOCATION = NamedLocationIdentity.mutable(&quot;Hub:write&quot;);
455 
456     public static final LocationIdentity HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Hub&quot;) {
457         @Override
458         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
459             TypeReference constantType = StampTool.typeReferenceOrNull(object);
460             if (constantType != null &amp;&amp; constantType.isExact()) {
461                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(constantType.getType()), tool.getMetaAccess());
462             }
463             return read;
464         }
465     };
466 
467     public static final LocationIdentity COMPRESSED_HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;CompressedHub&quot;) {
468         @Override
469         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
470             TypeReference constantType = StampTool.typeReferenceOrNull(object);
471             if (constantType != null &amp;&amp; constantType.isExact()) {
472                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), ((HotSpotMetaspaceConstant) tool.getConstantReflection().asObjectHub(constantType.getType())).compress(),
473                                 tool.getMetaAccess());
474             }
475             return read;
476         }
477     };
478 
479     @Fold
480     static int hubOffset(@InjectedParameter GraalHotSpotVMConfig config) {
481         return config.hubOffset;
482     }
483 
484     public static void initializeObjectHeader(Word memory, Word markWord, KlassPointer hub) {
485         memory.writeWord(markOffset(INJECTED_VMCONFIG), markWord, MARK_WORD_LOCATION);
486         StoreHubNode.write(memory, hub);
487     }
488 
489     @Fold
490     public static int unlockedMask(@InjectedParameter GraalHotSpotVMConfig config) {
491         return config.unlockedMask;
492     }
493 
494     @Fold
495     public static int monitorMask(@InjectedParameter GraalHotSpotVMConfig config) {
496         return config.monitorMask;
497     }
498 
499     @Fold
500     public static int objectMonitorOwnerOffset(@InjectedParameter GraalHotSpotVMConfig config) {
501         return config.objectMonitorOwner;
502     }
503 
504     @Fold
505     public static int objectMonitorRecursionsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
506         return config.objectMonitorRecursions;
507     }
508 
509     @Fold
510     public static int objectMonitorCxqOffset(@InjectedParameter GraalHotSpotVMConfig config) {
511         return config.objectMonitorCxq;
512     }
513 
514     @Fold
515     public static int objectMonitorEntryListOffset(@InjectedParameter GraalHotSpotVMConfig config) {
516         return config.objectMonitorEntryList;
517     }
518 
519     /**
520      * Mask for a biasable, locked or unlocked mark word.
521      *
522      * &lt;pre&gt;
523      * +----------------------------------+-+-+
524      * |                                 1|1|1|
525      * +----------------------------------+-+-+
526      * &lt;/pre&gt;
527      *
528      */
529     @Fold
530     public static int biasedLockMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
531         return config.biasedLockMaskInPlace;
532     }
533 
534     @Fold
535     public static int epochMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
536         return config.epochMaskInPlace;
537     }
538 
539     /**
540      * Pattern for a biasable, unlocked mark word.
541      *
542      * &lt;pre&gt;
543      * +----------------------------------+-+-+
544      * |                                 1|0|1|
545      * +----------------------------------+-+-+
546      * &lt;/pre&gt;
547      *
548      */
549     @Fold
550     public static int biasedLockPattern(@InjectedParameter GraalHotSpotVMConfig config) {
551         return config.biasedLockPattern;
552     }
553 
554     @Fold
555     public static int ageMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
556         return config.ageMaskInPlace;
557     }
558 
559     @Fold
560     public static int metaspaceArrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
561         return config.metaspaceArrayLengthOffset;
562     }
563 
564     @Fold
565     public static int metaspaceArrayBaseOffset(@InjectedParameter GraalHotSpotVMConfig config) {
566         return config.metaspaceArrayBaseOffset;
567     }
568 
569     @Fold
570     public static int arrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
571         return config.arrayOopDescLengthOffset();
572     }
573 
574     public static Word arrayStart(int[] a) {
575         return WordFactory.unsigned(ComputeObjectAddressNode.get(a, ReplacementsUtil.getArrayBaseOffset(INJECTED_METAACCESS, JavaKind.Int)));
576     }
577 
578     /**
579      * Idiom for making {@link GraalHotSpotVMConfig} a constant.
580      */
581     @Fold
582     public static int objectAlignment(@InjectedParameter GraalHotSpotVMConfig config) {
583         return config.objectAlignment;
584     }
585 
586     /**
587      * Calls {@link #arrayAllocationSize(int, int, int, int)} using an injected VM configuration
588      * object.
589      */
590     public static long arrayAllocationSize(int length, int headerSize, int log2ElementSize) {
591         return arrayAllocationSize(length, headerSize, log2ElementSize, objectAlignment(INJECTED_VMCONFIG));
592     }
593 
594     /**
595      * Computes the size of the memory chunk allocated for an array. This size accounts for the
596      * array header size, body size and any padding after the last element to satisfy object
597      * alignment requirements.
598      *
599      * @param length the number of elements in the array
600      * @param headerSize the size of the array header
601      * @param log2ElementSize log2 of the size of an element in the array
602      * @param alignment the {@linkplain GraalHotSpotVMConfig#objectAlignment object alignment
603      *            requirement}
604      * @return the size of the memory chunk
605      */
606     public static long arrayAllocationSize(int length, int headerSize, int log2ElementSize, int alignment) {
607         long size = ((long) length &lt;&lt; log2ElementSize) + headerSize + (alignment - 1);
608         long mask = ~(alignment - 1);
609         return size &amp; mask;
610     }
611 
612     @Fold
613     public static int instanceHeaderSize(@InjectedParameter GraalHotSpotVMConfig config) {
614         return config.useCompressedClassPointers ? (2 * wordSize()) - 4 : 2 * wordSize();
615     }
616 
617     @Fold
618     public static byte dirtyCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
619         return config.dirtyCardValue;
620     }
621 
622     @Fold
623     public static byte g1YoungCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
624         return config.g1YoungCardValue;
625     }
626 
627     @Fold
628     public static int cardTableShift(@InjectedParameter GraalHotSpotVMConfig config) {
629         return config.cardtableShift;
630     }
631 
632     @Fold
633     public static int g1CardQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
634         return config.g1CardQueueIndexOffset;
635     }
636 
637     @Fold
638     public static int g1CardQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
639         return config.g1CardQueueBufferOffset;
640     }
641 
642     @Fold
643     public static int g1SATBQueueMarkingOffset(@InjectedParameter GraalHotSpotVMConfig config) {
644         return config.g1SATBQueueMarkingOffset;
645     }
646 
647     @Fold
648     public static int g1SATBQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
649         return config.g1SATBQueueIndexOffset;
650     }
651 
652     @Fold
653     public static int g1SATBQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
654         return config.g1SATBQueueBufferOffset;
655     }
656 
657     public static final LocationIdentity KLASS_SUPER_CHECK_OFFSET_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super_check_offset&quot;);
658 
659     @Fold
660     public static int superCheckOffsetOffset(@InjectedParameter GraalHotSpotVMConfig config) {
661         return config.superCheckOffsetOffset;
662     }
663 
664     public static final LocationIdentity SECONDARY_SUPER_CACHE_LOCATION = NamedLocationIdentity.mutable(&quot;SecondarySuperCache&quot;);
665 
666     @Fold
667     public static int secondarySuperCacheOffset(@InjectedParameter GraalHotSpotVMConfig config) {
668         return config.secondarySuperCacheOffset;
669     }
670 
671     public static final LocationIdentity SECONDARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupers&quot;);
672 
673     @Fold
674     public static int secondarySupersOffset(@InjectedParameter GraalHotSpotVMConfig config) {
675         return config.secondarySupersOffset;
676     }
677 
678     public static final LocationIdentity DISPLACED_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;DisplacedMarkWord&quot;);
679 
680     public static final LocationIdentity OBJECT_MONITOR_OWNER_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_owner&quot;);
681 
682     public static final LocationIdentity OBJECT_MONITOR_RECURSION_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_recursions&quot;);
683 
684     public static final LocationIdentity OBJECT_MONITOR_CXQ_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_cxq&quot;);
685 
686     public static final LocationIdentity OBJECT_MONITOR_ENTRY_LIST_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_EntryList&quot;);
687 
688     @Fold
689     public static int lockDisplacedMarkOffset(@InjectedParameter GraalHotSpotVMConfig config) {
690         return config.basicLockDisplacedHeaderOffset;
691     }
692 
693     @Fold
694     public static boolean useBiasedLocking(@InjectedParameter GraalHotSpotVMConfig config) {
695         return config.useBiasedLocking;
696     }
697 
698     @Fold
699     static int uninitializedIdentityHashCodeValue(@InjectedParameter GraalHotSpotVMConfig config) {
700         return config.uninitializedIdentityHashCodeValue;
701     }
702 
703     @Fold
704     static int identityHashCodeShift(@InjectedParameter GraalHotSpotVMConfig config) {
705         return config.identityHashCodeShift;
706     }
707 
708     /**
709      * Loads the hub of an object (without null checking it first).
710      */
711     public static KlassPointer loadHub(Object object) {
712         return loadHubIntrinsic(object);
713     }
714 
715     public static Object verifyOop(Object object) {
716         if (verifyOops(INJECTED_VMCONFIG)) {
717             verifyOopStub(VERIFY_OOP, object);
718         }
719         return object;
720     }
721 
722     @NodeIntrinsic(ForeignCallNode.class)
723     private static native Object verifyOopStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
724 
725     public static Word loadWordFromObject(Object object, int offset) {
726         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
727         return loadWordFromObjectIntrinsic(object, offset, LocationIdentity.any(), getWordKind());
728     }
729 
730     public static Word loadWordFromObject(Object object, int offset, LocationIdentity identity) {
731         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
732         return loadWordFromObjectIntrinsic(object, offset, identity, getWordKind());
733     }
734 
735     public static KlassPointer loadKlassFromObject(Object object, int offset, LocationIdentity identity) {
736         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadKlassFromObject&quot;);
737         return loadKlassFromObjectIntrinsic(object, offset, identity, getWordKind());
738     }
739 
740     /**
741      * Reads the value of a given register.
742      *
743      * @param register a register which must not be available to the register allocator
744      * @return the value of {@code register} as a word
745      */
746     public static Word registerAsWord(@ConstantNodeParameter Register register) {
747         return registerAsWord(register, true, false);
748     }
749 
750     @NodeIntrinsic(value = ReadRegisterNode.class)
751     public static native Word registerAsWord(@ConstantNodeParameter Register register, @ConstantNodeParameter boolean directUse, @ConstantNodeParameter boolean incoming);
752 
753     @NodeIntrinsic(value = WriteRegisterNode.class)
754     public static native void writeRegisterAsWord(@ConstantNodeParameter Register register, Word value);
755 
756     @NodeIntrinsic(value = RawLoadNode.class)
757     private static native Word loadWordFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
758 
759     @NodeIntrinsic(value = RawLoadNode.class)
760     private static native KlassPointer loadKlassFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
761 
762     @NodeIntrinsic(value = LoadHubNode.class)
763     public static native KlassPointer loadHubIntrinsic(Object object);
764 
765     public static final LocationIdentity CLASS_STATE_LOCATION = NamedLocationIdentity.mutable(&quot;ClassState&quot;);
766 
767     @Fold
768     public static int instanceKlassInitStateOffset(@InjectedParameter GraalHotSpotVMConfig config) {
769         return config.instanceKlassInitStateOffset;
770     }
771 
772     @Fold
773     public static int instanceKlassStateFullyInitialized(@InjectedParameter GraalHotSpotVMConfig config) {
774         return config.instanceKlassStateFullyInitialized;
775     }
776 
777     /**
778      *
779      * @param hub the hub of an InstanceKlass
780      * @return true is the InstanceKlass represented by hub is fully initialized
781      */
782     public static boolean isInstanceKlassFullyInitialized(KlassPointer hub) {
783         return readInstanceKlassState(hub) == instanceKlassStateFullyInitialized(INJECTED_VMCONFIG);
784     }
785 
786     private static byte readInstanceKlassState(KlassPointer hub) {
787         return hub.readByte(instanceKlassInitStateOffset(INJECTED_VMCONFIG), CLASS_STATE_LOCATION);
788     }
789 
790     public static final LocationIdentity KLASS_MODIFIER_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_modifier_flags&quot;);
791 
792     @Fold
793     public static int klassModifierFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
794         return config.klassModifierFlagsOffset;
795     }
796 
797     public static final LocationIdentity CLASS_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._klass&quot;) {
798         @Override
799         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
800             return foldIndirection(read, object, CLASS_MIRROR_LOCATION);
801         }
802     };
803 
804     public static final LocationIdentity CLASS_ARRAY_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._array_klass&quot;) {
805         @Override
806         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
807             return foldIndirection(read, object, ARRAY_KLASS_COMPONENT_MIRROR);
808         }
809     };
810 
811     @Fold
812     public static int arrayKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
813         return config.arrayKlassOffset;
814     }
815 
816     public static final LocationIdentity CLASS_MIRROR_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror&quot;);
817 
818     public static final LocationIdentity CLASS_MIRROR_HANDLE_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror handle&quot;);
819 
820     @Fold
821     public static int layoutHelperHeaderSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
822         return config.layoutHelperHeaderSizeShift;
823     }
824 
825     @Fold
826     public static int layoutHelperHeaderSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
827         return config.layoutHelperHeaderSizeMask;
828     }
829 
830     @Fold
831     public static int layoutHelperLog2ElementSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
832         return config.layoutHelperLog2ElementSizeShift;
833     }
834 
835     @Fold
836     public static int layoutHelperLog2ElementSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
837         return config.layoutHelperLog2ElementSizeMask;
838     }
839 
840     @NodeIntrinsic(ForeignCallNode.class)
841     public static native int identityHashCode(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
842 
843     @Fold
844     public static long gcTotalCollectionsAddress(@InjectedParameter GraalHotSpotVMConfig config) {
845         return config.gcTotalCollectionsAddress();
846     }
847 
848     @Fold
849     public static long referentOffset(@InjectedParameter MetaAccessProvider metaAccessProvider) {
850         return getFieldOffset(metaAccessProvider.lookupJavaType(Reference.class), &quot;referent&quot;);
851     }
852 
853     public static final LocationIdentity OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;ObjArrayKlass::_element_klass&quot;) {
854         @Override
855         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
856             ValueNode javaObject = findReadHub(object);
857             if (javaObject != null) {
858                 ResolvedJavaType type = StampTool.typeOrNull(javaObject);
859                 if (type != null &amp;&amp; type.isArray()) {
860                     ResolvedJavaType element = type.getComponentType();
861                     if (element != null &amp;&amp; !element.isPrimitive() &amp;&amp; !element.getElementalType().isInterface()) {
862                         Assumptions assumptions = object.graph().getAssumptions();
863                         AssumptionResult&lt;ResolvedJavaType&gt; leafType = element.findLeafConcreteSubtype();
864                         if (leafType != null &amp;&amp; leafType.canRecordTo(assumptions)) {
865                             leafType.recordTo(assumptions);
866                             return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(leafType.getResult()), tool.getMetaAccess());
867                         }
868                     }
869                 }
870             }
871             return read;
872         }
873     };
874 
875     @Fold
876     public static int arrayClassElementOffset(@InjectedParameter GraalHotSpotVMConfig config) {
877         return config.arrayClassElementOffset;
878     }
879 
880     public static final LocationIdentity PRIMARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;PrimarySupers&quot;);
881 
882     public static final LocationIdentity METASPACE_ARRAY_LENGTH_LOCATION = NamedLocationIdentity.immutable(&quot;MetaspaceArrayLength&quot;);
883 
884     public static final LocationIdentity SECONDARY_SUPERS_ELEMENT_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupersElement&quot;);
885 }
    </pre>
  </body>
</html>
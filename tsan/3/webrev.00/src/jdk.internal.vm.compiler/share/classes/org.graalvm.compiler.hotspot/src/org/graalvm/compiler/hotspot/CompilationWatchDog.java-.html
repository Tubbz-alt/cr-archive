<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationWatchDog.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static org.graalvm.compiler.hotspot.HotSpotGraalCompiler.fmt;
 28 
 29 import java.util.Arrays;
 30 
 31 import org.graalvm.compiler.debug.TTY;
 32 import org.graalvm.compiler.options.Option;
 33 import org.graalvm.compiler.options.OptionKey;
 34 import org.graalvm.compiler.options.OptionType;
 35 import org.graalvm.compiler.options.OptionValues;
 36 
 37 import jdk.vm.ci.meta.ResolvedJavaMethod;
 38 
 39 /**
 40  * A watch dog for reporting long running compilations. This is designed to be an always on
 41  * mechanism for the purpose of getting better reports from customer sites. As such, it only exits
 42  * the VM when it is very sure about a stuck compilation as opposed to only observing a long running
 43  * compilation. In both cases, it logs messages to {@link TTY}.
 44  *
 45  * A watch dog thread is associated with each compiler thread. It wakes up every
 46  * {@value #SPIN_TIMEOUT_MS} milliseconds to observe the state of the compiler thread. After the
 47  * first {@link Options#CompilationWatchDogStartDelay} seconds of a specific compilation, the watch
 48  * dog reports a long running compilation. Every
 49  * {@link Options#CompilationWatchDogStackTraceInterval} seconds after that point in time where the
 50  * same compilation is still executing, the watch dog takes a stack trace of the compiler thread. If
 51  * more than {@value Options#NonFatalIdenticalCompilationSnapshots} contiguous identical stack
 52  * traces are seen, the watch dog reports a stuck compilation and exits the VM.
 53  */
 54 class CompilationWatchDog extends Thread implements AutoCloseable {
 55 
 56     public static class Options {
 57         // @formatter:off
 58         @Option(help = &quot;Delay in seconds before watch dog monitoring a compilation (0 disables monitoring).&quot;, type = OptionType.Debug)
 59         public static final OptionKey&lt;Double&gt; CompilationWatchDogStartDelay = new OptionKey&lt;&gt;(0.0D);
 60         @Option(help = &quot;Interval in seconds between a watch dog reporting stack traces for long running compilations.&quot;, type = OptionType.Debug)
 61         public static final OptionKey&lt;Double&gt; CompilationWatchDogStackTraceInterval = new OptionKey&lt;&gt;(60.0D);
 62         @Option(help = &quot;Number of contiguous identical compiler thread stack traces allowed before the VM exits &quot; +
 63                        &quot;on the basis of a stuck compilation.&quot;, type = OptionType.Debug)
 64         public static final OptionKey&lt;Integer&gt; NonFatalIdenticalCompilationSnapshots = new OptionKey&lt;&gt;(20);
 65         // @formatter:on
 66     }
 67 
 68     private enum WatchDogState {
 69         /**
 70          * The watch dog thread sleeps currently, either no method is currently compiled, or no
 71          * method is compiled long enough to be monitored.
 72          */
 73         SLEEPING,
 74         /**
 75          * The watch dog thread identified a compilation that already takes long enough to be
 76          * interesting. It will sleep and wake up periodically and check if the current compilation
 77          * takes too long. If it takes too long it will start collecting stack traces from the
 78          * compiler thread.
 79          */
 80         WATCHING_WITHOUT_STACK_INSPECTION,
 81         /**
 82          * The watch dog thread is fully monitoring the compiler thread. It takes stack traces
 83          * periodically and sleeps again until the next period. If the number of stack traces
 84          * reaches a certain upper bound and those stack traces are equal it will shut down the
 85          * entire VM with an error.
 86          */
 87         WATCHING_WITH_STACK_INSPECTION
 88     }
 89 
 90     /**
 91      * The number of milliseconds a watch dog thread sleeps between observing the state of the
 92      * compilation thread it is associated with. Most compilations are expected to complete within
 93      * this time period and thus not be actively monitored by the watch dog.
 94      */
 95     private static final int SPIN_TIMEOUT_MS = 1000;
 96 
 97     private WatchDogState state = WatchDogState.SLEEPING;
 98     private final Thread compilerThread;
 99     private final long startDelayMilliseconds;
100     private final long stackTraceIntervalMilliseconds;
101     private final int nonFatalIdenticalCompilationSnapshots;
102     private volatile ResolvedJavaMethod currentMethod;
103     private volatile int currentId;
104     private ResolvedJavaMethod lastWatched;
105 
106     // The 4 fields below are for a single compilation being watched
107     private long elapsed;
108     private int traceIntervals;
109     private int numberOfIdenticalStackTraces;
110     private StackTraceElement[] lastStackTrace;
111 
112     CompilationWatchDog(Thread compilerThread, long startDelayMilliseconds, long stackTraceIntervalMilliseconds, int nonFatalIdenticalCompilationSnapshots) {
113         this.compilerThread = compilerThread;
114         this.setName(&quot;WatchDog&quot; + getId() + &quot;[&quot; + compilerThread.getName() + &quot;]&quot;);
115         this.setPriority(Thread.MAX_PRIORITY);
116         this.setDaemon(true);
117         this.startDelayMilliseconds = startDelayMilliseconds;
118         this.stackTraceIntervalMilliseconds = stackTraceIntervalMilliseconds;
119         this.nonFatalIdenticalCompilationSnapshots = nonFatalIdenticalCompilationSnapshots;
120     }
121 
122     public void startCompilation(ResolvedJavaMethod method, int id) {
123         trace(&quot;start %s&quot;, fmt(method));
124         this.currentMethod = method;
125         this.currentId = id;
126     }
127 
128     public void stopCompilation() {
129         trace(&quot; stop %s&quot;, fmt(currentMethod));
130         this.currentMethod = null;
131     }
132 
133     private void reset() {
134         elapsed = 0;
135         traceIntervals = 0;
136         numberOfIdenticalStackTraces = 0;
137         lastWatched = null;
138         lastStackTrace = null;
139         state = WatchDogState.SLEEPING;
140     }
141 
142     private void tick(WatchDogState newState) {
143         state = newState;
144     }
145 
146     /**
147      * Saves the current stack trace {@link StackTraceElement} of the monitored compiler thread
148      * {@link CompilationWatchDog#compilerThread}.
149      *
150      * @param newStackTrace the current stack trace of the monitored compiler thread
151      * @return {@code true} if the stack trace is equal to the last stack trace (or if it is the
152      *         first one) and {@code false} if it is not equal to the last one.
153      */
154     private boolean recordStackTrace(StackTraceElement[] newStackTrace) {
155         if (lastStackTrace == null) {
156             lastStackTrace = newStackTrace;
157             return true;
158         }
159         if (!Arrays.equals(lastStackTrace, newStackTrace)) {
160             lastStackTrace = newStackTrace;
161             return false;
162         }
163         return true;
164     }
165 
166     /**
167      * Set to true to debug the watch dog.
168      */
169     private static final boolean DEBUG = Boolean.getBoolean(&quot;debug.graal.CompilationWatchDog&quot;);
170 
171     private void trace(String format, Object... args) {
172         if (DEBUG) {
173             TTY.println(this + &quot;: &quot; + String.format(format, args));
174         }
175     }
176 
177     private static long ms(double seconds) {
178         return (long) seconds * 1000;
179     }
180 
181     private static double secs(long ms) {
182         return (double) ms / 1000;
183     }
184 
185     @Override
186     public String toString() {
187         return getName();
188     }
189 
190     @Override
191     public void run() {
192         try {
193             trace(&quot;Started%n&quot;, this);
194             while (true) {
195                 // get a copy of the last set method
196                 final ResolvedJavaMethod currentlyCompiling = currentMethod;
197                 if (currentlyCompiling == null) {
198                     // continue sleeping, compilation is either over before starting
199                     // to watch the compiler thread or no compilation at all started
200                     reset();
201                 } else {
202                     switch (state) {
203                         case SLEEPING:
204                             lastWatched = currentlyCompiling;
205                             elapsed = 0;
206                             tick(WatchDogState.WATCHING_WITHOUT_STACK_INSPECTION);
207                             break;
208                         case WATCHING_WITHOUT_STACK_INSPECTION:
209                             if (currentlyCompiling.equals(lastWatched)) {
210                                 if (elapsed &gt;= startDelayMilliseconds) {
211                                     // we looked at the same compilation for a certain time
212                                     // so now we start to collect stack traces
213                                     tick(WatchDogState.WATCHING_WITH_STACK_INSPECTION);
214                                     trace(&quot;changes mode to watching with stack traces&quot;);
215                                 } else {
216                                     // we still compile the same method but won&#39;t collect traces
217                                     // yet
218                                     trace(&quot;watching without stack traces [%.2f seconds]&quot;, secs(elapsed));
219                                 }
220                                 elapsed += SPIN_TIMEOUT_MS;
221                             } else {
222                                 // compilation finished before we exceeded initial watching
223                                 // period
224                                 reset();
225                             }
226                             break;
227                         case WATCHING_WITH_STACK_INSPECTION:
228                             if (currentlyCompiling.equals(lastWatched)) {
229                                 if (elapsed &gt;= startDelayMilliseconds + (traceIntervals * stackTraceIntervalMilliseconds)) {
230                                     trace(&quot;took a stack trace&quot;);
231                                     boolean newStackTrace = recordStackTrace(compilerThread.getStackTrace());
232                                     if (!newStackTrace) {
233                                         trace(&quot;%d identical stack traces in a row&quot;, numberOfIdenticalStackTraces);
234                                         numberOfIdenticalStackTraces = 0;
235                                     }
236                                     numberOfIdenticalStackTraces++;
237                                     if (numberOfIdenticalStackTraces &gt; nonFatalIdenticalCompilationSnapshots) {
238                                         synchronized (CompilationWatchDog.class) {
239                                             TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
240                                                             &quot;%s took %d identical stack traces, which indicates a stuck compilation (id=%d) of %s%n%sExiting VM%n&quot;, this,
241                                                             numberOfIdenticalStackTraces, currentId, fmt(currentMethod), fmt(lastStackTrace));
242                                             System.exit(-1);
243                                         }
244                                     } else if (newStackTrace) {
245                                         synchronized (CompilationWatchDog.class) {
246                                             TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
247                                                             &quot;%s detected long running compilation (id=%d) of %s [%.2f seconds]%n%s&quot;, this, currentId, fmt(currentMethod),
248                                                             secs(elapsed), fmt(lastStackTrace));
249                                         }
250                                     }
251                                     traceIntervals++;
252                                 } else {
253                                     // we still watch the compilation in the same trace interval
254                                     trace(&quot;watching with stack traces [%.2f seconds]&quot;, secs(elapsed));
255                                 }
256                                 elapsed += SPIN_TIMEOUT_MS;
257                             } else {
258                                 // compilation finished before we are able to collect stack
259                                 // traces
260                                 reset();
261                             }
262                             break;
263                         default:
264                             break;
265                     }
266                 }
267                 try {
268                     Thread.sleep(SPIN_TIMEOUT_MS);
269                 } catch (InterruptedException e) {
270                     // Silently swallow
271                 }
272             }
273         } catch (VirtualMachineError vmError) {
274             /*
275              * We encounter a VM error. This includes for example OutOfMemoryExceptions. In such a
276              * case we silently swallow the error. If it happens again the application thread will
277              * most likely encounter the same problem. If not the watchdog thread will no longer
278              * monitor the compilation and thus the error cannot happen again.
279              */
280         } catch (Throwable t) {
281             /*
282              * A real exception happened on the compilation watchdog. This is unintended behavior
283              * and must not happen in any case.
284              */
285             throw new InternalError(String.format(&quot;%s encountered an exception%n%s%n&quot;, this, fmt(t)), t);
286         }
287     }
288 
289     private static final ThreadLocal&lt;CompilationWatchDog&gt; WATCH_DOGS = new ThreadLocal&lt;&gt;();
290 
291     /**
292      * Opens a scope for watching the compilation of a given method.
293      *
294      * @param method a method about to be compiled
295      * @param id compilation request identifier
296      * @return {@code null} if the compilation watch dog is disabled otherwise this object. The
297      *         returned value should be used in a {@code try}-with-resources statement whose scope
298      *         is the whole compilation so that leaving the scope will cause {@link #close()} to be
299      *         called.
300      */
301     static CompilationWatchDog watch(ResolvedJavaMethod method, int id, OptionValues options) {
302         long startDelayMilliseconds = ms(Options.CompilationWatchDogStartDelay.getValue(options));
303         if (startDelayMilliseconds &gt; 0.0D) {
304             // Lazily get a watch dog thread for the current compiler thread
305             CompilationWatchDog watchDog = WATCH_DOGS.get();
306             if (watchDog == null) {
307                 Thread currentThread = currentThread();
308                 long stackTraceIntervalMilliseconds = ms(Options.CompilationWatchDogStackTraceInterval.getValue(options));
309                 int nonFatalIdenticalCompilationSnapshots = Options.NonFatalIdenticalCompilationSnapshots.getValue(options);
310                 watchDog = new CompilationWatchDog(currentThread, startDelayMilliseconds, stackTraceIntervalMilliseconds, nonFatalIdenticalCompilationSnapshots);
311                 WATCH_DOGS.set(watchDog);
312                 watchDog.start();
313             }
314             watchDog.startCompilation(method, id);
315             return watchDog;
316         }
317         return null;
318     }
319 
320     @Override
321     public void close() {
322         stopCompilation();
323     }
324 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotForeignCallLinkage.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotDebugInfoBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotForeignCallLinkageImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotForeignCallLinkage.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
<span class="line-removed"> 27 import jdk.vm.ci.meta.InvokeTarget;</span>
<span class="line-removed"> 28 </span>
 29 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 30 import org.graalvm.compiler.core.target.Backend;
 31 import org.graalvm.compiler.hotspot.stubs.Stub;
 32 import jdk.internal.vm.compiler.word.LocationIdentity;
 33 


 34 /**
 35  * The details required to link a HotSpot runtime or stub call.
 36  */
 37 public interface HotSpotForeignCallLinkage extends ForeignCallLinkage, InvokeTarget {
 38 
 39     /**
 40      * Constants for specifying whether a foreign call destroys or preserves registers. A foreign
 41      * call will always destroy {@link HotSpotForeignCallLinkage#getOutgoingCallingConvention() its}
 42      * {@linkplain ForeignCallLinkage#getTemporaries() temporary} registers.
 43      */
 44     enum RegisterEffect {
<span class="line-modified"> 45         DESTROYS_REGISTERS,</span>
<span class="line-modified"> 46         PRESERVES_REGISTERS</span>
 47     }
 48 
 49     /**
 50      * Constants for specifying whether a call is a leaf or not and whether a
 51      * {@code JavaFrameAnchor} prologue and epilogue is required around the call. A leaf function
 52      * does not lock, GC or throw exceptions.
 53      */
 54     enum Transition {
 55         /**
<span class="line-modified"> 56          * A call to a leaf function that is guaranteed to not use floating point registers and will</span>
<span class="line-modified"> 57          * never have its caller stack inspected by the VM. That is, {@code JavaFrameAnchor}</span>
<span class="line-modified"> 58          * management around the call can be omitted.</span>



 59          */
<span class="line-modified"> 60         LEAF_NOFP,</span>
 61 
 62         /**
 63          * A call to a leaf function that might use floating point registers but will never have its
 64          * caller stack inspected. That is, {@code JavaFrameAnchor} management around the call can
 65          * be omitted.
 66          */
 67         LEAF,
 68 
 69         /**
 70          * A call to a leaf function that might use floating point registers and may have its caller
 71          * stack inspected. That is, {@code JavaFrameAnchor} management code around the call is
 72          * required.
 73          */
 74         STACK_INSPECTABLE_LEAF,
 75 
 76         /**
 77          * A function that may lock, GC or raise an exception and thus requires debug info to be
 78          * associated with a call site to the function. The execution stack may be inspected while
 79          * in the called function. That is, {@code JavaFrameAnchor} management code around the call
 80          * is required.
 81          */
 82         SAFEPOINT,
 83     }
 84 
 85     /**
 86      * Constants specifying when a foreign call or stub call is re-executable.
 87      */
 88     enum Reexecutability {
 89         /**
 90          * Denotes a call that cannot be re-executed. If an exception is raised, the call is
 91          * deoptimized and the exception is passed on to be dispatched. If the call can throw an
 92          * exception it needs to have a precise frame state.
 93          */
 94         NOT_REEXECUTABLE,
 95 
<span class="line-removed"> 96         /**</span>
<span class="line-removed"> 97          * Denotes a call that can only be re-executed if it returns with a pending exception. This</span>
<span class="line-removed"> 98          * type of call models a function that may throw exceptions before any side effects happen.</span>
<span class="line-removed"> 99          * In this case if an exception is raised the call may be deoptimized and reexecuted. It</span>
<span class="line-removed">100          * also means that while the call has side effects and may deoptimize it doesn&#39;t necessarily</span>
<span class="line-removed">101          * need to have a precise frame state.</span>
<span class="line-removed">102          */</span>
<span class="line-removed">103         REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
<span class="line-removed">104 </span>
105         /**
106          * Denotes a call that can always be re-executed. If an exception is raised by the call it
107          * may be cleared, compiled code deoptimized and reexecuted. Since the call has no side
108          * effects it is assumed that the same exception will be thrown.
109          */
110         REEXECUTABLE
111     }
112 
113     /**
114      * Sentinel marker for a computed jump address.
115      */
116     long JUMP_ADDRESS = 0xDEADDEADBEEFBEEFL;
117 
118     /**
119      * Determines if the call has side effects.
120      */
121     boolean isReexecutable();
122 
<span class="line-removed">123     /**</span>
<span class="line-removed">124      * Determines if the call returning a pending exception implies it is side-effect free.</span>
<span class="line-removed">125      */</span>
<span class="line-removed">126     boolean isReexecutableOnlyAfterException();</span>
<span class="line-removed">127 </span>
128     LocationIdentity[] getKilledLocations();
129 
130     void setCompiledStub(Stub stub);
131 


132     /**
133      * Determines if this is a call to a compiled {@linkplain Stub stub}.
134      */
135     boolean isCompiledStub();
136 
137     /**
138      * Gets the stub, if any, this foreign call links to.
139      */
140     Stub getStub();
141 
142     void finalizeAddress(Backend backend);
143 
144     long getAddress();
145 
146     /**
147      * Determines if the runtime function or stub might use floating point registers. If the answer
148      * is no, then no FPU state management prologue or epilogue needs to be emitted around the call.
149      */
150     boolean mayContainFP();
151 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 


 27 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 28 import org.graalvm.compiler.core.target.Backend;
 29 import org.graalvm.compiler.hotspot.stubs.Stub;
 30 import jdk.internal.vm.compiler.word.LocationIdentity;
 31 
<span class="line-added"> 32 import jdk.vm.ci.meta.InvokeTarget;</span>
<span class="line-added"> 33 </span>
 34 /**
 35  * The details required to link a HotSpot runtime or stub call.
 36  */
 37 public interface HotSpotForeignCallLinkage extends ForeignCallLinkage, InvokeTarget {
 38 
 39     /**
 40      * Constants for specifying whether a foreign call destroys or preserves registers. A foreign
 41      * call will always destroy {@link HotSpotForeignCallLinkage#getOutgoingCallingConvention() its}
 42      * {@linkplain ForeignCallLinkage#getTemporaries() temporary} registers.
 43      */
 44     enum RegisterEffect {
<span class="line-modified"> 45         DESTROYS_ALL_CALLER_SAVE_REGISTERS,</span>
<span class="line-modified"> 46         COMPUTES_REGISTERS_KILLED</span>
 47     }
 48 
 49     /**
 50      * Constants for specifying whether a call is a leaf or not and whether a
 51      * {@code JavaFrameAnchor} prologue and epilogue is required around the call. A leaf function
 52      * does not lock, GC or throw exceptions.
 53      */
 54     enum Transition {
 55         /**
<span class="line-modified"> 56          * A call to a leaf function that is guaranteed to not use floating point registers.</span>
<span class="line-modified"> 57          * Consequently, floating point registers cleanup will be waived. On AMD64, this means the</span>
<span class="line-modified"> 58          * compiler will no longer emit vzeroupper instruction around the foreign call, which it</span>
<span class="line-added"> 59          * normally does for unknown foreign calls to avoid potential SSE-AVX transition penalty.</span>
<span class="line-added"> 60          * Besides, this foreign call will never have its caller stack inspected by the VM. That is,</span>
<span class="line-added"> 61          * {@code JavaFrameAnchor} management around the call can be omitted.</span>
 62          */
<span class="line-modified"> 63         LEAF_NO_VZERO,</span>
 64 
 65         /**
 66          * A call to a leaf function that might use floating point registers but will never have its
 67          * caller stack inspected. That is, {@code JavaFrameAnchor} management around the call can
 68          * be omitted.
 69          */
 70         LEAF,
 71 
 72         /**
 73          * A call to a leaf function that might use floating point registers and may have its caller
 74          * stack inspected. That is, {@code JavaFrameAnchor} management code around the call is
 75          * required.
 76          */
 77         STACK_INSPECTABLE_LEAF,
 78 
 79         /**
 80          * A function that may lock, GC or raise an exception and thus requires debug info to be
 81          * associated with a call site to the function. The execution stack may be inspected while
 82          * in the called function. That is, {@code JavaFrameAnchor} management code around the call
 83          * is required.
 84          */
 85         SAFEPOINT,
 86     }
 87 
 88     /**
 89      * Constants specifying when a foreign call or stub call is re-executable.
 90      */
 91     enum Reexecutability {
 92         /**
 93          * Denotes a call that cannot be re-executed. If an exception is raised, the call is
 94          * deoptimized and the exception is passed on to be dispatched. If the call can throw an
 95          * exception it needs to have a precise frame state.
 96          */
 97         NOT_REEXECUTABLE,
 98 









 99         /**
100          * Denotes a call that can always be re-executed. If an exception is raised by the call it
101          * may be cleared, compiled code deoptimized and reexecuted. Since the call has no side
102          * effects it is assumed that the same exception will be thrown.
103          */
104         REEXECUTABLE
105     }
106 
107     /**
108      * Sentinel marker for a computed jump address.
109      */
110     long JUMP_ADDRESS = 0xDEADDEADBEEFBEEFL;
111 
112     /**
113      * Determines if the call has side effects.
114      */
115     boolean isReexecutable();
116 





117     LocationIdentity[] getKilledLocations();
118 
119     void setCompiledStub(Stub stub);
120 
<span class="line-added">121     RegisterEffect getEffect();</span>
<span class="line-added">122 </span>
123     /**
124      * Determines if this is a call to a compiled {@linkplain Stub stub}.
125      */
126     boolean isCompiledStub();
127 
128     /**
129      * Gets the stub, if any, this foreign call links to.
130      */
131     Stub getStub();
132 
133     void finalizeAddress(Backend backend);
134 
135     long getAddress();
136 
137     /**
138      * Determines if the runtime function or stub might use floating point registers. If the answer
139      * is no, then no FPU state management prologue or epilogue needs to be emitted around the call.
140      */
141     boolean mayContainFP();
142 
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotDebugInfoBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotForeignCallLinkageImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/lir/HotSpotZapRegistersPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../debug/BenchmarkCounters.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../meta/AddressLoweringHotSpotSuitesProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/lir/HotSpotZapRegistersPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.lir;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 28 
 29 import java.util.ArrayList;
 30 


 31 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 32 import org.graalvm.compiler.debug.DebugContext;
 33 import org.graalvm.compiler.debug.Indent;
 34 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 35 import org.graalvm.compiler.hotspot.stubs.Stub;
 36 import org.graalvm.compiler.lir.LIR;
<span class="line-removed"> 37 import org.graalvm.compiler.lir.LIRFrameState;</span>
 38 import org.graalvm.compiler.lir.LIRInsertionBuffer;
 39 import org.graalvm.compiler.lir.LIRInstruction;
<span class="line-modified"> 40 import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>

 41 import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool;
 42 import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool.ZapRegistersAfterInstruction;
 43 import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool.ZapStackArgumentSpaceBeforeInstruction;
 44 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 45 import org.graalvm.compiler.lir.phases.PostAllocationOptimizationPhase;
 46 


 47 import jdk.vm.ci.code.TargetDescription;

 48 import jdk.vm.ci.meta.AllocatableValue;
 49 
 50 /**
 51  * Inserts a {@link DiagnosticLIRGeneratorTool#createZapRegisters ZapRegistersOp} after
 52  * {@link ZapRegistersAfterInstruction} for stubs and
 53  * {@link DiagnosticLIRGeneratorTool#zapArgumentSpace ZapArgumentSpaceOp} after
 54  * {@link ZapStackArgumentSpaceBeforeInstruction} for all compiles.
 55  */
 56 public final class HotSpotZapRegistersPhase extends PostAllocationOptimizationPhase {
 57 
 58     @Override
 59     protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PostAllocationOptimizationContext context) {
 60         Stub stub = ((HotSpotLIRGenerationResult) lirGenRes).getStub();
<span class="line-modified"> 61         boolean zapRegisters = stub != null &amp;&amp; !stub.preservesRegisters();</span>
 62         boolean zapStack = false;
<span class="line-modified"> 63         for (AllocatableValue arg : lirGenRes.getCallingConvention().getArguments()) {</span>

 64             if (isStackSlot(arg)) {
 65                 zapStack = true;
 66                 break;
 67             }
 68         }
 69         if (zapRegisters || zapStack) {
 70             LIR lir = lirGenRes.getLIR();
<span class="line-modified"> 71             processLIR(context.diagnosticLirGenTool, (HotSpotLIRGenerationResult) lirGenRes, lir, zapRegisters, zapStack);</span>




 72         }
 73     }
 74 
<span class="line-modified"> 75     private static void processLIR(DiagnosticLIRGeneratorTool diagnosticLirGenTool, HotSpotLIRGenerationResult res, LIR lir, boolean zapRegisters, boolean zapStack) {</span>
 76         LIRInsertionBuffer buffer = new LIRInsertionBuffer();
 77         for (AbstractBlockBase&lt;?&gt; block : lir.codeEmittingOrder()) {
 78             if (block != null) {
<span class="line-modified"> 79                 processBlock(diagnosticLirGenTool, res, lir, buffer, block, zapRegisters, zapStack);</span>
 80             }
 81         }
 82     }
 83 
 84     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 85     private static void processBlock(DiagnosticLIRGeneratorTool diagnosticLirGenTool, HotSpotLIRGenerationResult res, LIR lir, LIRInsertionBuffer buffer, AbstractBlockBase&lt;?&gt; block,</span>
 86                     boolean zapRegisters, boolean zapStack) {
 87         DebugContext debug = lir.getDebug();
 88         try (Indent indent = debug.logAndIndent(&quot;Process block %s&quot;, block)) {
 89             ArrayList&lt;LIRInstruction&gt; instructions = lir.getLIRforBlock(block);
 90             buffer.init(instructions);
 91             for (int index = 0; index &lt; instructions.size(); index++) {
 92                 LIRInstruction inst = instructions.get(index);
 93                 if (zapStack &amp;&amp; inst instanceof ZapStackArgumentSpaceBeforeInstruction) {
 94                     LIRInstruction zap = diagnosticLirGenTool.zapArgumentSpace();
 95                     if (zap != null) {
 96                         buffer.append(index, zap);
 97                     }
 98                 }
 99                 if (zapRegisters &amp;&amp; inst instanceof ZapRegistersAfterInstruction) {
<span class="line-modified">100                     LIRFrameState state = getLIRState(inst);</span>
<span class="line-modified">101                     if (state != null) {</span>
<span class="line-modified">102                         SaveRegistersOp zap = diagnosticLirGenTool.createZapRegisters();</span>
<span class="line-modified">103                         SaveRegistersOp old = res.getCalleeSaveInfo().put(state, zap);</span>
<span class="line-modified">104                         assert old == null : &quot;Already another SaveRegisterOp registered! &quot; + old;</span>
<span class="line-modified">105                         buffer.append(index + 1, (LIRInstruction) zap);</span>
<span class="line-modified">106                         debug.log(&quot;Insert ZapRegister after %s&quot;, inst);</span>
<span class="line-modified">107                     }</span>













108                 }
109             }
110             buffer.finish();
111         }
112     }
<span class="line-removed">113 </span>
<span class="line-removed">114     /**</span>
<span class="line-removed">115      * Returns the {@link LIRFrameState} of an instruction.</span>
<span class="line-removed">116      */</span>
<span class="line-removed">117     private static LIRFrameState getLIRState(LIRInstruction inst) {</span>
<span class="line-removed">118         final LIRFrameState[] lirState = {null};</span>
<span class="line-removed">119         inst.forEachState(state -&gt; {</span>
<span class="line-removed">120             assert lirState[0] == null : &quot;Multiple states: &quot; + inst;</span>
<span class="line-removed">121             lirState[0] = state;</span>
<span class="line-removed">122         });</span>
<span class="line-removed">123         assert lirState[0] != null : &quot;No state: &quot; + inst;</span>
<span class="line-removed">124         return lirState[0];</span>
<span class="line-removed">125     }</span>
<span class="line-removed">126 </span>
127 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.lir;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 28 
 29 import java.util.ArrayList;
 30 
<span class="line-added"> 31 import jdk.internal.vm.compiler.collections.EconomicSet;</span>
<span class="line-added"> 32 import jdk.internal.vm.compiler.collections.Equivalence;</span>
 33 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 34 import org.graalvm.compiler.debug.DebugContext;
 35 import org.graalvm.compiler.debug.Indent;
 36 import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
 37 import org.graalvm.compiler.hotspot.stubs.Stub;
 38 import org.graalvm.compiler.lir.LIR;

 39 import org.graalvm.compiler.lir.LIRInsertionBuffer;
 40 import org.graalvm.compiler.lir.LIRInstruction;
<span class="line-modified"> 41 import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;</span>
<span class="line-added"> 42 import org.graalvm.compiler.lir.ValueConsumer;</span>
 43 import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool;
 44 import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool.ZapRegistersAfterInstruction;
 45 import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool.ZapStackArgumentSpaceBeforeInstruction;
 46 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 47 import org.graalvm.compiler.lir.phases.PostAllocationOptimizationPhase;
 48 
<span class="line-added"> 49 import jdk.vm.ci.code.CallingConvention;</span>
<span class="line-added"> 50 import jdk.vm.ci.code.Register;</span>
 51 import jdk.vm.ci.code.TargetDescription;
<span class="line-added"> 52 import jdk.vm.ci.code.ValueUtil;</span>
 53 import jdk.vm.ci.meta.AllocatableValue;
 54 
 55 /**
 56  * Inserts a {@link DiagnosticLIRGeneratorTool#createZapRegisters ZapRegistersOp} after
 57  * {@link ZapRegistersAfterInstruction} for stubs and
 58  * {@link DiagnosticLIRGeneratorTool#zapArgumentSpace ZapArgumentSpaceOp} after
 59  * {@link ZapStackArgumentSpaceBeforeInstruction} for all compiles.
 60  */
 61 public final class HotSpotZapRegistersPhase extends PostAllocationOptimizationPhase {
 62 
 63     @Override
 64     protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PostAllocationOptimizationContext context) {
 65         Stub stub = ((HotSpotLIRGenerationResult) lirGenRes).getStub();
<span class="line-modified"> 66         boolean zapRegisters = stub == null;</span>
 67         boolean zapStack = false;
<span class="line-modified"> 68         CallingConvention callingConvention = lirGenRes.getCallingConvention();</span>
<span class="line-added"> 69         for (AllocatableValue arg : callingConvention.getArguments()) {</span>
 70             if (isStackSlot(arg)) {
 71                 zapStack = true;
 72                 break;
 73             }
 74         }
 75         if (zapRegisters || zapStack) {
 76             LIR lir = lirGenRes.getLIR();
<span class="line-modified"> 77             EconomicSet&lt;Register&gt; allocatableRegisters = EconomicSet.create(Equivalence.IDENTITY);</span>
<span class="line-added"> 78             for (Register r : lirGenRes.getFrameMap().getRegisterConfig().getAllocatableRegisters()) {</span>
<span class="line-added"> 79                 allocatableRegisters.add(r);</span>
<span class="line-added"> 80             }</span>
<span class="line-added"> 81             processLIR(context.diagnosticLirGenTool, lir, allocatableRegisters, zapRegisters, zapStack);</span>
 82         }
 83     }
 84 
<span class="line-modified"> 85     private static void processLIR(DiagnosticLIRGeneratorTool diagnosticLirGenTool, LIR lir, EconomicSet&lt;Register&gt; allocatableRegisters, boolean zapRegisters, boolean zapStack) {</span>
 86         LIRInsertionBuffer buffer = new LIRInsertionBuffer();
 87         for (AbstractBlockBase&lt;?&gt; block : lir.codeEmittingOrder()) {
 88             if (block != null) {
<span class="line-modified"> 89                 processBlock(diagnosticLirGenTool, lir, allocatableRegisters, buffer, block, zapRegisters, zapStack);</span>
 90             }
 91         }
 92     }
 93 
 94     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 95     private static void processBlock(DiagnosticLIRGeneratorTool diagnosticLirGenTool, LIR lir, EconomicSet&lt;Register&gt; allocatableRegisters, LIRInsertionBuffer buffer, AbstractBlockBase&lt;?&gt; block,</span>
 96                     boolean zapRegisters, boolean zapStack) {
 97         DebugContext debug = lir.getDebug();
 98         try (Indent indent = debug.logAndIndent(&quot;Process block %s&quot;, block)) {
 99             ArrayList&lt;LIRInstruction&gt; instructions = lir.getLIRforBlock(block);
100             buffer.init(instructions);
101             for (int index = 0; index &lt; instructions.size(); index++) {
102                 LIRInstruction inst = instructions.get(index);
103                 if (zapStack &amp;&amp; inst instanceof ZapStackArgumentSpaceBeforeInstruction) {
104                     LIRInstruction zap = diagnosticLirGenTool.zapArgumentSpace();
105                     if (zap != null) {
106                         buffer.append(index, zap);
107                     }
108                 }
109                 if (zapRegisters &amp;&amp; inst instanceof ZapRegistersAfterInstruction) {
<span class="line-modified">110                     final EconomicSet&lt;Register&gt; destroyedRegisters = EconomicSet.create(Equivalence.IDENTITY);</span>
<span class="line-modified">111                     ValueConsumer tempConsumer = (value, mode, flags) -&gt; {</span>
<span class="line-modified">112                         if (ValueUtil.isRegister(value)) {</span>
<span class="line-modified">113                             final Register reg = ValueUtil.asRegister(value);</span>
<span class="line-modified">114                             if (allocatableRegisters.contains(reg)) {</span>
<span class="line-modified">115                                 destroyedRegisters.add(reg);</span>
<span class="line-modified">116                             }</span>
<span class="line-modified">117                         }</span>
<span class="line-added">118                     };</span>
<span class="line-added">119                     ValueConsumer defConsumer = (value, mode, flags) -&gt; {</span>
<span class="line-added">120                         if (ValueUtil.isRegister(value)) {</span>
<span class="line-added">121                             final Register reg = ValueUtil.asRegister(value);</span>
<span class="line-added">122                             destroyedRegisters.remove(reg);</span>
<span class="line-added">123                         }</span>
<span class="line-added">124                     };</span>
<span class="line-added">125                     inst.visitEachTemp(tempConsumer);</span>
<span class="line-added">126                     inst.visitEachOutput(defConsumer);</span>
<span class="line-added">127 </span>
<span class="line-added">128                     ZapRegistersOp zap = diagnosticLirGenTool.createZapRegisters(destroyedRegisters.toArray(new Register[destroyedRegisters.size()]));</span>
<span class="line-added">129                     buffer.append(index + 1, (LIRInstruction) zap);</span>
<span class="line-added">130                     debug.log(&quot;Insert ZapRegister after %s&quot;, inst);</span>
131                 }
132             }
133             buffer.finish();
134         }
135     }














136 }
</pre>
</td>
</tr>
</table>
<center><a href="../debug/BenchmarkCounters.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../meta/AddressLoweringHotSpotSuitesProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraalHotSpotVMConfigVersioned.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotBackendFactory.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotBackend.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 59,10 ***</span>
<span class="line-new-header">--- 59,11 ---</span>
  import org.graalvm.compiler.lir.LIRFrameState;
  import org.graalvm.compiler.lir.LIRInstruction;
  import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
  import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
  import org.graalvm.compiler.lir.StandardOp.LabelOp;
<span class="line-added">+ import org.graalvm.compiler.lir.StandardOp.RestoreRegistersOp;</span>
  import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;
  import org.graalvm.compiler.lir.ValueConsumer;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  import org.graalvm.compiler.lir.framemap.FrameMap;
  import org.graalvm.compiler.nodes.UnwindNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,19 ***</span>
  import org.graalvm.compiler.phases.tiers.SuitesProvider;
  import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
  import org.graalvm.compiler.word.Word;
  import jdk.internal.vm.compiler.word.Pointer;
  
  import jdk.vm.ci.code.CompilationRequest;
  import jdk.vm.ci.code.CompiledCode;
  import jdk.vm.ci.code.Register;
<span class="line-removed">- import jdk.vm.ci.code.RegisterSaveLayout;</span>
  import jdk.vm.ci.code.StackSlot;
  import jdk.vm.ci.code.ValueUtil;
  import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.Value;
  import jdk.vm.ci.runtime.JVMCICompiler;
  
  /**
<span class="line-new-header">--- 75,20 ---</span>
  import org.graalvm.compiler.phases.tiers.SuitesProvider;
  import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
  import org.graalvm.compiler.word.Word;
  import jdk.internal.vm.compiler.word.Pointer;
  
<span class="line-added">+ import jdk.vm.ci.code.CallingConvention;</span>
  import jdk.vm.ci.code.CompilationRequest;
  import jdk.vm.ci.code.CompiledCode;
  import jdk.vm.ci.code.Register;
  import jdk.vm.ci.code.StackSlot;
  import jdk.vm.ci.code.ValueUtil;
  import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
<span class="line-added">+ import jdk.vm.ci.meta.AllocatableValue;</span>
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.Value;
  import jdk.vm.ci.runtime.JVMCICompiler;
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,11 ***</span>
  public abstract class HotSpotBackend extends Backend implements FrameMap.ReferenceMapBuilderFactory {
  
      public static class Options {
          // @formatter:off
          @Option(help = &quot;Use Graal arithmetic stubs instead of HotSpot stubs where possible&quot;)
<span class="line-modified">!         public static final OptionKey&lt;Boolean&gt; GraalArithmeticStubs = new OptionKey&lt;&gt;(JavaVersionUtil.JAVA_SPECIFICATION_VERSION &gt;= 9);</span>
          @Option(help = &quot;Enables instruction profiling on assembler level. Valid values are a comma separated list of supported instructions.&quot; +
                          &quot; Compare with subclasses of Assembler.InstructionCounter.&quot;, type = OptionType.Debug)
          public static final OptionKey&lt;String&gt; ASMInstructionProfiling = new OptionKey&lt;&gt;(null);
          // @formatter:on
      }
<span class="line-new-header">--- 97,11 ---</span>
  public abstract class HotSpotBackend extends Backend implements FrameMap.ReferenceMapBuilderFactory {
  
      public static class Options {
          // @formatter:off
          @Option(help = &quot;Use Graal arithmetic stubs instead of HotSpot stubs where possible&quot;)
<span class="line-modified">!         public static final OptionKey&lt;Boolean&gt; GraalArithmeticStubs = new OptionKey&lt;&gt;(JavaVersionUtil.JAVA_SPEC &gt;= 9);</span>
          @Option(help = &quot;Enables instruction profiling on assembler level. Valid values are a comma separated list of supported instructions.&quot; +
                          &quot; Compare with subclasses of Assembler.InstructionCounter.&quot;, type = OptionType.Debug)
          public static final OptionKey&lt;String&gt; ASMInstructionProfiling = new OptionKey&lt;&gt;(null);
          // @formatter:on
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 303,10 ***</span>
<span class="line-new-header">--- 305,15 ---</span>
      /**
       * Descriptor for {@code StubRoutines::_ghash_processBlocks}.
       */
      public static final ForeignCallDescriptor GHASH_PROCESS_BLOCKS = new ForeignCallDescriptor(&quot;ghashProcessBlocks&quot;, void.class, Word.class, Word.class, Word.class, int.class);
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Descriptor for {@code StubRoutines::_base64_encodeBlock}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static final ForeignCallDescriptor BASE64_ENCODE_BLOCK = new ForeignCallDescriptor(&quot;base64EncodeBlock&quot;, void.class, Word.class, int.class, int.class, Word.class, int.class, boolean.class);</span>
<span class="line-added">+ </span>
      /**
       * Descriptor for {@code StubRoutines::_counterMode_AESCrypt}.
       */
      public static final ForeignCallDescriptor COUNTERMODE_IMPL_CRYPT = new ForeignCallDescriptor(&quot;counterModeAESCrypt&quot;, int.class, Word.class, Word.class, Word.class, Word.class, int.class,
                      Word.class, Word.class);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 418,37 ***</span>
      }
  
      /**
       * Finds all the registers that are defined by some given LIR.
       *
<span class="line-modified">!      * @param lir the LIR to examine</span>
       * @return the registers that are defined by or used as temps for any instruction in {@code lir}
       */
<span class="line-modified">!     protected final EconomicSet&lt;Register&gt; gatherDestroyedCallerRegisters(LIR lir) {</span>
          final EconomicSet&lt;Register&gt; destroyedRegisters = EconomicSet.create(Equivalence.IDENTITY);
          ValueConsumer defConsumer = new ValueConsumer() {
  
              @Override
              public void visitValue(Value value, OperandMode mode, EnumSet&lt;OperandFlag&gt; flags) {
                  if (ValueUtil.isRegister(value)) {
                      final Register reg = ValueUtil.asRegister(value);
<span class="line-modified">!                     destroyedRegisters.add(reg);</span>
                  }
              }
          };
          for (AbstractBlockBase&lt;?&gt; block : lir.codeEmittingOrder()) {
              if (block == null) {
                  continue;
              }
              for (LIRInstruction op : lir.getLIRforBlock(block)) {
                  if (op instanceof LabelOp) {
                      // Don&#39;t consider this as a definition
                  } else {
                      op.visitEachTemp(defConsumer);
                      op.visitEachOutput(defConsumer);
                  }
              }
          }
          return translateToCallerRegisters(destroyedRegisters);
      }
  
      /**
<span class="line-new-header">--- 425,63 ---</span>
      }
  
      /**
       * Finds all the registers that are defined by some given LIR.
       *
<span class="line-modified">!      * @param gen the result to examine</span>
       * @return the registers that are defined by or used as temps for any instruction in {@code lir}
       */
<span class="line-modified">!     private EconomicSet&lt;Register&gt; gatherDestroyedCallerRegisters(HotSpotLIRGenerationResult gen) {</span>
<span class="line-added">+         LIR lir = gen.getLIR();</span>
<span class="line-added">+         final EconomicSet&lt;Register&gt; preservedRegisters = EconomicSet.create(Equivalence.IDENTITY);</span>
          final EconomicSet&lt;Register&gt; destroyedRegisters = EconomicSet.create(Equivalence.IDENTITY);
          ValueConsumer defConsumer = new ValueConsumer() {
  
              @Override
              public void visitValue(Value value, OperandMode mode, EnumSet&lt;OperandFlag&gt; flags) {
                  if (ValueUtil.isRegister(value)) {
                      final Register reg = ValueUtil.asRegister(value);
<span class="line-modified">!                     if (!preservedRegisters.contains(reg)) {</span>
<span class="line-added">+                         destroyedRegisters.add(reg);</span>
<span class="line-added">+                     }</span>
                  }
              }
          };
<span class="line-added">+         boolean sawSaveRegisters = false;</span>
          for (AbstractBlockBase&lt;?&gt; block : lir.codeEmittingOrder()) {
              if (block == null) {
                  continue;
              }
<span class="line-added">+             // Ignore the effects of instructions bracketed by save/restore</span>
<span class="line-added">+             SaveRegistersOp save = null;</span>
              for (LIRInstruction op : lir.getLIRforBlock(block)) {
                  if (op instanceof LabelOp) {
                      // Don&#39;t consider this as a definition
<span class="line-added">+                 } else if (op instanceof SaveRegistersOp) {</span>
<span class="line-added">+                     save = (SaveRegistersOp) op;</span>
<span class="line-added">+                     sawSaveRegisters = true;</span>
<span class="line-added">+                     preservedRegisters.addAll(save.getSaveableRegisters());</span>
<span class="line-added">+                 } else if (op instanceof RestoreRegistersOp) {</span>
<span class="line-added">+                     save = null;</span>
<span class="line-added">+                     preservedRegisters.clear();</span>
                  } else {
                      op.visitEachTemp(defConsumer);
                      op.visitEachOutput(defConsumer);
                  }
              }
<span class="line-added">+             assert save == null : &quot;missing RestoreRegistersOp&quot;;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (sawSaveRegisters) {</span>
<span class="line-added">+             // The return value must be killed so it can be propagated out</span>
<span class="line-added">+             CallingConvention cc = gen.getCallingConvention();</span>
<span class="line-added">+             AllocatableValue returnValue = cc.getReturn();</span>
<span class="line-added">+             if (returnValue != null) {</span>
<span class="line-added">+                 if (ValueUtil.isRegister(returnValue)) {</span>
<span class="line-added">+                     destroyedRegisters.add(ValueUtil.asRegister(returnValue));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          }
          return translateToCallerRegisters(destroyedRegisters);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 457,34 ***</span>
       * register windows on SPARC). Registers which are not visible by the caller are removed.
       */
      protected abstract EconomicSet&lt;Register&gt; translateToCallerRegisters(EconomicSet&lt;Register&gt; calleeRegisters);
  
      /**
<span class="line-modified">!      * Updates a given stub with respect to the registers it destroys.</span>
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-modified">!      * Any entry in {@code calleeSaveInfo} that {@linkplain SaveRegistersOp#supportsRemove()</span>
<span class="line-modified">!      * supports} pruning will have {@code destroyedRegisters}</span>
<span class="line-modified">!      * {@linkplain SaveRegistersOp#remove(EconomicSet) removed} as these registers are declared as</span>
<span class="line-removed">-      * temporaries in the stub&#39;s {@linkplain ForeignCallLinkage linkage} (and thus will be saved by</span>
<span class="line-removed">-      * the stub&#39;s caller).</span>
       *
       * @param stub the stub to update
<span class="line-modified">!      * @param destroyedRegisters the registers destroyed by the stub</span>
<span class="line-removed">-      * @param calleeSaveInfo a map from debug infos to the operations that provide their</span>
<span class="line-removed">-      *            {@linkplain RegisterSaveLayout callee-save information}</span>
       * @param frameMap used to {@linkplain FrameMap#offsetForStackSlot(StackSlot) convert} a virtual
<span class="line-removed">-      *            slot to a frame slot index</span>
       */
<span class="line-modified">!     protected void updateStub(Stub stub, EconomicSet&lt;Register&gt; destroyedRegisters, EconomicMap&lt;LIRFrameState, SaveRegistersOp&gt; calleeSaveInfo, FrameMap frameMap) {</span>
          stub.initDestroyedCallerRegisters(destroyedRegisters);
  
          MapCursor&lt;LIRFrameState, SaveRegistersOp&gt; cursor = calleeSaveInfo.getEntries();
          while (cursor.advance()) {
              SaveRegistersOp save = cursor.getValue();
<span class="line-modified">!             if (save.supportsRemove()) {</span>
<span class="line-removed">-                 save.remove(destroyedRegisters);</span>
<span class="line-removed">-             }</span>
              if (cursor.getKey() != LIRFrameState.NO_STATE) {
                  cursor.getKey().debugInfo().setCalleeSaveInfo(save.getMap(frameMap));
              }
          }
      }
<span class="line-new-header">--- 490,39 ---</span>
       * register windows on SPARC). Registers which are not visible by the caller are removed.
       */
      protected abstract EconomicSet&lt;Register&gt; translateToCallerRegisters(EconomicSet&lt;Register&gt; calleeRegisters);
  
      /**
<span class="line-modified">!      * Updates a given stub with respect to the registers it destroys by</span>
<span class="line-modified">!      * {@link #gatherDestroyedCallerRegisters(HotSpotLIRGenerationResult) computing the destroyed</span>
<span class="line-modified">!      * registers} and removing those registers from the {@linkplain SaveRegistersOp SaveRegistersOp}</span>
<span class="line-modified">!      * as these registers are declared as temporaries in the stub&#39;s {@linkplain ForeignCallLinkage</span>
<span class="line-modified">!      * linkage} (and thus will be saved by the stub&#39;s caller).</span>
       *
       * @param stub the stub to update
<span class="line-modified">!      * @param gen the HotSpotLIRGenerationResult being emitted</span>
       * @param frameMap used to {@linkplain FrameMap#offsetForStackSlot(StackSlot) convert} a virtual
       */
<span class="line-modified">!     protected void updateStub(Stub stub, HotSpotLIRGenerationResult gen, FrameMap frameMap) {</span>
<span class="line-added">+         EconomicSet&lt;Register&gt; destroyedRegisters = gatherDestroyedCallerRegisters(gen);</span>
<span class="line-added">+         EconomicMap&lt;LIRFrameState, SaveRegistersOp&gt; calleeSaveInfo = gen.getCalleeSaveInfo();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (stub.getLinkage().needsDebugInfo() &amp;&amp; calleeSaveInfo.isEmpty()) {</span>
<span class="line-added">+             // This call is a safepoint but no register saving was done so we must ensure that all</span>
<span class="line-added">+             // registers appear to be killed. The Native ABI may allow caller save registers but</span>
<span class="line-added">+             // for HotSpot they must be described in a RegisterMap so they are accessible.</span>
<span class="line-added">+             for (Register r : frameMap.getRegisterConfig().getCallerSaveRegisters()) {</span>
<span class="line-added">+                 destroyedRegisters.add(r);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          stub.initDestroyedCallerRegisters(destroyedRegisters);
  
          MapCursor&lt;LIRFrameState, SaveRegistersOp&gt; cursor = calleeSaveInfo.getEntries();
          while (cursor.advance()) {
              SaveRegistersOp save = cursor.getValue();
<span class="line-modified">!             save.remove(destroyedRegisters);</span>
              if (cursor.getKey() != LIRFrameState.NO_STATE) {
                  cursor.getKey().debugInfo().setCalleeSaveInfo(save.getMap(frameMap));
              }
          }
      }
</pre>
<center><a href="GraalHotSpotVMConfigVersioned.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotBackendFactory.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
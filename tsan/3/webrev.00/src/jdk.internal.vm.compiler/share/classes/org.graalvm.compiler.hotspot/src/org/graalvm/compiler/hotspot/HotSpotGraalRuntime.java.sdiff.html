<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotGraalOptionValues.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotGraalRuntimeProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalRuntime.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static jdk.vm.ci.common.InitTimer.timer;
 28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 30 import static org.graalvm.compiler.core.common.GraalOptions.HotSpotPrintInlining;
 31 
 32 import java.io.PrintStream;
 33 import java.util.ArrayList;
 34 import java.util.EnumMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.concurrent.atomic.AtomicReference;

 38 
 39 import jdk.internal.vm.compiler.collections.EconomicMap;
 40 import jdk.internal.vm.compiler.collections.EconomicSet;
 41 import jdk.internal.vm.compiler.collections.Equivalence;
 42 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
 43 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 44 import org.graalvm.compiler.api.runtime.GraalRuntime;
 45 import org.graalvm.compiler.core.CompilationWrapper.ExceptionAction;
 46 import org.graalvm.compiler.core.common.CompilationIdentifier;
 47 import org.graalvm.compiler.core.common.GraalOptions;
 48 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 49 import org.graalvm.compiler.core.target.Backend;
 50 import org.graalvm.compiler.debug.DebugContext;
 51 import org.graalvm.compiler.debug.DebugContext.Description;
 52 import org.graalvm.compiler.debug.DebugHandlersFactory;
 53 import org.graalvm.compiler.debug.DebugOptions;
 54 import org.graalvm.compiler.debug.DiagnosticsOutputDirectory;
 55 import org.graalvm.compiler.debug.GlobalMetrics;
 56 import org.graalvm.compiler.debug.GraalError;
 57 import org.graalvm.compiler.debug.TTY;
</pre>
<hr />
<pre>
 70 import org.graalvm.compiler.replacements.SnippetCounter;
 71 import org.graalvm.compiler.replacements.SnippetCounter.Group;
 72 import org.graalvm.compiler.runtime.RuntimeProvider;
 73 import org.graalvm.compiler.serviceprovider.GraalServices;
 74 
 75 import jdk.vm.ci.code.Architecture;
 76 import jdk.vm.ci.code.stack.StackIntrospection;
 77 import jdk.vm.ci.common.InitTimer;
 78 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 79 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 80 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 81 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
 82 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 83 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
 84 import jdk.vm.ci.meta.JavaKind;
 85 import jdk.vm.ci.meta.MetaAccessProvider;
 86 import jdk.vm.ci.meta.ResolvedJavaMethod;
 87 import jdk.vm.ci.meta.ResolvedJavaType;
 88 import jdk.vm.ci.runtime.JVMCI;
 89 import jdk.vm.ci.runtime.JVMCIBackend;

 90 
 91 //JaCoCo Exclude
 92 
 93 /**
 94  * Singleton class holding the instance of the {@link GraalRuntime}.
 95  */
 96 public final class HotSpotGraalRuntime implements HotSpotGraalRuntimeProvider {
 97 
<span class="line-modified"> 98     private static final boolean IS_AOT = Boolean.getBoolean(&quot;com.oracle.graalvm.isaot&quot;);</span>




 99 
100     private static boolean checkArrayIndexScaleInvariants(MetaAccessProvider metaAccess) {
101         assert metaAccess.getArrayIndexScale(JavaKind.Byte) == 1;
102         assert metaAccess.getArrayIndexScale(JavaKind.Boolean) == 1;
103         assert metaAccess.getArrayIndexScale(JavaKind.Char) == 2;
104         assert metaAccess.getArrayIndexScale(JavaKind.Short) == 2;
105         assert metaAccess.getArrayIndexScale(JavaKind.Int) == 4;
106         assert metaAccess.getArrayIndexScale(JavaKind.Long) == 8;
107         assert metaAccess.getArrayIndexScale(JavaKind.Float) == 4;
108         assert metaAccess.getArrayIndexScale(JavaKind.Double) == 8;
109         return true;
110     }
111 
112     private final String runtimeName;
113     private final String compilerConfigurationName;
114     private final HotSpotBackend hostBackend;





115     private final GlobalMetrics metricValues = new GlobalMetrics();
116     private final List&lt;SnippetCounter.Group&gt; snippetCounterGroups;
117     private final HotSpotGC garbageCollector;
118 
119     private final EconomicMap&lt;Class&lt;? extends Architecture&gt;, HotSpotBackend&gt; backends = EconomicMap.create(Equivalence.IDENTITY);
120 
121     private final GraalHotSpotVMConfig config;
122 
123     /**
124      * The options can be {@linkplain #setOptionValues(String[], String[]) updated} by external
125      * interfaces such as JMX. This comes with the risk that inconsistencies can arise as an
126      * {@link OptionValues} object can be cached by various parts of Graal instead of always
127      * obtaining them from this object. However, concurrent updates are never lost.
128      */
129     private AtomicReference&lt;OptionValues&gt; optionsRef = new AtomicReference&lt;&gt;();
130 
<span class="line-removed">131     private final HotSpotGraalCompiler compiler;</span>
<span class="line-removed">132 </span>
133     private final DiagnosticsOutputDirectory outputDirectory;
134     private final Map&lt;ExceptionAction, Integer&gt; compilationProblemsPerAction;
135 
136     /**
137      * @param nameQualifier a qualifier to be added to this runtime&#39;s {@linkplain #getName() name}
138      * @param compilerConfigurationFactory factory for the compiler configuration
139      *            {@link CompilerConfigurationFactory#selectFactory(String, OptionValues)}
140      */
141     @SuppressWarnings(&quot;try&quot;)
142     HotSpotGraalRuntime(String nameQualifier, HotSpotJVMCIRuntime jvmciRuntime, CompilerConfigurationFactory compilerConfigurationFactory, OptionValues initialOptions) {
143         this.runtimeName = getClass().getSimpleName() + &quot;:&quot; + nameQualifier;
144         HotSpotVMConfigStore store = jvmciRuntime.getConfigStore();
145         config = GeneratePIC.getValue(initialOptions) ? new AOTGraalHotSpotVMConfig(store) : new GraalHotSpotVMConfig(store);
146 
147         // Only set HotSpotPrintInlining if it still has its default value (false).
148         if (GraalOptions.HotSpotPrintInlining.getValue(initialOptions) == false &amp;&amp; config.printInlining) {
149             optionsRef.set(new OptionValues(initialOptions, HotSpotPrintInlining, true));
150         } else {
151             optionsRef.set(initialOptions);
152         }
153         OptionValues options = optionsRef.get();
154 
155         garbageCollector = getSelectedGC();
156 
157         outputDirectory = new DiagnosticsOutputDirectory(options);
158         compilationProblemsPerAction = new EnumMap&lt;&gt;(ExceptionAction.class);
159         snippetCounterGroups = GraalOptions.SnippetCounters.getValue(options) ? new ArrayList&lt;&gt;() : null;
160         CompilerConfiguration compilerConfiguration = compilerConfigurationFactory.createCompilerConfiguration();
161         compilerConfigurationName = compilerConfigurationFactory.getName();
162 
<span class="line-removed">163         compiler = new HotSpotGraalCompiler(jvmciRuntime, this, options);</span>
164         if (IS_AOT) {
<span class="line-modified">165             management = null;</span>
166         } else {
167             management = GraalServices.loadSingle(HotSpotGraalManagementRegistration.class, false);
<span class="line-modified">168             if (management != null) {</span>
<span class="line-modified">169                 management.initialize(this);</span>
<span class="line-modified">170             }</span>
171         }
172 
173         BackendMap backendMap = compilerConfigurationFactory.createBackendMap();
174 
175         JVMCIBackend hostJvmciBackend = jvmciRuntime.getHostJVMCIBackend();
176         Architecture hostArchitecture = hostJvmciBackend.getTarget().arch;
177         try (InitTimer t = timer(&quot;create backend:&quot;, hostArchitecture)) {
178             HotSpotBackendFactory factory = backendMap.getBackendFactory(hostArchitecture);
179             if (factory == null) {
180                 throw new GraalError(&quot;No backend available for host architecture \&quot;%s\&quot;&quot;, hostArchitecture);
181             }
182             hostBackend = registerBackend(factory.createBackend(this, compilerConfiguration, jvmciRuntime, null));
183         }
184 
185         for (JVMCIBackend jvmciBackend : jvmciRuntime.getJVMCIBackends().values()) {
186             if (jvmciBackend == hostJvmciBackend) {
187                 continue;
188             }
189 
190             Architecture gpuArchitecture = jvmciBackend.getTarget().arch;
</pre>
<hr />
<pre>
272         return backend;
273     }
274 
275     @Override
276     public HotSpotProviders getHostProviders() {
277         return getHostBackend().getProviders();
278     }
279 
280     @Override
281     public GraalHotSpotVMConfig getVMConfig() {
282         return config;
283     }
284 
285     @Override
286     public DebugContext openDebugContext(OptionValues compilationOptions, CompilationIdentifier compilationId, Object compilable, Iterable&lt;DebugHandlersFactory&gt; factories, PrintStream logStream) {
287         if (management != null &amp;&amp; management.poll(false) != null) {
288             if (compilable instanceof HotSpotResolvedJavaMethod) {
289                 HotSpotResolvedObjectType type = ((HotSpotResolvedJavaMethod) compilable).getDeclaringClass();
290                 if (type instanceof HotSpotResolvedJavaType) {
291                     Class&lt;?&gt; clazz = runtime().getMirror(type);
<span class="line-modified">292                     try {</span>
<span class="line-modified">293                         ClassLoader cl = clazz.getClassLoader();</span>
<span class="line-modified">294                         if (cl != null) {</span>
<span class="line-modified">295                             loaders.add(cl);</span>




296                         }
<span class="line-removed">297                     } catch (SecurityException e) {</span>
<span class="line-removed">298                         // This loader can obviously not be used for resolving class names</span>
299                     }
300                 }
301             }
302         }
303         Description description = new Description(compilable, compilationId.toString(CompilationIdentifier.Verbosity.ID));
304         return DebugContext.create(compilationOptions, description, metricValues, logStream, factories);
305     }
306 
307     @Override
308     public OptionValues getOptions() {
309         return optionsRef.get();
310     }
311 
312     @Override
313     public Group createSnippetCounterGroup(String groupName) {
314         if (snippetCounterGroups != null) {
315             Group group = new Group(groupName);
316             snippetCounterGroups.add(group);
317             return group;
318         }
</pre>
<hr />
<pre>
328     @Override
329     public &lt;T&gt; T getCapability(Class&lt;T&gt; clazz) {
330         if (clazz == RuntimeProvider.class) {
331             return (T) this;
332         } else if (clazz == OptionValues.class) {
333             return (T) optionsRef.get();
334         } else if (clazz == StackIntrospection.class) {
335             return (T) this;
336         } else if (clazz == SnippetReflectionProvider.class) {
337             return (T) getHostProviders().getSnippetReflection();
338         } else if (clazz == GraalHotSpotVMConfig.class) {
339             return (T) getVMConfig();
340         } else if (clazz == StampProvider.class) {
341             return (T) getHostProviders().getStampProvider();
342         } else if (ForeignCallsProvider.class.isAssignableFrom(clazz)) {
343             return (T) getHostProviders().getForeignCalls();
344         }
345         return null;
346     }
347 

348     public HotSpotGC getGarbageCollector() {
349         return garbageCollector;
350     }
351 
352     @Override
353     public HotSpotBackend getHostBackend() {
354         return hostBackend;
355     }
356 
357     @Override
358     public &lt;T extends Architecture&gt; Backend getBackend(Class&lt;T&gt; arch) {
359         assert arch != Architecture.class;
360         return backends.get(arch);
361     }
362 
363     @Override
364     public String getCompilerConfigurationName() {
365         return compilerConfigurationName;
366     }
367 
368     private long runtimeStartTime;
<span class="line-modified">369     private boolean shutdown;</span>




370 
371     /**
372      * Take action related to entering a new execution phase.
373      *
374      * @param phase the execution phase being entered
375      */
376     void phaseTransition(String phase) {
377         if (Options.UseCompilationStatistics.getValue(optionsRef.get())) {
378             CompilationStatistics.clear(phase);
379         }
380     }
381 
382     void shutdown() {
383         shutdown = true;
384         metricValues.print(optionsRef.get());
385 
386         phaseTransition(&quot;final&quot;);
387 
388         if (snippetCounterGroups != null) {
389             for (Group group : snippetCounterGroups) {
390                 TTY.out().out().println(group);
391             }
392         }
393         BenchmarkCounters.shutdown(runtime(), optionsRef.get(), runtimeStartTime);
394 
395         outputDirectory.close();










396     }
397 
398     void clearMetrics() {
399         metricValues.clear();
400     }
401 
402     private final boolean bootstrapJVMCI;
403     private boolean bootstrapFinished;
404 
405     public void notifyBootstrapFinished() {
406         bootstrapFinished = true;
407     }
408 
409     @Override
410     public boolean isBootstrapping() {
411         return bootstrapJVMCI &amp;&amp; !bootstrapFinished;
412     }
413 
414     @Override
415     public boolean isShutdown() {
</pre>
<hr />
<pre>
562             ClassNotFoundException cause = failures.isEmpty() ? new ClassNotFoundException(className) : failures.iterator().next();
563             throw new Exception(&quot;Cannot find class &quot; + className + &quot; to schedule recompilation&quot;, cause);
564         }
565         for (Class&lt;?&gt; clazz : found) {
566             ResolvedJavaType type = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess().lookupJavaType(clazz);
567             for (ResolvedJavaMethod method : type.getDeclaredMethods()) {
568                 if (methodName.equals(method.getName()) &amp;&amp; method instanceof HotSpotResolvedJavaMethod) {
569                     HotSpotResolvedJavaMethod hotSpotMethod = (HotSpotResolvedJavaMethod) method;
570                     dumpMethod(hotSpotMethod, filter, host, port);
571                 }
572             }
573         }
574     }
575 
576     private void dumpMethod(HotSpotResolvedJavaMethod hotSpotMethod, String filter, String host, int port) throws Exception {
577         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; extra = EconomicMap.create();
578         extra.put(DebugOptions.Dump, filter);
579         extra.put(DebugOptions.PrintGraphHost, host);
580         extra.put(DebugOptions.PrintGraphPort, port);
581         OptionValues compileOptions = new OptionValues(getOptions(), extra);

582         compiler.compileMethod(new HotSpotCompilationRequest(hotSpotMethod, -1, 0L), false, compileOptions);
583     }
584 
585     public Object invokeManagementAction(String actionName, Object[] params) throws Exception {
586         if (&quot;dumpMethod&quot;.equals(actionName)) {
587             if (params.length != 0 &amp;&amp; params[0] instanceof HotSpotResolvedJavaMethod) {
588                 HotSpotResolvedJavaMethod method = param(params, 0, &quot;method&quot;, HotSpotResolvedJavaMethod.class, null);
589                 String filter = param(params, 1, &quot;filter&quot;, String.class, &quot;:3&quot;);
590                 String host = param(params, 2, &quot;host&quot;, String.class, &quot;localhost&quot;);
591                 Number port = param(params, 3, &quot;port&quot;, Number.class, 4445);
592                 dumpMethod(method, filter, host, port.intValue());
593             } else {
594                 String className = param(params, 0, &quot;className&quot;, String.class, null);
595                 String methodName = param(params, 1, &quot;methodName&quot;, String.class, null);
596                 String filter = param(params, 2, &quot;filter&quot;, String.class, &quot;:3&quot;);
597                 String host = param(params, 3, &quot;host&quot;, String.class, &quot;localhost&quot;);
598                 Number port = param(params, 4, &quot;port&quot;, Number.class, 4445);
599                 dumpMethod(className, methodName, filter, host, port.intValue());
600             }
601         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static jdk.vm.ci.common.InitTimer.timer;
 28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 30 import static org.graalvm.compiler.core.common.GraalOptions.HotSpotPrintInlining;
 31 
 32 import java.io.PrintStream;
 33 import java.util.ArrayList;
 34 import java.util.EnumMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.concurrent.atomic.AtomicReference;
<span class="line-added"> 38 import java.util.function.Supplier;</span>
 39 
 40 import jdk.internal.vm.compiler.collections.EconomicMap;
 41 import jdk.internal.vm.compiler.collections.EconomicSet;
 42 import jdk.internal.vm.compiler.collections.Equivalence;
 43 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
 44 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 45 import org.graalvm.compiler.api.runtime.GraalRuntime;
 46 import org.graalvm.compiler.core.CompilationWrapper.ExceptionAction;
 47 import org.graalvm.compiler.core.common.CompilationIdentifier;
 48 import org.graalvm.compiler.core.common.GraalOptions;
 49 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 50 import org.graalvm.compiler.core.target.Backend;
 51 import org.graalvm.compiler.debug.DebugContext;
 52 import org.graalvm.compiler.debug.DebugContext.Description;
 53 import org.graalvm.compiler.debug.DebugHandlersFactory;
 54 import org.graalvm.compiler.debug.DebugOptions;
 55 import org.graalvm.compiler.debug.DiagnosticsOutputDirectory;
 56 import org.graalvm.compiler.debug.GlobalMetrics;
 57 import org.graalvm.compiler.debug.GraalError;
 58 import org.graalvm.compiler.debug.TTY;
</pre>
<hr />
<pre>
 71 import org.graalvm.compiler.replacements.SnippetCounter;
 72 import org.graalvm.compiler.replacements.SnippetCounter.Group;
 73 import org.graalvm.compiler.runtime.RuntimeProvider;
 74 import org.graalvm.compiler.serviceprovider.GraalServices;
 75 
 76 import jdk.vm.ci.code.Architecture;
 77 import jdk.vm.ci.code.stack.StackIntrospection;
 78 import jdk.vm.ci.common.InitTimer;
 79 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 80 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 81 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 82 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
 83 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 84 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
 85 import jdk.vm.ci.meta.JavaKind;
 86 import jdk.vm.ci.meta.MetaAccessProvider;
 87 import jdk.vm.ci.meta.ResolvedJavaMethod;
 88 import jdk.vm.ci.meta.ResolvedJavaType;
 89 import jdk.vm.ci.runtime.JVMCI;
 90 import jdk.vm.ci.runtime.JVMCIBackend;
<span class="line-added"> 91 import jdk.vm.ci.services.Services;</span>
 92 
 93 //JaCoCo Exclude
 94 
 95 /**
 96  * Singleton class holding the instance of the {@link GraalRuntime}.
 97  */
 98 public final class HotSpotGraalRuntime implements HotSpotGraalRuntimeProvider {
 99 
<span class="line-modified">100     private static final boolean IS_AOT = Boolean.parseBoolean(Services.getSavedProperties().get(&quot;com.oracle.graalvm.isaot&quot;));</span>
<span class="line-added">101     /**</span>
<span class="line-added">102      * A factory for {@link HotSpotGraalManagementRegistration} injected by {@code LibGraalFeature}.</span>
<span class="line-added">103      */</span>
<span class="line-added">104     private static final Supplier&lt;HotSpotGraalManagementRegistration&gt; AOT_INJECTED_MANAGEMENT = null;</span>
105 
106     private static boolean checkArrayIndexScaleInvariants(MetaAccessProvider metaAccess) {
107         assert metaAccess.getArrayIndexScale(JavaKind.Byte) == 1;
108         assert metaAccess.getArrayIndexScale(JavaKind.Boolean) == 1;
109         assert metaAccess.getArrayIndexScale(JavaKind.Char) == 2;
110         assert metaAccess.getArrayIndexScale(JavaKind.Short) == 2;
111         assert metaAccess.getArrayIndexScale(JavaKind.Int) == 4;
112         assert metaAccess.getArrayIndexScale(JavaKind.Long) == 8;
113         assert metaAccess.getArrayIndexScale(JavaKind.Float) == 4;
114         assert metaAccess.getArrayIndexScale(JavaKind.Double) == 8;
115         return true;
116     }
117 
118     private final String runtimeName;
119     private final String compilerConfigurationName;
120     private final HotSpotBackend hostBackend;
<span class="line-added">121 </span>
<span class="line-added">122     public GlobalMetrics getMetricValues() {</span>
<span class="line-added">123         return metricValues;</span>
<span class="line-added">124     }</span>
<span class="line-added">125 </span>
126     private final GlobalMetrics metricValues = new GlobalMetrics();
127     private final List&lt;SnippetCounter.Group&gt; snippetCounterGroups;
128     private final HotSpotGC garbageCollector;
129 
130     private final EconomicMap&lt;Class&lt;? extends Architecture&gt;, HotSpotBackend&gt; backends = EconomicMap.create(Equivalence.IDENTITY);
131 
132     private final GraalHotSpotVMConfig config;
133 
134     /**
135      * The options can be {@linkplain #setOptionValues(String[], String[]) updated} by external
136      * interfaces such as JMX. This comes with the risk that inconsistencies can arise as an
137      * {@link OptionValues} object can be cached by various parts of Graal instead of always
138      * obtaining them from this object. However, concurrent updates are never lost.
139      */
140     private AtomicReference&lt;OptionValues&gt; optionsRef = new AtomicReference&lt;&gt;();
141 


142     private final DiagnosticsOutputDirectory outputDirectory;
143     private final Map&lt;ExceptionAction, Integer&gt; compilationProblemsPerAction;
144 
145     /**
146      * @param nameQualifier a qualifier to be added to this runtime&#39;s {@linkplain #getName() name}
147      * @param compilerConfigurationFactory factory for the compiler configuration
148      *            {@link CompilerConfigurationFactory#selectFactory(String, OptionValues)}
149      */
150     @SuppressWarnings(&quot;try&quot;)
151     HotSpotGraalRuntime(String nameQualifier, HotSpotJVMCIRuntime jvmciRuntime, CompilerConfigurationFactory compilerConfigurationFactory, OptionValues initialOptions) {
152         this.runtimeName = getClass().getSimpleName() + &quot;:&quot; + nameQualifier;
153         HotSpotVMConfigStore store = jvmciRuntime.getConfigStore();
154         config = GeneratePIC.getValue(initialOptions) ? new AOTGraalHotSpotVMConfig(store) : new GraalHotSpotVMConfig(store);
155 
156         // Only set HotSpotPrintInlining if it still has its default value (false).
157         if (GraalOptions.HotSpotPrintInlining.getValue(initialOptions) == false &amp;&amp; config.printInlining) {
158             optionsRef.set(new OptionValues(initialOptions, HotSpotPrintInlining, true));
159         } else {
160             optionsRef.set(initialOptions);
161         }
162         OptionValues options = optionsRef.get();
163 
164         garbageCollector = getSelectedGC();
165 
166         outputDirectory = new DiagnosticsOutputDirectory(options);
167         compilationProblemsPerAction = new EnumMap&lt;&gt;(ExceptionAction.class);
168         snippetCounterGroups = GraalOptions.SnippetCounters.getValue(options) ? new ArrayList&lt;&gt;() : null;
169         CompilerConfiguration compilerConfiguration = compilerConfigurationFactory.createCompilerConfiguration();
170         compilerConfigurationName = compilerConfigurationFactory.getName();
171 

172         if (IS_AOT) {
<span class="line-modified">173             management = AOT_INJECTED_MANAGEMENT == null ? null : AOT_INJECTED_MANAGEMENT.get();</span>
174         } else {
175             management = GraalServices.loadSingle(HotSpotGraalManagementRegistration.class, false);
<span class="line-modified">176         }</span>
<span class="line-modified">177         if (management != null) {</span>
<span class="line-modified">178             management.initialize(this, config);</span>
179         }
180 
181         BackendMap backendMap = compilerConfigurationFactory.createBackendMap();
182 
183         JVMCIBackend hostJvmciBackend = jvmciRuntime.getHostJVMCIBackend();
184         Architecture hostArchitecture = hostJvmciBackend.getTarget().arch;
185         try (InitTimer t = timer(&quot;create backend:&quot;, hostArchitecture)) {
186             HotSpotBackendFactory factory = backendMap.getBackendFactory(hostArchitecture);
187             if (factory == null) {
188                 throw new GraalError(&quot;No backend available for host architecture \&quot;%s\&quot;&quot;, hostArchitecture);
189             }
190             hostBackend = registerBackend(factory.createBackend(this, compilerConfiguration, jvmciRuntime, null));
191         }
192 
193         for (JVMCIBackend jvmciBackend : jvmciRuntime.getJVMCIBackends().values()) {
194             if (jvmciBackend == hostJvmciBackend) {
195                 continue;
196             }
197 
198             Architecture gpuArchitecture = jvmciBackend.getTarget().arch;
</pre>
<hr />
<pre>
280         return backend;
281     }
282 
283     @Override
284     public HotSpotProviders getHostProviders() {
285         return getHostBackend().getProviders();
286     }
287 
288     @Override
289     public GraalHotSpotVMConfig getVMConfig() {
290         return config;
291     }
292 
293     @Override
294     public DebugContext openDebugContext(OptionValues compilationOptions, CompilationIdentifier compilationId, Object compilable, Iterable&lt;DebugHandlersFactory&gt; factories, PrintStream logStream) {
295         if (management != null &amp;&amp; management.poll(false) != null) {
296             if (compilable instanceof HotSpotResolvedJavaMethod) {
297                 HotSpotResolvedObjectType type = ((HotSpotResolvedJavaMethod) compilable).getDeclaringClass();
298                 if (type instanceof HotSpotResolvedJavaType) {
299                     Class&lt;?&gt; clazz = runtime().getMirror(type);
<span class="line-modified">300                     if (clazz != null) {</span>
<span class="line-modified">301                         try {</span>
<span class="line-modified">302                             ClassLoader cl = clazz.getClassLoader();</span>
<span class="line-modified">303                             if (cl != null) {</span>
<span class="line-added">304                                 loaders.add(cl);</span>
<span class="line-added">305                             }</span>
<span class="line-added">306                         } catch (SecurityException e) {</span>
<span class="line-added">307                             // This loader can obviously not be used for resolving class names</span>
308                         }


309                     }
310                 }
311             }
312         }
313         Description description = new Description(compilable, compilationId.toString(CompilationIdentifier.Verbosity.ID));
314         return DebugContext.create(compilationOptions, description, metricValues, logStream, factories);
315     }
316 
317     @Override
318     public OptionValues getOptions() {
319         return optionsRef.get();
320     }
321 
322     @Override
323     public Group createSnippetCounterGroup(String groupName) {
324         if (snippetCounterGroups != null) {
325             Group group = new Group(groupName);
326             snippetCounterGroups.add(group);
327             return group;
328         }
</pre>
<hr />
<pre>
338     @Override
339     public &lt;T&gt; T getCapability(Class&lt;T&gt; clazz) {
340         if (clazz == RuntimeProvider.class) {
341             return (T) this;
342         } else if (clazz == OptionValues.class) {
343             return (T) optionsRef.get();
344         } else if (clazz == StackIntrospection.class) {
345             return (T) this;
346         } else if (clazz == SnippetReflectionProvider.class) {
347             return (T) getHostProviders().getSnippetReflection();
348         } else if (clazz == GraalHotSpotVMConfig.class) {
349             return (T) getVMConfig();
350         } else if (clazz == StampProvider.class) {
351             return (T) getHostProviders().getStampProvider();
352         } else if (ForeignCallsProvider.class.isAssignableFrom(clazz)) {
353             return (T) getHostProviders().getForeignCalls();
354         }
355         return null;
356     }
357 
<span class="line-added">358     @Override</span>
359     public HotSpotGC getGarbageCollector() {
360         return garbageCollector;
361     }
362 
363     @Override
364     public HotSpotBackend getHostBackend() {
365         return hostBackend;
366     }
367 
368     @Override
369     public &lt;T extends Architecture&gt; Backend getBackend(Class&lt;T&gt; arch) {
370         assert arch != Architecture.class;
371         return backends.get(arch);
372     }
373 
374     @Override
375     public String getCompilerConfigurationName() {
376         return compilerConfigurationName;
377     }
378 
379     private long runtimeStartTime;
<span class="line-modified">380 </span>
<span class="line-added">381     /**</span>
<span class="line-added">382      * Called from compiler threads to check whether to bail out of a compilation.</span>
<span class="line-added">383      */</span>
<span class="line-added">384     private volatile boolean shutdown;</span>
385 
386     /**
387      * Take action related to entering a new execution phase.
388      *
389      * @param phase the execution phase being entered
390      */
391     void phaseTransition(String phase) {
392         if (Options.UseCompilationStatistics.getValue(optionsRef.get())) {
393             CompilationStatistics.clear(phase);
394         }
395     }
396 
397     void shutdown() {
398         shutdown = true;
399         metricValues.print(optionsRef.get());
400 
401         phaseTransition(&quot;final&quot;);
402 
403         if (snippetCounterGroups != null) {
404             for (Group group : snippetCounterGroups) {
405                 TTY.out().out().println(group);
406             }
407         }
408         BenchmarkCounters.shutdown(runtime(), optionsRef.get(), runtimeStartTime);
409 
410         outputDirectory.close();
<span class="line-added">411 </span>
<span class="line-added">412         shutdownLibGraal();</span>
<span class="line-added">413     }</span>
<span class="line-added">414 </span>
<span class="line-added">415     /**</span>
<span class="line-added">416      * Substituted by</span>
<span class="line-added">417      * {@code com.oracle.svm.graal.hotspot.libgraal.Target_org_graalvm_compiler_hotspot_HotSpotGraalRuntime}</span>
<span class="line-added">418      * to call {@code org.graalvm.nativeimage.VMRuntime.shutdown()}.</span>
<span class="line-added">419      */</span>
<span class="line-added">420     private static void shutdownLibGraal() {</span>
421     }
422 
423     void clearMetrics() {
424         metricValues.clear();
425     }
426 
427     private final boolean bootstrapJVMCI;
428     private boolean bootstrapFinished;
429 
430     public void notifyBootstrapFinished() {
431         bootstrapFinished = true;
432     }
433 
434     @Override
435     public boolean isBootstrapping() {
436         return bootstrapJVMCI &amp;&amp; !bootstrapFinished;
437     }
438 
439     @Override
440     public boolean isShutdown() {
</pre>
<hr />
<pre>
587             ClassNotFoundException cause = failures.isEmpty() ? new ClassNotFoundException(className) : failures.iterator().next();
588             throw new Exception(&quot;Cannot find class &quot; + className + &quot; to schedule recompilation&quot;, cause);
589         }
590         for (Class&lt;?&gt; clazz : found) {
591             ResolvedJavaType type = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess().lookupJavaType(clazz);
592             for (ResolvedJavaMethod method : type.getDeclaredMethods()) {
593                 if (methodName.equals(method.getName()) &amp;&amp; method instanceof HotSpotResolvedJavaMethod) {
594                     HotSpotResolvedJavaMethod hotSpotMethod = (HotSpotResolvedJavaMethod) method;
595                     dumpMethod(hotSpotMethod, filter, host, port);
596                 }
597             }
598         }
599     }
600 
601     private void dumpMethod(HotSpotResolvedJavaMethod hotSpotMethod, String filter, String host, int port) throws Exception {
602         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; extra = EconomicMap.create();
603         extra.put(DebugOptions.Dump, filter);
604         extra.put(DebugOptions.PrintGraphHost, host);
605         extra.put(DebugOptions.PrintGraphPort, port);
606         OptionValues compileOptions = new OptionValues(getOptions(), extra);
<span class="line-added">607         HotSpotGraalCompiler compiler = (HotSpotGraalCompiler) runtime().getCompiler();</span>
608         compiler.compileMethod(new HotSpotCompilationRequest(hotSpotMethod, -1, 0L), false, compileOptions);
609     }
610 
611     public Object invokeManagementAction(String actionName, Object[] params) throws Exception {
612         if (&quot;dumpMethod&quot;.equals(actionName)) {
613             if (params.length != 0 &amp;&amp; params[0] instanceof HotSpotResolvedJavaMethod) {
614                 HotSpotResolvedJavaMethod method = param(params, 0, &quot;method&quot;, HotSpotResolvedJavaMethod.class, null);
615                 String filter = param(params, 1, &quot;filter&quot;, String.class, &quot;:3&quot;);
616                 String host = param(params, 2, &quot;host&quot;, String.class, &quot;localhost&quot;);
617                 Number port = param(params, 3, &quot;port&quot;, Number.class, 4445);
618                 dumpMethod(method, filter, host, port.intValue());
619             } else {
620                 String className = param(params, 0, &quot;className&quot;, String.class, null);
621                 String methodName = param(params, 1, &quot;methodName&quot;, String.class, null);
622                 String filter = param(params, 2, &quot;filter&quot;, String.class, &quot;:3&quot;);
623                 String host = param(params, 3, &quot;host&quot;, String.class, &quot;localhost&quot;);
624                 Number port = param(params, 4, &quot;port&quot;, Number.class, 4445);
625                 dumpMethod(className, methodName, filter, host, port.intValue());
626             }
627         }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotGraalOptionValues.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotGraalRuntimeProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
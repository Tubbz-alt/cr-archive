<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotGraalConstantFieldProvider.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotHostForeignCallsProvider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotGraphBuilderPlugins.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,30 ***</span>
  
  
  package org.graalvm.compiler.hotspot.meta;
  
  import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
  import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
  import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.JAVA_THREAD_THREAD_OBJECT_LOCATION;
  import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
<span class="line-removed">- import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;</span>
  
  import java.lang.invoke.ConstantCallSite;
  import java.lang.invoke.MutableCallSite;
  import java.lang.invoke.VolatileCallSite;
  import java.lang.reflect.Array;
  import java.math.BigInteger;
  import java.util.zip.CRC32;
  
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
<span class="line-removed">- import org.graalvm.compiler.bytecode.BytecodeProvider;</span>
  import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
  import org.graalvm.compiler.core.common.type.ObjectStamp;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.core.common.type.TypeReference;
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
  import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.ArraysSupportSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.CRC32CSubstitutions;
<span class="line-new-header">--- 23,33 ---</span>
  
  
  package org.graalvm.compiler.hotspot.meta;
  
  import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
<span class="line-added">+ import static org.graalvm.compiler.hotspot.HotSpotBackend.BASE64_ENCODE_BLOCK;</span>
  import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
  import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.JAVA_THREAD_THREAD_OBJECT_LOCATION;
  import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
  
  import java.lang.invoke.ConstantCallSite;
  import java.lang.invoke.MutableCallSite;
  import java.lang.invoke.VolatileCallSite;
  import java.lang.reflect.Array;
<span class="line-added">+ import java.lang.reflect.Type;</span>
  import java.math.BigInteger;
  import java.util.zip.CRC32;
  
<span class="line-added">+ import jdk.internal.vm.compiler.collections.Pair;</span>
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
  import org.graalvm.compiler.core.common.type.ObjectStamp;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.core.common.type.TypeReference;
<span class="line-added">+ import org.graalvm.compiler.debug.GraalError;</span>
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<span class="line-added">+ import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;</span>
  import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
  import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.ArraysSupportSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.CRC32CSubstitutions;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,15 ***</span>
  import org.graalvm.compiler.hotspot.replacements.CallSiteTargetNode;
  import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
  import org.graalvm.compiler.hotspot.replacements.CounterModeSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.HotSpotArraySubstitutions;
  import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
  import org.graalvm.compiler.hotspot.replacements.ObjectCloneNode;
<span class="line-removed">- import org.graalvm.compiler.hotspot.replacements.ObjectSubstitutions;</span>
  import org.graalvm.compiler.hotspot.replacements.ReflectionGetCallerClassNode;
  import org.graalvm.compiler.hotspot.replacements.ReflectionSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
  import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
  import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
<span class="line-new-header">--- 57,15 ---</span>
  import org.graalvm.compiler.hotspot.replacements.CallSiteTargetNode;
  import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
  import org.graalvm.compiler.hotspot.replacements.CounterModeSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;
<span class="line-added">+ import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;</span>
  import org.graalvm.compiler.hotspot.replacements.HotSpotArraySubstitutions;
  import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
  import org.graalvm.compiler.hotspot.replacements.ObjectCloneNode;
  import org.graalvm.compiler.hotspot.replacements.ReflectionGetCallerClassNode;
  import org.graalvm.compiler.hotspot.replacements.ReflectionSubstitutions;
  import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
  import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
  import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,30 ***</span>
<span class="line-new-header">--- 91,35 ---</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;
  import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
  import org.graalvm.compiler.nodes.memory.ReadNode;
  import org.graalvm.compiler.nodes.memory.address.AddressNode;
  import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.Replacements;</span>
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
  import org.graalvm.compiler.replacements.InlineDuringParsingPlugin;
  import org.graalvm.compiler.replacements.MethodHandlePlugin;
  import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;
  import org.graalvm.compiler.replacements.ReplacementsImpl;
  import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins;
  import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
  import org.graalvm.compiler.serviceprovider.GraalServices;
<span class="line-added">+ import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
  import org.graalvm.compiler.word.WordOperationPlugin;
  import org.graalvm.compiler.word.WordTypes;
  import jdk.internal.vm.compiler.word.LocationIdentity;
  
  import jdk.vm.ci.code.CodeUtil;
<span class="line-added">+ import jdk.vm.ci.code.TargetDescription;</span>
<span class="line-added">+ import jdk.vm.ci.hotspot.VMIntrinsicMethod;</span>
  import jdk.vm.ci.meta.ConstantReflectionProvider;
  import jdk.vm.ci.meta.DeoptimizationAction;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.MetaAccessProvider;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-added">+ import jdk.vm.ci.services.Services;</span>
  import sun.misc.Unsafe;
  
  /**
   * Defines the {@link Plugins} used when running on HotSpot.
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,75 ***</span>
       * Creates a {@link Plugins} object that should be used when running on HotSpot.
       *
       * @param constantReflection
       * @param snippetReflection
       * @param foreignCalls
       */
<span class="line-modified">!     public static Plugins create(CompilerConfiguration compilerConfiguration, GraalHotSpotVMConfig config, HotSpotWordTypes wordTypes, MetaAccessProvider metaAccess,</span>
<span class="line-modified">!                     ConstantReflectionProvider constantReflection, SnippetReflectionProvider snippetReflection, ForeignCallsProvider foreignCalls, ReplacementsImpl replacements) {</span>
<span class="line-modified">!         InvocationPlugins invocationPlugins = new HotSpotInvocationPlugins(config, compilerConfiguration);</span>
  
          Plugins plugins = new Plugins(invocationPlugins);
<span class="line-modified">!         NodeIntrinsificationProvider nodeIntrinsificationProvider = new NodeIntrinsificationProvider(metaAccess, snippetReflection, foreignCalls, wordTypes);</span>
          HotSpotWordOperationPlugin wordOperationPlugin = new HotSpotWordOperationPlugin(snippetReflection, wordTypes);
          HotSpotNodePlugin nodePlugin = new HotSpotNodePlugin(wordOperationPlugin, config, wordTypes);
  
          plugins.appendTypePlugin(nodePlugin);
          plugins.appendNodePlugin(nodePlugin);
<span class="line-removed">-         OptionValues options = replacements.getOptions();</span>
          if (!GeneratePIC.getValue(options)) {
              plugins.appendNodePlugin(new MethodHandlePlugin(constantReflection.getMethodHandleAccess(), true));
          }
          plugins.appendInlineInvokePlugin(replacements);
          if (InlineDuringParsing.getValue(options)) {
              plugins.appendInlineInvokePlugin(new InlineDuringParsingPlugin());
          }
  
          if (GeneratePIC.getValue(options)) {
<span class="line-modified">!             plugins.setClassInitializationPlugin(new HotSpotClassInitializationPlugin());</span>
              if (TieredAOT.getValue(options)) {
                  plugins.setProfilingPlugin(new HotSpotAOTProfilingPlugin());
              }
          }
  
          invocationPlugins.defer(new Runnable() {
  
              @Override
              public void run() {
<span class="line-modified">!                 BytecodeProvider replacementBytecodeProvider = replacements.getDefaultReplacementBytecodeProvider();</span>
<span class="line-modified">!                 registerObjectPlugins(invocationPlugins, options, config, replacementBytecodeProvider);</span>
<span class="line-removed">-                 registerClassPlugins(plugins, config, replacementBytecodeProvider);</span>
                  registerSystemPlugins(invocationPlugins, foreignCalls);
<span class="line-modified">!                 registerThreadPlugins(invocationPlugins, metaAccess, wordTypes, config, replacementBytecodeProvider);</span>
                  if (!GeneratePIC.getValue(options)) {
                      registerCallSitePlugins(invocationPlugins);
                  }
<span class="line-modified">!                 registerReflectionPlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">!                 registerConstantPoolPlugins(invocationPlugins, wordTypes, config, replacementBytecodeProvider);</span>
<span class="line-modified">!                 registerAESPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">!                 registerCRC32Plugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">!                 registerCRC32CPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">!                 registerBigIntegerPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">!                 registerSHAPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
                  registerGHASHPlugins(invocationPlugins, config, metaAccess, foreignCalls);
<span class="line-modified">!                 registerCounterModePlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">!                 registerUnsafePlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">!                 StandardGraphBuilderPlugins.registerInvocationPlugins(metaAccess, snippetReflection, invocationPlugins, replacementBytecodeProvider, true, false);</span>
<span class="line-modified">!                 registerArrayPlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">!                 registerStringPlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">!                 registerArraysSupportPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
  
                  for (NodeIntrinsicPluginFactory factory : GraalServices.load(NodeIntrinsicPluginFactory.class)) {
                      factory.registerPlugins(invocationPlugins, nodeIntrinsificationProvider);
                  }
              }
          });
          return plugins;
      }
  
<span class="line-modified">!     private static void registerObjectPlugins(InvocationPlugins plugins, OptionValues options, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Object.class, bytecodeProvider);</span>
          if (!GeneratePIC.getValue(options)) {
              // FIXME: clone() requires speculation and requires a fix in here (to check that
              // b.getAssumptions() != null), and in ReplacementImpl.getSubstitution() where there is
              // an instantiation of IntrinsicGraphBuilder using a constructor that sets
              // AllowAssumptions to YES automatically. The former has to inherit the assumptions
<span class="line-new-header">--- 129,88 ---</span>
       * Creates a {@link Plugins} object that should be used when running on HotSpot.
       *
       * @param constantReflection
       * @param snippetReflection
       * @param foreignCalls
<span class="line-added">+      * @param options</span>
<span class="line-added">+      * @param target</span>
       */
<span class="line-modified">!     public static Plugins create(HotSpotGraalRuntimeProvider graalRuntime,</span>
<span class="line-modified">!                     CompilerConfiguration compilerConfiguration,</span>
<span class="line-modified">!                     GraalHotSpotVMConfig config,</span>
<span class="line-added">+                     HotSpotWordTypes wordTypes,</span>
<span class="line-added">+                     MetaAccessProvider metaAccess,</span>
<span class="line-added">+                     ConstantReflectionProvider constantReflection,</span>
<span class="line-added">+                     SnippetReflectionProvider snippetReflection,</span>
<span class="line-added">+                     ForeignCallsProvider foreignCalls,</span>
<span class="line-added">+                     ReplacementsImpl replacements,</span>
<span class="line-added">+                     OptionValues options, TargetDescription target) {</span>
<span class="line-added">+         InvocationPlugins invocationPlugins = new HotSpotInvocationPlugins(graalRuntime, config, compilerConfiguration);</span>
  
          Plugins plugins = new Plugins(invocationPlugins);
<span class="line-modified">!         NodeIntrinsificationProvider nodeIntrinsificationProvider = new NodeIntrinsificationProvider(metaAccess, snippetReflection, foreignCalls, wordTypes, target);</span>
          HotSpotWordOperationPlugin wordOperationPlugin = new HotSpotWordOperationPlugin(snippetReflection, wordTypes);
          HotSpotNodePlugin nodePlugin = new HotSpotNodePlugin(wordOperationPlugin, config, wordTypes);
  
          plugins.appendTypePlugin(nodePlugin);
          plugins.appendNodePlugin(nodePlugin);
          if (!GeneratePIC.getValue(options)) {
              plugins.appendNodePlugin(new MethodHandlePlugin(constantReflection.getMethodHandleAccess(), true));
          }
          plugins.appendInlineInvokePlugin(replacements);
          if (InlineDuringParsing.getValue(options)) {
              plugins.appendInlineInvokePlugin(new InlineDuringParsingPlugin());
          }
  
          if (GeneratePIC.getValue(options)) {
<span class="line-modified">!             plugins.setClassInitializationPlugin(new HotSpotAOTClassInitializationPlugin());</span>
              if (TieredAOT.getValue(options)) {
                  plugins.setProfilingPlugin(new HotSpotAOTProfilingPlugin());
              }
<span class="line-added">+         } else {</span>
<span class="line-added">+             if (config.instanceKlassInitThreadOffset != -1) {</span>
<span class="line-added">+                 plugins.setClassInitializationPlugin(new HotSpotJITClassInitializationPlugin());</span>
<span class="line-added">+             }</span>
          }
  
          invocationPlugins.defer(new Runnable() {
  
              @Override
              public void run() {
<span class="line-modified">!                 registerObjectPlugins(invocationPlugins, options, config, replacements);</span>
<span class="line-modified">!                 registerClassPlugins(plugins, config, replacements);</span>
                  registerSystemPlugins(invocationPlugins, foreignCalls);
<span class="line-modified">!                 registerThreadPlugins(invocationPlugins, metaAccess, wordTypes, config, replacements);</span>
                  if (!GeneratePIC.getValue(options)) {
                      registerCallSitePlugins(invocationPlugins);
                  }
<span class="line-modified">!                 registerReflectionPlugins(invocationPlugins, replacements);</span>
<span class="line-modified">!                 registerConstantPoolPlugins(invocationPlugins, wordTypes, config, replacements);</span>
<span class="line-modified">!                 registerAESPlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">!                 registerCRC32Plugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">!                 registerCRC32CPlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">!                 registerBigIntegerPlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">!                 registerSHAPlugins(invocationPlugins, config, replacements);</span>
                  registerGHASHPlugins(invocationPlugins, config, metaAccess, foreignCalls);
<span class="line-modified">!                 registerCounterModePlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">!                 registerBase64Plugins(invocationPlugins, config, metaAccess, foreignCalls);</span>
<span class="line-modified">!                 registerUnsafePlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">!                 StandardGraphBuilderPlugins.registerInvocationPlugins(metaAccess, snippetReflection, invocationPlugins, replacements, true, false, true);</span>
<span class="line-modified">!                 registerArrayPlugins(invocationPlugins, replacements);</span>
<span class="line-modified">!                 registerStringPlugins(invocationPlugins, replacements);</span>
<span class="line-added">+                 registerArraysSupportPlugins(invocationPlugins, config, replacements);</span>
  
                  for (NodeIntrinsicPluginFactory factory : GraalServices.load(NodeIntrinsicPluginFactory.class)) {
                      factory.registerPlugins(invocationPlugins, nodeIntrinsificationProvider);
                  }
              }
          });
          return plugins;
      }
  
<span class="line-modified">!     private static void registerObjectPlugins(InvocationPlugins plugins, OptionValues options, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Object.class, replacements);</span>
          if (!GeneratePIC.getValue(options)) {
              // FIXME: clone() requires speculation and requires a fix in here (to check that
              // b.getAssumptions() != null), and in ReplacementImpl.getSubstitution() where there is
              // an instantiation of IntrinsicGraphBuilder using a constructor that sets
              // AllowAssumptions to YES automatically. The former has to inherit the assumptions
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,21 ***</span>
                  public boolean inlineOnly() {
                      return true;
                  }
              });
          }
<span class="line-modified">!         r.registerMethodSubstitution(ObjectSubstitutions.class, &quot;hashCode&quot;, Receiver.class);</span>
          if (config.inlineNotify()) {
<span class="line-modified">!             r.registerMethodSubstitution(ObjectSubstitutions.class, &quot;notify&quot;, Receiver.class);</span>
          }
          if (config.inlineNotifyAll()) {
<span class="line-modified">!             r.registerMethodSubstitution(ObjectSubstitutions.class, &quot;notifyAll&quot;, Receiver.class);</span>
          }
      }
  
<span class="line-modified">!     private static void registerClassPlugins(Plugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins.getInvocationPlugins(), Class.class, bytecodeProvider);</span>
  
          r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getModifiers&quot;, Receiver.class);
          r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isInterface&quot;, Receiver.class);
          r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isArray&quot;, Receiver.class);
          r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isPrimitive&quot;, Receiver.class);
<span class="line-new-header">--- 228,57 ---</span>
                  public boolean inlineOnly() {
                      return true;
                  }
              });
          }
<span class="line-modified">!         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {</span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added">+                 ValueNode object = receiver.get();</span>
<span class="line-added">+                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object));</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public boolean inlineOnly() {</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         });</span>
          if (config.inlineNotify()) {
<span class="line-modified">!             r.register1(&quot;notify&quot;, Receiver.class, new InvocationPlugin() {</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added">+                     ValueNode object = receiver.get();</span>
<span class="line-added">+                     b.add(new FastNotifyNode(object, false, b.bci()));</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public boolean inlineOnly() {</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             });</span>
          }
          if (config.inlineNotifyAll()) {
<span class="line-modified">!             r.register1(&quot;notifyAll&quot;, Receiver.class, new InvocationPlugin() {</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added">+                     ValueNode object = receiver.get();</span>
<span class="line-added">+                     b.add(new FastNotifyNode(object, true, b.bci()));</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public boolean inlineOnly() {</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             });</span>
          }
      }
  
<span class="line-modified">!     private static void registerClassPlugins(Plugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins.getInvocationPlugins(), Class.class, replacements);</span>
  
          r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getModifiers&quot;, Receiver.class);
          r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isInterface&quot;, Receiver.class);
          r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isArray&quot;, Receiver.class);
          r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isPrimitive&quot;, Receiver.class);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,11 ***</span>
      private static void registerCallSitePlugins(InvocationPlugins plugins) {
          InvocationPlugin plugin = new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  ValueNode callSite = receiver.get();
<span class="line-modified">!                 ValueNode folded = CallSiteTargetNode.tryFold(GraphUtil.originalValue(callSite), b.getMetaAccess(), b.getAssumptions());</span>
                  if (folded != null) {
                      b.addPush(JavaKind.Object, folded);
                  } else {
                      b.addPush(JavaKind.Object, new CallSiteTargetNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), callSite));
                  }
<span class="line-new-header">--- 292,11 ---</span>
      private static void registerCallSitePlugins(InvocationPlugins plugins) {
          InvocationPlugin plugin = new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  ValueNode callSite = receiver.get();
<span class="line-modified">!                 ValueNode folded = CallSiteTargetNode.tryFold(GraphUtil.originalValue(callSite, true), b.getMetaAccess(), b.getAssumptions());</span>
                  if (folded != null) {
                      b.addPush(JavaKind.Object, folded);
                  } else {
                      b.addPush(JavaKind.Object, new CallSiteTargetNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), callSite));
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 254,12 ***</span>
          plugins.register(plugin, ConstantCallSite.class, &quot;getTarget&quot;, Receiver.class);
          plugins.register(plugin, MutableCallSite.class, &quot;getTarget&quot;, Receiver.class);
          plugins.register(plugin, VolatileCallSite.class, &quot;getTarget&quot;, Receiver.class);
      }
  
<span class="line-modified">!     private static void registerReflectionPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, reflectionClass, bytecodeProvider);</span>
          r.register0(&quot;getCallerClass&quot;, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  b.addPush(JavaKind.Object, new ReflectionGetCallerClassNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions())));
                  return true;
<span class="line-new-header">--- 311,12 ---</span>
          plugins.register(plugin, ConstantCallSite.class, &quot;getTarget&quot;, Receiver.class);
          plugins.register(plugin, MutableCallSite.class, &quot;getTarget&quot;, Receiver.class);
          plugins.register(plugin, VolatileCallSite.class, &quot;getTarget&quot;, Receiver.class);
      }
  
<span class="line-modified">!     private static void registerReflectionPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, reflectionClass, replacements);</span>
          r.register0(&quot;getCallerClass&quot;, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  b.addPush(JavaKind.Object, new ReflectionGetCallerClassNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions())));
                  return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,19 ***</span>
              }
          });
          r.registerMethodSubstitution(ReflectionSubstitutions.class, &quot;getClassAccessFlags&quot;, Class.class);
      }
  
<span class="line-modified">!     private static void registerUnsafePlugins(InvocationPlugins plugins, BytecodeProvider replacementBytecodeProvider) {</span>
          Registration r;
<span class="line-modified">!         if (Java8OrEarlier) {</span>
<span class="line-modified">!             r = new Registration(plugins, Unsafe.class, replacementBytecodeProvider);</span>
          } else {
<span class="line-modified">!             r = new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacementBytecodeProvider);</span>
          }
<span class="line-modified">!         r.registerMethodSubstitution(HotSpotUnsafeSubstitutions.class, HotSpotUnsafeSubstitutions.copyMemoryName, &quot;copyMemory&quot;, Receiver.class, Object.class, long.class, Object.class, long.class,</span>
<span class="line-modified">!                         long.class);</span>
      }
  
      private static final LocationIdentity INSTANCE_KLASS_CONSTANTS = NamedLocationIdentity.immutable(&quot;InstanceKlass::_constants&quot;);
      private static final LocationIdentity CONSTANT_POOL_LENGTH = NamedLocationIdentity.immutable(&quot;ConstantPool::_length&quot;);
  
<span class="line-new-header">--- 328,20 ---</span>
              }
          });
          r.registerMethodSubstitution(ReflectionSubstitutions.class, &quot;getClassAccessFlags&quot;, Class.class);
      }
  
<span class="line-modified">!     private static void registerUnsafePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
          Registration r;
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-modified">!             r = new Registration(plugins, Unsafe.class, replacements);</span>
          } else {
<span class="line-modified">!             r = new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements);</span>
          }
<span class="line-modified">!         String substituteMethodName = config.doingUnsafeAccessOffset != Integer.MAX_VALUE ? &quot;copyMemoryGuarded&quot; : &quot;copyMemory&quot;;</span>
<span class="line-modified">!         r.registerMethodSubstitution(HotSpotUnsafeSubstitutions.class, HotSpotUnsafeSubstitutions.copyMemoryName, substituteMethodName, Receiver.class, Object.class, long.class, Object.class,</span>
<span class="line-added">+                         long.class, long.class);</span>
      }
  
      private static final LocationIdentity INSTANCE_KLASS_CONSTANTS = NamedLocationIdentity.immutable(&quot;InstanceKlass::_constants&quot;);
      private static final LocationIdentity CONSTANT_POOL_LENGTH = NamedLocationIdentity.immutable(&quot;ConstantPool::_length&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,12 ***</span>
          ValueNode elementValue = WordOperationPlugin.readOp(b, elementKind, elementAddress, NamedLocationIdentity.getArrayLocation(elementKind), BarrierType.NONE, notCompressible);
          b.addPush(elementKind, elementValue);
          return true;
      }
  
<span class="line-modified">!     private static void registerConstantPoolPlugins(InvocationPlugins plugins, WordTypes wordTypes, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, constantPoolClass, bytecodeProvider);</span>
  
          r.register2(&quot;getSize0&quot;, Receiver.class, Object.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop) {
                  boolean notCompressible = false;
<span class="line-new-header">--- 378,12 ---</span>
          ValueNode elementValue = WordOperationPlugin.readOp(b, elementKind, elementAddress, NamedLocationIdentity.getArrayLocation(elementKind), BarrierType.NONE, notCompressible);
          b.addPush(elementKind, elementValue);
          return true;
      }
  
<span class="line-modified">!     private static void registerConstantPoolPlugins(InvocationPlugins plugins, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, constantPoolClass, replacements);</span>
  
          r.register2(&quot;getSize0&quot;, Receiver.class, Object.class, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop) {
                  boolean notCompressible = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,26 ***</span>
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerArrayPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Array.class, bytecodeProvider);</span>
          r.setAllowOverwrite(true);
          r.registerMethodSubstitution(HotSpotArraySubstitutions.class, &quot;newInstance&quot;, Class.class, int.class);
      }
  
<span class="line-modified">!     private static void registerStringPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         if (!Java8OrEarlier) {</span>
<span class="line-modified">!             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, bytecodeProvider);</span>
              utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;toBytes&quot;, char[].class, int.class, int.class);
              utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChars&quot;, byte[].class, int.class, int.class, char[].class, int.class);
          }
      }
  
<span class="line-modified">!     private static void registerThreadPlugins(InvocationPlugins plugins, MetaAccessProvider metaAccess, WordTypes wordTypes, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Thread.class, bytecodeProvider);</span>
          r.register0(&quot;currentThread&quot;, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  CurrentJavaThreadNode thread = b.add(new CurrentJavaThreadNode(wordTypes.getWordKind()));
                  ValueNode offset = b.add(ConstantNode.forLong(config.threadObjectOffset));
<span class="line-new-header">--- 449,26 ---</span>
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Array.class, replacements);</span>
          r.setAllowOverwrite(true);
          r.registerMethodSubstitution(HotSpotArraySubstitutions.class, &quot;newInstance&quot;, Class.class, int.class);
      }
  
<span class="line-modified">!     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">!             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);</span>
              utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;toBytes&quot;, char[].class, int.class, int.class);
              utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChars&quot;, byte[].class, int.class, int.class, char[].class, int.class);
          }
      }
  
<span class="line-modified">!     private static void registerThreadPlugins(InvocationPlugins plugins, MetaAccessProvider metaAccess, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Thread.class, replacements);</span>
          r.register0(&quot;currentThread&quot;, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
                  CurrentJavaThreadNode thread = b.add(new CurrentJavaThreadNode(wordTypes.getWordKind()));
                  ValueNode offset = b.add(ConstantNode.forLong(config.threadObjectOffset));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,107 ***</span>
                  b.addPush(JavaKind.Object, new ReadNode(address, JAVA_THREAD_THREAD_OBJECT_LOCATION, stamp, BarrierType.NONE));
                  return true;
              }
          });
  
<span class="line-modified">!         r.registerMethodSubstitution(ThreadSubstitutions.class, &quot;isInterrupted&quot;, Receiver.class, boolean.class);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     public static final String cbcEncryptName;</span>
<span class="line-removed">-     public static final String cbcDecryptName;</span>
<span class="line-removed">-     public static final String aesEncryptName;</span>
<span class="line-removed">-     public static final String aesDecryptName;</span>
  
      public static final String reflectionClass;
      public static final String constantPoolClass;
  
      static {
<span class="line-modified">!         if (Java8OrEarlier) {</span>
<span class="line-removed">-             cbcEncryptName = &quot;encrypt&quot;;</span>
<span class="line-removed">-             cbcDecryptName = &quot;decrypt&quot;;</span>
<span class="line-removed">-             aesEncryptName = &quot;encryptBlock&quot;;</span>
<span class="line-removed">-             aesDecryptName = &quot;decryptBlock&quot;;</span>
              reflectionClass = &quot;sun.reflect.Reflection&quot;;
              constantPoolClass = &quot;sun.reflect.ConstantPool&quot;;
          } else {
<span class="line-removed">-             cbcEncryptName = &quot;implEncrypt&quot;;</span>
<span class="line-removed">-             cbcDecryptName = &quot;implDecrypt&quot;;</span>
<span class="line-removed">-             aesEncryptName = &quot;implEncryptBlock&quot;;</span>
<span class="line-removed">-             aesDecryptName = &quot;implDecryptBlock&quot;;</span>
              reflectionClass = &quot;jdk.internal.reflect.Reflection&quot;;
              constantPoolClass = &quot;jdk.internal.reflect.ConstantPool&quot;;
          }
      }
  
<span class="line-modified">!     private static void registerAESPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
          if (config.useAESIntrinsics) {
              assert config.aescryptEncryptBlockStub != 0L;
              assert config.aescryptDecryptBlockStub != 0L;
              assert config.cipherBlockChainingEncryptAESCryptStub != 0L;
              assert config.cipherBlockChainingDecryptAESCryptStub != 0L;
              String arch = config.osArch;
              String decryptSuffix = arch.equals(&quot;sparc&quot;) ? &quot;WithOriginalKey&quot; : &quot;&quot;;
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CipherBlockChaining&quot;, bytecodeProvider);</span>
<span class="line-modified">!             r.registerMethodSubstitution(CipherBlockChainingSubstitutions.class, cbcEncryptName, Receiver.class, byte[].class, int.class, int.class, byte[].class, int.class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(CipherBlockChainingSubstitutions.class, cbcDecryptName, cbcDecryptName + decryptSuffix, Receiver.class, byte[].class, int.class, int.class, byte[].class,</span>
<span class="line-modified">!                             int.class);</span>
<span class="line-modified">!             r = new Registration(plugins, &quot;com.sun.crypto.provider.AESCrypt&quot;, bytecodeProvider);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AESCryptSubstitutions.class, aesEncryptName, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AESCryptSubstitutions.class, aesDecryptName, aesDecryptName + decryptSuffix, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>
          }
      }
  
<span class="line-modified">!     private static void registerBigIntegerPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, BigInteger.class, bytecodeProvider);</span>
<span class="line-modified">!         if (config.useMultiplyToLenIntrinsic()) {</span>
<span class="line-modified">!             assert config.multiplyToLen != 0L;</span>
<span class="line-modified">!             if (Java8OrEarlier) {</span>
<span class="line-modified">!                 r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;multiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class, int.class,</span>
<span class="line-removed">-                                 int[].class);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMultiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class, int.class,</span>
<span class="line-removed">-                                 int[].class);</span>
<span class="line-removed">-             }</span>
          }
<span class="line-modified">!         if (config.useMulAddIntrinsic()) {</span>
<span class="line-modified">!             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMulAdd&quot;, int[].class, int[].class, int.class, int.class, int.class);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (config.useMontgomeryMultiplyIntrinsic()) {</span>
<span class="line-modified">!             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMontgomeryMultiply&quot;, int[].class, int[].class, int[].class, int.class, long.class, int[].class);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (config.useMontgomerySquareIntrinsic()) {</span>
<span class="line-modified">!             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMontgomerySquare&quot;, int[].class, int[].class, int.class, long.class, int[].class);</span>
          }
<span class="line-modified">!         if (config.useSquareToLenIntrinsic()) {</span>
<span class="line-modified">!             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implSquareToLen&quot;, int[].class, int.class, int[].class, int.class);</span>
          }
      }
  
<span class="line-modified">!     private static void registerSHAPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
          boolean useSha1 = config.useSHA1Intrinsics();
          boolean useSha256 = config.useSHA256Intrinsics();
          boolean useSha512 = config.useSHA512Intrinsics();
  
<span class="line-modified">!         if (!Java8OrEarlier &amp;&amp; (useSha1 || useSha256 || useSha512)) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;sun.security.provider.DigestBase&quot;, bytecodeProvider);</span>
              r.registerMethodSubstitution(DigestBaseSubstitutions.class, &quot;implCompressMultiBlock0&quot;, Receiver.class, byte[].class, int.class, int.class);
          }
  
          if (useSha1) {
              assert config.sha1ImplCompress != 0L;
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA&quot;, bytecodeProvider);</span>
<span class="line-modified">!             r.registerMethodSubstitution(SHASubstitutions.class, SHASubstitutions.implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
          }
          if (useSha256) {
              assert config.sha256ImplCompress != 0L;
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA2&quot;, bytecodeProvider);</span>
<span class="line-modified">!             r.registerMethodSubstitution(SHA2Substitutions.class, SHA2Substitutions.implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
          }
          if (useSha512) {
              assert config.sha512ImplCompress != 0L;
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA5&quot;, bytecodeProvider);</span>
<span class="line-modified">!             r.registerMethodSubstitution(SHA5Substitutions.class, SHA5Substitutions.implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
          }
      }
  
      private static void registerGHASHPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {
          if (config.useGHASHIntrinsics()) {
<span class="line-new-header">--- 478,158 ---</span>
                  b.addPush(JavaKind.Object, new ReadNode(address, JAVA_THREAD_THREAD_OBJECT_LOCATION, stamp, BarrierType.NONE));
                  return true;
              }
          });
  
<span class="line-modified">!         if (config.osThreadInterruptedOffset != Integer.MAX_VALUE) {</span>
<span class="line-modified">!             r.registerMethodSubstitution(ThreadSubstitutions.class, &quot;isInterrupted&quot;, Receiver.class, boolean.class);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!     }</span>
  
      public static final String reflectionClass;
      public static final String constantPoolClass;
  
      static {
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
              reflectionClass = &quot;sun.reflect.Reflection&quot;;
              constantPoolClass = &quot;sun.reflect.ConstantPool&quot;;
          } else {
              reflectionClass = &quot;jdk.internal.reflect.Reflection&quot;;
              constantPoolClass = &quot;jdk.internal.reflect.ConstantPool&quot;;
          }
      }
  
<span class="line-modified">!     public static String lookupIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {</span>
<span class="line-added">+         return selectIntrinsicName(config, className, name1, name2).getLeft();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns a pair of Strings where the left one represents the matched intrinsic name and the</span>
<span class="line-added">+      * right one represents the mismatched intrinsic name.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static Pair&lt;String, String&gt; selectIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {</span>
<span class="line-added">+         boolean foundName1 = false;</span>
<span class="line-added">+         boolean foundName2 = false;</span>
<span class="line-added">+         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {</span>
<span class="line-added">+             if (className.equals(intrinsic.declaringClass)) {</span>
<span class="line-added">+                 if (name1.equals(intrinsic.name)) {</span>
<span class="line-added">+                     foundName1 = true;</span>
<span class="line-added">+                 } else if (name2.equals(intrinsic.name)) {</span>
<span class="line-added">+                     foundName2 = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (foundName1 &amp;&amp; !foundName2) {</span>
<span class="line-added">+             return Pair.create(name1, name2);</span>
<span class="line-added">+         } else if (foundName2 &amp;&amp; !foundName1) {</span>
<span class="line-added">+             return Pair.create(name2, name1);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         throw GraalError.shouldNotReachHere();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public static boolean isIntrinsicName(GraalHotSpotVMConfig config, String className, String name) {</span>
<span class="line-added">+         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {</span>
<span class="line-added">+             if (className.equals(intrinsic.declaringClass)) {</span>
<span class="line-added">+                 if (name.equals(intrinsic.name)) {</span>
<span class="line-added">+                     return true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static void registerAESPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
          if (config.useAESIntrinsics) {
              assert config.aescryptEncryptBlockStub != 0L;
              assert config.aescryptDecryptBlockStub != 0L;
              assert config.cipherBlockChainingEncryptAESCryptStub != 0L;
              assert config.cipherBlockChainingDecryptAESCryptStub != 0L;
              String arch = config.osArch;
              String decryptSuffix = arch.equals(&quot;sparc&quot;) ? &quot;WithOriginalKey&quot; : &quot;&quot;;
<span class="line-modified">! </span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CipherBlockChaining&quot;, replacements);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             Pair&lt;String, String&gt; cbcEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implEncrypt&quot;, &quot;encrypt&quot;);</span>
<span class="line-modified">!             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcEncryptName, Receiver.class, byte[].class, int.class, int.class,</span>
<span class="line-modified">!                             byte[].class, int.class);</span>
<span class="line-modified">! </span>
<span class="line-added">+             Pair&lt;String, String&gt; cbcDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implDecrypt&quot;, &quot;decrypt&quot;);</span>
<span class="line-added">+             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcDecryptName, cbcDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, int.class,</span>
<span class="line-added">+                             byte[].class, int.class);</span>
<span class="line-added">+ </span>
<span class="line-added">+             r = new Registration(plugins, &quot;com.sun.crypto.provider.AESCrypt&quot;, replacements);</span>
<span class="line-added">+ </span>
<span class="line-added">+             Pair&lt;String, String&gt; aesEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implEncryptBlock&quot;, &quot;encryptBlock&quot;);</span>
<span class="line-added">+             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesEncryptName, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>
<span class="line-added">+ </span>
<span class="line-added">+             Pair&lt;String, String&gt; aesDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implDecryptBlock&quot;, &quot;decryptBlock&quot;);</span>
<span class="line-added">+             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesDecryptName, aesDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>
          }
      }
  
<span class="line-modified">!     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, Type... argumentTypes) {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), argumentTypes);</span>
<span class="line-modified">!         } catch (NoSuchMethodError e) {</span>
<span class="line-modified">!             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,</span>
<span class="line-modified">!                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));</span>
          }
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, String substituteName, Type... argumentTypes) {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), substituteName, argumentTypes);</span>
<span class="line-modified">!         } catch (NoSuchMethodError e) {</span>
<span class="line-modified">!             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,</span>
<span class="line-modified">!                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));</span>
          }
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-added">+     private static void registerBigIntegerPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-added">+         Registration r = new Registration(plugins, BigInteger.class, replacements);</span>
<span class="line-added">+         assert !config.useMultiplyToLenIntrinsic() || config.multiplyToLen != 0L;</span>
<span class="line-added">+         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-added">+             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;multiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,</span>
<span class="line-added">+                             int.class, int[].class);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implMultiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,</span>
<span class="line-added">+                             int.class, int[].class);</span>
          }
<span class="line-added">+         r.registerConditionalMethodSubstitution(config.useMulAddIntrinsic(), BigIntegerSubstitutions.class, &quot;implMulAdd&quot;, int[].class, int[].class, int.class, int.class, int.class);</span>
<span class="line-added">+         r.registerConditionalMethodSubstitution(config.useMontgomeryMultiplyIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomeryMultiply&quot;, int[].class, int[].class, int[].class, int.class,</span>
<span class="line-added">+                         long.class, int[].class);</span>
<span class="line-added">+         r.registerConditionalMethodSubstitution(config.useMontgomerySquareIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomerySquare&quot;, int[].class, int[].class, int.class, long.class,</span>
<span class="line-added">+                         int[].class);</span>
<span class="line-added">+         r.registerConditionalMethodSubstitution(config.useSquareToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implSquareToLen&quot;, int[].class, int.class, int[].class, int.class);</span>
      }
  
<span class="line-modified">!     private static void registerSHAPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
          boolean useSha1 = config.useSHA1Intrinsics();
          boolean useSha256 = config.useSHA256Intrinsics();
          boolean useSha512 = config.useSHA512Intrinsics();
  
<span class="line-modified">!         if (isIntrinsicName(config, &quot;sun/security/provider/DigestBase&quot;, &quot;implCompressMultiBlock0&quot;) &amp;&amp; (useSha1 || useSha256 || useSha512)) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;sun.security.provider.DigestBase&quot;, replacements);</span>
              r.registerMethodSubstitution(DigestBaseSubstitutions.class, &quot;implCompressMultiBlock0&quot;, Receiver.class, byte[].class, int.class, int.class);
          }
  
<span class="line-added">+         Pair&lt;String, String&gt; implCompressName = selectIntrinsicName(config, &quot;sun/security/provider/SHA&quot;, &quot;implCompress&quot;, &quot;implCompress0&quot;);</span>
          if (useSha1) {
              assert config.sha1ImplCompress != 0L;
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA&quot;, replacements);</span>
<span class="line-modified">!             registerAndCheckMismatch(r, SHASubstitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
          }
          if (useSha256) {
              assert config.sha256ImplCompress != 0L;
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA2&quot;, replacements);</span>
<span class="line-modified">!             registerAndCheckMismatch(r, SHA2Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
          }
          if (useSha512) {
              assert config.sha512ImplCompress != 0L;
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA5&quot;, replacements);</span>
<span class="line-modified">!             registerAndCheckMismatch(r, SHA5Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
          }
      }
  
      private static void registerGHASHPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {
          if (config.useGHASHIntrinsics()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 553,42 ***</span>
                                  }
                              });
          }
      }
  
<span class="line-modified">!     private static void registerCounterModePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         if (config.useAESCTRIntrinsics) {</span>
<span class="line-modified">!             assert config.counterModeAESCrypt != 0L;</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CounterMode&quot;, bytecodeProvider);</span>
<span class="line-modified">!             r.registerMethodSubstitution(CounterModeSubstitutions.class, &quot;implCrypt&quot;, Receiver.class, byte[].class, int.class, int.class, byte[].class, int.class);</span>
          }
      }
  
<span class="line-modified">!     private static void registerCRC32Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         if (config.useCRC32Intrinsics) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, CRC32.class, bytecodeProvider);</span>
<span class="line-modified">!             r.registerMethodSubstitution(CRC32Substitutions.class, &quot;update&quot;, int.class, int.class);</span>
<span class="line-modified">!             if (Java8OrEarlier) {</span>
<span class="line-modified">!                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateBytes0&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateByteBuffer0&quot;, int.class, long.class, int.class, int.class);</span>
<span class="line-modified">!             }</span>
          }
      }
  
<span class="line-modified">!     private static void registerCRC32CPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         if (config.useCRC32CIntrinsics) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;java.util.zip.CRC32C&quot;, bytecodeProvider);</span>
<span class="line-modified">!             r.registerMethodSubstitution(CRC32CSubstitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(CRC32CSubstitutions.class, &quot;updateDirectByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
          }
      }
  
<span class="line-modified">!     private static void registerArraysSupportPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         if (config.useVectorizedMismatchIntrinsic) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;jdk.internal.util.ArraysSupport&quot;, bytecodeProvider);</span>
<span class="line-modified">!             r.registerMethodSubstitution(ArraysSupportSubstitutions.class, &quot;vectorizedMismatch&quot;, Object.class, long.class, Object.class, long.class, int.class, int.class);</span>
          }
      }
  }
<span class="line-new-header">--- 662,74 ---</span>
                                  }
                              });
          }
      }
  
<span class="line-modified">!     private static void registerCounterModePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">!             assert !config.useAESCTRIntrinsics || config.counterModeAESCrypt != 0L;</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CounterMode&quot;, replacements);</span>
<span class="line-modified">!             r.registerConditionalMethodSubstitution(config.useAESCTRIntrinsics, CounterModeSubstitutions.class, &quot;implCrypt&quot;, Receiver.class, byte[].class, int.class, int.class, byte[].class,</span>
<span class="line-added">+                             int.class);</span>
          }
      }
  
<span class="line-modified">!     private static void registerBase64Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {</span>
<span class="line-modified">!         if (config.useBase64Intrinsics()) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;java.util.Base64$Encoder&quot;);</span>
<span class="line-modified">!             r.register7(&quot;encodeBlock&quot;,</span>
<span class="line-modified">!                             Receiver.class,</span>
<span class="line-modified">!                             byte[].class,</span>
<span class="line-modified">!                             int.class,</span>
<span class="line-modified">!                             int.class,</span>
<span class="line-modified">!                             byte[].class,</span>
<span class="line-modified">!                             int.class,</span>
<span class="line-modified">!                             boolean.class,</span>
<span class="line-added">+                             new InvocationPlugin() {</span>
<span class="line-added">+                                 @Override</span>
<span class="line-added">+                                 public boolean apply(GraphBuilderContext b,</span>
<span class="line-added">+                                                 ResolvedJavaMethod targetMethod,</span>
<span class="line-added">+                                                 Receiver receiver,</span>
<span class="line-added">+                                                 ValueNode src,</span>
<span class="line-added">+                                                 ValueNode sp,</span>
<span class="line-added">+                                                 ValueNode sl,</span>
<span class="line-added">+                                                 ValueNode dst,</span>
<span class="line-added">+                                                 ValueNode dp,</span>
<span class="line-added">+                                                 ValueNode isURL) {</span>
<span class="line-added">+                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);</span>
<span class="line-added">+                                     ComputeObjectAddressNode srcAddress = b.add(new ComputeObjectAddressNode(src, ConstantNode.forInt(byteArrayBaseOffset)));</span>
<span class="line-added">+                                     ComputeObjectAddressNode dstAddress = b.add(new ComputeObjectAddressNode(dst, ConstantNode.forInt(byteArrayBaseOffset)));</span>
<span class="line-added">+                                     b.add(new ForeignCallNode(foreignCalls, BASE64_ENCODE_BLOCK, srcAddress, sp, sl, dstAddress, dp, isURL));</span>
<span class="line-added">+                                     return true;</span>
<span class="line-added">+                                 }</span>
<span class="line-added">+                             });</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static void registerCRC32Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-added">+         Registration r = new Registration(plugins, CRC32.class, replacements);</span>
<span class="line-added">+         r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;update&quot;, int.class, int.class);</span>
<span class="line-added">+         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-added">+             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-added">+             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes0&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-added">+             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer0&quot;, int.class, long.class, int.class, int.class);</span>
          }
      }
  
<span class="line-modified">!     private static void registerCRC32CPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;java.util.zip.CRC32C&quot;, replacements);</span>
<span class="line-modified">!             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateDirectByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
          }
      }
  
<span class="line-modified">!     private static void registerArraysSupportPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;jdk.internal.util.ArraysSupport&quot;, replacements);</span>
<span class="line-modified">!             r.registerConditionalMethodSubstitution(config.useVectorizedMismatchIntrinsic, ArraysSupportSubstitutions.class, &quot;vectorizedMismatch&quot;, Object.class, long.class, Object.class, long.class,</span>
<span class="line-added">+                             int.class, int.class);</span>
          }
      }
  }
</pre>
<center><a href="HotSpotGraalConstantFieldProvider.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotHostForeignCallsProvider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
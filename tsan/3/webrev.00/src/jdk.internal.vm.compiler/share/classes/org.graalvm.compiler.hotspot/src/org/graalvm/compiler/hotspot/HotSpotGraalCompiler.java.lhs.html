<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalCompiler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.OptAssumptions;
 28 
 29 import java.io.ByteArrayOutputStream;
 30 import java.io.PrintStream;
 31 import java.util.Collections;
 32 import java.util.Formattable;
 33 import java.util.Formatter;
 34 import java.util.List;
 35 
 36 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
 37 import org.graalvm.compiler.code.CompilationResult;
 38 import org.graalvm.compiler.core.GraalCompiler;
 39 import org.graalvm.compiler.core.common.CompilationIdentifier;
 40 import org.graalvm.compiler.core.common.util.CompilationAlarm;
 41 import org.graalvm.compiler.debug.DebugContext;
 42 import org.graalvm.compiler.debug.DebugContext.Activation;
 43 import org.graalvm.compiler.debug.DebugHandlersFactory;
 44 import org.graalvm.compiler.debug.DebugOptions;
 45 import org.graalvm.compiler.hotspot.CompilationCounters.Options;
 46 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 47 import org.graalvm.compiler.hotspot.phases.OnStackReplacementPhase;
 48 import org.graalvm.compiler.java.GraphBuilderPhase;
 49 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 50 import org.graalvm.compiler.lir.phases.LIRSuites;
<a name="2" id="anc2"></a>
 51 import org.graalvm.compiler.nodes.StructuredGraph;
 52 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 53 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 54 import org.graalvm.compiler.options.OptionValues;
 55 import org.graalvm.compiler.phases.OptimisticOptimizations;
 56 import org.graalvm.compiler.phases.OptimisticOptimizations.Optimization;
 57 import org.graalvm.compiler.phases.PhaseSuite;
 58 import org.graalvm.compiler.phases.tiers.HighTierContext;
 59 import org.graalvm.compiler.phases.tiers.Suites;
 60 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
<a name="3" id="anc3"></a>
 61 
 62 import jdk.vm.ci.code.CompilationRequest;
 63 import jdk.vm.ci.code.CompilationRequestResult;
 64 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 65 import jdk.vm.ci.hotspot.HotSpotCompilationRequestResult;
 66 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 67 import jdk.vm.ci.meta.DefaultProfilingInfo;
 68 import jdk.vm.ci.meta.JavaMethod;
 69 import jdk.vm.ci.meta.ProfilingInfo;
 70 import jdk.vm.ci.meta.ResolvedJavaMethod;
 71 import jdk.vm.ci.meta.SpeculationLog;
 72 import jdk.vm.ci.meta.TriState;
 73 import jdk.vm.ci.runtime.JVMCICompiler;
<a name="4" id="anc4"></a>
 74 
<a name="5" id="anc5"></a><span class="line-modified"> 75 public class HotSpotGraalCompiler implements GraalJVMCICompiler {</span>
 76 
<a name="6" id="anc6"></a>
 77     private final HotSpotJVMCIRuntime jvmciRuntime;
 78     private final HotSpotGraalRuntimeProvider graalRuntime;
 79     private final CompilationCounters compilationCounters;
 80     private final BootstrapWatchDog bootstrapWatchDog;
 81     private List&lt;DebugHandlersFactory&gt; factories;
 82 
 83     HotSpotGraalCompiler(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalRuntimeProvider graalRuntime, OptionValues options) {
 84         this.jvmciRuntime = jvmciRuntime;
 85         this.graalRuntime = graalRuntime;
<a name="7" id="anc7"></a><span class="line-modified"> 86         // It is sufficient to have one compilation counter object per Graal compiler object.</span>
 87         this.compilationCounters = Options.CompilationCountLimit.getValue(options) &gt; 0 ? new CompilationCounters(options) : null;
 88         this.bootstrapWatchDog = graalRuntime.isBootstrapping() &amp;&amp; !DebugOptions.BootstrapInitializeOnly.getValue(options) ? BootstrapWatchDog.maybeCreate(graalRuntime) : null;
 89     }
 90 
 91     public List&lt;DebugHandlersFactory&gt; getDebugHandlersFactories() {
 92         if (factories == null) {
 93             factories = Collections.singletonList(new GraalDebugHandlersFactory(graalRuntime.getHostProviders().getSnippetReflection()));
 94         }
 95         return factories;
 96     }
 97 
 98     @Override
 99     public HotSpotGraalRuntimeProvider getGraalRuntime() {
100         return graalRuntime;
101     }
102 
103     @Override
104     public CompilationRequestResult compileMethod(CompilationRequest request) {
105         return compileMethod(request, true, graalRuntime.getOptions());
106     }
107 
108     @SuppressWarnings(&quot;try&quot;)
<a name="8" id="anc8"></a><span class="line-modified">109     CompilationRequestResult compileMethod(CompilationRequest request, boolean installAsDefault, OptionValues options) {</span>
<span class="line-modified">110         if (graalRuntime.isShutdown()) {</span>
<span class="line-modified">111             return HotSpotCompilationRequestResult.failure(String.format(&quot;Shutdown entered&quot;), false);</span>
<span class="line-modified">112         }</span>

113 
<a name="9" id="anc9"></a><span class="line-modified">114         ResolvedJavaMethod method = request.getMethod();</span>
115 
<a name="10" id="anc10"></a><span class="line-modified">116         if (graalRuntime.isBootstrapping()) {</span>
<span class="line-modified">117             if (DebugOptions.BootstrapInitializeOnly.getValue(options)) {</span>
<span class="line-modified">118                 return HotSpotCompilationRequestResult.failure(String.format(&quot;Skip compilation because %s is enabled&quot;, DebugOptions.BootstrapInitializeOnly.getName()), true);</span>







119             }
<a name="11" id="anc11"></a><span class="line-modified">120             if (bootstrapWatchDog != null) {</span>
<span class="line-modified">121                 if (bootstrapWatchDog.hitCriticalCompilationRateOrTimeout()) {</span>
<span class="line-modified">122                     // Drain the compilation queue to expedite completion of the bootstrap</span>
<span class="line-modified">123                     return HotSpotCompilationRequestResult.failure(&quot;hit critical bootstrap compilation rate or timeout&quot;, true);</span>




124                 }
<a name="12" id="anc12"></a>






125             }
126         }
<a name="13" id="anc13"></a><span class="line-modified">127         HotSpotCompilationRequest hsRequest = (HotSpotCompilationRequest) request;</span>
<span class="line-modified">128         try (CompilationWatchDog w1 = CompilationWatchDog.watch(method, hsRequest.getId(), options);</span>
<span class="line-modified">129                         BootstrapWatchDog.Watch w2 = bootstrapWatchDog == null ? null : bootstrapWatchDog.watch(request);</span>
<span class="line-modified">130                         CompilationAlarm alarm = CompilationAlarm.trackCompilationPeriod(options);) {</span>
<span class="line-modified">131             if (compilationCounters != null) {</span>
<span class="line-modified">132                 compilationCounters.countCompilation(method);</span>




133             }
<a name="14" id="anc14"></a><span class="line-modified">134             CompilationTask task = new CompilationTask(jvmciRuntime, this, hsRequest, true, installAsDefault, options);</span>
<span class="line-modified">135             CompilationRequestResult r = null;</span>
<span class="line-modified">136             try (DebugContext debug = graalRuntime.openDebugContext(options, task.getCompilationIdentifier(), method, getDebugHandlersFactories(), DebugContext.DEFAULT_LOG_STREAM);</span>
<span class="line-modified">137                             Activation a = debug.activate()) {</span>
<span class="line-removed">138                 r = task.runCompilation(debug);</span>
139             }
<a name="15" id="anc15"></a><span class="line-removed">140             assert r != null;</span>
<span class="line-removed">141             return r;</span>
142         }
<a name="16" id="anc16"></a>





143     }
144 
145     public StructuredGraph createGraph(ResolvedJavaMethod method, int entryBCI, boolean useProfilingInfo, CompilationIdentifier compilationId, OptionValues options, DebugContext debug) {
146         HotSpotBackend backend = graalRuntime.getHostBackend();
147         HotSpotProviders providers = backend.getProviders();
148         final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
<a name="17" id="anc17"></a><span class="line-modified">149         StructuredGraph graph = method.isNative() || isOSR ? null : providers.getReplacements().getIntrinsicGraph(method, compilationId, debug);</span>
150 
151         if (graph == null) {
152             SpeculationLog speculationLog = method.getSpeculationLog();
153             if (speculationLog != null) {
154                 speculationLog.collectFailedSpeculations();
155             }
<a name="18" id="anc18"></a><span class="line-modified">156             graph = new StructuredGraph.Builder(options, debug, AllowAssumptions.ifTrue(OptAssumptions.getValue(options))).method(method).entryBCI(entryBCI).speculationLog(</span>
<span class="line-modified">157                             speculationLog).useProfilingInfo(useProfilingInfo).compilationId(compilationId).build();</span>







158         }
159         return graph;
160     }
161 
162     public CompilationResult compileHelper(CompilationResultBuilderFactory crbf, CompilationResult result, StructuredGraph graph, ResolvedJavaMethod method, int entryBCI, boolean useProfilingInfo,
163                     OptionValues options) {
<a name="19" id="anc19"></a>

164 
<a name="20" id="anc20"></a>


165         HotSpotBackend backend = graalRuntime.getHostBackend();
166         HotSpotProviders providers = backend.getProviders();
167         final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
168 
169         Suites suites = getSuites(providers, options);
170         LIRSuites lirSuites = getLIRSuites(providers, options);
171         ProfilingInfo profilingInfo = useProfilingInfo ? method.getProfilingInfo(!isOSR, isOSR) : DefaultProfilingInfo.get(TriState.FALSE);
172         OptimisticOptimizations optimisticOpts = getOptimisticOpts(profilingInfo, options);
173 
174         /*
175          * Cut off never executed code profiles if there is code, e.g. after the osr loop, that is
176          * never executed.
177          */
178         if (isOSR &amp;&amp; !OnStackReplacementPhase.Options.DeoptAfterOSR.getValue(options)) {
179             optimisticOpts.remove(Optimization.RemoveNeverExecutedCode);
180         }
181 
182         result.setEntryBCI(entryBCI);
183         boolean shouldDebugNonSafepoints = providers.getCodeCache().shouldDebugNonSafepoints();
<a name="21" id="anc21"></a><span class="line-modified">184         PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = configGraphBuilderSuite(providers.getSuites().getDefaultGraphBuilderSuite(), shouldDebugNonSafepoints, isOSR);</span>
185         GraalCompiler.compileGraph(graph, method, providers, backend, graphBuilderSuite, optimisticOpts, profilingInfo, suites, lirSuites, result, crbf, true);
186 
187         if (!isOSR &amp;&amp; useProfilingInfo) {
188             ProfilingInfo profile = profilingInfo;
189             profile.setCompilerIRSize(StructuredGraph.class, graph.getNodeCount());
190         }
191 
192         return result;
193     }
194 
<a name="22" id="anc22"></a><span class="line-modified">195     public CompilationResult compile(ResolvedJavaMethod method, int entryBCI, boolean useProfilingInfo, CompilationIdentifier compilationId, OptionValues options, DebugContext debug) {</span>
<span class="line-modified">196         StructuredGraph graph = createGraph(method, entryBCI, useProfilingInfo, compilationId, options, debug);</span>





197         CompilationResult result = new CompilationResult(compilationId);
<a name="23" id="anc23"></a><span class="line-modified">198         return compileHelper(CompilationResultBuilderFactory.Default, result, graph, method, entryBCI, useProfilingInfo, options);</span>
199     }
200 
201     protected OptimisticOptimizations getOptimisticOpts(ProfilingInfo profilingInfo, OptionValues options) {
202         return new OptimisticOptimizations(profilingInfo, options);
203     }
204 
205     protected Suites getSuites(HotSpotProviders providers, OptionValues options) {
206         return providers.getSuites().getDefaultSuites(options);
207     }
208 
209     protected LIRSuites getLIRSuites(HotSpotProviders providers, OptionValues options) {
210         return providers.getSuites().getDefaultLIRSuites(options);
211     }
212 
213     /**
214      * Reconfigures a given graph builder suite (GBS) if one of the given GBS parameter values is
215      * not the default.
216      *
217      * @param suite the graph builder suite
218      * @param shouldDebugNonSafepoints specifies if extra debug info should be generated (default is
219      *            false)
<a name="24" id="anc24"></a>

220      * @param isOSR specifies if extra OSR-specific post-processing is required (default is false)
221      * @return a new suite derived from {@code suite} if any of the GBS parameters did not have a
222      *         default value otherwise {@code suite}
223      */
<a name="25" id="anc25"></a><span class="line-modified">224     protected PhaseSuite&lt;HighTierContext&gt; configGraphBuilderSuite(PhaseSuite&lt;HighTierContext&gt; suite, boolean shouldDebugNonSafepoints, boolean isOSR) {</span>
<span class="line-modified">225         if (shouldDebugNonSafepoints || isOSR) {</span>
226             PhaseSuite&lt;HighTierContext&gt; newGbs = suite.copy();
<a name="26" id="anc26"></a><span class="line-modified">227 </span>

228             if (shouldDebugNonSafepoints) {
<a name="27" id="anc27"></a><span class="line-removed">229                 GraphBuilderPhase graphBuilderPhase = (GraphBuilderPhase) newGbs.findPhase(GraphBuilderPhase.class).previous();</span>
<span class="line-removed">230                 GraphBuilderConfiguration graphBuilderConfig = graphBuilderPhase.getGraphBuilderConfig();</span>
231                 graphBuilderConfig = graphBuilderConfig.withNodeSourcePosition(true);
<a name="28" id="anc28"></a><span class="line-removed">232                 GraphBuilderPhase newGraphBuilderPhase = new GraphBuilderPhase(graphBuilderConfig);</span>
<span class="line-removed">233                 newGbs.findPhase(GraphBuilderPhase.class).set(newGraphBuilderPhase);</span>
234             }
<a name="29" id="anc29"></a>




235             if (isOSR) {
<a name="30" id="anc30"></a><span class="line-removed">236                 // We must not clear non liveness for OSR compilations.</span>
<span class="line-removed">237                 GraphBuilderPhase graphBuilderPhase = (GraphBuilderPhase) newGbs.findPhase(GraphBuilderPhase.class).previous();</span>
<span class="line-removed">238                 GraphBuilderConfiguration graphBuilderConfig = graphBuilderPhase.getGraphBuilderConfig();</span>
<span class="line-removed">239                 GraphBuilderPhase newGraphBuilderPhase = new GraphBuilderPhase(graphBuilderConfig);</span>
<span class="line-removed">240                 newGbs.findPhase(GraphBuilderPhase.class).set(newGraphBuilderPhase);</span>
241                 newGbs.appendPhase(new OnStackReplacementPhase());
242             }
243             return newGbs;
244         }
245         return suite;
246     }
247 
248     /**
249      * Converts {@code method} to a String with {@link JavaMethod#format(String)} and the format
250      * string {@code &quot;%H.%n(%p)&quot;}.
251      */
252     static String str(JavaMethod method) {
253         return method.format(&quot;%H.%n(%p)&quot;);
254     }
255 
256     /**
257      * Wraps {@code obj} in a {@link Formatter} that standardizes formatting for certain objects.
258      */
259     static Formattable fmt(Object obj) {
260         return new Formattable() {
261             @Override
262             public void formatTo(Formatter buf, int flags, int width, int precision) {
263                 if (obj instanceof Throwable) {
264                     ByteArrayOutputStream baos = new ByteArrayOutputStream();
265                     ((Throwable) obj).printStackTrace(new PrintStream(baos));
266                     buf.format(&quot;%s&quot;, baos.toString());
267                 } else if (obj instanceof StackTraceElement[]) {
268                     for (StackTraceElement e : (StackTraceElement[]) obj) {
269                         buf.format(&quot;\t%s%n&quot;, e);
270                     }
271                 } else if (obj instanceof JavaMethod) {
272                     buf.format(&quot;%s&quot;, str((JavaMethod) obj));
273                 } else {
274                     buf.format(&quot;%s&quot;, obj);
275                 }
276             }
277         };
278     }
279 }
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
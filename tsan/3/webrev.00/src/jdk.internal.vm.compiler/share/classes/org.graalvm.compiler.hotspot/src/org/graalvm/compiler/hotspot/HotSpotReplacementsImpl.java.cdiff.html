<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotReplacementsImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotLIRGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotTTYStreamProvider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotReplacementsImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,11 ***</span>
  
  package org.graalvm.compiler.hotspot;
  
  import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
<span class="line-modified">! import static org.graalvm.compiler.replacements.ReplacementsImpl.Options.UseEncodedSnippets;</span>
  
  import java.util.Set;
  
  import jdk.internal.vm.compiler.collections.EconomicSet;
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
<span class="line-new-header">--- 24,13 ---</span>
  
  package org.graalvm.compiler.hotspot;
  
  import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
<span class="line-modified">! import static org.graalvm.compiler.core.common.GraalOptions.UseEncodedGraphs;</span>
<span class="line-added">+ import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION;</span>
<span class="line-added">+ import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;</span>
  
  import java.util.Set;
  
  import jdk.internal.vm.compiler.collections.EconomicSet;
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,14 ***</span>
<span class="line-new-header">--- 39,16 ---</span>
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.NodeSourcePosition;
  import org.graalvm.compiler.hotspot.meta.HotSpotWordOperationPlugin;
  import org.graalvm.compiler.hotspot.word.HotSpotOperation;
<span class="line-added">+ import org.graalvm.compiler.nodes.Cancellable;</span>
  import org.graalvm.compiler.nodes.Invoke;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderPlugin;
<span class="line-added">+ import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.util.Providers;
  import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,49 ***</span>
  /**
   * Filters certain method substitutions based on whether there is underlying hardware support for
   * them.
   */
  public class HotSpotReplacementsImpl extends ReplacementsImpl {
<span class="line-modified">!     public HotSpotReplacementsImpl(OptionValues options, Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider, TargetDescription target) {</span>
<span class="line-modified">!         super(options, new GraalDebugHandlersFactory(snippetReflection), providers, snippetReflection, bytecodeProvider, target);</span>
      }
  
<span class="line-modified">!     protected HotSpotReplacementsImpl(HotSpotReplacementsImpl replacements, Providers providers) {</span>
<span class="line-modified">!         super(replacements.options, new GraalDebugHandlersFactory(replacements.snippetReflection), providers, replacements.snippetReflection,</span>
                          replacements.getDefaultReplacementBytecodeProvider(), replacements.target);
      }
  
      @Override
      public Class&lt;? extends GraphBuilderPlugin&gt; getIntrinsifyingPlugin(ResolvedJavaMethod method) {
          return method.getAnnotation(HotSpotOperation.class) != null ? HotSpotWordOperationPlugin.class : super.getIntrinsifyingPlugin(method);
      }
  
<span class="line-modified">!     public void registerMethodSubstitution(ResolvedJavaMethod method, ResolvedJavaMethod original) {</span>
<span class="line-modified">!         if (!IS_IN_NATIVE_IMAGE) {</span>
<span class="line-modified">!             if (IS_BUILDING_NATIVE_IMAGE || UseEncodedSnippets.getValue(options)) {</span>
<span class="line-modified">!                 synchronized (HotSpotReplacementsImpl.class) {</span>
<span class="line-modified">!                     if (snippetEncoder == null) {</span>
<span class="line-modified">!                         snippetEncoder = new SymbolicSnippetEncoder(this);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     snippetEncoder.registerMethodSubstitution(method, original);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
          }
      }
  
      @Override
<span class="line-modified">!     public StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug) {</span>
<span class="line-modified">!         if (IS_IN_NATIVE_IMAGE) {</span>
              HotSpotReplacementsImpl replacements = (HotSpotReplacementsImpl) providers.getReplacements();
              InvocationPlugin plugin = replacements.getGraphBuilderPlugins().getInvocationPlugins().lookupInvocation(method);
              if (plugin instanceof MethodSubstitutionPlugin) {
                  MethodSubstitutionPlugin msp = (MethodSubstitutionPlugin) plugin;
<span class="line-modified">!                 return replacements.getMethodSubstitution(msp, method);</span>
              }
              return null;
          }
<span class="line-modified">!         return super.getIntrinsicGraph(method, compilationId, debug);</span>
      }
  
      @Override
      public void notifyNotInlined(GraphBuilderContext b, ResolvedJavaMethod method, Invoke invoke) {
          if (b.parsingIntrinsic() &amp;&amp; snippetEncoder != null) {
<span class="line-new-header">--- 61,92 ---</span>
  /**
   * Filters certain method substitutions based on whether there is underlying hardware support for
   * them.
   */
  public class HotSpotReplacementsImpl extends ReplacementsImpl {
<span class="line-modified">!     public HotSpotReplacementsImpl(Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider, TargetDescription target) {</span>
<span class="line-modified">!         super(new GraalDebugHandlersFactory(snippetReflection), providers, snippetReflection, bytecodeProvider, target);</span>
      }
  
<span class="line-modified">!     HotSpotReplacementsImpl(HotSpotReplacementsImpl replacements, Providers providers) {</span>
<span class="line-modified">!         super(new GraalDebugHandlersFactory(replacements.snippetReflection), providers, replacements.snippetReflection,</span>
                          replacements.getDefaultReplacementBytecodeProvider(), replacements.target);
      }
  
<span class="line-added">+     public void maybeInitializeEncoder(OptionValues options) {</span>
<span class="line-added">+         if (IS_BUILDING_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {</span>
<span class="line-added">+             synchronized (HotSpotReplacementsImpl.class) {</span>
<span class="line-added">+                 if (snippetEncoder == null) {</span>
<span class="line-added">+                     snippetEncoder = new SymbolicSnippetEncoder(this);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public Class&lt;? extends GraphBuilderPlugin&gt; getIntrinsifyingPlugin(ResolvedJavaMethod method) {
          return method.getAnnotation(HotSpotOperation.class) != null ? HotSpotWordOperationPlugin.class : super.getIntrinsifyingPlugin(method);
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public void registerMethodSubstitution(MethodSubstitutionPlugin plugin) {</span>
<span class="line-modified">!         if (snippetEncoder != null) {</span>
<span class="line-modified">!             snippetEncoder.registerMethodSubstitution(plugin);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public void registerConditionalPlugin(InvocationPlugin plugin) {</span>
<span class="line-modified">!         if (snippetEncoder != null) {</span>
<span class="line-added">+             snippetEncoder.registerConditionalPlugin(plugin);</span>
          }
      }
  
<span class="line-added">+     public void checkRegistered(MethodSubstitutionPlugin plugin) {</span>
<span class="line-added">+         snippetEncoder.checkRegistered(plugin);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
<span class="line-modified">!     public StructuredGraph getIntrinsicGraph(ResolvedJavaMethod method, CompilationIdentifier compilationId, DebugContext debug, Cancellable cancellable) {</span>
<span class="line-modified">!         boolean useEncodedGraphs = UseEncodedGraphs.getValue(debug.getOptions());</span>
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE || useEncodedGraphs) {</span>
              HotSpotReplacementsImpl replacements = (HotSpotReplacementsImpl) providers.getReplacements();
              InvocationPlugin plugin = replacements.getGraphBuilderPlugins().getInvocationPlugins().lookupInvocation(method);
              if (plugin instanceof MethodSubstitutionPlugin) {
                  MethodSubstitutionPlugin msp = (MethodSubstitutionPlugin) plugin;
<span class="line-modified">!                 if (!IS_IN_NATIVE_IMAGE &amp;&amp; useEncodedGraphs) {</span>
<span class="line-added">+                     replacements.maybeInitializeEncoder(debug.getOptions());</span>
<span class="line-added">+                     replacements.registerMethodSubstitution(msp);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 StructuredGraph methodSubstitution = replacements.getMethodSubstitution(msp, method, ROOT_COMPILATION, StructuredGraph.AllowAssumptions.YES, cancellable, debug.getOptions());</span>
<span class="line-added">+                 methodSubstitution.resetDebug(debug);</span>
<span class="line-added">+                 return methodSubstitution;</span>
              }
              return null;
          }
<span class="line-modified">!         return super.getIntrinsicGraph(method, compilationId, debug, cancellable);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public StructuredGraph getSubstitution(ResolvedJavaMethod targetMethod, int invokeBci, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition, OptionValues options) {</span>
<span class="line-added">+         boolean useEncodedGraphs = UseEncodedGraphs.getValue(options);</span>
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE || useEncodedGraphs) {</span>
<span class="line-added">+             InvocationPlugin plugin = getGraphBuilderPlugins().getInvocationPlugins().lookupInvocation(targetMethod);</span>
<span class="line-added">+             if (plugin instanceof MethodSubstitutionPlugin &amp;&amp; (!plugin.inlineOnly() || invokeBci &gt;= 0)) {</span>
<span class="line-added">+                 MethodSubstitutionPlugin msPlugin = (MethodSubstitutionPlugin) plugin;</span>
<span class="line-added">+                 if (!IS_IN_NATIVE_IMAGE &amp;&amp; useEncodedGraphs) {</span>
<span class="line-added">+                     maybeInitializeEncoder(options);</span>
<span class="line-added">+                     registerMethodSubstitution(msPlugin);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 // This assumes the normal path creates the graph using</span>
<span class="line-added">+                 // GraphBuilderConfiguration.getSnippetDefault with omits exception edges</span>
<span class="line-added">+                 StructuredGraph subst = getMethodSubstitution(msPlugin, targetMethod, INLINE_AFTER_PARSING, StructuredGraph.AllowAssumptions.NO, null, options);</span>
<span class="line-added">+                 return subst;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return super.getSubstitution(targetMethod, invokeBci, trackNodeSourcePosition, replaceePosition, options);</span>
      }
  
      @Override
      public void notifyNotInlined(GraphBuilderContext b, ResolvedJavaMethod method, Invoke invoke) {
          if (b.parsingIntrinsic() &amp;&amp; snippetEncoder != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,31 ***</span>
      // building will not miss any snippets.
      @NativeImageReinitialize private EconomicSet&lt;ResolvedJavaMethod&gt; registeredSnippets = EconomicSet.create();
      private boolean snippetRegistrationClosed;
  
      @Override
<span class="line-modified">!     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition) {</span>
          if (!IS_IN_NATIVE_IMAGE) {
              assert !snippetRegistrationClosed : &quot;Cannot register snippet after registration is closed: &quot; + method.format(&quot;%H.%n(%p)&quot;);
              assert registeredSnippets.add(method) : &quot;Cannot register snippet twice: &quot; + method.format(&quot;%H.%n(%p)&quot;);
<span class="line-modified">!             if (IS_BUILDING_NATIVE_IMAGE || UseEncodedSnippets.getValue(options)) {</span>
                  synchronized (HotSpotReplacementsImpl.class) {
<span class="line-modified">!                     if (snippetEncoder == null) {</span>
<span class="line-removed">-                         snippetEncoder = new SymbolicSnippetEncoder(this);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     snippetEncoder.registerSnippet(method, original, receiver, trackNodeSourcePosition);</span>
                  }
              }
          }
      }
  
      @Override
      public void closeSnippetRegistration() {
          snippetRegistrationClosed = true;
      }
  
<span class="line-modified">!     static SymbolicSnippetEncoder.EncodedSnippets getEncodedSnippets() {</span>
          return encodedSnippets;
      }
  
      public Set&lt;ResolvedJavaMethod&gt; getSnippetMethods() {
          if (snippetEncoder != null) {
<span class="line-new-header">--- 163,31 ---</span>
      // building will not miss any snippets.
      @NativeImageReinitialize private EconomicSet&lt;ResolvedJavaMethod&gt; registeredSnippets = EconomicSet.create();
      private boolean snippetRegistrationClosed;
  
      @Override
<span class="line-modified">!     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {</span>
          if (!IS_IN_NATIVE_IMAGE) {
              assert !snippetRegistrationClosed : &quot;Cannot register snippet after registration is closed: &quot; + method.format(&quot;%H.%n(%p)&quot;);
              assert registeredSnippets.add(method) : &quot;Cannot register snippet twice: &quot; + method.format(&quot;%H.%n(%p)&quot;);
<span class="line-modified">!             if (IS_BUILDING_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {</span>
                  synchronized (HotSpotReplacementsImpl.class) {
<span class="line-modified">!                     snippetEncoder.registerSnippet(method, original, receiver, trackNodeSourcePosition, options);</span>
                  }
              }
          }
      }
  
      @Override
      public void closeSnippetRegistration() {
          snippetRegistrationClosed = true;
      }
  
<span class="line-modified">!     private static SymbolicSnippetEncoder.EncodedSnippets getEncodedSnippets(OptionValues options) {</span>
<span class="line-added">+         if (!IS_IN_NATIVE_IMAGE &amp;&amp; snippetEncoder != null) {</span>
<span class="line-added">+             snippetEncoder.encode(options);</span>
<span class="line-added">+         }</span>
          return encodedSnippets;
      }
  
      public Set&lt;ResolvedJavaMethod&gt; getSnippetMethods() {
          if (snippetEncoder != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,61 ***</span>
  
      static void setEncodedSnippets(SymbolicSnippetEncoder.EncodedSnippets encodedSnippets) {
          HotSpotReplacementsImpl.encodedSnippets = encodedSnippets;
      }
  
<span class="line-modified">!     public boolean encode() {</span>
          SymbolicSnippetEncoder encoder = HotSpotReplacementsImpl.snippetEncoder;
          if (encoder != null) {
<span class="line-modified">!             return encoder.encode();</span>
          }
          return false;
      }
  
      private static volatile SymbolicSnippetEncoder.EncodedSnippets encodedSnippets;
  
<span class="line-modified">!     @NativeImageReinitialize static SymbolicSnippetEncoder snippetEncoder;</span>
  
      @Override
<span class="line-modified">!     public StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition) {</span>
<span class="line-modified">!         StructuredGraph graph = getEncodedSnippet(method, args);</span>
          if (graph != null) {
              return graph;
          }
  
          assert !IS_IN_NATIVE_IMAGE : &quot;should be using encoded snippets&quot;;
<span class="line-modified">!         return super.getSnippet(method, recursiveEntry, args, trackNodeSourcePosition, replaceePosition);</span>
      }
  
<span class="line-modified">!     public StructuredGraph getEncodedSnippet(ResolvedJavaMethod method, Object[] args) {</span>
<span class="line-modified">!         if (IS_IN_NATIVE_IMAGE || UseEncodedSnippets.getValue(options)) {</span>
              synchronized (HotSpotReplacementsImpl.class) {
<span class="line-modified">!                 if (!IS_IN_NATIVE_IMAGE &amp;&amp; UseEncodedSnippets.getValue(options)) {</span>
<span class="line-removed">-                     snippetEncoder.encode();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if (getEncodedSnippets() == null) {</span>
                      throw GraalError.shouldNotReachHere(&quot;encoded snippets not found&quot;);
                  }
<span class="line-modified">!                 StructuredGraph graph = getEncodedSnippets().getEncodedSnippet(method, this, args);</span>
<span class="line-modified">!                 if (graph == null) {</span>
<span class="line-modified">!                     throw GraalError.shouldNotReachHere(&quot;snippet not found: &quot; + method.format(&quot;%H.%n(%p)&quot;));</span>
                  }
<span class="line-removed">-                 return graph;</span>
              }
<span class="line-modified">!         } else if (registeredSnippets != null) {</span>
<span class="line-modified">!             assert registeredSnippets.contains(method) : &quot;Asking for snippet method that was never registered: &quot; + method.format(&quot;%H.%n(%p)&quot;);</span>
          }
          return null;
      }
  
<span class="line-modified">!     public StructuredGraph getMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original) {</span>
<span class="line-modified">!         if (IS_IN_NATIVE_IMAGE || UseEncodedSnippets.getValue(options)) {</span>
<span class="line-modified">!             if (getEncodedSnippets() == null) {</span>
                  throw GraalError.shouldNotReachHere(&quot;encoded snippets not found&quot;);
              }
<span class="line-modified">!             return getEncodedSnippets().getMethodSubstitutionGraph(plugin, original, this);</span>
          }
          return null;
      }
  
  }
<span class="line-new-header">--- 198,65 ---</span>
  
      static void setEncodedSnippets(SymbolicSnippetEncoder.EncodedSnippets encodedSnippets) {
          HotSpotReplacementsImpl.encodedSnippets = encodedSnippets;
      }
  
<span class="line-modified">!     public boolean encode(OptionValues options) {</span>
          SymbolicSnippetEncoder encoder = HotSpotReplacementsImpl.snippetEncoder;
          if (encoder != null) {
<span class="line-modified">!             return encoder.encode(options);</span>
          }
          return false;
      }
  
      private static volatile SymbolicSnippetEncoder.EncodedSnippets encodedSnippets;
  
<span class="line-modified">!     @NativeImageReinitialize private static SymbolicSnippetEncoder snippetEncoder;</span>
  
      @Override
<span class="line-modified">!     public StructuredGraph getSnippet(ResolvedJavaMethod method, ResolvedJavaMethod recursiveEntry, Object[] args, boolean trackNodeSourcePosition, NodeSourcePosition replaceePosition,</span>
<span class="line-modified">!                     OptionValues options) {</span>
<span class="line-added">+         StructuredGraph graph = getEncodedSnippet(method, args, StructuredGraph.AllowAssumptions.NO, options);</span>
          if (graph != null) {
              return graph;
          }
  
          assert !IS_IN_NATIVE_IMAGE : &quot;should be using encoded snippets&quot;;
<span class="line-modified">!         return super.getSnippet(method, recursiveEntry, args, trackNodeSourcePosition, replaceePosition, options);</span>
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;try&quot;)</span>
<span class="line-modified">!     private StructuredGraph getEncodedSnippet(ResolvedJavaMethod method, Object[] args, StructuredGraph.AllowAssumptions allowAssumptions, OptionValues options) {</span>
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {</span>
              synchronized (HotSpotReplacementsImpl.class) {
<span class="line-modified">!                 if (getEncodedSnippets(options) == null) {</span>
                      throw GraalError.shouldNotReachHere(&quot;encoded snippets not found&quot;);
                  }
<span class="line-modified">!                 // Snippets graphs can contain foreign object reference and</span>
<span class="line-modified">!                 // outlive a single compilation.</span>
<span class="line-modified">!                 try (CompilationContext scope = HotSpotGraalServices.enterGlobalCompilationContext()) {</span>
<span class="line-added">+                     StructuredGraph graph = getEncodedSnippets(options).getEncodedSnippet(method, this, args, allowAssumptions, options);</span>
<span class="line-added">+                     if (graph == null) {</span>
<span class="line-added">+                         throw GraalError.shouldNotReachHere(&quot;snippet not found: &quot; + method.format(&quot;%H.%n(%p)&quot;));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     return graph;</span>
                  }
              }
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             assert registeredSnippets == null || registeredSnippets.contains(method) : &quot;Asking for snippet method that was never registered: &quot; + method.format(&quot;%H.%n(%p)&quot;);</span>
          }
          return null;
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public StructuredGraph getMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context,</span>
<span class="line-modified">!                     StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {</span>
<span class="line-added">+         if (IS_IN_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {</span>
<span class="line-added">+             if (getEncodedSnippets(options) == null) {</span>
                  throw GraalError.shouldNotReachHere(&quot;encoded snippets not found&quot;);
              }
<span class="line-modified">!             return getEncodedSnippets(options).getMethodSubstitutionGraph(plugin, original, this, context, allowAssumptions, cancellable, options);</span>
          }
          return null;
      }
  
  }
</pre>
<center><a href="HotSpotLIRGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotTTYStreamProvider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
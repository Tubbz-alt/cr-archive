<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/JVMCIVersionCheck.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import java.util.Formatter;
 28 import java.util.HashMap;
 29 import java.util.Map;
 30 import java.util.Properties;
 31 import java.util.regex.Matcher;
 32 import java.util.regex.Pattern;
 33 
 34 /**
 35  * Mechanism for checking that the current Java runtime environment supports the minimum JVMCI API
 36  * required by Graal. The {@code JVMCI_VERSION_CHECK} environment variable can be used to ignore a
 37  * failed check ({@code JVMCI_VERSION_CHECK=ignore}) or print a warning (
 38  * {@code JVMCI_VERSION_CHECK=warn}) and continue. Otherwise, a failed check results in an
 39  * {@link InternalError} being raised or, if called from {@link #main(String[])}, the VM exiting
 40  * with a result code of {@code -1}
 41  *
 42  * This class only depends on the JDK so that it can be used without building Graal.
 43  */
 44 public final class JVMCIVersionCheck {
 45 
 46     private static final Version JVMCI_MIN_VERSION = new Version3(19, 3, 4);
 47 
 48     public interface Version {
 49         boolean isLessThan(Version other);
 50 
 51         static Version parse(String vmVersion) {
 52             Matcher m = Pattern.compile(&quot;.*-jvmci-(\\d+)\\.(\\d+)-b(\\d+).*&quot;).matcher(vmVersion);
 53             if (m.matches()) {
 54                 try {
 55                     int major = Integer.parseInt(m.group(1));
 56                     int minor = Integer.parseInt(m.group(2));
 57                     int build = Integer.parseInt(m.group(3));
 58                     return new Version3(major, minor, build);
 59                 } catch (NumberFormatException e) {
 60                     // ignore
 61                 }
 62             }
 63             m = Pattern.compile(&quot;.*-jvmci-(\\d+)(?:\\.|-b)(\\d+).*&quot;).matcher(vmVersion);
 64             if (m.matches()) {
 65                 try {
 66                     int major = Integer.parseInt(m.group(1));
 67                     int minor = Integer.parseInt(m.group(2));
 68                     return new Version2(major, minor);
 69                 } catch (NumberFormatException e) {
 70                     // ignore
 71                 }
 72             }
 73             return null;
 74         }
 75     }
 76 
 77     public static class Version2 implements Version {
 78         private final int major;
 79         private final int minor;
 80 
 81         public Version2(int major, int minor) {
 82             this.major = major;
 83             this.minor = minor;
 84         }
 85 
 86         @Override
 87         public boolean isLessThan(Version other) {
 88             if (other.getClass() == Version3.class) {
 89                 return true;
 90             }
 91             Version2 o = (Version2) other;
 92             if (this.major &lt; o.major) {
 93                 return true;
 94             }
 95             if (this.major == o.major &amp;&amp; this.minor &lt; o.minor) {
 96                 return true;
 97             }
 98             return false;
 99         }
100 
101         @Override
102         public String toString() {
103             if (major &gt;= 19) {
104                 return String.format(&quot;%d-b%02d&quot;, major, minor);
105             } else {
106                 return String.format(&quot;%d.%d&quot;, major, minor);
107             }
108         }
109     }
110 
111     public static class Version3 implements Version {
112         private final int major;
113         private final int minor;
114         private final int build;
115 
116         public Version3(int major, int minor, int build) {
117             this.major = major;
118             this.minor = minor;
119             this.build = build;
120         }
121 
122         @Override
123         public boolean isLessThan(Version other) {
124             if (other.getClass() == Version2.class) {
125                 return false;
126             }
127             Version3 o = (Version3) other;
128             if (this.major &lt; o.major) {
129                 return true;
130             }
131             if (this.major == o.major) {
132                 if (this.minor &lt; o.minor) {
133                     return true;
134                 }
135                 if (this.minor == o.minor &amp;&amp; this.build &lt; o.build) {
136                     return true;
137                 }
138             }
139             return false;
140         }
141 
142         @Override
143         public String toString() {
144             return String.format(&quot;%d.%d-b%02d&quot;, major, minor, build);
145         }
146     }
147 
148     private void failVersionCheck(boolean exit, String reason, Object... args) {
149         Formatter errorMessage = new Formatter().format(reason, args);
150         String javaHome = props.get(&quot;java.home&quot;);
151         String vmName = props.get(&quot;java.vm.name&quot;);
152         errorMessage.format(&quot;Set the JVMCI_VERSION_CHECK environment variable to \&quot;ignore\&quot; to suppress &quot;);
153         errorMessage.format(&quot;this error or to \&quot;warn\&quot; to emit a warning and continue execution.%n&quot;);
154         errorMessage.format(&quot;Currently used Java home directory is %s.%n&quot;, javaHome);
155         errorMessage.format(&quot;Currently used VM configuration is: %s%n&quot;, vmName);
156         if (javaSpecVersion.compareTo(&quot;1.9&quot;) &lt; 0) {
157             errorMessage.format(&quot;Download the latest JVMCI JDK 8 from https://github.com/graalvm/openjdk8-jvmci-builder/releases&quot;);
158         } else {
159             if (javaSpecVersion.compareTo(&quot;11&quot;) == 0 &amp;&amp; vmVersion.contains(&quot;-jvmci-&quot;)) {
160                 errorMessage.format(&quot;Download the latest Labs OpenJDK 11 from https://github.com/graalvm/labs-openjdk-11/releases&quot;);
161             } else {
162                 errorMessage.format(&quot;Download JDK 11 or later.&quot;);
163             }
164         }
165         String value = System.getenv(&quot;JVMCI_VERSION_CHECK&quot;);
166         if (&quot;warn&quot;.equals(value)) {
167             System.err.println(errorMessage.toString());
168         } else if (&quot;ignore&quot;.equals(value)) {
169             return;
170         } else if (exit) {
171             System.err.println(errorMessage.toString());
172             System.exit(-1);
173         } else {
174             throw new InternalError(errorMessage.toString());
175         }
176     }
177 
178     private final String javaSpecVersion;
179     private final String vmVersion;
180     private final Map&lt;String, String&gt; props;
181 
182     private JVMCIVersionCheck(Map&lt;String, String&gt; props, String javaSpecVersion, String vmVersion) {
183         this.props = props;
184         this.javaSpecVersion = javaSpecVersion;
185         this.vmVersion = vmVersion;
186     }
187 
188     static void check(Map&lt;String, String&gt; props, boolean exitOnFailure) {
189         JVMCIVersionCheck checker = new JVMCIVersionCheck(props, props.get(&quot;java.specification.version&quot;), props.get(&quot;java.vm.version&quot;));
190         checker.run(exitOnFailure, JVMCI_MIN_VERSION);
191     }
192 
193     /**
194      * Entry point for testing.
195      */
196     public static void check(Map&lt;String, String&gt; props,
197                     Version minVersion,
198                     String javaSpecVersion,
199                     String javaVmVersion, boolean exitOnFailure) {
200         JVMCIVersionCheck checker = new JVMCIVersionCheck(props, javaSpecVersion, javaVmVersion);
201         checker.run(exitOnFailure, minVersion);
202     }
203 
204     private void run(boolean exitOnFailure, Version minVersion) {
205         if (javaSpecVersion.compareTo(&quot;1.9&quot;) &lt; 0) {
206             Version v = Version.parse(vmVersion);
207             if (v != null) {
208                 if (v.isLessThan(minVersion)) {
209                     failVersionCheck(exitOnFailure, &quot;The VM does not support the minimum JVMCI API version required by Graal: %s &lt; %s.%n&quot;, v, minVersion);
210                 }
211                 return;
212             }
213             failVersionCheck(exitOnFailure, &quot;The VM does not support the minimum JVMCI API version required by Graal.%n&quot; +
214                             &quot;Cannot read JVMCI version from java.vm.version property: %s.%n&quot;, vmVersion);
215         } else if (javaSpecVersion.compareTo(&quot;11&quot;) &lt; 0) {
216             failVersionCheck(exitOnFailure, &quot;Graal is not compatible with the JVMCI API in JDK 9 and 10.%n&quot;);
217         } else {
218             if (vmVersion.contains(&quot;SNAPSHOT&quot;)) {
219                 return;
220             }
221             if (vmVersion.contains(&quot;internal&quot;)) {
222                 // Allow local builds
223                 return;
224             }
225             if (vmVersion.contains(&quot;-jvmci-&quot;)) {
226                 // A &quot;labsjdk&quot;
227                 Version v = Version.parse(vmVersion);
228                 if (v != null) {
229                     if (v.isLessThan(minVersion)) {
230                         failVersionCheck(exitOnFailure, &quot;The VM does not support the minimum JVMCI API version required by Graal: %s &lt; %s.%n&quot;, v, minVersion);
231                     }
232                     return;
233                 }
234                 failVersionCheck(exitOnFailure, &quot;The VM does not support the minimum JVMCI API version required by Graal.%n&quot; +
235                                 &quot;Cannot read JVMCI version from java.vm.version property: %s.%n&quot;, vmVersion);
236             } else {
237                 // Graal is compatible with all JDK versions as of 11 GA.
238             }
239         }
240     }
241 
242     /**
243      * Command line interface for performing the check.
244      */
245     public static void main(String[] args) {
246         Properties sprops = System.getProperties();
247         Map&lt;String, String&gt; props = new HashMap&lt;&gt;(sprops.size());
248         for (String name : sprops.stringPropertyNames()) {
249             props.put(name, sprops.getProperty(name));
250         }
251         check(props, true);
252     }
253 }
    </pre>
  </body>
</html>
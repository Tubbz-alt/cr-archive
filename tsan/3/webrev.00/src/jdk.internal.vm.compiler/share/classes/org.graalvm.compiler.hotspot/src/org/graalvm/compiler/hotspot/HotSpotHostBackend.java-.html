<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotHostBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static jdk.vm.ci.code.CodeUtil.K;
 28 import static jdk.vm.ci.code.CodeUtil.getCallingConvention;
 29 import static jdk.vm.ci.common.InitTimer.timer;
 30 
 31 import java.util.Collections;
 32 
 33 import org.graalvm.compiler.core.common.NumUtil;
 34 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 35 import org.graalvm.compiler.debug.DebugHandlersFactory;
 36 import org.graalvm.compiler.hotspot.meta.HotSpotHostForeignCallsProvider;
 37 import org.graalvm.compiler.hotspot.meta.HotSpotLoweringProvider;
 38 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 39 import org.graalvm.compiler.hotspot.stubs.Stub;
 40 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 41 import org.graalvm.compiler.lir.framemap.ReferenceMapBuilder;
 42 import org.graalvm.compiler.nodes.StructuredGraph;
 43 import org.graalvm.compiler.options.OptionValues;
 44 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 45 import org.graalvm.compiler.word.Word;
 46 
 47 import jdk.vm.ci.code.CallingConvention;
 48 import jdk.vm.ci.common.InitTimer;
 49 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
 50 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 51 import jdk.vm.ci.meta.JavaKind;
 52 import jdk.vm.ci.meta.JavaType;
 53 import jdk.vm.ci.runtime.JVMCICompiler;
 54 
 55 /**
 56  * Common functionality of HotSpot host backends.
 57  */
 58 public abstract class HotSpotHostBackend extends HotSpotBackend {
 59 
 60     /**
 61      * Descriptor for {@code SharedRuntime::deopt_blob()-&gt;unpack()}.
 62      */
 63     public static final ForeignCallDescriptor DEOPTIMIZATION_HANDLER = new ForeignCallDescriptor(&quot;deoptHandler&quot;, void.class);
 64 
 65     /**
 66      * Descriptor for {@code SharedRuntime::deopt_blob()-&gt;uncommon_trap()}.
 67      */
 68     public static final ForeignCallDescriptor UNCOMMON_TRAP_HANDLER = new ForeignCallDescriptor(&quot;uncommonTrapHandler&quot;, void.class);
 69 
 70     public static final ForeignCallDescriptor ENABLE_STACK_RESERVED_ZONE = new ForeignCallDescriptor(&quot;enableStackReservedZoneEntry&quot;, void.class, Word.class);
 71 
 72     public static final ForeignCallDescriptor THROW_DELAYED_STACKOVERFLOW_ERROR = new ForeignCallDescriptor(&quot;throwDelayedStackoverflowError&quot;, void.class);
 73 
 74     protected final GraalHotSpotVMConfig config;
 75 
 76     public HotSpotHostBackend(GraalHotSpotVMConfig config, HotSpotGraalRuntimeProvider runtime, HotSpotProviders providers) {
 77         super(runtime, providers);
 78         this.config = config;
 79     }
 80 
 81     @Override
 82     @SuppressWarnings(&quot;try&quot;)
 83     public void completeInitialization(HotSpotJVMCIRuntime jvmciRuntime, OptionValues options) {
 84         final HotSpotProviders providers = getProviders();
 85         HotSpotHostForeignCallsProvider foreignCalls = (HotSpotHostForeignCallsProvider) providers.getForeignCalls();
 86         final HotSpotLoweringProvider lowerer = (HotSpotLoweringProvider) providers.getLowerer();
 87 
 88         try (InitTimer st = timer(&quot;foreignCalls.initialize&quot;)) {
 89             foreignCalls.initialize(providers, options);
 90         }
 91         try (InitTimer st = timer(&quot;lowerer.initialize&quot;)) {
 92             Iterable&lt;DebugHandlersFactory&gt; factories = Collections.singletonList(new GraalDebugHandlersFactory(providers.getSnippetReflection()));
 93             lowerer.initialize(options, factories, providers, config);
 94         }
 95         providers.getReplacements().closeSnippetRegistration();
 96     }
 97 
 98     protected CallingConvention makeCallingConvention(StructuredGraph graph, Stub stub) {
 99         if (stub != null) {
100             return stub.getLinkage().getIncomingCallingConvention();
101         }
102 
103         CallingConvention cc = getCallingConvention(getCodeCache(), HotSpotCallingConventionType.JavaCallee, graph.method(), this);
104         if (graph.getEntryBCI() != JVMCICompiler.INVOCATION_ENTRY_BCI) {
105             // for OSR, only a pointer is passed to the method.
106             JavaType[] parameterTypes = new JavaType[]{getMetaAccess().lookupJavaType(long.class)};
107             CallingConvention tmp = getCodeCache().getRegisterConfig().getCallingConvention(HotSpotCallingConventionType.JavaCallee, getMetaAccess().lookupJavaType(void.class), parameterTypes, this);
108             cc = new CallingConvention(cc.getStackSize(), cc.getReturn(), tmp.getArgument(0));
109         }
110         return cc;
111     }
112 
113     public void emitStackOverflowCheck(CompilationResultBuilder crb) {
114         if (config.useStackBanging) {
115             // Each code entry causes one stack bang n pages down the stack where n
116             // is configurable by StackShadowPages. The setting depends on the maximum
117             // depth of VM call stack or native before going back into java code,
118             // since only java code can raise a stack overflow exception using the
119             // stack banging mechanism. The VM and native code does not detect stack
120             // overflow.
121             // The code in JavaCalls::call() checks that there is at least n pages
122             // available, so all entry code needs to do is bang once for the end of
123             // this shadow zone.
124             // The entry code may need to bang additional pages if the framesize
125             // is greater than a page.
126 
127             int pageSize = config.vmPageSize;
128             int bangEnd = NumUtil.roundUp(config.stackShadowPages * 4 * K, pageSize);
129 
130             // This is how far the previous frame&#39;s stack banging extended.
131             int bangEndSafe = bangEnd;
132 
133             int frameSize = Math.max(crb.frameMap.frameSize(), crb.compilationResult.getMaxInterpreterFrameSize());
134             if (frameSize &gt; pageSize) {
135                 bangEnd += frameSize;
136             }
137 
138             int bangOffset = bangEndSafe;
139             if (bangOffset &lt;= bangEnd) {
140                 crb.blockComment(&quot;[stack overflow check]&quot;);
141             }
142             while (bangOffset &lt;= bangEnd) {
143                 // Need at least one stack bang at end of shadow zone.
144                 bangStackWithOffset(crb, bangOffset);
145                 bangOffset += pageSize;
146             }
147         }
148     }
149 
150     protected abstract void bangStackWithOffset(CompilationResultBuilder crb, int bangOffset);
151 
152     @Override
153     public ReferenceMapBuilder newReferenceMapBuilder(int totalFrameSize) {
154         int uncompressedReferenceSize = getTarget().arch.getPlatformKind(JavaKind.Object).getSizeInBytes();
155         return new HotSpotReferenceMapBuilder(totalFrameSize, config.maxOopMapStackOffset, uncompressedReferenceSize);
156     }
157 
158 }
    </pre>
  </body>
</html>
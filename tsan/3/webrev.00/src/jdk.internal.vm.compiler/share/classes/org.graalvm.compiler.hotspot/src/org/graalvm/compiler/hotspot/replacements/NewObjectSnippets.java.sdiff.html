<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/NewObjectSnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MonitorSnippets.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ObjectCloneNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/NewObjectSnippets.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot.replacements;
  26 

  27 import static jdk.vm.ci.meta.DeoptimizationAction.None;
  28 import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;
  29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;

  30 import static org.graalvm.compiler.core.common.calc.UnsignedMath.belowThan;
  31 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_OPTIONVALUES;
  32 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
  33 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY;
  34 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY_OR_NULL;
  35 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE;
  36 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE_OR_NULL;
  37 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY;
  38 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY_OR_NULL;
  39 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_ARRAY_KLASS_LOCATION;

  40 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_WRITE_LOCATION;
  41 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
  42 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.PROTOTYPE_MARK_WORD_LOCATION;
  43 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_END_LOCATION;
  44 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_TOP_LOCATION;
  45 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocateInstancePrefetchLines;
  46 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchDistance;
  47 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchLines;
  48 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchStepSize;
  49 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchStyle;
  50 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayAllocationSize;
  51 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayKlassOffset;
  52 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayLengthOffset;
  53 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.initializeObjectHeader;
  54 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.instanceHeaderSize;

  55 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.isInstanceKlassFullyInitialized;
  56 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeMask;
  57 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeShift;
  58 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeMask;
  59 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeShift;
  60 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.loadKlassFromObject;
  61 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.prototypeMarkWordOffset;


  62 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readLayoutHelper;
  63 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readTlabEnd;
  64 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readTlabTop;
  65 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.registerAsWord;
  66 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.useBiasedLocking;
  67 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.useTLAB;
  68 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.verifyOop;
  69 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.writeTlabTop;
  70 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocations;
  71 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocationsContext;
  72 import static org.graalvm.compiler.nodes.PiArrayNode.piArrayCastToSnippetReplaceeStamp;
  73 import static org.graalvm.compiler.nodes.PiNode.piCastToSnippetReplaceeStamp;

  74 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FAST_PATH_PROBABILITY;
  75 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FREQUENT_PROBABILITY;
  76 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;

  77 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
  78 import static org.graalvm.compiler.replacements.ReplacementsUtil.REPLACEMENTS_ASSERTIONS_ENABLED;
  79 import static org.graalvm.compiler.replacements.ReplacementsUtil.runtimeAssert;
  80 import static org.graalvm.compiler.replacements.ReplacementsUtil.staticAssert;
  81 import static org.graalvm.compiler.replacements.SnippetTemplate.DEFAULT_REPLACER;
  82 import static org.graalvm.compiler.replacements.nodes.CStringConstant.cstring;
  83 import static org.graalvm.compiler.replacements.nodes.ExplodeLoopNode.explodeLoop;
  84 
  85 import org.graalvm.compiler.api.replacements.Fold;
  86 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
  87 import org.graalvm.compiler.api.replacements.Snippet;
  88 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
  89 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
  90 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
  91 import org.graalvm.compiler.core.common.type.StampFactory;
  92 import org.graalvm.compiler.debug.DebugHandlersFactory;
  93 import org.graalvm.compiler.debug.GraalError;
  94 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
  95 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
  96 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  97 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
  98 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
  99 import org.graalvm.compiler.hotspot.nodes.DimensionsNode;

 100 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyFixedNode;
 101 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyNode;
 102 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 103 import org.graalvm.compiler.hotspot.word.KlassPointer;
 104 import org.graalvm.compiler.nodes.ConstantNode;
 105 import org.graalvm.compiler.nodes.DeoptimizeNode;
 106 import org.graalvm.compiler.nodes.PiNode;
 107 import org.graalvm.compiler.nodes.PrefetchAllocateNode;
 108 import org.graalvm.compiler.nodes.SnippetAnchorNode;
 109 import org.graalvm.compiler.nodes.StructuredGraph;
 110 import org.graalvm.compiler.nodes.ValueNode;
 111 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
 112 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;

 113 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 114 import org.graalvm.compiler.nodes.extended.MembarNode;
 115 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
 116 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 117 import org.graalvm.compiler.nodes.java.NewArrayNode;
 118 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 119 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 120 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 121 import org.graalvm.compiler.nodes.spi.LoweringTool;
 122 import org.graalvm.compiler.nodes.util.GraphUtil;
 123 import org.graalvm.compiler.options.OptionValues;
 124 import org.graalvm.compiler.replacements.ReplacementsUtil;
 125 import org.graalvm.compiler.replacements.SnippetCounter;
 126 import org.graalvm.compiler.replacements.SnippetCounter.Group;
 127 import org.graalvm.compiler.replacements.SnippetTemplate;
 128 import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;
 129 import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
 130 import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
 131 import org.graalvm.compiler.replacements.Snippets;
 132 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;

 133 import org.graalvm.compiler.word.Word;
 134 import jdk.internal.vm.compiler.word.LocationIdentity;
 135 import jdk.internal.vm.compiler.word.WordFactory;
 136 
 137 import jdk.vm.ci.code.CodeUtil;
 138 import jdk.vm.ci.code.MemoryBarriers;
 139 import jdk.vm.ci.code.Register;
 140 import jdk.vm.ci.code.TargetDescription;
 141 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 142 import jdk.vm.ci.meta.JavaKind;
 143 import jdk.vm.ci.meta.ResolvedJavaType;
 144 
 145 /**
 146  * Snippets used for implementing NEW, ANEWARRAY and NEWARRAY.
 147  */
 148 public class NewObjectSnippets implements Snippets {
 149 
 150     enum ProfileContext {
 151         AllocatingMethod,
 152         InstanceOrArray,
</pre>
<hr />
<pre>
 192             DynamicCounterNode.counter(&quot;number of allocations&quot;, name, 1, context);
 193         }
 194     }
 195 
 196     public static void emitPrefetchAllocate(Word address, boolean isArray) {
 197         if (allocatePrefetchStyle(INJECTED_VMCONFIG) &gt; 0) {
 198             // Insert a prefetch for each allocation only on the fast-path
 199             // Generate several prefetch instructions.
 200             int lines = isArray ? allocatePrefetchLines(INJECTED_VMCONFIG) : allocateInstancePrefetchLines(INJECTED_VMCONFIG);
 201             int stepSize = allocatePrefetchStepSize(INJECTED_VMCONFIG);
 202             int distance = allocatePrefetchDistance(INJECTED_VMCONFIG);
 203             ExplodeLoopNode.explodeLoop();
 204             for (int i = 0; i &lt; lines; i++) {
 205                 PrefetchAllocateNode.prefetch(OffsetAddressNode.address(address, distance));
 206                 distance += stepSize;
 207             }
 208         }
 209     }
 210 
 211     @Snippet
<span class="line-modified"> 212     public static Object allocateInstance(@ConstantParameter long size, KlassPointer hub, Word prototypeMarkWord, @ConstantParameter boolean fillContents,</span>
<span class="line-modified"> 213                     @ConstantParameter Register threadRegister, @ConstantParameter boolean constantSize, @ConstantParameter String typeContext,</span>






 214                     @ConstantParameter Counters counters) {
<span class="line-modified"> 215         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, hub, prototypeMarkWord, fillContents, threadRegister, constantSize, typeContext, counters));</span>
 216     }
 217 
<span class="line-modified"> 218     public static Object allocateInstanceHelper(long size, KlassPointer hub, Word prototypeMarkWord, boolean fillContents,</span>
<span class="line-modified"> 219                     Register threadRegister, boolean constantSize, String typeContext, Counters counters) {</span>







 220         Object result;
 221         Word thread = registerAsWord(threadRegister);
 222         Word top = readTlabTop(thread);
 223         Word end = readTlabEnd(thread);
 224         Word newTop = top.add(WordFactory.unsigned(size));
 225         if (useTLAB(INJECTED_VMCONFIG) &amp;&amp; probability(FAST_PATH_PROBABILITY, newTop.belowOrEqual(end))) {
 226             writeTlabTop(thread, newTop);
 227             emitPrefetchAllocate(newTop, false);
<span class="line-modified"> 228             result = formatObject(hub, size, top, prototypeMarkWord, fillContents, constantSize, counters);</span>
 229         } else {
 230             Counters theCounters = counters;
 231             if (theCounters != null &amp;&amp; theCounters.stub != null) {
 232                 theCounters.stub.inc();
 233             }
 234             result = newInstanceStub(hub);
 235         }
 236         profileAllocation(&quot;instance&quot;, size, typeContext);
 237         return verifyOop(result);
 238     }
 239 
 240     public static Object newInstanceStub(KlassPointer hub) {
 241         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 242             return nonNullOrDeopt(newInstanceOrNull(NEW_INSTANCE_OR_NULL, hub));
 243         } else {
 244             return newInstance(NEW_INSTANCE, hub);
 245         }
 246     }
 247 
 248     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 249     private static native Object newInstance(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub);
 250 
 251     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 252     private static native Object newInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub);
 253 
 254     @Snippet
<span class="line-modified"> 255     public static Object allocateInstancePIC(@ConstantParameter long size, KlassPointer hub, Word prototypeMarkWord, @ConstantParameter boolean fillContents,</span>
<span class="line-modified"> 256                     @ConstantParameter Register threadRegister, @ConstantParameter boolean constantSize, @ConstantParameter String typeContext,</span>






 257                     @ConstantParameter Counters counters) {
 258         // Klass must be initialized by the time the first instance is allocated, therefore we can
 259         // just load it from the corresponding cell and avoid the resolution check. We have to use a
 260         // fixed load though, to prevent it from floating above the initialization.
 261         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
<span class="line-modified"> 262         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, picHub, prototypeMarkWord, fillContents, threadRegister, constantSize, typeContext, counters));</span>
 263     }
 264 
 265     @Snippet
<span class="line-modified"> 266     public static Object allocateInstanceDynamic(Class&lt;?&gt; type, Class&lt;?&gt; classClass, @ConstantParameter boolean fillContents, @ConstantParameter Register threadRegister,</span>



 267                     @ConstantParameter Counters counters) {
<span class="line-modified"> 268         if (probability(SLOW_PATH_PROBABILITY, type == null)) {</span>
 269             DeoptimizeNode.deopt(None, RuntimeConstraint);
 270         }
 271         Class&lt;?&gt; nonNullType = PiNode.piCastNonNullClass(type, SnippetAnchorNode.anchor());
 272 
<span class="line-modified"> 273         if (probability(SLOW_PATH_PROBABILITY, DynamicNewInstanceNode.throwsInstantiationException(type, classClass))) {</span>
 274             DeoptimizeNode.deopt(None, RuntimeConstraint);
 275         }
 276 
<span class="line-modified"> 277         return PiNode.piCastToSnippetReplaceeStamp(allocateInstanceDynamicHelper(type, fillContents, threadRegister, counters, nonNullType));</span>
 278     }
 279 
<span class="line-modified"> 280     private static Object allocateInstanceDynamicHelper(Class&lt;?&gt; type, boolean fillContents, Register threadRegister, Counters counters, Class&lt;?&gt; nonNullType) {</span>





 281         KlassPointer hub = ClassGetHubNode.readClass(nonNullType);
 282         if (probability(FAST_PATH_PROBABILITY, !hub.isNull())) {
 283             KlassPointer nonNullHub = ClassGetHubNode.piCastNonNull(hub, SnippetAnchorNode.anchor());
 284 
<span class="line-modified"> 285             if (probability(FAST_PATH_PROBABILITY, isInstanceKlassFullyInitialized(nonNullHub))) {</span>
 286                 int layoutHelper = readLayoutHelper(nonNullHub);
 287                 /*
 288                  * src/share/vm/oops/klass.hpp: For instances, layout helper is a positive number,
 289                  * the instance size. This size is already passed through align_object_size and
 290                  * scaled to bytes. The low order bit is set if instances of this class cannot be
 291                  * allocated using the fastpath.
 292                  */
 293                 if (probability(FAST_PATH_PROBABILITY, (layoutHelper &amp; 1) == 0)) {
 294                     Word prototypeMarkWord = nonNullHub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION);
 295                     /*
 296                      * FIXME(je,ds): we should actually pass typeContext instead of &quot;&quot; but late
 297                      * binding of parameters is not yet supported by the GraphBuilderPlugin system.
 298                      */
<span class="line-modified"> 299                     return allocateInstanceHelper(layoutHelper, nonNullHub, prototypeMarkWord, fillContents, threadRegister, false, &quot;&quot;, counters);</span>
 300                 }
 301             } else {
 302                 DeoptimizeNode.deopt(None, RuntimeConstraint);
 303             }
 304         }
 305         return dynamicNewInstanceStub(type);
 306     }
 307 
 308     /**
 309      * Maximum array length for which fast path allocation is used.
 310      */
 311     public static final int MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH = 0x00FFFFFF;
 312 
 313     @Snippet
<span class="line-modified"> 314     public static Object allocatePrimitiveArrayPIC(KlassPointer hub, int length, Word prototypeMarkWord, @ConstantParameter int headerSize, @ConstantParameter int log2ElementSize,</span>
<span class="line-modified"> 315                     @ConstantParameter boolean fillContents, @ConstantParameter Register threadRegister, @ConstantParameter boolean maybeUnroll, @ConstantParameter String typeContext,</span>









 316                     @ConstantParameter Counters counters) {
 317         // Primitive array types are eagerly pre-resolved. We can use a floating load.
 318         KlassPointer picHub = LoadConstantIndirectlyNode.loadKlass(hub);
<span class="line-modified"> 319         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents, threadRegister, maybeUnroll, typeContext, counters);</span>

 320     }
 321 
 322     @Snippet
<span class="line-modified"> 323     public static Object allocateArrayPIC(KlassPointer hub, int length, Word prototypeMarkWord, @ConstantParameter int headerSize, @ConstantParameter int log2ElementSize,</span>
<span class="line-modified"> 324                     @ConstantParameter boolean fillContents, @ConstantParameter Register threadRegister, @ConstantParameter boolean maybeUnroll, @ConstantParameter String typeContext,</span>









 325                     @ConstantParameter Counters counters) {
 326         // Array type would be resolved by dominating resolution.
 327         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
<span class="line-modified"> 328         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents, threadRegister, maybeUnroll, typeContext, counters);</span>

 329     }
 330 
 331     @Snippet
 332     public static Object allocateArray(KlassPointer hub,
 333                     int length,
 334                     Word prototypeMarkWord,
 335                     @ConstantParameter int headerSize,
 336                     @ConstantParameter int log2ElementSize,
 337                     @ConstantParameter boolean fillContents,

 338                     @ConstantParameter Register threadRegister,
 339                     @ConstantParameter boolean maybeUnroll,
 340                     @ConstantParameter String typeContext,

 341                     @ConstantParameter Counters counters) {
 342         Object result = allocateArrayImpl(hub,
 343                         length,
 344                         prototypeMarkWord,
 345                         headerSize,
 346                         log2ElementSize,
 347                         fillContents,
<span class="line-modified"> 348                         threadRegister,</span>
 349                         maybeUnroll,
 350                         typeContext,
<span class="line-modified"> 351 </span>
 352                         counters);
 353         return piArrayCastToSnippetReplaceeStamp(verifyOop(result), length);
 354     }
 355 
 356     /**
 357      * When allocating on the slow path, determines whether to use a version of the runtime call
 358      * that returns {@code null} on a failed allocation instead of raising an OutOfMemoryError.
 359      */
 360     @Fold
 361     static boolean useNullAllocationStubs(@InjectedParameter GraalHotSpotVMConfig config) {
 362         return config.areNullAllocationStubsAvailable();
 363     }
 364 
<span class="line-modified"> 365     private static Object allocateArrayImpl(KlassPointer hub, int length, Word prototypeMarkWord, int headerSize, int log2ElementSize, boolean fillContents, Register threadRegister,</span>
<span class="line-modified"> 366                     boolean maybeUnroll, String typeContext, Counters counters) {</span>










 367         Object result;
 368         long allocationSize = arrayAllocationSize(length, headerSize, log2ElementSize);
 369         Word thread = registerAsWord(threadRegister);
 370         Word top = readTlabTop(thread);
 371         Word end = readTlabEnd(thread);
 372         Word newTop = top.add(WordFactory.unsigned(allocationSize));
 373         if (probability(FREQUENT_PROBABILITY, belowThan(length, MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH)) &amp;&amp; useTLAB(INJECTED_VMCONFIG) &amp;&amp;
 374                         probability(FAST_PATH_PROBABILITY, newTop.belowOrEqual(end))) {
 375             writeTlabTop(thread, newTop);
 376             emitPrefetchAllocate(newTop, true);
 377             Counters theCounters = counters;
 378             if (theCounters != null &amp;&amp; theCounters.arrayLoopInit != null) {
 379                 theCounters.arrayLoopInit.inc();
 380             }
<span class="line-modified"> 381             result = formatArray(hub, allocationSize, length, headerSize, top, prototypeMarkWord, fillContents, maybeUnroll, counters);</span>
 382         } else {
 383             result = newArrayStub(hub, length);
 384         }
 385         profileAllocation(&quot;array&quot;, allocationSize, typeContext);
 386         return result;
 387     }
 388 
 389     public static Object newArrayStub(KlassPointer hub, int length) {
 390         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 391             return nonNullOrDeopt(newArrayOrNull(NEW_ARRAY_OR_NULL, hub, length));
 392         } else {
 393             return newArray(NEW_ARRAY, hub, length);
 394         }
 395     }
 396 
 397     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 398     private static native Object newArray(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int length);
 399 
 400     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 401     private static native Object newArrayOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int length);
</pre>
<hr />
<pre>
 405      */
 406     public static final ForeignCallDescriptor DYNAMIC_NEW_INSTANCE = new ForeignCallDescriptor(&quot;dynamic_new_instance&quot;, Object.class, Class.class);
 407 
 408     /**
 409      * New dynamic array stub that returns null on allocation failure.
 410      */
 411     public static final ForeignCallDescriptor DYNAMIC_NEW_INSTANCE_OR_NULL = new ForeignCallDescriptor(&quot;dynamic_new_instance_or_null&quot;, Object.class, Class.class);
 412 
 413     public static Object dynamicNewInstanceStub(Class&lt;?&gt; elementType) {
 414         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 415             return nonNullOrDeopt(dynamicNewInstanceOrNull(DYNAMIC_NEW_INSTANCE_OR_NULL, elementType));
 416         } else {
 417             return dynamicNewInstance(DYNAMIC_NEW_INSTANCE, elementType);
 418         }
 419     }
 420 
 421     /**
 422      * Deoptimizes if {@code obj == null} otherwise returns {@code obj}.
 423      */
 424     private static Object nonNullOrDeopt(Object obj) {
<span class="line-modified"> 425         if (obj == null) {</span>
 426             DeoptimizeNode.deopt(None, RuntimeConstraint);
 427         }
 428         return obj;
 429     }
 430 
 431     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 432     public static native Object dynamicNewInstance(@ConstantNodeParameter ForeignCallDescriptor descriptor, Class&lt;?&gt; elementType);
 433 
 434     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 435     public static native Object dynamicNewInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, Class&lt;?&gt; elementType);
 436 
 437     @Snippet
<span class="line-modified"> 438     public static Object allocateArrayDynamic(Class&lt;?&gt; elementType, Class&lt;?&gt; voidClass, int length, @ConstantParameter boolean fillContents, @ConstantParameter Register threadRegister,</span>
<span class="line-modified"> 439                     @ConstantParameter JavaKind knownElementKind, @ConstantParameter int knownLayoutHelper, Word prototypeMarkWord,</span>








 440                     @ConstantParameter Counters counters) {
<span class="line-modified"> 441         Object result = allocateArrayDynamicImpl(elementType, voidClass, length, fillContents, threadRegister, knownElementKind, knownLayoutHelper, prototypeMarkWord, counters);</span>

 442         return result;
 443     }
 444 
<span class="line-modified"> 445     private static Object allocateArrayDynamicImpl(Class&lt;?&gt; elementType, Class&lt;?&gt; voidClass, int length, boolean fillContents, Register threadRegister, JavaKind knownElementKind,</span>
<span class="line-modified"> 446                     int knownLayoutHelper, Word prototypeMarkWord, Counters counters) {</span>









 447         /*
 448          * We only need the dynamic check for void when we have no static information from
 449          * knownElementKind.
 450          */
 451         staticAssert(knownElementKind != JavaKind.Void, &quot;unsupported knownElementKind&quot;);
 452         if (knownElementKind == JavaKind.Illegal &amp;&amp; probability(SLOW_PATH_PROBABILITY, elementType == null || DynamicNewArrayNode.throwsIllegalArgumentException(elementType, voidClass))) {
 453             DeoptimizeNode.deopt(None, RuntimeConstraint);
 454         }
 455 
 456         KlassPointer klass = loadKlassFromObject(elementType, arrayKlassOffset(INJECTED_VMCONFIG), CLASS_ARRAY_KLASS_LOCATION);
<span class="line-modified"> 457         if (klass.isNull()) {</span>
 458             DeoptimizeNode.deopt(None, RuntimeConstraint);
 459         }
 460         KlassPointer nonNullKlass = ClassGetHubNode.piCastNonNull(klass, SnippetAnchorNode.anchor());
 461 
<span class="line-modified"> 462         if (length &lt; 0) {</span>
 463             DeoptimizeNode.deopt(None, RuntimeConstraint);
 464         }
 465         int layoutHelper;
 466         if (knownElementKind == JavaKind.Illegal) {
 467             layoutHelper = readLayoutHelper(nonNullKlass);
 468         } else {
 469             runtimeAssert(knownLayoutHelper == readLayoutHelper(nonNullKlass), &quot;layout mismatch&quot;);
 470             layoutHelper = knownLayoutHelper;
 471         }
 472         //@formatter:off
 473         // from src/share/vm/oops/klass.hpp:
 474         //
 475         // For arrays, layout helper is a negative number, containing four
 476         // distinct bytes, as follows:
 477         //    MSB:[tag, hsz, ebt, log2(esz)]:LSB
 478         // where:
 479         //    tag is 0x80 if the elements are oops, 0xC0 if non-oops
 480         //    hsz is array header size in bytes (i.e., offset of first element)
 481         //    ebt is the BasicType of the elements
 482         //    esz is the element size in bytes
 483         //@formatter:on
 484 
 485         int headerSize = (layoutHelper &gt;&gt; layoutHelperHeaderSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperHeaderSizeMask(INJECTED_VMCONFIG);
 486         int log2ElementSize = (layoutHelper &gt;&gt; layoutHelperLog2ElementSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperLog2ElementSizeMask(INJECTED_VMCONFIG);
 487 
<span class="line-modified"> 488         Object result = allocateArrayImpl(nonNullKlass, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents, threadRegister, false, &quot;dynamic type&quot;, counters);</span>

 489         return piArrayCastToSnippetReplaceeStamp(verifyOop(result), length);
 490     }
 491 
 492     /**
 493      * Calls the runtime stub for implementing MULTIANEWARRAY.
 494      */
 495     @Snippet
 496     private static Object newmultiarray(KlassPointer hub, @ConstantParameter int rank, @VarargsParameter int[] dimensions) {
 497         Word dims = DimensionsNode.allocaDimsArray(rank);
 498         ExplodeLoopNode.explodeLoop();
 499         for (int i = 0; i &lt; rank; i++) {
 500             dims.writeInt(i * 4, dimensions[i], LocationIdentity.init());
 501         }
 502         return newMultiArrayStub(hub, rank, dims);
 503     }
 504 
 505     private static Object newMultiArrayStub(KlassPointer hub, int rank, Word dims) {
 506         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 507             return nonNullOrDeopt(newMultiArrayOrNull(NEW_MULTI_ARRAY_OR_NULL, hub, rank, dims));
 508         } else {
</pre>
<hr />
<pre>
 516         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
 517         return newmultiarray(picHub, rank, dimensions);
 518     }
 519 
 520     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 521     private static native Object newMultiArray(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int rank, Word dims);
 522 
 523     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 524     private static native Object newMultiArrayOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int rank, Word dims);
 525 
 526     /**
 527      * Maximum number of long stores to emit when zeroing an object with a constant size. Larger
 528      * objects have their bodies initialized in a loop.
 529      */
 530     private static final int MAX_UNROLLED_OBJECT_ZEROING_STORES = 8;
 531 
 532     /**
 533      * Zero uninitialized memory in a newly allocated object, unrolling as necessary and ensuring
 534      * that stores are aligned.
 535      *
<span class="line-removed"> 536      * @param size number of bytes to zero</span>
 537      * @param memory beginning of object which is being zeroed
<span class="line-modified"> 538      * @param constantSize is {@code size} known to be constant in the snippet</span>
<span class="line-modified"> 539      * @param startOffset offset to begin zeroing. May not be word aligned.</span>

 540      * @param manualUnroll maximally unroll zeroing

 541      */
<span class="line-modified"> 542     private static void zeroMemory(long size, Word memory, boolean constantSize, int startOffset, boolean manualUnroll, Counters counters) {</span>
<span class="line-modified"> 543         fillMemory(0, size, memory, constantSize, startOffset, manualUnroll, counters);</span>

 544     }
 545 
<span class="line-modified"> 546     private static void fillMemory(long value, long size, Word memory, boolean constantSize, int startOffset, boolean manualUnroll, Counters counters) {</span>
<span class="line-modified"> 547         ReplacementsUtil.runtimeAssert((size &amp; 0x7) == 0, &quot;unaligned object size&quot;);</span>

 548         int offset = startOffset;
 549         if ((offset &amp; 0x7) != 0) {
 550             memory.writeInt(offset, (int) value, LocationIdentity.init());
 551             offset += 4;
 552         }
 553         ReplacementsUtil.runtimeAssert((offset &amp; 0x7) == 0, &quot;unaligned offset&quot;);
 554         Counters theCounters = counters;
<span class="line-modified"> 555         if (manualUnroll &amp;&amp; ((size - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="line-modified"> 556             ReplacementsUtil.staticAssert(!constantSize, &quot;size shouldn&#39;t be constant at instantiation time&quot;);</span>
 557             // This case handles arrays of constant length. Instead of having a snippet variant for
 558             // each length, generate a chain of stores of maximum length. Once it&#39;s inlined the
 559             // break statement will trim excess stores.
 560             if (theCounters != null &amp;&amp; theCounters.instanceSeqInit != null) {
 561                 theCounters.instanceSeqInit.inc();
 562             }
 563 
 564             explodeLoop();
 565             for (int i = 0; i &lt; MAX_UNROLLED_OBJECT_ZEROING_STORES; i++, offset += 8) {
<span class="line-modified"> 566                 if (offset == size) {</span>
 567                     break;
 568                 }
 569                 memory.initializeLong(offset, value, LocationIdentity.init());
 570             }
 571         } else {
 572             // Use Word instead of int to avoid extension to long in generated code
 573             Word off = WordFactory.signed(offset);
<span class="line-modified"> 574             if (constantSize &amp;&amp; ((size - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="line-modified"> 575                 if (theCounters != null &amp;&amp; theCounters.instanceSeqInit != null) {</span>
<span class="line-modified"> 576                     theCounters.instanceSeqInit.inc();</span>
 577                 }
<span class="line-modified"> 578                 explodeLoop();</span>
 579             } else {
<span class="line-modified"> 580                 if (theCounters != null &amp;&amp; theCounters.instanceLoopInit != null) {</span>
<span class="line-modified"> 581                     theCounters.instanceLoopInit.inc();</span>










 582                 }
<span class="line-removed"> 583             }</span>
<span class="line-removed"> 584             for (; off.rawValue() &lt; size; off = off.add(8)) {</span>
<span class="line-removed"> 585                 memory.initializeLong(off, value, LocationIdentity.init());</span>
 586             }
 587         }
 588     }
 589 





 590     /**
 591      * Fill uninitialized memory with garbage value in a newly allocated object, unrolling as
 592      * necessary and ensuring that stores are aligned.
 593      *
<span class="line-removed"> 594      * @param size number of bytes to zero</span>
 595      * @param memory beginning of object which is being zeroed
<span class="line-modified"> 596      * @param constantSize is {@code  size} known to be constant in the snippet</span>
<span class="line-modified"> 597      * @param startOffset offset to begin zeroing. May not be word aligned.</span>


 598      * @param manualUnroll maximally unroll zeroing
 599      */
<span class="line-modified"> 600     private static void fillWithGarbage(long size, Word memory, boolean constantSize, int startOffset, boolean manualUnroll, Counters counters) {</span>
<span class="line-modified"> 601         fillMemory(0xfefefefefefefefeL, size, memory, constantSize, startOffset, manualUnroll, counters);</span>
 602     }
 603 
 604     /**
 605      * Formats some allocated memory with an object header and zeroes out the rest.
 606      */
<span class="line-modified"> 607     private static Object formatObject(KlassPointer hub, long size, Word memory, Word compileTimePrototypeMarkWord, boolean fillContents, boolean constantSize, Counters counters) {</span>







 608         Word prototypeMarkWord = useBiasedLocking(INJECTED_VMCONFIG) ? hub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION) : compileTimePrototypeMarkWord;
 609         initializeObjectHeader(memory, prototypeMarkWord, hub);
 610         if (fillContents) {
<span class="line-modified"> 611             zeroMemory(size, memory, constantSize, instanceHeaderSize(INJECTED_VMCONFIG), false, counters);</span>
 612         } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {
<span class="line-modified"> 613             fillWithGarbage(size, memory, constantSize, instanceHeaderSize(INJECTED_VMCONFIG), false, counters);</span>



 614         }
<span class="line-removed"> 615         MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
 616         return memory.toObjectNonNull();
 617     }
 618 
 619     @Snippet
 620     private static void verifyHeap(@ConstantParameter Register threadRegister) {
 621         Word thread = registerAsWord(threadRegister);
 622         Word topValue = readTlabTop(thread);
 623         if (!topValue.equal(WordFactory.zero())) {
 624             Word topValueContents = topValue.readWord(0, MARK_WORD_LOCATION);
 625             if (topValueContents.equal(WordFactory.zero())) {
 626                 AssertionSnippets.vmMessageC(AssertionSnippets.ASSERTION_VM_MESSAGE_C, true, cstring(&quot;overzeroing of TLAB detected&quot;), 0L, 0L, 0L);
 627             }
 628         }
 629     }
 630 













 631     /**
 632      * Formats some allocated memory with an object header and zeroes out the rest.
 633      */
<span class="line-modified"> 634     private static Object formatArray(KlassPointer hub, long allocationSize, int length, int headerSize, Word memory, Word prototypeMarkWord, boolean fillContents, boolean maybeUnroll,</span>









 635                     Counters counters) {
 636         memory.writeInt(arrayLengthOffset(INJECTED_VMCONFIG), length, LocationIdentity.init());
 637         /*
 638          * store hub last as the concurrent garbage collectors assume length is valid if hub field
 639          * is not null
 640          */
 641         initializeObjectHeader(memory, prototypeMarkWord, hub);
 642         if (fillContents) {
<span class="line-modified"> 643             zeroMemory(allocationSize, memory, false, headerSize, maybeUnroll, counters);</span>
 644         } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {
<span class="line-modified"> 645             fillWithGarbage(allocationSize, memory, false, headerSize, maybeUnroll, counters);</span>



 646         }
<span class="line-removed"> 647         MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
 648         return memory.toObjectNonNull();
 649     }
 650 
 651     static class Counters {
 652         Counters(SnippetCounter.Group.Factory factory) {
 653             Group newInstance = factory.createSnippetCounterGroup(&quot;NewInstance&quot;);
 654             Group newArray = factory.createSnippetCounterGroup(&quot;NewArray&quot;);
 655             instanceSeqInit = new SnippetCounter(newInstance, &quot;tlabSeqInit&quot;, &quot;TLAB alloc with unrolled zeroing&quot;);
 656             instanceLoopInit = new SnippetCounter(newInstance, &quot;tlabLoopInit&quot;, &quot;TLAB alloc with zeroing in a loop&quot;);

 657             arrayLoopInit = new SnippetCounter(newArray, &quot;tlabLoopInit&quot;, &quot;TLAB alloc with zeroing in a loop&quot;);
 658             stub = new SnippetCounter(newInstance, &quot;stub&quot;, &quot;alloc and zeroing via stub&quot;);
 659         }
 660 
 661         final SnippetCounter instanceSeqInit;
 662         final SnippetCounter instanceLoopInit;

 663         final SnippetCounter arrayLoopInit;
 664         final SnippetCounter stub;
 665     }
 666 
 667     public static class Templates extends AbstractTemplates {
 668 
<span class="line-modified"> 669         private final SnippetInfo allocateInstance = snippet(NewObjectSnippets.class, &quot;allocateInstance&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);</span>

 670         private final SnippetInfo allocateInstancePIC = snippet(NewObjectSnippets.class, &quot;allocateInstancePIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
<span class="line-modified"> 671                         TLAB_END_LOCATION);</span>
 672         private final SnippetInfo allocateArray = snippet(NewObjectSnippets.class, &quot;allocateArray&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 673         private final SnippetInfo allocateArrayPIC = snippet(NewObjectSnippets.class, &quot;allocateArrayPIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 674         private final SnippetInfo allocatePrimitiveArrayPIC = snippet(NewObjectSnippets.class, &quot;allocatePrimitiveArrayPIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
 675                         TLAB_END_LOCATION);
 676         private final SnippetInfo allocateArrayDynamic = snippet(NewObjectSnippets.class, &quot;allocateArrayDynamic&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
 677                         TLAB_END_LOCATION);
 678         private final SnippetInfo allocateInstanceDynamic = snippet(NewObjectSnippets.class, &quot;allocateInstanceDynamic&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
<span class="line-modified"> 679                         TLAB_END_LOCATION);</span>
 680         private final SnippetInfo newmultiarray = snippet(NewObjectSnippets.class, &quot;newmultiarray&quot;, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 681         private final SnippetInfo newmultiarrayPIC = snippet(NewObjectSnippets.class, &quot;newmultiarrayPIC&quot;, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 682         private final SnippetInfo verifyHeap = snippet(NewObjectSnippets.class, &quot;verifyHeap&quot;);

 683         private final GraalHotSpotVMConfig config;
 684         private final Counters counters;
 685 
 686         public Templates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory factory, HotSpotProviders providers, TargetDescription target,
 687                         GraalHotSpotVMConfig config) {
 688             super(options, factories, providers, providers.getSnippetReflection(), target);
 689             this.config = config;
 690             counters = new Counters(factory);
 691         }
 692 
 693         /**
 694          * Lowers a {@link NewInstanceNode}.
 695          */
 696         public void lower(NewInstanceNode newInstanceNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 697             StructuredGraph graph = newInstanceNode.graph();
 698             HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) newInstanceNode.instanceClass();
 699             assert !type.isArray();
 700             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), type.klass(), providers.getMetaAccess(), graph);
 701             long size = instanceSize(type);
 702 
 703             OptionValues localOptions = graph.getOptions();
 704             SnippetInfo snippet = GeneratePIC.getValue(localOptions) ? allocateInstancePIC : allocateInstance;
 705             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
 706             args.addConst(&quot;size&quot;, size);
 707             args.add(&quot;hub&quot;, hub);
 708             args.add(&quot;prototypeMarkWord&quot;, type.prototypeMarkWord());
 709             args.addConst(&quot;fillContents&quot;, newInstanceNode.fillContents());

 710             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 711             args.addConst(&quot;constantSize&quot;, true);
 712             args.addConst(&quot;typeContext&quot;, ProfileAllocations.getValue(localOptions) ? type.toJavaName(false) : &quot;&quot;);
 713             args.addConst(&quot;counters&quot;, counters);
 714 
 715             SnippetTemplate template = template(newInstanceNode, args);
 716             graph.getDebug().log(&quot;Lowering allocateInstance in %s: node=%s, template=%s, arguments=%s&quot;, graph, newInstanceNode, template, args);
 717             template.instantiate(providers.getMetaAccess(), newInstanceNode, DEFAULT_REPLACER, args);
 718         }
 719 
 720         /**
 721          * Lowers a {@link NewArrayNode}.
 722          */
 723         public void lower(NewArrayNode newArrayNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 724             StructuredGraph graph = newArrayNode.graph();
 725             ResolvedJavaType elementType = newArrayNode.elementType();
 726             HotSpotResolvedObjectType arrayType = (HotSpotResolvedObjectType) elementType.getArrayClass();
 727             JavaKind elementKind = elementType.getJavaKind();
 728             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), arrayType.klass(), providers.getMetaAccess(), graph);
 729             final int headerSize = tool.getMetaAccess().getArrayBaseOffset(elementKind);
</pre>
<hr />
<pre>
 733             SnippetInfo snippet;
 734             if (GeneratePIC.getValue(localOptions)) {
 735                 if (elementType.isPrimitive()) {
 736                     snippet = allocatePrimitiveArrayPIC;
 737                 } else {
 738                     snippet = allocateArrayPIC;
 739                 }
 740             } else {
 741                 snippet = allocateArray;
 742             }
 743 
 744             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
 745             args.add(&quot;hub&quot;, hub);
 746             ValueNode length = newArrayNode.length();
 747             args.add(&quot;length&quot;, length.isAlive() ? length : graph.addOrUniqueWithInputs(length));
 748             assert arrayType.prototypeMarkWord() == lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord() : &quot;all array types are assumed to have the same prototypeMarkWord&quot;;
 749             args.add(&quot;prototypeMarkWord&quot;, arrayType.prototypeMarkWord());
 750             args.addConst(&quot;headerSize&quot;, headerSize);
 751             args.addConst(&quot;log2ElementSize&quot;, log2ElementSize);
 752             args.addConst(&quot;fillContents&quot;, newArrayNode.fillContents());

 753             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 754             args.addConst(&quot;maybeUnroll&quot;, length.isConstant());
 755             args.addConst(&quot;typeContext&quot;, ProfileAllocations.getValue(localOptions) ? arrayType.toJavaName(false) : &quot;&quot;);

 756             args.addConst(&quot;counters&quot;, counters);
 757             SnippetTemplate template = template(newArrayNode, args);
 758             graph.getDebug().log(&quot;Lowering allocateArray in %s: node=%s, template=%s, arguments=%s&quot;, graph, newArrayNode, template, args);
 759             template.instantiate(providers.getMetaAccess(), newArrayNode, DEFAULT_REPLACER, args);
 760         }
 761 
 762         public void lower(DynamicNewInstanceNode newInstanceNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 763             Arguments args = new Arguments(allocateInstanceDynamic, newInstanceNode.graph().getGuardsStage(), tool.getLoweringStage());
 764             args.add(&quot;type&quot;, newInstanceNode.getInstanceType());
 765             ValueNode classClass = newInstanceNode.getClassClass();
 766             assert classClass != null;
 767             args.add(&quot;classClass&quot;, classClass);
 768             args.addConst(&quot;fillContents&quot;, newInstanceNode.fillContents());

 769             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 770             args.addConst(&quot;counters&quot;, counters);
 771 
 772             SnippetTemplate template = template(newInstanceNode, args);
 773             template.instantiate(providers.getMetaAccess(), newInstanceNode, DEFAULT_REPLACER, args);
 774         }
 775 
 776         public void lower(DynamicNewArrayNode newArrayNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 777             StructuredGraph graph = newArrayNode.graph();
<span class="line-modified"> 778             Arguments args = new Arguments(allocateArrayDynamic, newArrayNode.graph().getGuardsStage(), tool.getLoweringStage());</span>
 779             args.add(&quot;elementType&quot;, newArrayNode.getElementType());
 780             ValueNode voidClass = newArrayNode.getVoidClass();
 781             assert voidClass != null;
 782             args.add(&quot;voidClass&quot;, voidClass);
 783             ValueNode length = newArrayNode.length();
 784             args.add(&quot;length&quot;, length.isAlive() ? length : graph.addOrUniqueWithInputs(length));
 785             args.addConst(&quot;fillContents&quot;, newArrayNode.fillContents());

 786             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 787             /*
 788              * We use Kind.Illegal as a marker value instead of null because constant snippet
 789              * parameters cannot be null.
 790              */
 791             args.addConst(&quot;knownElementKind&quot;, newArrayNode.getKnownElementKind() == null ? JavaKind.Illegal : newArrayNode.getKnownElementKind());
 792             if (newArrayNode.getKnownElementKind() != null) {
 793                 args.addConst(&quot;knownLayoutHelper&quot;, lookupArrayClass(tool, newArrayNode.getKnownElementKind()).layoutHelper());
 794             } else {
 795                 args.addConst(&quot;knownLayoutHelper&quot;, 0);
 796             }

 797             args.add(&quot;prototypeMarkWord&quot;, lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord());
 798             args.addConst(&quot;counters&quot;, counters);
 799             SnippetTemplate template = template(newArrayNode, args);
 800             template.instantiate(providers.getMetaAccess(), newArrayNode, DEFAULT_REPLACER, args);
 801         }
 802 
 803         private static HotSpotResolvedObjectType lookupArrayClass(LoweringTool tool, JavaKind kind) {
 804             return (HotSpotResolvedObjectType) tool.getMetaAccess().lookupJavaType(kind == JavaKind.Object ? Object.class : kind.toJavaClass()).getArrayClass();
 805         }
 806 
 807         public void lower(NewMultiArrayNode newmultiarrayNode, LoweringTool tool) {
 808             StructuredGraph graph = newmultiarrayNode.graph();
 809             OptionValues localOptions = graph.getOptions();
 810             int rank = newmultiarrayNode.dimensionCount();
 811             ValueNode[] dims = new ValueNode[rank];
 812             for (int i = 0; i &lt; newmultiarrayNode.dimensionCount(); i++) {
 813                 dims[i] = newmultiarrayNode.dimension(i);
 814             }
 815             HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) newmultiarrayNode.type();
 816             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), type.klass(), providers.getMetaAccess(), graph);
</pre>
<hr />
<pre>
 823             template(newmultiarrayNode, args).instantiate(providers.getMetaAccess(), newmultiarrayNode, DEFAULT_REPLACER, args);
 824         }
 825 
 826         private static long instanceSize(HotSpotResolvedObjectType type) {
 827             long size = type.instanceSize();
 828             assert size &gt;= 0;
 829             return size;
 830         }
 831 
 832         public void lower(VerifyHeapNode verifyHeapNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 833             if (config.cAssertions) {
 834                 Arguments args = new Arguments(verifyHeap, verifyHeapNode.graph().getGuardsStage(), tool.getLoweringStage());
 835                 args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 836 
 837                 SnippetTemplate template = template(verifyHeapNode, args);
 838                 template.instantiate(providers.getMetaAccess(), verifyHeapNode, DEFAULT_REPLACER, args);
 839             } else {
 840                 GraphUtil.removeFixedWithUnusedInputs(verifyHeapNode);
 841             }
 842         }









 843     }
 844 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot.replacements;
  26 
<span class="line-added">  27 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateRecompile;</span>
  28 import static jdk.vm.ci.meta.DeoptimizationAction.None;
  29 import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;
  30 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
<span class="line-added">  31 import static org.graalvm.compiler.core.common.GraalOptions.MinimalBulkZeroingSize;</span>
  32 import static org.graalvm.compiler.core.common.calc.UnsignedMath.belowThan;
  33 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_OPTIONVALUES;
  34 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
  35 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY;
  36 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY_OR_NULL;
  37 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE;
  38 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE_OR_NULL;
  39 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY;
  40 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY_OR_NULL;
  41 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_ARRAY_KLASS_LOCATION;
<span class="line-added">  42 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_INIT_STATE_LOCATION;</span>
  43 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_WRITE_LOCATION;
  44 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
  45 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.PROTOTYPE_MARK_WORD_LOCATION;
  46 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_END_LOCATION;
  47 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_TOP_LOCATION;
  48 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocateInstancePrefetchLines;
  49 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchDistance;
  50 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchLines;
  51 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchStepSize;
  52 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchStyle;
  53 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayAllocationSize;
  54 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayKlassOffset;
  55 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayLengthOffset;
  56 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.initializeObjectHeader;
  57 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.instanceHeaderSize;
<span class="line-added">  58 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.instanceKlassStateBeingInitialized;</span>
  59 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.isInstanceKlassFullyInitialized;
  60 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeMask;
  61 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeShift;
  62 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeMask;
  63 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeShift;
  64 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.loadKlassFromObject;
  65 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.prototypeMarkWordOffset;
<span class="line-added">  66 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readInstanceKlassInitState;</span>
<span class="line-added">  67 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readInstanceKlassInitThread;</span>
  68 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readLayoutHelper;
  69 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readTlabEnd;
  70 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readTlabTop;
  71 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.registerAsWord;
  72 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.useBiasedLocking;
  73 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.useTLAB;
  74 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.verifyOop;
  75 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.writeTlabTop;
  76 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocations;
  77 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocationsContext;
  78 import static org.graalvm.compiler.nodes.PiArrayNode.piArrayCastToSnippetReplaceeStamp;
  79 import static org.graalvm.compiler.nodes.PiNode.piCastToSnippetReplaceeStamp;
<span class="line-added">  80 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.DEOPT_PROBABILITY;</span>
  81 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FAST_PATH_PROBABILITY;
  82 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FREQUENT_PROBABILITY;
  83 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;
<span class="line-added">  84 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.VERY_FAST_PATH_PROBABILITY;</span>
  85 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
  86 import static org.graalvm.compiler.replacements.ReplacementsUtil.REPLACEMENTS_ASSERTIONS_ENABLED;
  87 import static org.graalvm.compiler.replacements.ReplacementsUtil.runtimeAssert;
  88 import static org.graalvm.compiler.replacements.ReplacementsUtil.staticAssert;
  89 import static org.graalvm.compiler.replacements.SnippetTemplate.DEFAULT_REPLACER;
  90 import static org.graalvm.compiler.replacements.nodes.CStringConstant.cstring;
  91 import static org.graalvm.compiler.replacements.nodes.ExplodeLoopNode.explodeLoop;
  92 
  93 import org.graalvm.compiler.api.replacements.Fold;
  94 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
  95 import org.graalvm.compiler.api.replacements.Snippet;
  96 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
  97 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
  98 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
  99 import org.graalvm.compiler.core.common.type.StampFactory;
 100 import org.graalvm.compiler.debug.DebugHandlersFactory;
 101 import org.graalvm.compiler.debug.GraalError;
 102 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 103 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 104 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 105 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 106 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
 107 import org.graalvm.compiler.hotspot.nodes.DimensionsNode;
<span class="line-added"> 108 import org.graalvm.compiler.hotspot.nodes.KlassBeingInitializedCheckNode;</span>
 109 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyFixedNode;
 110 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyNode;
 111 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 112 import org.graalvm.compiler.hotspot.word.KlassPointer;
 113 import org.graalvm.compiler.nodes.ConstantNode;
 114 import org.graalvm.compiler.nodes.DeoptimizeNode;
 115 import org.graalvm.compiler.nodes.PiNode;
 116 import org.graalvm.compiler.nodes.PrefetchAllocateNode;
 117 import org.graalvm.compiler.nodes.SnippetAnchorNode;
 118 import org.graalvm.compiler.nodes.StructuredGraph;
 119 import org.graalvm.compiler.nodes.ValueNode;
 120 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
 121 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
<span class="line-added"> 122 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;</span>
 123 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 124 import org.graalvm.compiler.nodes.extended.MembarNode;
 125 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
 126 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 127 import org.graalvm.compiler.nodes.java.NewArrayNode;
 128 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 129 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 130 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 131 import org.graalvm.compiler.nodes.spi.LoweringTool;
 132 import org.graalvm.compiler.nodes.util.GraphUtil;
 133 import org.graalvm.compiler.options.OptionValues;
 134 import org.graalvm.compiler.replacements.ReplacementsUtil;
 135 import org.graalvm.compiler.replacements.SnippetCounter;
 136 import org.graalvm.compiler.replacements.SnippetCounter.Group;
 137 import org.graalvm.compiler.replacements.SnippetTemplate;
 138 import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;
 139 import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
 140 import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
 141 import org.graalvm.compiler.replacements.Snippets;
 142 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
<span class="line-added"> 143 import org.graalvm.compiler.replacements.nodes.ZeroMemoryNode;</span>
 144 import org.graalvm.compiler.word.Word;
 145 import jdk.internal.vm.compiler.word.LocationIdentity;
 146 import jdk.internal.vm.compiler.word.WordFactory;
 147 
 148 import jdk.vm.ci.code.CodeUtil;
 149 import jdk.vm.ci.code.MemoryBarriers;
 150 import jdk.vm.ci.code.Register;
 151 import jdk.vm.ci.code.TargetDescription;
 152 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 153 import jdk.vm.ci.meta.JavaKind;
 154 import jdk.vm.ci.meta.ResolvedJavaType;
 155 
 156 /**
 157  * Snippets used for implementing NEW, ANEWARRAY and NEWARRAY.
 158  */
 159 public class NewObjectSnippets implements Snippets {
 160 
 161     enum ProfileContext {
 162         AllocatingMethod,
 163         InstanceOrArray,
</pre>
<hr />
<pre>
 203             DynamicCounterNode.counter(&quot;number of allocations&quot;, name, 1, context);
 204         }
 205     }
 206 
 207     public static void emitPrefetchAllocate(Word address, boolean isArray) {
 208         if (allocatePrefetchStyle(INJECTED_VMCONFIG) &gt; 0) {
 209             // Insert a prefetch for each allocation only on the fast-path
 210             // Generate several prefetch instructions.
 211             int lines = isArray ? allocatePrefetchLines(INJECTED_VMCONFIG) : allocateInstancePrefetchLines(INJECTED_VMCONFIG);
 212             int stepSize = allocatePrefetchStepSize(INJECTED_VMCONFIG);
 213             int distance = allocatePrefetchDistance(INJECTED_VMCONFIG);
 214             ExplodeLoopNode.explodeLoop();
 215             for (int i = 0; i &lt; lines; i++) {
 216                 PrefetchAllocateNode.prefetch(OffsetAddressNode.address(address, distance));
 217                 distance += stepSize;
 218             }
 219         }
 220     }
 221 
 222     @Snippet
<span class="line-modified"> 223     public static Object allocateInstance(@ConstantParameter long size,</span>
<span class="line-modified"> 224                     KlassPointer hub,</span>
<span class="line-added"> 225                     Word prototypeMarkWord,</span>
<span class="line-added"> 226                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 227                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 228                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 229                     @ConstantParameter boolean constantSize,</span>
<span class="line-added"> 230                     @ConstantParameter String typeContext,</span>
 231                     @ConstantParameter Counters counters) {
<span class="line-modified"> 232         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, hub, prototypeMarkWord, fillContents, emitMemoryBarrier, threadRegister, constantSize, typeContext, counters));</span>
 233     }
 234 
<span class="line-modified"> 235     public static Object allocateInstanceHelper(long size,</span>
<span class="line-modified"> 236                     KlassPointer hub,</span>
<span class="line-added"> 237                     Word prototypeMarkWord,</span>
<span class="line-added"> 238                     boolean fillContents,</span>
<span class="line-added"> 239                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 240                     Register threadRegister,</span>
<span class="line-added"> 241                     boolean constantSize,</span>
<span class="line-added"> 242                     String typeContext,</span>
<span class="line-added"> 243                     Counters counters) {</span>
 244         Object result;
 245         Word thread = registerAsWord(threadRegister);
 246         Word top = readTlabTop(thread);
 247         Word end = readTlabEnd(thread);
 248         Word newTop = top.add(WordFactory.unsigned(size));
 249         if (useTLAB(INJECTED_VMCONFIG) &amp;&amp; probability(FAST_PATH_PROBABILITY, newTop.belowOrEqual(end))) {
 250             writeTlabTop(thread, newTop);
 251             emitPrefetchAllocate(newTop, false);
<span class="line-modified"> 252             result = formatObject(hub, size, top, prototypeMarkWord, fillContents, emitMemoryBarrier, constantSize, counters);</span>
 253         } else {
 254             Counters theCounters = counters;
 255             if (theCounters != null &amp;&amp; theCounters.stub != null) {
 256                 theCounters.stub.inc();
 257             }
 258             result = newInstanceStub(hub);
 259         }
 260         profileAllocation(&quot;instance&quot;, size, typeContext);
 261         return verifyOop(result);
 262     }
 263 
 264     public static Object newInstanceStub(KlassPointer hub) {
 265         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 266             return nonNullOrDeopt(newInstanceOrNull(NEW_INSTANCE_OR_NULL, hub));
 267         } else {
 268             return newInstance(NEW_INSTANCE, hub);
 269         }
 270     }
 271 
 272     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 273     private static native Object newInstance(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub);
 274 
 275     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 276     private static native Object newInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub);
 277 
 278     @Snippet
<span class="line-modified"> 279     public static Object allocateInstancePIC(@ConstantParameter long size,</span>
<span class="line-modified"> 280                     KlassPointer hub,</span>
<span class="line-added"> 281                     Word prototypeMarkWord,</span>
<span class="line-added"> 282                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 283                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 284                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 285                     @ConstantParameter boolean constantSize,</span>
<span class="line-added"> 286                     @ConstantParameter String typeContext,</span>
 287                     @ConstantParameter Counters counters) {
 288         // Klass must be initialized by the time the first instance is allocated, therefore we can
 289         // just load it from the corresponding cell and avoid the resolution check. We have to use a
 290         // fixed load though, to prevent it from floating above the initialization.
 291         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
<span class="line-modified"> 292         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, picHub, prototypeMarkWord, fillContents, emitMemoryBarrier, threadRegister, constantSize, typeContext, counters));</span>
 293     }
 294 
 295     @Snippet
<span class="line-modified"> 296     public static Object allocateInstanceDynamic(Class&lt;?&gt; type, Class&lt;?&gt; classClass,</span>
<span class="line-added"> 297                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 298                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 299                     @ConstantParameter Register threadRegister,</span>
 300                     @ConstantParameter Counters counters) {
<span class="line-modified"> 301         if (probability(DEOPT_PROBABILITY, type == null)) {</span>
 302             DeoptimizeNode.deopt(None, RuntimeConstraint);
 303         }
 304         Class&lt;?&gt; nonNullType = PiNode.piCastNonNullClass(type, SnippetAnchorNode.anchor());
 305 
<span class="line-modified"> 306         if (probability(DEOPT_PROBABILITY, DynamicNewInstanceNode.throwsInstantiationException(type, classClass))) {</span>
 307             DeoptimizeNode.deopt(None, RuntimeConstraint);
 308         }
 309 
<span class="line-modified"> 310         return PiNode.piCastToSnippetReplaceeStamp(allocateInstanceDynamicHelper(type, fillContents, emitMemoryBarrier, threadRegister, counters, nonNullType));</span>
 311     }
 312 
<span class="line-modified"> 313     private static Object allocateInstanceDynamicHelper(Class&lt;?&gt; type,</span>
<span class="line-added"> 314                     boolean fillContents,</span>
<span class="line-added"> 315                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 316                     Register threadRegister,</span>
<span class="line-added"> 317                     Counters counters,</span>
<span class="line-added"> 318                     Class&lt;?&gt; nonNullType) {</span>
 319         KlassPointer hub = ClassGetHubNode.readClass(nonNullType);
 320         if (probability(FAST_PATH_PROBABILITY, !hub.isNull())) {
 321             KlassPointer nonNullHub = ClassGetHubNode.piCastNonNull(hub, SnippetAnchorNode.anchor());
 322 
<span class="line-modified"> 323             if (probability(VERY_FAST_PATH_PROBABILITY, isInstanceKlassFullyInitialized(nonNullHub))) {</span>
 324                 int layoutHelper = readLayoutHelper(nonNullHub);
 325                 /*
 326                  * src/share/vm/oops/klass.hpp: For instances, layout helper is a positive number,
 327                  * the instance size. This size is already passed through align_object_size and
 328                  * scaled to bytes. The low order bit is set if instances of this class cannot be
 329                  * allocated using the fastpath.
 330                  */
 331                 if (probability(FAST_PATH_PROBABILITY, (layoutHelper &amp; 1) == 0)) {
 332                     Word prototypeMarkWord = nonNullHub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION);
 333                     /*
 334                      * FIXME(je,ds): we should actually pass typeContext instead of &quot;&quot; but late
 335                      * binding of parameters is not yet supported by the GraphBuilderPlugin system.
 336                      */
<span class="line-modified"> 337                     return allocateInstanceHelper(layoutHelper, nonNullHub, prototypeMarkWord, fillContents, emitMemoryBarrier, threadRegister, false, &quot;&quot;, counters);</span>
 338                 }
 339             } else {
 340                 DeoptimizeNode.deopt(None, RuntimeConstraint);
 341             }
 342         }
 343         return dynamicNewInstanceStub(type);
 344     }
 345 
 346     /**
 347      * Maximum array length for which fast path allocation is used.
 348      */
 349     public static final int MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH = 0x00FFFFFF;
 350 
 351     @Snippet
<span class="line-modified"> 352     public static Object allocatePrimitiveArrayPIC(KlassPointer hub,</span>
<span class="line-modified"> 353                     int length,</span>
<span class="line-added"> 354                     Word prototypeMarkWord,</span>
<span class="line-added"> 355                     @ConstantParameter int headerSize,</span>
<span class="line-added"> 356                     @ConstantParameter int log2ElementSize,</span>
<span class="line-added"> 357                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 358                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 359                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 360                     @ConstantParameter boolean maybeUnroll,</span>
<span class="line-added"> 361                     @ConstantParameter String typeContext,</span>
<span class="line-added"> 362                     @ConstantParameter boolean supportsBulkZeroing,</span>
 363                     @ConstantParameter Counters counters) {
 364         // Primitive array types are eagerly pre-resolved. We can use a floating load.
 365         KlassPointer picHub = LoadConstantIndirectlyNode.loadKlass(hub);
<span class="line-modified"> 366         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents,</span>
<span class="line-added"> 367                         emitMemoryBarrier, threadRegister, maybeUnroll, typeContext, supportsBulkZeroing, counters);</span>
 368     }
 369 
 370     @Snippet
<span class="line-modified"> 371     public static Object allocateArrayPIC(KlassPointer hub,</span>
<span class="line-modified"> 372                     int length,</span>
<span class="line-added"> 373                     Word prototypeMarkWord,</span>
<span class="line-added"> 374                     @ConstantParameter int headerSize,</span>
<span class="line-added"> 375                     @ConstantParameter int log2ElementSize,</span>
<span class="line-added"> 376                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 377                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 378                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 379                     @ConstantParameter boolean maybeUnroll,</span>
<span class="line-added"> 380                     @ConstantParameter String typeContext,</span>
<span class="line-added"> 381                     @ConstantParameter boolean supportsBulkZeroing,</span>
 382                     @ConstantParameter Counters counters) {
 383         // Array type would be resolved by dominating resolution.
 384         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
<span class="line-modified"> 385         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents,</span>
<span class="line-added"> 386                         emitMemoryBarrier, threadRegister, maybeUnroll, typeContext, supportsBulkZeroing, counters);</span>
 387     }
 388 
 389     @Snippet
 390     public static Object allocateArray(KlassPointer hub,
 391                     int length,
 392                     Word prototypeMarkWord,
 393                     @ConstantParameter int headerSize,
 394                     @ConstantParameter int log2ElementSize,
 395                     @ConstantParameter boolean fillContents,
<span class="line-added"> 396                     @ConstantParameter boolean emitMemoryBarrier,</span>
 397                     @ConstantParameter Register threadRegister,
 398                     @ConstantParameter boolean maybeUnroll,
 399                     @ConstantParameter String typeContext,
<span class="line-added"> 400                     @ConstantParameter boolean supportsBulkZeroing,</span>
 401                     @ConstantParameter Counters counters) {
 402         Object result = allocateArrayImpl(hub,
 403                         length,
 404                         prototypeMarkWord,
 405                         headerSize,
 406                         log2ElementSize,
 407                         fillContents,
<span class="line-modified"> 408                         emitMemoryBarrier, threadRegister,</span>
 409                         maybeUnroll,
 410                         typeContext,
<span class="line-modified"> 411                         supportsBulkZeroing,</span>
 412                         counters);
 413         return piArrayCastToSnippetReplaceeStamp(verifyOop(result), length);
 414     }
 415 
 416     /**
 417      * When allocating on the slow path, determines whether to use a version of the runtime call
 418      * that returns {@code null} on a failed allocation instead of raising an OutOfMemoryError.
 419      */
 420     @Fold
 421     static boolean useNullAllocationStubs(@InjectedParameter GraalHotSpotVMConfig config) {
 422         return config.areNullAllocationStubsAvailable();
 423     }
 424 
<span class="line-modified"> 425     private static Object allocateArrayImpl(KlassPointer hub,</span>
<span class="line-modified"> 426                     int length,</span>
<span class="line-added"> 427                     Word prototypeMarkWord,</span>
<span class="line-added"> 428                     int headerSize,</span>
<span class="line-added"> 429                     int log2ElementSize,</span>
<span class="line-added"> 430                     boolean fillContents,</span>
<span class="line-added"> 431                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 432                     Register threadRegister,</span>
<span class="line-added"> 433                     boolean maybeUnroll,</span>
<span class="line-added"> 434                     String typeContext,</span>
<span class="line-added"> 435                     boolean supportsBulkZeroing,</span>
<span class="line-added"> 436                     Counters counters) {</span>
 437         Object result;
 438         long allocationSize = arrayAllocationSize(length, headerSize, log2ElementSize);
 439         Word thread = registerAsWord(threadRegister);
 440         Word top = readTlabTop(thread);
 441         Word end = readTlabEnd(thread);
 442         Word newTop = top.add(WordFactory.unsigned(allocationSize));
 443         if (probability(FREQUENT_PROBABILITY, belowThan(length, MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH)) &amp;&amp; useTLAB(INJECTED_VMCONFIG) &amp;&amp;
 444                         probability(FAST_PATH_PROBABILITY, newTop.belowOrEqual(end))) {
 445             writeTlabTop(thread, newTop);
 446             emitPrefetchAllocate(newTop, true);
 447             Counters theCounters = counters;
 448             if (theCounters != null &amp;&amp; theCounters.arrayLoopInit != null) {
 449                 theCounters.arrayLoopInit.inc();
 450             }
<span class="line-modified"> 451             result = formatArray(hub, allocationSize, length, headerSize, top, prototypeMarkWord, fillContents, emitMemoryBarrier, maybeUnroll, supportsBulkZeroing, counters);</span>
 452         } else {
 453             result = newArrayStub(hub, length);
 454         }
 455         profileAllocation(&quot;array&quot;, allocationSize, typeContext);
 456         return result;
 457     }
 458 
 459     public static Object newArrayStub(KlassPointer hub, int length) {
 460         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 461             return nonNullOrDeopt(newArrayOrNull(NEW_ARRAY_OR_NULL, hub, length));
 462         } else {
 463             return newArray(NEW_ARRAY, hub, length);
 464         }
 465     }
 466 
 467     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 468     private static native Object newArray(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int length);
 469 
 470     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 471     private static native Object newArrayOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int length);
</pre>
<hr />
<pre>
 475      */
 476     public static final ForeignCallDescriptor DYNAMIC_NEW_INSTANCE = new ForeignCallDescriptor(&quot;dynamic_new_instance&quot;, Object.class, Class.class);
 477 
 478     /**
 479      * New dynamic array stub that returns null on allocation failure.
 480      */
 481     public static final ForeignCallDescriptor DYNAMIC_NEW_INSTANCE_OR_NULL = new ForeignCallDescriptor(&quot;dynamic_new_instance_or_null&quot;, Object.class, Class.class);
 482 
 483     public static Object dynamicNewInstanceStub(Class&lt;?&gt; elementType) {
 484         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 485             return nonNullOrDeopt(dynamicNewInstanceOrNull(DYNAMIC_NEW_INSTANCE_OR_NULL, elementType));
 486         } else {
 487             return dynamicNewInstance(DYNAMIC_NEW_INSTANCE, elementType);
 488         }
 489     }
 490 
 491     /**
 492      * Deoptimizes if {@code obj == null} otherwise returns {@code obj}.
 493      */
 494     private static Object nonNullOrDeopt(Object obj) {
<span class="line-modified"> 495         if (BranchProbabilityNode.probability(BranchProbabilityNode.DEOPT_PROBABILITY, obj == null)) {</span>
 496             DeoptimizeNode.deopt(None, RuntimeConstraint);
 497         }
 498         return obj;
 499     }
 500 
 501     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 502     public static native Object dynamicNewInstance(@ConstantNodeParameter ForeignCallDescriptor descriptor, Class&lt;?&gt; elementType);
 503 
 504     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 505     public static native Object dynamicNewInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, Class&lt;?&gt; elementType);
 506 
 507     @Snippet
<span class="line-modified"> 508     public static Object allocateArrayDynamic(Class&lt;?&gt; elementType,</span>
<span class="line-modified"> 509                     Class&lt;?&gt; voidClass,</span>
<span class="line-added"> 510                     int length,</span>
<span class="line-added"> 511                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 512                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 513                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 514                     @ConstantParameter JavaKind knownElementKind,</span>
<span class="line-added"> 515                     @ConstantParameter int knownLayoutHelper,</span>
<span class="line-added"> 516                     @ConstantParameter boolean supportsBulkZeroing,</span>
<span class="line-added"> 517                     Word prototypeMarkWord,</span>
 518                     @ConstantParameter Counters counters) {
<span class="line-modified"> 519         Object result = allocateArrayDynamicImpl(elementType, voidClass, length, fillContents, emitMemoryBarrier, threadRegister, knownElementKind,</span>
<span class="line-added"> 520                         knownLayoutHelper, supportsBulkZeroing, prototypeMarkWord, counters);</span>
 521         return result;
 522     }
 523 
<span class="line-modified"> 524     private static Object allocateArrayDynamicImpl(Class&lt;?&gt; elementType,</span>
<span class="line-modified"> 525                     Class&lt;?&gt; voidClass,</span>
<span class="line-added"> 526                     int length,</span>
<span class="line-added"> 527                     boolean fillContents,</span>
<span class="line-added"> 528                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 529                     Register threadRegister,</span>
<span class="line-added"> 530                     JavaKind knownElementKind,</span>
<span class="line-added"> 531                     int knownLayoutHelper,</span>
<span class="line-added"> 532                     boolean supportsBulkZeroing,</span>
<span class="line-added"> 533                     Word prototypeMarkWord,</span>
<span class="line-added"> 534                     Counters counters) {</span>
 535         /*
 536          * We only need the dynamic check for void when we have no static information from
 537          * knownElementKind.
 538          */
 539         staticAssert(knownElementKind != JavaKind.Void, &quot;unsupported knownElementKind&quot;);
 540         if (knownElementKind == JavaKind.Illegal &amp;&amp; probability(SLOW_PATH_PROBABILITY, elementType == null || DynamicNewArrayNode.throwsIllegalArgumentException(elementType, voidClass))) {
 541             DeoptimizeNode.deopt(None, RuntimeConstraint);
 542         }
 543 
 544         KlassPointer klass = loadKlassFromObject(elementType, arrayKlassOffset(INJECTED_VMCONFIG), CLASS_ARRAY_KLASS_LOCATION);
<span class="line-modified"> 545         if (probability(DEOPT_PROBABILITY, klass.isNull())) {</span>
 546             DeoptimizeNode.deopt(None, RuntimeConstraint);
 547         }
 548         KlassPointer nonNullKlass = ClassGetHubNode.piCastNonNull(klass, SnippetAnchorNode.anchor());
 549 
<span class="line-modified"> 550         if (probability(DEOPT_PROBABILITY, length &lt; 0)) {</span>
 551             DeoptimizeNode.deopt(None, RuntimeConstraint);
 552         }
 553         int layoutHelper;
 554         if (knownElementKind == JavaKind.Illegal) {
 555             layoutHelper = readLayoutHelper(nonNullKlass);
 556         } else {
 557             runtimeAssert(knownLayoutHelper == readLayoutHelper(nonNullKlass), &quot;layout mismatch&quot;);
 558             layoutHelper = knownLayoutHelper;
 559         }
 560         //@formatter:off
 561         // from src/share/vm/oops/klass.hpp:
 562         //
 563         // For arrays, layout helper is a negative number, containing four
 564         // distinct bytes, as follows:
 565         //    MSB:[tag, hsz, ebt, log2(esz)]:LSB
 566         // where:
 567         //    tag is 0x80 if the elements are oops, 0xC0 if non-oops
 568         //    hsz is array header size in bytes (i.e., offset of first element)
 569         //    ebt is the BasicType of the elements
 570         //    esz is the element size in bytes
 571         //@formatter:on
 572 
 573         int headerSize = (layoutHelper &gt;&gt; layoutHelperHeaderSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperHeaderSizeMask(INJECTED_VMCONFIG);
 574         int log2ElementSize = (layoutHelper &gt;&gt; layoutHelperLog2ElementSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperLog2ElementSizeMask(INJECTED_VMCONFIG);
 575 
<span class="line-modified"> 576         Object result = allocateArrayImpl(nonNullKlass, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents,</span>
<span class="line-added"> 577                         emitMemoryBarrier, threadRegister, false, &quot;dynamic type&quot;, supportsBulkZeroing, counters);</span>
 578         return piArrayCastToSnippetReplaceeStamp(verifyOop(result), length);
 579     }
 580 
 581     /**
 582      * Calls the runtime stub for implementing MULTIANEWARRAY.
 583      */
 584     @Snippet
 585     private static Object newmultiarray(KlassPointer hub, @ConstantParameter int rank, @VarargsParameter int[] dimensions) {
 586         Word dims = DimensionsNode.allocaDimsArray(rank);
 587         ExplodeLoopNode.explodeLoop();
 588         for (int i = 0; i &lt; rank; i++) {
 589             dims.writeInt(i * 4, dimensions[i], LocationIdentity.init());
 590         }
 591         return newMultiArrayStub(hub, rank, dims);
 592     }
 593 
 594     private static Object newMultiArrayStub(KlassPointer hub, int rank, Word dims) {
 595         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 596             return nonNullOrDeopt(newMultiArrayOrNull(NEW_MULTI_ARRAY_OR_NULL, hub, rank, dims));
 597         } else {
</pre>
<hr />
<pre>
 605         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
 606         return newmultiarray(picHub, rank, dimensions);
 607     }
 608 
 609     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 610     private static native Object newMultiArray(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int rank, Word dims);
 611 
 612     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 613     private static native Object newMultiArrayOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int rank, Word dims);
 614 
 615     /**
 616      * Maximum number of long stores to emit when zeroing an object with a constant size. Larger
 617      * objects have their bodies initialized in a loop.
 618      */
 619     private static final int MAX_UNROLLED_OBJECT_ZEROING_STORES = 8;
 620 
 621     /**
 622      * Zero uninitialized memory in a newly allocated object, unrolling as necessary and ensuring
 623      * that stores are aligned.
 624      *

 625      * @param memory beginning of object which is being zeroed
<span class="line-modified"> 626      * @param startOffset offset to begin zeroing (inclusive). May not be word aligned.</span>
<span class="line-modified"> 627      * @param endOffset offset to stop zeroing (exclusive). May not be word aligned.</span>
<span class="line-added"> 628      * @param isEndOffsetConstant is {@code endOffset} known to be constant in the snippet</span>
 629      * @param manualUnroll maximally unroll zeroing
<span class="line-added"> 630      * @param supportsBulkZeroing whether bulk zeroing is supported by the backend</span>
 631      */
<span class="line-modified"> 632     private static void zeroMemory(Word memory, int startOffset, long endOffset, boolean isEndOffsetConstant, boolean manualUnroll,</span>
<span class="line-modified"> 633                     boolean supportsBulkZeroing, Counters counters) {</span>
<span class="line-added"> 634         fillMemory(0, memory, startOffset, endOffset, isEndOffsetConstant, manualUnroll, supportsBulkZeroing, counters);</span>
 635     }
 636 
<span class="line-modified"> 637     private static void fillMemory(long value, Word memory, int startOffset, long endOffset, boolean constantOffsetLimit, boolean manualUnroll,</span>
<span class="line-modified"> 638                     boolean supportsBulkZeroing, Counters counters) {</span>
<span class="line-added"> 639         ReplacementsUtil.runtimeAssert((endOffset &amp; 0x7) == 0, &quot;unaligned object size&quot;);</span>
 640         int offset = startOffset;
 641         if ((offset &amp; 0x7) != 0) {
 642             memory.writeInt(offset, (int) value, LocationIdentity.init());
 643             offset += 4;
 644         }
 645         ReplacementsUtil.runtimeAssert((offset &amp; 0x7) == 0, &quot;unaligned offset&quot;);
 646         Counters theCounters = counters;
<span class="line-modified"> 647         if (manualUnroll &amp;&amp; ((endOffset - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="line-modified"> 648             ReplacementsUtil.staticAssert(!constantOffsetLimit, &quot;size shouldn&#39;t be constant at instantiation time&quot;);</span>
 649             // This case handles arrays of constant length. Instead of having a snippet variant for
 650             // each length, generate a chain of stores of maximum length. Once it&#39;s inlined the
 651             // break statement will trim excess stores.
 652             if (theCounters != null &amp;&amp; theCounters.instanceSeqInit != null) {
 653                 theCounters.instanceSeqInit.inc();
 654             }
 655 
 656             explodeLoop();
 657             for (int i = 0; i &lt; MAX_UNROLLED_OBJECT_ZEROING_STORES; i++, offset += 8) {
<span class="line-modified"> 658                 if (offset == endOffset) {</span>
 659                     break;
 660                 }
 661                 memory.initializeLong(offset, value, LocationIdentity.init());
 662             }
 663         } else {
 664             // Use Word instead of int to avoid extension to long in generated code
 665             Word off = WordFactory.signed(offset);
<span class="line-modified"> 666             if (supportsBulkZeroing &amp;&amp; value == 0 &amp;&amp; probability(SLOW_PATH_PROBABILITY, (endOffset - offset) &gt;= getMinimalBulkZeroingSize(INJECTED_OPTIONVALUES))) {</span>
<span class="line-modified"> 667                 if (theCounters != null &amp;&amp; theCounters.instanceBulkInit != null) {</span>
<span class="line-modified"> 668                     theCounters.instanceBulkInit.inc();</span>
 669                 }
<span class="line-modified"> 670                 ZeroMemoryNode.zero(memory.add(off), endOffset - offset, true, LocationIdentity.init());</span>
 671             } else {
<span class="line-modified"> 672                 if (constantOffsetLimit &amp;&amp; ((endOffset - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="line-modified"> 673                     if (theCounters != null &amp;&amp; theCounters.instanceSeqInit != null) {</span>
<span class="line-added"> 674                         theCounters.instanceSeqInit.inc();</span>
<span class="line-added"> 675                     }</span>
<span class="line-added"> 676                     explodeLoop();</span>
<span class="line-added"> 677                 } else {</span>
<span class="line-added"> 678                     if (theCounters != null &amp;&amp; theCounters.instanceLoopInit != null) {</span>
<span class="line-added"> 679                         theCounters.instanceLoopInit.inc();</span>
<span class="line-added"> 680                     }</span>
<span class="line-added"> 681                 }</span>
<span class="line-added"> 682                 for (; off.rawValue() &lt; endOffset; off = off.add(8)) {</span>
<span class="line-added"> 683                     memory.initializeLong(off, value, LocationIdentity.init());</span>
 684                 }



 685             }
 686         }
 687     }
 688 
<span class="line-added"> 689     @Fold</span>
<span class="line-added"> 690     static int getMinimalBulkZeroingSize(@InjectedParameter OptionValues optionValues) {</span>
<span class="line-added"> 691         return MinimalBulkZeroingSize.getValue(optionValues);</span>
<span class="line-added"> 692     }</span>
<span class="line-added"> 693 </span>
 694     /**
 695      * Fill uninitialized memory with garbage value in a newly allocated object, unrolling as
 696      * necessary and ensuring that stores are aligned.
 697      *

 698      * @param memory beginning of object which is being zeroed
<span class="line-modified"> 699      * @param startOffset offset to begin filling garbage value (inclusive). May not be word</span>
<span class="line-modified"> 700      *            aligned.</span>
<span class="line-added"> 701      * @param endOffset offset to stop filling garbage value (exclusive). May not be word aligned.</span>
<span class="line-added"> 702      * @param isEndOffsetConstant is {@code  endOffset} known to be constant in the snippet</span>
 703      * @param manualUnroll maximally unroll zeroing
 704      */
<span class="line-modified"> 705     private static void fillWithGarbage(Word memory, int startOffset, long endOffset, boolean isEndOffsetConstant, boolean manualUnroll, Counters counters) {</span>
<span class="line-modified"> 706         fillMemory(0xfefefefefefefefeL, memory, startOffset, endOffset, isEndOffsetConstant, manualUnroll, false, counters);</span>
 707     }
 708 
 709     /**
 710      * Formats some allocated memory with an object header and zeroes out the rest.
 711      */
<span class="line-modified"> 712     private static Object formatObject(KlassPointer hub,</span>
<span class="line-added"> 713                     long size,</span>
<span class="line-added"> 714                     Word memory,</span>
<span class="line-added"> 715                     Word compileTimePrototypeMarkWord,</span>
<span class="line-added"> 716                     boolean fillContents,</span>
<span class="line-added"> 717                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 718                     boolean constantSize,</span>
<span class="line-added"> 719                     Counters counters) {</span>
 720         Word prototypeMarkWord = useBiasedLocking(INJECTED_VMCONFIG) ? hub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION) : compileTimePrototypeMarkWord;
 721         initializeObjectHeader(memory, prototypeMarkWord, hub);
 722         if (fillContents) {
<span class="line-modified"> 723             zeroMemory(memory, instanceHeaderSize(INJECTED_VMCONFIG), size, constantSize, false, false, counters);</span>
 724         } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {
<span class="line-modified"> 725             fillWithGarbage(memory, instanceHeaderSize(INJECTED_VMCONFIG), size, constantSize, false, counters);</span>
<span class="line-added"> 726         }</span>
<span class="line-added"> 727         if (emitMemoryBarrier) {</span>
<span class="line-added"> 728             MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
 729         }

 730         return memory.toObjectNonNull();
 731     }
 732 
 733     @Snippet
 734     private static void verifyHeap(@ConstantParameter Register threadRegister) {
 735         Word thread = registerAsWord(threadRegister);
 736         Word topValue = readTlabTop(thread);
 737         if (!topValue.equal(WordFactory.zero())) {
 738             Word topValueContents = topValue.readWord(0, MARK_WORD_LOCATION);
 739             if (topValueContents.equal(WordFactory.zero())) {
 740                 AssertionSnippets.vmMessageC(AssertionSnippets.ASSERTION_VM_MESSAGE_C, true, cstring(&quot;overzeroing of TLAB detected&quot;), 0L, 0L, 0L);
 741             }
 742         }
 743     }
 744 
<span class="line-added"> 745     @Snippet</span>
<span class="line-added"> 746     private static void threadBeingInitializedCheck(@ConstantParameter Register threadRegister, KlassPointer klass) {</span>
<span class="line-added"> 747         int state = readInstanceKlassInitState(klass);</span>
<span class="line-added"> 748         if (state != instanceKlassStateBeingInitialized(INJECTED_VMCONFIG)) {</span>
<span class="line-added"> 749             // The klass is no longer being initialized so force recompilation</span>
<span class="line-added"> 750             DeoptimizeNode.deopt(InvalidateRecompile, RuntimeConstraint);</span>
<span class="line-added"> 751         } else if (registerAsWord(threadRegister) != readInstanceKlassInitThread(klass)) {</span>
<span class="line-added"> 752             // The klass is being initialized but this isn&#39;t the initializing thread so</span>
<span class="line-added"> 753             // so deopt and allow execution to resume in the interpreter where it should block.</span>
<span class="line-added"> 754             DeoptimizeNode.deopt(None, RuntimeConstraint);</span>
<span class="line-added"> 755         }</span>
<span class="line-added"> 756     }</span>
<span class="line-added"> 757 </span>
 758     /**
 759      * Formats some allocated memory with an object header and zeroes out the rest.
 760      */
<span class="line-modified"> 761     private static Object formatArray(KlassPointer hub,</span>
<span class="line-added"> 762                     long allocationSize,</span>
<span class="line-added"> 763                     int length,</span>
<span class="line-added"> 764                     int headerSize,</span>
<span class="line-added"> 765                     Word memory,</span>
<span class="line-added"> 766                     Word prototypeMarkWord,</span>
<span class="line-added"> 767                     boolean fillContents,</span>
<span class="line-added"> 768                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 769                     boolean maybeUnroll,</span>
<span class="line-added"> 770                     boolean supportsBulkZeroing,</span>
 771                     Counters counters) {
 772         memory.writeInt(arrayLengthOffset(INJECTED_VMCONFIG), length, LocationIdentity.init());
 773         /*
 774          * store hub last as the concurrent garbage collectors assume length is valid if hub field
 775          * is not null
 776          */
 777         initializeObjectHeader(memory, prototypeMarkWord, hub);
 778         if (fillContents) {
<span class="line-modified"> 779             zeroMemory(memory, headerSize, allocationSize, false, maybeUnroll, supportsBulkZeroing, counters);</span>
 780         } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {
<span class="line-modified"> 781             fillWithGarbage(memory, headerSize, allocationSize, false, maybeUnroll, counters);</span>
<span class="line-added"> 782         }</span>
<span class="line-added"> 783         if (emitMemoryBarrier) {</span>
<span class="line-added"> 784             MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
 785         }

 786         return memory.toObjectNonNull();
 787     }
 788 
 789     static class Counters {
 790         Counters(SnippetCounter.Group.Factory factory) {
 791             Group newInstance = factory.createSnippetCounterGroup(&quot;NewInstance&quot;);
 792             Group newArray = factory.createSnippetCounterGroup(&quot;NewArray&quot;);
 793             instanceSeqInit = new SnippetCounter(newInstance, &quot;tlabSeqInit&quot;, &quot;TLAB alloc with unrolled zeroing&quot;);
 794             instanceLoopInit = new SnippetCounter(newInstance, &quot;tlabLoopInit&quot;, &quot;TLAB alloc with zeroing in a loop&quot;);
<span class="line-added"> 795             instanceBulkInit = new SnippetCounter(newArray, &quot;tlabBulkInit&quot;, &quot;TLAB alloc with bulk zeroing&quot;);</span>
 796             arrayLoopInit = new SnippetCounter(newArray, &quot;tlabLoopInit&quot;, &quot;TLAB alloc with zeroing in a loop&quot;);
 797             stub = new SnippetCounter(newInstance, &quot;stub&quot;, &quot;alloc and zeroing via stub&quot;);
 798         }
 799 
 800         final SnippetCounter instanceSeqInit;
 801         final SnippetCounter instanceLoopInit;
<span class="line-added"> 802         final SnippetCounter instanceBulkInit;</span>
 803         final SnippetCounter arrayLoopInit;
 804         final SnippetCounter stub;
 805     }
 806 
 807     public static class Templates extends AbstractTemplates {
 808 
<span class="line-modified"> 809         private final SnippetInfo allocateInstance = snippet(NewObjectSnippets.class, &quot;allocateInstance&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION,</span>
<span class="line-added"> 810                         PROTOTYPE_MARK_WORD_LOCATION);</span>
 811         private final SnippetInfo allocateInstancePIC = snippet(NewObjectSnippets.class, &quot;allocateInstancePIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
<span class="line-modified"> 812                         TLAB_END_LOCATION, PROTOTYPE_MARK_WORD_LOCATION);</span>
 813         private final SnippetInfo allocateArray = snippet(NewObjectSnippets.class, &quot;allocateArray&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 814         private final SnippetInfo allocateArrayPIC = snippet(NewObjectSnippets.class, &quot;allocateArrayPIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 815         private final SnippetInfo allocatePrimitiveArrayPIC = snippet(NewObjectSnippets.class, &quot;allocatePrimitiveArrayPIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
 816                         TLAB_END_LOCATION);
 817         private final SnippetInfo allocateArrayDynamic = snippet(NewObjectSnippets.class, &quot;allocateArrayDynamic&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
 818                         TLAB_END_LOCATION);
 819         private final SnippetInfo allocateInstanceDynamic = snippet(NewObjectSnippets.class, &quot;allocateInstanceDynamic&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
<span class="line-modified"> 820                         TLAB_END_LOCATION, PROTOTYPE_MARK_WORD_LOCATION, CLASS_INIT_STATE_LOCATION);</span>
 821         private final SnippetInfo newmultiarray = snippet(NewObjectSnippets.class, &quot;newmultiarray&quot;, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 822         private final SnippetInfo newmultiarrayPIC = snippet(NewObjectSnippets.class, &quot;newmultiarrayPIC&quot;, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 823         private final SnippetInfo verifyHeap = snippet(NewObjectSnippets.class, &quot;verifyHeap&quot;);
<span class="line-added"> 824         private final SnippetInfo threadBeingInitializedCheck = snippet(NewObjectSnippets.class, &quot;threadBeingInitializedCheck&quot;);</span>
 825         private final GraalHotSpotVMConfig config;
 826         private final Counters counters;
 827 
 828         public Templates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory factory, HotSpotProviders providers, TargetDescription target,
 829                         GraalHotSpotVMConfig config) {
 830             super(options, factories, providers, providers.getSnippetReflection(), target);
 831             this.config = config;
 832             counters = new Counters(factory);
 833         }
 834 
 835         /**
 836          * Lowers a {@link NewInstanceNode}.
 837          */
 838         public void lower(NewInstanceNode newInstanceNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 839             StructuredGraph graph = newInstanceNode.graph();
 840             HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) newInstanceNode.instanceClass();
 841             assert !type.isArray();
 842             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), type.klass(), providers.getMetaAccess(), graph);
 843             long size = instanceSize(type);
 844 
 845             OptionValues localOptions = graph.getOptions();
 846             SnippetInfo snippet = GeneratePIC.getValue(localOptions) ? allocateInstancePIC : allocateInstance;
 847             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
 848             args.addConst(&quot;size&quot;, size);
 849             args.add(&quot;hub&quot;, hub);
 850             args.add(&quot;prototypeMarkWord&quot;, type.prototypeMarkWord());
 851             args.addConst(&quot;fillContents&quot;, newInstanceNode.fillContents());
<span class="line-added"> 852             args.addConst(&quot;emitMemoryBarrier&quot;, newInstanceNode.emitMemoryBarrier());</span>
 853             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 854             args.addConst(&quot;constantSize&quot;, true);
 855             args.addConst(&quot;typeContext&quot;, ProfileAllocations.getValue(localOptions) ? type.toJavaName(false) : &quot;&quot;);
 856             args.addConst(&quot;counters&quot;, counters);
 857 
 858             SnippetTemplate template = template(newInstanceNode, args);
 859             graph.getDebug().log(&quot;Lowering allocateInstance in %s: node=%s, template=%s, arguments=%s&quot;, graph, newInstanceNode, template, args);
 860             template.instantiate(providers.getMetaAccess(), newInstanceNode, DEFAULT_REPLACER, args);
 861         }
 862 
 863         /**
 864          * Lowers a {@link NewArrayNode}.
 865          */
 866         public void lower(NewArrayNode newArrayNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 867             StructuredGraph graph = newArrayNode.graph();
 868             ResolvedJavaType elementType = newArrayNode.elementType();
 869             HotSpotResolvedObjectType arrayType = (HotSpotResolvedObjectType) elementType.getArrayClass();
 870             JavaKind elementKind = elementType.getJavaKind();
 871             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), arrayType.klass(), providers.getMetaAccess(), graph);
 872             final int headerSize = tool.getMetaAccess().getArrayBaseOffset(elementKind);
</pre>
<hr />
<pre>
 876             SnippetInfo snippet;
 877             if (GeneratePIC.getValue(localOptions)) {
 878                 if (elementType.isPrimitive()) {
 879                     snippet = allocatePrimitiveArrayPIC;
 880                 } else {
 881                     snippet = allocateArrayPIC;
 882                 }
 883             } else {
 884                 snippet = allocateArray;
 885             }
 886 
 887             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
 888             args.add(&quot;hub&quot;, hub);
 889             ValueNode length = newArrayNode.length();
 890             args.add(&quot;length&quot;, length.isAlive() ? length : graph.addOrUniqueWithInputs(length));
 891             assert arrayType.prototypeMarkWord() == lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord() : &quot;all array types are assumed to have the same prototypeMarkWord&quot;;
 892             args.add(&quot;prototypeMarkWord&quot;, arrayType.prototypeMarkWord());
 893             args.addConst(&quot;headerSize&quot;, headerSize);
 894             args.addConst(&quot;log2ElementSize&quot;, log2ElementSize);
 895             args.addConst(&quot;fillContents&quot;, newArrayNode.fillContents());
<span class="line-added"> 896             args.addConst(&quot;emitMemoryBarrier&quot;, newArrayNode.emitMemoryBarrier());</span>
 897             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 898             args.addConst(&quot;maybeUnroll&quot;, length.isConstant());
 899             args.addConst(&quot;typeContext&quot;, ProfileAllocations.getValue(localOptions) ? arrayType.toJavaName(false) : &quot;&quot;);
<span class="line-added"> 900             args.addConst(&quot;supportsBulkZeroing&quot;, tool.getLowerer().supportsBulkZeroing());</span>
 901             args.addConst(&quot;counters&quot;, counters);
 902             SnippetTemplate template = template(newArrayNode, args);
 903             graph.getDebug().log(&quot;Lowering allocateArray in %s: node=%s, template=%s, arguments=%s&quot;, graph, newArrayNode, template, args);
 904             template.instantiate(providers.getMetaAccess(), newArrayNode, DEFAULT_REPLACER, args);
 905         }
 906 
 907         public void lower(DynamicNewInstanceNode newInstanceNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 908             Arguments args = new Arguments(allocateInstanceDynamic, newInstanceNode.graph().getGuardsStage(), tool.getLoweringStage());
 909             args.add(&quot;type&quot;, newInstanceNode.getInstanceType());
 910             ValueNode classClass = newInstanceNode.getClassClass();
 911             assert classClass != null;
 912             args.add(&quot;classClass&quot;, classClass);
 913             args.addConst(&quot;fillContents&quot;, newInstanceNode.fillContents());
<span class="line-added"> 914             args.addConst(&quot;emitMemoryBarrier&quot;, newInstanceNode.emitMemoryBarrier());</span>
 915             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 916             args.addConst(&quot;counters&quot;, counters);
 917 
 918             SnippetTemplate template = template(newInstanceNode, args);
 919             template.instantiate(providers.getMetaAccess(), newInstanceNode, DEFAULT_REPLACER, args);
 920         }
 921 
 922         public void lower(DynamicNewArrayNode newArrayNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 923             StructuredGraph graph = newArrayNode.graph();
<span class="line-modified"> 924             Arguments args = new Arguments(allocateArrayDynamic, graph.getGuardsStage(), tool.getLoweringStage());</span>
 925             args.add(&quot;elementType&quot;, newArrayNode.getElementType());
 926             ValueNode voidClass = newArrayNode.getVoidClass();
 927             assert voidClass != null;
 928             args.add(&quot;voidClass&quot;, voidClass);
 929             ValueNode length = newArrayNode.length();
 930             args.add(&quot;length&quot;, length.isAlive() ? length : graph.addOrUniqueWithInputs(length));
 931             args.addConst(&quot;fillContents&quot;, newArrayNode.fillContents());
<span class="line-added"> 932             args.addConst(&quot;emitMemoryBarrier&quot;, newArrayNode.emitMemoryBarrier());</span>
 933             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 934             /*
 935              * We use Kind.Illegal as a marker value instead of null because constant snippet
 936              * parameters cannot be null.
 937              */
 938             args.addConst(&quot;knownElementKind&quot;, newArrayNode.getKnownElementKind() == null ? JavaKind.Illegal : newArrayNode.getKnownElementKind());
 939             if (newArrayNode.getKnownElementKind() != null) {
 940                 args.addConst(&quot;knownLayoutHelper&quot;, lookupArrayClass(tool, newArrayNode.getKnownElementKind()).layoutHelper());
 941             } else {
 942                 args.addConst(&quot;knownLayoutHelper&quot;, 0);
 943             }
<span class="line-added"> 944             args.addConst(&quot;supportsBulkZeroing&quot;, tool.getLowerer().supportsBulkZeroing());</span>
 945             args.add(&quot;prototypeMarkWord&quot;, lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord());
 946             args.addConst(&quot;counters&quot;, counters);
 947             SnippetTemplate template = template(newArrayNode, args);
 948             template.instantiate(providers.getMetaAccess(), newArrayNode, DEFAULT_REPLACER, args);
 949         }
 950 
 951         private static HotSpotResolvedObjectType lookupArrayClass(LoweringTool tool, JavaKind kind) {
 952             return (HotSpotResolvedObjectType) tool.getMetaAccess().lookupJavaType(kind == JavaKind.Object ? Object.class : kind.toJavaClass()).getArrayClass();
 953         }
 954 
 955         public void lower(NewMultiArrayNode newmultiarrayNode, LoweringTool tool) {
 956             StructuredGraph graph = newmultiarrayNode.graph();
 957             OptionValues localOptions = graph.getOptions();
 958             int rank = newmultiarrayNode.dimensionCount();
 959             ValueNode[] dims = new ValueNode[rank];
 960             for (int i = 0; i &lt; newmultiarrayNode.dimensionCount(); i++) {
 961                 dims[i] = newmultiarrayNode.dimension(i);
 962             }
 963             HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) newmultiarrayNode.type();
 964             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), type.klass(), providers.getMetaAccess(), graph);
</pre>
<hr />
<pre>
 971             template(newmultiarrayNode, args).instantiate(providers.getMetaAccess(), newmultiarrayNode, DEFAULT_REPLACER, args);
 972         }
 973 
 974         private static long instanceSize(HotSpotResolvedObjectType type) {
 975             long size = type.instanceSize();
 976             assert size &gt;= 0;
 977             return size;
 978         }
 979 
 980         public void lower(VerifyHeapNode verifyHeapNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 981             if (config.cAssertions) {
 982                 Arguments args = new Arguments(verifyHeap, verifyHeapNode.graph().getGuardsStage(), tool.getLoweringStage());
 983                 args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 984 
 985                 SnippetTemplate template = template(verifyHeapNode, args);
 986                 template.instantiate(providers.getMetaAccess(), verifyHeapNode, DEFAULT_REPLACER, args);
 987             } else {
 988                 GraphUtil.removeFixedWithUnusedInputs(verifyHeapNode);
 989             }
 990         }
<span class="line-added"> 991 </span>
<span class="line-added"> 992         public void lower(KlassBeingInitializedCheckNode verifyHeapNode, HotSpotRegistersProvider registers, LoweringTool tool) {</span>
<span class="line-added"> 993             Arguments args = new Arguments(threadBeingInitializedCheck, verifyHeapNode.graph().getGuardsStage(), tool.getLoweringStage());</span>
<span class="line-added"> 994             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());</span>
<span class="line-added"> 995             args.add(&quot;klass&quot;, verifyHeapNode.getKlass());</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997             SnippetTemplate template = template(verifyHeapNode, args);</span>
<span class="line-added"> 998             template.instantiate(providers.getMetaAccess(), verifyHeapNode, DEFAULT_REPLACER, args);</span>
<span class="line-added"> 999         }</span>
1000     }
1001 }
</pre>
</td>
</tr>
</table>
<center><a href="MonitorSnippets.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ObjectCloneNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/gc/g1/G1BarrierSet.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2019, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 package org.graalvm.compiler.hotspot.gc.g1;
 27 
 28 import org.graalvm.compiler.debug.GraalError;
 29 import org.graalvm.compiler.hotspot.gc.shared.BarrierSet;
 30 import org.graalvm.compiler.nodes.StructuredGraph;
 31 import org.graalvm.compiler.nodes.ValueNode;
 32 import org.graalvm.compiler.nodes.extended.ArrayRangeWrite;
 33 import org.graalvm.compiler.nodes.java.AbstractCompareAndSwapNode;
 34 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 35 import org.graalvm.compiler.nodes.memory.FixedAccessNode;
 36 import org.graalvm.compiler.nodes.memory.HeapAccess;
 37 import org.graalvm.compiler.nodes.memory.ReadNode;
 38 import org.graalvm.compiler.nodes.memory.WriteNode;
 39 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 40 import org.graalvm.compiler.nodes.type.StampTool;
 41 
 42 public class G1BarrierSet extends BarrierSet {
 43 
 44     @Override
 45     public void addReadNodeBarriers(ReadNode node, StructuredGraph graph) {
 46         if (node.getBarrierType() != HeapAccess.BarrierType.NONE) {
 47             assert (node.getBarrierType() == HeapAccess.BarrierType.PRECISE);
 48             G1ReferentFieldReadBarrier barrier = graph.add(new G1ReferentFieldReadBarrier(node.getAddress(), node, false));
 49             graph.addAfterFixed(node, barrier);
 50         }
 51     }
 52 
 53     @Override
 54     public void addWriteNodeBarriers(WriteNode node, StructuredGraph graph) {
 55         HeapAccess.BarrierType barrierType = node.getBarrierType();
 56         switch (barrierType) {
 57             case NONE:
 58                 // nothing to do
 59                 break;
 60             case IMPRECISE:
 61             case PRECISE:
 62                 boolean precise = barrierType == HeapAccess.BarrierType.PRECISE;
 63                 if (!node.getLocationIdentity().isInit()) {
 64                     // The pre barrier does nothing if the value being read is null, so it can
 65                     // be explicitly skipped when this is an initializing store.
 66                     addG1PreWriteBarrier(node, node.getAddress(), null, true, node.getNullCheck(), graph);
 67                 }
 68                 addG1PostWriteBarrier(node, node.getAddress(), node.value(), precise, graph);
 69                 break;
 70             default:
 71                 throw new GraalError(&quot;unexpected barrier type: &quot; + barrierType);
 72         }
 73     }
 74 
 75     @Override
 76     public void addAtomicReadWriteNodeBarriers(LoweredAtomicReadAndWriteNode node, StructuredGraph graph) {
 77         HeapAccess.BarrierType barrierType = node.getBarrierType();
 78         switch (barrierType) {
 79             case NONE:
 80                 // nothing to do
 81                 break;
 82             case IMPRECISE:
 83             case PRECISE:
 84                 boolean precise = barrierType == HeapAccess.BarrierType.PRECISE;
 85                 addG1PreWriteBarrier(node, node.getAddress(), null, true, node.getNullCheck(), graph);
 86                 addG1PostWriteBarrier(node, node.getAddress(), node.getNewValue(), precise, graph);
 87                 break;
 88             default:
 89                 throw new GraalError(&quot;unexpected barrier type: &quot; + barrierType);
 90         }
 91     }
 92 
 93     @Override
 94     public void addCASBarriers(AbstractCompareAndSwapNode node, StructuredGraph graph) {
 95         HeapAccess.BarrierType barrierType = node.getBarrierType();
 96         switch (barrierType) {
 97             case NONE:
 98                 // nothing to do
 99                 break;
100             case IMPRECISE:
101             case PRECISE:
102                 boolean precise = barrierType == HeapAccess.BarrierType.PRECISE;
103                 addG1PreWriteBarrier(node, node.getAddress(), node.getExpectedValue(), false, false, graph);
104                 addG1PostWriteBarrier(node, node.getAddress(), node.getNewValue(), precise, graph);
105                 break;
106             default:
107                 throw new GraalError(&quot;unexpected barrier type: &quot; + barrierType);
108         }
109     }
110 
111     @Override
112     public void addArrayRangeBarriers(ArrayRangeWrite write, StructuredGraph graph) {
113         if (!write.isInitialization()) {
114             // The pre barrier does nothing if the value being read is null, so it can
115             // be explicitly skipped when this is an initializing store.
116             G1ArrayRangePreWriteBarrier g1ArrayRangePreWriteBarrier = graph.add(new G1ArrayRangePreWriteBarrier(write.getAddress(), write.getLength(), write.getElementStride()));
117             graph.addBeforeFixed(write.asNode(), g1ArrayRangePreWriteBarrier);
118         }
119         G1ArrayRangePostWriteBarrier g1ArrayRangePostWriteBarrier = graph.add(new G1ArrayRangePostWriteBarrier(write.getAddress(), write.getLength(), write.getElementStride()));
120         graph.addAfterFixed(write.asNode(), g1ArrayRangePostWriteBarrier);
121     }
122 
123     private static void addG1PreWriteBarrier(FixedAccessNode node, AddressNode address, ValueNode value, boolean doLoad, boolean nullCheck, StructuredGraph graph) {
124         G1PreWriteBarrier preBarrier = graph.add(new G1PreWriteBarrier(address, value, doLoad, nullCheck));
125         preBarrier.setStateBefore(node.stateBefore());
126         node.setNullCheck(false);
127         node.setStateBefore(null);
128         graph.addBeforeFixed(node, preBarrier);
129     }
130 
131     private static void addG1PostWriteBarrier(FixedAccessNode node, AddressNode address, ValueNode value, boolean precise, StructuredGraph graph) {
132         final boolean alwaysNull = StampTool.isPointerAlwaysNull(value);
133         graph.addAfterFixed(node, graph.add(new G1PostWriteBarrier(address, value, precise, alwaysNull)));
134     }
135 }
    </pre>
  </body>
</html>
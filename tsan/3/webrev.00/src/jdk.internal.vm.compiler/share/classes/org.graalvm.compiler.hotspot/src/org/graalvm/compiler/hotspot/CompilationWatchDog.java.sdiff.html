<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationWatchDog.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilationTask.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilerConfigurationFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationWatchDog.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static org.graalvm.compiler.hotspot.HotSpotGraalCompiler.fmt;
 28 
 29 import java.util.Arrays;
 30 

 31 import org.graalvm.compiler.debug.TTY;
 32 import org.graalvm.compiler.options.Option;
 33 import org.graalvm.compiler.options.OptionKey;
 34 import org.graalvm.compiler.options.OptionType;
 35 import org.graalvm.compiler.options.OptionValues;
 36 
 37 import jdk.vm.ci.meta.ResolvedJavaMethod;

 38 
 39 /**
 40  * A watch dog for reporting long running compilations. This is designed to be an always on
 41  * mechanism for the purpose of getting better reports from customer sites. As such, it only exits
 42  * the VM when it is very sure about a stuck compilation as opposed to only observing a long running
 43  * compilation. In both cases, it logs messages to {@link TTY}.
 44  *
 45  * A watch dog thread is associated with each compiler thread. It wakes up every
 46  * {@value #SPIN_TIMEOUT_MS} milliseconds to observe the state of the compiler thread. After the
 47  * first {@link Options#CompilationWatchDogStartDelay} seconds of a specific compilation, the watch
 48  * dog reports a long running compilation. Every
 49  * {@link Options#CompilationWatchDogStackTraceInterval} seconds after that point in time where the
 50  * same compilation is still executing, the watch dog takes a stack trace of the compiler thread. If
<span class="line-modified"> 51  * more than {@value Options#NonFatalIdenticalCompilationSnapshots} contiguous identical stack</span>
<span class="line-modified"> 52  * traces are seen, the watch dog reports a stuck compilation and exits the VM.</span>
 53  */
<span class="line-modified"> 54 class CompilationWatchDog extends Thread implements AutoCloseable {</span>
 55 
 56     public static class Options {
 57         // @formatter:off
 58         @Option(help = &quot;Delay in seconds before watch dog monitoring a compilation (0 disables monitoring).&quot;, type = OptionType.Debug)
 59         public static final OptionKey&lt;Double&gt; CompilationWatchDogStartDelay = new OptionKey&lt;&gt;(0.0D);
 60         @Option(help = &quot;Interval in seconds between a watch dog reporting stack traces for long running compilations.&quot;, type = OptionType.Debug)
 61         public static final OptionKey&lt;Double&gt; CompilationWatchDogStackTraceInterval = new OptionKey&lt;&gt;(60.0D);
 62         @Option(help = &quot;Number of contiguous identical compiler thread stack traces allowed before the VM exits &quot; +
 63                        &quot;on the basis of a stuck compilation.&quot;, type = OptionType.Debug)
 64         public static final OptionKey&lt;Integer&gt; NonFatalIdenticalCompilationSnapshots = new OptionKey&lt;&gt;(20);
 65         // @formatter:on
 66     }
 67 
 68     private enum WatchDogState {
 69         /**
 70          * The watch dog thread sleeps currently, either no method is currently compiled, or no
 71          * method is compiled long enough to be monitored.
 72          */
 73         SLEEPING,
 74         /**
</pre>
<hr />
<pre>
 94      */
 95     private static final int SPIN_TIMEOUT_MS = 1000;
 96 
 97     private WatchDogState state = WatchDogState.SLEEPING;
 98     private final Thread compilerThread;
 99     private final long startDelayMilliseconds;
100     private final long stackTraceIntervalMilliseconds;
101     private final int nonFatalIdenticalCompilationSnapshots;
102     private volatile ResolvedJavaMethod currentMethod;
103     private volatile int currentId;
104     private ResolvedJavaMethod lastWatched;
105 
106     // The 4 fields below are for a single compilation being watched
107     private long elapsed;
108     private int traceIntervals;
109     private int numberOfIdenticalStackTraces;
110     private StackTraceElement[] lastStackTrace;
111 
112     CompilationWatchDog(Thread compilerThread, long startDelayMilliseconds, long stackTraceIntervalMilliseconds, int nonFatalIdenticalCompilationSnapshots) {
113         this.compilerThread = compilerThread;
<span class="line-removed">114         this.setName(&quot;WatchDog&quot; + getId() + &quot;[&quot; + compilerThread.getName() + &quot;]&quot;);</span>
<span class="line-removed">115         this.setPriority(Thread.MAX_PRIORITY);</span>
<span class="line-removed">116         this.setDaemon(true);</span>
117         this.startDelayMilliseconds = startDelayMilliseconds;
118         this.stackTraceIntervalMilliseconds = stackTraceIntervalMilliseconds;
119         this.nonFatalIdenticalCompilationSnapshots = nonFatalIdenticalCompilationSnapshots;
120     }
121 
122     public void startCompilation(ResolvedJavaMethod method, int id) {
123         trace(&quot;start %s&quot;, fmt(method));
124         this.currentMethod = method;
125         this.currentId = id;
126     }
127 
128     public void stopCompilation() {
129         trace(&quot; stop %s&quot;, fmt(currentMethod));
130         this.currentMethod = null;
131     }
132 
133     private void reset() {
134         elapsed = 0;
135         traceIntervals = 0;
136         numberOfIdenticalStackTraces = 0;
</pre>
<hr />
<pre>
149      *
150      * @param newStackTrace the current stack trace of the monitored compiler thread
151      * @return {@code true} if the stack trace is equal to the last stack trace (or if it is the
152      *         first one) and {@code false} if it is not equal to the last one.
153      */
154     private boolean recordStackTrace(StackTraceElement[] newStackTrace) {
155         if (lastStackTrace == null) {
156             lastStackTrace = newStackTrace;
157             return true;
158         }
159         if (!Arrays.equals(lastStackTrace, newStackTrace)) {
160             lastStackTrace = newStackTrace;
161             return false;
162         }
163         return true;
164     }
165 
166     /**
167      * Set to true to debug the watch dog.
168      */
<span class="line-modified">169     private static final boolean DEBUG = Boolean.getBoolean(&quot;debug.graal.CompilationWatchDog&quot;);</span>
170 
171     private void trace(String format, Object... args) {
172         if (DEBUG) {
173             TTY.println(this + &quot;: &quot; + String.format(format, args));
174         }
175     }
176 
177     private static long ms(double seconds) {
178         return (long) seconds * 1000;
179     }
180 
181     private static double secs(long ms) {
182         return (double) ms / 1000;
183     }
184 
185     @Override
186     public String toString() {
<span class="line-modified">187         return getName();</span>
188     }
189 
190     @Override
191     public void run() {
192         try {
193             trace(&quot;Started%n&quot;, this);
194             while (true) {
195                 // get a copy of the last set method
196                 final ResolvedJavaMethod currentlyCompiling = currentMethod;
197                 if (currentlyCompiling == null) {
198                     // continue sleeping, compilation is either over before starting
199                     // to watch the compiler thread or no compilation at all started
200                     reset();
201                 } else {
202                     switch (state) {
203                         case SLEEPING:
204                             lastWatched = currentlyCompiling;
205                             elapsed = 0;
206                             tick(WatchDogState.WATCHING_WITHOUT_STACK_INSPECTION);
207                             break;
</pre>
<hr />
<pre>
222                                 // compilation finished before we exceeded initial watching
223                                 // period
224                                 reset();
225                             }
226                             break;
227                         case WATCHING_WITH_STACK_INSPECTION:
228                             if (currentlyCompiling.equals(lastWatched)) {
229                                 if (elapsed &gt;= startDelayMilliseconds + (traceIntervals * stackTraceIntervalMilliseconds)) {
230                                     trace(&quot;took a stack trace&quot;);
231                                     boolean newStackTrace = recordStackTrace(compilerThread.getStackTrace());
232                                     if (!newStackTrace) {
233                                         trace(&quot;%d identical stack traces in a row&quot;, numberOfIdenticalStackTraces);
234                                         numberOfIdenticalStackTraces = 0;
235                                     }
236                                     numberOfIdenticalStackTraces++;
237                                     if (numberOfIdenticalStackTraces &gt; nonFatalIdenticalCompilationSnapshots) {
238                                         synchronized (CompilationWatchDog.class) {
239                                             TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
240                                                             &quot;%s took %d identical stack traces, which indicates a stuck compilation (id=%d) of %s%n%sExiting VM%n&quot;, this,
241                                                             numberOfIdenticalStackTraces, currentId, fmt(currentMethod), fmt(lastStackTrace));
<span class="line-modified">242                                             System.exit(-1);</span>
243                                         }
244                                     } else if (newStackTrace) {
245                                         synchronized (CompilationWatchDog.class) {
246                                             TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
247                                                             &quot;%s detected long running compilation (id=%d) of %s [%.2f seconds]%n%s&quot;, this, currentId, fmt(currentMethod),
248                                                             secs(elapsed), fmt(lastStackTrace));
249                                         }
250                                     }
251                                     traceIntervals++;
252                                 } else {
253                                     // we still watch the compilation in the same trace interval
254                                     trace(&quot;watching with stack traces [%.2f seconds]&quot;, secs(elapsed));
255                                 }
256                                 elapsed += SPIN_TIMEOUT_MS;
257                             } else {
258                                 // compilation finished before we are able to collect stack
259                                 // traces
260                                 reset();
261                             }
262                             break;
</pre>
<hr />
<pre>
287     }
288 
289     private static final ThreadLocal&lt;CompilationWatchDog&gt; WATCH_DOGS = new ThreadLocal&lt;&gt;();
290 
291     /**
292      * Opens a scope for watching the compilation of a given method.
293      *
294      * @param method a method about to be compiled
295      * @param id compilation request identifier
296      * @return {@code null} if the compilation watch dog is disabled otherwise this object. The
297      *         returned value should be used in a {@code try}-with-resources statement whose scope
298      *         is the whole compilation so that leaving the scope will cause {@link #close()} to be
299      *         called.
300      */
301     static CompilationWatchDog watch(ResolvedJavaMethod method, int id, OptionValues options) {
302         long startDelayMilliseconds = ms(Options.CompilationWatchDogStartDelay.getValue(options));
303         if (startDelayMilliseconds &gt; 0.0D) {
304             // Lazily get a watch dog thread for the current compiler thread
305             CompilationWatchDog watchDog = WATCH_DOGS.get();
306             if (watchDog == null) {
<span class="line-modified">307                 Thread currentThread = currentThread();</span>
308                 long stackTraceIntervalMilliseconds = ms(Options.CompilationWatchDogStackTraceInterval.getValue(options));
309                 int nonFatalIdenticalCompilationSnapshots = Options.NonFatalIdenticalCompilationSnapshots.getValue(options);
310                 watchDog = new CompilationWatchDog(currentThread, startDelayMilliseconds, stackTraceIntervalMilliseconds, nonFatalIdenticalCompilationSnapshots);
311                 WATCH_DOGS.set(watchDog);
<span class="line-modified">312                 watchDog.start();</span>




313             }
314             watchDog.startCompilation(method, id);
315             return watchDog;
316         }
317         return null;
318     }
319 
320     @Override
321     public void close() {
322         stopCompilation();
323     }
324 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static org.graalvm.compiler.hotspot.HotSpotGraalCompiler.fmt;
 28 
 29 import java.util.Arrays;
 30 
<span class="line-added"> 31 import org.graalvm.compiler.core.GraalServiceThread;</span>
 32 import org.graalvm.compiler.debug.TTY;
 33 import org.graalvm.compiler.options.Option;
 34 import org.graalvm.compiler.options.OptionKey;
 35 import org.graalvm.compiler.options.OptionType;
 36 import org.graalvm.compiler.options.OptionValues;
 37 
 38 import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-added"> 39 import jdk.vm.ci.services.Services;</span>
 40 
 41 /**
 42  * A watch dog for reporting long running compilations. This is designed to be an always on
 43  * mechanism for the purpose of getting better reports from customer sites. As such, it only exits
 44  * the VM when it is very sure about a stuck compilation as opposed to only observing a long running
 45  * compilation. In both cases, it logs messages to {@link TTY}.
 46  *
 47  * A watch dog thread is associated with each compiler thread. It wakes up every
 48  * {@value #SPIN_TIMEOUT_MS} milliseconds to observe the state of the compiler thread. After the
 49  * first {@link Options#CompilationWatchDogStartDelay} seconds of a specific compilation, the watch
 50  * dog reports a long running compilation. Every
 51  * {@link Options#CompilationWatchDogStackTraceInterval} seconds after that point in time where the
 52  * same compilation is still executing, the watch dog takes a stack trace of the compiler thread. If
<span class="line-modified"> 53  * more than {@link Options#NonFatalIdenticalCompilationSnapshots} contiguous identical stack traces</span>
<span class="line-modified"> 54  * are seen, the watch dog reports a stuck compilation and exits the VM.</span>
 55  */
<span class="line-modified"> 56 class CompilationWatchDog implements Runnable, AutoCloseable {</span>
 57 
 58     public static class Options {
 59         // @formatter:off
 60         @Option(help = &quot;Delay in seconds before watch dog monitoring a compilation (0 disables monitoring).&quot;, type = OptionType.Debug)
 61         public static final OptionKey&lt;Double&gt; CompilationWatchDogStartDelay = new OptionKey&lt;&gt;(0.0D);
 62         @Option(help = &quot;Interval in seconds between a watch dog reporting stack traces for long running compilations.&quot;, type = OptionType.Debug)
 63         public static final OptionKey&lt;Double&gt; CompilationWatchDogStackTraceInterval = new OptionKey&lt;&gt;(60.0D);
 64         @Option(help = &quot;Number of contiguous identical compiler thread stack traces allowed before the VM exits &quot; +
 65                        &quot;on the basis of a stuck compilation.&quot;, type = OptionType.Debug)
 66         public static final OptionKey&lt;Integer&gt; NonFatalIdenticalCompilationSnapshots = new OptionKey&lt;&gt;(20);
 67         // @formatter:on
 68     }
 69 
 70     private enum WatchDogState {
 71         /**
 72          * The watch dog thread sleeps currently, either no method is currently compiled, or no
 73          * method is compiled long enough to be monitored.
 74          */
 75         SLEEPING,
 76         /**
</pre>
<hr />
<pre>
 96      */
 97     private static final int SPIN_TIMEOUT_MS = 1000;
 98 
 99     private WatchDogState state = WatchDogState.SLEEPING;
100     private final Thread compilerThread;
101     private final long startDelayMilliseconds;
102     private final long stackTraceIntervalMilliseconds;
103     private final int nonFatalIdenticalCompilationSnapshots;
104     private volatile ResolvedJavaMethod currentMethod;
105     private volatile int currentId;
106     private ResolvedJavaMethod lastWatched;
107 
108     // The 4 fields below are for a single compilation being watched
109     private long elapsed;
110     private int traceIntervals;
111     private int numberOfIdenticalStackTraces;
112     private StackTraceElement[] lastStackTrace;
113 
114     CompilationWatchDog(Thread compilerThread, long startDelayMilliseconds, long stackTraceIntervalMilliseconds, int nonFatalIdenticalCompilationSnapshots) {
115         this.compilerThread = compilerThread;



116         this.startDelayMilliseconds = startDelayMilliseconds;
117         this.stackTraceIntervalMilliseconds = stackTraceIntervalMilliseconds;
118         this.nonFatalIdenticalCompilationSnapshots = nonFatalIdenticalCompilationSnapshots;
119     }
120 
121     public void startCompilation(ResolvedJavaMethod method, int id) {
122         trace(&quot;start %s&quot;, fmt(method));
123         this.currentMethod = method;
124         this.currentId = id;
125     }
126 
127     public void stopCompilation() {
128         trace(&quot; stop %s&quot;, fmt(currentMethod));
129         this.currentMethod = null;
130     }
131 
132     private void reset() {
133         elapsed = 0;
134         traceIntervals = 0;
135         numberOfIdenticalStackTraces = 0;
</pre>
<hr />
<pre>
148      *
149      * @param newStackTrace the current stack trace of the monitored compiler thread
150      * @return {@code true} if the stack trace is equal to the last stack trace (or if it is the
151      *         first one) and {@code false} if it is not equal to the last one.
152      */
153     private boolean recordStackTrace(StackTraceElement[] newStackTrace) {
154         if (lastStackTrace == null) {
155             lastStackTrace = newStackTrace;
156             return true;
157         }
158         if (!Arrays.equals(lastStackTrace, newStackTrace)) {
159             lastStackTrace = newStackTrace;
160             return false;
161         }
162         return true;
163     }
164 
165     /**
166      * Set to true to debug the watch dog.
167      */
<span class="line-modified">168     private static final boolean DEBUG = Boolean.parseBoolean(Services.getSavedProperties().get(&quot;debug.graal.CompilationWatchDog&quot;));</span>
169 
170     private void trace(String format, Object... args) {
171         if (DEBUG) {
172             TTY.println(this + &quot;: &quot; + String.format(format, args));
173         }
174     }
175 
176     private static long ms(double seconds) {
177         return (long) seconds * 1000;
178     }
179 
180     private static double secs(long ms) {
181         return (double) ms / 1000;
182     }
183 
184     @Override
185     public String toString() {
<span class="line-modified">186         return &quot;WatchDog[&quot; + compilerThread.getName() + &quot;]&quot;;</span>
187     }
188 
189     @Override
190     public void run() {
191         try {
192             trace(&quot;Started%n&quot;, this);
193             while (true) {
194                 // get a copy of the last set method
195                 final ResolvedJavaMethod currentlyCompiling = currentMethod;
196                 if (currentlyCompiling == null) {
197                     // continue sleeping, compilation is either over before starting
198                     // to watch the compiler thread or no compilation at all started
199                     reset();
200                 } else {
201                     switch (state) {
202                         case SLEEPING:
203                             lastWatched = currentlyCompiling;
204                             elapsed = 0;
205                             tick(WatchDogState.WATCHING_WITHOUT_STACK_INSPECTION);
206                             break;
</pre>
<hr />
<pre>
221                                 // compilation finished before we exceeded initial watching
222                                 // period
223                                 reset();
224                             }
225                             break;
226                         case WATCHING_WITH_STACK_INSPECTION:
227                             if (currentlyCompiling.equals(lastWatched)) {
228                                 if (elapsed &gt;= startDelayMilliseconds + (traceIntervals * stackTraceIntervalMilliseconds)) {
229                                     trace(&quot;took a stack trace&quot;);
230                                     boolean newStackTrace = recordStackTrace(compilerThread.getStackTrace());
231                                     if (!newStackTrace) {
232                                         trace(&quot;%d identical stack traces in a row&quot;, numberOfIdenticalStackTraces);
233                                         numberOfIdenticalStackTraces = 0;
234                                     }
235                                     numberOfIdenticalStackTraces++;
236                                     if (numberOfIdenticalStackTraces &gt; nonFatalIdenticalCompilationSnapshots) {
237                                         synchronized (CompilationWatchDog.class) {
238                                             TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
239                                                             &quot;%s took %d identical stack traces, which indicates a stuck compilation (id=%d) of %s%n%sExiting VM%n&quot;, this,
240                                                             numberOfIdenticalStackTraces, currentId, fmt(currentMethod), fmt(lastStackTrace));
<span class="line-modified">241                                             HotSpotGraalServices.exit(-1);</span>
242                                         }
243                                     } else if (newStackTrace) {
244                                         synchronized (CompilationWatchDog.class) {
245                                             TTY.printf(&quot;======================= WATCH DOG THREAD =======================%n&quot; +
246                                                             &quot;%s detected long running compilation (id=%d) of %s [%.2f seconds]%n%s&quot;, this, currentId, fmt(currentMethod),
247                                                             secs(elapsed), fmt(lastStackTrace));
248                                         }
249                                     }
250                                     traceIntervals++;
251                                 } else {
252                                     // we still watch the compilation in the same trace interval
253                                     trace(&quot;watching with stack traces [%.2f seconds]&quot;, secs(elapsed));
254                                 }
255                                 elapsed += SPIN_TIMEOUT_MS;
256                             } else {
257                                 // compilation finished before we are able to collect stack
258                                 // traces
259                                 reset();
260                             }
261                             break;
</pre>
<hr />
<pre>
286     }
287 
288     private static final ThreadLocal&lt;CompilationWatchDog&gt; WATCH_DOGS = new ThreadLocal&lt;&gt;();
289 
290     /**
291      * Opens a scope for watching the compilation of a given method.
292      *
293      * @param method a method about to be compiled
294      * @param id compilation request identifier
295      * @return {@code null} if the compilation watch dog is disabled otherwise this object. The
296      *         returned value should be used in a {@code try}-with-resources statement whose scope
297      *         is the whole compilation so that leaving the scope will cause {@link #close()} to be
298      *         called.
299      */
300     static CompilationWatchDog watch(ResolvedJavaMethod method, int id, OptionValues options) {
301         long startDelayMilliseconds = ms(Options.CompilationWatchDogStartDelay.getValue(options));
302         if (startDelayMilliseconds &gt; 0.0D) {
303             // Lazily get a watch dog thread for the current compiler thread
304             CompilationWatchDog watchDog = WATCH_DOGS.get();
305             if (watchDog == null) {
<span class="line-modified">306                 Thread currentThread = Thread.currentThread();</span>
307                 long stackTraceIntervalMilliseconds = ms(Options.CompilationWatchDogStackTraceInterval.getValue(options));
308                 int nonFatalIdenticalCompilationSnapshots = Options.NonFatalIdenticalCompilationSnapshots.getValue(options);
309                 watchDog = new CompilationWatchDog(currentThread, startDelayMilliseconds, stackTraceIntervalMilliseconds, nonFatalIdenticalCompilationSnapshots);
310                 WATCH_DOGS.set(watchDog);
<span class="line-modified">311                 GraalServiceThread thread = new GraalServiceThread(watchDog);</span>
<span class="line-added">312                 thread.setName(thread.getId() + &quot; &quot; + watchDog.toString());</span>
<span class="line-added">313                 thread.setPriority(Thread.MAX_PRIORITY);</span>
<span class="line-added">314                 thread.setDaemon(true);</span>
<span class="line-added">315                 thread.start();</span>
316             }
317             watchDog.startCompilation(method, id);
318             return watchDog;
319         }
320         return null;
321     }
322 
323     @Override
324     public void close() {
325         stopCompilation();
326     }
327 }
</pre>
</td>
</tr>
</table>
<center><a href="CompilationTask.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilerConfigurationFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
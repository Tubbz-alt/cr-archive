<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static jdk.vm.ci.common.InitTimer.timer;
 28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
 29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 30 import static org.graalvm.compiler.core.common.GraalOptions.HotSpotPrintInlining;
 31 
 32 import java.io.PrintStream;
 33 import java.util.ArrayList;
 34 import java.util.EnumMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.concurrent.atomic.AtomicReference;
 38 import java.util.function.Supplier;
 39 
 40 import jdk.internal.vm.compiler.collections.EconomicMap;
 41 import jdk.internal.vm.compiler.collections.EconomicSet;
 42 import jdk.internal.vm.compiler.collections.Equivalence;
 43 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
 44 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 45 import org.graalvm.compiler.api.runtime.GraalRuntime;
 46 import org.graalvm.compiler.core.CompilationWrapper.ExceptionAction;
 47 import org.graalvm.compiler.core.common.CompilationIdentifier;
 48 import org.graalvm.compiler.core.common.GraalOptions;
 49 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 50 import org.graalvm.compiler.core.target.Backend;
 51 import org.graalvm.compiler.debug.DebugContext;
 52 import org.graalvm.compiler.debug.DebugContext.Description;
 53 import org.graalvm.compiler.debug.DebugHandlersFactory;
 54 import org.graalvm.compiler.debug.DebugOptions;
 55 import org.graalvm.compiler.debug.DiagnosticsOutputDirectory;
 56 import org.graalvm.compiler.debug.GlobalMetrics;
 57 import org.graalvm.compiler.debug.GraalError;
 58 import org.graalvm.compiler.debug.TTY;
 59 import org.graalvm.compiler.hotspot.CompilationStatistics.Options;
 60 import org.graalvm.compiler.hotspot.CompilerConfigurationFactory.BackendMap;
 61 import org.graalvm.compiler.hotspot.debug.BenchmarkCounters;
 62 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 63 import org.graalvm.compiler.nodes.spi.StampProvider;
 64 import org.graalvm.compiler.options.EnumOptionKey;
 65 import org.graalvm.compiler.options.OptionDescriptor;
 66 import org.graalvm.compiler.options.OptionDescriptors;
 67 import org.graalvm.compiler.options.OptionKey;
 68 import org.graalvm.compiler.options.OptionValues;
 69 import org.graalvm.compiler.options.OptionsParser;
 70 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
 71 import org.graalvm.compiler.replacements.SnippetCounter;
 72 import org.graalvm.compiler.replacements.SnippetCounter.Group;
 73 import org.graalvm.compiler.runtime.RuntimeProvider;
 74 import org.graalvm.compiler.serviceprovider.GraalServices;
 75 
 76 import jdk.vm.ci.code.Architecture;
 77 import jdk.vm.ci.code.stack.StackIntrospection;
 78 import jdk.vm.ci.common.InitTimer;
 79 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 80 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 81 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 82 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
 83 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 84 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
 85 import jdk.vm.ci.meta.JavaKind;
 86 import jdk.vm.ci.meta.MetaAccessProvider;
 87 import jdk.vm.ci.meta.ResolvedJavaMethod;
 88 import jdk.vm.ci.meta.ResolvedJavaType;
 89 import jdk.vm.ci.runtime.JVMCI;
 90 import jdk.vm.ci.runtime.JVMCIBackend;
 91 import jdk.vm.ci.services.Services;
 92 
 93 //JaCoCo Exclude
 94 
 95 /**
 96  * Singleton class holding the instance of the {@link GraalRuntime}.
 97  */
 98 public final class HotSpotGraalRuntime implements HotSpotGraalRuntimeProvider {
 99 
100     private static final boolean IS_AOT = Boolean.parseBoolean(Services.getSavedProperties().get(&quot;com.oracle.graalvm.isaot&quot;));
101     /**
102      * A factory for {@link HotSpotGraalManagementRegistration} injected by {@code LibGraalFeature}.
103      */
104     private static final Supplier&lt;HotSpotGraalManagementRegistration&gt; AOT_INJECTED_MANAGEMENT = null;
105 
106     private static boolean checkArrayIndexScaleInvariants(MetaAccessProvider metaAccess) {
107         assert metaAccess.getArrayIndexScale(JavaKind.Byte) == 1;
108         assert metaAccess.getArrayIndexScale(JavaKind.Boolean) == 1;
109         assert metaAccess.getArrayIndexScale(JavaKind.Char) == 2;
110         assert metaAccess.getArrayIndexScale(JavaKind.Short) == 2;
111         assert metaAccess.getArrayIndexScale(JavaKind.Int) == 4;
112         assert metaAccess.getArrayIndexScale(JavaKind.Long) == 8;
113         assert metaAccess.getArrayIndexScale(JavaKind.Float) == 4;
114         assert metaAccess.getArrayIndexScale(JavaKind.Double) == 8;
115         return true;
116     }
117 
118     private final String runtimeName;
119     private final String compilerConfigurationName;
120     private final HotSpotBackend hostBackend;
121 
122     public GlobalMetrics getMetricValues() {
123         return metricValues;
124     }
125 
126     private final GlobalMetrics metricValues = new GlobalMetrics();
127     private final List&lt;SnippetCounter.Group&gt; snippetCounterGroups;
128     private final HotSpotGC garbageCollector;
129 
130     private final EconomicMap&lt;Class&lt;? extends Architecture&gt;, HotSpotBackend&gt; backends = EconomicMap.create(Equivalence.IDENTITY);
131 
132     private final GraalHotSpotVMConfig config;
133 
134     /**
135      * The options can be {@linkplain #setOptionValues(String[], String[]) updated} by external
136      * interfaces such as JMX. This comes with the risk that inconsistencies can arise as an
137      * {@link OptionValues} object can be cached by various parts of Graal instead of always
138      * obtaining them from this object. However, concurrent updates are never lost.
139      */
140     private AtomicReference&lt;OptionValues&gt; optionsRef = new AtomicReference&lt;&gt;();
141 
142     private final DiagnosticsOutputDirectory outputDirectory;
143     private final Map&lt;ExceptionAction, Integer&gt; compilationProblemsPerAction;
144 
145     /**
146      * @param nameQualifier a qualifier to be added to this runtime&#39;s {@linkplain #getName() name}
147      * @param compilerConfigurationFactory factory for the compiler configuration
148      *            {@link CompilerConfigurationFactory#selectFactory(String, OptionValues)}
149      */
150     @SuppressWarnings(&quot;try&quot;)
151     HotSpotGraalRuntime(String nameQualifier, HotSpotJVMCIRuntime jvmciRuntime, CompilerConfigurationFactory compilerConfigurationFactory, OptionValues initialOptions) {
152         this.runtimeName = getClass().getSimpleName() + &quot;:&quot; + nameQualifier;
153         HotSpotVMConfigStore store = jvmciRuntime.getConfigStore();
154         config = GeneratePIC.getValue(initialOptions) ? new AOTGraalHotSpotVMConfig(store) : new GraalHotSpotVMConfig(store);
155 
156         // Only set HotSpotPrintInlining if it still has its default value (false).
157         if (GraalOptions.HotSpotPrintInlining.getValue(initialOptions) == false &amp;&amp; config.printInlining) {
158             optionsRef.set(new OptionValues(initialOptions, HotSpotPrintInlining, true));
159         } else {
160             optionsRef.set(initialOptions);
161         }
162         OptionValues options = optionsRef.get();
163 
164         garbageCollector = getSelectedGC();
165 
166         outputDirectory = new DiagnosticsOutputDirectory(options);
167         compilationProblemsPerAction = new EnumMap&lt;&gt;(ExceptionAction.class);
168         snippetCounterGroups = GraalOptions.SnippetCounters.getValue(options) ? new ArrayList&lt;&gt;() : null;
169         CompilerConfiguration compilerConfiguration = compilerConfigurationFactory.createCompilerConfiguration();
170         compilerConfigurationName = compilerConfigurationFactory.getName();
171 
172         if (IS_AOT) {
173             management = AOT_INJECTED_MANAGEMENT == null ? null : AOT_INJECTED_MANAGEMENT.get();
174         } else {
175             management = GraalServices.loadSingle(HotSpotGraalManagementRegistration.class, false);
176         }
177         if (management != null) {
178             management.initialize(this, config);
179         }
180 
181         BackendMap backendMap = compilerConfigurationFactory.createBackendMap();
182 
183         JVMCIBackend hostJvmciBackend = jvmciRuntime.getHostJVMCIBackend();
184         Architecture hostArchitecture = hostJvmciBackend.getTarget().arch;
185         try (InitTimer t = timer(&quot;create backend:&quot;, hostArchitecture)) {
186             HotSpotBackendFactory factory = backendMap.getBackendFactory(hostArchitecture);
187             if (factory == null) {
188                 throw new GraalError(&quot;No backend available for host architecture \&quot;%s\&quot;&quot;, hostArchitecture);
189             }
190             hostBackend = registerBackend(factory.createBackend(this, compilerConfiguration, jvmciRuntime, null));
191         }
192 
193         for (JVMCIBackend jvmciBackend : jvmciRuntime.getJVMCIBackends().values()) {
194             if (jvmciBackend == hostJvmciBackend) {
195                 continue;
196             }
197 
198             Architecture gpuArchitecture = jvmciBackend.getTarget().arch;
199             HotSpotBackendFactory factory = backendMap.getBackendFactory(gpuArchitecture);
200             if (factory == null) {
201                 throw new GraalError(&quot;No backend available for specified GPU architecture \&quot;%s\&quot;&quot;, gpuArchitecture);
202             }
203             try (InitTimer t = timer(&quot;create backend:&quot;, gpuArchitecture)) {
204                 registerBackend(factory.createBackend(this, compilerConfiguration, null, hostBackend));
205             }
206         }
207 
208         // Complete initialization of backends
209         try (InitTimer st = timer(hostBackend.getTarget().arch.getName(), &quot;.completeInitialization&quot;)) {
210             hostBackend.completeInitialization(jvmciRuntime, options);
211         }
212         for (HotSpotBackend backend : backends.getValues()) {
213             if (backend != hostBackend) {
214                 try (InitTimer st = timer(backend.getTarget().arch.getName(), &quot;.completeInitialization&quot;)) {
215                     backend.completeInitialization(jvmciRuntime, options);
216                 }
217             }
218         }
219 
220         BenchmarkCounters.initialize(jvmciRuntime, options);
221 
222         assert checkArrayIndexScaleInvariants(hostJvmciBackend.getMetaAccess());
223 
224         runtimeStartTime = System.nanoTime();
225         bootstrapJVMCI = config.getFlag(&quot;BootstrapJVMCI&quot;, Boolean.class);
226     }
227 
228     /**
229      * Constants denoting the GC algorithms available in HotSpot.
230      */
231     public enum HotSpotGC {
232         // Supported GCs
233         Serial(true, &quot;UseSerialGC&quot;),
234         Parallel(true, &quot;UseParallelGC&quot;, &quot;UseParallelOldGC&quot;, &quot;UseParNewGC&quot;),
235         CMS(true, &quot;UseConcMarkSweepGC&quot;),
236         G1(true, &quot;UseG1GC&quot;),
237 
238         // Unsupported GCs
239         Epsilon(false, &quot;UseEpsilonGC&quot;),
240         Z(false, &quot;UseZGC&quot;);
241 
242         HotSpotGC(boolean supported, String... flags) {
243             this.supported = supported;
244             this.flags = flags;
245         }
246 
247         final boolean supported;
248         private final String[] flags;
249 
250         public boolean isSelected(GraalHotSpotVMConfig config) {
251             for (String flag : flags) {
252                 final boolean notPresent = false;
253                 if (config.getFlag(flag, Boolean.class, notPresent)) {
254                     return true;
255                 }
256             }
257             return false;
258         }
259 
260     }
261 
262     private HotSpotGC getSelectedGC() throws GraalError {
263         for (HotSpotGC gc : HotSpotGC.values()) {
264             if (gc.isSelected(config)) {
265                 if (!gc.supported) {
266                     throw new GraalError(gc.name() + &quot; garbage collector is not supported by Graal&quot;);
267                 }
268                 return gc;
269             }
270         }
271         // As of JDK 9, exactly one GC flag is guaranteed to be selected.
272         // On JDK 8, the default GC is Serial when no GC flag is true.
273         return HotSpotGC.Serial;
274     }
275 
276     private HotSpotBackend registerBackend(HotSpotBackend backend) {
277         Class&lt;? extends Architecture&gt; arch = backend.getTarget().arch.getClass();
278         HotSpotBackend oldValue = backends.put(arch, backend);
279         assert oldValue == null : &quot;cannot overwrite existing backend for architecture &quot; + arch.getSimpleName();
280         return backend;
281     }
282 
283     @Override
284     public HotSpotProviders getHostProviders() {
285         return getHostBackend().getProviders();
286     }
287 
288     @Override
289     public GraalHotSpotVMConfig getVMConfig() {
290         return config;
291     }
292 
293     @Override
294     public DebugContext openDebugContext(OptionValues compilationOptions, CompilationIdentifier compilationId, Object compilable, Iterable&lt;DebugHandlersFactory&gt; factories, PrintStream logStream) {
295         if (management != null &amp;&amp; management.poll(false) != null) {
296             if (compilable instanceof HotSpotResolvedJavaMethod) {
297                 HotSpotResolvedObjectType type = ((HotSpotResolvedJavaMethod) compilable).getDeclaringClass();
298                 if (type instanceof HotSpotResolvedJavaType) {
299                     Class&lt;?&gt; clazz = runtime().getMirror(type);
300                     if (clazz != null) {
301                         try {
302                             ClassLoader cl = clazz.getClassLoader();
303                             if (cl != null) {
304                                 loaders.add(cl);
305                             }
306                         } catch (SecurityException e) {
307                             // This loader can obviously not be used for resolving class names
308                         }
309                     }
310                 }
311             }
312         }
313         Description description = new Description(compilable, compilationId.toString(CompilationIdentifier.Verbosity.ID));
314         return DebugContext.create(compilationOptions, description, metricValues, logStream, factories);
315     }
316 
317     @Override
318     public OptionValues getOptions() {
319         return optionsRef.get();
320     }
321 
322     @Override
323     public Group createSnippetCounterGroup(String groupName) {
324         if (snippetCounterGroups != null) {
325             Group group = new Group(groupName);
326             snippetCounterGroups.add(group);
327             return group;
328         }
329         return null;
330     }
331 
332     @Override
333     public String getName() {
334         return runtimeName;
335     }
336 
337     @SuppressWarnings(&quot;unchecked&quot;)
338     @Override
339     public &lt;T&gt; T getCapability(Class&lt;T&gt; clazz) {
340         if (clazz == RuntimeProvider.class) {
341             return (T) this;
342         } else if (clazz == OptionValues.class) {
343             return (T) optionsRef.get();
344         } else if (clazz == StackIntrospection.class) {
345             return (T) this;
346         } else if (clazz == SnippetReflectionProvider.class) {
347             return (T) getHostProviders().getSnippetReflection();
348         } else if (clazz == GraalHotSpotVMConfig.class) {
349             return (T) getVMConfig();
350         } else if (clazz == StampProvider.class) {
351             return (T) getHostProviders().getStampProvider();
352         } else if (ForeignCallsProvider.class.isAssignableFrom(clazz)) {
353             return (T) getHostProviders().getForeignCalls();
354         }
355         return null;
356     }
357 
358     @Override
359     public HotSpotGC getGarbageCollector() {
360         return garbageCollector;
361     }
362 
363     @Override
364     public HotSpotBackend getHostBackend() {
365         return hostBackend;
366     }
367 
368     @Override
369     public &lt;T extends Architecture&gt; Backend getBackend(Class&lt;T&gt; arch) {
370         assert arch != Architecture.class;
371         return backends.get(arch);
372     }
373 
374     @Override
375     public String getCompilerConfigurationName() {
376         return compilerConfigurationName;
377     }
378 
379     private long runtimeStartTime;
380 
381     /**
382      * Called from compiler threads to check whether to bail out of a compilation.
383      */
384     private volatile boolean shutdown;
385 
386     /**
387      * Take action related to entering a new execution phase.
388      *
389      * @param phase the execution phase being entered
390      */
391     void phaseTransition(String phase) {
392         if (Options.UseCompilationStatistics.getValue(optionsRef.get())) {
393             CompilationStatistics.clear(phase);
394         }
395     }
396 
397     void shutdown() {
398         shutdown = true;
399         metricValues.print(optionsRef.get());
400 
401         phaseTransition(&quot;final&quot;);
402 
403         if (snippetCounterGroups != null) {
404             for (Group group : snippetCounterGroups) {
405                 TTY.out().out().println(group);
406             }
407         }
408         BenchmarkCounters.shutdown(runtime(), optionsRef.get(), runtimeStartTime);
409 
410         outputDirectory.close();
411 
412         shutdownLibGraal();
413     }
414 
415     /**
416      * Substituted by
417      * {@code com.oracle.svm.graal.hotspot.libgraal.Target_org_graalvm_compiler_hotspot_HotSpotGraalRuntime}
418      * to call {@code org.graalvm.nativeimage.VMRuntime.shutdown()}.
419      */
420     private static void shutdownLibGraal() {
421     }
422 
423     void clearMetrics() {
424         metricValues.clear();
425     }
426 
427     private final boolean bootstrapJVMCI;
428     private boolean bootstrapFinished;
429 
430     public void notifyBootstrapFinished() {
431         bootstrapFinished = true;
432     }
433 
434     @Override
435     public boolean isBootstrapping() {
436         return bootstrapJVMCI &amp;&amp; !bootstrapFinished;
437     }
438 
439     @Override
440     public boolean isShutdown() {
441         return shutdown;
442     }
443 
444     @Override
445     public DiagnosticsOutputDirectory getOutputDirectory() {
446         return outputDirectory;
447     }
448 
449     @Override
450     public Map&lt;ExceptionAction, Integer&gt; getCompilationProblemsPerAction() {
451         return compilationProblemsPerAction;
452     }
453 
454     // ------- Management interface ---------
455 
456     private final HotSpotGraalManagementRegistration management;
457 
458     /**
459      * @returns the management object for this runtime or {@code null}
460      */
461     public HotSpotGraalManagementRegistration getManagement() {
462         return management;
463     }
464 
465     /**
466      * Set of weak references to {@link ClassLoader}s available for resolving class names present in
467      * management {@linkplain #invokeManagementAction(String, Object[]) action} arguments.
468      */
469     private final WeakClassLoaderSet loaders = new WeakClassLoaderSet(ClassLoader.getSystemClassLoader());
470 
471     /**
472      * Sets or updates this object&#39;s {@linkplain #getOptions() options} from {@code names} and
473      * {@code values}.
474      *
475      * @param values the values to set. The empty string represents {@code null} which resets an
476      *            option to its default value. For string type options, a non-empty value must be
477      *            enclosed in double quotes.
478      * @return an array of Strings where the element at index i is {@code names[i]} if setting the
479      *         denoted option succeeded, {@code null} if the option is unknown otherwise an error
480      *         message describing the failure to set the option
481      */
482     public String[] setOptionValues(String[] names, String[] values) {
483         EconomicMap&lt;String, OptionDescriptor&gt; optionDescriptors = getOptionDescriptors();
484         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; newValues = EconomicMap.create(names.length);
485         EconomicSet&lt;OptionKey&lt;?&gt;&gt; resetValues = EconomicSet.create(names.length);
486         String[] result = new String[names.length];
487         for (int i = 0; i &lt; names.length; i++) {
488             String name = names[i];
489             OptionDescriptor option = optionDescriptors.get(name);
490             if (option != null) {
491                 String svalue = values[i];
492                 Class&lt;?&gt; optionValueType = option.getOptionValueType();
493                 OptionKey&lt;?&gt; optionKey = option.getOptionKey();
494                 if (svalue == null || svalue.isEmpty() &amp;&amp; !(optionKey instanceof EnumOptionKey)) {
495                     resetValues.add(optionKey);
496                     result[i] = name;
497                 } else {
498                     String valueToParse;
499                     if (optionValueType == String.class) {
500                         if (svalue.length() &lt; 2 || svalue.charAt(0) != &#39;&quot;&#39; || svalue.charAt(svalue.length() - 1) != &#39;&quot;&#39;) {
501                             result[i] = &quot;Invalid value for String option &#39;&quot; + name + &quot;&#39;: must be the empty string or be enclosed in double quotes: &quot; + svalue;
502                             continue;
503                         } else {
504                             valueToParse = svalue.substring(1, svalue.length() - 1);
505                         }
506                     } else {
507                         valueToParse = svalue;
508                     }
509                     try {
510                         OptionsParser.parseOption(name, valueToParse, newValues, OptionsParser.getOptionsLoader());
511                         result[i] = name;
512                     } catch (IllegalArgumentException e) {
513                         result[i] = e.getMessage();
514                         continue;
515                     }
516                 }
517             } else {
518                 result[i] = null;
519             }
520         }
521 
522         OptionValues currentOptions;
523         OptionValues newOptions;
524         do {
525             currentOptions = optionsRef.get();
526             UnmodifiableMapCursor&lt;OptionKey&lt;?&gt;, Object&gt; cursor = currentOptions.getMap().getEntries();
527             while (cursor.advance()) {
528                 OptionKey&lt;?&gt; key = cursor.getKey();
529                 if (!resetValues.contains(key) &amp;&amp; !newValues.containsKey(key)) {
530                     newValues.put(key, OptionValues.decodeNull(cursor.getValue()));
531                 }
532             }
533             newOptions = new OptionValues(newValues);
534         } while (!optionsRef.compareAndSet(currentOptions, newOptions));
535 
536         return result;
537     }
538 
539     /**
540      * Gets the values for the options corresponding to {@code names} encoded as strings. The empty
541      * string represents {@code null}. For string type options, non-{@code null} values will be
542      * enclosed in double quotes.
543      *
544      * @param names a list of option names
545      * @return the values for each named option. If an element in {@code names} does not denote an
546      *         existing option, the corresponding element in the returned array will be {@code null}
547      */
548     public String[] getOptionValues(String... names) {
549         String[] values = new String[names.length];
550         EconomicMap&lt;String, OptionDescriptor&gt; optionDescriptors = getOptionDescriptors();
551         for (int i = 0; i &lt; names.length; i++) {
552             OptionDescriptor option = optionDescriptors.get(names[i]);
553             if (option != null) {
554                 OptionKey&lt;?&gt; optionKey = option.getOptionKey();
555                 Object value = optionKey.getValue(getOptions());
556                 String svalue;
557                 if (option.getOptionValueType() == String.class &amp;&amp; value != null) {
558                     svalue = &quot;\&quot;&quot; + value + &quot;\&quot;&quot;;
559                 } else if (value == null) {
560                     svalue = &quot;&quot;;
561                 } else {
562                     svalue = String.valueOf(value);
563                 }
564                 values[i] = svalue;
565             } else {
566                 // null denotes the option does not exist
567                 values[i] = null;
568             }
569         }
570         return values;
571     }
572 
573     private static EconomicMap&lt;String, OptionDescriptor&gt; getOptionDescriptors() {
574         EconomicMap&lt;String, OptionDescriptor&gt; result = EconomicMap.create();
575         for (OptionDescriptors set : OptionsParser.getOptionsLoader()) {
576             for (OptionDescriptor option : set) {
577                 result.put(option.getName(), option);
578             }
579         }
580         return result;
581     }
582 
583     private void dumpMethod(String className, String methodName, String filter, String host, int port) throws Exception {
584         EconomicSet&lt;ClassNotFoundException&gt; failures = EconomicSet.create();
585         EconomicSet&lt;Class&lt;?&gt;&gt; found = loaders.resolve(className, failures);
586         if (found.isEmpty()) {
587             ClassNotFoundException cause = failures.isEmpty() ? new ClassNotFoundException(className) : failures.iterator().next();
588             throw new Exception(&quot;Cannot find class &quot; + className + &quot; to schedule recompilation&quot;, cause);
589         }
590         for (Class&lt;?&gt; clazz : found) {
591             ResolvedJavaType type = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess().lookupJavaType(clazz);
592             for (ResolvedJavaMethod method : type.getDeclaredMethods()) {
593                 if (methodName.equals(method.getName()) &amp;&amp; method instanceof HotSpotResolvedJavaMethod) {
594                     HotSpotResolvedJavaMethod hotSpotMethod = (HotSpotResolvedJavaMethod) method;
595                     dumpMethod(hotSpotMethod, filter, host, port);
596                 }
597             }
598         }
599     }
600 
601     private void dumpMethod(HotSpotResolvedJavaMethod hotSpotMethod, String filter, String host, int port) throws Exception {
602         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; extra = EconomicMap.create();
603         extra.put(DebugOptions.Dump, filter);
604         extra.put(DebugOptions.PrintGraphHost, host);
605         extra.put(DebugOptions.PrintGraphPort, port);
606         OptionValues compileOptions = new OptionValues(getOptions(), extra);
607         HotSpotGraalCompiler compiler = (HotSpotGraalCompiler) runtime().getCompiler();
608         compiler.compileMethod(new HotSpotCompilationRequest(hotSpotMethod, -1, 0L), false, compileOptions);
609     }
610 
611     public Object invokeManagementAction(String actionName, Object[] params) throws Exception {
612         if (&quot;dumpMethod&quot;.equals(actionName)) {
613             if (params.length != 0 &amp;&amp; params[0] instanceof HotSpotResolvedJavaMethod) {
614                 HotSpotResolvedJavaMethod method = param(params, 0, &quot;method&quot;, HotSpotResolvedJavaMethod.class, null);
615                 String filter = param(params, 1, &quot;filter&quot;, String.class, &quot;:3&quot;);
616                 String host = param(params, 2, &quot;host&quot;, String.class, &quot;localhost&quot;);
617                 Number port = param(params, 3, &quot;port&quot;, Number.class, 4445);
618                 dumpMethod(method, filter, host, port.intValue());
619             } else {
620                 String className = param(params, 0, &quot;className&quot;, String.class, null);
621                 String methodName = param(params, 1, &quot;methodName&quot;, String.class, null);
622                 String filter = param(params, 2, &quot;filter&quot;, String.class, &quot;:3&quot;);
623                 String host = param(params, 3, &quot;host&quot;, String.class, &quot;localhost&quot;);
624                 Number port = param(params, 4, &quot;port&quot;, Number.class, 4445);
625                 dumpMethod(className, methodName, filter, host, port.intValue());
626             }
627         }
628         return null;
629     }
630 
631     private static &lt;T&gt; T param(Object[] arr, int index, String name, Class&lt;T&gt; type, T defaultValue) {
632         Object value = arr.length &gt; index ? arr[index] : null;
633         if (value == null || (value instanceof String &amp;&amp; ((String) value).isEmpty())) {
634             if (defaultValue == null) {
635                 throw new IllegalArgumentException(name + &quot; must be specified&quot;);
636             }
637             value = defaultValue;
638         }
639         if (type.isInstance(value)) {
640             return type.cast(value);
641         }
642         throw new IllegalArgumentException(&quot;Expecting &quot; + type.getName() + &quot; for &quot; + name + &quot; but was &quot; + value);
643     }
644 }
    </pre>
  </body>
</html>
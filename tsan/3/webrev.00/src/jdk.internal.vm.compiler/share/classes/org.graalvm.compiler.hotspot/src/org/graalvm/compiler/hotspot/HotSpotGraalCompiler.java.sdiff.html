<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalCompiler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotForeignCallLinkageImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotGraalCompilerFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalCompiler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 import java.util.Collections;
 32 import java.util.Formattable;
 33 import java.util.Formatter;
 34 import java.util.List;
 35 
 36 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
 37 import org.graalvm.compiler.code.CompilationResult;
 38 import org.graalvm.compiler.core.GraalCompiler;
 39 import org.graalvm.compiler.core.common.CompilationIdentifier;
 40 import org.graalvm.compiler.core.common.util.CompilationAlarm;
 41 import org.graalvm.compiler.debug.DebugContext;
 42 import org.graalvm.compiler.debug.DebugContext.Activation;
 43 import org.graalvm.compiler.debug.DebugHandlersFactory;
 44 import org.graalvm.compiler.debug.DebugOptions;
 45 import org.graalvm.compiler.hotspot.CompilationCounters.Options;
 46 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 47 import org.graalvm.compiler.hotspot.phases.OnStackReplacementPhase;
 48 import org.graalvm.compiler.java.GraphBuilderPhase;
 49 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 50 import org.graalvm.compiler.lir.phases.LIRSuites;

 51 import org.graalvm.compiler.nodes.StructuredGraph;
 52 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 53 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 54 import org.graalvm.compiler.options.OptionValues;
 55 import org.graalvm.compiler.phases.OptimisticOptimizations;
 56 import org.graalvm.compiler.phases.OptimisticOptimizations.Optimization;
 57 import org.graalvm.compiler.phases.PhaseSuite;
 58 import org.graalvm.compiler.phases.tiers.HighTierContext;
 59 import org.graalvm.compiler.phases.tiers.Suites;
 60 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;

 61 
 62 import jdk.vm.ci.code.CompilationRequest;
 63 import jdk.vm.ci.code.CompilationRequestResult;
 64 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 65 import jdk.vm.ci.hotspot.HotSpotCompilationRequestResult;
 66 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 67 import jdk.vm.ci.meta.DefaultProfilingInfo;
 68 import jdk.vm.ci.meta.JavaMethod;
 69 import jdk.vm.ci.meta.ProfilingInfo;
 70 import jdk.vm.ci.meta.ResolvedJavaMethod;
 71 import jdk.vm.ci.meta.SpeculationLog;
 72 import jdk.vm.ci.meta.TriState;
 73 import jdk.vm.ci.runtime.JVMCICompiler;

 74 
<span class="line-modified"> 75 public class HotSpotGraalCompiler implements GraalJVMCICompiler {</span>
 76 

 77     private final HotSpotJVMCIRuntime jvmciRuntime;
 78     private final HotSpotGraalRuntimeProvider graalRuntime;
 79     private final CompilationCounters compilationCounters;
 80     private final BootstrapWatchDog bootstrapWatchDog;
 81     private List&lt;DebugHandlersFactory&gt; factories;
 82 
 83     HotSpotGraalCompiler(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalRuntimeProvider graalRuntime, OptionValues options) {
 84         this.jvmciRuntime = jvmciRuntime;
 85         this.graalRuntime = graalRuntime;
<span class="line-modified"> 86         // It is sufficient to have one compilation counter object per Graal compiler object.</span>
 87         this.compilationCounters = Options.CompilationCountLimit.getValue(options) &gt; 0 ? new CompilationCounters(options) : null;
 88         this.bootstrapWatchDog = graalRuntime.isBootstrapping() &amp;&amp; !DebugOptions.BootstrapInitializeOnly.getValue(options) ? BootstrapWatchDog.maybeCreate(graalRuntime) : null;
 89     }
 90 
 91     public List&lt;DebugHandlersFactory&gt; getDebugHandlersFactories() {
 92         if (factories == null) {
 93             factories = Collections.singletonList(new GraalDebugHandlersFactory(graalRuntime.getHostProviders().getSnippetReflection()));
 94         }
 95         return factories;
 96     }
 97 
 98     @Override
 99     public HotSpotGraalRuntimeProvider getGraalRuntime() {
100         return graalRuntime;
101     }
102 
103     @Override
104     public CompilationRequestResult compileMethod(CompilationRequest request) {
105         return compileMethod(request, true, graalRuntime.getOptions());
106     }
107 
108     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">109     CompilationRequestResult compileMethod(CompilationRequest request, boolean installAsDefault, OptionValues options) {</span>
<span class="line-modified">110         if (graalRuntime.isShutdown()) {</span>
<span class="line-modified">111             return HotSpotCompilationRequestResult.failure(String.format(&quot;Shutdown entered&quot;), false);</span>
<span class="line-modified">112         }</span>

113 
<span class="line-modified">114         ResolvedJavaMethod method = request.getMethod();</span>
115 
<span class="line-modified">116         if (graalRuntime.isBootstrapping()) {</span>
<span class="line-modified">117             if (DebugOptions.BootstrapInitializeOnly.getValue(options)) {</span>
<span class="line-modified">118                 return HotSpotCompilationRequestResult.failure(String.format(&quot;Skip compilation because %s is enabled&quot;, DebugOptions.BootstrapInitializeOnly.getName()), true);</span>







119             }
<span class="line-modified">120             if (bootstrapWatchDog != null) {</span>
<span class="line-modified">121                 if (bootstrapWatchDog.hitCriticalCompilationRateOrTimeout()) {</span>
<span class="line-modified">122                     // Drain the compilation queue to expedite completion of the bootstrap</span>
<span class="line-modified">123                     return HotSpotCompilationRequestResult.failure(&quot;hit critical bootstrap compilation rate or timeout&quot;, true);</span>




124                 }







125             }
126         }
<span class="line-modified">127         HotSpotCompilationRequest hsRequest = (HotSpotCompilationRequest) request;</span>
<span class="line-modified">128         try (CompilationWatchDog w1 = CompilationWatchDog.watch(method, hsRequest.getId(), options);</span>
<span class="line-modified">129                         BootstrapWatchDog.Watch w2 = bootstrapWatchDog == null ? null : bootstrapWatchDog.watch(request);</span>
<span class="line-modified">130                         CompilationAlarm alarm = CompilationAlarm.trackCompilationPeriod(options);) {</span>
<span class="line-modified">131             if (compilationCounters != null) {</span>
<span class="line-modified">132                 compilationCounters.countCompilation(method);</span>




133             }
<span class="line-modified">134             CompilationTask task = new CompilationTask(jvmciRuntime, this, hsRequest, true, installAsDefault, options);</span>
<span class="line-modified">135             CompilationRequestResult r = null;</span>
<span class="line-modified">136             try (DebugContext debug = graalRuntime.openDebugContext(options, task.getCompilationIdentifier(), method, getDebugHandlersFactories(), DebugContext.DEFAULT_LOG_STREAM);</span>
<span class="line-modified">137                             Activation a = debug.activate()) {</span>
<span class="line-removed">138                 r = task.runCompilation(debug);</span>
139             }
<span class="line-removed">140             assert r != null;</span>
<span class="line-removed">141             return r;</span>
142         }






143     }
144 
145     public StructuredGraph createGraph(ResolvedJavaMethod method, int entryBCI, boolean useProfilingInfo, CompilationIdentifier compilationId, OptionValues options, DebugContext debug) {
146         HotSpotBackend backend = graalRuntime.getHostBackend();
147         HotSpotProviders providers = backend.getProviders();
148         final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
<span class="line-modified">149         StructuredGraph graph = method.isNative() || isOSR ? null : providers.getReplacements().getIntrinsicGraph(method, compilationId, debug);</span>
150 
151         if (graph == null) {
152             SpeculationLog speculationLog = method.getSpeculationLog();
153             if (speculationLog != null) {
154                 speculationLog.collectFailedSpeculations();
155             }
<span class="line-modified">156             graph = new StructuredGraph.Builder(options, debug, AllowAssumptions.ifTrue(OptAssumptions.getValue(options))).method(method).entryBCI(entryBCI).speculationLog(</span>
<span class="line-modified">157                             speculationLog).useProfilingInfo(useProfilingInfo).compilationId(compilationId).build();</span>







158         }
159         return graph;
160     }
161 
162     public CompilationResult compileHelper(CompilationResultBuilderFactory crbf, CompilationResult result, StructuredGraph graph, ResolvedJavaMethod method, int entryBCI, boolean useProfilingInfo,
163                     OptionValues options) {


164 



165         HotSpotBackend backend = graalRuntime.getHostBackend();
166         HotSpotProviders providers = backend.getProviders();
167         final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
168 
169         Suites suites = getSuites(providers, options);
170         LIRSuites lirSuites = getLIRSuites(providers, options);
171         ProfilingInfo profilingInfo = useProfilingInfo ? method.getProfilingInfo(!isOSR, isOSR) : DefaultProfilingInfo.get(TriState.FALSE);
172         OptimisticOptimizations optimisticOpts = getOptimisticOpts(profilingInfo, options);
173 
174         /*
175          * Cut off never executed code profiles if there is code, e.g. after the osr loop, that is
176          * never executed.
177          */
178         if (isOSR &amp;&amp; !OnStackReplacementPhase.Options.DeoptAfterOSR.getValue(options)) {
179             optimisticOpts.remove(Optimization.RemoveNeverExecutedCode);
180         }
181 
182         result.setEntryBCI(entryBCI);
183         boolean shouldDebugNonSafepoints = providers.getCodeCache().shouldDebugNonSafepoints();
<span class="line-modified">184         PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = configGraphBuilderSuite(providers.getSuites().getDefaultGraphBuilderSuite(), shouldDebugNonSafepoints, isOSR);</span>
185         GraalCompiler.compileGraph(graph, method, providers, backend, graphBuilderSuite, optimisticOpts, profilingInfo, suites, lirSuites, result, crbf, true);
186 
187         if (!isOSR &amp;&amp; useProfilingInfo) {
188             ProfilingInfo profile = profilingInfo;
189             profile.setCompilerIRSize(StructuredGraph.class, graph.getNodeCount());
190         }
191 
192         return result;
193     }
194 
<span class="line-modified">195     public CompilationResult compile(ResolvedJavaMethod method, int entryBCI, boolean useProfilingInfo, CompilationIdentifier compilationId, OptionValues options, DebugContext debug) {</span>
<span class="line-modified">196         StructuredGraph graph = createGraph(method, entryBCI, useProfilingInfo, compilationId, options, debug);</span>





197         CompilationResult result = new CompilationResult(compilationId);
<span class="line-modified">198         return compileHelper(CompilationResultBuilderFactory.Default, result, graph, method, entryBCI, useProfilingInfo, options);</span>
199     }
200 
201     protected OptimisticOptimizations getOptimisticOpts(ProfilingInfo profilingInfo, OptionValues options) {
202         return new OptimisticOptimizations(profilingInfo, options);
203     }
204 
205     protected Suites getSuites(HotSpotProviders providers, OptionValues options) {
206         return providers.getSuites().getDefaultSuites(options);
207     }
208 
209     protected LIRSuites getLIRSuites(HotSpotProviders providers, OptionValues options) {
210         return providers.getSuites().getDefaultLIRSuites(options);
211     }
212 
213     /**
214      * Reconfigures a given graph builder suite (GBS) if one of the given GBS parameter values is
215      * not the default.
216      *
217      * @param suite the graph builder suite
218      * @param shouldDebugNonSafepoints specifies if extra debug info should be generated (default is
219      *            false)


220      * @param isOSR specifies if extra OSR-specific post-processing is required (default is false)
221      * @return a new suite derived from {@code suite} if any of the GBS parameters did not have a
222      *         default value otherwise {@code suite}
223      */
<span class="line-modified">224     protected PhaseSuite&lt;HighTierContext&gt; configGraphBuilderSuite(PhaseSuite&lt;HighTierContext&gt; suite, boolean shouldDebugNonSafepoints, boolean isOSR) {</span>
<span class="line-modified">225         if (shouldDebugNonSafepoints || isOSR) {</span>
226             PhaseSuite&lt;HighTierContext&gt; newGbs = suite.copy();
<span class="line-modified">227 </span>

228             if (shouldDebugNonSafepoints) {
<span class="line-removed">229                 GraphBuilderPhase graphBuilderPhase = (GraphBuilderPhase) newGbs.findPhase(GraphBuilderPhase.class).previous();</span>
<span class="line-removed">230                 GraphBuilderConfiguration graphBuilderConfig = graphBuilderPhase.getGraphBuilderConfig();</span>
231                 graphBuilderConfig = graphBuilderConfig.withNodeSourcePosition(true);
<span class="line-removed">232                 GraphBuilderPhase newGraphBuilderPhase = new GraphBuilderPhase(graphBuilderConfig);</span>
<span class="line-removed">233                 newGbs.findPhase(GraphBuilderPhase.class).set(newGraphBuilderPhase);</span>
234             }





235             if (isOSR) {
<span class="line-removed">236                 // We must not clear non liveness for OSR compilations.</span>
<span class="line-removed">237                 GraphBuilderPhase graphBuilderPhase = (GraphBuilderPhase) newGbs.findPhase(GraphBuilderPhase.class).previous();</span>
<span class="line-removed">238                 GraphBuilderConfiguration graphBuilderConfig = graphBuilderPhase.getGraphBuilderConfig();</span>
<span class="line-removed">239                 GraphBuilderPhase newGraphBuilderPhase = new GraphBuilderPhase(graphBuilderConfig);</span>
<span class="line-removed">240                 newGbs.findPhase(GraphBuilderPhase.class).set(newGraphBuilderPhase);</span>
241                 newGbs.appendPhase(new OnStackReplacementPhase());
242             }
243             return newGbs;
244         }
245         return suite;
246     }
247 
248     /**
249      * Converts {@code method} to a String with {@link JavaMethod#format(String)} and the format
250      * string {@code &quot;%H.%n(%p)&quot;}.
251      */
252     static String str(JavaMethod method) {
253         return method.format(&quot;%H.%n(%p)&quot;);
254     }
255 
256     /**
257      * Wraps {@code obj} in a {@link Formatter} that standardizes formatting for certain objects.
258      */
259     static Formattable fmt(Object obj) {
260         return new Formattable() {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 import java.util.Collections;
 32 import java.util.Formattable;
 33 import java.util.Formatter;
 34 import java.util.List;
 35 
 36 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
 37 import org.graalvm.compiler.code.CompilationResult;
 38 import org.graalvm.compiler.core.GraalCompiler;
 39 import org.graalvm.compiler.core.common.CompilationIdentifier;
 40 import org.graalvm.compiler.core.common.util.CompilationAlarm;
 41 import org.graalvm.compiler.debug.DebugContext;
 42 import org.graalvm.compiler.debug.DebugContext.Activation;
 43 import org.graalvm.compiler.debug.DebugHandlersFactory;
 44 import org.graalvm.compiler.debug.DebugOptions;
 45 import org.graalvm.compiler.hotspot.CompilationCounters.Options;
 46 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 47 import org.graalvm.compiler.hotspot.phases.OnStackReplacementPhase;
 48 import org.graalvm.compiler.java.GraphBuilderPhase;
 49 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
 50 import org.graalvm.compiler.lir.phases.LIRSuites;
<span class="line-added"> 51 import org.graalvm.compiler.nodes.Cancellable;</span>
 52 import org.graalvm.compiler.nodes.StructuredGraph;
 53 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
 54 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 55 import org.graalvm.compiler.options.OptionValues;
 56 import org.graalvm.compiler.phases.OptimisticOptimizations;
 57 import org.graalvm.compiler.phases.OptimisticOptimizations.Optimization;
 58 import org.graalvm.compiler.phases.PhaseSuite;
 59 import org.graalvm.compiler.phases.tiers.HighTierContext;
 60 import org.graalvm.compiler.phases.tiers.Suites;
 61 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
<span class="line-added"> 62 import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;</span>
 63 
 64 import jdk.vm.ci.code.CompilationRequest;
 65 import jdk.vm.ci.code.CompilationRequestResult;
 66 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 67 import jdk.vm.ci.hotspot.HotSpotCompilationRequestResult;
 68 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 69 import jdk.vm.ci.meta.DefaultProfilingInfo;
 70 import jdk.vm.ci.meta.JavaMethod;
 71 import jdk.vm.ci.meta.ProfilingInfo;
 72 import jdk.vm.ci.meta.ResolvedJavaMethod;
 73 import jdk.vm.ci.meta.SpeculationLog;
 74 import jdk.vm.ci.meta.TriState;
 75 import jdk.vm.ci.runtime.JVMCICompiler;
<span class="line-added"> 76 import sun.misc.Unsafe;</span>
 77 
<span class="line-modified"> 78 public class HotSpotGraalCompiler implements GraalJVMCICompiler, Cancellable {</span>
 79 
<span class="line-added"> 80     private static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();</span>
 81     private final HotSpotJVMCIRuntime jvmciRuntime;
 82     private final HotSpotGraalRuntimeProvider graalRuntime;
 83     private final CompilationCounters compilationCounters;
 84     private final BootstrapWatchDog bootstrapWatchDog;
 85     private List&lt;DebugHandlersFactory&gt; factories;
 86 
 87     HotSpotGraalCompiler(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalRuntimeProvider graalRuntime, OptionValues options) {
 88         this.jvmciRuntime = jvmciRuntime;
 89         this.graalRuntime = graalRuntime;
<span class="line-modified"> 90         // It is sufficient to have one compilation counter object per compiler object.</span>
 91         this.compilationCounters = Options.CompilationCountLimit.getValue(options) &gt; 0 ? new CompilationCounters(options) : null;
 92         this.bootstrapWatchDog = graalRuntime.isBootstrapping() &amp;&amp; !DebugOptions.BootstrapInitializeOnly.getValue(options) ? BootstrapWatchDog.maybeCreate(graalRuntime) : null;
 93     }
 94 
 95     public List&lt;DebugHandlersFactory&gt; getDebugHandlersFactories() {
 96         if (factories == null) {
 97             factories = Collections.singletonList(new GraalDebugHandlersFactory(graalRuntime.getHostProviders().getSnippetReflection()));
 98         }
 99         return factories;
100     }
101 
102     @Override
103     public HotSpotGraalRuntimeProvider getGraalRuntime() {
104         return graalRuntime;
105     }
106 
107     @Override
108     public CompilationRequestResult compileMethod(CompilationRequest request) {
109         return compileMethod(request, true, graalRuntime.getOptions());
110     }
111 
112     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">113     CompilationRequestResult compileMethod(CompilationRequest request, boolean installAsDefault, OptionValues initialOptions) {</span>
<span class="line-modified">114         try (CompilationContext scope = HotSpotGraalServices.openLocalCompilationContext(request)) {</span>
<span class="line-modified">115             if (graalRuntime.isShutdown()) {</span>
<span class="line-modified">116                 return HotSpotCompilationRequestResult.failure(String.format(&quot;Shutdown entered&quot;), true);</span>
<span class="line-added">117             }</span>
118 
<span class="line-modified">119             ResolvedJavaMethod method = request.getMethod();</span>
120 
<span class="line-modified">121             if (graalRuntime.isBootstrapping()) {</span>
<span class="line-modified">122                 if (DebugOptions.BootstrapInitializeOnly.getValue(initialOptions)) {</span>
<span class="line-modified">123                     return HotSpotCompilationRequestResult.failure(String.format(&quot;Skip compilation because %s is enabled&quot;, DebugOptions.BootstrapInitializeOnly.getName()), true);</span>
<span class="line-added">124                 }</span>
<span class="line-added">125                 if (bootstrapWatchDog != null) {</span>
<span class="line-added">126                     if (bootstrapWatchDog.hitCriticalCompilationRateOrTimeout()) {</span>
<span class="line-added">127                         // Drain the compilation queue to expedite completion of the bootstrap</span>
<span class="line-added">128                         return HotSpotCompilationRequestResult.failure(&quot;hit critical bootstrap compilation rate or timeout&quot;, true);</span>
<span class="line-added">129                     }</span>
<span class="line-added">130                 }</span>
131             }
<span class="line-modified">132             HotSpotCompilationRequest hsRequest = (HotSpotCompilationRequest) request;</span>
<span class="line-modified">133             CompilationTask task = new CompilationTask(jvmciRuntime, this, hsRequest, true, shouldRetainLocalVariables(hsRequest.getJvmciEnv()), installAsDefault);</span>
<span class="line-modified">134             OptionValues options = task.filterOptions(initialOptions);</span>
<span class="line-modified">135             try (CompilationWatchDog w1 = CompilationWatchDog.watch(method, hsRequest.getId(), options);</span>
<span class="line-added">136                             BootstrapWatchDog.Watch w2 = bootstrapWatchDog == null ? null : bootstrapWatchDog.watch(request);</span>
<span class="line-added">137                             CompilationAlarm alarm = CompilationAlarm.trackCompilationPeriod(options);) {</span>
<span class="line-added">138                 if (compilationCounters != null) {</span>
<span class="line-added">139                     compilationCounters.countCompilation(method);</span>
140                 }
<span class="line-added">141                 CompilationRequestResult r = null;</span>
<span class="line-added">142                 try (DebugContext debug = graalRuntime.openDebugContext(options, task.getCompilationIdentifier(), method, getDebugHandlersFactories(), DebugContext.DEFAULT_LOG_STREAM);</span>
<span class="line-added">143                                 Activation a = debug.activate()) {</span>
<span class="line-added">144                     r = task.runCompilation(debug);</span>
<span class="line-added">145                 }</span>
<span class="line-added">146                 assert r != null;</span>
<span class="line-added">147                 return r;</span>
148             }
149         }
<span class="line-modified">150     }</span>
<span class="line-modified">151 </span>
<span class="line-modified">152     private boolean shouldRetainLocalVariables(long envAddress) {</span>
<span class="line-modified">153         GraalHotSpotVMConfig config = graalRuntime.getVMConfig();</span>
<span class="line-modified">154         if (envAddress == 0) {</span>
<span class="line-modified">155             return false;</span>
<span class="line-added">156         }</span>
<span class="line-added">157         if (config.jvmciCompileStateCanPopFrameOffset != Integer.MIN_VALUE) {</span>
<span class="line-added">158             if ((UNSAFE.getByte(envAddress + config.jvmciCompileStateCanPopFrameOffset) &amp; 0xFF) != 0) {</span>
<span class="line-added">159                 return true;</span>
160             }
<span class="line-modified">161         }</span>
<span class="line-modified">162         if (config.jvmciCompileStateCanAccessLocalVariablesOffset != Integer.MIN_VALUE) {</span>
<span class="line-modified">163             if ((UNSAFE.getByte(envAddress + config.jvmciCompileStateCanAccessLocalVariablesOffset) &amp; 0xFF) != 0) {</span>
<span class="line-modified">164                 return true;</span>

165             }


166         }
<span class="line-added">167         return false;</span>
<span class="line-added">168     }</span>
<span class="line-added">169 </span>
<span class="line-added">170     @Override</span>
<span class="line-added">171     public boolean isCancelled() {</span>
<span class="line-added">172         return graalRuntime.isShutdown();</span>
173     }
174 
175     public StructuredGraph createGraph(ResolvedJavaMethod method, int entryBCI, boolean useProfilingInfo, CompilationIdentifier compilationId, OptionValues options, DebugContext debug) {
176         HotSpotBackend backend = graalRuntime.getHostBackend();
177         HotSpotProviders providers = backend.getProviders();
178         final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
<span class="line-modified">179         StructuredGraph graph = method.isNative() || isOSR ? null : providers.getReplacements().getIntrinsicGraph(method, compilationId, debug, this);</span>
180 
181         if (graph == null) {
182             SpeculationLog speculationLog = method.getSpeculationLog();
183             if (speculationLog != null) {
184                 speculationLog.collectFailedSpeculations();
185             }
<span class="line-modified">186             // @formatter:off</span>
<span class="line-modified">187             graph = new StructuredGraph.Builder(options, debug, AllowAssumptions.ifTrue(OptAssumptions.getValue(options))).</span>
<span class="line-added">188                             method(method).</span>
<span class="line-added">189                             cancellable(this).</span>
<span class="line-added">190                             entryBCI(entryBCI).</span>
<span class="line-added">191                             speculationLog(speculationLog).</span>
<span class="line-added">192                             useProfilingInfo(useProfilingInfo).</span>
<span class="line-added">193                             compilationId(compilationId).build();</span>
<span class="line-added">194             // @formatter:on</span>
195         }
196         return graph;
197     }
198 
199     public CompilationResult compileHelper(CompilationResultBuilderFactory crbf, CompilationResult result, StructuredGraph graph, ResolvedJavaMethod method, int entryBCI, boolean useProfilingInfo,
200                     OptionValues options) {
<span class="line-added">201         return compileHelper(crbf, result, graph, method, entryBCI, useProfilingInfo, false, options);</span>
<span class="line-added">202     }</span>
203 
<span class="line-added">204     public CompilationResult compileHelper(CompilationResultBuilderFactory crbf, CompilationResult result, StructuredGraph graph, ResolvedJavaMethod method, int entryBCI, boolean useProfilingInfo,</span>
<span class="line-added">205                     boolean shouldRetainLocalVariables, OptionValues options) {</span>
<span class="line-added">206         assert options == graph.getOptions();</span>
207         HotSpotBackend backend = graalRuntime.getHostBackend();
208         HotSpotProviders providers = backend.getProviders();
209         final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
210 
211         Suites suites = getSuites(providers, options);
212         LIRSuites lirSuites = getLIRSuites(providers, options);
213         ProfilingInfo profilingInfo = useProfilingInfo ? method.getProfilingInfo(!isOSR, isOSR) : DefaultProfilingInfo.get(TriState.FALSE);
214         OptimisticOptimizations optimisticOpts = getOptimisticOpts(profilingInfo, options);
215 
216         /*
217          * Cut off never executed code profiles if there is code, e.g. after the osr loop, that is
218          * never executed.
219          */
220         if (isOSR &amp;&amp; !OnStackReplacementPhase.Options.DeoptAfterOSR.getValue(options)) {
221             optimisticOpts.remove(Optimization.RemoveNeverExecutedCode);
222         }
223 
224         result.setEntryBCI(entryBCI);
225         boolean shouldDebugNonSafepoints = providers.getCodeCache().shouldDebugNonSafepoints();
<span class="line-modified">226         PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = configGraphBuilderSuite(providers.getSuites().getDefaultGraphBuilderSuite(), shouldDebugNonSafepoints, shouldRetainLocalVariables, isOSR);</span>
227         GraalCompiler.compileGraph(graph, method, providers, backend, graphBuilderSuite, optimisticOpts, profilingInfo, suites, lirSuites, result, crbf, true);
228 
229         if (!isOSR &amp;&amp; useProfilingInfo) {
230             ProfilingInfo profile = profilingInfo;
231             profile.setCompilerIRSize(StructuredGraph.class, graph.getNodeCount());
232         }
233 
234         return result;
235     }
236 
<span class="line-modified">237     public CompilationResult compile(ResolvedJavaMethod method,</span>
<span class="line-modified">238                     int entryBCI,</span>
<span class="line-added">239                     boolean useProfilingInfo,</span>
<span class="line-added">240                     boolean shouldRetainLocalVariables,</span>
<span class="line-added">241                     CompilationIdentifier compilationId,</span>
<span class="line-added">242                     DebugContext debug) {</span>
<span class="line-added">243         StructuredGraph graph = createGraph(method, entryBCI, useProfilingInfo, compilationId, debug.getOptions(), debug);</span>
244         CompilationResult result = new CompilationResult(compilationId);
<span class="line-modified">245         return compileHelper(CompilationResultBuilderFactory.Default, result, graph, method, entryBCI, useProfilingInfo, shouldRetainLocalVariables, debug.getOptions());</span>
246     }
247 
248     protected OptimisticOptimizations getOptimisticOpts(ProfilingInfo profilingInfo, OptionValues options) {
249         return new OptimisticOptimizations(profilingInfo, options);
250     }
251 
252     protected Suites getSuites(HotSpotProviders providers, OptionValues options) {
253         return providers.getSuites().getDefaultSuites(options);
254     }
255 
256     protected LIRSuites getLIRSuites(HotSpotProviders providers, OptionValues options) {
257         return providers.getSuites().getDefaultLIRSuites(options);
258     }
259 
260     /**
261      * Reconfigures a given graph builder suite (GBS) if one of the given GBS parameter values is
262      * not the default.
263      *
264      * @param suite the graph builder suite
265      * @param shouldDebugNonSafepoints specifies if extra debug info should be generated (default is
266      *            false)
<span class="line-added">267      * @param shouldRetainLocalVariables specifies if local variables should be retained for</span>
<span class="line-added">268      *            debugging purposes (default is false)</span>
269      * @param isOSR specifies if extra OSR-specific post-processing is required (default is false)
270      * @return a new suite derived from {@code suite} if any of the GBS parameters did not have a
271      *         default value otherwise {@code suite}
272      */
<span class="line-modified">273     protected PhaseSuite&lt;HighTierContext&gt; configGraphBuilderSuite(PhaseSuite&lt;HighTierContext&gt; suite, boolean shouldDebugNonSafepoints, boolean shouldRetainLocalVariables, boolean isOSR) {</span>
<span class="line-modified">274         if (shouldDebugNonSafepoints || shouldRetainLocalVariables || isOSR) {</span>
275             PhaseSuite&lt;HighTierContext&gt; newGbs = suite.copy();
<span class="line-modified">276             GraphBuilderPhase graphBuilderPhase = (GraphBuilderPhase) newGbs.findPhase(GraphBuilderPhase.class).previous();</span>
<span class="line-added">277             GraphBuilderConfiguration graphBuilderConfig = graphBuilderPhase.getGraphBuilderConfig();</span>
278             if (shouldDebugNonSafepoints) {


279                 graphBuilderConfig = graphBuilderConfig.withNodeSourcePosition(true);


280             }
<span class="line-added">281             if (shouldRetainLocalVariables) {</span>
<span class="line-added">282                 graphBuilderConfig = graphBuilderConfig.withRetainLocalVariables(true);</span>
<span class="line-added">283             }</span>
<span class="line-added">284             GraphBuilderPhase newGraphBuilderPhase = new GraphBuilderPhase(graphBuilderConfig);</span>
<span class="line-added">285             newGbs.findPhase(GraphBuilderPhase.class).set(newGraphBuilderPhase);</span>
286             if (isOSR) {





287                 newGbs.appendPhase(new OnStackReplacementPhase());
288             }
289             return newGbs;
290         }
291         return suite;
292     }
293 
294     /**
295      * Converts {@code method} to a String with {@link JavaMethod#format(String)} and the format
296      * string {@code &quot;%H.%n(%p)&quot;}.
297      */
298     static String str(JavaMethod method) {
299         return method.format(&quot;%H.%n(%p)&quot;);
300     }
301 
302     /**
303      * Wraps {@code obj} in a {@link Formatter} that standardizes formatting for certain objects.
304      */
305     static Formattable fmt(Object obj) {
306         return new Formattable() {
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotForeignCallLinkageImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotGraalCompilerFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/NewObjectSnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MonitorSnippets.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ObjectCloneNode.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/NewObjectSnippets.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,23 +22,26 @@</span>
   */
  
  
  package org.graalvm.compiler.hotspot.replacements;
  
<span class="udiff-line-added">+ import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateRecompile;</span>
  import static jdk.vm.ci.meta.DeoptimizationAction.None;
  import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;
  import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
<span class="udiff-line-added">+ import static org.graalvm.compiler.core.common.GraalOptions.MinimalBulkZeroingSize;</span>
  import static org.graalvm.compiler.core.common.calc.UnsignedMath.belowThan;
  import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_OPTIONVALUES;
  import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
  import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY;
  import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY_OR_NULL;
  import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE;
  import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE_OR_NULL;
  import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY;
  import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY_OR_NULL;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_ARRAY_KLASS_LOCATION;
<span class="udiff-line-added">+ import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_INIT_STATE_LOCATION;</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_WRITE_LOCATION;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.PROTOTYPE_MARK_WORD_LOCATION;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_END_LOCATION;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_TOP_LOCATION;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -50,17 +53,20 @@</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayAllocationSize;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayKlassOffset;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayLengthOffset;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.initializeObjectHeader;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.instanceHeaderSize;
<span class="udiff-line-added">+ import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.instanceKlassStateBeingInitialized;</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.isInstanceKlassFullyInitialized;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeMask;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeShift;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeMask;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeShift;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.loadKlassFromObject;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.prototypeMarkWordOffset;
<span class="udiff-line-added">+ import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readInstanceKlassInitState;</span>
<span class="udiff-line-added">+ import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readInstanceKlassInitThread;</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readLayoutHelper;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readTlabEnd;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readTlabTop;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.registerAsWord;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.useBiasedLocking;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,13 +75,15 @@</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.writeTlabTop;
  import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocations;
  import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocationsContext;
  import static org.graalvm.compiler.nodes.PiArrayNode.piArrayCastToSnippetReplaceeStamp;
  import static org.graalvm.compiler.nodes.PiNode.piCastToSnippetReplaceeStamp;
<span class="udiff-line-added">+ import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.DEOPT_PROBABILITY;</span>
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FAST_PATH_PROBABILITY;
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FREQUENT_PROBABILITY;
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;
<span class="udiff-line-added">+ import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.VERY_FAST_PATH_PROBABILITY;</span>
  import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
  import static org.graalvm.compiler.replacements.ReplacementsUtil.REPLACEMENTS_ASSERTIONS_ENABLED;
  import static org.graalvm.compiler.replacements.ReplacementsUtil.runtimeAssert;
  import static org.graalvm.compiler.replacements.ReplacementsUtil.staticAssert;
  import static org.graalvm.compiler.replacements.SnippetTemplate.DEFAULT_REPLACER;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -95,10 +103,11 @@</span>
  import org.graalvm.compiler.graph.Node.NodeIntrinsic;
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
  import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
  import org.graalvm.compiler.hotspot.nodes.DimensionsNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.hotspot.nodes.KlassBeingInitializedCheckNode;</span>
  import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyFixedNode;
  import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyNode;
  import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
  import org.graalvm.compiler.hotspot.word.KlassPointer;
  import org.graalvm.compiler.nodes.ConstantNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108,10 +117,11 @@</span>
  import org.graalvm.compiler.nodes.SnippetAnchorNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
  import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;</span>
  import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  import org.graalvm.compiler.nodes.extended.MembarNode;
  import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
  import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
  import org.graalvm.compiler.nodes.java.NewArrayNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -128,10 +138,11 @@</span>
  import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;
  import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
  import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
  import org.graalvm.compiler.replacements.Snippets;
  import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.replacements.nodes.ZeroMemoryNode;</span>
  import org.graalvm.compiler.word.Word;
  import jdk.internal.vm.compiler.word.LocationIdentity;
  import jdk.internal.vm.compiler.word.WordFactory;
  
  import jdk.vm.ci.code.CodeUtil;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -207,27 +218,40 @@</span>
              }
          }
      }
  
      @Snippet
<span class="udiff-line-modified-removed">-     public static Object allocateInstance(@ConstantParameter long size, KlassPointer hub, Word prototypeMarkWord, @ConstantParameter boolean fillContents,</span>
<span class="udiff-line-modified-removed">-                     @ConstantParameter Register threadRegister, @ConstantParameter boolean constantSize, @ConstantParameter String typeContext,</span>
<span class="udiff-line-modified-added">+     public static Object allocateInstance(@ConstantParameter long size,</span>
<span class="udiff-line-modified-added">+                     KlassPointer hub,</span>
<span class="udiff-line-added">+                     Word prototypeMarkWord,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean fillContents,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     @ConstantParameter Register threadRegister,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean constantSize,</span>
<span class="udiff-line-added">+                     @ConstantParameter String typeContext,</span>
                      @ConstantParameter Counters counters) {
<span class="udiff-line-modified-removed">-         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, hub, prototypeMarkWord, fillContents, threadRegister, constantSize, typeContext, counters));</span>
<span class="udiff-line-modified-added">+         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, hub, prototypeMarkWord, fillContents, emitMemoryBarrier, threadRegister, constantSize, typeContext, counters));</span>
      }
  
<span class="udiff-line-modified-removed">-     public static Object allocateInstanceHelper(long size, KlassPointer hub, Word prototypeMarkWord, boolean fillContents,</span>
<span class="udiff-line-modified-removed">-                     Register threadRegister, boolean constantSize, String typeContext, Counters counters) {</span>
<span class="udiff-line-modified-added">+     public static Object allocateInstanceHelper(long size,</span>
<span class="udiff-line-modified-added">+                     KlassPointer hub,</span>
<span class="udiff-line-added">+                     Word prototypeMarkWord,</span>
<span class="udiff-line-added">+                     boolean fillContents,</span>
<span class="udiff-line-added">+                     boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     Register threadRegister,</span>
<span class="udiff-line-added">+                     boolean constantSize,</span>
<span class="udiff-line-added">+                     String typeContext,</span>
<span class="udiff-line-added">+                     Counters counters) {</span>
          Object result;
          Word thread = registerAsWord(threadRegister);
          Word top = readTlabTop(thread);
          Word end = readTlabEnd(thread);
          Word newTop = top.add(WordFactory.unsigned(size));
          if (useTLAB(INJECTED_VMCONFIG) &amp;&amp; probability(FAST_PATH_PROBABILITY, newTop.belowOrEqual(end))) {
              writeTlabTop(thread, newTop);
              emitPrefetchAllocate(newTop, false);
<span class="udiff-line-modified-removed">-             result = formatObject(hub, size, top, prototypeMarkWord, fillContents, constantSize, counters);</span>
<span class="udiff-line-modified-added">+             result = formatObject(hub, size, top, prototypeMarkWord, fillContents, emitMemoryBarrier, constantSize, counters);</span>
          } else {
              Counters theCounters = counters;
              if (theCounters != null &amp;&amp; theCounters.stub != null) {
                  theCounters.stub.inc();
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -250,41 +274,55 @@</span>
  
      @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
      private static native Object newInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub);
  
      @Snippet
<span class="udiff-line-modified-removed">-     public static Object allocateInstancePIC(@ConstantParameter long size, KlassPointer hub, Word prototypeMarkWord, @ConstantParameter boolean fillContents,</span>
<span class="udiff-line-modified-removed">-                     @ConstantParameter Register threadRegister, @ConstantParameter boolean constantSize, @ConstantParameter String typeContext,</span>
<span class="udiff-line-modified-added">+     public static Object allocateInstancePIC(@ConstantParameter long size,</span>
<span class="udiff-line-modified-added">+                     KlassPointer hub,</span>
<span class="udiff-line-added">+                     Word prototypeMarkWord,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean fillContents,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     @ConstantParameter Register threadRegister,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean constantSize,</span>
<span class="udiff-line-added">+                     @ConstantParameter String typeContext,</span>
                      @ConstantParameter Counters counters) {
          // Klass must be initialized by the time the first instance is allocated, therefore we can
          // just load it from the corresponding cell and avoid the resolution check. We have to use a
          // fixed load though, to prevent it from floating above the initialization.
          KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
<span class="udiff-line-modified-removed">-         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, picHub, prototypeMarkWord, fillContents, threadRegister, constantSize, typeContext, counters));</span>
<span class="udiff-line-modified-added">+         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, picHub, prototypeMarkWord, fillContents, emitMemoryBarrier, threadRegister, constantSize, typeContext, counters));</span>
      }
  
      @Snippet
<span class="udiff-line-modified-removed">-     public static Object allocateInstanceDynamic(Class&lt;?&gt; type, Class&lt;?&gt; classClass, @ConstantParameter boolean fillContents, @ConstantParameter Register threadRegister,</span>
<span class="udiff-line-modified-added">+     public static Object allocateInstanceDynamic(Class&lt;?&gt; type, Class&lt;?&gt; classClass,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean fillContents,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     @ConstantParameter Register threadRegister,</span>
                      @ConstantParameter Counters counters) {
<span class="udiff-line-modified-removed">-         if (probability(SLOW_PATH_PROBABILITY, type == null)) {</span>
<span class="udiff-line-modified-added">+         if (probability(DEOPT_PROBABILITY, type == null)) {</span>
              DeoptimizeNode.deopt(None, RuntimeConstraint);
          }
          Class&lt;?&gt; nonNullType = PiNode.piCastNonNullClass(type, SnippetAnchorNode.anchor());
  
<span class="udiff-line-modified-removed">-         if (probability(SLOW_PATH_PROBABILITY, DynamicNewInstanceNode.throwsInstantiationException(type, classClass))) {</span>
<span class="udiff-line-modified-added">+         if (probability(DEOPT_PROBABILITY, DynamicNewInstanceNode.throwsInstantiationException(type, classClass))) {</span>
              DeoptimizeNode.deopt(None, RuntimeConstraint);
          }
  
<span class="udiff-line-modified-removed">-         return PiNode.piCastToSnippetReplaceeStamp(allocateInstanceDynamicHelper(type, fillContents, threadRegister, counters, nonNullType));</span>
<span class="udiff-line-modified-added">+         return PiNode.piCastToSnippetReplaceeStamp(allocateInstanceDynamicHelper(type, fillContents, emitMemoryBarrier, threadRegister, counters, nonNullType));</span>
      }
  
<span class="udiff-line-modified-removed">-     private static Object allocateInstanceDynamicHelper(Class&lt;?&gt; type, boolean fillContents, Register threadRegister, Counters counters, Class&lt;?&gt; nonNullType) {</span>
<span class="udiff-line-modified-added">+     private static Object allocateInstanceDynamicHelper(Class&lt;?&gt; type,</span>
<span class="udiff-line-added">+                     boolean fillContents,</span>
<span class="udiff-line-added">+                     boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     Register threadRegister,</span>
<span class="udiff-line-added">+                     Counters counters,</span>
<span class="udiff-line-added">+                     Class&lt;?&gt; nonNullType) {</span>
          KlassPointer hub = ClassGetHubNode.readClass(nonNullType);
          if (probability(FAST_PATH_PROBABILITY, !hub.isNull())) {
              KlassPointer nonNullHub = ClassGetHubNode.piCastNonNull(hub, SnippetAnchorNode.anchor());
  
<span class="udiff-line-modified-removed">-             if (probability(FAST_PATH_PROBABILITY, isInstanceKlassFullyInitialized(nonNullHub))) {</span>
<span class="udiff-line-modified-added">+             if (probability(VERY_FAST_PATH_PROBABILITY, isInstanceKlassFullyInitialized(nonNullHub))) {</span>
                  int layoutHelper = readLayoutHelper(nonNullHub);
                  /*
                   * src/share/vm/oops/klass.hpp: For instances, layout helper is a positive number,
                   * the instance size. This size is already passed through align_object_size and
                   * scaled to bytes. The low order bit is set if instances of this class cannot be
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -294,11 +332,11 @@</span>
                      Word prototypeMarkWord = nonNullHub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION);
                      /*
                       * FIXME(je,ds): we should actually pass typeContext instead of &quot;&quot; but late
                       * binding of parameters is not yet supported by the GraphBuilderPlugin system.
                       */
<span class="udiff-line-modified-removed">-                     return allocateInstanceHelper(layoutHelper, nonNullHub, prototypeMarkWord, fillContents, threadRegister, false, &quot;&quot;, counters);</span>
<span class="udiff-line-modified-added">+                     return allocateInstanceHelper(layoutHelper, nonNullHub, prototypeMarkWord, fillContents, emitMemoryBarrier, threadRegister, false, &quot;&quot;, counters);</span>
                  }
              } else {
                  DeoptimizeNode.deopt(None, RuntimeConstraint);
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -309,48 +347,70 @@</span>
       * Maximum array length for which fast path allocation is used.
       */
      public static final int MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH = 0x00FFFFFF;
  
      @Snippet
<span class="udiff-line-modified-removed">-     public static Object allocatePrimitiveArrayPIC(KlassPointer hub, int length, Word prototypeMarkWord, @ConstantParameter int headerSize, @ConstantParameter int log2ElementSize,</span>
<span class="udiff-line-modified-removed">-                     @ConstantParameter boolean fillContents, @ConstantParameter Register threadRegister, @ConstantParameter boolean maybeUnroll, @ConstantParameter String typeContext,</span>
<span class="udiff-line-modified-added">+     public static Object allocatePrimitiveArrayPIC(KlassPointer hub,</span>
<span class="udiff-line-modified-added">+                     int length,</span>
<span class="udiff-line-added">+                     Word prototypeMarkWord,</span>
<span class="udiff-line-added">+                     @ConstantParameter int headerSize,</span>
<span class="udiff-line-added">+                     @ConstantParameter int log2ElementSize,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean fillContents,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     @ConstantParameter Register threadRegister,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean maybeUnroll,</span>
<span class="udiff-line-added">+                     @ConstantParameter String typeContext,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean supportsBulkZeroing,</span>
                      @ConstantParameter Counters counters) {
          // Primitive array types are eagerly pre-resolved. We can use a floating load.
          KlassPointer picHub = LoadConstantIndirectlyNode.loadKlass(hub);
<span class="udiff-line-modified-removed">-         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents, threadRegister, maybeUnroll, typeContext, counters);</span>
<span class="udiff-line-modified-added">+         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents,</span>
<span class="udiff-line-added">+                         emitMemoryBarrier, threadRegister, maybeUnroll, typeContext, supportsBulkZeroing, counters);</span>
      }
  
      @Snippet
<span class="udiff-line-modified-removed">-     public static Object allocateArrayPIC(KlassPointer hub, int length, Word prototypeMarkWord, @ConstantParameter int headerSize, @ConstantParameter int log2ElementSize,</span>
<span class="udiff-line-modified-removed">-                     @ConstantParameter boolean fillContents, @ConstantParameter Register threadRegister, @ConstantParameter boolean maybeUnroll, @ConstantParameter String typeContext,</span>
<span class="udiff-line-modified-added">+     public static Object allocateArrayPIC(KlassPointer hub,</span>
<span class="udiff-line-modified-added">+                     int length,</span>
<span class="udiff-line-added">+                     Word prototypeMarkWord,</span>
<span class="udiff-line-added">+                     @ConstantParameter int headerSize,</span>
<span class="udiff-line-added">+                     @ConstantParameter int log2ElementSize,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean fillContents,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     @ConstantParameter Register threadRegister,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean maybeUnroll,</span>
<span class="udiff-line-added">+                     @ConstantParameter String typeContext,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean supportsBulkZeroing,</span>
                      @ConstantParameter Counters counters) {
          // Array type would be resolved by dominating resolution.
          KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
<span class="udiff-line-modified-removed">-         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents, threadRegister, maybeUnroll, typeContext, counters);</span>
<span class="udiff-line-modified-added">+         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents,</span>
<span class="udiff-line-added">+                         emitMemoryBarrier, threadRegister, maybeUnroll, typeContext, supportsBulkZeroing, counters);</span>
      }
  
      @Snippet
      public static Object allocateArray(KlassPointer hub,
                      int length,
                      Word prototypeMarkWord,
                      @ConstantParameter int headerSize,
                      @ConstantParameter int log2ElementSize,
                      @ConstantParameter boolean fillContents,
<span class="udiff-line-added">+                     @ConstantParameter boolean emitMemoryBarrier,</span>
                      @ConstantParameter Register threadRegister,
                      @ConstantParameter boolean maybeUnroll,
                      @ConstantParameter String typeContext,
<span class="udiff-line-added">+                     @ConstantParameter boolean supportsBulkZeroing,</span>
                      @ConstantParameter Counters counters) {
          Object result = allocateArrayImpl(hub,
                          length,
                          prototypeMarkWord,
                          headerSize,
                          log2ElementSize,
                          fillContents,
<span class="udiff-line-modified-removed">-                         threadRegister,</span>
<span class="udiff-line-modified-added">+                         emitMemoryBarrier, threadRegister,</span>
                          maybeUnroll,
                          typeContext,
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+                         supportsBulkZeroing,</span>
                          counters);
          return piArrayCastToSnippetReplaceeStamp(verifyOop(result), length);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -360,12 +420,22 @@</span>
      @Fold
      static boolean useNullAllocationStubs(@InjectedParameter GraalHotSpotVMConfig config) {
          return config.areNullAllocationStubsAvailable();
      }
  
<span class="udiff-line-modified-removed">-     private static Object allocateArrayImpl(KlassPointer hub, int length, Word prototypeMarkWord, int headerSize, int log2ElementSize, boolean fillContents, Register threadRegister,</span>
<span class="udiff-line-modified-removed">-                     boolean maybeUnroll, String typeContext, Counters counters) {</span>
<span class="udiff-line-modified-added">+     private static Object allocateArrayImpl(KlassPointer hub,</span>
<span class="udiff-line-modified-added">+                     int length,</span>
<span class="udiff-line-added">+                     Word prototypeMarkWord,</span>
<span class="udiff-line-added">+                     int headerSize,</span>
<span class="udiff-line-added">+                     int log2ElementSize,</span>
<span class="udiff-line-added">+                     boolean fillContents,</span>
<span class="udiff-line-added">+                     boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     Register threadRegister,</span>
<span class="udiff-line-added">+                     boolean maybeUnroll,</span>
<span class="udiff-line-added">+                     String typeContext,</span>
<span class="udiff-line-added">+                     boolean supportsBulkZeroing,</span>
<span class="udiff-line-added">+                     Counters counters) {</span>
          Object result;
          long allocationSize = arrayAllocationSize(length, headerSize, log2ElementSize);
          Word thread = registerAsWord(threadRegister);
          Word top = readTlabTop(thread);
          Word end = readTlabEnd(thread);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -376,11 +446,11 @@</span>
              emitPrefetchAllocate(newTop, true);
              Counters theCounters = counters;
              if (theCounters != null &amp;&amp; theCounters.arrayLoopInit != null) {
                  theCounters.arrayLoopInit.inc();
              }
<span class="udiff-line-modified-removed">-             result = formatArray(hub, allocationSize, length, headerSize, top, prototypeMarkWord, fillContents, maybeUnroll, counters);</span>
<span class="udiff-line-modified-added">+             result = formatArray(hub, allocationSize, length, headerSize, top, prototypeMarkWord, fillContents, emitMemoryBarrier, maybeUnroll, supportsBulkZeroing, counters);</span>
          } else {
              result = newArrayStub(hub, length);
          }
          profileAllocation(&quot;array&quot;, allocationSize, typeContext);
          return result;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -420,11 +490,11 @@</span>
  
      /**
       * Deoptimizes if {@code obj == null} otherwise returns {@code obj}.
       */
      private static Object nonNullOrDeopt(Object obj) {
<span class="udiff-line-modified-removed">-         if (obj == null) {</span>
<span class="udiff-line-modified-added">+         if (BranchProbabilityNode.probability(BranchProbabilityNode.DEOPT_PROBABILITY, obj == null)) {</span>
              DeoptimizeNode.deopt(None, RuntimeConstraint);
          }
          return obj;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -433,35 +503,53 @@</span>
  
      @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
      public static native Object dynamicNewInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, Class&lt;?&gt; elementType);
  
      @Snippet
<span class="udiff-line-modified-removed">-     public static Object allocateArrayDynamic(Class&lt;?&gt; elementType, Class&lt;?&gt; voidClass, int length, @ConstantParameter boolean fillContents, @ConstantParameter Register threadRegister,</span>
<span class="udiff-line-modified-removed">-                     @ConstantParameter JavaKind knownElementKind, @ConstantParameter int knownLayoutHelper, Word prototypeMarkWord,</span>
<span class="udiff-line-modified-added">+     public static Object allocateArrayDynamic(Class&lt;?&gt; elementType,</span>
<span class="udiff-line-modified-added">+                     Class&lt;?&gt; voidClass,</span>
<span class="udiff-line-added">+                     int length,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean fillContents,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     @ConstantParameter Register threadRegister,</span>
<span class="udiff-line-added">+                     @ConstantParameter JavaKind knownElementKind,</span>
<span class="udiff-line-added">+                     @ConstantParameter int knownLayoutHelper,</span>
<span class="udiff-line-added">+                     @ConstantParameter boolean supportsBulkZeroing,</span>
<span class="udiff-line-added">+                     Word prototypeMarkWord,</span>
                      @ConstantParameter Counters counters) {
<span class="udiff-line-modified-removed">-         Object result = allocateArrayDynamicImpl(elementType, voidClass, length, fillContents, threadRegister, knownElementKind, knownLayoutHelper, prototypeMarkWord, counters);</span>
<span class="udiff-line-modified-added">+         Object result = allocateArrayDynamicImpl(elementType, voidClass, length, fillContents, emitMemoryBarrier, threadRegister, knownElementKind,</span>
<span class="udiff-line-added">+                         knownLayoutHelper, supportsBulkZeroing, prototypeMarkWord, counters);</span>
          return result;
      }
  
<span class="udiff-line-modified-removed">-     private static Object allocateArrayDynamicImpl(Class&lt;?&gt; elementType, Class&lt;?&gt; voidClass, int length, boolean fillContents, Register threadRegister, JavaKind knownElementKind,</span>
<span class="udiff-line-modified-removed">-                     int knownLayoutHelper, Word prototypeMarkWord, Counters counters) {</span>
<span class="udiff-line-modified-added">+     private static Object allocateArrayDynamicImpl(Class&lt;?&gt; elementType,</span>
<span class="udiff-line-modified-added">+                     Class&lt;?&gt; voidClass,</span>
<span class="udiff-line-added">+                     int length,</span>
<span class="udiff-line-added">+                     boolean fillContents,</span>
<span class="udiff-line-added">+                     boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     Register threadRegister,</span>
<span class="udiff-line-added">+                     JavaKind knownElementKind,</span>
<span class="udiff-line-added">+                     int knownLayoutHelper,</span>
<span class="udiff-line-added">+                     boolean supportsBulkZeroing,</span>
<span class="udiff-line-added">+                     Word prototypeMarkWord,</span>
<span class="udiff-line-added">+                     Counters counters) {</span>
          /*
           * We only need the dynamic check for void when we have no static information from
           * knownElementKind.
           */
          staticAssert(knownElementKind != JavaKind.Void, &quot;unsupported knownElementKind&quot;);
          if (knownElementKind == JavaKind.Illegal &amp;&amp; probability(SLOW_PATH_PROBABILITY, elementType == null || DynamicNewArrayNode.throwsIllegalArgumentException(elementType, voidClass))) {
              DeoptimizeNode.deopt(None, RuntimeConstraint);
          }
  
          KlassPointer klass = loadKlassFromObject(elementType, arrayKlassOffset(INJECTED_VMCONFIG), CLASS_ARRAY_KLASS_LOCATION);
<span class="udiff-line-modified-removed">-         if (klass.isNull()) {</span>
<span class="udiff-line-modified-added">+         if (probability(DEOPT_PROBABILITY, klass.isNull())) {</span>
              DeoptimizeNode.deopt(None, RuntimeConstraint);
          }
          KlassPointer nonNullKlass = ClassGetHubNode.piCastNonNull(klass, SnippetAnchorNode.anchor());
  
<span class="udiff-line-modified-removed">-         if (length &lt; 0) {</span>
<span class="udiff-line-modified-added">+         if (probability(DEOPT_PROBABILITY, length &lt; 0)) {</span>
              DeoptimizeNode.deopt(None, RuntimeConstraint);
          }
          int layoutHelper;
          if (knownElementKind == JavaKind.Illegal) {
              layoutHelper = readLayoutHelper(nonNullKlass);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -483,11 +571,12 @@</span>
          //@formatter:on
  
          int headerSize = (layoutHelper &gt;&gt; layoutHelperHeaderSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperHeaderSizeMask(INJECTED_VMCONFIG);
          int log2ElementSize = (layoutHelper &gt;&gt; layoutHelperLog2ElementSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperLog2ElementSizeMask(INJECTED_VMCONFIG);
  
<span class="udiff-line-modified-removed">-         Object result = allocateArrayImpl(nonNullKlass, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents, threadRegister, false, &quot;dynamic type&quot;, counters);</span>
<span class="udiff-line-modified-added">+         Object result = allocateArrayImpl(nonNullKlass, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents,</span>
<span class="udiff-line-added">+                         emitMemoryBarrier, threadRegister, false, &quot;dynamic type&quot;, supportsBulkZeroing, counters);</span>
          return piArrayCastToSnippetReplaceeStamp(verifyOop(result), length);
      }
  
      /**
       * Calls the runtime stub for implementing MULTIANEWARRAY.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -531,90 +620,115 @@</span>
  
      /**
       * Zero uninitialized memory in a newly allocated object, unrolling as necessary and ensuring
       * that stores are aligned.
       *
<span class="udiff-line-removed">-      * @param size number of bytes to zero</span>
       * @param memory beginning of object which is being zeroed
<span class="udiff-line-modified-removed">-      * @param constantSize is {@code size} known to be constant in the snippet</span>
<span class="udiff-line-modified-removed">-      * @param startOffset offset to begin zeroing. May not be word aligned.</span>
<span class="udiff-line-modified-added">+      * @param startOffset offset to begin zeroing (inclusive). May not be word aligned.</span>
<span class="udiff-line-modified-added">+      * @param endOffset offset to stop zeroing (exclusive). May not be word aligned.</span>
<span class="udiff-line-added">+      * @param isEndOffsetConstant is {@code endOffset} known to be constant in the snippet</span>
       * @param manualUnroll maximally unroll zeroing
<span class="udiff-line-added">+      * @param supportsBulkZeroing whether bulk zeroing is supported by the backend</span>
       */
<span class="udiff-line-modified-removed">-     private static void zeroMemory(long size, Word memory, boolean constantSize, int startOffset, boolean manualUnroll, Counters counters) {</span>
<span class="udiff-line-modified-removed">-         fillMemory(0, size, memory, constantSize, startOffset, manualUnroll, counters);</span>
<span class="udiff-line-modified-added">+     private static void zeroMemory(Word memory, int startOffset, long endOffset, boolean isEndOffsetConstant, boolean manualUnroll,</span>
<span class="udiff-line-modified-added">+                     boolean supportsBulkZeroing, Counters counters) {</span>
<span class="udiff-line-added">+         fillMemory(0, memory, startOffset, endOffset, isEndOffsetConstant, manualUnroll, supportsBulkZeroing, counters);</span>
      }
  
<span class="udiff-line-modified-removed">-     private static void fillMemory(long value, long size, Word memory, boolean constantSize, int startOffset, boolean manualUnroll, Counters counters) {</span>
<span class="udiff-line-modified-removed">-         ReplacementsUtil.runtimeAssert((size &amp; 0x7) == 0, &quot;unaligned object size&quot;);</span>
<span class="udiff-line-modified-added">+     private static void fillMemory(long value, Word memory, int startOffset, long endOffset, boolean constantOffsetLimit, boolean manualUnroll,</span>
<span class="udiff-line-modified-added">+                     boolean supportsBulkZeroing, Counters counters) {</span>
<span class="udiff-line-added">+         ReplacementsUtil.runtimeAssert((endOffset &amp; 0x7) == 0, &quot;unaligned object size&quot;);</span>
          int offset = startOffset;
          if ((offset &amp; 0x7) != 0) {
              memory.writeInt(offset, (int) value, LocationIdentity.init());
              offset += 4;
          }
          ReplacementsUtil.runtimeAssert((offset &amp; 0x7) == 0, &quot;unaligned offset&quot;);
          Counters theCounters = counters;
<span class="udiff-line-modified-removed">-         if (manualUnroll &amp;&amp; ((size - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="udiff-line-modified-removed">-             ReplacementsUtil.staticAssert(!constantSize, &quot;size shouldn&#39;t be constant at instantiation time&quot;);</span>
<span class="udiff-line-modified-added">+         if (manualUnroll &amp;&amp; ((endOffset - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="udiff-line-modified-added">+             ReplacementsUtil.staticAssert(!constantOffsetLimit, &quot;size shouldn&#39;t be constant at instantiation time&quot;);</span>
              // This case handles arrays of constant length. Instead of having a snippet variant for
              // each length, generate a chain of stores of maximum length. Once it&#39;s inlined the
              // break statement will trim excess stores.
              if (theCounters != null &amp;&amp; theCounters.instanceSeqInit != null) {
                  theCounters.instanceSeqInit.inc();
              }
  
              explodeLoop();
              for (int i = 0; i &lt; MAX_UNROLLED_OBJECT_ZEROING_STORES; i++, offset += 8) {
<span class="udiff-line-modified-removed">-                 if (offset == size) {</span>
<span class="udiff-line-modified-added">+                 if (offset == endOffset) {</span>
                      break;
                  }
                  memory.initializeLong(offset, value, LocationIdentity.init());
              }
          } else {
              // Use Word instead of int to avoid extension to long in generated code
              Word off = WordFactory.signed(offset);
<span class="udiff-line-modified-removed">-             if (constantSize &amp;&amp; ((size - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="udiff-line-modified-removed">-                 if (theCounters != null &amp;&amp; theCounters.instanceSeqInit != null) {</span>
<span class="udiff-line-modified-removed">-                     theCounters.instanceSeqInit.inc();</span>
<span class="udiff-line-modified-added">+             if (supportsBulkZeroing &amp;&amp; value == 0 &amp;&amp; probability(SLOW_PATH_PROBABILITY, (endOffset - offset) &gt;= getMinimalBulkZeroingSize(INJECTED_OPTIONVALUES))) {</span>
<span class="udiff-line-modified-added">+                 if (theCounters != null &amp;&amp; theCounters.instanceBulkInit != null) {</span>
<span class="udiff-line-modified-added">+                     theCounters.instanceBulkInit.inc();</span>
                  }
<span class="udiff-line-modified-removed">-                 explodeLoop();</span>
<span class="udiff-line-modified-added">+                 ZeroMemoryNode.zero(memory.add(off), endOffset - offset, true, LocationIdentity.init());</span>
              } else {
<span class="udiff-line-modified-removed">-                 if (theCounters != null &amp;&amp; theCounters.instanceLoopInit != null) {</span>
<span class="udiff-line-modified-removed">-                     theCounters.instanceLoopInit.inc();</span>
<span class="udiff-line-modified-added">+                 if (constantOffsetLimit &amp;&amp; ((endOffset - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="udiff-line-modified-added">+                     if (theCounters != null &amp;&amp; theCounters.instanceSeqInit != null) {</span>
<span class="udiff-line-added">+                         theCounters.instanceSeqInit.inc();</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     explodeLoop();</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     if (theCounters != null &amp;&amp; theCounters.instanceLoopInit != null) {</span>
<span class="udiff-line-added">+                         theCounters.instanceLoopInit.inc();</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 for (; off.rawValue() &lt; endOffset; off = off.add(8)) {</span>
<span class="udiff-line-added">+                     memory.initializeLong(off, value, LocationIdentity.init());</span>
                  }
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             for (; off.rawValue() &lt; size; off = off.add(8)) {</span>
<span class="udiff-line-removed">-                 memory.initializeLong(off, value, LocationIdentity.init());</span>
              }
          }
      }
  
<span class="udiff-line-added">+     @Fold</span>
<span class="udiff-line-added">+     static int getMinimalBulkZeroingSize(@InjectedParameter OptionValues optionValues) {</span>
<span class="udiff-line-added">+         return MinimalBulkZeroingSize.getValue(optionValues);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Fill uninitialized memory with garbage value in a newly allocated object, unrolling as
       * necessary and ensuring that stores are aligned.
       *
<span class="udiff-line-removed">-      * @param size number of bytes to zero</span>
       * @param memory beginning of object which is being zeroed
<span class="udiff-line-modified-removed">-      * @param constantSize is {@code  size} known to be constant in the snippet</span>
<span class="udiff-line-modified-removed">-      * @param startOffset offset to begin zeroing. May not be word aligned.</span>
<span class="udiff-line-modified-added">+      * @param startOffset offset to begin filling garbage value (inclusive). May not be word</span>
<span class="udiff-line-modified-added">+      *            aligned.</span>
<span class="udiff-line-added">+      * @param endOffset offset to stop filling garbage value (exclusive). May not be word aligned.</span>
<span class="udiff-line-added">+      * @param isEndOffsetConstant is {@code  endOffset} known to be constant in the snippet</span>
       * @param manualUnroll maximally unroll zeroing
       */
<span class="udiff-line-modified-removed">-     private static void fillWithGarbage(long size, Word memory, boolean constantSize, int startOffset, boolean manualUnroll, Counters counters) {</span>
<span class="udiff-line-modified-removed">-         fillMemory(0xfefefefefefefefeL, size, memory, constantSize, startOffset, manualUnroll, counters);</span>
<span class="udiff-line-modified-added">+     private static void fillWithGarbage(Word memory, int startOffset, long endOffset, boolean isEndOffsetConstant, boolean manualUnroll, Counters counters) {</span>
<span class="udiff-line-modified-added">+         fillMemory(0xfefefefefefefefeL, memory, startOffset, endOffset, isEndOffsetConstant, manualUnroll, false, counters);</span>
      }
  
      /**
       * Formats some allocated memory with an object header and zeroes out the rest.
       */
<span class="udiff-line-modified-removed">-     private static Object formatObject(KlassPointer hub, long size, Word memory, Word compileTimePrototypeMarkWord, boolean fillContents, boolean constantSize, Counters counters) {</span>
<span class="udiff-line-modified-added">+     private static Object formatObject(KlassPointer hub,</span>
<span class="udiff-line-added">+                     long size,</span>
<span class="udiff-line-added">+                     Word memory,</span>
<span class="udiff-line-added">+                     Word compileTimePrototypeMarkWord,</span>
<span class="udiff-line-added">+                     boolean fillContents,</span>
<span class="udiff-line-added">+                     boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     boolean constantSize,</span>
<span class="udiff-line-added">+                     Counters counters) {</span>
          Word prototypeMarkWord = useBiasedLocking(INJECTED_VMCONFIG) ? hub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION) : compileTimePrototypeMarkWord;
          initializeObjectHeader(memory, prototypeMarkWord, hub);
          if (fillContents) {
<span class="udiff-line-modified-removed">-             zeroMemory(size, memory, constantSize, instanceHeaderSize(INJECTED_VMCONFIG), false, counters);</span>
<span class="udiff-line-modified-added">+             zeroMemory(memory, instanceHeaderSize(INJECTED_VMCONFIG), size, constantSize, false, false, counters);</span>
          } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {
<span class="udiff-line-modified-removed">-             fillWithGarbage(size, memory, constantSize, instanceHeaderSize(INJECTED_VMCONFIG), false, counters);</span>
<span class="udiff-line-modified-added">+             fillWithGarbage(memory, instanceHeaderSize(INJECTED_VMCONFIG), size, constantSize, false, counters);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (emitMemoryBarrier) {</span>
<span class="udiff-line-added">+             MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
          }
<span class="udiff-line-removed">-         MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
          return memory.toObjectNonNull();
      }
  
      @Snippet
      private static void verifyHeap(@ConstantParameter Register threadRegister) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -626,62 +740,90 @@</span>
                  AssertionSnippets.vmMessageC(AssertionSnippets.ASSERTION_VM_MESSAGE_C, true, cstring(&quot;overzeroing of TLAB detected&quot;), 0L, 0L, 0L);
              }
          }
      }
  
<span class="udiff-line-added">+     @Snippet</span>
<span class="udiff-line-added">+     private static void threadBeingInitializedCheck(@ConstantParameter Register threadRegister, KlassPointer klass) {</span>
<span class="udiff-line-added">+         int state = readInstanceKlassInitState(klass);</span>
<span class="udiff-line-added">+         if (state != instanceKlassStateBeingInitialized(INJECTED_VMCONFIG)) {</span>
<span class="udiff-line-added">+             // The klass is no longer being initialized so force recompilation</span>
<span class="udiff-line-added">+             DeoptimizeNode.deopt(InvalidateRecompile, RuntimeConstraint);</span>
<span class="udiff-line-added">+         } else if (registerAsWord(threadRegister) != readInstanceKlassInitThread(klass)) {</span>
<span class="udiff-line-added">+             // The klass is being initialized but this isn&#39;t the initializing thread so</span>
<span class="udiff-line-added">+             // so deopt and allow execution to resume in the interpreter where it should block.</span>
<span class="udiff-line-added">+             DeoptimizeNode.deopt(None, RuntimeConstraint);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Formats some allocated memory with an object header and zeroes out the rest.
       */
<span class="udiff-line-modified-removed">-     private static Object formatArray(KlassPointer hub, long allocationSize, int length, int headerSize, Word memory, Word prototypeMarkWord, boolean fillContents, boolean maybeUnroll,</span>
<span class="udiff-line-modified-added">+     private static Object formatArray(KlassPointer hub,</span>
<span class="udiff-line-added">+                     long allocationSize,</span>
<span class="udiff-line-added">+                     int length,</span>
<span class="udiff-line-added">+                     int headerSize,</span>
<span class="udiff-line-added">+                     Word memory,</span>
<span class="udiff-line-added">+                     Word prototypeMarkWord,</span>
<span class="udiff-line-added">+                     boolean fillContents,</span>
<span class="udiff-line-added">+                     boolean emitMemoryBarrier,</span>
<span class="udiff-line-added">+                     boolean maybeUnroll,</span>
<span class="udiff-line-added">+                     boolean supportsBulkZeroing,</span>
                      Counters counters) {
          memory.writeInt(arrayLengthOffset(INJECTED_VMCONFIG), length, LocationIdentity.init());
          /*
           * store hub last as the concurrent garbage collectors assume length is valid if hub field
           * is not null
           */
          initializeObjectHeader(memory, prototypeMarkWord, hub);
          if (fillContents) {
<span class="udiff-line-modified-removed">-             zeroMemory(allocationSize, memory, false, headerSize, maybeUnroll, counters);</span>
<span class="udiff-line-modified-added">+             zeroMemory(memory, headerSize, allocationSize, false, maybeUnroll, supportsBulkZeroing, counters);</span>
          } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {
<span class="udiff-line-modified-removed">-             fillWithGarbage(allocationSize, memory, false, headerSize, maybeUnroll, counters);</span>
<span class="udiff-line-modified-added">+             fillWithGarbage(memory, headerSize, allocationSize, false, maybeUnroll, counters);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (emitMemoryBarrier) {</span>
<span class="udiff-line-added">+             MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
          }
<span class="udiff-line-removed">-         MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
          return memory.toObjectNonNull();
      }
  
      static class Counters {
          Counters(SnippetCounter.Group.Factory factory) {
              Group newInstance = factory.createSnippetCounterGroup(&quot;NewInstance&quot;);
              Group newArray = factory.createSnippetCounterGroup(&quot;NewArray&quot;);
              instanceSeqInit = new SnippetCounter(newInstance, &quot;tlabSeqInit&quot;, &quot;TLAB alloc with unrolled zeroing&quot;);
              instanceLoopInit = new SnippetCounter(newInstance, &quot;tlabLoopInit&quot;, &quot;TLAB alloc with zeroing in a loop&quot;);
<span class="udiff-line-added">+             instanceBulkInit = new SnippetCounter(newArray, &quot;tlabBulkInit&quot;, &quot;TLAB alloc with bulk zeroing&quot;);</span>
              arrayLoopInit = new SnippetCounter(newArray, &quot;tlabLoopInit&quot;, &quot;TLAB alloc with zeroing in a loop&quot;);
              stub = new SnippetCounter(newInstance, &quot;stub&quot;, &quot;alloc and zeroing via stub&quot;);
          }
  
          final SnippetCounter instanceSeqInit;
          final SnippetCounter instanceLoopInit;
<span class="udiff-line-added">+         final SnippetCounter instanceBulkInit;</span>
          final SnippetCounter arrayLoopInit;
          final SnippetCounter stub;
      }
  
      public static class Templates extends AbstractTemplates {
  
<span class="udiff-line-modified-removed">-         private final SnippetInfo allocateInstance = snippet(NewObjectSnippets.class, &quot;allocateInstance&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);</span>
<span class="udiff-line-modified-added">+         private final SnippetInfo allocateInstance = snippet(NewObjectSnippets.class, &quot;allocateInstance&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION,</span>
<span class="udiff-line-added">+                         PROTOTYPE_MARK_WORD_LOCATION);</span>
          private final SnippetInfo allocateInstancePIC = snippet(NewObjectSnippets.class, &quot;allocateInstancePIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
<span class="udiff-line-modified-removed">-                         TLAB_END_LOCATION);</span>
<span class="udiff-line-modified-added">+                         TLAB_END_LOCATION, PROTOTYPE_MARK_WORD_LOCATION);</span>
          private final SnippetInfo allocateArray = snippet(NewObjectSnippets.class, &quot;allocateArray&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
          private final SnippetInfo allocateArrayPIC = snippet(NewObjectSnippets.class, &quot;allocateArrayPIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
          private final SnippetInfo allocatePrimitiveArrayPIC = snippet(NewObjectSnippets.class, &quot;allocatePrimitiveArrayPIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
                          TLAB_END_LOCATION);
          private final SnippetInfo allocateArrayDynamic = snippet(NewObjectSnippets.class, &quot;allocateArrayDynamic&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
                          TLAB_END_LOCATION);
          private final SnippetInfo allocateInstanceDynamic = snippet(NewObjectSnippets.class, &quot;allocateInstanceDynamic&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
<span class="udiff-line-modified-removed">-                         TLAB_END_LOCATION);</span>
<span class="udiff-line-modified-added">+                         TLAB_END_LOCATION, PROTOTYPE_MARK_WORD_LOCATION, CLASS_INIT_STATE_LOCATION);</span>
          private final SnippetInfo newmultiarray = snippet(NewObjectSnippets.class, &quot;newmultiarray&quot;, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
          private final SnippetInfo newmultiarrayPIC = snippet(NewObjectSnippets.class, &quot;newmultiarrayPIC&quot;, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
          private final SnippetInfo verifyHeap = snippet(NewObjectSnippets.class, &quot;verifyHeap&quot;);
<span class="udiff-line-added">+         private final SnippetInfo threadBeingInitializedCheck = snippet(NewObjectSnippets.class, &quot;threadBeingInitializedCheck&quot;);</span>
          private final GraalHotSpotVMConfig config;
          private final Counters counters;
  
          public Templates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory factory, HotSpotProviders providers, TargetDescription target,
                          GraalHotSpotVMConfig config) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -705,10 +847,11 @@</span>
              Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
              args.addConst(&quot;size&quot;, size);
              args.add(&quot;hub&quot;, hub);
              args.add(&quot;prototypeMarkWord&quot;, type.prototypeMarkWord());
              args.addConst(&quot;fillContents&quot;, newInstanceNode.fillContents());
<span class="udiff-line-added">+             args.addConst(&quot;emitMemoryBarrier&quot;, newInstanceNode.emitMemoryBarrier());</span>
              args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
              args.addConst(&quot;constantSize&quot;, true);
              args.addConst(&quot;typeContext&quot;, ProfileAllocations.getValue(localOptions) ? type.toJavaName(false) : &quot;&quot;);
              args.addConst(&quot;counters&quot;, counters);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -748,13 +891,15 @@</span>
              assert arrayType.prototypeMarkWord() == lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord() : &quot;all array types are assumed to have the same prototypeMarkWord&quot;;
              args.add(&quot;prototypeMarkWord&quot;, arrayType.prototypeMarkWord());
              args.addConst(&quot;headerSize&quot;, headerSize);
              args.addConst(&quot;log2ElementSize&quot;, log2ElementSize);
              args.addConst(&quot;fillContents&quot;, newArrayNode.fillContents());
<span class="udiff-line-added">+             args.addConst(&quot;emitMemoryBarrier&quot;, newArrayNode.emitMemoryBarrier());</span>
              args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
              args.addConst(&quot;maybeUnroll&quot;, length.isConstant());
              args.addConst(&quot;typeContext&quot;, ProfileAllocations.getValue(localOptions) ? arrayType.toJavaName(false) : &quot;&quot;);
<span class="udiff-line-added">+             args.addConst(&quot;supportsBulkZeroing&quot;, tool.getLowerer().supportsBulkZeroing());</span>
              args.addConst(&quot;counters&quot;, counters);
              SnippetTemplate template = template(newArrayNode, args);
              graph.getDebug().log(&quot;Lowering allocateArray in %s: node=%s, template=%s, arguments=%s&quot;, graph, newArrayNode, template, args);
              template.instantiate(providers.getMetaAccess(), newArrayNode, DEFAULT_REPLACER, args);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -764,27 +909,29 @@</span>
              args.add(&quot;type&quot;, newInstanceNode.getInstanceType());
              ValueNode classClass = newInstanceNode.getClassClass();
              assert classClass != null;
              args.add(&quot;classClass&quot;, classClass);
              args.addConst(&quot;fillContents&quot;, newInstanceNode.fillContents());
<span class="udiff-line-added">+             args.addConst(&quot;emitMemoryBarrier&quot;, newInstanceNode.emitMemoryBarrier());</span>
              args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
              args.addConst(&quot;counters&quot;, counters);
  
              SnippetTemplate template = template(newInstanceNode, args);
              template.instantiate(providers.getMetaAccess(), newInstanceNode, DEFAULT_REPLACER, args);
          }
  
          public void lower(DynamicNewArrayNode newArrayNode, HotSpotRegistersProvider registers, LoweringTool tool) {
              StructuredGraph graph = newArrayNode.graph();
<span class="udiff-line-modified-removed">-             Arguments args = new Arguments(allocateArrayDynamic, newArrayNode.graph().getGuardsStage(), tool.getLoweringStage());</span>
<span class="udiff-line-modified-added">+             Arguments args = new Arguments(allocateArrayDynamic, graph.getGuardsStage(), tool.getLoweringStage());</span>
              args.add(&quot;elementType&quot;, newArrayNode.getElementType());
              ValueNode voidClass = newArrayNode.getVoidClass();
              assert voidClass != null;
              args.add(&quot;voidClass&quot;, voidClass);
              ValueNode length = newArrayNode.length();
              args.add(&quot;length&quot;, length.isAlive() ? length : graph.addOrUniqueWithInputs(length));
              args.addConst(&quot;fillContents&quot;, newArrayNode.fillContents());
<span class="udiff-line-added">+             args.addConst(&quot;emitMemoryBarrier&quot;, newArrayNode.emitMemoryBarrier());</span>
              args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
              /*
               * We use Kind.Illegal as a marker value instead of null because constant snippet
               * parameters cannot be null.
               */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -792,10 +939,11 @@</span>
              if (newArrayNode.getKnownElementKind() != null) {
                  args.addConst(&quot;knownLayoutHelper&quot;, lookupArrayClass(tool, newArrayNode.getKnownElementKind()).layoutHelper());
              } else {
                  args.addConst(&quot;knownLayoutHelper&quot;, 0);
              }
<span class="udiff-line-added">+             args.addConst(&quot;supportsBulkZeroing&quot;, tool.getLowerer().supportsBulkZeroing());</span>
              args.add(&quot;prototypeMarkWord&quot;, lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord());
              args.addConst(&quot;counters&quot;, counters);
              SnippetTemplate template = template(newArrayNode, args);
              template.instantiate(providers.getMetaAccess(), newArrayNode, DEFAULT_REPLACER, args);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -838,7 +986,16 @@</span>
                  template.instantiate(providers.getMetaAccess(), verifyHeapNode, DEFAULT_REPLACER, args);
              } else {
                  GraphUtil.removeFixedWithUnusedInputs(verifyHeapNode);
              }
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public void lower(KlassBeingInitializedCheckNode verifyHeapNode, HotSpotRegistersProvider registers, LoweringTool tool) {</span>
<span class="udiff-line-added">+             Arguments args = new Arguments(threadBeingInitializedCheck, verifyHeapNode.graph().getGuardsStage(), tool.getLoweringStage());</span>
<span class="udiff-line-added">+             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());</span>
<span class="udiff-line-added">+             args.add(&quot;klass&quot;, verifyHeapNode.getKlass());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             SnippetTemplate template = template(verifyHeapNode, args);</span>
<span class="udiff-line-added">+             template.instantiate(providers.getMetaAccess(), verifyHeapNode, DEFAULT_REPLACER, args);</span>
<span class="udiff-line-added">+         }</span>
      }
  }
</pre>
<center><a href="MonitorSnippets.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ObjectCloneNode.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
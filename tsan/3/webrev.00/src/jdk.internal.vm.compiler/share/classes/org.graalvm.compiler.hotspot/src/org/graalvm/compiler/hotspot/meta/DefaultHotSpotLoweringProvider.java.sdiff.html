<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/DefaultHotSpotLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AddressLoweringHotSpotSuitesProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotForeignCallsProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/DefaultHotSpotLoweringProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42 
 43 import java.lang.ref.Reference;
 44 import java.util.EnumMap;
 45 
 46 import org.graalvm.compiler.api.directives.GraalDirectives;
 47 import org.graalvm.compiler.core.common.CompressEncoding;
 48 import org.graalvm.compiler.core.common.GraalOptions;
 49 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 50 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 51 import org.graalvm.compiler.core.common.type.ObjectStamp;
 52 import org.graalvm.compiler.core.common.type.Stamp;
 53 import org.graalvm.compiler.core.common.type.StampFactory;
 54 import org.graalvm.compiler.core.common.type.StampPair;
 55 import org.graalvm.compiler.debug.DebugCloseable;
 56 import org.graalvm.compiler.debug.DebugHandlersFactory;
 57 import org.graalvm.compiler.debug.GraalError;
 58 import org.graalvm.compiler.graph.Node;
 59 import org.graalvm.compiler.graph.NodeInputList;
 60 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 61 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
<span class="line-removed"> 62 import org.graalvm.compiler.hotspot.gc.g1.G1ArrayRangePostWriteBarrier;</span>
<span class="line-removed"> 63 import org.graalvm.compiler.hotspot.gc.g1.G1ArrayRangePreWriteBarrier;</span>
<span class="line-removed"> 64 import org.graalvm.compiler.hotspot.gc.g1.G1PostWriteBarrier;</span>
<span class="line-removed"> 65 import org.graalvm.compiler.hotspot.gc.g1.G1PreWriteBarrier;</span>
<span class="line-removed"> 66 import org.graalvm.compiler.hotspot.gc.g1.G1ReferentFieldReadBarrier;</span>
<span class="line-removed"> 67 import org.graalvm.compiler.hotspot.gc.shared.SerialArrayRangeWriteBarrier;</span>
<span class="line-removed"> 68 import org.graalvm.compiler.hotspot.gc.shared.SerialWriteBarrier;</span>
 69 import org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode;
 70 import org.graalvm.compiler.hotspot.nodes.HotSpotCompressionNode;
 71 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 72 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;

 73 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 74 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 75 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 76 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
 77 import org.graalvm.compiler.hotspot.nodes.profiling.ProfileNode;
 78 import org.graalvm.compiler.hotspot.nodes.type.HotSpotNarrowOopStamp;
 79 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 80 import org.graalvm.compiler.hotspot.nodes.type.MethodPointerStamp;
 81 import org.graalvm.compiler.hotspot.replacements.AssertionSnippets;
 82 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;

 83 import org.graalvm.compiler.hotspot.replacements.HashCodeSnippets;


 84 import org.graalvm.compiler.hotspot.replacements.HubGetClassNode;
 85 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 86 import org.graalvm.compiler.hotspot.replacements.InstanceOfSnippets;
 87 import org.graalvm.compiler.hotspot.replacements.KlassLayoutHelperNode;
 88 import org.graalvm.compiler.hotspot.replacements.LoadExceptionObjectSnippets;
 89 import org.graalvm.compiler.hotspot.replacements.MonitorSnippets;
 90 import org.graalvm.compiler.hotspot.replacements.NewObjectSnippets;
 91 import org.graalvm.compiler.hotspot.replacements.ObjectCloneSnippets;

 92 import org.graalvm.compiler.hotspot.replacements.StringToBytesSnippets;

 93 import org.graalvm.compiler.hotspot.replacements.UnsafeLoadSnippets;
<span class="line-modified"> 94 import org.graalvm.compiler.hotspot.replacements.WriteBarrierSnippets;</span>
 95 import org.graalvm.compiler.hotspot.replacements.aot.ResolveConstantSnippets;
 96 import org.graalvm.compiler.hotspot.replacements.arraycopy.HotSpotArraycopySnippets;
 97 import org.graalvm.compiler.hotspot.replacements.profiling.ProfileSnippets;
 98 import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets;
 99 import org.graalvm.compiler.hotspot.word.KlassPointer;
100 import org.graalvm.compiler.nodes.AbstractBeginNode;
101 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
102 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
103 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
104 import org.graalvm.compiler.nodes.ConstantNode;
105 import org.graalvm.compiler.nodes.FixedNode;
106 import org.graalvm.compiler.nodes.GetObjectAddressNode;
107 import org.graalvm.compiler.nodes.Invoke;
108 import org.graalvm.compiler.nodes.LogicNode;
109 import org.graalvm.compiler.nodes.LoweredCallTargetNode;
110 import org.graalvm.compiler.nodes.NodeView;
111 import org.graalvm.compiler.nodes.ParameterNode;
112 import org.graalvm.compiler.nodes.SafepointNode;
113 import org.graalvm.compiler.nodes.StartNode;
114 import org.graalvm.compiler.nodes.StructuredGraph;

115 import org.graalvm.compiler.nodes.UnwindNode;
116 import org.graalvm.compiler.nodes.ValueNode;
117 import org.graalvm.compiler.nodes.calc.AddNode;
118 import org.graalvm.compiler.nodes.calc.FloatingNode;
119 import org.graalvm.compiler.nodes.calc.IntegerDivRemNode;
120 import org.graalvm.compiler.nodes.calc.IsNullNode;
121 import org.graalvm.compiler.nodes.calc.RemNode;
122 import org.graalvm.compiler.nodes.debug.StringToBytesNode;
123 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
124 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
125 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
126 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
127 import org.graalvm.compiler.nodes.extended.GetClassNode;
<span class="line-removed">128 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;</span>
129 import org.graalvm.compiler.nodes.extended.LoadHubNode;
130 import org.graalvm.compiler.nodes.extended.LoadMethodNode;
131 import org.graalvm.compiler.nodes.extended.OSRLocalNode;
132 import org.graalvm.compiler.nodes.extended.OSRLockNode;
133 import org.graalvm.compiler.nodes.extended.OSRMonitorEnterNode;
134 import org.graalvm.compiler.nodes.extended.OSRStartNode;
<span class="line-removed">135 import org.graalvm.compiler.nodes.extended.RawLoadNode;</span>
136 import org.graalvm.compiler.nodes.extended.StoreHubNode;







137 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
138 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
139 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
140 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
141 import org.graalvm.compiler.nodes.java.InstanceOfNode;
142 import org.graalvm.compiler.nodes.java.LoadExceptionObjectNode;
143 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
144 import org.graalvm.compiler.nodes.java.MonitorExitNode;
145 import org.graalvm.compiler.nodes.java.MonitorIdNode;
146 import org.graalvm.compiler.nodes.java.NewArrayNode;
147 import org.graalvm.compiler.nodes.java.NewInstanceNode;
148 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
149 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
150 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
151 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
152 import org.graalvm.compiler.nodes.memory.ReadNode;
153 import org.graalvm.compiler.nodes.memory.WriteNode;
154 import org.graalvm.compiler.nodes.memory.address.AddressNode;
155 import org.graalvm.compiler.nodes.spi.LoweringProvider;
156 import org.graalvm.compiler.nodes.spi.LoweringTool;
157 import org.graalvm.compiler.nodes.spi.StampProvider;
158 import org.graalvm.compiler.nodes.type.StampTool;
159 import org.graalvm.compiler.nodes.util.GraphUtil;
160 import org.graalvm.compiler.options.OptionValues;
161 import org.graalvm.compiler.replacements.DefaultJavaLoweringProvider;
162 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
163 import org.graalvm.compiler.replacements.arraycopy.ArrayCopySnippets;
<span class="line-modified">164 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyWithSlowPathNode;</span>
165 import org.graalvm.compiler.replacements.nodes.AssertionNode;
166 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
167 import jdk.internal.vm.compiler.word.LocationIdentity;
168 
169 import jdk.vm.ci.code.TargetDescription;
170 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
171 import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;
172 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
173 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
174 import jdk.vm.ci.meta.JavaConstant;
175 import jdk.vm.ci.meta.JavaKind;
176 import jdk.vm.ci.meta.JavaType;
177 import jdk.vm.ci.meta.MetaAccessProvider;
178 import jdk.vm.ci.meta.ResolvedJavaField;
179 import jdk.vm.ci.meta.ResolvedJavaType;
180 
181 /**
182  * HotSpot implementation of {@link LoweringProvider}.
183  */
<span class="line-modified">184 public class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {</span>
185 
186     protected final HotSpotGraalRuntimeProvider runtime;
187     protected final HotSpotRegistersProvider registers;
188     protected final HotSpotConstantReflectionProvider constantReflection;
189 
190     protected InstanceOfSnippets.Templates instanceofSnippets;
191     protected NewObjectSnippets.Templates newObjectSnippets;
192     protected MonitorSnippets.Templates monitorSnippets;
<span class="line-modified">193     protected WriteBarrierSnippets.Templates writeBarrierSnippets;</span>

194     protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;
195     protected UnsafeLoadSnippets.Templates unsafeLoadSnippets;
196     protected AssertionSnippets.Templates assertionSnippets;
197     protected ArrayCopySnippets.Templates arraycopySnippets;
198     protected StringToBytesSnippets.Templates stringToBytesSnippets;
199     protected HashCodeSnippets.Templates hashCodeSnippets;
200     protected ResolveConstantSnippets.Templates resolveConstantSnippets;
201     protected ProfileSnippets.Templates profileSnippets;
<span class="line-modified">202 </span>

203     protected ObjectCloneSnippets.Templates objectCloneSnippets;
204     protected ForeignCallSnippets.Templates foreignCallSnippets;
205 
206     public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers,
207                     HotSpotConstantReflectionProvider constantReflection, TargetDescription target) {
208         super(metaAccess, foreignCalls, target, runtime.getVMConfig().useCompressedOops);
209         this.runtime = runtime;
210         this.registers = registers;
211         this.constantReflection = constantReflection;

212     }
213 
214     @Override
215     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {
216         super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());
217 
218         assert target == providers.getCodeCache().getTarget();
219         instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);
220         newObjectSnippets = new NewObjectSnippets.Templates(options, factories, runtime, providers, target, config);
221         monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);
<span class="line-modified">222         writeBarrierSnippets = new WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);</span>

223         exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);
224         unsafeLoadSnippets = new UnsafeLoadSnippets.Templates(options, factories, providers, target);
225         assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);
226         arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);
227         stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);
228         hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);
229         resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);
<span class="line-removed">230         if (!JavaVersionUtil.Java8OrEarlier) {</span>
<span class="line-removed">231             profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);</span>
<span class="line-removed">232         }</span>
233         objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);
234         foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);












235     }
236 
237     public MonitorSnippets.Templates getMonitorSnippets() {
238         return monitorSnippets;
239     }
240 
241     @Override
242     @SuppressWarnings(&quot;try&quot;)
243     public void lower(Node n, LoweringTool tool) {
244         StructuredGraph graph = (StructuredGraph) n.graph();
245         try (DebugCloseable context = n.withNodeSourcePosition()) {
246             if (n instanceof Invoke) {
247                 lowerInvoke((Invoke) n, tool, graph);
248             } else if (n instanceof LoadMethodNode) {
249                 lowerLoadMethodNode((LoadMethodNode) n);
250             } else if (n instanceof GetClassNode) {
251                 lowerGetClassNode((GetClassNode) n, tool, graph);
252             } else if (n instanceof StoreHubNode) {
253                 lowerStoreHubNode((StoreHubNode) n, graph);
254             } else if (n instanceof OSRStartNode) {
</pre>
<hr />
<pre>
315                     ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);
316                     dynamicNewArrayNode.setVoidClass(voidClass);
317                 }
318                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
319                     newObjectSnippets.lower(dynamicNewArrayNode, registers, tool);
320                 }
321             } else if (n instanceof VerifyHeapNode) {
322                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
323                     newObjectSnippets.lower((VerifyHeapNode) n, registers, tool);
324                 }
325             } else if (n instanceof RawMonitorEnterNode) {
326                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
327                     monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);
328                 }
329             } else if (n instanceof MonitorExitNode) {
330                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
331                     monitorSnippets.lower((MonitorExitNode) n, registers, tool);
332                 }
333             } else if (n instanceof ArrayCopyNode) {
334                 arraycopySnippets.lower((ArrayCopyNode) n, tool);
<span class="line-modified">335             } else if (n instanceof ArrayCopyWithSlowPathNode) {</span>
<span class="line-modified">336                 arraycopySnippets.lower((ArrayCopyWithSlowPathNode) n, tool);</span>
337             } else if (n instanceof G1PreWriteBarrier) {
<span class="line-modified">338                 writeBarrierSnippets.lower((G1PreWriteBarrier) n, registers, tool);</span>
339             } else if (n instanceof G1PostWriteBarrier) {
<span class="line-modified">340                 writeBarrierSnippets.lower((G1PostWriteBarrier) n, registers, tool);</span>
341             } else if (n instanceof G1ReferentFieldReadBarrier) {
<span class="line-modified">342                 writeBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, registers, tool);</span>
343             } else if (n instanceof SerialWriteBarrier) {
<span class="line-modified">344                 writeBarrierSnippets.lower((SerialWriteBarrier) n, tool);</span>
345             } else if (n instanceof SerialArrayRangeWriteBarrier) {
<span class="line-modified">346                 writeBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);</span>
347             } else if (n instanceof G1ArrayRangePreWriteBarrier) {
<span class="line-modified">348                 writeBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, registers, tool);</span>
349             } else if (n instanceof G1ArrayRangePostWriteBarrier) {
<span class="line-modified">350                 writeBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, registers, tool);</span>
351             } else if (n instanceof NewMultiArrayNode) {
352                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
353                     newObjectSnippets.lower((NewMultiArrayNode) n, tool);
354                 }
355             } else if (n instanceof LoadExceptionObjectNode) {
356                 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);
357             } else if (n instanceof AssertionNode) {
358                 assertionSnippets.lower((AssertionNode) n, tool);
359             } else if (n instanceof StringToBytesNode) {
360                 if (graph.getGuardsStage().areDeoptsFixed()) {
361                     stringToBytesSnippets.lower((StringToBytesNode) n, tool);
362                 }
363             } else if (n instanceof IntegerDivRemNode) {
364                 // Nothing to do for division nodes. The HotSpot signal handler catches divisions by
365                 // zero and the MIN_VALUE / -1 cases.
366             } else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {
367                 /* No lowering, we generate LIR directly for these nodes. */
368             } else if (n instanceof ClassGetHubNode) {
369                 lowerClassGetHubNode((ClassGetHubNode) n, tool);
370             } else if (n instanceof HubGetClassNode) {
</pre>
<hr />
<pre>
378             } else if (n instanceof IdentityHashCodeNode) {
379                 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);
380             } else if (n instanceof ResolveDynamicConstantNode) {
381                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
382                     resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);
383                 }
384             } else if (n instanceof ResolveConstantNode) {
385                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
386                     resolveConstantSnippets.lower((ResolveConstantNode) n, tool);
387                 }
388             } else if (n instanceof ResolveMethodAndLoadCountersNode) {
389                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
390                     resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);
391                 }
392             } else if (n instanceof InitializeKlassNode) {
393                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
394                     resolveConstantSnippets.lower((InitializeKlassNode) n, tool);
395                 }
396             } else if (n instanceof ProfileNode) {
397                 profileSnippets.lower((ProfileNode) n, tool);










398             } else {
399                 super.lower(n, tool);
400             }
401         }

402     }
403 
404     private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {
405         /*
406          * Lower the node into a ComputeObjectAddress node and an Add but ensure that it&#39;s below any
407          * potential safepoints and above it&#39;s uses.
408          */
409         for (Node use : n.usages().snapshot()) {
410             if (use instanceof FixedNode) {
411                 FixedNode fixed = (FixedNode) use;
412                 StructuredGraph graph = n.graph();
413                 GetObjectAddressNode address = graph.add(new GetObjectAddressNode(n.getObject()));
414                 graph.addBeforeFixed(fixed, address);
415                 AddNode add = graph.addOrUnique(new AddNode(address, n.getOffset()));
416                 use.replaceFirstInput(n, add);
417             } else {
418                 throw GraalError.shouldNotReachHere(&quot;Unexpected floating use of ComputeObjectAddressNode &quot; + n);
419             }
420         }
421         GraphUtil.unlinkFixedNode(n);
</pre>
<hr />
<pre>
451         }
452         n.replaceAtUsagesAndDelete(read);
453     }
454 
455     private void lowerClassGetHubNode(ClassGetHubNode n, LoweringTool tool) {
456         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
457             return;
458         }
459 
460         StructuredGraph graph = n.graph();
461         assert !n.getValue().isConstant();
462         AddressNode address = createOffsetAddress(graph, n.getValue(), runtime.getVMConfig().klassOffset);
463         FloatingReadNode read = graph.unique(new FloatingReadNode(address, CLASS_KLASS_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
464         n.replaceAtUsagesAndDelete(read);
465     }
466 
467     private void lowerInvoke(Invoke invoke, LoweringTool tool, StructuredGraph graph) {
468         if (invoke.callTarget() instanceof MethodCallTargetNode) {
469             MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
470             NodeInputList&lt;ValueNode&gt; parameters = callTarget.arguments();
<span class="line-modified">471             ValueNode receiver = parameters.size() &lt;= 0 ? null : parameters.get(0);</span>
<span class="line-modified">472             if (!callTarget.isStatic() &amp;&amp; receiver.stamp(NodeView.DEFAULT) instanceof ObjectStamp &amp;&amp; !StampTool.isPointerNonNull(receiver)) {</span>
<span class="line-modified">473                 ValueNode nonNullReceiver = createNullCheckedValue(receiver, invoke.asNode(), tool);</span>
<span class="line-modified">474                 parameters.set(0, nonNullReceiver);</span>
<span class="line-modified">475                 receiver = nonNullReceiver;</span>




476             }
477             JavaType[] signature = callTarget.targetMethod().getSignature().toParameterTypes(callTarget.isStatic() ? null : callTarget.targetMethod().getDeclaringClass());
478 
479             LoweredCallTargetNode loweredCallTarget = null;
480             OptionValues options = graph.getOptions();
481             if (InlineVTableStubs.getValue(options) &amp;&amp; callTarget.invokeKind().isIndirect() &amp;&amp; (AlwaysInlineVTableStubs.getValue(options) || invoke.isPolymorphic())) {
482                 HotSpotResolvedJavaMethod hsMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();
483                 ResolvedJavaType receiverType = invoke.getReceiverType();
484                 if (hsMethod.isInVirtualMethodTable(receiverType)) {
485                     JavaKind wordKind = runtime.getTarget().wordJavaKind;
486                     ValueNode hub = createReadHub(graph, receiver, tool);
487 
488                     ReadNode metaspaceMethod = createReadVirtualMethod(graph, hub, hsMethod, receiverType);
489                     // We use LocationNode.ANY_LOCATION for the reads that access the
490                     // compiled code entry as HotSpot does not guarantee they are final
491                     // values.
492                     int methodCompiledEntryOffset = runtime.getVMConfig().methodCompiledEntryOffset;
493                     AddressNode address = createOffsetAddress(graph, metaspaceMethod, methodCompiledEntryOffset);
494                     ReadNode compiledEntry = graph.add(new ReadNode(address, any(), StampFactory.forKind(wordKind), BarrierType.NONE));
495 
</pre>
<hr />
<pre>
526         return new HotSpotCompressionNode(op, value, getOopEncoding());
527     }
528 
529     @Override
530     public ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField f) {
531         HotSpotResolvedJavaField field = (HotSpotResolvedJavaField) f;
532         JavaConstant base = constantReflection.asJavaClass(field.getDeclaringClass());
533         return ConstantNode.forConstant(base, metaAccess, graph);
534     }
535 
536     @Override
537     protected ValueNode createReadArrayComponentHub(StructuredGraph graph, ValueNode arrayHub, FixedNode anchor) {
538         /*
539          * Anchor the read of the element klass to the cfg, because it is only valid when arrayClass
540          * is an object class, which might not be the case in other parts of the compiled method.
541          */
542         AddressNode address = createOffsetAddress(graph, arrayHub, runtime.getVMConfig().arrayClassElementOffset);
543         return graph.unique(new FloatingReadNode(address, OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION, null, KlassPointerStamp.klassNonNull(), AbstractBeginNode.prevBegin(anchor)));
544     }
545 
<span class="line-removed">546     @Override</span>
<span class="line-removed">547     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {</span>
<span class="line-removed">548         StructuredGraph graph = load.graph();</span>
<span class="line-removed">549         if (!(load instanceof GuardedUnsafeLoadNode) &amp;&amp; !graph.getGuardsStage().allowsFloatingGuards() &amp;&amp; addReadBarrier(load)) {</span>
<span class="line-removed">550             unsafeLoadSnippets.lower(load, tool);</span>
<span class="line-removed">551         } else {</span>
<span class="line-removed">552             super.lowerUnsafeLoadNode(load, tool);</span>
<span class="line-removed">553         }</span>
<span class="line-removed">554     }</span>
<span class="line-removed">555 </span>
556     private void lowerLoadMethodNode(LoadMethodNode loadMethodNode) {
557         StructuredGraph graph = loadMethodNode.graph();
558         HotSpotResolvedJavaMethod method = (HotSpotResolvedJavaMethod) loadMethodNode.getMethod();
559         ReadNode metaspaceMethod = createReadVirtualMethod(graph, loadMethodNode.getHub(), method, loadMethodNode.getReceiverType());
560         graph.replaceFixed(loadMethodNode, metaspaceMethod);
561     }
562 
563     private static void lowerGetClassNode(GetClassNode getClass, LoweringTool tool, StructuredGraph graph) {
564         StampProvider stampProvider = tool.getStampProvider();
565         LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, getClass.getObject()));
566         HubGetClassNode hubGetClass = graph.unique(new HubGetClassNode(tool.getMetaAccess(), hub));
567         getClass.replaceAtUsagesAndDelete(hubGetClass);
568         hub.lower(tool);
569         hubGetClass.lower(tool);
570     }
571 
572     private void lowerStoreHubNode(StoreHubNode storeHub, StructuredGraph graph) {
573         WriteNode hub = createWriteHub(graph, storeHub.getObject(), storeHub.getValue());
574         graph.replaceFixed(storeHub, hub);
575     }
576 
<span class="line-removed">577     @Override</span>
<span class="line-removed">578     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {</span>
<span class="line-removed">579         return (entryKind == JavaKind.Object &amp;&amp; !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.IMPRECISE : BarrierType.NONE;</span>
<span class="line-removed">580     }</span>
<span class="line-removed">581 </span>
<span class="line-removed">582     @Override</span>
<span class="line-removed">583     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {</span>
<span class="line-removed">584         return (entryKind == JavaKind.Object &amp;&amp; !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.PRECISE : BarrierType.NONE;</span>
<span class="line-removed">585     }</span>
<span class="line-removed">586 </span>
587     private void lowerOSRStartNode(OSRStartNode osrStart) {
588         StructuredGraph graph = osrStart.graph();
589         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
590             StartNode newStart = graph.add(new StartNode());
591             ParameterNode buffer = graph.addWithoutUnique(new ParameterNode(0, StampPair.createSingle(StampFactory.forKind(runtime.getTarget().wordJavaKind))));
592             ForeignCallNode migrationEnd = graph.add(new ForeignCallNode(foreignCalls, OSR_MIGRATION_END, buffer));
593             migrationEnd.setStateAfter(osrStart.stateAfter());
594             newStart.setNext(migrationEnd);
595             FixedNode next = osrStart.next();
596             osrStart.setNext(null);
597             migrationEnd.setNext(next);
598             graph.setStart(newStart);
599 
600             final int wordSize = target.wordSize;
601 
602             // @formatter:off
603             // taken from c2 locals_addr = osr_buf + (max_locals-1)*wordSize)
604             // @formatter:on
605             int localsOffset = (graph.method().getMaxLocals() - 1) * wordSize;
606             for (OSRLocalNode osrLocal : graph.getNodes(OSRLocalNode.TYPE)) {
</pre>
<hr />
<pre>
622             // buffer
623             for (OSRMonitorEnterNode osrMonitorEnter : graph.getNodes(OSRMonitorEnterNode.TYPE)) {
624                 MonitorIdNode monitorID = osrMonitorEnter.getMonitorId();
625                 OSRLockNode lock = (OSRLockNode) osrMonitorEnter.object();
626                 final int index = lock.index();
627 
628                 final int offsetDisplacedHeader = locksOffset - ((index * 2) + 1) * wordSize;
629                 final int offsetLockObject = locksOffset - index * 2 * wordSize;
630 
631                 // load the displaced mark from the osr buffer
632                 AddressNode addressDisplacedHeader = createOffsetAddress(graph, buffer, offsetDisplacedHeader);
633                 ReadNode loadDisplacedHeader = graph.add(new ReadNode(addressDisplacedHeader, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
634                 graph.addBeforeFixed(migrationEnd, loadDisplacedHeader);
635 
636                 // we need to initialize the stack slot for the lock
637                 BeginLockScopeNode beginLockScope = graph.add(new BeginLockScopeNode(lock.getStackKind(), monitorID.getLockDepth()));
638                 graph.addBeforeFixed(migrationEnd, beginLockScope);
639 
640                 // write the displaced mark to the correct stack slot
641                 AddressNode addressDisplacedMark = createOffsetAddress(graph, beginLockScope, runtime.getVMConfig().basicLockDisplacedHeaderOffset);
<span class="line-modified">642                 WriteNode writeStackSlot = graph.add(new WriteNode(addressDisplacedMark, DISPLACED_MARK_WORD_LOCATION, loadDisplacedHeader, BarrierType.NONE));</span>
643                 graph.addBeforeFixed(migrationEnd, writeStackSlot);
644 
645                 // load the lock object from the osr buffer
646                 AddressNode addressLockObject = createOffsetAddress(graph, buffer, offsetLockObject);
647                 ReadNode loadObject = graph.add(new ReadNode(addressLockObject, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
648                 lock.replaceAndDelete(loadObject);
649                 graph.addBeforeFixed(migrationEnd, loadObject);
650             }
651 
652             osrStart.replaceAtUsagesAndDelete(newStart);
653         }
654     }
655 
656     static final class Exceptions {
657         protected static final EnumMap&lt;BytecodeExceptionKind, RuntimeException&gt; cachedExceptions;
658 
659         static {
660             cachedExceptions = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);
661             cachedExceptions.put(BytecodeExceptionKind.NULL_POINTER, clearStackTrace(new NullPointerException()));
662             cachedExceptions.put(BytecodeExceptionKind.OUT_OF_BOUNDS, clearStackTrace(new ArrayIndexOutOfBoundsException()));
</pre>
<hr />
<pre>
692         }
693         Throwable exception = Exceptions.cachedExceptions.get(node.getExceptionKind());
694         assert exception != null;
695 
696         StructuredGraph graph = node.graph();
697         FloatingNode exceptionNode = ConstantNode.forConstant(constantReflection.forObject(exception), metaAccess, graph);
698         graph.replaceFixedWithFloating(node, exceptionNode);
699     }
700 
701     private void lowerBytecodeExceptionNode(BytecodeExceptionNode node) {
702         if (OmitHotExceptionStacktrace.getValue(node.getOptions())) {
703             throwCachedException(node);
704             return;
705         }
706 
707         ForeignCallDescriptor descriptor = RuntimeCalls.runtimeCalls.get(node.getExceptionKind());
708         assert descriptor != null;
709 
710         StructuredGraph graph = node.graph();
711         ForeignCallNode foreignCallNode = graph.add(new ForeignCallNode(foreignCalls, descriptor, node.stamp(NodeView.DEFAULT), node.getArguments()));







712         graph.replaceFixedWithFixed(node, foreignCallNode);
713     }
714 
<span class="line-removed">715     private boolean addReadBarrier(RawLoadNode load) {</span>
<span class="line-removed">716         if (runtime.getVMConfig().useG1GC &amp;&amp; load.graph().getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS &amp;&amp; load.object().getStackKind() == JavaKind.Object &amp;&amp;</span>
<span class="line-removed">717                         load.accessKind() == JavaKind.Object &amp;&amp; !StampTool.isPointerAlwaysNull(load.object())) {</span>
<span class="line-removed">718             ResolvedJavaType type = StampTool.typeOrNull(load.object());</span>
<span class="line-removed">719             if (type != null &amp;&amp; !type.isArray()) {</span>
<span class="line-removed">720                 return true;</span>
<span class="line-removed">721             }</span>
<span class="line-removed">722         }</span>
<span class="line-removed">723         return false;</span>
<span class="line-removed">724     }</span>
<span class="line-removed">725 </span>
726     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, HotSpotResolvedJavaMethod method, ResolvedJavaType receiverType) {
727         return createReadVirtualMethod(graph, hub, method.vtableEntryOffset(receiverType));
728     }
729 
730     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, int vtableEntryOffset) {
731         assert vtableEntryOffset &gt; 0;
732         // We use LocationNode.ANY_LOCATION for the reads that access the vtable
733         // entry as HotSpot does not guarantee that this is a final value.
734         Stamp methodStamp = MethodPointerStamp.methodNonNull();
735         AddressNode address = createOffsetAddress(graph, hub, vtableEntryOffset);
736         ReadNode metaspaceMethod = graph.add(new ReadNode(address, any(), methodStamp, BarrierType.NONE));
737         return metaspaceMethod;
738     }
739 
740     @Override
741     protected ValueNode createReadHub(StructuredGraph graph, ValueNode object, LoweringTool tool) {
742         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
743             return graph.unique(new LoadHubNode(tool.getStampProvider(), object));
744         }
745         assert !object.isConstant() || object.isNullConstant();
</pre>
<hr />
<pre>
751 
752         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
753         LocationIdentity hubLocation = runtime.getVMConfig().useCompressedClassPointers ? COMPRESSED_HUB_LOCATION : HUB_LOCATION;
754         FloatingReadNode memoryRead = graph.unique(new FloatingReadNode(address, hubLocation, null, hubStamp, null, BarrierType.NONE));
755         if (runtime.getVMConfig().useCompressedClassPointers) {
756             return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());
757         } else {
758             return memoryRead;
759         }
760     }
761 
762     private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {
763         assert !object.isConstant() || object.asConstant().isDefaultForKind();
764 
765         ValueNode writeValue = value;
766         if (runtime.getVMConfig().useCompressedClassPointers) {
767             writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());
768         }
769 
770         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
<span class="line-modified">771         return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE));</span>
772     }
773 
774     @Override
775     protected BarrierType fieldLoadBarrierType(ResolvedJavaField f) {
776         HotSpotResolvedJavaField loadField = (HotSpotResolvedJavaField) f;
<span class="line-modified">777         BarrierType barrierType = BarrierType.NONE;</span>
<span class="line-removed">778         if (runtime.getVMConfig().useG1GC &amp;&amp; loadField.getJavaKind() == JavaKind.Object &amp;&amp; metaAccess.lookupJavaType(Reference.class).equals(loadField.getDeclaringClass()) &amp;&amp;</span>
779                         loadField.getName().equals(&quot;referent&quot;)) {
<span class="line-modified">780             barrierType = BarrierType.PRECISE;</span>
781         }
<span class="line-modified">782         return barrierType;</span>
783     }
784 
785     @Override
786     public int fieldOffset(ResolvedJavaField f) {
787         return f.getOffset();
788     }
789 
790     @Override
791     public int arrayLengthOffset() {
792         return runtime.getVMConfig().arrayOopDescLengthOffset();
793     }
794 
795     @Override
796     protected final JavaKind getStorageKind(ResolvedJavaField field) {
797         return field.getJavaKind();
798     }
799 
800     @Override
801     public ObjectCloneSnippets.Templates getObjectCloneSnippets() {
802         return objectCloneSnippets;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 42 
 43 import java.lang.ref.Reference;
 44 import java.util.EnumMap;
 45 
 46 import org.graalvm.compiler.api.directives.GraalDirectives;
 47 import org.graalvm.compiler.core.common.CompressEncoding;
 48 import org.graalvm.compiler.core.common.GraalOptions;
 49 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 50 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 51 import org.graalvm.compiler.core.common.type.ObjectStamp;
 52 import org.graalvm.compiler.core.common.type.Stamp;
 53 import org.graalvm.compiler.core.common.type.StampFactory;
 54 import org.graalvm.compiler.core.common.type.StampPair;
 55 import org.graalvm.compiler.debug.DebugCloseable;
 56 import org.graalvm.compiler.debug.DebugHandlersFactory;
 57 import org.graalvm.compiler.debug.GraalError;
 58 import org.graalvm.compiler.graph.Node;
 59 import org.graalvm.compiler.graph.NodeInputList;
 60 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 61 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;







 62 import org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode;
 63 import org.graalvm.compiler.hotspot.nodes.HotSpotCompressionNode;
 64 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 65 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
<span class="line-added"> 66 import org.graalvm.compiler.hotspot.nodes.KlassBeingInitializedCheckNode;</span>
 67 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 68 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 69 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 70 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
 71 import org.graalvm.compiler.hotspot.nodes.profiling.ProfileNode;
 72 import org.graalvm.compiler.hotspot.nodes.type.HotSpotNarrowOopStamp;
 73 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 74 import org.graalvm.compiler.hotspot.nodes.type.MethodPointerStamp;
 75 import org.graalvm.compiler.hotspot.replacements.AssertionSnippets;
 76 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
<span class="line-added"> 77 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;</span>
 78 import org.graalvm.compiler.hotspot.replacements.HashCodeSnippets;
<span class="line-added"> 79 import org.graalvm.compiler.hotspot.replacements.HotSpotG1WriteBarrierSnippets;</span>
<span class="line-added"> 80 import org.graalvm.compiler.hotspot.replacements.HotSpotSerialWriteBarrierSnippets;</span>
 81 import org.graalvm.compiler.hotspot.replacements.HubGetClassNode;
 82 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 83 import org.graalvm.compiler.hotspot.replacements.InstanceOfSnippets;
 84 import org.graalvm.compiler.hotspot.replacements.KlassLayoutHelperNode;
 85 import org.graalvm.compiler.hotspot.replacements.LoadExceptionObjectSnippets;
 86 import org.graalvm.compiler.hotspot.replacements.MonitorSnippets;
 87 import org.graalvm.compiler.hotspot.replacements.NewObjectSnippets;
 88 import org.graalvm.compiler.hotspot.replacements.ObjectCloneSnippets;
<span class="line-added"> 89 import org.graalvm.compiler.hotspot.replacements.ObjectSnippets;</span>
 90 import org.graalvm.compiler.hotspot.replacements.StringToBytesSnippets;
<span class="line-added"> 91 import org.graalvm.compiler.hotspot.replacements.UnsafeCopyMemoryNode;</span>
 92 import org.graalvm.compiler.hotspot.replacements.UnsafeLoadSnippets;
<span class="line-modified"> 93 import org.graalvm.compiler.hotspot.replacements.UnsafeSnippets;</span>
 94 import org.graalvm.compiler.hotspot.replacements.aot.ResolveConstantSnippets;
 95 import org.graalvm.compiler.hotspot.replacements.arraycopy.HotSpotArraycopySnippets;
 96 import org.graalvm.compiler.hotspot.replacements.profiling.ProfileSnippets;
 97 import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets;
 98 import org.graalvm.compiler.hotspot.word.KlassPointer;
 99 import org.graalvm.compiler.nodes.AbstractBeginNode;
100 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
101 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
102 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
103 import org.graalvm.compiler.nodes.ConstantNode;
104 import org.graalvm.compiler.nodes.FixedNode;
105 import org.graalvm.compiler.nodes.GetObjectAddressNode;
106 import org.graalvm.compiler.nodes.Invoke;
107 import org.graalvm.compiler.nodes.LogicNode;
108 import org.graalvm.compiler.nodes.LoweredCallTargetNode;
109 import org.graalvm.compiler.nodes.NodeView;
110 import org.graalvm.compiler.nodes.ParameterNode;
111 import org.graalvm.compiler.nodes.SafepointNode;
112 import org.graalvm.compiler.nodes.StartNode;
113 import org.graalvm.compiler.nodes.StructuredGraph;
<span class="line-added">114 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;</span>
115 import org.graalvm.compiler.nodes.UnwindNode;
116 import org.graalvm.compiler.nodes.ValueNode;
117 import org.graalvm.compiler.nodes.calc.AddNode;
118 import org.graalvm.compiler.nodes.calc.FloatingNode;
119 import org.graalvm.compiler.nodes.calc.IntegerDivRemNode;
120 import org.graalvm.compiler.nodes.calc.IsNullNode;
121 import org.graalvm.compiler.nodes.calc.RemNode;
122 import org.graalvm.compiler.nodes.debug.StringToBytesNode;
123 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
124 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
125 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
126 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
127 import org.graalvm.compiler.nodes.extended.GetClassNode;

128 import org.graalvm.compiler.nodes.extended.LoadHubNode;
129 import org.graalvm.compiler.nodes.extended.LoadMethodNode;
130 import org.graalvm.compiler.nodes.extended.OSRLocalNode;
131 import org.graalvm.compiler.nodes.extended.OSRLockNode;
132 import org.graalvm.compiler.nodes.extended.OSRMonitorEnterNode;
133 import org.graalvm.compiler.nodes.extended.OSRStartNode;

134 import org.graalvm.compiler.nodes.extended.StoreHubNode;
<span class="line-added">135 import org.graalvm.compiler.nodes.gc.G1ArrayRangePostWriteBarrier;</span>
<span class="line-added">136 import org.graalvm.compiler.nodes.gc.G1ArrayRangePreWriteBarrier;</span>
<span class="line-added">137 import org.graalvm.compiler.nodes.gc.G1PostWriteBarrier;</span>
<span class="line-added">138 import org.graalvm.compiler.nodes.gc.G1PreWriteBarrier;</span>
<span class="line-added">139 import org.graalvm.compiler.nodes.gc.G1ReferentFieldReadBarrier;</span>
<span class="line-added">140 import org.graalvm.compiler.nodes.gc.SerialArrayRangeWriteBarrier;</span>
<span class="line-added">141 import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;</span>
142 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
143 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
144 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
145 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
146 import org.graalvm.compiler.nodes.java.InstanceOfNode;
147 import org.graalvm.compiler.nodes.java.LoadExceptionObjectNode;
148 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
149 import org.graalvm.compiler.nodes.java.MonitorExitNode;
150 import org.graalvm.compiler.nodes.java.MonitorIdNode;
151 import org.graalvm.compiler.nodes.java.NewArrayNode;
152 import org.graalvm.compiler.nodes.java.NewInstanceNode;
153 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
154 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
155 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
156 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
157 import org.graalvm.compiler.nodes.memory.ReadNode;
158 import org.graalvm.compiler.nodes.memory.WriteNode;
159 import org.graalvm.compiler.nodes.memory.address.AddressNode;
160 import org.graalvm.compiler.nodes.spi.LoweringProvider;
161 import org.graalvm.compiler.nodes.spi.LoweringTool;
162 import org.graalvm.compiler.nodes.spi.StampProvider;
163 import org.graalvm.compiler.nodes.type.StampTool;
164 import org.graalvm.compiler.nodes.util.GraphUtil;
165 import org.graalvm.compiler.options.OptionValues;
166 import org.graalvm.compiler.replacements.DefaultJavaLoweringProvider;
167 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
168 import org.graalvm.compiler.replacements.arraycopy.ArrayCopySnippets;
<span class="line-modified">169 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyWithDelayedLoweringNode;</span>
170 import org.graalvm.compiler.replacements.nodes.AssertionNode;
171 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
172 import jdk.internal.vm.compiler.word.LocationIdentity;
173 
174 import jdk.vm.ci.code.TargetDescription;
175 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
176 import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;
177 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
178 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
179 import jdk.vm.ci.meta.JavaConstant;
180 import jdk.vm.ci.meta.JavaKind;
181 import jdk.vm.ci.meta.JavaType;
182 import jdk.vm.ci.meta.MetaAccessProvider;
183 import jdk.vm.ci.meta.ResolvedJavaField;
184 import jdk.vm.ci.meta.ResolvedJavaType;
185 
186 /**
187  * HotSpot implementation of {@link LoweringProvider}.
188  */
<span class="line-modified">189 public abstract class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {</span>
190 
191     protected final HotSpotGraalRuntimeProvider runtime;
192     protected final HotSpotRegistersProvider registers;
193     protected final HotSpotConstantReflectionProvider constantReflection;
194 
195     protected InstanceOfSnippets.Templates instanceofSnippets;
196     protected NewObjectSnippets.Templates newObjectSnippets;
197     protected MonitorSnippets.Templates monitorSnippets;
<span class="line-modified">198     protected HotSpotSerialWriteBarrierSnippets.Templates serialWriteBarrierSnippets;</span>
<span class="line-added">199     protected HotSpotG1WriteBarrierSnippets.Templates g1WriteBarrierSnippets;</span>
200     protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;
201     protected UnsafeLoadSnippets.Templates unsafeLoadSnippets;
202     protected AssertionSnippets.Templates assertionSnippets;
203     protected ArrayCopySnippets.Templates arraycopySnippets;
204     protected StringToBytesSnippets.Templates stringToBytesSnippets;
205     protected HashCodeSnippets.Templates hashCodeSnippets;
206     protected ResolveConstantSnippets.Templates resolveConstantSnippets;
207     protected ProfileSnippets.Templates profileSnippets;
<span class="line-modified">208     protected ObjectSnippets.Templates objectSnippets;</span>
<span class="line-added">209     protected UnsafeSnippets.Templates unsafeSnippets;</span>
210     protected ObjectCloneSnippets.Templates objectCloneSnippets;
211     protected ForeignCallSnippets.Templates foreignCallSnippets;
212 
213     public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers,
214                     HotSpotConstantReflectionProvider constantReflection, TargetDescription target) {
215         super(metaAccess, foreignCalls, target, runtime.getVMConfig().useCompressedOops);
216         this.runtime = runtime;
217         this.registers = registers;
218         this.constantReflection = constantReflection;
<span class="line-added">219 </span>
220     }
221 
222     @Override
223     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {
224         super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());
225 
226         assert target == providers.getCodeCache().getTarget();
227         instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);
228         newObjectSnippets = new NewObjectSnippets.Templates(options, factories, runtime, providers, target, config);
229         monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);
<span class="line-modified">230         g1WriteBarrierSnippets = new HotSpotG1WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);</span>
<span class="line-added">231         serialWriteBarrierSnippets = new HotSpotSerialWriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);</span>
232         exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);
233         unsafeLoadSnippets = new UnsafeLoadSnippets.Templates(options, factories, providers, target);
234         assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);
235         arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);
236         stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);
237         hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);
238         resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);



239         objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);
240         foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);
<span class="line-added">241         objectSnippets = new ObjectSnippets.Templates(options, factories, providers, target);</span>
<span class="line-added">242         unsafeSnippets = new UnsafeSnippets.Templates(options, factories, providers, target);</span>
<span class="line-added">243         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-added">244             // AOT only introduced in JDK 9</span>
<span class="line-added">245             profileSnippets = null;</span>
<span class="line-added">246         } else {</span>
<span class="line-added">247             profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);</span>
<span class="line-added">248         }</span>
<span class="line-added">249     }</span>
<span class="line-added">250 </span>
<span class="line-added">251     public ArrayCopySnippets.Templates getArraycopySnippets() {</span>
<span class="line-added">252         return arraycopySnippets;</span>
253     }
254 
255     public MonitorSnippets.Templates getMonitorSnippets() {
256         return monitorSnippets;
257     }
258 
259     @Override
260     @SuppressWarnings(&quot;try&quot;)
261     public void lower(Node n, LoweringTool tool) {
262         StructuredGraph graph = (StructuredGraph) n.graph();
263         try (DebugCloseable context = n.withNodeSourcePosition()) {
264             if (n instanceof Invoke) {
265                 lowerInvoke((Invoke) n, tool, graph);
266             } else if (n instanceof LoadMethodNode) {
267                 lowerLoadMethodNode((LoadMethodNode) n);
268             } else if (n instanceof GetClassNode) {
269                 lowerGetClassNode((GetClassNode) n, tool, graph);
270             } else if (n instanceof StoreHubNode) {
271                 lowerStoreHubNode((StoreHubNode) n, graph);
272             } else if (n instanceof OSRStartNode) {
</pre>
<hr />
<pre>
333                     ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);
334                     dynamicNewArrayNode.setVoidClass(voidClass);
335                 }
336                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
337                     newObjectSnippets.lower(dynamicNewArrayNode, registers, tool);
338                 }
339             } else if (n instanceof VerifyHeapNode) {
340                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
341                     newObjectSnippets.lower((VerifyHeapNode) n, registers, tool);
342                 }
343             } else if (n instanceof RawMonitorEnterNode) {
344                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
345                     monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);
346                 }
347             } else if (n instanceof MonitorExitNode) {
348                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
349                     monitorSnippets.lower((MonitorExitNode) n, registers, tool);
350                 }
351             } else if (n instanceof ArrayCopyNode) {
352                 arraycopySnippets.lower((ArrayCopyNode) n, tool);
<span class="line-modified">353             } else if (n instanceof ArrayCopyWithDelayedLoweringNode) {</span>
<span class="line-modified">354                 arraycopySnippets.lower((ArrayCopyWithDelayedLoweringNode) n, tool);</span>
355             } else if (n instanceof G1PreWriteBarrier) {
<span class="line-modified">356                 g1WriteBarrierSnippets.lower((G1PreWriteBarrier) n, tool);</span>
357             } else if (n instanceof G1PostWriteBarrier) {
<span class="line-modified">358                 g1WriteBarrierSnippets.lower((G1PostWriteBarrier) n, tool);</span>
359             } else if (n instanceof G1ReferentFieldReadBarrier) {
<span class="line-modified">360                 g1WriteBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, tool);</span>
361             } else if (n instanceof SerialWriteBarrier) {
<span class="line-modified">362                 serialWriteBarrierSnippets.lower((SerialWriteBarrier) n, tool);</span>
363             } else if (n instanceof SerialArrayRangeWriteBarrier) {
<span class="line-modified">364                 serialWriteBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);</span>
365             } else if (n instanceof G1ArrayRangePreWriteBarrier) {
<span class="line-modified">366                 g1WriteBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, tool);</span>
367             } else if (n instanceof G1ArrayRangePostWriteBarrier) {
<span class="line-modified">368                 g1WriteBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, tool);</span>
369             } else if (n instanceof NewMultiArrayNode) {
370                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
371                     newObjectSnippets.lower((NewMultiArrayNode) n, tool);
372                 }
373             } else if (n instanceof LoadExceptionObjectNode) {
374                 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);
375             } else if (n instanceof AssertionNode) {
376                 assertionSnippets.lower((AssertionNode) n, tool);
377             } else if (n instanceof StringToBytesNode) {
378                 if (graph.getGuardsStage().areDeoptsFixed()) {
379                     stringToBytesSnippets.lower((StringToBytesNode) n, tool);
380                 }
381             } else if (n instanceof IntegerDivRemNode) {
382                 // Nothing to do for division nodes. The HotSpot signal handler catches divisions by
383                 // zero and the MIN_VALUE / -1 cases.
384             } else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {
385                 /* No lowering, we generate LIR directly for these nodes. */
386             } else if (n instanceof ClassGetHubNode) {
387                 lowerClassGetHubNode((ClassGetHubNode) n, tool);
388             } else if (n instanceof HubGetClassNode) {
</pre>
<hr />
<pre>
396             } else if (n instanceof IdentityHashCodeNode) {
397                 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);
398             } else if (n instanceof ResolveDynamicConstantNode) {
399                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
400                     resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);
401                 }
402             } else if (n instanceof ResolveConstantNode) {
403                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
404                     resolveConstantSnippets.lower((ResolveConstantNode) n, tool);
405                 }
406             } else if (n instanceof ResolveMethodAndLoadCountersNode) {
407                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
408                     resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);
409                 }
410             } else if (n instanceof InitializeKlassNode) {
411                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
412                     resolveConstantSnippets.lower((InitializeKlassNode) n, tool);
413                 }
414             } else if (n instanceof ProfileNode) {
415                 profileSnippets.lower((ProfileNode) n, tool);
<span class="line-added">416             } else if (n instanceof KlassBeingInitializedCheckNode) {</span>
<span class="line-added">417                 newObjectSnippets.lower((KlassBeingInitializedCheckNode) n, registers, tool);</span>
<span class="line-added">418             } else if (n instanceof FastNotifyNode) {</span>
<span class="line-added">419                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {</span>
<span class="line-added">420                     objectSnippets.lower(n, tool);</span>
<span class="line-added">421                 }</span>
<span class="line-added">422             } else if (n instanceof UnsafeCopyMemoryNode) {</span>
<span class="line-added">423                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {</span>
<span class="line-added">424                     unsafeSnippets.lower((UnsafeCopyMemoryNode) n, tool);</span>
<span class="line-added">425                 }</span>
426             } else {
427                 super.lower(n, tool);
428             }
429         }
<span class="line-added">430 </span>
431     }
432 
433     private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {
434         /*
435          * Lower the node into a ComputeObjectAddress node and an Add but ensure that it&#39;s below any
436          * potential safepoints and above it&#39;s uses.
437          */
438         for (Node use : n.usages().snapshot()) {
439             if (use instanceof FixedNode) {
440                 FixedNode fixed = (FixedNode) use;
441                 StructuredGraph graph = n.graph();
442                 GetObjectAddressNode address = graph.add(new GetObjectAddressNode(n.getObject()));
443                 graph.addBeforeFixed(fixed, address);
444                 AddNode add = graph.addOrUnique(new AddNode(address, n.getOffset()));
445                 use.replaceFirstInput(n, add);
446             } else {
447                 throw GraalError.shouldNotReachHere(&quot;Unexpected floating use of ComputeObjectAddressNode &quot; + n);
448             }
449         }
450         GraphUtil.unlinkFixedNode(n);
</pre>
<hr />
<pre>
480         }
481         n.replaceAtUsagesAndDelete(read);
482     }
483 
484     private void lowerClassGetHubNode(ClassGetHubNode n, LoweringTool tool) {
485         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
486             return;
487         }
488 
489         StructuredGraph graph = n.graph();
490         assert !n.getValue().isConstant();
491         AddressNode address = createOffsetAddress(graph, n.getValue(), runtime.getVMConfig().klassOffset);
492         FloatingReadNode read = graph.unique(new FloatingReadNode(address, CLASS_KLASS_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
493         n.replaceAtUsagesAndDelete(read);
494     }
495 
496     private void lowerInvoke(Invoke invoke, LoweringTool tool, StructuredGraph graph) {
497         if (invoke.callTarget() instanceof MethodCallTargetNode) {
498             MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
499             NodeInputList&lt;ValueNode&gt; parameters = callTarget.arguments();
<span class="line-modified">500             ValueNode receiver = parameters.isEmpty() ? null : parameters.get(0);</span>
<span class="line-modified">501 </span>
<span class="line-modified">502             if (!callTarget.isStatic()) {</span>
<span class="line-modified">503                 assert receiver != null : &quot;non-static call must have a receiver&quot;;</span>
<span class="line-modified">504                 if (receiver.stamp(NodeView.DEFAULT) instanceof ObjectStamp &amp;&amp; !StampTool.isPointerNonNull(receiver)) {</span>
<span class="line-added">505                     ValueNode nonNullReceiver = createNullCheckedValue(receiver, invoke.asNode(), tool);</span>
<span class="line-added">506                     parameters.set(0, nonNullReceiver);</span>
<span class="line-added">507                     receiver = nonNullReceiver;</span>
<span class="line-added">508                 }</span>
509             }
510             JavaType[] signature = callTarget.targetMethod().getSignature().toParameterTypes(callTarget.isStatic() ? null : callTarget.targetMethod().getDeclaringClass());
511 
512             LoweredCallTargetNode loweredCallTarget = null;
513             OptionValues options = graph.getOptions();
514             if (InlineVTableStubs.getValue(options) &amp;&amp; callTarget.invokeKind().isIndirect() &amp;&amp; (AlwaysInlineVTableStubs.getValue(options) || invoke.isPolymorphic())) {
515                 HotSpotResolvedJavaMethod hsMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();
516                 ResolvedJavaType receiverType = invoke.getReceiverType();
517                 if (hsMethod.isInVirtualMethodTable(receiverType)) {
518                     JavaKind wordKind = runtime.getTarget().wordJavaKind;
519                     ValueNode hub = createReadHub(graph, receiver, tool);
520 
521                     ReadNode metaspaceMethod = createReadVirtualMethod(graph, hub, hsMethod, receiverType);
522                     // We use LocationNode.ANY_LOCATION for the reads that access the
523                     // compiled code entry as HotSpot does not guarantee they are final
524                     // values.
525                     int methodCompiledEntryOffset = runtime.getVMConfig().methodCompiledEntryOffset;
526                     AddressNode address = createOffsetAddress(graph, metaspaceMethod, methodCompiledEntryOffset);
527                     ReadNode compiledEntry = graph.add(new ReadNode(address, any(), StampFactory.forKind(wordKind), BarrierType.NONE));
528 
</pre>
<hr />
<pre>
559         return new HotSpotCompressionNode(op, value, getOopEncoding());
560     }
561 
562     @Override
563     public ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField f) {
564         HotSpotResolvedJavaField field = (HotSpotResolvedJavaField) f;
565         JavaConstant base = constantReflection.asJavaClass(field.getDeclaringClass());
566         return ConstantNode.forConstant(base, metaAccess, graph);
567     }
568 
569     @Override
570     protected ValueNode createReadArrayComponentHub(StructuredGraph graph, ValueNode arrayHub, FixedNode anchor) {
571         /*
572          * Anchor the read of the element klass to the cfg, because it is only valid when arrayClass
573          * is an object class, which might not be the case in other parts of the compiled method.
574          */
575         AddressNode address = createOffsetAddress(graph, arrayHub, runtime.getVMConfig().arrayClassElementOffset);
576         return graph.unique(new FloatingReadNode(address, OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION, null, KlassPointerStamp.klassNonNull(), AbstractBeginNode.prevBegin(anchor)));
577     }
578 










579     private void lowerLoadMethodNode(LoadMethodNode loadMethodNode) {
580         StructuredGraph graph = loadMethodNode.graph();
581         HotSpotResolvedJavaMethod method = (HotSpotResolvedJavaMethod) loadMethodNode.getMethod();
582         ReadNode metaspaceMethod = createReadVirtualMethod(graph, loadMethodNode.getHub(), method, loadMethodNode.getReceiverType());
583         graph.replaceFixed(loadMethodNode, metaspaceMethod);
584     }
585 
586     private static void lowerGetClassNode(GetClassNode getClass, LoweringTool tool, StructuredGraph graph) {
587         StampProvider stampProvider = tool.getStampProvider();
588         LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, getClass.getObject()));
589         HubGetClassNode hubGetClass = graph.unique(new HubGetClassNode(tool.getMetaAccess(), hub));
590         getClass.replaceAtUsagesAndDelete(hubGetClass);
591         hub.lower(tool);
592         hubGetClass.lower(tool);
593     }
594 
595     private void lowerStoreHubNode(StoreHubNode storeHub, StructuredGraph graph) {
596         WriteNode hub = createWriteHub(graph, storeHub.getObject(), storeHub.getValue());
597         graph.replaceFixed(storeHub, hub);
598     }
599 










600     private void lowerOSRStartNode(OSRStartNode osrStart) {
601         StructuredGraph graph = osrStart.graph();
602         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
603             StartNode newStart = graph.add(new StartNode());
604             ParameterNode buffer = graph.addWithoutUnique(new ParameterNode(0, StampPair.createSingle(StampFactory.forKind(runtime.getTarget().wordJavaKind))));
605             ForeignCallNode migrationEnd = graph.add(new ForeignCallNode(foreignCalls, OSR_MIGRATION_END, buffer));
606             migrationEnd.setStateAfter(osrStart.stateAfter());
607             newStart.setNext(migrationEnd);
608             FixedNode next = osrStart.next();
609             osrStart.setNext(null);
610             migrationEnd.setNext(next);
611             graph.setStart(newStart);
612 
613             final int wordSize = target.wordSize;
614 
615             // @formatter:off
616             // taken from c2 locals_addr = osr_buf + (max_locals-1)*wordSize)
617             // @formatter:on
618             int localsOffset = (graph.method().getMaxLocals() - 1) * wordSize;
619             for (OSRLocalNode osrLocal : graph.getNodes(OSRLocalNode.TYPE)) {
</pre>
<hr />
<pre>
635             // buffer
636             for (OSRMonitorEnterNode osrMonitorEnter : graph.getNodes(OSRMonitorEnterNode.TYPE)) {
637                 MonitorIdNode monitorID = osrMonitorEnter.getMonitorId();
638                 OSRLockNode lock = (OSRLockNode) osrMonitorEnter.object();
639                 final int index = lock.index();
640 
641                 final int offsetDisplacedHeader = locksOffset - ((index * 2) + 1) * wordSize;
642                 final int offsetLockObject = locksOffset - index * 2 * wordSize;
643 
644                 // load the displaced mark from the osr buffer
645                 AddressNode addressDisplacedHeader = createOffsetAddress(graph, buffer, offsetDisplacedHeader);
646                 ReadNode loadDisplacedHeader = graph.add(new ReadNode(addressDisplacedHeader, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
647                 graph.addBeforeFixed(migrationEnd, loadDisplacedHeader);
648 
649                 // we need to initialize the stack slot for the lock
650                 BeginLockScopeNode beginLockScope = graph.add(new BeginLockScopeNode(lock.getStackKind(), monitorID.getLockDepth()));
651                 graph.addBeforeFixed(migrationEnd, beginLockScope);
652 
653                 // write the displaced mark to the correct stack slot
654                 AddressNode addressDisplacedMark = createOffsetAddress(graph, beginLockScope, runtime.getVMConfig().basicLockDisplacedHeaderOffset);
<span class="line-modified">655                 WriteNode writeStackSlot = graph.add(new WriteNode(addressDisplacedMark, DISPLACED_MARK_WORD_LOCATION, loadDisplacedHeader, BarrierType.NONE, false));</span>
656                 graph.addBeforeFixed(migrationEnd, writeStackSlot);
657 
658                 // load the lock object from the osr buffer
659                 AddressNode addressLockObject = createOffsetAddress(graph, buffer, offsetLockObject);
660                 ReadNode loadObject = graph.add(new ReadNode(addressLockObject, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
661                 lock.replaceAndDelete(loadObject);
662                 graph.addBeforeFixed(migrationEnd, loadObject);
663             }
664 
665             osrStart.replaceAtUsagesAndDelete(newStart);
666         }
667     }
668 
669     static final class Exceptions {
670         protected static final EnumMap&lt;BytecodeExceptionKind, RuntimeException&gt; cachedExceptions;
671 
672         static {
673             cachedExceptions = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);
674             cachedExceptions.put(BytecodeExceptionKind.NULL_POINTER, clearStackTrace(new NullPointerException()));
675             cachedExceptions.put(BytecodeExceptionKind.OUT_OF_BOUNDS, clearStackTrace(new ArrayIndexOutOfBoundsException()));
</pre>
<hr />
<pre>
705         }
706         Throwable exception = Exceptions.cachedExceptions.get(node.getExceptionKind());
707         assert exception != null;
708 
709         StructuredGraph graph = node.graph();
710         FloatingNode exceptionNode = ConstantNode.forConstant(constantReflection.forObject(exception), metaAccess, graph);
711         graph.replaceFixedWithFloating(node, exceptionNode);
712     }
713 
714     private void lowerBytecodeExceptionNode(BytecodeExceptionNode node) {
715         if (OmitHotExceptionStacktrace.getValue(node.getOptions())) {
716             throwCachedException(node);
717             return;
718         }
719 
720         ForeignCallDescriptor descriptor = RuntimeCalls.runtimeCalls.get(node.getExceptionKind());
721         assert descriptor != null;
722 
723         StructuredGraph graph = node.graph();
724         ForeignCallNode foreignCallNode = graph.add(new ForeignCallNode(foreignCalls, descriptor, node.stamp(NodeView.DEFAULT), node.getArguments()));
<span class="line-added">725         /*</span>
<span class="line-added">726          * The original BytecodeExceptionNode has a rethrowException FrameState which isn&#39;t suitable</span>
<span class="line-added">727          * for deopt because the exception to be thrown come from this call so it&#39;s not available in</span>
<span class="line-added">728          * the debug info. The foreign call needs a stateDuring instead so it can deopt with a</span>
<span class="line-added">729          * pending exception.</span>
<span class="line-added">730          */</span>
<span class="line-added">731         foreignCallNode.setStateAfter(node.createStateDuring());</span>
732         graph.replaceFixedWithFixed(node, foreignCallNode);
733     }
734 











735     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, HotSpotResolvedJavaMethod method, ResolvedJavaType receiverType) {
736         return createReadVirtualMethod(graph, hub, method.vtableEntryOffset(receiverType));
737     }
738 
739     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, int vtableEntryOffset) {
740         assert vtableEntryOffset &gt; 0;
741         // We use LocationNode.ANY_LOCATION for the reads that access the vtable
742         // entry as HotSpot does not guarantee that this is a final value.
743         Stamp methodStamp = MethodPointerStamp.methodNonNull();
744         AddressNode address = createOffsetAddress(graph, hub, vtableEntryOffset);
745         ReadNode metaspaceMethod = graph.add(new ReadNode(address, any(), methodStamp, BarrierType.NONE));
746         return metaspaceMethod;
747     }
748 
749     @Override
750     protected ValueNode createReadHub(StructuredGraph graph, ValueNode object, LoweringTool tool) {
751         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
752             return graph.unique(new LoadHubNode(tool.getStampProvider(), object));
753         }
754         assert !object.isConstant() || object.isNullConstant();
</pre>
<hr />
<pre>
760 
761         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
762         LocationIdentity hubLocation = runtime.getVMConfig().useCompressedClassPointers ? COMPRESSED_HUB_LOCATION : HUB_LOCATION;
763         FloatingReadNode memoryRead = graph.unique(new FloatingReadNode(address, hubLocation, null, hubStamp, null, BarrierType.NONE));
764         if (runtime.getVMConfig().useCompressedClassPointers) {
765             return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());
766         } else {
767             return memoryRead;
768         }
769     }
770 
771     private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {
772         assert !object.isConstant() || object.asConstant().isDefaultForKind();
773 
774         ValueNode writeValue = value;
775         if (runtime.getVMConfig().useCompressedClassPointers) {
776             writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());
777         }
778 
779         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
<span class="line-modified">780         return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE, false));</span>
781     }
782 
783     @Override
784     protected BarrierType fieldLoadBarrierType(ResolvedJavaField f) {
785         HotSpotResolvedJavaField loadField = (HotSpotResolvedJavaField) f;
<span class="line-modified">786         if (loadField.getJavaKind() == JavaKind.Object &amp;&amp; metaAccess.lookupJavaType(Reference.class).equals(loadField.getDeclaringClass()) &amp;&amp;</span>

787                         loadField.getName().equals(&quot;referent&quot;)) {
<span class="line-modified">788             return BarrierType.WEAK_FIELD;</span>
789         }
<span class="line-modified">790         return super.fieldLoadBarrierType(f);</span>
791     }
792 
793     @Override
794     public int fieldOffset(ResolvedJavaField f) {
795         return f.getOffset();
796     }
797 
798     @Override
799     public int arrayLengthOffset() {
800         return runtime.getVMConfig().arrayOopDescLengthOffset();
801     }
802 
803     @Override
804     protected final JavaKind getStorageKind(ResolvedJavaField field) {
805         return field.getJavaKind();
806     }
807 
808     @Override
809     public ObjectCloneSnippets.Templates getObjectCloneSnippets() {
810         return objectCloneSnippets;
</pre>
</td>
</tr>
</table>
<center><a href="AddressLoweringHotSpotSuitesProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotForeignCallsProviderImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
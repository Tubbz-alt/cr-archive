<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/gc/shared/CardTableBarrierSet.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2019, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 package org.graalvm.compiler.hotspot.gc.shared;
 27 
 28 import org.graalvm.compiler.debug.GraalError;
 29 import org.graalvm.compiler.nodes.StructuredGraph;
 30 import org.graalvm.compiler.nodes.ValueNode;
 31 import org.graalvm.compiler.nodes.extended.ArrayRangeWrite;
 32 import org.graalvm.compiler.nodes.java.AbstractCompareAndSwapNode;
 33 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 34 import org.graalvm.compiler.nodes.memory.FixedAccessNode;
 35 import org.graalvm.compiler.nodes.memory.HeapAccess;
 36 import org.graalvm.compiler.nodes.memory.ReadNode;
 37 import org.graalvm.compiler.nodes.memory.WriteNode;
 38 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 39 import org.graalvm.compiler.nodes.type.StampTool;
 40 
 41 public class CardTableBarrierSet extends BarrierSet {
 42 
 43     @Override
 44     public void addReadNodeBarriers(ReadNode node, StructuredGraph graph) {
 45         assert node.getBarrierType() == HeapAccess.BarrierType.NONE : &quot;Non precise read barrier has been attached to read node.&quot;;
 46     }
 47 
 48     @Override
 49     public void addWriteNodeBarriers(WriteNode node, StructuredGraph graph) {
 50         HeapAccess.BarrierType barrierType = node.getBarrierType();
 51         switch (barrierType) {
 52             case NONE:
 53                 // nothing to do
 54                 break;
 55             case IMPRECISE:
 56             case PRECISE:
 57                 boolean precise = barrierType == HeapAccess.BarrierType.PRECISE;
 58                 addSerialPostWriteBarrier(node, node.getAddress(), node.value(), precise, graph);
 59                 break;
 60             default:
 61                 throw new GraalError(&quot;unexpected barrier type: &quot; + barrierType);
 62         }
 63     }
 64 
 65     @Override
 66     public void addAtomicReadWriteNodeBarriers(LoweredAtomicReadAndWriteNode node, StructuredGraph graph) {
 67         HeapAccess.BarrierType barrierType = node.getBarrierType();
 68         switch (barrierType) {
 69             case NONE:
 70                 // nothing to do
 71                 break;
 72             case IMPRECISE:
 73             case PRECISE:
 74                 boolean precise = barrierType == HeapAccess.BarrierType.PRECISE;
 75                 addSerialPostWriteBarrier(node, node.getAddress(), node.getNewValue(), precise, graph);
 76                 break;
 77             default:
 78                 throw new GraalError(&quot;unexpected barrier type: &quot; + barrierType);
 79         }
 80     }
 81 
 82     @Override
 83     public void addCASBarriers(AbstractCompareAndSwapNode node, StructuredGraph graph) {
 84         HeapAccess.BarrierType barrierType = node.getBarrierType();
 85         switch (barrierType) {
 86             case NONE:
 87                 // nothing to do
 88                 break;
 89             case IMPRECISE:
 90             case PRECISE:
 91                 boolean precise = barrierType == HeapAccess.BarrierType.PRECISE;
 92                 addSerialPostWriteBarrier(node, node.getAddress(), node.getNewValue(), precise, graph);
 93                 break;
 94             default:
 95                 throw new GraalError(&quot;unexpected barrier type: &quot; + barrierType);
 96         }
 97     }
 98 
 99     @Override
100     public void addArrayRangeBarriers(ArrayRangeWrite write, StructuredGraph graph) {
101         SerialArrayRangeWriteBarrier serialArrayRangeWriteBarrier = graph.add(new SerialArrayRangeWriteBarrier(write.getAddress(), write.getLength(), write.getElementStride()));
102         graph.addAfterFixed(write.asNode(), serialArrayRangeWriteBarrier);
103     }
104 
105     protected void addSerialPostWriteBarrier(FixedAccessNode node, AddressNode address, ValueNode value, boolean precise, StructuredGraph graph) {
106         final boolean alwaysNull = StampTool.isPointerAlwaysNull(value);
107         if (alwaysNull) {
108             // Serial barrier isn&#39;t needed for null value
109             return;
110         }
111         graph.addAfterFixed(node, graph.add(new SerialWriteBarrier(address, precise)));
112     }
113 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/SymbolicSnippetEncoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JVMCIVersionCheck.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="debug/BenchmarkCounters.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/SymbolicSnippetEncoder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot;
  26 
  27 import static jdk.vm.ci.runtime.JVMCI.getRuntime;
  28 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  29 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;

  30 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
<span class="line-modified">  31 import static org.graalvm.compiler.replacements.ReplacementsImpl.Options.UseEncodedSnippets;</span>

  32 
  33 import java.util.ArrayList;
  34 import java.util.Arrays;
  35 import java.util.Collections;
  36 import java.util.HashMap;
  37 import java.util.HashSet;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Objects;
  41 import java.util.Set;
  42 import java.util.concurrent.ConcurrentHashMap;
  43 
  44 import org.graalvm.compiler.api.replacements.Fold;
  45 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  46 import org.graalvm.compiler.api.replacements.Snippet;
  47 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  48 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
  49 import org.graalvm.compiler.api.runtime.GraalRuntime;
  50 import org.graalvm.compiler.bytecode.BytecodeProvider;
<span class="line-modified">  51 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;</span>
  52 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
  53 import org.graalvm.compiler.core.common.type.Stamp;
  54 import org.graalvm.compiler.core.common.type.StampPair;
  55 import org.graalvm.compiler.core.common.type.SymbolicJVMCIReference;
  56 import org.graalvm.compiler.debug.DebugContext;
  57 import org.graalvm.compiler.debug.GraalError;
  58 import org.graalvm.compiler.graph.Node;
  59 import org.graalvm.compiler.graph.NodeClass;
  60 import org.graalvm.compiler.graph.NodeMap;
  61 import org.graalvm.compiler.graph.NodeSourcePosition;
  62 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
  63 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
  64 import org.graalvm.compiler.java.BytecodeParser;
  65 import org.graalvm.compiler.java.GraphBuilderPhase;
  66 import org.graalvm.compiler.nodeinfo.Verbosity;
  67 import org.graalvm.compiler.nodes.CallTargetNode;

  68 import org.graalvm.compiler.nodes.ConstantNode;
  69 import org.graalvm.compiler.nodes.EncodedGraph;
  70 import org.graalvm.compiler.nodes.FrameState;
  71 import org.graalvm.compiler.nodes.FullInfopointNode;
  72 import org.graalvm.compiler.nodes.GraphEncoder;
  73 import org.graalvm.compiler.nodes.ParameterNode;
  74 import org.graalvm.compiler.nodes.ProxyNode;
  75 import org.graalvm.compiler.nodes.StructuredGraph;
  76 import org.graalvm.compiler.nodes.ValueNode;
  77 import org.graalvm.compiler.nodes.cfg.Block;
  78 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
  79 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  80 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
  81 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
  82 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
  83 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  84 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  85 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
  86 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
  87 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
  88 import org.graalvm.compiler.nodes.java.AccessFieldNode;
  89 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
<span class="line-removed">  90 import org.graalvm.compiler.nodes.spi.DelegatingReplacements;</span>
<span class="line-removed">  91 import org.graalvm.compiler.nodes.spi.StampProvider;</span>
  92 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  93 import org.graalvm.compiler.options.OptionValues;
  94 import org.graalvm.compiler.phases.OptimisticOptimizations;
  95 import org.graalvm.compiler.phases.schedule.SchedulePhase;
  96 import org.graalvm.compiler.phases.util.Providers;
  97 import org.graalvm.compiler.replacements.ConstantBindingParameterPlugin;
  98 import org.graalvm.compiler.replacements.PEGraphDecoder;
  99 import org.graalvm.compiler.replacements.ReplacementsImpl;
 100 import org.graalvm.compiler.replacements.SnippetCounter;
 101 import org.graalvm.compiler.replacements.SnippetIntegerHistogram;
 102 
<span class="line-removed"> 103 import jdk.vm.ci.code.Architecture;</span>
 104 import jdk.vm.ci.code.TargetDescription;
 105 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 106 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
 107 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 108 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;

 109 import jdk.vm.ci.meta.Constant;
 110 import jdk.vm.ci.meta.ConstantReflectionProvider;
 111 import jdk.vm.ci.meta.JavaConstant;
 112 import jdk.vm.ci.meta.JavaKind;
<span class="line-removed"> 113 import jdk.vm.ci.meta.JavaType;</span>
 114 import jdk.vm.ci.meta.MemoryAccessProvider;
<span class="line-removed"> 115 import jdk.vm.ci.meta.MetaAccessProvider;</span>
 116 import jdk.vm.ci.meta.MethodHandleAccessProvider;
 117 import jdk.vm.ci.meta.ResolvedJavaField;
 118 import jdk.vm.ci.meta.ResolvedJavaMethod;
 119 import jdk.vm.ci.meta.ResolvedJavaType;
 120 import jdk.vm.ci.meta.UnresolvedJavaField;
 121 import jdk.vm.ci.meta.UnresolvedJavaMethod;
 122 import jdk.vm.ci.meta.UnresolvedJavaType;
 123 
 124 /**
 125  * This class performs graph encoding using {@link GraphEncoder} but also converts JVMCI type and
 126  * method references into a symbolic form that can be resolved at graph decode time using
 127  * {@link SymbolicJVMCIReference}.
 128  */
<span class="line-modified"> 129 public class SymbolicSnippetEncoder extends DelegatingReplacements {</span>
 130 
 131     /**
 132      * This is a customized HotSpotReplacementsImpl intended only for parsing snippets and method
 133      * substitutions for graph encoding.
 134      */
<span class="line-modified"> 135     private final HotSpotSnippetReplacementsImpl replacements;</span>
 136 
 137     /**
 138      * The set of all snippet methods that have been encoded.
 139      */
 140     private final Set&lt;ResolvedJavaMethod&gt; snippetMethods = Collections.synchronizedSet(new HashSet&lt;&gt;());
 141 
 142     /**
 143      * A mapping from the method substitution method to the original method name. The string key and
 144      * values are produced using {@link #methodKey(ResolvedJavaMethod)}.
 145      */
 146     private final Map&lt;String, String&gt; originalMethods = new ConcurrentHashMap&lt;&gt;();
 147 


 148     /**
 149      * The current count of graphs encoded. Used to detect when new graphs have been enqueued for
 150      * encoding.
 151      */
<span class="line-modified"> 152     int encodedGraphs = 0;</span>
 153 
 154     /**
 155      * All the graphs parsed so far.
 156      */
 157     private Map&lt;String, StructuredGraph&gt; preparedSnippetGraphs = new HashMap&lt;&gt;();
 158 






 159     /**
 160      * The invocation plugins which were delayed during graph preparation.
 161      */
 162     private Set&lt;ResolvedJavaMethod&gt; delayedInvocationPluginMethods = new HashSet&lt;&gt;();
 163 
 164     void addDelayedInvocationPluginMethod(ResolvedJavaMethod method) {
 165         delayedInvocationPluginMethods.add(method);
 166     }
 167 
 168     Set&lt;ResolvedJavaMethod&gt; getSnippetMethods() {
 169         return snippetMethods;
 170     }
 171 
 172     protected class SnippetInlineInvokePlugin implements InlineInvokePlugin {
 173 
 174         @Override
 175         public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
 176             if (method.getAnnotation(Fold.class) != null) {
 177                 delayedInvocationPluginMethods.add(method);
 178                 return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
 179             }
 180 
<span class="line-modified"> 181             if (getIntrinsifyingPlugin(method) != null) {</span>
 182                 delayedInvocationPluginMethods.add(method);
 183                 return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
 184             }
 185 
 186             // Force inlining when parsing replacements
<span class="line-modified"> 187             return createIntrinsicInlineInfo(method, null, getDefaultReplacementBytecodeProvider());</span>
 188         }
 189 
 190         @Override
 191         public void notifyAfterInline(ResolvedJavaMethod methodToInline) {
 192             assert methodToInline.getAnnotation(Fold.class) == null : methodToInline;
 193         }
 194     }
 195 
 196     public static class SnippetInvocationPlugins extends InvocationPlugins {
 197 
 198         SnippetInvocationPlugins(InvocationPlugins invocationPlugins) {
 199             super(invocationPlugins);
 200         }
 201 
 202         @Override
 203         public InvocationPlugin lookupInvocation(ResolvedJavaMethod method) {
 204             if (method.getAnnotation(Fold.class) != null) {
 205                 return null;
 206             }
 207             return super.lookupInvocation(method);
 208         }
 209     }
 210 
 211     /**
 212      * This plugin disables the snippet counter machinery.
 213      */
 214     private class SnippetCounterPlugin implements NodePlugin {
 215         String snippetCounterName = &#39;L&#39; + SnippetCounter.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &#39;;&#39;;
 216         String snippetIntegerHistogramName = &#39;L&#39; + SnippetIntegerHistogram.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &#39;;&#39;;
 217 
 218         @Override
 219         public boolean handleLoadField(GraphBuilderContext b, ValueNode object, ResolvedJavaField field) {
 220             if (field.getName().equals(&quot;group&quot;) &amp;&amp; field.getDeclaringClass().getName().equals(snippetCounterName)) {
 221                 b.addPush(JavaKind.Object, ConstantNode.forConstant(JavaConstant.NULL_POINTER, b.getMetaAccess()));
 222                 return true;
 223             }
 224             if (field.getType().getName().equals(snippetCounterName)) {
<span class="line-modified"> 225                 b.addPush(JavaKind.Object, ConstantNode.forConstant(replacements.snippetReflection.forObject(SnippetCounter.DISABLED_COUNTER), b.getMetaAccess()));</span>
 226                 return true;
 227             }
 228 
 229             if (field.getType().getName().equals(snippetIntegerHistogramName)) {
<span class="line-modified"> 230                 b.addPush(JavaKind.Object, ConstantNode.forConstant(replacements.snippetReflection.forObject(SnippetIntegerHistogram.DISABLED_COUNTER), b.getMetaAccess()));</span>
 231                 return true;
 232             }
 233             return false;
 234         }
 235     }
 236 
 237     /**
 238      * Generate a String name for a method including all type information. Used as a symbolic key
 239      * for lookup.
 240      */
 241     private static String methodKey(ResolvedJavaMethod method) {
<span class="line-modified"> 242         return method.format(&quot;%f %H.%n(%P)&quot;);</span>
 243     }
 244 
 245     SymbolicSnippetEncoder(HotSpotReplacementsImpl replacements) {
<span class="line-modified"> 246         super(replacements);</span>
<span class="line-removed"> 247 </span>
 248         GraphBuilderConfiguration.Plugins plugins = replacements.getGraphBuilderPlugins();
 249         SnippetInvocationPlugins invocationPlugins = new SnippetInvocationPlugins(plugins.getInvocationPlugins());
 250         GraphBuilderConfiguration.Plugins copy = new GraphBuilderConfiguration.Plugins(plugins, invocationPlugins);
 251         copy.clearInlineInvokePlugins();
 252         copy.appendInlineInvokePlugin(new SnippetInlineInvokePlugin());
 253         copy.appendNodePlugin(new SnippetCounterPlugin());
 254         HotSpotProviders providers = (HotSpotProviders) replacements.getProviders().copyWith(new HotSpotSubstrateConstantReflectionProvider(replacements.getProviders().getConstantReflection()));
<span class="line-modified"> 255         this.replacements = new HotSpotSnippetReplacementsImpl(replacements, providers.copyWith(copy));</span>
<span class="line-modified"> 256         this.replacements.setGraphBuilderPlugins(copy);</span>








 257     }
 258 
<span class="line-modified"> 259     @Override</span>
<span class="line-modified"> 260     public GraphBuilderConfiguration.Plugins getGraphBuilderPlugins() {</span>
<span class="line-modified"> 261         return replacements.getGraphBuilderPlugins();</span>

 262     }
 263 
 264     /**
 265      * Compiles the snippet and stores the graph.
 266      */
<span class="line-modified"> 267     public void registerMethodSubstitution(ResolvedJavaMethod method, ResolvedJavaMethod original) {</span>

 268         assert method.getAnnotation(MethodSubstitution.class) != null : &quot;MethodSubstitution must be annotated with @&quot; + MethodSubstitution.class.getSimpleName();
<span class="line-modified"> 269         buildGraph(method, original, null, false, false);</span>

 270         snippetMethods.add(method);


 271     }
 272 
 273     static class EncodedSnippets {
 274         private byte[] snippetEncoding;
 275         private Object[] snippetObjects;
 276         private NodeClass&lt;?&gt;[] snippetNodeClasses;
 277         private Map&lt;String, Integer&gt; snippetStartOffsets;
 278         private Map&lt;String, String&gt; originalMethods;
 279 
 280         EncodedSnippets(byte[] snippetEncoding, Object[] snippetObjects, NodeClass&lt;?&gt;[] snippetNodeClasses, Map&lt;String, Integer&gt; snippetStartOffsets, Map&lt;String, String&gt; originalMethods) {
 281             this.snippetEncoding = snippetEncoding;
 282             this.snippetObjects = snippetObjects;
 283             this.snippetNodeClasses = snippetNodeClasses;
 284             this.snippetStartOffsets = snippetStartOffsets;
 285             this.originalMethods = originalMethods;
 286         }
 287 
<span class="line-modified"> 288         public StructuredGraph getMethodSubstitutionGraph(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, ReplacementsImpl replacements) {</span>
<span class="line-modified"> 289             Integer startOffset = snippetStartOffsets.get(plugin.toString());</span>





 290             if (startOffset == null) {
<span class="line-modified"> 291                 throw GraalError.shouldNotReachHere(&quot;plugin graph not found: &quot; + plugin);</span>
 292             }
 293 
<span class="line-modified"> 294             return decodeGraph(original, null, startOffset, replacements);</span>

 295         }
 296 
 297         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 298         private StructuredGraph decodeGraph(ResolvedJavaMethod method, Object[] args, int startOffset, ReplacementsImpl replacements) {</span>
<span class="line-modified"> 299             OptionValues options = replacements.getOptions();</span>
<span class="line-modified"> 300             SnippetReflectionProvider snippetReflection = replacements.snippetReflection;</span>
<span class="line-modified"> 301             ParameterPlugin parameterPlugin = null;</span>




 302             Providers providers = replacements.getProviders();
<span class="line-modified"> 303             if (args != null) {</span>
<span class="line-modified"> 304                 parameterPlugin = new ConstantBindingParameterPlugin(args, providers.getMetaAccess(), snippetReflection);</span>
<span class="line-modified"> 305             }</span>
<span class="line-modified"> 306 </span>
<span class="line-modified"> 307             EncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses, method.getDeclaringClass(),</span>
<span class="line-removed"> 308                             originalMethods.get(methodKey(method)));</span>
<span class="line-removed"> 309             try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method)) {</span>
<span class="line-removed"> 310                 StructuredGraph result = new StructuredGraph.Builder(options, debug).method(method).setIsSubstitution(true).build();</span>
<span class="line-removed"> 311                 PEGraphDecoder graphDecoder = new PEGraphDecoder(</span>
<span class="line-removed"> 312                                 providers.getCodeCache().getTarget().arch,</span>
<span class="line-removed"> 313                                 result,</span>
<span class="line-removed"> 314                                 providers.getMetaAccess(),</span>
<span class="line-removed"> 315                                 providers.getConstantReflection(),</span>
<span class="line-removed"> 316                                 providers.getConstantFieldProvider(),</span>
<span class="line-removed"> 317                                 providers.getStampProvider(),</span>
<span class="line-removed"> 318                                 null, // loopExplosionPlugin</span>
<span class="line-removed"> 319                                 replacements.getGraphBuilderPlugins().getInvocationPlugins(),</span>
<span class="line-removed"> 320                                 new InlineInvokePlugin[0],</span>
<span class="line-removed"> 321                                 parameterPlugin,</span>
<span class="line-removed"> 322                                 null, // nodePlugins</span>
<span class="line-removed"> 323                                 null, // callInlinedMethod</span>
<span class="line-removed"> 324                                 null // sourceLanguagePositionProvider</span>
<span class="line-removed"> 325                 ) {</span>
<span class="line-removed"> 326                     @Override</span>
<span class="line-removed"> 327                     protected EncodedGraph lookupEncodedGraph(ResolvedJavaMethod lookupMethod,</span>
<span class="line-removed"> 328                                     ResolvedJavaMethod originalMethod,</span>
<span class="line-removed"> 329                                     BytecodeProvider intrinsicBytecodeProvider,</span>
<span class="line-removed"> 330                                     boolean isSubstitution,</span>
<span class="line-removed"> 331                                     boolean trackNodeSourcePosition) {</span>
<span class="line-removed"> 332                         if (lookupMethod.equals(method)) {</span>
<span class="line-removed"> 333                             return encodedGraph;</span>
<span class="line-removed"> 334                         } else {</span>
<span class="line-removed"> 335                             throw GraalError.shouldNotReachHere(method.format(&quot;%H.%n(%p)&quot;));</span>
<span class="line-removed"> 336                         }</span>
<span class="line-removed"> 337                     }</span>
<span class="line-removed"> 338                 };</span>
 339 
 340                 graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
 341 
 342                 assert result.verify();
 343                 return result;
 344             }
 345         }
 346 
<span class="line-modified"> 347         StructuredGraph getEncodedSnippet(ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args) {</span>
 348             Integer startOffset = null;
 349             if (snippetStartOffsets != null) {
 350                 startOffset = snippetStartOffsets.get(methodKey(method));
 351             }
 352             if (startOffset == null) {
 353                 if (IS_IN_NATIVE_IMAGE) {
 354                     throw GraalError.shouldNotReachHere(&quot;snippet not found: &quot; + method.format(&quot;%H.%n(%p)&quot;));
 355                 } else {
 356                     return null;
 357                 }
 358             }
 359 
<span class="line-modified"> 360             SymbolicEncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses, method.getDeclaringClass(),</span>
<span class="line-modified"> 361                             originalMethods.get(methodKey(method)));</span>
<span class="line-modified"> 362             return decodeSnippetGraph(encodedGraph, method, replacements, args, HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch);</span>
 363         }
 364 
 365     }
 366 
<span class="line-modified"> 367     private StructuredGraph buildGraph(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean requireInlining, boolean trackNodeSourcePosition) {</span>



































 368         assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
 369         Object[] args = null;
 370         if (receiver != null) {
 371             args = new Object[method.getSignature().getParameterCount(true)];
 372             args[0] = receiver;
 373         }
<span class="line-modified"> 374         try (DebugContext debug = openDebugContext(&quot;Snippet_&quot;, method)) {</span>
<span class="line-modified"> 375             StructuredGraph graph = replacements.makeGraph(debug, replacements.getDefaultReplacementBytecodeProvider(), method, args, original, trackNodeSourcePosition, null);</span>











 376 
 377             // Check if all methods which should be inlined are really inlined.
 378             for (MethodCallTargetNode callTarget : graph.getNodes(MethodCallTargetNode.TYPE)) {
 379                 ResolvedJavaMethod callee = callTarget.targetMethod();
 380                 if (requireInlining &amp;&amp; !delayedInvocationPluginMethods.contains(callee) &amp;&amp; !Objects.equals(callee, original)) {
 381                     throw GraalError.shouldNotReachHere(&quot;method &quot; + callee.format(&quot;%H.%n&quot;) + &quot; not inlined in snippet &quot; + method.getName() + &quot; (maybe not final?)&quot;);
 382                 }
 383             }
<span class="line-modified"> 384             assert verifySnippetEncodeDecode(method, original, trackNodeSourcePosition, graph);</span>
 385             debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;After buildGraph&quot;);
 386             return graph;
 387         }
 388     }
 389 
 390     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 391     static StructuredGraph decodeSnippetGraph(SymbolicEncodedGraph encodedGraph, ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args, Architecture architecture) {</span>

 392         Providers providers = replacements.getProviders();
 393         ParameterPlugin parameterPlugin = null;
 394         if (args != null) {
 395             parameterPlugin = new ConstantBindingParameterPlugin(args, providers.getMetaAccess(), replacements.snippetReflection);
 396         }
 397 
<span class="line-modified"> 398         try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method)) {</span>
 399             // @formatter:off
<span class="line-modified"> 400             StructuredGraph result = new StructuredGraph.Builder(replacements.getOptions(), debug)</span>
<span class="line-modified"> 401                             .method(method)</span>
<span class="line-modified"> 402                             .trackNodeSourcePosition(encodedGraph.trackNodeSourcePosition())</span>
<span class="line-modified"> 403                             .setIsSubstitution(true)</span>
<span class="line-modified"> 404                             .build();</span>
 405             // @formatter:on
 406             try (DebugContext.Scope scope = debug.scope(&quot;DecodeSnippetGraph&quot;, result)) {
<span class="line-modified"> 407                 PEGraphDecoder graphDecoder = new PEGraphDecoder(</span>
<span class="line-removed"> 408                                 architecture,</span>
<span class="line-removed"> 409                                 result,</span>
<span class="line-removed"> 410                                 providers.getMetaAccess(),</span>
<span class="line-removed"> 411                                 providers.getConstantReflection(),</span>
<span class="line-removed"> 412                                 providers.getConstantFieldProvider(),</span>
<span class="line-removed"> 413                                 providers.getStampProvider(),</span>
<span class="line-removed"> 414                                 null,</span>
<span class="line-removed"> 415                                 replacements.getGraphBuilderPlugins().getInvocationPlugins(),</span>
<span class="line-removed"> 416                                 new InlineInvokePlugin[0],</span>
<span class="line-removed"> 417                                 parameterPlugin,</span>
<span class="line-removed"> 418                                 null,</span>
<span class="line-removed"> 419                                 null,</span>
<span class="line-removed"> 420                                 null) {</span>
<span class="line-removed"> 421                     @Override</span>
<span class="line-removed"> 422                     protected EncodedGraph lookupEncodedGraph(</span>
<span class="line-removed"> 423                                     ResolvedJavaMethod lookupMethod,</span>
<span class="line-removed"> 424                                     ResolvedJavaMethod originalMethod,</span>
<span class="line-removed"> 425                                     BytecodeProvider intrinsicBytecodeProvider,</span>
<span class="line-removed"> 426                                     boolean isSubstitution,</span>
<span class="line-removed"> 427                                     boolean track) {</span>
<span class="line-removed"> 428                         if (lookupMethod.equals(method)) {</span>
<span class="line-removed"> 429                             assert !track || encodedGraph.trackNodeSourcePosition();</span>
<span class="line-removed"> 430                             return encodedGraph;</span>
<span class="line-removed"> 431                         } else {</span>
<span class="line-removed"> 432                             throw GraalError.shouldNotReachHere(method.format(&quot;%H.%n(%p)&quot;));</span>
<span class="line-removed"> 433                         }</span>
<span class="line-removed"> 434                     }</span>
<span class="line-removed"> 435                 };</span>
 436 
 437                 graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
 438                 debug.dump(DebugContext.VERBOSE_LEVEL, result, &quot;After decoding&quot;);
 439 
 440                 assert result.verify();
 441                 return result;
 442             } catch (Throwable t) {
 443                 throw debug.handle(t);
 444             }
 445         }
 446     }
 447 
 448     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 449     private boolean verifySnippetEncodeDecode(ResolvedJavaMethod method, ResolvedJavaMethod original, boolean trackNodeSourcePosition, StructuredGraph structuredGraph) {</span>

 450         // Verify the encoding and decoding process
<span class="line-modified"> 451         EncodedGraph encodedGraph = GraphEncoder.encodeSingleGraph(structuredGraph, HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch);</span>
<span class="line-modified"> 452 </span>
<span class="line-modified"> 453         Architecture arch = HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch;</span>
<span class="line-modified"> 454 </span>
<span class="line-modified"> 455         try (DebugContext debug = replacements.openDebugContext(&quot;VerifySnippetEncodeDecode_&quot;, method)) {</span>
<span class="line-modified"> 456             HotSpotProviders originalProvider = (HotSpotProviders) replacements.getProviders();</span>
<span class="line-modified"> 457 </span>
<span class="line-modified"> 458             SnippetReflectionProvider snippetReflection = originalProvider.getSnippetReflection();</span>
<span class="line-modified"> 459             SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider constantReflection = new SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider(</span>
<span class="line-modified"> 460                             originalProvider.getConstantReflection());</span>
<span class="line-modified"> 461             HotSpotProviders newProviders = new HotSpotProviders(originalProvider.getMetaAccess(), originalProvider.getCodeCache(), constantReflection,</span>
<span class="line-modified"> 462                             originalProvider.getConstantFieldProvider(), originalProvider.getForeignCalls(), originalProvider.getLowerer(), null, originalProvider.getSuites(),</span>
<span class="line-modified"> 463                             originalProvider.getRegisters(), snippetReflection, originalProvider.getWordTypes(), originalProvider.getGraphBuilderPlugins());</span>
<span class="line-modified"> 464             HotSpotSnippetReplacementsImpl filteringReplacements = new HotSpotSnippetReplacementsImpl(getOptions(), newProviders, snippetReflection,</span>
<span class="line-modified"> 465                             originalProvider.getReplacements().getDefaultReplacementBytecodeProvider(),</span>
<span class="line-modified"> 466                             originalProvider.getCodeCache().getTarget());</span>
<span class="line-removed"> 467             filteringReplacements.setGraphBuilderPlugins(originalProvider.getReplacements().getGraphBuilderPlugins());</span>
<span class="line-removed"> 468             try (DebugContext.Scope scaope = debug.scope(&quot;VerifySnippetEncodeDecode&quot;, structuredGraph)) {</span>
<span class="line-removed"> 469                 for (int i = 0; i &lt; encodedGraph.getNumObjects(); i++) {</span>
<span class="line-removed"> 470                     filterSnippetObject(encodedGraph.getObject(i));</span>
<span class="line-removed"> 471                 }</span>
<span class="line-removed"> 472                 StructuredGraph snippet = filteringReplacements.makeGraph(debug, filteringReplacements.getDefaultReplacementBytecodeProvider(), method, null, original,</span>
<span class="line-removed"> 473                                 trackNodeSourcePosition, null);</span>
<span class="line-removed"> 474                 SymbolicEncodedGraph symbolicGraph = new SymbolicEncodedGraph(encodedGraph, method.getDeclaringClass(), original != null ? methodKey(original) : null);</span>
<span class="line-removed"> 475                 StructuredGraph decodedSnippet = decodeSnippetGraph(symbolicGraph, method, replacements, null, arch);</span>
<span class="line-removed"> 476                 String snippetString = getCanonicalGraphString(snippet, true, false);</span>
<span class="line-removed"> 477                 String decodedSnippetString = getCanonicalGraphString(decodedSnippet, true, false);</span>
<span class="line-removed"> 478                 if (snippetString.equals(decodedSnippetString)) {</span>
<span class="line-removed"> 479                     debug.log(&quot;Snippet decode for %s produces exactly same graph&quot;, method);</span>
<span class="line-removed"> 480                     debug.dump(DebugContext.INFO_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);</span>
<span class="line-removed"> 481                 } else {</span>
<span class="line-removed"> 482                     debug.log(&quot;Snippet decode for %s produces different graph&quot;, method);</span>
<span class="line-removed"> 483                     debug.log(&quot;%s&quot;, compareGraphStrings(snippet, snippetString, decodedSnippet, decodedSnippetString));</span>
<span class="line-removed"> 484                     debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;Snippet graph for %s&quot;, method);</span>
<span class="line-removed"> 485                     debug.dump(DebugContext.INFO_LEVEL, structuredGraph, &quot;Encoded snippet graph for %s&quot;, method);</span>
<span class="line-removed"> 486                     debug.dump(DebugContext.INFO_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);</span>
<span class="line-removed"> 487                 }</span>
<span class="line-removed"> 488             } catch (Throwable t) {</span>
<span class="line-removed"> 489                 throw debug.handle(t);</span>
 490             }



















 491         }
 492         return true;
 493     }
 494 
 495     /**
 496      * If there are new graphs waiting to be encoded, reencode all the graphs and return the result.
 497      */
 498     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 499     synchronized EncodedSnippets maybeEncodeSnippets() {</span>











 500         Map&lt;String, StructuredGraph&gt; graphs = this.preparedSnippetGraphs;
 501         if (encodedGraphs != graphs.size()) {
<span class="line-modified"> 502             DebugContext debug = openDebugContext(&quot;SnippetEncoder&quot;, null);</span>
 503             try (DebugContext.Scope scope = debug.scope(&quot;SnippetSupportEncode&quot;)) {
 504                 encodedGraphs = graphs.size();
 505                 for (StructuredGraph graph : graphs.values()) {
 506                     for (Node node : graph.getNodes()) {
 507                         node.setNodeSourcePosition(null);
 508                     }
 509                 }
 510                 return encodeSnippets(debug);
 511             }
 512         }
 513         return null;
 514     }
 515 
<span class="line-modified"> 516     @Override</span>
<span class="line-modified"> 517     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition) {</span>
<span class="line-removed"> 518         if (IS_BUILDING_NATIVE_IMAGE || UseEncodedSnippets.getValue(getOptions())) {</span>
 519             assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
 520             String key = methodKey(method);
 521             if (!preparedSnippetGraphs.containsKey(key)) {
 522                 if (original != null) {
 523                     originalMethods.put(key, methodKey(original));
 524                 }
<span class="line-modified"> 525                 StructuredGraph snippet = buildGraph(method, original, receiver, true, trackNodeSourcePosition);</span>
 526                 snippetMethods.add(method);
 527                 preparedSnippetGraphs.put(key, snippet);
 528             }
 529         }

 530     }
 531 
<span class="line-modified"> 532     EncodedSnippets encodeSnippets(DebugContext debug) {</span>
 533         GraphEncoder encoder = new GraphEncoder(HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch, debug);
 534         for (StructuredGraph graph : preparedSnippetGraphs.values()) {
 535             encoder.prepare(graph);
 536         }
 537         encoder.finishPrepare();
 538 
 539         byte[] snippetEncoding;
 540         Object[] snippetObjects;
 541         NodeClass&lt;?&gt;[] snippetNodeClasses;
 542         Map&lt;String, Integer&gt; snippetStartOffsets;
 543 
 544         snippetStartOffsets = new HashMap&lt;&gt;();
 545         for (Map.Entry&lt;String, StructuredGraph&gt; entry : preparedSnippetGraphs.entrySet()) {
 546             snippetStartOffsets.put(entry.getKey(), encoder.encode(entry.getValue()));
 547         }
 548         snippetEncoding = encoder.getEncoding();
 549         snippetObjects = encoder.getObjects();
 550         snippetNodeClasses = encoder.getNodeClasses();
 551         for (int i = 0; i &lt; snippetObjects.length; i++) {
 552             Object o = filterSnippetObject(snippetObjects[i]);
 553             debug.log(&quot;snippetObjects[%d] = %s -&gt; %s&quot;, i, o != null ? o.getClass().getSimpleName() : null, o);
 554             snippetObjects[i] = o;
 555         }
 556         debug.log(&quot;Encoded %d snippet preparedSnippetGraphs using %d bytes with %d objects&quot;, snippetStartOffsets.size(), snippetEncoding.length, snippetObjects.length);
 557         return new EncodedSnippets(snippetEncoding, snippetObjects, snippetNodeClasses, snippetStartOffsets, originalMethods);
 558     }
 559 
 560     /**
 561      * Encode any outstanding graphs and return true if any work was done.
 562      */
 563     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 564     public boolean encode() {</span>
<span class="line-modified"> 565         EncodedSnippets encodedSnippets = maybeEncodeSnippets();</span>
 566         if (encodedSnippets != null) {
 567             HotSpotReplacementsImpl.setEncodedSnippets(encodedSnippets);
 568             return true;
 569         }
 570         return false;
 571     }
 572 
<span class="line-modified"> 573     private DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method) {</span>
<span class="line-modified"> 574         return replacements.openDebugContext(idPrefix, method);</span>
 575     }
 576 
 577     static class SymbolicEncodedGraph extends EncodedGraph {
 578 
<span class="line-modified"> 579         private final ResolvedJavaType accessingClass;</span>
 580         private final String originalMethod;
 581 
<span class="line-modified"> 582         SymbolicEncodedGraph(byte[] encoding, int startOffset, Object[] objects, NodeClass&lt;?&gt;[] types, ResolvedJavaType accessingClass, String originalMethod) {</span>
 583             super(encoding, startOffset, objects, types, null, null, null, false, false);
<span class="line-modified"> 584             this.accessingClass = accessingClass;</span>
 585             this.originalMethod = originalMethod;
 586         }
 587 
 588         SymbolicEncodedGraph(EncodedGraph encodedGraph, ResolvedJavaType declaringClass, String originalMethod) {
<span class="line-modified"> 589             this(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), encodedGraph.getObjects(), encodedGraph.getNodeClasses(), declaringClass, originalMethod);</span>

 590         }
 591 
 592         @Override
 593         public Object getObject(int i) {
 594             Object o = objects[i];

 595             if (o instanceof SymbolicJVMCIReference) {
<span class="line-modified"> 596                 objects[i] = o = ((SymbolicJVMCIReference&lt;?&gt;) o).resolve(accessingClass);</span>






 597             } else if (o instanceof UnresolvedJavaType) {
<span class="line-modified"> 598                 objects[i] = o = ((UnresolvedJavaType) o).resolve(accessingClass);</span>






 599             } else if (o instanceof UnresolvedJavaMethod) {
 600                 throw new InternalError(o.toString());
 601             } else if (o instanceof UnresolvedJavaField) {
<span class="line-modified"> 602                 objects[i] = o = ((UnresolvedJavaField) o).resolve(accessingClass);</span>






 603             } else if (o instanceof GraalCapability) {
<span class="line-modified"> 604                 objects[i] = o = ((GraalCapability) o).resolve(((GraalJVMCICompiler) getRuntime().getCompiler()).getGraalRuntime());</span>







 605             }
 606             return o;
 607         }
 608 
 609         @Override
 610         public boolean isCallToOriginal(ResolvedJavaMethod callTarget) {
 611             if (originalMethod != null &amp;&amp; originalMethod.equals(methodKey(callTarget))) {
 612                 return true;
 613             }
 614             return super.isCallToOriginal(callTarget);
 615         }
 616     }
 617 
 618     /**
 619      * Symbolic reference to an object which can be retrieved from
 620      * {@link GraalRuntime#getCapability(Class)}.
 621      */
 622     static class GraalCapability {
 623         final Class&lt;?&gt; capabilityClass;
 624 
 625         GraalCapability(Class&lt;?&gt; capabilityClass) {
 626             this.capabilityClass = capabilityClass;
 627         }
 628 
 629         public Object resolve(GraalRuntime runtime) {
 630             Object capability = runtime.getCapability(this.capabilityClass);
 631             if (capability != null) {
 632                 assert capability.getClass() == capabilityClass;
 633                 return capability;
 634             }
 635             throw new InternalError(this.capabilityClass.getName());
 636         }
 637     }
 638 
 639     static class SymbolicResolvedJavaMethod implements SymbolicJVMCIReference&lt;ResolvedJavaMethod&gt; {
 640         final UnresolvedJavaType type;
 641         final String methodName;
 642         final String signature;
 643 
<span class="line-modified"> 644         SymbolicResolvedJavaMethod(HotSpotResolvedJavaMethod method) {</span>
 645             this.type = UnresolvedJavaType.create(method.getDeclaringClass().getName());
 646             this.methodName = method.getName();
 647             this.signature = method.getSignature().toMethodDescriptor();
 648         }
 649 
 650         @Override
 651         public String toString() {
 652             return &quot;SymbolicResolvedJavaMethod{&quot; +
 653                             &quot;declaringType=&#39;&quot; + type.getName() + &#39;\&#39;&#39; +
 654                             &quot;, methodName=&#39;&quot; + methodName + &#39;\&#39;&#39; +
 655                             &quot;, signature=&#39;&quot; + signature + &#39;\&#39;&#39; +
 656                             &#39;}&#39;;
 657         }
 658 
 659         @Override
 660         public ResolvedJavaMethod resolve(ResolvedJavaType accessingClass) {
 661             ResolvedJavaType resolvedType = type.resolve(accessingClass);



 662             for (ResolvedJavaMethod method : methodName.equals(&quot;&lt;init&gt;&quot;) ? resolvedType.getDeclaredConstructors() : resolvedType.getDeclaredMethods()) {
 663                 if (method.getName().equals(methodName) &amp;&amp; method.getSignature().toMethodDescriptor().equals(signature)) {
 664                     return method;
 665                 }
 666             }
 667             throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 668         }
 669     }
 670 
 671     static class SymbolicResolvedJavaField implements SymbolicJVMCIReference&lt;ResolvedJavaField&gt; {
 672         final UnresolvedJavaType declaringType;
 673         final String name;
 674         final UnresolvedJavaType signature;
 675         private final boolean isStatic;
 676 
<span class="line-modified"> 677         SymbolicResolvedJavaField(HotSpotResolvedJavaField field) {</span>
 678             this.declaringType = UnresolvedJavaType.create(field.getDeclaringClass().getName());
 679             this.name = field.getName();
 680             this.signature = UnresolvedJavaType.create(field.getType().getName());
 681             this.isStatic = field.isStatic();
 682         }
 683 
 684         @Override
 685         public ResolvedJavaField resolve(ResolvedJavaType accessingClass) {
 686             ResolvedJavaType resolvedType = declaringType.resolve(accessingClass);
 687             ResolvedJavaType resolvedFieldType = signature.resolve(accessingClass);
 688             ResolvedJavaField[] fields = isStatic ? resolvedType.getStaticFields() : resolvedType.getInstanceFields(true);
 689             for (ResolvedJavaField field : fields) {
 690                 if (field.getName().equals(name)) {
 691                     if (field.getType().equals(resolvedFieldType)) {
 692                         return field;
 693                     }
 694                 }
 695             }
 696             throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 697         }
 698 
 699         @Override
 700         public String toString() {
 701             return &quot;SymbolicResolvedJavaField{&quot; +
 702                             signature.getName() + &#39; &#39; +
 703                             declaringType.getName() + &#39;.&#39; +
 704                             name +
 705                             &#39;}&#39;;
 706         }
 707     }
 708 













 709     static class SymbolicStampPair implements SymbolicJVMCIReference&lt;StampPair&gt; {
 710         Object trustedStamp;
 711         Object uncheckdStamp;
 712 
 713         SymbolicStampPair(StampPair stamp) {
 714             this.trustedStamp = maybeMakeSymbolic(stamp.getTrustedStamp());
 715             this.uncheckdStamp = maybeMakeSymbolic(stamp.getUncheckedStamp());
 716         }
 717 
 718         @Override
 719         public StampPair resolve(ResolvedJavaType accessingClass) {
 720             return StampPair.create(resolveStamp(accessingClass, trustedStamp), resolveStamp(accessingClass, uncheckdStamp));
 721         }
 722     }
 723 
 724     private static Object maybeMakeSymbolic(Stamp trustedStamp) {
 725         if (trustedStamp != null) {
 726             SymbolicJVMCIReference&lt;?&gt; symbolicJVMCIReference = trustedStamp.makeSymbolic();
 727             if (symbolicJVMCIReference != null) {
 728                 return symbolicJVMCIReference;
</pre>
<hr />
<pre>
 752         HashSet&lt;JavaConstant&gt; safeConstants = new HashSet&lt;&gt;();
 753 
 754         @Override
 755         public Boolean constantEquals(Constant x, Constant y) {
 756             return constantReflection.constantEquals(x, y);
 757         }
 758 
 759         @Override
 760         public Integer readArrayLength(JavaConstant array) {
 761             return constantReflection.readArrayLength(array);
 762         }
 763 
 764         @Override
 765         public JavaConstant readArrayElement(JavaConstant array, int index) {
 766             return constantReflection.readArrayElement(array, index);
 767         }
 768 
 769         @Override
 770         public JavaConstant readFieldValue(ResolvedJavaField field, JavaConstant receiver) {
 771             JavaConstant javaConstant = constantReflection.readFieldValue(field, receiver);
<span class="line-modified"> 772             if (!safeConstants.contains(receiver) &amp;&amp; !field.getDeclaringClass().getName().contains(&quot;graalvm&quot;) &amp;&amp; !field.getDeclaringClass().getName().contains(&quot;jdk/vm/ci/&quot;) &amp;&amp;</span>




 773                             !field.getName().equals(&quot;TYPE&quot;)) {
 774                 // Only permit constant reflection on compiler classes. This is necessary primarily
 775                 // because of the boxing snippets which are compiled as snippets but are really just
 776                 // regular JDK java sources that are being compiled like a snippet. These shouldn&#39;t
 777                 // permit constant folding during graph preparation as that embeds constants from
 778                 // the runtime into a compiler graph.
 779                 return null;
 780             }
 781             if (javaConstant.getJavaKind() == JavaKind.Object) {
 782                 safeConstants.add(javaConstant);
 783             }
 784             return javaConstant;
 785         }
 786 
 787         @Override
 788         public JavaConstant boxPrimitive(JavaConstant source) {
 789             return constantReflection.boxPrimitive(source);
 790         }
 791 
 792         @Override
</pre>
<hr />
<pre>
 812         @Override
 813         public MemoryAccessProvider getMemoryAccessProvider() {
 814             return constantReflection.getMemoryAccessProvider();
 815         }
 816 
 817         @Override
 818         public JavaConstant asJavaClass(ResolvedJavaType type) {
 819             return constantReflection.asJavaClass(type);
 820         }
 821 
 822         @Override
 823         public Constant asObjectHub(ResolvedJavaType type) {
 824             return constantReflection.asObjectHub(type);
 825         }
 826     }
 827 
 828     /**
 829      * Objects embedded in encoded graphs might need to converted into a symbolic form so convert
 830      * the object or pass it through.
 831      */
<span class="line-modified"> 832     static Object filterSnippetObject(Object o) {</span>
 833         if (o instanceof HotSpotResolvedJavaMethod) {
 834             return new SymbolicResolvedJavaMethod((HotSpotResolvedJavaMethod) o);
 835         } else if (o instanceof HotSpotResolvedJavaField) {
 836             return new SymbolicResolvedJavaField((HotSpotResolvedJavaField) o);
 837         } else if (o instanceof HotSpotResolvedJavaType) {
<span class="line-modified"> 838             return UnresolvedJavaType.create(((HotSpotResolvedJavaType) o).getName());</span>
 839         } else if (o instanceof NodeSourcePosition) {
 840             // Filter these out for now. These can&#39;t easily be handled because these positions
 841             // description snippet methods which might not be available in the runtime.
 842             return null;
 843         } else if (o instanceof HotSpotForeignCallsProvider || o instanceof GraalHotSpotVMConfig) {
 844             return new GraalCapability(o.getClass());
 845         } else if (o instanceof Stamp) {
 846             SymbolicJVMCIReference&lt;?&gt; ref = ((Stamp) o).makeSymbolic();
 847             if (ref != null) {
 848                 return ref;
 849             }
 850             return o;
 851         } else if (o instanceof StampPair) {
 852             if (((StampPair) o).getTrustedStamp() instanceof AbstractObjectStamp) {
 853                 return new SymbolicStampPair((StampPair) o);
 854             }




 855         }
 856         return o;
 857     }
 858 
<span class="line-modified"> 859     static String compareGraphStrings(StructuredGraph expectedGraph, String expectedString, StructuredGraph actualGraph, String actualString) {</span>
 860         if (!expectedString.equals(actualString)) {
 861             String[] expectedLines = expectedString.split(&quot;\n&quot;);
 862             String[] actualLines = actualString.split(&quot;\n&quot;);
 863             int diffIndex = -1;
 864             int limit = Math.min(actualLines.length, expectedLines.length);
 865             String marker = &quot; &lt;&lt;&lt;&quot;;
 866             for (int i = 0; i &lt; limit; i++) {
 867                 if (!expectedLines[i].equals(actualLines[i])) {
 868                     diffIndex = i;
 869                     break;
 870                 }
 871             }
 872             if (diffIndex == -1) {
 873                 // Prefix is the same so add some space after the prefix
 874                 diffIndex = limit;
 875                 if (actualLines.length == limit) {
 876                     actualLines = Arrays.copyOf(actualLines, limit + 1);
 877                     actualLines[diffIndex] = &quot;&quot;;
 878                 } else {
 879                     assert expectedLines.length == limit;
 880                     expectedLines = Arrays.copyOf(expectedLines, limit + 1);
 881                     expectedLines[diffIndex] = &quot;&quot;;
 882                 }
 883             }
 884             // Place a marker next to the first line that differs
 885             expectedLines[diffIndex] = expectedLines[diffIndex] + marker;
 886             actualLines[diffIndex] = actualLines[diffIndex] + marker;
 887             String ediff = String.join(&quot;\n&quot;, expectedLines);
 888             String adiff = String.join(&quot;\n&quot;, actualLines);
 889             return &quot;mismatch in preparedSnippetGraphs:\n========= expected (&quot; + expectedGraph + &quot;) =========\n&quot; + ediff + &quot;\n\n========= actual (&quot; + actualGraph + &quot;) =========\n&quot; + adiff;
 890         } else {
 891             return &quot;mismatch in preparedSnippetGraphs&quot;;
 892         }
 893     }
 894 
<span class="line-modified"> 895     static String getCanonicalGraphString(StructuredGraph graph, boolean excludeVirtual, boolean checkConstants) {</span>
 896         SchedulePhase schedule = new SchedulePhase(SchedulePhase.SchedulingStrategy.EARLIEST);
 897         schedule.apply(graph);
 898         StructuredGraph.ScheduleResult scheduleResult = graph.getLastSchedule();
 899 
 900         NodeMap&lt;Integer&gt; canonicalId = graph.createNodeMap();
 901         int nextId = 0;
 902 
 903         List&lt;String&gt; constantsLines = new ArrayList&lt;&gt;();
 904 
 905         StringBuilder result = new StringBuilder();
 906         for (Block block : scheduleResult.getCFG().getBlocks()) {
 907             result.append(&quot;Block &quot;).append(block).append(&#39; &#39;);
 908             if (block == scheduleResult.getCFG().getStartBlock()) {
 909                 result.append(&quot;* &quot;);
 910             }
 911             result.append(&quot;-&gt; &quot;);
 912             for (Block succ : block.getSuccessors()) {
 913                 result.append(succ).append(&#39; &#39;);
 914             }
 915             result.append(&#39;\n&#39;);
</pre>
<hr />
<pre>
 955         if (checkConstants) {
 956             constantsLinesResult.append(constantsLines.size()).append(&quot; constants:\n&quot;);
 957         }
 958         Collections.sort(constantsLines);
 959         for (String s : constantsLines) {
 960             constantsLinesResult.append(s);
 961             constantsLinesResult.append(&#39;\n&#39;);
 962         }
 963 
 964         return constantsLinesResult.toString() + result.toString();
 965     }
 966 
 967     private static int filteredUsageCount(Node node) {
 968         return node.usages().filter(n -&gt; !(n instanceof FrameState)).count();
 969     }
 970 
 971     /**
 972      * This horror show of classes exists solely get {@link HotSpotSnippetBytecodeParser} to be used
 973      * as the parser for these snippets.
 974      */
<span class="line-modified"> 975     static class HotSpotSnippetReplacementsImpl extends HotSpotReplacementsImpl {</span>
 976         HotSpotSnippetReplacementsImpl(HotSpotReplacementsImpl replacements, Providers providers) {
 977             super(replacements, providers);
 978         }
 979 
<span class="line-modified"> 980         HotSpotSnippetReplacementsImpl(OptionValues options, Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider, TargetDescription target) {</span>
<span class="line-modified"> 981             super(options, providers, snippetReflection, bytecodeProvider, target);</span>
 982         }
 983 
 984         @Override
 985         protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
 986             return new SnippetGraphMaker(this, substitute, original);
 987         }
 988     }
 989 
<span class="line-modified"> 990     static class SnippetGraphMaker extends ReplacementsImpl.GraphMaker {</span>
 991         SnippetGraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
 992             super(replacements, substitute, substitutedMethod);
 993         }
 994 
 995         @Override
<span class="line-modified"> 996         protected GraphBuilderPhase.Instance createGraphBuilder(MetaAccessProvider metaAccess, StampProvider stampProvider, ConstantReflectionProvider constantReflection,</span>
<span class="line-modified"> 997                         ConstantFieldProvider constantFieldProvider, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified"> 998             return new HotSpotSnippetGraphBuilderPhase(metaAccess, stampProvider, constantReflection, constantFieldProvider, graphBuilderConfig, optimisticOpts,</span>
<span class="line-removed"> 999                             initialIntrinsicContext);</span>
1000         }
1001     }
1002 
<span class="line-modified">1003     static class HotSpotSnippetGraphBuilderPhase extends GraphBuilderPhase.Instance {</span>
<span class="line-modified">1004         HotSpotSnippetGraphBuilderPhase(MetaAccessProvider metaAccess, StampProvider stampProvider, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,</span>
<span class="line-modified">1005                         GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-removed">1006             super(metaAccess, stampProvider, constantReflection, constantFieldProvider, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>
1007         }
1008 
1009         @Override
1010         protected BytecodeParser createBytecodeParser(StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI, IntrinsicContext intrinsicContext) {
1011             return new HotSpotSnippetBytecodeParser(this, graph, parent, method, entryBCI, intrinsicContext);
1012         }
1013     }
1014 
<span class="line-modified">1015     static class HotSpotSnippetBytecodeParser extends BytecodeParser {</span>
1016         HotSpotSnippetBytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI,
1017                         IntrinsicContext intrinsicContext) {
1018             super(graphBuilderInstance, graph, parent, method, entryBCI, intrinsicContext);
1019         }
1020 
1021         @Override
1022         public boolean canDeferPlugin(GeneratedInvocationPlugin plugin) {
<span class="line-modified">1023             return plugin.getSource().equals(Fold.class) || plugin.getSource().equals(Node.NodeIntrinsic.class);</span>







1024         }
1025 
1026         @Override
<span class="line-modified">1027         protected boolean tryInvocationPlugin(CallTargetNode.InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType, JavaType returnType) {</span>
1028             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1029                 return false;
1030             }
<span class="line-modified">1031             return super.tryInvocationPlugin(invokeKind, args, targetMethod, resultType, returnType);</span>











1032         }
1033     }
1034 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot;
  26 
  27 import static jdk.vm.ci.runtime.JVMCI.getRuntime;
  28 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  29 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
<span class="line-added">  30 import static org.graalvm.compiler.core.common.GraalOptions.UseEncodedGraphs;</span>
  31 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
<span class="line-modified">  32 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;</span>
<span class="line-added">  33 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;</span>
  34 
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Collections;
  38 import java.util.HashMap;
  39 import java.util.HashSet;
  40 import java.util.List;
  41 import java.util.Map;
  42 import java.util.Objects;
  43 import java.util.Set;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 
  46 import org.graalvm.compiler.api.replacements.Fold;
  47 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  48 import org.graalvm.compiler.api.replacements.Snippet;
  49 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  50 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
  51 import org.graalvm.compiler.api.runtime.GraalRuntime;
  52 import org.graalvm.compiler.bytecode.BytecodeProvider;
<span class="line-modified">  53 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;</span>
  54 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
  55 import org.graalvm.compiler.core.common.type.Stamp;
  56 import org.graalvm.compiler.core.common.type.StampPair;
  57 import org.graalvm.compiler.core.common.type.SymbolicJVMCIReference;
  58 import org.graalvm.compiler.debug.DebugContext;
  59 import org.graalvm.compiler.debug.GraalError;
  60 import org.graalvm.compiler.graph.Node;
  61 import org.graalvm.compiler.graph.NodeClass;
  62 import org.graalvm.compiler.graph.NodeMap;
  63 import org.graalvm.compiler.graph.NodeSourcePosition;
  64 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
  65 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
  66 import org.graalvm.compiler.java.BytecodeParser;
  67 import org.graalvm.compiler.java.GraphBuilderPhase;
  68 import org.graalvm.compiler.nodeinfo.Verbosity;
  69 import org.graalvm.compiler.nodes.CallTargetNode;
<span class="line-added">  70 import org.graalvm.compiler.nodes.Cancellable;</span>
  71 import org.graalvm.compiler.nodes.ConstantNode;
  72 import org.graalvm.compiler.nodes.EncodedGraph;
  73 import org.graalvm.compiler.nodes.FrameState;
  74 import org.graalvm.compiler.nodes.FullInfopointNode;
  75 import org.graalvm.compiler.nodes.GraphEncoder;
  76 import org.graalvm.compiler.nodes.ParameterNode;
  77 import org.graalvm.compiler.nodes.ProxyNode;
  78 import org.graalvm.compiler.nodes.StructuredGraph;
  79 import org.graalvm.compiler.nodes.ValueNode;
  80 import org.graalvm.compiler.nodes.cfg.Block;
  81 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
  82 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  83 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
  84 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
  85 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
  86 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  87 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  88 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
  89 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
  90 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
  91 import org.graalvm.compiler.nodes.java.AccessFieldNode;
  92 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;


  93 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  94 import org.graalvm.compiler.options.OptionValues;
  95 import org.graalvm.compiler.phases.OptimisticOptimizations;
  96 import org.graalvm.compiler.phases.schedule.SchedulePhase;
  97 import org.graalvm.compiler.phases.util.Providers;
  98 import org.graalvm.compiler.replacements.ConstantBindingParameterPlugin;
  99 import org.graalvm.compiler.replacements.PEGraphDecoder;
 100 import org.graalvm.compiler.replacements.ReplacementsImpl;
 101 import org.graalvm.compiler.replacements.SnippetCounter;
 102 import org.graalvm.compiler.replacements.SnippetIntegerHistogram;
 103 

 104 import jdk.vm.ci.code.TargetDescription;
 105 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 106 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
 107 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 108 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
<span class="line-added"> 109 import jdk.vm.ci.hotspot.HotSpotSignature;</span>
 110 import jdk.vm.ci.meta.Constant;
 111 import jdk.vm.ci.meta.ConstantReflectionProvider;
 112 import jdk.vm.ci.meta.JavaConstant;
 113 import jdk.vm.ci.meta.JavaKind;

 114 import jdk.vm.ci.meta.MemoryAccessProvider;

 115 import jdk.vm.ci.meta.MethodHandleAccessProvider;
 116 import jdk.vm.ci.meta.ResolvedJavaField;
 117 import jdk.vm.ci.meta.ResolvedJavaMethod;
 118 import jdk.vm.ci.meta.ResolvedJavaType;
 119 import jdk.vm.ci.meta.UnresolvedJavaField;
 120 import jdk.vm.ci.meta.UnresolvedJavaMethod;
 121 import jdk.vm.ci.meta.UnresolvedJavaType;
 122 
 123 /**
 124  * This class performs graph encoding using {@link GraphEncoder} but also converts JVMCI type and
 125  * method references into a symbolic form that can be resolved at graph decode time using
 126  * {@link SymbolicJVMCIReference}.
 127  */
<span class="line-modified"> 128 public class SymbolicSnippetEncoder {</span>
 129 
 130     /**
 131      * This is a customized HotSpotReplacementsImpl intended only for parsing snippets and method
 132      * substitutions for graph encoding.
 133      */
<span class="line-modified"> 134     private final HotSpotSnippetReplacementsImpl snippetReplacements;</span>
 135 
 136     /**
 137      * The set of all snippet methods that have been encoded.
 138      */
 139     private final Set&lt;ResolvedJavaMethod&gt; snippetMethods = Collections.synchronizedSet(new HashSet&lt;&gt;());
 140 
 141     /**
 142      * A mapping from the method substitution method to the original method name. The string key and
 143      * values are produced using {@link #methodKey(ResolvedJavaMethod)}.
 144      */
 145     private final Map&lt;String, String&gt; originalMethods = new ConcurrentHashMap&lt;&gt;();
 146 
<span class="line-added"> 147     private final HotSpotReplacementsImpl originalReplacements;</span>
<span class="line-added"> 148 </span>
 149     /**
 150      * The current count of graphs encoded. Used to detect when new graphs have been enqueued for
 151      * encoding.
 152      */
<span class="line-modified"> 153     private int encodedGraphs = 0;</span>
 154 
 155     /**
 156      * All the graphs parsed so far.
 157      */
 158     private Map&lt;String, StructuredGraph&gt; preparedSnippetGraphs = new HashMap&lt;&gt;();
 159 
<span class="line-added"> 160     private Set&lt;MethodSubstitutionPlugin&gt; knownPlugins = new HashSet&lt;&gt;();</span>
<span class="line-added"> 161 </span>
<span class="line-added"> 162     private Set&lt;InvocationPlugin&gt; conditionalPlugins = new HashSet&lt;&gt;();</span>
<span class="line-added"> 163 </span>
<span class="line-added"> 164     private int preparedPlugins = 0;</span>
<span class="line-added"> 165 </span>
 166     /**
 167      * The invocation plugins which were delayed during graph preparation.
 168      */
 169     private Set&lt;ResolvedJavaMethod&gt; delayedInvocationPluginMethods = new HashSet&lt;&gt;();
 170 
 171     void addDelayedInvocationPluginMethod(ResolvedJavaMethod method) {
 172         delayedInvocationPluginMethods.add(method);
 173     }
 174 
 175     Set&lt;ResolvedJavaMethod&gt; getSnippetMethods() {
 176         return snippetMethods;
 177     }
 178 
 179     protected class SnippetInlineInvokePlugin implements InlineInvokePlugin {
 180 
 181         @Override
 182         public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
 183             if (method.getAnnotation(Fold.class) != null) {
 184                 delayedInvocationPluginMethods.add(method);
 185                 return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
 186             }
 187 
<span class="line-modified"> 188             if (snippetReplacements.getIntrinsifyingPlugin(method) != null) {</span>
 189                 delayedInvocationPluginMethods.add(method);
 190                 return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
 191             }
 192 
 193             // Force inlining when parsing replacements
<span class="line-modified"> 194             return createIntrinsicInlineInfo(method, snippetReplacements.getDefaultReplacementBytecodeProvider());</span>
 195         }
 196 
 197         @Override
 198         public void notifyAfterInline(ResolvedJavaMethod methodToInline) {
 199             assert methodToInline.getAnnotation(Fold.class) == null : methodToInline;
 200         }
 201     }
 202 
 203     public static class SnippetInvocationPlugins extends InvocationPlugins {
 204 
 205         SnippetInvocationPlugins(InvocationPlugins invocationPlugins) {
 206             super(invocationPlugins);
 207         }
 208 
 209         @Override
 210         public InvocationPlugin lookupInvocation(ResolvedJavaMethod method) {
 211             if (method.getAnnotation(Fold.class) != null) {
 212                 return null;
 213             }
 214             return super.lookupInvocation(method);
 215         }
 216     }
 217 
 218     /**
 219      * This plugin disables the snippet counter machinery.
 220      */
 221     private class SnippetCounterPlugin implements NodePlugin {
 222         String snippetCounterName = &#39;L&#39; + SnippetCounter.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &#39;;&#39;;
 223         String snippetIntegerHistogramName = &#39;L&#39; + SnippetIntegerHistogram.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &#39;;&#39;;
 224 
 225         @Override
 226         public boolean handleLoadField(GraphBuilderContext b, ValueNode object, ResolvedJavaField field) {
 227             if (field.getName().equals(&quot;group&quot;) &amp;&amp; field.getDeclaringClass().getName().equals(snippetCounterName)) {
 228                 b.addPush(JavaKind.Object, ConstantNode.forConstant(JavaConstant.NULL_POINTER, b.getMetaAccess()));
 229                 return true;
 230             }
 231             if (field.getType().getName().equals(snippetCounterName)) {
<span class="line-modified"> 232                 b.addPush(JavaKind.Object, ConstantNode.forConstant(snippetReplacements.snippetReflection.forObject(SnippetCounter.DISABLED_COUNTER), b.getMetaAccess()));</span>
 233                 return true;
 234             }
 235 
 236             if (field.getType().getName().equals(snippetIntegerHistogramName)) {
<span class="line-modified"> 237                 b.addPush(JavaKind.Object, ConstantNode.forConstant(snippetReplacements.snippetReflection.forObject(SnippetIntegerHistogram.DISABLED_COUNTER), b.getMetaAccess()));</span>
 238                 return true;
 239             }
 240             return false;
 241         }
 242     }
 243 
 244     /**
 245      * Generate a String name for a method including all type information. Used as a symbolic key
 246      * for lookup.
 247      */
 248     private static String methodKey(ResolvedJavaMethod method) {
<span class="line-modified"> 249         return method.format(&quot;%H.%n(%P)&quot;);</span>
 250     }
 251 
 252     SymbolicSnippetEncoder(HotSpotReplacementsImpl replacements) {
<span class="line-modified"> 253         this.originalReplacements = replacements;</span>

 254         GraphBuilderConfiguration.Plugins plugins = replacements.getGraphBuilderPlugins();
 255         SnippetInvocationPlugins invocationPlugins = new SnippetInvocationPlugins(plugins.getInvocationPlugins());
 256         GraphBuilderConfiguration.Plugins copy = new GraphBuilderConfiguration.Plugins(plugins, invocationPlugins);
 257         copy.clearInlineInvokePlugins();
 258         copy.appendInlineInvokePlugin(new SnippetInlineInvokePlugin());
 259         copy.appendNodePlugin(new SnippetCounterPlugin());
 260         HotSpotProviders providers = (HotSpotProviders) replacements.getProviders().copyWith(new HotSpotSubstrateConstantReflectionProvider(replacements.getProviders().getConstantReflection()));
<span class="line-modified"> 261         this.snippetReplacements = new HotSpotSnippetReplacementsImpl(replacements, providers.copyWith(copy));</span>
<span class="line-modified"> 262         this.snippetReplacements.setGraphBuilderPlugins(copy);</span>
<span class="line-added"> 263     }</span>
<span class="line-added"> 264 </span>
<span class="line-added"> 265     synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin) {</span>
<span class="line-added"> 266         knownPlugins.add(plugin);</span>
<span class="line-added"> 267     }</span>
<span class="line-added"> 268 </span>
<span class="line-added"> 269     void registerConditionalPlugin(InvocationPlugin plugin) {</span>
<span class="line-added"> 270         conditionalPlugins.add(plugin);</span>
 271     }
 272 
<span class="line-modified"> 273     synchronized void checkRegistered(MethodSubstitutionPlugin plugin) {</span>
<span class="line-modified"> 274         if (!knownPlugins.contains(plugin)) {</span>
<span class="line-modified"> 275             throw new GraalError(&quot;missing plugin should have been registered during construction&quot;);</span>
<span class="line-added"> 276         }</span>
 277     }
 278 
 279     /**
 280      * Compiles the snippet and stores the graph.
 281      */
<span class="line-modified"> 282     private synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context, OptionValues options) {</span>
<span class="line-added"> 283         ResolvedJavaMethod method = plugin.getSubstitute(snippetReplacements.getProviders().getMetaAccess());</span>
 284         assert method.getAnnotation(MethodSubstitution.class) != null : &quot;MethodSubstitution must be annotated with @&quot; + MethodSubstitution.class.getSimpleName();
<span class="line-modified"> 285         String originalMethodString = plugin.originalMethodAsString();</span>
<span class="line-added"> 286         StructuredGraph subst = buildGraph(method, original, originalMethodString, null, true, false, context, options);</span>
 287         snippetMethods.add(method);
<span class="line-added"> 288         originalMethods.put(methodKey(method), originalMethodString);</span>
<span class="line-added"> 289         preparedSnippetGraphs.put(plugin.toString() + context, subst);</span>
 290     }
 291 
 292     static class EncodedSnippets {
 293         private byte[] snippetEncoding;
 294         private Object[] snippetObjects;
 295         private NodeClass&lt;?&gt;[] snippetNodeClasses;
 296         private Map&lt;String, Integer&gt; snippetStartOffsets;
 297         private Map&lt;String, String&gt; originalMethods;
 298 
 299         EncodedSnippets(byte[] snippetEncoding, Object[] snippetObjects, NodeClass&lt;?&gt;[] snippetNodeClasses, Map&lt;String, Integer&gt; snippetStartOffsets, Map&lt;String, String&gt; originalMethods) {
 300             this.snippetEncoding = snippetEncoding;
 301             this.snippetObjects = snippetObjects;
 302             this.snippetNodeClasses = snippetNodeClasses;
 303             this.snippetStartOffsets = snippetStartOffsets;
 304             this.originalMethods = originalMethods;
 305         }
 306 
<span class="line-modified"> 307         StructuredGraph getMethodSubstitutionGraph(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, ReplacementsImpl replacements, IntrinsicContext.CompilationContext context,</span>
<span class="line-modified"> 308                         StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {</span>
<span class="line-added"> 309             IntrinsicContext.CompilationContext contextToUse = context;</span>
<span class="line-added"> 310             if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {</span>
<span class="line-added"> 311                 contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;</span>
<span class="line-added"> 312             }</span>
<span class="line-added"> 313             Integer startOffset = snippetStartOffsets.get(plugin.toString() + contextToUse);</span>
 314             if (startOffset == null) {
<span class="line-modified"> 315                 throw GraalError.shouldNotReachHere(&quot;plugin graph not found: &quot; + plugin + &quot; with &quot; + contextToUse);</span>
 316             }
 317 
<span class="line-modified"> 318             ResolvedJavaType accessingClass = replacements.getProviders().getMetaAccess().lookupJavaType(plugin.getDeclaringClass());</span>
<span class="line-added"> 319             return decodeGraph(original, accessingClass, startOffset, replacements, contextToUse, allowAssumptions, cancellable, options);</span>
 320         }
 321 
 322         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 323         private StructuredGraph decodeGraph(ResolvedJavaMethod method,</span>
<span class="line-modified"> 324                         ResolvedJavaType accessingClass,</span>
<span class="line-modified"> 325                         int startOffset,</span>
<span class="line-modified"> 326                         ReplacementsImpl replacements,</span>
<span class="line-added"> 327                         IntrinsicContext.CompilationContext context,</span>
<span class="line-added"> 328                         StructuredGraph.AllowAssumptions allowAssumptions,</span>
<span class="line-added"> 329                         Cancellable cancellable,</span>
<span class="line-added"> 330                         OptionValues options) {</span>
 331             Providers providers = replacements.getProviders();
<span class="line-modified"> 332             EncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses,</span>
<span class="line-modified"> 333                             methodKey(method), accessingClass, method.getDeclaringClass());</span>
<span class="line-modified"> 334             try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method, options)) {</span>
<span class="line-modified"> 335                 StructuredGraph result = new StructuredGraph.Builder(options, debug, allowAssumptions).cancellable(cancellable).method(method).setIsSubstitution(true).build();</span>
<span class="line-modified"> 336                 PEGraphDecoder graphDecoder = new SubstitutionGraphDecoder(providers, result, replacements, null, method, context, encodedGraph);</span>































 337 
 338                 graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
 339 
 340                 assert result.verify();
 341                 return result;
 342             }
 343         }
 344 
<span class="line-modified"> 345         StructuredGraph getEncodedSnippet(ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args, StructuredGraph.AllowAssumptions allowAssumptions, OptionValues options) {</span>
 346             Integer startOffset = null;
 347             if (snippetStartOffsets != null) {
 348                 startOffset = snippetStartOffsets.get(methodKey(method));
 349             }
 350             if (startOffset == null) {
 351                 if (IS_IN_NATIVE_IMAGE) {
 352                     throw GraalError.shouldNotReachHere(&quot;snippet not found: &quot; + method.format(&quot;%H.%n(%p)&quot;));
 353                 } else {
 354                     return null;
 355                 }
 356             }
 357 
<span class="line-modified"> 358             SymbolicEncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses,</span>
<span class="line-modified"> 359                             originalMethods.get(methodKey(method)), method.getDeclaringClass());</span>
<span class="line-modified"> 360             return decodeSnippetGraph(encodedGraph, method, replacements, args, allowAssumptions, options);</span>
 361         }
 362 
 363     }
 364 
<span class="line-modified"> 365     private static class SubstitutionGraphDecoder extends PEGraphDecoder {</span>
<span class="line-added"> 366         private final ResolvedJavaMethod method;</span>
<span class="line-added"> 367         private final EncodedGraph encodedGraph;</span>
<span class="line-added"> 368         private IntrinsicContext intrinsic;</span>
<span class="line-added"> 369 </span>
<span class="line-added"> 370         SubstitutionGraphDecoder(Providers providers, StructuredGraph result, ReplacementsImpl replacements, ParameterPlugin parameterPlugin, ResolvedJavaMethod method,</span>
<span class="line-added"> 371                         IntrinsicContext.CompilationContext context, EncodedGraph encodedGraph) {</span>
<span class="line-added"> 372             super(providers.getCodeCache().getTarget().arch, result, providers, null,</span>
<span class="line-added"> 373                             replacements.getGraphBuilderPlugins().getInvocationPlugins(), new InlineInvokePlugin[0], parameterPlugin,</span>
<span class="line-added"> 374                             null, null, null, null);</span>
<span class="line-added"> 375             this.method = method;</span>
<span class="line-added"> 376             this.encodedGraph = encodedGraph;</span>
<span class="line-added"> 377             intrinsic = new IntrinsicContext(method, null, replacements.getDefaultReplacementBytecodeProvider(), context, false);</span>
<span class="line-added"> 378         }</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380         @Override</span>
<span class="line-added"> 381         protected EncodedGraph lookupEncodedGraph(ResolvedJavaMethod lookupMethod,</span>
<span class="line-added"> 382                         MethodSubstitutionPlugin plugin,</span>
<span class="line-added"> 383                         BytecodeProvider intrinsicBytecodeProvider,</span>
<span class="line-added"> 384                         boolean isSubstitution,</span>
<span class="line-added"> 385                         boolean trackNodeSourcePosition) {</span>
<span class="line-added"> 386             if (lookupMethod.equals(method)) {</span>
<span class="line-added"> 387                 return encodedGraph;</span>
<span class="line-added"> 388             } else {</span>
<span class="line-added"> 389                 throw GraalError.shouldNotReachHere(method.format(&quot;%H.%n(%p)&quot;));</span>
<span class="line-added"> 390             }</span>
<span class="line-added"> 391         }</span>
<span class="line-added"> 392 </span>
<span class="line-added"> 393         @Override</span>
<span class="line-added"> 394         protected IntrinsicContext getIntrinsic() {</span>
<span class="line-added"> 395             return intrinsic;</span>
<span class="line-added"> 396         }</span>
<span class="line-added"> 397     }</span>
<span class="line-added"> 398 </span>
<span class="line-added"> 399     private StructuredGraph buildGraph(ResolvedJavaMethod method, ResolvedJavaMethod original, String originalMethodString, Object receiver, boolean requireInlining, boolean trackNodeSourcePosition,</span>
<span class="line-added"> 400                     IntrinsicContext.CompilationContext context, OptionValues options) {</span>
 401         assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
 402         Object[] args = null;
 403         if (receiver != null) {
 404             args = new Object[method.getSignature().getParameterCount(true)];
 405             args[0] = receiver;
 406         }
<span class="line-modified"> 407         // To get dumping out from this context during image building, it&#39;s necessary to pass the</span>
<span class="line-modified"> 408         // dumping options directly to the VM, otherwise they aren&#39;t available during initialization</span>
<span class="line-added"> 409         // of the backend. Use this:</span>
<span class="line-added"> 410         //</span>
<span class="line-added"> 411         // -J-Dgraal.Dump=SymbolicSnippetEncoder_:2 -J-Dgraal.PrintGraph=File</span>
<span class="line-added"> 412         // -J-Dgraal.DebugStubsAndSnippets=true</span>
<span class="line-added"> 413         IntrinsicContext.CompilationContext contextToUse = context;</span>
<span class="line-added"> 414         if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {</span>
<span class="line-added"> 415             contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;</span>
<span class="line-added"> 416         }</span>
<span class="line-added"> 417         try (DebugContext debug = openDebugContext(&quot;SymbolicSnippetEncoder_&quot;, method, options)) {</span>
<span class="line-added"> 418             StructuredGraph graph = snippetReplacements.makeGraph(debug, snippetReplacements.getDefaultReplacementBytecodeProvider(), method, args, original, trackNodeSourcePosition, null,</span>
<span class="line-added"> 419                             contextToUse);</span>
 420 
 421             // Check if all methods which should be inlined are really inlined.
 422             for (MethodCallTargetNode callTarget : graph.getNodes(MethodCallTargetNode.TYPE)) {
 423                 ResolvedJavaMethod callee = callTarget.targetMethod();
 424                 if (requireInlining &amp;&amp; !delayedInvocationPluginMethods.contains(callee) &amp;&amp; !Objects.equals(callee, original)) {
 425                     throw GraalError.shouldNotReachHere(&quot;method &quot; + callee.format(&quot;%H.%n&quot;) + &quot; not inlined in snippet &quot; + method.getName() + &quot; (maybe not final?)&quot;);
 426                 }
 427             }
<span class="line-modified"> 428             assert verifySnippetEncodeDecode(debug, method, original, originalMethodString, trackNodeSourcePosition, graph);</span>
 429             debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;After buildGraph&quot;);
 430             return graph;
 431         }
 432     }
 433 
 434     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 435     private static StructuredGraph decodeSnippetGraph(SymbolicEncodedGraph encodedGraph, ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args,</span>
<span class="line-added"> 436                     StructuredGraph.AllowAssumptions allowAssumptions, OptionValues options) {</span>
 437         Providers providers = replacements.getProviders();
 438         ParameterPlugin parameterPlugin = null;
 439         if (args != null) {
 440             parameterPlugin = new ConstantBindingParameterPlugin(args, providers.getMetaAccess(), replacements.snippetReflection);
 441         }
 442 
<span class="line-modified"> 443         try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method, options)) {</span>
 444             // @formatter:off
<span class="line-modified"> 445             StructuredGraph result = new StructuredGraph.Builder(options, debug, allowAssumptions)</span>
<span class="line-modified"> 446                     .method(method)</span>
<span class="line-modified"> 447                     .trackNodeSourcePosition(encodedGraph.trackNodeSourcePosition())</span>
<span class="line-modified"> 448                     .setIsSubstitution(true)</span>
<span class="line-modified"> 449                     .build();</span>
 450             // @formatter:on
 451             try (DebugContext.Scope scope = debug.scope(&quot;DecodeSnippetGraph&quot;, result)) {
<span class="line-modified"> 452                 PEGraphDecoder graphDecoder = new SubstitutionGraphDecoder(providers, result, replacements, parameterPlugin, method, INLINE_AFTER_PARSING, encodedGraph);</span>




























 453 
 454                 graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
 455                 debug.dump(DebugContext.VERBOSE_LEVEL, result, &quot;After decoding&quot;);
 456 
 457                 assert result.verify();
 458                 return result;
 459             } catch (Throwable t) {
 460                 throw debug.handle(t);
 461             }
 462         }
 463     }
 464 
 465     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 466     private boolean verifySnippetEncodeDecode(DebugContext debug, ResolvedJavaMethod method, ResolvedJavaMethod original, String originalMethodString, boolean trackNodeSourcePosition,</span>
<span class="line-added"> 467                     StructuredGraph graph) {</span>
 468         // Verify the encoding and decoding process
<span class="line-modified"> 469         EncodedGraph encodedGraph = GraphEncoder.encodeSingleGraph(graph, HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch);</span>
<span class="line-modified"> 470 </span>
<span class="line-modified"> 471         HotSpotProviders originalProvider = (HotSpotProviders) snippetReplacements.getProviders();</span>
<span class="line-modified"> 472 </span>
<span class="line-modified"> 473         SnippetReflectionProvider snippetReflection = originalProvider.getSnippetReflection();</span>
<span class="line-modified"> 474         SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider constantReflection = new SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider(</span>
<span class="line-modified"> 475                         originalProvider.getConstantReflection());</span>
<span class="line-modified"> 476         HotSpotProviders newProviders = new HotSpotProviders(originalProvider.getMetaAccess(), originalProvider.getCodeCache(), constantReflection,</span>
<span class="line-modified"> 477                         originalProvider.getConstantFieldProvider(), originalProvider.getForeignCalls(), originalProvider.getLowerer(), null, originalProvider.getSuites(),</span>
<span class="line-modified"> 478                         originalProvider.getRegisters(), snippetReflection, originalProvider.getWordTypes(), originalProvider.getGraphBuilderPlugins(), originalProvider.getGC());</span>
<span class="line-modified"> 479         HotSpotSnippetReplacementsImpl filteringReplacements = new HotSpotSnippetReplacementsImpl(newProviders, snippetReflection,</span>
<span class="line-modified"> 480                         originalProvider.getReplacements().getDefaultReplacementBytecodeProvider(), originalProvider.getCodeCache().getTarget());</span>
<span class="line-modified"> 481         filteringReplacements.setGraphBuilderPlugins(originalProvider.getReplacements().getGraphBuilderPlugins());</span>
<span class="line-modified"> 482         try (DebugContext.Scope scaope = debug.scope(&quot;VerifySnippetEncodeDecode&quot;, graph)) {</span>
<span class="line-modified"> 483             for (int i = 0; i &lt; encodedGraph.getNumObjects(); i++) {</span>
<span class="line-modified"> 484                 filterSnippetObject(encodedGraph.getObject(i));</span>























 485             }
<span class="line-added"> 486             StructuredGraph snippet = filteringReplacements.makeGraph(debug, filteringReplacements.getDefaultReplacementBytecodeProvider(), method, null, original,</span>
<span class="line-added"> 487                             trackNodeSourcePosition, null);</span>
<span class="line-added"> 488             SymbolicEncodedGraph symbolicGraph = new SymbolicEncodedGraph(encodedGraph, method.getDeclaringClass(), originalMethodString);</span>
<span class="line-added"> 489             StructuredGraph decodedSnippet = decodeSnippetGraph(symbolicGraph, original != null ? original : method, originalReplacements, null,</span>
<span class="line-added"> 490                             StructuredGraph.AllowAssumptions.ifNonNull(graph.getAssumptions()), graph.getOptions());</span>
<span class="line-added"> 491             String snippetString = getCanonicalGraphString(snippet, true, false);</span>
<span class="line-added"> 492             String decodedSnippetString = getCanonicalGraphString(decodedSnippet, true, false);</span>
<span class="line-added"> 493             if (snippetString.equals(decodedSnippetString)) {</span>
<span class="line-added"> 494                 debug.log(&quot;Snippet decode for %s produces exactly same graph&quot;, method);</span>
<span class="line-added"> 495                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);</span>
<span class="line-added"> 496             } else {</span>
<span class="line-added"> 497                 debug.log(&quot;Snippet decode for %s produces different graph&quot;, method);</span>
<span class="line-added"> 498                 debug.log(&quot;%s&quot;, compareGraphStrings(snippet, snippetString, decodedSnippet, decodedSnippetString));</span>
<span class="line-added"> 499                 debug.dump(DebugContext.VERBOSE_LEVEL, snippet, &quot;Snippet graph for %s&quot;, method);</span>
<span class="line-added"> 500                 debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Encoded snippet graph for %s&quot;, method);</span>
<span class="line-added"> 501                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);</span>
<span class="line-added"> 502             }</span>
<span class="line-added"> 503         } catch (Throwable t) {</span>
<span class="line-added"> 504             throw debug.handle(t);</span>
 505         }
 506         return true;
 507     }
 508 
 509     /**
 510      * If there are new graphs waiting to be encoded, reencode all the graphs and return the result.
 511      */
 512     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 513     private synchronized EncodedSnippets maybeEncodeSnippets(OptionValues options) {</span>
<span class="line-added"> 514         Set&lt;MethodSubstitutionPlugin&gt; plugins = this.knownPlugins;</span>
<span class="line-added"> 515         if (preparedPlugins != plugins.size()) {</span>
<span class="line-added"> 516             for (MethodSubstitutionPlugin plugin : plugins) {</span>
<span class="line-added"> 517                 ResolvedJavaMethod original = plugin.getOriginalMethod(originalReplacements.getProviders().getMetaAccess());</span>
<span class="line-added"> 518                 registerMethodSubstitution(plugin, original, INLINE_AFTER_PARSING, options);</span>
<span class="line-added"> 519                 if (!original.isNative()) {</span>
<span class="line-added"> 520                     registerMethodSubstitution(plugin, original, ROOT_COMPILATION_ENCODING, options);</span>
<span class="line-added"> 521                 }</span>
<span class="line-added"> 522             }</span>
<span class="line-added"> 523             preparedPlugins = plugins.size();</span>
<span class="line-added"> 524         }</span>
 525         Map&lt;String, StructuredGraph&gt; graphs = this.preparedSnippetGraphs;
 526         if (encodedGraphs != graphs.size()) {
<span class="line-modified"> 527             DebugContext debug = openDebugContext(&quot;SnippetEncoder&quot;, null, options);</span>
 528             try (DebugContext.Scope scope = debug.scope(&quot;SnippetSupportEncode&quot;)) {
 529                 encodedGraphs = graphs.size();
 530                 for (StructuredGraph graph : graphs.values()) {
 531                     for (Node node : graph.getNodes()) {
 532                         node.setNodeSourcePosition(null);
 533                     }
 534                 }
 535                 return encodeSnippets(debug);
 536             }
 537         }
 538         return null;
 539     }
 540 
<span class="line-modified"> 541     synchronized void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {</span>
<span class="line-modified"> 542         if (IS_BUILDING_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {</span>

 543             assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
 544             String key = methodKey(method);
 545             if (!preparedSnippetGraphs.containsKey(key)) {
 546                 if (original != null) {
 547                     originalMethods.put(key, methodKey(original));
 548                 }
<span class="line-modified"> 549                 StructuredGraph snippet = buildGraph(method, original, null, receiver, true, trackNodeSourcePosition, INLINE_AFTER_PARSING, options);</span>
 550                 snippetMethods.add(method);
 551                 preparedSnippetGraphs.put(key, snippet);
 552             }
 553         }
<span class="line-added"> 554 </span>
 555     }
 556 
<span class="line-modified"> 557     private synchronized EncodedSnippets encodeSnippets(DebugContext debug) {</span>
 558         GraphEncoder encoder = new GraphEncoder(HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch, debug);
 559         for (StructuredGraph graph : preparedSnippetGraphs.values()) {
 560             encoder.prepare(graph);
 561         }
 562         encoder.finishPrepare();
 563 
 564         byte[] snippetEncoding;
 565         Object[] snippetObjects;
 566         NodeClass&lt;?&gt;[] snippetNodeClasses;
 567         Map&lt;String, Integer&gt; snippetStartOffsets;
 568 
 569         snippetStartOffsets = new HashMap&lt;&gt;();
 570         for (Map.Entry&lt;String, StructuredGraph&gt; entry : preparedSnippetGraphs.entrySet()) {
 571             snippetStartOffsets.put(entry.getKey(), encoder.encode(entry.getValue()));
 572         }
 573         snippetEncoding = encoder.getEncoding();
 574         snippetObjects = encoder.getObjects();
 575         snippetNodeClasses = encoder.getNodeClasses();
 576         for (int i = 0; i &lt; snippetObjects.length; i++) {
 577             Object o = filterSnippetObject(snippetObjects[i]);
 578             debug.log(&quot;snippetObjects[%d] = %s -&gt; %s&quot;, i, o != null ? o.getClass().getSimpleName() : null, o);
 579             snippetObjects[i] = o;
 580         }
 581         debug.log(&quot;Encoded %d snippet preparedSnippetGraphs using %d bytes with %d objects&quot;, snippetStartOffsets.size(), snippetEncoding.length, snippetObjects.length);
 582         return new EncodedSnippets(snippetEncoding, snippetObjects, snippetNodeClasses, snippetStartOffsets, originalMethods);
 583     }
 584 
 585     /**
 586      * Encode any outstanding graphs and return true if any work was done.
 587      */
 588     @SuppressWarnings(&quot;try&quot;)
<span class="line-modified"> 589     public boolean encode(OptionValues options) {</span>
<span class="line-modified"> 590         EncodedSnippets encodedSnippets = maybeEncodeSnippets(options);</span>
 591         if (encodedSnippets != null) {
 592             HotSpotReplacementsImpl.setEncodedSnippets(encodedSnippets);
 593             return true;
 594         }
 595         return false;
 596     }
 597 
<span class="line-modified"> 598     private DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method, OptionValues options) {</span>
<span class="line-modified"> 599         return snippetReplacements.openDebugContext(idPrefix, method, options);</span>
 600     }
 601 
 602     static class SymbolicEncodedGraph extends EncodedGraph {
 603 
<span class="line-modified"> 604         private final ResolvedJavaType[] accessingClasses;</span>
 605         private final String originalMethod;
 606 
<span class="line-modified"> 607         SymbolicEncodedGraph(byte[] encoding, int startOffset, Object[] objects, NodeClass&lt;?&gt;[] types, String originalMethod, ResolvedJavaType... accessingClasses) {</span>
 608             super(encoding, startOffset, objects, types, null, null, null, false, false);
<span class="line-modified"> 609             this.accessingClasses = accessingClasses;</span>
 610             this.originalMethod = originalMethod;
 611         }
 612 
 613         SymbolicEncodedGraph(EncodedGraph encodedGraph, ResolvedJavaType declaringClass, String originalMethod) {
<span class="line-modified"> 614             this(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), encodedGraph.getObjects(), encodedGraph.getNodeClasses(),</span>
<span class="line-added"> 615                             originalMethod, declaringClass);</span>
 616         }
 617 
 618         @Override
 619         public Object getObject(int i) {
 620             Object o = objects[i];
<span class="line-added"> 621             Object replacement = null;</span>
 622             if (o instanceof SymbolicJVMCIReference) {
<span class="line-modified"> 623                 for (ResolvedJavaType type : accessingClasses) {</span>
<span class="line-added"> 624                     try {</span>
<span class="line-added"> 625                         replacement = ((SymbolicJVMCIReference&lt;?&gt;) o).resolve(type);</span>
<span class="line-added"> 626                         break;</span>
<span class="line-added"> 627                     } catch (NoClassDefFoundError e) {</span>
<span class="line-added"> 628                     }</span>
<span class="line-added"> 629                 }</span>
 630             } else if (o instanceof UnresolvedJavaType) {
<span class="line-modified"> 631                 for (ResolvedJavaType type : accessingClasses) {</span>
<span class="line-added"> 632                     try {</span>
<span class="line-added"> 633                         replacement = ((UnresolvedJavaType) o).resolve(type);</span>
<span class="line-added"> 634                         break;</span>
<span class="line-added"> 635                     } catch (NoClassDefFoundError e) {</span>
<span class="line-added"> 636                     }</span>
<span class="line-added"> 637                 }</span>
 638             } else if (o instanceof UnresolvedJavaMethod) {
 639                 throw new InternalError(o.toString());
 640             } else if (o instanceof UnresolvedJavaField) {
<span class="line-modified"> 641                 for (ResolvedJavaType type : accessingClasses) {</span>
<span class="line-added"> 642                     try {</span>
<span class="line-added"> 643                         replacement = ((UnresolvedJavaField) o).resolve(type);</span>
<span class="line-added"> 644                         break;</span>
<span class="line-added"> 645                     } catch (NoClassDefFoundError e) {</span>
<span class="line-added"> 646                     }</span>
<span class="line-added"> 647                 }</span>
 648             } else if (o instanceof GraalCapability) {
<span class="line-modified"> 649                 replacement = ((GraalCapability) o).resolve(((GraalJVMCICompiler) getRuntime().getCompiler()).getGraalRuntime());</span>
<span class="line-added"> 650             } else {</span>
<span class="line-added"> 651                 return o;</span>
<span class="line-added"> 652             }</span>
<span class="line-added"> 653             if (replacement != null) {</span>
<span class="line-added"> 654                 objects[i] = o = replacement;</span>
<span class="line-added"> 655             } else {</span>
<span class="line-added"> 656                 throw new GraalError(&quot;Can&#39;t resolve &quot; + o);</span>
 657             }
 658             return o;
 659         }
 660 
 661         @Override
 662         public boolean isCallToOriginal(ResolvedJavaMethod callTarget) {
 663             if (originalMethod != null &amp;&amp; originalMethod.equals(methodKey(callTarget))) {
 664                 return true;
 665             }
 666             return super.isCallToOriginal(callTarget);
 667         }
 668     }
 669 
 670     /**
 671      * Symbolic reference to an object which can be retrieved from
 672      * {@link GraalRuntime#getCapability(Class)}.
 673      */
 674     static class GraalCapability {
 675         final Class&lt;?&gt; capabilityClass;
 676 
 677         GraalCapability(Class&lt;?&gt; capabilityClass) {
 678             this.capabilityClass = capabilityClass;
 679         }
 680 
 681         public Object resolve(GraalRuntime runtime) {
 682             Object capability = runtime.getCapability(this.capabilityClass);
 683             if (capability != null) {
 684                 assert capability.getClass() == capabilityClass;
 685                 return capability;
 686             }
 687             throw new InternalError(this.capabilityClass.getName());
 688         }
 689     }
 690 
 691     static class SymbolicResolvedJavaMethod implements SymbolicJVMCIReference&lt;ResolvedJavaMethod&gt; {
 692         final UnresolvedJavaType type;
 693         final String methodName;
 694         final String signature;
 695 
<span class="line-modified"> 696         SymbolicResolvedJavaMethod(ResolvedJavaMethod method) {</span>
 697             this.type = UnresolvedJavaType.create(method.getDeclaringClass().getName());
 698             this.methodName = method.getName();
 699             this.signature = method.getSignature().toMethodDescriptor();
 700         }
 701 
 702         @Override
 703         public String toString() {
 704             return &quot;SymbolicResolvedJavaMethod{&quot; +
 705                             &quot;declaringType=&#39;&quot; + type.getName() + &#39;\&#39;&#39; +
 706                             &quot;, methodName=&#39;&quot; + methodName + &#39;\&#39;&#39; +
 707                             &quot;, signature=&#39;&quot; + signature + &#39;\&#39;&#39; +
 708                             &#39;}&#39;;
 709         }
 710 
 711         @Override
 712         public ResolvedJavaMethod resolve(ResolvedJavaType accessingClass) {
 713             ResolvedJavaType resolvedType = type.resolve(accessingClass);
<span class="line-added"> 714             if (resolvedType == null) {</span>
<span class="line-added"> 715                 throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());</span>
<span class="line-added"> 716             }</span>
 717             for (ResolvedJavaMethod method : methodName.equals(&quot;&lt;init&gt;&quot;) ? resolvedType.getDeclaredConstructors() : resolvedType.getDeclaredMethods()) {
 718                 if (method.getName().equals(methodName) &amp;&amp; method.getSignature().toMethodDescriptor().equals(signature)) {
 719                     return method;
 720                 }
 721             }
 722             throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 723         }
 724     }
 725 
 726     static class SymbolicResolvedJavaField implements SymbolicJVMCIReference&lt;ResolvedJavaField&gt; {
 727         final UnresolvedJavaType declaringType;
 728         final String name;
 729         final UnresolvedJavaType signature;
 730         private final boolean isStatic;
 731 
<span class="line-modified"> 732         SymbolicResolvedJavaField(ResolvedJavaField field) {</span>
 733             this.declaringType = UnresolvedJavaType.create(field.getDeclaringClass().getName());
 734             this.name = field.getName();
 735             this.signature = UnresolvedJavaType.create(field.getType().getName());
 736             this.isStatic = field.isStatic();
 737         }
 738 
 739         @Override
 740         public ResolvedJavaField resolve(ResolvedJavaType accessingClass) {
 741             ResolvedJavaType resolvedType = declaringType.resolve(accessingClass);
 742             ResolvedJavaType resolvedFieldType = signature.resolve(accessingClass);
 743             ResolvedJavaField[] fields = isStatic ? resolvedType.getStaticFields() : resolvedType.getInstanceFields(true);
 744             for (ResolvedJavaField field : fields) {
 745                 if (field.getName().equals(name)) {
 746                     if (field.getType().equals(resolvedFieldType)) {
 747                         return field;
 748                     }
 749                 }
 750             }
 751             throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 752         }
 753 
 754         @Override
 755         public String toString() {
 756             return &quot;SymbolicResolvedJavaField{&quot; +
 757                             signature.getName() + &#39; &#39; +
 758                             declaringType.getName() + &#39;.&#39; +
 759                             name +
 760                             &#39;}&#39;;
 761         }
 762     }
 763 
<span class="line-added"> 764     static class SymbolicResolvedJavaMethodBytecode implements SymbolicJVMCIReference&lt;ResolvedJavaMethodBytecode&gt; {</span>
<span class="line-added"> 765         SymbolicResolvedJavaMethod method;</span>
<span class="line-added"> 766 </span>
<span class="line-added"> 767         SymbolicResolvedJavaMethodBytecode(ResolvedJavaMethodBytecode bytecode) {</span>
<span class="line-added"> 768             method = new SymbolicResolvedJavaMethod(bytecode.getMethod());</span>
<span class="line-added"> 769         }</span>
<span class="line-added"> 770 </span>
<span class="line-added"> 771         @Override</span>
<span class="line-added"> 772         public ResolvedJavaMethodBytecode resolve(ResolvedJavaType accessingClass) {</span>
<span class="line-added"> 773             return new ResolvedJavaMethodBytecode(method.resolve(accessingClass));</span>
<span class="line-added"> 774         }</span>
<span class="line-added"> 775     }</span>
<span class="line-added"> 776 </span>
 777     static class SymbolicStampPair implements SymbolicJVMCIReference&lt;StampPair&gt; {
 778         Object trustedStamp;
 779         Object uncheckdStamp;
 780 
 781         SymbolicStampPair(StampPair stamp) {
 782             this.trustedStamp = maybeMakeSymbolic(stamp.getTrustedStamp());
 783             this.uncheckdStamp = maybeMakeSymbolic(stamp.getUncheckedStamp());
 784         }
 785 
 786         @Override
 787         public StampPair resolve(ResolvedJavaType accessingClass) {
 788             return StampPair.create(resolveStamp(accessingClass, trustedStamp), resolveStamp(accessingClass, uncheckdStamp));
 789         }
 790     }
 791 
 792     private static Object maybeMakeSymbolic(Stamp trustedStamp) {
 793         if (trustedStamp != null) {
 794             SymbolicJVMCIReference&lt;?&gt; symbolicJVMCIReference = trustedStamp.makeSymbolic();
 795             if (symbolicJVMCIReference != null) {
 796                 return symbolicJVMCIReference;
</pre>
<hr />
<pre>
 820         HashSet&lt;JavaConstant&gt; safeConstants = new HashSet&lt;&gt;();
 821 
 822         @Override
 823         public Boolean constantEquals(Constant x, Constant y) {
 824             return constantReflection.constantEquals(x, y);
 825         }
 826 
 827         @Override
 828         public Integer readArrayLength(JavaConstant array) {
 829             return constantReflection.readArrayLength(array);
 830         }
 831 
 832         @Override
 833         public JavaConstant readArrayElement(JavaConstant array, int index) {
 834             return constantReflection.readArrayElement(array, index);
 835         }
 836 
 837         @Override
 838         public JavaConstant readFieldValue(ResolvedJavaField field, JavaConstant receiver) {
 839             JavaConstant javaConstant = constantReflection.readFieldValue(field, receiver);
<span class="line-modified"> 840             if (!safeConstants.contains(receiver) &amp;&amp;</span>
<span class="line-added"> 841                             !field.getDeclaringClass().getName().contains(&quot;graalvm&quot;) &amp;&amp;</span>
<span class="line-added"> 842                             !field.getDeclaringClass().getName().contains(&quot;jdk/vm/ci/&quot;) &amp;&amp;</span>
<span class="line-added"> 843                             !field.getDeclaringClass().getName().contains(&quot;jdk/internal/vm/compiler&quot;) &amp;&amp;</span>
<span class="line-added"> 844 </span>
 845                             !field.getName().equals(&quot;TYPE&quot;)) {
 846                 // Only permit constant reflection on compiler classes. This is necessary primarily
 847                 // because of the boxing snippets which are compiled as snippets but are really just
 848                 // regular JDK java sources that are being compiled like a snippet. These shouldn&#39;t
 849                 // permit constant folding during graph preparation as that embeds constants from
 850                 // the runtime into a compiler graph.
 851                 return null;
 852             }
 853             if (javaConstant.getJavaKind() == JavaKind.Object) {
 854                 safeConstants.add(javaConstant);
 855             }
 856             return javaConstant;
 857         }
 858 
 859         @Override
 860         public JavaConstant boxPrimitive(JavaConstant source) {
 861             return constantReflection.boxPrimitive(source);
 862         }
 863 
 864         @Override
</pre>
<hr />
<pre>
 884         @Override
 885         public MemoryAccessProvider getMemoryAccessProvider() {
 886             return constantReflection.getMemoryAccessProvider();
 887         }
 888 
 889         @Override
 890         public JavaConstant asJavaClass(ResolvedJavaType type) {
 891             return constantReflection.asJavaClass(type);
 892         }
 893 
 894         @Override
 895         public Constant asObjectHub(ResolvedJavaType type) {
 896             return constantReflection.asObjectHub(type);
 897         }
 898     }
 899 
 900     /**
 901      * Objects embedded in encoded graphs might need to converted into a symbolic form so convert
 902      * the object or pass it through.
 903      */
<span class="line-modified"> 904     private static Object filterSnippetObject(Object o) {</span>
 905         if (o instanceof HotSpotResolvedJavaMethod) {
 906             return new SymbolicResolvedJavaMethod((HotSpotResolvedJavaMethod) o);
 907         } else if (o instanceof HotSpotResolvedJavaField) {
 908             return new SymbolicResolvedJavaField((HotSpotResolvedJavaField) o);
 909         } else if (o instanceof HotSpotResolvedJavaType) {
<span class="line-modified"> 910             return UnresolvedJavaType.create(((ResolvedJavaType) o).getName());</span>
 911         } else if (o instanceof NodeSourcePosition) {
 912             // Filter these out for now. These can&#39;t easily be handled because these positions
 913             // description snippet methods which might not be available in the runtime.
 914             return null;
 915         } else if (o instanceof HotSpotForeignCallsProvider || o instanceof GraalHotSpotVMConfig) {
 916             return new GraalCapability(o.getClass());
 917         } else if (o instanceof Stamp) {
 918             SymbolicJVMCIReference&lt;?&gt; ref = ((Stamp) o).makeSymbolic();
 919             if (ref != null) {
 920                 return ref;
 921             }
 922             return o;
 923         } else if (o instanceof StampPair) {
 924             if (((StampPair) o).getTrustedStamp() instanceof AbstractObjectStamp) {
 925                 return new SymbolicStampPair((StampPair) o);
 926             }
<span class="line-added"> 927         } else if (o instanceof ResolvedJavaMethodBytecode) {</span>
<span class="line-added"> 928             return new SymbolicResolvedJavaMethodBytecode((ResolvedJavaMethodBytecode) o);</span>
<span class="line-added"> 929         } else if (o instanceof HotSpotSignature) {</span>
<span class="line-added"> 930             throw new GraalError(o.toString());</span>
 931         }
 932         return o;
 933     }
 934 
<span class="line-modified"> 935     private static String compareGraphStrings(StructuredGraph expectedGraph, String expectedString, StructuredGraph actualGraph, String actualString) {</span>
 936         if (!expectedString.equals(actualString)) {
 937             String[] expectedLines = expectedString.split(&quot;\n&quot;);
 938             String[] actualLines = actualString.split(&quot;\n&quot;);
 939             int diffIndex = -1;
 940             int limit = Math.min(actualLines.length, expectedLines.length);
 941             String marker = &quot; &lt;&lt;&lt;&quot;;
 942             for (int i = 0; i &lt; limit; i++) {
 943                 if (!expectedLines[i].equals(actualLines[i])) {
 944                     diffIndex = i;
 945                     break;
 946                 }
 947             }
 948             if (diffIndex == -1) {
 949                 // Prefix is the same so add some space after the prefix
 950                 diffIndex = limit;
 951                 if (actualLines.length == limit) {
 952                     actualLines = Arrays.copyOf(actualLines, limit + 1);
 953                     actualLines[diffIndex] = &quot;&quot;;
 954                 } else {
 955                     assert expectedLines.length == limit;
 956                     expectedLines = Arrays.copyOf(expectedLines, limit + 1);
 957                     expectedLines[diffIndex] = &quot;&quot;;
 958                 }
 959             }
 960             // Place a marker next to the first line that differs
 961             expectedLines[diffIndex] = expectedLines[diffIndex] + marker;
 962             actualLines[diffIndex] = actualLines[diffIndex] + marker;
 963             String ediff = String.join(&quot;\n&quot;, expectedLines);
 964             String adiff = String.join(&quot;\n&quot;, actualLines);
 965             return &quot;mismatch in preparedSnippetGraphs:\n========= expected (&quot; + expectedGraph + &quot;) =========\n&quot; + ediff + &quot;\n\n========= actual (&quot; + actualGraph + &quot;) =========\n&quot; + adiff;
 966         } else {
 967             return &quot;mismatch in preparedSnippetGraphs&quot;;
 968         }
 969     }
 970 
<span class="line-modified"> 971     private static String getCanonicalGraphString(StructuredGraph graph, boolean excludeVirtual, boolean checkConstants) {</span>
 972         SchedulePhase schedule = new SchedulePhase(SchedulePhase.SchedulingStrategy.EARLIEST);
 973         schedule.apply(graph);
 974         StructuredGraph.ScheduleResult scheduleResult = graph.getLastSchedule();
 975 
 976         NodeMap&lt;Integer&gt; canonicalId = graph.createNodeMap();
 977         int nextId = 0;
 978 
 979         List&lt;String&gt; constantsLines = new ArrayList&lt;&gt;();
 980 
 981         StringBuilder result = new StringBuilder();
 982         for (Block block : scheduleResult.getCFG().getBlocks()) {
 983             result.append(&quot;Block &quot;).append(block).append(&#39; &#39;);
 984             if (block == scheduleResult.getCFG().getStartBlock()) {
 985                 result.append(&quot;* &quot;);
 986             }
 987             result.append(&quot;-&gt; &quot;);
 988             for (Block succ : block.getSuccessors()) {
 989                 result.append(succ).append(&#39; &#39;);
 990             }
 991             result.append(&#39;\n&#39;);
</pre>
<hr />
<pre>
1031         if (checkConstants) {
1032             constantsLinesResult.append(constantsLines.size()).append(&quot; constants:\n&quot;);
1033         }
1034         Collections.sort(constantsLines);
1035         for (String s : constantsLines) {
1036             constantsLinesResult.append(s);
1037             constantsLinesResult.append(&#39;\n&#39;);
1038         }
1039 
1040         return constantsLinesResult.toString() + result.toString();
1041     }
1042 
1043     private static int filteredUsageCount(Node node) {
1044         return node.usages().filter(n -&gt; !(n instanceof FrameState)).count();
1045     }
1046 
1047     /**
1048      * This horror show of classes exists solely get {@link HotSpotSnippetBytecodeParser} to be used
1049      * as the parser for these snippets.
1050      */
<span class="line-modified">1051     class HotSpotSnippetReplacementsImpl extends HotSpotReplacementsImpl {</span>
1052         HotSpotSnippetReplacementsImpl(HotSpotReplacementsImpl replacements, Providers providers) {
1053             super(replacements, providers);
1054         }
1055 
<span class="line-modified">1056         HotSpotSnippetReplacementsImpl(Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider, TargetDescription target) {</span>
<span class="line-modified">1057             super(providers, snippetReflection, bytecodeProvider, target);</span>
1058         }
1059 
1060         @Override
1061         protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
1062             return new SnippetGraphMaker(this, substitute, original);
1063         }
1064     }
1065 
<span class="line-modified">1066     class SnippetGraphMaker extends ReplacementsImpl.GraphMaker {</span>
1067         SnippetGraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
1068             super(replacements, substitute, substitutedMethod);
1069         }
1070 
1071         @Override
<span class="line-modified">1072         protected GraphBuilderPhase.Instance createGraphBuilder(Providers providers, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts,</span>
<span class="line-modified">1073                         IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">1074             return new HotSpotSnippetGraphBuilderPhase(providers, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>

1075         }
1076     }
1077 
<span class="line-modified">1078     class HotSpotSnippetGraphBuilderPhase extends GraphBuilderPhase.Instance {</span>
<span class="line-modified">1079         HotSpotSnippetGraphBuilderPhase(Providers theProviders, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">1080             super(theProviders, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>

1081         }
1082 
1083         @Override
1084         protected BytecodeParser createBytecodeParser(StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI, IntrinsicContext intrinsicContext) {
1085             return new HotSpotSnippetBytecodeParser(this, graph, parent, method, entryBCI, intrinsicContext);
1086         }
1087     }
1088 
<span class="line-modified">1089     class HotSpotSnippetBytecodeParser extends BytecodeParser {</span>
1090         HotSpotSnippetBytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI,
1091                         IntrinsicContext intrinsicContext) {
1092             super(graphBuilderInstance, graph, parent, method, entryBCI, intrinsicContext);
1093         }
1094 
1095         @Override
1096         public boolean canDeferPlugin(GeneratedInvocationPlugin plugin) {
<span class="line-modified">1097             // Fold is always deferred but NodeIntrinsics may have to wait if all their arguments</span>
<span class="line-added">1098             // aren&#39;t constant yet.</span>
<span class="line-added">1099             return plugin.isGeneratedFromFoldOrNodeIntrinsic();</span>
<span class="line-added">1100         }</span>
<span class="line-added">1101 </span>
<span class="line-added">1102         @Override</span>
<span class="line-added">1103         protected boolean canInlinePartialIntrinsicExit() {</span>
<span class="line-added">1104             return false;</span>
1105         }
1106 
1107         @Override
<span class="line-modified">1108         protected boolean tryInvocationPlugin(CallTargetNode.InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {</span>
1109             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1110                 return false;
1111             }
<span class="line-modified">1112             if (targetMethod.getAnnotation(Fold.class) != null) {</span>
<span class="line-added">1113                 // Always defer Fold until decode time but NodeIntrinsics may fold if they are able.</span>
<span class="line-added">1114                 return false;</span>
<span class="line-added">1115             }</span>
<span class="line-added">1116             InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);</span>
<span class="line-added">1117             if (conditionalPlugins.contains(plugin)) {</span>
<span class="line-added">1118                 // Because supporting arbitrary plugins in the context of encoded graphs is complex</span>
<span class="line-added">1119                 // we disallow it. This limitation can be worked around through the use of method</span>
<span class="line-added">1120                 // substitutions.</span>
<span class="line-added">1121                 throw new GraalError(&quot;conditional plugins are unsupported in snippets and method substitutions: &quot; + targetMethod + &quot; &quot; + plugin);</span>
<span class="line-added">1122             }</span>
<span class="line-added">1123             return super.tryInvocationPlugin(invokeKind, args, targetMethod, resultType);</span>
1124         }
1125     }
1126 }
</pre>
</td>
</tr>
</table>
<center><a href="JVMCIVersionCheck.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="debug/BenchmarkCounters.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
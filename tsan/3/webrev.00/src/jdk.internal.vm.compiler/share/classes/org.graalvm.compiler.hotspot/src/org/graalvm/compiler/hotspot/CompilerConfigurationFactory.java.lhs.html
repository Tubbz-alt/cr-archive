<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilerConfigurationFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static jdk.vm.ci.common.InitTimer.timer;
 28 
<a name="2" id="anc2"></a><span class="line-removed"> 29 import java.net.URL;</span>
 30 import java.util.ArrayList;
 31 import java.util.Collection;
 32 import java.util.Collections;
 33 import java.util.List;
 34 import java.util.stream.Collectors;
 35 
 36 import jdk.internal.vm.compiler.collections.EconomicMap;
 37 import org.graalvm.compiler.core.common.SuppressFBWarnings;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.debug.TTY;
 40 import org.graalvm.compiler.lir.phases.LIRPhase;
 41 import org.graalvm.compiler.lir.phases.LIRPhaseSuite;
 42 import org.graalvm.compiler.options.EnumOptionKey;
 43 import org.graalvm.compiler.options.Option;
 44 import org.graalvm.compiler.options.OptionKey;
<a name="3" id="anc3"></a>
 45 import org.graalvm.compiler.options.OptionType;
 46 import org.graalvm.compiler.options.OptionValues;
 47 import org.graalvm.compiler.phases.BasePhase;
 48 import org.graalvm.compiler.phases.PhaseSuite;
 49 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
 50 import org.graalvm.compiler.serviceprovider.GraalServices;
 51 
 52 import jdk.vm.ci.code.Architecture;
 53 import jdk.vm.ci.common.InitTimer;
<a name="4" id="anc4"></a>
 54 
 55 /**
<a name="5" id="anc5"></a><span class="line-modified"> 56  * A factory that creates the {@link CompilerConfiguration} the Graal compiler will use. Each</span>
<span class="line-modified"> 57  * factory must have a unique {@link #name} and {@link #autoSelectionPriority}. The latter imposes a</span>
<span class="line-modified"> 58  * total ordering between factories for the purpose of auto-selecting the factory to use.</span>
 59  */
 60 public abstract class CompilerConfigurationFactory implements Comparable&lt;CompilerConfigurationFactory&gt; {
 61 
 62     enum ShowConfigurationLevel {
 63         none,
 64         info,
 65         verbose
 66     }
 67 
 68     static class Options {
 69         // @formatter:off
<a name="6" id="anc6"></a><span class="line-modified"> 70         @Option(help = &quot;Names the Graal compiler configuration to use. If omitted, the compiler configuration &quot; +</span>
 71                        &quot;with the highest auto-selection priority is used. To see the set of available configurations, &quot; +
<a name="7" id="anc7"></a><span class="line-modified"> 72                        &quot;supply the value &#39;help&#39; to this option.&quot;, type = OptionType.Expert)</span>
 73         public static final OptionKey&lt;String&gt; CompilerConfiguration = new OptionKey&lt;&gt;(null);
<a name="8" id="anc8"></a><span class="line-modified"> 74         @Option(help = &quot;Writes to the VM log information about the Graal compiler configuration selected.&quot;, type = OptionType.User)</span>
 75         public static final OptionKey&lt;ShowConfigurationLevel&gt; ShowConfiguration = new EnumOptionKey&lt;&gt;(ShowConfigurationLevel.none);
 76         // @formatter:on
 77     }
 78 
 79     /**
 80      * The name of this factory. This must be unique across all factory instances and is used when
 81      * selecting a factory based on the value of {@link Options#CompilerConfiguration}.
 82      */
 83     private final String name;
 84 
 85     /**
 86      * The priority of this factory. This must be unique across all factory instances and is used
 87      * when selecting a factory when {@link Options#CompilerConfiguration} is omitted
 88      */
 89     private final int autoSelectionPriority;
 90 
 91     protected CompilerConfigurationFactory(String name, int autoSelectionPriority) {
 92         this.name = name;
 93         this.autoSelectionPriority = autoSelectionPriority;
 94     }
 95 
 96     public abstract CompilerConfiguration createCompilerConfiguration();
 97 
 98     /**
 99      * Collect the set of available {@linkplain HotSpotBackendFactory backends} for this compiler
100      * configuration.
101      */
102     public BackendMap createBackendMap() {
103         // default to backend with the same name as the compiler configuration
104         return new DefaultBackendMap(name);
105     }
106 
107     /**
108      * Returns a name that should uniquely identify this compiler configuration.
109      */
110     public final String getName() {
111         return name;
112     }
113 
114     public interface BackendMap {
115         HotSpotBackendFactory getBackendFactory(Architecture arch);
116     }
117 
118     public static class DefaultBackendMap implements BackendMap {
119 
120         private final EconomicMap&lt;Class&lt;? extends Architecture&gt;, HotSpotBackendFactory&gt; backends = EconomicMap.create();
121 
122         @SuppressWarnings(&quot;try&quot;)
123         public DefaultBackendMap(String backendName) {
124             try (InitTimer t = timer(&quot;HotSpotBackendFactory.register&quot;)) {
125                 for (HotSpotBackendFactory backend : GraalServices.load(HotSpotBackendFactory.class)) {
126                     if (backend.getName().equals(backendName)) {
127                         Class&lt;? extends Architecture&gt; arch = backend.getArchitecture();
128                         HotSpotBackendFactory oldEntry = backends.put(arch, backend);
129                         assert oldEntry == null || oldEntry == backend : &quot;duplicate Graal backend&quot;;
130                     }
131                 }
132             }
133         }
134 
135         @Override
136         public final HotSpotBackendFactory getBackendFactory(Architecture arch) {
137             return backends.get(arch.getClass());
138         }
139     }
140 
141     @Override
142     public int compareTo(CompilerConfigurationFactory o) {
143         if (autoSelectionPriority &gt; o.autoSelectionPriority) {
144             return -1;
145         }
146         if (autoSelectionPriority &lt; o.autoSelectionPriority) {
147             return 1;
148         }
149         assert this == o : &quot;distinct compiler configurations cannot have the same auto selection priority&quot;;
150         return 0;
151     }
152 
153     /**
154      * Asserts uniqueness of {@link #name} and {@link #autoSelectionPriority} for {@code factory} in
155      * {@code factories}.
156      */
157     private static boolean checkUnique(CompilerConfigurationFactory factory, List&lt;CompilerConfigurationFactory&gt; factories) {
158         for (CompilerConfigurationFactory other : factories) {
159             if (other != factory) {
160                 assert !other.name.equals(factory.name) : factory.getClass().getName() + &quot; cannot have the same selector as &quot; + other.getClass().getName() + &quot;: &quot; + factory.name;
161                 assert other.autoSelectionPriority != factory.autoSelectionPriority : factory.getClass().getName() + &quot; cannot have the same auto-selection priority as &quot; +
162                                 other.getClass().getName() +
163                                 &quot;: &quot; + factory.autoSelectionPriority;
164             }
165         }
166         return true;
167     }
168 
169     /**
170      * @return sorted list of {@link CompilerConfigurationFactory}s
171      */
172     @SuppressFBWarnings(value = &quot;DLS_DEAD_LOCAL_STORE&quot;, justification = &quot;false positive on dead store to `candidates`&quot;)
173     private static List&lt;CompilerConfigurationFactory&gt; getAllCandidates() {
174         List&lt;CompilerConfigurationFactory&gt; candidates = new ArrayList&lt;&gt;();
175         for (CompilerConfigurationFactory candidate : GraalServices.load(CompilerConfigurationFactory.class)) {
176             assert checkUnique(candidate, candidates);
177             candidates.add(candidate);
178         }
179         Collections.sort(candidates);
180         return candidates;
181     }
182 
183     /**
184      * Selects and instantiates a {@link CompilerConfigurationFactory}. The selection algorithm is
185      * as follows: if {@code name} is non-null, then select the factory with the same name else if
186      * {@code Options.CompilerConfiguration.getValue()} is non-null then select the factory whose
187      * name matches the value else select the factory with the highest
188      * {@link #autoSelectionPriority} value.
189      *
190      * @param name the name of the compiler configuration to select (optional)
191      */
192     @SuppressWarnings(&quot;try&quot;)
193     public static CompilerConfigurationFactory selectFactory(String name, OptionValues options) {
194         CompilerConfigurationFactory factory = null;
195         try (InitTimer t = timer(&quot;CompilerConfigurationFactory.selectFactory&quot;)) {
196             String value = name == null ? Options.CompilerConfiguration.getValue(options) : name;
197             if (&quot;help&quot;.equals(value)) {
<a name="9" id="anc9"></a><span class="line-modified">198                 System.out.println(&quot;The available Graal compiler configurations are:&quot;);</span>
199                 for (CompilerConfigurationFactory candidate : getAllCandidates()) {
200                     System.out.println(&quot;    &quot; + candidate.name);
201                 }
<a name="10" id="anc10"></a><span class="line-modified">202                 System.exit(0);</span>
203             } else if (value != null) {
204                 for (CompilerConfigurationFactory candidate : GraalServices.load(CompilerConfigurationFactory.class)) {
205                     if (candidate.name.equals(value)) {
206                         factory = candidate;
207                         break;
208                     }
209                 }
210                 if (factory == null) {
<a name="11" id="anc11"></a><span class="line-modified">211                     throw new GraalError(&quot;Graal compiler configuration &#39;%s&#39; not found. Available configurations are: %s&quot;, value,</span>
212                                     getAllCandidates().stream().map(c -&gt; c.name).collect(Collectors.joining(&quot;, &quot;)));
213                 }
214             } else {
215                 List&lt;CompilerConfigurationFactory&gt; candidates = getAllCandidates();
216                 if (candidates.isEmpty()) {
217                     throw new GraalError(&quot;No %s providers found&quot;, CompilerConfigurationFactory.class.getName());
218                 }
219                 factory = candidates.get(0);
220             }
221         }
<a name="12" id="anc12"></a>

222         ShowConfigurationLevel level = Options.ShowConfiguration.getValue(options);
223         if (level != ShowConfigurationLevel.none) {
224             switch (level) {
225                 case info: {
226                     printConfigInfo(factory);
227                     break;
228                 }
229                 case verbose: {
230                     printConfigInfo(factory);
231                     CompilerConfiguration config = factory.createCompilerConfiguration();
232                     TTY.println(&quot;High tier: &quot; + phaseNames(config.createHighTier(options)));
233                     TTY.println(&quot;Mid tier: &quot; + phaseNames(config.createMidTier(options)));
234                     TTY.println(&quot;Low tier: &quot; + phaseNames(config.createLowTier(options)));
235                     TTY.println(&quot;Pre regalloc stage: &quot; + phaseNames(config.createPreAllocationOptimizationStage(options)));
236                     TTY.println(&quot;Regalloc stage: &quot; + phaseNames(config.createAllocationStage(options)));
237                     TTY.println(&quot;Post regalloc stage: &quot; + phaseNames(config.createPostAllocationOptimizationStage(options)));
238                     config.createAllocationStage(options);
239                     break;
240                 }
241             }
242         }
243         return factory;
244     }
245 
246     private static void printConfigInfo(CompilerConfigurationFactory factory) {
<a name="13" id="anc13"></a><span class="line-modified">247         URL location = factory.getClass().getResource(factory.getClass().getSimpleName() + &quot;.class&quot;);</span>
<span class="line-modified">248         TTY.printf(&quot;Using Graal compiler configuration &#39;%s&#39; provided by %s loaded from %s%n&quot;, factory.name, factory.getClass().getName(), location);</span>
249     }
250 
251     private static &lt;C&gt; List&lt;String&gt; phaseNames(PhaseSuite&lt;C&gt; suite) {
252         Collection&lt;BasePhase&lt;? super C&gt;&gt; phases = suite.getPhases();
253         List&lt;String&gt; res = new ArrayList&lt;&gt;(phases.size());
254         for (BasePhase&lt;?&gt; phase : phases) {
255             res.add(phase.contractorName());
256         }
257         Collections.sort(res);
258         return res;
259     }
260 
261     private static &lt;C&gt; List&lt;String&gt; phaseNames(LIRPhaseSuite&lt;C&gt; suite) {
262         List&lt;LIRPhase&lt;C&gt;&gt; phases = suite.getPhases();
263         List&lt;String&gt; res = new ArrayList&lt;&gt;(phases.size());
264         for (LIRPhase&lt;?&gt; phase : phases) {
265             res.add(phase.getClass().getName());
266         }
267         Collections.sort(res);
268         return res;
269     }
270 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
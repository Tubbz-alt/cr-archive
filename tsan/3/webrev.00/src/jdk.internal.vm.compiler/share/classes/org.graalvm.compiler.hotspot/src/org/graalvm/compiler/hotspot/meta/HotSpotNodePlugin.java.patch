diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotNodePlugin.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotNodePlugin.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotNodePlugin.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotNodePlugin.java
@@ -25,12 +25,13 @@
 package org.graalvm.compiler.hotspot.meta;
 
 import static jdk.vm.ci.meta.DeoptimizationAction.None;
 import static jdk.vm.ci.meta.DeoptimizationReason.TransferToInterpreter;
 import static org.graalvm.compiler.core.common.GraalOptions.ImmutableCode;
+import static org.graalvm.compiler.hotspot.meta.HotSpotNodePlugin.Options.HotSpotPostOnExceptions;
 
-import java.lang.reflect.Field;
+import java.util.function.Supplier;
 
 import org.graalvm.compiler.core.common.CompilationIdentifier;
 import org.graalvm.compiler.core.common.type.StampFactory;
 import org.graalvm.compiler.core.common.type.StampPair;
 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
@@ -38,10 +39,11 @@
 import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
 import org.graalvm.compiler.hotspot.word.HotSpotWordTypes;
 import org.graalvm.compiler.nodes.ConstantNode;
 import org.graalvm.compiler.nodes.FixedGuardNode;
 import org.graalvm.compiler.nodes.FixedWithNextNode;
+import org.graalvm.compiler.nodes.FrameState;
 import org.graalvm.compiler.nodes.LogicNode;
 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 import org.graalvm.compiler.nodes.StructuredGraph;
 import org.graalvm.compiler.nodes.ValueNode;
 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
@@ -54,10 +56,14 @@
 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
 import org.graalvm.compiler.nodes.memory.ReadNode;
 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 import org.graalvm.compiler.nodes.util.ConstantFoldUtil;
+import org.graalvm.compiler.options.Option;
+import org.graalvm.compiler.options.OptionKey;
+import org.graalvm.compiler.options.OptionType;
+import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;
 import org.graalvm.compiler.word.Word;
 import org.graalvm.compiler.word.WordOperationPlugin;
 import jdk.internal.vm.compiler.word.LocationIdentity;
 
 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
@@ -81,10 +87,16 @@
  * i.e., there are never non-inlined invokes that involve the {@link Word} type.</li>
  * <li>Constant folding of field loads.</li>
  * </ul>
  */
 public final class HotSpotNodePlugin implements NodePlugin, TypePlugin {
+    public static class Options {
+        @Option(help = "Testing only option that forces deopts for exception throws", type = OptionType.Expert)//
+        public static final OptionKey<Boolean> HotSpotPostOnExceptions = new OptionKey<>(false);
+    }
+
+    private static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();
     protected final WordOperationPlugin wordOperationPlugin;
     private final GraalHotSpotVMConfig config;
     private final HotSpotWordTypes wordTypes;
 
     public HotSpotNodePlugin(WordOperationPlugin wordOperationPlugin, GraalHotSpotVMConfig config, HotSpotWordTypes wordTypes) {
@@ -207,57 +219,44 @@
         }
         return false;
     }
 
     @Override
-    public FixedWithNextNode instrumentExceptionDispatch(StructuredGraph graph, FixedWithNextNode afterExceptionLoaded) {
+    public FixedWithNextNode instrumentExceptionDispatch(StructuredGraph graph, FixedWithNextNode afterExceptionLoaded, Supplier<FrameState> frameStateFunction) {
         CompilationIdentifier id = graph.compilationId();
-        if (id instanceof HotSpotCompilationIdentifier) {
+        if (id instanceof HotSpotCompilationIdentifier &&
+                        config.jvmciCompileStateCanPostOnExceptionsOffset != Integer.MIN_VALUE &&
+                        config.javaThreadShouldPostOnExceptionsFlagOffset != Integer.MIN_VALUE) {
+            boolean canPostOnExceptions = HotSpotPostOnExceptions.getValue(graph.getOptions());
             HotSpotCompilationRequest request = ((HotSpotCompilationIdentifier) id).getRequest();
             if (request != null) {
                 long compileState = request.getJvmciEnv();
-                if (compileState != 0 &&
-                                config.jvmciCompileStateCanPostOnExceptionsOffset != Integer.MIN_VALUE &&
-                                config.javaThreadShouldPostOnExceptionsFlagOffset != Integer.MIN_VALUE) {
+                if (compileState != 0) {
                     long canPostOnExceptionsOffset = compileState + config.jvmciCompileStateCanPostOnExceptionsOffset;
-                    boolean canPostOnExceptions = UNSAFE.getByte(canPostOnExceptionsOffset) != 0;
-                    if (canPostOnExceptions) {
-                        // If the exception capability is set, then generate code
-                        // to check the JavaThread.should_post_on_exceptions flag to see
-                        // if we actually need to report exception events for the current
-                        // thread. If not, take the fast path otherwise deoptimize.
-                        CurrentJavaThreadNode thread = graph.unique(new CurrentJavaThreadNode(wordTypes.getWordKind()));
-                        ValueNode offset = graph.unique(ConstantNode.forLong(config.javaThreadShouldPostOnExceptionsFlagOffset));
-                        AddressNode address = graph.unique(new OffsetAddressNode(thread, offset));
-                        ReadNode shouldPostException = graph.add(new ReadNode(address, JAVA_THREAD_SHOULD_POST_ON_EXCEPTIONS_FLAG_LOCATION, StampFactory.intValue(), BarrierType.NONE));
-                        afterExceptionLoaded.setNext(shouldPostException);
-                        ValueNode zero = graph.unique(ConstantNode.forInt(0));
-                        LogicNode cond = graph.unique(new IntegerEqualsNode(shouldPostException, zero));
-                        FixedGuardNode check = graph.add(new FixedGuardNode(cond, TransferToInterpreter, None, false));
-                        shouldPostException.setNext(check);
-                        return check;
-                    }
+                    canPostOnExceptions = UNSAFE.getByte(canPostOnExceptionsOffset) != 0;
                 }
             }
+            if (canPostOnExceptions) {
+                // If the exception capability is set, then generate code
+                // to check the JavaThread.should_post_on_exceptions flag to see
+                // if we actually need to report exception events for the current
+                // thread. If not, take the fast path otherwise deoptimize.
+                CurrentJavaThreadNode thread = graph.unique(new CurrentJavaThreadNode(wordTypes.getWordKind()));
+                ValueNode offset = graph.unique(ConstantNode.forLong(config.javaThreadShouldPostOnExceptionsFlagOffset));
+                AddressNode address = graph.unique(new OffsetAddressNode(thread, offset));
+                ReadNode shouldPostException = graph.add(new ReadNode(address, JAVA_THREAD_SHOULD_POST_ON_EXCEPTIONS_FLAG_LOCATION, StampFactory.intValue(), BarrierType.NONE));
+                afterExceptionLoaded.setNext(shouldPostException);
+                ValueNode zero = graph.unique(ConstantNode.forInt(0));
+                LogicNode cond = graph.unique(new IntegerEqualsNode(shouldPostException, zero));
+                FixedGuardNode check = graph.add(new FixedGuardNode(cond, TransferToInterpreter, None, false));
+                FrameState fs = frameStateFunction.get();
+                assert fs.stackSize() == 1 && fs.rethrowException() : "expected rethrow exception FrameState";
+                check.setStateBefore(fs);
+                shouldPostException.setNext(check);
+                return check;
+            }
         }
         return afterExceptionLoaded;
     }
 
     private static final LocationIdentity JAVA_THREAD_SHOULD_POST_ON_EXCEPTIONS_FLAG_LOCATION = NamedLocationIdentity.mutable("JavaThread::_should_post_on_exceptions_flag");
-    static final Unsafe UNSAFE = initUnsafe();
-
-    static Unsafe initUnsafe() {
-        try {
-            // Fast path when we are trusted.
-            return Unsafe.getUnsafe();
-        } catch (SecurityException se) {
-            // Slow path when we are not trusted.
-            try {
-                Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
-                theUnsafe.setAccessible(true);
-                return (Unsafe) theUnsafe.get(Unsafe.class);
-            } catch (Exception e) {
-                throw new RuntimeException("exception while trying to get Unsafe", e);
-            }
-        }
-    }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/ForeignCallStub.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ExceptionHandlerStub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="OutOfBoundsExceptionStub.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/stubs/ForeignCallStub.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.stubs;
 26 
 27 import static jdk.vm.ci.code.BytecodeFrame.UNKNOWN_BCI;
 28 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.JavaCall;
 29 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.JavaCallee;
 30 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.NativeCall;
<span class="line-modified"> 31 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.DESTROYS_REGISTERS;</span>
<span class="line-modified"> 32 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.PRESERVES_REGISTERS;</span>
 33 import static org.graalvm.compiler.nodes.CallTargetNode.InvokeKind.Static;
 34 import static org.graalvm.compiler.nodes.ConstantNode.forBoolean;
 35 
 36 import org.graalvm.compiler.core.common.CompilationIdentifier;
 37 import org.graalvm.compiler.core.common.LIRKind;
 38 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 39 import org.graalvm.compiler.core.common.type.Stamp;
 40 import org.graalvm.compiler.core.common.type.StampFactory;
 41 import org.graalvm.compiler.core.common.type.StampPair;
 42 import org.graalvm.compiler.debug.DebugContext;
 43 import org.graalvm.compiler.debug.GraalError;
 44 import org.graalvm.compiler.debug.JavaMethodContext;
 45 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 46 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Reexecutability;
 47 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition;
 48 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkageImpl;
 49 import org.graalvm.compiler.hotspot.meta.HotSpotLoweringProvider;
 50 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 51 import org.graalvm.compiler.hotspot.nodes.StubForeignCallNode;
 52 import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets.Templates;
 53 import org.graalvm.compiler.nodes.InvokeNode;
 54 import org.graalvm.compiler.nodes.ParameterNode;
 55 import org.graalvm.compiler.nodes.ReturnNode;
 56 import org.graalvm.compiler.nodes.StructuredGraph;
 57 import org.graalvm.compiler.nodes.ValueNode;
 58 import org.graalvm.compiler.options.OptionValues;
<span class="line-removed"> 59 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;</span>
 60 import org.graalvm.compiler.replacements.GraphKit;
 61 import org.graalvm.compiler.replacements.nodes.ReadRegisterNode;
 62 import org.graalvm.compiler.word.Word;
 63 import org.graalvm.compiler.word.WordTypes;
 64 import jdk.internal.vm.compiler.word.LocationIdentity;
 65 
 66 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 67 import jdk.vm.ci.hotspot.HotSpotSignature;
 68 import jdk.vm.ci.meta.JavaKind;
 69 import jdk.vm.ci.meta.JavaMethod;
 70 import jdk.vm.ci.meta.JavaType;
 71 import jdk.vm.ci.meta.MetaAccessProvider;
 72 import jdk.vm.ci.meta.ResolvedJavaMethod;
 73 import jdk.vm.ci.meta.ResolvedJavaType;
 74 import jdk.vm.ci.meta.Signature;
 75 
 76 /**
 77  * A {@linkplain #getGraph generated} stub for a {@link Transition non-leaf} foreign call from
 78  * compiled code. A stub is required for such calls as the caller may be scheduled for
 79  * deoptimization while the call is in progress. And since these are foreign/runtime calls on slow
</pre>
<hr />
<pre>
 95      * Specifies if the JavaThread value for the current thread is to be prepended to the arguments
 96      * for the call to {@link #target}.
 97      */
 98     protected final boolean prependThread;
 99 
100     /**
101      * Creates a stub for a call to code at a given address.
102      *
103      * @param address the address of the code to call
104      * @param descriptor the signature of the call to this stub
105      * @param prependThread true if the JavaThread value for the current thread is to be prepended
106      *            to the arguments for the call to {@code address}
107      * @param reexecutability specifies if the stub call can be re-executed without (meaningful)
108      *            side effects. Deoptimization will not return to a point before a stub call that
109      *            cannot be re-executed.
110      * @param killedLocations the memory locations killed by the stub call
111      */
112     public ForeignCallStub(OptionValues options, HotSpotJVMCIRuntime runtime, HotSpotProviders providers, long address, ForeignCallDescriptor descriptor, boolean prependThread,
113                     Transition transition, Reexecutability reexecutability, LocationIdentity... killedLocations) {
114         super(options, providers, HotSpotForeignCallLinkageImpl.create(providers.getMetaAccess(), providers.getCodeCache(), providers.getWordTypes(), providers.getForeignCalls(), descriptor, 0L,
<span class="line-modified">115                         PRESERVES_REGISTERS, JavaCall, JavaCallee, transition, reexecutability, killedLocations));</span>
116         this.jvmciRuntime = runtime;
117         this.prependThread = prependThread;
118         MetaAccessProvider metaAccess = providers.getMetaAccess();
119         Class&lt;?&gt;[] targetParameterTypes = createTargetParameters(descriptor);
120         ForeignCallDescriptor targetSig = new ForeignCallDescriptor(descriptor.getName() + &quot;:C&quot;, descriptor.getResultType(), targetParameterTypes);
121         target = HotSpotForeignCallLinkageImpl.create(metaAccess, providers.getCodeCache(), providers.getWordTypes(), providers.getForeignCalls(), targetSig, address,
<span class="line-modified">122                         DESTROYS_REGISTERS, NativeCall, NativeCall, transition, reexecutability, killedLocations);</span>
123     }
124 
125     /**
126      * Gets the linkage information for the call from this stub.
127      */
128     public HotSpotForeignCallLinkage getTargetLinkage() {
129         return target;
130     }
131 
132     private Class&lt;?&gt;[] createTargetParameters(ForeignCallDescriptor descriptor) {
133         Class&lt;?&gt;[] parameters = descriptor.getArgumentTypes();
134         if (prependThread) {
135             Class&lt;?&gt;[] newParameters = new Class&lt;?&gt;[parameters.length + 1];
136             System.arraycopy(parameters, 0, newParameters, 1, parameters.length);
137             newParameters[0] = Word.class;
138             return newParameters;
139         }
140         return parameters;
141     }
142 
</pre>
<hr />
<pre>
219      *
220      * &lt;pre&gt;
221      *     void foreignFunctionStub(args...) {
222      *         foreignFunction(currentThread,  args);
223      *         if ((shouldClearException &amp;&amp; clearPendingException(thread())) || (!shouldClearException &amp;&amp; hasPendingException(thread)) {
224      *             DeoptimizeCallerNode.deopt(None, RuntimeConstraint);
225      *         }
226      *     }
227      * &lt;/pre&gt;
228      *
229      * In each example above, the {@code currentThread} argument is the C++ JavaThread value (i.e.,
230      * %r15 on AMD64) and is only prepended if {@link #prependThread} is true.
231      */
232     @Override
233     @SuppressWarnings(&quot;try&quot;)
234     protected StructuredGraph getGraph(DebugContext debug, CompilationIdentifier compilationId) {
235         WordTypes wordTypes = providers.getWordTypes();
236         Class&lt;?&gt;[] args = linkage.getDescriptor().getArgumentTypes();
237         boolean isObjectResult = !LIRKind.isValue(linkage.getOutgoingCallingConvention().getReturn());
238         // Do we want to clear the pending exception?
<span class="line-modified">239         boolean shouldClearException = linkage.isReexecutable() || linkage.isReexecutableOnlyAfterException();</span>
240         try {
241             HotSpotLoweringProvider lowerer = (HotSpotLoweringProvider) providers.getLowerer();
242             Templates foreignCallSnippets = lowerer.getForeignCallSnippets();
243             ResolvedJavaMethod handlePendingException = foreignCallSnippets.handlePendingException.getMethod();
244             ResolvedJavaMethod getAndClearObjectResult = foreignCallSnippets.getAndClearObjectResult.getMethod();
245             ResolvedJavaMethod verifyObject = foreignCallSnippets.verifyObject.getMethod();
246             ResolvedJavaMethod thisMethod = getGraphMethod();
247             GraphKit kit = new GraphKit(debug, thisMethod, providers, wordTypes, providers.getGraphBuilderPlugins(), compilationId, toString());
248             StructuredGraph graph = kit.getGraph();
249             ParameterNode[] params = createParameters(kit, args);
250             ReadRegisterNode thread = kit.append(new ReadRegisterNode(providers.getRegisters().getThreadRegister(), wordTypes.getWordKind(), true, false));
251             ValueNode result = createTargetCall(kit, params, thread);
252             createStaticInvoke(kit, handlePendingException, thread, forBoolean(shouldClearException, graph), forBoolean(isObjectResult, graph));
253             if (isObjectResult) {
254                 InvokeNode object = createStaticInvoke(kit, getAndClearObjectResult, thread);
255                 result = createStaticInvoke(kit, verifyObject, object);
256             }
257             kit.append(new ReturnNode(linkage.getDescriptor().getResultType() == void.class ? null : result));
258             debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Initial stub graph&quot;);
259 
260             kit.inlineInvokes(&quot;Foreign call stub.&quot;, &quot;Backend&quot;);
<span class="line-removed">261             new RemoveValueProxyPhase().apply(graph);</span>
262 
263             debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Stub graph before compilation&quot;);
264             return graph;
265         } catch (Exception e) {
266             throw GraalError.shouldNotReachHere(e);
267         }
268     }
269 
270     private static InvokeNode createStaticInvoke(GraphKit kit, ResolvedJavaMethod method, ValueNode... args) {
271         return kit.createInvoke(method, Static, null, UNKNOWN_BCI, args);
272     }
273 
274     private ResolvedJavaMethod getGraphMethod() {
275         ResolvedJavaMethod thisMethod = null;
276         for (ResolvedJavaMethod method : providers.getMetaAccess().lookupJavaType(ForeignCallStub.class).getDeclaredMethods()) {
277             if (method.getName().equals(&quot;getGraph&quot;)) {
278                 if (thisMethod == null) {
279                     thisMethod = method;
280                 } else {
281                     throw new InternalError(&quot;getGraph is ambiguous&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.stubs;
 26 
 27 import static jdk.vm.ci.code.BytecodeFrame.UNKNOWN_BCI;
 28 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.JavaCall;
 29 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.JavaCallee;
 30 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.NativeCall;
<span class="line-modified"> 31 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.COMPUTES_REGISTERS_KILLED;</span>
<span class="line-modified"> 32 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.DESTROYS_ALL_CALLER_SAVE_REGISTERS;</span>
 33 import static org.graalvm.compiler.nodes.CallTargetNode.InvokeKind.Static;
 34 import static org.graalvm.compiler.nodes.ConstantNode.forBoolean;
 35 
 36 import org.graalvm.compiler.core.common.CompilationIdentifier;
 37 import org.graalvm.compiler.core.common.LIRKind;
 38 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 39 import org.graalvm.compiler.core.common.type.Stamp;
 40 import org.graalvm.compiler.core.common.type.StampFactory;
 41 import org.graalvm.compiler.core.common.type.StampPair;
 42 import org.graalvm.compiler.debug.DebugContext;
 43 import org.graalvm.compiler.debug.GraalError;
 44 import org.graalvm.compiler.debug.JavaMethodContext;
 45 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 46 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Reexecutability;
 47 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition;
 48 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkageImpl;
 49 import org.graalvm.compiler.hotspot.meta.HotSpotLoweringProvider;
 50 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 51 import org.graalvm.compiler.hotspot.nodes.StubForeignCallNode;
 52 import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets.Templates;
 53 import org.graalvm.compiler.nodes.InvokeNode;
 54 import org.graalvm.compiler.nodes.ParameterNode;
 55 import org.graalvm.compiler.nodes.ReturnNode;
 56 import org.graalvm.compiler.nodes.StructuredGraph;
 57 import org.graalvm.compiler.nodes.ValueNode;
 58 import org.graalvm.compiler.options.OptionValues;

 59 import org.graalvm.compiler.replacements.GraphKit;
 60 import org.graalvm.compiler.replacements.nodes.ReadRegisterNode;
 61 import org.graalvm.compiler.word.Word;
 62 import org.graalvm.compiler.word.WordTypes;
 63 import jdk.internal.vm.compiler.word.LocationIdentity;
 64 
 65 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 66 import jdk.vm.ci.hotspot.HotSpotSignature;
 67 import jdk.vm.ci.meta.JavaKind;
 68 import jdk.vm.ci.meta.JavaMethod;
 69 import jdk.vm.ci.meta.JavaType;
 70 import jdk.vm.ci.meta.MetaAccessProvider;
 71 import jdk.vm.ci.meta.ResolvedJavaMethod;
 72 import jdk.vm.ci.meta.ResolvedJavaType;
 73 import jdk.vm.ci.meta.Signature;
 74 
 75 /**
 76  * A {@linkplain #getGraph generated} stub for a {@link Transition non-leaf} foreign call from
 77  * compiled code. A stub is required for such calls as the caller may be scheduled for
 78  * deoptimization while the call is in progress. And since these are foreign/runtime calls on slow
</pre>
<hr />
<pre>
 94      * Specifies if the JavaThread value for the current thread is to be prepended to the arguments
 95      * for the call to {@link #target}.
 96      */
 97     protected final boolean prependThread;
 98 
 99     /**
100      * Creates a stub for a call to code at a given address.
101      *
102      * @param address the address of the code to call
103      * @param descriptor the signature of the call to this stub
104      * @param prependThread true if the JavaThread value for the current thread is to be prepended
105      *            to the arguments for the call to {@code address}
106      * @param reexecutability specifies if the stub call can be re-executed without (meaningful)
107      *            side effects. Deoptimization will not return to a point before a stub call that
108      *            cannot be re-executed.
109      * @param killedLocations the memory locations killed by the stub call
110      */
111     public ForeignCallStub(OptionValues options, HotSpotJVMCIRuntime runtime, HotSpotProviders providers, long address, ForeignCallDescriptor descriptor, boolean prependThread,
112                     Transition transition, Reexecutability reexecutability, LocationIdentity... killedLocations) {
113         super(options, providers, HotSpotForeignCallLinkageImpl.create(providers.getMetaAccess(), providers.getCodeCache(), providers.getWordTypes(), providers.getForeignCalls(), descriptor, 0L,
<span class="line-modified">114                         COMPUTES_REGISTERS_KILLED, JavaCall, JavaCallee, transition, reexecutability, killedLocations));</span>
115         this.jvmciRuntime = runtime;
116         this.prependThread = prependThread;
117         MetaAccessProvider metaAccess = providers.getMetaAccess();
118         Class&lt;?&gt;[] targetParameterTypes = createTargetParameters(descriptor);
119         ForeignCallDescriptor targetSig = new ForeignCallDescriptor(descriptor.getName() + &quot;:C&quot;, descriptor.getResultType(), targetParameterTypes);
120         target = HotSpotForeignCallLinkageImpl.create(metaAccess, providers.getCodeCache(), providers.getWordTypes(), providers.getForeignCalls(), targetSig, address,
<span class="line-modified">121                         DESTROYS_ALL_CALLER_SAVE_REGISTERS, NativeCall, NativeCall, transition, reexecutability, killedLocations);</span>
122     }
123 
124     /**
125      * Gets the linkage information for the call from this stub.
126      */
127     public HotSpotForeignCallLinkage getTargetLinkage() {
128         return target;
129     }
130 
131     private Class&lt;?&gt;[] createTargetParameters(ForeignCallDescriptor descriptor) {
132         Class&lt;?&gt;[] parameters = descriptor.getArgumentTypes();
133         if (prependThread) {
134             Class&lt;?&gt;[] newParameters = new Class&lt;?&gt;[parameters.length + 1];
135             System.arraycopy(parameters, 0, newParameters, 1, parameters.length);
136             newParameters[0] = Word.class;
137             return newParameters;
138         }
139         return parameters;
140     }
141 
</pre>
<hr />
<pre>
218      *
219      * &lt;pre&gt;
220      *     void foreignFunctionStub(args...) {
221      *         foreignFunction(currentThread,  args);
222      *         if ((shouldClearException &amp;&amp; clearPendingException(thread())) || (!shouldClearException &amp;&amp; hasPendingException(thread)) {
223      *             DeoptimizeCallerNode.deopt(None, RuntimeConstraint);
224      *         }
225      *     }
226      * &lt;/pre&gt;
227      *
228      * In each example above, the {@code currentThread} argument is the C++ JavaThread value (i.e.,
229      * %r15 on AMD64) and is only prepended if {@link #prependThread} is true.
230      */
231     @Override
232     @SuppressWarnings(&quot;try&quot;)
233     protected StructuredGraph getGraph(DebugContext debug, CompilationIdentifier compilationId) {
234         WordTypes wordTypes = providers.getWordTypes();
235         Class&lt;?&gt;[] args = linkage.getDescriptor().getArgumentTypes();
236         boolean isObjectResult = !LIRKind.isValue(linkage.getOutgoingCallingConvention().getReturn());
237         // Do we want to clear the pending exception?
<span class="line-modified">238         boolean shouldClearException = linkage.isReexecutable();</span>
239         try {
240             HotSpotLoweringProvider lowerer = (HotSpotLoweringProvider) providers.getLowerer();
241             Templates foreignCallSnippets = lowerer.getForeignCallSnippets();
242             ResolvedJavaMethod handlePendingException = foreignCallSnippets.handlePendingException.getMethod();
243             ResolvedJavaMethod getAndClearObjectResult = foreignCallSnippets.getAndClearObjectResult.getMethod();
244             ResolvedJavaMethod verifyObject = foreignCallSnippets.verifyObject.getMethod();
245             ResolvedJavaMethod thisMethod = getGraphMethod();
246             GraphKit kit = new GraphKit(debug, thisMethod, providers, wordTypes, providers.getGraphBuilderPlugins(), compilationId, toString());
247             StructuredGraph graph = kit.getGraph();
248             ParameterNode[] params = createParameters(kit, args);
249             ReadRegisterNode thread = kit.append(new ReadRegisterNode(providers.getRegisters().getThreadRegister(), wordTypes.getWordKind(), true, false));
250             ValueNode result = createTargetCall(kit, params, thread);
251             createStaticInvoke(kit, handlePendingException, thread, forBoolean(shouldClearException, graph), forBoolean(isObjectResult, graph));
252             if (isObjectResult) {
253                 InvokeNode object = createStaticInvoke(kit, getAndClearObjectResult, thread);
254                 result = createStaticInvoke(kit, verifyObject, object);
255             }
256             kit.append(new ReturnNode(linkage.getDescriptor().getResultType() == void.class ? null : result));
257             debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Initial stub graph&quot;);
258 
259             kit.inlineInvokes(&quot;Foreign call stub.&quot;, &quot;Backend&quot;);

260 
261             debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Stub graph before compilation&quot;);
262             return graph;
263         } catch (Exception e) {
264             throw GraalError.shouldNotReachHere(e);
265         }
266     }
267 
268     private static InvokeNode createStaticInvoke(GraphKit kit, ResolvedJavaMethod method, ValueNode... args) {
269         return kit.createInvoke(method, Static, null, UNKNOWN_BCI, args);
270     }
271 
272     private ResolvedJavaMethod getGraphMethod() {
273         ResolvedJavaMethod thisMethod = null;
274         for (ResolvedJavaMethod method : providers.getMetaAccess().lookupJavaType(ForeignCallStub.class).getDeclaredMethods()) {
275             if (method.getName().equals(&quot;getGraph&quot;)) {
276                 if (thisMethod == null) {
277                     thisMethod = method;
278                 } else {
279                     throw new InternalError(&quot;getGraph is ambiguous&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="ExceptionHandlerStub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="OutOfBoundsExceptionStub.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
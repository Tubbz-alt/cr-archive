<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/MonitorSnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InstanceOfSnippets.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NewObjectSnippets.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/MonitorSnippets.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.replacements;
 26 
 27 import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;

 28 import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
 29 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfig.INJECTED_OPTIONVALUES;
 30 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfig.INJECTED_VMCONFIG;
 31 import static org.graalvm.compiler.hotspot.nodes.AcquiredCASLockNode.mark;
 32 import static org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode.beginLockScope;
 33 import static org.graalvm.compiler.hotspot.nodes.EndLockScopeNode.endLockScope;
 34 import static org.graalvm.compiler.hotspot.nodes.VMErrorNode.vmError;
 35 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.DISPLACED_MARK_WORD_LOCATION;
 36 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
 37 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_CXQ_LOCATION;
 38 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_ENTRY_LIST_LOCATION;
 39 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_OWNER_LOCATION;
 40 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_RECURSION_LOCATION;

 41 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.PROTOTYPE_MARK_WORD_LOCATION;
 42 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.ageMaskInPlace;
 43 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.biasedLockMaskInPlace;
 44 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.biasedLockPattern;
 45 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.epochMaskInPlace;
 46 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.loadWordFromObject;
 47 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.lockDisplacedMarkOffset;
 48 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.markOffset;
 49 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.monitorMask;
 50 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorCxqOffset;
 51 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorEntryListOffset;
 52 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorOwnerOffset;
 53 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorRecursionsOffset;

 54 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.pageSize;
 55 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.prototypeMarkWordOffset;
 56 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.registerAsWord;
 57 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.stackBias;
 58 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.unlockedMask;
 59 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.useBiasedLocking;
 60 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.verifyOop;
 61 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.wordSize;
 62 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileMonitors;
 63 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.SimpleFastInflatedLocking;
 64 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.TraceMonitorsMethodFilter;
 65 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.TraceMonitorsTypeFilter;
 66 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.VerifyBalancedMonitors;
 67 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FAST_PATH_PROBABILITY;
 68 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FREQUENT_PROBABILITY;
 69 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.NOT_FREQUENT_PROBABILITY;
 70 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.NOT_LIKELY_PROBABILITY;
 71 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;
 72 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.VERY_FAST_PATH_PROBABILITY;
 73 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
</pre>
<hr />
<pre>
 93 import org.graalvm.compiler.graph.iterators.NodeIterable;
 94 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 95 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 96 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
 97 import org.graalvm.compiler.hotspot.nodes.CurrentLockNode;
 98 import org.graalvm.compiler.hotspot.nodes.FastAcquireBiasedLockNode;
 99 import org.graalvm.compiler.hotspot.nodes.MonitorCounterNode;
100 import org.graalvm.compiler.hotspot.word.KlassPointer;
101 import org.graalvm.compiler.nodes.BreakpointNode;
102 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
103 import org.graalvm.compiler.nodes.ConstantNode;
104 import org.graalvm.compiler.nodes.DeoptimizeNode;
105 import org.graalvm.compiler.nodes.FrameState;
106 import org.graalvm.compiler.nodes.InvokeNode;
107 import org.graalvm.compiler.nodes.NamedLocationIdentity;
108 import org.graalvm.compiler.nodes.NodeView;
109 import org.graalvm.compiler.nodes.ReturnNode;
110 import org.graalvm.compiler.nodes.StructuredGraph;
111 import org.graalvm.compiler.nodes.ValueNode;
112 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;

113 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
114 import org.graalvm.compiler.nodes.extended.MembarNode;
115 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
116 import org.graalvm.compiler.nodes.java.MonitorExitNode;
117 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
118 import org.graalvm.compiler.nodes.spi.LoweringTool;
119 import org.graalvm.compiler.nodes.type.StampTool;
120 import org.graalvm.compiler.options.OptionValues;
121 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
<span class="line-removed">122 import org.graalvm.compiler.replacements.Log;</span>
123 import org.graalvm.compiler.replacements.SnippetCounter;
124 import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;
125 import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
126 import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
127 import org.graalvm.compiler.replacements.Snippets;
128 import org.graalvm.compiler.word.Word;
129 import jdk.internal.vm.compiler.word.LocationIdentity;
130 import jdk.internal.vm.compiler.word.Pointer;
131 import jdk.internal.vm.compiler.word.WordBase;
132 import jdk.internal.vm.compiler.word.WordFactory;
133 
134 import jdk.vm.ci.code.BytecodeFrame;
135 import jdk.vm.ci.code.Register;
136 import jdk.vm.ci.code.TargetDescription;
137 import jdk.vm.ci.meta.DeoptimizationAction;
138 import jdk.vm.ci.meta.DeoptimizationReason;
139 import jdk.vm.ci.meta.JavaType;
140 import jdk.vm.ci.meta.ResolvedJavaType;
141 
142 /**
143  * Snippets used for implementing the monitorenter and monitorexit instructions.
144  *
145  * The locking algorithm used is described in the paper
146  * &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=1167515.1167496&quot;&gt; Eliminating synchronization-related
147  * atomic operations with biased locking and bulk rebiasing&lt;/a&gt; by Kenneth Russell and David
148  * Detlefs.
149  *
<span class="line-modified">150  * Comment below is reproduced from {@code markOop.hpp} for convenience:</span>
151  *
152  * &lt;pre&gt;
153  *  Bit-format of an object header (most significant first, big endian layout below):
154  *  32 bits:
155  *  --------
156  *             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)
157  *             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
158  *             size:32 ------------------------------------------&gt;| (CMS free block)
159  *             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
160  *
161  *  64 bits:
162  *  --------
163  *  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)
164  *  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
165  *  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
166  *  size:64 -----------------------------------------------------&gt;| (CMS free block)
167  *
168  *  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)
169  *  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)
170  *  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)
</pre>
<hr />
<pre>
455                 counters.inflatedCas.inc();
456                 return true;
457             } else {
458                 traceObject(trace, &quot;+lock{stub:inflated:failed-cas}&quot;, object, true);
459                 counters.inflatedFailedCas.inc();
460             }
461         } else {
462             traceObject(trace, &quot;+lock{stub:inflated:owned}&quot;, object, true);
463             counters.inflatedOwned.inc();
464         }
465         return false;
466     }
467 
468     /**
469      * Calls straight out to the monitorenter stub.
470      */
471     @Snippet
472     public static void monitorenterStub(Object object, @ConstantParameter int lockDepth, @ConstantParameter boolean trace) {
473         verifyOop(object);
474         incCounter();
<span class="line-modified">475         if (object == null) {</span>
476             DeoptimizeNode.deopt(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.NullCheckException);
477         }
478         // BeginLockScope nodes do not read from object so a use of object
479         // cannot float about the null check above
480         final Word lock = beginLockScope(lockDepth);
481         traceObject(trace, &quot;+lock{stub}&quot;, object, true);
482         monitorenterStubC(MONITORENTER, object, lock);
483     }
484 
485     @Snippet
486     public static void monitorexit(Object object, @ConstantParameter int lockDepth, @ConstantParameter Register threadRegister, @ConstantParameter boolean trace,
487                     @ConstantParameter Counters counters) {
488         trace(trace, &quot;           object: 0x%016lx\n&quot;, Word.objectToTrackedPointer(object));
489         final Word mark = loadWordFromObject(object, markOffset(INJECTED_VMCONFIG));
490         if (useBiasedLocking(INJECTED_VMCONFIG)) {
491             // Check for biased locking unlock case, which is a no-op
492             // Note: we do not have to check the thread ID for two reasons.
493             // First, the interpreter checks for IllegalMonitorStateException at
494             // a higher level. Second, if the bias was revoked while we held the
495             // lock, the object could not be rebiased toward another thread, so
</pre>
<hr />
<pre>
557             int ownerOffset = objectMonitorOwnerOffset(INJECTED_VMCONFIG);
558             Word owner = monitor.readWord(ownerOffset, OBJECT_MONITOR_OWNER_LOCATION);
559             int recursionsOffset = objectMonitorRecursionsOffset(INJECTED_VMCONFIG);
560             Word recursions = monitor.readWord(recursionsOffset, OBJECT_MONITOR_RECURSION_LOCATION);
561             Word thread = registerAsWord(threadRegister);
562             if (probability(FAST_PATH_PROBABILITY, owner.xor(thread).or(recursions).equal(0))) {
563                 // owner == thread &amp;&amp; recursions == 0
564                 int cxqOffset = objectMonitorCxqOffset(INJECTED_VMCONFIG);
565                 Word cxq = monitor.readWord(cxqOffset, OBJECT_MONITOR_CXQ_LOCATION);
566                 int entryListOffset = objectMonitorEntryListOffset(INJECTED_VMCONFIG);
567                 Word entryList = monitor.readWord(entryListOffset, OBJECT_MONITOR_ENTRY_LIST_LOCATION);
568                 if (probability(FREQUENT_PROBABILITY, cxq.or(entryList).equal(0))) {
569                     // cxq == 0 &amp;&amp; entryList == 0
570                     // Nobody is waiting, success
571                     // release_store
572                     memoryBarrier(LOAD_STORE | STORE_STORE);
573                     monitor.writeWord(ownerOffset, zero());
574                     traceObject(trace, &quot;-lock{inflated:simple}&quot;, object, false);
575                     counters.unlockInflatedSimple.inc();
576                     return true;


























577                 }
578             }
579             counters.unlockStubInflated.inc();
580             traceObject(trace, &quot;-lock{stub:inflated}&quot;, object, false);
581             monitorexitStubC(MONITOREXIT, object, lock);
582             return true;
583         }
584         return false;
585     }
586 
587     /**
588      * Calls straight out to the monitorexit stub.
589      */
590     @Snippet
591     public static void monitorexitStub(Object object, @ConstantParameter int lockDepth, @ConstantParameter boolean trace) {
592         verifyOop(object);
593         traceObject(trace, &quot;-lock{stub}&quot;, object, false);
594         final Word lock = CurrentLockNode.currentLock(lockDepth);
595         monitorexitStubC(MONITOREXIT, object, lock);
596         endLockScope();
</pre>
<hr />
<pre>
675         public final SnippetCounter lockStubEpochExpired;
676         public final SnippetCounter lockStubRevoke;
677         public final SnippetCounter lockStubFailedCas;
678         public final SnippetCounter inflatedCas;
679         public final SnippetCounter inflatedFailedCas;
680         public final SnippetCounter inflatedOwned;
681         public final SnippetCounter unbiasable;
682         public final SnippetCounter revokeBias;
683 
684         /**
685          * Counters for the various paths for releasing a lock. The counters whose names start with
686          * {@code &quot;unlock&quot;} are mutually exclusive. The other counters are for paths that may be
687          * shared.
688          */
689         public final SnippetCounter unlockBias;
690         public final SnippetCounter unlockCas;
691         public final SnippetCounter unlockCasRecursive;
692         public final SnippetCounter unlockStub;
693         public final SnippetCounter unlockStubInflated;
694         public final SnippetCounter unlockInflatedSimple;

695 
696         public Counters(SnippetCounter.Group.Factory factory) {
697             SnippetCounter.Group enter = factory.createSnippetCounterGroup(&quot;MonitorEnters&quot;);
698             SnippetCounter.Group exit = factory.createSnippetCounterGroup(&quot;MonitorExits&quot;);
699             lockBiasExisting = new SnippetCounter(enter, &quot;lock{bias:existing}&quot;, &quot;bias-locked previously biased object&quot;);
700             lockBiasAcquired = new SnippetCounter(enter, &quot;lock{bias:acquired}&quot;, &quot;bias-locked newly biased object&quot;);
701             lockBiasTransfer = new SnippetCounter(enter, &quot;lock{bias:transfer}&quot;, &quot;bias-locked, biased transferred&quot;);
702             lockCas = new SnippetCounter(enter, &quot;lock{cas}&quot;, &quot;cas-locked an object&quot;);
703             lockCasRecursive = new SnippetCounter(enter, &quot;lock{cas:recursive}&quot;, &quot;cas-locked, recursive&quot;);
704             lockStubEpochExpired = new SnippetCounter(enter, &quot;lock{stub:epoch-expired}&quot;, &quot;stub-locked, epoch expired&quot;);
705             lockStubRevoke = new SnippetCounter(enter, &quot;lock{stub:revoke}&quot;, &quot;stub-locked, biased revoked&quot;);
706             lockStubFailedCas = new SnippetCounter(enter, &quot;lock{stub:failed-cas/stack}&quot;, &quot;stub-locked, failed cas and stack locking&quot;);
707             inflatedCas = new SnippetCounter(enter, &quot;lock{inflated:cas}&quot;, &quot;heavyweight-locked, cas-locked&quot;);
708             inflatedFailedCas = new SnippetCounter(enter, &quot;lock{inflated:failed-cas}&quot;, &quot;heavyweight-locked, failed cas&quot;);
709             inflatedOwned = new SnippetCounter(enter, &quot;lock{inflated:owned}&quot;, &quot;heavyweight-locked, already owned&quot;);
710             unbiasable = new SnippetCounter(enter, &quot;unbiasable&quot;, &quot;object with unbiasable type&quot;);
711             revokeBias = new SnippetCounter(enter, &quot;revokeBias&quot;, &quot;object had bias revoked&quot;);
712 
713             unlockBias = new SnippetCounter(exit, &quot;unlock{bias}&quot;, &quot;bias-unlocked an object&quot;);
714             unlockCas = new SnippetCounter(exit, &quot;unlock{cas}&quot;, &quot;cas-unlocked an object&quot;);
715             unlockCasRecursive = new SnippetCounter(exit, &quot;unlock{cas:recursive}&quot;, &quot;cas-unlocked an object, recursive&quot;);
716             unlockStub = new SnippetCounter(exit, &quot;unlock{stub}&quot;, &quot;stub-unlocked an object&quot;);
717             unlockStubInflated = new SnippetCounter(exit, &quot;unlock{stub:inflated}&quot;, &quot;stub-unlocked an object with inflated monitor&quot;);
718             unlockInflatedSimple = new SnippetCounter(exit, &quot;unlock{inflated}&quot;, &quot;unlocked an object monitor&quot;);

719         }
720     }
721 
722     public static class Templates extends AbstractTemplates {
723 
724         private final SnippetInfo monitorenter = snippet(MonitorSnippets.class, &quot;monitorenter&quot;);
<span class="line-modified">725         private final SnippetInfo monitorexit = snippet(MonitorSnippets.class, &quot;monitorexit&quot;);</span>

726         private final SnippetInfo monitorenterStub = snippet(MonitorSnippets.class, &quot;monitorenterStub&quot;);
727         private final SnippetInfo monitorexitStub = snippet(MonitorSnippets.class, &quot;monitorexitStub&quot;);
728         private final SnippetInfo initCounter = snippet(MonitorSnippets.class, &quot;initCounter&quot;);
729         private final SnippetInfo checkCounter = snippet(MonitorSnippets.class, &quot;checkCounter&quot;);
730 
731         private final boolean useFastLocking;
732         public final Counters counters;
733 
734         public Templates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory factory, HotSpotProviders providers, TargetDescription target,
735                         boolean useFastLocking) {
736             super(options, factories, providers, providers.getSnippetReflection(), target);
737             this.useFastLocking = useFastLocking;
738 
739             this.counters = new Counters(factory);
740         }
741 
742         public void lower(RawMonitorEnterNode monitorenterNode, HotSpotRegistersProvider registers, LoweringTool tool) {
743             StructuredGraph graph = monitorenterNode.graph();
744             checkBalancedMonitors(graph, tool);
745 
</pre>
<hr />
<pre>
814                 return (graph.method().format(&quot;%H.%n&quot;).contains(filter));
815             }
816         }
817 
818         /**
819          * If balanced monitor checking is enabled then nodes are inserted at the start and all
820          * return points of the graph to initialize and check the monitor counter respectively.
821          */
822         private void checkBalancedMonitors(StructuredGraph graph, LoweringTool tool) {
823             if (VerifyBalancedMonitors.getValue(options)) {
824                 NodeIterable&lt;MonitorCounterNode&gt; nodes = graph.getNodes().filter(MonitorCounterNode.class);
825                 if (nodes.isEmpty()) {
826                     // Only insert the nodes if this is the first monitorenter being lowered.
827                     JavaType returnType = initCounter.getMethod().getSignature().getReturnType(initCounter.getMethod().getDeclaringClass());
828                     StampPair returnStamp = StampFactory.forDeclaredType(graph.getAssumptions(), returnType, false);
829                     MethodCallTargetNode callTarget = graph.add(new MethodCallTargetNode(InvokeKind.Static, initCounter.getMethod(), new ValueNode[0], returnStamp, null));
830                     InvokeNode invoke = graph.add(new InvokeNode(callTarget, 0));
831                     invoke.setStateAfter(graph.start().stateAfter());
832                     graph.addAfterFixed(graph.start(), invoke);
833 
<span class="line-modified">834                     StructuredGraph inlineeGraph = providers.getReplacements().getSnippet(initCounter.getMethod(), null, invoke.graph().trackNodeSourcePosition(), invoke.getNodeSourcePosition());</span>

835                     InliningUtil.inline(invoke, inlineeGraph, false, null);
836 
837                     List&lt;ReturnNode&gt; rets = graph.getNodes(ReturnNode.TYPE).snapshot();
838                     for (ReturnNode ret : rets) {
839                         returnType = checkCounter.getMethod().getSignature().getReturnType(checkCounter.getMethod().getDeclaringClass());
840                         String msg = &quot;unbalanced monitors in &quot; + graph.method().format(&quot;%H.%n(%p)&quot;) + &quot;, count = %d&quot;;
841                         ConstantNode errMsg = ConstantNode.forConstant(tool.getConstantReflection().forString(msg), providers.getMetaAccess(), graph);
842                         returnStamp = StampFactory.forDeclaredType(graph.getAssumptions(), returnType, false);
843                         callTarget = graph.add(new MethodCallTargetNode(InvokeKind.Static, checkCounter.getMethod(), new ValueNode[]{errMsg}, returnStamp, null));
844                         invoke = graph.add(new InvokeNode(callTarget, 0));
845                         Bytecode code = new ResolvedJavaMethodBytecode(graph.method());
846                         FrameState stateAfter = new FrameState(null, code, BytecodeFrame.AFTER_BCI, new ValueNode[0], new ValueNode[0], 0, new ValueNode[0], null, false, false);
847                         invoke.setStateAfter(graph.add(stateAfter));
848                         graph.addBeforeFixed(ret, invoke);
849 
850                         Arguments args = new Arguments(checkCounter, graph.getGuardsStage(), tool.getLoweringStage());
851                         args.addConst(&quot;errMsg&quot;, msg);
852                         inlineeGraph = template(invoke, args).copySpecializedGraph(graph.getDebug());
853                         InliningUtil.inline(invoke, inlineeGraph, false, null);
854                     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.replacements;
 26 
 27 import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;
<span class="line-added"> 28 import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;</span>
 29 import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
 30 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfig.INJECTED_OPTIONVALUES;
 31 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfig.INJECTED_VMCONFIG;
 32 import static org.graalvm.compiler.hotspot.nodes.AcquiredCASLockNode.mark;
 33 import static org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode.beginLockScope;
 34 import static org.graalvm.compiler.hotspot.nodes.EndLockScopeNode.endLockScope;
 35 import static org.graalvm.compiler.hotspot.nodes.VMErrorNode.vmError;
 36 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.DISPLACED_MARK_WORD_LOCATION;
 37 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
 38 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_CXQ_LOCATION;
 39 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_ENTRY_LIST_LOCATION;
 40 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_OWNER_LOCATION;
 41 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_RECURSION_LOCATION;
<span class="line-added"> 42 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_SUCC_LOCATION;</span>
 43 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.PROTOTYPE_MARK_WORD_LOCATION;
 44 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.ageMaskInPlace;
 45 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.biasedLockMaskInPlace;
 46 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.biasedLockPattern;
 47 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.epochMaskInPlace;
 48 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.loadWordFromObject;
 49 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.lockDisplacedMarkOffset;
 50 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.markOffset;
 51 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.monitorMask;
 52 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorCxqOffset;
 53 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorEntryListOffset;
 54 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorOwnerOffset;
 55 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorRecursionsOffset;
<span class="line-added"> 56 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorSuccOffset;</span>
 57 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.pageSize;
 58 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.prototypeMarkWordOffset;
 59 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.registerAsWord;
 60 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.stackBias;
 61 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.unlockedMask;
 62 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.useBiasedLocking;
 63 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.verifyOop;
 64 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.wordSize;
 65 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileMonitors;
 66 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.SimpleFastInflatedLocking;
 67 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.TraceMonitorsMethodFilter;
 68 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.TraceMonitorsTypeFilter;
 69 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.VerifyBalancedMonitors;
 70 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FAST_PATH_PROBABILITY;
 71 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FREQUENT_PROBABILITY;
 72 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.NOT_FREQUENT_PROBABILITY;
 73 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.NOT_LIKELY_PROBABILITY;
 74 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;
 75 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.VERY_FAST_PATH_PROBABILITY;
 76 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
</pre>
<hr />
<pre>
 96 import org.graalvm.compiler.graph.iterators.NodeIterable;
 97 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 98 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 99 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
100 import org.graalvm.compiler.hotspot.nodes.CurrentLockNode;
101 import org.graalvm.compiler.hotspot.nodes.FastAcquireBiasedLockNode;
102 import org.graalvm.compiler.hotspot.nodes.MonitorCounterNode;
103 import org.graalvm.compiler.hotspot.word.KlassPointer;
104 import org.graalvm.compiler.nodes.BreakpointNode;
105 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
106 import org.graalvm.compiler.nodes.ConstantNode;
107 import org.graalvm.compiler.nodes.DeoptimizeNode;
108 import org.graalvm.compiler.nodes.FrameState;
109 import org.graalvm.compiler.nodes.InvokeNode;
110 import org.graalvm.compiler.nodes.NamedLocationIdentity;
111 import org.graalvm.compiler.nodes.NodeView;
112 import org.graalvm.compiler.nodes.ReturnNode;
113 import org.graalvm.compiler.nodes.StructuredGraph;
114 import org.graalvm.compiler.nodes.ValueNode;
115 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
<span class="line-added">116 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;</span>
117 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
118 import org.graalvm.compiler.nodes.extended.MembarNode;
119 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
120 import org.graalvm.compiler.nodes.java.MonitorExitNode;
121 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
122 import org.graalvm.compiler.nodes.spi.LoweringTool;
123 import org.graalvm.compiler.nodes.type.StampTool;
124 import org.graalvm.compiler.options.OptionValues;
125 import org.graalvm.compiler.phases.common.inlining.InliningUtil;

126 import org.graalvm.compiler.replacements.SnippetCounter;
127 import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;
128 import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
129 import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
130 import org.graalvm.compiler.replacements.Snippets;
131 import org.graalvm.compiler.word.Word;
132 import jdk.internal.vm.compiler.word.LocationIdentity;
133 import jdk.internal.vm.compiler.word.Pointer;
134 import jdk.internal.vm.compiler.word.WordBase;
135 import jdk.internal.vm.compiler.word.WordFactory;
136 
137 import jdk.vm.ci.code.BytecodeFrame;
138 import jdk.vm.ci.code.Register;
139 import jdk.vm.ci.code.TargetDescription;
140 import jdk.vm.ci.meta.DeoptimizationAction;
141 import jdk.vm.ci.meta.DeoptimizationReason;
142 import jdk.vm.ci.meta.JavaType;
143 import jdk.vm.ci.meta.ResolvedJavaType;
144 
145 /**
146  * Snippets used for implementing the monitorenter and monitorexit instructions.
147  *
148  * The locking algorithm used is described in the paper
149  * &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=1167515.1167496&quot;&gt; Eliminating synchronization-related
150  * atomic operations with biased locking and bulk rebiasing&lt;/a&gt; by Kenneth Russell and David
151  * Detlefs.
152  *
<span class="line-modified">153  * Comment below is reproduced from {@code markWord.hpp} for convenience:</span>
154  *
155  * &lt;pre&gt;
156  *  Bit-format of an object header (most significant first, big endian layout below):
157  *  32 bits:
158  *  --------
159  *             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)
160  *             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
161  *             size:32 ------------------------------------------&gt;| (CMS free block)
162  *             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
163  *
164  *  64 bits:
165  *  --------
166  *  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)
167  *  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
168  *  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)
169  *  size:64 -----------------------------------------------------&gt;| (CMS free block)
170  *
171  *  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)
172  *  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)
173  *  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)
</pre>
<hr />
<pre>
458                 counters.inflatedCas.inc();
459                 return true;
460             } else {
461                 traceObject(trace, &quot;+lock{stub:inflated:failed-cas}&quot;, object, true);
462                 counters.inflatedFailedCas.inc();
463             }
464         } else {
465             traceObject(trace, &quot;+lock{stub:inflated:owned}&quot;, object, true);
466             counters.inflatedOwned.inc();
467         }
468         return false;
469     }
470 
471     /**
472      * Calls straight out to the monitorenter stub.
473      */
474     @Snippet
475     public static void monitorenterStub(Object object, @ConstantParameter int lockDepth, @ConstantParameter boolean trace) {
476         verifyOop(object);
477         incCounter();
<span class="line-modified">478         if (BranchProbabilityNode.probability(BranchProbabilityNode.DEOPT_PROBABILITY, object == null)) {</span>
479             DeoptimizeNode.deopt(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.NullCheckException);
480         }
481         // BeginLockScope nodes do not read from object so a use of object
482         // cannot float about the null check above
483         final Word lock = beginLockScope(lockDepth);
484         traceObject(trace, &quot;+lock{stub}&quot;, object, true);
485         monitorenterStubC(MONITORENTER, object, lock);
486     }
487 
488     @Snippet
489     public static void monitorexit(Object object, @ConstantParameter int lockDepth, @ConstantParameter Register threadRegister, @ConstantParameter boolean trace,
490                     @ConstantParameter Counters counters) {
491         trace(trace, &quot;           object: 0x%016lx\n&quot;, Word.objectToTrackedPointer(object));
492         final Word mark = loadWordFromObject(object, markOffset(INJECTED_VMCONFIG));
493         if (useBiasedLocking(INJECTED_VMCONFIG)) {
494             // Check for biased locking unlock case, which is a no-op
495             // Note: we do not have to check the thread ID for two reasons.
496             // First, the interpreter checks for IllegalMonitorStateException at
497             // a higher level. Second, if the bias was revoked while we held the
498             // lock, the object could not be rebiased toward another thread, so
</pre>
<hr />
<pre>
560             int ownerOffset = objectMonitorOwnerOffset(INJECTED_VMCONFIG);
561             Word owner = monitor.readWord(ownerOffset, OBJECT_MONITOR_OWNER_LOCATION);
562             int recursionsOffset = objectMonitorRecursionsOffset(INJECTED_VMCONFIG);
563             Word recursions = monitor.readWord(recursionsOffset, OBJECT_MONITOR_RECURSION_LOCATION);
564             Word thread = registerAsWord(threadRegister);
565             if (probability(FAST_PATH_PROBABILITY, owner.xor(thread).or(recursions).equal(0))) {
566                 // owner == thread &amp;&amp; recursions == 0
567                 int cxqOffset = objectMonitorCxqOffset(INJECTED_VMCONFIG);
568                 Word cxq = monitor.readWord(cxqOffset, OBJECT_MONITOR_CXQ_LOCATION);
569                 int entryListOffset = objectMonitorEntryListOffset(INJECTED_VMCONFIG);
570                 Word entryList = monitor.readWord(entryListOffset, OBJECT_MONITOR_ENTRY_LIST_LOCATION);
571                 if (probability(FREQUENT_PROBABILITY, cxq.or(entryList).equal(0))) {
572                     // cxq == 0 &amp;&amp; entryList == 0
573                     // Nobody is waiting, success
574                     // release_store
575                     memoryBarrier(LOAD_STORE | STORE_STORE);
576                     monitor.writeWord(ownerOffset, zero());
577                     traceObject(trace, &quot;-lock{inflated:simple}&quot;, object, false);
578                     counters.unlockInflatedSimple.inc();
579                     return true;
<span class="line-added">580                 } else {</span>
<span class="line-added">581                     int succOffset = objectMonitorSuccOffset(INJECTED_VMCONFIG);</span>
<span class="line-added">582                     Word succ = monitor.readWord(succOffset, OBJECT_MONITOR_SUCC_LOCATION);</span>
<span class="line-added">583                     if (probability(FREQUENT_PROBABILITY, succ.isNonNull())) {</span>
<span class="line-added">584                         // There may be a thread spinning on this monitor. Temporarily setting</span>
<span class="line-added">585                         // the monitor owner to null, and hope that the other thread will grab it.</span>
<span class="line-added">586                         monitor.writeWord(ownerOffset, zero());</span>
<span class="line-added">587                         memoryBarrier(STORE_STORE | STORE_LOAD);</span>
<span class="line-added">588                         succ = monitor.readWord(succOffset, OBJECT_MONITOR_SUCC_LOCATION);</span>
<span class="line-added">589                         if (probability(NOT_FREQUENT_PROBABILITY, succ.isNonNull())) {</span>
<span class="line-added">590                             // We manage to release the monitor before the other running thread even</span>
<span class="line-added">591                             // notices.</span>
<span class="line-added">592                             traceObject(trace, &quot;-lock{inflated:transfer}&quot;, object, false);</span>
<span class="line-added">593                             counters.unlockInflatedTransfer.inc();</span>
<span class="line-added">594                             return true;</span>
<span class="line-added">595                         } else {</span>
<span class="line-added">596                             // Either the monitor is grabbed by a spinning thread, or the spinning</span>
<span class="line-added">597                             // thread parks. Now we attempt to reset the owner of the monitor.</span>
<span class="line-added">598                             if (probability(FREQUENT_PROBABILITY, !monitor.logicCompareAndSwapWord(ownerOffset, zero(), thread, OBJECT_MONITOR_OWNER_LOCATION))) {</span>
<span class="line-added">599                                 // The monitor is stolen.</span>
<span class="line-added">600                                 traceObject(trace, &quot;-lock{inflated:transfer}&quot;, object, false);</span>
<span class="line-added">601                                 counters.unlockInflatedTransfer.inc();</span>
<span class="line-added">602                                 return true;</span>
<span class="line-added">603                             }</span>
<span class="line-added">604                         }</span>
<span class="line-added">605                     }</span>
606                 }
607             }
608             counters.unlockStubInflated.inc();
609             traceObject(trace, &quot;-lock{stub:inflated}&quot;, object, false);
610             monitorexitStubC(MONITOREXIT, object, lock);
611             return true;
612         }
613         return false;
614     }
615 
616     /**
617      * Calls straight out to the monitorexit stub.
618      */
619     @Snippet
620     public static void monitorexitStub(Object object, @ConstantParameter int lockDepth, @ConstantParameter boolean trace) {
621         verifyOop(object);
622         traceObject(trace, &quot;-lock{stub}&quot;, object, false);
623         final Word lock = CurrentLockNode.currentLock(lockDepth);
624         monitorexitStubC(MONITOREXIT, object, lock);
625         endLockScope();
</pre>
<hr />
<pre>
704         public final SnippetCounter lockStubEpochExpired;
705         public final SnippetCounter lockStubRevoke;
706         public final SnippetCounter lockStubFailedCas;
707         public final SnippetCounter inflatedCas;
708         public final SnippetCounter inflatedFailedCas;
709         public final SnippetCounter inflatedOwned;
710         public final SnippetCounter unbiasable;
711         public final SnippetCounter revokeBias;
712 
713         /**
714          * Counters for the various paths for releasing a lock. The counters whose names start with
715          * {@code &quot;unlock&quot;} are mutually exclusive. The other counters are for paths that may be
716          * shared.
717          */
718         public final SnippetCounter unlockBias;
719         public final SnippetCounter unlockCas;
720         public final SnippetCounter unlockCasRecursive;
721         public final SnippetCounter unlockStub;
722         public final SnippetCounter unlockStubInflated;
723         public final SnippetCounter unlockInflatedSimple;
<span class="line-added">724         public final SnippetCounter unlockInflatedTransfer;</span>
725 
726         public Counters(SnippetCounter.Group.Factory factory) {
727             SnippetCounter.Group enter = factory.createSnippetCounterGroup(&quot;MonitorEnters&quot;);
728             SnippetCounter.Group exit = factory.createSnippetCounterGroup(&quot;MonitorExits&quot;);
729             lockBiasExisting = new SnippetCounter(enter, &quot;lock{bias:existing}&quot;, &quot;bias-locked previously biased object&quot;);
730             lockBiasAcquired = new SnippetCounter(enter, &quot;lock{bias:acquired}&quot;, &quot;bias-locked newly biased object&quot;);
731             lockBiasTransfer = new SnippetCounter(enter, &quot;lock{bias:transfer}&quot;, &quot;bias-locked, biased transferred&quot;);
732             lockCas = new SnippetCounter(enter, &quot;lock{cas}&quot;, &quot;cas-locked an object&quot;);
733             lockCasRecursive = new SnippetCounter(enter, &quot;lock{cas:recursive}&quot;, &quot;cas-locked, recursive&quot;);
734             lockStubEpochExpired = new SnippetCounter(enter, &quot;lock{stub:epoch-expired}&quot;, &quot;stub-locked, epoch expired&quot;);
735             lockStubRevoke = new SnippetCounter(enter, &quot;lock{stub:revoke}&quot;, &quot;stub-locked, biased revoked&quot;);
736             lockStubFailedCas = new SnippetCounter(enter, &quot;lock{stub:failed-cas/stack}&quot;, &quot;stub-locked, failed cas and stack locking&quot;);
737             inflatedCas = new SnippetCounter(enter, &quot;lock{inflated:cas}&quot;, &quot;heavyweight-locked, cas-locked&quot;);
738             inflatedFailedCas = new SnippetCounter(enter, &quot;lock{inflated:failed-cas}&quot;, &quot;heavyweight-locked, failed cas&quot;);
739             inflatedOwned = new SnippetCounter(enter, &quot;lock{inflated:owned}&quot;, &quot;heavyweight-locked, already owned&quot;);
740             unbiasable = new SnippetCounter(enter, &quot;unbiasable&quot;, &quot;object with unbiasable type&quot;);
741             revokeBias = new SnippetCounter(enter, &quot;revokeBias&quot;, &quot;object had bias revoked&quot;);
742 
743             unlockBias = new SnippetCounter(exit, &quot;unlock{bias}&quot;, &quot;bias-unlocked an object&quot;);
744             unlockCas = new SnippetCounter(exit, &quot;unlock{cas}&quot;, &quot;cas-unlocked an object&quot;);
745             unlockCasRecursive = new SnippetCounter(exit, &quot;unlock{cas:recursive}&quot;, &quot;cas-unlocked an object, recursive&quot;);
746             unlockStub = new SnippetCounter(exit, &quot;unlock{stub}&quot;, &quot;stub-unlocked an object&quot;);
747             unlockStubInflated = new SnippetCounter(exit, &quot;unlock{stub:inflated}&quot;, &quot;stub-unlocked an object with inflated monitor&quot;);
748             unlockInflatedSimple = new SnippetCounter(exit, &quot;unlock{inflated}&quot;, &quot;unlocked an object monitor&quot;);
<span class="line-added">749             unlockInflatedTransfer = new SnippetCounter(exit, &quot;unlock{inflated:transfer}&quot;, &quot;unlocked an object monitor in the presence of ObjectMonitor::_succ&quot;);</span>
750         }
751     }
752 
753     public static class Templates extends AbstractTemplates {
754 
755         private final SnippetInfo monitorenter = snippet(MonitorSnippets.class, &quot;monitorenter&quot;);
<span class="line-modified">756         private final SnippetInfo monitorexit = snippet(MonitorSnippets.class, &quot;monitorexit&quot;, DISPLACED_MARK_WORD_LOCATION, OBJECT_MONITOR_OWNER_LOCATION, OBJECT_MONITOR_CXQ_LOCATION,</span>
<span class="line-added">757                         OBJECT_MONITOR_ENTRY_LIST_LOCATION, OBJECT_MONITOR_RECURSION_LOCATION, OBJECT_MONITOR_SUCC_LOCATION);</span>
758         private final SnippetInfo monitorenterStub = snippet(MonitorSnippets.class, &quot;monitorenterStub&quot;);
759         private final SnippetInfo monitorexitStub = snippet(MonitorSnippets.class, &quot;monitorexitStub&quot;);
760         private final SnippetInfo initCounter = snippet(MonitorSnippets.class, &quot;initCounter&quot;);
761         private final SnippetInfo checkCounter = snippet(MonitorSnippets.class, &quot;checkCounter&quot;);
762 
763         private final boolean useFastLocking;
764         public final Counters counters;
765 
766         public Templates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory factory, HotSpotProviders providers, TargetDescription target,
767                         boolean useFastLocking) {
768             super(options, factories, providers, providers.getSnippetReflection(), target);
769             this.useFastLocking = useFastLocking;
770 
771             this.counters = new Counters(factory);
772         }
773 
774         public void lower(RawMonitorEnterNode monitorenterNode, HotSpotRegistersProvider registers, LoweringTool tool) {
775             StructuredGraph graph = monitorenterNode.graph();
776             checkBalancedMonitors(graph, tool);
777 
</pre>
<hr />
<pre>
846                 return (graph.method().format(&quot;%H.%n&quot;).contains(filter));
847             }
848         }
849 
850         /**
851          * If balanced monitor checking is enabled then nodes are inserted at the start and all
852          * return points of the graph to initialize and check the monitor counter respectively.
853          */
854         private void checkBalancedMonitors(StructuredGraph graph, LoweringTool tool) {
855             if (VerifyBalancedMonitors.getValue(options)) {
856                 NodeIterable&lt;MonitorCounterNode&gt; nodes = graph.getNodes().filter(MonitorCounterNode.class);
857                 if (nodes.isEmpty()) {
858                     // Only insert the nodes if this is the first monitorenter being lowered.
859                     JavaType returnType = initCounter.getMethod().getSignature().getReturnType(initCounter.getMethod().getDeclaringClass());
860                     StampPair returnStamp = StampFactory.forDeclaredType(graph.getAssumptions(), returnType, false);
861                     MethodCallTargetNode callTarget = graph.add(new MethodCallTargetNode(InvokeKind.Static, initCounter.getMethod(), new ValueNode[0], returnStamp, null));
862                     InvokeNode invoke = graph.add(new InvokeNode(callTarget, 0));
863                     invoke.setStateAfter(graph.start().stateAfter());
864                     graph.addAfterFixed(graph.start(), invoke);
865 
<span class="line-modified">866                     StructuredGraph inlineeGraph = providers.getReplacements().getSnippet(initCounter.getMethod(), null, null, invoke.graph().trackNodeSourcePosition(), invoke.getNodeSourcePosition(),</span>
<span class="line-added">867                                     invoke.getOptions());</span>
868                     InliningUtil.inline(invoke, inlineeGraph, false, null);
869 
870                     List&lt;ReturnNode&gt; rets = graph.getNodes(ReturnNode.TYPE).snapshot();
871                     for (ReturnNode ret : rets) {
872                         returnType = checkCounter.getMethod().getSignature().getReturnType(checkCounter.getMethod().getDeclaringClass());
873                         String msg = &quot;unbalanced monitors in &quot; + graph.method().format(&quot;%H.%n(%p)&quot;) + &quot;, count = %d&quot;;
874                         ConstantNode errMsg = ConstantNode.forConstant(tool.getConstantReflection().forString(msg), providers.getMetaAccess(), graph);
875                         returnStamp = StampFactory.forDeclaredType(graph.getAssumptions(), returnType, false);
876                         callTarget = graph.add(new MethodCallTargetNode(InvokeKind.Static, checkCounter.getMethod(), new ValueNode[]{errMsg}, returnStamp, null));
877                         invoke = graph.add(new InvokeNode(callTarget, 0));
878                         Bytecode code = new ResolvedJavaMethodBytecode(graph.method());
879                         FrameState stateAfter = new FrameState(null, code, BytecodeFrame.AFTER_BCI, new ValueNode[0], new ValueNode[0], 0, new ValueNode[0], null, false, false);
880                         invoke.setStateAfter(graph.add(stateAfter));
881                         graph.addBeforeFixed(ret, invoke);
882 
883                         Arguments args = new Arguments(checkCounter, graph.getGuardsStage(), tool.getLoweringStage());
884                         args.addConst(&quot;errMsg&quot;, msg);
885                         inlineeGraph = template(invoke, args).copySpecializedGraph(graph.getDebug());
886                         InliningUtil.inline(invoke, inlineeGraph, false, null);
887                     }
</pre>
</td>
</tr>
</table>
<center><a href="InstanceOfSnippets.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NewObjectSnippets.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
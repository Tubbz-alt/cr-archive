<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotHostForeignCallsProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotGraphBuilderPlugins.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotInvocationPlugins.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotHostForeignCallsProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.NativeCall;
 28 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 29 import static org.graalvm.compiler.core.target.Backend.ARITHMETIC_DREM;
 30 import static org.graalvm.compiler.core.target.Backend.ARITHMETIC_FREM;
 31 import static org.graalvm.compiler.hotspot.HotSpotBackend.BACKEDGE_EVENT;

 32 import static org.graalvm.compiler.hotspot.HotSpotBackend.COUNTERMODE_IMPL_CRYPT;
 33 import static org.graalvm.compiler.hotspot.HotSpotBackend.DECRYPT;
 34 import static org.graalvm.compiler.hotspot.HotSpotBackend.DECRYPT_BLOCK;
 35 import static org.graalvm.compiler.hotspot.HotSpotBackend.DECRYPT_BLOCK_WITH_ORIGINAL_KEY;
 36 import static org.graalvm.compiler.hotspot.HotSpotBackend.DECRYPT_WITH_ORIGINAL_KEY;
 37 import static org.graalvm.compiler.hotspot.HotSpotBackend.ENCRYPT;
 38 import static org.graalvm.compiler.hotspot.HotSpotBackend.ENCRYPT_BLOCK;
 39 import static org.graalvm.compiler.hotspot.HotSpotBackend.EXCEPTION_HANDLER;
 40 import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
 41 import static org.graalvm.compiler.hotspot.HotSpotBackend.IC_MISS_HANDLER;
 42 import static org.graalvm.compiler.hotspot.HotSpotBackend.INITIALIZE_KLASS_BY_SYMBOL;
 43 import static org.graalvm.compiler.hotspot.HotSpotBackend.INVOCATION_EVENT;
 44 import static org.graalvm.compiler.hotspot.HotSpotBackend.MONTGOMERY_MULTIPLY;
 45 import static org.graalvm.compiler.hotspot.HotSpotBackend.MONTGOMERY_SQUARE;
 46 import static org.graalvm.compiler.hotspot.HotSpotBackend.MULTIPLY_TO_LEN;
 47 import static org.graalvm.compiler.hotspot.HotSpotBackend.MUL_ADD;
 48 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY;
 49 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY_OR_NULL;
 50 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE;
 51 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE_OR_NULL;
 52 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY;
 53 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY_OR_NULL;
 54 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_DYNAMIC_INVOKE;
 55 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_KLASS_BY_SYMBOL;
 56 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_METHOD_BY_SYMBOL_AND_LOAD_COUNTERS;
 57 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_STRING_BY_SYMBOL;
 58 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA2_IMPL_COMPRESS;
 59 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA2_IMPL_COMPRESS_MB;
 60 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA5_IMPL_COMPRESS;
 61 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA5_IMPL_COMPRESS_MB;
 62 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA_IMPL_COMPRESS;
 63 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA_IMPL_COMPRESS_MB;
 64 import static org.graalvm.compiler.hotspot.HotSpotBackend.SQUARE_TO_LEN;
 65 import static org.graalvm.compiler.hotspot.HotSpotBackend.UNWIND_EXCEPTION_TO_CALLER;
 66 import static org.graalvm.compiler.hotspot.HotSpotBackend.VECTORIZED_MISMATCHED;
 67 import static org.graalvm.compiler.hotspot.HotSpotBackend.VM_ERROR;
 68 import static org.graalvm.compiler.hotspot.HotSpotBackend.WRONG_METHOD_HANDLER;
 69 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Reexecutability.NOT_REEXECUTABLE;
 70 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Reexecutability.REEXECUTABLE;
<span class="line-modified"> 71 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Reexecutability.REEXECUTABLE_ONLY_AFTER_EXCEPTION;</span>
<span class="line-removed"> 72 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.DESTROYS_REGISTERS;</span>
<span class="line-removed"> 73 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.PRESERVES_REGISTERS;</span>
 74 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition.LEAF;
<span class="line-modified"> 75 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition.LEAF_NOFP;</span>
 76 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition.SAFEPOINT;
 77 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition.STACK_INSPECTABLE_LEAF;
<span class="line-modified"> 78 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.DEOPTIMIZATION_HANDLER;</span>


 79 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.ENABLE_STACK_RESERVED_ZONE;
 80 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.THROW_DELAYED_STACKOVERFLOW_ERROR;
<span class="line-removed"> 81 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.UNCOMMON_TRAP_HANDLER;</span>
 82 import static org.graalvm.compiler.hotspot.replacements.AssertionSnippets.ASSERTION_VM_MESSAGE_C;



 83 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
 84 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_END_LOCATION;
 85 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_TOP_LOCATION;



 86 import static org.graalvm.compiler.hotspot.replacements.MonitorSnippets.MONITORENTER;
 87 import static org.graalvm.compiler.hotspot.replacements.MonitorSnippets.MONITOREXIT;
 88 import static org.graalvm.compiler.hotspot.replacements.NewObjectSnippets.DYNAMIC_NEW_INSTANCE;
 89 import static org.graalvm.compiler.hotspot.replacements.NewObjectSnippets.DYNAMIC_NEW_INSTANCE_OR_NULL;
<span class="line-removed"> 90 import static org.graalvm.compiler.hotspot.replacements.ThreadSubstitutions.THREAD_IS_INTERRUPTED;</span>
<span class="line-removed"> 91 import static org.graalvm.compiler.hotspot.replacements.WriteBarrierSnippets.G1WBPOSTCALL;</span>
<span class="line-removed"> 92 import static org.graalvm.compiler.hotspot.replacements.WriteBarrierSnippets.G1WBPRECALL;</span>
<span class="line-removed"> 93 import static org.graalvm.compiler.hotspot.replacements.WriteBarrierSnippets.VALIDATE_OBJECT;</span>
 94 import static org.graalvm.compiler.hotspot.stubs.ExceptionHandlerStub.EXCEPTION_HANDLER_FOR_PC;
 95 import static org.graalvm.compiler.hotspot.stubs.StubUtil.VM_MESSAGE_C;
 96 import static org.graalvm.compiler.hotspot.stubs.UnwindExceptionToCallerStub.EXCEPTION_HANDLER_FOR_RETURN_ADDRESS;
 97 import static org.graalvm.compiler.nodes.java.ForeignCallDescriptors.REGISTER_FINALIZER;
<span class="line-removed"> 98 import static org.graalvm.compiler.replacements.Log.LOG_OBJECT;</span>
<span class="line-removed"> 99 import static org.graalvm.compiler.replacements.Log.LOG_PRIMITIVE;</span>
<span class="line-removed">100 import static org.graalvm.compiler.replacements.Log.LOG_PRINTF;</span>
101 import static org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode.BinaryOperation.POW;
102 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.COS;
103 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.EXP;
104 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG;
105 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG10;
106 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.SIN;
107 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.TAN;
108 import static jdk.internal.vm.compiler.word.LocationIdentity.any;
109 
110 import java.util.EnumMap;
111 
112 import jdk.internal.vm.compiler.collections.EconomicMap;
113 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
114 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
115 import org.graalvm.compiler.debug.GraalError;
116 import org.graalvm.compiler.hotspot.CompilerRuntimeHotSpotVMConfig;
117 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
118 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
119 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
120 import org.graalvm.compiler.hotspot.stubs.ArrayStoreExceptionStub;
</pre>
<hr />
<pre>
200         ForeignCallDescriptor desc = descMap.get(routine);
201         if (desc == null) {
202             desc = buildDescriptor(kind, aligned, disjoint, uninit, killAny, routine);
203             descMap.put(routine, desc);
204         }
205         if (uninit) {
206             assert kind == JavaKind.Object;
207             uninitObjectArraycopyDescriptors[aligned ? 1 : 0][disjoint ? 1 : 0] = desc;
208         } else if (killAny) {
209             arraycopyDescriptorsKillAny[aligned ? 1 : 0][disjoint ? 1 : 0].put(kind, desc);
210         } else {
211             arraycopyDescriptors[aligned ? 1 : 0][disjoint ? 1 : 0].put(kind, desc);
212         }
213     }
214 
215     private ForeignCallDescriptor buildDescriptor(JavaKind kind, boolean aligned, boolean disjoint, boolean uninit, boolean killAny, long routine) {
216         assert !uninit || kind == JavaKind.Object;
217         String name = kind + (aligned ? &quot;Aligned&quot; : &quot;&quot;) + (disjoint ? &quot;Disjoint&quot; : &quot;&quot;) + (uninit ? &quot;Uninit&quot; : &quot;&quot;) + &quot;Arraycopy&quot; + (killAny ? &quot;KillAny&quot; : &quot;&quot;);
218         ForeignCallDescriptor desc = new ForeignCallDescriptor(name, void.class, Word.class, Word.class, Word.class);
219         LocationIdentity killed = killAny ? LocationIdentity.any() : NamedLocationIdentity.getArrayLocation(kind);
<span class="line-modified">220         registerForeignCall(desc, routine, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, NOT_REEXECUTABLE, killed);</span>
221         return desc;
222     }
223 
224     private void registerCheckcastArraycopyDescriptor(boolean uninit, long routine) {
225         String name = &quot;Object&quot; + (uninit ? &quot;Uninit&quot; : &quot;&quot;) + &quot;CheckcastArraycopy&quot;;
226         // Input:
227         // c_rarg0 - source array address
228         // c_rarg1 - destination array address
229         // c_rarg2 - element count, treated as ssize_t, can be zero
230         // c_rarg3 - size_t ckoff (super_check_offset)
231         // c_rarg4 - oop ckval (super_klass)
232         // return: 0 = success, n = number of copied elements xor&#39;d with -1.
233         ForeignCallDescriptor desc = new ForeignCallDescriptor(name, int.class, Word.class, Word.class, Word.class, Word.class, Word.class);
234         LocationIdentity killed = NamedLocationIdentity.any();
<span class="line-modified">235         registerForeignCall(desc, routine, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, NOT_REEXECUTABLE, killed);</span>
236         checkcastArraycopyDescriptors[uninit ? 1 : 0] = desc;
237     }
238 
239     private void registerArrayCopy(JavaKind kind,
240                     long routine,
241                     long alignedRoutine,
242                     long disjointRoutine,
243                     long alignedDisjointRoutine) {
244         registerArrayCopy(kind, routine, alignedRoutine, disjointRoutine, alignedDisjointRoutine, false);
245     }
246 
247     private void registerArrayCopy(JavaKind kind,
248                     long routine,
249                     long alignedRoutine,
250                     long disjointRoutine,
251                     long alignedDisjointRoutine,
252                     boolean uninit) {
253         /*
254          * Sometimes the same function is used for multiple cases so share them when that&#39;s the case
255          * but only within the same Kind. For instance short and char are the same copy routines but
256          * they kill different memory so they still have to be distinct.
257          */
258         EconomicMap&lt;Long, ForeignCallDescriptor&gt; descMap = EconomicMap.create();
259         registerArraycopyDescriptor(descMap, kind, false, false, uninit, false, routine);
260         registerArraycopyDescriptor(descMap, kind, true, false, uninit, false, alignedRoutine);
261         registerArraycopyDescriptor(descMap, kind, false, true, uninit, false, disjointRoutine);
262         registerArraycopyDescriptor(descMap, kind, true, true, uninit, false, alignedDisjointRoutine);
263 
264         if (!uninit) {
265             EconomicMap&lt;Long, ForeignCallDescriptor&gt; killAnyDescMap = EconomicMap.create();
266             registerArraycopyDescriptor(killAnyDescMap, kind, false, false, uninit, true, routine);
267             registerArraycopyDescriptor(killAnyDescMap, kind, true, false, uninit, true, alignedRoutine);
268             registerArraycopyDescriptor(killAnyDescMap, kind, false, true, uninit, true, disjointRoutine);
269             registerArraycopyDescriptor(killAnyDescMap, kind, true, true, uninit, true, alignedDisjointRoutine);
270         }
271     }
272 
273     public void initialize(HotSpotProviders providers, OptionValues options) {
274         GraalHotSpotVMConfig c = runtime.getVMConfig();
<span class="line-modified">275         registerForeignCall(DEOPTIMIZATION_HANDLER, c.handleDeoptStub, NativeCall, PRESERVES_REGISTERS, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">276         registerForeignCall(UNCOMMON_TRAP_HANDLER, c.uncommonTrapStub, NativeCall, PRESERVES_REGISTERS, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">277         registerForeignCall(IC_MISS_HANDLER, c.inlineCacheMissStub, NativeCall, PRESERVES_REGISTERS, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>



278 
279         if (c.enableStackReservedZoneAddress != 0) {
280             assert c.throwDelayedStackOverflowErrorEntry != 0 : &quot;both must exist&quot;;
<span class="line-modified">281             registerForeignCall(ENABLE_STACK_RESERVED_ZONE, c.enableStackReservedZoneAddress, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">282             registerForeignCall(THROW_DELAYED_STACKOVERFLOW_ERROR, c.throwDelayedStackOverflowErrorEntry, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
283         }
284 
<span class="line-modified">285         registerForeignCall(JAVA_TIME_MILLIS, c.javaTimeMillisAddress, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">286         registerForeignCall(JAVA_TIME_NANOS, c.javaTimeNanosAddress, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
287 
288         registerMathStubs(c, providers, options);
289 
<span class="line-modified">290         registerForeignCall(ARITHMETIC_FREM, c.fremAddress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">291         registerForeignCall(ARITHMETIC_DREM, c.dremAddress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
292 
<span class="line-modified">293         registerForeignCall(LOAD_AND_CLEAR_EXCEPTION, c.loadAndClearExceptionAddress, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE_ONLY_AFTER_EXCEPTION, any());</span>
294 
<span class="line-modified">295         registerForeignCall(EXCEPTION_HANDLER_FOR_PC, c.exceptionHandlerForPcAddress, NativeCall, DESTROYS_REGISTERS, SAFEPOINT, REEXECUTABLE, any());</span>
<span class="line-modified">296         registerForeignCall(EXCEPTION_HANDLER_FOR_RETURN_ADDRESS, c.exceptionHandlerForReturnAddressAddress, NativeCall, DESTROYS_REGISTERS, SAFEPOINT, REEXECUTABLE, any());</span>
297 
298         CreateExceptionStub.registerForeignCalls(c, this);
299 
300         /*
301          * This message call is registered twice, where the second one must only be used for calls
302          * that do not return, i.e., that exit the VM.
303          */
<span class="line-modified">304         registerForeignCall(VM_MESSAGE_C, c.vmMessageAddress, NativeCall, DESTROYS_REGISTERS, SAFEPOINT, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">305         registerForeignCall(ASSERTION_VM_MESSAGE_C, c.vmMessageAddress, NativeCall, PRESERVES_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
306 
307         linkForeignCall(options, providers, NEW_INSTANCE, c.newInstanceAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
308         linkForeignCall(options, providers, NEW_ARRAY, c.newArrayAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
309         linkForeignCall(options, providers, NEW_MULTI_ARRAY, c.newMultiArrayAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
310         linkForeignCall(options, providers, DYNAMIC_NEW_INSTANCE, c.dynamicNewInstanceAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE);
311 
312         if (c.areNullAllocationStubsAvailable()) {
313             linkForeignCall(options, providers, NEW_INSTANCE_OR_NULL, c.newInstanceOrNullAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
314             linkForeignCall(options, providers, NEW_ARRAY_OR_NULL, c.newArrayOrNullAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
315             linkForeignCall(options, providers, NEW_MULTI_ARRAY_OR_NULL, c.newMultiArrayOrNullAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
316             linkForeignCall(options, providers, DYNAMIC_NEW_INSTANCE_OR_NULL, c.dynamicNewInstanceOrNullAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE);
317         }
318 
319         link(new ExceptionHandlerStub(options, providers, foreignCalls.get(EXCEPTION_HANDLER)));
<span class="line-modified">320         link(new UnwindExceptionToCallerStub(options, providers, registerStubCall(UNWIND_EXCEPTION_TO_CALLER, SAFEPOINT, REEXECUTABLE_ONLY_AFTER_EXCEPTION, any())));</span>
<span class="line-modified">321         link(new VerifyOopStub(options, providers, registerStubCall(VERIFY_OOP, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS)));</span>

322 
323         EnumMap&lt;BytecodeExceptionKind, ForeignCallDescriptor&gt; exceptionRuntimeCalls = DefaultHotSpotLoweringProvider.RuntimeCalls.runtimeCalls;
<span class="line-modified">324         link(new ArrayStoreExceptionStub(options, providers, registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.ARRAY_STORE), SAFEPOINT, REEXECUTABLE, any())));</span>
<span class="line-modified">325         link(new ClassCastExceptionStub(options, providers, registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.CLASS_CAST), SAFEPOINT, REEXECUTABLE, any())));</span>
<span class="line-modified">326         link(new NullPointerExceptionStub(options, providers, registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.NULL_POINTER), SAFEPOINT, REEXECUTABLE, any())));</span>
<span class="line-modified">327         link(new OutOfBoundsExceptionStub(options, providers, registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.OUT_OF_BOUNDS), SAFEPOINT, REEXECUTABLE, any())));</span>
<span class="line-modified">328         link(new DivisionByZeroExceptionStub(options, providers, registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.DIVISION_BY_ZERO), SAFEPOINT, REEXECUTABLE, any())));</span>
<span class="line-modified">329         link(new IntegerExactOverflowExceptionStub(options, providers, registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW), SAFEPOINT, REEXECUTABLE, any())));</span>
<span class="line-modified">330         link(new LongExactOverflowExceptionStub(options, providers, registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.LONG_EXACT_OVERFLOW), SAFEPOINT, REEXECUTABLE, any())));</span>
<span class="line-modified">331 </span>
<span class="line-modified">332         linkForeignCall(options, providers, IDENTITY_HASHCODE, c.identityHashCodeAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE_ONLY_AFTER_EXCEPTION, MARK_WORD_LOCATION);</span>
<span class="line-modified">333         linkForeignCall(options, providers, REGISTER_FINALIZER, c.registerFinalizerAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE_ONLY_AFTER_EXCEPTION, any());</span>
<span class="line-modified">334         linkForeignCall(options, providers, MONITORENTER, c.monitorenterAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE_ONLY_AFTER_EXCEPTION, any());</span>
<span class="line-modified">335         linkForeignCall(options, providers, MONITOREXIT, c.monitorexitAddress, PREPEND_THREAD, STACK_INSPECTABLE_LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION, any());</span>
<span class="line-modified">336         linkForeignCall(options, providers, NOTIFY, c.notifyAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE_ONLY_AFTER_EXCEPTION, any());</span>
<span class="line-modified">337         linkForeignCall(options, providers, NOTIFY_ALL, c.notifyAllAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE_ONLY_AFTER_EXCEPTION, any());</span>







338         linkForeignCall(options, providers, LOG_PRINTF, c.logPrintfAddress, PREPEND_THREAD, LEAF, REEXECUTABLE, NO_LOCATIONS);
339         linkForeignCall(options, providers, LOG_OBJECT, c.logObjectAddress, PREPEND_THREAD, LEAF, REEXECUTABLE, NO_LOCATIONS);
340         linkForeignCall(options, providers, LOG_PRIMITIVE, c.logPrimitiveAddress, PREPEND_THREAD, LEAF, REEXECUTABLE, NO_LOCATIONS);
<span class="line-modified">341         linkForeignCall(options, providers, VM_ERROR, c.vmErrorAddress, PREPEND_THREAD, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">342         linkForeignCall(options, providers, OSR_MIGRATION_END, c.osrMigrationEndAddress, DONT_PREPEND_THREAD, LEAF_NOFP, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NO_LOCATIONS);</span>
<span class="line-modified">343         linkForeignCall(options, providers, G1WBPRECALL, c.writeBarrierPreAddress, PREPEND_THREAD, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">344         linkForeignCall(options, providers, G1WBPOSTCALL, c.writeBarrierPostAddress, PREPEND_THREAD, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">345         linkForeignCall(options, providers, VALIDATE_OBJECT, c.validateObject, PREPEND_THREAD, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
346 
347         if (GeneratePIC.getValue(options)) {
<span class="line-modified">348             registerForeignCall(WRONG_METHOD_HANDLER, c.handleWrongMethodStub, NativeCall, PRESERVES_REGISTERS, LEAF_NOFP, REEXECUTABLE, NO_LOCATIONS);</span>
349             CompilerRuntimeHotSpotVMConfig cr = new CompilerRuntimeHotSpotVMConfig(HotSpotJVMCIRuntime.runtime().getConfigStore());
350             linkForeignCall(options, providers, RESOLVE_STRING_BY_SYMBOL, cr.resolveStringBySymbol, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
351             linkForeignCall(options, providers, RESOLVE_DYNAMIC_INVOKE, cr.resolveDynamicInvoke, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, any());
352             linkForeignCall(options, providers, RESOLVE_KLASS_BY_SYMBOL, cr.resolveKlassBySymbol, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, any());
353             linkForeignCall(options, providers, RESOLVE_METHOD_BY_SYMBOL_AND_LOAD_COUNTERS, cr.resolveMethodBySymbolAndLoadCounters, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, NO_LOCATIONS);
354             linkForeignCall(options, providers, INITIALIZE_KLASS_BY_SYMBOL, cr.initializeKlassBySymbol, PREPEND_THREAD, SAFEPOINT, NOT_REEXECUTABLE, any());
355             linkForeignCall(options, providers, INVOCATION_EVENT, cr.invocationEvent, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, NO_LOCATIONS);
356             linkForeignCall(options, providers, BACKEDGE_EVENT, cr.backedgeEvent, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, NO_LOCATIONS);
357         }
358 
<span class="line-removed">359         // Cannot be a leaf as VM acquires Thread_lock which requires thread_in_vm state</span>
<span class="line-removed">360         linkForeignCall(options, providers, THREAD_IS_INTERRUPTED, c.threadIsInterruptedAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE_ONLY_AFTER_EXCEPTION, any());</span>
<span class="line-removed">361 </span>
362         linkForeignCall(options, providers, TEST_DEOPTIMIZE_CALL_INT, c.testDeoptimizeCallInt, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, any());
363 
364         registerArrayCopy(JavaKind.Byte, c.jbyteArraycopy, c.jbyteAlignedArraycopy, c.jbyteDisjointArraycopy, c.jbyteAlignedDisjointArraycopy);
365         registerArrayCopy(JavaKind.Boolean, c.jbyteArraycopy, c.jbyteAlignedArraycopy, c.jbyteDisjointArraycopy, c.jbyteAlignedDisjointArraycopy);
366         registerArrayCopy(JavaKind.Char, c.jshortArraycopy, c.jshortAlignedArraycopy, c.jshortDisjointArraycopy, c.jshortAlignedDisjointArraycopy);
367         registerArrayCopy(JavaKind.Short, c.jshortArraycopy, c.jshortAlignedArraycopy, c.jshortDisjointArraycopy, c.jshortAlignedDisjointArraycopy);
368         registerArrayCopy(JavaKind.Int, c.jintArraycopy, c.jintAlignedArraycopy, c.jintDisjointArraycopy, c.jintAlignedDisjointArraycopy);
369         registerArrayCopy(JavaKind.Float, c.jintArraycopy, c.jintAlignedArraycopy, c.jintDisjointArraycopy, c.jintAlignedDisjointArraycopy);
370         registerArrayCopy(JavaKind.Long, c.jlongArraycopy, c.jlongAlignedArraycopy, c.jlongDisjointArraycopy, c.jlongAlignedDisjointArraycopy);
371         registerArrayCopy(JavaKind.Double, c.jlongArraycopy, c.jlongAlignedArraycopy, c.jlongDisjointArraycopy, c.jlongAlignedDisjointArraycopy);
372         registerArrayCopy(JavaKind.Object, c.oopArraycopy, c.oopAlignedArraycopy, c.oopDisjointArraycopy, c.oopAlignedDisjointArraycopy);
373         registerArrayCopy(JavaKind.Object, c.oopArraycopyUninit, c.oopAlignedArraycopyUninit, c.oopDisjointArraycopyUninit, c.oopAlignedDisjointArraycopyUninit, true);
374 
375         registerCheckcastArraycopyDescriptor(true, c.checkcastArraycopyUninit);
376         registerCheckcastArraycopyDescriptor(false, c.checkcastArraycopy);
377 
<span class="line-modified">378         registerForeignCall(GENERIC_ARRAYCOPY, c.genericArraycopy, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.any());</span>
<span class="line-modified">379         registerForeignCall(UNSAFE_ARRAYCOPY, c.unsafeArraycopy, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.any());</span>
380 
381         if (c.useMultiplyToLenIntrinsic()) {
<span class="line-modified">382             registerForeignCall(MULTIPLY_TO_LEN, c.multiplyToLen, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
383                             NamedLocationIdentity.getArrayLocation(JavaKind.Int));
384         }
385 
386         if (c.useSHA1Intrinsics()) {
<span class="line-modified">387             registerForeignCall(SHA_IMPL_COMPRESS, c.sha1ImplCompress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.any());</span>
<span class="line-modified">388             registerForeignCall(SHA_IMPL_COMPRESS_MB, c.sha1ImplCompressMultiBlock, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.any());</span>
389         }
390         if (c.useSHA256Intrinsics()) {
<span class="line-modified">391             registerForeignCall(SHA2_IMPL_COMPRESS, c.sha256ImplCompress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.any());</span>
<span class="line-modified">392             registerForeignCall(SHA2_IMPL_COMPRESS_MB, c.sha256ImplCompressMultiBlock, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.any());</span>
393         }
394         if (c.useSHA512Intrinsics()) {
<span class="line-modified">395             registerForeignCall(SHA5_IMPL_COMPRESS, c.sha512ImplCompress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.any());</span>
<span class="line-modified">396             registerForeignCall(SHA5_IMPL_COMPRESS_MB, c.sha512ImplCompressMultiBlock, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.any());</span>
397         }
398         if (c.useGHASHIntrinsics()) {
<span class="line-modified">399             registerForeignCall(GHASH_PROCESS_BLOCKS, c.ghashProcessBlocks, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.any());</span>



400         }
401         if (c.useMulAddIntrinsic()) {
<span class="line-modified">402             registerForeignCall(MUL_ADD, c.mulAdd, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.getArrayLocation(JavaKind.Int));</span>
403         }
404         if (c.useMontgomeryMultiplyIntrinsic()) {
<span class="line-modified">405             registerForeignCall(MONTGOMERY_MULTIPLY, c.montgomeryMultiply, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
406                             NamedLocationIdentity.getArrayLocation(JavaKind.Int));
407         }
408         if (c.useMontgomerySquareIntrinsic()) {
<span class="line-modified">409             registerForeignCall(MONTGOMERY_SQUARE, c.montgomerySquare, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
410                             NamedLocationIdentity.getArrayLocation(JavaKind.Int));
411         }
412         if (c.useSquareToLenIntrinsic()) {
<span class="line-modified">413             registerForeignCall(SQUARE_TO_LEN, c.squareToLen, NativeCall, DESTROYS_REGISTERS, LEAF_NOFP, REEXECUTABLE_ONLY_AFTER_EXCEPTION, NamedLocationIdentity.getArrayLocation(JavaKind.Int));</span>
414         }
415 
416         if (c.useAESIntrinsics) {
417             /*
418              * When the java.ext.dirs property is modified then the crypto classes might not be
419              * found. If that&#39;s the case we ignore the ClassNotFoundException and continue since we
420              * cannot replace a non-existing method anyway.
421              */
422             try {
423                 // These stubs do callee saving
<span class="line-modified">424                 registerForeignCall(ENCRYPT_BLOCK, c.aescryptEncryptBlockStub, NativeCall, PRESERVES_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
425                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
<span class="line-modified">426                 registerForeignCall(DECRYPT_BLOCK, c.aescryptDecryptBlockStub, NativeCall, PRESERVES_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
427                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
<span class="line-modified">428                 registerForeignCall(DECRYPT_BLOCK_WITH_ORIGINAL_KEY, c.aescryptDecryptBlockStub, NativeCall, PRESERVES_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
429                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
430             } catch (GraalError e) {
431                 if (!(e.getCause() instanceof ClassNotFoundException)) {
432                     throw e;
433                 }
434             }
435             try {
436                 // These stubs do callee saving
<span class="line-modified">437                 registerForeignCall(ENCRYPT, c.cipherBlockChainingEncryptAESCryptStub, NativeCall, PRESERVES_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
438                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
<span class="line-modified">439                 registerForeignCall(DECRYPT, c.cipherBlockChainingDecryptAESCryptStub, NativeCall, PRESERVES_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
440                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
<span class="line-modified">441                 registerForeignCall(DECRYPT_WITH_ORIGINAL_KEY, c.cipherBlockChainingDecryptAESCryptStub, NativeCall, PRESERVES_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
442                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
443             } catch (GraalError e) {
444                 if (!(e.getCause() instanceof ClassNotFoundException)) {
445                     throw e;
446                 }
447             }
448         }
449 
450         if (c.useAESCTRIntrinsics) {
451             assert (c.counterModeAESCrypt != 0L);
<span class="line-modified">452             registerForeignCall(COUNTERMODE_IMPL_CRYPT, c.counterModeAESCrypt, NativeCall, PRESERVES_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
453                             NamedLocationIdentity.any());
454         }
455 
456         if (c.useVectorizedMismatchIntrinsic) {
457             assert (c.vectorizedMismatch != 0L);
<span class="line-modified">458             registerForeignCall(VECTORIZED_MISMATCHED, c.vectorizedMismatch, NativeCall, PRESERVES_REGISTERS, LEAF, REEXECUTABLE_ONLY_AFTER_EXCEPTION,</span>
459                             NamedLocationIdentity.any());
460 
461         }
462     }
463 
464     public HotSpotForeignCallLinkage getForeignCall(ForeignCallDescriptor descriptor) {
465         assert foreignCalls != null : descriptor;
466         return foreignCalls.get(descriptor);
467     }
468 
469     @SuppressWarnings(&quot;unused&quot;)
470     protected void registerMathStubs(GraalHotSpotVMConfig hotSpotVMConfig, HotSpotProviders providers, OptionValues options) {
<span class="line-modified">471         registerForeignCall(SIN.foreignCallDescriptor, hotSpotVMConfig.arithmeticSinAddress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">472         registerForeignCall(COS.foreignCallDescriptor, hotSpotVMConfig.arithmeticCosAddress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">473         registerForeignCall(TAN.foreignCallDescriptor, hotSpotVMConfig.arithmeticTanAddress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">474         registerForeignCall(EXP.foreignCallDescriptor, hotSpotVMConfig.arithmeticExpAddress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">475         registerForeignCall(LOG.foreignCallDescriptor, hotSpotVMConfig.arithmeticLogAddress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">476         registerForeignCall(LOG10.foreignCallDescriptor, hotSpotVMConfig.arithmeticLog10Address, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">477         registerForeignCall(POW.foreignCallDescriptor, hotSpotVMConfig.arithmeticPowAddress, NativeCall, DESTROYS_REGISTERS, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
478     }
479 }
</pre>
</td>
<td>
<hr />
<pre>
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.NativeCall;
 28 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 29 import static org.graalvm.compiler.core.target.Backend.ARITHMETIC_DREM;
 30 import static org.graalvm.compiler.core.target.Backend.ARITHMETIC_FREM;
 31 import static org.graalvm.compiler.hotspot.HotSpotBackend.BACKEDGE_EVENT;
<span class="line-added"> 32 import static org.graalvm.compiler.hotspot.HotSpotBackend.BASE64_ENCODE_BLOCK;</span>
 33 import static org.graalvm.compiler.hotspot.HotSpotBackend.COUNTERMODE_IMPL_CRYPT;
 34 import static org.graalvm.compiler.hotspot.HotSpotBackend.DECRYPT;
 35 import static org.graalvm.compiler.hotspot.HotSpotBackend.DECRYPT_BLOCK;
 36 import static org.graalvm.compiler.hotspot.HotSpotBackend.DECRYPT_BLOCK_WITH_ORIGINAL_KEY;
 37 import static org.graalvm.compiler.hotspot.HotSpotBackend.DECRYPT_WITH_ORIGINAL_KEY;
 38 import static org.graalvm.compiler.hotspot.HotSpotBackend.ENCRYPT;
 39 import static org.graalvm.compiler.hotspot.HotSpotBackend.ENCRYPT_BLOCK;
 40 import static org.graalvm.compiler.hotspot.HotSpotBackend.EXCEPTION_HANDLER;
 41 import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
 42 import static org.graalvm.compiler.hotspot.HotSpotBackend.IC_MISS_HANDLER;
 43 import static org.graalvm.compiler.hotspot.HotSpotBackend.INITIALIZE_KLASS_BY_SYMBOL;
 44 import static org.graalvm.compiler.hotspot.HotSpotBackend.INVOCATION_EVENT;
 45 import static org.graalvm.compiler.hotspot.HotSpotBackend.MONTGOMERY_MULTIPLY;
 46 import static org.graalvm.compiler.hotspot.HotSpotBackend.MONTGOMERY_SQUARE;
 47 import static org.graalvm.compiler.hotspot.HotSpotBackend.MULTIPLY_TO_LEN;
 48 import static org.graalvm.compiler.hotspot.HotSpotBackend.MUL_ADD;
 49 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY;
 50 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY_OR_NULL;
 51 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE;
 52 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE_OR_NULL;
 53 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY;
 54 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY_OR_NULL;
 55 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_DYNAMIC_INVOKE;
 56 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_KLASS_BY_SYMBOL;
 57 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_METHOD_BY_SYMBOL_AND_LOAD_COUNTERS;
 58 import static org.graalvm.compiler.hotspot.HotSpotBackend.RESOLVE_STRING_BY_SYMBOL;
 59 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA2_IMPL_COMPRESS;
 60 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA2_IMPL_COMPRESS_MB;
 61 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA5_IMPL_COMPRESS;
 62 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA5_IMPL_COMPRESS_MB;
 63 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA_IMPL_COMPRESS;
 64 import static org.graalvm.compiler.hotspot.HotSpotBackend.SHA_IMPL_COMPRESS_MB;
 65 import static org.graalvm.compiler.hotspot.HotSpotBackend.SQUARE_TO_LEN;
 66 import static org.graalvm.compiler.hotspot.HotSpotBackend.UNWIND_EXCEPTION_TO_CALLER;
 67 import static org.graalvm.compiler.hotspot.HotSpotBackend.VECTORIZED_MISMATCHED;
 68 import static org.graalvm.compiler.hotspot.HotSpotBackend.VM_ERROR;
 69 import static org.graalvm.compiler.hotspot.HotSpotBackend.WRONG_METHOD_HANDLER;
 70 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Reexecutability.NOT_REEXECUTABLE;
 71 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Reexecutability.REEXECUTABLE;
<span class="line-modified"> 72 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.DESTROYS_ALL_CALLER_SAVE_REGISTERS;</span>


 73 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition.LEAF;
<span class="line-modified"> 74 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition.LEAF_NO_VZERO;</span>
 75 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition.SAFEPOINT;
 76 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition.STACK_INSPECTABLE_LEAF;
<span class="line-modified"> 77 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.DEOPT_BLOB_UNCOMMON_TRAP;</span>
<span class="line-added"> 78 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.DEOPT_BLOB_UNPACK;</span>
<span class="line-added"> 79 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.DEOPT_BLOB_UNPACK_WITH_EXCEPTION_IN_TLS;</span>
 80 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.ENABLE_STACK_RESERVED_ZONE;
 81 import static org.graalvm.compiler.hotspot.HotSpotHostBackend.THROW_DELAYED_STACKOVERFLOW_ERROR;

 82 import static org.graalvm.compiler.hotspot.replacements.AssertionSnippets.ASSERTION_VM_MESSAGE_C;
<span class="line-added"> 83 import static org.graalvm.compiler.hotspot.replacements.HotSpotG1WriteBarrierSnippets.G1WBPOSTCALL;</span>
<span class="line-added"> 84 import static org.graalvm.compiler.hotspot.replacements.HotSpotG1WriteBarrierSnippets.G1WBPRECALL;</span>
<span class="line-added"> 85 import static org.graalvm.compiler.hotspot.replacements.HotSpotG1WriteBarrierSnippets.VALIDATE_OBJECT;</span>
 86 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
 87 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_END_LOCATION;
 88 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_TOP_LOCATION;
<span class="line-added"> 89 import static org.graalvm.compiler.hotspot.replacements.Log.LOG_OBJECT;</span>
<span class="line-added"> 90 import static org.graalvm.compiler.hotspot.replacements.Log.LOG_PRIMITIVE;</span>
<span class="line-added"> 91 import static org.graalvm.compiler.hotspot.replacements.Log.LOG_PRINTF;</span>
 92 import static org.graalvm.compiler.hotspot.replacements.MonitorSnippets.MONITORENTER;
 93 import static org.graalvm.compiler.hotspot.replacements.MonitorSnippets.MONITOREXIT;
 94 import static org.graalvm.compiler.hotspot.replacements.NewObjectSnippets.DYNAMIC_NEW_INSTANCE;
 95 import static org.graalvm.compiler.hotspot.replacements.NewObjectSnippets.DYNAMIC_NEW_INSTANCE_OR_NULL;




 96 import static org.graalvm.compiler.hotspot.stubs.ExceptionHandlerStub.EXCEPTION_HANDLER_FOR_PC;
 97 import static org.graalvm.compiler.hotspot.stubs.StubUtil.VM_MESSAGE_C;
 98 import static org.graalvm.compiler.hotspot.stubs.UnwindExceptionToCallerStub.EXCEPTION_HANDLER_FOR_RETURN_ADDRESS;
 99 import static org.graalvm.compiler.nodes.java.ForeignCallDescriptors.REGISTER_FINALIZER;



100 import static org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode.BinaryOperation.POW;
101 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.COS;
102 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.EXP;
103 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG;
104 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG10;
105 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.SIN;
106 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.TAN;
107 import static jdk.internal.vm.compiler.word.LocationIdentity.any;
108 
109 import java.util.EnumMap;
110 
111 import jdk.internal.vm.compiler.collections.EconomicMap;
112 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
113 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
114 import org.graalvm.compiler.debug.GraalError;
115 import org.graalvm.compiler.hotspot.CompilerRuntimeHotSpotVMConfig;
116 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
117 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
118 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
119 import org.graalvm.compiler.hotspot.stubs.ArrayStoreExceptionStub;
</pre>
<hr />
<pre>
199         ForeignCallDescriptor desc = descMap.get(routine);
200         if (desc == null) {
201             desc = buildDescriptor(kind, aligned, disjoint, uninit, killAny, routine);
202             descMap.put(routine, desc);
203         }
204         if (uninit) {
205             assert kind == JavaKind.Object;
206             uninitObjectArraycopyDescriptors[aligned ? 1 : 0][disjoint ? 1 : 0] = desc;
207         } else if (killAny) {
208             arraycopyDescriptorsKillAny[aligned ? 1 : 0][disjoint ? 1 : 0].put(kind, desc);
209         } else {
210             arraycopyDescriptors[aligned ? 1 : 0][disjoint ? 1 : 0].put(kind, desc);
211         }
212     }
213 
214     private ForeignCallDescriptor buildDescriptor(JavaKind kind, boolean aligned, boolean disjoint, boolean uninit, boolean killAny, long routine) {
215         assert !uninit || kind == JavaKind.Object;
216         String name = kind + (aligned ? &quot;Aligned&quot; : &quot;&quot;) + (disjoint ? &quot;Disjoint&quot; : &quot;&quot;) + (uninit ? &quot;Uninit&quot; : &quot;&quot;) + &quot;Arraycopy&quot; + (killAny ? &quot;KillAny&quot; : &quot;&quot;);
217         ForeignCallDescriptor desc = new ForeignCallDescriptor(name, void.class, Word.class, Word.class, Word.class);
218         LocationIdentity killed = killAny ? LocationIdentity.any() : NamedLocationIdentity.getArrayLocation(kind);
<span class="line-modified">219         registerForeignCall(desc, routine, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE, killed);</span>
220         return desc;
221     }
222 
223     private void registerCheckcastArraycopyDescriptor(boolean uninit, long routine) {
224         String name = &quot;Object&quot; + (uninit ? &quot;Uninit&quot; : &quot;&quot;) + &quot;CheckcastArraycopy&quot;;
225         // Input:
226         // c_rarg0 - source array address
227         // c_rarg1 - destination array address
228         // c_rarg2 - element count, treated as ssize_t, can be zero
229         // c_rarg3 - size_t ckoff (super_check_offset)
230         // c_rarg4 - oop ckval (super_klass)
231         // return: 0 = success, n = number of copied elements xor&#39;d with -1.
232         ForeignCallDescriptor desc = new ForeignCallDescriptor(name, int.class, Word.class, Word.class, Word.class, Word.class, Word.class);
233         LocationIdentity killed = NamedLocationIdentity.any();
<span class="line-modified">234         registerForeignCall(desc, routine, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE, killed);</span>
235         checkcastArraycopyDescriptors[uninit ? 1 : 0] = desc;
236     }
237 
238     private void registerArrayCopy(JavaKind kind,
239                     long routine,
240                     long alignedRoutine,
241                     long disjointRoutine,
242                     long alignedDisjointRoutine) {
243         registerArrayCopy(kind, routine, alignedRoutine, disjointRoutine, alignedDisjointRoutine, false);
244     }
245 
246     private void registerArrayCopy(JavaKind kind,
247                     long routine,
248                     long alignedRoutine,
249                     long disjointRoutine,
250                     long alignedDisjointRoutine,
251                     boolean uninit) {
252         /*
253          * Sometimes the same function is used for multiple cases so share them when that&#39;s the case
254          * but only within the same Kind. For instance short and char are the same copy routines but
255          * they kill different memory so they still have to be distinct.
256          */
257         EconomicMap&lt;Long, ForeignCallDescriptor&gt; descMap = EconomicMap.create();
258         registerArraycopyDescriptor(descMap, kind, false, false, uninit, false, routine);
259         registerArraycopyDescriptor(descMap, kind, true, false, uninit, false, alignedRoutine);
260         registerArraycopyDescriptor(descMap, kind, false, true, uninit, false, disjointRoutine);
261         registerArraycopyDescriptor(descMap, kind, true, true, uninit, false, alignedDisjointRoutine);
262 
263         if (!uninit) {
264             EconomicMap&lt;Long, ForeignCallDescriptor&gt; killAnyDescMap = EconomicMap.create();
265             registerArraycopyDescriptor(killAnyDescMap, kind, false, false, uninit, true, routine);
266             registerArraycopyDescriptor(killAnyDescMap, kind, true, false, uninit, true, alignedRoutine);
267             registerArraycopyDescriptor(killAnyDescMap, kind, false, true, uninit, true, disjointRoutine);
268             registerArraycopyDescriptor(killAnyDescMap, kind, true, true, uninit, true, alignedDisjointRoutine);
269         }
270     }
271 
272     public void initialize(HotSpotProviders providers, OptionValues options) {
273         GraalHotSpotVMConfig c = runtime.getVMConfig();
<span class="line-modified">274         registerForeignCall(DEOPT_BLOB_UNPACK, c.deoptBlobUnpack, NativeCall, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">275         if (c.deoptBlobUnpackWithExceptionInTLS != 0) {</span>
<span class="line-modified">276             registerForeignCall(DEOPT_BLOB_UNPACK_WITH_EXCEPTION_IN_TLS, c.deoptBlobUnpackWithExceptionInTLS, NativeCall, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-added">277         }</span>
<span class="line-added">278         registerForeignCall(DEOPT_BLOB_UNCOMMON_TRAP, c.deoptBlobUncommonTrap, NativeCall, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-added">279         registerForeignCall(IC_MISS_HANDLER, c.inlineCacheMissStub, NativeCall, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
280 
281         if (c.enableStackReservedZoneAddress != 0) {
282             assert c.throwDelayedStackOverflowErrorEntry != 0 : &quot;both must exist&quot;;
<span class="line-modified">283             registerForeignCall(ENABLE_STACK_RESERVED_ZONE, c.enableStackReservedZoneAddress, NativeCall, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">284             registerForeignCall(THROW_DELAYED_STACKOVERFLOW_ERROR, c.throwDelayedStackOverflowErrorEntry, NativeCall, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
285         }
286 
<span class="line-modified">287         registerForeignCall(JAVA_TIME_MILLIS, c.javaTimeMillisAddress, NativeCall, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">288         registerForeignCall(JAVA_TIME_NANOS, c.javaTimeNanosAddress, NativeCall, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
289 
290         registerMathStubs(c, providers, options);
291 
<span class="line-modified">292         registerForeignCall(ARITHMETIC_FREM, c.fremAddress, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">293         registerForeignCall(ARITHMETIC_DREM, c.dremAddress, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
294 
<span class="line-modified">295         registerForeignCall(LOAD_AND_CLEAR_EXCEPTION, c.loadAndClearExceptionAddress, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE, any());</span>
296 
<span class="line-modified">297         registerForeignCall(EXCEPTION_HANDLER_FOR_PC, c.exceptionHandlerForPcAddress, NativeCall, SAFEPOINT, REEXECUTABLE, any());</span>
<span class="line-modified">298         registerForeignCall(EXCEPTION_HANDLER_FOR_RETURN_ADDRESS, c.exceptionHandlerForReturnAddressAddress, NativeCall, SAFEPOINT, REEXECUTABLE, any());</span>
299 
300         CreateExceptionStub.registerForeignCalls(c, this);
301 
302         /*
303          * This message call is registered twice, where the second one must only be used for calls
304          * that do not return, i.e., that exit the VM.
305          */
<span class="line-modified">306         registerForeignCall(VM_MESSAGE_C, c.vmMessageAddress, NativeCall, SAFEPOINT, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">307         registerForeignCall(ASSERTION_VM_MESSAGE_C, c.vmMessageAddress, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
308 
309         linkForeignCall(options, providers, NEW_INSTANCE, c.newInstanceAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
310         linkForeignCall(options, providers, NEW_ARRAY, c.newArrayAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
311         linkForeignCall(options, providers, NEW_MULTI_ARRAY, c.newMultiArrayAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
312         linkForeignCall(options, providers, DYNAMIC_NEW_INSTANCE, c.dynamicNewInstanceAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE);
313 
314         if (c.areNullAllocationStubsAvailable()) {
315             linkForeignCall(options, providers, NEW_INSTANCE_OR_NULL, c.newInstanceOrNullAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
316             linkForeignCall(options, providers, NEW_ARRAY_OR_NULL, c.newArrayOrNullAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
317             linkForeignCall(options, providers, NEW_MULTI_ARRAY_OR_NULL, c.newMultiArrayOrNullAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
318             linkForeignCall(options, providers, DYNAMIC_NEW_INSTANCE_OR_NULL, c.dynamicNewInstanceOrNullAddress, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE);
319         }
320 
321         link(new ExceptionHandlerStub(options, providers, foreignCalls.get(EXCEPTION_HANDLER)));
<span class="line-modified">322         link(new UnwindExceptionToCallerStub(options, providers,</span>
<span class="line-modified">323                         registerStubCall(UNWIND_EXCEPTION_TO_CALLER, SAFEPOINT, NOT_REEXECUTABLE, DESTROYS_ALL_CALLER_SAVE_REGISTERS, any())));</span>
<span class="line-added">324         link(new VerifyOopStub(options, providers, registerStubCall(VERIFY_OOP, LEAF_NO_VZERO, REEXECUTABLE, DESTROYS_ALL_CALLER_SAVE_REGISTERS, NO_LOCATIONS)));</span>
325 
326         EnumMap&lt;BytecodeExceptionKind, ForeignCallDescriptor&gt; exceptionRuntimeCalls = DefaultHotSpotLoweringProvider.RuntimeCalls.runtimeCalls;
<span class="line-modified">327         link(new ArrayStoreExceptionStub(options, providers,</span>
<span class="line-modified">328                         registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.ARRAY_STORE), SAFEPOINT, NOT_REEXECUTABLE, DESTROYS_ALL_CALLER_SAVE_REGISTERS, any())));</span>
<span class="line-modified">329         link(new ClassCastExceptionStub(options, providers,</span>
<span class="line-modified">330                         registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.CLASS_CAST), SAFEPOINT, NOT_REEXECUTABLE, DESTROYS_ALL_CALLER_SAVE_REGISTERS, any())));</span>
<span class="line-modified">331         link(new NullPointerExceptionStub(options, providers,</span>
<span class="line-modified">332                         registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.NULL_POINTER), SAFEPOINT, NOT_REEXECUTABLE, DESTROYS_ALL_CALLER_SAVE_REGISTERS, any())));</span>
<span class="line-modified">333         link(new OutOfBoundsExceptionStub(options, providers,</span>
<span class="line-modified">334                         registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.OUT_OF_BOUNDS), SAFEPOINT, NOT_REEXECUTABLE, DESTROYS_ALL_CALLER_SAVE_REGISTERS, any())));</span>
<span class="line-modified">335         link(new DivisionByZeroExceptionStub(options, providers,</span>
<span class="line-modified">336                         registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.DIVISION_BY_ZERO), SAFEPOINT, NOT_REEXECUTABLE, DESTROYS_ALL_CALLER_SAVE_REGISTERS, any())));</span>
<span class="line-modified">337         link(new IntegerExactOverflowExceptionStub(options, providers,</span>
<span class="line-modified">338                         registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW), SAFEPOINT, NOT_REEXECUTABLE, DESTROYS_ALL_CALLER_SAVE_REGISTERS, any())));</span>
<span class="line-modified">339         link(new LongExactOverflowExceptionStub(options, providers,</span>
<span class="line-modified">340                         registerStubCall(exceptionRuntimeCalls.get(BytecodeExceptionKind.LONG_EXACT_OVERFLOW), SAFEPOINT, NOT_REEXECUTABLE, DESTROYS_ALL_CALLER_SAVE_REGISTERS, any())));</span>
<span class="line-added">341 </span>
<span class="line-added">342         linkForeignCall(options, providers, IDENTITY_HASHCODE, c.identityHashCodeAddress, PREPEND_THREAD, SAFEPOINT, NOT_REEXECUTABLE, MARK_WORD_LOCATION);</span>
<span class="line-added">343         linkForeignCall(options, providers, REGISTER_FINALIZER, c.registerFinalizerAddress, PREPEND_THREAD, SAFEPOINT, NOT_REEXECUTABLE, any());</span>
<span class="line-added">344         linkForeignCall(options, providers, MONITORENTER, c.monitorenterAddress, PREPEND_THREAD, SAFEPOINT, NOT_REEXECUTABLE, any());</span>
<span class="line-added">345         linkForeignCall(options, providers, MONITOREXIT, c.monitorexitAddress, PREPEND_THREAD, STACK_INSPECTABLE_LEAF, NOT_REEXECUTABLE, any());</span>
<span class="line-added">346         linkForeignCall(options, providers, NOTIFY, c.notifyAddress, PREPEND_THREAD, LEAF_NO_VZERO, NOT_REEXECUTABLE, any());</span>
<span class="line-added">347         linkForeignCall(options, providers, NOTIFY_ALL, c.notifyAllAddress, PREPEND_THREAD, LEAF_NO_VZERO, NOT_REEXECUTABLE, any());</span>
348         linkForeignCall(options, providers, LOG_PRINTF, c.logPrintfAddress, PREPEND_THREAD, LEAF, REEXECUTABLE, NO_LOCATIONS);
349         linkForeignCall(options, providers, LOG_OBJECT, c.logObjectAddress, PREPEND_THREAD, LEAF, REEXECUTABLE, NO_LOCATIONS);
350         linkForeignCall(options, providers, LOG_PRIMITIVE, c.logPrimitiveAddress, PREPEND_THREAD, LEAF, REEXECUTABLE, NO_LOCATIONS);
<span class="line-modified">351         linkForeignCall(options, providers, VM_ERROR, c.vmErrorAddress, PREPEND_THREAD, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">352         linkForeignCall(options, providers, OSR_MIGRATION_END, c.osrMigrationEndAddress, DONT_PREPEND_THREAD, LEAF_NO_VZERO, NOT_REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">353         linkForeignCall(options, providers, G1WBPRECALL, c.writeBarrierPreAddress, PREPEND_THREAD, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">354         linkForeignCall(options, providers, G1WBPOSTCALL, c.writeBarrierPostAddress, PREPEND_THREAD, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">355         linkForeignCall(options, providers, VALIDATE_OBJECT, c.validateObject, PREPEND_THREAD, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
356 
357         if (GeneratePIC.getValue(options)) {
<span class="line-modified">358             registerForeignCall(WRONG_METHOD_HANDLER, c.handleWrongMethodStub, NativeCall, LEAF_NO_VZERO, REEXECUTABLE, NO_LOCATIONS);</span>
359             CompilerRuntimeHotSpotVMConfig cr = new CompilerRuntimeHotSpotVMConfig(HotSpotJVMCIRuntime.runtime().getConfigStore());
360             linkForeignCall(options, providers, RESOLVE_STRING_BY_SYMBOL, cr.resolveStringBySymbol, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
361             linkForeignCall(options, providers, RESOLVE_DYNAMIC_INVOKE, cr.resolveDynamicInvoke, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, any());
362             linkForeignCall(options, providers, RESOLVE_KLASS_BY_SYMBOL, cr.resolveKlassBySymbol, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, any());
363             linkForeignCall(options, providers, RESOLVE_METHOD_BY_SYMBOL_AND_LOAD_COUNTERS, cr.resolveMethodBySymbolAndLoadCounters, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, NO_LOCATIONS);
364             linkForeignCall(options, providers, INITIALIZE_KLASS_BY_SYMBOL, cr.initializeKlassBySymbol, PREPEND_THREAD, SAFEPOINT, NOT_REEXECUTABLE, any());
365             linkForeignCall(options, providers, INVOCATION_EVENT, cr.invocationEvent, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, NO_LOCATIONS);
366             linkForeignCall(options, providers, BACKEDGE_EVENT, cr.backedgeEvent, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, NO_LOCATIONS);
367         }
368 



369         linkForeignCall(options, providers, TEST_DEOPTIMIZE_CALL_INT, c.testDeoptimizeCallInt, PREPEND_THREAD, SAFEPOINT, REEXECUTABLE, any());
370 
371         registerArrayCopy(JavaKind.Byte, c.jbyteArraycopy, c.jbyteAlignedArraycopy, c.jbyteDisjointArraycopy, c.jbyteAlignedDisjointArraycopy);
372         registerArrayCopy(JavaKind.Boolean, c.jbyteArraycopy, c.jbyteAlignedArraycopy, c.jbyteDisjointArraycopy, c.jbyteAlignedDisjointArraycopy);
373         registerArrayCopy(JavaKind.Char, c.jshortArraycopy, c.jshortAlignedArraycopy, c.jshortDisjointArraycopy, c.jshortAlignedDisjointArraycopy);
374         registerArrayCopy(JavaKind.Short, c.jshortArraycopy, c.jshortAlignedArraycopy, c.jshortDisjointArraycopy, c.jshortAlignedDisjointArraycopy);
375         registerArrayCopy(JavaKind.Int, c.jintArraycopy, c.jintAlignedArraycopy, c.jintDisjointArraycopy, c.jintAlignedDisjointArraycopy);
376         registerArrayCopy(JavaKind.Float, c.jintArraycopy, c.jintAlignedArraycopy, c.jintDisjointArraycopy, c.jintAlignedDisjointArraycopy);
377         registerArrayCopy(JavaKind.Long, c.jlongArraycopy, c.jlongAlignedArraycopy, c.jlongDisjointArraycopy, c.jlongAlignedDisjointArraycopy);
378         registerArrayCopy(JavaKind.Double, c.jlongArraycopy, c.jlongAlignedArraycopy, c.jlongDisjointArraycopy, c.jlongAlignedDisjointArraycopy);
379         registerArrayCopy(JavaKind.Object, c.oopArraycopy, c.oopAlignedArraycopy, c.oopDisjointArraycopy, c.oopAlignedDisjointArraycopy);
380         registerArrayCopy(JavaKind.Object, c.oopArraycopyUninit, c.oopAlignedArraycopyUninit, c.oopDisjointArraycopyUninit, c.oopAlignedDisjointArraycopyUninit, true);
381 
382         registerCheckcastArraycopyDescriptor(true, c.checkcastArraycopyUninit);
383         registerCheckcastArraycopyDescriptor(false, c.checkcastArraycopy);
384 
<span class="line-modified">385         registerForeignCall(GENERIC_ARRAYCOPY, c.genericArraycopy, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
<span class="line-modified">386         registerForeignCall(UNSAFE_ARRAYCOPY, c.unsafeArraycopy, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
387 
388         if (c.useMultiplyToLenIntrinsic()) {
<span class="line-modified">389             registerForeignCall(MULTIPLY_TO_LEN, c.multiplyToLen, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE,</span>
390                             NamedLocationIdentity.getArrayLocation(JavaKind.Int));
391         }
392 
393         if (c.useSHA1Intrinsics()) {
<span class="line-modified">394             registerForeignCall(SHA_IMPL_COMPRESS, c.sha1ImplCompress, NativeCall, LEAF, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
<span class="line-modified">395             registerForeignCall(SHA_IMPL_COMPRESS_MB, c.sha1ImplCompressMultiBlock, NativeCall, LEAF, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
396         }
397         if (c.useSHA256Intrinsics()) {
<span class="line-modified">398             registerForeignCall(SHA2_IMPL_COMPRESS, c.sha256ImplCompress, NativeCall, LEAF, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
<span class="line-modified">399             registerForeignCall(SHA2_IMPL_COMPRESS_MB, c.sha256ImplCompressMultiBlock, NativeCall, LEAF, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
400         }
401         if (c.useSHA512Intrinsics()) {
<span class="line-modified">402             registerForeignCall(SHA5_IMPL_COMPRESS, c.sha512ImplCompress, NativeCall, LEAF, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
<span class="line-modified">403             registerForeignCall(SHA5_IMPL_COMPRESS_MB, c.sha512ImplCompressMultiBlock, NativeCall, LEAF, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
404         }
405         if (c.useGHASHIntrinsics()) {
<span class="line-modified">406             registerForeignCall(GHASH_PROCESS_BLOCKS, c.ghashProcessBlocks, NativeCall, LEAF, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
<span class="line-added">407         }</span>
<span class="line-added">408         if (c.useBase64Intrinsics()) {</span>
<span class="line-added">409             registerForeignCall(BASE64_ENCODE_BLOCK, c.base64EncodeBlock, NativeCall, LEAF, NOT_REEXECUTABLE, NamedLocationIdentity.any());</span>
410         }
411         if (c.useMulAddIntrinsic()) {
<span class="line-modified">412             registerForeignCall(MUL_ADD, c.mulAdd, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE, NamedLocationIdentity.getArrayLocation(JavaKind.Int));</span>
413         }
414         if (c.useMontgomeryMultiplyIntrinsic()) {
<span class="line-modified">415             registerForeignCall(MONTGOMERY_MULTIPLY, c.montgomeryMultiply, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE,</span>
416                             NamedLocationIdentity.getArrayLocation(JavaKind.Int));
417         }
418         if (c.useMontgomerySquareIntrinsic()) {
<span class="line-modified">419             registerForeignCall(MONTGOMERY_SQUARE, c.montgomerySquare, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE,</span>
420                             NamedLocationIdentity.getArrayLocation(JavaKind.Int));
421         }
422         if (c.useSquareToLenIntrinsic()) {
<span class="line-modified">423             registerForeignCall(SQUARE_TO_LEN, c.squareToLen, NativeCall, LEAF_NO_VZERO, NOT_REEXECUTABLE, NamedLocationIdentity.getArrayLocation(JavaKind.Int));</span>
424         }
425 
426         if (c.useAESIntrinsics) {
427             /*
428              * When the java.ext.dirs property is modified then the crypto classes might not be
429              * found. If that&#39;s the case we ignore the ClassNotFoundException and continue since we
430              * cannot replace a non-existing method anyway.
431              */
432             try {
433                 // These stubs do callee saving
<span class="line-modified">434                 registerForeignCall(ENCRYPT_BLOCK, c.aescryptEncryptBlockStub, NativeCall, LEAF, NOT_REEXECUTABLE,</span>
435                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
<span class="line-modified">436                 registerForeignCall(DECRYPT_BLOCK, c.aescryptDecryptBlockStub, NativeCall, LEAF, NOT_REEXECUTABLE,</span>
437                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
<span class="line-modified">438                 registerForeignCall(DECRYPT_BLOCK_WITH_ORIGINAL_KEY, c.aescryptDecryptBlockStub, NativeCall, LEAF, NOT_REEXECUTABLE,</span>
439                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
440             } catch (GraalError e) {
441                 if (!(e.getCause() instanceof ClassNotFoundException)) {
442                     throw e;
443                 }
444             }
445             try {
446                 // These stubs do callee saving
<span class="line-modified">447                 registerForeignCall(ENCRYPT, c.cipherBlockChainingEncryptAESCryptStub, NativeCall, LEAF, NOT_REEXECUTABLE,</span>
448                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
<span class="line-modified">449                 registerForeignCall(DECRYPT, c.cipherBlockChainingDecryptAESCryptStub, NativeCall, LEAF, NOT_REEXECUTABLE,</span>
450                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
<span class="line-modified">451                 registerForeignCall(DECRYPT_WITH_ORIGINAL_KEY, c.cipherBlockChainingDecryptAESCryptStub, NativeCall, LEAF, NOT_REEXECUTABLE,</span>
452                                 NamedLocationIdentity.getArrayLocation(JavaKind.Byte));
453             } catch (GraalError e) {
454                 if (!(e.getCause() instanceof ClassNotFoundException)) {
455                     throw e;
456                 }
457             }
458         }
459 
460         if (c.useAESCTRIntrinsics) {
461             assert (c.counterModeAESCrypt != 0L);
<span class="line-modified">462             registerForeignCall(COUNTERMODE_IMPL_CRYPT, c.counterModeAESCrypt, NativeCall, LEAF, NOT_REEXECUTABLE,</span>
463                             NamedLocationIdentity.any());
464         }
465 
466         if (c.useVectorizedMismatchIntrinsic) {
467             assert (c.vectorizedMismatch != 0L);
<span class="line-modified">468             registerForeignCall(VECTORIZED_MISMATCHED, c.vectorizedMismatch, NativeCall, LEAF, NOT_REEXECUTABLE,</span>
469                             NamedLocationIdentity.any());
470 
471         }
472     }
473 
474     public HotSpotForeignCallLinkage getForeignCall(ForeignCallDescriptor descriptor) {
475         assert foreignCalls != null : descriptor;
476         return foreignCalls.get(descriptor);
477     }
478 
479     @SuppressWarnings(&quot;unused&quot;)
480     protected void registerMathStubs(GraalHotSpotVMConfig hotSpotVMConfig, HotSpotProviders providers, OptionValues options) {
<span class="line-modified">481         registerForeignCall(SIN.foreignCallDescriptor, hotSpotVMConfig.arithmeticSinAddress, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">482         registerForeignCall(COS.foreignCallDescriptor, hotSpotVMConfig.arithmeticCosAddress, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">483         registerForeignCall(TAN.foreignCallDescriptor, hotSpotVMConfig.arithmeticTanAddress, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">484         registerForeignCall(EXP.foreignCallDescriptor, hotSpotVMConfig.arithmeticExpAddress, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">485         registerForeignCall(LOG.foreignCallDescriptor, hotSpotVMConfig.arithmeticLogAddress, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">486         registerForeignCall(LOG10.foreignCallDescriptor, hotSpotVMConfig.arithmeticLog10Address, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
<span class="line-modified">487         registerForeignCall(POW.foreignCallDescriptor, hotSpotVMConfig.arithmeticPowAddress, NativeCall, LEAF, REEXECUTABLE, NO_LOCATIONS);</span>
488     }
489 }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotGraphBuilderPlugins.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotInvocationPlugins.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
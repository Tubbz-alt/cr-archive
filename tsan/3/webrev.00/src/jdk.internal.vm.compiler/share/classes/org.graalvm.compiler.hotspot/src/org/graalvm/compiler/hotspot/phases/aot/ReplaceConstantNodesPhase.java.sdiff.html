<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/aot/ReplaceConstantNodesPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EliminateRedundantInitializationPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../profiling/FinalizeProfileNodesPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/aot/ReplaceConstantNodesPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.phases.aot;
 26 
 27 import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.strictlyDominates;
 28 import static org.graalvm.compiler.hotspot.nodes.aot.LoadMethodCountersNode.getLoadMethodCountersNodes;
 29 import static org.graalvm.compiler.nodes.ConstantNode.getConstantNodes;
 30 
 31 import java.util.HashSet;
 32 import java.util.List;
 33 
 34 import jdk.internal.vm.compiler.collections.EconomicMap;

 35 import org.graalvm.compiler.core.common.cfg.BlockMap;
 36 import org.graalvm.compiler.core.common.type.ObjectStamp;
 37 import org.graalvm.compiler.core.common.type.Stamp;
 38 import org.graalvm.compiler.core.common.type.StampFactory;
 39 import org.graalvm.compiler.debug.GraalError;
 40 import org.graalvm.compiler.graph.Node;
 41 import org.graalvm.compiler.graph.NodeMap;
 42 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 43 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 44 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyFixedNode;
 45 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyNode;
 46 import org.graalvm.compiler.hotspot.nodes.aot.LoadMethodCountersNode;
 47 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 48 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 49 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
 50 import org.graalvm.compiler.nodes.AbstractBeginNode;
 51 import org.graalvm.compiler.nodes.AbstractMergeNode;
 52 import org.graalvm.compiler.nodes.ConstantNode;
 53 import org.graalvm.compiler.nodes.FixedNode;
 54 import org.graalvm.compiler.nodes.FixedWithNextNode;
 55 import org.graalvm.compiler.nodes.FrameState;
 56 import org.graalvm.compiler.nodes.LoopBeginNode;
 57 import org.graalvm.compiler.nodes.LoopExitNode;
 58 import org.graalvm.compiler.nodes.StateSplit;
 59 import org.graalvm.compiler.nodes.StructuredGraph;
 60 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 61 import org.graalvm.compiler.nodes.ValueNode;
 62 import org.graalvm.compiler.nodes.calc.FloatingNode;
 63 import org.graalvm.compiler.nodes.cfg.Block;

 64 import org.graalvm.compiler.phases.BasePhase;
 65 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator;
 66 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure;
 67 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 68 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
<span class="line-removed"> 69 import org.graalvm.compiler.phases.tiers.PhaseContext;</span>
 70 
 71 import jdk.vm.ci.code.BytecodeFrame;
 72 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 73 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 74 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
 75 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 76 import jdk.vm.ci.meta.Constant;
 77 import jdk.vm.ci.meta.ConstantReflectionProvider;
 78 import jdk.vm.ci.meta.MetaAccessProvider;
 79 import jdk.vm.ci.meta.ResolvedJavaType;
 80 
<span class="line-modified"> 81 public class ReplaceConstantNodesPhase extends BasePhase&lt;PhaseContext&gt; {</span>
 82 
 83     private final boolean verifyFingerprints;
 84 
 85     static Class&lt;?&gt; characterCacheClass = Character.class.getDeclaredClasses()[0];
 86     static Class&lt;?&gt; byteCacheClass = Byte.class.getDeclaredClasses()[0];
 87     static Class&lt;?&gt; shortCacheClass = Short.class.getDeclaredClasses()[0];
 88     static Class&lt;?&gt; integerCacheClass = Integer.class.getDeclaredClasses()[0];
 89     static Class&lt;?&gt; longCacheClass = Long.class.getDeclaredClasses()[0];
 90 
 91     static class ClassInfo {
 92 
 93         private ResolvedJavaType stringType;
 94         private final HashSet&lt;ResolvedJavaType&gt; builtIns = new HashSet&lt;&gt;();
 95 
 96         ClassInfo(MetaAccessProvider metaAccessProvider) {
 97             builtIns.add(metaAccessProvider.lookupJavaType(Boolean.class));
 98 
 99             assert &quot;java.lang.Character$CharacterCache&quot;.equals(characterCacheClass.getName());
100             builtIns.add(metaAccessProvider.lookupJavaType(characterCacheClass));
101 
</pre>
<hr />
<pre>
301             return reachingStates.get(n);
302         }
303 
304         public void addState(Node n, FrameState s) {
305             reachingStates.setAndGrow(n, s);
306         }
307     }
308 
309     /**
310      * Try to find dominating node doing the resolution that can be reused.
311      *
312      * @param graph
313      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
314      *            resolution.
315      */
316     private static void tryToReplaceWithExisting(StructuredGraph graph, ConstantNode node) {
317         ScheduleResult schedule = graph.getLastSchedule();
318         NodeMap&lt;Block&gt; nodeToBlock = schedule.getNodeToBlockMap();
319         BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes = schedule.getBlockToNodesMap();
320 
<span class="line-modified">321         EconomicMap&lt;Block, Node&gt; blockToExisting = EconomicMap.create();</span>
322         for (Node n : node.usages().filter(n -&gt; isReplacementNode(n))) {
323             blockToExisting.put(nodeToBlock.get(n), n);
324         }
325         for (Node use : node.usages().filter(n -&gt; !isReplacementNode(n)).snapshot()) {
326             boolean replaced = false;
327             Block b = nodeToBlock.get(use);
328             Node e = blockToExisting.get(b);
329             if (e != null) {
330                 // There is an initialization or resolution in the same block as the use, look if
331                 // the use is scheduled after it.
332                 for (Node n : blockToNodes.get(b)) {
333                     if (n.equals(use)) {
334                         // Usage is before initialization, can&#39;t use it
335                         break;
336                     }
337                     if (n.equals(e)) {
338                         use.replaceFirstInput(node, e);
339                         replaced = true;
340                         break;
341                     }
</pre>
<hr />
<pre>
431         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) constant.getType();
432         if (type.equals(classInfo.stringType)) {
433             assert !constant.isCompressed() : &quot;No support for replacing compressed oop constants&quot;;
434             FixedWithNextNode replacement = graph.add(new ResolveConstantNode(node));
435             insertReplacement(graph, stateMapper, node, replacement);
436             node.replaceAtUsages(replacement, n -&gt; !(n instanceof ResolveConstantNode));
437         } else {
438             throw new GraalError(&quot;Unsupported object constant type: &quot; + type);
439         }
440     }
441 
442     /**
443      * Replace {@link LoadMethodCountersNode} with indirect load
444      * {@link ResolveMethodAndLoadCountersNode}, expose a klass constant of the holder.
445      *
446      * @param graph
447      * @param stateMapper
448      * @param node
449      * @param context
450      */
<span class="line-modified">451     private static void handleLoadMethodCounters(StructuredGraph graph, FrameStateMapperClosure stateMapper, LoadMethodCountersNode node, PhaseContext context) {</span>
452         ResolvedJavaType type = node.getMethod().getDeclaringClass();
453         Stamp hubStamp = context.getStampProvider().createHubStamp((ObjectStamp) StampFactory.objectNonNull());
454         ConstantReflectionProvider constantReflection = context.getConstantReflection();
455         ConstantNode klassHint = ConstantNode.forConstant(hubStamp, constantReflection.asObjectHub(type), context.getMetaAccess(), graph);
456         FixedWithNextNode replacement = graph.add(new ResolveMethodAndLoadCountersNode(node.getMethod(), klassHint));
457         insertReplacement(graph, stateMapper, node, replacement);
458         node.replaceAtUsages(replacement, n -&gt; !(n instanceof ResolveMethodAndLoadCountersNode));
459     }
460 
461     /**
462      * Replace {@link LoadMethodCountersNode} with {@link ResolveMethodAndLoadCountersNode}, expose
463      * klass constants.
464      *
465      * @param graph
466      * @param stateMapper
467      * @param context
468      */
<span class="line-modified">469     private static void replaceLoadMethodCounters(StructuredGraph graph, FrameStateMapperClosure stateMapper, PhaseContext context) {</span>
470         new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);
471 
472         for (LoadMethodCountersNode node : getLoadMethodCountersNodes(graph)) {
473             if (anyUsagesNeedReplacement(node)) {
474                 handleLoadMethodCounters(graph, stateMapper, node, context);
475             }
476         }
477     }
478 
479     /**
480      * Replace object and klass constants with resolution nodes or reuse preceding initializations.
481      *
482      * @param graph
483      * @param stateMapper
484      */
485     private void replaceKlassesAndObjects(StructuredGraph graph, FrameStateMapperClosure stateMapper, ClassInfo classInfo) {
486         new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);
487 
488         for (ConstantNode node : getConstantNodes(graph)) {
489             Constant constant = node.asConstant();
490             if (constant instanceof HotSpotMetaspaceConstant &amp;&amp; anyUsagesNeedReplacement(node)) {
491                 handleHotSpotMetaspaceConstant(graph, stateMapper, node, classInfo);
492             } else if (constant instanceof HotSpotObjectConstant &amp;&amp; anyUsagesNeedReplacement(node)) {
493                 handleHotSpotObjectConstant(graph, stateMapper, node, classInfo);
494             }
495         }
496     }
497 
498     @Override
<span class="line-modified">499     protected void run(StructuredGraph graph, PhaseContext context) {</span>
500         FrameStateMapperClosure stateMapper = new FrameStateMapperClosure(graph);
501         ReentrantNodeIterator.apply(stateMapper, graph.start(), null);
502 
503         // Replace LoadMethodCountersNode with ResolveMethodAndLoadCountersNode, expose klass
504         // constants.
505         replaceLoadMethodCounters(graph, stateMapper, context);
506 
507         // Replace object and klass constants (including the ones added in the previous pass) with
508         // resolution nodes.
509         replaceKlassesAndObjects(graph, stateMapper, new ClassInfo(context.getMetaAccess()));
510     }
511 
512     @Override
513     public boolean checkContract() {
514         return false;
515     }
516 
517     public ReplaceConstantNodesPhase() {
518         this(true);
519     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.phases.aot;
 26 
 27 import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.strictlyDominates;
 28 import static org.graalvm.compiler.hotspot.nodes.aot.LoadMethodCountersNode.getLoadMethodCountersNodes;
 29 import static org.graalvm.compiler.nodes.ConstantNode.getConstantNodes;
 30 
 31 import java.util.HashSet;
 32 import java.util.List;
 33 
 34 import jdk.internal.vm.compiler.collections.EconomicMap;
<span class="line-added"> 35 import jdk.internal.vm.compiler.collections.Equivalence;</span>
 36 import org.graalvm.compiler.core.common.cfg.BlockMap;
 37 import org.graalvm.compiler.core.common.type.ObjectStamp;
 38 import org.graalvm.compiler.core.common.type.Stamp;
 39 import org.graalvm.compiler.core.common.type.StampFactory;
 40 import org.graalvm.compiler.debug.GraalError;
 41 import org.graalvm.compiler.graph.Node;
 42 import org.graalvm.compiler.graph.NodeMap;
 43 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 44 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 45 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyFixedNode;
 46 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyNode;
 47 import org.graalvm.compiler.hotspot.nodes.aot.LoadMethodCountersNode;
 48 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 49 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 50 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
 51 import org.graalvm.compiler.nodes.AbstractBeginNode;
 52 import org.graalvm.compiler.nodes.AbstractMergeNode;
 53 import org.graalvm.compiler.nodes.ConstantNode;
 54 import org.graalvm.compiler.nodes.FixedNode;
 55 import org.graalvm.compiler.nodes.FixedWithNextNode;
 56 import org.graalvm.compiler.nodes.FrameState;
 57 import org.graalvm.compiler.nodes.LoopBeginNode;
 58 import org.graalvm.compiler.nodes.LoopExitNode;
 59 import org.graalvm.compiler.nodes.StateSplit;
 60 import org.graalvm.compiler.nodes.StructuredGraph;
 61 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
 62 import org.graalvm.compiler.nodes.ValueNode;
 63 import org.graalvm.compiler.nodes.calc.FloatingNode;
 64 import org.graalvm.compiler.nodes.cfg.Block;
<span class="line-added"> 65 import org.graalvm.compiler.nodes.spi.CoreProviders;</span>
 66 import org.graalvm.compiler.phases.BasePhase;
 67 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator;
 68 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure;
 69 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 70 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;

 71 
 72 import jdk.vm.ci.code.BytecodeFrame;
 73 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 74 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 75 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
 76 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 77 import jdk.vm.ci.meta.Constant;
 78 import jdk.vm.ci.meta.ConstantReflectionProvider;
 79 import jdk.vm.ci.meta.MetaAccessProvider;
 80 import jdk.vm.ci.meta.ResolvedJavaType;
 81 
<span class="line-modified"> 82 public class ReplaceConstantNodesPhase extends BasePhase&lt;CoreProviders&gt; {</span>
 83 
 84     private final boolean verifyFingerprints;
 85 
 86     static Class&lt;?&gt; characterCacheClass = Character.class.getDeclaredClasses()[0];
 87     static Class&lt;?&gt; byteCacheClass = Byte.class.getDeclaredClasses()[0];
 88     static Class&lt;?&gt; shortCacheClass = Short.class.getDeclaredClasses()[0];
 89     static Class&lt;?&gt; integerCacheClass = Integer.class.getDeclaredClasses()[0];
 90     static Class&lt;?&gt; longCacheClass = Long.class.getDeclaredClasses()[0];
 91 
 92     static class ClassInfo {
 93 
 94         private ResolvedJavaType stringType;
 95         private final HashSet&lt;ResolvedJavaType&gt; builtIns = new HashSet&lt;&gt;();
 96 
 97         ClassInfo(MetaAccessProvider metaAccessProvider) {
 98             builtIns.add(metaAccessProvider.lookupJavaType(Boolean.class));
 99 
100             assert &quot;java.lang.Character$CharacterCache&quot;.equals(characterCacheClass.getName());
101             builtIns.add(metaAccessProvider.lookupJavaType(characterCacheClass));
102 
</pre>
<hr />
<pre>
302             return reachingStates.get(n);
303         }
304 
305         public void addState(Node n, FrameState s) {
306             reachingStates.setAndGrow(n, s);
307         }
308     }
309 
310     /**
311      * Try to find dominating node doing the resolution that can be reused.
312      *
313      * @param graph
314      * @param node {@link ConstantNode} containing a {@link HotSpotResolvedJavaType} that needs
315      *            resolution.
316      */
317     private static void tryToReplaceWithExisting(StructuredGraph graph, ConstantNode node) {
318         ScheduleResult schedule = graph.getLastSchedule();
319         NodeMap&lt;Block&gt; nodeToBlock = schedule.getNodeToBlockMap();
320         BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes = schedule.getBlockToNodesMap();
321 
<span class="line-modified">322         EconomicMap&lt;Block, Node&gt; blockToExisting = EconomicMap.create(Equivalence.IDENTITY);</span>
323         for (Node n : node.usages().filter(n -&gt; isReplacementNode(n))) {
324             blockToExisting.put(nodeToBlock.get(n), n);
325         }
326         for (Node use : node.usages().filter(n -&gt; !isReplacementNode(n)).snapshot()) {
327             boolean replaced = false;
328             Block b = nodeToBlock.get(use);
329             Node e = blockToExisting.get(b);
330             if (e != null) {
331                 // There is an initialization or resolution in the same block as the use, look if
332                 // the use is scheduled after it.
333                 for (Node n : blockToNodes.get(b)) {
334                     if (n.equals(use)) {
335                         // Usage is before initialization, can&#39;t use it
336                         break;
337                     }
338                     if (n.equals(e)) {
339                         use.replaceFirstInput(node, e);
340                         replaced = true;
341                         break;
342                     }
</pre>
<hr />
<pre>
432         HotSpotResolvedJavaType type = (HotSpotResolvedJavaType) constant.getType();
433         if (type.equals(classInfo.stringType)) {
434             assert !constant.isCompressed() : &quot;No support for replacing compressed oop constants&quot;;
435             FixedWithNextNode replacement = graph.add(new ResolveConstantNode(node));
436             insertReplacement(graph, stateMapper, node, replacement);
437             node.replaceAtUsages(replacement, n -&gt; !(n instanceof ResolveConstantNode));
438         } else {
439             throw new GraalError(&quot;Unsupported object constant type: &quot; + type);
440         }
441     }
442 
443     /**
444      * Replace {@link LoadMethodCountersNode} with indirect load
445      * {@link ResolveMethodAndLoadCountersNode}, expose a klass constant of the holder.
446      *
447      * @param graph
448      * @param stateMapper
449      * @param node
450      * @param context
451      */
<span class="line-modified">452     private static void handleLoadMethodCounters(StructuredGraph graph, FrameStateMapperClosure stateMapper, LoadMethodCountersNode node, CoreProviders context) {</span>
453         ResolvedJavaType type = node.getMethod().getDeclaringClass();
454         Stamp hubStamp = context.getStampProvider().createHubStamp((ObjectStamp) StampFactory.objectNonNull());
455         ConstantReflectionProvider constantReflection = context.getConstantReflection();
456         ConstantNode klassHint = ConstantNode.forConstant(hubStamp, constantReflection.asObjectHub(type), context.getMetaAccess(), graph);
457         FixedWithNextNode replacement = graph.add(new ResolveMethodAndLoadCountersNode(node.getMethod(), klassHint));
458         insertReplacement(graph, stateMapper, node, replacement);
459         node.replaceAtUsages(replacement, n -&gt; !(n instanceof ResolveMethodAndLoadCountersNode));
460     }
461 
462     /**
463      * Replace {@link LoadMethodCountersNode} with {@link ResolveMethodAndLoadCountersNode}, expose
464      * klass constants.
465      *
466      * @param graph
467      * @param stateMapper
468      * @param context
469      */
<span class="line-modified">470     private static void replaceLoadMethodCounters(StructuredGraph graph, FrameStateMapperClosure stateMapper, CoreProviders context) {</span>
471         new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);
472 
473         for (LoadMethodCountersNode node : getLoadMethodCountersNodes(graph)) {
474             if (anyUsagesNeedReplacement(node)) {
475                 handleLoadMethodCounters(graph, stateMapper, node, context);
476             }
477         }
478     }
479 
480     /**
481      * Replace object and klass constants with resolution nodes or reuse preceding initializations.
482      *
483      * @param graph
484      * @param stateMapper
485      */
486     private void replaceKlassesAndObjects(StructuredGraph graph, FrameStateMapperClosure stateMapper, ClassInfo classInfo) {
487         new SchedulePhase(SchedulingStrategy.LATEST_OUT_OF_LOOPS, true).apply(graph, false);
488 
489         for (ConstantNode node : getConstantNodes(graph)) {
490             Constant constant = node.asConstant();
491             if (constant instanceof HotSpotMetaspaceConstant &amp;&amp; anyUsagesNeedReplacement(node)) {
492                 handleHotSpotMetaspaceConstant(graph, stateMapper, node, classInfo);
493             } else if (constant instanceof HotSpotObjectConstant &amp;&amp; anyUsagesNeedReplacement(node)) {
494                 handleHotSpotObjectConstant(graph, stateMapper, node, classInfo);
495             }
496         }
497     }
498 
499     @Override
<span class="line-modified">500     protected void run(StructuredGraph graph, CoreProviders context) {</span>
501         FrameStateMapperClosure stateMapper = new FrameStateMapperClosure(graph);
502         ReentrantNodeIterator.apply(stateMapper, graph.start(), null);
503 
504         // Replace LoadMethodCountersNode with ResolveMethodAndLoadCountersNode, expose klass
505         // constants.
506         replaceLoadMethodCounters(graph, stateMapper, context);
507 
508         // Replace object and klass constants (including the ones added in the previous pass) with
509         // resolution nodes.
510         replaceKlassesAndObjects(graph, stateMapper, new ClassInfo(context.getMetaAccess()));
511     }
512 
513     @Override
514     public boolean checkContract() {
515         return false;
516     }
517 
518     public ReplaceConstantNodesPhase() {
519         this(true);
520     }
</pre>
</td>
</tr>
</table>
<center><a href="EliminateRedundantInitializationPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../profiling/FinalizeProfileNodesPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
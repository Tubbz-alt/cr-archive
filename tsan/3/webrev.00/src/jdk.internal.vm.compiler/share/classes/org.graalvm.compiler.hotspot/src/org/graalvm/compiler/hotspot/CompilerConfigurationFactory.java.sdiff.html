<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilerConfigurationFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilationWatchDog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraalHotSpotVMConfig.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilerConfigurationFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static jdk.vm.ci.common.InitTimer.timer;
 28 
<span class="line-removed"> 29 import java.net.URL;</span>
 30 import java.util.ArrayList;
 31 import java.util.Collection;
 32 import java.util.Collections;
 33 import java.util.List;
 34 import java.util.stream.Collectors;
 35 
 36 import jdk.internal.vm.compiler.collections.EconomicMap;
 37 import org.graalvm.compiler.core.common.SuppressFBWarnings;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.debug.TTY;
 40 import org.graalvm.compiler.lir.phases.LIRPhase;
 41 import org.graalvm.compiler.lir.phases.LIRPhaseSuite;
 42 import org.graalvm.compiler.options.EnumOptionKey;
 43 import org.graalvm.compiler.options.Option;
 44 import org.graalvm.compiler.options.OptionKey;

 45 import org.graalvm.compiler.options.OptionType;
 46 import org.graalvm.compiler.options.OptionValues;
 47 import org.graalvm.compiler.phases.BasePhase;
 48 import org.graalvm.compiler.phases.PhaseSuite;
 49 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
 50 import org.graalvm.compiler.serviceprovider.GraalServices;
 51 
 52 import jdk.vm.ci.code.Architecture;
 53 import jdk.vm.ci.common.InitTimer;

 54 
 55 /**
<span class="line-modified"> 56  * A factory that creates the {@link CompilerConfiguration} the Graal compiler will use. Each</span>
<span class="line-modified"> 57  * factory must have a unique {@link #name} and {@link #autoSelectionPriority}. The latter imposes a</span>
<span class="line-modified"> 58  * total ordering between factories for the purpose of auto-selecting the factory to use.</span>
 59  */
 60 public abstract class CompilerConfigurationFactory implements Comparable&lt;CompilerConfigurationFactory&gt; {
 61 
 62     enum ShowConfigurationLevel {
 63         none,
 64         info,
 65         verbose
 66     }
 67 
 68     static class Options {
 69         // @formatter:off
<span class="line-modified"> 70         @Option(help = &quot;Names the Graal compiler configuration to use. If omitted, the compiler configuration &quot; +</span>
 71                        &quot;with the highest auto-selection priority is used. To see the set of available configurations, &quot; +
<span class="line-modified"> 72                        &quot;supply the value &#39;help&#39; to this option.&quot;, type = OptionType.Expert)</span>
 73         public static final OptionKey&lt;String&gt; CompilerConfiguration = new OptionKey&lt;&gt;(null);
<span class="line-modified"> 74         @Option(help = &quot;Writes to the VM log information about the Graal compiler configuration selected.&quot;, type = OptionType.User)</span>
 75         public static final OptionKey&lt;ShowConfigurationLevel&gt; ShowConfiguration = new EnumOptionKey&lt;&gt;(ShowConfigurationLevel.none);
 76         // @formatter:on
 77     }
 78 
 79     /**
 80      * The name of this factory. This must be unique across all factory instances and is used when
 81      * selecting a factory based on the value of {@link Options#CompilerConfiguration}.
 82      */
 83     private final String name;
 84 
 85     /**
 86      * The priority of this factory. This must be unique across all factory instances and is used
 87      * when selecting a factory when {@link Options#CompilerConfiguration} is omitted
 88      */
 89     private final int autoSelectionPriority;
 90 
 91     protected CompilerConfigurationFactory(String name, int autoSelectionPriority) {
 92         this.name = name;
 93         this.autoSelectionPriority = autoSelectionPriority;
 94     }
</pre>
<hr />
<pre>
178         }
179         Collections.sort(candidates);
180         return candidates;
181     }
182 
183     /**
184      * Selects and instantiates a {@link CompilerConfigurationFactory}. The selection algorithm is
185      * as follows: if {@code name} is non-null, then select the factory with the same name else if
186      * {@code Options.CompilerConfiguration.getValue()} is non-null then select the factory whose
187      * name matches the value else select the factory with the highest
188      * {@link #autoSelectionPriority} value.
189      *
190      * @param name the name of the compiler configuration to select (optional)
191      */
192     @SuppressWarnings(&quot;try&quot;)
193     public static CompilerConfigurationFactory selectFactory(String name, OptionValues options) {
194         CompilerConfigurationFactory factory = null;
195         try (InitTimer t = timer(&quot;CompilerConfigurationFactory.selectFactory&quot;)) {
196             String value = name == null ? Options.CompilerConfiguration.getValue(options) : name;
197             if (&quot;help&quot;.equals(value)) {
<span class="line-modified">198                 System.out.println(&quot;The available Graal compiler configurations are:&quot;);</span>
199                 for (CompilerConfigurationFactory candidate : getAllCandidates()) {
200                     System.out.println(&quot;    &quot; + candidate.name);
201                 }
<span class="line-modified">202                 System.exit(0);</span>
203             } else if (value != null) {
204                 for (CompilerConfigurationFactory candidate : GraalServices.load(CompilerConfigurationFactory.class)) {
205                     if (candidate.name.equals(value)) {
206                         factory = candidate;
207                         break;
208                     }
209                 }
210                 if (factory == null) {
<span class="line-modified">211                     throw new GraalError(&quot;Graal compiler configuration &#39;%s&#39; not found. Available configurations are: %s&quot;, value,</span>
212                                     getAllCandidates().stream().map(c -&gt; c.name).collect(Collectors.joining(&quot;, &quot;)));
213                 }
214             } else {
215                 List&lt;CompilerConfigurationFactory&gt; candidates = getAllCandidates();
216                 if (candidates.isEmpty()) {
217                     throw new GraalError(&quot;No %s providers found&quot;, CompilerConfigurationFactory.class.getName());
218                 }
219                 factory = candidates.get(0);
220             }
221         }


222         ShowConfigurationLevel level = Options.ShowConfiguration.getValue(options);
223         if (level != ShowConfigurationLevel.none) {
224             switch (level) {
225                 case info: {
226                     printConfigInfo(factory);
227                     break;
228                 }
229                 case verbose: {
230                     printConfigInfo(factory);
231                     CompilerConfiguration config = factory.createCompilerConfiguration();
232                     TTY.println(&quot;High tier: &quot; + phaseNames(config.createHighTier(options)));
233                     TTY.println(&quot;Mid tier: &quot; + phaseNames(config.createMidTier(options)));
234                     TTY.println(&quot;Low tier: &quot; + phaseNames(config.createLowTier(options)));
235                     TTY.println(&quot;Pre regalloc stage: &quot; + phaseNames(config.createPreAllocationOptimizationStage(options)));
236                     TTY.println(&quot;Regalloc stage: &quot; + phaseNames(config.createAllocationStage(options)));
237                     TTY.println(&quot;Post regalloc stage: &quot; + phaseNames(config.createPostAllocationOptimizationStage(options)));
238                     config.createAllocationStage(options);
239                     break;
240                 }
241             }
242         }
243         return factory;
244     }
245 
246     private static void printConfigInfo(CompilerConfigurationFactory factory) {
<span class="line-modified">247         URL location = factory.getClass().getResource(factory.getClass().getSimpleName() + &quot;.class&quot;);</span>
<span class="line-modified">248         TTY.printf(&quot;Using Graal compiler configuration &#39;%s&#39; provided by %s loaded from %s%n&quot;, factory.name, factory.getClass().getName(), location);</span>
249     }
250 
251     private static &lt;C&gt; List&lt;String&gt; phaseNames(PhaseSuite&lt;C&gt; suite) {
252         Collection&lt;BasePhase&lt;? super C&gt;&gt; phases = suite.getPhases();
253         List&lt;String&gt; res = new ArrayList&lt;&gt;(phases.size());
254         for (BasePhase&lt;?&gt; phase : phases) {
255             res.add(phase.contractorName());
256         }
257         Collections.sort(res);
258         return res;
259     }
260 
261     private static &lt;C&gt; List&lt;String&gt; phaseNames(LIRPhaseSuite&lt;C&gt; suite) {
262         List&lt;LIRPhase&lt;C&gt;&gt; phases = suite.getPhases();
263         List&lt;String&gt; res = new ArrayList&lt;&gt;(phases.size());
264         for (LIRPhase&lt;?&gt; phase : phases) {
265             res.add(phase.getClass().getName());
266         }
267         Collections.sort(res);
268         return res;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static jdk.vm.ci.common.InitTimer.timer;
 28 

 29 import java.util.ArrayList;
 30 import java.util.Collection;
 31 import java.util.Collections;
 32 import java.util.List;
 33 import java.util.stream.Collectors;
 34 
 35 import jdk.internal.vm.compiler.collections.EconomicMap;
 36 import org.graalvm.compiler.core.common.SuppressFBWarnings;
 37 import org.graalvm.compiler.debug.GraalError;
 38 import org.graalvm.compiler.debug.TTY;
 39 import org.graalvm.compiler.lir.phases.LIRPhase;
 40 import org.graalvm.compiler.lir.phases.LIRPhaseSuite;
 41 import org.graalvm.compiler.options.EnumOptionKey;
 42 import org.graalvm.compiler.options.Option;
 43 import org.graalvm.compiler.options.OptionKey;
<span class="line-added"> 44 import org.graalvm.compiler.options.OptionStability;</span>
 45 import org.graalvm.compiler.options.OptionType;
 46 import org.graalvm.compiler.options.OptionValues;
 47 import org.graalvm.compiler.phases.BasePhase;
 48 import org.graalvm.compiler.phases.PhaseSuite;
 49 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
 50 import org.graalvm.compiler.serviceprovider.GraalServices;
 51 
 52 import jdk.vm.ci.code.Architecture;
 53 import jdk.vm.ci.common.InitTimer;
<span class="line-added"> 54 import jdk.vm.ci.services.Services;</span>
 55 
 56 /**
<span class="line-modified"> 57  * A factory that creates the {@link CompilerConfiguration} the compiler will use. Each factory must</span>
<span class="line-modified"> 58  * have a unique {@link #name} and {@link #autoSelectionPriority}. The latter imposes a total</span>
<span class="line-modified"> 59  * ordering between factories for the purpose of auto-selecting the factory to use.</span>
 60  */
 61 public abstract class CompilerConfigurationFactory implements Comparable&lt;CompilerConfigurationFactory&gt; {
 62 
 63     enum ShowConfigurationLevel {
 64         none,
 65         info,
 66         verbose
 67     }
 68 
 69     static class Options {
 70         // @formatter:off
<span class="line-modified"> 71         @Option(help = &quot;Names the compiler configuration to use. If omitted, the compiler configuration &quot; +</span>
 72                        &quot;with the highest auto-selection priority is used. To see the set of available configurations, &quot; +
<span class="line-modified"> 73                        &quot;supply the value &#39;help&#39; to this option.&quot;, type = OptionType.Expert, stability = OptionStability.STABLE)</span>
 74         public static final OptionKey&lt;String&gt; CompilerConfiguration = new OptionKey&lt;&gt;(null);
<span class="line-modified"> 75         @Option(help = &quot;Writes to the VM log information about the compiler configuration selected.&quot;, type = OptionType.User, stability = OptionStability.STABLE)</span>
 76         public static final OptionKey&lt;ShowConfigurationLevel&gt; ShowConfiguration = new EnumOptionKey&lt;&gt;(ShowConfigurationLevel.none);
 77         // @formatter:on
 78     }
 79 
 80     /**
 81      * The name of this factory. This must be unique across all factory instances and is used when
 82      * selecting a factory based on the value of {@link Options#CompilerConfiguration}.
 83      */
 84     private final String name;
 85 
 86     /**
 87      * The priority of this factory. This must be unique across all factory instances and is used
 88      * when selecting a factory when {@link Options#CompilerConfiguration} is omitted
 89      */
 90     private final int autoSelectionPriority;
 91 
 92     protected CompilerConfigurationFactory(String name, int autoSelectionPriority) {
 93         this.name = name;
 94         this.autoSelectionPriority = autoSelectionPriority;
 95     }
</pre>
<hr />
<pre>
179         }
180         Collections.sort(candidates);
181         return candidates;
182     }
183 
184     /**
185      * Selects and instantiates a {@link CompilerConfigurationFactory}. The selection algorithm is
186      * as follows: if {@code name} is non-null, then select the factory with the same name else if
187      * {@code Options.CompilerConfiguration.getValue()} is non-null then select the factory whose
188      * name matches the value else select the factory with the highest
189      * {@link #autoSelectionPriority} value.
190      *
191      * @param name the name of the compiler configuration to select (optional)
192      */
193     @SuppressWarnings(&quot;try&quot;)
194     public static CompilerConfigurationFactory selectFactory(String name, OptionValues options) {
195         CompilerConfigurationFactory factory = null;
196         try (InitTimer t = timer(&quot;CompilerConfigurationFactory.selectFactory&quot;)) {
197             String value = name == null ? Options.CompilerConfiguration.getValue(options) : name;
198             if (&quot;help&quot;.equals(value)) {
<span class="line-modified">199                 System.out.println(&quot;The available compiler configurations are:&quot;);</span>
200                 for (CompilerConfigurationFactory candidate : getAllCandidates()) {
201                     System.out.println(&quot;    &quot; + candidate.name);
202                 }
<span class="line-modified">203                 HotSpotGraalServices.exit(0);</span>
204             } else if (value != null) {
205                 for (CompilerConfigurationFactory candidate : GraalServices.load(CompilerConfigurationFactory.class)) {
206                     if (candidate.name.equals(value)) {
207                         factory = candidate;
208                         break;
209                     }
210                 }
211                 if (factory == null) {
<span class="line-modified">212                     throw new GraalError(&quot;Compiler configuration &#39;%s&#39; not found. Available configurations are: %s&quot;, value,</span>
213                                     getAllCandidates().stream().map(c -&gt; c.name).collect(Collectors.joining(&quot;, &quot;)));
214                 }
215             } else {
216                 List&lt;CompilerConfigurationFactory&gt; candidates = getAllCandidates();
217                 if (candidates.isEmpty()) {
218                     throw new GraalError(&quot;No %s providers found&quot;, CompilerConfigurationFactory.class.getName());
219                 }
220                 factory = candidates.get(0);
221             }
222         }
<span class="line-added">223         assert factory != null;</span>
<span class="line-added">224 </span>
225         ShowConfigurationLevel level = Options.ShowConfiguration.getValue(options);
226         if (level != ShowConfigurationLevel.none) {
227             switch (level) {
228                 case info: {
229                     printConfigInfo(factory);
230                     break;
231                 }
232                 case verbose: {
233                     printConfigInfo(factory);
234                     CompilerConfiguration config = factory.createCompilerConfiguration();
235                     TTY.println(&quot;High tier: &quot; + phaseNames(config.createHighTier(options)));
236                     TTY.println(&quot;Mid tier: &quot; + phaseNames(config.createMidTier(options)));
237                     TTY.println(&quot;Low tier: &quot; + phaseNames(config.createLowTier(options)));
238                     TTY.println(&quot;Pre regalloc stage: &quot; + phaseNames(config.createPreAllocationOptimizationStage(options)));
239                     TTY.println(&quot;Regalloc stage: &quot; + phaseNames(config.createAllocationStage(options)));
240                     TTY.println(&quot;Post regalloc stage: &quot; + phaseNames(config.createPostAllocationOptimizationStage(options)));
241                     config.createAllocationStage(options);
242                     break;
243                 }
244             }
245         }
246         return factory;
247     }
248 
249     private static void printConfigInfo(CompilerConfigurationFactory factory) {
<span class="line-modified">250         Object location = Services.IS_IN_NATIVE_IMAGE ? &quot;JVMCI native library&quot; : factory.getClass().getResource(factory.getClass().getSimpleName() + &quot;.class&quot;);</span>
<span class="line-modified">251         TTY.printf(&quot;Using compiler configuration &#39;%s&#39; provided by %s loaded from %s%n&quot;, factory.name, factory.getClass().getName(), location);</span>
252     }
253 
254     private static &lt;C&gt; List&lt;String&gt; phaseNames(PhaseSuite&lt;C&gt; suite) {
255         Collection&lt;BasePhase&lt;? super C&gt;&gt; phases = suite.getPhases();
256         List&lt;String&gt; res = new ArrayList&lt;&gt;(phases.size());
257         for (BasePhase&lt;?&gt; phase : phases) {
258             res.add(phase.contractorName());
259         }
260         Collections.sort(res);
261         return res;
262     }
263 
264     private static &lt;C&gt; List&lt;String&gt; phaseNames(LIRPhaseSuite&lt;C&gt; suite) {
265         List&lt;LIRPhase&lt;C&gt;&gt; phases = suite.getPhases();
266         List&lt;String&gt; res = new ArrayList&lt;&gt;(phases.size());
267         for (LIRPhase&lt;?&gt; phase : phases) {
268             res.add(phase.getClass().getName());
269         }
270         Collections.sort(res);
271         return res;
</pre>
</td>
</tr>
</table>
<center><a href="CompilationWatchDog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GraalHotSpotVMConfig.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
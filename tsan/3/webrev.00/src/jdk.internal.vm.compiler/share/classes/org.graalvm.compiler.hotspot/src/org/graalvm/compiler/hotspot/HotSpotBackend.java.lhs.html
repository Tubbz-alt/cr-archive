<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotBackend.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static org.graalvm.compiler.replacements.arraycopy.ArrayCopyForeignCalls.UNSAFE_ARRAYCOPY;
 28 
 29 import java.util.EnumSet;
 30 
 31 import jdk.internal.vm.compiler.collections.EconomicMap;
 32 import jdk.internal.vm.compiler.collections.EconomicSet;
 33 import jdk.internal.vm.compiler.collections.Equivalence;
 34 import jdk.internal.vm.compiler.collections.MapCursor;
 35 import org.graalvm.compiler.code.CompilationResult;
 36 import org.graalvm.compiler.core.common.CompilationIdentifier;
 37 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 38 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 39 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 40 import org.graalvm.compiler.core.target.Backend;
 41 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 42 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 43 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 44 import org.graalvm.compiler.hotspot.nodes.VMErrorNode;
 45 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantStubCall;
 46 import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
 47 import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
 48 import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
 49 import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;
 50 import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
 51 import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
 52 import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
 53 import org.graalvm.compiler.hotspot.stubs.ExceptionHandlerStub;
 54 import org.graalvm.compiler.hotspot.stubs.Stub;
 55 import org.graalvm.compiler.hotspot.stubs.UnwindExceptionToCallerStub;
 56 import org.graalvm.compiler.hotspot.word.KlassPointer;
 57 import org.graalvm.compiler.hotspot.word.MethodCountersPointer;
 58 import org.graalvm.compiler.lir.LIR;
 59 import org.graalvm.compiler.lir.LIRFrameState;
 60 import org.graalvm.compiler.lir.LIRInstruction;
 61 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 62 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 63 import org.graalvm.compiler.lir.StandardOp.LabelOp;
<a name="1" id="anc1"></a>
 64 import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;
 65 import org.graalvm.compiler.lir.ValueConsumer;
 66 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 67 import org.graalvm.compiler.lir.framemap.FrameMap;
 68 import org.graalvm.compiler.nodes.UnwindNode;
 69 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 70 import org.graalvm.compiler.options.Option;
 71 import org.graalvm.compiler.options.OptionKey;
 72 import org.graalvm.compiler.options.OptionType;
 73 import org.graalvm.compiler.options.OptionValues;
 74 import org.graalvm.compiler.phases.tiers.SuitesProvider;
 75 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 76 import org.graalvm.compiler.word.Word;
 77 import jdk.internal.vm.compiler.word.Pointer;
 78 
<a name="2" id="anc2"></a>
 79 import jdk.vm.ci.code.CompilationRequest;
 80 import jdk.vm.ci.code.CompiledCode;
 81 import jdk.vm.ci.code.Register;
<a name="3" id="anc3"></a><span class="line-removed"> 82 import jdk.vm.ci.code.RegisterSaveLayout;</span>
 83 import jdk.vm.ci.code.StackSlot;
 84 import jdk.vm.ci.code.ValueUtil;
 85 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 86 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 87 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
<a name="4" id="anc4"></a>
 88 import jdk.vm.ci.meta.ResolvedJavaMethod;
 89 import jdk.vm.ci.meta.Value;
 90 import jdk.vm.ci.runtime.JVMCICompiler;
 91 
 92 /**
 93  * HotSpot specific backend.
 94  */
 95 public abstract class HotSpotBackend extends Backend implements FrameMap.ReferenceMapBuilderFactory {
 96 
 97     public static class Options {
 98         // @formatter:off
 99         @Option(help = &quot;Use Graal arithmetic stubs instead of HotSpot stubs where possible&quot;)
<a name="5" id="anc5"></a><span class="line-modified">100         public static final OptionKey&lt;Boolean&gt; GraalArithmeticStubs = new OptionKey&lt;&gt;(JavaVersionUtil.JAVA_SPECIFICATION_VERSION &gt;= 9);</span>
101         @Option(help = &quot;Enables instruction profiling on assembler level. Valid values are a comma separated list of supported instructions.&quot; +
102                         &quot; Compare with subclasses of Assembler.InstructionCounter.&quot;, type = OptionType.Debug)
103         public static final OptionKey&lt;String&gt; ASMInstructionProfiling = new OptionKey&lt;&gt;(null);
104         // @formatter:on
105     }
106 
107     /**
108      * Descriptor for {@link ExceptionHandlerStub}. This stub is called by the
109      * {@linkplain GraalHotSpotVMConfig#MARKID_EXCEPTION_HANDLER_ENTRY exception handler} in a
110      * compiled method.
111      */
112     public static final ForeignCallDescriptor EXCEPTION_HANDLER = new ForeignCallDescriptor(&quot;exceptionHandler&quot;, void.class, Object.class, Word.class);
113 
114     /**
115      * Descriptor for SharedRuntime::get_ic_miss_stub().
116      */
117     public static final ForeignCallDescriptor IC_MISS_HANDLER = new ForeignCallDescriptor(&quot;icMissHandler&quot;, void.class);
118 
119     /**
120      * Descriptor for SharedRuntime::get_handle_wrong_method_stub().
121      */
122     public static final ForeignCallDescriptor WRONG_METHOD_HANDLER = new ForeignCallDescriptor(&quot;wrongMethodHandler&quot;, void.class);
123 
124     /**
125      * Descriptor for {@link UnwindExceptionToCallerStub}. This stub is called by code generated
126      * from {@link UnwindNode}.
127      */
128     public static final ForeignCallDescriptor UNWIND_EXCEPTION_TO_CALLER = new ForeignCallDescriptor(&quot;unwindExceptionToCaller&quot;, void.class, Object.class, Word.class);
129 
130     /**
131      * Descriptor for the arguments when unwinding to an exception handler in a caller.
132      */
133     public static final ForeignCallDescriptor EXCEPTION_HANDLER_IN_CALLER = new ForeignCallDescriptor(&quot;exceptionHandlerInCaller&quot;, void.class, Object.class, Word.class);
134 
135     private final HotSpotGraalRuntimeProvider runtime;
136 
137     /**
138      * @see AESCryptSubstitutions#encryptBlockStub(ForeignCallDescriptor, Word, Word, Pointer)
139      */
140     public static final ForeignCallDescriptor ENCRYPT_BLOCK = new ForeignCallDescriptor(&quot;encrypt_block&quot;, void.class, Word.class, Word.class, Pointer.class);
141 
142     /**
143      * @see AESCryptSubstitutions#decryptBlockStub(ForeignCallDescriptor, Word, Word, Pointer)
144      */
145     public static final ForeignCallDescriptor DECRYPT_BLOCK = new ForeignCallDescriptor(&quot;decrypt_block&quot;, void.class, Word.class, Word.class, Pointer.class);
146 
147     /**
148      * @see AESCryptSubstitutions#decryptBlockStub(ForeignCallDescriptor, Word, Word, Pointer)
149      */
150     public static final ForeignCallDescriptor DECRYPT_BLOCK_WITH_ORIGINAL_KEY = new ForeignCallDescriptor(&quot;decrypt_block_with_original_key&quot;, void.class, Word.class, Word.class, Pointer.class,
151                     Pointer.class);
152 
153     /**
154      * @see CipherBlockChainingSubstitutions#crypt
155      */
156     public static final ForeignCallDescriptor ENCRYPT = new ForeignCallDescriptor(&quot;encrypt&quot;, void.class, Word.class, Word.class, Pointer.class, Pointer.class, int.class);
157 
158     /**
159      * @see CipherBlockChainingSubstitutions#crypt
160      */
161     public static final ForeignCallDescriptor DECRYPT = new ForeignCallDescriptor(&quot;decrypt&quot;, void.class, Word.class, Word.class, Pointer.class, Pointer.class, int.class);
162 
163     /**
164      * @see CipherBlockChainingSubstitutions#crypt
165      */
166     public static final ForeignCallDescriptor DECRYPT_WITH_ORIGINAL_KEY = new ForeignCallDescriptor(&quot;decrypt_with_original_key&quot;, void.class, Word.class, Word.class, Pointer.class, Pointer.class,
167                     int.class, Pointer.class);
168 
169     /**
170      * @see BigIntegerSubstitutions#multiplyToLen
171      */
172     public static final ForeignCallDescriptor MULTIPLY_TO_LEN = new ForeignCallDescriptor(&quot;multiplyToLen&quot;, void.class, Word.class, int.class, Word.class, int.class, Word.class, int.class);
173 
174     public static void multiplyToLenStub(Word xAddr, int xlen, Word yAddr, int ylen, Word zAddr, int zLen) {
175         multiplyToLenStub(HotSpotBackend.MULTIPLY_TO_LEN, xAddr, xlen, yAddr, ylen, zAddr, zLen);
176     }
177 
178     @NodeIntrinsic(ForeignCallNode.class)
179     private static native void multiplyToLenStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word xIn, int xLen, Word yIn, int yLen, Word zIn, int zLen);
180 
181     /**
182      * @see BigIntegerSubstitutions#mulAdd
183      */
184     public static final ForeignCallDescriptor MUL_ADD = new ForeignCallDescriptor(&quot;mulAdd&quot;, int.class, Word.class, Word.class, int.class, int.class, int.class);
185 
186     public static int mulAddStub(Word inAddr, Word outAddr, int newOffset, int len, int k) {
187         return mulAddStub(HotSpotBackend.MUL_ADD, inAddr, outAddr, newOffset, len, k);
188     }
189 
190     @NodeIntrinsic(ForeignCallNode.class)
191     private static native int mulAddStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word inAddr, Word outAddr, int newOffset, int len, int k);
192 
193     /**
194      * @see BigIntegerSubstitutions#implMontgomeryMultiply
195      */
196     public static final ForeignCallDescriptor MONTGOMERY_MULTIPLY = new ForeignCallDescriptor(&quot;implMontgomeryMultiply&quot;, void.class, Word.class, Word.class, Word.class, int.class, long.class,
197                     Word.class);
198 
199     public static void implMontgomeryMultiply(Word aAddr, Word bAddr, Word nAddr, int len, long inv, Word productAddr) {
200         implMontgomeryMultiply(HotSpotBackend.MONTGOMERY_MULTIPLY, aAddr, bAddr, nAddr, len, inv, productAddr);
201     }
202 
203     @NodeIntrinsic(ForeignCallNode.class)
204     private static native void implMontgomeryMultiply(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word aAddr, Word bAddr, Word nAddr, int len, long inv, Word productAddr);
205 
206     /**
207      * @see BigIntegerSubstitutions#implMontgomerySquare
208      */
209     public static final ForeignCallDescriptor MONTGOMERY_SQUARE = new ForeignCallDescriptor(&quot;implMontgomerySquare&quot;, void.class, Word.class, Word.class, int.class, long.class, Word.class);
210 
211     public static void implMontgomerySquare(Word aAddr, Word nAddr, int len, long inv, Word productAddr) {
212         implMontgomerySquare(HotSpotBackend.MONTGOMERY_SQUARE, aAddr, nAddr, len, inv, productAddr);
213     }
214 
215     @NodeIntrinsic(ForeignCallNode.class)
216     private static native void implMontgomerySquare(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word aAddr, Word nAddr, int len, long inv, Word productAddr);
217 
218     /**
219      * @see BigIntegerSubstitutions#implSquareToLen
220      */
221     public static final ForeignCallDescriptor SQUARE_TO_LEN = new ForeignCallDescriptor(&quot;implSquareToLen&quot;, void.class, Word.class, int.class, Word.class, int.class);
222 
223     public static void implSquareToLen(Word xAddr, int len, Word zAddr, int zLen) {
224         implSquareToLen(SQUARE_TO_LEN, xAddr, len, zAddr, zLen);
225     }
226 
227     @NodeIntrinsic(ForeignCallNode.class)
228     private static native void implSquareToLen(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word xAddr, int len, Word zAddr, int zLen);
229 
230     /**
231      * @see SHASubstitutions#implCompress0
232      */
233     public static final ForeignCallDescriptor SHA_IMPL_COMPRESS = new ForeignCallDescriptor(&quot;shaImplCompress&quot;, void.class, Word.class, Object.class);
234 
235     public static void shaImplCompressStub(Word bufAddr, Object state) {
236         shaImplCompressStub(HotSpotBackend.SHA_IMPL_COMPRESS, bufAddr, state);
237     }
238 
239     @NodeIntrinsic(ForeignCallNode.class)
240     private static native void shaImplCompressStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word bufAddr, Object state);
241 
242     /**
243      * @see SHA2Substitutions#implCompress0
244      */
245     public static final ForeignCallDescriptor SHA2_IMPL_COMPRESS = new ForeignCallDescriptor(&quot;sha2ImplCompress&quot;, void.class, Word.class, Object.class);
246 
247     public static void sha2ImplCompressStub(Word bufAddr, Object state) {
248         sha2ImplCompressStub(HotSpotBackend.SHA2_IMPL_COMPRESS, bufAddr, state);
249     }
250 
251     @NodeIntrinsic(ForeignCallNode.class)
252     private static native void sha2ImplCompressStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word bufAddr, Object state);
253 
254     /**
255      * @see SHA5Substitutions#implCompress0
256      */
257     public static final ForeignCallDescriptor SHA5_IMPL_COMPRESS = new ForeignCallDescriptor(&quot;sha5ImplCompress&quot;, void.class, Word.class, Object.class);
258 
259     public static void sha5ImplCompressStub(Word bufAddr, Object state) {
260         sha5ImplCompressStub(HotSpotBackend.SHA5_IMPL_COMPRESS, bufAddr, state);
261     }
262 
263     @NodeIntrinsic(ForeignCallNode.class)
264     private static native void sha5ImplCompressStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word bufAddr, Object state);
265 
266     /**
267      * @see DigestBaseSubstitutions#implCompressMultiBlock0
268      */
269     public static final ForeignCallDescriptor SHA_IMPL_COMPRESS_MB = new ForeignCallDescriptor(&quot;shaImplCompressMB&quot;, int.class, Word.class, Object.class, int.class, int.class);
270 
271     public static int shaImplCompressMBStub(Word bufAddr, Object stateAddr, int ofs, int limit) {
272         return shaImplCompressMBStub(HotSpotBackend.SHA_IMPL_COMPRESS_MB, bufAddr, stateAddr, ofs, limit);
273     }
274 
275     @NodeIntrinsic(ForeignCallNode.class)
276     private static native int shaImplCompressMBStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word bufAddr, Object state, int ofs, int limit);
277 
278     public static final ForeignCallDescriptor SHA2_IMPL_COMPRESS_MB = new ForeignCallDescriptor(&quot;sha2ImplCompressMB&quot;, int.class, Word.class, Object.class, int.class, int.class);
279 
280     public static int sha2ImplCompressMBStub(Word bufAddr, Object stateAddr, int ofs, int limit) {
281         return sha2ImplCompressMBStub(HotSpotBackend.SHA2_IMPL_COMPRESS_MB, bufAddr, stateAddr, ofs, limit);
282     }
283 
284     @NodeIntrinsic(ForeignCallNode.class)
285     private static native int sha2ImplCompressMBStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word bufAddr, Object state, int ofs, int limit);
286 
287     public static final ForeignCallDescriptor SHA5_IMPL_COMPRESS_MB = new ForeignCallDescriptor(&quot;sha5ImplCompressMB&quot;, int.class, Word.class, Object.class, int.class, int.class);
288 
289     public static int sha5ImplCompressMBStub(Word bufAddr, Object stateAddr, int ofs, int limit) {
290         return sha5ImplCompressMBStub(HotSpotBackend.SHA5_IMPL_COMPRESS_MB, bufAddr, stateAddr, ofs, limit);
291     }
292 
293     @NodeIntrinsic(ForeignCallNode.class)
294     private static native int sha5ImplCompressMBStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word bufAddr, Object state, int ofs, int limit);
295 
296     public static void unsafeArraycopy(Word srcAddr, Word dstAddr, Word size) {
297         unsafeArraycopyStub(UNSAFE_ARRAYCOPY, srcAddr, dstAddr, size);
298     }
299 
300     @NodeIntrinsic(ForeignCallNode.class)
301     private static native void unsafeArraycopyStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word srcAddr, Word dstAddr, Word size);
302 
303     /**
304      * Descriptor for {@code StubRoutines::_ghash_processBlocks}.
305      */
306     public static final ForeignCallDescriptor GHASH_PROCESS_BLOCKS = new ForeignCallDescriptor(&quot;ghashProcessBlocks&quot;, void.class, Word.class, Word.class, Word.class, int.class);
307 
<a name="6" id="anc6"></a>




308     /**
309      * Descriptor for {@code StubRoutines::_counterMode_AESCrypt}.
310      */
311     public static final ForeignCallDescriptor COUNTERMODE_IMPL_CRYPT = new ForeignCallDescriptor(&quot;counterModeAESCrypt&quot;, int.class, Word.class, Word.class, Word.class, Word.class, int.class,
312                     Word.class, Word.class);
313 
314     public static int counterModeAESCrypt(Word srcAddr, Word dstAddr, Word kPtr, Word cntPtr, int len, Word encCntPtr, Word used) {
315         return counterModeAESCrypt(COUNTERMODE_IMPL_CRYPT, srcAddr, dstAddr, kPtr, cntPtr, len, encCntPtr, used);
316     }
317 
318     @NodeIntrinsic(ForeignCallNode.class)
319     private static native int counterModeAESCrypt(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word srcAddr, Word dstAddr, Word kPtr, Word cntPtr, int len, Word encCntPtr,
320                     Word used);
321 
322     /**
323      * Descriptor for {@code StubRoutines::_vectorizedMismatch}.
324      */
325     public static final ForeignCallDescriptor VECTORIZED_MISMATCHED = new ForeignCallDescriptor(&quot;vectorizedMismatch&quot;, int.class, Word.class, Word.class, int.class, int.class);
326 
327     public static int vectorizedMismatch(Word aAddr, Word bAddr, int length, int log2ArrayIndexScale) {
328         return vectorizedMismatchStub(VECTORIZED_MISMATCHED, aAddr, bAddr, length, log2ArrayIndexScale);
329     }
330 
331     @NodeIntrinsic(ForeignCallNode.class)
332     private static native int vectorizedMismatchStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Word aAddr, Word bAddr, int length, int log2ArrayIndexScale);
333 
334     /**
335      * @see VMErrorNode
336      */
337     public static final ForeignCallDescriptor VM_ERROR = new ForeignCallDescriptor(&quot;vm_error&quot;, void.class, Object.class, Object.class, long.class);
338 
339     /**
340      * New multi array stub that throws an {@link OutOfMemoryError} on allocation failure.
341      */
342     public static final ForeignCallDescriptor NEW_MULTI_ARRAY = new ForeignCallDescriptor(&quot;new_multi_array&quot;, Object.class, KlassPointer.class, int.class, Word.class);
343 
344     /**
345      * New multi array stub that will return null on allocation failure.
346      */
347     public static final ForeignCallDescriptor NEW_MULTI_ARRAY_OR_NULL = new ForeignCallDescriptor(&quot;new_multi_array_or_null&quot;, Object.class, KlassPointer.class, int.class, Word.class);
348 
349     /**
350      * New array stub that throws an {@link OutOfMemoryError} on allocation failure.
351      */
352     public static final ForeignCallDescriptor NEW_ARRAY = new ForeignCallDescriptor(&quot;new_array&quot;, Object.class, KlassPointer.class, int.class);
353 
354     /**
355      * New array stub that will return null on allocation failure.
356      */
357     public static final ForeignCallDescriptor NEW_ARRAY_OR_NULL = new ForeignCallDescriptor(&quot;new_array_or_null&quot;, Object.class, KlassPointer.class, int.class);
358 
359     /**
360      * New instance stub that throws an {@link OutOfMemoryError} on allocation failure.
361      */
362     public static final ForeignCallDescriptor NEW_INSTANCE = new ForeignCallDescriptor(&quot;new_instance&quot;, Object.class, KlassPointer.class);
363 
364     /**
365      * New instance stub that will return null on allocation failure.
366      */
367     public static final ForeignCallDescriptor NEW_INSTANCE_OR_NULL = new ForeignCallDescriptor(&quot;new_instance_or_null&quot;, Object.class, KlassPointer.class);
368 
369     /**
370      * @see ResolveConstantStubCall
371      */
372     public static final ForeignCallDescriptor RESOLVE_STRING_BY_SYMBOL = new ForeignCallDescriptor(&quot;resolve_string_by_symbol&quot;, Object.class, Word.class, Word.class);
373 
374     /**
375      * @see ResolveConstantStubCall
376      */
377     public static final ForeignCallDescriptor RESOLVE_DYNAMIC_INVOKE = new ForeignCallDescriptor(&quot;resolve_dynamic_invoke&quot;, Object.class, Word.class);
378 
379     /**
380      * @see ResolveConstantStubCall
381      */
382     public static final ForeignCallDescriptor RESOLVE_KLASS_BY_SYMBOL = new ForeignCallDescriptor(&quot;resolve_klass_by_symbol&quot;, Word.class, Word.class, Word.class);
383 
384     /**
385      * @see ResolveConstantStubCall
386      */
387     public static final ForeignCallDescriptor INITIALIZE_KLASS_BY_SYMBOL = new ForeignCallDescriptor(&quot;initialize_klass_by_symbol&quot;, Word.class, Word.class, Word.class);
388 
389     /**
390      * @see ResolveConstantStubCall
391      */
392     public static final ForeignCallDescriptor RESOLVE_METHOD_BY_SYMBOL_AND_LOAD_COUNTERS = new ForeignCallDescriptor(&quot;resolve_method_by_symbol_and_load_counters&quot;, Word.class, Word.class, Word.class,
393                     Word.class);
394 
395     /**
396      * Tiered support.
397      */
398     public static final ForeignCallDescriptor INVOCATION_EVENT = new ForeignCallDescriptor(&quot;invocation_event&quot;, void.class, MethodCountersPointer.class);
399     public static final ForeignCallDescriptor BACKEDGE_EVENT = new ForeignCallDescriptor(&quot;backedge_event&quot;, void.class, MethodCountersPointer.class, int.class, int.class);
400 
401     public HotSpotBackend(HotSpotGraalRuntimeProvider runtime, HotSpotProviders providers) {
402         super(providers);
403         this.runtime = runtime;
404     }
405 
406     public HotSpotGraalRuntimeProvider getRuntime() {
407         return runtime;
408     }
409 
410     /**
411      * Performs any remaining initialization that was deferred until the {@linkplain #getRuntime()
412      * runtime} object was initialized and this backend was registered with it.
413      *
414      * @param jvmciRuntime
415      * @param options
416      */
417     public void completeInitialization(HotSpotJVMCIRuntime jvmciRuntime, OptionValues options) {
418     }
419 
420     /**
421      * Finds all the registers that are defined by some given LIR.
422      *
<a name="7" id="anc7"></a><span class="line-modified">423      * @param lir the LIR to examine</span>
424      * @return the registers that are defined by or used as temps for any instruction in {@code lir}
425      */
<a name="8" id="anc8"></a><span class="line-modified">426     protected final EconomicSet&lt;Register&gt; gatherDestroyedCallerRegisters(LIR lir) {</span>


427         final EconomicSet&lt;Register&gt; destroyedRegisters = EconomicSet.create(Equivalence.IDENTITY);
428         ValueConsumer defConsumer = new ValueConsumer() {
429 
430             @Override
431             public void visitValue(Value value, OperandMode mode, EnumSet&lt;OperandFlag&gt; flags) {
432                 if (ValueUtil.isRegister(value)) {
433                     final Register reg = ValueUtil.asRegister(value);
<a name="9" id="anc9"></a><span class="line-modified">434                     destroyedRegisters.add(reg);</span>


435                 }
436             }
437         };
<a name="10" id="anc10"></a>
438         for (AbstractBlockBase&lt;?&gt; block : lir.codeEmittingOrder()) {
439             if (block == null) {
440                 continue;
441             }
<a name="11" id="anc11"></a>

442             for (LIRInstruction op : lir.getLIRforBlock(block)) {
443                 if (op instanceof LabelOp) {
444                     // Don&#39;t consider this as a definition
<a name="12" id="anc12"></a>






445                 } else {
446                     op.visitEachTemp(defConsumer);
447                     op.visitEachOutput(defConsumer);
448                 }
449             }
<a name="13" id="anc13"></a>











450         }
451         return translateToCallerRegisters(destroyedRegisters);
452     }
453 
454     /**
455      * Translates a set of registers from the callee&#39;s perspective to the caller&#39;s perspective. This
456      * is needed for architectures where input/output registers are renamed during a call (e.g.
457      * register windows on SPARC). Registers which are not visible by the caller are removed.
458      */
459     protected abstract EconomicSet&lt;Register&gt; translateToCallerRegisters(EconomicSet&lt;Register&gt; calleeRegisters);
460 
461     /**
<a name="14" id="anc14"></a><span class="line-modified">462      * Updates a given stub with respect to the registers it destroys.</span>
<span class="line-modified">463      * &lt;p&gt;</span>
<span class="line-modified">464      * Any entry in {@code calleeSaveInfo} that {@linkplain SaveRegistersOp#supportsRemove()</span>
<span class="line-modified">465      * supports} pruning will have {@code destroyedRegisters}</span>
<span class="line-modified">466      * {@linkplain SaveRegistersOp#remove(EconomicSet) removed} as these registers are declared as</span>
<span class="line-removed">467      * temporaries in the stub&#39;s {@linkplain ForeignCallLinkage linkage} (and thus will be saved by</span>
<span class="line-removed">468      * the stub&#39;s caller).</span>
469      *
470      * @param stub the stub to update
<a name="15" id="anc15"></a><span class="line-modified">471      * @param destroyedRegisters the registers destroyed by the stub</span>
<span class="line-removed">472      * @param calleeSaveInfo a map from debug infos to the operations that provide their</span>
<span class="line-removed">473      *            {@linkplain RegisterSaveLayout callee-save information}</span>
474      * @param frameMap used to {@linkplain FrameMap#offsetForStackSlot(StackSlot) convert} a virtual
<a name="16" id="anc16"></a><span class="line-removed">475      *            slot to a frame slot index</span>
476      */
<a name="17" id="anc17"></a><span class="line-modified">477     protected void updateStub(Stub stub, EconomicSet&lt;Register&gt; destroyedRegisters, EconomicMap&lt;LIRFrameState, SaveRegistersOp&gt; calleeSaveInfo, FrameMap frameMap) {</span>












478         stub.initDestroyedCallerRegisters(destroyedRegisters);
479 
480         MapCursor&lt;LIRFrameState, SaveRegistersOp&gt; cursor = calleeSaveInfo.getEntries();
481         while (cursor.advance()) {
482             SaveRegistersOp save = cursor.getValue();
<a name="18" id="anc18"></a><span class="line-modified">483             if (save.supportsRemove()) {</span>
<span class="line-removed">484                 save.remove(destroyedRegisters);</span>
<span class="line-removed">485             }</span>
486             if (cursor.getKey() != LIRFrameState.NO_STATE) {
487                 cursor.getKey().debugInfo().setCalleeSaveInfo(save.getMap(frameMap));
488             }
489         }
490     }
491 
492     @Override
493     public HotSpotProviders getProviders() {
494         return (HotSpotProviders) super.getProviders();
495     }
496 
497     @Override
498     public SuitesProvider getSuites() {
499         return getProviders().getSuites();
500     }
501 
502     protected void profileInstructions(LIR lir, CompilationResultBuilder crb) {
503         if (HotSpotBackend.Options.ASMInstructionProfiling.getValue(lir.getOptions()) != null) {
504             HotSpotInstructionProfiling.countInstructions(lir, crb.asm);
505         }
506     }
507 
508     @Override
509     public CompiledCode createCompiledCode(ResolvedJavaMethod method,
510                     CompilationRequest compilationRequest,
511                     CompilationResult compResult,
512                     boolean isDefault,
513                     OptionValues options) {
514         assert !isDefault || compResult.getName() == null : &quot;a default nmethod should have a null name since it is associated with a Method*&quot;;
515         HotSpotCompilationRequest compRequest = compilationRequest instanceof HotSpotCompilationRequest ? (HotSpotCompilationRequest) compilationRequest : null;
516         return HotSpotCompiledCodeBuilder.createCompiledCode(getCodeCache(), method, compRequest, compResult, options);
517     }
518 
519     @Override
520     public CompilationIdentifier getCompilationIdentifier(ResolvedJavaMethod resolvedJavaMethod) {
521         if (resolvedJavaMethod instanceof HotSpotResolvedJavaMethod) {
522             HotSpotCompilationRequest request = new HotSpotCompilationRequest((HotSpotResolvedJavaMethod) resolvedJavaMethod, JVMCICompiler.INVOCATION_ENTRY_BCI, 0L);
523             return new HotSpotCompilationIdentifier(request);
524         }
525         return super.getCompilationIdentifier(resolvedJavaMethod);
526     }
527 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
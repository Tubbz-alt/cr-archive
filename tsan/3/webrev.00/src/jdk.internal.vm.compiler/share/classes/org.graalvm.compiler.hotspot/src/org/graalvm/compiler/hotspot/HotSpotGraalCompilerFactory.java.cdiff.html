<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalCompilerFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotGraalCompiler.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotGraalJVMCIServiceLocator.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalCompilerFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,11 ***</span>
<span class="line-new-header">--- 23,13 ---</span>
  
  
  package org.graalvm.compiler.hotspot;
  
  import static jdk.vm.ci.common.InitTimer.timer;
<span class="line-added">+ import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;</span>
  import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
<span class="line-added">+ import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;</span>
  import static org.graalvm.compiler.hotspot.HotSpotGraalOptionValues.GRAAL_OPTION_PROPERTY_PREFIX;
  
  import java.io.PrintStream;
  
  import org.graalvm.compiler.api.runtime.GraalRuntime;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,12 ***</span>
  import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
  
  import jdk.vm.ci.common.InitTimer;
  import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
<span class="line-modified">! import jdk.vm.ci.hotspot.HotSpotSignature;</span>
  import jdk.vm.ci.runtime.JVMCIRuntime;
  
  public final class HotSpotGraalCompilerFactory extends HotSpotJVMCICompilerFactory {
  
      private static MethodFilter[] graalCompileOnlyFilter;
      private static boolean compileGraalWithC1Only;
<span class="line-new-header">--- 42,14 ---</span>
  import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
  
  import jdk.vm.ci.common.InitTimer;
  import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
<span class="line-modified">! import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;</span>
<span class="line-added">+ import jdk.vm.ci.meta.Signature;</span>
  import jdk.vm.ci.runtime.JVMCIRuntime;
<span class="line-added">+ import jdk.vm.ci.services.Services;</span>
  
  public final class HotSpotGraalCompilerFactory extends HotSpotJVMCICompilerFactory {
  
      private static MethodFilter[] graalCompileOnlyFilter;
      private static boolean compileGraalWithC1Only;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,29 ***</span>
       */
      private OptionValues options;
  
      @Override
      public void onSelection() {
<span class="line-modified">!         JVMCIVersionCheck.check(false);</span>
          assert options == null : &quot;cannot select &quot; + getClass() + &quot; service more than once&quot;;
          options = HotSpotGraalOptionValues.defaultOptions();
          initializeGraalCompilePolicyFields(options);
          isGraalPredicate = compileGraalWithC1Only ? new IsGraalPredicate() : null;
          /*
           * Exercise this code path early to encourage loading now. This doesn&#39;t solve problem of
           * deadlock during class loading but seems to eliminate it in practice.
           */
<span class="line-modified">!         adjustCompilationLevelInternal(Object.class, &quot;hashCode&quot;, &quot;()I&quot;, CompilationLevel.FullOptimization);</span>
<span class="line-modified">!         adjustCompilationLevelInternal(Object.class, &quot;hashCode&quot;, &quot;()I&quot;, CompilationLevel.Simple);</span>
          if (IS_BUILDING_NATIVE_IMAGE) {
              // Triggers initialization of all option descriptors
              Options.CompileGraalWithC1Only.getName();
          }
      }
  
      private static void initializeGraalCompilePolicyFields(OptionValues options) {
<span class="line-modified">!         compileGraalWithC1Only = Options.CompileGraalWithC1Only.getValue(options);</span>
          String optionValue = Options.GraalCompileOnly.getValue(options);
          if (optionValue != null) {
              MethodFilter[] filter = MethodFilter.parse(optionValue);
              if (filter.length == 0) {
                  filter = null;
<span class="line-new-header">--- 72,31 ---</span>
       */
      private OptionValues options;
  
      @Override
      public void onSelection() {
<span class="line-modified">!         JVMCIVersionCheck.check(Services.getSavedProperties(), false);</span>
          assert options == null : &quot;cannot select &quot; + getClass() + &quot; service more than once&quot;;
          options = HotSpotGraalOptionValues.defaultOptions();
          initializeGraalCompilePolicyFields(options);
          isGraalPredicate = compileGraalWithC1Only ? new IsGraalPredicate() : null;
          /*
           * Exercise this code path early to encourage loading now. This doesn&#39;t solve problem of
           * deadlock during class loading but seems to eliminate it in practice.
           */
<span class="line-modified">!         if (isGraalPredicate != null &amp;&amp; isGraalPredicate.getCompilationLevelAdjustment() != None) {</span>
<span class="line-modified">!             adjustCompilationLevelInternal(Object.class, CompilationLevel.FullOptimization);</span>
<span class="line-added">+             adjustCompilationLevelInternal(Object.class, CompilationLevel.Simple);</span>
<span class="line-added">+         }</span>
          if (IS_BUILDING_NATIVE_IMAGE) {
              // Triggers initialization of all option descriptors
              Options.CompileGraalWithC1Only.getName();
          }
      }
  
      private static void initializeGraalCompilePolicyFields(OptionValues options) {
<span class="line-modified">!         compileGraalWithC1Only = Options.CompileGraalWithC1Only.getValue(options) &amp;&amp; !IS_IN_NATIVE_IMAGE;</span>
          String optionValue = Options.GraalCompileOnly.getValue(options);
          if (optionValue != null) {
              MethodFilter[] filter = MethodFilter.parse(optionValue);
              if (filter.length == 0) {
                  filter = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,11 ***</span>
  
      @Override
      public HotSpotGraalCompiler createCompiler(JVMCIRuntime runtime) {
          CompilerConfigurationFactory factory = CompilerConfigurationFactory.selectFactory(null, options);
          if (isGraalPredicate != null) {
<span class="line-modified">!             isGraalPredicate.onCompilerConfigurationFactorySelection(factory);</span>
          }
          HotSpotGraalCompiler compiler = createCompiler(&quot;VM&quot;, runtime, options, factory);
          // Only the HotSpotGraalRuntime associated with the compiler created via
          // jdk.vm.ci.runtime.JVMCIRuntime.getCompiler() is registered for receiving
          // VM events.
<span class="line-new-header">--- 127,11 ---</span>
  
      @Override
      public HotSpotGraalCompiler createCompiler(JVMCIRuntime runtime) {
          CompilerConfigurationFactory factory = CompilerConfigurationFactory.selectFactory(null, options);
          if (isGraalPredicate != null) {
<span class="line-modified">!             isGraalPredicate.onCompilerConfigurationFactorySelection((HotSpotJVMCIRuntime) runtime, factory);</span>
          }
          HotSpotGraalCompiler compiler = createCompiler(&quot;VM&quot;, runtime, options, factory);
          // Only the HotSpotGraalRuntime associated with the compiler created via
          // jdk.vm.ci.runtime.JVMCIRuntime.getCompiler() is registered for receiving
          // VM events.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,64 ***</span>
          }
      }
  
      @Override
      public CompilationLevelAdjustment getCompilationLevelAdjustment() {
<span class="line-modified">!         if (graalCompileOnlyFilter != null) {</span>
<span class="line-removed">-             return CompilationLevelAdjustment.ByFullSignature;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (compileGraalWithC1Only) {</span>
<span class="line-removed">-             // We only decide using the class declaring the method</span>
<span class="line-removed">-             // so no need to have the method name and signature</span>
<span class="line-removed">-             // symbols converted to a String.</span>
<span class="line-removed">-             return CompilationLevelAdjustment.ByHolder;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return CompilationLevelAdjustment.None;</span>
      }
  
      @Override
      public CompilationLevel adjustCompilationLevel(Object declaringClassObject, String name, String signature, boolean isOsr, CompilationLevel level) {
<span class="line-removed">-         if (declaringClassObject instanceof String) {</span>
<span class="line-removed">-             // This must be SVM mode in which case only GraalCompileC1Only matters since Graal and</span>
<span class="line-removed">-             // JVMCI are already compiled.</span>
<span class="line-removed">-             return checkGraalCompileOnlyFilter((String) declaringClassObject, name, signature, level);</span>
<span class="line-removed">-         }</span>
          Class&lt;?&gt; declaringClass = (Class&lt;?&gt;) declaringClassObject;
<span class="line-modified">!         return adjustCompilationLevelInternal(declaringClass, name, signature, level);</span>
      }
  
      static {
          // Fail-fast detection for package renaming to guard use of package
          // prefixes in adjustCompilationLevelInternal.
          assert jdk.vm.ci.services.Services.class.getName().equals(&quot;jdk.vm.ci.services.Services&quot;);
          assert HotSpotGraalCompilerFactory.class.getName().equals(&quot;org.graalvm.compiler.hotspot.HotSpotGraalCompilerFactory&quot;);
      }
  
<span class="line-modified">!     private CompilationLevel adjustCompilationLevelInternal(Class&lt;?&gt; declaringClass, String name, String signature, CompilationLevel level) {</span>
<span class="line-modified">!         if (compileGraalWithC1Only) {</span>
<span class="line-modified">!             if (level.ordinal() &gt; CompilationLevel.Simple.ordinal()) {</span>
<span class="line-modified">!                 if (isGraalPredicate.apply(declaringClass)) {</span>
<span class="line-modified">!                     return CompilationLevel.Simple;</span>
<span class="line-removed">-                 }</span>
              }
          }
<span class="line-modified">!         return checkGraalCompileOnlyFilter(declaringClass.getName(), name, signature, level);</span>
      }
  
<span class="line-modified">!     public static CompilationLevel checkGraalCompileOnlyFilter(String declaringClassName, String name, String signature, CompilationLevel level) {</span>
          if (graalCompileOnlyFilter != null) {
<span class="line-modified">!             if (level == CompilationLevel.FullOptimization) {</span>
<span class="line-modified">!                 HotSpotSignature sig = null;</span>
<span class="line-modified">!                 for (MethodFilter filter : graalCompileOnlyFilter) {</span>
<span class="line-modified">!                     if (filter.hasSignature() &amp;&amp; sig == null) {</span>
<span class="line-modified">!                         sig = new HotSpotSignature(HotSpotJVMCIRuntime.runtime(), signature);</span>
<span class="line-modified">!                     }</span>
<span class="line-removed">-                     if (filter.matches(declaringClassName, name, sig)) {</span>
<span class="line-removed">-                         return level;</span>
<span class="line-removed">-                     }</span>
                  }
<span class="line-removed">-                 return CompilationLevel.Simple;</span>
              }
          }
<span class="line-modified">!         return level;</span>
      }
  }
<span class="line-new-header">--- 158,46 ---</span>
          }
      }
  
      @Override
      public CompilationLevelAdjustment getCompilationLevelAdjustment() {
<span class="line-modified">!         return isGraalPredicate != null ? isGraalPredicate.getCompilationLevelAdjustment() : None;</span>
      }
  
      @Override
      public CompilationLevel adjustCompilationLevel(Object declaringClassObject, String name, String signature, boolean isOsr, CompilationLevel level) {
          Class&lt;?&gt; declaringClass = (Class&lt;?&gt;) declaringClassObject;
<span class="line-modified">!         return adjustCompilationLevelInternal(declaringClass, level);</span>
      }
  
      static {
          // Fail-fast detection for package renaming to guard use of package
          // prefixes in adjustCompilationLevelInternal.
          assert jdk.vm.ci.services.Services.class.getName().equals(&quot;jdk.vm.ci.services.Services&quot;);
          assert HotSpotGraalCompilerFactory.class.getName().equals(&quot;org.graalvm.compiler.hotspot.HotSpotGraalCompilerFactory&quot;);
      }
  
<span class="line-modified">!     private CompilationLevel adjustCompilationLevelInternal(Class&lt;?&gt; declaringClass, CompilationLevel level) {</span>
<span class="line-modified">!         assert isGraalPredicate != null;</span>
<span class="line-modified">!         if (level.ordinal() &gt; CompilationLevel.Simple.ordinal()) {</span>
<span class="line-modified">!             if (isGraalPredicate.apply(declaringClass)) {</span>
<span class="line-modified">!                 return CompilationLevel.Simple;</span>
              }
          }
<span class="line-modified">!         return level;</span>
      }
  
<span class="line-modified">!     static boolean shouldExclude(HotSpotResolvedJavaMethod method) {</span>
          if (graalCompileOnlyFilter != null) {
<span class="line-modified">!             String javaClassName = method.getDeclaringClass().toJavaName();</span>
<span class="line-modified">!             String name = method.getName();</span>
<span class="line-modified">!             Signature signature = method.getSignature();</span>
<span class="line-modified">!             for (MethodFilter filter : graalCompileOnlyFilter) {</span>
<span class="line-modified">!                 if (filter.matches(javaClassName, name, signature)) {</span>
<span class="line-modified">!                     return false;</span>
                  }
              }
<span class="line-added">+             return true;</span>
          }
<span class="line-modified">!         return false;</span>
      }
  }
</pre>
<center><a href="HotSpotGraalCompiler.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotGraalJVMCIServiceLocator.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
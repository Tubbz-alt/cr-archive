diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationTask.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationTask.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationTask.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationTask.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,64 +24,49 @@
 
 package org.graalvm.compiler.hotspot;
 
 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Diagnose;
 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.ExitVM;
-import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAction;
+import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAsFailure;
 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
 import static org.graalvm.compiler.core.phases.HighTier.Options.Inline;
 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 
 import java.io.PrintStream;
+import java.util.Collections;
 import java.util.List;
 
 import jdk.internal.vm.compiler.collections.EconomicMap;
 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 import org.graalvm.compiler.code.CompilationResult;
 import org.graalvm.compiler.core.CompilationPrinter;
 import org.graalvm.compiler.core.CompilationWrapper;
 import org.graalvm.compiler.core.common.CompilationIdentifier;
-import org.graalvm.compiler.debug.Assertions;
 import org.graalvm.compiler.debug.CounterKey;
 import org.graalvm.compiler.debug.DebugCloseable;
 import org.graalvm.compiler.debug.DebugContext;
+import org.graalvm.compiler.debug.DebugContext.Description;
 import org.graalvm.compiler.debug.DebugDumpScope;
-import org.graalvm.compiler.debug.GraalError;
+import org.graalvm.compiler.debug.DebugHandlersFactory;
 import org.graalvm.compiler.debug.TimerKey;
-import org.graalvm.compiler.options.EnumOptionKey;
 import org.graalvm.compiler.options.OptionKey;
 import org.graalvm.compiler.options.OptionValues;
 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 
 import jdk.vm.ci.code.BailoutException;
 import jdk.vm.ci.code.CodeCacheProvider;
-import jdk.vm.ci.hotspot.EventProvider;
 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 import jdk.vm.ci.hotspot.HotSpotCompilationRequestResult;
 import jdk.vm.ci.hotspot.HotSpotInstalledCode;
-import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory;
 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 import jdk.vm.ci.hotspot.HotSpotNmethod;
 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
+import jdk.vm.ci.meta.ResolvedJavaMethod;
 import jdk.vm.ci.runtime.JVMCICompiler;
-import jdk.vm.ci.services.JVMCIServiceLocator;
 
 public class CompilationTask {
 
-    private static final EventProvider eventProvider;
-
-    static {
-        List<EventProvider> providers = JVMCIServiceLocator.getProviders(EventProvider.class);
-        if (providers.size() > 1) {
-            throw new GraalError("Multiple %s providers found: %s", EventProvider.class.getName(), providers);
-        } else if (providers.isEmpty()) {
-            eventProvider = EventProvider.createEmptyEventProvider();
-        } else {
-            eventProvider = providers.get(0);
-        }
-    }
-
     private final HotSpotJVMCIRuntime jvmciRuntime;
 
     private final HotSpotGraalCompiler compiler;
     private final HotSpotCompilationIdentifier compilationId;
 
@@ -92,30 +77,35 @@
      * {@linkplain HotSpotNmethod#isDefault() default} nmethod for the compiled method.
      */
     private final boolean installAsDefault;
 
     private final boolean useProfilingInfo;
-    private final OptionValues options;
+    private final boolean shouldRetainLocalVariables;
 
     final class HotSpotCompilationWrapper extends CompilationWrapper<HotSpotCompilationRequestResult> {
-        private final EventProvider.CompilationEvent compilationEvent;
         CompilationResult result;
 
-        HotSpotCompilationWrapper(EventProvider.CompilationEvent compilationEvent) {
+        HotSpotCompilationWrapper() {
             super(compiler.getGraalRuntime().getOutputDirectory(), compiler.getGraalRuntime().getCompilationProblemsPerAction());
-            this.compilationEvent = compilationEvent;
         }
 
         @Override
-        protected DebugContext createRetryDebugContext(OptionValues retryOptions, PrintStream logStream) {
+        protected DebugContext createRetryDebugContext(DebugContext initialDebug, OptionValues retryOptions, PrintStream logStream) {
             SnippetReflectionProvider snippetReflection = compiler.getGraalRuntime().getHostProviders().getSnippetReflection();
-            return DebugContext.create(retryOptions, logStream, new GraalDebugHandlersFactory(snippetReflection));
+            Description description = initialDebug.getDescription();
+            List<DebugHandlersFactory> factories = Collections.singletonList(new GraalDebugHandlersFactory(snippetReflection));
+            return DebugContext.create(retryOptions, description, initialDebug.getGlobalMetrics(), logStream, factories);
+        }
+
+        @Override
+        protected void exitHostVM(int status) {
+            HotSpotGraalServices.exit(status);
         }
 
         @Override
         public String toString() {
-            return getMethod().format("%H.%n(%p)");
+            return getMethod().format("%H.%n(%p) @ " + getEntryBCI());
         }
 
         @Override
         protected HotSpotCompilationRequestResult handleException(Throwable t) {
             if (t instanceof BailoutException) {
@@ -126,67 +116,62 @@
                  * not be retried. Hotspot compile broker will ensure that no recompilation at the
                  * given tier will happen if retry is false.
                  */
                 return HotSpotCompilationRequestResult.failure(bailout.getMessage(), !bailout.isPermanent());
             }
-            // Log a failure event.
-            EventProvider.CompilerFailureEvent event = eventProvider.newCompilerFailureEvent();
-            if (event.shouldWrite()) {
-                event.setCompileId(getId());
-                event.setMessage(t.getMessage());
-                event.commit();
-            }
 
             /*
              * Treat random exceptions from the compiler as indicating a problem compiling this
              * method. Report the result of toString instead of getMessage to ensure that the
              * exception type is included in the output in case there's no detail mesage.
              */
             return HotSpotCompilationRequestResult.failure(t.toString(), false);
         }
 
         @Override
-        protected ExceptionAction lookupAction(OptionValues values, EnumOptionKey<ExceptionAction> actionKey, Throwable cause) {
-            // Respect current action if it has been explicitly set.
-            if (!actionKey.hasBeenSet(values)) {
-                if (actionKey == CompilationFailureAction) {
-                    // Automatically exit on non-bailout during bootstrap
-                    // or when assertions are enabled.
-                    if (Assertions.assertionsEnabled() || compiler.getGraalRuntime().isBootstrapping()) {
-                        return ExitVM;
-                    }
-                } else if (actionKey == CompilationBailoutAction && ((BailoutException) cause).isPermanent()) {
-                    // Get more info for permanent bailouts during bootstrap
-                    // or when assertions are enabled.
-                    assert CompilationBailoutAction.getDefaultValue() == ExceptionAction.Silent;
-                    if (Assertions.assertionsEnabled() || compiler.getGraalRuntime().isBootstrapping()) {
-                        return Diagnose;
+        protected ExceptionAction lookupAction(OptionValues values, Throwable cause) {
+            if (cause instanceof BailoutException) {
+                BailoutException bailout = (BailoutException) cause;
+                if (bailout.isPermanent()) {
+                    // Respect current action if it has been explicitly set.
+                    if (!CompilationBailoutAsFailure.hasBeenSet(values)) {
+                        // Get more info for permanent bailouts during bootstrap.
+                        if (compiler.getGraalRuntime().isBootstrapping()) {
+                            return Diagnose;
+                        }
+
                     }
                 }
+                if (!CompilationBailoutAsFailure.getValue(values)) {
+                    return super.lookupAction(values, cause);
+                }
+            }
+
+            // Respect current action if it has been explicitly set.
+            if (!CompilationFailureAction.hasBeenSet(values)) {
+                // Automatically exit on failure during bootstrap.
+                if (compiler.getGraalRuntime().isBootstrapping()) {
+                    return ExitVM;
+                }
             }
-            return super.lookupAction(values, actionKey, cause);
+            return super.lookupAction(values, cause);
         }
 
         @SuppressWarnings("try")
         @Override
         protected HotSpotCompilationRequestResult performCompilation(DebugContext debug) {
             HotSpotResolvedJavaMethod method = getMethod();
             int entryBCI = getEntryBCI();
             final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
-            CompilationStatistics stats = CompilationStatistics.create(options, method, isOSR);
+            CompilationStatistics stats = CompilationStatistics.create(debug.getOptions(), method, isOSR);
 
-            final CompilationPrinter printer = CompilationPrinter.begin(options, compilationId, method, entryBCI);
+            final CompilationPrinter printer = CompilationPrinter.begin(debug.getOptions(), compilationId, method, entryBCI);
 
             try (DebugContext.Scope s = debug.scope("Compiling", new DebugDumpScope(getIdString(), true))) {
-                // Begin the compilation event.
-                compilationEvent.begin();
-                result = compiler.compile(method, entryBCI, useProfilingInfo, compilationId, options, debug);
+                result = compiler.compile(method, entryBCI, useProfilingInfo, shouldRetainLocalVariables, compilationId, debug);
             } catch (Throwable e) {
                 throw debug.handle(e);
-            } finally {
-                // End the compilation event.
-                compilationEvent.end();
             }
 
             if (result != null) {
                 try (DebugCloseable b = CodeInstallationTime.start(debug)) {
                     installMethod(debug, result);
@@ -194,25 +179,46 @@
                 // Installation is included in compilation time and memory usage reported by printer
                 printer.finish(result);
             }
             stats.finish(method, installedCode);
             if (result != null) {
-                return HotSpotCompilationRequestResult.success(result.getBytecodeSize() - method.getCodeSize());
+                // For compilation of substitutions the method in the compilation request might be
+                // different than the actual method parsed. The root of the compilation will always
+                // be the first method in the methods list, so use that instead.
+                ResolvedJavaMethod rootMethod = result.getMethods()[0];
+                int inlinedBytecodes = result.getBytecodeSize() - rootMethod.getCodeSize();
+                assert inlinedBytecodes >= 0 : rootMethod + " " + method;
+                return HotSpotCompilationRequestResult.success(inlinedBytecodes);
             }
             return null;
         }
 
     }
 
-    public CompilationTask(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalCompiler compiler, HotSpotCompilationRequest request, boolean useProfilingInfo, boolean installAsDefault,
-                    OptionValues options) {
+    public CompilationTask(HotSpotJVMCIRuntime jvmciRuntime,
+                    HotSpotGraalCompiler compiler,
+                    HotSpotCompilationRequest request,
+                    boolean useProfilingInfo,
+                    boolean installAsDefault) {
+        this(jvmciRuntime, compiler, request, useProfilingInfo, false, installAsDefault);
+    }
+
+    public CompilationTask(HotSpotJVMCIRuntime jvmciRuntime,
+                    HotSpotGraalCompiler compiler,
+                    HotSpotCompilationRequest request,
+                    boolean useProfilingInfo,
+                    boolean shouldRetainLocalVariables,
+                    boolean installAsDefault) {
         this.jvmciRuntime = jvmciRuntime;
         this.compiler = compiler;
         this.compilationId = new HotSpotCompilationIdentifier(request);
         this.useProfilingInfo = useProfilingInfo;
+        this.shouldRetainLocalVariables = shouldRetainLocalVariables;
         this.installAsDefault = installAsDefault;
+    }
 
+    public OptionValues filterOptions(OptionValues options) {
         /*
          * Disable inlining if HotSpot has it disabled unless it's been explicitly set in Graal.
          */
         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
         GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
@@ -227,11 +233,11 @@
             }
             if (!m.isEmpty()) {
                 newOptions = new OptionValues(options, m);
             }
         }
-        this.options = newOptions;
+        return newOptions;
     }
 
     public HotSpotResolvedJavaMethod getMethod() {
         return getRequest().getMethod();
     }
@@ -270,22 +276,22 @@
     }
 
     /**
      * Time spent in compilation.
      */
-    private static final TimerKey CompilationTime = DebugContext.timer("CompilationTime").doc("Time spent in compilation and code installation.");
+    public static final TimerKey CompilationTime = DebugContext.timer("CompilationTime").doc("Time spent in compilation and code installation.");
 
     /**
      * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes}.
      */
     private static final CounterKey CompiledBytecodes = DebugContext.counter("CompiledBytecodes");
 
     /**
      * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes} for
      * which {@linkplain CompilationResult#getTargetCode()} code was installed.
      */
-    private static final CounterKey CompiledAndInstalledBytecodes = DebugContext.counter("CompiledAndInstalledBytecodes");
+    public static final CounterKey CompiledAndInstalledBytecodes = DebugContext.counter("CompiledAndInstalledBytecodes");
 
     /**
      * Counts the number of installed {@linkplain CompilationResult#getTargetCodeSize()} bytes.
      */
     private static final CounterKey InstalledCodeSize = DebugContext.counter("InstalledCodeSize");
@@ -293,13 +299,14 @@
     /**
      * Time spent in code installation.
      */
     public static final TimerKey CodeInstallationTime = DebugContext.timer("CodeInstallation");
 
-    public HotSpotCompilationRequestResult runCompilation() {
-        SnippetReflectionProvider snippetReflection = compiler.getGraalRuntime().getHostProviders().getSnippetReflection();
-        try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(snippetReflection))) {
+    public HotSpotCompilationRequestResult runCompilation(OptionValues initialOptions) {
+        OptionValues options = filterOptions(initialOptions);
+        HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
+        try (DebugContext debug = graalRuntime.openDebugContext(options, compilationId, getMethod(), compiler.getDebugHandlersFactories(), DebugContext.DEFAULT_LOG_STREAM)) {
             return runCompilation(debug);
         }
     }
 
     @SuppressWarnings("try")
@@ -308,27 +315,23 @@
         GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
         int entryBCI = getEntryBCI();
         boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
         HotSpotResolvedJavaMethod method = getMethod();
 
-        // Log a compilation event.
-        EventProvider.CompilationEvent compilationEvent = eventProvider.newCompilationEvent();
-
-        if (installAsDefault) {
+        if (installAsDefault || isOSR) {
             // If there is already compiled code for this method on our level we simply return.
             // JVMCI compiles are always at the highest compile level, even in non-tiered mode so we
             // only need to check for that value.
             if (method.hasCodeAtLevel(entryBCI, config.compilationLevelFullOptimization)) {
                 return HotSpotCompilationRequestResult.failure("Already compiled", false);
             }
-            if (HotSpotGraalCompilerFactory.checkGraalCompileOnlyFilter(method.getDeclaringClass().toJavaName(), method.getName(), method.getSignature().toString(),
-                            HotSpotJVMCICompilerFactory.CompilationLevel.FullOptimization) != HotSpotJVMCICompilerFactory.CompilationLevel.FullOptimization) {
+            if (HotSpotGraalCompilerFactory.shouldExclude(method)) {
                 return HotSpotCompilationRequestResult.failure("GraalCompileOnly excluded", false);
             }
         }
 
-        HotSpotCompilationWrapper compilation = new HotSpotCompilationWrapper(compilationEvent);
+        HotSpotCompilationWrapper compilation = new HotSpotCompilationWrapper();
         try (DebugCloseable a = CompilationTime.start(debug)) {
             return compilation.run(debug);
         } finally {
             try {
                 int compiledBytecodes = 0;
@@ -341,22 +344,10 @@
                         codeSize = installedCode.getSize();
                         CompiledAndInstalledBytecodes.add(debug, compiledBytecodes);
                         InstalledCodeSize.add(debug, codeSize);
                     }
                 }
-
-                // Log a compilation event.
-                if (compilationEvent.shouldWrite()) {
-                    compilationEvent.setMethod(method.format("%H.%n(%p)"));
-                    compilationEvent.setCompileId(getId());
-                    compilationEvent.setCompileLevel(config.compilationLevelFullOptimization);
-                    compilationEvent.setSucceeded(compilation.result != null && installedCode != null);
-                    compilationEvent.setIsOsr(isOSR);
-                    compilationEvent.setCodeSize(codeSize);
-                    compilationEvent.setInlinedBytes(compiledBytecodes);
-                    compilationEvent.commit();
-                }
             } catch (Throwable t) {
                 return compilation.handleException(t);
             }
         }
     }

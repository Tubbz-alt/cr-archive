<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/NewObjectSnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot.replacements;
  26 
<a name="2" id="anc2"></a><span class="line-added">  27 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateRecompile;</span>
  28 import static jdk.vm.ci.meta.DeoptimizationAction.None;
  29 import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;
  30 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
<a name="3" id="anc3"></a><span class="line-added">  31 import static org.graalvm.compiler.core.common.GraalOptions.MinimalBulkZeroingSize;</span>
  32 import static org.graalvm.compiler.core.common.calc.UnsignedMath.belowThan;
  33 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_OPTIONVALUES;
  34 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
  35 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY;
  36 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY_OR_NULL;
  37 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE;
  38 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE_OR_NULL;
  39 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY;
  40 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY_OR_NULL;
  41 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_ARRAY_KLASS_LOCATION;
<a name="4" id="anc4"></a><span class="line-added">  42 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_INIT_STATE_LOCATION;</span>
  43 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_WRITE_LOCATION;
  44 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
  45 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.PROTOTYPE_MARK_WORD_LOCATION;
  46 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_END_LOCATION;
  47 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_TOP_LOCATION;
  48 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocateInstancePrefetchLines;
  49 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchDistance;
  50 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchLines;
  51 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchStepSize;
  52 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.allocatePrefetchStyle;
  53 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayAllocationSize;
  54 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayKlassOffset;
  55 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayLengthOffset;
  56 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.initializeObjectHeader;
  57 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.instanceHeaderSize;
<a name="5" id="anc5"></a><span class="line-added">  58 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.instanceKlassStateBeingInitialized;</span>
  59 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.isInstanceKlassFullyInitialized;
  60 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeMask;
  61 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeShift;
  62 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeMask;
  63 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeShift;
  64 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.loadKlassFromObject;
  65 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.prototypeMarkWordOffset;
<a name="6" id="anc6"></a><span class="line-added">  66 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readInstanceKlassInitState;</span>
<span class="line-added">  67 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readInstanceKlassInitThread;</span>
  68 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readLayoutHelper;
  69 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readTlabEnd;
  70 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readTlabTop;
  71 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.registerAsWord;
  72 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.useBiasedLocking;
  73 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.useTLAB;
  74 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.verifyOop;
  75 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.writeTlabTop;
  76 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocations;
  77 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocationsContext;
  78 import static org.graalvm.compiler.nodes.PiArrayNode.piArrayCastToSnippetReplaceeStamp;
  79 import static org.graalvm.compiler.nodes.PiNode.piCastToSnippetReplaceeStamp;
<a name="7" id="anc7"></a><span class="line-added">  80 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.DEOPT_PROBABILITY;</span>
  81 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FAST_PATH_PROBABILITY;
  82 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FREQUENT_PROBABILITY;
  83 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;
<a name="8" id="anc8"></a><span class="line-added">  84 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.VERY_FAST_PATH_PROBABILITY;</span>
  85 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
  86 import static org.graalvm.compiler.replacements.ReplacementsUtil.REPLACEMENTS_ASSERTIONS_ENABLED;
  87 import static org.graalvm.compiler.replacements.ReplacementsUtil.runtimeAssert;
  88 import static org.graalvm.compiler.replacements.ReplacementsUtil.staticAssert;
  89 import static org.graalvm.compiler.replacements.SnippetTemplate.DEFAULT_REPLACER;
  90 import static org.graalvm.compiler.replacements.nodes.CStringConstant.cstring;
  91 import static org.graalvm.compiler.replacements.nodes.ExplodeLoopNode.explodeLoop;
  92 
  93 import org.graalvm.compiler.api.replacements.Fold;
  94 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
  95 import org.graalvm.compiler.api.replacements.Snippet;
  96 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
  97 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
  98 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
  99 import org.graalvm.compiler.core.common.type.StampFactory;
 100 import org.graalvm.compiler.debug.DebugHandlersFactory;
 101 import org.graalvm.compiler.debug.GraalError;
 102 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 103 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 104 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 105 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 106 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
 107 import org.graalvm.compiler.hotspot.nodes.DimensionsNode;
<a name="9" id="anc9"></a><span class="line-added"> 108 import org.graalvm.compiler.hotspot.nodes.KlassBeingInitializedCheckNode;</span>
 109 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyFixedNode;
 110 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyNode;
 111 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 112 import org.graalvm.compiler.hotspot.word.KlassPointer;
 113 import org.graalvm.compiler.nodes.ConstantNode;
 114 import org.graalvm.compiler.nodes.DeoptimizeNode;
 115 import org.graalvm.compiler.nodes.PiNode;
 116 import org.graalvm.compiler.nodes.PrefetchAllocateNode;
 117 import org.graalvm.compiler.nodes.SnippetAnchorNode;
 118 import org.graalvm.compiler.nodes.StructuredGraph;
 119 import org.graalvm.compiler.nodes.ValueNode;
 120 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
 121 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
<a name="10" id="anc10"></a><span class="line-added"> 122 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;</span>
 123 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 124 import org.graalvm.compiler.nodes.extended.MembarNode;
 125 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
 126 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 127 import org.graalvm.compiler.nodes.java.NewArrayNode;
 128 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 129 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 130 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 131 import org.graalvm.compiler.nodes.spi.LoweringTool;
 132 import org.graalvm.compiler.nodes.util.GraphUtil;
 133 import org.graalvm.compiler.options.OptionValues;
 134 import org.graalvm.compiler.replacements.ReplacementsUtil;
 135 import org.graalvm.compiler.replacements.SnippetCounter;
 136 import org.graalvm.compiler.replacements.SnippetCounter.Group;
 137 import org.graalvm.compiler.replacements.SnippetTemplate;
 138 import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;
 139 import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
 140 import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
 141 import org.graalvm.compiler.replacements.Snippets;
 142 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
<a name="11" id="anc11"></a><span class="line-added"> 143 import org.graalvm.compiler.replacements.nodes.ZeroMemoryNode;</span>
 144 import org.graalvm.compiler.word.Word;
 145 import jdk.internal.vm.compiler.word.LocationIdentity;
 146 import jdk.internal.vm.compiler.word.WordFactory;
 147 
 148 import jdk.vm.ci.code.CodeUtil;
 149 import jdk.vm.ci.code.MemoryBarriers;
 150 import jdk.vm.ci.code.Register;
 151 import jdk.vm.ci.code.TargetDescription;
 152 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 153 import jdk.vm.ci.meta.JavaKind;
 154 import jdk.vm.ci.meta.ResolvedJavaType;
 155 
 156 /**
 157  * Snippets used for implementing NEW, ANEWARRAY and NEWARRAY.
 158  */
 159 public class NewObjectSnippets implements Snippets {
 160 
 161     enum ProfileContext {
 162         AllocatingMethod,
 163         InstanceOrArray,
 164         AllocatedType,
 165         AllocatedTypesInMethod,
 166         Total
 167     }
 168 
 169     @Fold
 170     static String createName(@Fold.InjectedParameter OptionValues options, String path, String typeContext) {
 171         switch (ProfileAllocationsContext.getValue(options)) {
 172             case AllocatingMethod:
 173                 return &quot;&quot;;
 174             case InstanceOrArray:
 175                 return path;
 176             case AllocatedType:
 177             case AllocatedTypesInMethod:
 178                 return typeContext;
 179             case Total:
 180                 return &quot;bytes&quot;;
 181             default:
 182                 throw GraalError.shouldNotReachHere();
 183         }
 184     }
 185 
 186     @Fold
 187     static boolean doProfile(@Fold.InjectedParameter OptionValues options) {
 188         return ProfileAllocations.getValue(options);
 189     }
 190 
 191     @Fold
 192     static boolean withContext(@Fold.InjectedParameter OptionValues options) {
 193         ProfileContext context = ProfileAllocationsContext.getValue(options);
 194         return context == ProfileContext.AllocatingMethod || context == ProfileContext.AllocatedTypesInMethod;
 195     }
 196 
 197     protected static void profileAllocation(String path, long size, String typeContext) {
 198         if (doProfile(INJECTED_OPTIONVALUES)) {
 199             String name = createName(INJECTED_OPTIONVALUES, path, typeContext);
 200 
 201             boolean context = withContext(INJECTED_OPTIONVALUES);
 202             DynamicCounterNode.counter(&quot;number of bytes allocated&quot;, name, size, context);
 203             DynamicCounterNode.counter(&quot;number of allocations&quot;, name, 1, context);
 204         }
 205     }
 206 
 207     public static void emitPrefetchAllocate(Word address, boolean isArray) {
 208         if (allocatePrefetchStyle(INJECTED_VMCONFIG) &gt; 0) {
 209             // Insert a prefetch for each allocation only on the fast-path
 210             // Generate several prefetch instructions.
 211             int lines = isArray ? allocatePrefetchLines(INJECTED_VMCONFIG) : allocateInstancePrefetchLines(INJECTED_VMCONFIG);
 212             int stepSize = allocatePrefetchStepSize(INJECTED_VMCONFIG);
 213             int distance = allocatePrefetchDistance(INJECTED_VMCONFIG);
 214             ExplodeLoopNode.explodeLoop();
 215             for (int i = 0; i &lt; lines; i++) {
 216                 PrefetchAllocateNode.prefetch(OffsetAddressNode.address(address, distance));
 217                 distance += stepSize;
 218             }
 219         }
 220     }
 221 
 222     @Snippet
<a name="12" id="anc12"></a><span class="line-modified"> 223     public static Object allocateInstance(@ConstantParameter long size,</span>
<span class="line-modified"> 224                     KlassPointer hub,</span>
<span class="line-added"> 225                     Word prototypeMarkWord,</span>
<span class="line-added"> 226                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 227                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 228                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 229                     @ConstantParameter boolean constantSize,</span>
<span class="line-added"> 230                     @ConstantParameter String typeContext,</span>
 231                     @ConstantParameter Counters counters) {
<a name="13" id="anc13"></a><span class="line-modified"> 232         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, hub, prototypeMarkWord, fillContents, emitMemoryBarrier, threadRegister, constantSize, typeContext, counters));</span>
 233     }
 234 
<a name="14" id="anc14"></a><span class="line-modified"> 235     public static Object allocateInstanceHelper(long size,</span>
<span class="line-modified"> 236                     KlassPointer hub,</span>
<span class="line-added"> 237                     Word prototypeMarkWord,</span>
<span class="line-added"> 238                     boolean fillContents,</span>
<span class="line-added"> 239                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 240                     Register threadRegister,</span>
<span class="line-added"> 241                     boolean constantSize,</span>
<span class="line-added"> 242                     String typeContext,</span>
<span class="line-added"> 243                     Counters counters) {</span>
 244         Object result;
 245         Word thread = registerAsWord(threadRegister);
 246         Word top = readTlabTop(thread);
 247         Word end = readTlabEnd(thread);
 248         Word newTop = top.add(WordFactory.unsigned(size));
 249         if (useTLAB(INJECTED_VMCONFIG) &amp;&amp; probability(FAST_PATH_PROBABILITY, newTop.belowOrEqual(end))) {
 250             writeTlabTop(thread, newTop);
 251             emitPrefetchAllocate(newTop, false);
<a name="15" id="anc15"></a><span class="line-modified"> 252             result = formatObject(hub, size, top, prototypeMarkWord, fillContents, emitMemoryBarrier, constantSize, counters);</span>
 253         } else {
 254             Counters theCounters = counters;
 255             if (theCounters != null &amp;&amp; theCounters.stub != null) {
 256                 theCounters.stub.inc();
 257             }
 258             result = newInstanceStub(hub);
 259         }
 260         profileAllocation(&quot;instance&quot;, size, typeContext);
 261         return verifyOop(result);
 262     }
 263 
 264     public static Object newInstanceStub(KlassPointer hub) {
 265         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 266             return nonNullOrDeopt(newInstanceOrNull(NEW_INSTANCE_OR_NULL, hub));
 267         } else {
 268             return newInstance(NEW_INSTANCE, hub);
 269         }
 270     }
 271 
 272     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 273     private static native Object newInstance(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub);
 274 
 275     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 276     private static native Object newInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub);
 277 
 278     @Snippet
<a name="16" id="anc16"></a><span class="line-modified"> 279     public static Object allocateInstancePIC(@ConstantParameter long size,</span>
<span class="line-modified"> 280                     KlassPointer hub,</span>
<span class="line-added"> 281                     Word prototypeMarkWord,</span>
<span class="line-added"> 282                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 283                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 284                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 285                     @ConstantParameter boolean constantSize,</span>
<span class="line-added"> 286                     @ConstantParameter String typeContext,</span>
 287                     @ConstantParameter Counters counters) {
 288         // Klass must be initialized by the time the first instance is allocated, therefore we can
 289         // just load it from the corresponding cell and avoid the resolution check. We have to use a
 290         // fixed load though, to prevent it from floating above the initialization.
 291         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
<a name="17" id="anc17"></a><span class="line-modified"> 292         return piCastToSnippetReplaceeStamp(allocateInstanceHelper(size, picHub, prototypeMarkWord, fillContents, emitMemoryBarrier, threadRegister, constantSize, typeContext, counters));</span>
 293     }
 294 
 295     @Snippet
<a name="18" id="anc18"></a><span class="line-modified"> 296     public static Object allocateInstanceDynamic(Class&lt;?&gt; type, Class&lt;?&gt; classClass,</span>
<span class="line-added"> 297                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 298                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 299                     @ConstantParameter Register threadRegister,</span>
 300                     @ConstantParameter Counters counters) {
<a name="19" id="anc19"></a><span class="line-modified"> 301         if (probability(DEOPT_PROBABILITY, type == null)) {</span>
 302             DeoptimizeNode.deopt(None, RuntimeConstraint);
 303         }
 304         Class&lt;?&gt; nonNullType = PiNode.piCastNonNullClass(type, SnippetAnchorNode.anchor());
 305 
<a name="20" id="anc20"></a><span class="line-modified"> 306         if (probability(DEOPT_PROBABILITY, DynamicNewInstanceNode.throwsInstantiationException(type, classClass))) {</span>
 307             DeoptimizeNode.deopt(None, RuntimeConstraint);
 308         }
 309 
<a name="21" id="anc21"></a><span class="line-modified"> 310         return PiNode.piCastToSnippetReplaceeStamp(allocateInstanceDynamicHelper(type, fillContents, emitMemoryBarrier, threadRegister, counters, nonNullType));</span>
 311     }
 312 
<a name="22" id="anc22"></a><span class="line-modified"> 313     private static Object allocateInstanceDynamicHelper(Class&lt;?&gt; type,</span>
<span class="line-added"> 314                     boolean fillContents,</span>
<span class="line-added"> 315                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 316                     Register threadRegister,</span>
<span class="line-added"> 317                     Counters counters,</span>
<span class="line-added"> 318                     Class&lt;?&gt; nonNullType) {</span>
 319         KlassPointer hub = ClassGetHubNode.readClass(nonNullType);
 320         if (probability(FAST_PATH_PROBABILITY, !hub.isNull())) {
 321             KlassPointer nonNullHub = ClassGetHubNode.piCastNonNull(hub, SnippetAnchorNode.anchor());
 322 
<a name="23" id="anc23"></a><span class="line-modified"> 323             if (probability(VERY_FAST_PATH_PROBABILITY, isInstanceKlassFullyInitialized(nonNullHub))) {</span>
 324                 int layoutHelper = readLayoutHelper(nonNullHub);
 325                 /*
 326                  * src/share/vm/oops/klass.hpp: For instances, layout helper is a positive number,
 327                  * the instance size. This size is already passed through align_object_size and
 328                  * scaled to bytes. The low order bit is set if instances of this class cannot be
 329                  * allocated using the fastpath.
 330                  */
 331                 if (probability(FAST_PATH_PROBABILITY, (layoutHelper &amp; 1) == 0)) {
 332                     Word prototypeMarkWord = nonNullHub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION);
 333                     /*
 334                      * FIXME(je,ds): we should actually pass typeContext instead of &quot;&quot; but late
 335                      * binding of parameters is not yet supported by the GraphBuilderPlugin system.
 336                      */
<a name="24" id="anc24"></a><span class="line-modified"> 337                     return allocateInstanceHelper(layoutHelper, nonNullHub, prototypeMarkWord, fillContents, emitMemoryBarrier, threadRegister, false, &quot;&quot;, counters);</span>
 338                 }
 339             } else {
 340                 DeoptimizeNode.deopt(None, RuntimeConstraint);
 341             }
 342         }
 343         return dynamicNewInstanceStub(type);
 344     }
 345 
 346     /**
 347      * Maximum array length for which fast path allocation is used.
 348      */
 349     public static final int MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH = 0x00FFFFFF;
 350 
 351     @Snippet
<a name="25" id="anc25"></a><span class="line-modified"> 352     public static Object allocatePrimitiveArrayPIC(KlassPointer hub,</span>
<span class="line-modified"> 353                     int length,</span>
<span class="line-added"> 354                     Word prototypeMarkWord,</span>
<span class="line-added"> 355                     @ConstantParameter int headerSize,</span>
<span class="line-added"> 356                     @ConstantParameter int log2ElementSize,</span>
<span class="line-added"> 357                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 358                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 359                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 360                     @ConstantParameter boolean maybeUnroll,</span>
<span class="line-added"> 361                     @ConstantParameter String typeContext,</span>
<span class="line-added"> 362                     @ConstantParameter boolean supportsBulkZeroing,</span>
 363                     @ConstantParameter Counters counters) {
 364         // Primitive array types are eagerly pre-resolved. We can use a floating load.
 365         KlassPointer picHub = LoadConstantIndirectlyNode.loadKlass(hub);
<a name="26" id="anc26"></a><span class="line-modified"> 366         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents,</span>
<span class="line-added"> 367                         emitMemoryBarrier, threadRegister, maybeUnroll, typeContext, supportsBulkZeroing, counters);</span>
 368     }
 369 
 370     @Snippet
<a name="27" id="anc27"></a><span class="line-modified"> 371     public static Object allocateArrayPIC(KlassPointer hub,</span>
<span class="line-modified"> 372                     int length,</span>
<span class="line-added"> 373                     Word prototypeMarkWord,</span>
<span class="line-added"> 374                     @ConstantParameter int headerSize,</span>
<span class="line-added"> 375                     @ConstantParameter int log2ElementSize,</span>
<span class="line-added"> 376                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 377                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 378                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 379                     @ConstantParameter boolean maybeUnroll,</span>
<span class="line-added"> 380                     @ConstantParameter String typeContext,</span>
<span class="line-added"> 381                     @ConstantParameter boolean supportsBulkZeroing,</span>
 382                     @ConstantParameter Counters counters) {
 383         // Array type would be resolved by dominating resolution.
 384         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
<a name="28" id="anc28"></a><span class="line-modified"> 385         return allocateArrayImpl(picHub, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents,</span>
<span class="line-added"> 386                         emitMemoryBarrier, threadRegister, maybeUnroll, typeContext, supportsBulkZeroing, counters);</span>
 387     }
 388 
 389     @Snippet
 390     public static Object allocateArray(KlassPointer hub,
 391                     int length,
 392                     Word prototypeMarkWord,
 393                     @ConstantParameter int headerSize,
 394                     @ConstantParameter int log2ElementSize,
 395                     @ConstantParameter boolean fillContents,
<a name="29" id="anc29"></a><span class="line-added"> 396                     @ConstantParameter boolean emitMemoryBarrier,</span>
 397                     @ConstantParameter Register threadRegister,
 398                     @ConstantParameter boolean maybeUnroll,
 399                     @ConstantParameter String typeContext,
<a name="30" id="anc30"></a><span class="line-added"> 400                     @ConstantParameter boolean supportsBulkZeroing,</span>
 401                     @ConstantParameter Counters counters) {
 402         Object result = allocateArrayImpl(hub,
 403                         length,
 404                         prototypeMarkWord,
 405                         headerSize,
 406                         log2ElementSize,
 407                         fillContents,
<a name="31" id="anc31"></a><span class="line-modified"> 408                         emitMemoryBarrier, threadRegister,</span>
 409                         maybeUnroll,
 410                         typeContext,
<a name="32" id="anc32"></a><span class="line-modified"> 411                         supportsBulkZeroing,</span>
 412                         counters);
 413         return piArrayCastToSnippetReplaceeStamp(verifyOop(result), length);
 414     }
 415 
 416     /**
 417      * When allocating on the slow path, determines whether to use a version of the runtime call
 418      * that returns {@code null} on a failed allocation instead of raising an OutOfMemoryError.
 419      */
 420     @Fold
 421     static boolean useNullAllocationStubs(@InjectedParameter GraalHotSpotVMConfig config) {
 422         return config.areNullAllocationStubsAvailable();
 423     }
 424 
<a name="33" id="anc33"></a><span class="line-modified"> 425     private static Object allocateArrayImpl(KlassPointer hub,</span>
<span class="line-modified"> 426                     int length,</span>
<span class="line-added"> 427                     Word prototypeMarkWord,</span>
<span class="line-added"> 428                     int headerSize,</span>
<span class="line-added"> 429                     int log2ElementSize,</span>
<span class="line-added"> 430                     boolean fillContents,</span>
<span class="line-added"> 431                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 432                     Register threadRegister,</span>
<span class="line-added"> 433                     boolean maybeUnroll,</span>
<span class="line-added"> 434                     String typeContext,</span>
<span class="line-added"> 435                     boolean supportsBulkZeroing,</span>
<span class="line-added"> 436                     Counters counters) {</span>
 437         Object result;
 438         long allocationSize = arrayAllocationSize(length, headerSize, log2ElementSize);
 439         Word thread = registerAsWord(threadRegister);
 440         Word top = readTlabTop(thread);
 441         Word end = readTlabEnd(thread);
 442         Word newTop = top.add(WordFactory.unsigned(allocationSize));
 443         if (probability(FREQUENT_PROBABILITY, belowThan(length, MAX_ARRAY_FAST_PATH_ALLOCATION_LENGTH)) &amp;&amp; useTLAB(INJECTED_VMCONFIG) &amp;&amp;
 444                         probability(FAST_PATH_PROBABILITY, newTop.belowOrEqual(end))) {
 445             writeTlabTop(thread, newTop);
 446             emitPrefetchAllocate(newTop, true);
 447             Counters theCounters = counters;
 448             if (theCounters != null &amp;&amp; theCounters.arrayLoopInit != null) {
 449                 theCounters.arrayLoopInit.inc();
 450             }
<a name="34" id="anc34"></a><span class="line-modified"> 451             result = formatArray(hub, allocationSize, length, headerSize, top, prototypeMarkWord, fillContents, emitMemoryBarrier, maybeUnroll, supportsBulkZeroing, counters);</span>
 452         } else {
 453             result = newArrayStub(hub, length);
 454         }
 455         profileAllocation(&quot;array&quot;, allocationSize, typeContext);
 456         return result;
 457     }
 458 
 459     public static Object newArrayStub(KlassPointer hub, int length) {
 460         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 461             return nonNullOrDeopt(newArrayOrNull(NEW_ARRAY_OR_NULL, hub, length));
 462         } else {
 463             return newArray(NEW_ARRAY, hub, length);
 464         }
 465     }
 466 
 467     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 468     private static native Object newArray(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int length);
 469 
 470     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 471     private static native Object newArrayOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int length);
 472 
 473     /**
 474      * New dynamic array stub that throws an {@link OutOfMemoryError} on allocation failure.
 475      */
 476     public static final ForeignCallDescriptor DYNAMIC_NEW_INSTANCE = new ForeignCallDescriptor(&quot;dynamic_new_instance&quot;, Object.class, Class.class);
 477 
 478     /**
 479      * New dynamic array stub that returns null on allocation failure.
 480      */
 481     public static final ForeignCallDescriptor DYNAMIC_NEW_INSTANCE_OR_NULL = new ForeignCallDescriptor(&quot;dynamic_new_instance_or_null&quot;, Object.class, Class.class);
 482 
 483     public static Object dynamicNewInstanceStub(Class&lt;?&gt; elementType) {
 484         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 485             return nonNullOrDeopt(dynamicNewInstanceOrNull(DYNAMIC_NEW_INSTANCE_OR_NULL, elementType));
 486         } else {
 487             return dynamicNewInstance(DYNAMIC_NEW_INSTANCE, elementType);
 488         }
 489     }
 490 
 491     /**
 492      * Deoptimizes if {@code obj == null} otherwise returns {@code obj}.
 493      */
 494     private static Object nonNullOrDeopt(Object obj) {
<a name="35" id="anc35"></a><span class="line-modified"> 495         if (BranchProbabilityNode.probability(BranchProbabilityNode.DEOPT_PROBABILITY, obj == null)) {</span>
 496             DeoptimizeNode.deopt(None, RuntimeConstraint);
 497         }
 498         return obj;
 499     }
 500 
 501     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 502     public static native Object dynamicNewInstance(@ConstantNodeParameter ForeignCallDescriptor descriptor, Class&lt;?&gt; elementType);
 503 
 504     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 505     public static native Object dynamicNewInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, Class&lt;?&gt; elementType);
 506 
 507     @Snippet
<a name="36" id="anc36"></a><span class="line-modified"> 508     public static Object allocateArrayDynamic(Class&lt;?&gt; elementType,</span>
<span class="line-modified"> 509                     Class&lt;?&gt; voidClass,</span>
<span class="line-added"> 510                     int length,</span>
<span class="line-added"> 511                     @ConstantParameter boolean fillContents,</span>
<span class="line-added"> 512                     @ConstantParameter boolean emitMemoryBarrier,</span>
<span class="line-added"> 513                     @ConstantParameter Register threadRegister,</span>
<span class="line-added"> 514                     @ConstantParameter JavaKind knownElementKind,</span>
<span class="line-added"> 515                     @ConstantParameter int knownLayoutHelper,</span>
<span class="line-added"> 516                     @ConstantParameter boolean supportsBulkZeroing,</span>
<span class="line-added"> 517                     Word prototypeMarkWord,</span>
 518                     @ConstantParameter Counters counters) {
<a name="37" id="anc37"></a><span class="line-modified"> 519         Object result = allocateArrayDynamicImpl(elementType, voidClass, length, fillContents, emitMemoryBarrier, threadRegister, knownElementKind,</span>
<span class="line-added"> 520                         knownLayoutHelper, supportsBulkZeroing, prototypeMarkWord, counters);</span>
 521         return result;
 522     }
 523 
<a name="38" id="anc38"></a><span class="line-modified"> 524     private static Object allocateArrayDynamicImpl(Class&lt;?&gt; elementType,</span>
<span class="line-modified"> 525                     Class&lt;?&gt; voidClass,</span>
<span class="line-added"> 526                     int length,</span>
<span class="line-added"> 527                     boolean fillContents,</span>
<span class="line-added"> 528                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 529                     Register threadRegister,</span>
<span class="line-added"> 530                     JavaKind knownElementKind,</span>
<span class="line-added"> 531                     int knownLayoutHelper,</span>
<span class="line-added"> 532                     boolean supportsBulkZeroing,</span>
<span class="line-added"> 533                     Word prototypeMarkWord,</span>
<span class="line-added"> 534                     Counters counters) {</span>
 535         /*
 536          * We only need the dynamic check for void when we have no static information from
 537          * knownElementKind.
 538          */
 539         staticAssert(knownElementKind != JavaKind.Void, &quot;unsupported knownElementKind&quot;);
 540         if (knownElementKind == JavaKind.Illegal &amp;&amp; probability(SLOW_PATH_PROBABILITY, elementType == null || DynamicNewArrayNode.throwsIllegalArgumentException(elementType, voidClass))) {
 541             DeoptimizeNode.deopt(None, RuntimeConstraint);
 542         }
 543 
 544         KlassPointer klass = loadKlassFromObject(elementType, arrayKlassOffset(INJECTED_VMCONFIG), CLASS_ARRAY_KLASS_LOCATION);
<a name="39" id="anc39"></a><span class="line-modified"> 545         if (probability(DEOPT_PROBABILITY, klass.isNull())) {</span>
 546             DeoptimizeNode.deopt(None, RuntimeConstraint);
 547         }
 548         KlassPointer nonNullKlass = ClassGetHubNode.piCastNonNull(klass, SnippetAnchorNode.anchor());
 549 
<a name="40" id="anc40"></a><span class="line-modified"> 550         if (probability(DEOPT_PROBABILITY, length &lt; 0)) {</span>
 551             DeoptimizeNode.deopt(None, RuntimeConstraint);
 552         }
 553         int layoutHelper;
 554         if (knownElementKind == JavaKind.Illegal) {
 555             layoutHelper = readLayoutHelper(nonNullKlass);
 556         } else {
 557             runtimeAssert(knownLayoutHelper == readLayoutHelper(nonNullKlass), &quot;layout mismatch&quot;);
 558             layoutHelper = knownLayoutHelper;
 559         }
 560         //@formatter:off
 561         // from src/share/vm/oops/klass.hpp:
 562         //
 563         // For arrays, layout helper is a negative number, containing four
 564         // distinct bytes, as follows:
 565         //    MSB:[tag, hsz, ebt, log2(esz)]:LSB
 566         // where:
 567         //    tag is 0x80 if the elements are oops, 0xC0 if non-oops
 568         //    hsz is array header size in bytes (i.e., offset of first element)
 569         //    ebt is the BasicType of the elements
 570         //    esz is the element size in bytes
 571         //@formatter:on
 572 
 573         int headerSize = (layoutHelper &gt;&gt; layoutHelperHeaderSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperHeaderSizeMask(INJECTED_VMCONFIG);
 574         int log2ElementSize = (layoutHelper &gt;&gt; layoutHelperLog2ElementSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperLog2ElementSizeMask(INJECTED_VMCONFIG);
 575 
<a name="41" id="anc41"></a><span class="line-modified"> 576         Object result = allocateArrayImpl(nonNullKlass, length, prototypeMarkWord, headerSize, log2ElementSize, fillContents,</span>
<span class="line-added"> 577                         emitMemoryBarrier, threadRegister, false, &quot;dynamic type&quot;, supportsBulkZeroing, counters);</span>
 578         return piArrayCastToSnippetReplaceeStamp(verifyOop(result), length);
 579     }
 580 
 581     /**
 582      * Calls the runtime stub for implementing MULTIANEWARRAY.
 583      */
 584     @Snippet
 585     private static Object newmultiarray(KlassPointer hub, @ConstantParameter int rank, @VarargsParameter int[] dimensions) {
 586         Word dims = DimensionsNode.allocaDimsArray(rank);
 587         ExplodeLoopNode.explodeLoop();
 588         for (int i = 0; i &lt; rank; i++) {
 589             dims.writeInt(i * 4, dimensions[i], LocationIdentity.init());
 590         }
 591         return newMultiArrayStub(hub, rank, dims);
 592     }
 593 
 594     private static Object newMultiArrayStub(KlassPointer hub, int rank, Word dims) {
 595         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
 596             return nonNullOrDeopt(newMultiArrayOrNull(NEW_MULTI_ARRAY_OR_NULL, hub, rank, dims));
 597         } else {
 598             return newMultiArray(NEW_MULTI_ARRAY, hub, rank, dims);
 599         }
 600     }
 601 
 602     @Snippet
 603     private static Object newmultiarrayPIC(KlassPointer hub, @ConstantParameter int rank, @VarargsParameter int[] dimensions) {
 604         // Array type would be resolved by dominating resolution.
 605         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
 606         return newmultiarray(picHub, rank, dimensions);
 607     }
 608 
 609     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
 610     private static native Object newMultiArray(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int rank, Word dims);
 611 
 612     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
 613     private static native Object newMultiArrayOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int rank, Word dims);
 614 
 615     /**
 616      * Maximum number of long stores to emit when zeroing an object with a constant size. Larger
 617      * objects have their bodies initialized in a loop.
 618      */
 619     private static final int MAX_UNROLLED_OBJECT_ZEROING_STORES = 8;
 620 
 621     /**
 622      * Zero uninitialized memory in a newly allocated object, unrolling as necessary and ensuring
 623      * that stores are aligned.
 624      *
<a name="42" id="anc42"></a>
 625      * @param memory beginning of object which is being zeroed
<a name="43" id="anc43"></a><span class="line-modified"> 626      * @param startOffset offset to begin zeroing (inclusive). May not be word aligned.</span>
<span class="line-modified"> 627      * @param endOffset offset to stop zeroing (exclusive). May not be word aligned.</span>
<span class="line-added"> 628      * @param isEndOffsetConstant is {@code endOffset} known to be constant in the snippet</span>
 629      * @param manualUnroll maximally unroll zeroing
<a name="44" id="anc44"></a><span class="line-added"> 630      * @param supportsBulkZeroing whether bulk zeroing is supported by the backend</span>
 631      */
<a name="45" id="anc45"></a><span class="line-modified"> 632     private static void zeroMemory(Word memory, int startOffset, long endOffset, boolean isEndOffsetConstant, boolean manualUnroll,</span>
<span class="line-modified"> 633                     boolean supportsBulkZeroing, Counters counters) {</span>
<span class="line-added"> 634         fillMemory(0, memory, startOffset, endOffset, isEndOffsetConstant, manualUnroll, supportsBulkZeroing, counters);</span>
 635     }
 636 
<a name="46" id="anc46"></a><span class="line-modified"> 637     private static void fillMemory(long value, Word memory, int startOffset, long endOffset, boolean constantOffsetLimit, boolean manualUnroll,</span>
<span class="line-modified"> 638                     boolean supportsBulkZeroing, Counters counters) {</span>
<span class="line-added"> 639         ReplacementsUtil.runtimeAssert((endOffset &amp; 0x7) == 0, &quot;unaligned object size&quot;);</span>
 640         int offset = startOffset;
 641         if ((offset &amp; 0x7) != 0) {
 642             memory.writeInt(offset, (int) value, LocationIdentity.init());
 643             offset += 4;
 644         }
 645         ReplacementsUtil.runtimeAssert((offset &amp; 0x7) == 0, &quot;unaligned offset&quot;);
 646         Counters theCounters = counters;
<a name="47" id="anc47"></a><span class="line-modified"> 647         if (manualUnroll &amp;&amp; ((endOffset - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="line-modified"> 648             ReplacementsUtil.staticAssert(!constantOffsetLimit, &quot;size shouldn&#39;t be constant at instantiation time&quot;);</span>
 649             // This case handles arrays of constant length. Instead of having a snippet variant for
 650             // each length, generate a chain of stores of maximum length. Once it&#39;s inlined the
 651             // break statement will trim excess stores.
 652             if (theCounters != null &amp;&amp; theCounters.instanceSeqInit != null) {
 653                 theCounters.instanceSeqInit.inc();
 654             }
 655 
 656             explodeLoop();
 657             for (int i = 0; i &lt; MAX_UNROLLED_OBJECT_ZEROING_STORES; i++, offset += 8) {
<a name="48" id="anc48"></a><span class="line-modified"> 658                 if (offset == endOffset) {</span>
 659                     break;
 660                 }
 661                 memory.initializeLong(offset, value, LocationIdentity.init());
 662             }
 663         } else {
 664             // Use Word instead of int to avoid extension to long in generated code
 665             Word off = WordFactory.signed(offset);
<a name="49" id="anc49"></a><span class="line-modified"> 666             if (supportsBulkZeroing &amp;&amp; value == 0 &amp;&amp; probability(SLOW_PATH_PROBABILITY, (endOffset - offset) &gt;= getMinimalBulkZeroingSize(INJECTED_OPTIONVALUES))) {</span>
<span class="line-modified"> 667                 if (theCounters != null &amp;&amp; theCounters.instanceBulkInit != null) {</span>
<span class="line-modified"> 668                     theCounters.instanceBulkInit.inc();</span>
 669                 }
<a name="50" id="anc50"></a><span class="line-modified"> 670                 ZeroMemoryNode.zero(memory.add(off), endOffset - offset, true, LocationIdentity.init());</span>
 671             } else {
<a name="51" id="anc51"></a><span class="line-modified"> 672                 if (constantOffsetLimit &amp;&amp; ((endOffset - offset) / 8) &lt;= MAX_UNROLLED_OBJECT_ZEROING_STORES) {</span>
<span class="line-modified"> 673                     if (theCounters != null &amp;&amp; theCounters.instanceSeqInit != null) {</span>
<span class="line-added"> 674                         theCounters.instanceSeqInit.inc();</span>
<span class="line-added"> 675                     }</span>
<span class="line-added"> 676                     explodeLoop();</span>
<span class="line-added"> 677                 } else {</span>
<span class="line-added"> 678                     if (theCounters != null &amp;&amp; theCounters.instanceLoopInit != null) {</span>
<span class="line-added"> 679                         theCounters.instanceLoopInit.inc();</span>
<span class="line-added"> 680                     }</span>
<span class="line-added"> 681                 }</span>
<span class="line-added"> 682                 for (; off.rawValue() &lt; endOffset; off = off.add(8)) {</span>
<span class="line-added"> 683                     memory.initializeLong(off, value, LocationIdentity.init());</span>
 684                 }
<a name="52" id="anc52"></a>


 685             }
 686         }
 687     }
 688 
<a name="53" id="anc53"></a><span class="line-added"> 689     @Fold</span>
<span class="line-added"> 690     static int getMinimalBulkZeroingSize(@InjectedParameter OptionValues optionValues) {</span>
<span class="line-added"> 691         return MinimalBulkZeroingSize.getValue(optionValues);</span>
<span class="line-added"> 692     }</span>
<span class="line-added"> 693 </span>
 694     /**
 695      * Fill uninitialized memory with garbage value in a newly allocated object, unrolling as
 696      * necessary and ensuring that stores are aligned.
 697      *
<a name="54" id="anc54"></a>
 698      * @param memory beginning of object which is being zeroed
<a name="55" id="anc55"></a><span class="line-modified"> 699      * @param startOffset offset to begin filling garbage value (inclusive). May not be word</span>
<span class="line-modified"> 700      *            aligned.</span>
<span class="line-added"> 701      * @param endOffset offset to stop filling garbage value (exclusive). May not be word aligned.</span>
<span class="line-added"> 702      * @param isEndOffsetConstant is {@code  endOffset} known to be constant in the snippet</span>
 703      * @param manualUnroll maximally unroll zeroing
 704      */
<a name="56" id="anc56"></a><span class="line-modified"> 705     private static void fillWithGarbage(Word memory, int startOffset, long endOffset, boolean isEndOffsetConstant, boolean manualUnroll, Counters counters) {</span>
<span class="line-modified"> 706         fillMemory(0xfefefefefefefefeL, memory, startOffset, endOffset, isEndOffsetConstant, manualUnroll, false, counters);</span>
 707     }
 708 
 709     /**
 710      * Formats some allocated memory with an object header and zeroes out the rest.
 711      */
<a name="57" id="anc57"></a><span class="line-modified"> 712     private static Object formatObject(KlassPointer hub,</span>
<span class="line-added"> 713                     long size,</span>
<span class="line-added"> 714                     Word memory,</span>
<span class="line-added"> 715                     Word compileTimePrototypeMarkWord,</span>
<span class="line-added"> 716                     boolean fillContents,</span>
<span class="line-added"> 717                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 718                     boolean constantSize,</span>
<span class="line-added"> 719                     Counters counters) {</span>
 720         Word prototypeMarkWord = useBiasedLocking(INJECTED_VMCONFIG) ? hub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION) : compileTimePrototypeMarkWord;
 721         initializeObjectHeader(memory, prototypeMarkWord, hub);
 722         if (fillContents) {
<a name="58" id="anc58"></a><span class="line-modified"> 723             zeroMemory(memory, instanceHeaderSize(INJECTED_VMCONFIG), size, constantSize, false, false, counters);</span>
 724         } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {
<a name="59" id="anc59"></a><span class="line-modified"> 725             fillWithGarbage(memory, instanceHeaderSize(INJECTED_VMCONFIG), size, constantSize, false, counters);</span>
<span class="line-added"> 726         }</span>
<span class="line-added"> 727         if (emitMemoryBarrier) {</span>
<span class="line-added"> 728             MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
 729         }
<a name="60" id="anc60"></a>
 730         return memory.toObjectNonNull();
 731     }
 732 
 733     @Snippet
 734     private static void verifyHeap(@ConstantParameter Register threadRegister) {
 735         Word thread = registerAsWord(threadRegister);
 736         Word topValue = readTlabTop(thread);
 737         if (!topValue.equal(WordFactory.zero())) {
 738             Word topValueContents = topValue.readWord(0, MARK_WORD_LOCATION);
 739             if (topValueContents.equal(WordFactory.zero())) {
 740                 AssertionSnippets.vmMessageC(AssertionSnippets.ASSERTION_VM_MESSAGE_C, true, cstring(&quot;overzeroing of TLAB detected&quot;), 0L, 0L, 0L);
 741             }
 742         }
 743     }
 744 
<a name="61" id="anc61"></a><span class="line-added"> 745     @Snippet</span>
<span class="line-added"> 746     private static void threadBeingInitializedCheck(@ConstantParameter Register threadRegister, KlassPointer klass) {</span>
<span class="line-added"> 747         int state = readInstanceKlassInitState(klass);</span>
<span class="line-added"> 748         if (state != instanceKlassStateBeingInitialized(INJECTED_VMCONFIG)) {</span>
<span class="line-added"> 749             // The klass is no longer being initialized so force recompilation</span>
<span class="line-added"> 750             DeoptimizeNode.deopt(InvalidateRecompile, RuntimeConstraint);</span>
<span class="line-added"> 751         } else if (registerAsWord(threadRegister) != readInstanceKlassInitThread(klass)) {</span>
<span class="line-added"> 752             // The klass is being initialized but this isn&#39;t the initializing thread so</span>
<span class="line-added"> 753             // so deopt and allow execution to resume in the interpreter where it should block.</span>
<span class="line-added"> 754             DeoptimizeNode.deopt(None, RuntimeConstraint);</span>
<span class="line-added"> 755         }</span>
<span class="line-added"> 756     }</span>
<span class="line-added"> 757 </span>
 758     /**
 759      * Formats some allocated memory with an object header and zeroes out the rest.
 760      */
<a name="62" id="anc62"></a><span class="line-modified"> 761     private static Object formatArray(KlassPointer hub,</span>
<span class="line-added"> 762                     long allocationSize,</span>
<span class="line-added"> 763                     int length,</span>
<span class="line-added"> 764                     int headerSize,</span>
<span class="line-added"> 765                     Word memory,</span>
<span class="line-added"> 766                     Word prototypeMarkWord,</span>
<span class="line-added"> 767                     boolean fillContents,</span>
<span class="line-added"> 768                     boolean emitMemoryBarrier,</span>
<span class="line-added"> 769                     boolean maybeUnroll,</span>
<span class="line-added"> 770                     boolean supportsBulkZeroing,</span>
 771                     Counters counters) {
 772         memory.writeInt(arrayLengthOffset(INJECTED_VMCONFIG), length, LocationIdentity.init());
 773         /*
 774          * store hub last as the concurrent garbage collectors assume length is valid if hub field
 775          * is not null
 776          */
 777         initializeObjectHeader(memory, prototypeMarkWord, hub);
 778         if (fillContents) {
<a name="63" id="anc63"></a><span class="line-modified"> 779             zeroMemory(memory, headerSize, allocationSize, false, maybeUnroll, supportsBulkZeroing, counters);</span>
 780         } else if (REPLACEMENTS_ASSERTIONS_ENABLED) {
<a name="64" id="anc64"></a><span class="line-modified"> 781             fillWithGarbage(memory, headerSize, allocationSize, false, maybeUnroll, counters);</span>
<span class="line-added"> 782         }</span>
<span class="line-added"> 783         if (emitMemoryBarrier) {</span>
<span class="line-added"> 784             MembarNode.memoryBarrier(MemoryBarriers.STORE_STORE, LocationIdentity.init());</span>
 785         }
<a name="65" id="anc65"></a>
 786         return memory.toObjectNonNull();
 787     }
 788 
 789     static class Counters {
 790         Counters(SnippetCounter.Group.Factory factory) {
 791             Group newInstance = factory.createSnippetCounterGroup(&quot;NewInstance&quot;);
 792             Group newArray = factory.createSnippetCounterGroup(&quot;NewArray&quot;);
 793             instanceSeqInit = new SnippetCounter(newInstance, &quot;tlabSeqInit&quot;, &quot;TLAB alloc with unrolled zeroing&quot;);
 794             instanceLoopInit = new SnippetCounter(newInstance, &quot;tlabLoopInit&quot;, &quot;TLAB alloc with zeroing in a loop&quot;);
<a name="66" id="anc66"></a><span class="line-added"> 795             instanceBulkInit = new SnippetCounter(newArray, &quot;tlabBulkInit&quot;, &quot;TLAB alloc with bulk zeroing&quot;);</span>
 796             arrayLoopInit = new SnippetCounter(newArray, &quot;tlabLoopInit&quot;, &quot;TLAB alloc with zeroing in a loop&quot;);
 797             stub = new SnippetCounter(newInstance, &quot;stub&quot;, &quot;alloc and zeroing via stub&quot;);
 798         }
 799 
 800         final SnippetCounter instanceSeqInit;
 801         final SnippetCounter instanceLoopInit;
<a name="67" id="anc67"></a><span class="line-added"> 802         final SnippetCounter instanceBulkInit;</span>
 803         final SnippetCounter arrayLoopInit;
 804         final SnippetCounter stub;
 805     }
 806 
 807     public static class Templates extends AbstractTemplates {
 808 
<a name="68" id="anc68"></a><span class="line-modified"> 809         private final SnippetInfo allocateInstance = snippet(NewObjectSnippets.class, &quot;allocateInstance&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION,</span>
<span class="line-added"> 810                         PROTOTYPE_MARK_WORD_LOCATION);</span>
 811         private final SnippetInfo allocateInstancePIC = snippet(NewObjectSnippets.class, &quot;allocateInstancePIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
<a name="69" id="anc69"></a><span class="line-modified"> 812                         TLAB_END_LOCATION, PROTOTYPE_MARK_WORD_LOCATION);</span>
 813         private final SnippetInfo allocateArray = snippet(NewObjectSnippets.class, &quot;allocateArray&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 814         private final SnippetInfo allocateArrayPIC = snippet(NewObjectSnippets.class, &quot;allocateArrayPIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 815         private final SnippetInfo allocatePrimitiveArrayPIC = snippet(NewObjectSnippets.class, &quot;allocatePrimitiveArrayPIC&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
 816                         TLAB_END_LOCATION);
 817         private final SnippetInfo allocateArrayDynamic = snippet(NewObjectSnippets.class, &quot;allocateArrayDynamic&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
 818                         TLAB_END_LOCATION);
 819         private final SnippetInfo allocateInstanceDynamic = snippet(NewObjectSnippets.class, &quot;allocateInstanceDynamic&quot;, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
<a name="70" id="anc70"></a><span class="line-modified"> 820                         TLAB_END_LOCATION, PROTOTYPE_MARK_WORD_LOCATION, CLASS_INIT_STATE_LOCATION);</span>
 821         private final SnippetInfo newmultiarray = snippet(NewObjectSnippets.class, &quot;newmultiarray&quot;, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 822         private final SnippetInfo newmultiarrayPIC = snippet(NewObjectSnippets.class, &quot;newmultiarrayPIC&quot;, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
 823         private final SnippetInfo verifyHeap = snippet(NewObjectSnippets.class, &quot;verifyHeap&quot;);
<a name="71" id="anc71"></a><span class="line-added"> 824         private final SnippetInfo threadBeingInitializedCheck = snippet(NewObjectSnippets.class, &quot;threadBeingInitializedCheck&quot;);</span>
 825         private final GraalHotSpotVMConfig config;
 826         private final Counters counters;
 827 
 828         public Templates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory factory, HotSpotProviders providers, TargetDescription target,
 829                         GraalHotSpotVMConfig config) {
 830             super(options, factories, providers, providers.getSnippetReflection(), target);
 831             this.config = config;
 832             counters = new Counters(factory);
 833         }
 834 
 835         /**
 836          * Lowers a {@link NewInstanceNode}.
 837          */
 838         public void lower(NewInstanceNode newInstanceNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 839             StructuredGraph graph = newInstanceNode.graph();
 840             HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) newInstanceNode.instanceClass();
 841             assert !type.isArray();
 842             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), type.klass(), providers.getMetaAccess(), graph);
 843             long size = instanceSize(type);
 844 
 845             OptionValues localOptions = graph.getOptions();
 846             SnippetInfo snippet = GeneratePIC.getValue(localOptions) ? allocateInstancePIC : allocateInstance;
 847             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
 848             args.addConst(&quot;size&quot;, size);
 849             args.add(&quot;hub&quot;, hub);
 850             args.add(&quot;prototypeMarkWord&quot;, type.prototypeMarkWord());
 851             args.addConst(&quot;fillContents&quot;, newInstanceNode.fillContents());
<a name="72" id="anc72"></a><span class="line-added"> 852             args.addConst(&quot;emitMemoryBarrier&quot;, newInstanceNode.emitMemoryBarrier());</span>
 853             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 854             args.addConst(&quot;constantSize&quot;, true);
 855             args.addConst(&quot;typeContext&quot;, ProfileAllocations.getValue(localOptions) ? type.toJavaName(false) : &quot;&quot;);
 856             args.addConst(&quot;counters&quot;, counters);
 857 
 858             SnippetTemplate template = template(newInstanceNode, args);
 859             graph.getDebug().log(&quot;Lowering allocateInstance in %s: node=%s, template=%s, arguments=%s&quot;, graph, newInstanceNode, template, args);
 860             template.instantiate(providers.getMetaAccess(), newInstanceNode, DEFAULT_REPLACER, args);
 861         }
 862 
 863         /**
 864          * Lowers a {@link NewArrayNode}.
 865          */
 866         public void lower(NewArrayNode newArrayNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 867             StructuredGraph graph = newArrayNode.graph();
 868             ResolvedJavaType elementType = newArrayNode.elementType();
 869             HotSpotResolvedObjectType arrayType = (HotSpotResolvedObjectType) elementType.getArrayClass();
 870             JavaKind elementKind = elementType.getJavaKind();
 871             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), arrayType.klass(), providers.getMetaAccess(), graph);
 872             final int headerSize = tool.getMetaAccess().getArrayBaseOffset(elementKind);
 873             int log2ElementSize = CodeUtil.log2(tool.getMetaAccess().getArrayIndexScale(elementKind));
 874 
 875             OptionValues localOptions = graph.getOptions();
 876             SnippetInfo snippet;
 877             if (GeneratePIC.getValue(localOptions)) {
 878                 if (elementType.isPrimitive()) {
 879                     snippet = allocatePrimitiveArrayPIC;
 880                 } else {
 881                     snippet = allocateArrayPIC;
 882                 }
 883             } else {
 884                 snippet = allocateArray;
 885             }
 886 
 887             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
 888             args.add(&quot;hub&quot;, hub);
 889             ValueNode length = newArrayNode.length();
 890             args.add(&quot;length&quot;, length.isAlive() ? length : graph.addOrUniqueWithInputs(length));
 891             assert arrayType.prototypeMarkWord() == lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord() : &quot;all array types are assumed to have the same prototypeMarkWord&quot;;
 892             args.add(&quot;prototypeMarkWord&quot;, arrayType.prototypeMarkWord());
 893             args.addConst(&quot;headerSize&quot;, headerSize);
 894             args.addConst(&quot;log2ElementSize&quot;, log2ElementSize);
 895             args.addConst(&quot;fillContents&quot;, newArrayNode.fillContents());
<a name="73" id="anc73"></a><span class="line-added"> 896             args.addConst(&quot;emitMemoryBarrier&quot;, newArrayNode.emitMemoryBarrier());</span>
 897             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 898             args.addConst(&quot;maybeUnroll&quot;, length.isConstant());
 899             args.addConst(&quot;typeContext&quot;, ProfileAllocations.getValue(localOptions) ? arrayType.toJavaName(false) : &quot;&quot;);
<a name="74" id="anc74"></a><span class="line-added"> 900             args.addConst(&quot;supportsBulkZeroing&quot;, tool.getLowerer().supportsBulkZeroing());</span>
 901             args.addConst(&quot;counters&quot;, counters);
 902             SnippetTemplate template = template(newArrayNode, args);
 903             graph.getDebug().log(&quot;Lowering allocateArray in %s: node=%s, template=%s, arguments=%s&quot;, graph, newArrayNode, template, args);
 904             template.instantiate(providers.getMetaAccess(), newArrayNode, DEFAULT_REPLACER, args);
 905         }
 906 
 907         public void lower(DynamicNewInstanceNode newInstanceNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 908             Arguments args = new Arguments(allocateInstanceDynamic, newInstanceNode.graph().getGuardsStage(), tool.getLoweringStage());
 909             args.add(&quot;type&quot;, newInstanceNode.getInstanceType());
 910             ValueNode classClass = newInstanceNode.getClassClass();
 911             assert classClass != null;
 912             args.add(&quot;classClass&quot;, classClass);
 913             args.addConst(&quot;fillContents&quot;, newInstanceNode.fillContents());
<a name="75" id="anc75"></a><span class="line-added"> 914             args.addConst(&quot;emitMemoryBarrier&quot;, newInstanceNode.emitMemoryBarrier());</span>
 915             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 916             args.addConst(&quot;counters&quot;, counters);
 917 
 918             SnippetTemplate template = template(newInstanceNode, args);
 919             template.instantiate(providers.getMetaAccess(), newInstanceNode, DEFAULT_REPLACER, args);
 920         }
 921 
 922         public void lower(DynamicNewArrayNode newArrayNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 923             StructuredGraph graph = newArrayNode.graph();
<a name="76" id="anc76"></a><span class="line-modified"> 924             Arguments args = new Arguments(allocateArrayDynamic, graph.getGuardsStage(), tool.getLoweringStage());</span>
 925             args.add(&quot;elementType&quot;, newArrayNode.getElementType());
 926             ValueNode voidClass = newArrayNode.getVoidClass();
 927             assert voidClass != null;
 928             args.add(&quot;voidClass&quot;, voidClass);
 929             ValueNode length = newArrayNode.length();
 930             args.add(&quot;length&quot;, length.isAlive() ? length : graph.addOrUniqueWithInputs(length));
 931             args.addConst(&quot;fillContents&quot;, newArrayNode.fillContents());
<a name="77" id="anc77"></a><span class="line-added"> 932             args.addConst(&quot;emitMemoryBarrier&quot;, newArrayNode.emitMemoryBarrier());</span>
 933             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 934             /*
 935              * We use Kind.Illegal as a marker value instead of null because constant snippet
 936              * parameters cannot be null.
 937              */
 938             args.addConst(&quot;knownElementKind&quot;, newArrayNode.getKnownElementKind() == null ? JavaKind.Illegal : newArrayNode.getKnownElementKind());
 939             if (newArrayNode.getKnownElementKind() != null) {
 940                 args.addConst(&quot;knownLayoutHelper&quot;, lookupArrayClass(tool, newArrayNode.getKnownElementKind()).layoutHelper());
 941             } else {
 942                 args.addConst(&quot;knownLayoutHelper&quot;, 0);
 943             }
<a name="78" id="anc78"></a><span class="line-added"> 944             args.addConst(&quot;supportsBulkZeroing&quot;, tool.getLowerer().supportsBulkZeroing());</span>
 945             args.add(&quot;prototypeMarkWord&quot;, lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord());
 946             args.addConst(&quot;counters&quot;, counters);
 947             SnippetTemplate template = template(newArrayNode, args);
 948             template.instantiate(providers.getMetaAccess(), newArrayNode, DEFAULT_REPLACER, args);
 949         }
 950 
 951         private static HotSpotResolvedObjectType lookupArrayClass(LoweringTool tool, JavaKind kind) {
 952             return (HotSpotResolvedObjectType) tool.getMetaAccess().lookupJavaType(kind == JavaKind.Object ? Object.class : kind.toJavaClass()).getArrayClass();
 953         }
 954 
 955         public void lower(NewMultiArrayNode newmultiarrayNode, LoweringTool tool) {
 956             StructuredGraph graph = newmultiarrayNode.graph();
 957             OptionValues localOptions = graph.getOptions();
 958             int rank = newmultiarrayNode.dimensionCount();
 959             ValueNode[] dims = new ValueNode[rank];
 960             for (int i = 0; i &lt; newmultiarrayNode.dimensionCount(); i++) {
 961                 dims[i] = newmultiarrayNode.dimension(i);
 962             }
 963             HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) newmultiarrayNode.type();
 964             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), type.klass(), providers.getMetaAccess(), graph);
 965 
 966             SnippetInfo snippet = GeneratePIC.getValue(localOptions) ? newmultiarrayPIC : newmultiarray;
 967             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
 968             args.add(&quot;hub&quot;, hub);
 969             args.addConst(&quot;rank&quot;, rank);
 970             args.addVarargs(&quot;dimensions&quot;, int.class, StampFactory.forKind(JavaKind.Int), dims);
 971             template(newmultiarrayNode, args).instantiate(providers.getMetaAccess(), newmultiarrayNode, DEFAULT_REPLACER, args);
 972         }
 973 
 974         private static long instanceSize(HotSpotResolvedObjectType type) {
 975             long size = type.instanceSize();
 976             assert size &gt;= 0;
 977             return size;
 978         }
 979 
 980         public void lower(VerifyHeapNode verifyHeapNode, HotSpotRegistersProvider registers, LoweringTool tool) {
 981             if (config.cAssertions) {
 982                 Arguments args = new Arguments(verifyHeap, verifyHeapNode.graph().getGuardsStage(), tool.getLoweringStage());
 983                 args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());
 984 
 985                 SnippetTemplate template = template(verifyHeapNode, args);
 986                 template.instantiate(providers.getMetaAccess(), verifyHeapNode, DEFAULT_REPLACER, args);
 987             } else {
 988                 GraphUtil.removeFixedWithUnusedInputs(verifyHeapNode);
 989             }
 990         }
<a name="79" id="anc79"></a><span class="line-added"> 991 </span>
<span class="line-added"> 992         public void lower(KlassBeingInitializedCheckNode verifyHeapNode, HotSpotRegistersProvider registers, LoweringTool tool) {</span>
<span class="line-added"> 993             Arguments args = new Arguments(threadBeingInitializedCheck, verifyHeapNode.graph().getGuardsStage(), tool.getLoweringStage());</span>
<span class="line-added"> 994             args.addConst(&quot;threadRegister&quot;, registers.getThreadRegister());</span>
<span class="line-added"> 995             args.add(&quot;klass&quot;, verifyHeapNode.getKlass());</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997             SnippetTemplate template = template(verifyHeapNode, args);</span>
<span class="line-added"> 998             template.instantiate(providers.getMetaAccess(), verifyHeapNode, DEFAULT_REPLACER, args);</span>
<span class="line-added"> 999         }</span>
1000     }
1001 }
<a name="80" id="anc80"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="80" type="hidden" />
</body>
</html>
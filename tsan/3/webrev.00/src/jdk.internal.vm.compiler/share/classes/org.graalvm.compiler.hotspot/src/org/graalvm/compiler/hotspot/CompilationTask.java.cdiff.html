<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationTask.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilationStatistics.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilationWatchDog.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationTask.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,64 ***</span>
  
  package org.graalvm.compiler.hotspot;
  
  import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Diagnose;
  import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.ExitVM;
<span class="line-modified">! import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAction;</span>
  import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
  import static org.graalvm.compiler.core.phases.HighTier.Options.Inline;
  import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
  
  import java.io.PrintStream;
  import java.util.List;
  
  import jdk.internal.vm.compiler.collections.EconomicMap;
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  import org.graalvm.compiler.code.CompilationResult;
  import org.graalvm.compiler.core.CompilationPrinter;
  import org.graalvm.compiler.core.CompilationWrapper;
  import org.graalvm.compiler.core.common.CompilationIdentifier;
<span class="line-removed">- import org.graalvm.compiler.debug.Assertions;</span>
  import org.graalvm.compiler.debug.CounterKey;
  import org.graalvm.compiler.debug.DebugCloseable;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.DebugDumpScope;
<span class="line-modified">! import org.graalvm.compiler.debug.GraalError;</span>
  import org.graalvm.compiler.debug.TimerKey;
<span class="line-removed">- import org.graalvm.compiler.options.EnumOptionKey;</span>
  import org.graalvm.compiler.options.OptionKey;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
  
  import jdk.vm.ci.code.BailoutException;
  import jdk.vm.ci.code.CodeCacheProvider;
<span class="line-removed">- import jdk.vm.ci.hotspot.EventProvider;</span>
  import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
  import jdk.vm.ci.hotspot.HotSpotCompilationRequestResult;
  import jdk.vm.ci.hotspot.HotSpotInstalledCode;
<span class="line-removed">- import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory;</span>
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
  import jdk.vm.ci.hotspot.HotSpotNmethod;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
  import jdk.vm.ci.runtime.JVMCICompiler;
<span class="line-removed">- import jdk.vm.ci.services.JVMCIServiceLocator;</span>
  
  public class CompilationTask {
  
<span class="line-removed">-     private static final EventProvider eventProvider;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static {</span>
<span class="line-removed">-         List&lt;EventProvider&gt; providers = JVMCIServiceLocator.getProviders(EventProvider.class);</span>
<span class="line-removed">-         if (providers.size() &gt; 1) {</span>
<span class="line-removed">-             throw new GraalError(&quot;Multiple %s providers found: %s&quot;, EventProvider.class.getName(), providers);</span>
<span class="line-removed">-         } else if (providers.isEmpty()) {</span>
<span class="line-removed">-             eventProvider = EventProvider.createEmptyEventProvider();</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             eventProvider = providers.get(0);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      private final HotSpotJVMCIRuntime jvmciRuntime;
  
      private final HotSpotGraalCompiler compiler;
      private final HotSpotCompilationIdentifier compilationId;
  
<span class="line-new-header">--- 24,49 ---</span>
  
  package org.graalvm.compiler.hotspot;
  
  import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Diagnose;
  import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.ExitVM;
<span class="line-modified">! import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAsFailure;</span>
  import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
  import static org.graalvm.compiler.core.phases.HighTier.Options.Inline;
  import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
  
  import java.io.PrintStream;
<span class="line-added">+ import java.util.Collections;</span>
  import java.util.List;
  
  import jdk.internal.vm.compiler.collections.EconomicMap;
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  import org.graalvm.compiler.code.CompilationResult;
  import org.graalvm.compiler.core.CompilationPrinter;
  import org.graalvm.compiler.core.CompilationWrapper;
  import org.graalvm.compiler.core.common.CompilationIdentifier;
  import org.graalvm.compiler.debug.CounterKey;
  import org.graalvm.compiler.debug.DebugCloseable;
  import org.graalvm.compiler.debug.DebugContext;
<span class="line-added">+ import org.graalvm.compiler.debug.DebugContext.Description;</span>
  import org.graalvm.compiler.debug.DebugDumpScope;
<span class="line-modified">! import org.graalvm.compiler.debug.DebugHandlersFactory;</span>
  import org.graalvm.compiler.debug.TimerKey;
  import org.graalvm.compiler.options.OptionKey;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
  
  import jdk.vm.ci.code.BailoutException;
  import jdk.vm.ci.code.CodeCacheProvider;
  import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
  import jdk.vm.ci.hotspot.HotSpotCompilationRequestResult;
  import jdk.vm.ci.hotspot.HotSpotInstalledCode;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
  import jdk.vm.ci.hotspot.HotSpotNmethod;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
<span class="line-added">+ import jdk.vm.ci.meta.ResolvedJavaMethod;</span>
  import jdk.vm.ci.runtime.JVMCICompiler;
  
  public class CompilationTask {
  
      private final HotSpotJVMCIRuntime jvmciRuntime;
  
      private final HotSpotGraalCompiler compiler;
      private final HotSpotCompilationIdentifier compilationId;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 92,30 ***</span>
       * {@linkplain HotSpotNmethod#isDefault() default} nmethod for the compiled method.
       */
      private final boolean installAsDefault;
  
      private final boolean useProfilingInfo;
<span class="line-modified">!     private final OptionValues options;</span>
  
      final class HotSpotCompilationWrapper extends CompilationWrapper&lt;HotSpotCompilationRequestResult&gt; {
<span class="line-removed">-         private final EventProvider.CompilationEvent compilationEvent;</span>
          CompilationResult result;
  
<span class="line-modified">!         HotSpotCompilationWrapper(EventProvider.CompilationEvent compilationEvent) {</span>
              super(compiler.getGraalRuntime().getOutputDirectory(), compiler.getGraalRuntime().getCompilationProblemsPerAction());
<span class="line-removed">-             this.compilationEvent = compilationEvent;</span>
          }
  
          @Override
<span class="line-modified">!         protected DebugContext createRetryDebugContext(OptionValues retryOptions, PrintStream logStream) {</span>
              SnippetReflectionProvider snippetReflection = compiler.getGraalRuntime().getHostProviders().getSnippetReflection();
<span class="line-modified">!             return DebugContext.create(retryOptions, logStream, new GraalDebugHandlersFactory(snippetReflection));</span>
          }
  
          @Override
          public String toString() {
<span class="line-modified">!             return getMethod().format(&quot;%H.%n(%p)&quot;);</span>
          }
  
          @Override
          protected HotSpotCompilationRequestResult handleException(Throwable t) {
              if (t instanceof BailoutException) {
<span class="line-new-header">--- 77,35 ---</span>
       * {@linkplain HotSpotNmethod#isDefault() default} nmethod for the compiled method.
       */
      private final boolean installAsDefault;
  
      private final boolean useProfilingInfo;
<span class="line-modified">!     private final boolean shouldRetainLocalVariables;</span>
  
      final class HotSpotCompilationWrapper extends CompilationWrapper&lt;HotSpotCompilationRequestResult&gt; {
          CompilationResult result;
  
<span class="line-modified">!         HotSpotCompilationWrapper() {</span>
              super(compiler.getGraalRuntime().getOutputDirectory(), compiler.getGraalRuntime().getCompilationProblemsPerAction());
          }
  
          @Override
<span class="line-modified">!         protected DebugContext createRetryDebugContext(DebugContext initialDebug, OptionValues retryOptions, PrintStream logStream) {</span>
              SnippetReflectionProvider snippetReflection = compiler.getGraalRuntime().getHostProviders().getSnippetReflection();
<span class="line-modified">!             Description description = initialDebug.getDescription();</span>
<span class="line-added">+             List&lt;DebugHandlersFactory&gt; factories = Collections.singletonList(new GraalDebugHandlersFactory(snippetReflection));</span>
<span class="line-added">+             return DebugContext.create(retryOptions, description, initialDebug.getGlobalMetrics(), logStream, factories);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected void exitHostVM(int status) {</span>
<span class="line-added">+             HotSpotGraalServices.exit(status);</span>
          }
  
          @Override
          public String toString() {
<span class="line-modified">!             return getMethod().format(&quot;%H.%n(%p) @ &quot; + getEntryBCI());</span>
          }
  
          @Override
          protected HotSpotCompilationRequestResult handleException(Throwable t) {
              if (t instanceof BailoutException) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,67 ***</span>
                   * not be retried. Hotspot compile broker will ensure that no recompilation at the
                   * given tier will happen if retry is false.
                   */
                  return HotSpotCompilationRequestResult.failure(bailout.getMessage(), !bailout.isPermanent());
              }
<span class="line-removed">-             // Log a failure event.</span>
<span class="line-removed">-             EventProvider.CompilerFailureEvent event = eventProvider.newCompilerFailureEvent();</span>
<span class="line-removed">-             if (event.shouldWrite()) {</span>
<span class="line-removed">-                 event.setCompileId(getId());</span>
<span class="line-removed">-                 event.setMessage(t.getMessage());</span>
<span class="line-removed">-                 event.commit();</span>
<span class="line-removed">-             }</span>
  
              /*
               * Treat random exceptions from the compiler as indicating a problem compiling this
               * method. Report the result of toString instead of getMessage to ensure that the
               * exception type is included in the output in case there&#39;s no detail mesage.
               */
              return HotSpotCompilationRequestResult.failure(t.toString(), false);
          }
  
          @Override
<span class="line-modified">!         protected ExceptionAction lookupAction(OptionValues values, EnumOptionKey&lt;ExceptionAction&gt; actionKey, Throwable cause) {</span>
<span class="line-modified">!             // Respect current action if it has been explicitly set.</span>
<span class="line-modified">!             if (!actionKey.hasBeenSet(values)) {</span>
<span class="line-modified">!                 if (actionKey == CompilationFailureAction) {</span>
<span class="line-modified">!                     // Automatically exit on non-bailout during bootstrap</span>
<span class="line-modified">!                     // or when assertions are enabled.</span>
<span class="line-modified">!                     if (Assertions.assertionsEnabled() || compiler.getGraalRuntime().isBootstrapping()) {</span>
<span class="line-modified">!                         return ExitVM;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 } else if (actionKey == CompilationBailoutAction &amp;&amp; ((BailoutException) cause).isPermanent()) {</span>
<span class="line-modified">!                     // Get more info for permanent bailouts during bootstrap</span>
<span class="line-removed">-                     // or when assertions are enabled.</span>
<span class="line-removed">-                     assert CompilationBailoutAction.getDefaultValue() == ExceptionAction.Silent;</span>
<span class="line-removed">-                     if (Assertions.assertionsEnabled() || compiler.getGraalRuntime().isBootstrapping()) {</span>
<span class="line-removed">-                         return Diagnose;</span>
                      }
                  }
              }
<span class="line-modified">!             return super.lookupAction(values, actionKey, cause);</span>
          }
  
          @SuppressWarnings(&quot;try&quot;)
          @Override
          protected HotSpotCompilationRequestResult performCompilation(DebugContext debug) {
              HotSpotResolvedJavaMethod method = getMethod();
              int entryBCI = getEntryBCI();
              final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
<span class="line-modified">!             CompilationStatistics stats = CompilationStatistics.create(options, method, isOSR);</span>
  
<span class="line-modified">!             final CompilationPrinter printer = CompilationPrinter.begin(options, compilationId, method, entryBCI);</span>
  
              try (DebugContext.Scope s = debug.scope(&quot;Compiling&quot;, new DebugDumpScope(getIdString(), true))) {
<span class="line-modified">!                 // Begin the compilation event.</span>
<span class="line-removed">-                 compilationEvent.begin();</span>
<span class="line-removed">-                 result = compiler.compile(method, entryBCI, useProfilingInfo, compilationId, options, debug);</span>
              } catch (Throwable e) {
                  throw debug.handle(e);
<span class="line-removed">-             } finally {</span>
<span class="line-removed">-                 // End the compilation event.</span>
<span class="line-removed">-                 compilationEvent.end();</span>
              }
  
              if (result != null) {
                  try (DebugCloseable b = CodeInstallationTime.start(debug)) {
                      installMethod(debug, result);
<span class="line-new-header">--- 116,62 ---</span>
                   * not be retried. Hotspot compile broker will ensure that no recompilation at the
                   * given tier will happen if retry is false.
                   */
                  return HotSpotCompilationRequestResult.failure(bailout.getMessage(), !bailout.isPermanent());
              }
  
              /*
               * Treat random exceptions from the compiler as indicating a problem compiling this
               * method. Report the result of toString instead of getMessage to ensure that the
               * exception type is included in the output in case there&#39;s no detail mesage.
               */
              return HotSpotCompilationRequestResult.failure(t.toString(), false);
          }
  
          @Override
<span class="line-modified">!         protected ExceptionAction lookupAction(OptionValues values, Throwable cause) {</span>
<span class="line-modified">!             if (cause instanceof BailoutException) {</span>
<span class="line-modified">!                 BailoutException bailout = (BailoutException) cause;</span>
<span class="line-modified">!                 if (bailout.isPermanent()) {</span>
<span class="line-modified">!                     // Respect current action if it has been explicitly set.</span>
<span class="line-modified">!                     if (!CompilationBailoutAsFailure.hasBeenSet(values)) {</span>
<span class="line-modified">!                         // Get more info for permanent bailouts during bootstrap.</span>
<span class="line-modified">!                         if (compiler.getGraalRuntime().isBootstrapping()) {</span>
<span class="line-modified">!                             return Diagnose;</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">! </span>
                      }
                  }
<span class="line-added">+                 if (!CompilationBailoutAsFailure.getValue(values)) {</span>
<span class="line-added">+                     return super.lookupAction(values, cause);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Respect current action if it has been explicitly set.</span>
<span class="line-added">+             if (!CompilationFailureAction.hasBeenSet(values)) {</span>
<span class="line-added">+                 // Automatically exit on failure during bootstrap.</span>
<span class="line-added">+                 if (compiler.getGraalRuntime().isBootstrapping()) {</span>
<span class="line-added">+                     return ExitVM;</span>
<span class="line-added">+                 }</span>
              }
<span class="line-modified">!             return super.lookupAction(values, cause);</span>
          }
  
          @SuppressWarnings(&quot;try&quot;)
          @Override
          protected HotSpotCompilationRequestResult performCompilation(DebugContext debug) {
              HotSpotResolvedJavaMethod method = getMethod();
              int entryBCI = getEntryBCI();
              final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
<span class="line-modified">!             CompilationStatistics stats = CompilationStatistics.create(debug.getOptions(), method, isOSR);</span>
  
<span class="line-modified">!             final CompilationPrinter printer = CompilationPrinter.begin(debug.getOptions(), compilationId, method, entryBCI);</span>
  
              try (DebugContext.Scope s = debug.scope(&quot;Compiling&quot;, new DebugDumpScope(getIdString(), true))) {
<span class="line-modified">!                 result = compiler.compile(method, entryBCI, useProfilingInfo, shouldRetainLocalVariables, compilationId, debug);</span>
              } catch (Throwable e) {
                  throw debug.handle(e);
              }
  
              if (result != null) {
                  try (DebugCloseable b = CodeInstallationTime.start(debug)) {
                      installMethod(debug, result);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 194,25 ***</span>
                  // Installation is included in compilation time and memory usage reported by printer
                  printer.finish(result);
              }
              stats.finish(method, installedCode);
              if (result != null) {
<span class="line-modified">!                 return HotSpotCompilationRequestResult.success(result.getBytecodeSize() - method.getCodeSize());</span>
              }
              return null;
          }
  
      }
  
<span class="line-modified">!     public CompilationTask(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalCompiler compiler, HotSpotCompilationRequest request, boolean useProfilingInfo, boolean installAsDefault,</span>
<span class="line-modified">!                     OptionValues options) {</span>
          this.jvmciRuntime = jvmciRuntime;
          this.compiler = compiler;
          this.compilationId = new HotSpotCompilationIdentifier(request);
          this.useProfilingInfo = useProfilingInfo;
          this.installAsDefault = installAsDefault;
  
          /*
           * Disable inlining if HotSpot has it disabled unless it&#39;s been explicitly set in Graal.
           */
          HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
          GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
<span class="line-new-header">--- 179,46 ---</span>
                  // Installation is included in compilation time and memory usage reported by printer
                  printer.finish(result);
              }
              stats.finish(method, installedCode);
              if (result != null) {
<span class="line-modified">!                 // For compilation of substitutions the method in the compilation request might be</span>
<span class="line-added">+                 // different than the actual method parsed. The root of the compilation will always</span>
<span class="line-added">+                 // be the first method in the methods list, so use that instead.</span>
<span class="line-added">+                 ResolvedJavaMethod rootMethod = result.getMethods()[0];</span>
<span class="line-added">+                 int inlinedBytecodes = result.getBytecodeSize() - rootMethod.getCodeSize();</span>
<span class="line-added">+                 assert inlinedBytecodes &gt;= 0 : rootMethod + &quot; &quot; + method;</span>
<span class="line-added">+                 return HotSpotCompilationRequestResult.success(inlinedBytecodes);</span>
              }
              return null;
          }
  
      }
  
<span class="line-modified">!     public CompilationTask(HotSpotJVMCIRuntime jvmciRuntime,</span>
<span class="line-modified">!                     HotSpotGraalCompiler compiler,</span>
<span class="line-added">+                     HotSpotCompilationRequest request,</span>
<span class="line-added">+                     boolean useProfilingInfo,</span>
<span class="line-added">+                     boolean installAsDefault) {</span>
<span class="line-added">+         this(jvmciRuntime, compiler, request, useProfilingInfo, false, installAsDefault);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public CompilationTask(HotSpotJVMCIRuntime jvmciRuntime,</span>
<span class="line-added">+                     HotSpotGraalCompiler compiler,</span>
<span class="line-added">+                     HotSpotCompilationRequest request,</span>
<span class="line-added">+                     boolean useProfilingInfo,</span>
<span class="line-added">+                     boolean shouldRetainLocalVariables,</span>
<span class="line-added">+                     boolean installAsDefault) {</span>
          this.jvmciRuntime = jvmciRuntime;
          this.compiler = compiler;
          this.compilationId = new HotSpotCompilationIdentifier(request);
          this.useProfilingInfo = useProfilingInfo;
<span class="line-added">+         this.shouldRetainLocalVariables = shouldRetainLocalVariables;</span>
          this.installAsDefault = installAsDefault;
<span class="line-added">+     }</span>
  
<span class="line-added">+     public OptionValues filterOptions(OptionValues options) {</span>
          /*
           * Disable inlining if HotSpot has it disabled unless it&#39;s been explicitly set in Graal.
           */
          HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
          GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,11 ***</span>
              }
              if (!m.isEmpty()) {
                  newOptions = new OptionValues(options, m);
              }
          }
<span class="line-modified">!         this.options = newOptions;</span>
      }
  
      public HotSpotResolvedJavaMethod getMethod() {
          return getRequest().getMethod();
      }
<span class="line-new-header">--- 233,11 ---</span>
              }
              if (!m.isEmpty()) {
                  newOptions = new OptionValues(options, m);
              }
          }
<span class="line-modified">!         return newOptions;</span>
      }
  
      public HotSpotResolvedJavaMethod getMethod() {
          return getRequest().getMethod();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,22 ***</span>
      }
  
      /**
       * Time spent in compilation.
       */
<span class="line-modified">!     private static final TimerKey CompilationTime = DebugContext.timer(&quot;CompilationTime&quot;).doc(&quot;Time spent in compilation and code installation.&quot;);</span>
  
      /**
       * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes}.
       */
      private static final CounterKey CompiledBytecodes = DebugContext.counter(&quot;CompiledBytecodes&quot;);
  
      /**
       * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes} for
       * which {@linkplain CompilationResult#getTargetCode()} code was installed.
       */
<span class="line-modified">!     private static final CounterKey CompiledAndInstalledBytecodes = DebugContext.counter(&quot;CompiledAndInstalledBytecodes&quot;);</span>
  
      /**
       * Counts the number of installed {@linkplain CompilationResult#getTargetCodeSize()} bytes.
       */
      private static final CounterKey InstalledCodeSize = DebugContext.counter(&quot;InstalledCodeSize&quot;);
<span class="line-new-header">--- 276,22 ---</span>
      }
  
      /**
       * Time spent in compilation.
       */
<span class="line-modified">!     public static final TimerKey CompilationTime = DebugContext.timer(&quot;CompilationTime&quot;).doc(&quot;Time spent in compilation and code installation.&quot;);</span>
  
      /**
       * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes}.
       */
      private static final CounterKey CompiledBytecodes = DebugContext.counter(&quot;CompiledBytecodes&quot;);
  
      /**
       * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes} for
       * which {@linkplain CompilationResult#getTargetCode()} code was installed.
       */
<span class="line-modified">!     public static final CounterKey CompiledAndInstalledBytecodes = DebugContext.counter(&quot;CompiledAndInstalledBytecodes&quot;);</span>
  
      /**
       * Counts the number of installed {@linkplain CompilationResult#getTargetCodeSize()} bytes.
       */
      private static final CounterKey InstalledCodeSize = DebugContext.counter(&quot;InstalledCodeSize&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 293,13 ***</span>
      /**
       * Time spent in code installation.
       */
      public static final TimerKey CodeInstallationTime = DebugContext.timer(&quot;CodeInstallation&quot;);
  
<span class="line-modified">!     public HotSpotCompilationRequestResult runCompilation() {</span>
<span class="line-modified">!         SnippetReflectionProvider snippetReflection = compiler.getGraalRuntime().getHostProviders().getSnippetReflection();</span>
<span class="line-modified">!         try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(snippetReflection))) {</span>
              return runCompilation(debug);
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-new-header">--- 299,14 ---</span>
      /**
       * Time spent in code installation.
       */
      public static final TimerKey CodeInstallationTime = DebugContext.timer(&quot;CodeInstallation&quot;);
  
<span class="line-modified">!     public HotSpotCompilationRequestResult runCompilation(OptionValues initialOptions) {</span>
<span class="line-modified">!         OptionValues options = filterOptions(initialOptions);</span>
<span class="line-modified">!         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();</span>
<span class="line-added">+         try (DebugContext debug = graalRuntime.openDebugContext(options, compilationId, getMethod(), compiler.getDebugHandlersFactories(), DebugContext.DEFAULT_LOG_STREAM)) {</span>
              return runCompilation(debug);
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,27 ***</span>
          GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
          int entryBCI = getEntryBCI();
          boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
          HotSpotResolvedJavaMethod method = getMethod();
  
<span class="line-modified">!         // Log a compilation event.</span>
<span class="line-removed">-         EventProvider.CompilationEvent compilationEvent = eventProvider.newCompilationEvent();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (installAsDefault) {</span>
              // If there is already compiled code for this method on our level we simply return.
              // JVMCI compiles are always at the highest compile level, even in non-tiered mode so we
              // only need to check for that value.
              if (method.hasCodeAtLevel(entryBCI, config.compilationLevelFullOptimization)) {
                  return HotSpotCompilationRequestResult.failure(&quot;Already compiled&quot;, false);
              }
<span class="line-modified">!             if (HotSpotGraalCompilerFactory.checkGraalCompileOnlyFilter(method.getDeclaringClass().toJavaName(), method.getName(), method.getSignature().toString(),</span>
<span class="line-removed">-                             HotSpotJVMCICompilerFactory.CompilationLevel.FullOptimization) != HotSpotJVMCICompilerFactory.CompilationLevel.FullOptimization) {</span>
                  return HotSpotCompilationRequestResult.failure(&quot;GraalCompileOnly excluded&quot;, false);
              }
          }
  
<span class="line-modified">!         HotSpotCompilationWrapper compilation = new HotSpotCompilationWrapper(compilationEvent);</span>
          try (DebugCloseable a = CompilationTime.start(debug)) {
              return compilation.run(debug);
          } finally {
              try {
                  int compiledBytecodes = 0;
<span class="line-new-header">--- 315,23 ---</span>
          GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
          int entryBCI = getEntryBCI();
          boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
          HotSpotResolvedJavaMethod method = getMethod();
  
<span class="line-modified">!         if (installAsDefault || isOSR) {</span>
              // If there is already compiled code for this method on our level we simply return.
              // JVMCI compiles are always at the highest compile level, even in non-tiered mode so we
              // only need to check for that value.
              if (method.hasCodeAtLevel(entryBCI, config.compilationLevelFullOptimization)) {
                  return HotSpotCompilationRequestResult.failure(&quot;Already compiled&quot;, false);
              }
<span class="line-modified">!             if (HotSpotGraalCompilerFactory.shouldExclude(method)) {</span>
                  return HotSpotCompilationRequestResult.failure(&quot;GraalCompileOnly excluded&quot;, false);
              }
          }
  
<span class="line-modified">!         HotSpotCompilationWrapper compilation = new HotSpotCompilationWrapper();</span>
          try (DebugCloseable a = CompilationTime.start(debug)) {
              return compilation.run(debug);
          } finally {
              try {
                  int compiledBytecodes = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,22 ***</span>
                          codeSize = installedCode.getSize();
                          CompiledAndInstalledBytecodes.add(debug, compiledBytecodes);
                          InstalledCodeSize.add(debug, codeSize);
                      }
                  }
<span class="line-removed">- </span>
<span class="line-removed">-                 // Log a compilation event.</span>
<span class="line-removed">-                 if (compilationEvent.shouldWrite()) {</span>
<span class="line-removed">-                     compilationEvent.setMethod(method.format(&quot;%H.%n(%p)&quot;));</span>
<span class="line-removed">-                     compilationEvent.setCompileId(getId());</span>
<span class="line-removed">-                     compilationEvent.setCompileLevel(config.compilationLevelFullOptimization);</span>
<span class="line-removed">-                     compilationEvent.setSucceeded(compilation.result != null &amp;&amp; installedCode != null);</span>
<span class="line-removed">-                     compilationEvent.setIsOsr(isOSR);</span>
<span class="line-removed">-                     compilationEvent.setCodeSize(codeSize);</span>
<span class="line-removed">-                     compilationEvent.setInlinedBytes(compiledBytecodes);</span>
<span class="line-removed">-                     compilationEvent.commit();</span>
<span class="line-removed">-                 }</span>
              } catch (Throwable t) {
                  return compilation.handleException(t);
              }
          }
      }
<span class="line-new-header">--- 344,10 ---</span>
</pre>
<center><a href="CompilationStatistics.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilationWatchDog.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
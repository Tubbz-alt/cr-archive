<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
<a name="1" id="anc1"></a>
 28 import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
 29 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 30 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.JAVA_THREAD_THREAD_OBJECT_LOCATION;
 31 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
<a name="2" id="anc2"></a><span class="line-removed"> 32 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;</span>
 33 
 34 import java.lang.invoke.ConstantCallSite;
 35 import java.lang.invoke.MutableCallSite;
 36 import java.lang.invoke.VolatileCallSite;
 37 import java.lang.reflect.Array;
<a name="3" id="anc3"></a>
 38 import java.math.BigInteger;
 39 import java.util.zip.CRC32;
 40 
<a name="4" id="anc4"></a>
 41 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
<a name="5" id="anc5"></a><span class="line-removed"> 42 import org.graalvm.compiler.bytecode.BytecodeProvider;</span>
 43 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 44 import org.graalvm.compiler.core.common.type.ObjectStamp;
 45 import org.graalvm.compiler.core.common.type.StampFactory;
 46 import org.graalvm.compiler.core.common.type.TypeReference;
<a name="6" id="anc6"></a>
 47 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<a name="7" id="anc7"></a>
 48 import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
 49 import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
 50 import org.graalvm.compiler.hotspot.replacements.ArraysSupportSubstitutions;
 51 import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
 52 import org.graalvm.compiler.hotspot.replacements.CRC32CSubstitutions;
 53 import org.graalvm.compiler.hotspot.replacements.CRC32Substitutions;
 54 import org.graalvm.compiler.hotspot.replacements.CallSiteTargetNode;
 55 import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
 56 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
 57 import org.graalvm.compiler.hotspot.replacements.CounterModeSubstitutions;
 58 import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;
<a name="8" id="anc8"></a>
 59 import org.graalvm.compiler.hotspot.replacements.HotSpotArraySubstitutions;
 60 import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;
 61 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 62 import org.graalvm.compiler.hotspot.replacements.ObjectCloneNode;
<a name="9" id="anc9"></a><span class="line-removed"> 63 import org.graalvm.compiler.hotspot.replacements.ObjectSubstitutions;</span>
 64 import org.graalvm.compiler.hotspot.replacements.ReflectionGetCallerClassNode;
 65 import org.graalvm.compiler.hotspot.replacements.ReflectionSubstitutions;
 66 import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
 67 import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
 68 import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
 69 import org.graalvm.compiler.hotspot.replacements.StringUTF16Substitutions;
 70 import org.graalvm.compiler.hotspot.replacements.ThreadSubstitutions;
 71 import org.graalvm.compiler.hotspot.word.HotSpotWordTypes;
 72 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 73 import org.graalvm.compiler.nodes.ConstantNode;
 74 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 75 import org.graalvm.compiler.nodes.NodeView;
 76 import org.graalvm.compiler.nodes.ValueNode;
 77 import org.graalvm.compiler.nodes.calc.AddNode;
 78 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
 79 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 80 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 81 import org.graalvm.compiler.nodes.graphbuilderconf.ForeignCallPlugin;
 82 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 83 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 84 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 85 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 86 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 87 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 88 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;
 89 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
 90 import org.graalvm.compiler.nodes.memory.ReadNode;
 91 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 92 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<a name="10" id="anc10"></a>
 93 import org.graalvm.compiler.nodes.util.GraphUtil;
 94 import org.graalvm.compiler.options.OptionValues;
 95 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
 96 import org.graalvm.compiler.replacements.InlineDuringParsingPlugin;
 97 import org.graalvm.compiler.replacements.MethodHandlePlugin;
 98 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;
 99 import org.graalvm.compiler.replacements.ReplacementsImpl;
100 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins;
101 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
102 import org.graalvm.compiler.serviceprovider.GraalServices;
<a name="11" id="anc11"></a>
103 import org.graalvm.compiler.word.WordOperationPlugin;
104 import org.graalvm.compiler.word.WordTypes;
105 import jdk.internal.vm.compiler.word.LocationIdentity;
106 
107 import jdk.vm.ci.code.CodeUtil;
<a name="12" id="anc12"></a>

108 import jdk.vm.ci.meta.ConstantReflectionProvider;
109 import jdk.vm.ci.meta.DeoptimizationAction;
110 import jdk.vm.ci.meta.JavaKind;
111 import jdk.vm.ci.meta.MetaAccessProvider;
112 import jdk.vm.ci.meta.ResolvedJavaMethod;
<a name="13" id="anc13"></a>
113 import sun.misc.Unsafe;
114 
115 /**
116  * Defines the {@link Plugins} used when running on HotSpot.
117  */
118 public class HotSpotGraphBuilderPlugins {
119 
120     /**
121      * Creates a {@link Plugins} object that should be used when running on HotSpot.
122      *
123      * @param constantReflection
124      * @param snippetReflection
125      * @param foreignCalls
<a name="14" id="anc14"></a>

126      */
<a name="15" id="anc15"></a><span class="line-modified">127     public static Plugins create(CompilerConfiguration compilerConfiguration, GraalHotSpotVMConfig config, HotSpotWordTypes wordTypes, MetaAccessProvider metaAccess,</span>
<span class="line-modified">128                     ConstantReflectionProvider constantReflection, SnippetReflectionProvider snippetReflection, ForeignCallsProvider foreignCalls, ReplacementsImpl replacements) {</span>
<span class="line-modified">129         InvocationPlugins invocationPlugins = new HotSpotInvocationPlugins(config, compilerConfiguration);</span>








130 
131         Plugins plugins = new Plugins(invocationPlugins);
<a name="16" id="anc16"></a><span class="line-modified">132         NodeIntrinsificationProvider nodeIntrinsificationProvider = new NodeIntrinsificationProvider(metaAccess, snippetReflection, foreignCalls, wordTypes);</span>
133         HotSpotWordOperationPlugin wordOperationPlugin = new HotSpotWordOperationPlugin(snippetReflection, wordTypes);
134         HotSpotNodePlugin nodePlugin = new HotSpotNodePlugin(wordOperationPlugin, config, wordTypes);
135 
136         plugins.appendTypePlugin(nodePlugin);
137         plugins.appendNodePlugin(nodePlugin);
<a name="17" id="anc17"></a><span class="line-removed">138         OptionValues options = replacements.getOptions();</span>
139         if (!GeneratePIC.getValue(options)) {
140             plugins.appendNodePlugin(new MethodHandlePlugin(constantReflection.getMethodHandleAccess(), true));
141         }
142         plugins.appendInlineInvokePlugin(replacements);
143         if (InlineDuringParsing.getValue(options)) {
144             plugins.appendInlineInvokePlugin(new InlineDuringParsingPlugin());
145         }
146 
147         if (GeneratePIC.getValue(options)) {
<a name="18" id="anc18"></a><span class="line-modified">148             plugins.setClassInitializationPlugin(new HotSpotClassInitializationPlugin());</span>
149             if (TieredAOT.getValue(options)) {
150                 plugins.setProfilingPlugin(new HotSpotAOTProfilingPlugin());
151             }
<a name="19" id="anc19"></a>



152         }
153 
154         invocationPlugins.defer(new Runnable() {
155 
156             @Override
157             public void run() {
<a name="20" id="anc20"></a><span class="line-modified">158                 BytecodeProvider replacementBytecodeProvider = replacements.getDefaultReplacementBytecodeProvider();</span>
<span class="line-modified">159                 registerObjectPlugins(invocationPlugins, options, config, replacementBytecodeProvider);</span>
<span class="line-removed">160                 registerClassPlugins(plugins, config, replacementBytecodeProvider);</span>
161                 registerSystemPlugins(invocationPlugins, foreignCalls);
<a name="21" id="anc21"></a><span class="line-modified">162                 registerThreadPlugins(invocationPlugins, metaAccess, wordTypes, config, replacementBytecodeProvider);</span>
163                 if (!GeneratePIC.getValue(options)) {
164                     registerCallSitePlugins(invocationPlugins);
165                 }
<a name="22" id="anc22"></a><span class="line-modified">166                 registerReflectionPlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">167                 registerConstantPoolPlugins(invocationPlugins, wordTypes, config, replacementBytecodeProvider);</span>
<span class="line-modified">168                 registerAESPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">169                 registerCRC32Plugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">170                 registerCRC32CPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">171                 registerBigIntegerPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">172                 registerSHAPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
173                 registerGHASHPlugins(invocationPlugins, config, metaAccess, foreignCalls);
<a name="23" id="anc23"></a><span class="line-modified">174                 registerCounterModePlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">175                 registerUnsafePlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">176                 StandardGraphBuilderPlugins.registerInvocationPlugins(metaAccess, snippetReflection, invocationPlugins, replacementBytecodeProvider, true, false);</span>
<span class="line-modified">177                 registerArrayPlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">178                 registerStringPlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">179                 registerArraysSupportPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>

180 
181                 for (NodeIntrinsicPluginFactory factory : GraalServices.load(NodeIntrinsicPluginFactory.class)) {
182                     factory.registerPlugins(invocationPlugins, nodeIntrinsificationProvider);
183                 }
184             }
185         });
186         return plugins;
187     }
188 
<a name="24" id="anc24"></a><span class="line-modified">189     private static void registerObjectPlugins(InvocationPlugins plugins, OptionValues options, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">190         Registration r = new Registration(plugins, Object.class, bytecodeProvider);</span>
191         if (!GeneratePIC.getValue(options)) {
192             // FIXME: clone() requires speculation and requires a fix in here (to check that
193             // b.getAssumptions() != null), and in ReplacementImpl.getSubstitution() where there is
194             // an instantiation of IntrinsicGraphBuilder using a constructor that sets
195             // AllowAssumptions to YES automatically. The former has to inherit the assumptions
196             // settings from the root compile instead. So, for now, I&#39;m disabling it for
197             // GeneratePIC.
198             r.register1(&quot;clone&quot;, Receiver.class, new InvocationPlugin() {
199                 @Override
200                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
201                     ValueNode object = receiver.get();
202                     b.addPush(JavaKind.Object, new ObjectCloneNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), object));
203                     return true;
204                 }
205 
206                 @Override
207                 public boolean inlineOnly() {
208                     return true;
209                 }
210             });
211         }
<a name="25" id="anc25"></a><span class="line-modified">212         r.registerMethodSubstitution(ObjectSubstitutions.class, &quot;hashCode&quot;, Receiver.class);</span>












213         if (config.inlineNotify()) {
<a name="26" id="anc26"></a><span class="line-modified">214             r.registerMethodSubstitution(ObjectSubstitutions.class, &quot;notify&quot;, Receiver.class);</span>












215         }
216         if (config.inlineNotifyAll()) {
<a name="27" id="anc27"></a><span class="line-modified">217             r.registerMethodSubstitution(ObjectSubstitutions.class, &quot;notifyAll&quot;, Receiver.class);</span>












218         }
219     }
220 
<a name="28" id="anc28"></a><span class="line-modified">221     private static void registerClassPlugins(Plugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">222         Registration r = new Registration(plugins.getInvocationPlugins(), Class.class, bytecodeProvider);</span>
223 
224         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getModifiers&quot;, Receiver.class);
225         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isInterface&quot;, Receiver.class);
226         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isArray&quot;, Receiver.class);
227         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isPrimitive&quot;, Receiver.class);
228         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getSuperclass&quot;, Receiver.class);
229 
230         if (config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;, Integer.MAX_VALUE) != Integer.MAX_VALUE) {
231             r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getComponentType&quot;, Receiver.class);
232         }
233     }
234 
235     private static void registerCallSitePlugins(InvocationPlugins plugins) {
236         InvocationPlugin plugin = new InvocationPlugin() {
237             @Override
238             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
239                 ValueNode callSite = receiver.get();
<a name="29" id="anc29"></a><span class="line-modified">240                 ValueNode folded = CallSiteTargetNode.tryFold(GraphUtil.originalValue(callSite), b.getMetaAccess(), b.getAssumptions());</span>
241                 if (folded != null) {
242                     b.addPush(JavaKind.Object, folded);
243                 } else {
244                     b.addPush(JavaKind.Object, new CallSiteTargetNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), callSite));
245                 }
246                 return true;
247             }
248 
249             @Override
250             public boolean inlineOnly() {
251                 return true;
252             }
253         };
254         plugins.register(plugin, ConstantCallSite.class, &quot;getTarget&quot;, Receiver.class);
255         plugins.register(plugin, MutableCallSite.class, &quot;getTarget&quot;, Receiver.class);
256         plugins.register(plugin, VolatileCallSite.class, &quot;getTarget&quot;, Receiver.class);
257     }
258 
<a name="30" id="anc30"></a><span class="line-modified">259     private static void registerReflectionPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">260         Registration r = new Registration(plugins, reflectionClass, bytecodeProvider);</span>
261         r.register0(&quot;getCallerClass&quot;, new InvocationPlugin() {
262             @Override
263             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
264                 b.addPush(JavaKind.Object, new ReflectionGetCallerClassNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions())));
265                 return true;
266             }
267 
268             @Override
269             public boolean inlineOnly() {
270                 return true;
271             }
272         });
273         r.registerMethodSubstitution(ReflectionSubstitutions.class, &quot;getClassAccessFlags&quot;, Class.class);
274     }
275 
<a name="31" id="anc31"></a><span class="line-modified">276     private static void registerUnsafePlugins(InvocationPlugins plugins, BytecodeProvider replacementBytecodeProvider) {</span>
277         Registration r;
<a name="32" id="anc32"></a><span class="line-modified">278         if (Java8OrEarlier) {</span>
<span class="line-modified">279             r = new Registration(plugins, Unsafe.class, replacementBytecodeProvider);</span>
280         } else {
<a name="33" id="anc33"></a><span class="line-modified">281             r = new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacementBytecodeProvider);</span>
282         }
<a name="34" id="anc34"></a><span class="line-modified">283         r.registerMethodSubstitution(HotSpotUnsafeSubstitutions.class, HotSpotUnsafeSubstitutions.copyMemoryName, &quot;copyMemory&quot;, Receiver.class, Object.class, long.class, Object.class, long.class,</span>
<span class="line-modified">284                         long.class);</span>

285     }
286 
287     private static final LocationIdentity INSTANCE_KLASS_CONSTANTS = NamedLocationIdentity.immutable(&quot;InstanceKlass::_constants&quot;);
288     private static final LocationIdentity CONSTANT_POOL_LENGTH = NamedLocationIdentity.immutable(&quot;ConstantPool::_length&quot;);
289 
290     /**
291      * Emits a node to get the metaspace {@code ConstantPool} pointer given the value of the
292      * {@code constantPoolOop} field in a ConstantPool value.
293      *
294      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
295      * @return a node representing the metaspace {@code ConstantPool} pointer associated with
296      *         {@code constantPoolOop}
297      */
298     private static ValueNode getMetaspaceConstantPool(GraphBuilderContext b, ValueNode constantPoolOop, WordTypes wordTypes, GraalHotSpotVMConfig config) {
299         // ConstantPool.constantPoolOop is in fact the holder class.
300         ValueNode value = b.nullCheckedValue(constantPoolOop, DeoptimizationAction.None);
301         ValueNode klass = b.add(ClassGetHubNode.create(value, b.getMetaAccess(), b.getConstantReflection(), false));
302 
303         boolean notCompressible = false;
304         AddressNode constantsAddress = b.add(new OffsetAddressNode(klass, b.add(ConstantNode.forLong(config.instanceKlassConstantsOffset))));
305         return WordOperationPlugin.readOp(b, wordTypes.getWordKind(), constantsAddress, INSTANCE_KLASS_CONSTANTS, BarrierType.NONE, notCompressible);
306     }
307 
308     /**
309      * Emits a node representing an element in a metaspace {@code ConstantPool}.
310      *
311      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
312      */
313     private static boolean readMetaspaceConstantPoolElement(GraphBuilderContext b, ValueNode constantPoolOop, ValueNode index, JavaKind elementKind, WordTypes wordTypes, GraalHotSpotVMConfig config) {
314         ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
315         int shift = CodeUtil.log2(wordTypes.getWordKind().getByteCount());
316         ValueNode scaledIndex = b.add(new LeftShiftNode(IntegerConvertNode.convert(index, StampFactory.forKind(JavaKind.Long), NodeView.DEFAULT), b.add(ConstantNode.forInt(shift))));
317         ValueNode offset = b.add(new AddNode(scaledIndex, b.add(ConstantNode.forLong(config.constantPoolSize))));
318         AddressNode elementAddress = b.add(new OffsetAddressNode(constants, offset));
319         boolean notCompressible = false;
320         ValueNode elementValue = WordOperationPlugin.readOp(b, elementKind, elementAddress, NamedLocationIdentity.getArrayLocation(elementKind), BarrierType.NONE, notCompressible);
321         b.addPush(elementKind, elementValue);
322         return true;
323     }
324 
<a name="35" id="anc35"></a><span class="line-modified">325     private static void registerConstantPoolPlugins(InvocationPlugins plugins, WordTypes wordTypes, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">326         Registration r = new Registration(plugins, constantPoolClass, bytecodeProvider);</span>
327 
328         r.register2(&quot;getSize0&quot;, Receiver.class, Object.class, new InvocationPlugin() {
329             @Override
330             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop) {
331                 boolean notCompressible = false;
332                 ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
333                 AddressNode lengthAddress = b.add(new OffsetAddressNode(constants, b.add(ConstantNode.forLong(config.constantPoolLengthOffset))));
334                 ValueNode length = WordOperationPlugin.readOp(b, JavaKind.Int, lengthAddress, CONSTANT_POOL_LENGTH, BarrierType.NONE, notCompressible);
335                 b.addPush(JavaKind.Int, length);
336                 return true;
337             }
338         });
339 
340         r.register3(&quot;getIntAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
341             @Override
342             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
343                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Int, wordTypes, config);
344             }
345         });
346         r.register3(&quot;getLongAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
347             @Override
348             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
349                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Long, wordTypes, config);
350             }
351         });
352         r.register3(&quot;getFloatAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
353             @Override
354             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
355                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Float, wordTypes, config);
356             }
357         });
358         r.register3(&quot;getDoubleAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
359             @Override
360             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
361                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Double, wordTypes, config);
362             }
363         });
364     }
365 
366     private static void registerSystemPlugins(InvocationPlugins plugins, ForeignCallsProvider foreignCalls) {
367         Registration r = new Registration(plugins, System.class);
368         r.register0(&quot;currentTimeMillis&quot;, new ForeignCallPlugin(foreignCalls, HotSpotHostForeignCallsProvider.JAVA_TIME_MILLIS));
369         r.register0(&quot;nanoTime&quot;, new ForeignCallPlugin(foreignCalls, HotSpotHostForeignCallsProvider.JAVA_TIME_NANOS));
370         r.register1(&quot;identityHashCode&quot;, Object.class, new InvocationPlugin() {
371             @Override
372             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
373                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object));
374                 return true;
375             }
376 
377             @Override
378             public boolean inlineOnly() {
379                 return true;
380             }
381         });
382         r.register5(&quot;arraycopy&quot;, Object.class, int.class, Object.class, int.class, int.class, new InvocationPlugin() {
383             @Override
384             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode src, ValueNode srcPos, ValueNode dst, ValueNode dstPos, ValueNode length) {
385                 b.add(new ArrayCopyNode(b.bci(), src, srcPos, dst, dstPos, length));
386                 return true;
387             }
388 
389             @Override
390             public boolean inlineOnly() {
391                 return true;
392             }
393         });
394     }
395 
<a name="36" id="anc36"></a><span class="line-modified">396     private static void registerArrayPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">397         Registration r = new Registration(plugins, Array.class, bytecodeProvider);</span>
398         r.setAllowOverwrite(true);
399         r.registerMethodSubstitution(HotSpotArraySubstitutions.class, &quot;newInstance&quot;, Class.class, int.class);
400     }
401 
<a name="37" id="anc37"></a><span class="line-modified">402     private static void registerStringPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">403         if (!Java8OrEarlier) {</span>
<span class="line-modified">404             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, bytecodeProvider);</span>
405             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;toBytes&quot;, char[].class, int.class, int.class);
406             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChars&quot;, byte[].class, int.class, int.class, char[].class, int.class);
407         }
408     }
409 
<a name="38" id="anc38"></a><span class="line-modified">410     private static void registerThreadPlugins(InvocationPlugins plugins, MetaAccessProvider metaAccess, WordTypes wordTypes, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">411         Registration r = new Registration(plugins, Thread.class, bytecodeProvider);</span>
412         r.register0(&quot;currentThread&quot;, new InvocationPlugin() {
413             @Override
414             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
415                 CurrentJavaThreadNode thread = b.add(new CurrentJavaThreadNode(wordTypes.getWordKind()));
416                 ValueNode offset = b.add(ConstantNode.forLong(config.threadObjectOffset));
417                 AddressNode address = b.add(new OffsetAddressNode(thread, offset));
418                 // JavaThread::_threadObj is never compressed
419                 ObjectStamp stamp = StampFactory.objectNonNull(TypeReference.create(b.getAssumptions(), metaAccess.lookupJavaType(Thread.class)));
420                 b.addPush(JavaKind.Object, new ReadNode(address, JAVA_THREAD_THREAD_OBJECT_LOCATION, stamp, BarrierType.NONE));
421                 return true;
422             }
423         });
424 
<a name="39" id="anc39"></a><span class="line-modified">425         r.registerMethodSubstitution(ThreadSubstitutions.class, &quot;isInterrupted&quot;, Receiver.class, boolean.class);</span>
<span class="line-modified">426     }</span>

427 
<a name="40" id="anc40"></a><span class="line-modified">428     public static final String cbcEncryptName;</span>
<span class="line-removed">429     public static final String cbcDecryptName;</span>
<span class="line-removed">430     public static final String aesEncryptName;</span>
<span class="line-removed">431     public static final String aesDecryptName;</span>
432 
433     public static final String reflectionClass;
434     public static final String constantPoolClass;
435 
436     static {
<a name="41" id="anc41"></a><span class="line-modified">437         if (Java8OrEarlier) {</span>
<span class="line-removed">438             cbcEncryptName = &quot;encrypt&quot;;</span>
<span class="line-removed">439             cbcDecryptName = &quot;decrypt&quot;;</span>
<span class="line-removed">440             aesEncryptName = &quot;encryptBlock&quot;;</span>
<span class="line-removed">441             aesDecryptName = &quot;decryptBlock&quot;;</span>
442             reflectionClass = &quot;sun.reflect.Reflection&quot;;
443             constantPoolClass = &quot;sun.reflect.ConstantPool&quot;;
444         } else {
<a name="42" id="anc42"></a><span class="line-removed">445             cbcEncryptName = &quot;implEncrypt&quot;;</span>
<span class="line-removed">446             cbcDecryptName = &quot;implDecrypt&quot;;</span>
<span class="line-removed">447             aesEncryptName = &quot;implEncryptBlock&quot;;</span>
<span class="line-removed">448             aesDecryptName = &quot;implDecryptBlock&quot;;</span>
449             reflectionClass = &quot;jdk.internal.reflect.Reflection&quot;;
450             constantPoolClass = &quot;jdk.internal.reflect.ConstantPool&quot;;
451         }
452     }
453 
<a name="43" id="anc43"></a><span class="line-modified">454     private static void registerAESPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>







































455         if (config.useAESIntrinsics) {
456             assert config.aescryptEncryptBlockStub != 0L;
457             assert config.aescryptDecryptBlockStub != 0L;
458             assert config.cipherBlockChainingEncryptAESCryptStub != 0L;
459             assert config.cipherBlockChainingDecryptAESCryptStub != 0L;
460             String arch = config.osArch;
461             String decryptSuffix = arch.equals(&quot;sparc&quot;) ? &quot;WithOriginalKey&quot; : &quot;&quot;;
<a name="44" id="anc44"></a><span class="line-modified">462             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CipherBlockChaining&quot;, bytecodeProvider);</span>
<span class="line-modified">463             r.registerMethodSubstitution(CipherBlockChainingSubstitutions.class, cbcEncryptName, Receiver.class, byte[].class, int.class, int.class, byte[].class, int.class);</span>
<span class="line-modified">464             r.registerMethodSubstitution(CipherBlockChainingSubstitutions.class, cbcDecryptName, cbcDecryptName + decryptSuffix, Receiver.class, byte[].class, int.class, int.class, byte[].class,</span>
<span class="line-modified">465                             int.class);</span>
<span class="line-modified">466             r = new Registration(plugins, &quot;com.sun.crypto.provider.AESCrypt&quot;, bytecodeProvider);</span>
<span class="line-modified">467             r.registerMethodSubstitution(AESCryptSubstitutions.class, aesEncryptName, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>
<span class="line-modified">468             r.registerMethodSubstitution(AESCryptSubstitutions.class, aesDecryptName, aesDecryptName + decryptSuffix, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>











469         }
470     }
471 
<a name="45" id="anc45"></a><span class="line-modified">472     private static void registerBigIntegerPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">473         Registration r = new Registration(plugins, BigInteger.class, bytecodeProvider);</span>
<span class="line-modified">474         if (config.useMultiplyToLenIntrinsic()) {</span>
<span class="line-modified">475             assert config.multiplyToLen != 0L;</span>
<span class="line-modified">476             if (Java8OrEarlier) {</span>
<span class="line-modified">477                 r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;multiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class, int.class,</span>
<span class="line-removed">478                                 int[].class);</span>
<span class="line-removed">479             } else {</span>
<span class="line-removed">480                 r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMultiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class, int.class,</span>
<span class="line-removed">481                                 int[].class);</span>
<span class="line-removed">482             }</span>
483         }
<a name="46" id="anc46"></a><span class="line-modified">484         if (config.useMulAddIntrinsic()) {</span>
<span class="line-modified">485             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMulAdd&quot;, int[].class, int[].class, int.class, int.class, int.class);</span>
<span class="line-modified">486         }</span>
<span class="line-modified">487         if (config.useMontgomeryMultiplyIntrinsic()) {</span>
<span class="line-modified">488             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMontgomeryMultiply&quot;, int[].class, int[].class, int[].class, int.class, long.class, int[].class);</span>
<span class="line-modified">489         }</span>
<span class="line-modified">490         if (config.useMontgomerySquareIntrinsic()) {</span>
<span class="line-modified">491             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMontgomerySquare&quot;, int[].class, int[].class, int.class, long.class, int[].class);</span>
492         }
<a name="47" id="anc47"></a><span class="line-modified">493         if (config.useSquareToLenIntrinsic()) {</span>
<span class="line-modified">494             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implSquareToLen&quot;, int[].class, int.class, int[].class, int.class);</span>









495         }
<a name="48" id="anc48"></a>





496     }
497 
<a name="49" id="anc49"></a><span class="line-modified">498     private static void registerSHAPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
499         boolean useSha1 = config.useSHA1Intrinsics();
500         boolean useSha256 = config.useSHA256Intrinsics();
501         boolean useSha512 = config.useSHA512Intrinsics();
502 
<a name="50" id="anc50"></a><span class="line-modified">503         if (!Java8OrEarlier &amp;&amp; (useSha1 || useSha256 || useSha512)) {</span>
<span class="line-modified">504             Registration r = new Registration(plugins, &quot;sun.security.provider.DigestBase&quot;, bytecodeProvider);</span>
505             r.registerMethodSubstitution(DigestBaseSubstitutions.class, &quot;implCompressMultiBlock0&quot;, Receiver.class, byte[].class, int.class, int.class);
506         }
507 
<a name="51" id="anc51"></a>
508         if (useSha1) {
509             assert config.sha1ImplCompress != 0L;
<a name="52" id="anc52"></a><span class="line-modified">510             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA&quot;, bytecodeProvider);</span>
<span class="line-modified">511             r.registerMethodSubstitution(SHASubstitutions.class, SHASubstitutions.implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
512         }
513         if (useSha256) {
514             assert config.sha256ImplCompress != 0L;
<a name="53" id="anc53"></a><span class="line-modified">515             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA2&quot;, bytecodeProvider);</span>
<span class="line-modified">516             r.registerMethodSubstitution(SHA2Substitutions.class, SHA2Substitutions.implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
517         }
518         if (useSha512) {
519             assert config.sha512ImplCompress != 0L;
<a name="54" id="anc54"></a><span class="line-modified">520             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA5&quot;, bytecodeProvider);</span>
<span class="line-modified">521             r.registerMethodSubstitution(SHA5Substitutions.class, SHA5Substitutions.implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
522         }
523     }
524 
525     private static void registerGHASHPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {
526         if (config.useGHASHIntrinsics()) {
527             assert config.ghashProcessBlocks != 0L;
528             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.GHASH&quot;);
529             r.register5(&quot;processBlocks&quot;,
530                             byte[].class,
531                             int.class,
532                             int.class,
533                             long[].class,
534                             long[].class,
535                             new InvocationPlugin() {
536                                 @Override
537                                 public boolean apply(GraphBuilderContext b,
538                                                 ResolvedJavaMethod targetMethod,
539                                                 Receiver receiver,
540                                                 ValueNode data,
541                                                 ValueNode inOffset,
542                                                 ValueNode blocks,
543                                                 ValueNode state,
544                                                 ValueNode hashSubkey) {
545                                     int longArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Long);
546                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
547                                     ValueNode dataOffset = AddNode.create(ConstantNode.forInt(byteArrayBaseOffset), inOffset, NodeView.DEFAULT);
548                                     ComputeObjectAddressNode dataAddress = b.add(new ComputeObjectAddressNode(data, dataOffset));
549                                     ComputeObjectAddressNode stateAddress = b.add(new ComputeObjectAddressNode(state, ConstantNode.forInt(longArrayBaseOffset)));
550                                     ComputeObjectAddressNode hashSubkeyAddress = b.add(new ComputeObjectAddressNode(hashSubkey, ConstantNode.forInt(longArrayBaseOffset)));
551                                     b.add(new ForeignCallNode(foreignCalls, GHASH_PROCESS_BLOCKS, stateAddress, hashSubkeyAddress, dataAddress, blocks));
552                                     return true;
553                                 }
554                             });
555         }
556     }
557 
<a name="55" id="anc55"></a><span class="line-modified">558     private static void registerCounterModePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">559         if (config.useAESCTRIntrinsics) {</span>
<span class="line-modified">560             assert config.counterModeAESCrypt != 0L;</span>
<span class="line-modified">561             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CounterMode&quot;, bytecodeProvider);</span>
<span class="line-modified">562             r.registerMethodSubstitution(CounterModeSubstitutions.class, &quot;implCrypt&quot;, Receiver.class, byte[].class, int.class, int.class, byte[].class, int.class);</span>

563         }
564     }
565 
<a name="56" id="anc56"></a><span class="line-modified">566     private static void registerCRC32Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">567         if (config.useCRC32Intrinsics) {</span>
<span class="line-modified">568             Registration r = new Registration(plugins, CRC32.class, bytecodeProvider);</span>
<span class="line-modified">569             r.registerMethodSubstitution(CRC32Substitutions.class, &quot;update&quot;, int.class, int.class);</span>
<span class="line-modified">570             if (Java8OrEarlier) {</span>
<span class="line-modified">571                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">572                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
<span class="line-modified">573             } else {</span>
<span class="line-modified">574                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateBytes0&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">575                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateByteBuffer0&quot;, int.class, long.class, int.class, int.class);</span>
<span class="line-modified">576             }</span>






























577         }
578     }
579 
<a name="57" id="anc57"></a><span class="line-modified">580     private static void registerCRC32CPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">581         if (config.useCRC32CIntrinsics) {</span>
<span class="line-modified">582             Registration r = new Registration(plugins, &quot;java.util.zip.CRC32C&quot;, bytecodeProvider);</span>
<span class="line-modified">583             r.registerMethodSubstitution(CRC32CSubstitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">584             r.registerMethodSubstitution(CRC32CSubstitutions.class, &quot;updateDirectByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
585         }
586     }
587 
<a name="58" id="anc58"></a><span class="line-modified">588     private static void registerArraysSupportPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">589         if (config.useVectorizedMismatchIntrinsic) {</span>
<span class="line-modified">590             Registration r = new Registration(plugins, &quot;jdk.internal.util.ArraysSupport&quot;, bytecodeProvider);</span>
<span class="line-modified">591             r.registerMethodSubstitution(ArraysSupportSubstitutions.class, &quot;vectorizedMismatch&quot;, Object.class, long.class, Object.class, long.class, int.class, int.class);</span>

592         }
593     }
594 }
<a name="59" id="anc59"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="59" type="hidden" />
</body>
</html>
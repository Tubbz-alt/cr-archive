<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/lir/HotSpotZapRegistersPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../debug/BenchmarkCounters.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../meta/AddressLoweringHotSpotSuitesProvider.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/lir/HotSpotZapRegistersPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,27 +26,32 @@</span>
  
  import static jdk.vm.ci.code.ValueUtil.isStackSlot;
  
  import java.util.ArrayList;
  
<span class="udiff-line-added">+ import jdk.internal.vm.compiler.collections.EconomicSet;</span>
<span class="udiff-line-added">+ import jdk.internal.vm.compiler.collections.Equivalence;</span>
  import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
  import org.graalvm.compiler.debug.DebugContext;
  import org.graalvm.compiler.debug.Indent;
  import org.graalvm.compiler.hotspot.HotSpotLIRGenerationResult;
  import org.graalvm.compiler.hotspot.stubs.Stub;
  import org.graalvm.compiler.lir.LIR;
<span class="udiff-line-removed">- import org.graalvm.compiler.lir.LIRFrameState;</span>
  import org.graalvm.compiler.lir.LIRInsertionBuffer;
  import org.graalvm.compiler.lir.LIRInstruction;
<span class="udiff-line-modified-removed">- import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>
<span class="udiff-line-modified-added">+ import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;</span>
<span class="udiff-line-added">+ import org.graalvm.compiler.lir.ValueConsumer;</span>
  import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool;
  import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool.ZapRegistersAfterInstruction;
  import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool.ZapStackArgumentSpaceBeforeInstruction;
  import org.graalvm.compiler.lir.gen.LIRGenerationResult;
  import org.graalvm.compiler.lir.phases.PostAllocationOptimizationPhase;
  
<span class="udiff-line-added">+ import jdk.vm.ci.code.CallingConvention;</span>
<span class="udiff-line-added">+ import jdk.vm.ci.code.Register;</span>
  import jdk.vm.ci.code.TargetDescription;
<span class="udiff-line-added">+ import jdk.vm.ci.code.ValueUtil;</span>
  import jdk.vm.ci.meta.AllocatableValue;
  
  /**
   * Inserts a {@link DiagnosticLIRGeneratorTool#createZapRegisters ZapRegistersOp} after
   * {@link ZapRegistersAfterInstruction} for stubs and
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56,35 +61,40 @@</span>
  public final class HotSpotZapRegistersPhase extends PostAllocationOptimizationPhase {
  
      @Override
      protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PostAllocationOptimizationContext context) {
          Stub stub = ((HotSpotLIRGenerationResult) lirGenRes).getStub();
<span class="udiff-line-modified-removed">-         boolean zapRegisters = stub != null &amp;&amp; !stub.preservesRegisters();</span>
<span class="udiff-line-modified-added">+         boolean zapRegisters = stub == null;</span>
          boolean zapStack = false;
<span class="udiff-line-modified-removed">-         for (AllocatableValue arg : lirGenRes.getCallingConvention().getArguments()) {</span>
<span class="udiff-line-modified-added">+         CallingConvention callingConvention = lirGenRes.getCallingConvention();</span>
<span class="udiff-line-added">+         for (AllocatableValue arg : callingConvention.getArguments()) {</span>
              if (isStackSlot(arg)) {
                  zapStack = true;
                  break;
              }
          }
          if (zapRegisters || zapStack) {
              LIR lir = lirGenRes.getLIR();
<span class="udiff-line-modified-removed">-             processLIR(context.diagnosticLirGenTool, (HotSpotLIRGenerationResult) lirGenRes, lir, zapRegisters, zapStack);</span>
<span class="udiff-line-modified-added">+             EconomicSet&lt;Register&gt; allocatableRegisters = EconomicSet.create(Equivalence.IDENTITY);</span>
<span class="udiff-line-added">+             for (Register r : lirGenRes.getFrameMap().getRegisterConfig().getAllocatableRegisters()) {</span>
<span class="udiff-line-added">+                 allocatableRegisters.add(r);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             processLIR(context.diagnosticLirGenTool, lir, allocatableRegisters, zapRegisters, zapStack);</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     private static void processLIR(DiagnosticLIRGeneratorTool diagnosticLirGenTool, HotSpotLIRGenerationResult res, LIR lir, boolean zapRegisters, boolean zapStack) {</span>
<span class="udiff-line-modified-added">+     private static void processLIR(DiagnosticLIRGeneratorTool diagnosticLirGenTool, LIR lir, EconomicSet&lt;Register&gt; allocatableRegisters, boolean zapRegisters, boolean zapStack) {</span>
          LIRInsertionBuffer buffer = new LIRInsertionBuffer();
          for (AbstractBlockBase&lt;?&gt; block : lir.codeEmittingOrder()) {
              if (block != null) {
<span class="udiff-line-modified-removed">-                 processBlock(diagnosticLirGenTool, res, lir, buffer, block, zapRegisters, zapStack);</span>
<span class="udiff-line-modified-added">+                 processBlock(diagnosticLirGenTool, lir, allocatableRegisters, buffer, block, zapRegisters, zapStack);</span>
              }
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="udiff-line-modified-removed">-     private static void processBlock(DiagnosticLIRGeneratorTool diagnosticLirGenTool, HotSpotLIRGenerationResult res, LIR lir, LIRInsertionBuffer buffer, AbstractBlockBase&lt;?&gt; block,</span>
<span class="udiff-line-modified-added">+     private static void processBlock(DiagnosticLIRGeneratorTool diagnosticLirGenTool, LIR lir, EconomicSet&lt;Register&gt; allocatableRegisters, LIRInsertionBuffer buffer, AbstractBlockBase&lt;?&gt; block,</span>
                      boolean zapRegisters, boolean zapStack) {
          DebugContext debug = lir.getDebug();
          try (Indent indent = debug.logAndIndent(&quot;Process block %s&quot;, block)) {
              ArrayList&lt;LIRInstruction&gt; instructions = lir.getLIRforBlock(block);
              buffer.init(instructions);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -95,33 +105,32 @@</span>
                      if (zap != null) {
                          buffer.append(index, zap);
                      }
                  }
                  if (zapRegisters &amp;&amp; inst instanceof ZapRegistersAfterInstruction) {
<span class="udiff-line-modified-removed">-                     LIRFrameState state = getLIRState(inst);</span>
<span class="udiff-line-modified-removed">-                     if (state != null) {</span>
<span class="udiff-line-modified-removed">-                         SaveRegistersOp zap = diagnosticLirGenTool.createZapRegisters();</span>
<span class="udiff-line-modified-removed">-                         SaveRegistersOp old = res.getCalleeSaveInfo().put(state, zap);</span>
<span class="udiff-line-modified-removed">-                         assert old == null : &quot;Already another SaveRegisterOp registered! &quot; + old;</span>
<span class="udiff-line-modified-removed">-                         buffer.append(index + 1, (LIRInstruction) zap);</span>
<span class="udiff-line-modified-removed">-                         debug.log(&quot;Insert ZapRegister after %s&quot;, inst);</span>
<span class="udiff-line-modified-removed">-                     }</span>
<span class="udiff-line-modified-added">+                     final EconomicSet&lt;Register&gt; destroyedRegisters = EconomicSet.create(Equivalence.IDENTITY);</span>
<span class="udiff-line-modified-added">+                     ValueConsumer tempConsumer = (value, mode, flags) -&gt; {</span>
<span class="udiff-line-modified-added">+                         if (ValueUtil.isRegister(value)) {</span>
<span class="udiff-line-modified-added">+                             final Register reg = ValueUtil.asRegister(value);</span>
<span class="udiff-line-modified-added">+                             if (allocatableRegisters.contains(reg)) {</span>
<span class="udiff-line-modified-added">+                                 destroyedRegisters.add(reg);</span>
<span class="udiff-line-modified-added">+                             }</span>
<span class="udiff-line-modified-added">+                         }</span>
<span class="udiff-line-added">+                     };</span>
<span class="udiff-line-added">+                     ValueConsumer defConsumer = (value, mode, flags) -&gt; {</span>
<span class="udiff-line-added">+                         if (ValueUtil.isRegister(value)) {</span>
<span class="udiff-line-added">+                             final Register reg = ValueUtil.asRegister(value);</span>
<span class="udiff-line-added">+                             destroyedRegisters.remove(reg);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     };</span>
<span class="udiff-line-added">+                     inst.visitEachTemp(tempConsumer);</span>
<span class="udiff-line-added">+                     inst.visitEachOutput(defConsumer);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     ZapRegistersOp zap = diagnosticLirGenTool.createZapRegisters(destroyedRegisters.toArray(new Register[destroyedRegisters.size()]));</span>
<span class="udiff-line-added">+                     buffer.append(index + 1, (LIRInstruction) zap);</span>
<span class="udiff-line-added">+                     debug.log(&quot;Insert ZapRegister after %s&quot;, inst);</span>
                  }
              }
              buffer.finish();
          }
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Returns the {@link LIRFrameState} of an instruction.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static LIRFrameState getLIRState(LIRInstruction inst) {</span>
<span class="udiff-line-removed">-         final LIRFrameState[] lirState = {null};</span>
<span class="udiff-line-removed">-         inst.forEachState(state -&gt; {</span>
<span class="udiff-line-removed">-             assert lirState[0] == null : &quot;Multiple states: &quot; + inst;</span>
<span class="udiff-line-removed">-             lirState[0] = state;</span>
<span class="udiff-line-removed">-         });</span>
<span class="udiff-line-removed">-         assert lirState[0] != null : &quot;No state: &quot; + inst;</span>
<span class="udiff-line-removed">-         return lirState[0];</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
  }
</pre>
<center><a href="../debug/BenchmarkCounters.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../meta/AddressLoweringHotSpotSuitesProvider.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
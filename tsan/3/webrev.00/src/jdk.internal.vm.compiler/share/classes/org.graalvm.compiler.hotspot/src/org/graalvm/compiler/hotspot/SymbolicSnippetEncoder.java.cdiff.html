<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/SymbolicSnippetEncoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JVMCIVersionCheck.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="debug/BenchmarkCounters.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/SymbolicSnippetEncoder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,12 ***</span>
  package org.graalvm.compiler.hotspot;
  
  import static jdk.vm.ci.runtime.JVMCI.getRuntime;
  import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
<span class="line-modified">! import static org.graalvm.compiler.replacements.ReplacementsImpl.Options.UseEncodedSnippets;</span>
  
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collections;
  import java.util.HashMap;
<span class="line-new-header">--- 25,14 ---</span>
  package org.graalvm.compiler.hotspot;
  
  import static jdk.vm.ci.runtime.JVMCI.getRuntime;
  import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
<span class="line-added">+ import static org.graalvm.compiler.core.common.GraalOptions.UseEncodedGraphs;</span>
  import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
<span class="line-modified">! import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;</span>
<span class="line-added">+ import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;</span>
  
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collections;
  import java.util.HashMap;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,11 ***</span>
  import org.graalvm.compiler.api.replacements.Snippet;
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
  import org.graalvm.compiler.api.runtime.GraalRuntime;
  import org.graalvm.compiler.bytecode.BytecodeProvider;
<span class="line-modified">! import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;</span>
  import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
  import org.graalvm.compiler.core.common.type.Stamp;
  import org.graalvm.compiler.core.common.type.StampPair;
  import org.graalvm.compiler.core.common.type.SymbolicJVMCIReference;
  import org.graalvm.compiler.debug.DebugContext;
<span class="line-new-header">--- 48,11 ---</span>
  import org.graalvm.compiler.api.replacements.Snippet;
  import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
  import org.graalvm.compiler.api.runtime.GraalRuntime;
  import org.graalvm.compiler.bytecode.BytecodeProvider;
<span class="line-modified">! import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;</span>
  import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
  import org.graalvm.compiler.core.common.type.Stamp;
  import org.graalvm.compiler.core.common.type.StampPair;
  import org.graalvm.compiler.core.common.type.SymbolicJVMCIReference;
  import org.graalvm.compiler.debug.DebugContext;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,10 ***</span>
<span class="line-new-header">--- 65,11 ---</span>
  import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
  import org.graalvm.compiler.java.BytecodeParser;
  import org.graalvm.compiler.java.GraphBuilderPhase;
  import org.graalvm.compiler.nodeinfo.Verbosity;
  import org.graalvm.compiler.nodes.CallTargetNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.Cancellable;</span>
  import org.graalvm.compiler.nodes.ConstantNode;
  import org.graalvm.compiler.nodes.EncodedGraph;
  import org.graalvm.compiler.nodes.FrameState;
  import org.graalvm.compiler.nodes.FullInfopointNode;
  import org.graalvm.compiler.nodes.GraphEncoder;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,12 ***</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
  import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
  import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
  import org.graalvm.compiler.nodes.java.AccessFieldNode;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.spi.DelegatingReplacements;</span>
<span class="line-removed">- import org.graalvm.compiler.nodes.spi.StampProvider;</span>
  import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.OptimisticOptimizations;
  import org.graalvm.compiler.phases.schedule.SchedulePhase;
  import org.graalvm.compiler.phases.util.Providers;
<span class="line-new-header">--- 88,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,23 ***</span>
  import org.graalvm.compiler.replacements.PEGraphDecoder;
  import org.graalvm.compiler.replacements.ReplacementsImpl;
  import org.graalvm.compiler.replacements.SnippetCounter;
  import org.graalvm.compiler.replacements.SnippetIntegerHistogram;
  
<span class="line-removed">- import jdk.vm.ci.code.Architecture;</span>
  import jdk.vm.ci.code.TargetDescription;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.ConstantReflectionProvider;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaKind;
<span class="line-removed">- import jdk.vm.ci.meta.JavaType;</span>
  import jdk.vm.ci.meta.MemoryAccessProvider;
<span class="line-removed">- import jdk.vm.ci.meta.MetaAccessProvider;</span>
  import jdk.vm.ci.meta.MethodHandleAccessProvider;
  import jdk.vm.ci.meta.ResolvedJavaField;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  import jdk.vm.ci.meta.UnresolvedJavaField;
<span class="line-new-header">--- 99,21 ---</span>
  import org.graalvm.compiler.replacements.PEGraphDecoder;
  import org.graalvm.compiler.replacements.ReplacementsImpl;
  import org.graalvm.compiler.replacements.SnippetCounter;
  import org.graalvm.compiler.replacements.SnippetIntegerHistogram;
  
  import jdk.vm.ci.code.TargetDescription;
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
<span class="line-added">+ import jdk.vm.ci.hotspot.HotSpotSignature;</span>
  import jdk.vm.ci.meta.Constant;
  import jdk.vm.ci.meta.ConstantReflectionProvider;
  import jdk.vm.ci.meta.JavaConstant;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.MemoryAccessProvider;
  import jdk.vm.ci.meta.MethodHandleAccessProvider;
  import jdk.vm.ci.meta.ResolvedJavaField;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import jdk.vm.ci.meta.ResolvedJavaType;
  import jdk.vm.ci.meta.UnresolvedJavaField;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,17 ***</span>
  /**
   * This class performs graph encoding using {@link GraphEncoder} but also converts JVMCI type and
   * method references into a symbolic form that can be resolved at graph decode time using
   * {@link SymbolicJVMCIReference}.
   */
<span class="line-modified">! public class SymbolicSnippetEncoder extends DelegatingReplacements {</span>
  
      /**
       * This is a customized HotSpotReplacementsImpl intended only for parsing snippets and method
       * substitutions for graph encoding.
       */
<span class="line-modified">!     private final HotSpotSnippetReplacementsImpl replacements;</span>
  
      /**
       * The set of all snippet methods that have been encoded.
       */
      private final Set&lt;ResolvedJavaMethod&gt; snippetMethods = Collections.synchronizedSet(new HashSet&lt;&gt;());
<span class="line-new-header">--- 123,17 ---</span>
  /**
   * This class performs graph encoding using {@link GraphEncoder} but also converts JVMCI type and
   * method references into a symbolic form that can be resolved at graph decode time using
   * {@link SymbolicJVMCIReference}.
   */
<span class="line-modified">! public class SymbolicSnippetEncoder {</span>
  
      /**
       * This is a customized HotSpotReplacementsImpl intended only for parsing snippets and method
       * substitutions for graph encoding.
       */
<span class="line-modified">!     private final HotSpotSnippetReplacementsImpl snippetReplacements;</span>
  
      /**
       * The set of all snippet methods that have been encoded.
       */
      private final Set&lt;ResolvedJavaMethod&gt; snippetMethods = Collections.synchronizedSet(new HashSet&lt;&gt;());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,21 ***</span>
       * A mapping from the method substitution method to the original method name. The string key and
       * values are produced using {@link #methodKey(ResolvedJavaMethod)}.
       */
      private final Map&lt;String, String&gt; originalMethods = new ConcurrentHashMap&lt;&gt;();
  
      /**
       * The current count of graphs encoded. Used to detect when new graphs have been enqueued for
       * encoding.
       */
<span class="line-modified">!     int encodedGraphs = 0;</span>
  
      /**
       * All the graphs parsed so far.
       */
      private Map&lt;String, StructuredGraph&gt; preparedSnippetGraphs = new HashMap&lt;&gt;();
  
      /**
       * The invocation plugins which were delayed during graph preparation.
       */
      private Set&lt;ResolvedJavaMethod&gt; delayedInvocationPluginMethods = new HashSet&lt;&gt;();
  
<span class="line-new-header">--- 142,29 ---</span>
       * A mapping from the method substitution method to the original method name. The string key and
       * values are produced using {@link #methodKey(ResolvedJavaMethod)}.
       */
      private final Map&lt;String, String&gt; originalMethods = new ConcurrentHashMap&lt;&gt;();
  
<span class="line-added">+     private final HotSpotReplacementsImpl originalReplacements;</span>
<span class="line-added">+ </span>
      /**
       * The current count of graphs encoded. Used to detect when new graphs have been enqueued for
       * encoding.
       */
<span class="line-modified">!     private int encodedGraphs = 0;</span>
  
      /**
       * All the graphs parsed so far.
       */
      private Map&lt;String, StructuredGraph&gt; preparedSnippetGraphs = new HashMap&lt;&gt;();
  
<span class="line-added">+     private Set&lt;MethodSubstitutionPlugin&gt; knownPlugins = new HashSet&lt;&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+     private Set&lt;InvocationPlugin&gt; conditionalPlugins = new HashSet&lt;&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+     private int preparedPlugins = 0;</span>
<span class="line-added">+ </span>
      /**
       * The invocation plugins which were delayed during graph preparation.
       */
      private Set&lt;ResolvedJavaMethod&gt; delayedInvocationPluginMethods = new HashSet&lt;&gt;();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,17 ***</span>
              if (method.getAnnotation(Fold.class) != null) {
                  delayedInvocationPluginMethods.add(method);
                  return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
              }
  
<span class="line-modified">!             if (getIntrinsifyingPlugin(method) != null) {</span>
                  delayedInvocationPluginMethods.add(method);
                  return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
              }
  
              // Force inlining when parsing replacements
<span class="line-modified">!             return createIntrinsicInlineInfo(method, null, getDefaultReplacementBytecodeProvider());</span>
          }
  
          @Override
          public void notifyAfterInline(ResolvedJavaMethod methodToInline) {
              assert methodToInline.getAnnotation(Fold.class) == null : methodToInline;
<span class="line-new-header">--- 183,17 ---</span>
              if (method.getAnnotation(Fold.class) != null) {
                  delayedInvocationPluginMethods.add(method);
                  return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
              }
  
<span class="line-modified">!             if (snippetReplacements.getIntrinsifyingPlugin(method) != null) {</span>
                  delayedInvocationPluginMethods.add(method);
                  return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
              }
  
              // Force inlining when parsing replacements
<span class="line-modified">!             return createIntrinsicInlineInfo(method, snippetReplacements.getDefaultReplacementBytecodeProvider());</span>
          }
  
          @Override
          public void notifyAfterInline(ResolvedJavaMethod methodToInline) {
              assert methodToInline.getAnnotation(Fold.class) == null : methodToInline;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,16 ***</span>
              if (field.getName().equals(&quot;group&quot;) &amp;&amp; field.getDeclaringClass().getName().equals(snippetCounterName)) {
                  b.addPush(JavaKind.Object, ConstantNode.forConstant(JavaConstant.NULL_POINTER, b.getMetaAccess()));
                  return true;
              }
              if (field.getType().getName().equals(snippetCounterName)) {
<span class="line-modified">!                 b.addPush(JavaKind.Object, ConstantNode.forConstant(replacements.snippetReflection.forObject(SnippetCounter.DISABLED_COUNTER), b.getMetaAccess()));</span>
                  return true;
              }
  
              if (field.getType().getName().equals(snippetIntegerHistogramName)) {
<span class="line-modified">!                 b.addPush(JavaKind.Object, ConstantNode.forConstant(replacements.snippetReflection.forObject(SnippetIntegerHistogram.DISABLED_COUNTER), b.getMetaAccess()));</span>
                  return true;
              }
              return false;
          }
      }
<span class="line-new-header">--- 227,16 ---</span>
              if (field.getName().equals(&quot;group&quot;) &amp;&amp; field.getDeclaringClass().getName().equals(snippetCounterName)) {
                  b.addPush(JavaKind.Object, ConstantNode.forConstant(JavaConstant.NULL_POINTER, b.getMetaAccess()));
                  return true;
              }
              if (field.getType().getName().equals(snippetCounterName)) {
<span class="line-modified">!                 b.addPush(JavaKind.Object, ConstantNode.forConstant(snippetReplacements.snippetReflection.forObject(SnippetCounter.DISABLED_COUNTER), b.getMetaAccess()));</span>
                  return true;
              }
  
              if (field.getType().getName().equals(snippetIntegerHistogramName)) {
<span class="line-modified">!                 b.addPush(JavaKind.Object, ConstantNode.forConstant(snippetReplacements.snippetReflection.forObject(SnippetIntegerHistogram.DISABLED_COUNTER), b.getMetaAccess()));</span>
                  return true;
              }
              return false;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,39 ***</span>
      /**
       * Generate a String name for a method including all type information. Used as a symbolic key
       * for lookup.
       */
      private static String methodKey(ResolvedJavaMethod method) {
<span class="line-modified">!         return method.format(&quot;%f %H.%n(%P)&quot;);</span>
      }
  
      SymbolicSnippetEncoder(HotSpotReplacementsImpl replacements) {
<span class="line-modified">!         super(replacements);</span>
<span class="line-removed">- </span>
          GraphBuilderConfiguration.Plugins plugins = replacements.getGraphBuilderPlugins();
          SnippetInvocationPlugins invocationPlugins = new SnippetInvocationPlugins(plugins.getInvocationPlugins());
          GraphBuilderConfiguration.Plugins copy = new GraphBuilderConfiguration.Plugins(plugins, invocationPlugins);
          copy.clearInlineInvokePlugins();
          copy.appendInlineInvokePlugin(new SnippetInlineInvokePlugin());
          copy.appendNodePlugin(new SnippetCounterPlugin());
          HotSpotProviders providers = (HotSpotProviders) replacements.getProviders().copyWith(new HotSpotSubstrateConstantReflectionProvider(replacements.getProviders().getConstantReflection()));
<span class="line-modified">!         this.replacements = new HotSpotSnippetReplacementsImpl(replacements, providers.copyWith(copy));</span>
<span class="line-modified">!         this.replacements.setGraphBuilderPlugins(copy);</span>
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public GraphBuilderConfiguration.Plugins getGraphBuilderPlugins() {</span>
<span class="line-modified">!         return replacements.getGraphBuilderPlugins();</span>
      }
  
      /**
       * Compiles the snippet and stores the graph.
       */
<span class="line-modified">!     public void registerMethodSubstitution(ResolvedJavaMethod method, ResolvedJavaMethod original) {</span>
          assert method.getAnnotation(MethodSubstitution.class) != null : &quot;MethodSubstitution must be annotated with @&quot; + MethodSubstitution.class.getSimpleName();
<span class="line-modified">!         buildGraph(method, original, null, false, false);</span>
          snippetMethods.add(method);
      }
  
      static class EncodedSnippets {
          private byte[] snippetEncoding;
          private Object[] snippetObjects;
<span class="line-new-header">--- 244,51 ---</span>
      /**
       * Generate a String name for a method including all type information. Used as a symbolic key
       * for lookup.
       */
      private static String methodKey(ResolvedJavaMethod method) {
<span class="line-modified">!         return method.format(&quot;%H.%n(%P)&quot;);</span>
      }
  
      SymbolicSnippetEncoder(HotSpotReplacementsImpl replacements) {
<span class="line-modified">!         this.originalReplacements = replacements;</span>
          GraphBuilderConfiguration.Plugins plugins = replacements.getGraphBuilderPlugins();
          SnippetInvocationPlugins invocationPlugins = new SnippetInvocationPlugins(plugins.getInvocationPlugins());
          GraphBuilderConfiguration.Plugins copy = new GraphBuilderConfiguration.Plugins(plugins, invocationPlugins);
          copy.clearInlineInvokePlugins();
          copy.appendInlineInvokePlugin(new SnippetInlineInvokePlugin());
          copy.appendNodePlugin(new SnippetCounterPlugin());
          HotSpotProviders providers = (HotSpotProviders) replacements.getProviders().copyWith(new HotSpotSubstrateConstantReflectionProvider(replacements.getProviders().getConstantReflection()));
<span class="line-modified">!         this.snippetReplacements = new HotSpotSnippetReplacementsImpl(replacements, providers.copyWith(copy));</span>
<span class="line-modified">!         this.snippetReplacements.setGraphBuilderPlugins(copy);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin) {</span>
<span class="line-added">+         knownPlugins.add(plugin);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void registerConditionalPlugin(InvocationPlugin plugin) {</span>
<span class="line-added">+         conditionalPlugins.add(plugin);</span>
      }
  
<span class="line-modified">!     synchronized void checkRegistered(MethodSubstitutionPlugin plugin) {</span>
<span class="line-modified">!         if (!knownPlugins.contains(plugin)) {</span>
<span class="line-modified">!             throw new GraalError(&quot;missing plugin should have been registered during construction&quot;);</span>
<span class="line-added">+         }</span>
      }
  
      /**
       * Compiles the snippet and stores the graph.
       */
<span class="line-modified">!     private synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context, OptionValues options) {</span>
<span class="line-added">+         ResolvedJavaMethod method = plugin.getSubstitute(snippetReplacements.getProviders().getMetaAccess());</span>
          assert method.getAnnotation(MethodSubstitution.class) != null : &quot;MethodSubstitution must be annotated with @&quot; + MethodSubstitution.class.getSimpleName();
<span class="line-modified">!         String originalMethodString = plugin.originalMethodAsString();</span>
<span class="line-added">+         StructuredGraph subst = buildGraph(method, original, originalMethodString, null, true, false, context, options);</span>
          snippetMethods.add(method);
<span class="line-added">+         originalMethods.put(methodKey(method), originalMethodString);</span>
<span class="line-added">+         preparedSnippetGraphs.put(plugin.toString() + context, subst);</span>
      }
  
      static class EncodedSnippets {
          private byte[] snippetEncoding;
          private Object[] snippetObjects;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,70 ***</span>
              this.snippetNodeClasses = snippetNodeClasses;
              this.snippetStartOffsets = snippetStartOffsets;
              this.originalMethods = originalMethods;
          }
  
<span class="line-modified">!         public StructuredGraph getMethodSubstitutionGraph(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, ReplacementsImpl replacements) {</span>
<span class="line-modified">!             Integer startOffset = snippetStartOffsets.get(plugin.toString());</span>
              if (startOffset == null) {
<span class="line-modified">!                 throw GraalError.shouldNotReachHere(&quot;plugin graph not found: &quot; + plugin);</span>
              }
  
<span class="line-modified">!             return decodeGraph(original, null, startOffset, replacements);</span>
          }
  
          @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!         private StructuredGraph decodeGraph(ResolvedJavaMethod method, Object[] args, int startOffset, ReplacementsImpl replacements) {</span>
<span class="line-modified">!             OptionValues options = replacements.getOptions();</span>
<span class="line-modified">!             SnippetReflectionProvider snippetReflection = replacements.snippetReflection;</span>
<span class="line-modified">!             ParameterPlugin parameterPlugin = null;</span>
              Providers providers = replacements.getProviders();
<span class="line-modified">!             if (args != null) {</span>
<span class="line-modified">!                 parameterPlugin = new ConstantBindingParameterPlugin(args, providers.getMetaAccess(), snippetReflection);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-modified">!             EncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses, method.getDeclaringClass(),</span>
<span class="line-removed">-                             originalMethods.get(methodKey(method)));</span>
<span class="line-removed">-             try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method)) {</span>
<span class="line-removed">-                 StructuredGraph result = new StructuredGraph.Builder(options, debug).method(method).setIsSubstitution(true).build();</span>
<span class="line-removed">-                 PEGraphDecoder graphDecoder = new PEGraphDecoder(</span>
<span class="line-removed">-                                 providers.getCodeCache().getTarget().arch,</span>
<span class="line-removed">-                                 result,</span>
<span class="line-removed">-                                 providers.getMetaAccess(),</span>
<span class="line-removed">-                                 providers.getConstantReflection(),</span>
<span class="line-removed">-                                 providers.getConstantFieldProvider(),</span>
<span class="line-removed">-                                 providers.getStampProvider(),</span>
<span class="line-removed">-                                 null, // loopExplosionPlugin</span>
<span class="line-removed">-                                 replacements.getGraphBuilderPlugins().getInvocationPlugins(),</span>
<span class="line-removed">-                                 new InlineInvokePlugin[0],</span>
<span class="line-removed">-                                 parameterPlugin,</span>
<span class="line-removed">-                                 null, // nodePlugins</span>
<span class="line-removed">-                                 null, // callInlinedMethod</span>
<span class="line-removed">-                                 null // sourceLanguagePositionProvider</span>
<span class="line-removed">-                 ) {</span>
<span class="line-removed">-                     @Override</span>
<span class="line-removed">-                     protected EncodedGraph lookupEncodedGraph(ResolvedJavaMethod lookupMethod,</span>
<span class="line-removed">-                                     ResolvedJavaMethod originalMethod,</span>
<span class="line-removed">-                                     BytecodeProvider intrinsicBytecodeProvider,</span>
<span class="line-removed">-                                     boolean isSubstitution,</span>
<span class="line-removed">-                                     boolean trackNodeSourcePosition) {</span>
<span class="line-removed">-                         if (lookupMethod.equals(method)) {</span>
<span class="line-removed">-                             return encodedGraph;</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             throw GraalError.shouldNotReachHere(method.format(&quot;%H.%n(%p)&quot;));</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 };</span>
  
                  graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
  
                  assert result.verify();
                  return result;
              }
          }
  
<span class="line-modified">!         StructuredGraph getEncodedSnippet(ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args) {</span>
              Integer startOffset = null;
              if (snippetStartOffsets != null) {
                  startOffset = snippetStartOffsets.get(methodKey(method));
              }
              if (startOffset == null) {
<span class="line-new-header">--- 302,49 ---</span>
              this.snippetNodeClasses = snippetNodeClasses;
              this.snippetStartOffsets = snippetStartOffsets;
              this.originalMethods = originalMethods;
          }
  
<span class="line-modified">!         StructuredGraph getMethodSubstitutionGraph(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, ReplacementsImpl replacements, IntrinsicContext.CompilationContext context,</span>
<span class="line-modified">!                         StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {</span>
<span class="line-added">+             IntrinsicContext.CompilationContext contextToUse = context;</span>
<span class="line-added">+             if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {</span>
<span class="line-added">+                 contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             Integer startOffset = snippetStartOffsets.get(plugin.toString() + contextToUse);</span>
              if (startOffset == null) {
<span class="line-modified">!                 throw GraalError.shouldNotReachHere(&quot;plugin graph not found: &quot; + plugin + &quot; with &quot; + contextToUse);</span>
              }
  
<span class="line-modified">!             ResolvedJavaType accessingClass = replacements.getProviders().getMetaAccess().lookupJavaType(plugin.getDeclaringClass());</span>
<span class="line-added">+             return decodeGraph(original, accessingClass, startOffset, replacements, contextToUse, allowAssumptions, cancellable, options);</span>
          }
  
          @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!         private StructuredGraph decodeGraph(ResolvedJavaMethod method,</span>
<span class="line-modified">!                         ResolvedJavaType accessingClass,</span>
<span class="line-modified">!                         int startOffset,</span>
<span class="line-modified">!                         ReplacementsImpl replacements,</span>
<span class="line-added">+                         IntrinsicContext.CompilationContext context,</span>
<span class="line-added">+                         StructuredGraph.AllowAssumptions allowAssumptions,</span>
<span class="line-added">+                         Cancellable cancellable,</span>
<span class="line-added">+                         OptionValues options) {</span>
              Providers providers = replacements.getProviders();
<span class="line-modified">!             EncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses,</span>
<span class="line-modified">!                             methodKey(method), accessingClass, method.getDeclaringClass());</span>
<span class="line-modified">!             try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method, options)) {</span>
<span class="line-modified">!                 StructuredGraph result = new StructuredGraph.Builder(options, debug, allowAssumptions).cancellable(cancellable).method(method).setIsSubstitution(true).build();</span>
<span class="line-modified">!                 PEGraphDecoder graphDecoder = new SubstitutionGraphDecoder(providers, result, replacements, null, method, context, encodedGraph);</span>
  
                  graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
  
                  assert result.verify();
                  return result;
              }
          }
  
<span class="line-modified">!         StructuredGraph getEncodedSnippet(ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args, StructuredGraph.AllowAssumptions allowAssumptions, OptionValues options) {</span>
              Integer startOffset = null;
              if (snippetStartOffsets != null) {
                  startOffset = snippetStartOffsets.get(methodKey(method));
              }
              if (startOffset == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,86 ***</span>
                  } else {
                      return null;
                  }
              }
  
<span class="line-modified">!             SymbolicEncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses, method.getDeclaringClass(),</span>
<span class="line-modified">!                             originalMethods.get(methodKey(method)));</span>
<span class="line-modified">!             return decodeSnippetGraph(encodedGraph, method, replacements, args, HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch);</span>
          }
  
      }
  
<span class="line-modified">!     private StructuredGraph buildGraph(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean requireInlining, boolean trackNodeSourcePosition) {</span>
          assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
          Object[] args = null;
          if (receiver != null) {
              args = new Object[method.getSignature().getParameterCount(true)];
              args[0] = receiver;
          }
<span class="line-modified">!         try (DebugContext debug = openDebugContext(&quot;Snippet_&quot;, method)) {</span>
<span class="line-modified">!             StructuredGraph graph = replacements.makeGraph(debug, replacements.getDefaultReplacementBytecodeProvider(), method, args, original, trackNodeSourcePosition, null);</span>
  
              // Check if all methods which should be inlined are really inlined.
              for (MethodCallTargetNode callTarget : graph.getNodes(MethodCallTargetNode.TYPE)) {
                  ResolvedJavaMethod callee = callTarget.targetMethod();
                  if (requireInlining &amp;&amp; !delayedInvocationPluginMethods.contains(callee) &amp;&amp; !Objects.equals(callee, original)) {
                      throw GraalError.shouldNotReachHere(&quot;method &quot; + callee.format(&quot;%H.%n&quot;) + &quot; not inlined in snippet &quot; + method.getName() + &quot; (maybe not final?)&quot;);
                  }
              }
<span class="line-modified">!             assert verifySnippetEncodeDecode(method, original, trackNodeSourcePosition, graph);</span>
              debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;After buildGraph&quot;);
              return graph;
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     static StructuredGraph decodeSnippetGraph(SymbolicEncodedGraph encodedGraph, ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args, Architecture architecture) {</span>
          Providers providers = replacements.getProviders();
          ParameterPlugin parameterPlugin = null;
          if (args != null) {
              parameterPlugin = new ConstantBindingParameterPlugin(args, providers.getMetaAccess(), replacements.snippetReflection);
          }
  
<span class="line-modified">!         try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method)) {</span>
              // @formatter:off
<span class="line-modified">!             StructuredGraph result = new StructuredGraph.Builder(replacements.getOptions(), debug)</span>
<span class="line-modified">!                             .method(method)</span>
<span class="line-modified">!                             .trackNodeSourcePosition(encodedGraph.trackNodeSourcePosition())</span>
<span class="line-modified">!                             .setIsSubstitution(true)</span>
<span class="line-modified">!                             .build();</span>
              // @formatter:on
              try (DebugContext.Scope scope = debug.scope(&quot;DecodeSnippetGraph&quot;, result)) {
<span class="line-modified">!                 PEGraphDecoder graphDecoder = new PEGraphDecoder(</span>
<span class="line-removed">-                                 architecture,</span>
<span class="line-removed">-                                 result,</span>
<span class="line-removed">-                                 providers.getMetaAccess(),</span>
<span class="line-removed">-                                 providers.getConstantReflection(),</span>
<span class="line-removed">-                                 providers.getConstantFieldProvider(),</span>
<span class="line-removed">-                                 providers.getStampProvider(),</span>
<span class="line-removed">-                                 null,</span>
<span class="line-removed">-                                 replacements.getGraphBuilderPlugins().getInvocationPlugins(),</span>
<span class="line-removed">-                                 new InlineInvokePlugin[0],</span>
<span class="line-removed">-                                 parameterPlugin,</span>
<span class="line-removed">-                                 null,</span>
<span class="line-removed">-                                 null,</span>
<span class="line-removed">-                                 null) {</span>
<span class="line-removed">-                     @Override</span>
<span class="line-removed">-                     protected EncodedGraph lookupEncodedGraph(</span>
<span class="line-removed">-                                     ResolvedJavaMethod lookupMethod,</span>
<span class="line-removed">-                                     ResolvedJavaMethod originalMethod,</span>
<span class="line-removed">-                                     BytecodeProvider intrinsicBytecodeProvider,</span>
<span class="line-removed">-                                     boolean isSubstitution,</span>
<span class="line-removed">-                                     boolean track) {</span>
<span class="line-removed">-                         if (lookupMethod.equals(method)) {</span>
<span class="line-removed">-                             assert !track || encodedGraph.trackNodeSourcePosition();</span>
<span class="line-removed">-                             return encodedGraph;</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             throw GraalError.shouldNotReachHere(method.format(&quot;%H.%n(%p)&quot;));</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 };</span>
  
                  graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
                  debug.dump(DebugContext.VERBOSE_LEVEL, result, &quot;After decoding&quot;);
  
                  assert result.verify();
<span class="line-new-header">--- 353,105 ---</span>
                  } else {
                      return null;
                  }
              }
  
<span class="line-modified">!             SymbolicEncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses,</span>
<span class="line-modified">!                             originalMethods.get(methodKey(method)), method.getDeclaringClass());</span>
<span class="line-modified">!             return decodeSnippetGraph(encodedGraph, method, replacements, args, allowAssumptions, options);</span>
          }
  
      }
  
<span class="line-modified">!     private static class SubstitutionGraphDecoder extends PEGraphDecoder {</span>
<span class="line-added">+         private final ResolvedJavaMethod method;</span>
<span class="line-added">+         private final EncodedGraph encodedGraph;</span>
<span class="line-added">+         private IntrinsicContext intrinsic;</span>
<span class="line-added">+ </span>
<span class="line-added">+         SubstitutionGraphDecoder(Providers providers, StructuredGraph result, ReplacementsImpl replacements, ParameterPlugin parameterPlugin, ResolvedJavaMethod method,</span>
<span class="line-added">+                         IntrinsicContext.CompilationContext context, EncodedGraph encodedGraph) {</span>
<span class="line-added">+             super(providers.getCodeCache().getTarget().arch, result, providers, null,</span>
<span class="line-added">+                             replacements.getGraphBuilderPlugins().getInvocationPlugins(), new InlineInvokePlugin[0], parameterPlugin,</span>
<span class="line-added">+                             null, null, null, null);</span>
<span class="line-added">+             this.method = method;</span>
<span class="line-added">+             this.encodedGraph = encodedGraph;</span>
<span class="line-added">+             intrinsic = new IntrinsicContext(method, null, replacements.getDefaultReplacementBytecodeProvider(), context, false);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected EncodedGraph lookupEncodedGraph(ResolvedJavaMethod lookupMethod,</span>
<span class="line-added">+                         MethodSubstitutionPlugin plugin,</span>
<span class="line-added">+                         BytecodeProvider intrinsicBytecodeProvider,</span>
<span class="line-added">+                         boolean isSubstitution,</span>
<span class="line-added">+                         boolean trackNodeSourcePosition) {</span>
<span class="line-added">+             if (lookupMethod.equals(method)) {</span>
<span class="line-added">+                 return encodedGraph;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 throw GraalError.shouldNotReachHere(method.format(&quot;%H.%n(%p)&quot;));</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected IntrinsicContext getIntrinsic() {</span>
<span class="line-added">+             return intrinsic;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private StructuredGraph buildGraph(ResolvedJavaMethod method, ResolvedJavaMethod original, String originalMethodString, Object receiver, boolean requireInlining, boolean trackNodeSourcePosition,</span>
<span class="line-added">+                     IntrinsicContext.CompilationContext context, OptionValues options) {</span>
          assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
          Object[] args = null;
          if (receiver != null) {
              args = new Object[method.getSignature().getParameterCount(true)];
              args[0] = receiver;
          }
<span class="line-modified">!         // To get dumping out from this context during image building, it&#39;s necessary to pass the</span>
<span class="line-modified">!         // dumping options directly to the VM, otherwise they aren&#39;t available during initialization</span>
<span class="line-added">+         // of the backend. Use this:</span>
<span class="line-added">+         //</span>
<span class="line-added">+         // -J-Dgraal.Dump=SymbolicSnippetEncoder_:2 -J-Dgraal.PrintGraph=File</span>
<span class="line-added">+         // -J-Dgraal.DebugStubsAndSnippets=true</span>
<span class="line-added">+         IntrinsicContext.CompilationContext contextToUse = context;</span>
<span class="line-added">+         if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {</span>
<span class="line-added">+             contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         try (DebugContext debug = openDebugContext(&quot;SymbolicSnippetEncoder_&quot;, method, options)) {</span>
<span class="line-added">+             StructuredGraph graph = snippetReplacements.makeGraph(debug, snippetReplacements.getDefaultReplacementBytecodeProvider(), method, args, original, trackNodeSourcePosition, null,</span>
<span class="line-added">+                             contextToUse);</span>
  
              // Check if all methods which should be inlined are really inlined.
              for (MethodCallTargetNode callTarget : graph.getNodes(MethodCallTargetNode.TYPE)) {
                  ResolvedJavaMethod callee = callTarget.targetMethod();
                  if (requireInlining &amp;&amp; !delayedInvocationPluginMethods.contains(callee) &amp;&amp; !Objects.equals(callee, original)) {
                      throw GraalError.shouldNotReachHere(&quot;method &quot; + callee.format(&quot;%H.%n&quot;) + &quot; not inlined in snippet &quot; + method.getName() + &quot; (maybe not final?)&quot;);
                  }
              }
<span class="line-modified">!             assert verifySnippetEncodeDecode(debug, method, original, originalMethodString, trackNodeSourcePosition, graph);</span>
              debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;After buildGraph&quot;);
              return graph;
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     private static StructuredGraph decodeSnippetGraph(SymbolicEncodedGraph encodedGraph, ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args,</span>
<span class="line-added">+                     StructuredGraph.AllowAssumptions allowAssumptions, OptionValues options) {</span>
          Providers providers = replacements.getProviders();
          ParameterPlugin parameterPlugin = null;
          if (args != null) {
              parameterPlugin = new ConstantBindingParameterPlugin(args, providers.getMetaAccess(), replacements.snippetReflection);
          }
  
<span class="line-modified">!         try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method, options)) {</span>
              // @formatter:off
<span class="line-modified">!             StructuredGraph result = new StructuredGraph.Builder(options, debug, allowAssumptions)</span>
<span class="line-modified">!                     .method(method)</span>
<span class="line-modified">!                     .trackNodeSourcePosition(encodedGraph.trackNodeSourcePosition())</span>
<span class="line-modified">!                     .setIsSubstitution(true)</span>
<span class="line-modified">!                     .build();</span>
              // @formatter:on
              try (DebugContext.Scope scope = debug.scope(&quot;DecodeSnippetGraph&quot;, result)) {
<span class="line-modified">!                 PEGraphDecoder graphDecoder = new SubstitutionGraphDecoder(providers, result, replacements, parameterPlugin, method, INLINE_AFTER_PARSING, encodedGraph);</span>
  
                  graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
                  debug.dump(DebugContext.VERBOSE_LEVEL, result, &quot;After decoding&quot;);
  
                  assert result.verify();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,64 ***</span>
              }
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     private boolean verifySnippetEncodeDecode(ResolvedJavaMethod method, ResolvedJavaMethod original, boolean trackNodeSourcePosition, StructuredGraph structuredGraph) {</span>
          // Verify the encoding and decoding process
<span class="line-modified">!         EncodedGraph encodedGraph = GraphEncoder.encodeSingleGraph(structuredGraph, HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         Architecture arch = HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         try (DebugContext debug = replacements.openDebugContext(&quot;VerifySnippetEncodeDecode_&quot;, method)) {</span>
<span class="line-modified">!             HotSpotProviders originalProvider = (HotSpotProviders) replacements.getProviders();</span>
<span class="line-modified">! </span>
<span class="line-modified">!             SnippetReflectionProvider snippetReflection = originalProvider.getSnippetReflection();</span>
<span class="line-modified">!             SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider constantReflection = new SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider(</span>
<span class="line-modified">!                             originalProvider.getConstantReflection());</span>
<span class="line-modified">!             HotSpotProviders newProviders = new HotSpotProviders(originalProvider.getMetaAccess(), originalProvider.getCodeCache(), constantReflection,</span>
<span class="line-modified">!                             originalProvider.getConstantFieldProvider(), originalProvider.getForeignCalls(), originalProvider.getLowerer(), null, originalProvider.getSuites(),</span>
<span class="line-modified">!                             originalProvider.getRegisters(), snippetReflection, originalProvider.getWordTypes(), originalProvider.getGraphBuilderPlugins());</span>
<span class="line-modified">!             HotSpotSnippetReplacementsImpl filteringReplacements = new HotSpotSnippetReplacementsImpl(getOptions(), newProviders, snippetReflection,</span>
<span class="line-modified">!                             originalProvider.getReplacements().getDefaultReplacementBytecodeProvider(),</span>
<span class="line-modified">!                             originalProvider.getCodeCache().getTarget());</span>
<span class="line-removed">-             filteringReplacements.setGraphBuilderPlugins(originalProvider.getReplacements().getGraphBuilderPlugins());</span>
<span class="line-removed">-             try (DebugContext.Scope scaope = debug.scope(&quot;VerifySnippetEncodeDecode&quot;, structuredGraph)) {</span>
<span class="line-removed">-                 for (int i = 0; i &lt; encodedGraph.getNumObjects(); i++) {</span>
<span class="line-removed">-                     filterSnippetObject(encodedGraph.getObject(i));</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 StructuredGraph snippet = filteringReplacements.makeGraph(debug, filteringReplacements.getDefaultReplacementBytecodeProvider(), method, null, original,</span>
<span class="line-removed">-                                 trackNodeSourcePosition, null);</span>
<span class="line-removed">-                 SymbolicEncodedGraph symbolicGraph = new SymbolicEncodedGraph(encodedGraph, method.getDeclaringClass(), original != null ? methodKey(original) : null);</span>
<span class="line-removed">-                 StructuredGraph decodedSnippet = decodeSnippetGraph(symbolicGraph, method, replacements, null, arch);</span>
<span class="line-removed">-                 String snippetString = getCanonicalGraphString(snippet, true, false);</span>
<span class="line-removed">-                 String decodedSnippetString = getCanonicalGraphString(decodedSnippet, true, false);</span>
<span class="line-removed">-                 if (snippetString.equals(decodedSnippetString)) {</span>
<span class="line-removed">-                     debug.log(&quot;Snippet decode for %s produces exactly same graph&quot;, method);</span>
<span class="line-removed">-                     debug.dump(DebugContext.INFO_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     debug.log(&quot;Snippet decode for %s produces different graph&quot;, method);</span>
<span class="line-removed">-                     debug.log(&quot;%s&quot;, compareGraphStrings(snippet, snippetString, decodedSnippet, decodedSnippetString));</span>
<span class="line-removed">-                     debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;Snippet graph for %s&quot;, method);</span>
<span class="line-removed">-                     debug.dump(DebugContext.INFO_LEVEL, structuredGraph, &quot;Encoded snippet graph for %s&quot;, method);</span>
<span class="line-removed">-                     debug.dump(DebugContext.INFO_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } catch (Throwable t) {</span>
<span class="line-removed">-                 throw debug.handle(t);</span>
              }
          }
          return true;
      }
  
      /**
       * If there are new graphs waiting to be encoded, reencode all the graphs and return the result.
       */
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     synchronized EncodedSnippets maybeEncodeSnippets() {</span>
          Map&lt;String, StructuredGraph&gt; graphs = this.preparedSnippetGraphs;
          if (encodedGraphs != graphs.size()) {
<span class="line-modified">!             DebugContext debug = openDebugContext(&quot;SnippetEncoder&quot;, null);</span>
              try (DebugContext.Scope scope = debug.scope(&quot;SnippetSupportEncode&quot;)) {
                  encodedGraphs = graphs.size();
                  for (StructuredGraph graph : graphs.values()) {
                      for (Node node : graph.getNodes()) {
                          node.setNodeSourcePosition(null);
<span class="line-new-header">--- 461,72 ---</span>
              }
          }
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     private boolean verifySnippetEncodeDecode(DebugContext debug, ResolvedJavaMethod method, ResolvedJavaMethod original, String originalMethodString, boolean trackNodeSourcePosition,</span>
<span class="line-added">+                     StructuredGraph graph) {</span>
          // Verify the encoding and decoding process
<span class="line-modified">!         EncodedGraph encodedGraph = GraphEncoder.encodeSingleGraph(graph, HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         HotSpotProviders originalProvider = (HotSpotProviders) snippetReplacements.getProviders();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         SnippetReflectionProvider snippetReflection = originalProvider.getSnippetReflection();</span>
<span class="line-modified">!         SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider constantReflection = new SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider(</span>
<span class="line-modified">!                         originalProvider.getConstantReflection());</span>
<span class="line-modified">!         HotSpotProviders newProviders = new HotSpotProviders(originalProvider.getMetaAccess(), originalProvider.getCodeCache(), constantReflection,</span>
<span class="line-modified">!                         originalProvider.getConstantFieldProvider(), originalProvider.getForeignCalls(), originalProvider.getLowerer(), null, originalProvider.getSuites(),</span>
<span class="line-modified">!                         originalProvider.getRegisters(), snippetReflection, originalProvider.getWordTypes(), originalProvider.getGraphBuilderPlugins(), originalProvider.getGC());</span>
<span class="line-modified">!         HotSpotSnippetReplacementsImpl filteringReplacements = new HotSpotSnippetReplacementsImpl(newProviders, snippetReflection,</span>
<span class="line-modified">!                         originalProvider.getReplacements().getDefaultReplacementBytecodeProvider(), originalProvider.getCodeCache().getTarget());</span>
<span class="line-modified">!         filteringReplacements.setGraphBuilderPlugins(originalProvider.getReplacements().getGraphBuilderPlugins());</span>
<span class="line-modified">!         try (DebugContext.Scope scaope = debug.scope(&quot;VerifySnippetEncodeDecode&quot;, graph)) {</span>
<span class="line-modified">!             for (int i = 0; i &lt; encodedGraph.getNumObjects(); i++) {</span>
<span class="line-modified">!                 filterSnippetObject(encodedGraph.getObject(i));</span>
              }
<span class="line-added">+             StructuredGraph snippet = filteringReplacements.makeGraph(debug, filteringReplacements.getDefaultReplacementBytecodeProvider(), method, null, original,</span>
<span class="line-added">+                             trackNodeSourcePosition, null);</span>
<span class="line-added">+             SymbolicEncodedGraph symbolicGraph = new SymbolicEncodedGraph(encodedGraph, method.getDeclaringClass(), originalMethodString);</span>
<span class="line-added">+             StructuredGraph decodedSnippet = decodeSnippetGraph(symbolicGraph, original != null ? original : method, originalReplacements, null,</span>
<span class="line-added">+                             StructuredGraph.AllowAssumptions.ifNonNull(graph.getAssumptions()), graph.getOptions());</span>
<span class="line-added">+             String snippetString = getCanonicalGraphString(snippet, true, false);</span>
<span class="line-added">+             String decodedSnippetString = getCanonicalGraphString(decodedSnippet, true, false);</span>
<span class="line-added">+             if (snippetString.equals(decodedSnippetString)) {</span>
<span class="line-added">+                 debug.log(&quot;Snippet decode for %s produces exactly same graph&quot;, method);</span>
<span class="line-added">+                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 debug.log(&quot;Snippet decode for %s produces different graph&quot;, method);</span>
<span class="line-added">+                 debug.log(&quot;%s&quot;, compareGraphStrings(snippet, snippetString, decodedSnippet, decodedSnippetString));</span>
<span class="line-added">+                 debug.dump(DebugContext.VERBOSE_LEVEL, snippet, &quot;Snippet graph for %s&quot;, method);</span>
<span class="line-added">+                 debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Encoded snippet graph for %s&quot;, method);</span>
<span class="line-added">+                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } catch (Throwable t) {</span>
<span class="line-added">+             throw debug.handle(t);</span>
          }
          return true;
      }
  
      /**
       * If there are new graphs waiting to be encoded, reencode all the graphs and return the result.
       */
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     private synchronized EncodedSnippets maybeEncodeSnippets(OptionValues options) {</span>
<span class="line-added">+         Set&lt;MethodSubstitutionPlugin&gt; plugins = this.knownPlugins;</span>
<span class="line-added">+         if (preparedPlugins != plugins.size()) {</span>
<span class="line-added">+             for (MethodSubstitutionPlugin plugin : plugins) {</span>
<span class="line-added">+                 ResolvedJavaMethod original = plugin.getOriginalMethod(originalReplacements.getProviders().getMetaAccess());</span>
<span class="line-added">+                 registerMethodSubstitution(plugin, original, INLINE_AFTER_PARSING, options);</span>
<span class="line-added">+                 if (!original.isNative()) {</span>
<span class="line-added">+                     registerMethodSubstitution(plugin, original, ROOT_COMPILATION_ENCODING, options);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             preparedPlugins = plugins.size();</span>
<span class="line-added">+         }</span>
          Map&lt;String, StructuredGraph&gt; graphs = this.preparedSnippetGraphs;
          if (encodedGraphs != graphs.size()) {
<span class="line-modified">!             DebugContext debug = openDebugContext(&quot;SnippetEncoder&quot;, null, options);</span>
              try (DebugContext.Scope scope = debug.scope(&quot;SnippetSupportEncode&quot;)) {
                  encodedGraphs = graphs.size();
                  for (StructuredGraph graph : graphs.values()) {
                      for (Node node : graph.getNodes()) {
                          node.setNodeSourcePosition(null);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,27 ***</span>
              }
          }
          return null;
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition) {</span>
<span class="line-removed">-         if (IS_BUILDING_NATIVE_IMAGE || UseEncodedSnippets.getValue(getOptions())) {</span>
              assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
              String key = methodKey(method);
              if (!preparedSnippetGraphs.containsKey(key)) {
                  if (original != null) {
                      originalMethods.put(key, methodKey(original));
                  }
<span class="line-modified">!                 StructuredGraph snippet = buildGraph(method, original, receiver, true, trackNodeSourcePosition);</span>
                  snippetMethods.add(method);
                  preparedSnippetGraphs.put(key, snippet);
              }
          }
      }
  
<span class="line-modified">!     EncodedSnippets encodeSnippets(DebugContext debug) {</span>
          GraphEncoder encoder = new GraphEncoder(HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch, debug);
          for (StructuredGraph graph : preparedSnippetGraphs.values()) {
              encoder.prepare(graph);
          }
          encoder.finishPrepare();
<span class="line-new-header">--- 536,27 ---</span>
              }
          }
          return null;
      }
  
<span class="line-modified">!     synchronized void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {</span>
<span class="line-modified">!         if (IS_BUILDING_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {</span>
              assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
              String key = methodKey(method);
              if (!preparedSnippetGraphs.containsKey(key)) {
                  if (original != null) {
                      originalMethods.put(key, methodKey(original));
                  }
<span class="line-modified">!                 StructuredGraph snippet = buildGraph(method, original, null, receiver, true, trackNodeSourcePosition, INLINE_AFTER_PARSING, options);</span>
                  snippetMethods.add(method);
                  preparedSnippetGraphs.put(key, snippet);
              }
          }
<span class="line-added">+ </span>
      }
  
<span class="line-modified">!     private synchronized EncodedSnippets encodeSnippets(DebugContext debug) {</span>
          GraphEncoder encoder = new GraphEncoder(HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch, debug);
          for (StructuredGraph graph : preparedSnippetGraphs.values()) {
              encoder.prepare(graph);
          }
          encoder.finishPrepare();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,51 ***</span>
  
      /**
       * Encode any outstanding graphs and return true if any work was done.
       */
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     public boolean encode() {</span>
<span class="line-modified">!         EncodedSnippets encodedSnippets = maybeEncodeSnippets();</span>
          if (encodedSnippets != null) {
              HotSpotReplacementsImpl.setEncodedSnippets(encodedSnippets);
              return true;
          }
          return false;
      }
  
<span class="line-modified">!     private DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method) {</span>
<span class="line-modified">!         return replacements.openDebugContext(idPrefix, method);</span>
      }
  
      static class SymbolicEncodedGraph extends EncodedGraph {
  
<span class="line-modified">!         private final ResolvedJavaType accessingClass;</span>
          private final String originalMethod;
  
<span class="line-modified">!         SymbolicEncodedGraph(byte[] encoding, int startOffset, Object[] objects, NodeClass&lt;?&gt;[] types, ResolvedJavaType accessingClass, String originalMethod) {</span>
              super(encoding, startOffset, objects, types, null, null, null, false, false);
<span class="line-modified">!             this.accessingClass = accessingClass;</span>
              this.originalMethod = originalMethod;
          }
  
          SymbolicEncodedGraph(EncodedGraph encodedGraph, ResolvedJavaType declaringClass, String originalMethod) {
<span class="line-modified">!             this(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), encodedGraph.getObjects(), encodedGraph.getNodeClasses(), declaringClass, originalMethod);</span>
          }
  
          @Override
          public Object getObject(int i) {
              Object o = objects[i];
              if (o instanceof SymbolicJVMCIReference) {
<span class="line-modified">!                 objects[i] = o = ((SymbolicJVMCIReference&lt;?&gt;) o).resolve(accessingClass);</span>
              } else if (o instanceof UnresolvedJavaType) {
<span class="line-modified">!                 objects[i] = o = ((UnresolvedJavaType) o).resolve(accessingClass);</span>
              } else if (o instanceof UnresolvedJavaMethod) {
                  throw new InternalError(o.toString());
              } else if (o instanceof UnresolvedJavaField) {
<span class="line-modified">!                 objects[i] = o = ((UnresolvedJavaField) o).resolve(accessingClass);</span>
              } else if (o instanceof GraalCapability) {
<span class="line-modified">!                 objects[i] = o = ((GraalCapability) o).resolve(((GraalJVMCICompiler) getRuntime().getCompiler()).getGraalRuntime());</span>
              }
              return o;
          }
  
          @Override
<span class="line-new-header">--- 584,78 ---</span>
  
      /**
       * Encode any outstanding graphs and return true if any work was done.
       */
      @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">!     public boolean encode(OptionValues options) {</span>
<span class="line-modified">!         EncodedSnippets encodedSnippets = maybeEncodeSnippets(options);</span>
          if (encodedSnippets != null) {
              HotSpotReplacementsImpl.setEncodedSnippets(encodedSnippets);
              return true;
          }
          return false;
      }
  
<span class="line-modified">!     private DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method, OptionValues options) {</span>
<span class="line-modified">!         return snippetReplacements.openDebugContext(idPrefix, method, options);</span>
      }
  
      static class SymbolicEncodedGraph extends EncodedGraph {
  
<span class="line-modified">!         private final ResolvedJavaType[] accessingClasses;</span>
          private final String originalMethod;
  
<span class="line-modified">!         SymbolicEncodedGraph(byte[] encoding, int startOffset, Object[] objects, NodeClass&lt;?&gt;[] types, String originalMethod, ResolvedJavaType... accessingClasses) {</span>
              super(encoding, startOffset, objects, types, null, null, null, false, false);
<span class="line-modified">!             this.accessingClasses = accessingClasses;</span>
              this.originalMethod = originalMethod;
          }
  
          SymbolicEncodedGraph(EncodedGraph encodedGraph, ResolvedJavaType declaringClass, String originalMethod) {
<span class="line-modified">!             this(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), encodedGraph.getObjects(), encodedGraph.getNodeClasses(),</span>
<span class="line-added">+                             originalMethod, declaringClass);</span>
          }
  
          @Override
          public Object getObject(int i) {
              Object o = objects[i];
<span class="line-added">+             Object replacement = null;</span>
              if (o instanceof SymbolicJVMCIReference) {
<span class="line-modified">!                 for (ResolvedJavaType type : accessingClasses) {</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         replacement = ((SymbolicJVMCIReference&lt;?&gt;) o).resolve(type);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     } catch (NoClassDefFoundError e) {</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              } else if (o instanceof UnresolvedJavaType) {
<span class="line-modified">!                 for (ResolvedJavaType type : accessingClasses) {</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         replacement = ((UnresolvedJavaType) o).resolve(type);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     } catch (NoClassDefFoundError e) {</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              } else if (o instanceof UnresolvedJavaMethod) {
                  throw new InternalError(o.toString());
              } else if (o instanceof UnresolvedJavaField) {
<span class="line-modified">!                 for (ResolvedJavaType type : accessingClasses) {</span>
<span class="line-added">+                     try {</span>
<span class="line-added">+                         replacement = ((UnresolvedJavaField) o).resolve(type);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     } catch (NoClassDefFoundError e) {</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              } else if (o instanceof GraalCapability) {
<span class="line-modified">!                 replacement = ((GraalCapability) o).resolve(((GraalJVMCICompiler) getRuntime().getCompiler()).getGraalRuntime());</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 return o;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (replacement != null) {</span>
<span class="line-added">+                 objects[i] = o = replacement;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 throw new GraalError(&quot;Can&#39;t resolve &quot; + o);</span>
              }
              return o;
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 639,11 ***</span>
      static class SymbolicResolvedJavaMethod implements SymbolicJVMCIReference&lt;ResolvedJavaMethod&gt; {
          final UnresolvedJavaType type;
          final String methodName;
          final String signature;
  
<span class="line-modified">!         SymbolicResolvedJavaMethod(HotSpotResolvedJavaMethod method) {</span>
              this.type = UnresolvedJavaType.create(method.getDeclaringClass().getName());
              this.methodName = method.getName();
              this.signature = method.getSignature().toMethodDescriptor();
          }
  
<span class="line-new-header">--- 691,11 ---</span>
      static class SymbolicResolvedJavaMethod implements SymbolicJVMCIReference&lt;ResolvedJavaMethod&gt; {
          final UnresolvedJavaType type;
          final String methodName;
          final String signature;
  
<span class="line-modified">!         SymbolicResolvedJavaMethod(ResolvedJavaMethod method) {</span>
              this.type = UnresolvedJavaType.create(method.getDeclaringClass().getName());
              this.methodName = method.getName();
              this.signature = method.getSignature().toMethodDescriptor();
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 657,10 ***</span>
<span class="line-new-header">--- 709,13 ---</span>
          }
  
          @Override
          public ResolvedJavaMethod resolve(ResolvedJavaType accessingClass) {
              ResolvedJavaType resolvedType = type.resolve(accessingClass);
<span class="line-added">+             if (resolvedType == null) {</span>
<span class="line-added">+                 throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());</span>
<span class="line-added">+             }</span>
              for (ResolvedJavaMethod method : methodName.equals(&quot;&lt;init&gt;&quot;) ? resolvedType.getDeclaredConstructors() : resolvedType.getDeclaredMethods()) {
                  if (method.getName().equals(methodName) &amp;&amp; method.getSignature().toMethodDescriptor().equals(signature)) {
                      return method;
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,11 ***</span>
          final UnresolvedJavaType declaringType;
          final String name;
          final UnresolvedJavaType signature;
          private final boolean isStatic;
  
<span class="line-modified">!         SymbolicResolvedJavaField(HotSpotResolvedJavaField field) {</span>
              this.declaringType = UnresolvedJavaType.create(field.getDeclaringClass().getName());
              this.name = field.getName();
              this.signature = UnresolvedJavaType.create(field.getType().getName());
              this.isStatic = field.isStatic();
          }
<span class="line-new-header">--- 727,11 ---</span>
          final UnresolvedJavaType declaringType;
          final String name;
          final UnresolvedJavaType signature;
          private final boolean isStatic;
  
<span class="line-modified">!         SymbolicResolvedJavaField(ResolvedJavaField field) {</span>
              this.declaringType = UnresolvedJavaType.create(field.getDeclaringClass().getName());
              this.name = field.getName();
              this.signature = UnresolvedJavaType.create(field.getType().getName());
              this.isStatic = field.isStatic();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 704,10 ***</span>
<span class="line-new-header">--- 759,23 ---</span>
                              name +
                              &#39;}&#39;;
          }
      }
  
<span class="line-added">+     static class SymbolicResolvedJavaMethodBytecode implements SymbolicJVMCIReference&lt;ResolvedJavaMethodBytecode&gt; {</span>
<span class="line-added">+         SymbolicResolvedJavaMethod method;</span>
<span class="line-added">+ </span>
<span class="line-added">+         SymbolicResolvedJavaMethodBytecode(ResolvedJavaMethodBytecode bytecode) {</span>
<span class="line-added">+             method = new SymbolicResolvedJavaMethod(bytecode.getMethod());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public ResolvedJavaMethodBytecode resolve(ResolvedJavaType accessingClass) {</span>
<span class="line-added">+             return new ResolvedJavaMethodBytecode(method.resolve(accessingClass));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      static class SymbolicStampPair implements SymbolicJVMCIReference&lt;StampPair&gt; {
          Object trustedStamp;
          Object uncheckdStamp;
  
          SymbolicStampPair(StampPair stamp) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 767,11 ***</span>
          }
  
          @Override
          public JavaConstant readFieldValue(ResolvedJavaField field, JavaConstant receiver) {
              JavaConstant javaConstant = constantReflection.readFieldValue(field, receiver);
<span class="line-modified">!             if (!safeConstants.contains(receiver) &amp;&amp; !field.getDeclaringClass().getName().contains(&quot;graalvm&quot;) &amp;&amp; !field.getDeclaringClass().getName().contains(&quot;jdk/vm/ci/&quot;) &amp;&amp;</span>
                              !field.getName().equals(&quot;TYPE&quot;)) {
                  // Only permit constant reflection on compiler classes. This is necessary primarily
                  // because of the boxing snippets which are compiled as snippets but are really just
                  // regular JDK java sources that are being compiled like a snippet. These shouldn&#39;t
                  // permit constant folding during graph preparation as that embeds constants from
<span class="line-new-header">--- 835,15 ---</span>
          }
  
          @Override
          public JavaConstant readFieldValue(ResolvedJavaField field, JavaConstant receiver) {
              JavaConstant javaConstant = constantReflection.readFieldValue(field, receiver);
<span class="line-modified">!             if (!safeConstants.contains(receiver) &amp;&amp;</span>
<span class="line-added">+                             !field.getDeclaringClass().getName().contains(&quot;graalvm&quot;) &amp;&amp;</span>
<span class="line-added">+                             !field.getDeclaringClass().getName().contains(&quot;jdk/vm/ci/&quot;) &amp;&amp;</span>
<span class="line-added">+                             !field.getDeclaringClass().getName().contains(&quot;jdk/internal/vm/compiler&quot;) &amp;&amp;</span>
<span class="line-added">+ </span>
                              !field.getName().equals(&quot;TYPE&quot;)) {
                  // Only permit constant reflection on compiler classes. This is necessary primarily
                  // because of the boxing snippets which are compiled as snippets but are really just
                  // regular JDK java sources that are being compiled like a snippet. These shouldn&#39;t
                  // permit constant folding during graph preparation as that embeds constants from
</pre>
<hr />
<pre>
<span class="line-old-header">*** 827,17 ***</span>
  
      /**
       * Objects embedded in encoded graphs might need to converted into a symbolic form so convert
       * the object or pass it through.
       */
<span class="line-modified">!     static Object filterSnippetObject(Object o) {</span>
          if (o instanceof HotSpotResolvedJavaMethod) {
              return new SymbolicResolvedJavaMethod((HotSpotResolvedJavaMethod) o);
          } else if (o instanceof HotSpotResolvedJavaField) {
              return new SymbolicResolvedJavaField((HotSpotResolvedJavaField) o);
          } else if (o instanceof HotSpotResolvedJavaType) {
<span class="line-modified">!             return UnresolvedJavaType.create(((HotSpotResolvedJavaType) o).getName());</span>
          } else if (o instanceof NodeSourcePosition) {
              // Filter these out for now. These can&#39;t easily be handled because these positions
              // description snippet methods which might not be available in the runtime.
              return null;
          } else if (o instanceof HotSpotForeignCallsProvider || o instanceof GraalHotSpotVMConfig) {
<span class="line-new-header">--- 899,17 ---</span>
  
      /**
       * Objects embedded in encoded graphs might need to converted into a symbolic form so convert
       * the object or pass it through.
       */
<span class="line-modified">!     private static Object filterSnippetObject(Object o) {</span>
          if (o instanceof HotSpotResolvedJavaMethod) {
              return new SymbolicResolvedJavaMethod((HotSpotResolvedJavaMethod) o);
          } else if (o instanceof HotSpotResolvedJavaField) {
              return new SymbolicResolvedJavaField((HotSpotResolvedJavaField) o);
          } else if (o instanceof HotSpotResolvedJavaType) {
<span class="line-modified">!             return UnresolvedJavaType.create(((ResolvedJavaType) o).getName());</span>
          } else if (o instanceof NodeSourcePosition) {
              // Filter these out for now. These can&#39;t easily be handled because these positions
              // description snippet methods which might not be available in the runtime.
              return null;
          } else if (o instanceof HotSpotForeignCallsProvider || o instanceof GraalHotSpotVMConfig) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 850,15 ***</span>
              return o;
          } else if (o instanceof StampPair) {
              if (((StampPair) o).getTrustedStamp() instanceof AbstractObjectStamp) {
                  return new SymbolicStampPair((StampPair) o);
              }
          }
          return o;
      }
  
<span class="line-modified">!     static String compareGraphStrings(StructuredGraph expectedGraph, String expectedString, StructuredGraph actualGraph, String actualString) {</span>
          if (!expectedString.equals(actualString)) {
              String[] expectedLines = expectedString.split(&quot;\n&quot;);
              String[] actualLines = actualString.split(&quot;\n&quot;);
              int diffIndex = -1;
              int limit = Math.min(actualLines.length, expectedLines.length);
<span class="line-new-header">--- 922,19 ---</span>
              return o;
          } else if (o instanceof StampPair) {
              if (((StampPair) o).getTrustedStamp() instanceof AbstractObjectStamp) {
                  return new SymbolicStampPair((StampPair) o);
              }
<span class="line-added">+         } else if (o instanceof ResolvedJavaMethodBytecode) {</span>
<span class="line-added">+             return new SymbolicResolvedJavaMethodBytecode((ResolvedJavaMethodBytecode) o);</span>
<span class="line-added">+         } else if (o instanceof HotSpotSignature) {</span>
<span class="line-added">+             throw new GraalError(o.toString());</span>
          }
          return o;
      }
  
<span class="line-modified">!     private static String compareGraphStrings(StructuredGraph expectedGraph, String expectedString, StructuredGraph actualGraph, String actualString) {</span>
          if (!expectedString.equals(actualString)) {
              String[] expectedLines = expectedString.split(&quot;\n&quot;);
              String[] actualLines = actualString.split(&quot;\n&quot;);
              int diffIndex = -1;
              int limit = Math.min(actualLines.length, expectedLines.length);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 890,11 ***</span>
          } else {
              return &quot;mismatch in preparedSnippetGraphs&quot;;
          }
      }
  
<span class="line-modified">!     static String getCanonicalGraphString(StructuredGraph graph, boolean excludeVirtual, boolean checkConstants) {</span>
          SchedulePhase schedule = new SchedulePhase(SchedulePhase.SchedulingStrategy.EARLIEST);
          schedule.apply(graph);
          StructuredGraph.ScheduleResult scheduleResult = graph.getLastSchedule();
  
          NodeMap&lt;Integer&gt; canonicalId = graph.createNodeMap();
<span class="line-new-header">--- 966,11 ---</span>
          } else {
              return &quot;mismatch in preparedSnippetGraphs&quot;;
          }
      }
  
<span class="line-modified">!     private static String getCanonicalGraphString(StructuredGraph graph, boolean excludeVirtual, boolean checkConstants) {</span>
          SchedulePhase schedule = new SchedulePhase(SchedulePhase.SchedulingStrategy.EARLIEST);
          schedule.apply(graph);
          StructuredGraph.ScheduleResult scheduleResult = graph.getLastSchedule();
  
          NodeMap&lt;Integer&gt; canonicalId = graph.createNodeMap();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 970,65 ***</span>
  
      /**
       * This horror show of classes exists solely get {@link HotSpotSnippetBytecodeParser} to be used
       * as the parser for these snippets.
       */
<span class="line-modified">!     static class HotSpotSnippetReplacementsImpl extends HotSpotReplacementsImpl {</span>
          HotSpotSnippetReplacementsImpl(HotSpotReplacementsImpl replacements, Providers providers) {
              super(replacements, providers);
          }
  
<span class="line-modified">!         HotSpotSnippetReplacementsImpl(OptionValues options, Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider, TargetDescription target) {</span>
<span class="line-modified">!             super(options, providers, snippetReflection, bytecodeProvider, target);</span>
          }
  
          @Override
          protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
              return new SnippetGraphMaker(this, substitute, original);
          }
      }
  
<span class="line-modified">!     static class SnippetGraphMaker extends ReplacementsImpl.GraphMaker {</span>
          SnippetGraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
              super(replacements, substitute, substitutedMethod);
          }
  
          @Override
<span class="line-modified">!         protected GraphBuilderPhase.Instance createGraphBuilder(MetaAccessProvider metaAccess, StampProvider stampProvider, ConstantReflectionProvider constantReflection,</span>
<span class="line-modified">!                         ConstantFieldProvider constantFieldProvider, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">!             return new HotSpotSnippetGraphBuilderPhase(metaAccess, stampProvider, constantReflection, constantFieldProvider, graphBuilderConfig, optimisticOpts,</span>
<span class="line-removed">-                             initialIntrinsicContext);</span>
          }
      }
  
<span class="line-modified">!     static class HotSpotSnippetGraphBuilderPhase extends GraphBuilderPhase.Instance {</span>
<span class="line-modified">!         HotSpotSnippetGraphBuilderPhase(MetaAccessProvider metaAccess, StampProvider stampProvider, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,</span>
<span class="line-modified">!                         GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-removed">-             super(metaAccess, stampProvider, constantReflection, constantFieldProvider, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>
          }
  
          @Override
          protected BytecodeParser createBytecodeParser(StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI, IntrinsicContext intrinsicContext) {
              return new HotSpotSnippetBytecodeParser(this, graph, parent, method, entryBCI, intrinsicContext);
          }
      }
  
<span class="line-modified">!     static class HotSpotSnippetBytecodeParser extends BytecodeParser {</span>
          HotSpotSnippetBytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI,
                          IntrinsicContext intrinsicContext) {
              super(graphBuilderInstance, graph, parent, method, entryBCI, intrinsicContext);
          }
  
          @Override
          public boolean canDeferPlugin(GeneratedInvocationPlugin plugin) {
<span class="line-modified">!             return plugin.getSource().equals(Fold.class) || plugin.getSource().equals(Node.NodeIntrinsic.class);</span>
          }
  
          @Override
<span class="line-modified">!         protected boolean tryInvocationPlugin(CallTargetNode.InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType, JavaType returnType) {</span>
              if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
                  return false;
              }
<span class="line-modified">!             return super.tryInvocationPlugin(invokeKind, args, targetMethod, resultType, returnType);</span>
          }
      }
  }
<span class="line-new-header">--- 1046,81 ---</span>
  
      /**
       * This horror show of classes exists solely get {@link HotSpotSnippetBytecodeParser} to be used
       * as the parser for these snippets.
       */
<span class="line-modified">!     class HotSpotSnippetReplacementsImpl extends HotSpotReplacementsImpl {</span>
          HotSpotSnippetReplacementsImpl(HotSpotReplacementsImpl replacements, Providers providers) {
              super(replacements, providers);
          }
  
<span class="line-modified">!         HotSpotSnippetReplacementsImpl(Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider, TargetDescription target) {</span>
<span class="line-modified">!             super(providers, snippetReflection, bytecodeProvider, target);</span>
          }
  
          @Override
          protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
              return new SnippetGraphMaker(this, substitute, original);
          }
      }
  
<span class="line-modified">!     class SnippetGraphMaker extends ReplacementsImpl.GraphMaker {</span>
          SnippetGraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
              super(replacements, substitute, substitutedMethod);
          }
  
          @Override
<span class="line-modified">!         protected GraphBuilderPhase.Instance createGraphBuilder(Providers providers, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts,</span>
<span class="line-modified">!                         IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">!             return new HotSpotSnippetGraphBuilderPhase(providers, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>
          }
      }
  
<span class="line-modified">!     class HotSpotSnippetGraphBuilderPhase extends GraphBuilderPhase.Instance {</span>
<span class="line-modified">!         HotSpotSnippetGraphBuilderPhase(Providers theProviders, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {</span>
<span class="line-modified">!             super(theProviders, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);</span>
          }
  
          @Override
          protected BytecodeParser createBytecodeParser(StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI, IntrinsicContext intrinsicContext) {
              return new HotSpotSnippetBytecodeParser(this, graph, parent, method, entryBCI, intrinsicContext);
          }
      }
  
<span class="line-modified">!     class HotSpotSnippetBytecodeParser extends BytecodeParser {</span>
          HotSpotSnippetBytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI,
                          IntrinsicContext intrinsicContext) {
              super(graphBuilderInstance, graph, parent, method, entryBCI, intrinsicContext);
          }
  
          @Override
          public boolean canDeferPlugin(GeneratedInvocationPlugin plugin) {
<span class="line-modified">!             // Fold is always deferred but NodeIntrinsics may have to wait if all their arguments</span>
<span class="line-added">+             // aren&#39;t constant yet.</span>
<span class="line-added">+             return plugin.isGeneratedFromFoldOrNodeIntrinsic();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected boolean canInlinePartialIntrinsicExit() {</span>
<span class="line-added">+             return false;</span>
          }
  
          @Override
<span class="line-modified">!         protected boolean tryInvocationPlugin(CallTargetNode.InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {</span>
              if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
                  return false;
              }
<span class="line-modified">!             if (targetMethod.getAnnotation(Fold.class) != null) {</span>
<span class="line-added">+                 // Always defer Fold until decode time but NodeIntrinsics may fold if they are able.</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);</span>
<span class="line-added">+             if (conditionalPlugins.contains(plugin)) {</span>
<span class="line-added">+                 // Because supporting arbitrary plugins in the context of encoded graphs is complex</span>
<span class="line-added">+                 // we disallow it. This limitation can be worked around through the use of method</span>
<span class="line-added">+                 // substitutions.</span>
<span class="line-added">+                 throw new GraalError(&quot;conditional plugins are unsupported in snippets and method substitutions: &quot; + targetMethod + &quot; &quot; + plugin);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return super.tryInvocationPlugin(invokeKind, args, targetMethod, resultType);</span>
          }
      }
  }
</pre>
<center><a href="JVMCIVersionCheck.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="debug/BenchmarkCounters.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotForeignCallsProviderImpl.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotForeignCallsProviderImpl.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotForeignCallsProviderImpl.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotForeignCallsProviderImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,19 +24,20 @@
 
 package org.graalvm.compiler.hotspot.meta;
 
 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.JavaCall;
 import static jdk.vm.ci.hotspot.HotSpotCallingConventionType.JavaCallee;
-import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.PRESERVES_REGISTERS;
+import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect.DESTROYS_ALL_CALLER_SAVE_REGISTERS;
 import static org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition.SAFEPOINT;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import jdk.internal.vm.compiler.collections.EconomicMap;
 import org.graalvm.compiler.core.common.LIRKind;
 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
+import org.graalvm.compiler.debug.GraalError;
 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Reexecutability;
 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.RegisterEffect;
 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage.Transition;
 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkageImpl;
@@ -111,43 +112,43 @@
      */
     public HotSpotForeignCallLinkage registerStubCall(
                     ForeignCallDescriptor descriptor,
                     Transition transition,
                     Reexecutability reexecutability,
+                    RegisterEffect effect,
                     LocationIdentity... killedLocations) {
         return register(HotSpotForeignCallLinkageImpl.create(metaAccess,
                         codeCache,
                         wordTypes,
                         this,
                         descriptor,
-                        0L, PRESERVES_REGISTERS,
+                        0L, effect,
                         JavaCall,
                         JavaCallee,
                         transition,
                         reexecutability,
                         killedLocations));
     }
 
     /**
-     * Creates and registers the linkage for a foreign call.
+     * Creates and registers the linkage for a foreign call. All foreign calls are assumed to have
+     * the effect {@link RegisterEffect#DESTROYS_ALL_CALLER_SAVE_REGISTERS} since they are outside
+     * of Graal's knowledge.
      *
      * @param descriptor the signature of the foreign call
      * @param address the address of the code to call (must be non-zero)
      * @param outgoingCcType outgoing (caller) calling convention type
-     * @param effect specifies if the call destroys or preserves all registers (apart from
-     *            temporaries which are always destroyed)
      * @param transition specifies if this is a {@linkplain Transition#LEAF leaf} call
      * @param reexecutability specifies if the foreign call can be re-executed without (meaningful)
      *            side effects. Deoptimization will not return to a point before a foreign call that
      *            cannot be re-executed.
      * @param killedLocations the memory locations killed by the foreign call
      */
     public HotSpotForeignCallLinkage registerForeignCall(
                     ForeignCallDescriptor descriptor,
                     long address,
                     CallingConvention.Type outgoingCcType,
-                    RegisterEffect effect,
                     Transition transition,
                     Reexecutability reexecutability,
                     LocationIdentity... killedLocations) {
         Class<?> resultType = descriptor.getResultType();
         assert address != 0 : descriptor;
@@ -156,11 +157,11 @@
                         codeCache,
                         wordTypes,
                         this,
                         descriptor,
                         address,
-                        effect,
+                        DESTROYS_ALL_CALLER_SAVE_REGISTERS,
                         outgoingCcType,
                         null, // incomingCcType
                         transition,
                         reexecutability,
                         killedLocations));
@@ -205,14 +206,22 @@
 
     @Override
     public HotSpotForeignCallLinkage lookupForeignCall(ForeignCallDescriptor descriptor) {
         assert foreignCalls != null : descriptor;
         HotSpotForeignCallLinkage callTarget = foreignCalls.get(descriptor);
+        if (callTarget == null) {
+            throw GraalError.shouldNotReachHere("missing implementation for runtime call: " + descriptor);
+        }
         callTarget.finalizeAddress(runtime.getHostBackend());
         return callTarget;
     }
 
+    @Override
+    public boolean isAvailable(ForeignCallDescriptor descriptor) {
+        return foreignCalls.containsKey(descriptor);
+    }
+
     @Override
     public boolean isReexecutable(ForeignCallDescriptor descriptor) {
         assert foreignCalls.containsKey(descriptor) : "unknown foreign call: " + descriptor;
         return foreignCalls.get(descriptor).isReexecutable();
     }

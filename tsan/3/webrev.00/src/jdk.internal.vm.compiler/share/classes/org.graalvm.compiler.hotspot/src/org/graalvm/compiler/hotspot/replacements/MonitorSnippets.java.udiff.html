<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/MonitorSnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InstanceOfSnippets.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NewObjectSnippets.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/MonitorSnippets.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,10 +23,11 @@</span>
  
  
  package org.graalvm.compiler.hotspot.replacements;
  
  import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;
<span class="udiff-line-added">+ import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;</span>
  import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
  import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfig.INJECTED_OPTIONVALUES;
  import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfig.INJECTED_VMCONFIG;
  import static org.graalvm.compiler.hotspot.nodes.AcquiredCASLockNode.mark;
  import static org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode.beginLockScope;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -36,10 +37,11 @@</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_CXQ_LOCATION;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_ENTRY_LIST_LOCATION;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_OWNER_LOCATION;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_RECURSION_LOCATION;
<span class="udiff-line-added">+ import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJECT_MONITOR_SUCC_LOCATION;</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.PROTOTYPE_MARK_WORD_LOCATION;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.ageMaskInPlace;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.biasedLockMaskInPlace;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.biasedLockPattern;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.epochMaskInPlace;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -49,10 +51,11 @@</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.monitorMask;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorCxqOffset;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorEntryListOffset;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorOwnerOffset;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorRecursionsOffset;
<span class="udiff-line-added">+ import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.objectMonitorSuccOffset;</span>
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.pageSize;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.prototypeMarkWordOffset;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.registerAsWord;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.stackBias;
  import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.unlockedMask;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108,20 +111,20 @@</span>
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.ReturnNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;</span>
  import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  import org.graalvm.compiler.nodes.extended.MembarNode;
  import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  import org.graalvm.compiler.nodes.java.MonitorExitNode;
  import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
  import org.graalvm.compiler.nodes.spi.LoweringTool;
  import org.graalvm.compiler.nodes.type.StampTool;
  import org.graalvm.compiler.options.OptionValues;
  import org.graalvm.compiler.phases.common.inlining.InliningUtil;
<span class="udiff-line-removed">- import org.graalvm.compiler.replacements.Log;</span>
  import org.graalvm.compiler.replacements.SnippetCounter;
  import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;
  import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
  import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
  import org.graalvm.compiler.replacements.Snippets;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -145,11 +148,11 @@</span>
   * The locking algorithm used is described in the paper
   * &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=1167515.1167496&quot;&gt; Eliminating synchronization-related
   * atomic operations with biased locking and bulk rebiasing&lt;/a&gt; by Kenneth Russell and David
   * Detlefs.
   *
<span class="udiff-line-modified-removed">-  * Comment below is reproduced from {@code markOop.hpp} for convenience:</span>
<span class="udiff-line-modified-added">+  * Comment below is reproduced from {@code markWord.hpp} for convenience:</span>
   *
   * &lt;pre&gt;
   *  Bit-format of an object header (most significant first, big endian layout below):
   *  32 bits:
   *  --------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -470,11 +473,11 @@</span>
       */
      @Snippet
      public static void monitorenterStub(Object object, @ConstantParameter int lockDepth, @ConstantParameter boolean trace) {
          verifyOop(object);
          incCounter();
<span class="udiff-line-modified-removed">-         if (object == null) {</span>
<span class="udiff-line-modified-added">+         if (BranchProbabilityNode.probability(BranchProbabilityNode.DEOPT_PROBABILITY, object == null)) {</span>
              DeoptimizeNode.deopt(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.NullCheckException);
          }
          // BeginLockScope nodes do not read from object so a use of object
          // cannot float about the null check above
          final Word lock = beginLockScope(lockDepth);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -572,10 +575,36 @@</span>
                      memoryBarrier(LOAD_STORE | STORE_STORE);
                      monitor.writeWord(ownerOffset, zero());
                      traceObject(trace, &quot;-lock{inflated:simple}&quot;, object, false);
                      counters.unlockInflatedSimple.inc();
                      return true;
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     int succOffset = objectMonitorSuccOffset(INJECTED_VMCONFIG);</span>
<span class="udiff-line-added">+                     Word succ = monitor.readWord(succOffset, OBJECT_MONITOR_SUCC_LOCATION);</span>
<span class="udiff-line-added">+                     if (probability(FREQUENT_PROBABILITY, succ.isNonNull())) {</span>
<span class="udiff-line-added">+                         // There may be a thread spinning on this monitor. Temporarily setting</span>
<span class="udiff-line-added">+                         // the monitor owner to null, and hope that the other thread will grab it.</span>
<span class="udiff-line-added">+                         monitor.writeWord(ownerOffset, zero());</span>
<span class="udiff-line-added">+                         memoryBarrier(STORE_STORE | STORE_LOAD);</span>
<span class="udiff-line-added">+                         succ = monitor.readWord(succOffset, OBJECT_MONITOR_SUCC_LOCATION);</span>
<span class="udiff-line-added">+                         if (probability(NOT_FREQUENT_PROBABILITY, succ.isNonNull())) {</span>
<span class="udiff-line-added">+                             // We manage to release the monitor before the other running thread even</span>
<span class="udiff-line-added">+                             // notices.</span>
<span class="udiff-line-added">+                             traceObject(trace, &quot;-lock{inflated:transfer}&quot;, object, false);</span>
<span class="udiff-line-added">+                             counters.unlockInflatedTransfer.inc();</span>
<span class="udiff-line-added">+                             return true;</span>
<span class="udiff-line-added">+                         } else {</span>
<span class="udiff-line-added">+                             // Either the monitor is grabbed by a spinning thread, or the spinning</span>
<span class="udiff-line-added">+                             // thread parks. Now we attempt to reset the owner of the monitor.</span>
<span class="udiff-line-added">+                             if (probability(FREQUENT_PROBABILITY, !monitor.logicCompareAndSwapWord(ownerOffset, zero(), thread, OBJECT_MONITOR_OWNER_LOCATION))) {</span>
<span class="udiff-line-added">+                                 // The monitor is stolen.</span>
<span class="udiff-line-added">+                                 traceObject(trace, &quot;-lock{inflated:transfer}&quot;, object, false);</span>
<span class="udiff-line-added">+                                 counters.unlockInflatedTransfer.inc();</span>
<span class="udiff-line-added">+                                 return true;</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
                  }
              }
              counters.unlockStubInflated.inc();
              traceObject(trace, &quot;-lock{stub:inflated}&quot;, object, false);
              monitorexitStubC(MONITOREXIT, object, lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -690,10 +719,11 @@</span>
          public final SnippetCounter unlockCas;
          public final SnippetCounter unlockCasRecursive;
          public final SnippetCounter unlockStub;
          public final SnippetCounter unlockStubInflated;
          public final SnippetCounter unlockInflatedSimple;
<span class="udiff-line-added">+         public final SnippetCounter unlockInflatedTransfer;</span>
  
          public Counters(SnippetCounter.Group.Factory factory) {
              SnippetCounter.Group enter = factory.createSnippetCounterGroup(&quot;MonitorEnters&quot;);
              SnippetCounter.Group exit = factory.createSnippetCounterGroup(&quot;MonitorExits&quot;);
              lockBiasExisting = new SnippetCounter(enter, &quot;lock{bias:existing}&quot;, &quot;bias-locked previously biased object&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -714,17 +744,19 @@</span>
              unlockCas = new SnippetCounter(exit, &quot;unlock{cas}&quot;, &quot;cas-unlocked an object&quot;);
              unlockCasRecursive = new SnippetCounter(exit, &quot;unlock{cas:recursive}&quot;, &quot;cas-unlocked an object, recursive&quot;);
              unlockStub = new SnippetCounter(exit, &quot;unlock{stub}&quot;, &quot;stub-unlocked an object&quot;);
              unlockStubInflated = new SnippetCounter(exit, &quot;unlock{stub:inflated}&quot;, &quot;stub-unlocked an object with inflated monitor&quot;);
              unlockInflatedSimple = new SnippetCounter(exit, &quot;unlock{inflated}&quot;, &quot;unlocked an object monitor&quot;);
<span class="udiff-line-added">+             unlockInflatedTransfer = new SnippetCounter(exit, &quot;unlock{inflated:transfer}&quot;, &quot;unlocked an object monitor in the presence of ObjectMonitor::_succ&quot;);</span>
          }
      }
  
      public static class Templates extends AbstractTemplates {
  
          private final SnippetInfo monitorenter = snippet(MonitorSnippets.class, &quot;monitorenter&quot;);
<span class="udiff-line-modified-removed">-         private final SnippetInfo monitorexit = snippet(MonitorSnippets.class, &quot;monitorexit&quot;);</span>
<span class="udiff-line-modified-added">+         private final SnippetInfo monitorexit = snippet(MonitorSnippets.class, &quot;monitorexit&quot;, DISPLACED_MARK_WORD_LOCATION, OBJECT_MONITOR_OWNER_LOCATION, OBJECT_MONITOR_CXQ_LOCATION,</span>
<span class="udiff-line-added">+                         OBJECT_MONITOR_ENTRY_LIST_LOCATION, OBJECT_MONITOR_RECURSION_LOCATION, OBJECT_MONITOR_SUCC_LOCATION);</span>
          private final SnippetInfo monitorenterStub = snippet(MonitorSnippets.class, &quot;monitorenterStub&quot;);
          private final SnippetInfo monitorexitStub = snippet(MonitorSnippets.class, &quot;monitorexitStub&quot;);
          private final SnippetInfo initCounter = snippet(MonitorSnippets.class, &quot;initCounter&quot;);
          private final SnippetInfo checkCounter = snippet(MonitorSnippets.class, &quot;checkCounter&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -829,11 +861,12 @@</span>
                      MethodCallTargetNode callTarget = graph.add(new MethodCallTargetNode(InvokeKind.Static, initCounter.getMethod(), new ValueNode[0], returnStamp, null));
                      InvokeNode invoke = graph.add(new InvokeNode(callTarget, 0));
                      invoke.setStateAfter(graph.start().stateAfter());
                      graph.addAfterFixed(graph.start(), invoke);
  
<span class="udiff-line-modified-removed">-                     StructuredGraph inlineeGraph = providers.getReplacements().getSnippet(initCounter.getMethod(), null, invoke.graph().trackNodeSourcePosition(), invoke.getNodeSourcePosition());</span>
<span class="udiff-line-modified-added">+                     StructuredGraph inlineeGraph = providers.getReplacements().getSnippet(initCounter.getMethod(), null, null, invoke.graph().trackNodeSourcePosition(), invoke.getNodeSourcePosition(),</span>
<span class="udiff-line-added">+                                     invoke.getOptions());</span>
                      InliningUtil.inline(invoke, inlineeGraph, false, null);
  
                      List&lt;ReturnNode&gt; rets = graph.getNodes(ReturnNode.TYPE).snapshot();
                      for (ReturnNode ret : rets) {
                          returnType = checkCounter.getMethod().getSignature().getReturnType(checkCounter.getMethod().getDeclaringClass());
</pre>
<center><a href="InstanceOfSnippets.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NewObjectSnippets.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
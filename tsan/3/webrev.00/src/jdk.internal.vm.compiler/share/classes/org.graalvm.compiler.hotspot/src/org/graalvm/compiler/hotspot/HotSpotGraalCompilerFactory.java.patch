diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalCompilerFactory.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalCompilerFactory.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalCompilerFactory.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotGraalCompilerFactory.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,11 +23,13 @@
 
 
 package org.graalvm.compiler.hotspot;
 
 import static jdk.vm.ci.common.InitTimer.timer;
+import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;
 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
+import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 import static org.graalvm.compiler.hotspot.HotSpotGraalOptionValues.GRAAL_OPTION_PROPERTY_PREFIX;
 
 import java.io.PrintStream;
 
 import org.graalvm.compiler.api.runtime.GraalRuntime;
@@ -40,12 +42,14 @@
 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
 
 import jdk.vm.ci.common.InitTimer;
 import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory;
 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
-import jdk.vm.ci.hotspot.HotSpotSignature;
+import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
+import jdk.vm.ci.meta.Signature;
 import jdk.vm.ci.runtime.JVMCIRuntime;
+import jdk.vm.ci.services.Services;
 
 public final class HotSpotGraalCompilerFactory extends HotSpotJVMCICompilerFactory {
 
     private static MethodFilter[] graalCompileOnlyFilter;
     private static boolean compileGraalWithC1Only;
@@ -68,29 +72,31 @@
      */
     private OptionValues options;
 
     @Override
     public void onSelection() {
-        JVMCIVersionCheck.check(false);
+        JVMCIVersionCheck.check(Services.getSavedProperties(), false);
         assert options == null : "cannot select " + getClass() + " service more than once";
         options = HotSpotGraalOptionValues.defaultOptions();
         initializeGraalCompilePolicyFields(options);
         isGraalPredicate = compileGraalWithC1Only ? new IsGraalPredicate() : null;
         /*
          * Exercise this code path early to encourage loading now. This doesn't solve problem of
          * deadlock during class loading but seems to eliminate it in practice.
          */
-        adjustCompilationLevelInternal(Object.class, "hashCode", "()I", CompilationLevel.FullOptimization);
-        adjustCompilationLevelInternal(Object.class, "hashCode", "()I", CompilationLevel.Simple);
+        if (isGraalPredicate != null && isGraalPredicate.getCompilationLevelAdjustment() != None) {
+            adjustCompilationLevelInternal(Object.class, CompilationLevel.FullOptimization);
+            adjustCompilationLevelInternal(Object.class, CompilationLevel.Simple);
+        }
         if (IS_BUILDING_NATIVE_IMAGE) {
             // Triggers initialization of all option descriptors
             Options.CompileGraalWithC1Only.getName();
         }
     }
 
     private static void initializeGraalCompilePolicyFields(OptionValues options) {
-        compileGraalWithC1Only = Options.CompileGraalWithC1Only.getValue(options);
+        compileGraalWithC1Only = Options.CompileGraalWithC1Only.getValue(options) && !IS_IN_NATIVE_IMAGE;
         String optionValue = Options.GraalCompileOnly.getValue(options);
         if (optionValue != null) {
             MethodFilter[] filter = MethodFilter.parse(optionValue);
             if (filter.length == 0) {
                 filter = null;
@@ -121,11 +127,11 @@
 
     @Override
     public HotSpotGraalCompiler createCompiler(JVMCIRuntime runtime) {
         CompilerConfigurationFactory factory = CompilerConfigurationFactory.selectFactory(null, options);
         if (isGraalPredicate != null) {
-            isGraalPredicate.onCompilerConfigurationFactorySelection(factory);
+            isGraalPredicate.onCompilerConfigurationFactorySelection((HotSpotJVMCIRuntime) runtime, factory);
         }
         HotSpotGraalCompiler compiler = createCompiler("VM", runtime, options, factory);
         // Only the HotSpotGraalRuntime associated with the compiler created via
         // jdk.vm.ci.runtime.JVMCIRuntime.getCompiler() is registered for receiving
         // VM events.
@@ -152,64 +158,46 @@
         }
     }
 
     @Override
     public CompilationLevelAdjustment getCompilationLevelAdjustment() {
-        if (graalCompileOnlyFilter != null) {
-            return CompilationLevelAdjustment.ByFullSignature;
-        }
-        if (compileGraalWithC1Only) {
-            // We only decide using the class declaring the method
-            // so no need to have the method name and signature
-            // symbols converted to a String.
-            return CompilationLevelAdjustment.ByHolder;
-        }
-        return CompilationLevelAdjustment.None;
+        return isGraalPredicate != null ? isGraalPredicate.getCompilationLevelAdjustment() : None;
     }
 
     @Override
     public CompilationLevel adjustCompilationLevel(Object declaringClassObject, String name, String signature, boolean isOsr, CompilationLevel level) {
-        if (declaringClassObject instanceof String) {
-            // This must be SVM mode in which case only GraalCompileC1Only matters since Graal and
-            // JVMCI are already compiled.
-            return checkGraalCompileOnlyFilter((String) declaringClassObject, name, signature, level);
-        }
         Class<?> declaringClass = (Class<?>) declaringClassObject;
-        return adjustCompilationLevelInternal(declaringClass, name, signature, level);
+        return adjustCompilationLevelInternal(declaringClass, level);
     }
 
     static {
         // Fail-fast detection for package renaming to guard use of package
         // prefixes in adjustCompilationLevelInternal.
         assert jdk.vm.ci.services.Services.class.getName().equals("jdk.vm.ci.services.Services");
         assert HotSpotGraalCompilerFactory.class.getName().equals("org.graalvm.compiler.hotspot.HotSpotGraalCompilerFactory");
     }
 
-    private CompilationLevel adjustCompilationLevelInternal(Class<?> declaringClass, String name, String signature, CompilationLevel level) {
-        if (compileGraalWithC1Only) {
-            if (level.ordinal() > CompilationLevel.Simple.ordinal()) {
-                if (isGraalPredicate.apply(declaringClass)) {
-                    return CompilationLevel.Simple;
-                }
+    private CompilationLevel adjustCompilationLevelInternal(Class<?> declaringClass, CompilationLevel level) {
+        assert isGraalPredicate != null;
+        if (level.ordinal() > CompilationLevel.Simple.ordinal()) {
+            if (isGraalPredicate.apply(declaringClass)) {
+                return CompilationLevel.Simple;
             }
         }
-        return checkGraalCompileOnlyFilter(declaringClass.getName(), name, signature, level);
+        return level;
     }
 
-    public static CompilationLevel checkGraalCompileOnlyFilter(String declaringClassName, String name, String signature, CompilationLevel level) {
+    static boolean shouldExclude(HotSpotResolvedJavaMethod method) {
         if (graalCompileOnlyFilter != null) {
-            if (level == CompilationLevel.FullOptimization) {
-                HotSpotSignature sig = null;
-                for (MethodFilter filter : graalCompileOnlyFilter) {
-                    if (filter.hasSignature() && sig == null) {
-                        sig = new HotSpotSignature(HotSpotJVMCIRuntime.runtime(), signature);
-                    }
-                    if (filter.matches(declaringClassName, name, sig)) {
-                        return level;
-                    }
+            String javaClassName = method.getDeclaringClass().toJavaName();
+            String name = method.getName();
+            Signature signature = method.getSignature();
+            for (MethodFilter filter : graalCompileOnlyFilter) {
+                if (filter.matches(javaClassName, name, signature)) {
+                    return false;
                 }
-                return CompilationLevel.Simple;
             }
+            return true;
         }
-        return level;
+        return false;
     }
 }

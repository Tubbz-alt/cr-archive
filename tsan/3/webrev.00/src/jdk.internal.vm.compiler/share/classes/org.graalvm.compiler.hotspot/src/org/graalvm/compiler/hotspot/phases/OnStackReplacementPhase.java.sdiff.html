<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/OnStackReplacementPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoadJavaMirrorWithKlassPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="aot/AOTInliningPolicy.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/phases/OnStackReplacementPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.hotspot.phases;
 26 
 27 import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
 28 
 29 import org.graalvm.compiler.core.common.PermanentBailoutException;
 30 import org.graalvm.compiler.core.common.cfg.Loop;
 31 import org.graalvm.compiler.core.common.type.ObjectStamp;
 32 import org.graalvm.compiler.core.common.type.Stamp;
 33 import org.graalvm.compiler.debug.CounterKey;
 34 import org.graalvm.compiler.debug.DebugCloseable;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.debug.GraalError;
 37 import org.graalvm.compiler.graph.Node;
 38 import org.graalvm.compiler.graph.iterators.NodeIterable;
 39 import org.graalvm.compiler.loop.LoopEx;
 40 import org.graalvm.compiler.loop.LoopsData;
 41 import org.graalvm.compiler.loop.phases.LoopTransformations;
 42 import org.graalvm.compiler.nodeinfo.InputType;
 43 import org.graalvm.compiler.nodeinfo.Verbosity;
<span class="line-removed"> 44 import org.graalvm.compiler.nodes.AbstractBeginNode;</span>
 45 import org.graalvm.compiler.nodes.EntryMarkerNode;
 46 import org.graalvm.compiler.nodes.EntryProxyNode;
 47 import org.graalvm.compiler.nodes.FixedGuardNode;
 48 import org.graalvm.compiler.nodes.FixedNode;
 49 import org.graalvm.compiler.nodes.FrameState;
 50 import org.graalvm.compiler.nodes.LogicNode;
 51 import org.graalvm.compiler.nodes.LoopBeginNode;
 52 import org.graalvm.compiler.nodes.NodeView;
 53 import org.graalvm.compiler.nodes.ParameterNode;
 54 import org.graalvm.compiler.nodes.PiNode;
 55 import org.graalvm.compiler.nodes.StartNode;
 56 import org.graalvm.compiler.nodes.StructuredGraph;
 57 import org.graalvm.compiler.nodes.ValueNode;
 58 import org.graalvm.compiler.nodes.cfg.Block;
 59 import org.graalvm.compiler.nodes.extended.OSRLocalNode;
 60 import org.graalvm.compiler.nodes.extended.OSRLockNode;
 61 import org.graalvm.compiler.nodes.extended.OSRMonitorEnterNode;
 62 import org.graalvm.compiler.nodes.extended.OSRStartNode;
 63 import org.graalvm.compiler.nodes.java.AccessMonitorNode;
 64 import org.graalvm.compiler.nodes.java.InstanceOfNode;
</pre>
<hr />
<pre>
142             // Find the loop that contains the EntryMarker
143             Loop&lt;Block&gt; l = loops.getCFG().getNodeToBlock().get(osr).getLoop();
144             if (l == null) {
145                 break;
146             }
147 
148             iterations++;
149             if (maxIterations == -1) {
150                 maxIterations = l.getDepth();
151             } else if (iterations &gt; maxIterations) {
152                 throw GraalError.shouldNotReachHere();
153             }
154             // Peel the outermost loop first
155             while (l.getParent() != null) {
156                 l = l.getParent();
157             }
158 
159             LoopEx loop = loops.loop(l);
160             loop.loopBegin().markOsrLoop();
161             LoopTransformations.peel(loop);
<span class="line-modified">162             osr.replaceAtUsages(InputType.Guard, AbstractBeginNode.prevBegin((FixedNode) osr.predecessor()));</span>
<span class="line-modified">163             for (Node usage : osr.usages().snapshot()) {</span>
<span class="line-removed">164                 EntryProxyNode proxy = (EntryProxyNode) usage;</span>
<span class="line-removed">165                 proxy.replaceAndDelete(proxy.value());</span>
<span class="line-removed">166             }</span>
167             GraphUtil.removeFixedWithUnusedInputs(osr);
168             debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement loop peeling result&quot;);
169         } while (true);
170 
171         StartNode start = graph.start();
172         FrameState osrState = osr.stateAfter();
173         OSRStartNode osrStart;
174         try (DebugCloseable context = osr.withNodeSourcePosition()) {
175             osr.setStateAfter(null);
176             osrStart = graph.add(new OSRStartNode());
177             FixedNode next = osr.next();
178             osr.setNext(null);
179             osrStart.setNext(next);
180             graph.setStart(osrStart);
181             osrStart.setStateAfter(osrState);
182 
183             debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement after setting OSR start&quot;);
184             final int localsSize = osrState.localsSize();
185             final int locksSize = osrState.locksSize();
186 
</pre>
<hr />
<pre>
211                     if (graph.getSpeculationLog().maySpeculate(reason) &amp;&amp; osrLocal instanceof OSRLocalNode &amp;&amp; value.getStackKind().equals(JavaKind.Object) &amp;&amp; !narrowedStamp.isUnrestricted()) {
212                         // Add guard.
213                         LogicNode check = graph.addOrUniqueWithInputs(InstanceOfNode.createHelper((ObjectStamp) narrowedStamp, osrLocal, null, null));
214                         SpeculationLog.Speculation constant = graph.getSpeculationLog().speculate(reason);
215                         FixedGuardNode guard = graph.add(new FixedGuardNode(check, DeoptimizationReason.OptimizedTypeCheckViolated, DeoptimizationAction.InvalidateRecompile, constant, false));
216                         graph.addAfterFixed(osrStart, guard);
217 
218                         // Replace with a more specific type at usages.
219                         // We know that we are at the root,
220                         // so we need to replace the proxy in the state.
221                         proxy.replaceAtMatchingUsages(osrLocal, n -&gt; n == osrState);
222                         osrLocal = graph.addOrUnique(new PiNode(osrLocal, narrowedStamp, guard));
223                     }
224                     proxy.replaceAndDelete(osrLocal);
225                 } else {
226                     assert value == null || value instanceof OSRLocalNode;
227                 }
228             }
229 
230             osr.replaceAtUsages(InputType.Guard, osrStart);

231         }
232         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement after replacing entry proxies&quot;);
233         GraphUtil.killCFG(start);
234         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement result&quot;);
235         new DeadCodeEliminationPhase(Required).apply(graph);
236 
237         if (currentOSRWithLocks) {
238             OsrWithLocksCount.increment(debug);
239             try (DebugCloseable context = osrStart.withNodeSourcePosition()) {
240                 for (int i = osrState.monitorIdCount() - 1; i &gt;= 0; --i) {
241                     MonitorIdNode id = osrState.monitorIdAt(i);
242                     ValueNode lockedObject = osrState.lockAt(i);
243                     OSRMonitorEnterNode osrMonitorEnter = graph.add(new OSRMonitorEnterNode(lockedObject, id));
244                     for (Node usage : id.usages()) {
245                         if (usage instanceof AccessMonitorNode) {
246                             AccessMonitorNode access = (AccessMonitorNode) usage;
247                             access.setObject(lockedObject);
248                         }
249                     }
250                     FixedNode oldNext = osrStart.next();
</pre>
<hr />
<pre>
265              */
266             for (MonitorExitNode exit : graph.getNodes(MonitorExitNode.TYPE)) {
267                 MonitorIdNode id = exit.getMonitorId();
268                 if (id.usages().filter(MonitorEnterNode.class).count() != 1) {
269                     throw new PermanentBailoutException(&quot;Unbalanced monitor enter-exit in OSR compilation with locks. Object is locked before the loop but released inside the loop.&quot;);
270                 }
271             }
272         }
273         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement result&quot;);
274         new DeadCodeEliminationPhase(Required).apply(graph);
275         /*
276          * There must not be any parameter nodes left after OSR compilation.
277          */
278         assert graph.getNodes(ParameterNode.TYPE).count() == 0 : &quot;OSR Compilation contains references to parameters.&quot;;
279     }
280 
281     private static EntryMarkerNode getEntryMarker(StructuredGraph graph) {
282         NodeIterable&lt;EntryMarkerNode&gt; osrNodes = graph.getNodes(EntryMarkerNode.TYPE);
283         EntryMarkerNode osr = osrNodes.first();
284         if (osr == null) {
<span class="line-modified">285             throw new PermanentBailoutException(&quot;No OnStackReplacementNode generated&quot;);</span>
286         }
287         if (osrNodes.count() &gt; 1) {
288             throw new GraalError(&quot;Multiple OnStackReplacementNodes generated&quot;);
289         }
290         if (osr.stateAfter().stackSize() != 0) {
291             throw new PermanentBailoutException(&quot;OSR with stack entries not supported: %s&quot;, osr.stateAfter().toString(Verbosity.Debugger));
292         }
293         return osr;
294     }
295 
296     private static LoopBeginNode osrLoop(EntryMarkerNode osr) {
297         // Check that there is an OSR loop for the OSR begin
298         LoopsData loops = new LoopsData(osr.graph());
299         Loop&lt;Block&gt; l = loops.getCFG().getNodeToBlock().get(osr).getLoop();
300         if (l == null) {
301             return null;
302         }
303         return (LoopBeginNode) l.getHeader().getBeginNode();
304     }
305 
</pre>
</td>
<td>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.hotspot.phases;
 26 
 27 import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
 28 
 29 import org.graalvm.compiler.core.common.PermanentBailoutException;
 30 import org.graalvm.compiler.core.common.cfg.Loop;
 31 import org.graalvm.compiler.core.common.type.ObjectStamp;
 32 import org.graalvm.compiler.core.common.type.Stamp;
 33 import org.graalvm.compiler.debug.CounterKey;
 34 import org.graalvm.compiler.debug.DebugCloseable;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.debug.GraalError;
 37 import org.graalvm.compiler.graph.Node;
 38 import org.graalvm.compiler.graph.iterators.NodeIterable;
 39 import org.graalvm.compiler.loop.LoopEx;
 40 import org.graalvm.compiler.loop.LoopsData;
 41 import org.graalvm.compiler.loop.phases.LoopTransformations;
 42 import org.graalvm.compiler.nodeinfo.InputType;
 43 import org.graalvm.compiler.nodeinfo.Verbosity;

 44 import org.graalvm.compiler.nodes.EntryMarkerNode;
 45 import org.graalvm.compiler.nodes.EntryProxyNode;
 46 import org.graalvm.compiler.nodes.FixedGuardNode;
 47 import org.graalvm.compiler.nodes.FixedNode;
 48 import org.graalvm.compiler.nodes.FrameState;
 49 import org.graalvm.compiler.nodes.LogicNode;
 50 import org.graalvm.compiler.nodes.LoopBeginNode;
 51 import org.graalvm.compiler.nodes.NodeView;
 52 import org.graalvm.compiler.nodes.ParameterNode;
 53 import org.graalvm.compiler.nodes.PiNode;
 54 import org.graalvm.compiler.nodes.StartNode;
 55 import org.graalvm.compiler.nodes.StructuredGraph;
 56 import org.graalvm.compiler.nodes.ValueNode;
 57 import org.graalvm.compiler.nodes.cfg.Block;
 58 import org.graalvm.compiler.nodes.extended.OSRLocalNode;
 59 import org.graalvm.compiler.nodes.extended.OSRLockNode;
 60 import org.graalvm.compiler.nodes.extended.OSRMonitorEnterNode;
 61 import org.graalvm.compiler.nodes.extended.OSRStartNode;
 62 import org.graalvm.compiler.nodes.java.AccessMonitorNode;
 63 import org.graalvm.compiler.nodes.java.InstanceOfNode;
</pre>
<hr />
<pre>
141             // Find the loop that contains the EntryMarker
142             Loop&lt;Block&gt; l = loops.getCFG().getNodeToBlock().get(osr).getLoop();
143             if (l == null) {
144                 break;
145             }
146 
147             iterations++;
148             if (maxIterations == -1) {
149                 maxIterations = l.getDepth();
150             } else if (iterations &gt; maxIterations) {
151                 throw GraalError.shouldNotReachHere();
152             }
153             // Peel the outermost loop first
154             while (l.getParent() != null) {
155                 l = l.getParent();
156             }
157 
158             LoopEx loop = loops.loop(l);
159             loop.loopBegin().markOsrLoop();
160             LoopTransformations.peel(loop);
<span class="line-modified">161 </span>
<span class="line-modified">162             osr.prepareDelete();</span>



163             GraphUtil.removeFixedWithUnusedInputs(osr);
164             debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement loop peeling result&quot;);
165         } while (true);
166 
167         StartNode start = graph.start();
168         FrameState osrState = osr.stateAfter();
169         OSRStartNode osrStart;
170         try (DebugCloseable context = osr.withNodeSourcePosition()) {
171             osr.setStateAfter(null);
172             osrStart = graph.add(new OSRStartNode());
173             FixedNode next = osr.next();
174             osr.setNext(null);
175             osrStart.setNext(next);
176             graph.setStart(osrStart);
177             osrStart.setStateAfter(osrState);
178 
179             debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement after setting OSR start&quot;);
180             final int localsSize = osrState.localsSize();
181             final int locksSize = osrState.locksSize();
182 
</pre>
<hr />
<pre>
207                     if (graph.getSpeculationLog().maySpeculate(reason) &amp;&amp; osrLocal instanceof OSRLocalNode &amp;&amp; value.getStackKind().equals(JavaKind.Object) &amp;&amp; !narrowedStamp.isUnrestricted()) {
208                         // Add guard.
209                         LogicNode check = graph.addOrUniqueWithInputs(InstanceOfNode.createHelper((ObjectStamp) narrowedStamp, osrLocal, null, null));
210                         SpeculationLog.Speculation constant = graph.getSpeculationLog().speculate(reason);
211                         FixedGuardNode guard = graph.add(new FixedGuardNode(check, DeoptimizationReason.OptimizedTypeCheckViolated, DeoptimizationAction.InvalidateRecompile, constant, false));
212                         graph.addAfterFixed(osrStart, guard);
213 
214                         // Replace with a more specific type at usages.
215                         // We know that we are at the root,
216                         // so we need to replace the proxy in the state.
217                         proxy.replaceAtMatchingUsages(osrLocal, n -&gt; n == osrState);
218                         osrLocal = graph.addOrUnique(new PiNode(osrLocal, narrowedStamp, guard));
219                     }
220                     proxy.replaceAndDelete(osrLocal);
221                 } else {
222                     assert value == null || value instanceof OSRLocalNode;
223                 }
224             }
225 
226             osr.replaceAtUsages(InputType.Guard, osrStart);
<span class="line-added">227             osr.replaceAtUsages(InputType.Anchor, osrStart);</span>
228         }
229         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement after replacing entry proxies&quot;);
230         GraphUtil.killCFG(start);
231         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement result&quot;);
232         new DeadCodeEliminationPhase(Required).apply(graph);
233 
234         if (currentOSRWithLocks) {
235             OsrWithLocksCount.increment(debug);
236             try (DebugCloseable context = osrStart.withNodeSourcePosition()) {
237                 for (int i = osrState.monitorIdCount() - 1; i &gt;= 0; --i) {
238                     MonitorIdNode id = osrState.monitorIdAt(i);
239                     ValueNode lockedObject = osrState.lockAt(i);
240                     OSRMonitorEnterNode osrMonitorEnter = graph.add(new OSRMonitorEnterNode(lockedObject, id));
241                     for (Node usage : id.usages()) {
242                         if (usage instanceof AccessMonitorNode) {
243                             AccessMonitorNode access = (AccessMonitorNode) usage;
244                             access.setObject(lockedObject);
245                         }
246                     }
247                     FixedNode oldNext = osrStart.next();
</pre>
<hr />
<pre>
262              */
263             for (MonitorExitNode exit : graph.getNodes(MonitorExitNode.TYPE)) {
264                 MonitorIdNode id = exit.getMonitorId();
265                 if (id.usages().filter(MonitorEnterNode.class).count() != 1) {
266                     throw new PermanentBailoutException(&quot;Unbalanced monitor enter-exit in OSR compilation with locks. Object is locked before the loop but released inside the loop.&quot;);
267                 }
268             }
269         }
270         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;OnStackReplacement result&quot;);
271         new DeadCodeEliminationPhase(Required).apply(graph);
272         /*
273          * There must not be any parameter nodes left after OSR compilation.
274          */
275         assert graph.getNodes(ParameterNode.TYPE).count() == 0 : &quot;OSR Compilation contains references to parameters.&quot;;
276     }
277 
278     private static EntryMarkerNode getEntryMarker(StructuredGraph graph) {
279         NodeIterable&lt;EntryMarkerNode&gt; osrNodes = graph.getNodes(EntryMarkerNode.TYPE);
280         EntryMarkerNode osr = osrNodes.first();
281         if (osr == null) {
<span class="line-modified">282             throw new GraalError(&quot;No OnStackReplacementNode generated&quot;);</span>
283         }
284         if (osrNodes.count() &gt; 1) {
285             throw new GraalError(&quot;Multiple OnStackReplacementNodes generated&quot;);
286         }
287         if (osr.stateAfter().stackSize() != 0) {
288             throw new PermanentBailoutException(&quot;OSR with stack entries not supported: %s&quot;, osr.stateAfter().toString(Verbosity.Debugger));
289         }
290         return osr;
291     }
292 
293     private static LoopBeginNode osrLoop(EntryMarkerNode osr) {
294         // Check that there is an OSR loop for the OSR begin
295         LoopsData loops = new LoopsData(osr.graph());
296         Loop&lt;Block&gt; l = loops.getCFG().getNodeToBlock().get(osr).getLoop();
297         if (l == null) {
298             return null;
299         }
300         return (LoopBeginNode) l.getHeader().getBeginNode();
301     }
302 
</pre>
</td>
</tr>
</table>
<center><a href="LoadJavaMirrorWithKlassPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="aot/AOTInliningPolicy.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
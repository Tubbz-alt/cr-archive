<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotGraalConstantFieldProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotHostForeignCallsProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotGraphBuilderPlugins.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;

 28 import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
 29 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 30 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.JAVA_THREAD_THREAD_OBJECT_LOCATION;
 31 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
<span class="line-removed"> 32 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;</span>
 33 
 34 import java.lang.invoke.ConstantCallSite;
 35 import java.lang.invoke.MutableCallSite;
 36 import java.lang.invoke.VolatileCallSite;
 37 import java.lang.reflect.Array;

 38 import java.math.BigInteger;
 39 import java.util.zip.CRC32;
 40 

 41 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
<span class="line-removed"> 42 import org.graalvm.compiler.bytecode.BytecodeProvider;</span>
 43 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 44 import org.graalvm.compiler.core.common.type.ObjectStamp;
 45 import org.graalvm.compiler.core.common.type.StampFactory;
 46 import org.graalvm.compiler.core.common.type.TypeReference;

 47 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;

 48 import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
 49 import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
 50 import org.graalvm.compiler.hotspot.replacements.ArraysSupportSubstitutions;
 51 import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
 52 import org.graalvm.compiler.hotspot.replacements.CRC32CSubstitutions;
 53 import org.graalvm.compiler.hotspot.replacements.CRC32Substitutions;
 54 import org.graalvm.compiler.hotspot.replacements.CallSiteTargetNode;
 55 import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
 56 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
 57 import org.graalvm.compiler.hotspot.replacements.CounterModeSubstitutions;
 58 import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;

 59 import org.graalvm.compiler.hotspot.replacements.HotSpotArraySubstitutions;
 60 import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;
 61 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 62 import org.graalvm.compiler.hotspot.replacements.ObjectCloneNode;
<span class="line-removed"> 63 import org.graalvm.compiler.hotspot.replacements.ObjectSubstitutions;</span>
 64 import org.graalvm.compiler.hotspot.replacements.ReflectionGetCallerClassNode;
 65 import org.graalvm.compiler.hotspot.replacements.ReflectionSubstitutions;
 66 import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
 67 import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
 68 import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
 69 import org.graalvm.compiler.hotspot.replacements.StringUTF16Substitutions;
 70 import org.graalvm.compiler.hotspot.replacements.ThreadSubstitutions;
 71 import org.graalvm.compiler.hotspot.word.HotSpotWordTypes;
 72 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 73 import org.graalvm.compiler.nodes.ConstantNode;
 74 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 75 import org.graalvm.compiler.nodes.NodeView;
 76 import org.graalvm.compiler.nodes.ValueNode;
 77 import org.graalvm.compiler.nodes.calc.AddNode;
 78 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
 79 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 80 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 81 import org.graalvm.compiler.nodes.graphbuilderconf.ForeignCallPlugin;
 82 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 83 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 84 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 85 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 86 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 87 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 88 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;
 89 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
 90 import org.graalvm.compiler.nodes.memory.ReadNode;
 91 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 92 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;

 93 import org.graalvm.compiler.nodes.util.GraphUtil;
 94 import org.graalvm.compiler.options.OptionValues;
 95 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
 96 import org.graalvm.compiler.replacements.InlineDuringParsingPlugin;
 97 import org.graalvm.compiler.replacements.MethodHandlePlugin;
 98 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;
 99 import org.graalvm.compiler.replacements.ReplacementsImpl;
100 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins;
101 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
102 import org.graalvm.compiler.serviceprovider.GraalServices;

103 import org.graalvm.compiler.word.WordOperationPlugin;
104 import org.graalvm.compiler.word.WordTypes;
105 import jdk.internal.vm.compiler.word.LocationIdentity;
106 
107 import jdk.vm.ci.code.CodeUtil;


108 import jdk.vm.ci.meta.ConstantReflectionProvider;
109 import jdk.vm.ci.meta.DeoptimizationAction;
110 import jdk.vm.ci.meta.JavaKind;
111 import jdk.vm.ci.meta.MetaAccessProvider;
112 import jdk.vm.ci.meta.ResolvedJavaMethod;

113 import sun.misc.Unsafe;
114 
115 /**
116  * Defines the {@link Plugins} used when running on HotSpot.
117  */
118 public class HotSpotGraphBuilderPlugins {
119 
120     /**
121      * Creates a {@link Plugins} object that should be used when running on HotSpot.
122      *
123      * @param constantReflection
124      * @param snippetReflection
125      * @param foreignCalls


126      */
<span class="line-modified">127     public static Plugins create(CompilerConfiguration compilerConfiguration, GraalHotSpotVMConfig config, HotSpotWordTypes wordTypes, MetaAccessProvider metaAccess,</span>
<span class="line-modified">128                     ConstantReflectionProvider constantReflection, SnippetReflectionProvider snippetReflection, ForeignCallsProvider foreignCalls, ReplacementsImpl replacements) {</span>
<span class="line-modified">129         InvocationPlugins invocationPlugins = new HotSpotInvocationPlugins(config, compilerConfiguration);</span>








130 
131         Plugins plugins = new Plugins(invocationPlugins);
<span class="line-modified">132         NodeIntrinsificationProvider nodeIntrinsificationProvider = new NodeIntrinsificationProvider(metaAccess, snippetReflection, foreignCalls, wordTypes);</span>
133         HotSpotWordOperationPlugin wordOperationPlugin = new HotSpotWordOperationPlugin(snippetReflection, wordTypes);
134         HotSpotNodePlugin nodePlugin = new HotSpotNodePlugin(wordOperationPlugin, config, wordTypes);
135 
136         plugins.appendTypePlugin(nodePlugin);
137         plugins.appendNodePlugin(nodePlugin);
<span class="line-removed">138         OptionValues options = replacements.getOptions();</span>
139         if (!GeneratePIC.getValue(options)) {
140             plugins.appendNodePlugin(new MethodHandlePlugin(constantReflection.getMethodHandleAccess(), true));
141         }
142         plugins.appendInlineInvokePlugin(replacements);
143         if (InlineDuringParsing.getValue(options)) {
144             plugins.appendInlineInvokePlugin(new InlineDuringParsingPlugin());
145         }
146 
147         if (GeneratePIC.getValue(options)) {
<span class="line-modified">148             plugins.setClassInitializationPlugin(new HotSpotClassInitializationPlugin());</span>
149             if (TieredAOT.getValue(options)) {
150                 plugins.setProfilingPlugin(new HotSpotAOTProfilingPlugin());
151             }




152         }
153 
154         invocationPlugins.defer(new Runnable() {
155 
156             @Override
157             public void run() {
<span class="line-modified">158                 BytecodeProvider replacementBytecodeProvider = replacements.getDefaultReplacementBytecodeProvider();</span>
<span class="line-modified">159                 registerObjectPlugins(invocationPlugins, options, config, replacementBytecodeProvider);</span>
<span class="line-removed">160                 registerClassPlugins(plugins, config, replacementBytecodeProvider);</span>
161                 registerSystemPlugins(invocationPlugins, foreignCalls);
<span class="line-modified">162                 registerThreadPlugins(invocationPlugins, metaAccess, wordTypes, config, replacementBytecodeProvider);</span>
163                 if (!GeneratePIC.getValue(options)) {
164                     registerCallSitePlugins(invocationPlugins);
165                 }
<span class="line-modified">166                 registerReflectionPlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">167                 registerConstantPoolPlugins(invocationPlugins, wordTypes, config, replacementBytecodeProvider);</span>
<span class="line-modified">168                 registerAESPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">169                 registerCRC32Plugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">170                 registerCRC32CPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">171                 registerBigIntegerPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">172                 registerSHAPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
173                 registerGHASHPlugins(invocationPlugins, config, metaAccess, foreignCalls);
<span class="line-modified">174                 registerCounterModePlugins(invocationPlugins, config, replacementBytecodeProvider);</span>
<span class="line-modified">175                 registerUnsafePlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">176                 StandardGraphBuilderPlugins.registerInvocationPlugins(metaAccess, snippetReflection, invocationPlugins, replacementBytecodeProvider, true, false);</span>
<span class="line-modified">177                 registerArrayPlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">178                 registerStringPlugins(invocationPlugins, replacementBytecodeProvider);</span>
<span class="line-modified">179                 registerArraysSupportPlugins(invocationPlugins, config, replacementBytecodeProvider);</span>

180 
181                 for (NodeIntrinsicPluginFactory factory : GraalServices.load(NodeIntrinsicPluginFactory.class)) {
182                     factory.registerPlugins(invocationPlugins, nodeIntrinsificationProvider);
183                 }
184             }
185         });
186         return plugins;
187     }
188 
<span class="line-modified">189     private static void registerObjectPlugins(InvocationPlugins plugins, OptionValues options, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">190         Registration r = new Registration(plugins, Object.class, bytecodeProvider);</span>
191         if (!GeneratePIC.getValue(options)) {
192             // FIXME: clone() requires speculation and requires a fix in here (to check that
193             // b.getAssumptions() != null), and in ReplacementImpl.getSubstitution() where there is
194             // an instantiation of IntrinsicGraphBuilder using a constructor that sets
195             // AllowAssumptions to YES automatically. The former has to inherit the assumptions
196             // settings from the root compile instead. So, for now, I&#39;m disabling it for
197             // GeneratePIC.
198             r.register1(&quot;clone&quot;, Receiver.class, new InvocationPlugin() {
199                 @Override
200                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
201                     ValueNode object = receiver.get();
202                     b.addPush(JavaKind.Object, new ObjectCloneNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), object));
203                     return true;
204                 }
205 
206                 @Override
207                 public boolean inlineOnly() {
208                     return true;
209                 }
210             });
211         }
<span class="line-modified">212         r.registerMethodSubstitution(ObjectSubstitutions.class, &quot;hashCode&quot;, Receiver.class);</span>












213         if (config.inlineNotify()) {
<span class="line-modified">214             r.registerMethodSubstitution(ObjectSubstitutions.class, &quot;notify&quot;, Receiver.class);</span>












215         }
216         if (config.inlineNotifyAll()) {
<span class="line-modified">217             r.registerMethodSubstitution(ObjectSubstitutions.class, &quot;notifyAll&quot;, Receiver.class);</span>












218         }
219     }
220 
<span class="line-modified">221     private static void registerClassPlugins(Plugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">222         Registration r = new Registration(plugins.getInvocationPlugins(), Class.class, bytecodeProvider);</span>
223 
224         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getModifiers&quot;, Receiver.class);
225         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isInterface&quot;, Receiver.class);
226         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isArray&quot;, Receiver.class);
227         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isPrimitive&quot;, Receiver.class);
228         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getSuperclass&quot;, Receiver.class);
229 
230         if (config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;, Integer.MAX_VALUE) != Integer.MAX_VALUE) {
231             r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getComponentType&quot;, Receiver.class);
232         }
233     }
234 
235     private static void registerCallSitePlugins(InvocationPlugins plugins) {
236         InvocationPlugin plugin = new InvocationPlugin() {
237             @Override
238             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
239                 ValueNode callSite = receiver.get();
<span class="line-modified">240                 ValueNode folded = CallSiteTargetNode.tryFold(GraphUtil.originalValue(callSite), b.getMetaAccess(), b.getAssumptions());</span>
241                 if (folded != null) {
242                     b.addPush(JavaKind.Object, folded);
243                 } else {
244                     b.addPush(JavaKind.Object, new CallSiteTargetNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), callSite));
245                 }
246                 return true;
247             }
248 
249             @Override
250             public boolean inlineOnly() {
251                 return true;
252             }
253         };
254         plugins.register(plugin, ConstantCallSite.class, &quot;getTarget&quot;, Receiver.class);
255         plugins.register(plugin, MutableCallSite.class, &quot;getTarget&quot;, Receiver.class);
256         plugins.register(plugin, VolatileCallSite.class, &quot;getTarget&quot;, Receiver.class);
257     }
258 
<span class="line-modified">259     private static void registerReflectionPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">260         Registration r = new Registration(plugins, reflectionClass, bytecodeProvider);</span>
261         r.register0(&quot;getCallerClass&quot;, new InvocationPlugin() {
262             @Override
263             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
264                 b.addPush(JavaKind.Object, new ReflectionGetCallerClassNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions())));
265                 return true;
266             }
267 
268             @Override
269             public boolean inlineOnly() {
270                 return true;
271             }
272         });
273         r.registerMethodSubstitution(ReflectionSubstitutions.class, &quot;getClassAccessFlags&quot;, Class.class);
274     }
275 
<span class="line-modified">276     private static void registerUnsafePlugins(InvocationPlugins plugins, BytecodeProvider replacementBytecodeProvider) {</span>
277         Registration r;
<span class="line-modified">278         if (Java8OrEarlier) {</span>
<span class="line-modified">279             r = new Registration(plugins, Unsafe.class, replacementBytecodeProvider);</span>
280         } else {
<span class="line-modified">281             r = new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacementBytecodeProvider);</span>
282         }
<span class="line-modified">283         r.registerMethodSubstitution(HotSpotUnsafeSubstitutions.class, HotSpotUnsafeSubstitutions.copyMemoryName, &quot;copyMemory&quot;, Receiver.class, Object.class, long.class, Object.class, long.class,</span>
<span class="line-modified">284                         long.class);</span>

285     }
286 
287     private static final LocationIdentity INSTANCE_KLASS_CONSTANTS = NamedLocationIdentity.immutable(&quot;InstanceKlass::_constants&quot;);
288     private static final LocationIdentity CONSTANT_POOL_LENGTH = NamedLocationIdentity.immutable(&quot;ConstantPool::_length&quot;);
289 
290     /**
291      * Emits a node to get the metaspace {@code ConstantPool} pointer given the value of the
292      * {@code constantPoolOop} field in a ConstantPool value.
293      *
294      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
295      * @return a node representing the metaspace {@code ConstantPool} pointer associated with
296      *         {@code constantPoolOop}
297      */
298     private static ValueNode getMetaspaceConstantPool(GraphBuilderContext b, ValueNode constantPoolOop, WordTypes wordTypes, GraalHotSpotVMConfig config) {
299         // ConstantPool.constantPoolOop is in fact the holder class.
300         ValueNode value = b.nullCheckedValue(constantPoolOop, DeoptimizationAction.None);
301         ValueNode klass = b.add(ClassGetHubNode.create(value, b.getMetaAccess(), b.getConstantReflection(), false));
302 
303         boolean notCompressible = false;
304         AddressNode constantsAddress = b.add(new OffsetAddressNode(klass, b.add(ConstantNode.forLong(config.instanceKlassConstantsOffset))));
305         return WordOperationPlugin.readOp(b, wordTypes.getWordKind(), constantsAddress, INSTANCE_KLASS_CONSTANTS, BarrierType.NONE, notCompressible);
306     }
307 
308     /**
309      * Emits a node representing an element in a metaspace {@code ConstantPool}.
310      *
311      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
312      */
313     private static boolean readMetaspaceConstantPoolElement(GraphBuilderContext b, ValueNode constantPoolOop, ValueNode index, JavaKind elementKind, WordTypes wordTypes, GraalHotSpotVMConfig config) {
314         ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
315         int shift = CodeUtil.log2(wordTypes.getWordKind().getByteCount());
316         ValueNode scaledIndex = b.add(new LeftShiftNode(IntegerConvertNode.convert(index, StampFactory.forKind(JavaKind.Long), NodeView.DEFAULT), b.add(ConstantNode.forInt(shift))));
317         ValueNode offset = b.add(new AddNode(scaledIndex, b.add(ConstantNode.forLong(config.constantPoolSize))));
318         AddressNode elementAddress = b.add(new OffsetAddressNode(constants, offset));
319         boolean notCompressible = false;
320         ValueNode elementValue = WordOperationPlugin.readOp(b, elementKind, elementAddress, NamedLocationIdentity.getArrayLocation(elementKind), BarrierType.NONE, notCompressible);
321         b.addPush(elementKind, elementValue);
322         return true;
323     }
324 
<span class="line-modified">325     private static void registerConstantPoolPlugins(InvocationPlugins plugins, WordTypes wordTypes, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">326         Registration r = new Registration(plugins, constantPoolClass, bytecodeProvider);</span>
327 
328         r.register2(&quot;getSize0&quot;, Receiver.class, Object.class, new InvocationPlugin() {
329             @Override
330             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop) {
331                 boolean notCompressible = false;
332                 ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
333                 AddressNode lengthAddress = b.add(new OffsetAddressNode(constants, b.add(ConstantNode.forLong(config.constantPoolLengthOffset))));
334                 ValueNode length = WordOperationPlugin.readOp(b, JavaKind.Int, lengthAddress, CONSTANT_POOL_LENGTH, BarrierType.NONE, notCompressible);
335                 b.addPush(JavaKind.Int, length);
336                 return true;
337             }
338         });
339 
340         r.register3(&quot;getIntAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
341             @Override
342             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
343                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Int, wordTypes, config);
344             }
345         });
346         r.register3(&quot;getLongAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
</pre>
<hr />
<pre>
376 
377             @Override
378             public boolean inlineOnly() {
379                 return true;
380             }
381         });
382         r.register5(&quot;arraycopy&quot;, Object.class, int.class, Object.class, int.class, int.class, new InvocationPlugin() {
383             @Override
384             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode src, ValueNode srcPos, ValueNode dst, ValueNode dstPos, ValueNode length) {
385                 b.add(new ArrayCopyNode(b.bci(), src, srcPos, dst, dstPos, length));
386                 return true;
387             }
388 
389             @Override
390             public boolean inlineOnly() {
391                 return true;
392             }
393         });
394     }
395 
<span class="line-modified">396     private static void registerArrayPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">397         Registration r = new Registration(plugins, Array.class, bytecodeProvider);</span>
398         r.setAllowOverwrite(true);
399         r.registerMethodSubstitution(HotSpotArraySubstitutions.class, &quot;newInstance&quot;, Class.class, int.class);
400     }
401 
<span class="line-modified">402     private static void registerStringPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">403         if (!Java8OrEarlier) {</span>
<span class="line-modified">404             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, bytecodeProvider);</span>
405             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;toBytes&quot;, char[].class, int.class, int.class);
406             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChars&quot;, byte[].class, int.class, int.class, char[].class, int.class);
407         }
408     }
409 
<span class="line-modified">410     private static void registerThreadPlugins(InvocationPlugins plugins, MetaAccessProvider metaAccess, WordTypes wordTypes, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">411         Registration r = new Registration(plugins, Thread.class, bytecodeProvider);</span>
412         r.register0(&quot;currentThread&quot;, new InvocationPlugin() {
413             @Override
414             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
415                 CurrentJavaThreadNode thread = b.add(new CurrentJavaThreadNode(wordTypes.getWordKind()));
416                 ValueNode offset = b.add(ConstantNode.forLong(config.threadObjectOffset));
417                 AddressNode address = b.add(new OffsetAddressNode(thread, offset));
418                 // JavaThread::_threadObj is never compressed
419                 ObjectStamp stamp = StampFactory.objectNonNull(TypeReference.create(b.getAssumptions(), metaAccess.lookupJavaType(Thread.class)));
420                 b.addPush(JavaKind.Object, new ReadNode(address, JAVA_THREAD_THREAD_OBJECT_LOCATION, stamp, BarrierType.NONE));
421                 return true;
422             }
423         });
424 
<span class="line-modified">425         r.registerMethodSubstitution(ThreadSubstitutions.class, &quot;isInterrupted&quot;, Receiver.class, boolean.class);</span>
<span class="line-modified">426     }</span>

427 
<span class="line-modified">428     public static final String cbcEncryptName;</span>
<span class="line-removed">429     public static final String cbcDecryptName;</span>
<span class="line-removed">430     public static final String aesEncryptName;</span>
<span class="line-removed">431     public static final String aesDecryptName;</span>
432 
433     public static final String reflectionClass;
434     public static final String constantPoolClass;
435 
436     static {
<span class="line-modified">437         if (Java8OrEarlier) {</span>
<span class="line-removed">438             cbcEncryptName = &quot;encrypt&quot;;</span>
<span class="line-removed">439             cbcDecryptName = &quot;decrypt&quot;;</span>
<span class="line-removed">440             aesEncryptName = &quot;encryptBlock&quot;;</span>
<span class="line-removed">441             aesDecryptName = &quot;decryptBlock&quot;;</span>
442             reflectionClass = &quot;sun.reflect.Reflection&quot;;
443             constantPoolClass = &quot;sun.reflect.ConstantPool&quot;;
444         } else {
<span class="line-removed">445             cbcEncryptName = &quot;implEncrypt&quot;;</span>
<span class="line-removed">446             cbcDecryptName = &quot;implDecrypt&quot;;</span>
<span class="line-removed">447             aesEncryptName = &quot;implEncryptBlock&quot;;</span>
<span class="line-removed">448             aesDecryptName = &quot;implDecryptBlock&quot;;</span>
449             reflectionClass = &quot;jdk.internal.reflect.Reflection&quot;;
450             constantPoolClass = &quot;jdk.internal.reflect.ConstantPool&quot;;
451         }
452     }
453 
<span class="line-modified">454     private static void registerAESPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>







































455         if (config.useAESIntrinsics) {
456             assert config.aescryptEncryptBlockStub != 0L;
457             assert config.aescryptDecryptBlockStub != 0L;
458             assert config.cipherBlockChainingEncryptAESCryptStub != 0L;
459             assert config.cipherBlockChainingDecryptAESCryptStub != 0L;
460             String arch = config.osArch;
461             String decryptSuffix = arch.equals(&quot;sparc&quot;) ? &quot;WithOriginalKey&quot; : &quot;&quot;;
<span class="line-modified">462             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CipherBlockChaining&quot;, bytecodeProvider);</span>
<span class="line-modified">463             r.registerMethodSubstitution(CipherBlockChainingSubstitutions.class, cbcEncryptName, Receiver.class, byte[].class, int.class, int.class, byte[].class, int.class);</span>
<span class="line-modified">464             r.registerMethodSubstitution(CipherBlockChainingSubstitutions.class, cbcDecryptName, cbcDecryptName + decryptSuffix, Receiver.class, byte[].class, int.class, int.class, byte[].class,</span>
<span class="line-modified">465                             int.class);</span>
<span class="line-modified">466             r = new Registration(plugins, &quot;com.sun.crypto.provider.AESCrypt&quot;, bytecodeProvider);</span>
<span class="line-modified">467             r.registerMethodSubstitution(AESCryptSubstitutions.class, aesEncryptName, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>
<span class="line-modified">468             r.registerMethodSubstitution(AESCryptSubstitutions.class, aesDecryptName, aesDecryptName + decryptSuffix, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>











469         }
470     }
471 
<span class="line-modified">472     private static void registerBigIntegerPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">473         Registration r = new Registration(plugins, BigInteger.class, bytecodeProvider);</span>
<span class="line-modified">474         if (config.useMultiplyToLenIntrinsic()) {</span>
<span class="line-modified">475             assert config.multiplyToLen != 0L;</span>
<span class="line-modified">476             if (Java8OrEarlier) {</span>
<span class="line-modified">477                 r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;multiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class, int.class,</span>
<span class="line-removed">478                                 int[].class);</span>
<span class="line-removed">479             } else {</span>
<span class="line-removed">480                 r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMultiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class, int.class,</span>
<span class="line-removed">481                                 int[].class);</span>
<span class="line-removed">482             }</span>
483         }
<span class="line-modified">484         if (config.useMulAddIntrinsic()) {</span>
<span class="line-modified">485             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMulAdd&quot;, int[].class, int[].class, int.class, int.class, int.class);</span>
<span class="line-modified">486         }</span>
<span class="line-modified">487         if (config.useMontgomeryMultiplyIntrinsic()) {</span>
<span class="line-modified">488             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMontgomeryMultiply&quot;, int[].class, int[].class, int[].class, int.class, long.class, int[].class);</span>
<span class="line-modified">489         }</span>
<span class="line-modified">490         if (config.useMontgomerySquareIntrinsic()) {</span>
<span class="line-modified">491             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implMontgomerySquare&quot;, int[].class, int[].class, int.class, long.class, int[].class);</span>
492         }
<span class="line-modified">493         if (config.useSquareToLenIntrinsic()) {</span>
<span class="line-modified">494             r.registerMethodSubstitution(BigIntegerSubstitutions.class, &quot;implSquareToLen&quot;, int[].class, int.class, int[].class, int.class);</span>









495         }






496     }
497 
<span class="line-modified">498     private static void registerSHAPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
499         boolean useSha1 = config.useSHA1Intrinsics();
500         boolean useSha256 = config.useSHA256Intrinsics();
501         boolean useSha512 = config.useSHA512Intrinsics();
502 
<span class="line-modified">503         if (!Java8OrEarlier &amp;&amp; (useSha1 || useSha256 || useSha512)) {</span>
<span class="line-modified">504             Registration r = new Registration(plugins, &quot;sun.security.provider.DigestBase&quot;, bytecodeProvider);</span>
505             r.registerMethodSubstitution(DigestBaseSubstitutions.class, &quot;implCompressMultiBlock0&quot;, Receiver.class, byte[].class, int.class, int.class);
506         }
507 

508         if (useSha1) {
509             assert config.sha1ImplCompress != 0L;
<span class="line-modified">510             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA&quot;, bytecodeProvider);</span>
<span class="line-modified">511             r.registerMethodSubstitution(SHASubstitutions.class, SHASubstitutions.implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
512         }
513         if (useSha256) {
514             assert config.sha256ImplCompress != 0L;
<span class="line-modified">515             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA2&quot;, bytecodeProvider);</span>
<span class="line-modified">516             r.registerMethodSubstitution(SHA2Substitutions.class, SHA2Substitutions.implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
517         }
518         if (useSha512) {
519             assert config.sha512ImplCompress != 0L;
<span class="line-modified">520             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA5&quot;, bytecodeProvider);</span>
<span class="line-modified">521             r.registerMethodSubstitution(SHA5Substitutions.class, SHA5Substitutions.implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
522         }
523     }
524 
525     private static void registerGHASHPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {
526         if (config.useGHASHIntrinsics()) {
527             assert config.ghashProcessBlocks != 0L;
528             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.GHASH&quot;);
529             r.register5(&quot;processBlocks&quot;,
530                             byte[].class,
531                             int.class,
532                             int.class,
533                             long[].class,
534                             long[].class,
535                             new InvocationPlugin() {
536                                 @Override
537                                 public boolean apply(GraphBuilderContext b,
538                                                 ResolvedJavaMethod targetMethod,
539                                                 Receiver receiver,
540                                                 ValueNode data,
541                                                 ValueNode inOffset,
542                                                 ValueNode blocks,
543                                                 ValueNode state,
544                                                 ValueNode hashSubkey) {
545                                     int longArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Long);
546                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
547                                     ValueNode dataOffset = AddNode.create(ConstantNode.forInt(byteArrayBaseOffset), inOffset, NodeView.DEFAULT);
548                                     ComputeObjectAddressNode dataAddress = b.add(new ComputeObjectAddressNode(data, dataOffset));
549                                     ComputeObjectAddressNode stateAddress = b.add(new ComputeObjectAddressNode(state, ConstantNode.forInt(longArrayBaseOffset)));
550                                     ComputeObjectAddressNode hashSubkeyAddress = b.add(new ComputeObjectAddressNode(hashSubkey, ConstantNode.forInt(longArrayBaseOffset)));
551                                     b.add(new ForeignCallNode(foreignCalls, GHASH_PROCESS_BLOCKS, stateAddress, hashSubkeyAddress, dataAddress, blocks));
552                                     return true;
553                                 }
554                             });
555         }
556     }
557 
<span class="line-modified">558     private static void registerCounterModePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">559         if (config.useAESCTRIntrinsics) {</span>
<span class="line-modified">560             assert config.counterModeAESCrypt != 0L;</span>
<span class="line-modified">561             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CounterMode&quot;, bytecodeProvider);</span>
<span class="line-modified">562             r.registerMethodSubstitution(CounterModeSubstitutions.class, &quot;implCrypt&quot;, Receiver.class, byte[].class, int.class, int.class, byte[].class, int.class);</span>

563         }
564     }
565 
<span class="line-modified">566     private static void registerCRC32Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">567         if (config.useCRC32Intrinsics) {</span>
<span class="line-modified">568             Registration r = new Registration(plugins, CRC32.class, bytecodeProvider);</span>
<span class="line-modified">569             r.registerMethodSubstitution(CRC32Substitutions.class, &quot;update&quot;, int.class, int.class);</span>
<span class="line-modified">570             if (Java8OrEarlier) {</span>
<span class="line-modified">571                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">572                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
<span class="line-modified">573             } else {</span>
<span class="line-modified">574                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateBytes0&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">575                 r.registerMethodSubstitution(CRC32Substitutions.class, &quot;updateByteBuffer0&quot;, int.class, long.class, int.class, int.class);</span>
<span class="line-modified">576             }</span>






























577         }
578     }
579 
<span class="line-modified">580     private static void registerCRC32CPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">581         if (config.useCRC32CIntrinsics) {</span>
<span class="line-modified">582             Registration r = new Registration(plugins, &quot;java.util.zip.CRC32C&quot;, bytecodeProvider);</span>
<span class="line-modified">583             r.registerMethodSubstitution(CRC32CSubstitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">584             r.registerMethodSubstitution(CRC32CSubstitutions.class, &quot;updateDirectByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
585         }
586     }
587 
<span class="line-modified">588     private static void registerArraysSupportPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">589         if (config.useVectorizedMismatchIntrinsic) {</span>
<span class="line-modified">590             Registration r = new Registration(plugins, &quot;jdk.internal.util.ArraysSupport&quot;, bytecodeProvider);</span>
<span class="line-modified">591             r.registerMethodSubstitution(ArraysSupportSubstitutions.class, &quot;vectorizedMismatch&quot;, Object.class, long.class, Object.class, long.class, int.class, int.class);</span>

592         }
593     }
594 }
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
<span class="line-added"> 28 import static org.graalvm.compiler.hotspot.HotSpotBackend.BASE64_ENCODE_BLOCK;</span>
 29 import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
 30 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 31 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.JAVA_THREAD_THREAD_OBJECT_LOCATION;
 32 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;

 33 
 34 import java.lang.invoke.ConstantCallSite;
 35 import java.lang.invoke.MutableCallSite;
 36 import java.lang.invoke.VolatileCallSite;
 37 import java.lang.reflect.Array;
<span class="line-added"> 38 import java.lang.reflect.Type;</span>
 39 import java.math.BigInteger;
 40 import java.util.zip.CRC32;
 41 
<span class="line-added"> 42 import jdk.internal.vm.compiler.collections.Pair;</span>
 43 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;

 44 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 45 import org.graalvm.compiler.core.common.type.ObjectStamp;
 46 import org.graalvm.compiler.core.common.type.StampFactory;
 47 import org.graalvm.compiler.core.common.type.TypeReference;
<span class="line-added"> 48 import org.graalvm.compiler.debug.GraalError;</span>
 49 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<span class="line-added"> 50 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;</span>
 51 import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
 52 import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
 53 import org.graalvm.compiler.hotspot.replacements.ArraysSupportSubstitutions;
 54 import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
 55 import org.graalvm.compiler.hotspot.replacements.CRC32CSubstitutions;
 56 import org.graalvm.compiler.hotspot.replacements.CRC32Substitutions;
 57 import org.graalvm.compiler.hotspot.replacements.CallSiteTargetNode;
 58 import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
 59 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
 60 import org.graalvm.compiler.hotspot.replacements.CounterModeSubstitutions;
 61 import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;
<span class="line-added"> 62 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;</span>
 63 import org.graalvm.compiler.hotspot.replacements.HotSpotArraySubstitutions;
 64 import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;
 65 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 66 import org.graalvm.compiler.hotspot.replacements.ObjectCloneNode;

 67 import org.graalvm.compiler.hotspot.replacements.ReflectionGetCallerClassNode;
 68 import org.graalvm.compiler.hotspot.replacements.ReflectionSubstitutions;
 69 import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
 70 import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
 71 import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
 72 import org.graalvm.compiler.hotspot.replacements.StringUTF16Substitutions;
 73 import org.graalvm.compiler.hotspot.replacements.ThreadSubstitutions;
 74 import org.graalvm.compiler.hotspot.word.HotSpotWordTypes;
 75 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 76 import org.graalvm.compiler.nodes.ConstantNode;
 77 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 78 import org.graalvm.compiler.nodes.NodeView;
 79 import org.graalvm.compiler.nodes.ValueNode;
 80 import org.graalvm.compiler.nodes.calc.AddNode;
 81 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
 82 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 83 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 84 import org.graalvm.compiler.nodes.graphbuilderconf.ForeignCallPlugin;
 85 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 86 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 87 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 88 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 89 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 90 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 91 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;
 92 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
 93 import org.graalvm.compiler.nodes.memory.ReadNode;
 94 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 95 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-added"> 96 import org.graalvm.compiler.nodes.spi.Replacements;</span>
 97 import org.graalvm.compiler.nodes.util.GraphUtil;
 98 import org.graalvm.compiler.options.OptionValues;
 99 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
100 import org.graalvm.compiler.replacements.InlineDuringParsingPlugin;
101 import org.graalvm.compiler.replacements.MethodHandlePlugin;
102 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;
103 import org.graalvm.compiler.replacements.ReplacementsImpl;
104 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins;
105 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
106 import org.graalvm.compiler.serviceprovider.GraalServices;
<span class="line-added">107 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
108 import org.graalvm.compiler.word.WordOperationPlugin;
109 import org.graalvm.compiler.word.WordTypes;
110 import jdk.internal.vm.compiler.word.LocationIdentity;
111 
112 import jdk.vm.ci.code.CodeUtil;
<span class="line-added">113 import jdk.vm.ci.code.TargetDescription;</span>
<span class="line-added">114 import jdk.vm.ci.hotspot.VMIntrinsicMethod;</span>
115 import jdk.vm.ci.meta.ConstantReflectionProvider;
116 import jdk.vm.ci.meta.DeoptimizationAction;
117 import jdk.vm.ci.meta.JavaKind;
118 import jdk.vm.ci.meta.MetaAccessProvider;
119 import jdk.vm.ci.meta.ResolvedJavaMethod;
<span class="line-added">120 import jdk.vm.ci.services.Services;</span>
121 import sun.misc.Unsafe;
122 
123 /**
124  * Defines the {@link Plugins} used when running on HotSpot.
125  */
126 public class HotSpotGraphBuilderPlugins {
127 
128     /**
129      * Creates a {@link Plugins} object that should be used when running on HotSpot.
130      *
131      * @param constantReflection
132      * @param snippetReflection
133      * @param foreignCalls
<span class="line-added">134      * @param options</span>
<span class="line-added">135      * @param target</span>
136      */
<span class="line-modified">137     public static Plugins create(HotSpotGraalRuntimeProvider graalRuntime,</span>
<span class="line-modified">138                     CompilerConfiguration compilerConfiguration,</span>
<span class="line-modified">139                     GraalHotSpotVMConfig config,</span>
<span class="line-added">140                     HotSpotWordTypes wordTypes,</span>
<span class="line-added">141                     MetaAccessProvider metaAccess,</span>
<span class="line-added">142                     ConstantReflectionProvider constantReflection,</span>
<span class="line-added">143                     SnippetReflectionProvider snippetReflection,</span>
<span class="line-added">144                     ForeignCallsProvider foreignCalls,</span>
<span class="line-added">145                     ReplacementsImpl replacements,</span>
<span class="line-added">146                     OptionValues options, TargetDescription target) {</span>
<span class="line-added">147         InvocationPlugins invocationPlugins = new HotSpotInvocationPlugins(graalRuntime, config, compilerConfiguration);</span>
148 
149         Plugins plugins = new Plugins(invocationPlugins);
<span class="line-modified">150         NodeIntrinsificationProvider nodeIntrinsificationProvider = new NodeIntrinsificationProvider(metaAccess, snippetReflection, foreignCalls, wordTypes, target);</span>
151         HotSpotWordOperationPlugin wordOperationPlugin = new HotSpotWordOperationPlugin(snippetReflection, wordTypes);
152         HotSpotNodePlugin nodePlugin = new HotSpotNodePlugin(wordOperationPlugin, config, wordTypes);
153 
154         plugins.appendTypePlugin(nodePlugin);
155         plugins.appendNodePlugin(nodePlugin);

156         if (!GeneratePIC.getValue(options)) {
157             plugins.appendNodePlugin(new MethodHandlePlugin(constantReflection.getMethodHandleAccess(), true));
158         }
159         plugins.appendInlineInvokePlugin(replacements);
160         if (InlineDuringParsing.getValue(options)) {
161             plugins.appendInlineInvokePlugin(new InlineDuringParsingPlugin());
162         }
163 
164         if (GeneratePIC.getValue(options)) {
<span class="line-modified">165             plugins.setClassInitializationPlugin(new HotSpotAOTClassInitializationPlugin());</span>
166             if (TieredAOT.getValue(options)) {
167                 plugins.setProfilingPlugin(new HotSpotAOTProfilingPlugin());
168             }
<span class="line-added">169         } else {</span>
<span class="line-added">170             if (config.instanceKlassInitThreadOffset != -1) {</span>
<span class="line-added">171                 plugins.setClassInitializationPlugin(new HotSpotJITClassInitializationPlugin());</span>
<span class="line-added">172             }</span>
173         }
174 
175         invocationPlugins.defer(new Runnable() {
176 
177             @Override
178             public void run() {
<span class="line-modified">179                 registerObjectPlugins(invocationPlugins, options, config, replacements);</span>
<span class="line-modified">180                 registerClassPlugins(plugins, config, replacements);</span>

181                 registerSystemPlugins(invocationPlugins, foreignCalls);
<span class="line-modified">182                 registerThreadPlugins(invocationPlugins, metaAccess, wordTypes, config, replacements);</span>
183                 if (!GeneratePIC.getValue(options)) {
184                     registerCallSitePlugins(invocationPlugins);
185                 }
<span class="line-modified">186                 registerReflectionPlugins(invocationPlugins, replacements);</span>
<span class="line-modified">187                 registerConstantPoolPlugins(invocationPlugins, wordTypes, config, replacements);</span>
<span class="line-modified">188                 registerAESPlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">189                 registerCRC32Plugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">190                 registerCRC32CPlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">191                 registerBigIntegerPlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">192                 registerSHAPlugins(invocationPlugins, config, replacements);</span>
193                 registerGHASHPlugins(invocationPlugins, config, metaAccess, foreignCalls);
<span class="line-modified">194                 registerCounterModePlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">195                 registerBase64Plugins(invocationPlugins, config, metaAccess, foreignCalls);</span>
<span class="line-modified">196                 registerUnsafePlugins(invocationPlugins, config, replacements);</span>
<span class="line-modified">197                 StandardGraphBuilderPlugins.registerInvocationPlugins(metaAccess, snippetReflection, invocationPlugins, replacements, true, false, true);</span>
<span class="line-modified">198                 registerArrayPlugins(invocationPlugins, replacements);</span>
<span class="line-modified">199                 registerStringPlugins(invocationPlugins, replacements);</span>
<span class="line-added">200                 registerArraysSupportPlugins(invocationPlugins, config, replacements);</span>
201 
202                 for (NodeIntrinsicPluginFactory factory : GraalServices.load(NodeIntrinsicPluginFactory.class)) {
203                     factory.registerPlugins(invocationPlugins, nodeIntrinsificationProvider);
204                 }
205             }
206         });
207         return plugins;
208     }
209 
<span class="line-modified">210     private static void registerObjectPlugins(InvocationPlugins plugins, OptionValues options, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">211         Registration r = new Registration(plugins, Object.class, replacements);</span>
212         if (!GeneratePIC.getValue(options)) {
213             // FIXME: clone() requires speculation and requires a fix in here (to check that
214             // b.getAssumptions() != null), and in ReplacementImpl.getSubstitution() where there is
215             // an instantiation of IntrinsicGraphBuilder using a constructor that sets
216             // AllowAssumptions to YES automatically. The former has to inherit the assumptions
217             // settings from the root compile instead. So, for now, I&#39;m disabling it for
218             // GeneratePIC.
219             r.register1(&quot;clone&quot;, Receiver.class, new InvocationPlugin() {
220                 @Override
221                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
222                     ValueNode object = receiver.get();
223                     b.addPush(JavaKind.Object, new ObjectCloneNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), object));
224                     return true;
225                 }
226 
227                 @Override
228                 public boolean inlineOnly() {
229                     return true;
230                 }
231             });
232         }
<span class="line-modified">233         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {</span>
<span class="line-added">234             @Override</span>
<span class="line-added">235             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added">236                 ValueNode object = receiver.get();</span>
<span class="line-added">237                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object));</span>
<span class="line-added">238                 return true;</span>
<span class="line-added">239             }</span>
<span class="line-added">240 </span>
<span class="line-added">241             @Override</span>
<span class="line-added">242             public boolean inlineOnly() {</span>
<span class="line-added">243                 return true;</span>
<span class="line-added">244             }</span>
<span class="line-added">245         });</span>
246         if (config.inlineNotify()) {
<span class="line-modified">247             r.register1(&quot;notify&quot;, Receiver.class, new InvocationPlugin() {</span>
<span class="line-added">248                 @Override</span>
<span class="line-added">249                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added">250                     ValueNode object = receiver.get();</span>
<span class="line-added">251                     b.add(new FastNotifyNode(object, false, b.bci()));</span>
<span class="line-added">252                     return true;</span>
<span class="line-added">253                 }</span>
<span class="line-added">254 </span>
<span class="line-added">255                 @Override</span>
<span class="line-added">256                 public boolean inlineOnly() {</span>
<span class="line-added">257                     return true;</span>
<span class="line-added">258                 }</span>
<span class="line-added">259             });</span>
260         }
261         if (config.inlineNotifyAll()) {
<span class="line-modified">262             r.register1(&quot;notifyAll&quot;, Receiver.class, new InvocationPlugin() {</span>
<span class="line-added">263                 @Override</span>
<span class="line-added">264                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-added">265                     ValueNode object = receiver.get();</span>
<span class="line-added">266                     b.add(new FastNotifyNode(object, true, b.bci()));</span>
<span class="line-added">267                     return true;</span>
<span class="line-added">268                 }</span>
<span class="line-added">269 </span>
<span class="line-added">270                 @Override</span>
<span class="line-added">271                 public boolean inlineOnly() {</span>
<span class="line-added">272                     return true;</span>
<span class="line-added">273                 }</span>
<span class="line-added">274             });</span>
275         }
276     }
277 
<span class="line-modified">278     private static void registerClassPlugins(Plugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">279         Registration r = new Registration(plugins.getInvocationPlugins(), Class.class, replacements);</span>
280 
281         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getModifiers&quot;, Receiver.class);
282         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isInterface&quot;, Receiver.class);
283         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isArray&quot;, Receiver.class);
284         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isPrimitive&quot;, Receiver.class);
285         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getSuperclass&quot;, Receiver.class);
286 
287         if (config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;, Integer.MAX_VALUE) != Integer.MAX_VALUE) {
288             r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getComponentType&quot;, Receiver.class);
289         }
290     }
291 
292     private static void registerCallSitePlugins(InvocationPlugins plugins) {
293         InvocationPlugin plugin = new InvocationPlugin() {
294             @Override
295             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
296                 ValueNode callSite = receiver.get();
<span class="line-modified">297                 ValueNode folded = CallSiteTargetNode.tryFold(GraphUtil.originalValue(callSite, true), b.getMetaAccess(), b.getAssumptions());</span>
298                 if (folded != null) {
299                     b.addPush(JavaKind.Object, folded);
300                 } else {
301                     b.addPush(JavaKind.Object, new CallSiteTargetNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), callSite));
302                 }
303                 return true;
304             }
305 
306             @Override
307             public boolean inlineOnly() {
308                 return true;
309             }
310         };
311         plugins.register(plugin, ConstantCallSite.class, &quot;getTarget&quot;, Receiver.class);
312         plugins.register(plugin, MutableCallSite.class, &quot;getTarget&quot;, Receiver.class);
313         plugins.register(plugin, VolatileCallSite.class, &quot;getTarget&quot;, Receiver.class);
314     }
315 
<span class="line-modified">316     private static void registerReflectionPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">317         Registration r = new Registration(plugins, reflectionClass, replacements);</span>
318         r.register0(&quot;getCallerClass&quot;, new InvocationPlugin() {
319             @Override
320             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
321                 b.addPush(JavaKind.Object, new ReflectionGetCallerClassNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions())));
322                 return true;
323             }
324 
325             @Override
326             public boolean inlineOnly() {
327                 return true;
328             }
329         });
330         r.registerMethodSubstitution(ReflectionSubstitutions.class, &quot;getClassAccessFlags&quot;, Class.class);
331     }
332 
<span class="line-modified">333     private static void registerUnsafePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
334         Registration r;
<span class="line-modified">335         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-modified">336             r = new Registration(plugins, Unsafe.class, replacements);</span>
337         } else {
<span class="line-modified">338             r = new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements);</span>
339         }
<span class="line-modified">340         String substituteMethodName = config.doingUnsafeAccessOffset != Integer.MAX_VALUE ? &quot;copyMemoryGuarded&quot; : &quot;copyMemory&quot;;</span>
<span class="line-modified">341         r.registerMethodSubstitution(HotSpotUnsafeSubstitutions.class, HotSpotUnsafeSubstitutions.copyMemoryName, substituteMethodName, Receiver.class, Object.class, long.class, Object.class,</span>
<span class="line-added">342                         long.class, long.class);</span>
343     }
344 
345     private static final LocationIdentity INSTANCE_KLASS_CONSTANTS = NamedLocationIdentity.immutable(&quot;InstanceKlass::_constants&quot;);
346     private static final LocationIdentity CONSTANT_POOL_LENGTH = NamedLocationIdentity.immutable(&quot;ConstantPool::_length&quot;);
347 
348     /**
349      * Emits a node to get the metaspace {@code ConstantPool} pointer given the value of the
350      * {@code constantPoolOop} field in a ConstantPool value.
351      *
352      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
353      * @return a node representing the metaspace {@code ConstantPool} pointer associated with
354      *         {@code constantPoolOop}
355      */
356     private static ValueNode getMetaspaceConstantPool(GraphBuilderContext b, ValueNode constantPoolOop, WordTypes wordTypes, GraalHotSpotVMConfig config) {
357         // ConstantPool.constantPoolOop is in fact the holder class.
358         ValueNode value = b.nullCheckedValue(constantPoolOop, DeoptimizationAction.None);
359         ValueNode klass = b.add(ClassGetHubNode.create(value, b.getMetaAccess(), b.getConstantReflection(), false));
360 
361         boolean notCompressible = false;
362         AddressNode constantsAddress = b.add(new OffsetAddressNode(klass, b.add(ConstantNode.forLong(config.instanceKlassConstantsOffset))));
363         return WordOperationPlugin.readOp(b, wordTypes.getWordKind(), constantsAddress, INSTANCE_KLASS_CONSTANTS, BarrierType.NONE, notCompressible);
364     }
365 
366     /**
367      * Emits a node representing an element in a metaspace {@code ConstantPool}.
368      *
369      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
370      */
371     private static boolean readMetaspaceConstantPoolElement(GraphBuilderContext b, ValueNode constantPoolOop, ValueNode index, JavaKind elementKind, WordTypes wordTypes, GraalHotSpotVMConfig config) {
372         ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
373         int shift = CodeUtil.log2(wordTypes.getWordKind().getByteCount());
374         ValueNode scaledIndex = b.add(new LeftShiftNode(IntegerConvertNode.convert(index, StampFactory.forKind(JavaKind.Long), NodeView.DEFAULT), b.add(ConstantNode.forInt(shift))));
375         ValueNode offset = b.add(new AddNode(scaledIndex, b.add(ConstantNode.forLong(config.constantPoolSize))));
376         AddressNode elementAddress = b.add(new OffsetAddressNode(constants, offset));
377         boolean notCompressible = false;
378         ValueNode elementValue = WordOperationPlugin.readOp(b, elementKind, elementAddress, NamedLocationIdentity.getArrayLocation(elementKind), BarrierType.NONE, notCompressible);
379         b.addPush(elementKind, elementValue);
380         return true;
381     }
382 
<span class="line-modified">383     private static void registerConstantPoolPlugins(InvocationPlugins plugins, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">384         Registration r = new Registration(plugins, constantPoolClass, replacements);</span>
385 
386         r.register2(&quot;getSize0&quot;, Receiver.class, Object.class, new InvocationPlugin() {
387             @Override
388             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop) {
389                 boolean notCompressible = false;
390                 ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
391                 AddressNode lengthAddress = b.add(new OffsetAddressNode(constants, b.add(ConstantNode.forLong(config.constantPoolLengthOffset))));
392                 ValueNode length = WordOperationPlugin.readOp(b, JavaKind.Int, lengthAddress, CONSTANT_POOL_LENGTH, BarrierType.NONE, notCompressible);
393                 b.addPush(JavaKind.Int, length);
394                 return true;
395             }
396         });
397 
398         r.register3(&quot;getIntAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
399             @Override
400             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
401                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Int, wordTypes, config);
402             }
403         });
404         r.register3(&quot;getLongAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
</pre>
<hr />
<pre>
434 
435             @Override
436             public boolean inlineOnly() {
437                 return true;
438             }
439         });
440         r.register5(&quot;arraycopy&quot;, Object.class, int.class, Object.class, int.class, int.class, new InvocationPlugin() {
441             @Override
442             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode src, ValueNode srcPos, ValueNode dst, ValueNode dstPos, ValueNode length) {
443                 b.add(new ArrayCopyNode(b.bci(), src, srcPos, dst, dstPos, length));
444                 return true;
445             }
446 
447             @Override
448             public boolean inlineOnly() {
449                 return true;
450             }
451         });
452     }
453 
<span class="line-modified">454     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">455         Registration r = new Registration(plugins, Array.class, replacements);</span>
456         r.setAllowOverwrite(true);
457         r.registerMethodSubstitution(HotSpotArraySubstitutions.class, &quot;newInstance&quot;, Class.class, int.class);
458     }
459 
<span class="line-modified">460     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">461         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">462             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);</span>
463             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;toBytes&quot;, char[].class, int.class, int.class);
464             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChars&quot;, byte[].class, int.class, int.class, char[].class, int.class);
465         }
466     }
467 
<span class="line-modified">468     private static void registerThreadPlugins(InvocationPlugins plugins, MetaAccessProvider metaAccess, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">469         Registration r = new Registration(plugins, Thread.class, replacements);</span>
470         r.register0(&quot;currentThread&quot;, new InvocationPlugin() {
471             @Override
472             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
473                 CurrentJavaThreadNode thread = b.add(new CurrentJavaThreadNode(wordTypes.getWordKind()));
474                 ValueNode offset = b.add(ConstantNode.forLong(config.threadObjectOffset));
475                 AddressNode address = b.add(new OffsetAddressNode(thread, offset));
476                 // JavaThread::_threadObj is never compressed
477                 ObjectStamp stamp = StampFactory.objectNonNull(TypeReference.create(b.getAssumptions(), metaAccess.lookupJavaType(Thread.class)));
478                 b.addPush(JavaKind.Object, new ReadNode(address, JAVA_THREAD_THREAD_OBJECT_LOCATION, stamp, BarrierType.NONE));
479                 return true;
480             }
481         });
482 
<span class="line-modified">483         if (config.osThreadInterruptedOffset != Integer.MAX_VALUE) {</span>
<span class="line-modified">484             r.registerMethodSubstitution(ThreadSubstitutions.class, &quot;isInterrupted&quot;, Receiver.class, boolean.class);</span>
<span class="line-added">485         }</span>
486 
<span class="line-modified">487     }</span>



488 
489     public static final String reflectionClass;
490     public static final String constantPoolClass;
491 
492     static {
<span class="line-modified">493         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>




494             reflectionClass = &quot;sun.reflect.Reflection&quot;;
495             constantPoolClass = &quot;sun.reflect.ConstantPool&quot;;
496         } else {




497             reflectionClass = &quot;jdk.internal.reflect.Reflection&quot;;
498             constantPoolClass = &quot;jdk.internal.reflect.ConstantPool&quot;;
499         }
500     }
501 
<span class="line-modified">502     public static String lookupIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {</span>
<span class="line-added">503         return selectIntrinsicName(config, className, name1, name2).getLeft();</span>
<span class="line-added">504     }</span>
<span class="line-added">505 </span>
<span class="line-added">506     /**</span>
<span class="line-added">507      * Returns a pair of Strings where the left one represents the matched intrinsic name and the</span>
<span class="line-added">508      * right one represents the mismatched intrinsic name.</span>
<span class="line-added">509      */</span>
<span class="line-added">510     public static Pair&lt;String, String&gt; selectIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {</span>
<span class="line-added">511         boolean foundName1 = false;</span>
<span class="line-added">512         boolean foundName2 = false;</span>
<span class="line-added">513         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {</span>
<span class="line-added">514             if (className.equals(intrinsic.declaringClass)) {</span>
<span class="line-added">515                 if (name1.equals(intrinsic.name)) {</span>
<span class="line-added">516                     foundName1 = true;</span>
<span class="line-added">517                 } else if (name2.equals(intrinsic.name)) {</span>
<span class="line-added">518                     foundName2 = true;</span>
<span class="line-added">519                 }</span>
<span class="line-added">520             }</span>
<span class="line-added">521         }</span>
<span class="line-added">522         if (foundName1 &amp;&amp; !foundName2) {</span>
<span class="line-added">523             return Pair.create(name1, name2);</span>
<span class="line-added">524         } else if (foundName2 &amp;&amp; !foundName1) {</span>
<span class="line-added">525             return Pair.create(name2, name1);</span>
<span class="line-added">526         }</span>
<span class="line-added">527         throw GraalError.shouldNotReachHere();</span>
<span class="line-added">528     }</span>
<span class="line-added">529 </span>
<span class="line-added">530     public static boolean isIntrinsicName(GraalHotSpotVMConfig config, String className, String name) {</span>
<span class="line-added">531         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {</span>
<span class="line-added">532             if (className.equals(intrinsic.declaringClass)) {</span>
<span class="line-added">533                 if (name.equals(intrinsic.name)) {</span>
<span class="line-added">534                     return true;</span>
<span class="line-added">535                 }</span>
<span class="line-added">536             }</span>
<span class="line-added">537         }</span>
<span class="line-added">538         return false;</span>
<span class="line-added">539     }</span>
<span class="line-added">540 </span>
<span class="line-added">541     private static void registerAESPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
542         if (config.useAESIntrinsics) {
543             assert config.aescryptEncryptBlockStub != 0L;
544             assert config.aescryptDecryptBlockStub != 0L;
545             assert config.cipherBlockChainingEncryptAESCryptStub != 0L;
546             assert config.cipherBlockChainingDecryptAESCryptStub != 0L;
547             String arch = config.osArch;
548             String decryptSuffix = arch.equals(&quot;sparc&quot;) ? &quot;WithOriginalKey&quot; : &quot;&quot;;
<span class="line-modified">549 </span>
<span class="line-modified">550             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CipherBlockChaining&quot;, replacements);</span>
<span class="line-modified">551 </span>
<span class="line-modified">552             Pair&lt;String, String&gt; cbcEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implEncrypt&quot;, &quot;encrypt&quot;);</span>
<span class="line-modified">553             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcEncryptName, Receiver.class, byte[].class, int.class, int.class,</span>
<span class="line-modified">554                             byte[].class, int.class);</span>
<span class="line-modified">555 </span>
<span class="line-added">556             Pair&lt;String, String&gt; cbcDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implDecrypt&quot;, &quot;decrypt&quot;);</span>
<span class="line-added">557             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcDecryptName, cbcDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, int.class,</span>
<span class="line-added">558                             byte[].class, int.class);</span>
<span class="line-added">559 </span>
<span class="line-added">560             r = new Registration(plugins, &quot;com.sun.crypto.provider.AESCrypt&quot;, replacements);</span>
<span class="line-added">561 </span>
<span class="line-added">562             Pair&lt;String, String&gt; aesEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implEncryptBlock&quot;, &quot;encryptBlock&quot;);</span>
<span class="line-added">563             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesEncryptName, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>
<span class="line-added">564 </span>
<span class="line-added">565             Pair&lt;String, String&gt; aesDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implDecryptBlock&quot;, &quot;decryptBlock&quot;);</span>
<span class="line-added">566             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesDecryptName, aesDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, byte[].class, int.class);</span>
567         }
568     }
569 
<span class="line-modified">570     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, Type... argumentTypes) {</span>
<span class="line-modified">571         try {</span>
<span class="line-modified">572             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), argumentTypes);</span>
<span class="line-modified">573         } catch (NoSuchMethodError e) {</span>
<span class="line-modified">574             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,</span>
<span class="line-modified">575                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));</span>





576         }
<span class="line-modified">577     }</span>
<span class="line-modified">578 </span>
<span class="line-modified">579     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, String substituteName, Type... argumentTypes) {</span>
<span class="line-modified">580         try {</span>
<span class="line-modified">581             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), substituteName, argumentTypes);</span>
<span class="line-modified">582         } catch (NoSuchMethodError e) {</span>
<span class="line-modified">583             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,</span>
<span class="line-modified">584                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));</span>
585         }
<span class="line-modified">586     }</span>
<span class="line-modified">587 </span>
<span class="line-added">588     private static void registerBigIntegerPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-added">589         Registration r = new Registration(plugins, BigInteger.class, replacements);</span>
<span class="line-added">590         assert !config.useMultiplyToLenIntrinsic() || config.multiplyToLen != 0L;</span>
<span class="line-added">591         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-added">592             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;multiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,</span>
<span class="line-added">593                             int.class, int[].class);</span>
<span class="line-added">594         } else {</span>
<span class="line-added">595             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implMultiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,</span>
<span class="line-added">596                             int.class, int[].class);</span>
597         }
<span class="line-added">598         r.registerConditionalMethodSubstitution(config.useMulAddIntrinsic(), BigIntegerSubstitutions.class, &quot;implMulAdd&quot;, int[].class, int[].class, int.class, int.class, int.class);</span>
<span class="line-added">599         r.registerConditionalMethodSubstitution(config.useMontgomeryMultiplyIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomeryMultiply&quot;, int[].class, int[].class, int[].class, int.class,</span>
<span class="line-added">600                         long.class, int[].class);</span>
<span class="line-added">601         r.registerConditionalMethodSubstitution(config.useMontgomerySquareIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomerySquare&quot;, int[].class, int[].class, int.class, long.class,</span>
<span class="line-added">602                         int[].class);</span>
<span class="line-added">603         r.registerConditionalMethodSubstitution(config.useSquareToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implSquareToLen&quot;, int[].class, int.class, int[].class, int.class);</span>
604     }
605 
<span class="line-modified">606     private static void registerSHAPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
607         boolean useSha1 = config.useSHA1Intrinsics();
608         boolean useSha256 = config.useSHA256Intrinsics();
609         boolean useSha512 = config.useSHA512Intrinsics();
610 
<span class="line-modified">611         if (isIntrinsicName(config, &quot;sun/security/provider/DigestBase&quot;, &quot;implCompressMultiBlock0&quot;) &amp;&amp; (useSha1 || useSha256 || useSha512)) {</span>
<span class="line-modified">612             Registration r = new Registration(plugins, &quot;sun.security.provider.DigestBase&quot;, replacements);</span>
613             r.registerMethodSubstitution(DigestBaseSubstitutions.class, &quot;implCompressMultiBlock0&quot;, Receiver.class, byte[].class, int.class, int.class);
614         }
615 
<span class="line-added">616         Pair&lt;String, String&gt; implCompressName = selectIntrinsicName(config, &quot;sun/security/provider/SHA&quot;, &quot;implCompress&quot;, &quot;implCompress0&quot;);</span>
617         if (useSha1) {
618             assert config.sha1ImplCompress != 0L;
<span class="line-modified">619             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA&quot;, replacements);</span>
<span class="line-modified">620             registerAndCheckMismatch(r, SHASubstitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
621         }
622         if (useSha256) {
623             assert config.sha256ImplCompress != 0L;
<span class="line-modified">624             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA2&quot;, replacements);</span>
<span class="line-modified">625             registerAndCheckMismatch(r, SHA2Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
626         }
627         if (useSha512) {
628             assert config.sha512ImplCompress != 0L;
<span class="line-modified">629             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA5&quot;, replacements);</span>
<span class="line-modified">630             registerAndCheckMismatch(r, SHA5Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);</span>
631         }
632     }
633 
634     private static void registerGHASHPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {
635         if (config.useGHASHIntrinsics()) {
636             assert config.ghashProcessBlocks != 0L;
637             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.GHASH&quot;);
638             r.register5(&quot;processBlocks&quot;,
639                             byte[].class,
640                             int.class,
641                             int.class,
642                             long[].class,
643                             long[].class,
644                             new InvocationPlugin() {
645                                 @Override
646                                 public boolean apply(GraphBuilderContext b,
647                                                 ResolvedJavaMethod targetMethod,
648                                                 Receiver receiver,
649                                                 ValueNode data,
650                                                 ValueNode inOffset,
651                                                 ValueNode blocks,
652                                                 ValueNode state,
653                                                 ValueNode hashSubkey) {
654                                     int longArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Long);
655                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
656                                     ValueNode dataOffset = AddNode.create(ConstantNode.forInt(byteArrayBaseOffset), inOffset, NodeView.DEFAULT);
657                                     ComputeObjectAddressNode dataAddress = b.add(new ComputeObjectAddressNode(data, dataOffset));
658                                     ComputeObjectAddressNode stateAddress = b.add(new ComputeObjectAddressNode(state, ConstantNode.forInt(longArrayBaseOffset)));
659                                     ComputeObjectAddressNode hashSubkeyAddress = b.add(new ComputeObjectAddressNode(hashSubkey, ConstantNode.forInt(longArrayBaseOffset)));
660                                     b.add(new ForeignCallNode(foreignCalls, GHASH_PROCESS_BLOCKS, stateAddress, hashSubkeyAddress, dataAddress, blocks));
661                                     return true;
662                                 }
663                             });
664         }
665     }
666 
<span class="line-modified">667     private static void registerCounterModePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">668         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">669             assert !config.useAESCTRIntrinsics || config.counterModeAESCrypt != 0L;</span>
<span class="line-modified">670             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CounterMode&quot;, replacements);</span>
<span class="line-modified">671             r.registerConditionalMethodSubstitution(config.useAESCTRIntrinsics, CounterModeSubstitutions.class, &quot;implCrypt&quot;, Receiver.class, byte[].class, int.class, int.class, byte[].class,</span>
<span class="line-added">672                             int.class);</span>
673         }
674     }
675 
<span class="line-modified">676     private static void registerBase64Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {</span>
<span class="line-modified">677         if (config.useBase64Intrinsics()) {</span>
<span class="line-modified">678             Registration r = new Registration(plugins, &quot;java.util.Base64$Encoder&quot;);</span>
<span class="line-modified">679             r.register7(&quot;encodeBlock&quot;,</span>
<span class="line-modified">680                             Receiver.class,</span>
<span class="line-modified">681                             byte[].class,</span>
<span class="line-modified">682                             int.class,</span>
<span class="line-modified">683                             int.class,</span>
<span class="line-modified">684                             byte[].class,</span>
<span class="line-modified">685                             int.class,</span>
<span class="line-modified">686                             boolean.class,</span>
<span class="line-added">687                             new InvocationPlugin() {</span>
<span class="line-added">688                                 @Override</span>
<span class="line-added">689                                 public boolean apply(GraphBuilderContext b,</span>
<span class="line-added">690                                                 ResolvedJavaMethod targetMethod,</span>
<span class="line-added">691                                                 Receiver receiver,</span>
<span class="line-added">692                                                 ValueNode src,</span>
<span class="line-added">693                                                 ValueNode sp,</span>
<span class="line-added">694                                                 ValueNode sl,</span>
<span class="line-added">695                                                 ValueNode dst,</span>
<span class="line-added">696                                                 ValueNode dp,</span>
<span class="line-added">697                                                 ValueNode isURL) {</span>
<span class="line-added">698                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);</span>
<span class="line-added">699                                     ComputeObjectAddressNode srcAddress = b.add(new ComputeObjectAddressNode(src, ConstantNode.forInt(byteArrayBaseOffset)));</span>
<span class="line-added">700                                     ComputeObjectAddressNode dstAddress = b.add(new ComputeObjectAddressNode(dst, ConstantNode.forInt(byteArrayBaseOffset)));</span>
<span class="line-added">701                                     b.add(new ForeignCallNode(foreignCalls, BASE64_ENCODE_BLOCK, srcAddress, sp, sl, dstAddress, dp, isURL));</span>
<span class="line-added">702                                     return true;</span>
<span class="line-added">703                                 }</span>
<span class="line-added">704                             });</span>
<span class="line-added">705         }</span>
<span class="line-added">706     }</span>
<span class="line-added">707 </span>
<span class="line-added">708     private static void registerCRC32Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-added">709         Registration r = new Registration(plugins, CRC32.class, replacements);</span>
<span class="line-added">710         r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;update&quot;, int.class, int.class);</span>
<span class="line-added">711         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
<span class="line-added">712             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-added">713             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
<span class="line-added">714         } else {</span>
<span class="line-added">715             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes0&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-added">716             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer0&quot;, int.class, long.class, int.class, int.class);</span>
717         }
718     }
719 
<span class="line-modified">720     private static void registerCRC32CPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">721         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">722             Registration r = new Registration(plugins, &quot;java.util.zip.CRC32C&quot;, replacements);</span>
<span class="line-modified">723             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">724             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateDirectByteBuffer&quot;, int.class, long.class, int.class, int.class);</span>
725         }
726     }
727 
<span class="line-modified">728     private static void registerArraysSupportPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {</span>
<span class="line-modified">729         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">730             Registration r = new Registration(plugins, &quot;jdk.internal.util.ArraysSupport&quot;, replacements);</span>
<span class="line-modified">731             r.registerConditionalMethodSubstitution(config.useVectorizedMismatchIntrinsic, ArraysSupportSubstitutions.class, &quot;vectorizedMismatch&quot;, Object.class, long.class, Object.class, long.class,</span>
<span class="line-added">732                             int.class, int.class);</span>
733         }
734     }
735 }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotGraalConstantFieldProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotHostForeignCallsProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
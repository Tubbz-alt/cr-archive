<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationTask.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilationStatistics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilationWatchDog.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/CompilationTask.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Diagnose;
 28 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.ExitVM;
<span class="line-modified"> 29 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAction;</span>
 30 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
 31 import static org.graalvm.compiler.core.phases.HighTier.Options.Inline;
 32 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 33 
 34 import java.io.PrintStream;

 35 import java.util.List;
 36 
 37 import jdk.internal.vm.compiler.collections.EconomicMap;
 38 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 39 import org.graalvm.compiler.code.CompilationResult;
 40 import org.graalvm.compiler.core.CompilationPrinter;
 41 import org.graalvm.compiler.core.CompilationWrapper;
 42 import org.graalvm.compiler.core.common.CompilationIdentifier;
<span class="line-removed"> 43 import org.graalvm.compiler.debug.Assertions;</span>
 44 import org.graalvm.compiler.debug.CounterKey;
 45 import org.graalvm.compiler.debug.DebugCloseable;
 46 import org.graalvm.compiler.debug.DebugContext;

 47 import org.graalvm.compiler.debug.DebugDumpScope;
<span class="line-modified"> 48 import org.graalvm.compiler.debug.GraalError;</span>
 49 import org.graalvm.compiler.debug.TimerKey;
<span class="line-removed"> 50 import org.graalvm.compiler.options.EnumOptionKey;</span>
 51 import org.graalvm.compiler.options.OptionKey;
 52 import org.graalvm.compiler.options.OptionValues;
 53 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 54 
 55 import jdk.vm.ci.code.BailoutException;
 56 import jdk.vm.ci.code.CodeCacheProvider;
<span class="line-removed"> 57 import jdk.vm.ci.hotspot.EventProvider;</span>
 58 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 59 import jdk.vm.ci.hotspot.HotSpotCompilationRequestResult;
 60 import jdk.vm.ci.hotspot.HotSpotInstalledCode;
<span class="line-removed"> 61 import jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory;</span>
 62 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 63 import jdk.vm.ci.hotspot.HotSpotNmethod;
 64 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;

 65 import jdk.vm.ci.runtime.JVMCICompiler;
<span class="line-removed"> 66 import jdk.vm.ci.services.JVMCIServiceLocator;</span>
 67 
 68 public class CompilationTask {
 69 
<span class="line-removed"> 70     private static final EventProvider eventProvider;</span>
<span class="line-removed"> 71 </span>
<span class="line-removed"> 72     static {</span>
<span class="line-removed"> 73         List&lt;EventProvider&gt; providers = JVMCIServiceLocator.getProviders(EventProvider.class);</span>
<span class="line-removed"> 74         if (providers.size() &gt; 1) {</span>
<span class="line-removed"> 75             throw new GraalError(&quot;Multiple %s providers found: %s&quot;, EventProvider.class.getName(), providers);</span>
<span class="line-removed"> 76         } else if (providers.isEmpty()) {</span>
<span class="line-removed"> 77             eventProvider = EventProvider.createEmptyEventProvider();</span>
<span class="line-removed"> 78         } else {</span>
<span class="line-removed"> 79             eventProvider = providers.get(0);</span>
<span class="line-removed"> 80         }</span>
<span class="line-removed"> 81     }</span>
<span class="line-removed"> 82 </span>
 83     private final HotSpotJVMCIRuntime jvmciRuntime;
 84 
 85     private final HotSpotGraalCompiler compiler;
 86     private final HotSpotCompilationIdentifier compilationId;
 87 
 88     private HotSpotInstalledCode installedCode;
 89 
 90     /**
 91      * Specifies whether the compilation result is installed as the
 92      * {@linkplain HotSpotNmethod#isDefault() default} nmethod for the compiled method.
 93      */
 94     private final boolean installAsDefault;
 95 
 96     private final boolean useProfilingInfo;
<span class="line-modified"> 97     private final OptionValues options;</span>
 98 
 99     final class HotSpotCompilationWrapper extends CompilationWrapper&lt;HotSpotCompilationRequestResult&gt; {
<span class="line-removed">100         private final EventProvider.CompilationEvent compilationEvent;</span>
101         CompilationResult result;
102 
<span class="line-modified">103         HotSpotCompilationWrapper(EventProvider.CompilationEvent compilationEvent) {</span>
104             super(compiler.getGraalRuntime().getOutputDirectory(), compiler.getGraalRuntime().getCompilationProblemsPerAction());
<span class="line-removed">105             this.compilationEvent = compilationEvent;</span>
106         }
107 
108         @Override
<span class="line-modified">109         protected DebugContext createRetryDebugContext(OptionValues retryOptions, PrintStream logStream) {</span>
110             SnippetReflectionProvider snippetReflection = compiler.getGraalRuntime().getHostProviders().getSnippetReflection();
<span class="line-modified">111             return DebugContext.create(retryOptions, logStream, new GraalDebugHandlersFactory(snippetReflection));</span>







112         }
113 
114         @Override
115         public String toString() {
<span class="line-modified">116             return getMethod().format(&quot;%H.%n(%p)&quot;);</span>
117         }
118 
119         @Override
120         protected HotSpotCompilationRequestResult handleException(Throwable t) {
121             if (t instanceof BailoutException) {
122                 BailoutException bailout = (BailoutException) t;
123                 /*
124                  * Handling of permanent bailouts: Permanent bailouts that can happen for example
125                  * due to unsupported unstructured control flow in the bytecodes of a method must
126                  * not be retried. Hotspot compile broker will ensure that no recompilation at the
127                  * given tier will happen if retry is false.
128                  */
129                 return HotSpotCompilationRequestResult.failure(bailout.getMessage(), !bailout.isPermanent());
130             }
<span class="line-removed">131             // Log a failure event.</span>
<span class="line-removed">132             EventProvider.CompilerFailureEvent event = eventProvider.newCompilerFailureEvent();</span>
<span class="line-removed">133             if (event.shouldWrite()) {</span>
<span class="line-removed">134                 event.setCompileId(getId());</span>
<span class="line-removed">135                 event.setMessage(t.getMessage());</span>
<span class="line-removed">136                 event.commit();</span>
<span class="line-removed">137             }</span>
138 
139             /*
140              * Treat random exceptions from the compiler as indicating a problem compiling this
141              * method. Report the result of toString instead of getMessage to ensure that the
142              * exception type is included in the output in case there&#39;s no detail mesage.
143              */
144             return HotSpotCompilationRequestResult.failure(t.toString(), false);
145         }
146 
147         @Override
<span class="line-modified">148         protected ExceptionAction lookupAction(OptionValues values, EnumOptionKey&lt;ExceptionAction&gt; actionKey, Throwable cause) {</span>
<span class="line-modified">149             // Respect current action if it has been explicitly set.</span>
<span class="line-modified">150             if (!actionKey.hasBeenSet(values)) {</span>
<span class="line-modified">151                 if (actionKey == CompilationFailureAction) {</span>
<span class="line-modified">152                     // Automatically exit on non-bailout during bootstrap</span>
<span class="line-modified">153                     // or when assertions are enabled.</span>
<span class="line-modified">154                     if (Assertions.assertionsEnabled() || compiler.getGraalRuntime().isBootstrapping()) {</span>
<span class="line-modified">155                         return ExitVM;</span>
<span class="line-modified">156                     }</span>
<span class="line-modified">157                 } else if (actionKey == CompilationBailoutAction &amp;&amp; ((BailoutException) cause).isPermanent()) {</span>
<span class="line-modified">158                     // Get more info for permanent bailouts during bootstrap</span>
<span class="line-removed">159                     // or when assertions are enabled.</span>
<span class="line-removed">160                     assert CompilationBailoutAction.getDefaultValue() == ExceptionAction.Silent;</span>
<span class="line-removed">161                     if (Assertions.assertionsEnabled() || compiler.getGraalRuntime().isBootstrapping()) {</span>
<span class="line-removed">162                         return Diagnose;</span>
163                     }
164                 }











165             }
<span class="line-modified">166             return super.lookupAction(values, actionKey, cause);</span>
167         }
168 
169         @SuppressWarnings(&quot;try&quot;)
170         @Override
171         protected HotSpotCompilationRequestResult performCompilation(DebugContext debug) {
172             HotSpotResolvedJavaMethod method = getMethod();
173             int entryBCI = getEntryBCI();
174             final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
<span class="line-modified">175             CompilationStatistics stats = CompilationStatistics.create(options, method, isOSR);</span>
176 
<span class="line-modified">177             final CompilationPrinter printer = CompilationPrinter.begin(options, compilationId, method, entryBCI);</span>
178 
179             try (DebugContext.Scope s = debug.scope(&quot;Compiling&quot;, new DebugDumpScope(getIdString(), true))) {
<span class="line-modified">180                 // Begin the compilation event.</span>
<span class="line-removed">181                 compilationEvent.begin();</span>
<span class="line-removed">182                 result = compiler.compile(method, entryBCI, useProfilingInfo, compilationId, options, debug);</span>
183             } catch (Throwable e) {
184                 throw debug.handle(e);
<span class="line-removed">185             } finally {</span>
<span class="line-removed">186                 // End the compilation event.</span>
<span class="line-removed">187                 compilationEvent.end();</span>
188             }
189 
190             if (result != null) {
191                 try (DebugCloseable b = CodeInstallationTime.start(debug)) {
192                     installMethod(debug, result);
193                 }
194                 // Installation is included in compilation time and memory usage reported by printer
195                 printer.finish(result);
196             }
197             stats.finish(method, installedCode);
198             if (result != null) {
<span class="line-modified">199                 return HotSpotCompilationRequestResult.success(result.getBytecodeSize() - method.getCodeSize());</span>






200             }
201             return null;
202         }
203 
204     }
205 
<span class="line-modified">206     public CompilationTask(HotSpotJVMCIRuntime jvmciRuntime, HotSpotGraalCompiler compiler, HotSpotCompilationRequest request, boolean useProfilingInfo, boolean installAsDefault,</span>
<span class="line-modified">207                     OptionValues options) {</span>












208         this.jvmciRuntime = jvmciRuntime;
209         this.compiler = compiler;
210         this.compilationId = new HotSpotCompilationIdentifier(request);
211         this.useProfilingInfo = useProfilingInfo;

212         this.installAsDefault = installAsDefault;

213 

214         /*
215          * Disable inlining if HotSpot has it disabled unless it&#39;s been explicitly set in Graal.
216          */
217         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
218         GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
219         OptionValues newOptions = options;
220         if (!config.inline) {
221             EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; m = OptionValues.newOptionMap();
222             if (Inline.getValue(options) &amp;&amp; !Inline.hasBeenSet(options)) {
223                 m.put(Inline, false);
224             }
225             if (InlineDuringParsing.getValue(options) &amp;&amp; !InlineDuringParsing.hasBeenSet(options)) {
226                 m.put(InlineDuringParsing, false);
227             }
228             if (!m.isEmpty()) {
229                 newOptions = new OptionValues(options, m);
230             }
231         }
<span class="line-modified">232         this.options = newOptions;</span>
233     }
234 
235     public HotSpotResolvedJavaMethod getMethod() {
236         return getRequest().getMethod();
237     }
238 
239     CompilationIdentifier getCompilationIdentifier() {
240         return compilationId;
241     }
242 
243     /**
244      * Returns the HotSpot id of this compilation.
245      *
246      * @return HotSpot compile id
247      */
248     public int getId() {
249         return getRequest().getId();
250     }
251 
252     public int getEntryBCI() {
</pre>
<hr />
<pre>
255 
256     /**
257      * @return the compilation id plus a trailing &#39;%&#39; if the compilation is an OSR to match
258      *         PrintCompilation style output
259      */
260     public String getIdString() {
261         if (getEntryBCI() != JVMCICompiler.INVOCATION_ENTRY_BCI) {
262             return getId() + &quot;%&quot;;
263         } else {
264             return Integer.toString(getId());
265         }
266     }
267 
268     public HotSpotInstalledCode getInstalledCode() {
269         return installedCode;
270     }
271 
272     /**
273      * Time spent in compilation.
274      */
<span class="line-modified">275     private static final TimerKey CompilationTime = DebugContext.timer(&quot;CompilationTime&quot;).doc(&quot;Time spent in compilation and code installation.&quot;);</span>
276 
277     /**
278      * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes}.
279      */
280     private static final CounterKey CompiledBytecodes = DebugContext.counter(&quot;CompiledBytecodes&quot;);
281 
282     /**
283      * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes} for
284      * which {@linkplain CompilationResult#getTargetCode()} code was installed.
285      */
<span class="line-modified">286     private static final CounterKey CompiledAndInstalledBytecodes = DebugContext.counter(&quot;CompiledAndInstalledBytecodes&quot;);</span>
287 
288     /**
289      * Counts the number of installed {@linkplain CompilationResult#getTargetCodeSize()} bytes.
290      */
291     private static final CounterKey InstalledCodeSize = DebugContext.counter(&quot;InstalledCodeSize&quot;);
292 
293     /**
294      * Time spent in code installation.
295      */
296     public static final TimerKey CodeInstallationTime = DebugContext.timer(&quot;CodeInstallation&quot;);
297 
<span class="line-modified">298     public HotSpotCompilationRequestResult runCompilation() {</span>
<span class="line-modified">299         SnippetReflectionProvider snippetReflection = compiler.getGraalRuntime().getHostProviders().getSnippetReflection();</span>
<span class="line-modified">300         try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(snippetReflection))) {</span>

301             return runCompilation(debug);
302         }
303     }
304 
305     @SuppressWarnings(&quot;try&quot;)
306     public HotSpotCompilationRequestResult runCompilation(DebugContext debug) {
307         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
308         GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
309         int entryBCI = getEntryBCI();
310         boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
311         HotSpotResolvedJavaMethod method = getMethod();
312 
<span class="line-modified">313         // Log a compilation event.</span>
<span class="line-removed">314         EventProvider.CompilationEvent compilationEvent = eventProvider.newCompilationEvent();</span>
<span class="line-removed">315 </span>
<span class="line-removed">316         if (installAsDefault) {</span>
317             // If there is already compiled code for this method on our level we simply return.
318             // JVMCI compiles are always at the highest compile level, even in non-tiered mode so we
319             // only need to check for that value.
320             if (method.hasCodeAtLevel(entryBCI, config.compilationLevelFullOptimization)) {
321                 return HotSpotCompilationRequestResult.failure(&quot;Already compiled&quot;, false);
322             }
<span class="line-modified">323             if (HotSpotGraalCompilerFactory.checkGraalCompileOnlyFilter(method.getDeclaringClass().toJavaName(), method.getName(), method.getSignature().toString(),</span>
<span class="line-removed">324                             HotSpotJVMCICompilerFactory.CompilationLevel.FullOptimization) != HotSpotJVMCICompilerFactory.CompilationLevel.FullOptimization) {</span>
325                 return HotSpotCompilationRequestResult.failure(&quot;GraalCompileOnly excluded&quot;, false);
326             }
327         }
328 
<span class="line-modified">329         HotSpotCompilationWrapper compilation = new HotSpotCompilationWrapper(compilationEvent);</span>
330         try (DebugCloseable a = CompilationTime.start(debug)) {
331             return compilation.run(debug);
332         } finally {
333             try {
334                 int compiledBytecodes = 0;
335                 int codeSize = 0;
336 
337                 if (compilation.result != null) {
338                     compiledBytecodes = compilation.result.getBytecodeSize();
339                     CompiledBytecodes.add(debug, compiledBytecodes);
340                     if (installedCode != null) {
341                         codeSize = installedCode.getSize();
342                         CompiledAndInstalledBytecodes.add(debug, compiledBytecodes);
343                         InstalledCodeSize.add(debug, codeSize);
344                     }
345                 }
<span class="line-removed">346 </span>
<span class="line-removed">347                 // Log a compilation event.</span>
<span class="line-removed">348                 if (compilationEvent.shouldWrite()) {</span>
<span class="line-removed">349                     compilationEvent.setMethod(method.format(&quot;%H.%n(%p)&quot;));</span>
<span class="line-removed">350                     compilationEvent.setCompileId(getId());</span>
<span class="line-removed">351                     compilationEvent.setCompileLevel(config.compilationLevelFullOptimization);</span>
<span class="line-removed">352                     compilationEvent.setSucceeded(compilation.result != null &amp;&amp; installedCode != null);</span>
<span class="line-removed">353                     compilationEvent.setIsOsr(isOSR);</span>
<span class="line-removed">354                     compilationEvent.setCodeSize(codeSize);</span>
<span class="line-removed">355                     compilationEvent.setInlinedBytes(compiledBytecodes);</span>
<span class="line-removed">356                     compilationEvent.commit();</span>
<span class="line-removed">357                 }</span>
358             } catch (Throwable t) {
359                 return compilation.handleException(t);
360             }
361         }
362     }
363 
364     @SuppressWarnings(&quot;try&quot;)
365     private void installMethod(DebugContext debug, final CompilationResult compResult) {
366         final CodeCacheProvider codeCache = jvmciRuntime.getHostJVMCIBackend().getCodeCache();
367         HotSpotBackend backend = compiler.getGraalRuntime().getHostBackend();
368         installedCode = null;
369         Object[] context = {new DebugDumpScope(getIdString(), true), codeCache, getMethod(), compResult};
370         try (DebugContext.Scope s = debug.scope(&quot;CodeInstall&quot;, context)) {
371             HotSpotCompilationRequest request = getRequest();
372             installedCode = (HotSpotInstalledCode) backend.createInstalledCode(debug,
373                             request.getMethod(),
374                             request,
375                             compResult,
376                             null,
377                             installAsDefault,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Diagnose;
 28 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.ExitVM;
<span class="line-modified"> 29 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAsFailure;</span>
 30 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
 31 import static org.graalvm.compiler.core.phases.HighTier.Options.Inline;
 32 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 33 
 34 import java.io.PrintStream;
<span class="line-added"> 35 import java.util.Collections;</span>
 36 import java.util.List;
 37 
 38 import jdk.internal.vm.compiler.collections.EconomicMap;
 39 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 40 import org.graalvm.compiler.code.CompilationResult;
 41 import org.graalvm.compiler.core.CompilationPrinter;
 42 import org.graalvm.compiler.core.CompilationWrapper;
 43 import org.graalvm.compiler.core.common.CompilationIdentifier;

 44 import org.graalvm.compiler.debug.CounterKey;
 45 import org.graalvm.compiler.debug.DebugCloseable;
 46 import org.graalvm.compiler.debug.DebugContext;
<span class="line-added"> 47 import org.graalvm.compiler.debug.DebugContext.Description;</span>
 48 import org.graalvm.compiler.debug.DebugDumpScope;
<span class="line-modified"> 49 import org.graalvm.compiler.debug.DebugHandlersFactory;</span>
 50 import org.graalvm.compiler.debug.TimerKey;

 51 import org.graalvm.compiler.options.OptionKey;
 52 import org.graalvm.compiler.options.OptionValues;
 53 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 54 
 55 import jdk.vm.ci.code.BailoutException;
 56 import jdk.vm.ci.code.CodeCacheProvider;

 57 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 58 import jdk.vm.ci.hotspot.HotSpotCompilationRequestResult;
 59 import jdk.vm.ci.hotspot.HotSpotInstalledCode;

 60 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 61 import jdk.vm.ci.hotspot.HotSpotNmethod;
 62 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
<span class="line-added"> 63 import jdk.vm.ci.meta.ResolvedJavaMethod;</span>
 64 import jdk.vm.ci.runtime.JVMCICompiler;

 65 
 66 public class CompilationTask {
 67 













 68     private final HotSpotJVMCIRuntime jvmciRuntime;
 69 
 70     private final HotSpotGraalCompiler compiler;
 71     private final HotSpotCompilationIdentifier compilationId;
 72 
 73     private HotSpotInstalledCode installedCode;
 74 
 75     /**
 76      * Specifies whether the compilation result is installed as the
 77      * {@linkplain HotSpotNmethod#isDefault() default} nmethod for the compiled method.
 78      */
 79     private final boolean installAsDefault;
 80 
 81     private final boolean useProfilingInfo;
<span class="line-modified"> 82     private final boolean shouldRetainLocalVariables;</span>
 83 
 84     final class HotSpotCompilationWrapper extends CompilationWrapper&lt;HotSpotCompilationRequestResult&gt; {

 85         CompilationResult result;
 86 
<span class="line-modified"> 87         HotSpotCompilationWrapper() {</span>
 88             super(compiler.getGraalRuntime().getOutputDirectory(), compiler.getGraalRuntime().getCompilationProblemsPerAction());

 89         }
 90 
 91         @Override
<span class="line-modified"> 92         protected DebugContext createRetryDebugContext(DebugContext initialDebug, OptionValues retryOptions, PrintStream logStream) {</span>
 93             SnippetReflectionProvider snippetReflection = compiler.getGraalRuntime().getHostProviders().getSnippetReflection();
<span class="line-modified"> 94             Description description = initialDebug.getDescription();</span>
<span class="line-added"> 95             List&lt;DebugHandlersFactory&gt; factories = Collections.singletonList(new GraalDebugHandlersFactory(snippetReflection));</span>
<span class="line-added"> 96             return DebugContext.create(retryOptions, description, initialDebug.getGlobalMetrics(), logStream, factories);</span>
<span class="line-added"> 97         }</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99         @Override</span>
<span class="line-added">100         protected void exitHostVM(int status) {</span>
<span class="line-added">101             HotSpotGraalServices.exit(status);</span>
102         }
103 
104         @Override
105         public String toString() {
<span class="line-modified">106             return getMethod().format(&quot;%H.%n(%p) @ &quot; + getEntryBCI());</span>
107         }
108 
109         @Override
110         protected HotSpotCompilationRequestResult handleException(Throwable t) {
111             if (t instanceof BailoutException) {
112                 BailoutException bailout = (BailoutException) t;
113                 /*
114                  * Handling of permanent bailouts: Permanent bailouts that can happen for example
115                  * due to unsupported unstructured control flow in the bytecodes of a method must
116                  * not be retried. Hotspot compile broker will ensure that no recompilation at the
117                  * given tier will happen if retry is false.
118                  */
119                 return HotSpotCompilationRequestResult.failure(bailout.getMessage(), !bailout.isPermanent());
120             }







121 
122             /*
123              * Treat random exceptions from the compiler as indicating a problem compiling this
124              * method. Report the result of toString instead of getMessage to ensure that the
125              * exception type is included in the output in case there&#39;s no detail mesage.
126              */
127             return HotSpotCompilationRequestResult.failure(t.toString(), false);
128         }
129 
130         @Override
<span class="line-modified">131         protected ExceptionAction lookupAction(OptionValues values, Throwable cause) {</span>
<span class="line-modified">132             if (cause instanceof BailoutException) {</span>
<span class="line-modified">133                 BailoutException bailout = (BailoutException) cause;</span>
<span class="line-modified">134                 if (bailout.isPermanent()) {</span>
<span class="line-modified">135                     // Respect current action if it has been explicitly set.</span>
<span class="line-modified">136                     if (!CompilationBailoutAsFailure.hasBeenSet(values)) {</span>
<span class="line-modified">137                         // Get more info for permanent bailouts during bootstrap.</span>
<span class="line-modified">138                         if (compiler.getGraalRuntime().isBootstrapping()) {</span>
<span class="line-modified">139                             return Diagnose;</span>
<span class="line-modified">140                         }</span>
<span class="line-modified">141 </span>




142                     }
143                 }
<span class="line-added">144                 if (!CompilationBailoutAsFailure.getValue(values)) {</span>
<span class="line-added">145                     return super.lookupAction(values, cause);</span>
<span class="line-added">146                 }</span>
<span class="line-added">147             }</span>
<span class="line-added">148 </span>
<span class="line-added">149             // Respect current action if it has been explicitly set.</span>
<span class="line-added">150             if (!CompilationFailureAction.hasBeenSet(values)) {</span>
<span class="line-added">151                 // Automatically exit on failure during bootstrap.</span>
<span class="line-added">152                 if (compiler.getGraalRuntime().isBootstrapping()) {</span>
<span class="line-added">153                     return ExitVM;</span>
<span class="line-added">154                 }</span>
155             }
<span class="line-modified">156             return super.lookupAction(values, cause);</span>
157         }
158 
159         @SuppressWarnings(&quot;try&quot;)
160         @Override
161         protected HotSpotCompilationRequestResult performCompilation(DebugContext debug) {
162             HotSpotResolvedJavaMethod method = getMethod();
163             int entryBCI = getEntryBCI();
164             final boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
<span class="line-modified">165             CompilationStatistics stats = CompilationStatistics.create(debug.getOptions(), method, isOSR);</span>
166 
<span class="line-modified">167             final CompilationPrinter printer = CompilationPrinter.begin(debug.getOptions(), compilationId, method, entryBCI);</span>
168 
169             try (DebugContext.Scope s = debug.scope(&quot;Compiling&quot;, new DebugDumpScope(getIdString(), true))) {
<span class="line-modified">170                 result = compiler.compile(method, entryBCI, useProfilingInfo, shouldRetainLocalVariables, compilationId, debug);</span>


171             } catch (Throwable e) {
172                 throw debug.handle(e);



173             }
174 
175             if (result != null) {
176                 try (DebugCloseable b = CodeInstallationTime.start(debug)) {
177                     installMethod(debug, result);
178                 }
179                 // Installation is included in compilation time and memory usage reported by printer
180                 printer.finish(result);
181             }
182             stats.finish(method, installedCode);
183             if (result != null) {
<span class="line-modified">184                 // For compilation of substitutions the method in the compilation request might be</span>
<span class="line-added">185                 // different than the actual method parsed. The root of the compilation will always</span>
<span class="line-added">186                 // be the first method in the methods list, so use that instead.</span>
<span class="line-added">187                 ResolvedJavaMethod rootMethod = result.getMethods()[0];</span>
<span class="line-added">188                 int inlinedBytecodes = result.getBytecodeSize() - rootMethod.getCodeSize();</span>
<span class="line-added">189                 assert inlinedBytecodes &gt;= 0 : rootMethod + &quot; &quot; + method;</span>
<span class="line-added">190                 return HotSpotCompilationRequestResult.success(inlinedBytecodes);</span>
191             }
192             return null;
193         }
194 
195     }
196 
<span class="line-modified">197     public CompilationTask(HotSpotJVMCIRuntime jvmciRuntime,</span>
<span class="line-modified">198                     HotSpotGraalCompiler compiler,</span>
<span class="line-added">199                     HotSpotCompilationRequest request,</span>
<span class="line-added">200                     boolean useProfilingInfo,</span>
<span class="line-added">201                     boolean installAsDefault) {</span>
<span class="line-added">202         this(jvmciRuntime, compiler, request, useProfilingInfo, false, installAsDefault);</span>
<span class="line-added">203     }</span>
<span class="line-added">204 </span>
<span class="line-added">205     public CompilationTask(HotSpotJVMCIRuntime jvmciRuntime,</span>
<span class="line-added">206                     HotSpotGraalCompiler compiler,</span>
<span class="line-added">207                     HotSpotCompilationRequest request,</span>
<span class="line-added">208                     boolean useProfilingInfo,</span>
<span class="line-added">209                     boolean shouldRetainLocalVariables,</span>
<span class="line-added">210                     boolean installAsDefault) {</span>
211         this.jvmciRuntime = jvmciRuntime;
212         this.compiler = compiler;
213         this.compilationId = new HotSpotCompilationIdentifier(request);
214         this.useProfilingInfo = useProfilingInfo;
<span class="line-added">215         this.shouldRetainLocalVariables = shouldRetainLocalVariables;</span>
216         this.installAsDefault = installAsDefault;
<span class="line-added">217     }</span>
218 
<span class="line-added">219     public OptionValues filterOptions(OptionValues options) {</span>
220         /*
221          * Disable inlining if HotSpot has it disabled unless it&#39;s been explicitly set in Graal.
222          */
223         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
224         GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
225         OptionValues newOptions = options;
226         if (!config.inline) {
227             EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; m = OptionValues.newOptionMap();
228             if (Inline.getValue(options) &amp;&amp; !Inline.hasBeenSet(options)) {
229                 m.put(Inline, false);
230             }
231             if (InlineDuringParsing.getValue(options) &amp;&amp; !InlineDuringParsing.hasBeenSet(options)) {
232                 m.put(InlineDuringParsing, false);
233             }
234             if (!m.isEmpty()) {
235                 newOptions = new OptionValues(options, m);
236             }
237         }
<span class="line-modified">238         return newOptions;</span>
239     }
240 
241     public HotSpotResolvedJavaMethod getMethod() {
242         return getRequest().getMethod();
243     }
244 
245     CompilationIdentifier getCompilationIdentifier() {
246         return compilationId;
247     }
248 
249     /**
250      * Returns the HotSpot id of this compilation.
251      *
252      * @return HotSpot compile id
253      */
254     public int getId() {
255         return getRequest().getId();
256     }
257 
258     public int getEntryBCI() {
</pre>
<hr />
<pre>
261 
262     /**
263      * @return the compilation id plus a trailing &#39;%&#39; if the compilation is an OSR to match
264      *         PrintCompilation style output
265      */
266     public String getIdString() {
267         if (getEntryBCI() != JVMCICompiler.INVOCATION_ENTRY_BCI) {
268             return getId() + &quot;%&quot;;
269         } else {
270             return Integer.toString(getId());
271         }
272     }
273 
274     public HotSpotInstalledCode getInstalledCode() {
275         return installedCode;
276     }
277 
278     /**
279      * Time spent in compilation.
280      */
<span class="line-modified">281     public static final TimerKey CompilationTime = DebugContext.timer(&quot;CompilationTime&quot;).doc(&quot;Time spent in compilation and code installation.&quot;);</span>
282 
283     /**
284      * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes}.
285      */
286     private static final CounterKey CompiledBytecodes = DebugContext.counter(&quot;CompiledBytecodes&quot;);
287 
288     /**
289      * Counts the number of compiled {@linkplain CompilationResult#getBytecodeSize() bytecodes} for
290      * which {@linkplain CompilationResult#getTargetCode()} code was installed.
291      */
<span class="line-modified">292     public static final CounterKey CompiledAndInstalledBytecodes = DebugContext.counter(&quot;CompiledAndInstalledBytecodes&quot;);</span>
293 
294     /**
295      * Counts the number of installed {@linkplain CompilationResult#getTargetCodeSize()} bytes.
296      */
297     private static final CounterKey InstalledCodeSize = DebugContext.counter(&quot;InstalledCodeSize&quot;);
298 
299     /**
300      * Time spent in code installation.
301      */
302     public static final TimerKey CodeInstallationTime = DebugContext.timer(&quot;CodeInstallation&quot;);
303 
<span class="line-modified">304     public HotSpotCompilationRequestResult runCompilation(OptionValues initialOptions) {</span>
<span class="line-modified">305         OptionValues options = filterOptions(initialOptions);</span>
<span class="line-modified">306         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();</span>
<span class="line-added">307         try (DebugContext debug = graalRuntime.openDebugContext(options, compilationId, getMethod(), compiler.getDebugHandlersFactories(), DebugContext.DEFAULT_LOG_STREAM)) {</span>
308             return runCompilation(debug);
309         }
310     }
311 
312     @SuppressWarnings(&quot;try&quot;)
313     public HotSpotCompilationRequestResult runCompilation(DebugContext debug) {
314         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
315         GraalHotSpotVMConfig config = graalRuntime.getVMConfig();
316         int entryBCI = getEntryBCI();
317         boolean isOSR = entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
318         HotSpotResolvedJavaMethod method = getMethod();
319 
<span class="line-modified">320         if (installAsDefault || isOSR) {</span>



321             // If there is already compiled code for this method on our level we simply return.
322             // JVMCI compiles are always at the highest compile level, even in non-tiered mode so we
323             // only need to check for that value.
324             if (method.hasCodeAtLevel(entryBCI, config.compilationLevelFullOptimization)) {
325                 return HotSpotCompilationRequestResult.failure(&quot;Already compiled&quot;, false);
326             }
<span class="line-modified">327             if (HotSpotGraalCompilerFactory.shouldExclude(method)) {</span>

328                 return HotSpotCompilationRequestResult.failure(&quot;GraalCompileOnly excluded&quot;, false);
329             }
330         }
331 
<span class="line-modified">332         HotSpotCompilationWrapper compilation = new HotSpotCompilationWrapper();</span>
333         try (DebugCloseable a = CompilationTime.start(debug)) {
334             return compilation.run(debug);
335         } finally {
336             try {
337                 int compiledBytecodes = 0;
338                 int codeSize = 0;
339 
340                 if (compilation.result != null) {
341                     compiledBytecodes = compilation.result.getBytecodeSize();
342                     CompiledBytecodes.add(debug, compiledBytecodes);
343                     if (installedCode != null) {
344                         codeSize = installedCode.getSize();
345                         CompiledAndInstalledBytecodes.add(debug, compiledBytecodes);
346                         InstalledCodeSize.add(debug, codeSize);
347                     }
348                 }












349             } catch (Throwable t) {
350                 return compilation.handleException(t);
351             }
352         }
353     }
354 
355     @SuppressWarnings(&quot;try&quot;)
356     private void installMethod(DebugContext debug, final CompilationResult compResult) {
357         final CodeCacheProvider codeCache = jvmciRuntime.getHostJVMCIBackend().getCodeCache();
358         HotSpotBackend backend = compiler.getGraalRuntime().getHostBackend();
359         installedCode = null;
360         Object[] context = {new DebugDumpScope(getIdString(), true), codeCache, getMethod(), compResult};
361         try (DebugContext.Scope s = debug.scope(&quot;CodeInstall&quot;, context)) {
362             HotSpotCompilationRequest request = getRequest();
363             installedCode = (HotSpotInstalledCode) backend.createInstalledCode(debug,
364                             request.getMethod(),
365                             request,
366                             compResult,
367                             null,
368                             installAsDefault,
</pre>
</td>
</tr>
</table>
<center><a href="CompilationStatistics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilationWatchDog.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
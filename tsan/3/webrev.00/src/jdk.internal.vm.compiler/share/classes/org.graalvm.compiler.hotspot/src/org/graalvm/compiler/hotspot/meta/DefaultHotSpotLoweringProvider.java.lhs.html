<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/DefaultHotSpotLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 28 import static org.graalvm.compiler.core.common.GraalOptions.AlwaysInlineVTableStubs;
 29 import static org.graalvm.compiler.core.common.GraalOptions.InlineVTableStubs;
 30 import static org.graalvm.compiler.core.common.GraalOptions.OmitHotExceptionStacktrace;
 31 import static org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl.OSR_MIGRATION_END;
 32 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_KLASS_LOCATION;
 33 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_MIRROR_HANDLE_LOCATION;
 34 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_MIRROR_LOCATION;
 35 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.COMPRESSED_HUB_LOCATION;
 36 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.DISPLACED_MARK_WORD_LOCATION;
 37 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_LOCATION;
 38 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_WRITE_LOCATION;
 39 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.KLASS_LAYOUT_HELPER_LOCATION;
 40 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION;
 41 import static jdk.internal.vm.compiler.word.LocationIdentity.any;
 42 
 43 import java.lang.ref.Reference;
 44 import java.util.EnumMap;
 45 
 46 import org.graalvm.compiler.api.directives.GraalDirectives;
 47 import org.graalvm.compiler.core.common.CompressEncoding;
 48 import org.graalvm.compiler.core.common.GraalOptions;
 49 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 50 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 51 import org.graalvm.compiler.core.common.type.ObjectStamp;
 52 import org.graalvm.compiler.core.common.type.Stamp;
 53 import org.graalvm.compiler.core.common.type.StampFactory;
 54 import org.graalvm.compiler.core.common.type.StampPair;
 55 import org.graalvm.compiler.debug.DebugCloseable;
 56 import org.graalvm.compiler.debug.DebugHandlersFactory;
 57 import org.graalvm.compiler.debug.GraalError;
 58 import org.graalvm.compiler.graph.Node;
 59 import org.graalvm.compiler.graph.NodeInputList;
 60 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 61 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
<a name="2" id="anc2"></a><span class="line-removed"> 62 import org.graalvm.compiler.hotspot.gc.g1.G1ArrayRangePostWriteBarrier;</span>
<span class="line-removed"> 63 import org.graalvm.compiler.hotspot.gc.g1.G1ArrayRangePreWriteBarrier;</span>
<span class="line-removed"> 64 import org.graalvm.compiler.hotspot.gc.g1.G1PostWriteBarrier;</span>
<span class="line-removed"> 65 import org.graalvm.compiler.hotspot.gc.g1.G1PreWriteBarrier;</span>
<span class="line-removed"> 66 import org.graalvm.compiler.hotspot.gc.g1.G1ReferentFieldReadBarrier;</span>
<span class="line-removed"> 67 import org.graalvm.compiler.hotspot.gc.shared.SerialArrayRangeWriteBarrier;</span>
<span class="line-removed"> 68 import org.graalvm.compiler.hotspot.gc.shared.SerialWriteBarrier;</span>
 69 import org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode;
 70 import org.graalvm.compiler.hotspot.nodes.HotSpotCompressionNode;
 71 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 72 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
<a name="3" id="anc3"></a>
 73 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 74 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 75 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 76 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
 77 import org.graalvm.compiler.hotspot.nodes.profiling.ProfileNode;
 78 import org.graalvm.compiler.hotspot.nodes.type.HotSpotNarrowOopStamp;
 79 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 80 import org.graalvm.compiler.hotspot.nodes.type.MethodPointerStamp;
 81 import org.graalvm.compiler.hotspot.replacements.AssertionSnippets;
 82 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
<a name="4" id="anc4"></a>
 83 import org.graalvm.compiler.hotspot.replacements.HashCodeSnippets;
<a name="5" id="anc5"></a>

 84 import org.graalvm.compiler.hotspot.replacements.HubGetClassNode;
 85 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 86 import org.graalvm.compiler.hotspot.replacements.InstanceOfSnippets;
 87 import org.graalvm.compiler.hotspot.replacements.KlassLayoutHelperNode;
 88 import org.graalvm.compiler.hotspot.replacements.LoadExceptionObjectSnippets;
 89 import org.graalvm.compiler.hotspot.replacements.MonitorSnippets;
 90 import org.graalvm.compiler.hotspot.replacements.NewObjectSnippets;
 91 import org.graalvm.compiler.hotspot.replacements.ObjectCloneSnippets;
<a name="6" id="anc6"></a>
 92 import org.graalvm.compiler.hotspot.replacements.StringToBytesSnippets;
<a name="7" id="anc7"></a>
 93 import org.graalvm.compiler.hotspot.replacements.UnsafeLoadSnippets;
<a name="8" id="anc8"></a><span class="line-modified"> 94 import org.graalvm.compiler.hotspot.replacements.WriteBarrierSnippets;</span>
 95 import org.graalvm.compiler.hotspot.replacements.aot.ResolveConstantSnippets;
 96 import org.graalvm.compiler.hotspot.replacements.arraycopy.HotSpotArraycopySnippets;
 97 import org.graalvm.compiler.hotspot.replacements.profiling.ProfileSnippets;
 98 import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets;
 99 import org.graalvm.compiler.hotspot.word.KlassPointer;
100 import org.graalvm.compiler.nodes.AbstractBeginNode;
101 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
102 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
103 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
104 import org.graalvm.compiler.nodes.ConstantNode;
105 import org.graalvm.compiler.nodes.FixedNode;
106 import org.graalvm.compiler.nodes.GetObjectAddressNode;
107 import org.graalvm.compiler.nodes.Invoke;
108 import org.graalvm.compiler.nodes.LogicNode;
109 import org.graalvm.compiler.nodes.LoweredCallTargetNode;
110 import org.graalvm.compiler.nodes.NodeView;
111 import org.graalvm.compiler.nodes.ParameterNode;
112 import org.graalvm.compiler.nodes.SafepointNode;
113 import org.graalvm.compiler.nodes.StartNode;
114 import org.graalvm.compiler.nodes.StructuredGraph;
<a name="9" id="anc9"></a>
115 import org.graalvm.compiler.nodes.UnwindNode;
116 import org.graalvm.compiler.nodes.ValueNode;
117 import org.graalvm.compiler.nodes.calc.AddNode;
118 import org.graalvm.compiler.nodes.calc.FloatingNode;
119 import org.graalvm.compiler.nodes.calc.IntegerDivRemNode;
120 import org.graalvm.compiler.nodes.calc.IsNullNode;
121 import org.graalvm.compiler.nodes.calc.RemNode;
122 import org.graalvm.compiler.nodes.debug.StringToBytesNode;
123 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
124 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
125 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
126 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
127 import org.graalvm.compiler.nodes.extended.GetClassNode;
<a name="10" id="anc10"></a><span class="line-removed">128 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;</span>
129 import org.graalvm.compiler.nodes.extended.LoadHubNode;
130 import org.graalvm.compiler.nodes.extended.LoadMethodNode;
131 import org.graalvm.compiler.nodes.extended.OSRLocalNode;
132 import org.graalvm.compiler.nodes.extended.OSRLockNode;
133 import org.graalvm.compiler.nodes.extended.OSRMonitorEnterNode;
134 import org.graalvm.compiler.nodes.extended.OSRStartNode;
<a name="11" id="anc11"></a><span class="line-removed">135 import org.graalvm.compiler.nodes.extended.RawLoadNode;</span>
136 import org.graalvm.compiler.nodes.extended.StoreHubNode;
<a name="12" id="anc12"></a>






137 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
138 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
139 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
140 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
141 import org.graalvm.compiler.nodes.java.InstanceOfNode;
142 import org.graalvm.compiler.nodes.java.LoadExceptionObjectNode;
143 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
144 import org.graalvm.compiler.nodes.java.MonitorExitNode;
145 import org.graalvm.compiler.nodes.java.MonitorIdNode;
146 import org.graalvm.compiler.nodes.java.NewArrayNode;
147 import org.graalvm.compiler.nodes.java.NewInstanceNode;
148 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
149 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
150 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
151 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
152 import org.graalvm.compiler.nodes.memory.ReadNode;
153 import org.graalvm.compiler.nodes.memory.WriteNode;
154 import org.graalvm.compiler.nodes.memory.address.AddressNode;
155 import org.graalvm.compiler.nodes.spi.LoweringProvider;
156 import org.graalvm.compiler.nodes.spi.LoweringTool;
157 import org.graalvm.compiler.nodes.spi.StampProvider;
158 import org.graalvm.compiler.nodes.type.StampTool;
159 import org.graalvm.compiler.nodes.util.GraphUtil;
160 import org.graalvm.compiler.options.OptionValues;
161 import org.graalvm.compiler.replacements.DefaultJavaLoweringProvider;
162 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
163 import org.graalvm.compiler.replacements.arraycopy.ArrayCopySnippets;
<a name="13" id="anc13"></a><span class="line-modified">164 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyWithSlowPathNode;</span>
165 import org.graalvm.compiler.replacements.nodes.AssertionNode;
166 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
167 import jdk.internal.vm.compiler.word.LocationIdentity;
168 
169 import jdk.vm.ci.code.TargetDescription;
170 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
171 import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;
172 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
173 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
174 import jdk.vm.ci.meta.JavaConstant;
175 import jdk.vm.ci.meta.JavaKind;
176 import jdk.vm.ci.meta.JavaType;
177 import jdk.vm.ci.meta.MetaAccessProvider;
178 import jdk.vm.ci.meta.ResolvedJavaField;
179 import jdk.vm.ci.meta.ResolvedJavaType;
180 
181 /**
182  * HotSpot implementation of {@link LoweringProvider}.
183  */
<a name="14" id="anc14"></a><span class="line-modified">184 public class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {</span>
185 
186     protected final HotSpotGraalRuntimeProvider runtime;
187     protected final HotSpotRegistersProvider registers;
188     protected final HotSpotConstantReflectionProvider constantReflection;
189 
190     protected InstanceOfSnippets.Templates instanceofSnippets;
191     protected NewObjectSnippets.Templates newObjectSnippets;
192     protected MonitorSnippets.Templates monitorSnippets;
<a name="15" id="anc15"></a><span class="line-modified">193     protected WriteBarrierSnippets.Templates writeBarrierSnippets;</span>

194     protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;
195     protected UnsafeLoadSnippets.Templates unsafeLoadSnippets;
196     protected AssertionSnippets.Templates assertionSnippets;
197     protected ArrayCopySnippets.Templates arraycopySnippets;
198     protected StringToBytesSnippets.Templates stringToBytesSnippets;
199     protected HashCodeSnippets.Templates hashCodeSnippets;
200     protected ResolveConstantSnippets.Templates resolveConstantSnippets;
201     protected ProfileSnippets.Templates profileSnippets;
<a name="16" id="anc16"></a><span class="line-modified">202 </span>

203     protected ObjectCloneSnippets.Templates objectCloneSnippets;
204     protected ForeignCallSnippets.Templates foreignCallSnippets;
205 
206     public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers,
207                     HotSpotConstantReflectionProvider constantReflection, TargetDescription target) {
208         super(metaAccess, foreignCalls, target, runtime.getVMConfig().useCompressedOops);
209         this.runtime = runtime;
210         this.registers = registers;
211         this.constantReflection = constantReflection;
<a name="17" id="anc17"></a>
212     }
213 
214     @Override
215     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {
216         super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());
217 
218         assert target == providers.getCodeCache().getTarget();
219         instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);
220         newObjectSnippets = new NewObjectSnippets.Templates(options, factories, runtime, providers, target, config);
221         monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);
<a name="18" id="anc18"></a><span class="line-modified">222         writeBarrierSnippets = new WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);</span>

223         exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);
224         unsafeLoadSnippets = new UnsafeLoadSnippets.Templates(options, factories, providers, target);
225         assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);
226         arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);
227         stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);
228         hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);
229         resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);
<a name="19" id="anc19"></a><span class="line-removed">230         if (!JavaVersionUtil.Java8OrEarlier) {</span>
<span class="line-removed">231             profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);</span>
<span class="line-removed">232         }</span>
233         objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);
234         foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);
<a name="20" id="anc20"></a>











235     }
236 
237     public MonitorSnippets.Templates getMonitorSnippets() {
238         return monitorSnippets;
239     }
240 
241     @Override
242     @SuppressWarnings(&quot;try&quot;)
243     public void lower(Node n, LoweringTool tool) {
244         StructuredGraph graph = (StructuredGraph) n.graph();
245         try (DebugCloseable context = n.withNodeSourcePosition()) {
246             if (n instanceof Invoke) {
247                 lowerInvoke((Invoke) n, tool, graph);
248             } else if (n instanceof LoadMethodNode) {
249                 lowerLoadMethodNode((LoadMethodNode) n);
250             } else if (n instanceof GetClassNode) {
251                 lowerGetClassNode((GetClassNode) n, tool, graph);
252             } else if (n instanceof StoreHubNode) {
253                 lowerStoreHubNode((StoreHubNode) n, graph);
254             } else if (n instanceof OSRStartNode) {
255                 lowerOSRStartNode((OSRStartNode) n);
256             } else if (n instanceof BytecodeExceptionNode) {
257                 lowerBytecodeExceptionNode((BytecodeExceptionNode) n);
258             } else if (n instanceof InstanceOfNode) {
259                 InstanceOfNode instanceOfNode = (InstanceOfNode) n;
260                 if (graph.getGuardsStage().areDeoptsFixed()) {
261                     instanceofSnippets.lower(instanceOfNode, tool);
262                 } else {
263                     if (instanceOfNode.allowsNull()) {
264                         ValueNode object = instanceOfNode.getValue();
265                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(InstanceOfNode.create(instanceOfNode.type(), object, instanceOfNode.profile(), instanceOfNode.getAnchor()));
266                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
267                         instanceOfNode.replaceAndDelete(newNode);
268                     }
269                 }
270             } else if (n instanceof InstanceOfDynamicNode) {
271                 InstanceOfDynamicNode instanceOfDynamicNode = (InstanceOfDynamicNode) n;
272                 if (graph.getGuardsStage().areDeoptsFixed()) {
273                     instanceofSnippets.lower(instanceOfDynamicNode, tool);
274                 } else {
275                     ValueNode mirror = instanceOfDynamicNode.getMirrorOrHub();
276                     if (mirror.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Object) {
277                         ClassGetHubNode classGetHub = graph.unique(new ClassGetHubNode(mirror));
278                         instanceOfDynamicNode.setMirror(classGetHub);
279                     }
280 
281                     if (instanceOfDynamicNode.allowsNull()) {
282                         ValueNode object = instanceOfDynamicNode.getObject();
283                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(
284                                         InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), instanceOfDynamicNode.getMirrorOrHub(), object, false));
285                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
286                         instanceOfDynamicNode.replaceAndDelete(newNode);
287                     }
288                 }
289             } else if (n instanceof ClassIsAssignableFromNode) {
290                 if (graph.getGuardsStage().areDeoptsFixed()) {
291                     instanceofSnippets.lower((ClassIsAssignableFromNode) n, tool);
292                 }
293             } else if (n instanceof NewInstanceNode) {
294                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
295                     newObjectSnippets.lower((NewInstanceNode) n, registers, tool);
296                 }
297             } else if (n instanceof DynamicNewInstanceNode) {
298                 DynamicNewInstanceNode newInstanceNode = (DynamicNewInstanceNode) n;
299                 if (newInstanceNode.getClassClass() == null) {
300                     JavaConstant classClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(Class.class));
301                     ConstantNode classClass = ConstantNode.forConstant(classClassMirror, tool.getMetaAccess(), graph);
302                     newInstanceNode.setClassClass(classClass);
303                 }
304                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
305                     newObjectSnippets.lower(newInstanceNode, registers, tool);
306                 }
307             } else if (n instanceof NewArrayNode) {
308                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
309                     newObjectSnippets.lower((NewArrayNode) n, registers, tool);
310                 }
311             } else if (n instanceof DynamicNewArrayNode) {
312                 DynamicNewArrayNode dynamicNewArrayNode = (DynamicNewArrayNode) n;
313                 if (dynamicNewArrayNode.getVoidClass() == null) {
314                     JavaConstant voidClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(void.class));
315                     ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);
316                     dynamicNewArrayNode.setVoidClass(voidClass);
317                 }
318                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
319                     newObjectSnippets.lower(dynamicNewArrayNode, registers, tool);
320                 }
321             } else if (n instanceof VerifyHeapNode) {
322                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
323                     newObjectSnippets.lower((VerifyHeapNode) n, registers, tool);
324                 }
325             } else if (n instanceof RawMonitorEnterNode) {
326                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
327                     monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);
328                 }
329             } else if (n instanceof MonitorExitNode) {
330                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
331                     monitorSnippets.lower((MonitorExitNode) n, registers, tool);
332                 }
333             } else if (n instanceof ArrayCopyNode) {
334                 arraycopySnippets.lower((ArrayCopyNode) n, tool);
<a name="21" id="anc21"></a><span class="line-modified">335             } else if (n instanceof ArrayCopyWithSlowPathNode) {</span>
<span class="line-modified">336                 arraycopySnippets.lower((ArrayCopyWithSlowPathNode) n, tool);</span>
337             } else if (n instanceof G1PreWriteBarrier) {
<a name="22" id="anc22"></a><span class="line-modified">338                 writeBarrierSnippets.lower((G1PreWriteBarrier) n, registers, tool);</span>
339             } else if (n instanceof G1PostWriteBarrier) {
<a name="23" id="anc23"></a><span class="line-modified">340                 writeBarrierSnippets.lower((G1PostWriteBarrier) n, registers, tool);</span>
341             } else if (n instanceof G1ReferentFieldReadBarrier) {
<a name="24" id="anc24"></a><span class="line-modified">342                 writeBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, registers, tool);</span>
343             } else if (n instanceof SerialWriteBarrier) {
<a name="25" id="anc25"></a><span class="line-modified">344                 writeBarrierSnippets.lower((SerialWriteBarrier) n, tool);</span>
345             } else if (n instanceof SerialArrayRangeWriteBarrier) {
<a name="26" id="anc26"></a><span class="line-modified">346                 writeBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);</span>
347             } else if (n instanceof G1ArrayRangePreWriteBarrier) {
<a name="27" id="anc27"></a><span class="line-modified">348                 writeBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, registers, tool);</span>
349             } else if (n instanceof G1ArrayRangePostWriteBarrier) {
<a name="28" id="anc28"></a><span class="line-modified">350                 writeBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, registers, tool);</span>
351             } else if (n instanceof NewMultiArrayNode) {
352                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
353                     newObjectSnippets.lower((NewMultiArrayNode) n, tool);
354                 }
355             } else if (n instanceof LoadExceptionObjectNode) {
356                 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);
357             } else if (n instanceof AssertionNode) {
358                 assertionSnippets.lower((AssertionNode) n, tool);
359             } else if (n instanceof StringToBytesNode) {
360                 if (graph.getGuardsStage().areDeoptsFixed()) {
361                     stringToBytesSnippets.lower((StringToBytesNode) n, tool);
362                 }
363             } else if (n instanceof IntegerDivRemNode) {
364                 // Nothing to do for division nodes. The HotSpot signal handler catches divisions by
365                 // zero and the MIN_VALUE / -1 cases.
366             } else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {
367                 /* No lowering, we generate LIR directly for these nodes. */
368             } else if (n instanceof ClassGetHubNode) {
369                 lowerClassGetHubNode((ClassGetHubNode) n, tool);
370             } else if (n instanceof HubGetClassNode) {
371                 lowerHubGetClassNode((HubGetClassNode) n, tool);
372             } else if (n instanceof KlassLayoutHelperNode) {
373                 lowerKlassLayoutHelperNode((KlassLayoutHelperNode) n, tool);
374             } else if (n instanceof ComputeObjectAddressNode) {
375                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
376                     lowerComputeObjectAddressNode((ComputeObjectAddressNode) n);
377                 }
378             } else if (n instanceof IdentityHashCodeNode) {
379                 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);
380             } else if (n instanceof ResolveDynamicConstantNode) {
381                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
382                     resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);
383                 }
384             } else if (n instanceof ResolveConstantNode) {
385                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
386                     resolveConstantSnippets.lower((ResolveConstantNode) n, tool);
387                 }
388             } else if (n instanceof ResolveMethodAndLoadCountersNode) {
389                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
390                     resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);
391                 }
392             } else if (n instanceof InitializeKlassNode) {
393                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
394                     resolveConstantSnippets.lower((InitializeKlassNode) n, tool);
395                 }
396             } else if (n instanceof ProfileNode) {
397                 profileSnippets.lower((ProfileNode) n, tool);
<a name="29" id="anc29"></a>









398             } else {
399                 super.lower(n, tool);
400             }
401         }
<a name="30" id="anc30"></a>
402     }
403 
404     private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {
405         /*
406          * Lower the node into a ComputeObjectAddress node and an Add but ensure that it&#39;s below any
407          * potential safepoints and above it&#39;s uses.
408          */
409         for (Node use : n.usages().snapshot()) {
410             if (use instanceof FixedNode) {
411                 FixedNode fixed = (FixedNode) use;
412                 StructuredGraph graph = n.graph();
413                 GetObjectAddressNode address = graph.add(new GetObjectAddressNode(n.getObject()));
414                 graph.addBeforeFixed(fixed, address);
415                 AddNode add = graph.addOrUnique(new AddNode(address, n.getOffset()));
416                 use.replaceFirstInput(n, add);
417             } else {
418                 throw GraalError.shouldNotReachHere(&quot;Unexpected floating use of ComputeObjectAddressNode &quot; + n);
419             }
420         }
421         GraphUtil.unlinkFixedNode(n);
422         n.safeDelete();
423     }
424 
425     private void lowerKlassLayoutHelperNode(KlassLayoutHelperNode n, LoweringTool tool) {
426         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
427             return;
428         }
429         StructuredGraph graph = n.graph();
430         assert !n.getHub().isConstant();
431         AddressNode address = createOffsetAddress(graph, n.getHub(), runtime.getVMConfig().klassLayoutHelperOffset);
432         n.replaceAtUsagesAndDelete(graph.unique(new FloatingReadNode(address, KLASS_LAYOUT_HELPER_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE)));
433     }
434 
435     private void lowerHubGetClassNode(HubGetClassNode n, LoweringTool tool) {
436         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
437             return;
438         }
439 
440         ValueNode hub = n.getHub();
441         GraalHotSpotVMConfig vmConfig = runtime.getVMConfig();
442         StructuredGraph graph = n.graph();
443         assert !hub.isConstant() || GraalOptions.ImmutableCode.getValue(graph.getOptions());
444         AddressNode mirrorAddress = createOffsetAddress(graph, hub, vmConfig.classMirrorOffset);
445         FloatingReadNode read = graph.unique(
446                         new FloatingReadNode(mirrorAddress, CLASS_MIRROR_LOCATION, null, vmConfig.classMirrorIsHandle ? StampFactory.forKind(target.wordJavaKind) : n.stamp(NodeView.DEFAULT),
447                                         null, BarrierType.NONE));
448         if (vmConfig.classMirrorIsHandle) {
449             AddressNode address = createOffsetAddress(graph, read, 0);
450             read = graph.unique(new FloatingReadNode(address, CLASS_MIRROR_HANDLE_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
451         }
452         n.replaceAtUsagesAndDelete(read);
453     }
454 
455     private void lowerClassGetHubNode(ClassGetHubNode n, LoweringTool tool) {
456         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
457             return;
458         }
459 
460         StructuredGraph graph = n.graph();
461         assert !n.getValue().isConstant();
462         AddressNode address = createOffsetAddress(graph, n.getValue(), runtime.getVMConfig().klassOffset);
463         FloatingReadNode read = graph.unique(new FloatingReadNode(address, CLASS_KLASS_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
464         n.replaceAtUsagesAndDelete(read);
465     }
466 
467     private void lowerInvoke(Invoke invoke, LoweringTool tool, StructuredGraph graph) {
468         if (invoke.callTarget() instanceof MethodCallTargetNode) {
469             MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
470             NodeInputList&lt;ValueNode&gt; parameters = callTarget.arguments();
<a name="31" id="anc31"></a><span class="line-modified">471             ValueNode receiver = parameters.size() &lt;= 0 ? null : parameters.get(0);</span>
<span class="line-modified">472             if (!callTarget.isStatic() &amp;&amp; receiver.stamp(NodeView.DEFAULT) instanceof ObjectStamp &amp;&amp; !StampTool.isPointerNonNull(receiver)) {</span>
<span class="line-modified">473                 ValueNode nonNullReceiver = createNullCheckedValue(receiver, invoke.asNode(), tool);</span>
<span class="line-modified">474                 parameters.set(0, nonNullReceiver);</span>
<span class="line-modified">475                 receiver = nonNullReceiver;</span>




476             }
477             JavaType[] signature = callTarget.targetMethod().getSignature().toParameterTypes(callTarget.isStatic() ? null : callTarget.targetMethod().getDeclaringClass());
478 
479             LoweredCallTargetNode loweredCallTarget = null;
480             OptionValues options = graph.getOptions();
481             if (InlineVTableStubs.getValue(options) &amp;&amp; callTarget.invokeKind().isIndirect() &amp;&amp; (AlwaysInlineVTableStubs.getValue(options) || invoke.isPolymorphic())) {
482                 HotSpotResolvedJavaMethod hsMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();
483                 ResolvedJavaType receiverType = invoke.getReceiverType();
484                 if (hsMethod.isInVirtualMethodTable(receiverType)) {
485                     JavaKind wordKind = runtime.getTarget().wordJavaKind;
486                     ValueNode hub = createReadHub(graph, receiver, tool);
487 
488                     ReadNode metaspaceMethod = createReadVirtualMethod(graph, hub, hsMethod, receiverType);
489                     // We use LocationNode.ANY_LOCATION for the reads that access the
490                     // compiled code entry as HotSpot does not guarantee they are final
491                     // values.
492                     int methodCompiledEntryOffset = runtime.getVMConfig().methodCompiledEntryOffset;
493                     AddressNode address = createOffsetAddress(graph, metaspaceMethod, methodCompiledEntryOffset);
494                     ReadNode compiledEntry = graph.add(new ReadNode(address, any(), StampFactory.forKind(wordKind), BarrierType.NONE));
495 
496                     loweredCallTarget = graph.add(new HotSpotIndirectCallTargetNode(metaspaceMethod, compiledEntry, parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),
497                                     signature, callTarget.targetMethod(),
498                                     HotSpotCallingConventionType.JavaCall, callTarget.invokeKind()));
499 
500                     graph.addBeforeFixed(invoke.asNode(), metaspaceMethod);
501                     graph.addAfterFixed(metaspaceMethod, compiledEntry);
502                 }
503             }
504 
505             if (loweredCallTarget == null) {
506                 loweredCallTarget = graph.add(new HotSpotDirectCallTargetNode(parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),
507                                 signature, callTarget.targetMethod(),
508                                 HotSpotCallingConventionType.JavaCall,
509                                 callTarget.invokeKind()));
510             }
511             callTarget.replaceAndDelete(loweredCallTarget);
512         }
513     }
514 
515     private CompressEncoding getOopEncoding() {
516         return runtime.getVMConfig().getOopEncoding();
517     }
518 
519     @Override
520     protected Stamp loadCompressedStamp(ObjectStamp stamp) {
521         return HotSpotNarrowOopStamp.compressed(stamp, getOopEncoding());
522     }
523 
524     @Override
525     protected ValueNode newCompressionNode(CompressionOp op, ValueNode value) {
526         return new HotSpotCompressionNode(op, value, getOopEncoding());
527     }
528 
529     @Override
530     public ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField f) {
531         HotSpotResolvedJavaField field = (HotSpotResolvedJavaField) f;
532         JavaConstant base = constantReflection.asJavaClass(field.getDeclaringClass());
533         return ConstantNode.forConstant(base, metaAccess, graph);
534     }
535 
536     @Override
537     protected ValueNode createReadArrayComponentHub(StructuredGraph graph, ValueNode arrayHub, FixedNode anchor) {
538         /*
539          * Anchor the read of the element klass to the cfg, because it is only valid when arrayClass
540          * is an object class, which might not be the case in other parts of the compiled method.
541          */
542         AddressNode address = createOffsetAddress(graph, arrayHub, runtime.getVMConfig().arrayClassElementOffset);
543         return graph.unique(new FloatingReadNode(address, OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION, null, KlassPointerStamp.klassNonNull(), AbstractBeginNode.prevBegin(anchor)));
544     }
545 
<a name="32" id="anc32"></a><span class="line-removed">546     @Override</span>
<span class="line-removed">547     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {</span>
<span class="line-removed">548         StructuredGraph graph = load.graph();</span>
<span class="line-removed">549         if (!(load instanceof GuardedUnsafeLoadNode) &amp;&amp; !graph.getGuardsStage().allowsFloatingGuards() &amp;&amp; addReadBarrier(load)) {</span>
<span class="line-removed">550             unsafeLoadSnippets.lower(load, tool);</span>
<span class="line-removed">551         } else {</span>
<span class="line-removed">552             super.lowerUnsafeLoadNode(load, tool);</span>
<span class="line-removed">553         }</span>
<span class="line-removed">554     }</span>
<span class="line-removed">555 </span>
556     private void lowerLoadMethodNode(LoadMethodNode loadMethodNode) {
557         StructuredGraph graph = loadMethodNode.graph();
558         HotSpotResolvedJavaMethod method = (HotSpotResolvedJavaMethod) loadMethodNode.getMethod();
559         ReadNode metaspaceMethod = createReadVirtualMethod(graph, loadMethodNode.getHub(), method, loadMethodNode.getReceiverType());
560         graph.replaceFixed(loadMethodNode, metaspaceMethod);
561     }
562 
563     private static void lowerGetClassNode(GetClassNode getClass, LoweringTool tool, StructuredGraph graph) {
564         StampProvider stampProvider = tool.getStampProvider();
565         LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, getClass.getObject()));
566         HubGetClassNode hubGetClass = graph.unique(new HubGetClassNode(tool.getMetaAccess(), hub));
567         getClass.replaceAtUsagesAndDelete(hubGetClass);
568         hub.lower(tool);
569         hubGetClass.lower(tool);
570     }
571 
572     private void lowerStoreHubNode(StoreHubNode storeHub, StructuredGraph graph) {
573         WriteNode hub = createWriteHub(graph, storeHub.getObject(), storeHub.getValue());
574         graph.replaceFixed(storeHub, hub);
575     }
576 
<a name="33" id="anc33"></a><span class="line-removed">577     @Override</span>
<span class="line-removed">578     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {</span>
<span class="line-removed">579         return (entryKind == JavaKind.Object &amp;&amp; !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.IMPRECISE : BarrierType.NONE;</span>
<span class="line-removed">580     }</span>
<span class="line-removed">581 </span>
<span class="line-removed">582     @Override</span>
<span class="line-removed">583     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {</span>
<span class="line-removed">584         return (entryKind == JavaKind.Object &amp;&amp; !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.PRECISE : BarrierType.NONE;</span>
<span class="line-removed">585     }</span>
<span class="line-removed">586 </span>
587     private void lowerOSRStartNode(OSRStartNode osrStart) {
588         StructuredGraph graph = osrStart.graph();
589         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
590             StartNode newStart = graph.add(new StartNode());
591             ParameterNode buffer = graph.addWithoutUnique(new ParameterNode(0, StampPair.createSingle(StampFactory.forKind(runtime.getTarget().wordJavaKind))));
592             ForeignCallNode migrationEnd = graph.add(new ForeignCallNode(foreignCalls, OSR_MIGRATION_END, buffer));
593             migrationEnd.setStateAfter(osrStart.stateAfter());
594             newStart.setNext(migrationEnd);
595             FixedNode next = osrStart.next();
596             osrStart.setNext(null);
597             migrationEnd.setNext(next);
598             graph.setStart(newStart);
599 
600             final int wordSize = target.wordSize;
601 
602             // @formatter:off
603             // taken from c2 locals_addr = osr_buf + (max_locals-1)*wordSize)
604             // @formatter:on
605             int localsOffset = (graph.method().getMaxLocals() - 1) * wordSize;
606             for (OSRLocalNode osrLocal : graph.getNodes(OSRLocalNode.TYPE)) {
607                 int size = osrLocal.getStackKind().getSlotCount();
608                 int offset = localsOffset - (osrLocal.index() + size - 1) * wordSize;
609                 AddressNode address = createOffsetAddress(graph, buffer, offset);
610                 ReadNode load = graph.add(new ReadNode(address, any(), osrLocal.stamp(NodeView.DEFAULT), BarrierType.NONE));
611                 osrLocal.replaceAndDelete(load);
612                 graph.addBeforeFixed(migrationEnd, load);
613             }
614 
615             // @formatter:off
616             // taken from c2 monitors_addr = osr_buf + (max_locals+mcnt*2-1)*wordSize);
617             // @formatter:on
618             final int lockCount = osrStart.stateAfter().locksSize();
619             final int locksOffset = (graph.method().getMaxLocals() + lockCount * 2 - 1) * wordSize;
620 
621             // first initialize the lock slots for all enters with the displaced marks read from the
622             // buffer
623             for (OSRMonitorEnterNode osrMonitorEnter : graph.getNodes(OSRMonitorEnterNode.TYPE)) {
624                 MonitorIdNode monitorID = osrMonitorEnter.getMonitorId();
625                 OSRLockNode lock = (OSRLockNode) osrMonitorEnter.object();
626                 final int index = lock.index();
627 
628                 final int offsetDisplacedHeader = locksOffset - ((index * 2) + 1) * wordSize;
629                 final int offsetLockObject = locksOffset - index * 2 * wordSize;
630 
631                 // load the displaced mark from the osr buffer
632                 AddressNode addressDisplacedHeader = createOffsetAddress(graph, buffer, offsetDisplacedHeader);
633                 ReadNode loadDisplacedHeader = graph.add(new ReadNode(addressDisplacedHeader, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
634                 graph.addBeforeFixed(migrationEnd, loadDisplacedHeader);
635 
636                 // we need to initialize the stack slot for the lock
637                 BeginLockScopeNode beginLockScope = graph.add(new BeginLockScopeNode(lock.getStackKind(), monitorID.getLockDepth()));
638                 graph.addBeforeFixed(migrationEnd, beginLockScope);
639 
640                 // write the displaced mark to the correct stack slot
641                 AddressNode addressDisplacedMark = createOffsetAddress(graph, beginLockScope, runtime.getVMConfig().basicLockDisplacedHeaderOffset);
<a name="34" id="anc34"></a><span class="line-modified">642                 WriteNode writeStackSlot = graph.add(new WriteNode(addressDisplacedMark, DISPLACED_MARK_WORD_LOCATION, loadDisplacedHeader, BarrierType.NONE));</span>
643                 graph.addBeforeFixed(migrationEnd, writeStackSlot);
644 
645                 // load the lock object from the osr buffer
646                 AddressNode addressLockObject = createOffsetAddress(graph, buffer, offsetLockObject);
647                 ReadNode loadObject = graph.add(new ReadNode(addressLockObject, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
648                 lock.replaceAndDelete(loadObject);
649                 graph.addBeforeFixed(migrationEnd, loadObject);
650             }
651 
652             osrStart.replaceAtUsagesAndDelete(newStart);
653         }
654     }
655 
656     static final class Exceptions {
657         protected static final EnumMap&lt;BytecodeExceptionKind, RuntimeException&gt; cachedExceptions;
658 
659         static {
660             cachedExceptions = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);
661             cachedExceptions.put(BytecodeExceptionKind.NULL_POINTER, clearStackTrace(new NullPointerException()));
662             cachedExceptions.put(BytecodeExceptionKind.OUT_OF_BOUNDS, clearStackTrace(new ArrayIndexOutOfBoundsException()));
663             cachedExceptions.put(BytecodeExceptionKind.CLASS_CAST, clearStackTrace(new ClassCastException()));
664             cachedExceptions.put(BytecodeExceptionKind.ARRAY_STORE, clearStackTrace(new ArrayStoreException()));
665             cachedExceptions.put(BytecodeExceptionKind.DIVISION_BY_ZERO, clearStackTrace(new ArithmeticException()));
666         }
667 
668         private static RuntimeException clearStackTrace(RuntimeException ex) {
669             ex.setStackTrace(new StackTraceElement[0]);
670             return ex;
671         }
672     }
673 
674     public static final class RuntimeCalls {
675         public static final EnumMap&lt;BytecodeExceptionKind, ForeignCallDescriptor&gt; runtimeCalls;
676 
677         static {
678             runtimeCalls = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);
679             runtimeCalls.put(BytecodeExceptionKind.ARRAY_STORE, new ForeignCallDescriptor(&quot;createArrayStoreException&quot;, ArrayStoreException.class, Object.class));
680             runtimeCalls.put(BytecodeExceptionKind.CLASS_CAST, new ForeignCallDescriptor(&quot;createClassCastException&quot;, ClassCastException.class, Object.class, KlassPointer.class));
681             runtimeCalls.put(BytecodeExceptionKind.NULL_POINTER, new ForeignCallDescriptor(&quot;createNullPointerException&quot;, NullPointerException.class));
682             runtimeCalls.put(BytecodeExceptionKind.OUT_OF_BOUNDS, new ForeignCallDescriptor(&quot;createOutOfBoundsException&quot;, ArrayIndexOutOfBoundsException.class, int.class, int.class));
683             runtimeCalls.put(BytecodeExceptionKind.DIVISION_BY_ZERO, new ForeignCallDescriptor(&quot;createDivisionByZeroException&quot;, ArithmeticException.class));
684             runtimeCalls.put(BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createIntegerExactOverflowException&quot;, ArithmeticException.class));
685             runtimeCalls.put(BytecodeExceptionKind.LONG_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createLongExactOverflowException&quot;, ArithmeticException.class));
686         }
687     }
688 
689     private void throwCachedException(BytecodeExceptionNode node) {
690         if (IS_IN_NATIVE_IMAGE) {
691             throw new InternalError(&quot;Can&#39;t throw exception from SVM object&quot;);
692         }
693         Throwable exception = Exceptions.cachedExceptions.get(node.getExceptionKind());
694         assert exception != null;
695 
696         StructuredGraph graph = node.graph();
697         FloatingNode exceptionNode = ConstantNode.forConstant(constantReflection.forObject(exception), metaAccess, graph);
698         graph.replaceFixedWithFloating(node, exceptionNode);
699     }
700 
701     private void lowerBytecodeExceptionNode(BytecodeExceptionNode node) {
702         if (OmitHotExceptionStacktrace.getValue(node.getOptions())) {
703             throwCachedException(node);
704             return;
705         }
706 
707         ForeignCallDescriptor descriptor = RuntimeCalls.runtimeCalls.get(node.getExceptionKind());
708         assert descriptor != null;
709 
710         StructuredGraph graph = node.graph();
711         ForeignCallNode foreignCallNode = graph.add(new ForeignCallNode(foreignCalls, descriptor, node.stamp(NodeView.DEFAULT), node.getArguments()));
<a name="35" id="anc35"></a>






712         graph.replaceFixedWithFixed(node, foreignCallNode);
713     }
714 
<a name="36" id="anc36"></a><span class="line-removed">715     private boolean addReadBarrier(RawLoadNode load) {</span>
<span class="line-removed">716         if (runtime.getVMConfig().useG1GC &amp;&amp; load.graph().getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS &amp;&amp; load.object().getStackKind() == JavaKind.Object &amp;&amp;</span>
<span class="line-removed">717                         load.accessKind() == JavaKind.Object &amp;&amp; !StampTool.isPointerAlwaysNull(load.object())) {</span>
<span class="line-removed">718             ResolvedJavaType type = StampTool.typeOrNull(load.object());</span>
<span class="line-removed">719             if (type != null &amp;&amp; !type.isArray()) {</span>
<span class="line-removed">720                 return true;</span>
<span class="line-removed">721             }</span>
<span class="line-removed">722         }</span>
<span class="line-removed">723         return false;</span>
<span class="line-removed">724     }</span>
<span class="line-removed">725 </span>
726     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, HotSpotResolvedJavaMethod method, ResolvedJavaType receiverType) {
727         return createReadVirtualMethod(graph, hub, method.vtableEntryOffset(receiverType));
728     }
729 
730     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, int vtableEntryOffset) {
731         assert vtableEntryOffset &gt; 0;
732         // We use LocationNode.ANY_LOCATION for the reads that access the vtable
733         // entry as HotSpot does not guarantee that this is a final value.
734         Stamp methodStamp = MethodPointerStamp.methodNonNull();
735         AddressNode address = createOffsetAddress(graph, hub, vtableEntryOffset);
736         ReadNode metaspaceMethod = graph.add(new ReadNode(address, any(), methodStamp, BarrierType.NONE));
737         return metaspaceMethod;
738     }
739 
740     @Override
741     protected ValueNode createReadHub(StructuredGraph graph, ValueNode object, LoweringTool tool) {
742         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
743             return graph.unique(new LoadHubNode(tool.getStampProvider(), object));
744         }
745         assert !object.isConstant() || object.isNullConstant();
746 
747         KlassPointerStamp hubStamp = KlassPointerStamp.klassNonNull();
748         if (runtime.getVMConfig().useCompressedClassPointers) {
749             hubStamp = hubStamp.compressed(runtime.getVMConfig().getKlassEncoding());
750         }
751 
752         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
753         LocationIdentity hubLocation = runtime.getVMConfig().useCompressedClassPointers ? COMPRESSED_HUB_LOCATION : HUB_LOCATION;
754         FloatingReadNode memoryRead = graph.unique(new FloatingReadNode(address, hubLocation, null, hubStamp, null, BarrierType.NONE));
755         if (runtime.getVMConfig().useCompressedClassPointers) {
756             return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());
757         } else {
758             return memoryRead;
759         }
760     }
761 
762     private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {
763         assert !object.isConstant() || object.asConstant().isDefaultForKind();
764 
765         ValueNode writeValue = value;
766         if (runtime.getVMConfig().useCompressedClassPointers) {
767             writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());
768         }
769 
770         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
<a name="37" id="anc37"></a><span class="line-modified">771         return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE));</span>
772     }
773 
774     @Override
775     protected BarrierType fieldLoadBarrierType(ResolvedJavaField f) {
776         HotSpotResolvedJavaField loadField = (HotSpotResolvedJavaField) f;
<a name="38" id="anc38"></a><span class="line-modified">777         BarrierType barrierType = BarrierType.NONE;</span>
<span class="line-removed">778         if (runtime.getVMConfig().useG1GC &amp;&amp; loadField.getJavaKind() == JavaKind.Object &amp;&amp; metaAccess.lookupJavaType(Reference.class).equals(loadField.getDeclaringClass()) &amp;&amp;</span>
779                         loadField.getName().equals(&quot;referent&quot;)) {
<a name="39" id="anc39"></a><span class="line-modified">780             barrierType = BarrierType.PRECISE;</span>
781         }
<a name="40" id="anc40"></a><span class="line-modified">782         return barrierType;</span>
783     }
784 
785     @Override
786     public int fieldOffset(ResolvedJavaField f) {
787         return f.getOffset();
788     }
789 
790     @Override
791     public int arrayLengthOffset() {
792         return runtime.getVMConfig().arrayOopDescLengthOffset();
793     }
794 
795     @Override
796     protected final JavaKind getStorageKind(ResolvedJavaField field) {
797         return field.getJavaKind();
798     }
799 
800     @Override
801     public ObjectCloneSnippets.Templates getObjectCloneSnippets() {
802         return objectCloneSnippets;
803     }
804 
805     @Override
806     public ForeignCallSnippets.Templates getForeignCallSnippets() {
807         return foreignCallSnippets;
808     }
809 }
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>
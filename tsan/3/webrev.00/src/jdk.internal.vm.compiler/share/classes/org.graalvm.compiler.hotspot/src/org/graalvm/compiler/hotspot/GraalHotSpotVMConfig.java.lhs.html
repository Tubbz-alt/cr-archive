<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import java.lang.reflect.Field;
 28 import java.lang.reflect.Modifier;
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.core.common.CompressEncoding;
 32 import org.graalvm.compiler.hotspot.nodes.GraalHotSpotVMConfigNode;
 33 
 34 import jdk.vm.ci.common.JVMCIError;
 35 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 36 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
 37 import jdk.vm.ci.meta.ResolvedJavaMethod;
 38 
 39 /**
 40  * Used to access native configuration details.
 41  */
 42 public class GraalHotSpotVMConfig extends GraalHotSpotVMConfigBase {
 43 
 44     GraalHotSpotVMConfig(HotSpotVMConfigStore store) {
 45         super(store);
 46 
 47         assert narrowKlassShift &lt;= logKlassAlignment;
 48         assert narrowOopShift &lt;= logMinObjAlignment();
 49         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift);
 50         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift);
 51 
 52         assert check();
 53     }
 54 
 55     private final CompressEncoding oopEncoding;
 56     private final CompressEncoding klassEncoding;
<a name="2" id="anc2"></a>
 57 
 58     public CompressEncoding getOopEncoding() {
 59         return oopEncoding;
 60     }
 61 
 62     public CompressEncoding getKlassEncoding() {
 63         return klassEncoding;
 64     }
 65 
 66     public final boolean cAssertions = getConstant(&quot;ASSERT&quot;, Boolean.class);
 67 
 68     public final int codeEntryAlignment = getFlag(&quot;CodeEntryAlignment&quot;, Integer.class);
 69     public final boolean enableContended = getFlag(&quot;EnableContended&quot;, Boolean.class);
 70     public final boolean restrictContended = getFlag(&quot;RestrictContended&quot;, Boolean.class);
 71     public final int contendedPaddingWidth = getFlag(&quot;ContendedPaddingWidth&quot;, Integer.class);
<a name="3" id="anc3"></a><span class="line-removed"> 72     public final int fieldsAllocationStyle = getFlag(&quot;FieldsAllocationStyle&quot;, Integer.class);</span>
<span class="line-removed"> 73     public final boolean compactFields = getFlag(&quot;CompactFields&quot;, Boolean.class);</span>
 74     public final boolean verifyOops = getFlag(&quot;VerifyOops&quot;, Boolean.class);
 75     public final boolean ciTime = getFlag(&quot;CITime&quot;, Boolean.class);
 76     public final boolean ciTimeEach = getFlag(&quot;CITimeEach&quot;, Boolean.class);
 77     public final boolean dontCompileHugeMethods = getFlag(&quot;DontCompileHugeMethods&quot;, Boolean.class);
 78     public final int hugeMethodLimit = getFlag(&quot;HugeMethodLimit&quot;, Integer.class);
 79     public final boolean printInlining = getFlag(&quot;PrintInlining&quot;, Boolean.class);
 80     public final boolean inline = getFlag(&quot;Inline&quot;, Boolean.class);
 81     public final boolean inlineNotify = versioned.inlineNotify;
 82     public final boolean useFastLocking = getFlag(&quot;JVMCIUseFastLocking&quot;, Boolean.class);
 83     public final boolean forceUnreachable = getFlag(&quot;ForceUnreachable&quot;, Boolean.class);
 84     public final int codeSegmentSize = getFlag(&quot;CodeCacheSegmentSize&quot;, Integer.class);
 85     public final boolean foldStableValues = getFlag(&quot;FoldStableValues&quot;, Boolean.class);
 86     public final int maxVectorSize = getFlag(&quot;MaxVectorSize&quot;, Integer.class);
 87 
 88     public final boolean verifyBeforeGC = getFlag(&quot;VerifyBeforeGC&quot;, Boolean.class);
 89     public final boolean verifyAfterGC = getFlag(&quot;VerifyAfterGC&quot;, Boolean.class);
 90 
 91     public final boolean useTLAB = getFlag(&quot;UseTLAB&quot;, Boolean.class);
 92     public final boolean useBiasedLocking = getFlag(&quot;UseBiasedLocking&quot;, Boolean.class);
 93     public final boolean usePopCountInstruction = getFlag(&quot;UsePopCountInstruction&quot;, Boolean.class);
 94     public final boolean useAESIntrinsics = getFlag(&quot;UseAESIntrinsics&quot;, Boolean.class);
 95     public final boolean useAESCTRIntrinsics = getFlag(&quot;UseAESCTRIntrinsics&quot;, Boolean.class, false);
 96     public final boolean useCRC32Intrinsics = getFlag(&quot;UseCRC32Intrinsics&quot;, Boolean.class);
 97     public final boolean useCRC32CIntrinsics = versioned.useCRC32CIntrinsics;
<a name="4" id="anc4"></a><span class="line-modified"> 98     public final boolean threadLocalHandshakes = getFlag(&quot;ThreadLocalHandshakes&quot;, Boolean.class, false);</span>
 99 
100     private final boolean useMultiplyToLenIntrinsic = getFlag(&quot;UseMultiplyToLenIntrinsic&quot;, Boolean.class);
101     private final boolean useSHA1Intrinsics = getFlag(&quot;UseSHA1Intrinsics&quot;, Boolean.class);
102     private final boolean useSHA256Intrinsics = getFlag(&quot;UseSHA256Intrinsics&quot;, Boolean.class);
103     private final boolean useSHA512Intrinsics = getFlag(&quot;UseSHA512Intrinsics&quot;, Boolean.class);
104     private final boolean useGHASHIntrinsics = getFlag(&quot;UseGHASHIntrinsics&quot;, Boolean.class, false);
<a name="5" id="anc5"></a>
105     private final boolean useMontgomeryMultiplyIntrinsic = getFlag(&quot;UseMontgomeryMultiplyIntrinsic&quot;, Boolean.class, false);
106     private final boolean useMontgomerySquareIntrinsic = getFlag(&quot;UseMontgomerySquareIntrinsic&quot;, Boolean.class, false);
107     private final boolean useMulAddIntrinsic = getFlag(&quot;UseMulAddIntrinsic&quot;, Boolean.class, false);
108     private final boolean useSquareToLenIntrinsic = getFlag(&quot;UseSquareToLenIntrinsic&quot;, Boolean.class, false);
109     public final boolean useVectorizedMismatchIntrinsic = getFlag(&quot;UseVectorizedMismatchIntrinsic&quot;, Boolean.class, false);
<a name="6" id="anc6"></a>


110 
111     /*
112      * These are methods because in some JDKs the flags are visible but the stubs themselves haven&#39;t
113      * been exported so we have to check both if the flag is on and if we have the stub.
114      */
115     public boolean useMultiplyToLenIntrinsic() {
116         return useMultiplyToLenIntrinsic &amp;&amp; multiplyToLen != 0;
117     }
118 
119     public boolean useSHA1Intrinsics() {
120         return useSHA1Intrinsics &amp;&amp; sha1ImplCompress != 0 &amp;&amp; sha1ImplCompressMultiBlock != 0;
121     }
122 
123     public boolean useSHA256Intrinsics() {
124         return useSHA256Intrinsics &amp;&amp; sha256ImplCompress != 0 &amp;&amp; sha256ImplCompressMultiBlock != 0;
125     }
126 
127     public boolean useSHA512Intrinsics() {
128         return useSHA512Intrinsics &amp;&amp; sha512ImplCompress != 0 &amp;&amp; sha512ImplCompressMultiBlock != 0;
129     }
130 
131     public boolean useGHASHIntrinsics() {
132         return useGHASHIntrinsics &amp;&amp; ghashProcessBlocks != 0;
133     }
134 
<a name="7" id="anc7"></a>



135     public boolean useMontgomeryMultiplyIntrinsic() {
136         return useMontgomeryMultiplyIntrinsic &amp;&amp; montgomeryMultiply != 0;
137     }
138 
139     public boolean useMontgomerySquareIntrinsic() {
140         return useMontgomerySquareIntrinsic &amp;&amp; montgomerySquare != 0;
141     }
142 
143     public boolean useMulAddIntrinsic() {
144         return useMulAddIntrinsic &amp;&amp; mulAdd != 0;
145     }
146 
147     public boolean useSquareToLenIntrinsic() {
148         return useSquareToLenIntrinsic &amp;&amp; squareToLen != 0;
149     }
150 
151     public boolean inlineNotify() {
152         return inlineNotify &amp;&amp; notifyAddress != 0;
153     }
154 
155     public boolean inlineNotifyAll() {
156         return inlineNotify &amp;&amp; notifyAllAddress != 0;
157     }
158 
159     public final boolean useG1GC = getFlag(&quot;UseG1GC&quot;, Boolean.class);
<a name="8" id="anc8"></a><span class="line-modified">160     public final boolean useCMSGC = getFlag(&quot;UseConcMarkSweepGC&quot;, Boolean.class);</span>
161 
162     public final int allocatePrefetchStyle = getFlag(&quot;AllocatePrefetchStyle&quot;, Integer.class);
163     public final int allocatePrefetchInstr = getFlag(&quot;AllocatePrefetchInstr&quot;, Integer.class);
164     public final int allocatePrefetchLines = getFlag(&quot;AllocatePrefetchLines&quot;, Integer.class);
165     public final int allocateInstancePrefetchLines = getFlag(&quot;AllocateInstancePrefetchLines&quot;, Integer.class);
166     public final int allocatePrefetchStepSize = getFlag(&quot;AllocatePrefetchStepSize&quot;, Integer.class);
167     public final int allocatePrefetchDistance = getFlag(&quot;AllocatePrefetchDistance&quot;, Integer.class);
168 
169     private final long universeCollectedHeap = getFieldValue(&quot;CompilerToVM::Data::Universe_collectedHeap&quot;, Long.class, &quot;CollectedHeap*&quot;);
170     private final int collectedHeapTotalCollectionsOffset = getFieldOffset(&quot;CollectedHeap::_total_collections&quot;, Integer.class, &quot;unsigned int&quot;);
171 
172     public long gcTotalCollectionsAddress() {
173         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
174     }
175 
176     public final boolean useDeferredInitBarriers = getFlag(&quot;ReduceInitialCardMarks&quot;, Boolean.class);
177 
178     // Compressed Oops related values.
179     public final boolean useCompressedOops = getFlag(&quot;UseCompressedOops&quot;, Boolean.class);
180     public final boolean useCompressedClassPointers = getFlag(&quot;UseCompressedClassPointers&quot;, Boolean.class);
181 
182     public final long narrowOopBase = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_oop_base&quot;, Long.class, &quot;address&quot;);
183     public final int narrowOopShift = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_oop_shift&quot;, Integer.class, &quot;int&quot;);
184     public final int objectAlignment = getFlag(&quot;ObjectAlignmentInBytes&quot;, Integer.class);
185 
186     public final int minObjAlignment() {
187         return objectAlignment / heapWordSize;
188     }
189 
190     public final int logMinObjAlignment() {
191         return (int) (Math.log(objectAlignment) / Math.log(2));
192     }
193 
194     public final int narrowKlassSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_narrowKlass&quot;, Integer.class, &quot;int&quot;);
195     public final long narrowKlassBase = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_base&quot;, Long.class, &quot;address&quot;);
196     public final int narrowKlassShift = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_shift&quot;, Integer.class, &quot;int&quot;);
197     public final int logKlassAlignment = getConstant(&quot;LogKlassAlignmentInBytes&quot;, Integer.class);
198 
199     public final int stackShadowPages = getFlag(&quot;StackShadowPages&quot;, Integer.class);
200     public final int stackReservedPages = getFlag(&quot;StackReservedPages&quot;, Integer.class, 0);
201     public final boolean useStackBanging = getFlag(&quot;UseStackBanging&quot;, Boolean.class);
202     public final int stackBias = getConstant(&quot;STACK_BIAS&quot;, Integer.class);
203     public final int vmPageSize = getFieldValue(&quot;CompilerToVM::Data::vm_page_size&quot;, Integer.class, &quot;int&quot;);
204 
<a name="9" id="anc9"></a><span class="line-modified">205     public final int markOffset = getFieldOffset(&quot;oopDesc::_mark&quot;, Integer.class, &quot;markOop&quot;);</span>
206     public final int hubOffset = getFieldOffset(&quot;oopDesc::_metadata._klass&quot;, Integer.class, &quot;Klass*&quot;);
207 
<a name="10" id="anc10"></a><span class="line-modified">208     public final int prototypeMarkWordOffset = getFieldOffset(&quot;Klass::_prototype_header&quot;, Integer.class, &quot;markOop&quot;);</span>
209     public final int subklassOffset = getFieldOffset(&quot;Klass::_subklass&quot;, Integer.class, &quot;Klass*&quot;);
210     public final int nextSiblingOffset = getFieldOffset(&quot;Klass::_next_sibling&quot;, Integer.class, &quot;Klass*&quot;);
211     public final int superCheckOffsetOffset = getFieldOffset(&quot;Klass::_super_check_offset&quot;, Integer.class, &quot;juint&quot;);
212     public final int secondarySuperCacheOffset = getFieldOffset(&quot;Klass::_secondary_super_cache&quot;, Integer.class, &quot;Klass*&quot;);
213     public final int secondarySupersOffset = getFieldOffset(&quot;Klass::_secondary_supers&quot;, Integer.class, &quot;Array&lt;Klass*&gt;*&quot;);
214 
<a name="11" id="anc11"></a><span class="line-modified">215     public final boolean classMirrorIsHandle;</span>
<span class="line-modified">216     public final int classMirrorOffset;</span>
<span class="line-removed">217     {</span>
<span class="line-removed">218         String name = &quot;Klass::_java_mirror&quot;;</span>
<span class="line-removed">219         int offset = -1;</span>
<span class="line-removed">220         boolean isHandle = false;</span>
<span class="line-removed">221         try {</span>
<span class="line-removed">222             offset = getFieldOffset(name, Integer.class, &quot;oop&quot;);</span>
<span class="line-removed">223         } catch (JVMCIError e) {</span>
<span class="line-removed">224 </span>
<span class="line-removed">225         }</span>
<span class="line-removed">226         if (offset == -1) {</span>
<span class="line-removed">227             try {</span>
<span class="line-removed">228                 offset = getFieldOffset(name, Integer.class, &quot;jobject&quot;);</span>
<span class="line-removed">229                 isHandle = true;</span>
<span class="line-removed">230             } catch (JVMCIError e) {</span>
<span class="line-removed">231                 try {</span>
<span class="line-removed">232                     // JDK-8186777</span>
<span class="line-removed">233                     offset = getFieldOffset(name, Integer.class, &quot;OopHandle&quot;);</span>
<span class="line-removed">234                     isHandle = true;</span>
<span class="line-removed">235                 } catch (JVMCIError e2) {</span>
<span class="line-removed">236                 }</span>
<span class="line-removed">237             }</span>
<span class="line-removed">238         }</span>
<span class="line-removed">239         if (offset == -1) {</span>
<span class="line-removed">240             throw new JVMCIError(&quot;cannot get offset of field &quot; + name + &quot; with type oop, jobject or OopHandle&quot;);</span>
<span class="line-removed">241         }</span>
<span class="line-removed">242         classMirrorOffset = offset;</span>
<span class="line-removed">243         classMirrorIsHandle = isHandle;</span>
<span class="line-removed">244     }</span>
245 
246     public final int klassSuperKlassOffset = getFieldOffset(&quot;Klass::_super&quot;, Integer.class, &quot;Klass*&quot;);
247     public final int klassModifierFlagsOffset = getFieldOffset(&quot;Klass::_modifier_flags&quot;, Integer.class, &quot;jint&quot;);
248     public final int klassAccessFlagsOffset = getFieldOffset(&quot;Klass::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
249     public final int klassLayoutHelperOffset = getFieldOffset(&quot;Klass::_layout_helper&quot;, Integer.class, &quot;jint&quot;);
250 
251     public final int klassLayoutHelperNeutralValue = getConstant(&quot;Klass::_lh_neutral_value&quot;, Integer.class);
252     public final int layoutHelperLog2ElementSizeShift = getConstant(&quot;Klass::_lh_log2_element_size_shift&quot;, Integer.class);
253     public final int layoutHelperLog2ElementSizeMask = getConstant(&quot;Klass::_lh_log2_element_size_mask&quot;, Integer.class);
254     public final int layoutHelperElementTypeShift = getConstant(&quot;Klass::_lh_element_type_shift&quot;, Integer.class);
255     public final int layoutHelperElementTypeMask = getConstant(&quot;Klass::_lh_element_type_mask&quot;, Integer.class);
256     public final int layoutHelperHeaderSizeShift = getConstant(&quot;Klass::_lh_header_size_shift&quot;, Integer.class);
257     public final int layoutHelperHeaderSizeMask = getConstant(&quot;Klass::_lh_header_size_mask&quot;, Integer.class);
258     public final int layoutHelperArrayTagShift = getConstant(&quot;Klass::_lh_array_tag_shift&quot;, Integer.class);
259     public final int layoutHelperArrayTagTypeValue = getConstant(&quot;Klass::_lh_array_tag_type_value&quot;, Integer.class);
260     public final int layoutHelperArrayTagObjectValue = getConstant(&quot;Klass::_lh_array_tag_obj_value&quot;, Integer.class);
261 
262     /**
263      * This filters out the bit that differentiates a type array from an object array.
264      */
265     public int layoutHelperElementTypePrimitiveInPlace() {
266         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
267     }
268 
269     public final int vtableEntrySize = getFieldValue(&quot;CompilerToVM::Data::sizeof_vtableEntry&quot;, Integer.class, &quot;int&quot;);
270     public final int vtableEntryMethodOffset = getFieldOffset(&quot;vtableEntry::_method&quot;, Integer.class, &quot;Method*&quot;);
271 
272     public final int instanceKlassInitStateOffset = getFieldOffset(&quot;InstanceKlass::_init_state&quot;, Integer.class, &quot;u1&quot;);
<a name="12" id="anc12"></a>
273     public final int instanceKlassConstantsOffset = getFieldOffset(&quot;InstanceKlass::_constants&quot;, Integer.class, &quot;ConstantPool*&quot;);
274     public final int instanceKlassFieldsOffset = getFieldOffset(&quot;InstanceKlass::_fields&quot;, Integer.class, &quot;Array&lt;u2&gt;*&quot;);
275     public final int klassVtableStartOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_start_offset&quot;, Integer.class, &quot;int&quot;);
276     public final int klassVtableLengthOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_length_offset&quot;, Integer.class, &quot;int&quot;);
277 
278     public final int instanceKlassStateLinked = getConstant(&quot;InstanceKlass::linked&quot;, Integer.class);
<a name="13" id="anc13"></a>
279     public final int instanceKlassStateFullyInitialized = getConstant(&quot;InstanceKlass::fully_initialized&quot;, Integer.class);
280 
281     public final int arrayOopDescSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_arrayOopDesc&quot;, Integer.class, &quot;int&quot;);
282 
283     /**
284      * The offset of the array length word in an array object&#39;s header.
285      *
286      * See {@code arrayOopDesc::length_offset_in_bytes()}.
287      */
288     public final int arrayOopDescLengthOffset() {
289         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
290     }
291 
292     public final int arrayU1LengthOffset = getFieldOffset(&quot;Array&lt;int&gt;::_length&quot;, Integer.class, &quot;int&quot;);
293     public final int arrayU1DataOffset = getFieldOffset(&quot;Array&lt;u1&gt;::_data&quot;, Integer.class);
294     public final int arrayU2DataOffset = getFieldOffset(&quot;Array&lt;u2&gt;::_data&quot;, Integer.class);
295     public final int metaspaceArrayLengthOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_length&quot;, Integer.class, &quot;int&quot;);
296     public final int metaspaceArrayBaseOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_data[0]&quot;, Integer.class, &quot;Klass*&quot;);
297 
298     public final int arrayClassElementOffset = getFieldOffset(&quot;ObjArrayKlass::_element_klass&quot;, Integer.class, &quot;Klass*&quot;);
299 
300     public final int fieldInfoAccessFlagsOffset = getConstant(&quot;FieldInfo::access_flags_offset&quot;, Integer.class);
301     public final int fieldInfoNameIndexOffset = getConstant(&quot;FieldInfo::name_index_offset&quot;, Integer.class);
302     public final int fieldInfoSignatureIndexOffset = getConstant(&quot;FieldInfo::signature_index_offset&quot;, Integer.class);
303     public final int fieldInfoInitvalIndexOffset = getConstant(&quot;FieldInfo::initval_index_offset&quot;, Integer.class);
304     public final int fieldInfoLowPackedOffset = getConstant(&quot;FieldInfo::low_packed_offset&quot;, Integer.class);
305     public final int fieldInfoHighPackedOffset = getConstant(&quot;FieldInfo::high_packed_offset&quot;, Integer.class);
306     public final int fieldInfoFieldSlots = getConstant(&quot;FieldInfo::field_slots&quot;, Integer.class);
307 
308     public final int fieldInfoTagSize = getConstant(&quot;FIELDINFO_TAG_SIZE&quot;, Integer.class);
309 
310     public final int jvmAccMonitorMatch = getConstant(&quot;JVM_ACC_MONITOR_MATCH&quot;, Integer.class);
311     public final int jvmAccHasMonitorBytecodes = getConstant(&quot;JVM_ACC_HAS_MONITOR_BYTECODES&quot;, Integer.class);
312     public final int jvmAccHasFinalizer = getConstant(&quot;JVM_ACC_HAS_FINALIZER&quot;, Integer.class);
313     public final int jvmAccFieldInternal = getConstant(&quot;JVM_ACC_FIELD_INTERNAL&quot;, Integer.class);
314     public final int jvmAccFieldStable = getConstant(&quot;JVM_ACC_FIELD_STABLE&quot;, Integer.class);
315     public final int jvmAccFieldHasGenericSignature = getConstant(&quot;JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE&quot;, Integer.class);
316     public final int jvmAccWrittenFlags = getConstant(&quot;JVM_ACC_WRITTEN_FLAGS&quot;, Integer.class);
317     public final int jvmAccSynthetic = getConstant(&quot;JVM_ACC_SYNTHETIC&quot;, Integer.class);
318 
<a name="14" id="anc14"></a><span class="line-modified">319     public final int jvmciCompileStateCanPostOnExceptionsOffset = getJvmciCompileStateCanPostOnExceptionsOffset();</span>


320 
321     // Integer.MIN_VALUE if not available
<a name="15" id="anc15"></a><span class="line-modified">322     private int getJvmciCompileStateCanPostOnExceptionsOffset() {</span>
<span class="line-modified">323         int offset = getFieldOffset(&quot;JVMCICompileState::_jvmti_can_post_on_exceptions&quot;, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);</span>
324         if (offset == Integer.MIN_VALUE) {
325             // JDK 12
<a name="16" id="anc16"></a><span class="line-modified">326             offset = getFieldOffset(&quot;JVMCIEnv::_jvmti_can_post_on_exceptions&quot;, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);</span>
327         }
328         return offset;
329     }
330 
331     public final int threadTlabOffset = getFieldOffset(&quot;Thread::_tlab&quot;, Integer.class, &quot;ThreadLocalAllocBuffer&quot;);
332     public final int javaThreadAnchorOffset = getFieldOffset(&quot;JavaThread::_anchor&quot;, Integer.class, &quot;JavaFrameAnchor&quot;);
333     public final int javaThreadShouldPostOnExceptionsFlagOffset = getFieldOffset(&quot;JavaThread::_should_post_on_exceptions_flag&quot;, Integer.class, &quot;int&quot;, Integer.MIN_VALUE);
334     public final int threadObjectOffset = getFieldOffset(&quot;JavaThread::_threadObj&quot;, Integer.class, &quot;oop&quot;);
<a name="17" id="anc17"></a><span class="line-modified">335     public final int osThreadOffset = getFieldOffset(&quot;JavaThread::_osthread&quot;, Integer.class, &quot;OSThread*&quot;);</span>
336     public final int threadIsMethodHandleReturnOffset = getFieldOffset(&quot;JavaThread::_is_method_handle_return&quot;, Integer.class, &quot;int&quot;);
337     public final int threadObjectResultOffset = getFieldOffset(&quot;JavaThread::_vm_result&quot;, Integer.class, &quot;oop&quot;);
338     public final int jvmciCountersThreadOffset = getFieldOffset(&quot;JavaThread::_jvmci_counters&quot;, Integer.class, &quot;jlong*&quot;);
<a name="18" id="anc18"></a>
339     public final int javaThreadReservedStackActivationOffset = versioned.javaThreadReservedStackActivationOffset;
<a name="19" id="anc19"></a>
340 
341     public boolean requiresReservedStackCheck(List&lt;ResolvedJavaMethod&gt; methods) {
342         if (enableStackReservedZoneAddress != 0 &amp;&amp; methods != null) {
343             for (ResolvedJavaMethod method : methods) {
344                 if (((HotSpotResolvedJavaMethod) method).hasReservedStackAccess()) {
345                     return true;
346                 }
347             }
348         }
349         return false;
350     }
351 
352     /**
353      * An invalid value for {@link #rtldDefault}.
354      */
355     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
356 
357     /**
358      * Address of the library lookup routine. The C signature of this routine is:
359      *
360      * &lt;pre&gt;
361      *     void* (const char *filename, char *ebuf, int ebuflen)
362      * &lt;/pre&gt;
363      */
364     public final long dllLoad = getAddress(&quot;os::dll_load&quot;);
365 
366     /**
367      * Address of the library lookup routine. The C signature of this routine is:
368      *
369      * &lt;pre&gt;
370      *     void* (void* handle, const char* name)
371      * &lt;/pre&gt;
372      */
373     public final long dllLookup = getAddress(&quot;os::dll_lookup&quot;);
374 
375     /**
376      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
377      * return the first occurrence of the desired symbol using the default library search order. If
378      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
379      * the current platform.
380      */
381     public final long rtldDefault = getAddress(&quot;RTLD_DEFAULT&quot;, osName.equals(&quot;bsd&quot;) || osName.equals(&quot;linux&quot;) ? null : INVALID_RTLD_DEFAULT_HANDLE);
382 
383     /**
384      * This field is used to pass exception objects into and out of the runtime system during
385      * exception handling for compiled code.
386      */
387     public final int threadExceptionOopOffset = getFieldOffset(&quot;JavaThread::_exception_oop&quot;, Integer.class, &quot;oop&quot;);
388     public final int threadExceptionPcOffset = getFieldOffset(&quot;JavaThread::_exception_pc&quot;, Integer.class, &quot;address&quot;);
389     public final int pendingExceptionOffset = getFieldOffset(&quot;ThreadShadow::_pending_exception&quot;, Integer.class, &quot;oop&quot;);
390 
391     public final int pendingDeoptimizationOffset = getFieldOffset(&quot;JavaThread::_pending_deoptimization&quot;, Integer.class, &quot;int&quot;);
392     public final int pendingTransferToInterpreterOffset = getFieldOffset(&quot;JavaThread::_pending_transfer_to_interpreter&quot;, Integer.class, &quot;bool&quot;);
393 
394     private final int javaFrameAnchorLastJavaSpOffset = getFieldOffset(&quot;JavaFrameAnchor::_last_Java_sp&quot;, Integer.class, &quot;intptr_t*&quot;);
395     private final int javaFrameAnchorLastJavaPcOffset = getFieldOffset(&quot;JavaFrameAnchor::_last_Java_pc&quot;, Integer.class, &quot;address&quot;);
396 
397     public final int pendingFailedSpeculationOffset;
398     {
399         String name = &quot;JavaThread::_pending_failed_speculation&quot;;
400         int offset = -1;
401         try {
402             offset = getFieldOffset(name, Integer.class, &quot;jlong&quot;);
403         } catch (JVMCIError e) {
404             try {
405                 offset = getFieldOffset(name, Integer.class, &quot;long&quot;);
406             } catch (JVMCIError e2) {
407             }
408         }
409         if (offset == -1) {
410             throw new JVMCIError(&quot;cannot get offset of field &quot; + name + &quot; with type long or jlong&quot;);
411         }
412         pendingFailedSpeculationOffset = offset;
413     }
414 
415     public int threadLastJavaSpOffset() {
416         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
417     }
418 
419     public int threadLastJavaPcOffset() {
420         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
421     }
422 
423     public int threadLastJavaFpOffset() {
424         assert osArch.equals(&quot;aarch64&quot;) || osArch.equals(&quot;amd64&quot;);
425         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_last_Java_fp&quot;, Integer.class, &quot;intptr_t*&quot;);
426     }
427 
428     public int threadJavaFrameAnchorFlagsOffset() {
429         assert osArch.equals(&quot;sparc&quot;);
430         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_flags&quot;, Integer.class, &quot;int&quot;);
431     }
432 
433     public final int runtimeCallStackSize = getConstant(&quot;frame::arg_reg_save_area_bytes&quot;, Integer.class, intRequiredOnAMD64);
434     public final int frameInterpreterFrameSenderSpOffset = getConstant(&quot;frame::interpreter_frame_sender_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
435     public final int frameInterpreterFrameLastSpOffset = getConstant(&quot;frame::interpreter_frame_last_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
436 
<a name="20" id="anc20"></a><span class="line-modified">437     public final int osThreadInterruptedOffset = getFieldOffset(&quot;OSThread::_interrupted&quot;, Integer.class, &quot;jint&quot;);</span>
438 
<a name="21" id="anc21"></a><span class="line-modified">439     public final long markOopDescHashShift = getConstant(&quot;markOopDesc::hash_shift&quot;, Long.class);</span>
440 
<a name="22" id="anc22"></a><span class="line-modified">441     public final int biasedLockMaskInPlace = getConstant(&quot;markOopDesc::biased_lock_mask_in_place&quot;, Integer.class);</span>
<span class="line-modified">442     public final int ageMaskInPlace = getConstant(&quot;markOopDesc::age_mask_in_place&quot;, Integer.class);</span>
<span class="line-modified">443     public final int epochMaskInPlace = getConstant(&quot;markOopDesc::epoch_mask_in_place&quot;, Integer.class);</span>
<span class="line-modified">444     public final long markOopDescHashMask = getConstant(&quot;markOopDesc::hash_mask&quot;, Long.class);</span>
<span class="line-modified">445     public final long markOopDescHashMaskInPlace = getConstant(&quot;markOopDesc::hash_mask_in_place&quot;, Long.class);</span>
446 
<a name="23" id="anc23"></a><span class="line-modified">447     public final int unlockedMask = getConstant(&quot;markOopDesc::unlocked_value&quot;, Integer.class);</span>
<span class="line-modified">448     public final int monitorMask = getConstant(&quot;markOopDesc::monitor_value&quot;, Integer.class, -1);</span>
<span class="line-modified">449     public final int biasedLockPattern = getConstant(&quot;markOopDesc::biased_lock_pattern&quot;, Integer.class);</span>
450 
451     // This field has no type in vmStructs.cpp
452     public final int objectMonitorOwner = getFieldOffset(&quot;ObjectMonitor::_owner&quot;, Integer.class, null, -1);
453     public final int objectMonitorRecursions = getFieldOffset(&quot;ObjectMonitor::_recursions&quot;, Integer.class, &quot;intptr_t&quot;, -1);
454     public final int objectMonitorCxq = getFieldOffset(&quot;ObjectMonitor::_cxq&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);
455     public final int objectMonitorEntryList = getFieldOffset(&quot;ObjectMonitor::_EntryList&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);
<a name="24" id="anc24"></a>
456 
<a name="25" id="anc25"></a><span class="line-modified">457     public final int markWordNoHashInPlace = getConstant(&quot;markOopDesc::no_hash_in_place&quot;, Integer.class);</span>
<span class="line-modified">458     public final int markWordNoLockInPlace = getConstant(&quot;markOopDesc::no_lock_in_place&quot;, Integer.class);</span>
459 
460     /**
<a name="26" id="anc26"></a><span class="line-modified">461      * See {@code markOopDesc::prototype()}.</span>
462      */
463     public long arrayPrototypeMarkWord() {
464         return markWordNoHashInPlace | markWordNoLockInPlace;
465     }
466 
467     /**
<a name="27" id="anc27"></a><span class="line-modified">468      * See {@code markOopDesc::copy_set_hash()}.</span>
469      */
470     public long tlabIntArrayMarkWord() {
<a name="28" id="anc28"></a><span class="line-modified">471         long tmp = arrayPrototypeMarkWord() &amp; (~markOopDescHashMaskInPlace);</span>
<span class="line-modified">472         tmp |= ((0x2 &amp; markOopDescHashMask) &lt;&lt; markOopDescHashShift);</span>
473         return tmp;
474     }
475 
<a name="29" id="anc29"></a>



476     /**
477      * Mark word right shift to get identity hash code.
478      */
<a name="30" id="anc30"></a><span class="line-modified">479     public final int identityHashCodeShift = getConstant(&quot;markOopDesc::hash_shift&quot;, Integer.class);</span>
480 
481     /**
482      * Identity hash code value when uninitialized.
483      */
<a name="31" id="anc31"></a><span class="line-modified">484     public final int uninitializedIdentityHashCodeValue = getConstant(&quot;markOopDesc::no_hash&quot;, Integer.class);</span>
485 
486     public final int methodAccessFlagsOffset = getFieldOffset(&quot;Method::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
487     public final int methodConstMethodOffset = getFieldOffset(&quot;Method::_constMethod&quot;, Integer.class, &quot;ConstMethod*&quot;);
488     public final int methodIntrinsicIdOffset = versioned.methodIntrinsicIdOffset;
489     public final int methodFlagsOffset = versioned.methodFlagsOffset;
490     public final int methodVtableIndexOffset = getFieldOffset(&quot;Method::_vtable_index&quot;, Integer.class, &quot;int&quot;);
491 
492     public final int methodCountersOffset = getFieldOffset(&quot;Method::_method_counters&quot;, Integer.class, &quot;MethodCounters*&quot;);
493     public final int methodDataOffset = getFieldOffset(&quot;Method::_method_data&quot;, Integer.class, &quot;MethodData*&quot;);
494     public final int methodCompiledEntryOffset = getFieldOffset(&quot;Method::_from_compiled_entry&quot;, Integer.class, &quot;address&quot;);
495     public final int methodCodeOffset = versioned.methodCodeOffset;
496 
497     public final int methodFlagsCallerSensitive = getConstant(&quot;Method::_caller_sensitive&quot;, Integer.class);
498     public final int methodFlagsForceInline = getConstant(&quot;Method::_force_inline&quot;, Integer.class);
499     public final int methodFlagsDontInline = getConstant(&quot;Method::_dont_inline&quot;, Integer.class);
500     public final int methodFlagsHidden = getConstant(&quot;Method::_hidden&quot;, Integer.class);
501     public final int nonvirtualVtableIndex = getConstant(&quot;Method::nonvirtual_vtable_index&quot;, Integer.class);
502     public final int invalidVtableIndex = getConstant(&quot;Method::invalid_vtable_index&quot;, Integer.class);
503 
504     public final int invocationCounterOffset = getFieldOffset(&quot;MethodCounters::_invocation_counter&quot;, Integer.class, &quot;InvocationCounter&quot;);
505     public final int backedgeCounterOffset = getFieldOffset(&quot;MethodCounters::_backedge_counter&quot;, Integer.class, &quot;InvocationCounter&quot;);
506     public final int invocationCounterIncrement = versioned.invocationCounterIncrement;
507     public final int invocationCounterShift = versioned.invocationCounterShift;
508 
509     public final int nmethodEntryOffset = getFieldOffset(&quot;nmethod::_verified_entry_point&quot;,
510                     Integer.class, &quot;address&quot;);
511     public final int compilationLevelFullOptimization = getConstant(&quot;CompLevel_full_optimization&quot;,
512                     Integer.class);
513 
514     public final int constantPoolSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_ConstantPool&quot;, Integer.class, &quot;int&quot;);
515     public final int constantPoolLengthOffset = getFieldOffset(&quot;ConstantPool::_length&quot;,
516                     Integer.class, &quot;int&quot;);
517 
518     public final int heapWordSize = getConstant(&quot;HeapWordSize&quot;, Integer.class);
519 
520     /**
521      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
522      * are allowed to look like (respectively) the high or low bits of a real oop.
523      */
524     public final long nonOopBits = getFieldValue(&quot;CompilerToVM::Data::Universe_non_oop_bits&quot;, Long.class, &quot;void*&quot;);
525 
526     public final long verifyOopCounterAddress = getFieldAddress(&quot;StubRoutines::_verify_oop_count&quot;, &quot;jint&quot;);
527     public final long verifyOopMask = getFieldValue(&quot;CompilerToVM::Data::Universe_verify_oop_mask&quot;, Long.class, &quot;uintptr_t&quot;);
528     public final long verifyOopBits = getFieldValue(&quot;CompilerToVM::Data::Universe_verify_oop_bits&quot;, Long.class, &quot;uintptr_t&quot;);
529 
530     public final int logOfHRGrainBytes = getFieldValue(&quot;HeapRegion::LogOfHRGrainBytes&quot;, Integer.class, &quot;int&quot;);
531 
532     public final long cardtableStartAddress = getFieldValue(&quot;CompilerToVM::Data::cardtable_start_address&quot;, Long.class, &quot;jbyte*&quot;);
533     public final int cardtableShift = getFieldValue(&quot;CompilerToVM::Data::cardtable_shift&quot;, Integer.class, &quot;int&quot;);
534 
535     /**
536      * This is the largest stack offset encodeable in an OopMapValue. Offsets larger than this will
537      * throw an exception during code installation.
538      */
539     public final int maxOopMapStackOffset = getFieldValue(&quot;CompilerToVM::Data::_max_oop_map_stack_offset&quot;, Integer.class, &quot;int&quot;);
540 
541     public final long safepointPollingAddress = getFieldValue(&quot;os::_polling_page&quot;, Long.class, &quot;address&quot;);
542 
543     // G1 Collector Related Values.
544 
545     public final byte dirtyCardValue = versioned.dirtyCardValue;
546     public final byte g1YoungCardValue = versioned.g1YoungCardValue;
547 
548     public final int g1SATBQueueMarkingOffset = versioned.g1SATBQueueMarkingOffset;
549     public final int g1SATBQueueIndexOffset = versioned.g1SATBQueueIndexOffset;
550     public final int g1SATBQueueBufferOffset = versioned.g1SATBQueueBufferOffset;
551     public final int g1CardQueueIndexOffset = versioned.g1CardQueueIndexOffset;
552     public final int g1CardQueueBufferOffset = versioned.g1CardQueueBufferOffset;
553 
554     public final int klassOffset = getFieldValue(&quot;java_lang_Class::_klass_offset&quot;, Integer.class, &quot;int&quot;);
555     public final int arrayKlassOffset = getFieldValue(&quot;java_lang_Class::_array_klass_offset&quot;, Integer.class, &quot;int&quot;);
556 
557     public final int basicLockSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_BasicLock&quot;, Integer.class, &quot;int&quot;);
<a name="32" id="anc32"></a><span class="line-modified">558     public final int basicLockDisplacedHeaderOffset = getFieldOffset(&quot;BasicLock::_displaced_header&quot;, Integer.class, &quot;markOop&quot;);</span>
559 
560     public final int threadPollingPageOffset = getFieldOffset(&quot;Thread::_polling_page&quot;, Integer.class, &quot;address&quot;, -1);
561     public final int threadAllocatedBytesOffset = getFieldOffset(&quot;Thread::_allocated_bytes&quot;, Integer.class, &quot;jlong&quot;);
562 
563     public final int tlabRefillWasteIncrement = getFlag(&quot;TLABWasteIncrement&quot;, Integer.class);
564 
565     private final int threadLocalAllocBufferStartOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_start&quot;, Integer.class, &quot;HeapWord*&quot;);
566     private final int threadLocalAllocBufferEndOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_end&quot;, Integer.class, &quot;HeapWord*&quot;);
567     private final int threadLocalAllocBufferTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_top&quot;, Integer.class, &quot;HeapWord*&quot;);
568     private final int threadLocalAllocBufferPfTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_pf_top&quot;, Integer.class, &quot;HeapWord*&quot;);
569     private final int threadLocalAllocBufferSlowAllocationsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_slow_allocations&quot;, Integer.class, &quot;unsigned&quot;);
570     private final int threadLocalAllocBufferFastRefillWasteOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_fast_refill_waste&quot;, Integer.class, &quot;unsigned&quot;);
571     private final int threadLocalAllocBufferNumberOfRefillsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_number_of_refills&quot;, Integer.class, &quot;unsigned&quot;);
572     private final int threadLocalAllocBufferRefillWasteLimitOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_refill_waste_limit&quot;, Integer.class, &quot;size_t&quot;);
573     private final int threadLocalAllocBufferDesiredSizeOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_desired_size&quot;, Integer.class, &quot;size_t&quot;);
574 
575     public int tlabSlowAllocationsOffset() {
576         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
577     }
578 
579     public int tlabFastRefillWasteOffset() {
580         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
581     }
582 
583     public int tlabNumberOfRefillsOffset() {
584         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
585     }
586 
587     public int tlabRefillWasteLimitOffset() {
588         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
589     }
590 
591     public int threadTlabSizeOffset() {
592         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
593     }
594 
595     public int threadTlabStartOffset() {
596         return threadTlabOffset + threadLocalAllocBufferStartOffset;
597     }
598 
599     public int threadTlabEndOffset() {
600         return threadTlabOffset + threadLocalAllocBufferEndOffset;
601     }
602 
603     public int threadTlabTopOffset() {
604         return threadTlabOffset + threadLocalAllocBufferTopOffset;
605     }
606 
607     public int threadTlabPfTopOffset() {
608         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
609     }
610 
611     public final int tlabAlignmentReserve = getFieldValue(&quot;CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve&quot;, Integer.class, &quot;size_t&quot;);
612 
613     public final boolean tlabStats = getFlag(&quot;TLABStats&quot;, Boolean.class);
614 
<a name="33" id="anc33"></a>





615     // FIXME This is only temporary until the GC code is changed.
616     public final boolean inlineContiguousAllocationSupported = getFieldValue(&quot;CompilerToVM::Data::_supports_inline_contig_alloc&quot;, Boolean.class);
617     public final long heapEndAddress = getFieldValue(&quot;CompilerToVM::Data::_heap_end_addr&quot;, Long.class, &quot;HeapWord**&quot;);
618     public final long heapTopAddress = versioned.heapTopAddress;
619 
620     public final boolean cmsIncrementalMode = getFlag(&quot;CMSIncrementalMode&quot;, Boolean.class, false);
621 
622     public final long inlineCacheMissStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_ic_miss_stub&quot;, Long.class, &quot;address&quot;);
623     public final long handleWrongMethodStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub&quot;, Long.class, &quot;address&quot;);
624 
<a name="34" id="anc34"></a><span class="line-modified">625     public final long handleDeoptStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack&quot;, Long.class, &quot;address&quot;);</span>
<span class="line-modified">626     public final long uncommonTrapStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap&quot;, Long.class, &quot;address&quot;);</span>

627 
628     public final long codeCacheLowBound = versioned.codeCacheLowBound;
629     public final long codeCacheHighBound = versioned.codeCacheHighBound;
630 
631     public final long aescryptEncryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_encryptBlock&quot;, Long.class, &quot;address&quot;);
632     public final long aescryptDecryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_decryptBlock&quot;, Long.class, &quot;address&quot;);
633     public final long cipherBlockChainingEncryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_encryptAESCrypt&quot;, Long.class, &quot;address&quot;);
634     public final long cipherBlockChainingDecryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_decryptAESCrypt&quot;, Long.class, &quot;address&quot;);
635     public final long updateBytesCRC32Stub = getFieldValue(&quot;StubRoutines::_updateBytesCRC32&quot;, Long.class, &quot;address&quot;);
636     public final long crcTableAddress = getFieldValue(&quot;StubRoutines::_crc_table_adr&quot;, Long.class, &quot;address&quot;);
637 
638     public final long sha1ImplCompress = getFieldValue(&quot;StubRoutines::_sha1_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
639     public final long sha1ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha1_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
640     public final long sha256ImplCompress = getFieldValue(&quot;StubRoutines::_sha256_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
641     public final long sha256ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha256_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
642     public final long sha512ImplCompress = getFieldValue(&quot;StubRoutines::_sha512_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
643     public final long sha512ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha512_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
644     public final long multiplyToLen = getFieldValue(&quot;StubRoutines::_multiplyToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
645 
646     public final long counterModeAESCrypt = getFieldValue(&quot;StubRoutines::_counterMode_AESCrypt&quot;, Long.class, &quot;address&quot;, 0L);
647     public final long ghashProcessBlocks = getFieldValue(&quot;StubRoutines::_ghash_processBlocks&quot;, Long.class, &quot;address&quot;, 0L);
<a name="35" id="anc35"></a>
648     public final long crc32cTableTddr = getFieldValue(&quot;StubRoutines::_crc32c_table_addr&quot;, Long.class, &quot;address&quot;, 0L);
649     public final long updateBytesCRC32C = getFieldValue(&quot;StubRoutines::_updateBytesCRC32C&quot;, Long.class, &quot;address&quot;, 0L);
650     public final long updateBytesAdler32 = getFieldValue(&quot;StubRoutines::_updateBytesAdler32&quot;, Long.class, &quot;address&quot;, 0L);
651     public final long squareToLen = getFieldValue(&quot;StubRoutines::_squareToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
652     public final long mulAdd = getFieldValue(&quot;StubRoutines::_mulAdd&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
653     public final long montgomeryMultiply = getFieldValue(&quot;StubRoutines::_montgomeryMultiply&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
654     public final long montgomerySquare = getFieldValue(&quot;StubRoutines::_montgomerySquare&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
655     public final long vectorizedMismatch = getFieldValue(&quot;StubRoutines::_vectorizedMismatch&quot;, Long.class, &quot;address&quot;, 0L);
656 
657     public final long throwDelayedStackOverflowErrorEntry = versioned.throwDelayedStackOverflowErrorEntry;
658 
659     public final long jbyteArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_arraycopy&quot;, Long.class, &quot;address&quot;);
660     public final long jshortArraycopy = getFieldValue(&quot;StubRoutines::_jshort_arraycopy&quot;, Long.class, &quot;address&quot;);
661     public final long jintArraycopy = getFieldValue(&quot;StubRoutines::_jint_arraycopy&quot;, Long.class, &quot;address&quot;);
662     public final long jlongArraycopy = getFieldValue(&quot;StubRoutines::_jlong_arraycopy&quot;, Long.class, &quot;address&quot;);
663     public final long oopArraycopy = getFieldValue(&quot;StubRoutines::_oop_arraycopy&quot;, Long.class, &quot;address&quot;);
664     public final long oopArraycopyUninit = getFieldValue(&quot;StubRoutines::_oop_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
665     public final long jbyteDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
666     public final long jshortDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jshort_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
667     public final long jintDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jint_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
668     public final long jlongDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jlong_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
669     public final long oopDisjointArraycopy = getFieldValue(&quot;StubRoutines::_oop_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
670     public final long oopDisjointArraycopyUninit = getFieldValue(&quot;StubRoutines::_oop_disjoint_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
671     public final long jbyteAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jbyte_arraycopy&quot;, Long.class, &quot;address&quot;);
672     public final long jshortAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jshort_arraycopy&quot;, Long.class, &quot;address&quot;);
673     public final long jintAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jint_arraycopy&quot;, Long.class, &quot;address&quot;);
674     public final long jlongAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jlong_arraycopy&quot;, Long.class, &quot;address&quot;);
675     public final long oopAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_oop_arraycopy&quot;, Long.class, &quot;address&quot;);
676     public final long oopAlignedArraycopyUninit = getFieldValue(&quot;StubRoutines::_arrayof_oop_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
677     public final long jbyteAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jbyte_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
678     public final long jshortAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jshort_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
679     public final long jintAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jint_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
680     public final long jlongAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jlong_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
681     public final long oopAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
682     public final long oopAlignedDisjointArraycopyUninit = getFieldValue(&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
683     public final long checkcastArraycopy = getFieldValue(&quot;StubRoutines::_checkcast_arraycopy&quot;, Long.class, &quot;address&quot;);
684     public final long checkcastArraycopyUninit = getFieldValue(&quot;StubRoutines::_checkcast_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
685     public final long unsafeArraycopy = getFieldValue(&quot;StubRoutines::_unsafe_arraycopy&quot;, Long.class, &quot;address&quot;);
686     public final long genericArraycopy = getFieldValue(&quot;StubRoutines::_generic_arraycopy&quot;, Long.class, &quot;address&quot;);
687 
688     // Allocation stubs that throw an exception when allocation fails
689     public final long newInstanceAddress = getAddress(&quot;JVMCIRuntime::new_instance&quot;);
690     public final long newArrayAddress = getAddress(&quot;JVMCIRuntime::new_array&quot;);
691     public final long newMultiArrayAddress = getAddress(&quot;JVMCIRuntime::new_multi_array&quot;);
692     public final long dynamicNewInstanceAddress = getAddress(&quot;JVMCIRuntime::dynamic_new_instance&quot;);
693 
694     // Allocation stubs that return null when allocation fails
695     public final long newInstanceOrNullAddress = getAddress(&quot;JVMCIRuntime::new_instance_or_null&quot;, 0L);
696     public final long newArrayOrNullAddress = getAddress(&quot;JVMCIRuntime::new_array_or_null&quot;, 0L);
697     public final long newMultiArrayOrNullAddress = getAddress(&quot;JVMCIRuntime::new_multi_array_or_null&quot;, 0L);
698     public final long dynamicNewInstanceOrNullAddress = getAddress(&quot;JVMCIRuntime::dynamic_new_instance_or_null&quot;, 0L);
699 
700     public boolean areNullAllocationStubsAvailable() {
701         return newInstanceOrNullAddress != 0L;
702     }
703 
704     /**
705      * Checks that HotSpot implements all or none of the allocate-or-null stubs.
706      */
707     private boolean checkNullAllocationStubs() {
708         if (newInstanceOrNullAddress == 0L) {
709             assert newArrayOrNullAddress == 0L;
710             assert newMultiArrayOrNullAddress == 0L;
711             assert dynamicNewInstanceOrNullAddress == 0L;
712         } else {
713             assert newArrayOrNullAddress != 0L;
714             assert newMultiArrayOrNullAddress != 0L;
715             assert dynamicNewInstanceOrNullAddress != 0L;
716         }
717         return true;
718     }
719 
<a name="36" id="anc36"></a><span class="line-removed">720     public final long threadIsInterruptedAddress = getAddress(&quot;JVMCIRuntime::thread_is_interrupted&quot;);</span>
721     public final long vmMessageAddress = getAddress(&quot;JVMCIRuntime::vm_message&quot;);
722     public final long identityHashCodeAddress = getAddress(&quot;JVMCIRuntime::identity_hash_code&quot;);
723     public final long exceptionHandlerForPcAddress = getAddress(&quot;JVMCIRuntime::exception_handler_for_pc&quot;);
724     public final long monitorenterAddress = getAddress(&quot;JVMCIRuntime::monitorenter&quot;);
725     public final long monitorexitAddress = getAddress(&quot;JVMCIRuntime::monitorexit&quot;);
726     public final long notifyAddress = getAddress(&quot;JVMCIRuntime::object_notify&quot;, 0L);
727     public final long notifyAllAddress = getAddress(&quot;JVMCIRuntime::object_notifyAll&quot;, 0L);
728     public final long throwAndPostJvmtiExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_and_post_jvmti_exception&quot;);
729     public final long throwKlassExternalNameExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_klass_external_name_exception&quot;);
730     public final long throwClassCastExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_class_cast_exception&quot;);
731     public final long logPrimitiveAddress = getAddress(&quot;JVMCIRuntime::log_primitive&quot;);
732     public final long logObjectAddress = getAddress(&quot;JVMCIRuntime::log_object&quot;);
733     public final long logPrintfAddress = getAddress(&quot;JVMCIRuntime::log_printf&quot;);
734     public final long vmErrorAddress = getAddress(&quot;JVMCIRuntime::vm_error&quot;);
735     public final long loadAndClearExceptionAddress = getAddress(&quot;JVMCIRuntime::load_and_clear_exception&quot;);
736     public final long writeBarrierPreAddress = getAddress(&quot;JVMCIRuntime::write_barrier_pre&quot;);
737     public final long writeBarrierPostAddress = getAddress(&quot;JVMCIRuntime::write_barrier_post&quot;);
738     public final long validateObject = getAddress(&quot;JVMCIRuntime::validate_object&quot;);
739 
740     public final long testDeoptimizeCallInt = getAddress(&quot;JVMCIRuntime::test_deoptimize_call_int&quot;);
741 
742     public final long registerFinalizerAddress = getAddress(&quot;SharedRuntime::register_finalizer&quot;);
743     public final long exceptionHandlerForReturnAddressAddress = getAddress(&quot;SharedRuntime::exception_handler_for_return_address&quot;);
744     public final long osrMigrationEndAddress = getAddress(&quot;SharedRuntime::OSR_migration_end&quot;);
745     public final long enableStackReservedZoneAddress = versioned.enableStackReservedZoneAddress;
746 
747     public final long javaTimeMillisAddress = getAddress(&quot;os::javaTimeMillis&quot;);
748     public final long javaTimeNanosAddress = getAddress(&quot;os::javaTimeNanos&quot;);
749     public final long arithmeticSinAddress = getFieldValue(&quot;CompilerToVM::Data::dsin&quot;, Long.class, &quot;address&quot;);
750     public final long arithmeticCosAddress = getFieldValue(&quot;CompilerToVM::Data::dcos&quot;, Long.class, &quot;address&quot;);
751     public final long arithmeticTanAddress = getFieldValue(&quot;CompilerToVM::Data::dtan&quot;, Long.class, &quot;address&quot;);
752     public final long arithmeticExpAddress = getFieldValue(&quot;CompilerToVM::Data::dexp&quot;, Long.class, &quot;address&quot;);
753     public final long arithmeticLogAddress = getFieldValue(&quot;CompilerToVM::Data::dlog&quot;, Long.class, &quot;address&quot;);
754     public final long arithmeticLog10Address = getFieldValue(&quot;CompilerToVM::Data::dlog10&quot;, Long.class, &quot;address&quot;);
755     public final long arithmeticPowAddress = getFieldValue(&quot;CompilerToVM::Data::dpow&quot;, Long.class, &quot;address&quot;);
756 
757     public final long fremAddress = getAddress(&quot;SharedRuntime::frem&quot;);
758     public final long dremAddress = getAddress(&quot;SharedRuntime::drem&quot;);
759 
760     public final int jvmciCountersSize = getFlag(&quot;JVMCICounterSize&quot;, Integer.class);
761 
762     public final long deoptimizationFetchUnrollInfo = getAddress(&quot;Deoptimization::fetch_unroll_info&quot;);
763     public final long deoptimizationUncommonTrap = getAddress(&quot;Deoptimization::uncommon_trap&quot;);
764     public final long deoptimizationUnpackFrames = getAddress(&quot;Deoptimization::unpack_frames&quot;);
765 
766     public final int deoptimizationUnpackDeopt = getConstant(&quot;Deoptimization::Unpack_deopt&quot;, Integer.class);
767     public final int deoptimizationUnpackException = getConstant(&quot;Deoptimization::Unpack_exception&quot;, Integer.class);
768     public final int deoptimizationUnpackUncommonTrap = getConstant(&quot;Deoptimization::Unpack_uncommon_trap&quot;, Integer.class);
769     public final int deoptimizationUnpackReexecute = getConstant(&quot;Deoptimization::Unpack_reexecute&quot;, Integer.class);
770 
771     public final int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_size_of_deoptimized_frame&quot;, Integer.class, &quot;int&quot;);
772     public final int deoptimizationUnrollBlockCallerAdjustmentOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_caller_adjustment&quot;, Integer.class, &quot;int&quot;);
773     public final int deoptimizationUnrollBlockNumberOfFramesOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_number_of_frames&quot;, Integer.class, &quot;int&quot;);
774     public final int deoptimizationUnrollBlockTotalFrameSizesOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_total_frame_sizes&quot;, Integer.class, &quot;int&quot;);
775     public final int deoptimizationUnrollBlockUnpackKindOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_unpack_kind&quot;, Integer.class, &quot;int&quot;);
776     public final int deoptimizationUnrollBlockFrameSizesOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_frame_sizes&quot;, Integer.class, &quot;intptr_t*&quot;);
777     public final int deoptimizationUnrollBlockFramePcsOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_frame_pcs&quot;, Integer.class, &quot;address*&quot;);
778     public final int deoptimizationUnrollBlockInitialInfoOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_initial_info&quot;, Integer.class, &quot;intptr_t&quot;);
779 
780     // Checkstyle: stop
781     public final int MARKID_VERIFIED_ENTRY = getConstant(&quot;CodeInstaller::VERIFIED_ENTRY&quot;, Integer.class);
782     public final int MARKID_UNVERIFIED_ENTRY = getConstant(&quot;CodeInstaller::UNVERIFIED_ENTRY&quot;, Integer.class);
783     public final int MARKID_OSR_ENTRY = getConstant(&quot;CodeInstaller::OSR_ENTRY&quot;, Integer.class);
784     public final int MARKID_EXCEPTION_HANDLER_ENTRY = getConstant(&quot;CodeInstaller::EXCEPTION_HANDLER_ENTRY&quot;, Integer.class);
785     public final int MARKID_DEOPT_HANDLER_ENTRY = getConstant(&quot;CodeInstaller::DEOPT_HANDLER_ENTRY&quot;, Integer.class);
786     public final int MARKID_INVOKEINTERFACE = getConstant(&quot;CodeInstaller::INVOKEINTERFACE&quot;, Integer.class);
787     public final int MARKID_INVOKEVIRTUAL = getConstant(&quot;CodeInstaller::INVOKEVIRTUAL&quot;, Integer.class);
788     public final int MARKID_INVOKESTATIC = getConstant(&quot;CodeInstaller::INVOKESTATIC&quot;, Integer.class);
789     public final int MARKID_INVOKESPECIAL = getConstant(&quot;CodeInstaller::INVOKESPECIAL&quot;, Integer.class);
790     public final int MARKID_INLINE_INVOKE = getConstant(&quot;CodeInstaller::INLINE_INVOKE&quot;, Integer.class);
791     public final int MARKID_POLL_NEAR = getConstant(&quot;CodeInstaller::POLL_NEAR&quot;, Integer.class);
792     public final int MARKID_POLL_RETURN_NEAR = getConstant(&quot;CodeInstaller::POLL_RETURN_NEAR&quot;, Integer.class);
793     public final int MARKID_POLL_FAR = getConstant(&quot;CodeInstaller::POLL_FAR&quot;, Integer.class);
794     public final int MARKID_POLL_RETURN_FAR = getConstant(&quot;CodeInstaller::POLL_RETURN_FAR&quot;, Integer.class);
795     public final int MARKID_CARD_TABLE_SHIFT = getConstant(&quot;CodeInstaller::CARD_TABLE_SHIFT&quot;, Integer.class);
796     public final int MARKID_CARD_TABLE_ADDRESS = getConstant(&quot;CodeInstaller::CARD_TABLE_ADDRESS&quot;, Integer.class);
797     public final int MARKID_INVOKE_INVALID = getConstant(&quot;CodeInstaller::INVOKE_INVALID&quot;, Integer.class);
798 
799     /**
800      * The following constants are given default values here since they are missing in the native
801      * JVMCI-8 code but are still required for {@link GraalHotSpotVMConfigNode#canonical} to work in
802      * a JDK8 environment.
803      */
804     public final int MARKID_HEAP_TOP_ADDRESS = getConstant(&quot;CodeInstaller::HEAP_TOP_ADDRESS&quot;, Integer.class, 17);
805     public final int MARKID_HEAP_END_ADDRESS = getConstant(&quot;CodeInstaller::HEAP_END_ADDRESS&quot;, Integer.class, 18);
806     public final int MARKID_NARROW_KLASS_BASE_ADDRESS = getConstant(&quot;CodeInstaller::NARROW_KLASS_BASE_ADDRESS&quot;, Integer.class, 19);
807     public final int MARKID_NARROW_OOP_BASE_ADDRESS = getConstant(&quot;CodeInstaller::NARROW_OOP_BASE_ADDRESS&quot;, Integer.class, 20);
808     public final int MARKID_CRC_TABLE_ADDRESS = getConstant(&quot;CodeInstaller::CRC_TABLE_ADDRESS&quot;, Integer.class, 21);
809     public final int MARKID_LOG_OF_HEAP_REGION_GRAIN_BYTES = getConstant(&quot;CodeInstaller::LOG_OF_HEAP_REGION_GRAIN_BYTES&quot;, Integer.class, 22);
810     public final int MARKID_INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED = getConstant(&quot;CodeInstaller::INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED&quot;, Integer.class, 23);
811 
812     // Checkstyle: resume
813 
814     protected boolean check() {
815         for (Field f : getClass().getDeclaredFields()) {
816             int modifiers = f.getModifiers();
817             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
818                 assert Modifier.isFinal(modifiers) : &quot;field should be final: &quot; + f;
819             }
820         }
821 
822         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
823         assert checkNullAllocationStubs();
824         return true;
825     }
826 }
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>
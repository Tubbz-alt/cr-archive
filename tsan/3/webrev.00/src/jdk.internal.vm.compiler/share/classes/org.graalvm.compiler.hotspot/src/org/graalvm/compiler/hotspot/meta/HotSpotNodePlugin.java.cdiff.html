<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotNodePlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotInvocationPlugins.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotProviders.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotNodePlugin.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,12 ***</span>
  package org.graalvm.compiler.hotspot.meta;
  
  import static jdk.vm.ci.meta.DeoptimizationAction.None;
  import static jdk.vm.ci.meta.DeoptimizationReason.TransferToInterpreter;
  import static org.graalvm.compiler.core.common.GraalOptions.ImmutableCode;
  
<span class="line-modified">! import java.lang.reflect.Field;</span>
  
  import org.graalvm.compiler.core.common.CompilationIdentifier;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.core.common.type.StampPair;
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
<span class="line-new-header">--- 25,13 ---</span>
  package org.graalvm.compiler.hotspot.meta;
  
  import static jdk.vm.ci.meta.DeoptimizationAction.None;
  import static jdk.vm.ci.meta.DeoptimizationReason.TransferToInterpreter;
  import static org.graalvm.compiler.core.common.GraalOptions.ImmutableCode;
<span class="line-added">+ import static org.graalvm.compiler.hotspot.meta.HotSpotNodePlugin.Options.HotSpotPostOnExceptions;</span>
  
<span class="line-modified">! import java.util.function.Supplier;</span>
  
  import org.graalvm.compiler.core.common.CompilationIdentifier;
  import org.graalvm.compiler.core.common.type.StampFactory;
  import org.graalvm.compiler.core.common.type.StampPair;
  import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,10 ***</span>
<span class="line-new-header">--- 39,11 ---</span>
  import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
  import org.graalvm.compiler.hotspot.word.HotSpotWordTypes;
  import org.graalvm.compiler.nodes.ConstantNode;
  import org.graalvm.compiler.nodes.FixedGuardNode;
  import org.graalvm.compiler.nodes.FixedWithNextNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.FrameState;</span>
  import org.graalvm.compiler.nodes.LogicNode;
  import org.graalvm.compiler.nodes.NamedLocationIdentity;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,10 ***</span>
<span class="line-new-header">--- 56,14 ---</span>
  import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
  import org.graalvm.compiler.nodes.memory.ReadNode;
  import org.graalvm.compiler.nodes.memory.address.AddressNode;
  import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
  import org.graalvm.compiler.nodes.util.ConstantFoldUtil;
<span class="line-added">+ import org.graalvm.compiler.options.Option;</span>
<span class="line-added">+ import org.graalvm.compiler.options.OptionKey;</span>
<span class="line-added">+ import org.graalvm.compiler.options.OptionType;</span>
<span class="line-added">+ import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;</span>
  import org.graalvm.compiler.word.Word;
  import org.graalvm.compiler.word.WordOperationPlugin;
  import jdk.internal.vm.compiler.word.LocationIdentity;
  
  import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,10 ***</span>
<span class="line-new-header">--- 87,16 ---</span>
   * i.e., there are never non-inlined invokes that involve the {@link Word} type.&lt;/li&gt;
   * &lt;li&gt;Constant folding of field loads.&lt;/li&gt;
   * &lt;/ul&gt;
   */
  public final class HotSpotNodePlugin implements NodePlugin, TypePlugin {
<span class="line-added">+     public static class Options {</span>
<span class="line-added">+         @Option(help = &quot;Testing only option that forces deopts for exception throws&quot;, type = OptionType.Expert)//</span>
<span class="line-added">+         public static final OptionKey&lt;Boolean&gt; HotSpotPostOnExceptions = new OptionKey&lt;&gt;(false);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();</span>
      protected final WordOperationPlugin wordOperationPlugin;
      private final GraalHotSpotVMConfig config;
      private final HotSpotWordTypes wordTypes;
  
      public HotSpotNodePlugin(WordOperationPlugin wordOperationPlugin, GraalHotSpotVMConfig config, HotSpotWordTypes wordTypes) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,57 ***</span>
          }
          return false;
      }
  
      @Override
<span class="line-modified">!     public FixedWithNextNode instrumentExceptionDispatch(StructuredGraph graph, FixedWithNextNode afterExceptionLoaded) {</span>
          CompilationIdentifier id = graph.compilationId();
<span class="line-modified">!         if (id instanceof HotSpotCompilationIdentifier) {</span>
              HotSpotCompilationRequest request = ((HotSpotCompilationIdentifier) id).getRequest();
              if (request != null) {
                  long compileState = request.getJvmciEnv();
<span class="line-modified">!                 if (compileState != 0 &amp;&amp;</span>
<span class="line-removed">-                                 config.jvmciCompileStateCanPostOnExceptionsOffset != Integer.MIN_VALUE &amp;&amp;</span>
<span class="line-removed">-                                 config.javaThreadShouldPostOnExceptionsFlagOffset != Integer.MIN_VALUE) {</span>
                      long canPostOnExceptionsOffset = compileState + config.jvmciCompileStateCanPostOnExceptionsOffset;
<span class="line-modified">!                     boolean canPostOnExceptions = UNSAFE.getByte(canPostOnExceptionsOffset) != 0;</span>
<span class="line-removed">-                     if (canPostOnExceptions) {</span>
<span class="line-removed">-                         // If the exception capability is set, then generate code</span>
<span class="line-removed">-                         // to check the JavaThread.should_post_on_exceptions flag to see</span>
<span class="line-removed">-                         // if we actually need to report exception events for the current</span>
<span class="line-removed">-                         // thread. If not, take the fast path otherwise deoptimize.</span>
<span class="line-removed">-                         CurrentJavaThreadNode thread = graph.unique(new CurrentJavaThreadNode(wordTypes.getWordKind()));</span>
<span class="line-removed">-                         ValueNode offset = graph.unique(ConstantNode.forLong(config.javaThreadShouldPostOnExceptionsFlagOffset));</span>
<span class="line-removed">-                         AddressNode address = graph.unique(new OffsetAddressNode(thread, offset));</span>
<span class="line-removed">-                         ReadNode shouldPostException = graph.add(new ReadNode(address, JAVA_THREAD_SHOULD_POST_ON_EXCEPTIONS_FLAG_LOCATION, StampFactory.intValue(), BarrierType.NONE));</span>
<span class="line-removed">-                         afterExceptionLoaded.setNext(shouldPostException);</span>
<span class="line-removed">-                         ValueNode zero = graph.unique(ConstantNode.forInt(0));</span>
<span class="line-removed">-                         LogicNode cond = graph.unique(new IntegerEqualsNode(shouldPostException, zero));</span>
<span class="line-removed">-                         FixedGuardNode check = graph.add(new FixedGuardNode(cond, TransferToInterpreter, None, false));</span>
<span class="line-removed">-                         shouldPostException.setNext(check);</span>
<span class="line-removed">-                         return check;</span>
<span class="line-removed">-                     }</span>
                  }
              }
          }
          return afterExceptionLoaded;
      }
  
      private static final LocationIdentity JAVA_THREAD_SHOULD_POST_ON_EXCEPTIONS_FLAG_LOCATION = NamedLocationIdentity.mutable(&quot;JavaThread::_should_post_on_exceptions_flag&quot;);
<span class="line-removed">-     static final Unsafe UNSAFE = initUnsafe();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static Unsafe initUnsafe() {</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             // Fast path when we are trusted.</span>
<span class="line-removed">-             return Unsafe.getUnsafe();</span>
<span class="line-removed">-         } catch (SecurityException se) {</span>
<span class="line-removed">-             // Slow path when we are not trusted.</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span>
<span class="line-removed">-                 theUnsafe.setAccessible(true);</span>
<span class="line-removed">-                 return (Unsafe) theUnsafe.get(Unsafe.class);</span>
<span class="line-removed">-             } catch (Exception e) {</span>
<span class="line-removed">-                 throw new RuntimeException(&quot;exception while trying to get Unsafe&quot;, e);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  }
<span class="line-new-header">--- 219,44 ---</span>
          }
          return false;
      }
  
      @Override
<span class="line-modified">!     public FixedWithNextNode instrumentExceptionDispatch(StructuredGraph graph, FixedWithNextNode afterExceptionLoaded, Supplier&lt;FrameState&gt; frameStateFunction) {</span>
          CompilationIdentifier id = graph.compilationId();
<span class="line-modified">!         if (id instanceof HotSpotCompilationIdentifier &amp;&amp;</span>
<span class="line-added">+                         config.jvmciCompileStateCanPostOnExceptionsOffset != Integer.MIN_VALUE &amp;&amp;</span>
<span class="line-added">+                         config.javaThreadShouldPostOnExceptionsFlagOffset != Integer.MIN_VALUE) {</span>
<span class="line-added">+             boolean canPostOnExceptions = HotSpotPostOnExceptions.getValue(graph.getOptions());</span>
              HotSpotCompilationRequest request = ((HotSpotCompilationIdentifier) id).getRequest();
              if (request != null) {
                  long compileState = request.getJvmciEnv();
<span class="line-modified">!                 if (compileState != 0) {</span>
                      long canPostOnExceptionsOffset = compileState + config.jvmciCompileStateCanPostOnExceptionsOffset;
<span class="line-modified">!                     canPostOnExceptions = UNSAFE.getByte(canPostOnExceptionsOffset) != 0;</span>
                  }
              }
<span class="line-added">+             if (canPostOnExceptions) {</span>
<span class="line-added">+                 // If the exception capability is set, then generate code</span>
<span class="line-added">+                 // to check the JavaThread.should_post_on_exceptions flag to see</span>
<span class="line-added">+                 // if we actually need to report exception events for the current</span>
<span class="line-added">+                 // thread. If not, take the fast path otherwise deoptimize.</span>
<span class="line-added">+                 CurrentJavaThreadNode thread = graph.unique(new CurrentJavaThreadNode(wordTypes.getWordKind()));</span>
<span class="line-added">+                 ValueNode offset = graph.unique(ConstantNode.forLong(config.javaThreadShouldPostOnExceptionsFlagOffset));</span>
<span class="line-added">+                 AddressNode address = graph.unique(new OffsetAddressNode(thread, offset));</span>
<span class="line-added">+                 ReadNode shouldPostException = graph.add(new ReadNode(address, JAVA_THREAD_SHOULD_POST_ON_EXCEPTIONS_FLAG_LOCATION, StampFactory.intValue(), BarrierType.NONE));</span>
<span class="line-added">+                 afterExceptionLoaded.setNext(shouldPostException);</span>
<span class="line-added">+                 ValueNode zero = graph.unique(ConstantNode.forInt(0));</span>
<span class="line-added">+                 LogicNode cond = graph.unique(new IntegerEqualsNode(shouldPostException, zero));</span>
<span class="line-added">+                 FixedGuardNode check = graph.add(new FixedGuardNode(cond, TransferToInterpreter, None, false));</span>
<span class="line-added">+                 FrameState fs = frameStateFunction.get();</span>
<span class="line-added">+                 assert fs.stackSize() == 1 &amp;&amp; fs.rethrowException() : &quot;expected rethrow exception FrameState&quot;;</span>
<span class="line-added">+                 check.setStateBefore(fs);</span>
<span class="line-added">+                 shouldPostException.setNext(check);</span>
<span class="line-added">+                 return check;</span>
<span class="line-added">+             }</span>
          }
          return afterExceptionLoaded;
      }
  
      private static final LocationIdentity JAVA_THREAD_SHOULD_POST_ON_EXCEPTIONS_FLAG_LOCATION = NamedLocationIdentity.mutable(&quot;JavaThread::_should_post_on_exceptions_flag&quot;);
  }
</pre>
<center><a href="HotSpotInvocationPlugins.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotProviders.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
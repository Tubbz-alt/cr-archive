<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/jdk.internal.vm.compiler.word/src/jdk/internal/vm/compiler/word/LocationIdentity.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ComparableWord.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Pointer.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/jdk.internal.vm.compiler.word/src/jdk/internal/vm/compiler/word/LocationIdentity.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,11 ***</span>
   * &lt;p&gt;
   * Clients of {@link LocationIdentity} must use {@link #equals(Object)}, not {@code ==}, when
   * comparing two {@link LocationIdentity} values for equality. Likewise, they must not use
   * {@link java.util.IdentityHashMap}s with {@link LocationIdentity} values as keys.
   *
<span class="line-modified">!  * @since 1.0</span>
   */
  public abstract class LocationIdentity {
  
      private static final class AnyLocationIdentity extends LocationIdentity {
          @Override
<span class="line-new-header">--- 48,11 ---</span>
   * &lt;p&gt;
   * Clients of {@link LocationIdentity} must use {@link #equals(Object)}, not {@code ==}, when
   * comparing two {@link LocationIdentity} values for equality. Likewise, they must not use
   * {@link java.util.IdentityHashMap}s with {@link LocationIdentity} values as keys.
   *
<span class="line-modified">!  * @since 19.0</span>
   */
  public abstract class LocationIdentity {
  
      private static final class AnyLocationIdentity extends LocationIdentity {
          @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,104 ***</span>
  
      /**
       * Creates a new location identity. Subclasses are responsible to provide proper implementations
       * of {@link #equals} and {@link #hashCode}.
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      protected LocationIdentity() {
      }
  
      /**
       * Indicates that the given location is the union of all possible mutable locations. A write to
       * such a location kill all reads from mutable locations and a read from this location is killed
       * by any write (except for initialization writes).
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public static final LocationIdentity ANY_LOCATION = new AnyLocationIdentity();
  
      /**
       * Location only allowed to be used for writes. Indicates that a completely new memory location
       * is written. Kills no read. The previous value at the given location must be either
       * uninitialized or null. Writes to this location do not need a GC pre-barrier.
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public static final LocationIdentity INIT_LOCATION = new InitLocationIdentity();
  
      /**
       * Indicates that the given location is the union of all possible mutable locations. A write to
       * such a location kill all reads from mutable locations and a read from this location is killed
       * by any write (except for initialization writes).
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public static LocationIdentity any() {
          return ANY_LOCATION;
      }
  
      /**
       * Location only allowed to be used for writes. Indicates that a completely new memory location
       * is written. Kills no read. The previous value at the given location must be either
       * uninitialized or null. Writes to this location do not need a GC pre-barrier.
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public static LocationIdentity init() {
          return INIT_LOCATION;
      }
  
      /**
       * Denotes a location is unchanging in all cases. Not that this is different than the Java
       * notion of final which only requires definite assignment.
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public abstract boolean isImmutable();
  
      /**
       * The inversion of {@link #isImmutable}.
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public final boolean isMutable() {
          return !isImmutable();
      }
  
      /**
       * Returns true if this location identity is {@link #any}.
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public final boolean isAny() {
          return this == ANY_LOCATION;
      }
  
      /**
       * Returns true if this location identity is {@link #init}.
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public final boolean isInit() {
          return this == INIT_LOCATION;
      }
  
      /**
       * Returns true if this location identity is not {@link #any}.
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public final boolean isSingle() {
          return this != ANY_LOCATION;
      }
  
      /**
       * Returns true if the memory slice denoted by this location identity may overlap with the
       * provided other location identity.
       *
<span class="line-modified">!      * @since 1.0</span>
       */
      public final boolean overlaps(LocationIdentity other) {
          return isAny() || other.isAny() || this.equals(other);
      }
  }
<span class="line-new-header">--- 80,104 ---</span>
  
      /**
       * Creates a new location identity. Subclasses are responsible to provide proper implementations
       * of {@link #equals} and {@link #hashCode}.
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      protected LocationIdentity() {
      }
  
      /**
       * Indicates that the given location is the union of all possible mutable locations. A write to
       * such a location kill all reads from mutable locations and a read from this location is killed
       * by any write (except for initialization writes).
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public static final LocationIdentity ANY_LOCATION = new AnyLocationIdentity();
  
      /**
       * Location only allowed to be used for writes. Indicates that a completely new memory location
       * is written. Kills no read. The previous value at the given location must be either
       * uninitialized or null. Writes to this location do not need a GC pre-barrier.
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public static final LocationIdentity INIT_LOCATION = new InitLocationIdentity();
  
      /**
       * Indicates that the given location is the union of all possible mutable locations. A write to
       * such a location kill all reads from mutable locations and a read from this location is killed
       * by any write (except for initialization writes).
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public static LocationIdentity any() {
          return ANY_LOCATION;
      }
  
      /**
       * Location only allowed to be used for writes. Indicates that a completely new memory location
       * is written. Kills no read. The previous value at the given location must be either
       * uninitialized or null. Writes to this location do not need a GC pre-barrier.
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public static LocationIdentity init() {
          return INIT_LOCATION;
      }
  
      /**
       * Denotes a location is unchanging in all cases. Not that this is different than the Java
       * notion of final which only requires definite assignment.
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public abstract boolean isImmutable();
  
      /**
       * The inversion of {@link #isImmutable}.
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public final boolean isMutable() {
          return !isImmutable();
      }
  
      /**
       * Returns true if this location identity is {@link #any}.
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public final boolean isAny() {
          return this == ANY_LOCATION;
      }
  
      /**
       * Returns true if this location identity is {@link #init}.
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public final boolean isInit() {
          return this == INIT_LOCATION;
      }
  
      /**
       * Returns true if this location identity is not {@link #any}.
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public final boolean isSingle() {
          return this != ANY_LOCATION;
      }
  
      /**
       * Returns true if the memory slice denoted by this location identity may overlap with the
       * provided other location identity.
       *
<span class="line-modified">!      * @since 19.0</span>
       */
      public final boolean overlaps(LocationIdentity other) {
          return isAny() || other.isAny() || this.equals(other);
      }
  }
</pre>
<center><a href="ComparableWord.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Pointer.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
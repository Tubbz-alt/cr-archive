<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/jdk.internal.vm.compiler.word/src/jdk/internal/vm/compiler/word/Pointer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 
  26 
  27 
  28 
  29 
  30 
  31 
  32 
  33 
  34 
  35 
  36 
  37 
  38 
  39 
  40 
  41 package jdk.internal.vm.compiler.word;
  42 
  43 /**
  44  * Lowest-level memory access of native C memory.
  45  * &lt;p&gt;
  46  * Do not use these methods to access Java objects. These methods access the raw memory without any
  47  * null checks, read- or write barriers. Even when the VM uses compressed pointers, then readObject
  48  * and writeObject methods access uncompressed pointers.
  49  *
  50  * @since 19.0
  51  */
  52 public interface Pointer extends UnsignedWord, PointerBase {
  53 
  54     /**
  55      * Unsafe conversion of this Pointer to a Java language object. No correctness checks or type
  56      * checks are performed. The caller must ensure that the Pointer contains a valid Java object
  57      * that can i.e., processed by the garbage collector.
  58      *
  59      * @return this Pointer cast to Object.
  60      *
  61      * @since 19.0
  62      */
  63     Object toObject();
  64 
  65     /**
  66      * Unsafe conversion of this Pointer to a Java language object. No correctness checks or type
  67      * checks are performed. The caller must ensure that the Pointer contains a valid Java object
  68      * that can i.e., processed by the garbage collector and the Pointer does not contain 0.
  69      *
  70      * @return this Pointer cast to non-null Object.
  71      *
  72      * @since 19.0
  73      */
  74     Object toObjectNonNull();
  75 
  76     /**
  77      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
  78      * bytes.
  79      * &lt;p&gt;
  80      * The offset is always treated as a {@link SignedWord} value. However, the static type is
  81      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
  82      * knows that the highest-order bit of the unsigned value is never used).
  83      *
  84      * @param offset the signed offset for the memory access
  85      * @param locationIdentity the identity of the read
  86      * @return the result of the memory access
  87      *
  88      * @since 19.0
  89      */
  90     byte readByte(WordBase offset, LocationIdentity locationIdentity);
  91 
  92     /**
  93      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
  94      * bytes.
  95      * &lt;p&gt;
  96      * The offset is always treated as a {@link SignedWord} value. However, the static type is
  97      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
  98      * knows that the highest-order bit of the unsigned value is never used).
  99      *
 100      * @param offset the signed offset for the memory access
 101      * @param locationIdentity the identity of the read
 102      * @return the result of the memory access
 103      *
 104      * @since 19.0
 105      */
 106     char readChar(WordBase offset, LocationIdentity locationIdentity);
 107 
 108     /**
 109      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 110      * bytes.
 111      * &lt;p&gt;
 112      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 113      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 114      * knows that the highest-order bit of the unsigned value is never used).
 115      *
 116      * @param offset the signed offset for the memory access
 117      * @param locationIdentity the identity of the read
 118      * @return the result of the memory access
 119      *
 120      * @since 19.0
 121      */
 122     short readShort(WordBase offset, LocationIdentity locationIdentity);
 123 
 124     /**
 125      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 126      * bytes.
 127      * &lt;p&gt;
 128      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 129      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 130      * knows that the highest-order bit of the unsigned value is never used).
 131      *
 132      * @param offset the signed offset for the memory access
 133      * @param locationIdentity the identity of the read
 134      * @return the result of the memory access
 135      *
 136      * @since 19.0
 137      */
 138     int readInt(WordBase offset, LocationIdentity locationIdentity);
 139 
 140     /**
 141      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 142      * bytes.
 143      * &lt;p&gt;
 144      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 145      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 146      * knows that the highest-order bit of the unsigned value is never used).
 147      *
 148      * @param offset the signed offset for the memory access
 149      * @param locationIdentity the identity of the read
 150      * @return the result of the memory access
 151      *
 152      * @since 19.0
 153      */
 154     long readLong(WordBase offset, LocationIdentity locationIdentity);
 155 
 156     /**
 157      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 158      * bytes.
 159      * &lt;p&gt;
 160      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 161      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 162      * knows that the highest-order bit of the unsigned value is never used).
 163      *
 164      * @param offset the signed offset for the memory access
 165      * @param locationIdentity the identity of the read
 166      * @return the result of the memory access
 167      *
 168      * @since 19.0
 169      */
 170     float readFloat(WordBase offset, LocationIdentity locationIdentity);
 171 
 172     /**
 173      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 174      * bytes.
 175      * &lt;p&gt;
 176      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 177      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 178      * knows that the highest-order bit of the unsigned value is never used).
 179      *
 180      * @param offset the signed offset for the memory access
 181      * @param locationIdentity the identity of the read
 182      * @return the result of the memory access
 183      *
 184      * @since 19.0
 185      */
 186     double readDouble(WordBase offset, LocationIdentity locationIdentity);
 187 
 188     /**
 189      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 190      * bytes.
 191      * &lt;p&gt;
 192      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 193      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 194      * knows that the highest-order bit of the unsigned value is never used).
 195      *
 196      * @param offset the signed offset for the memory access
 197      * @param locationIdentity the identity of the read
 198      * @return the result of the memory access
 199      *
 200      * @since 19.0
 201      */
 202     &lt;T extends WordBase&gt; T readWord(WordBase offset, LocationIdentity locationIdentity);
 203 
 204     /**
 205      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 206      * bytes.
 207      * &lt;p&gt;
 208      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 209      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 210      * knows that the highest-order bit of the unsigned value is never used).
 211      *
 212      * @param offset the signed offset for the memory access
 213      * @param locationIdentity the identity of the read
 214      * @return the result of the memory access
 215      *
 216      * @since 19.0
 217      */
 218     Object readObject(WordBase offset, LocationIdentity locationIdentity);
 219 
 220     /**
 221      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 222      * bytes.
 223      *
 224      * @param offset the signed offset for the memory access
 225      * @param locationIdentity the identity of the read
 226      * @return the result of the memory access
 227      *
 228      * @since 19.0
 229      */
 230     byte readByte(int offset, LocationIdentity locationIdentity);
 231 
 232     /**
 233      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 234      * bytes.
 235      *
 236      * @param offset the signed offset for the memory access
 237      * @param locationIdentity the identity of the read
 238      * @return the result of the memory access
 239      *
 240      * @since 19.0
 241      */
 242     char readChar(int offset, LocationIdentity locationIdentity);
 243 
 244     /**
 245      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 246      * bytes.
 247      *
 248      * @param offset the signed offset for the memory access
 249      * @param locationIdentity the identity of the read
 250      * @return the result of the memory access
 251      *
 252      * @since 19.0
 253      */
 254     short readShort(int offset, LocationIdentity locationIdentity);
 255 
 256     /**
 257      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 258      * bytes.
 259      *
 260      * @param offset the signed offset for the memory access
 261      * @param locationIdentity the identity of the read
 262      * @return the result of the memory access
 263      *
 264      * @since 19.0
 265      */
 266     int readInt(int offset, LocationIdentity locationIdentity);
 267 
 268     /**
 269      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 270      * bytes.
 271      *
 272      * @param offset the signed offset for the memory access
 273      * @param locationIdentity the identity of the read
 274      * @return the result of the memory access
 275      *
 276      * @since 19.0
 277      */
 278     long readLong(int offset, LocationIdentity locationIdentity);
 279 
 280     /**
 281      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 282      * bytes.
 283      *
 284      * @param offset the signed offset for the memory access
 285      * @param locationIdentity the identity of the read
 286      * @return the result of the memory access
 287      *
 288      * @since 19.0
 289      */
 290     float readFloat(int offset, LocationIdentity locationIdentity);
 291 
 292     /**
 293      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 294      * bytes.
 295      *
 296      * @param offset the signed offset for the memory access
 297      * @param locationIdentity the identity of the read
 298      * @return the result of the memory access
 299      *
 300      * @since 19.0
 301      */
 302     double readDouble(int offset, LocationIdentity locationIdentity);
 303 
 304     /**
 305      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 306      * bytes.
 307      *
 308      * @param offset the signed offset for the memory access
 309      * @param locationIdentity the identity of the read
 310      * @return the result of the memory access
 311      *
 312      * @since 19.0
 313      */
 314     &lt;T extends WordBase&gt; T readWord(int offset, LocationIdentity locationIdentity);
 315 
 316     /**
 317      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 318      * bytes.
 319      *
 320      * @param offset the signed offset for the memory access
 321      * @param locationIdentity the identity of the read
 322      * @return the result of the memory access
 323      *
 324      * @since 19.0
 325      */
 326     Object readObject(int offset, LocationIdentity locationIdentity);
 327 
 328     /**
 329      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 330      * bytes.
 331      * &lt;p&gt;
 332      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 333      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 334      * knows that the highest-order bit of the unsigned value is never used).
 335      *
 336      * @param offset the signed offset for the memory access
 337      * @param locationIdentity the identity of the write
 338      * @param val the value to be written to memory
 339      *
 340      * @since 19.0
 341      */
 342     void writeByte(WordBase offset, byte val, LocationIdentity locationIdentity);
 343 
 344     /**
 345      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 346      * bytes.
 347      * &lt;p&gt;
 348      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 349      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 350      * knows that the highest-order bit of the unsigned value is never used).
 351      *
 352      * @param offset the signed offset for the memory access
 353      * @param locationIdentity the identity of the write
 354      * @param val the value to be written to memory
 355      *
 356      * @since 19.0
 357      */
 358     void writeChar(WordBase offset, char val, LocationIdentity locationIdentity);
 359 
 360     /**
 361      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 362      * bytes.
 363      * &lt;p&gt;
 364      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 365      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 366      * knows that the highest-order bit of the unsigned value is never used).
 367      *
 368      * @param offset the signed offset for the memory access
 369      * @param locationIdentity the identity of the write
 370      * @param val the value to be written to memory
 371      *
 372      * @since 19.0
 373      */
 374     void writeShort(WordBase offset, short val, LocationIdentity locationIdentity);
 375 
 376     /**
 377      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 378      * bytes.
 379      * &lt;p&gt;
 380      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 381      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 382      * knows that the highest-order bit of the unsigned value is never used).
 383      *
 384      * @param offset the signed offset for the memory access
 385      * @param locationIdentity the identity of the write
 386      * @param val the value to be written to memory
 387      *
 388      * @since 19.0
 389      */
 390     void writeInt(WordBase offset, int val, LocationIdentity locationIdentity);
 391 
 392     /**
 393      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 394      * bytes.
 395      * &lt;p&gt;
 396      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 397      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 398      * knows that the highest-order bit of the unsigned value is never used).
 399      *
 400      * @param offset the signed offset for the memory access
 401      * @param locationIdentity the identity of the write
 402      * @param val the value to be written to memory
 403      *
 404      * @since 19.0
 405      */
 406     void writeLong(WordBase offset, long val, LocationIdentity locationIdentity);
 407 
 408     /**
 409      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 410      * bytes.
 411      * &lt;p&gt;
 412      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 413      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 414      * knows that the highest-order bit of the unsigned value is never used).
 415      *
 416      * @param offset the signed offset for the memory access
 417      * @param locationIdentity the identity of the write
 418      * @param val the value to be written to memory
 419      *
 420      * @since 19.0
 421      */
 422     void writeFloat(WordBase offset, float val, LocationIdentity locationIdentity);
 423 
 424     /**
 425      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 426      * bytes.
 427      * &lt;p&gt;
 428      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 429      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 430      * knows that the highest-order bit of the unsigned value is never used).
 431      *
 432      * @param offset the signed offset for the memory access
 433      * @param locationIdentity the identity of the write
 434      * @param val the value to be written to memory
 435      *
 436      * @since 19.0
 437      */
 438     void writeDouble(WordBase offset, double val, LocationIdentity locationIdentity);
 439 
 440     /**
 441      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 442      * bytes.
 443      * &lt;p&gt;
 444      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 445      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 446      * knows that the highest-order bit of the unsigned value is never used).
 447      *
 448      * @param offset the signed offset for the memory access
 449      * @param locationIdentity the identity of the write
 450      * @param val the value to be written to memory
 451      *
 452      * @since 19.0
 453      */
 454     void writeWord(WordBase offset, WordBase val, LocationIdentity locationIdentity);
 455 
 456     /**
 457      * Initializes the memory at address {@code (this + offset)}. Both the base address and offset
 458      * are in bytes. The memory must be uninitialized or zero prior to this operation.
 459      * &lt;p&gt;
 460      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 461      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 462      * knows that the highest-order bit of the unsigned value is never used).
 463      *
 464      * @param offset the signed offset for the memory access
 465      * @param locationIdentity the identity of the write
 466      * @param val the value to be written to memory
 467      *
 468      * @since 19.0
 469      */
 470     void initializeLong(WordBase offset, long val, LocationIdentity locationIdentity);
 471 
 472     /**
 473      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 474      * bytes.
 475      * &lt;p&gt;
 476      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 477      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 478      * knows that the highest-order bit of the unsigned value is never used).
 479      *
 480      * @param offset the signed offset for the memory access
 481      * @param locationIdentity the identity of the write
 482      * @param val the value to be written to memory
 483      *
 484      * @since 19.0
 485      */
 486     void writeObject(WordBase offset, Object val, LocationIdentity locationIdentity);
 487 
 488     /**
 489      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 490      * bytes.
 491      *
 492      * @param offset the signed offset for the memory access
 493      * @param locationIdentity the identity of the write
 494      * @param val the value to be written to memory
 495      *
 496      * @since 19.0
 497      */
 498     void writeByte(int offset, byte val, LocationIdentity locationIdentity);
 499 
 500     /**
 501      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 502      * bytes.
 503      *
 504      * @param offset the signed offset for the memory access
 505      * @param locationIdentity the identity of the write
 506      * @param val the value to be written to memory
 507      *
 508      * @since 19.0
 509      */
 510     void writeChar(int offset, char val, LocationIdentity locationIdentity);
 511 
 512     /**
 513      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 514      * bytes.
 515      *
 516      * @param offset the signed offset for the memory access
 517      * @param locationIdentity the identity of the write
 518      * @param val the value to be written to memory
 519      *
 520      * @since 19.0
 521      */
 522     void writeShort(int offset, short val, LocationIdentity locationIdentity);
 523 
 524     /**
 525      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 526      * bytes.
 527      *
 528      * @param offset the signed offset for the memory access
 529      * @param locationIdentity the identity of the write
 530      * @param val the value to be written to memory
 531      *
 532      * @since 19.0
 533      */
 534     void writeInt(int offset, int val, LocationIdentity locationIdentity);
 535 
 536     /**
 537      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 538      * bytes.
 539      *
 540      * @param offset the signed offset for the memory access
 541      * @param locationIdentity the identity of the write
 542      * @param val the value to be written to memory
 543      *
 544      * @since 19.0
 545      */
 546     void writeLong(int offset, long val, LocationIdentity locationIdentity);
 547 
 548     /**
 549      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 550      * bytes.
 551      *
 552      * @param offset the signed offset for the memory access
 553      * @param locationIdentity the identity of the write
 554      * @param val the value to be written to memory
 555      *
 556      * @since 19.0
 557      */
 558     void writeFloat(int offset, float val, LocationIdentity locationIdentity);
 559 
 560     /**
 561      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 562      * bytes.
 563      *
 564      * @param offset the signed offset for the memory access
 565      * @param locationIdentity the identity of the write
 566      * @param val the value to be written to memory
 567      *
 568      * @since 19.0
 569      */
 570     void writeDouble(int offset, double val, LocationIdentity locationIdentity);
 571 
 572     /**
 573      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 574      * bytes.
 575      *
 576      * @param offset the signed offset for the memory access
 577      * @param locationIdentity the identity of the write
 578      * @param val the value to be written to memory
 579      *
 580      * @since 19.0
 581      */
 582     void writeWord(int offset, WordBase val, LocationIdentity locationIdentity);
 583 
 584     /**
 585      * Initializes the memory at address {@code (this + offset)}. Both the base address and offset
 586      * are in bytes. The memory must be uninitialized or zero prior to this operation.
 587      *
 588      * @param offset the signed offset for the memory access
 589      * @param locationIdentity the identity of the write
 590      * @param val the value to be written to memory
 591      *
 592      * @since 19.0
 593      */
 594     void initializeLong(int offset, long val, LocationIdentity locationIdentity);
 595 
 596     /**
 597      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 598      * bytes.
 599      *
 600      * @param offset the signed offset for the memory access
 601      * @param locationIdentity the identity of the write
 602      * @param val the value to be written to memory
 603      *
 604      * @since 19.0
 605      */
 606     void writeObject(int offset, Object val, LocationIdentity locationIdentity);
 607 
 608     /**
 609      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 610      * bytes.
 611      * &lt;p&gt;
 612      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 613      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 614      * knows that the highest-order bit of the unsigned value is never used).
 615      *
 616      * @param offset the signed offset for the memory access
 617      * @return the result of the memory access
 618      *
 619      * @since 19.0
 620      */
 621     byte readByte(WordBase offset);
 622 
 623     /**
 624      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 625      * bytes.
 626      * &lt;p&gt;
 627      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 628      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 629      * knows that the highest-order bit of the unsigned value is never used).
 630      *
 631      * @param offset the signed offset for the memory access
 632      * @return the result of the memory access
 633      *
 634      * @since 19.0
 635      */
 636     char readChar(WordBase offset);
 637 
 638     /**
 639      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 640      * bytes.
 641      * &lt;p&gt;
 642      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 643      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 644      * knows that the highest-order bit of the unsigned value is never used).
 645      *
 646      * @param offset the signed offset for the memory access
 647      * @return the result of the memory access
 648      *
 649      * @since 19.0
 650      */
 651     short readShort(WordBase offset);
 652 
 653     /**
 654      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 655      * bytes.
 656      * &lt;p&gt;
 657      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 658      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 659      * knows that the highest-order bit of the unsigned value is never used).
 660      *
 661      * @param offset the signed offset for the memory access
 662      * @return the result of the memory access
 663      *
 664      * @since 19.0
 665      */
 666     int readInt(WordBase offset);
 667 
 668     /**
 669      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 670      * bytes.
 671      * &lt;p&gt;
 672      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 673      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 674      * knows that the highest-order bit of the unsigned value is never used).
 675      *
 676      * @param offset the signed offset for the memory access
 677      * @return the result of the memory access
 678      *
 679      * @since 19.0
 680      */
 681     long readLong(WordBase offset);
 682 
 683     /**
 684      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 685      * bytes.
 686      * &lt;p&gt;
 687      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 688      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 689      * knows that the highest-order bit of the unsigned value is never used).
 690      *
 691      * @param offset the signed offset for the memory access
 692      * @return the result of the memory access
 693      *
 694      * @since 19.0
 695      */
 696     float readFloat(WordBase offset);
 697 
 698     /**
 699      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 700      * bytes.
 701      * &lt;p&gt;
 702      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 703      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 704      * knows that the highest-order bit of the unsigned value is never used).
 705      *
 706      * @param offset the signed offset for the memory access
 707      * @return the result of the memory access
 708      *
 709      * @since 19.0
 710      */
 711     double readDouble(WordBase offset);
 712 
 713     /**
 714      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 715      * bytes.
 716      * &lt;p&gt;
 717      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 718      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 719      * knows that the highest-order bit of the unsigned value is never used).
 720      *
 721      * @param offset the signed offset for the memory access
 722      * @return the result of the memory access
 723      *
 724      * @since 19.0
 725      */
 726     &lt;T extends WordBase&gt; T readWord(WordBase offset);
 727 
 728     /**
 729      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 730      * bytes.
 731      * &lt;p&gt;
 732      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 733      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 734      * knows that the highest-order bit of the unsigned value is never used).
 735      *
 736      * @param offset the signed offset for the memory access
 737      * @return the result of the memory access
 738      *
 739      * @since 19.0
 740      */
 741     Object readObject(WordBase offset);
 742 
 743     /**
 744      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 745      * bytes.
 746      *
 747      * @param offset the signed offset for the memory access
 748      * @return the result of the memory access
 749      *
 750      * @since 19.0
 751      */
 752     byte readByte(int offset);
 753 
 754     /**
 755      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 756      * bytes.
 757      *
 758      * @param offset the signed offset for the memory access
 759      * @return the result of the memory access
 760      *
 761      * @since 19.0
 762      */
 763     char readChar(int offset);
 764 
 765     /**
 766      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 767      * bytes.
 768      *
 769      * @param offset the signed offset for the memory access
 770      * @return the result of the memory access
 771      *
 772      * @since 19.0
 773      */
 774     short readShort(int offset);
 775 
 776     /**
 777      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 778      * bytes.
 779      *
 780      * @param offset the signed offset for the memory access
 781      * @return the result of the memory access
 782      *
 783      * @since 19.0
 784      */
 785     int readInt(int offset);
 786 
 787     /**
 788      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 789      * bytes.
 790      *
 791      * @param offset the signed offset for the memory access
 792      * @return the result of the memory access
 793      *
 794      * @since 19.0
 795      */
 796     long readLong(int offset);
 797 
 798     /**
 799      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 800      * bytes.
 801      *
 802      * @param offset the signed offset for the memory access
 803      * @return the result of the memory access
 804      *
 805      * @since 19.0
 806      */
 807     float readFloat(int offset);
 808 
 809     /**
 810      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 811      * bytes.
 812      *
 813      * @param offset the signed offset for the memory access
 814      * @return the result of the memory access
 815      *
 816      * @since 19.0
 817      */
 818     double readDouble(int offset);
 819 
 820     /**
 821      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 822      * bytes.
 823      *
 824      * @param offset the signed offset for the memory access
 825      * @return the result of the memory access
 826      *
 827      * @since 19.0
 828      */
 829     &lt;T extends WordBase&gt; T readWord(int offset);
 830 
 831     /**
 832      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 833      * bytes.
 834      *
 835      * @param offset the signed offset for the memory access
 836      * @return the result of the memory access
 837      *
 838      * @since 19.0
 839      */
 840     Object readObject(int offset);
 841 
 842     /**
 843      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 844      * bytes.
 845      * &lt;p&gt;
 846      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 847      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 848      * knows that the highest-order bit of the unsigned value is never used).
 849      *
 850      * @param offset the signed offset for the memory access
 851      * @param val the value to be written to memory
 852      *
 853      * @since 19.0
 854      */
 855     void writeByte(WordBase offset, byte val);
 856 
 857     /**
 858      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 859      * bytes.
 860      * &lt;p&gt;
 861      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 862      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 863      * knows that the highest-order bit of the unsigned value is never used).
 864      *
 865      * @param offset the signed offset for the memory access
 866      * @param val the value to be written to memory
 867      *
 868      * @since 19.0
 869      */
 870     void writeChar(WordBase offset, char val);
 871 
 872     /**
 873      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 874      * bytes.
 875      * &lt;p&gt;
 876      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 877      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 878      * knows that the highest-order bit of the unsigned value is never used).
 879      *
 880      * @param offset the signed offset for the memory access
 881      * @param val the value to be written to memory
 882      *
 883      * @since 19.0
 884      */
 885     void writeShort(WordBase offset, short val);
 886 
 887     /**
 888      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 889      * bytes.
 890      * &lt;p&gt;
 891      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 892      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 893      * knows that the highest-order bit of the unsigned value is never used).
 894      *
 895      * @param offset the signed offset for the memory access
 896      * @param val the value to be written to memory
 897      *
 898      * @since 19.0
 899      */
 900     void writeInt(WordBase offset, int val);
 901 
 902     /**
 903      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 904      * bytes.
 905      * &lt;p&gt;
 906      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 907      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 908      * knows that the highest-order bit of the unsigned value is never used).
 909      *
 910      * @param offset the signed offset for the memory access
 911      * @param val the value to be written to memory
 912      *
 913      * @since 19.0
 914      */
 915     void writeLong(WordBase offset, long val);
 916 
 917     /**
 918      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 919      * bytes.
 920      * &lt;p&gt;
 921      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 922      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 923      * knows that the highest-order bit of the unsigned value is never used).
 924      *
 925      * @param offset the signed offset for the memory access
 926      * @param val the value to be written to memory
 927      *
 928      * @since 19.0
 929      */
 930     void writeFloat(WordBase offset, float val);
 931 
 932     /**
 933      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 934      * bytes.
 935      * &lt;p&gt;
 936      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 937      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 938      * knows that the highest-order bit of the unsigned value is never used).
 939      *
 940      * @param offset the signed offset for the memory access
 941      * @param val the value to be written to memory
 942      *
 943      * @since 19.0
 944      */
 945     void writeDouble(WordBase offset, double val);
 946 
 947     /**
 948      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 949      * bytes.
 950      * &lt;p&gt;
 951      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 952      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 953      * knows that the highest-order bit of the unsigned value is never used).
 954      *
 955      * @param offset the signed offset for the memory access
 956      * @param val the value to be written to memory
 957      *
 958      * @since 19.0
 959      */
 960     void writeWord(WordBase offset, WordBase val);
 961 
 962     /**
 963      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
 964      * bytes.
 965      * &lt;p&gt;
 966      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 967      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 968      * knows that the highest-order bit of the unsigned value is never used).
 969      *
 970      * @param offset the signed offset for the memory access
 971      * @param val the value to be written to memory
 972      *
 973      * @since 19.0
 974      */
 975     void writeObject(WordBase offset, Object val);
 976 
 977     /**
 978      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
 979      * expected value, and if equal, exchanges it for the new value. Both the base address and
 980      * offset are in bytes.
 981      * &lt;p&gt;
 982      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 983      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 984      * knows that the highest-order bit of the unsigned value is never used).
 985      *
 986      * @param offset the signed offset for the memory access
 987      * @param expectedValue the expected current value at the memory address
 988      * @param newValue the new value for the atomic exchange
 989      * @param locationIdentity the identity of the memory location
 990      * @return The value that was read for comparison, which is {@code expectedValue} if the
 991      *         exchange was performed.
 992      *
 993      * @since 19.0
 994      */
 995     int compareAndSwapInt(WordBase offset, int expectedValue, int newValue, LocationIdentity locationIdentity);
 996 
 997     /**
 998      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
 999      * expected value, and if equal, exchanges it for the new value. Both the base address and
1000      * offset are in bytes.
1001      * &lt;p&gt;
1002      * The offset is always treated as a {@link SignedWord} value. However, the static type is
1003      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
1004      * knows that the highest-order bit of the unsigned value is never used).
1005      *
1006      * @param offset the signed offset for the memory access
1007      * @param expectedValue the expected current value at the memory address
1008      * @param newValue the new value for the atomic exchange
1009      * @param locationIdentity the identity of the memory location
1010      * @return The value that was read for comparison, which is {@code expectedValue} if the
1011      *         exchange was performed.
1012      *
1013      * @since 19.0
1014      */
1015     long compareAndSwapLong(WordBase offset, long expectedValue, long newValue, LocationIdentity locationIdentity);
1016 
1017     /**
1018      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1019      * expected value, and if equal, exchanges it for the new value. Both the base address and
1020      * offset are in bytes.
1021      * &lt;p&gt;
1022      * The offset is always treated as a {@link SignedWord} value. However, the static type is
1023      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
1024      * knows that the highest-order bit of the unsigned value is never used).
1025      *
1026      * @param offset the signed offset for the memory access
1027      * @param expectedValue the expected current value at the memory address
1028      * @param newValue the new value for the atomic exchange
1029      * @param locationIdentity the identity of the memory location
1030      * @return The value that was read for comparison, which is {@code expectedValue} if the
1031      *         exchange was performed.
1032      *
1033      * @since 19.0
1034      */
1035     &lt;T extends WordBase&gt; T compareAndSwapWord(WordBase offset, T expectedValue, T newValue, LocationIdentity locationIdentity);
1036 
1037     /**
1038      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1039      * expected value, and if equal, exchanges it for the new value. Both the base address and
1040      * offset are in bytes.
1041      * &lt;p&gt;
1042      * The offset is always treated as a {@link SignedWord} value. However, the static type is
1043      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
1044      * knows that the highest-order bit of the unsigned value is never used).
1045      *
1046      * @param offset the signed offset for the memory access
1047      * @param expectedValue the expected current value at the memory address
1048      * @param newValue the new value for the atomic exchange
1049      * @param locationIdentity the identity of the memory location
1050      * @return The value that was read for comparison, which is {@code expectedValue} if the
1051      *         exchange was performed.
1052      *
1053      * @since 19.0
1054      */
1055     Object compareAndSwapObject(WordBase offset, Object expectedValue, Object newValue, LocationIdentity locationIdentity);
1056 
1057     /**
1058      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1059      * expected value, and if equal, exchanges it for the new value. Both the base address and
1060      * offset are in bytes.
1061      * &lt;p&gt;
1062      * The offset is always treated as a {@link SignedWord} value. However, the static type is
1063      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
1064      * knows that the highest-order bit of the unsigned value is never used).
1065      *
1066      * @param offset the signed offset for the memory access
1067      * @param expectedValue the expected current value at the memory address
1068      * @param newValue the new value for the atomic exchange
1069      * @param locationIdentity the identity of the memory location
1070      * @return {@code true} if successful. False return indicates that the actual value was not
1071      *         equal to the expected value.
1072      *
1073      * @since 19.0
1074      */
1075     boolean logicCompareAndSwapInt(WordBase offset, int expectedValue, int newValue, LocationIdentity locationIdentity);
1076 
1077     /**
1078      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1079      * expected value, and if equal, exchanges it for the new value. Both the base address and
1080      * offset are in bytes.
1081      * &lt;p&gt;
1082      * The offset is always treated as a {@link SignedWord} value. However, the static type is
1083      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
1084      * knows that the highest-order bit of the unsigned value is never used).
1085      *
1086      * @param offset the signed offset for the memory access
1087      * @param expectedValue the expected current value at the memory address
1088      * @param newValue the new value for the atomic exchange
1089      * @param locationIdentity the identity of the memory location
1090      * @return {@code true} if successful. False return indicates that the actual value was not
1091      *         equal to the expected value.
1092      *
1093      * @since 19.0
1094      */
1095     boolean logicCompareAndSwapLong(WordBase offset, long expectedValue, long newValue, LocationIdentity locationIdentity);
1096 
1097     /**
1098      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1099      * expected value, and if equal, exchanges it for the new value. Both the base address and
1100      * offset are in bytes.
1101      * &lt;p&gt;
1102      * The offset is always treated as a {@link SignedWord} value. However, the static type is
1103      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
1104      * knows that the highest-order bit of the unsigned value is never used).
1105      *
1106      * @param offset the signed offset for the memory access
1107      * @param expectedValue the expected current value at the memory address
1108      * @param newValue the new value for the atomic exchange
1109      * @param locationIdentity the identity of the memory location
1110      * @return {@code true} if successful. False return indicates that the actual value was not
1111      *         equal to the expected value.
1112      *
1113      * @since 19.0
1114      */
1115     boolean logicCompareAndSwapWord(WordBase offset, WordBase expectedValue, WordBase newValue, LocationIdentity locationIdentity);
1116 
1117     /**
1118      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1119      * expected value, and if equal, exchanges it for the new value. Both the base address and
1120      * offset are in bytes.
1121      * &lt;p&gt;
1122      * The offset is always treated as a {@link SignedWord} value. However, the static type is
1123      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
1124      * knows that the highest-order bit of the unsigned value is never used).
1125      *
1126      * @param offset the signed offset for the memory access
1127      * @param expectedValue the expected current value at the memory address
1128      * @param newValue the new value for the atomic exchange
1129      * @param locationIdentity the identity of the memory location
1130      * @return {@code true} if successful. False return indicates that the actual value was not
1131      *         equal to the expected value.
1132      *
1133      * @since 19.0
1134      */
1135     boolean logicCompareAndSwapObject(WordBase offset, Object expectedValue, Object newValue, LocationIdentity locationIdentity);
1136 
1137     /**
1138      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
1139      * bytes.
1140      *
1141      * @param offset the signed offset for the memory access
1142      * @param val the value to be written to memory
1143      *
1144      * @since 19.0
1145      */
1146     void writeByte(int offset, byte val);
1147 
1148     /**
1149      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
1150      * bytes.
1151      *
1152      * @param offset the signed offset for the memory access
1153      * @param val the value to be written to memory
1154      *
1155      * @since 19.0
1156      */
1157     void writeChar(int offset, char val);
1158 
1159     /**
1160      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
1161      * bytes.
1162      *
1163      * @param offset the signed offset for the memory access
1164      * @param val the value to be written to memory
1165      *
1166      * @since 19.0
1167      */
1168     void writeShort(int offset, short val);
1169 
1170     /**
1171      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
1172      * bytes.
1173      *
1174      * @param offset the signed offset for the memory access
1175      * @param val the value to be written to memory
1176      *
1177      * @since 19.0
1178      */
1179     void writeInt(int offset, int val);
1180 
1181     /**
1182      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
1183      * bytes.
1184      *
1185      * @param offset the signed offset for the memory access
1186      * @param val the value to be written to memory
1187      *
1188      * @since 19.0
1189      */
1190     void writeLong(int offset, long val);
1191 
1192     /**
1193      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
1194      * bytes.
1195      *
1196      * @param offset the signed offset for the memory access
1197      * @param val the value to be written to memory
1198      *
1199      * @since 19.0
1200      */
1201     void writeFloat(int offset, float val);
1202 
1203     /**
1204      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
1205      * bytes.
1206      *
1207      * @param offset the signed offset for the memory access
1208      * @param val the value to be written to memory
1209      *
1210      * @since 19.0
1211      */
1212     void writeDouble(int offset, double val);
1213 
1214     /**
1215      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
1216      * bytes.
1217      *
1218      * @param offset the signed offset for the memory access
1219      * @param val the value to be written to memory
1220      *
1221      * @since 19.0
1222      */
1223     void writeWord(int offset, WordBase val);
1224 
1225     /**
1226      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
1227      * bytes.
1228      *
1229      * @param offset the signed offset for the memory access
1230      * @param val the value to be written to memory
1231      *
1232      * @since 19.0
1233      */
1234     void writeObject(int offset, Object val);
1235 
1236     /**
1237      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1238      * expected value, and if equal, exchanges it for the new value. Both the base address and
1239      * offset are in bytes.
1240      *
1241      * @param offset the signed offset for the memory access
1242      * @param expectedValue the expected current value at the memory address
1243      * @param newValue the new value for the atomic exchange
1244      * @param locationIdentity the identity of the memory location
1245      * @return The value that was read for comparison, which is {@code expectedValue} if the
1246      *         exchange was performed.
1247      *
1248      * @since 19.0
1249      */
1250     int compareAndSwapInt(int offset, int expectedValue, int newValue, LocationIdentity locationIdentity);
1251 
1252     /**
1253      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1254      * expected value, and if equal, exchanges it for the new value. Both the base address and
1255      * offset are in bytes.
1256      *
1257      * @param offset the signed offset for the memory access
1258      * @param expectedValue the expected current value at the memory address
1259      * @param newValue the new value for the atomic exchange
1260      * @param locationIdentity the identity of the memory location
1261      * @return The value that was read for comparison, which is {@code expectedValue} if the
1262      *         exchange was performed.
1263      *
1264      * @since 19.0
1265      */
1266     long compareAndSwapLong(int offset, long expectedValue, long newValue, LocationIdentity locationIdentity);
1267 
1268     /**
1269      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1270      * expected value, and if equal, exchanges it for the new value. Both the base address and
1271      * offset are in bytes.
1272      *
1273      * @param offset the signed offset for the memory access
1274      * @param expectedValue the expected current value at the memory address
1275      * @param newValue the new value for the atomic exchange
1276      * @param locationIdentity the identity of the memory location
1277      * @return The value that was read for comparison, which is {@code expectedValue} if the
1278      *         exchange was performed.
1279      *
1280      * @since 19.0
1281      */
1282     &lt;T extends WordBase&gt; T compareAndSwapWord(int offset, T expectedValue, T newValue, LocationIdentity locationIdentity);
1283 
1284     /**
1285      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1286      * expected value, and if equal, exchanges it for the new value. Both the base address and
1287      * offset are in bytes.
1288      *
1289      * @param offset the signed offset for the memory access
1290      * @param expectedValue the expected current value at the memory address
1291      * @param newValue the new value for the atomic exchange
1292      * @param locationIdentity the identity of the memory location
1293      * @return The value that was read for comparison, which is {@code expectedValue} if the
1294      *         exchange was performed.
1295      *
1296      * @since 19.0
1297      */
1298     Object compareAndSwapObject(int offset, Object expectedValue, Object newValue, LocationIdentity locationIdentity);
1299 
1300     /**
1301      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1302      * expected value, and if equal, exchanges it for the new value. Both the base address and
1303      * offset are in bytes.
1304      *
1305      * @param offset the signed offset for the memory access
1306      * @param expectedValue the expected current value at the memory address
1307      * @param newValue the new value for the atomic exchange
1308      * @param locationIdentity the identity of the memory location
1309      * @return {@code true} if successful. False return indicates that the actual value was not
1310      *         equal to the expected value.
1311      *
1312      * @since 19.0
1313      */
1314     boolean logicCompareAndSwapInt(int offset, int expectedValue, int newValue, LocationIdentity locationIdentity);
1315 
1316     /**
1317      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1318      * expected value, and if equal, exchanges it for the new value. Both the base address and
1319      * offset are in bytes.
1320      *
1321      * @param offset the signed offset for the memory access
1322      * @param expectedValue the expected current value at the memory address
1323      * @param newValue the new value for the atomic exchange
1324      * @param locationIdentity the identity of the memory location
1325      * @return {@code true} if successful. False return indicates that the actual value was not
1326      *         equal to the expected value.
1327      *
1328      * @since 19.0
1329      */
1330     boolean logicCompareAndSwapLong(int offset, long expectedValue, long newValue, LocationIdentity locationIdentity);
1331 
1332     /**
1333      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1334      * expected value, and if equal, exchanges it for the new value. Both the base address and
1335      * offset are in bytes.
1336      *
1337      * @param offset the signed offset for the memory access
1338      * @param expectedValue the expected current value at the memory address
1339      * @param newValue the new value for the atomic exchange
1340      * @param locationIdentity the identity of the memory location
1341      * @return {@code true} if successful. False return indicates that the actual value was not
1342      *         equal to the expected value.
1343      *
1344      * @since 19.0
1345      */
1346     boolean logicCompareAndSwapWord(int offset, WordBase expectedValue, WordBase newValue, LocationIdentity locationIdentity);
1347 
1348     /**
1349      * In a single atomic step, compares the memory at address {@code (this + offset)} to the
1350      * expected value, and if equal, exchanges it for the new value. Both the base address and
1351      * offset are in bytes.
1352      *
1353      * @param offset the signed offset for the memory access
1354      * @param expectedValue the expected current value at the memory address
1355      * @param newValue the new value for the atomic exchange
1356      * @param locationIdentity the identity of the memory location
1357      * @return {@code true} if successful. False return indicates that the actual value was not
1358      *         equal to the expected value.
1359      *
1360      * @since 19.0
1361      */
1362     boolean logicCompareAndSwapObject(int offset, Object expectedValue, Object newValue, LocationIdentity locationIdentity);
1363 
1364     // Math functions that are defined in Unsigned, but known to preserve the
1365     // pointer-characteristics.
1366     // It is therefore safe that they return a static type of Pointer instead of Unsigned.
1367 
1368     /**
1369      * Returns a Pointer whose value is {@code (this + val)}.
1370      *
1371      * @param val value to be added to this Pointer.
1372      * @return {@code this + val}
1373      *
1374      * @since 19.0
1375      */
1376     @Override
1377     Pointer add(UnsignedWord val);
1378 
1379     /**
1380      * Returns a Pointer whose value is {@code (this + val)}.
1381      *
1382      * @param val value to be added to this Pointer.
1383      * @return {@code this + val}
1384      *
1385      * @since 19.0
1386      */
1387     @Override
1388     Pointer add(int val);
1389 
1390     /**
1391      * Returns a Pointer whose value is {@code (this - val)}.
1392      *
1393      * @param val value to be subtracted from this Pointer.
1394      * @return {@code this - val}
1395      *
1396      * @since 19.0
1397      */
1398     @Override
1399     Pointer subtract(UnsignedWord val);
1400 
1401     /**
1402      * Returns a Pointer whose value is {@code (this - val)}.
1403      *
1404      * @param val value to be subtracted from this Pointer.
1405      * @return {@code this - val}
1406      *
1407      * @since 19.0
1408      */
1409     @Override
1410     Pointer subtract(int val);
1411 
1412     /**
1413      * Returns a Pointer whose value is {@code (this &amp; val)}.
1414      *
1415      * @param val value to be AND&#39;ed with this Pointer.
1416      * @return {@code this &amp; val}
1417      *
1418      * @since 19.0
1419      */
1420     @Override
1421     Pointer and(UnsignedWord val);
1422 
1423     /**
1424      * Returns a Pointer whose value is {@code (this &amp; val)}.
1425      *
1426      * @param val value to be AND&#39;ed with this Pointer.
1427      * @return {@code this &amp; val}
1428      *
1429      * @since 19.0
1430      */
1431     @Override
1432     Pointer and(int val);
1433 
1434     /**
1435      * Returns a Pointer whose value is {@code (this | val)}.
1436      *
1437      * @param val value to be OR&#39;ed with this Pointer.
1438      * @return {@code this | val}
1439      *
1440      * @since 19.0
1441      */
1442     @Override
1443     Pointer or(UnsignedWord val);
1444 
1445     /**
1446      * Returns a Pointer whose value is {@code (this | val)}.
1447      *
1448      * @param val value to be OR&#39;ed with this Pointer.
1449      * @return {@code this | val}
1450      *
1451      * @since 19.0
1452      */
1453     @Override
1454     Pointer or(int val);
1455 }
    </pre>
  </body>
</html>
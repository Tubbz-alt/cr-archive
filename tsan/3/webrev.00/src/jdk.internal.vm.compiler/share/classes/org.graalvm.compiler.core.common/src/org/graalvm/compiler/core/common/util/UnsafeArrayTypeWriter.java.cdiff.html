<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/util/UnsafeArrayTypeWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnsafeArrayTypeReader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="UnsignedLong.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/util/UnsafeArrayTypeWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,16 ---</span>
  import static org.graalvm.compiler.core.common.util.TypeConversion.asS2;
  import static org.graalvm.compiler.core.common.util.TypeConversion.asS4;
  import static org.graalvm.compiler.core.common.util.TypeConversion.asU1;
  import static org.graalvm.compiler.core.common.util.TypeConversion.asU2;
  import static org.graalvm.compiler.core.common.util.TypeConversion.asU4;
<span class="line-added">+ import static org.graalvm.compiler.serviceprovider.GraalUnsafeAccess.getUnsafe;</span>
<span class="line-added">+ </span>
<span class="line-added">+ import java.nio.ByteBuffer;</span>
<span class="line-added">+ </span>
<span class="line-added">+ import org.graalvm.compiler.core.common.calc.UnsignedMath;</span>
<span class="line-added">+ </span>
  import sun.misc.Unsafe;
  
  /**
   * Provides low-level sequential write access to a byte[] array for signed and unsigned values of
   * size 1, 2, 4, and 8 bytes. To avoid copying an array when the buffer size is no longer
</pre>
<hr />
<pre>
<span class="line-old-header">*** 41,14 ***</span>
   * hardware architecture: the value {@code true} allows more efficient memory access on
   * architectures that support unaligned memory accesses; the value {@code false} is the safe
   * fallback that works on every hardware.
   */
  public abstract class UnsafeArrayTypeWriter implements TypeWriter {
<span class="line-modified">! </span>
      private static final int MIN_CHUNK_LENGTH = 200;
      private static final int MAX_CHUNK_LENGTH = 16000;
  
      static class Chunk {
          protected final byte[] data;
          protected int size;
          protected Chunk next;
  
<span class="line-new-header">--- 47,20 ---</span>
   * hardware architecture: the value {@code true} allows more efficient memory access on
   * architectures that support unaligned memory accesses; the value {@code false} is the safe
   * fallback that works on every hardware.
   */
  public abstract class UnsafeArrayTypeWriter implements TypeWriter {
<span class="line-modified">!     private static final Unsafe UNSAFE = getUnsafe();</span>
      private static final int MIN_CHUNK_LENGTH = 200;
      private static final int MAX_CHUNK_LENGTH = 16000;
  
<span class="line-added">+     // Constants for UNSIGNED5 coding of Pack200</span>
<span class="line-added">+     public static final long HIGH_WORD_SHIFT = 6;</span>
<span class="line-added">+     public static final long NUM_HIGH_CODES = 1 &lt;&lt; HIGH_WORD_SHIFT; // number of high codes (64)</span>
<span class="line-added">+     public static final long NUM_LOW_CODES = (1 &lt;&lt; Byte.SIZE) - NUM_HIGH_CODES;</span>
<span class="line-added">+     public static final long MAX_BYTES = 11;</span>
<span class="line-added">+ </span>
      static class Chunk {
          protected final byte[] data;
          protected int size;
          protected Chunk next;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,20 ***</span>
          }
          assert resultIdx == totalSize;
          return result;
      }
  
      @Override
      public final void putS1(long value) {
          long offset = writeOffset(Byte.BYTES);
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset, asS1(value));</span>
      }
  
      @Override
      public final void putU1(long value) {
          long offset = writeOffset(Byte.BYTES);
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset, asU1(value));</span>
      }
  
      @Override
      public final void putU2(long value) {
          putS2(asU2(value));
<span class="line-new-header">--- 103,36 ---</span>
          }
          assert resultIdx == totalSize;
          return result;
      }
  
<span class="line-added">+     /** Copies the buffer into the provided ByteBuffer at its current position. */</span>
<span class="line-added">+     public final ByteBuffer toByteBuffer(ByteBuffer buffer) {</span>
<span class="line-added">+         assert buffer.remaining() &lt;= totalSize;</span>
<span class="line-added">+         int initialPos = buffer.position();</span>
<span class="line-added">+         for (Chunk cur = firstChunk; cur != null; cur = cur.next) {</span>
<span class="line-added">+             buffer.put(cur.data, 0, cur.size);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         assert buffer.position() - initialPos == totalSize;</span>
<span class="line-added">+         return buffer;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public final byte[] toArray() {</span>
<span class="line-added">+         byte[] result = new byte[TypeConversion.asS4(getBytesWritten())];</span>
<span class="line-added">+         return toArray(result);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public final void putS1(long value) {
          long offset = writeOffset(Byte.BYTES);
<span class="line-modified">!         UNSAFE.putByte(writeChunk.data, offset, asS1(value));</span>
      }
  
      @Override
      public final void putU1(long value) {
          long offset = writeOffset(Byte.BYTES);
<span class="line-modified">!         UNSAFE.putByte(writeChunk.data, offset, asU1(value));</span>
      }
  
      @Override
      public final void putU2(long value) {
          putS2(asU2(value));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,10 ***</span>
<span class="line-new-header">--- 141,34 ---</span>
      @Override
      public final void putU4(long value) {
          putS4(asU4(value));
      }
  
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void putS2(long value) {</span>
<span class="line-added">+         long offset = writeOffset(Short.BYTES);</span>
<span class="line-added">+         putS2(value, writeChunk, offset);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void putS4(long value) {</span>
<span class="line-added">+         long offset = writeOffset(Integer.BYTES);</span>
<span class="line-added">+         putS4(value, writeChunk, offset);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void putS8(long value) {</span>
<span class="line-added">+         long offset = writeOffset(Long.BYTES);</span>
<span class="line-added">+         putS8(value, writeChunk, offset);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected abstract void putS2(long value, Chunk chunk, long offset);</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected abstract void putS4(long value, Chunk chunk, long offset);</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected abstract void putS8(long value, Chunk chunk, long offset);</span>
<span class="line-added">+ </span>
      protected long writeOffset(int writeBytes) {
          if (writeChunk.size + writeBytes &gt;= writeChunk.data.length) {
              Chunk newChunk = new Chunk(Math.min(writeChunk.data.length * 2, MAX_CHUNK_LENGTH));
              writeChunk.next = newChunk;
              writeChunk = newChunk;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,57 ***</span>
          writeChunk.size += writeBytes;
          assert writeChunk.size &lt;= writeChunk.data.length;
  
          return result;
      }
  }
  
  final class UnalignedUnsafeArrayTypeWriter extends UnsafeArrayTypeWriter {
      @Override
<span class="line-modified">!     public void putS2(long value) {</span>
<span class="line-modified">!         long offset = writeOffset(Short.BYTES);</span>
<span class="line-removed">-         UnsafeAccess.UNSAFE.putShort(writeChunk.data, offset, asS2(value));</span>
      }
  
      @Override
<span class="line-modified">!     public void putS4(long value) {</span>
<span class="line-modified">!         long offset = writeOffset(Integer.BYTES);</span>
<span class="line-removed">-         UnsafeAccess.UNSAFE.putInt(writeChunk.data, offset, asS4(value));</span>
      }
  
      @Override
<span class="line-modified">!     public void putS8(long value) {</span>
<span class="line-modified">!         long offset = writeOffset(Long.BYTES);</span>
<span class="line-removed">-         UnsafeAccess.UNSAFE.putLong(writeChunk.data, offset, value);</span>
      }
  }
  
  final class AlignedUnsafeArrayTypeWriter extends UnsafeArrayTypeWriter {
      @Override
<span class="line-modified">!     public void putS2(long value) {</span>
<span class="line-modified">!         long offset = writeOffset(Short.BYTES);</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 0, (byte) (value &gt;&gt; 0));</span>
<span class="line-removed">-         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 1, (byte) (value &gt;&gt; 8));</span>
      }
  
      @Override
<span class="line-modified">!     public void putS4(long value) {</span>
<span class="line-modified">!         long offset = writeOffset(Integer.BYTES);</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 0, (byte) (value &gt;&gt; 0));</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 1, (byte) (value &gt;&gt; 8));</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 2, (byte) (value &gt;&gt; 16));</span>
<span class="line-removed">-         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 3, (byte) (value &gt;&gt; 24));</span>
      }
  
      @Override
<span class="line-modified">!     public void putS8(long value) {</span>
<span class="line-modified">!         long offset = writeOffset(Long.BYTES);</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 0, (byte) (value &gt;&gt; 0));</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 1, (byte) (value &gt;&gt; 8));</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 2, (byte) (value &gt;&gt; 16));</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 3, (byte) (value &gt;&gt; 24));</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 4, (byte) (value &gt;&gt; 32));</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 5, (byte) (value &gt;&gt; 40));</span>
<span class="line-modified">!         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 6, (byte) (value &gt;&gt; 48));</span>
<span class="line-removed">-         UnsafeAccess.UNSAFE.putByte(writeChunk.data, offset + 7, (byte) (value &gt;&gt; 56));</span>
      }
  }
<span class="line-new-header">--- 181,107 ---</span>
          writeChunk.size += writeBytes;
          assert writeChunk.size &lt;= writeChunk.data.length;
  
          return result;
      }
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void patchS4(long value, long offset) {</span>
<span class="line-added">+         long chunkStartOffset = 0;</span>
<span class="line-added">+         Chunk chunk = firstChunk;</span>
<span class="line-added">+         while (chunkStartOffset + chunk.size &lt;= offset) {</span>
<span class="line-added">+             chunkStartOffset += chunk.size;</span>
<span class="line-added">+             chunk = chunk.next;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         long targetOffset = offset - chunkStartOffset;</span>
<span class="line-added">+         assert targetOffset + Integer.BYTES &lt;= chunk.size : &quot;out of bounds&quot;;</span>
<span class="line-added">+         putS4(value, chunk, Unsafe.ARRAY_BYTE_BASE_OFFSET + targetOffset);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void putSV(long value) {</span>
<span class="line-added">+         // this is a modified version of the SIGNED5 encoding from Pack200</span>
<span class="line-added">+         write(encodeSign(value));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void putUV(long value) {</span>
<span class="line-added">+         // this is a modified version of the UNSIGNED5 encoding from Pack200</span>
<span class="line-added">+         write(value);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static long encodeSign(long value) {</span>
<span class="line-added">+         return (value &lt;&lt; 1) ^ (value &gt;&gt; 63);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void write(long value) {</span>
<span class="line-added">+         if (UnsignedMath.belowThan(value, NUM_LOW_CODES)) {</span>
<span class="line-added">+             putU1(value);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             writePacked(value);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void writePacked(long value) {</span>
<span class="line-added">+         long sum = value;</span>
<span class="line-added">+         for (int i = 1; UnsignedMath.aboveOrEqual(sum, NUM_LOW_CODES) &amp;&amp; i &lt; MAX_BYTES; i++) {</span>
<span class="line-added">+             sum -= NUM_LOW_CODES;</span>
<span class="line-added">+             long u1 = NUM_LOW_CODES + (sum &amp; (NUM_HIGH_CODES - 1)); // this is a &quot;high code&quot;</span>
<span class="line-added">+             sum &gt;&gt;&gt;= HIGH_WORD_SHIFT; // extracted 6 bits</span>
<span class="line-added">+             putU1(u1);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // remainder is either a &quot;low code&quot; or the last byte</span>
<span class="line-added">+         assert sum == (sum &amp; 0xFF) : &quot;not a byte&quot;;</span>
<span class="line-added">+         putU1(sum &amp; 0xFF);</span>
<span class="line-added">+     }</span>
  }
  
  final class UnalignedUnsafeArrayTypeWriter extends UnsafeArrayTypeWriter {
<span class="line-added">+     private static final Unsafe UNSAFE = getUnsafe();</span>
<span class="line-added">+ </span>
      @Override
<span class="line-modified">!     protected void putS2(long value, Chunk chunk, long offset) {</span>
<span class="line-modified">!         UNSAFE.putShort(chunk.data, offset, asS2(value));</span>
      }
  
      @Override
<span class="line-modified">!     protected void putS4(long value, Chunk chunk, long offset) {</span>
<span class="line-modified">!         UNSAFE.putInt(chunk.data, offset, asS4(value));</span>
      }
  
      @Override
<span class="line-modified">!     protected void putS8(long value, Chunk chunk, long offset) {</span>
<span class="line-modified">!         UNSAFE.putLong(chunk.data, offset, value);</span>
      }
  }
  
  final class AlignedUnsafeArrayTypeWriter extends UnsafeArrayTypeWriter {
<span class="line-added">+     private static final Unsafe UNSAFE = getUnsafe();</span>
<span class="line-added">+ </span>
      @Override
<span class="line-modified">!     protected void putS2(long value, Chunk chunk, long offset) {</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 0, (byte) (value &gt;&gt; 0));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 1, (byte) (value &gt;&gt; 8));</span>
      }
  
      @Override
<span class="line-modified">!     protected void putS4(long value, Chunk chunk, long offset) {</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 0, (byte) (value &gt;&gt; 0));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 1, (byte) (value &gt;&gt; 8));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 2, (byte) (value &gt;&gt; 16));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 3, (byte) (value &gt;&gt; 24));</span>
      }
  
      @Override
<span class="line-modified">!     protected void putS8(long value, Chunk chunk, long offset) {</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 0, (byte) (value &gt;&gt; 0));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 1, (byte) (value &gt;&gt; 8));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 2, (byte) (value &gt;&gt; 16));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 3, (byte) (value &gt;&gt; 24));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 4, (byte) (value &gt;&gt; 32));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 5, (byte) (value &gt;&gt; 40));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 6, (byte) (value &gt;&gt; 48));</span>
<span class="line-modified">!         UNSAFE.putByte(chunk.data, offset + 7, (byte) (value &gt;&gt; 56));</span>
      }
  }
</pre>
<center><a href="UnsafeArrayTypeReader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="UnsignedLong.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
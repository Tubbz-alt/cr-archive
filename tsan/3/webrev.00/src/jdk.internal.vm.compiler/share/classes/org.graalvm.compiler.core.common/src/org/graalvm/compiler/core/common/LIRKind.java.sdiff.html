<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/LIRKind.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraalOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NumUtil.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/LIRKind.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 71      * The location of object references in the value. If the value is a vector type, each bit
 72      * represents one component of the vector.
 73      */
 74     private final int referenceMask;
 75 
 76     /** Mask with 1-bits indicating which references in {@link #referenceMask} are compressed. */
 77     private final int referenceCompressionMask;
 78 
 79     private AllocatableValue derivedReferenceBase;
 80 
 81     private static final int UNKNOWN_REFERENCE = -1;
 82 
 83     public static final LIRKind Illegal = unknownReference(ValueKind.Illegal.getPlatformKind());
 84 
 85     private LIRKind(PlatformKind platformKind, int referenceMask, int referenceCompressionMask, AllocatableValue derivedReferenceBase) {
 86         super(platformKind);
 87         this.referenceMask = referenceMask;
 88         this.referenceCompressionMask = referenceCompressionMask;
 89         this.derivedReferenceBase = derivedReferenceBase;
 90 
<span class="line-modified"> 91         assert this.referenceCompressionMask == 0 || this.referenceMask == this.referenceCompressionMask : &quot;mixing compressed and uncompressed references is untested&quot;;</span>
 92         assert derivedReferenceBase == null || !derivedReferenceBase.getValueKind(LIRKind.class).isDerivedReference() : &quot;derived reference can&#39;t have another derived reference as base&quot;;
 93     }
 94 
 95     /**
 96      * Create a {@link LIRKind} of type {@code platformKind} that contains a primitive value. Should
 97      * be only used when it&#39;s guaranteed that the value is not even indirectly derived from a
 98      * reference. Otherwise, {@link #combine(Value...)} should be used instead.
 99      */
100     public static LIRKind value(PlatformKind platformKind) {
101         return new LIRKind(platformKind, 0, 0, null);
102     }
103 
104     /**
105      * Create a {@link LIRKind} of type {@code platformKind} that contains a single, tracked,
106      * uncompressed oop reference.
107      */
108     public static LIRKind reference(PlatformKind platformKind) {
109         return derivedReference(platformKind, null, false);
110     }
111 
</pre>
<hr />
<pre>
404      *
405      * @param idx The index into the vector if this is a vector kind. Must be 0 if this is a scalar
406      *            kind.
407      */
408     public boolean isReference(int idx) {
409         assert 0 &lt;= idx &amp;&amp; idx &lt; getPlatformKind().getVectorLength() : &quot;invalid index &quot; + idx + &quot; in &quot; + this;
410         return !isUnknownReference() &amp;&amp; (referenceMask &amp; 1 &lt;&lt; idx) != 0;
411     }
412 
413     /**
414      * Check whether the {@code idx}th part of this value is a &lt;b&gt;compressed&lt;/b&gt; reference.
415      *
416      * @param idx The index into the vector if this is a vector kind. Must be 0 if this is a scalar
417      *            kind.
418      */
419     public boolean isCompressedReference(int idx) {
420         assert 0 &lt;= idx &amp;&amp; idx &lt; getPlatformKind().getVectorLength() : &quot;invalid index &quot; + idx + &quot; in &quot; + this;
421         return !isUnknownReference() &amp;&amp; (referenceCompressionMask &amp; (1 &lt;&lt; idx)) != 0;
422     }
423 
















424     /**
425      * Check whether this kind is a value type that doesn&#39;t need to be tracked at safepoints.
426      */
427     public boolean isValue() {
428         return referenceMask == 0;
429     }
430 
431     public static boolean isValue(ValueKind&lt;?&gt; kind) {
432         if (kind instanceof LIRKind) {
433             return ((LIRKind) kind).isValue();
434         } else {
435             return false;
436         }
437     }
438 
439     public static boolean isValue(Value value) {
440         return isValue(value.getValueKind());
441     }
442 
443     @Override
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 71      * The location of object references in the value. If the value is a vector type, each bit
 72      * represents one component of the vector.
 73      */
 74     private final int referenceMask;
 75 
 76     /** Mask with 1-bits indicating which references in {@link #referenceMask} are compressed. */
 77     private final int referenceCompressionMask;
 78 
 79     private AllocatableValue derivedReferenceBase;
 80 
 81     private static final int UNKNOWN_REFERENCE = -1;
 82 
 83     public static final LIRKind Illegal = unknownReference(ValueKind.Illegal.getPlatformKind());
 84 
 85     private LIRKind(PlatformKind platformKind, int referenceMask, int referenceCompressionMask, AllocatableValue derivedReferenceBase) {
 86         super(platformKind);
 87         this.referenceMask = referenceMask;
 88         this.referenceCompressionMask = referenceCompressionMask;
 89         this.derivedReferenceBase = derivedReferenceBase;
 90 
<span class="line-modified"> 91         assert this.referenceCompressionMask == 0 || this.referenceMask == this.referenceCompressionMask : &quot;mixing compressed and uncompressed references is unsupported&quot;;</span>
 92         assert derivedReferenceBase == null || !derivedReferenceBase.getValueKind(LIRKind.class).isDerivedReference() : &quot;derived reference can&#39;t have another derived reference as base&quot;;
 93     }
 94 
 95     /**
 96      * Create a {@link LIRKind} of type {@code platformKind} that contains a primitive value. Should
 97      * be only used when it&#39;s guaranteed that the value is not even indirectly derived from a
 98      * reference. Otherwise, {@link #combine(Value...)} should be used instead.
 99      */
100     public static LIRKind value(PlatformKind platformKind) {
101         return new LIRKind(platformKind, 0, 0, null);
102     }
103 
104     /**
105      * Create a {@link LIRKind} of type {@code platformKind} that contains a single, tracked,
106      * uncompressed oop reference.
107      */
108     public static LIRKind reference(PlatformKind platformKind) {
109         return derivedReference(platformKind, null, false);
110     }
111 
</pre>
<hr />
<pre>
404      *
405      * @param idx The index into the vector if this is a vector kind. Must be 0 if this is a scalar
406      *            kind.
407      */
408     public boolean isReference(int idx) {
409         assert 0 &lt;= idx &amp;&amp; idx &lt; getPlatformKind().getVectorLength() : &quot;invalid index &quot; + idx + &quot; in &quot; + this;
410         return !isUnknownReference() &amp;&amp; (referenceMask &amp; 1 &lt;&lt; idx) != 0;
411     }
412 
413     /**
414      * Check whether the {@code idx}th part of this value is a &lt;b&gt;compressed&lt;/b&gt; reference.
415      *
416      * @param idx The index into the vector if this is a vector kind. Must be 0 if this is a scalar
417      *            kind.
418      */
419     public boolean isCompressedReference(int idx) {
420         assert 0 &lt;= idx &amp;&amp; idx &lt; getPlatformKind().getVectorLength() : &quot;invalid index &quot; + idx + &quot; in &quot; + this;
421         return !isUnknownReference() &amp;&amp; (referenceCompressionMask &amp; (1 &lt;&lt; idx)) != 0;
422     }
423 
<span class="line-added">424     /**</span>
<span class="line-added">425      * Check whether the given kind is a scalar (i.e., vector length 1) &lt;b&gt;compressed&lt;/b&gt; reference.</span>
<span class="line-added">426      *</span>
<span class="line-added">427      * @param kind The kind to be checked.</span>
<span class="line-added">428      * @return true if the given kind is a scalar compressed reference</span>
<span class="line-added">429      */</span>
<span class="line-added">430     public static boolean isScalarCompressedReference(ValueKind&lt;?&gt; kind) {</span>
<span class="line-added">431         if (kind instanceof LIRKind) {</span>
<span class="line-added">432             LIRKind lirKind = (LIRKind) kind;</span>
<span class="line-added">433             if (lirKind.getPlatformKind().getVectorLength() == 1 &amp;&amp; lirKind.isCompressedReference(0)) {</span>
<span class="line-added">434                 return true;</span>
<span class="line-added">435             }</span>
<span class="line-added">436         }</span>
<span class="line-added">437         return false;</span>
<span class="line-added">438     }</span>
<span class="line-added">439 </span>
440     /**
441      * Check whether this kind is a value type that doesn&#39;t need to be tracked at safepoints.
442      */
443     public boolean isValue() {
444         return referenceMask == 0;
445     }
446 
447     public static boolean isValue(ValueKind&lt;?&gt; kind) {
448         if (kind instanceof LIRKind) {
449             return ((LIRKind) kind).isValue();
450         } else {
451             return false;
452         }
453     }
454 
455     public static boolean isValue(Value value) {
456         return isValue(value.getValueKind());
457     }
458 
459     @Override
</pre>
</td>
</tr>
</table>
<center><a href="GraalOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NumUtil.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/NumUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.common;
 26 
 27 // JaCoCo Exclude
 28 
 29 import jdk.vm.ci.code.CodeUtil;
 30 
 31 /**
 32  * A collection of static utility functions that check ranges of numbers.
 33  */
 34 public class NumUtil {
 35 
 36     public static boolean isShiftCount(int x) {
 37         return 0 &lt;= x &amp;&amp; x &lt; 32;
 38     }
 39 
 40     /**
 41      * Determines if a given {@code int} value is the range of unsigned byte values.
 42      */
 43     public static boolean isUByte(int x) {
 44         return (x &amp; 0xff) == x;
 45     }
 46 
 47     /**
 48      * Determines if a given {@code int} value is the range of signed byte values.
 49      */
 50     public static boolean isByte(int x) {
 51         return (byte) x == x;
 52     }
 53 
 54     /**
 55      * Determines if a given {@code long} value is the range of unsigned byte values.
 56      */
 57     public static boolean isUByte(long x) {
 58         return (x &amp; 0xffL) == x;
 59     }
 60 
 61     /**
 62      * Determines if a given {@code long} value is the range of signed byte values.
 63      */
 64     public static boolean isByte(long l) {
 65         return (byte) l == l;
 66     }
 67 
 68     /**
 69      * Determines if a given {@code long} value is the range of unsigned int values.
 70      */
 71     public static boolean isUInt(long x) {
 72         return (x &amp; 0xffffffffL) == x;
 73     }
 74 
 75     /**
 76      * Determines if a given {@code long} value is the range of signed int values.
 77      */
 78     public static boolean isInt(long l) {
 79         return (int) l == l;
 80     }
 81 
 82     /**
 83      * Determines if a given {@code int} value is the range of signed short values.
 84      */
 85     public static boolean isShort(int x) {
 86         return (short) x == x;
 87     }
 88 
 89     /**
 90      * Determines if a given {@code long} value is the range of signed short values.
 91      */
 92     public static boolean isShort(long x) {
 93         return (short) x == x;
 94     }
 95 
 96     public static boolean isUShort(int s) {
 97         return s == (s &amp; 0xFFFF);
 98     }
 99 
100     public static boolean isUShort(long s) {
101         return s == (s &amp; 0xFFFF);
102     }
103 
104     public static boolean is32bit(long x) {
105         return -0x80000000L &lt;= x &amp;&amp; x &lt; 0x80000000L;
106     }
107 
<a name="2" id="anc2"></a>




108     public static short safeToShort(int v) {
109         assert isShort(v);
110         return (short) v;
111     }
112 
113     public static int safeToInt(long v) {
114         assert isInt(v);
115         return (int) v;
116     }
117 
118     public static int roundUp(int number, int mod) {
119         return ((number + mod - 1) / mod) * mod;
120     }
121 
122     public static long roundUp(long number, long mod) {
123         return ((number + mod - 1L) / mod) * mod;
124     }
125 
126     public static int roundDown(int number, int mod) {
127         return number / mod * mod;
128     }
129 
130     public static long roundDown(long number, long mod) {
131         return number / mod * mod;
132     }
133 
134     public static int log2Ceil(int val) {
135         int x = 1;
136         int log2 = 0;
137         while (x &lt; val) {
138             log2++;
139             x *= 2;
140         }
141         return log2;
142     }
143 
144     public static boolean isUnsignedNbit(int n, int value) {
145         assert n &gt; 0 &amp;&amp; n &lt; 32;
146         return 32 - Integer.numberOfLeadingZeros(value) &lt;= n;
147     }
148 
149     public static boolean isUnsignedNbit(int n, long value) {
150         assert n &gt; 0 &amp;&amp; n &lt; 64;
151         return 64 - Long.numberOfLeadingZeros(value) &lt;= n;
152     }
153 
154     public static boolean isSignedNbit(int n, int value) {
155         assert n &gt; 0 &amp;&amp; n &lt; 32;
156         int min = -(1 &lt;&lt; (n - 1));
157         int max = (1 &lt;&lt; (n - 1)) - 1;
158         return value &gt;= min &amp;&amp; value &lt;= max;
159     }
160 
161     public static boolean isSignedNbit(int n, long value) {
162         assert n &gt; 0 &amp;&amp; n &lt; 64;
163         long min = -(1L &lt;&lt; (n - 1));
164         long max = (1L &lt;&lt; (n - 1)) - 1;
165         return value &gt;= min &amp;&amp; value &lt;= max;
166     }
167 
168     /**
169      *
170      * @param n Number of bits that should be set to 1. Must be between 0 and 32 (inclusive).
171      * @return A number with n bits set to 1.
172      */
173     public static int getNbitNumberInt(int n) {
174         assert n &gt;= 0 &amp;&amp; n &lt;= 32 : &quot;0 &lt;= n &lt;= 32; instead: &quot; + n;
175         if (n &lt; 32) {
176             return (1 &lt;&lt; n) - 1;
177         } else {
178             return 0xFFFFFFFF;
179         }
180     }
181 
182     /**
183      *
184      * @param n Number of bits that should be set to 1. Must be between 0 and 64 (inclusive).
185      * @return A number with n bits set to 1.
186      */
187     public static long getNbitNumberLong(int n) {
188         assert n &gt;= 0 &amp;&amp; n &lt;= 64;
189         if (n &lt; 64) {
190             return (1L &lt;&lt; n) - 1;
191         } else {
192             return 0xFFFFFFFFFFFFFFFFL;
193         }
194     }
195 
196     /**
197      * Get the minimum value representable in a {@code bits} bit signed integer.
198      */
199     public static long minValue(int bits) {
200         return CodeUtil.minValue(bits);
201     }
202 
203     /**
204      * Get the maximum value representable in a {@code bits} bit signed integer.
205      */
206     public static long maxValue(int bits) {
207         return CodeUtil.maxValue(bits);
208     }
209 
210     /**
211      * Get the maximum value representable in a {@code bits} bit unsigned integer.
212      */
213     public static long maxValueUnsigned(int bits) {
214         return getNbitNumberLong(bits);
215     }
216 
217     public static long maxUnsigned(long a, long b) {
218         if (Long.compareUnsigned(a, b) &lt; 0) {
219             return b;
220         }
221         return a;
222     }
223 
224     public static long minUnsigned(long a, long b) {
225         if (Long.compareUnsigned(a, b) &lt; 0) {
226             return a;
227         }
228         return b;
229     }
230 
231     public static boolean sameSign(long a, long b) {
232         return a &lt; 0 == b &lt; 0;
233     }
234 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
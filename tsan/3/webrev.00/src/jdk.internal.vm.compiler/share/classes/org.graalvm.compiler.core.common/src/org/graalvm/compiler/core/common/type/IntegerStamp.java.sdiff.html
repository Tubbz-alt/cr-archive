<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/IntegerStamp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IllegalStamp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PrimitiveStamp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/IntegerStamp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 150         }
 151     }
 152 
 153     public static IntegerStamp stampForMask(int bits, long downMask, long upMask) {
 154         return new IntegerStamp(bits, minValueForMasks(bits, downMask, upMask), maxValueForMasks(bits, downMask, upMask), downMask, upMask);
 155     }
 156 
 157     @Override
 158     public IntegerStamp unrestricted() {
 159         return new IntegerStamp(getBits(), CodeUtil.minValue(getBits()), CodeUtil.maxValue(getBits()), 0, CodeUtil.mask(getBits()));
 160     }
 161 
 162     @Override
 163     public IntegerStamp empty() {
 164         return new IntegerStamp(getBits(), CodeUtil.maxValue(getBits()), CodeUtil.minValue(getBits()), CodeUtil.mask(getBits()), 0);
 165     }
 166 
 167     @Override
 168     public Stamp constant(Constant c, MetaAccessProvider meta) {
 169         if (c instanceof PrimitiveConstant) {
<span class="line-modified"> 170             long value = ((PrimitiveConstant) c).asLong();</span>
<span class="line-modified"> 171             return StampFactory.forInteger(getBits(), value, value);</span>







 172         }
 173         return this;
 174     }
 175 
 176     @Override
 177     public SerializableConstant deserialize(ByteBuffer buffer) {
 178         switch (getBits()) {
 179             case 1:
 180                 return JavaConstant.forBoolean(buffer.get() != 0);
 181             case 8:
 182                 return JavaConstant.forByte(buffer.get());
 183             case 16:
 184                 return JavaConstant.forShort(buffer.getShort());
 185             case 32:
 186                 return JavaConstant.forInt(buffer.getInt());
 187             case 64:
 188                 return JavaConstant.forLong(buffer.getLong());
 189             default:
 190                 throw GraalError.shouldNotReachHere();
 191         }
</pre>
<hr />
<pre>
 626                         @Override
 627                         public Constant foldConstant(Constant const1, Constant const2) {
 628                             PrimitiveConstant a = (PrimitiveConstant) const1;
 629                             PrimitiveConstant b = (PrimitiveConstant) const2;
 630                             assert a.getJavaKind() == b.getJavaKind();
 631                             return JavaConstant.forIntegerKind(a.getJavaKind(), a.asLong() + b.asLong());
 632                         }
 633 
 634                         @Override
 635                         public Stamp foldStamp(Stamp stamp1, Stamp stamp2) {
 636                             if (stamp1.isEmpty()) {
 637                                 return stamp1;
 638                             }
 639                             if (stamp2.isEmpty()) {
 640                                 return stamp2;
 641                             }
 642                             IntegerStamp a = (IntegerStamp) stamp1;
 643                             IntegerStamp b = (IntegerStamp) stamp2;
 644 
 645                             int bits = a.getBits();
<span class="line-modified"> 646                             assert bits == b.getBits();</span>
 647 
 648                             if (a.lowerBound == a.upperBound &amp;&amp; b.lowerBound == b.upperBound) {
 649                                 long value = CodeUtil.convert(a.lowerBound() + b.lowerBound(), a.getBits(), false);
 650                                 return StampFactory.forInteger(a.getBits(), value, value);
 651                             }
 652 
 653                             if (a.isUnrestricted()) {
 654                                 return a;
 655                             } else if (b.isUnrestricted()) {
 656                                 return b;
 657                             }
 658                             long defaultMask = CodeUtil.mask(bits);
 659                             long variableBits = (a.downMask() ^ a.upMask()) | (b.downMask() ^ b.upMask());
 660                             long variableBitsWithCarry = variableBits | (carryBits(a.downMask(), b.downMask()) ^ carryBits(a.upMask(), b.upMask()));
 661                             long newDownMask = (a.downMask() + b.downMask()) &amp; ~variableBitsWithCarry;
 662                             long newUpMask = (a.downMask() + b.downMask()) | variableBitsWithCarry;
 663 
 664                             newDownMask &amp;= defaultMask;
 665                             newUpMask &amp;= defaultMask;
 666 
</pre>
<hr />
<pre>
1281                             IntegerStamp stamp = (IntegerStamp) s;
1282                             return JavaConstant.forPrimitiveInt(stamp.getBits(), 0);
1283                         }
1284                     },
1285 
1286                     new ShiftOp.Shl() {
1287 
1288                         @Override
1289                         public Constant foldConstant(Constant value, int amount) {
1290                             PrimitiveConstant c = (PrimitiveConstant) value;
1291                             switch (c.getJavaKind()) {
1292                                 case Int:
1293                                     return JavaConstant.forInt(c.asInt() &lt;&lt; amount);
1294                                 case Long:
1295                                     return JavaConstant.forLong(c.asLong() &lt;&lt; amount);
1296                                 default:
1297                                     throw GraalError.shouldNotReachHere();
1298                             }
1299                         }
1300 









1301                         @Override
1302                         public Stamp foldStamp(Stamp stamp, IntegerStamp shift) {
1303                             IntegerStamp value = (IntegerStamp) stamp;
1304                             int bits = value.getBits();
1305                             if (value.isEmpty()) {
1306                                 return value;
1307                             } else if (shift.isEmpty()) {
1308                                 return StampFactory.forInteger(bits).empty();
1309                             } else if (value.upMask() == 0) {
1310                                 return value;
1311                             }
1312 
1313                             int shiftMask = getShiftAmountMask(stamp);
1314                             int shiftBits = Integer.bitCount(shiftMask);
1315                             if (shift.lowerBound() == shift.upperBound()) {
1316                                 int shiftAmount = (int) (shift.lowerBound() &amp; shiftMask);
1317                                 if (shiftAmount == 0) {
1318                                     return value;
1319                                 }
1320                                 // the mask of bits that will be lost or shifted into the sign bit
<span class="line-modified">1321                                 long removedBits = -1L &lt;&lt; (bits - shiftAmount - 1);</span>
<span class="line-removed">1322                                 if ((value.lowerBound() &amp; removedBits) == 0 &amp;&amp; (value.upperBound() &amp; removedBits) == 0) {</span>
1323                                     /*
1324                                      * use a better stamp if neither lower nor upper bound can lose
1325                                      * bits
1326                                      */
<span class="line-modified">1327                                     return new IntegerStamp(bits, value.lowerBound() &lt;&lt; shiftAmount, value.upperBound() &lt;&lt; shiftAmount, value.downMask() &lt;&lt; shiftAmount, value.upMask() &lt;&lt; shiftAmount);</span>



1328                                 }
1329                             }
1330                             if ((shift.lowerBound() &gt;&gt;&gt; shiftBits) == (shift.upperBound() &gt;&gt;&gt; shiftBits)) {
1331                                 long defaultMask = CodeUtil.mask(bits);
1332                                 long downMask = defaultMask;
1333                                 long upMask = 0;
1334                                 for (long i = shift.lowerBound(); i &lt;= shift.upperBound(); i++) {
1335                                     if (shift.contains(i)) {
1336                                         downMask &amp;= value.downMask() &lt;&lt; (i &amp; shiftMask);
1337                                         upMask |= value.upMask() &lt;&lt; (i &amp; shiftMask);
1338                                     }
1339                                 }
1340                                 return IntegerStamp.stampForMask(bits, downMask, upMask &amp; defaultMask);
1341                             }
1342                             return value.unrestricted();
1343                         }
1344 
1345                         @Override
1346                         public int getShiftAmountMask(Stamp s) {
1347                             IntegerStamp stamp = (IntegerStamp) s;
</pre>
<hr />
<pre>
1577                             }
1578 
1579                             final long upperBound;
1580                             if (stamp.lowerBound() &lt; CodeUtil.minValue(resultBits)) {
1581                                 upperBound = CodeUtil.maxValue(resultBits);
1582                             } else {
1583                                 upperBound = saturate(stamp.upperBound(), resultBits);
1584                             }
1585                             final long lowerBound;
1586                             if (stamp.upperBound() &gt; CodeUtil.maxValue(resultBits)) {
1587                                 lowerBound = CodeUtil.minValue(resultBits);
1588                             } else {
1589                                 lowerBound = saturate(stamp.lowerBound(), resultBits);
1590                             }
1591 
1592                             long defaultMask = CodeUtil.mask(resultBits);
1593                             long newDownMask = stamp.downMask() &amp; defaultMask;
1594                             long newUpMask = stamp.upMask() &amp; defaultMask;
1595                             long newLowerBound = CodeUtil.signExtend((lowerBound | newDownMask) &amp; newUpMask, resultBits);
1596                             long newUpperBound = CodeUtil.signExtend((upperBound | newDownMask) &amp; newUpMask, resultBits);
<span class="line-modified">1597                             return new IntegerStamp(resultBits, newLowerBound, newUpperBound, newDownMask, newUpMask);</span>



1598                         }
1599                     },
1600 
1601                     new FloatConvertOp(I2F) {
1602 
1603                         @Override
1604                         public Constant foldConstant(Constant c) {
1605                             PrimitiveConstant value = (PrimitiveConstant) c;
1606                             return JavaConstant.forFloat(value.asInt());
1607                         }
1608 
1609                         @Override
1610                         public Stamp foldStamp(Stamp input) {
1611                             if (input.isEmpty()) {
1612                                 return StampFactory.empty(JavaKind.Float);
1613                             }
1614                             IntegerStamp stamp = (IntegerStamp) input;
1615                             assert stamp.getBits() == 32;
1616                             float lowerBound = stamp.lowerBound();
1617                             float upperBound = stamp.upperBound();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 150         }
 151     }
 152 
 153     public static IntegerStamp stampForMask(int bits, long downMask, long upMask) {
 154         return new IntegerStamp(bits, minValueForMasks(bits, downMask, upMask), maxValueForMasks(bits, downMask, upMask), downMask, upMask);
 155     }
 156 
 157     @Override
 158     public IntegerStamp unrestricted() {
 159         return new IntegerStamp(getBits(), CodeUtil.minValue(getBits()), CodeUtil.maxValue(getBits()), 0, CodeUtil.mask(getBits()));
 160     }
 161 
 162     @Override
 163     public IntegerStamp empty() {
 164         return new IntegerStamp(getBits(), CodeUtil.maxValue(getBits()), CodeUtil.minValue(getBits()), CodeUtil.mask(getBits()), 0);
 165     }
 166 
 167     @Override
 168     public Stamp constant(Constant c, MetaAccessProvider meta) {
 169         if (c instanceof PrimitiveConstant) {
<span class="line-modified"> 170             PrimitiveConstant primitiveConstant = (PrimitiveConstant) c;</span>
<span class="line-modified"> 171             long value = primitiveConstant.asLong();</span>
<span class="line-added"> 172             if (primitiveConstant.getJavaKind() == JavaKind.Boolean &amp;&amp; value == 1) {</span>
<span class="line-added"> 173                 // Need to special case booleans as integer stamps are always signed values.</span>
<span class="line-added"> 174                 value = -1;</span>
<span class="line-added"> 175             }</span>
<span class="line-added"> 176             Stamp returnedStamp = StampFactory.forInteger(getBits(), value, value);</span>
<span class="line-added"> 177             assert returnedStamp.hasValues();</span>
<span class="line-added"> 178             return returnedStamp;</span>
 179         }
 180         return this;
 181     }
 182 
 183     @Override
 184     public SerializableConstant deserialize(ByteBuffer buffer) {
 185         switch (getBits()) {
 186             case 1:
 187                 return JavaConstant.forBoolean(buffer.get() != 0);
 188             case 8:
 189                 return JavaConstant.forByte(buffer.get());
 190             case 16:
 191                 return JavaConstant.forShort(buffer.getShort());
 192             case 32:
 193                 return JavaConstant.forInt(buffer.getInt());
 194             case 64:
 195                 return JavaConstant.forLong(buffer.getLong());
 196             default:
 197                 throw GraalError.shouldNotReachHere();
 198         }
</pre>
<hr />
<pre>
 633                         @Override
 634                         public Constant foldConstant(Constant const1, Constant const2) {
 635                             PrimitiveConstant a = (PrimitiveConstant) const1;
 636                             PrimitiveConstant b = (PrimitiveConstant) const2;
 637                             assert a.getJavaKind() == b.getJavaKind();
 638                             return JavaConstant.forIntegerKind(a.getJavaKind(), a.asLong() + b.asLong());
 639                         }
 640 
 641                         @Override
 642                         public Stamp foldStamp(Stamp stamp1, Stamp stamp2) {
 643                             if (stamp1.isEmpty()) {
 644                                 return stamp1;
 645                             }
 646                             if (stamp2.isEmpty()) {
 647                                 return stamp2;
 648                             }
 649                             IntegerStamp a = (IntegerStamp) stamp1;
 650                             IntegerStamp b = (IntegerStamp) stamp2;
 651 
 652                             int bits = a.getBits();
<span class="line-modified"> 653                             assert bits == b.getBits() : String.format(&quot;stamp1.bits=%d, stamp2.bits=%d&quot;, bits, b.getBits());</span>
 654 
 655                             if (a.lowerBound == a.upperBound &amp;&amp; b.lowerBound == b.upperBound) {
 656                                 long value = CodeUtil.convert(a.lowerBound() + b.lowerBound(), a.getBits(), false);
 657                                 return StampFactory.forInteger(a.getBits(), value, value);
 658                             }
 659 
 660                             if (a.isUnrestricted()) {
 661                                 return a;
 662                             } else if (b.isUnrestricted()) {
 663                                 return b;
 664                             }
 665                             long defaultMask = CodeUtil.mask(bits);
 666                             long variableBits = (a.downMask() ^ a.upMask()) | (b.downMask() ^ b.upMask());
 667                             long variableBitsWithCarry = variableBits | (carryBits(a.downMask(), b.downMask()) ^ carryBits(a.upMask(), b.upMask()));
 668                             long newDownMask = (a.downMask() + b.downMask()) &amp; ~variableBitsWithCarry;
 669                             long newUpMask = (a.downMask() + b.downMask()) | variableBitsWithCarry;
 670 
 671                             newDownMask &amp;= defaultMask;
 672                             newUpMask &amp;= defaultMask;
 673 
</pre>
<hr />
<pre>
1288                             IntegerStamp stamp = (IntegerStamp) s;
1289                             return JavaConstant.forPrimitiveInt(stamp.getBits(), 0);
1290                         }
1291                     },
1292 
1293                     new ShiftOp.Shl() {
1294 
1295                         @Override
1296                         public Constant foldConstant(Constant value, int amount) {
1297                             PrimitiveConstant c = (PrimitiveConstant) value;
1298                             switch (c.getJavaKind()) {
1299                                 case Int:
1300                                     return JavaConstant.forInt(c.asInt() &lt;&lt; amount);
1301                                 case Long:
1302                                     return JavaConstant.forLong(c.asLong() &lt;&lt; amount);
1303                                 default:
1304                                     throw GraalError.shouldNotReachHere();
1305                             }
1306                         }
1307 
<span class="line-added">1308                         private boolean testNoSignChangeAfterShifting(int bits, long value, int shiftAmount) {</span>
<span class="line-added">1309                             long removedBits = -1L &lt;&lt; (bits - shiftAmount - 1);</span>
<span class="line-added">1310                             if (value &lt; 0) {</span>
<span class="line-added">1311                                 return (value &amp; removedBits) == removedBits;</span>
<span class="line-added">1312                             } else {</span>
<span class="line-added">1313                                 return (value &amp; removedBits) == 0;</span>
<span class="line-added">1314                             }</span>
<span class="line-added">1315                         }</span>
<span class="line-added">1316 </span>
1317                         @Override
1318                         public Stamp foldStamp(Stamp stamp, IntegerStamp shift) {
1319                             IntegerStamp value = (IntegerStamp) stamp;
1320                             int bits = value.getBits();
1321                             if (value.isEmpty()) {
1322                                 return value;
1323                             } else if (shift.isEmpty()) {
1324                                 return StampFactory.forInteger(bits).empty();
1325                             } else if (value.upMask() == 0) {
1326                                 return value;
1327                             }
1328 
1329                             int shiftMask = getShiftAmountMask(stamp);
1330                             int shiftBits = Integer.bitCount(shiftMask);
1331                             if (shift.lowerBound() == shift.upperBound()) {
1332                                 int shiftAmount = (int) (shift.lowerBound() &amp; shiftMask);
1333                                 if (shiftAmount == 0) {
1334                                     return value;
1335                                 }
1336                                 // the mask of bits that will be lost or shifted into the sign bit
<span class="line-modified">1337                                 if (testNoSignChangeAfterShifting(bits, value.lowerBound(), shiftAmount) &amp;&amp; testNoSignChangeAfterShifting(bits, value.upperBound(), shiftAmount)) {</span>

1338                                     /*
1339                                      * use a better stamp if neither lower nor upper bound can lose
1340                                      * bits
1341                                      */
<span class="line-modified">1342                                     IntegerStamp result = new IntegerStamp(bits, value.lowerBound() &lt;&lt; shiftAmount, value.upperBound() &lt;&lt; shiftAmount,</span>
<span class="line-added">1343                                                     (value.downMask() &lt;&lt; shiftAmount) &amp; CodeUtil.mask(bits),</span>
<span class="line-added">1344                                                     (value.upMask() &lt;&lt; shiftAmount) &amp; CodeUtil.mask(bits));</span>
<span class="line-added">1345                                     return result;</span>
1346                                 }
1347                             }
1348                             if ((shift.lowerBound() &gt;&gt;&gt; shiftBits) == (shift.upperBound() &gt;&gt;&gt; shiftBits)) {
1349                                 long defaultMask = CodeUtil.mask(bits);
1350                                 long downMask = defaultMask;
1351                                 long upMask = 0;
1352                                 for (long i = shift.lowerBound(); i &lt;= shift.upperBound(); i++) {
1353                                     if (shift.contains(i)) {
1354                                         downMask &amp;= value.downMask() &lt;&lt; (i &amp; shiftMask);
1355                                         upMask |= value.upMask() &lt;&lt; (i &amp; shiftMask);
1356                                     }
1357                                 }
1358                                 return IntegerStamp.stampForMask(bits, downMask, upMask &amp; defaultMask);
1359                             }
1360                             return value.unrestricted();
1361                         }
1362 
1363                         @Override
1364                         public int getShiftAmountMask(Stamp s) {
1365                             IntegerStamp stamp = (IntegerStamp) s;
</pre>
<hr />
<pre>
1595                             }
1596 
1597                             final long upperBound;
1598                             if (stamp.lowerBound() &lt; CodeUtil.minValue(resultBits)) {
1599                                 upperBound = CodeUtil.maxValue(resultBits);
1600                             } else {
1601                                 upperBound = saturate(stamp.upperBound(), resultBits);
1602                             }
1603                             final long lowerBound;
1604                             if (stamp.upperBound() &gt; CodeUtil.maxValue(resultBits)) {
1605                                 lowerBound = CodeUtil.minValue(resultBits);
1606                             } else {
1607                                 lowerBound = saturate(stamp.lowerBound(), resultBits);
1608                             }
1609 
1610                             long defaultMask = CodeUtil.mask(resultBits);
1611                             long newDownMask = stamp.downMask() &amp; defaultMask;
1612                             long newUpMask = stamp.upMask() &amp; defaultMask;
1613                             long newLowerBound = CodeUtil.signExtend((lowerBound | newDownMask) &amp; newUpMask, resultBits);
1614                             long newUpperBound = CodeUtil.signExtend((upperBound | newDownMask) &amp; newUpMask, resultBits);
<span class="line-modified">1615 </span>
<span class="line-added">1616                             IntegerStamp result = new IntegerStamp(resultBits, newLowerBound, newUpperBound, newDownMask, newUpMask);</span>
<span class="line-added">1617                             assert result.hasValues();</span>
<span class="line-added">1618                             return result;</span>
1619                         }
1620                     },
1621 
1622                     new FloatConvertOp(I2F) {
1623 
1624                         @Override
1625                         public Constant foldConstant(Constant c) {
1626                             PrimitiveConstant value = (PrimitiveConstant) c;
1627                             return JavaConstant.forFloat(value.asInt());
1628                         }
1629 
1630                         @Override
1631                         public Stamp foldStamp(Stamp input) {
1632                             if (input.isEmpty()) {
1633                                 return StampFactory.empty(JavaKind.Float);
1634                             }
1635                             IntegerStamp stamp = (IntegerStamp) input;
1636                             assert stamp.getBits() == 32;
1637                             float lowerBound = stamp.lowerBound();
1638                             float upperBound = stamp.upperBound();
</pre>
</td>
</tr>
</table>
<center><a href="IllegalStamp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PrimitiveStamp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
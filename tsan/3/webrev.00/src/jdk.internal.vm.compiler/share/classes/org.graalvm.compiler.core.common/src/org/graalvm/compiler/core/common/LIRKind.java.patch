diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/LIRKind.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/LIRKind.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/LIRKind.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/LIRKind.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -86,11 +86,11 @@
         super(platformKind);
         this.referenceMask = referenceMask;
         this.referenceCompressionMask = referenceCompressionMask;
         this.derivedReferenceBase = derivedReferenceBase;
 
-        assert this.referenceCompressionMask == 0 || this.referenceMask == this.referenceCompressionMask : "mixing compressed and uncompressed references is untested";
+        assert this.referenceCompressionMask == 0 || this.referenceMask == this.referenceCompressionMask : "mixing compressed and uncompressed references is unsupported";
         assert derivedReferenceBase == null || !derivedReferenceBase.getValueKind(LIRKind.class).isDerivedReference() : "derived reference can't have another derived reference as base";
     }
 
     /**
      * Create a {@link LIRKind} of type {@code platformKind} that contains a primitive value. Should
@@ -419,10 +419,26 @@
     public boolean isCompressedReference(int idx) {
         assert 0 <= idx && idx < getPlatformKind().getVectorLength() : "invalid index " + idx + " in " + this;
         return !isUnknownReference() && (referenceCompressionMask & (1 << idx)) != 0;
     }
 
+    /**
+     * Check whether the given kind is a scalar (i.e., vector length 1) <b>compressed</b> reference.
+     *
+     * @param kind The kind to be checked.
+     * @return true if the given kind is a scalar compressed reference
+     */
+    public static boolean isScalarCompressedReference(ValueKind<?> kind) {
+        if (kind instanceof LIRKind) {
+            LIRKind lirKind = (LIRKind) kind;
+            if (lirKind.getPlatformKind().getVectorLength() == 1 && lirKind.isCompressedReference(0)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     /**
      * Check whether this kind is a value type that doesn't need to be tracked at safepoints.
      */
     public boolean isValue() {
         return referenceMask == 0;

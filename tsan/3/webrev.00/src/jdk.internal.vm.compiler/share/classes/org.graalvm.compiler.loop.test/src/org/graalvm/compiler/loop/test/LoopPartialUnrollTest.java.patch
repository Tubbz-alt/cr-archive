diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,11 +24,13 @@
 
 package org.graalvm.compiler.loop.test;
 
 import java.util.ListIterator;
 
+import org.graalvm.compiler.api.directives.GraalDirectives;
 import org.graalvm.compiler.core.common.CompilationIdentifier;
+import org.graalvm.compiler.core.common.GraalOptions;
 import org.graalvm.compiler.core.test.GraalCompilerTest;
 import org.graalvm.compiler.debug.DebugContext;
 import org.graalvm.compiler.graph.iterators.NodeIterable;
 import org.graalvm.compiler.java.ComputeLoopFrequenciesClosure;
 import org.graalvm.compiler.loop.DefaultLoopPolicies;
@@ -60,18 +62,18 @@
 import jdk.vm.ci.meta.ResolvedJavaMethod;
 
 public class LoopPartialUnrollTest extends GraalCompilerTest {
 
     @Override
-    protected boolean checkMidTierGraph(StructuredGraph graph) {
+    protected void checkMidTierGraph(StructuredGraph graph) {
         NodeIterable<LoopBeginNode> loops = graph.getNodes().filter(LoopBeginNode.class);
         for (LoopBeginNode loop : loops) {
             if (loop.isMainLoop()) {
-                return true;
+                return;
             }
         }
-        return false;
+        fail("expected a main loop");
     }
 
     public static long sumWithEqualityLimit(int[] text) {
         long sum = 0;
         for (int i = 0; branchProbability(0.99, i != text.length); ++i) {
@@ -138,10 +140,39 @@
         }
 
         return c;
     }
 
+    @Test
+    @Ignore
+    public void testUnsignedLoopCarried() {
+        for (int i = -1; i < 64; i++) {
+            for (int j = 0; j < 64; j++) {
+                test("testUnsignedLoopCarriedSnippet", i, j);
+            }
+        }
+        test("testUnsignedLoopCarriedSnippet", -1 - 32, -1);
+        test("testUnsignedLoopCarriedSnippet", -1 - 4, -1);
+        test("testUnsignedLoopCarriedSnippet", -1 - 32, 0);
+    }
+
+    public static int testUnsignedLoopCarriedSnippet(int start, int end) {
+        int a = 0;
+        int b = 0;
+        int c = 0;
+
+        for (int i = start; branchProbability(0.99, Integer.compareUnsigned(i, end) < 0); i++) {
+            int t1 = volatileInt;
+            int t2 = a + b;
+            c = b;
+            b = a;
+            a = t1 + t2;
+        }
+
+        return c;
+    }
+
     @Test
     public void testLoopCarried2() {
         for (int i = -1; i < 64; i++) {
             for (int j = -1; j < 64; j++) {
                 test("testLoopCarried2Snippet", i, j);
@@ -214,10 +245,29 @@
     @Test
     public void testSignExtension() {
         test("testSignExtensionSnippet", 9L);
     }
 
+    public static Object objectPhi(int n) {
+        Integer v = Integer.valueOf(200);
+        GraalDirectives.blackhole(v); // Prevents PEA
+        Integer r = 1;
+
+        for (int i = 0; iterationCount(100, i < n); i++) {
+            GraalDirectives.blackhole(r); // Create a phi of two loop invariants
+            r = v;
+        }
+
+        return r;
+    }
+
+    @Test
+    public void testObjectPhi() {
+        OptionValues options = new OptionValues(getInitialOptions(), GraalOptions.LoopPeeling, false);
+        test(options, "objectPhi", 1);
+    }
+
     @Override
     protected Suites createSuites(OptionValues opts) {
         Suites suites = super.createSuites(opts).copy();
         PhaseSuite<MidTierContext> mid = suites.getMidTier();
         ListIterator<BasePhase<? super MidTierContext>> iter = mid.findPhase(LoopPartialUnrollPhase.class);
@@ -250,11 +300,11 @@
         OptionValues options = new OptionValues(getInitialOptions(), DefaultLoopPolicies.Options.UnrollMaxIterations, 2);
         StructuredGraph graph = parse(builder(method, StructuredGraph.AllowAssumptions.YES, id, options), getEagerGraphBuilderSuite());
         try (DebugContext.Scope buildScope = graph.getDebug().scope(name, method, graph)) {
             MidTierContext context = new MidTierContext(getProviders(), getTargetProvider(), OptimisticOptimizations.ALL, null);
 
-            CanonicalizerPhase canonicalizer = new CanonicalizerPhase();
+            CanonicalizerPhase canonicalizer = this.createCanonicalizerPhase();
             canonicalizer.apply(graph, context);
             new RemoveValueProxyPhase().apply(graph);
             new LoweringPhase(canonicalizer, LoweringTool.StandardLoweringStage.HIGH_TIER).apply(graph, context);
             new FloatingReadPhase().apply(graph);
             new DeadCodeEliminationPhase().apply(graph);
@@ -286,11 +336,11 @@
 
     public void testDuplicateBody(String reference, String test) {
 
         StructuredGraph referenceGraph = buildGraph(reference, false);
         StructuredGraph testGraph = buildGraph(test, true);
-        CanonicalizerPhase canonicalizer = new CanonicalizerPhase();
+        CanonicalizerPhase canonicalizer = createCanonicalizerPhase();
         canonicalizer.apply(testGraph, getDefaultMidTierContext());
         canonicalizer.apply(referenceGraph, getDefaultMidTierContext());
         assertEquals(referenceGraph, testGraph);
     }
 }

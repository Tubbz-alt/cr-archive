<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes.test/src/org/graalvm/compiler/nodes/test/PrimitiveStampBoundaryTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoopPhiCanonicalizerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ShortCircuitOrNodeTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes.test/src/org/graalvm/compiler/nodes/test/PrimitiveStampBoundaryTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 66             for (long v2 : shiftBoundaryValues) {
 67                 shiftStamps.add(IntegerStamp.create(32, Math.min(v1, v2), Math.max(v1, v2)));
 68             }
 69         }
 70         shiftStamps.add((IntegerStamp) StampFactory.empty(JavaKind.Int));
 71 
 72         integerTestStamps = new HashSet&lt;&gt;();
 73         for (long v1 : longBoundaryValues) {
 74             for (long v2 : longBoundaryValues) {
 75                 if (v2 == (int) v2 &amp;&amp; v1 == (int) v1) {
 76                     integerTestStamps.add(IntegerStamp.create(32, Math.min(v1, v2), Math.max(v1, v2)));
 77                 }
 78                 integerTestStamps.add(IntegerStamp.create(64, Math.min(v1, v2), Math.max(v1, v2)));
 79             }
 80         }
 81         integerTestStamps.add((PrimitiveStamp) StampFactory.empty(JavaKind.Int));
 82         integerTestStamps.add((PrimitiveStamp) StampFactory.empty(JavaKind.Long));
 83     }
 84 
 85     static double[] doubleBoundaryValues = {Double.NEGATIVE_INFINITY, Double.MIN_VALUE, Float.NEGATIVE_INFINITY, Float.MIN_VALUE,
<span class="line-modified"> 86                     Long.MIN_VALUE, Long.MIN_VALUE + 1, Integer.MIN_VALUE, Integer.MIN_VALUE + 1, -1, 0, 1,</span>
 87                     Integer.MAX_VALUE - 1, Integer.MAX_VALUE, Long.MAX_VALUE - 1, Long.MAX_VALUE,
 88                     Float.MAX_VALUE, Float.POSITIVE_INFINITY, Double.MAX_VALUE, Double.POSITIVE_INFINITY};
 89 
 90     static double[] doubleSpecialValues = {Double.NaN, -0.0, -0.0F, Float.NaN};
 91 
 92     static {
 93         floatTestStamps = new HashSet&lt;&gt;();
 94 
 95         for (double d1 : doubleBoundaryValues) {
 96             for (double d2 : doubleBoundaryValues) {
 97                 float f1 = (float) d2;
 98                 float f2 = (float) d1;
 99                 if (d2 == f1 &amp;&amp; d1 == f2) {
100                     generateFloatingStamps(new FloatStamp(32, Math.min(f2, f1), Math.max(f2, f1), true));
101                     generateFloatingStamps(new FloatStamp(32, Math.min(f2, f1), Math.max(f2, f1), false));
102                 }
103                 generateFloatingStamps(new FloatStamp(64, Math.min(d1, d2), Math.max(d1, d2), true));
104                 generateFloatingStamps(new FloatStamp(64, Math.min(d1, d2), Math.max(d1, d2), false));
105             }
106         }
</pre>
<hr />
<pre>
154         }
155         for (FloatConvert op : EnumSet.allOf(FloatConvert.class)) {
156             ArithmeticOpTable.FloatConvertOp floatConvert = FloatStamp.OPS.getFloatConvert(op);
157             if (floatConvert == null) {
158                 continue;
159             }
160             assert op.getCategory() == FloatConvertCategory.FloatingPointToInteger || op.getCategory() == FloatConvertCategory.FloatingPointToFloatingPoint : op;
161             testConvertBoundaryValues(floatConvert, op.getInputBits(), floatTestStamps);
162         }
163     }
164 
165     private static void testConvertBoundaryValues(ArithmeticOpTable.FloatConvertOp op, int bits, HashSet&lt;PrimitiveStamp&gt; stamps) {
166         for (PrimitiveStamp stamp : stamps) {
167             if (bits == stamp.getBits()) {
168                 Stamp lower = boundaryStamp(stamp, false);
169                 Stamp upper = boundaryStamp(stamp, true);
170                 checkConvertOperation(op, op.foldStamp(stamp), lower);
171                 checkConvertOperation(op, op.foldStamp(stamp), upper);
172             }
173         }













174     }
175 
176     private static void checkConvertOperation(ArithmeticOpTable.FloatConvertOp op, Stamp result, Stamp v1stamp) {
177         Stamp folded = op.foldStamp(v1stamp);
<span class="line-modified">178         assertTrue(folded.isEmpty() || folded.asConstant() != null, &quot;should constant fold %s %s %s&quot;, op, v1stamp, folded);</span>
179         assertTrue(result.meet(folded).equals(result), &quot;result out of range %s %s %s %s %s&quot;, op, v1stamp, folded, result, result.meet(folded));
180     }
181 
182     @Test
183     public void testShiftBoundaryValues() {
184         for (ShiftOp&lt;?&gt; op : IntegerStamp.OPS.getShiftOps()) {
185             testShiftBoundaryValues(op, integerTestStamps, shiftStamps);
186         }
187     }
188 
189     private static void testShiftBoundaryValues(ShiftOp&lt;?&gt; shiftOp, HashSet&lt;PrimitiveStamp&gt; stamps, HashSet&lt;IntegerStamp&gt; shifts) {
190         for (PrimitiveStamp testStamp : stamps) {
191             if (testStamp instanceof IntegerStamp) {
192                 IntegerStamp stamp = (IntegerStamp) testStamp;
193                 for (IntegerStamp shiftStamp : shifts) {
194                     IntegerStamp foldedStamp = (IntegerStamp) shiftOp.foldStamp(stamp, shiftStamp);
195                     if (foldedStamp.isEmpty()) {
196                         assertTrue(stamp.isEmpty() || shiftStamp.isEmpty());
197                         continue;
198                     }
199                     checkShiftOperation(stamp.getBits(), shiftOp, foldedStamp, stamp.lowerBound(), shiftStamp.lowerBound());
200                     checkShiftOperation(stamp.getBits(), shiftOp, foldedStamp, stamp.lowerBound(), shiftStamp.upperBound());
201                     checkShiftOperation(stamp.getBits(), shiftOp, foldedStamp, stamp.upperBound(), shiftStamp.lowerBound());
202                     checkShiftOperation(stamp.getBits(), shiftOp, foldedStamp, stamp.upperBound(), shiftStamp.upperBound());
203                 }
204             }
205         }
206     }
207 
208     private static void checkShiftOperation(int bits, ShiftOp&lt;?&gt; op, IntegerStamp result, long v1, long v2) {
209         IntegerStamp v1stamp = IntegerStamp.create(bits, v1, v1);
210         IntegerStamp v2stamp = IntegerStamp.create(32, v2, v2);
211         IntegerStamp folded = (IntegerStamp) op.foldStamp(v1stamp, v2stamp);
212         Constant constant = op.foldConstant(JavaConstant.forPrimitiveInt(bits, v1), (int) v2);
213         assertTrue(constant != null);
214         assertTrue(folded.asConstant() != null, &quot;should constant fold %s %s %s %s&quot;, op, v1stamp, v2stamp, folded);
215         assertTrue(result.meet(folded).equals(result), &quot;result out of range %s %s %s %s %s %s&quot;, op, v1stamp, v2stamp, folded, result, result.meet(folded));
216     }
217 
218     private static void checkBinaryOperation(ArithmeticOpTable.BinaryOp&lt;?&gt; op, Stamp result, Stamp v1stamp, Stamp v2stamp) {



219         Stamp folded = op.foldStamp(v1stamp, v2stamp);
220         if (v1stamp.isEmpty() || v2stamp.isEmpty()) {
221             assertTrue(folded.isEmpty());
222             assertTrue(v1stamp.asConstant() != null || v1stamp.isEmpty());
223             assertTrue(v2stamp.asConstant() != null || v2stamp.isEmpty());
224             return;
225         }
226         Constant constant = op.foldConstant(v1stamp.asConstant(), v2stamp.asConstant());
227         if (constant != null) {
228             assertFalse(folded.isEmpty());
229             Constant constant2 = folded.asConstant();
230             if (constant2 == null &amp;&amp; v1stamp instanceof FloatStamp) {
231                 JavaConstant c = (JavaConstant) constant;
232                 assertTrue((c.getJavaKind() == JavaKind.Double &amp;&amp; Double.isNaN(c.asDouble())) ||
233                                 (c.getJavaKind() == JavaKind.Float &amp;&amp; Float.isNaN(c.asFloat())));
234             } else {
235                 assertTrue(constant2 != null, &quot;should constant fold %s %s %s %s&quot;, op, v1stamp, v2stamp, folded);
236                 if (!constant.equals(constant2)) {
237                     op.foldConstant(v1stamp.asConstant(), v2stamp.asConstant());
238                     op.foldStamp(v1stamp, v2stamp);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 66             for (long v2 : shiftBoundaryValues) {
 67                 shiftStamps.add(IntegerStamp.create(32, Math.min(v1, v2), Math.max(v1, v2)));
 68             }
 69         }
 70         shiftStamps.add((IntegerStamp) StampFactory.empty(JavaKind.Int));
 71 
 72         integerTestStamps = new HashSet&lt;&gt;();
 73         for (long v1 : longBoundaryValues) {
 74             for (long v2 : longBoundaryValues) {
 75                 if (v2 == (int) v2 &amp;&amp; v1 == (int) v1) {
 76                     integerTestStamps.add(IntegerStamp.create(32, Math.min(v1, v2), Math.max(v1, v2)));
 77                 }
 78                 integerTestStamps.add(IntegerStamp.create(64, Math.min(v1, v2), Math.max(v1, v2)));
 79             }
 80         }
 81         integerTestStamps.add((PrimitiveStamp) StampFactory.empty(JavaKind.Int));
 82         integerTestStamps.add((PrimitiveStamp) StampFactory.empty(JavaKind.Long));
 83     }
 84 
 85     static double[] doubleBoundaryValues = {Double.NEGATIVE_INFINITY, Double.MIN_VALUE, Float.NEGATIVE_INFINITY, Float.MIN_VALUE,
<span class="line-modified"> 86                     Long.MIN_VALUE, Long.MIN_VALUE + 1, Integer.MIN_VALUE, Integer.MIN_VALUE + 1, -1, -0.0, +0.0, 1,</span>
 87                     Integer.MAX_VALUE - 1, Integer.MAX_VALUE, Long.MAX_VALUE - 1, Long.MAX_VALUE,
 88                     Float.MAX_VALUE, Float.POSITIVE_INFINITY, Double.MAX_VALUE, Double.POSITIVE_INFINITY};
 89 
 90     static double[] doubleSpecialValues = {Double.NaN, -0.0, -0.0F, Float.NaN};
 91 
 92     static {
 93         floatTestStamps = new HashSet&lt;&gt;();
 94 
 95         for (double d1 : doubleBoundaryValues) {
 96             for (double d2 : doubleBoundaryValues) {
 97                 float f1 = (float) d2;
 98                 float f2 = (float) d1;
 99                 if (d2 == f1 &amp;&amp; d1 == f2) {
100                     generateFloatingStamps(new FloatStamp(32, Math.min(f2, f1), Math.max(f2, f1), true));
101                     generateFloatingStamps(new FloatStamp(32, Math.min(f2, f1), Math.max(f2, f1), false));
102                 }
103                 generateFloatingStamps(new FloatStamp(64, Math.min(d1, d2), Math.max(d1, d2), true));
104                 generateFloatingStamps(new FloatStamp(64, Math.min(d1, d2), Math.max(d1, d2), false));
105             }
106         }
</pre>
<hr />
<pre>
154         }
155         for (FloatConvert op : EnumSet.allOf(FloatConvert.class)) {
156             ArithmeticOpTable.FloatConvertOp floatConvert = FloatStamp.OPS.getFloatConvert(op);
157             if (floatConvert == null) {
158                 continue;
159             }
160             assert op.getCategory() == FloatConvertCategory.FloatingPointToInteger || op.getCategory() == FloatConvertCategory.FloatingPointToFloatingPoint : op;
161             testConvertBoundaryValues(floatConvert, op.getInputBits(), floatTestStamps);
162         }
163     }
164 
165     private static void testConvertBoundaryValues(ArithmeticOpTable.FloatConvertOp op, int bits, HashSet&lt;PrimitiveStamp&gt; stamps) {
166         for (PrimitiveStamp stamp : stamps) {
167             if (bits == stamp.getBits()) {
168                 Stamp lower = boundaryStamp(stamp, false);
169                 Stamp upper = boundaryStamp(stamp, true);
170                 checkConvertOperation(op, op.foldStamp(stamp), lower);
171                 checkConvertOperation(op, op.foldStamp(stamp), upper);
172             }
173         }
<span class="line-added">174 </span>
<span class="line-added">175     }</span>
<span class="line-added">176 </span>
<span class="line-added">177     static void shouldConstantFold(boolean b, Stamp folded, Object o, Stamp s1) {</span>
<span class="line-added">178         assertTrue(b || (folded instanceof FloatStamp &amp;&amp; ((FloatStamp) folded).contains(0.0)), &quot;should constant fold %s %s %s&quot;, o, s1, folded);</span>
<span class="line-added">179     }</span>
<span class="line-added">180 </span>
<span class="line-added">181     private static boolean constantFloatStampMayIncludeNegativeZero(Stamp s) {</span>
<span class="line-added">182         if (s instanceof FloatStamp) {</span>
<span class="line-added">183             FloatStamp f = (FloatStamp) s;</span>
<span class="line-added">184             return Double.compare(f.lowerBound(), f.upperBound()) == 0 &amp;&amp; f.isNonNaN();</span>
<span class="line-added">185         }</span>
<span class="line-added">186         return false;</span>
187     }
188 
189     private static void checkConvertOperation(ArithmeticOpTable.FloatConvertOp op, Stamp result, Stamp v1stamp) {
190         Stamp folded = op.foldStamp(v1stamp);
<span class="line-modified">191         shouldConstantFold(folded.isEmpty() || folded.asConstant() != null, folded, op, v1stamp);</span>
192         assertTrue(result.meet(folded).equals(result), &quot;result out of range %s %s %s %s %s&quot;, op, v1stamp, folded, result, result.meet(folded));
193     }
194 
195     @Test
196     public void testShiftBoundaryValues() {
197         for (ShiftOp&lt;?&gt; op : IntegerStamp.OPS.getShiftOps()) {
198             testShiftBoundaryValues(op, integerTestStamps, shiftStamps);
199         }
200     }
201 
202     private static void testShiftBoundaryValues(ShiftOp&lt;?&gt; shiftOp, HashSet&lt;PrimitiveStamp&gt; stamps, HashSet&lt;IntegerStamp&gt; shifts) {
203         for (PrimitiveStamp testStamp : stamps) {
204             if (testStamp instanceof IntegerStamp) {
205                 IntegerStamp stamp = (IntegerStamp) testStamp;
206                 for (IntegerStamp shiftStamp : shifts) {
207                     IntegerStamp foldedStamp = (IntegerStamp) shiftOp.foldStamp(stamp, shiftStamp);
208                     if (foldedStamp.isEmpty()) {
209                         assertTrue(stamp.isEmpty() || shiftStamp.isEmpty());
210                         continue;
211                     }
212                     checkShiftOperation(stamp.getBits(), shiftOp, foldedStamp, stamp.lowerBound(), shiftStamp.lowerBound());
213                     checkShiftOperation(stamp.getBits(), shiftOp, foldedStamp, stamp.lowerBound(), shiftStamp.upperBound());
214                     checkShiftOperation(stamp.getBits(), shiftOp, foldedStamp, stamp.upperBound(), shiftStamp.lowerBound());
215                     checkShiftOperation(stamp.getBits(), shiftOp, foldedStamp, stamp.upperBound(), shiftStamp.upperBound());
216                 }
217             }
218         }
219     }
220 
221     private static void checkShiftOperation(int bits, ShiftOp&lt;?&gt; op, IntegerStamp result, long v1, long v2) {
222         IntegerStamp v1stamp = IntegerStamp.create(bits, v1, v1);
223         IntegerStamp v2stamp = IntegerStamp.create(32, v2, v2);
224         IntegerStamp folded = (IntegerStamp) op.foldStamp(v1stamp, v2stamp);
225         Constant constant = op.foldConstant(JavaConstant.forPrimitiveInt(bits, v1), (int) v2);
226         assertTrue(constant != null);
227         assertTrue(folded.asConstant() != null, &quot;should constant fold %s %s %s %s&quot;, op, v1stamp, v2stamp, folded);
228         assertTrue(result.meet(folded).equals(result), &quot;result out of range %s %s %s %s %s %s&quot;, op, v1stamp, v2stamp, folded, result, result.meet(folded));
229     }
230 
231     private static void checkBinaryOperation(ArithmeticOpTable.BinaryOp&lt;?&gt; op, Stamp result, Stamp v1stamp, Stamp v2stamp) {
<span class="line-added">232         if (constantFloatStampMayIncludeNegativeZero(v1stamp) || constantFloatStampMayIncludeNegativeZero(v2stamp)) {</span>
<span class="line-added">233             return;</span>
<span class="line-added">234         }</span>
235         Stamp folded = op.foldStamp(v1stamp, v2stamp);
236         if (v1stamp.isEmpty() || v2stamp.isEmpty()) {
237             assertTrue(folded.isEmpty());
238             assertTrue(v1stamp.asConstant() != null || v1stamp.isEmpty());
239             assertTrue(v2stamp.asConstant() != null || v2stamp.isEmpty());
240             return;
241         }
242         Constant constant = op.foldConstant(v1stamp.asConstant(), v2stamp.asConstant());
243         if (constant != null) {
244             assertFalse(folded.isEmpty());
245             Constant constant2 = folded.asConstant();
246             if (constant2 == null &amp;&amp; v1stamp instanceof FloatStamp) {
247                 JavaConstant c = (JavaConstant) constant;
248                 assertTrue((c.getJavaKind() == JavaKind.Double &amp;&amp; Double.isNaN(c.asDouble())) ||
249                                 (c.getJavaKind() == JavaKind.Float &amp;&amp; Float.isNaN(c.asFloat())));
250             } else {
251                 assertTrue(constant2 != null, &quot;should constant fold %s %s %s %s&quot;, op, v1stamp, v2stamp, folded);
252                 if (!constant.equals(constant2)) {
253                     op.foldConstant(v1stamp.asConstant(), v2stamp.asConstant());
254                     op.foldStamp(v1stamp, v2stamp);
</pre>
</td>
</tr>
</table>
<center><a href="LoopPhiCanonicalizerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ShortCircuitOrNodeTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragment.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragment.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragment.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragment.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,16 +23,15 @@
 
 
 package org.graalvm.compiler.loop;
 
 import java.util.ArrayDeque;
-import java.util.Collections;
 import java.util.Deque;
 import java.util.Iterator;
 
 import jdk.internal.vm.compiler.collections.EconomicMap;
-import org.graalvm.compiler.debug.GraalError;
+import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
 import org.graalvm.compiler.graph.Graph;
 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
 import org.graalvm.compiler.graph.Node;
 import org.graalvm.compiler.graph.NodeBitMap;
 import org.graalvm.compiler.graph.iterators.NodeIterable;
@@ -40,22 +39,19 @@
 import org.graalvm.compiler.nodes.AbstractMergeNode;
 import org.graalvm.compiler.nodes.EndNode;
 import org.graalvm.compiler.nodes.FixedNode;
 import org.graalvm.compiler.nodes.FrameState;
 import org.graalvm.compiler.nodes.GuardNode;
-import org.graalvm.compiler.nodes.GuardPhiNode;
 import org.graalvm.compiler.nodes.GuardProxyNode;
 import org.graalvm.compiler.nodes.Invoke;
+import org.graalvm.compiler.nodes.LoopBeginNode;
 import org.graalvm.compiler.nodes.LoopExitNode;
 import org.graalvm.compiler.nodes.MergeNode;
-import org.graalvm.compiler.nodes.NodeView;
 import org.graalvm.compiler.nodes.PhiNode;
 import org.graalvm.compiler.nodes.ProxyNode;
 import org.graalvm.compiler.nodes.StructuredGraph;
 import org.graalvm.compiler.nodes.ValueNode;
-import org.graalvm.compiler.nodes.ValuePhiNode;
-import org.graalvm.compiler.nodes.ValueProxyNode;
 import org.graalvm.compiler.nodes.VirtualState;
 import org.graalvm.compiler.nodes.cfg.Block;
 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 import org.graalvm.compiler.nodes.spi.NodeWithState;
@@ -197,21 +193,11 @@
         } else {
             // TODO (gd) apply fix ?
         }
     }
 
-    protected static NodeBitMap computeNodes(Graph graph, Iterable<AbstractBeginNode> blocks) {
-        return computeNodes(graph, blocks, Collections.emptyList());
-    }
-
-    protected static NodeBitMap computeNodes(Graph graph, Iterable<AbstractBeginNode> blocks, Iterable<AbstractBeginNode> earlyExits) {
-        final NodeBitMap nodes = graph.createNodeBitMap();
-        computeNodes(nodes, graph, blocks, earlyExits);
-        return nodes;
-    }
-
-    protected static void computeNodes(NodeBitMap nodes, Graph graph, Iterable<AbstractBeginNode> blocks, Iterable<AbstractBeginNode> earlyExits) {
+    protected static void computeNodes(NodeBitMap nodes, Graph graph, LoopEx loop, Iterable<AbstractBeginNode> blocks, Iterable<AbstractBeginNode> earlyExits) {
         for (AbstractBeginNode b : blocks) {
             if (b.isDeleted()) {
                 continue;
             }
 
@@ -259,29 +245,29 @@
             }
 
             for (Node n : b.getBlockNodes()) {
                 if (n instanceof CommitAllocationNode) {
                     for (VirtualObjectNode obj : ((CommitAllocationNode) n).getVirtualObjects()) {
-                        markFloating(worklist, obj, nodes, nonLoopNodes);
+                        markFloating(worklist, loop, obj, nodes, nonLoopNodes);
                     }
                 }
                 if (n instanceof MonitorEnterNode) {
-                    markFloating(worklist, ((MonitorEnterNode) n).getMonitorId(), nodes, nonLoopNodes);
+                    markFloating(worklist, loop, ((MonitorEnterNode) n).getMonitorId(), nodes, nonLoopNodes);
                 }
                 if (n instanceof AbstractMergeNode) {
                     /*
                      * Since we already marked all phi nodes as being in the loop to break cycles,
                      * we also have to iterate over their usages here.
                      */
                     for (PhiNode phi : ((AbstractMergeNode) n).phis()) {
                         for (Node usage : phi.usages()) {
-                            markFloating(worklist, usage, nodes, nonLoopNodes);
+                            markFloating(worklist, loop, usage, nodes, nonLoopNodes);
                         }
                     }
                 }
                 for (Node usage : n.usages()) {
-                    markFloating(worklist, usage, nodes, nonLoopNodes);
+                    markFloating(worklist, loop, usage, nodes, nonLoopNodes);
                 }
             }
         }
     }
 
@@ -329,14 +315,18 @@
         WorkListEntry entry = new WorkListEntry(node, loopNodes);
         assert !workList.contains(entry) : "node " + node + " added to worklist twice";
         workList.push(entry);
     }
 
-    private static void markFloating(Deque<WorkListEntry> workList, Node start, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {
+    private static void markFloating(Deque<WorkListEntry> workList, LoopEx loop, Node start, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {
         if (isLoopNode(start, loopNodes, nonLoopNodes).isKnown()) {
             return;
         }
+
+        LoopBeginNode loopBeginNode = loop.loopBegin();
+        ControlFlowGraph cfg = loop.loopsData().getCFG();
+
         pushWorkList(workList, start, loopNodes);
         while (!workList.isEmpty()) {
             WorkListEntry currentEntry = workList.peek();
             if (currentEntry.usages.hasNext()) {
                 Node current = currentEntry.usages.next();
@@ -350,17 +340,30 @@
                 }
             } else {
                 workList.pop();
                 boolean isLoopNode = currentEntry.isLoopNode;
                 Node current = currentEntry.n;
-                if (!isLoopNode && current instanceof GuardNode) {
-                    /*
-                     * (gd) this is only OK if we are not going to make loop transforms based on
-                     * this
-                     */
-                    assert !((GuardNode) current).graph().hasValueProxies();
-                    isLoopNode = true;
+                if (!isLoopNode && current instanceof GuardNode && !current.hasUsages()) {
+                    GuardNode guard = (GuardNode) current;
+                    if (isLoopNode(guard.getCondition(), loopNodes, nonLoopNodes) != TriState.FALSE) {
+                        ValueNode anchor = guard.getAnchor().asNode();
+                        TriState isAnchorInLoop = isLoopNode(anchor, loopNodes, nonLoopNodes);
+                        if (isAnchorInLoop != TriState.FALSE) {
+                            if (!(anchor instanceof LoopExitNode && ((LoopExitNode) anchor).loopBegin() == loopBeginNode)) {
+                                // It is undecidable whether the node is in the loop or not. This is
+                                // not an issue for getting counted loop information,
+                                // but causes issues when using the information for actual loop
+                                // transformations. This is why a loop transformation must
+                                // not happen while guards are floating.
+                                isLoopNode = true;
+                            }
+                        } else if (AbstractControlFlowGraph.strictlyDominates(cfg.blockFor(anchor), cfg.blockFor(loopBeginNode))) {
+                            // The anchor is above the loop. The no-usage guard can potentially be
+                            // scheduled inside the loop.
+                            isLoopNode = true;
+                        }
+                    }
                 }
                 if (isLoopNode) {
                     loopNodes.mark(current);
                     for (WorkListEntry e : workList) {
                         e.isLoopNode = true;
@@ -465,18 +468,11 @@
                         continue;
                     }
                     final ValueNode replaceWith;
                     ValueNode newVpn = prim(newEarlyExitIsLoopExit ? vpn : vpn.value());
                     if (newVpn != null) {
-                        PhiNode phi;
-                        if (vpn instanceof ValueProxyNode) {
-                            phi = graph.addWithoutUnique(new ValuePhiNode(vpn.stamp(NodeView.DEFAULT), merge));
-                        } else if (vpn instanceof GuardProxyNode) {
-                            phi = graph.addWithoutUnique(new GuardPhiNode(merge));
-                        } else {
-                            throw GraalError.shouldNotReachHere();
-                        }
+                        PhiNode phi = vpn.createPhi(merge);
                         phi.addInput(vpn);
                         phi.addInput(newVpn);
                         replaceWith = phi;
                     } else {
                         replaceWith = vpn.value();

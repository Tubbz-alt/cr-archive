<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoopEx.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragmentInside.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,16 ***</span>
  
  
  package org.graalvm.compiler.loop;
  
  import java.util.ArrayDeque;
<span class="line-removed">- import java.util.Collections;</span>
  import java.util.Deque;
  import java.util.Iterator;
  
  import jdk.internal.vm.compiler.collections.EconomicMap;
<span class="line-modified">! import org.graalvm.compiler.debug.GraalError;</span>
  import org.graalvm.compiler.graph.Graph;
  import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeBitMap;
  import org.graalvm.compiler.graph.iterators.NodeIterable;
<span class="line-new-header">--- 23,15 ---</span>
  
  
  package org.graalvm.compiler.loop;
  
  import java.util.ArrayDeque;
  import java.util.Deque;
  import java.util.Iterator;
  
  import jdk.internal.vm.compiler.collections.EconomicMap;
<span class="line-modified">! import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;</span>
  import org.graalvm.compiler.graph.Graph;
  import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeBitMap;
  import org.graalvm.compiler.graph.iterators.NodeIterable;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,22 ***</span>
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.EndNode;
  import org.graalvm.compiler.nodes.FixedNode;
  import org.graalvm.compiler.nodes.FrameState;
  import org.graalvm.compiler.nodes.GuardNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.GuardPhiNode;</span>
  import org.graalvm.compiler.nodes.GuardProxyNode;
  import org.graalvm.compiler.nodes.Invoke;
  import org.graalvm.compiler.nodes.LoopExitNode;
  import org.graalvm.compiler.nodes.MergeNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.NodeView;</span>
  import org.graalvm.compiler.nodes.PhiNode;
  import org.graalvm.compiler.nodes.ProxyNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.ValuePhiNode;</span>
<span class="line-removed">- import org.graalvm.compiler.nodes.ValueProxyNode;</span>
  import org.graalvm.compiler.nodes.VirtualState;
  import org.graalvm.compiler.nodes.cfg.Block;
  import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  import org.graalvm.compiler.nodes.java.MonitorEnterNode;
  import org.graalvm.compiler.nodes.spi.NodeWithState;
<span class="line-new-header">--- 39,19 ---</span>
  import org.graalvm.compiler.nodes.AbstractMergeNode;
  import org.graalvm.compiler.nodes.EndNode;
  import org.graalvm.compiler.nodes.FixedNode;
  import org.graalvm.compiler.nodes.FrameState;
  import org.graalvm.compiler.nodes.GuardNode;
  import org.graalvm.compiler.nodes.GuardProxyNode;
  import org.graalvm.compiler.nodes.Invoke;
<span class="line-added">+ import org.graalvm.compiler.nodes.LoopBeginNode;</span>
  import org.graalvm.compiler.nodes.LoopExitNode;
  import org.graalvm.compiler.nodes.MergeNode;
  import org.graalvm.compiler.nodes.PhiNode;
  import org.graalvm.compiler.nodes.ProxyNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.VirtualState;
  import org.graalvm.compiler.nodes.cfg.Block;
  import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  import org.graalvm.compiler.nodes.java.MonitorEnterNode;
  import org.graalvm.compiler.nodes.spi.NodeWithState;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 197,21 ***</span>
          } else {
              // TODO (gd) apply fix ?
          }
      }
  
<span class="line-modified">!     protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode&gt; blocks) {</span>
<span class="line-removed">-         return computeNodes(graph, blocks, Collections.emptyList());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;AbstractBeginNode&gt; earlyExits) {</span>
<span class="line-removed">-         final NodeBitMap nodes = graph.createNodeBitMap();</span>
<span class="line-removed">-         computeNodes(nodes, graph, blocks, earlyExits);</span>
<span class="line-removed">-         return nodes;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     protected static void computeNodes(NodeBitMap nodes, Graph graph, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;AbstractBeginNode&gt; earlyExits) {</span>
          for (AbstractBeginNode b : blocks) {
              if (b.isDeleted()) {
                  continue;
              }
  
<span class="line-new-header">--- 193,11 ---</span>
          } else {
              // TODO (gd) apply fix ?
          }
      }
  
<span class="line-modified">!     protected static void computeNodes(NodeBitMap nodes, Graph graph, LoopEx loop, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;AbstractBeginNode&gt; earlyExits) {</span>
          for (AbstractBeginNode b : blocks) {
              if (b.isDeleted()) {
                  continue;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,29 ***</span>
              }
  
              for (Node n : b.getBlockNodes()) {
                  if (n instanceof CommitAllocationNode) {
                      for (VirtualObjectNode obj : ((CommitAllocationNode) n).getVirtualObjects()) {
<span class="line-modified">!                         markFloating(worklist, obj, nodes, nonLoopNodes);</span>
                      }
                  }
                  if (n instanceof MonitorEnterNode) {
<span class="line-modified">!                     markFloating(worklist, ((MonitorEnterNode) n).getMonitorId(), nodes, nonLoopNodes);</span>
                  }
                  if (n instanceof AbstractMergeNode) {
                      /*
                       * Since we already marked all phi nodes as being in the loop to break cycles,
                       * we also have to iterate over their usages here.
                       */
                      for (PhiNode phi : ((AbstractMergeNode) n).phis()) {
                          for (Node usage : phi.usages()) {
<span class="line-modified">!                             markFloating(worklist, usage, nodes, nonLoopNodes);</span>
                          }
                      }
                  }
                  for (Node usage : n.usages()) {
<span class="line-modified">!                     markFloating(worklist, usage, nodes, nonLoopNodes);</span>
                  }
              }
          }
      }
  
<span class="line-new-header">--- 245,29 ---</span>
              }
  
              for (Node n : b.getBlockNodes()) {
                  if (n instanceof CommitAllocationNode) {
                      for (VirtualObjectNode obj : ((CommitAllocationNode) n).getVirtualObjects()) {
<span class="line-modified">!                         markFloating(worklist, loop, obj, nodes, nonLoopNodes);</span>
                      }
                  }
                  if (n instanceof MonitorEnterNode) {
<span class="line-modified">!                     markFloating(worklist, loop, ((MonitorEnterNode) n).getMonitorId(), nodes, nonLoopNodes);</span>
                  }
                  if (n instanceof AbstractMergeNode) {
                      /*
                       * Since we already marked all phi nodes as being in the loop to break cycles,
                       * we also have to iterate over their usages here.
                       */
                      for (PhiNode phi : ((AbstractMergeNode) n).phis()) {
                          for (Node usage : phi.usages()) {
<span class="line-modified">!                             markFloating(worklist, loop, usage, nodes, nonLoopNodes);</span>
                          }
                      }
                  }
                  for (Node usage : n.usages()) {
<span class="line-modified">!                     markFloating(worklist, loop, usage, nodes, nonLoopNodes);</span>
                  }
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 329,14 ***</span>
          WorkListEntry entry = new WorkListEntry(node, loopNodes);
          assert !workList.contains(entry) : &quot;node &quot; + node + &quot; added to worklist twice&quot;;
          workList.push(entry);
      }
  
<span class="line-modified">!     private static void markFloating(Deque&lt;WorkListEntry&gt; workList, Node start, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {</span>
          if (isLoopNode(start, loopNodes, nonLoopNodes).isKnown()) {
              return;
          }
          pushWorkList(workList, start, loopNodes);
          while (!workList.isEmpty()) {
              WorkListEntry currentEntry = workList.peek();
              if (currentEntry.usages.hasNext()) {
                  Node current = currentEntry.usages.next();
<span class="line-new-header">--- 315,18 ---</span>
          WorkListEntry entry = new WorkListEntry(node, loopNodes);
          assert !workList.contains(entry) : &quot;node &quot; + node + &quot; added to worklist twice&quot;;
          workList.push(entry);
      }
  
<span class="line-modified">!     private static void markFloating(Deque&lt;WorkListEntry&gt; workList, LoopEx loop, Node start, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {</span>
          if (isLoopNode(start, loopNodes, nonLoopNodes).isKnown()) {
              return;
          }
<span class="line-added">+ </span>
<span class="line-added">+         LoopBeginNode loopBeginNode = loop.loopBegin();</span>
<span class="line-added">+         ControlFlowGraph cfg = loop.loopsData().getCFG();</span>
<span class="line-added">+ </span>
          pushWorkList(workList, start, loopNodes);
          while (!workList.isEmpty()) {
              WorkListEntry currentEntry = workList.peek();
              if (currentEntry.usages.hasNext()) {
                  Node current = currentEntry.usages.next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,17 ***</span>
                  }
              } else {
                  workList.pop();
                  boolean isLoopNode = currentEntry.isLoopNode;
                  Node current = currentEntry.n;
<span class="line-modified">!                 if (!isLoopNode &amp;&amp; current instanceof GuardNode) {</span>
<span class="line-modified">!                     /*</span>
<span class="line-modified">!                      * (gd) this is only OK if we are not going to make loop transforms based on</span>
<span class="line-modified">!                      * this</span>
<span class="line-modified">!                      */</span>
<span class="line-modified">!                     assert !((GuardNode) current).graph().hasValueProxies();</span>
<span class="line-modified">!                     isLoopNode = true;</span>
                  }
                  if (isLoopNode) {
                      loopNodes.mark(current);
                      for (WorkListEntry e : workList) {
                          e.isLoopNode = true;
<span class="line-new-header">--- 340,30 ---</span>
                  }
              } else {
                  workList.pop();
                  boolean isLoopNode = currentEntry.isLoopNode;
                  Node current = currentEntry.n;
<span class="line-modified">!                 if (!isLoopNode &amp;&amp; current instanceof GuardNode &amp;&amp; !current.hasUsages()) {</span>
<span class="line-modified">!                     GuardNode guard = (GuardNode) current;</span>
<span class="line-modified">!                     if (isLoopNode(guard.getCondition(), loopNodes, nonLoopNodes) != TriState.FALSE) {</span>
<span class="line-modified">!                         ValueNode anchor = guard.getAnchor().asNode();</span>
<span class="line-modified">!                         TriState isAnchorInLoop = isLoopNode(anchor, loopNodes, nonLoopNodes);</span>
<span class="line-modified">!                         if (isAnchorInLoop != TriState.FALSE) {</span>
<span class="line-modified">!                             if (!(anchor instanceof LoopExitNode &amp;&amp; ((LoopExitNode) anchor).loopBegin() == loopBeginNode)) {</span>
<span class="line-added">+                                 // It is undecidable whether the node is in the loop or not. This is</span>
<span class="line-added">+                                 // not an issue for getting counted loop information,</span>
<span class="line-added">+                                 // but causes issues when using the information for actual loop</span>
<span class="line-added">+                                 // transformations. This is why a loop transformation must</span>
<span class="line-added">+                                 // not happen while guards are floating.</span>
<span class="line-added">+                                 isLoopNode = true;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         } else if (AbstractControlFlowGraph.strictlyDominates(cfg.blockFor(anchor), cfg.blockFor(loopBeginNode))) {</span>
<span class="line-added">+                             // The anchor is above the loop. The no-usage guard can potentially be</span>
<span class="line-added">+                             // scheduled inside the loop.</span>
<span class="line-added">+                             isLoopNode = true;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
                  }
                  if (isLoopNode) {
                      loopNodes.mark(current);
                      for (WorkListEntry e : workList) {
                          e.isLoopNode = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 465,18 ***</span>
                          continue;
                      }
                      final ValueNode replaceWith;
                      ValueNode newVpn = prim(newEarlyExitIsLoopExit ? vpn : vpn.value());
                      if (newVpn != null) {
<span class="line-modified">!                         PhiNode phi;</span>
<span class="line-removed">-                         if (vpn instanceof ValueProxyNode) {</span>
<span class="line-removed">-                             phi = graph.addWithoutUnique(new ValuePhiNode(vpn.stamp(NodeView.DEFAULT), merge));</span>
<span class="line-removed">-                         } else if (vpn instanceof GuardProxyNode) {</span>
<span class="line-removed">-                             phi = graph.addWithoutUnique(new GuardPhiNode(merge));</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             throw GraalError.shouldNotReachHere();</span>
<span class="line-removed">-                         }</span>
                          phi.addInput(vpn);
                          phi.addInput(newVpn);
                          replaceWith = phi;
                      } else {
                          replaceWith = vpn.value();
<span class="line-new-header">--- 468,11 ---</span>
                          continue;
                      }
                      final ValueNode replaceWith;
                      ValueNode newVpn = prim(newEarlyExitIsLoopExit ? vpn : vpn.value());
                      if (newVpn != null) {
<span class="line-modified">!                         PhiNode phi = vpn.createPhi(merge);</span>
                          phi.addInput(vpn);
                          phi.addInput(newVpn);
                          replaceWith = phi;
                      } else {
                          replaceWith = vpn.value();
</pre>
<center><a href="LoopEx.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragmentInside.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
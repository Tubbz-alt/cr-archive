<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/CountedLoopInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DefaultLoopPolicies.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/CountedLoopInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.loop;
 26 
 27 import static java.lang.Math.abs;
 28 import static org.graalvm.compiler.loop.MathUtil.unsignedDivBefore;
 29 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.add;
 30 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.sub;
 31 
<span class="line-removed"> 32 import org.graalvm.compiler.core.common.NumUtil;</span>
 33 import org.graalvm.compiler.core.common.type.IntegerStamp;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.core.common.util.UnsignedLong;
 36 import org.graalvm.compiler.debug.DebugCloseable;
 37 import org.graalvm.compiler.loop.InductionVariable.Direction;
 38 import org.graalvm.compiler.nodes.AbstractBeginNode;
 39 import org.graalvm.compiler.nodes.ConstantNode;
 40 import org.graalvm.compiler.nodes.GuardNode;
 41 import org.graalvm.compiler.nodes.IfNode;
 42 import org.graalvm.compiler.nodes.LogicNode;
 43 import org.graalvm.compiler.nodes.NodeView;
 44 import org.graalvm.compiler.nodes.StructuredGraph;
 45 import org.graalvm.compiler.nodes.ValueNode;
 46 import org.graalvm.compiler.nodes.calc.ConditionalNode;
<span class="line-removed"> 47 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;</span>
 48 import org.graalvm.compiler.nodes.calc.NegateNode;
 49 import org.graalvm.compiler.nodes.extended.GuardingNode;
 50 import org.graalvm.compiler.nodes.util.GraphUtil;



 51 
 52 import jdk.vm.ci.meta.DeoptimizationAction;
 53 import jdk.vm.ci.meta.DeoptimizationReason;
 54 import jdk.vm.ci.meta.SpeculationLog;
 55 
 56 public class CountedLoopInfo {
 57 
 58     private final LoopEx loop;
 59     private InductionVariable iv;
 60     private ValueNode end;
 61     private boolean oneOff;
 62     private AbstractBeginNode body;
 63     private IfNode ifNode;

 64 
<span class="line-modified"> 65     CountedLoopInfo(LoopEx loop, InductionVariable iv, IfNode ifNode, ValueNode end, boolean oneOff, AbstractBeginNode body) {</span>
 66         assert iv.direction() != null;
 67         this.loop = loop;
 68         this.iv = iv;
 69         this.end = end;
 70         this.oneOff = oneOff;
 71         this.body = body;
 72         this.ifNode = ifNode;

 73     }
 74 
 75     /**
 76      * Returns a node that computes the maximum trip count of this loop. That is the trip count of
 77      * this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
 78      * count check}.
 79      *
 80      * This count is exact if {@link #isExactTripCount()} returns true.
 81      *
 82      * THIS VALUE SHOULD BE TREATED AS UNSIGNED.
 83      */
 84     public ValueNode maxTripCountNode() {
 85         return maxTripCountNode(false);
 86     }
 87 




 88     /**
 89      * Returns a node that computes the maximum trip count of this loop. That is the trip count of
 90      * this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
 91      * count check}.
 92      *
 93      * This count is exact if {@link #isExactTripCount()} returns true.
 94      *
 95      * THIS VALUE SHOULD BE TREATED AS UNSIGNED.
 96      *
 97      * @param assumeLoopEntered if true the check that the loop is entered at all will be omitted.
 98      */
 99     public ValueNode maxTripCountNode(boolean assumeLoopEntered) {
100         StructuredGraph graph = iv.valueNode().graph();
101         Stamp stamp = iv.valueNode().stamp(NodeView.DEFAULT);
102 
103         ValueNode max;
104         ValueNode min;
105         ValueNode absStride;
106         if (iv.direction() == Direction.Up) {
107             absStride = iv.strideNode();
108             max = end;
109             min = iv.initNode();
110         } else {
111             assert iv.direction() == Direction.Down;
112             absStride = NegateNode.create(iv.strideNode(), NodeView.DEFAULT);
113             max = iv.initNode();
114             min = end;
115         }
116         ValueNode range = sub(max, min);
117 
<span class="line-modified">118         ConstantNode one = ConstantNode.forIntegerStamp(stamp, 1);</span>
119         if (oneOff) {
120             range = add(range, one);
121         }
122         // round-away-from-zero divison: (range + stride -/+ 1) / stride
<span class="line-modified">123         ValueNode denominator = add(range, sub(absStride, one));</span>
124         ValueNode div = unsignedDivBefore(graph, loop.entryPoint(), denominator, absStride, null);
125 
126         if (assumeLoopEntered) {
127             return graph.addOrUniqueWithInputs(div);
128         }
<span class="line-modified">129         ConstantNode zero = ConstantNode.forIntegerStamp(stamp, 0);</span>
<span class="line-modified">130         LogicNode noEntryCheck = IntegerLessThanNode.create(max, min, NodeView.DEFAULT);</span>



131         return graph.addOrUniqueWithInputs(ConditionalNode.create(noEntryCheck, zero, div, NodeView.DEFAULT));
132     }
133 


































134     /**
135      * @return true if the loop has constant bounds.
136      */
137     public boolean isConstantMaxTripCount() {
138         return end instanceof ConstantNode &amp;&amp; iv.isConstantInit() &amp;&amp; iv.isConstantStride();
139     }
140 
141     public UnsignedLong constantMaxTripCount() {
142         assert isConstantMaxTripCount();
143         return new UnsignedLong(rawConstantMaxTripCount());
144     }
145 
146     /**
147      * Compute the raw value of the trip count for this loop. THIS IS AN UNSIGNED VALUE;
148      */
149     private long rawConstantMaxTripCount() {
150         assert iv.direction() != null;
151         long endValue = end.asJavaConstant().asLong();
152         long initValue = iv.constantInit();
153         long range;
154         long absStride;

155         if (iv.direction() == Direction.Up) {
<span class="line-modified">156             if (endValue &lt; initValue) {</span>
157                 return 0;
158             }
159             range = endValue - iv.constantInit();
160             absStride = iv.constantStride();
161         } else {
162             assert iv.direction() == Direction.Down;
<span class="line-modified">163             if (initValue &lt; endValue) {</span>
164                 return 0;
165             }
166             range = iv.constantInit() - endValue;
167             absStride = -iv.constantStride();
168         }
169         if (oneOff) {
170             range += 1;
171         }
172         long denominator = range + absStride - 1;
173         return Long.divideUnsigned(denominator, absStride);
174     }
175 















176     public boolean isExactTripCount() {
177         return loop.loop().getNaturalExits().size() == 1;
178     }
179 
180     public ValueNode exactTripCountNode() {
181         assert isExactTripCount();
182         return maxTripCountNode();
183     }
184 
185     public boolean isConstantExactTripCount() {
186         assert isExactTripCount();
187         return isConstantMaxTripCount();
188     }
189 
190     public UnsignedLong constantExactTripCount() {
191         assert isExactTripCount();
192         return constantMaxTripCount();
193     }
194 
195     @Override
</pre>
<hr />
<pre>
229     public Direction getDirection() {
230         return iv.direction();
231     }
232 
233     public InductionVariable getCounter() {
234         return iv;
235     }
236 
237     public GuardingNode getOverFlowGuard() {
238         return loop.loopBegin().getOverflowGuard();
239     }
240 
241     public boolean counterNeverOverflows() {
242         if (iv.isConstantStride() &amp;&amp; abs(iv.constantStride()) == 1) {
243             return true;
244         }
245         IntegerStamp endStamp = (IntegerStamp) end.stamp(NodeView.DEFAULT);
246         ValueNode strideNode = iv.strideNode();
247         IntegerStamp strideStamp = (IntegerStamp) strideNode.stamp(NodeView.DEFAULT);
248         GraphUtil.tryKillUnused(strideNode);

249         if (getDirection() == Direction.Up) {
<span class="line-modified">250             long max = NumUtil.maxValue(endStamp.getBits());</span>
<span class="line-modified">251             return endStamp.upperBound() &lt;= max - (strideStamp.upperBound() - 1) - (oneOff ? 1 : 0);</span>
252         } else if (getDirection() == Direction.Down) {
<span class="line-modified">253             long min = NumUtil.minValue(endStamp.getBits());</span>
<span class="line-modified">254             return min + (1 - strideStamp.lowerBound()) + (oneOff ? 1 : 0) &lt;= endStamp.lowerBound();</span>
255         }
256         return false;
257     }
258 
259     @SuppressWarnings(&quot;try&quot;)
260     public GuardingNode createOverFlowGuard() {
261         GuardingNode overflowGuard = getOverFlowGuard();
262         if (overflowGuard != null || counterNeverOverflows()) {
263             return overflowGuard;
264         }
265         try (DebugCloseable position = loop.loopBegin().withNodeSourcePosition()) {
266             IntegerStamp stamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);

267             StructuredGraph graph = iv.valueNode().graph();
268             LogicNode cond; // we use a negated guard with a &lt; condition to achieve a &gt;=
269             ConstantNode one = ConstantNode.forIntegerStamp(stamp, 1, graph);
270             if (iv.direction() == Direction.Up) {
<span class="line-modified">271                 ValueNode v1 = sub(ConstantNode.forIntegerStamp(stamp, NumUtil.maxValue(stamp.getBits())), sub(iv.strideNode(), one));</span>
272                 if (oneOff) {
273                     v1 = sub(v1, one);
274                 }
<span class="line-modified">275                 cond = graph.addOrUniqueWithInputs(IntegerLessThanNode.create(v1, end, NodeView.DEFAULT));</span>
276             } else {
277                 assert iv.direction() == Direction.Down;
<span class="line-modified">278                 ValueNode v1 = add(ConstantNode.forIntegerStamp(stamp, NumUtil.minValue(stamp.getBits())), sub(one, iv.strideNode()));</span>
279                 if (oneOff) {
280                     v1 = add(v1, one);
281                 }
<span class="line-modified">282                 cond = graph.addOrUniqueWithInputs(IntegerLessThanNode.create(end, v1, NodeView.DEFAULT));</span>
283             }
284             assert graph.getGuardsStage().allowsFloatingGuards();
285             overflowGuard = graph.unique(new GuardNode(cond, AbstractBeginNode.prevBegin(loop.entryPoint()), DeoptimizationReason.LoopLimitCheck, DeoptimizationAction.InvalidateRecompile, true,
286                             SpeculationLog.NO_SPECULATION, null)); // TODO gd: use speculation
287             loop.loopBegin().setOverflowGuard(overflowGuard);
288             return overflowGuard;
289         }
290     }
291 
292     public IntegerStamp getStamp() {
293         return (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);
294     }
295 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.loop;
 26 
 27 import static java.lang.Math.abs;
 28 import static org.graalvm.compiler.loop.MathUtil.unsignedDivBefore;
 29 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.add;
 30 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.sub;
 31 

 32 import org.graalvm.compiler.core.common.type.IntegerStamp;
 33 import org.graalvm.compiler.core.common.type.Stamp;
 34 import org.graalvm.compiler.core.common.util.UnsignedLong;
 35 import org.graalvm.compiler.debug.DebugCloseable;
 36 import org.graalvm.compiler.loop.InductionVariable.Direction;
 37 import org.graalvm.compiler.nodes.AbstractBeginNode;
 38 import org.graalvm.compiler.nodes.ConstantNode;
 39 import org.graalvm.compiler.nodes.GuardNode;
 40 import org.graalvm.compiler.nodes.IfNode;
 41 import org.graalvm.compiler.nodes.LogicNode;
 42 import org.graalvm.compiler.nodes.NodeView;
 43 import org.graalvm.compiler.nodes.StructuredGraph;
 44 import org.graalvm.compiler.nodes.ValueNode;
 45 import org.graalvm.compiler.nodes.calc.ConditionalNode;

 46 import org.graalvm.compiler.nodes.calc.NegateNode;
 47 import org.graalvm.compiler.nodes.extended.GuardingNode;
 48 import org.graalvm.compiler.nodes.util.GraphUtil;
<span class="line-added"> 49 import org.graalvm.compiler.nodes.util.IntegerHelper;</span>
<span class="line-added"> 50 import org.graalvm.compiler.nodes.util.SignedIntegerHelper;</span>
<span class="line-added"> 51 import org.graalvm.compiler.nodes.util.UnsignedIntegerHelper;</span>
 52 
 53 import jdk.vm.ci.meta.DeoptimizationAction;
 54 import jdk.vm.ci.meta.DeoptimizationReason;
 55 import jdk.vm.ci.meta.SpeculationLog;
 56 
 57 public class CountedLoopInfo {
 58 
 59     private final LoopEx loop;
 60     private InductionVariable iv;
 61     private ValueNode end;
 62     private boolean oneOff;
 63     private AbstractBeginNode body;
 64     private IfNode ifNode;
<span class="line-added"> 65     private final boolean unsigned;</span>
 66 
<span class="line-modified"> 67     CountedLoopInfo(LoopEx loop, InductionVariable iv, IfNode ifNode, ValueNode end, boolean oneOff, AbstractBeginNode body, boolean unsigned) {</span>
 68         assert iv.direction() != null;
 69         this.loop = loop;
 70         this.iv = iv;
 71         this.end = end;
 72         this.oneOff = oneOff;
 73         this.body = body;
 74         this.ifNode = ifNode;
<span class="line-added"> 75         this.unsigned = unsigned;</span>
 76     }
 77 
 78     /**
 79      * Returns a node that computes the maximum trip count of this loop. That is the trip count of
 80      * this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
 81      * count check}.
 82      *
 83      * This count is exact if {@link #isExactTripCount()} returns true.
 84      *
 85      * THIS VALUE SHOULD BE TREATED AS UNSIGNED.
 86      */
 87     public ValueNode maxTripCountNode() {
 88         return maxTripCountNode(false);
 89     }
 90 
<span class="line-added"> 91     public boolean isUnsignedCheck() {</span>
<span class="line-added"> 92         return this.unsigned;</span>
<span class="line-added"> 93     }</span>
<span class="line-added"> 94 </span>
 95     /**
 96      * Returns a node that computes the maximum trip count of this loop. That is the trip count of
 97      * this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
 98      * count check}.
 99      *
100      * This count is exact if {@link #isExactTripCount()} returns true.
101      *
102      * THIS VALUE SHOULD BE TREATED AS UNSIGNED.
103      *
104      * @param assumeLoopEntered if true the check that the loop is entered at all will be omitted.
105      */
106     public ValueNode maxTripCountNode(boolean assumeLoopEntered) {
107         StructuredGraph graph = iv.valueNode().graph();
108         Stamp stamp = iv.valueNode().stamp(NodeView.DEFAULT);
109 
110         ValueNode max;
111         ValueNode min;
112         ValueNode absStride;
113         if (iv.direction() == Direction.Up) {
114             absStride = iv.strideNode();
115             max = end;
116             min = iv.initNode();
117         } else {
118             assert iv.direction() == Direction.Down;
119             absStride = NegateNode.create(iv.strideNode(), NodeView.DEFAULT);
120             max = iv.initNode();
121             min = end;
122         }
123         ValueNode range = sub(max, min);
124 
<span class="line-modified">125         ConstantNode one = ConstantNode.forIntegerStamp(stamp, 1, graph);</span>
126         if (oneOff) {
127             range = add(range, one);
128         }
129         // round-away-from-zero divison: (range + stride -/+ 1) / stride
<span class="line-modified">130         ValueNode denominator = add(graph, range, sub(absStride, one), NodeView.DEFAULT);</span>
131         ValueNode div = unsignedDivBefore(graph, loop.entryPoint(), denominator, absStride, null);
132 
133         if (assumeLoopEntered) {
134             return graph.addOrUniqueWithInputs(div);
135         }
<span class="line-modified">136         ConstantNode zero = ConstantNode.forIntegerStamp(stamp, 0, graph);</span>
<span class="line-modified">137         // This check is &quot;wide&quot;: it looks like min &lt;= max</span>
<span class="line-added">138         // That&#39;s OK even if the loop is strict (`!isLimitIncluded()`)</span>
<span class="line-added">139         // because in this case, `div` will be zero when min == max</span>
<span class="line-added">140         LogicNode noEntryCheck = getCounterIntegerHelper().createCompareNode(max, min, NodeView.DEFAULT);</span>
141         return graph.addOrUniqueWithInputs(ConditionalNode.create(noEntryCheck, zero, div, NodeView.DEFAULT));
142     }
143 
<span class="line-added">144     /**</span>
<span class="line-added">145      * Determine if the loop might be entered. Returns {@code false} if we can tell statically that</span>
<span class="line-added">146      * the loop cannot be entered; returns {@code true} if the loop might possibly be entered,</span>
<span class="line-added">147      * including in the case where we cannot be sure statically.</span>
<span class="line-added">148      *</span>
<span class="line-added">149      * @return false if the loop can definitely not be entered, true otherwise</span>
<span class="line-added">150      */</span>
<span class="line-added">151     public boolean loopMightBeEntered() {</span>
<span class="line-added">152         Stamp stamp = iv.valueNode().stamp(NodeView.DEFAULT);</span>
<span class="line-added">153 </span>
<span class="line-added">154         ValueNode max;</span>
<span class="line-added">155         ValueNode min;</span>
<span class="line-added">156         if (iv.direction() == Direction.Up) {</span>
<span class="line-added">157             max = end;</span>
<span class="line-added">158             min = iv.initNode();</span>
<span class="line-added">159         } else {</span>
<span class="line-added">160             assert iv.direction() == Direction.Down;</span>
<span class="line-added">161             max = iv.initNode();</span>
<span class="line-added">162             min = end;</span>
<span class="line-added">163         }</span>
<span class="line-added">164         if (oneOff) {</span>
<span class="line-added">165             max = add(max, ConstantNode.forIntegerStamp(stamp, 1));</span>
<span class="line-added">166         }</span>
<span class="line-added">167 </span>
<span class="line-added">168         LogicNode entryCheck = getCounterIntegerHelper().createCompareNode(min, max, NodeView.DEFAULT);</span>
<span class="line-added">169         if (entryCheck.isContradiction()) {</span>
<span class="line-added">170             // We can definitely not enter this loop.</span>
<span class="line-added">171             return false;</span>
<span class="line-added">172         } else {</span>
<span class="line-added">173             // We don&#39;t know for sure that the loop can&#39;t be entered, so assume it can.</span>
<span class="line-added">174             return true;</span>
<span class="line-added">175         }</span>
<span class="line-added">176     }</span>
<span class="line-added">177 </span>
178     /**
179      * @return true if the loop has constant bounds.
180      */
181     public boolean isConstantMaxTripCount() {
182         return end instanceof ConstantNode &amp;&amp; iv.isConstantInit() &amp;&amp; iv.isConstantStride();
183     }
184 
185     public UnsignedLong constantMaxTripCount() {
186         assert isConstantMaxTripCount();
187         return new UnsignedLong(rawConstantMaxTripCount());
188     }
189 
190     /**
191      * Compute the raw value of the trip count for this loop. THIS IS AN UNSIGNED VALUE;
192      */
193     private long rawConstantMaxTripCount() {
194         assert iv.direction() != null;
195         long endValue = end.asJavaConstant().asLong();
196         long initValue = iv.constantInit();
197         long range;
198         long absStride;
<span class="line-added">199         IntegerHelper helper = getCounterIntegerHelper(64);</span>
200         if (iv.direction() == Direction.Up) {
<span class="line-modified">201             if (helper.compare(endValue, initValue) &lt; 0) {</span>
202                 return 0;
203             }
204             range = endValue - iv.constantInit();
205             absStride = iv.constantStride();
206         } else {
207             assert iv.direction() == Direction.Down;
<span class="line-modified">208             if (helper.compare(initValue, endValue) &lt; 0) {</span>
209                 return 0;
210             }
211             range = iv.constantInit() - endValue;
212             absStride = -iv.constantStride();
213         }
214         if (oneOff) {
215             range += 1;
216         }
217         long denominator = range + absStride - 1;
218         return Long.divideUnsigned(denominator, absStride);
219     }
220 
<span class="line-added">221     public IntegerHelper getCounterIntegerHelper() {</span>
<span class="line-added">222         IntegerStamp stamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);</span>
<span class="line-added">223         return getCounterIntegerHelper(stamp.getBits());</span>
<span class="line-added">224     }</span>
<span class="line-added">225 </span>
<span class="line-added">226     public IntegerHelper getCounterIntegerHelper(int bits) {</span>
<span class="line-added">227         IntegerHelper helper;</span>
<span class="line-added">228         if (isUnsignedCheck()) {</span>
<span class="line-added">229             helper = new UnsignedIntegerHelper(bits);</span>
<span class="line-added">230         } else {</span>
<span class="line-added">231             helper = new SignedIntegerHelper(bits);</span>
<span class="line-added">232         }</span>
<span class="line-added">233         return helper;</span>
<span class="line-added">234     }</span>
<span class="line-added">235 </span>
236     public boolean isExactTripCount() {
237         return loop.loop().getNaturalExits().size() == 1;
238     }
239 
240     public ValueNode exactTripCountNode() {
241         assert isExactTripCount();
242         return maxTripCountNode();
243     }
244 
245     public boolean isConstantExactTripCount() {
246         assert isExactTripCount();
247         return isConstantMaxTripCount();
248     }
249 
250     public UnsignedLong constantExactTripCount() {
251         assert isExactTripCount();
252         return constantMaxTripCount();
253     }
254 
255     @Override
</pre>
<hr />
<pre>
289     public Direction getDirection() {
290         return iv.direction();
291     }
292 
293     public InductionVariable getCounter() {
294         return iv;
295     }
296 
297     public GuardingNode getOverFlowGuard() {
298         return loop.loopBegin().getOverflowGuard();
299     }
300 
301     public boolean counterNeverOverflows() {
302         if (iv.isConstantStride() &amp;&amp; abs(iv.constantStride()) == 1) {
303             return true;
304         }
305         IntegerStamp endStamp = (IntegerStamp) end.stamp(NodeView.DEFAULT);
306         ValueNode strideNode = iv.strideNode();
307         IntegerStamp strideStamp = (IntegerStamp) strideNode.stamp(NodeView.DEFAULT);
308         GraphUtil.tryKillUnused(strideNode);
<span class="line-added">309         IntegerHelper integerHelper = getCounterIntegerHelper();</span>
310         if (getDirection() == Direction.Up) {
<span class="line-modified">311             long max = integerHelper.maxValue();</span>
<span class="line-modified">312             return integerHelper.compare(endStamp.upperBound(), max - (strideStamp.upperBound() - 1) - (oneOff ? 1 : 0)) &lt;= 0;</span>
313         } else if (getDirection() == Direction.Down) {
<span class="line-modified">314             long min = integerHelper.minValue();</span>
<span class="line-modified">315             return integerHelper.compare(min + (1 - strideStamp.lowerBound()) + (oneOff ? 1 : 0), endStamp.lowerBound()) &lt;= 0;</span>
316         }
317         return false;
318     }
319 
320     @SuppressWarnings(&quot;try&quot;)
321     public GuardingNode createOverFlowGuard() {
322         GuardingNode overflowGuard = getOverFlowGuard();
323         if (overflowGuard != null || counterNeverOverflows()) {
324             return overflowGuard;
325         }
326         try (DebugCloseable position = loop.loopBegin().withNodeSourcePosition()) {
327             IntegerStamp stamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);
<span class="line-added">328             IntegerHelper integerHelper = getCounterIntegerHelper();</span>
329             StructuredGraph graph = iv.valueNode().graph();
330             LogicNode cond; // we use a negated guard with a &lt; condition to achieve a &gt;=
331             ConstantNode one = ConstantNode.forIntegerStamp(stamp, 1, graph);
332             if (iv.direction() == Direction.Up) {
<span class="line-modified">333                 ValueNode v1 = sub(ConstantNode.forIntegerStamp(stamp, integerHelper.maxValue()), sub(iv.strideNode(), one));</span>
334                 if (oneOff) {
335                     v1 = sub(v1, one);
336                 }
<span class="line-modified">337                 cond = graph.addOrUniqueWithInputs(integerHelper.createCompareNode(v1, end, NodeView.DEFAULT));</span>
338             } else {
339                 assert iv.direction() == Direction.Down;
<span class="line-modified">340                 ValueNode v1 = add(ConstantNode.forIntegerStamp(stamp, integerHelper.minValue()), sub(one, iv.strideNode()));</span>
341                 if (oneOff) {
342                     v1 = add(v1, one);
343                 }
<span class="line-modified">344                 cond = graph.addOrUniqueWithInputs(integerHelper.createCompareNode(end, v1, NodeView.DEFAULT));</span>
345             }
346             assert graph.getGuardsStage().allowsFloatingGuards();
347             overflowGuard = graph.unique(new GuardNode(cond, AbstractBeginNode.prevBegin(loop.entryPoint()), DeoptimizationReason.LoopLimitCheck, DeoptimizationAction.InvalidateRecompile, true,
348                             SpeculationLog.NO_SPECULATION, null)); // TODO gd: use speculation
349             loop.loopBegin().setOverflowGuard(overflowGuard);
350             return overflowGuard;
351         }
352     }
353 
354     public IntegerStamp getStamp() {
355         return (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);
356     }
357 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DefaultLoopPolicies.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
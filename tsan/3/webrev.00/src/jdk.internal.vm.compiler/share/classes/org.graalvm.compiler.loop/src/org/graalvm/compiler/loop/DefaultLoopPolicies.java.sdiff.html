<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/DefaultLoopPolicies.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CountedLoopInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopEx.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/DefaultLoopPolicies.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.loop;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.LoopMaxUnswitch;
 28 import static org.graalvm.compiler.core.common.GraalOptions.MaximumDesiredSize;
<span class="line-modified"> 29 import static org.graalvm.compiler.core.common.GraalOptions.MinimumPeelProbability;</span>
 30 
 31 import java.util.List;
 32 
 33 import org.graalvm.compiler.core.common.util.UnsignedLong;
 34 import org.graalvm.compiler.debug.CounterKey;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.debug.GraalError;
 37 import org.graalvm.compiler.graph.Node;
 38 import org.graalvm.compiler.graph.NodeBitMap;
 39 import org.graalvm.compiler.nodes.AbstractBeginNode;
 40 import org.graalvm.compiler.nodes.ControlSplitNode;
<span class="line-removed"> 41 import org.graalvm.compiler.nodes.DeoptimizeNode;</span>
<span class="line-removed"> 42 import org.graalvm.compiler.nodes.FixedNode;</span>
<span class="line-removed"> 43 import org.graalvm.compiler.nodes.FixedWithNextNode;</span>
 44 import org.graalvm.compiler.nodes.InvokeNode;
 45 import org.graalvm.compiler.nodes.LoopBeginNode;
 46 import org.graalvm.compiler.nodes.MergeNode;
 47 import org.graalvm.compiler.nodes.StructuredGraph;
 48 import org.graalvm.compiler.nodes.VirtualState;
 49 import org.graalvm.compiler.nodes.VirtualState.VirtualClosure;
 50 import org.graalvm.compiler.nodes.calc.CompareNode;
 51 import org.graalvm.compiler.nodes.cfg.Block;
 52 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 53 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;
<span class="line-removed"> 54 import org.graalvm.compiler.nodes.java.TypeSwitchNode;</span>
 55 import org.graalvm.compiler.options.Option;
 56 import org.graalvm.compiler.options.OptionKey;
 57 import org.graalvm.compiler.options.OptionType;
 58 import org.graalvm.compiler.options.OptionValues;
 59 
 60 import jdk.vm.ci.meta.MetaAccessProvider;
 61 
 62 public class DefaultLoopPolicies implements LoopPolicies {
 63 
 64     public static class Options {
 65         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; LoopUnswitchMaxIncrease = new OptionKey&lt;&gt;(500);
 66         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; LoopUnswitchTrivial = new OptionKey&lt;&gt;(10);
 67         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Double&gt; LoopUnswitchFrequencyBoost = new OptionKey&lt;&gt;(10.0);
 68 
 69         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; FullUnrollMaxNodes = new OptionKey&lt;&gt;(400);
 70         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; FullUnrollConstantCompareBoost = new OptionKey&lt;&gt;(15);
 71         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; FullUnrollMaxIterations = new OptionKey&lt;&gt;(600);
 72         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; ExactFullUnrollMaxNodes = new OptionKey&lt;&gt;(800);
 73         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; ExactPartialUnrollMaxNodes = new OptionKey&lt;&gt;(200);
 74 
 75         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; UnrollMaxIterations = new OptionKey&lt;&gt;(16);
 76     }
 77 
 78     @Override
 79     public boolean shouldPeel(LoopEx loop, ControlFlowGraph cfg, MetaAccessProvider metaAccess) {
 80         LoopBeginNode loopBegin = loop.loopBegin();
 81         double entryProbability = cfg.blockFor(loopBegin.forwardEnd()).getRelativeFrequency();
<span class="line-modified"> 82         OptionValues options = cfg.graph.getOptions();</span>
<span class="line-modified"> 83         if (entryProbability &gt; MinimumPeelProbability.getValue(options) &amp;&amp; loop.size() + loopBegin.graph().getNodeCount() &lt; MaximumDesiredSize.getValue(options)) {</span>
<span class="line-modified"> 84             // check whether we&#39;re allowed to peel this loop</span>
<span class="line-modified"> 85             return loop.canDuplicateLoop();</span>
<span class="line-modified"> 86         } else {</span>












 87             return false;
 88         }







 89     }
 90 
 91     @Override
 92     public boolean shouldFullUnroll(LoopEx loop) {
 93         if (!loop.isCounted() || !loop.counted().isConstantMaxTripCount() || !loop.counted().counterNeverOverflows()) {
 94             return false;
 95         }
 96         OptionValues options = loop.entryPoint().getOptions();
 97         CountedLoopInfo counted = loop.counted();
 98         UnsignedLong maxTrips = counted.constantMaxTripCount();
 99         if (maxTrips.equals(0)) {
100             return loop.canDuplicateLoop();
101         }
102         if (maxTrips.isGreaterThan(Options.FullUnrollMaxIterations.getValue(options))) {
103             return false;
104         }
105         int globalMax = MaximumDesiredSize.getValue(options) - loop.loopBegin().graph().getNodeCount();
106         if (globalMax &lt;= 0) {
107             return false;
108         }
</pre>
<hr />
<pre>
172                 }
173                 if (node instanceof InvokeNode) {
174                     return false;
175                 }
176             }
177             return true;
178         } else {
179             loopBegin.getDebug().log(DebugContext.VERBOSE_LEVEL, &quot;shouldPartiallyUnroll %s unrolled loop is too large %s &quot;, loopBegin, size);
180             return false;
181         }
182     }
183 
184     @Override
185     public boolean shouldTryUnswitch(LoopEx loop) {
186         LoopBeginNode loopBegin = loop.loopBegin();
187         double loopFrequency = loopBegin.loopFrequency();
188         if (loopFrequency &lt;= 1.0) {
189             return false;
190         }
191         OptionValues options = loop.entryPoint().getOptions();
<span class="line-modified">192         return loopBegin.unswitches() &lt;= LoopMaxUnswitch.getValue(options);</span>
193     }
194 
195     private static final class CountingClosure implements VirtualClosure {
196         int count;
197 
198         @Override
199         public void apply(VirtualState node) {
200             count++;
201         }
202     }
203 
204     private static class IsolatedInitialization {
205         static final CounterKey UNSWITCH_SPLIT_WITH_PHIS = DebugContext.counter(&quot;UnswitchSplitWithPhis&quot;);
206     }
207 
208     @Override
209     public boolean shouldUnswitch(LoopEx loop, List&lt;ControlSplitNode&gt; controlSplits) {
210         int phis = 0;
211         StructuredGraph graph = loop.loopBegin().graph();
212         DebugContext debug = graph.getDebug();
</pre>
<hr />
<pre>
221             if (postDomBlock != null) {
222                 IsolatedInitialization.UNSWITCH_SPLIT_WITH_PHIS.increment(debug);
223                 phis += ((MergeNode) postDomBlock.getBeginNode()).phis().count();
224             }
225         }
226         int inBranchTotal = branchNodes.count();
227 
228         CountingClosure stateNodesCount = new CountingClosure();
229         double loopFrequency = loop.loopBegin().loopFrequency();
230         OptionValues options = loop.loopBegin().getOptions();
231         int maxDiff = Options.LoopUnswitchTrivial.getValue(options) + (int) (Options.LoopUnswitchFrequencyBoost.getValue(options) * (loopFrequency - 1.0 + phis));
232 
233         maxDiff = Math.min(maxDiff, Options.LoopUnswitchMaxIncrease.getValue(options));
234         int remainingGraphSpace = MaximumDesiredSize.getValue(options) - graph.getNodeCount();
235         maxDiff = Math.min(maxDiff, remainingGraphSpace);
236 
237         loop.loopBegin().stateAfter().applyToVirtual(stateNodesCount);
238         int loopTotal = loop.size() - loop.loopBegin().phis().count() - stateNodesCount.count - 1;
239         int actualDiff = (loopTotal - inBranchTotal);
240         ControlSplitNode firstSplit = controlSplits.get(0);
<span class="line-modified">241         if (firstSplit instanceof TypeSwitchNode) {</span>
<span class="line-modified">242             int copies = firstSplit.successors().count() - 1;</span>
<span class="line-modified">243             for (Node succ : firstSplit.successors()) {</span>
<span class="line-removed">244                 FixedNode current = (FixedNode) succ;</span>
<span class="line-removed">245                 while (current instanceof FixedWithNextNode) {</span>
<span class="line-removed">246                     current = ((FixedWithNextNode) current).next();</span>
<span class="line-removed">247                 }</span>
<span class="line-removed">248                 if (current instanceof DeoptimizeNode) {</span>
<span class="line-removed">249                     copies--;</span>
<span class="line-removed">250                 }</span>
<span class="line-removed">251             }</span>
<span class="line-removed">252             actualDiff = actualDiff * copies;</span>
<span class="line-removed">253         }</span>
254 
255         debug.log(&quot;shouldUnswitch(%s, %s) : delta=%d (%.2f%% inside of branches), max=%d, f=%.2f, phis=%d -&gt; %b&quot;, loop, controlSplits, actualDiff, (double) (inBranchTotal) / loopTotal * 100, maxDiff,
256                         loopFrequency, phis, actualDiff &lt;= maxDiff);
257         if (actualDiff &lt;= maxDiff) {
258             // check whether we&#39;re allowed to unswitch this loop
259             return loop.canDuplicateLoop();
260         } else {
261             return false;
262         }
263     }
264 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.loop;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.LoopMaxUnswitch;
 28 import static org.graalvm.compiler.core.common.GraalOptions.MaximumDesiredSize;
<span class="line-modified"> 29 import static org.graalvm.compiler.core.common.GraalOptions.MinimumPeelFrequency;</span>
 30 
 31 import java.util.List;
 32 
 33 import org.graalvm.compiler.core.common.util.UnsignedLong;
 34 import org.graalvm.compiler.debug.CounterKey;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.debug.GraalError;
 37 import org.graalvm.compiler.graph.Node;
 38 import org.graalvm.compiler.graph.NodeBitMap;
 39 import org.graalvm.compiler.nodes.AbstractBeginNode;
 40 import org.graalvm.compiler.nodes.ControlSplitNode;



 41 import org.graalvm.compiler.nodes.InvokeNode;
 42 import org.graalvm.compiler.nodes.LoopBeginNode;
 43 import org.graalvm.compiler.nodes.MergeNode;
 44 import org.graalvm.compiler.nodes.StructuredGraph;
 45 import org.graalvm.compiler.nodes.VirtualState;
 46 import org.graalvm.compiler.nodes.VirtualState.VirtualClosure;
 47 import org.graalvm.compiler.nodes.calc.CompareNode;
 48 import org.graalvm.compiler.nodes.cfg.Block;
 49 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 50 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;

 51 import org.graalvm.compiler.options.Option;
 52 import org.graalvm.compiler.options.OptionKey;
 53 import org.graalvm.compiler.options.OptionType;
 54 import org.graalvm.compiler.options.OptionValues;
 55 
 56 import jdk.vm.ci.meta.MetaAccessProvider;
 57 
 58 public class DefaultLoopPolicies implements LoopPolicies {
 59 
 60     public static class Options {
 61         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; LoopUnswitchMaxIncrease = new OptionKey&lt;&gt;(500);
 62         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; LoopUnswitchTrivial = new OptionKey&lt;&gt;(10);
 63         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Double&gt; LoopUnswitchFrequencyBoost = new OptionKey&lt;&gt;(10.0);
 64 
 65         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; FullUnrollMaxNodes = new OptionKey&lt;&gt;(400);
 66         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; FullUnrollConstantCompareBoost = new OptionKey&lt;&gt;(15);
 67         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; FullUnrollMaxIterations = new OptionKey&lt;&gt;(600);
 68         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; ExactFullUnrollMaxNodes = new OptionKey&lt;&gt;(800);
 69         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; ExactPartialUnrollMaxNodes = new OptionKey&lt;&gt;(200);
 70 
 71         @Option(help = &quot;&quot;, type = OptionType.Expert) public static final OptionKey&lt;Integer&gt; UnrollMaxIterations = new OptionKey&lt;&gt;(16);
 72     }
 73 
 74     @Override
 75     public boolean shouldPeel(LoopEx loop, ControlFlowGraph cfg, MetaAccessProvider metaAccess) {
 76         LoopBeginNode loopBegin = loop.loopBegin();
 77         double entryProbability = cfg.blockFor(loopBegin.forwardEnd()).getRelativeFrequency();
<span class="line-modified"> 78         StructuredGraph graph = cfg.graph;</span>
<span class="line-modified"> 79         OptionValues options = graph.getOptions();</span>
<span class="line-modified"> 80 </span>
<span class="line-modified"> 81         if (entryProbability &lt; MinimumPeelFrequency.getValue(options)) {</span>
<span class="line-modified"> 82             return false;</span>
<span class="line-added"> 83         }</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85         if (loop.parent() != null) {</span>
<span class="line-added"> 86             if (loop.size() &gt; loop.parent().size() &gt;&gt; 1) {</span>
<span class="line-added"> 87                 // This loops make up more than half of the parent loop in terms of number of nodes.</span>
<span class="line-added"> 88                 // There is a risk that this loop unproportionally increases parent loop body size.</span>
<span class="line-added"> 89                 return false;</span>
<span class="line-added"> 90             }</span>
<span class="line-added"> 91         }</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93         if (loop.loop().getChildren().size() &gt; 0) {</span>
<span class="line-added"> 94             // This loop has child loops. Loop peeling could explode graph size.</span>
 95             return false;
 96         }
<span class="line-added"> 97 </span>
<span class="line-added"> 98         if (loop.size() + graph.getNodeCount() &gt; MaximumDesiredSize.getValue(options)) {</span>
<span class="line-added"> 99             // We are out of budget for peeling.</span>
<span class="line-added">100             return false;</span>
<span class="line-added">101         }</span>
<span class="line-added">102 </span>
<span class="line-added">103         return true;</span>
104     }
105 
106     @Override
107     public boolean shouldFullUnroll(LoopEx loop) {
108         if (!loop.isCounted() || !loop.counted().isConstantMaxTripCount() || !loop.counted().counterNeverOverflows()) {
109             return false;
110         }
111         OptionValues options = loop.entryPoint().getOptions();
112         CountedLoopInfo counted = loop.counted();
113         UnsignedLong maxTrips = counted.constantMaxTripCount();
114         if (maxTrips.equals(0)) {
115             return loop.canDuplicateLoop();
116         }
117         if (maxTrips.isGreaterThan(Options.FullUnrollMaxIterations.getValue(options))) {
118             return false;
119         }
120         int globalMax = MaximumDesiredSize.getValue(options) - loop.loopBegin().graph().getNodeCount();
121         if (globalMax &lt;= 0) {
122             return false;
123         }
</pre>
<hr />
<pre>
187                 }
188                 if (node instanceof InvokeNode) {
189                     return false;
190                 }
191             }
192             return true;
193         } else {
194             loopBegin.getDebug().log(DebugContext.VERBOSE_LEVEL, &quot;shouldPartiallyUnroll %s unrolled loop is too large %s &quot;, loopBegin, size);
195             return false;
196         }
197     }
198 
199     @Override
200     public boolean shouldTryUnswitch(LoopEx loop) {
201         LoopBeginNode loopBegin = loop.loopBegin();
202         double loopFrequency = loopBegin.loopFrequency();
203         if (loopFrequency &lt;= 1.0) {
204             return false;
205         }
206         OptionValues options = loop.entryPoint().getOptions();
<span class="line-modified">207         return loopBegin.unswitches() &lt; LoopMaxUnswitch.getValue(options);</span>
208     }
209 
210     private static final class CountingClosure implements VirtualClosure {
211         int count;
212 
213         @Override
214         public void apply(VirtualState node) {
215             count++;
216         }
217     }
218 
219     private static class IsolatedInitialization {
220         static final CounterKey UNSWITCH_SPLIT_WITH_PHIS = DebugContext.counter(&quot;UnswitchSplitWithPhis&quot;);
221     }
222 
223     @Override
224     public boolean shouldUnswitch(LoopEx loop, List&lt;ControlSplitNode&gt; controlSplits) {
225         int phis = 0;
226         StructuredGraph graph = loop.loopBegin().graph();
227         DebugContext debug = graph.getDebug();
</pre>
<hr />
<pre>
236             if (postDomBlock != null) {
237                 IsolatedInitialization.UNSWITCH_SPLIT_WITH_PHIS.increment(debug);
238                 phis += ((MergeNode) postDomBlock.getBeginNode()).phis().count();
239             }
240         }
241         int inBranchTotal = branchNodes.count();
242 
243         CountingClosure stateNodesCount = new CountingClosure();
244         double loopFrequency = loop.loopBegin().loopFrequency();
245         OptionValues options = loop.loopBegin().getOptions();
246         int maxDiff = Options.LoopUnswitchTrivial.getValue(options) + (int) (Options.LoopUnswitchFrequencyBoost.getValue(options) * (loopFrequency - 1.0 + phis));
247 
248         maxDiff = Math.min(maxDiff, Options.LoopUnswitchMaxIncrease.getValue(options));
249         int remainingGraphSpace = MaximumDesiredSize.getValue(options) - graph.getNodeCount();
250         maxDiff = Math.min(maxDiff, remainingGraphSpace);
251 
252         loop.loopBegin().stateAfter().applyToVirtual(stateNodesCount);
253         int loopTotal = loop.size() - loop.loopBegin().phis().count() - stateNodesCount.count - 1;
254         int actualDiff = (loopTotal - inBranchTotal);
255         ControlSplitNode firstSplit = controlSplits.get(0);
<span class="line-modified">256 </span>
<span class="line-modified">257         int copies = firstSplit.successors().count() - 1;</span>
<span class="line-modified">258         actualDiff = actualDiff * copies;</span>










259 
260         debug.log(&quot;shouldUnswitch(%s, %s) : delta=%d (%.2f%% inside of branches), max=%d, f=%.2f, phis=%d -&gt; %b&quot;, loop, controlSplits, actualDiff, (double) (inBranchTotal) / loopTotal * 100, maxDiff,
261                         loopFrequency, phis, actualDiff &lt;= maxDiff);
262         if (actualDiff &lt;= maxDiff) {
263             // check whether we&#39;re allowed to unswitch this loop
264             return loop.canDuplicateLoop();
265         } else {
266             return false;
267         }
268     }
269 }
</pre>
</td>
</tr>
</table>
<center><a href="CountedLoopInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopEx.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragmentInside.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoopFragment.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragmentWhole.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragmentInside.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,12 ***</span>
  import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  import org.graalvm.compiler.nodes.calc.SubNode;
  import org.graalvm.compiler.nodes.extended.OpaqueNode;
  import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
  import org.graalvm.compiler.nodes.util.GraphUtil;
<span class="line-modified">! </span>
<span class="line-removed">- import jdk.vm.ci.code.CodeUtil;</span>
  
  public class LoopFragmentInside extends LoopFragment {
  
      /**
       * mergedInitializers. When an inside fragment&#39;s (loop)ends are merged to create a unique exit
<span class="line-new-header">--- 69,11 ---</span>
  import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  import org.graalvm.compiler.nodes.calc.SubNode;
  import org.graalvm.compiler.nodes.extended.OpaqueNode;
  import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
  import org.graalvm.compiler.nodes.util.GraphUtil;
<span class="line-modified">! import org.graalvm.compiler.nodes.util.IntegerHelper;</span>
  
  public class LoopFragmentInside extends LoopFragment {
  
      /**
       * mergedInitializers. When an inside fragment&#39;s (loop)ends are merged to create a unique exit
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,16 ***</span>
           * other.
           */
          LoopBeginNode mainLoopBegin = loop.loopBegin();
          ArrayList&lt;ValueNode&gt; backedgeValues = new ArrayList&lt;&gt;();
          for (PhiNode mainPhiNode : mainLoopBegin.phis()) {
<span class="line-modified">!             ValueNode duplicatedNode = getDuplicatedNode(mainPhiNode.valueAt(1));</span>
              if (duplicatedNode == null) {
<span class="line-modified">!                 if (mainLoopBegin.isPhiAtMerge(mainPhiNode.valueAt(1))) {</span>
<span class="line-modified">!                     duplicatedNode = ((PhiNode) (mainPhiNode.valueAt(1))).valueAt(1);</span>
                  } else {
<span class="line-modified">!                     assert mainPhiNode.valueAt(1).isConstant() : mainPhiNode.valueAt(1);</span>
                  }
              }
              backedgeValues.add(duplicatedNode);
          }
          int index = 0;
<span class="line-new-header">--- 166,17 ---</span>
           * other.
           */
          LoopBeginNode mainLoopBegin = loop.loopBegin();
          ArrayList&lt;ValueNode&gt; backedgeValues = new ArrayList&lt;&gt;();
          for (PhiNode mainPhiNode : mainLoopBegin.phis()) {
<span class="line-modified">!             ValueNode originalNode = mainPhiNode.valueAt(1);</span>
<span class="line-added">+             ValueNode duplicatedNode = getDuplicatedNode(originalNode);</span>
              if (duplicatedNode == null) {
<span class="line-modified">!                 if (mainLoopBegin.isPhiAtMerge(originalNode)) {</span>
<span class="line-modified">!                     duplicatedNode = ((PhiNode) (originalNode)).valueAt(1);</span>
                  } else {
<span class="line-modified">!                     assert originalNode.isConstant() || loop.isOutsideLoop(originalNode) : &quot;Not duplicated node &quot; + originalNode;</span>
                  }
              }
              backedgeValues.add(duplicatedNode);
          }
          int index = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,22 ***</span>
              if (opaque == null) {
                  opaque = new OpaqueNode(AddNode.add(counterStride, counterStride, NodeView.DEFAULT));
                  ValueNode limit = counted.getLimit();
                  int bits = ((IntegerStamp) limit.stamp(NodeView.DEFAULT)).getBits();
                  ValueNode newLimit = SubNode.create(limit, opaque, NodeView.DEFAULT);
                  LogicNode overflowCheck;
                  ConstantNode extremum;
                  if (counted.getDirection() == InductionVariable.Direction.Up) {
                      // limit - counterStride could overflow negatively if limit - min &lt;
                      // counterStride
<span class="line-modified">!                     extremum = ConstantNode.forIntegerBits(bits, CodeUtil.minValue(bits));</span>
                      overflowCheck = IntegerBelowNode.create(SubNode.create(limit, extremum, NodeView.DEFAULT), opaque, NodeView.DEFAULT);
                  } else {
                      assert counted.getDirection() == InductionVariable.Direction.Down;
                      // limit - counterStride could overflow if max - limit &lt; -counterStride
                      // i.e., counterStride &lt; limit - max
<span class="line-modified">!                     extremum = ConstantNode.forIntegerBits(bits, CodeUtil.maxValue(bits));</span>
                      overflowCheck = IntegerBelowNode.create(opaque, SubNode.create(limit, extremum, NodeView.DEFAULT), NodeView.DEFAULT);
                  }
                  newLimit = ConditionalNode.create(overflowCheck, extremum, newLimit, NodeView.DEFAULT);
                  CompareNode compareNode = (CompareNode) counted.getLimitTest().condition();
                  compareNode.replaceFirstInput(limit, graph.addOrUniqueWithInputs(newLimit));
<span class="line-new-header">--- 203,23 ---</span>
              if (opaque == null) {
                  opaque = new OpaqueNode(AddNode.add(counterStride, counterStride, NodeView.DEFAULT));
                  ValueNode limit = counted.getLimit();
                  int bits = ((IntegerStamp) limit.stamp(NodeView.DEFAULT)).getBits();
                  ValueNode newLimit = SubNode.create(limit, opaque, NodeView.DEFAULT);
<span class="line-added">+                 IntegerHelper helper = counted.getCounterIntegerHelper();</span>
                  LogicNode overflowCheck;
                  ConstantNode extremum;
                  if (counted.getDirection() == InductionVariable.Direction.Up) {
                      // limit - counterStride could overflow negatively if limit - min &lt;
                      // counterStride
<span class="line-modified">!                     extremum = ConstantNode.forIntegerBits(bits, helper.minValue());</span>
                      overflowCheck = IntegerBelowNode.create(SubNode.create(limit, extremum, NodeView.DEFAULT), opaque, NodeView.DEFAULT);
                  } else {
                      assert counted.getDirection() == InductionVariable.Direction.Down;
                      // limit - counterStride could overflow if max - limit &lt; -counterStride
                      // i.e., counterStride &lt; limit - max
<span class="line-modified">!                     extremum = ConstantNode.forIntegerBits(bits, helper.maxValue());</span>
                      overflowCheck = IntegerBelowNode.create(opaque, SubNode.create(limit, extremum, NodeView.DEFAULT), NodeView.DEFAULT);
                  }
                  newLimit = ConditionalNode.create(overflowCheck, extremum, newLimit, NodeView.DEFAULT);
                  CompareNode compareNode = (CompareNode) counted.getLimitTest().condition();
                  compareNode.replaceFirstInput(limit, graph.addOrUniqueWithInputs(newLimit));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,11 ***</span>
                  opaque.setValue(graph.addOrUniqueWithInputs(AddNode.add(counterStride, previousValue, NodeView.DEFAULT)));
                  GraphUtil.tryKillUnused(previousValue);
              }
          }
          mainLoopBegin.setUnrollFactor(mainLoopBegin.getUnrollFactor() * 2);
<span class="line-modified">!         mainLoopBegin.setLoopFrequency(mainLoopBegin.loopFrequency() / 2);</span>
          graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;LoopPartialUnroll %s&quot;, loop);
  
          mainLoopBegin.getDebug().dump(DebugContext.VERBOSE_LEVEL, mainLoopBegin.graph(), &quot;After insertWithinAfter %s&quot;, mainLoopBegin);
      }
  
<span class="line-new-header">--- 231,11 ---</span>
                  opaque.setValue(graph.addOrUniqueWithInputs(AddNode.add(counterStride, previousValue, NodeView.DEFAULT)));
                  GraphUtil.tryKillUnused(previousValue);
              }
          }
          mainLoopBegin.setUnrollFactor(mainLoopBegin.getUnrollFactor() * 2);
<span class="line-modified">!         mainLoopBegin.setLoopFrequency(Math.max(1.0, mainLoopBegin.loopFrequency() / 2));</span>
          graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;LoopPartialUnroll %s&quot;, loop);
  
          mainLoopBegin.getDebug().dump(DebugContext.VERBOSE_LEVEL, mainLoopBegin.graph(), &quot;After insertWithinAfter %s&quot;, mainLoopBegin);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,64 ***</span>
          CountedLoopInfo mainCounted = loop.counted();
          LoopBeginNode mainLoopBegin = loop.loopBegin();
          // Discard the segment entry and its flow, after if merging it into the loop
          StructuredGraph graph = mainLoopBegin.graph();
          IfNode loopTest = mainCounted.getLimitTest();
<span class="line-modified">!         IfNode newSegmentTest = getDuplicatedNode(loopTest);</span>
<span class="line-modified">!         AbstractBeginNode trueSuccessor = loopTest.trueSuccessor();</span>
<span class="line-modified">!         AbstractBeginNode falseSuccessor = loopTest.falseSuccessor();</span>
<span class="line-modified">!         FixedNode firstNode;</span>
<span class="line-removed">-         boolean codeInTrueSide = false;</span>
<span class="line-removed">-         if (trueSuccessor == mainCounted.getBody()) {</span>
<span class="line-removed">-             firstNode = trueSuccessor.next();</span>
<span class="line-removed">-             codeInTrueSide = true;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             assert (falseSuccessor == mainCounted.getBody());</span>
<span class="line-removed">-             firstNode = falseSuccessor.next();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         trueSuccessor = newSegmentTest.trueSuccessor();</span>
<span class="line-removed">-         falseSuccessor = newSegmentTest.falseSuccessor();</span>
          for (Node usage : falseSuccessor.anchored().snapshot()) {
              usage.replaceFirstInput(falseSuccessor, loopTest.falseSuccessor());
          }
          for (Node usage : trueSuccessor.anchored().snapshot()) {
              usage.replaceFirstInput(trueSuccessor, loopTest.trueSuccessor());
          }
<span class="line-modified">!         AbstractBeginNode startBlockNode;</span>
<span class="line-modified">!         if (codeInTrueSide) {</span>
<span class="line-modified">!             startBlockNode = trueSuccessor;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             graph.getDebug().dump(DebugContext.VERBOSE_LEVEL, mainLoopBegin.graph(), &quot;before&quot;);</span>
<span class="line-modified">!             startBlockNode = falseSuccessor;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         FixedNode lastNode = getBlockEnd(startBlockNode);</span>
<span class="line-removed">-         LoopEndNode loopEndNode = mainLoopBegin.getSingleLoopEnd();</span>
<span class="line-removed">-         FixedWithNextNode lastCodeNode = (FixedWithNextNode) loopEndNode.predecessor();</span>
<span class="line-removed">-         FixedNode newSegmentFirstNode = getDuplicatedNode(firstNode);</span>
<span class="line-removed">-         FixedWithNextNode newSegmentLastNode = getDuplicatedNode(lastCodeNode);</span>
<span class="line-removed">-         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, loopEndNode.graph(), &quot;Before placing segment&quot;);</span>
<span class="line-removed">-         if (firstNode instanceof LoopEndNode) {</span>
              GraphUtil.killCFG(getDuplicatedNode(mainLoopBegin));
          } else {
<span class="line-modified">!             newSegmentLastNode.clearSuccessors();</span>
<span class="line-modified">!             startBlockNode.setNext(lastNode);</span>
              lastCodeNode.replaceFirstSuccessor(loopEndNode, newSegmentFirstNode);
<span class="line-modified">!             newSegmentLastNode.replaceFirstSuccessor(lastNode, loopEndNode);</span>
<span class="line-modified">!             lastCodeNode.setNext(newSegmentFirstNode);</span>
<span class="line-modified">!             newSegmentLastNode.setNext(loopEndNode);</span>
<span class="line-modified">!             startBlockNode.clearSuccessors();</span>
<span class="line-removed">-             lastNode.safeDelete();</span>
<span class="line-removed">-             Node newSegmentTestStart = newSegmentTest.predecessor();</span>
<span class="line-removed">-             LogicNode newSegmentIfTest = newSegmentTest.condition();</span>
<span class="line-removed">-             newSegmentTestStart.clearSuccessors();</span>
<span class="line-removed">-             newSegmentTest.safeDelete();</span>
<span class="line-removed">-             newSegmentIfTest.safeDelete();</span>
<span class="line-removed">-             trueSuccessor.safeDelete();</span>
<span class="line-removed">-             falseSuccessor.safeDelete();</span>
<span class="line-removed">-             newSegmentTestStart.safeDelete();</span>
          }
<span class="line-modified">!         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, loopEndNode.graph(), &quot;After placing segment&quot;);</span>
      }
  
      private static EndNode getBlockEnd(FixedNode node) {
          FixedNode curNode = node;
          while (curNode instanceof FixedWithNextNode) {
<span class="line-new-header">--- 243,44 ---</span>
          CountedLoopInfo mainCounted = loop.counted();
          LoopBeginNode mainLoopBegin = loop.loopBegin();
          // Discard the segment entry and its flow, after if merging it into the loop
          StructuredGraph graph = mainLoopBegin.graph();
          IfNode loopTest = mainCounted.getLimitTest();
<span class="line-modified">!         IfNode newSegmentLoopTest = getDuplicatedNode(loopTest);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Redirect anchors</span>
<span class="line-modified">!         AbstractBeginNode falseSuccessor = newSegmentLoopTest.falseSuccessor();</span>
          for (Node usage : falseSuccessor.anchored().snapshot()) {
              usage.replaceFirstInput(falseSuccessor, loopTest.falseSuccessor());
          }
<span class="line-added">+         AbstractBeginNode trueSuccessor = newSegmentLoopTest.trueSuccessor();</span>
          for (Node usage : trueSuccessor.anchored().snapshot()) {
              usage.replaceFirstInput(trueSuccessor, loopTest.trueSuccessor());
          }
<span class="line-modified">! </span>
<span class="line-modified">!         // remove if test</span>
<span class="line-modified">!         graph.removeSplitPropagate(newSegmentLoopTest, loopTest.trueSuccessor() == mainCounted.getBody() ? trueSuccessor : falseSuccessor);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before placing segment&quot;);</span>
<span class="line-modified">!         if (mainCounted.getBody().next() instanceof LoopEndNode) {</span>
              GraphUtil.killCFG(getDuplicatedNode(mainLoopBegin));
          } else {
<span class="line-modified">!             AbstractBeginNode newSegmentBegin = getDuplicatedNode(mainLoopBegin);</span>
<span class="line-modified">!             FixedNode newSegmentFirstNode = newSegmentBegin.next();</span>
<span class="line-added">+             EndNode newSegmentEnd = getBlockEnd(newSegmentBegin);</span>
<span class="line-added">+             FixedWithNextNode newSegmentLastNode = (FixedWithNextNode) newSegmentEnd.predecessor();</span>
<span class="line-added">+             LoopEndNode loopEndNode = mainLoopBegin.getSingleLoopEnd();</span>
<span class="line-added">+             FixedWithNextNode lastCodeNode = (FixedWithNextNode) loopEndNode.predecessor();</span>
<span class="line-added">+ </span>
<span class="line-added">+             newSegmentBegin.clearSuccessors();</span>
              lastCodeNode.replaceFirstSuccessor(loopEndNode, newSegmentFirstNode);
<span class="line-modified">!             newSegmentLastNode.replaceFirstSuccessor(newSegmentEnd, loopEndNode);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             newSegmentBegin.safeDelete();</span>
<span class="line-modified">!             newSegmentEnd.safeDelete();</span>
          }
<span class="line-modified">!         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;After placing segment&quot;);</span>
      }
  
      private static EndNode getBlockEnd(FixedNode node) {
          FixedNode curNode = node;
          while (curNode instanceof FixedWithNextNode) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,11 ***</span>
          // new corresponding phis
          for (PhiNode phi : newPhis) {
              for (int i = 0; i &lt; phi.valueCount(); i++) {
                  ValueNode v = phi.valueAt(i);
                  if (loopBegin.isPhiAtMerge(v)) {
<span class="line-modified">!                     PhiNode newV = peel.getDuplicatedNode((ValuePhiNode) v);</span>
                      if (newV != null) {
                          phi.setValueAt(i, newV);
                      }
                  }
              }
<span class="line-new-header">--- 436,11 ---</span>
          // new corresponding phis
          for (PhiNode phi : newPhis) {
              for (int i = 0; i &lt; phi.valueCount(); i++) {
                  ValueNode v = phi.valueAt(i);
                  if (loopBegin.isPhiAtMerge(v)) {
<span class="line-modified">!                     PhiNode newV = peel.getDuplicatedNode((PhiNode) v);</span>
                      if (newV != null) {
                          phi.setValueAt(i, newV);
                      }
                  }
              }
</pre>
<center><a href="LoopFragment.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragmentWhole.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
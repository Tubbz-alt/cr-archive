diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragmentInside.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragmentInside.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragmentInside.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragmentInside.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -69,12 +69,11 @@
 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 import org.graalvm.compiler.nodes.calc.SubNode;
 import org.graalvm.compiler.nodes.extended.OpaqueNode;
 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 import org.graalvm.compiler.nodes.util.GraphUtil;
-
-import jdk.vm.ci.code.CodeUtil;
+import org.graalvm.compiler.nodes.util.IntegerHelper;
 
 public class LoopFragmentInside extends LoopFragment {
 
     /**
      * mergedInitializers. When an inside fragment's (loop)ends are merged to create a unique exit
@@ -167,16 +166,17 @@
          * other.
          */
         LoopBeginNode mainLoopBegin = loop.loopBegin();
         ArrayList<ValueNode> backedgeValues = new ArrayList<>();
         for (PhiNode mainPhiNode : mainLoopBegin.phis()) {
-            ValueNode duplicatedNode = getDuplicatedNode(mainPhiNode.valueAt(1));
+            ValueNode originalNode = mainPhiNode.valueAt(1);
+            ValueNode duplicatedNode = getDuplicatedNode(originalNode);
             if (duplicatedNode == null) {
-                if (mainLoopBegin.isPhiAtMerge(mainPhiNode.valueAt(1))) {
-                    duplicatedNode = ((PhiNode) (mainPhiNode.valueAt(1))).valueAt(1);
+                if (mainLoopBegin.isPhiAtMerge(originalNode)) {
+                    duplicatedNode = ((PhiNode) (originalNode)).valueAt(1);
                 } else {
-                    assert mainPhiNode.valueAt(1).isConstant() : mainPhiNode.valueAt(1);
+                    assert originalNode.isConstant() || loop.isOutsideLoop(originalNode) : "Not duplicated node " + originalNode;
                 }
             }
             backedgeValues.add(duplicatedNode);
         }
         int index = 0;
@@ -203,22 +203,23 @@
             if (opaque == null) {
                 opaque = new OpaqueNode(AddNode.add(counterStride, counterStride, NodeView.DEFAULT));
                 ValueNode limit = counted.getLimit();
                 int bits = ((IntegerStamp) limit.stamp(NodeView.DEFAULT)).getBits();
                 ValueNode newLimit = SubNode.create(limit, opaque, NodeView.DEFAULT);
+                IntegerHelper helper = counted.getCounterIntegerHelper();
                 LogicNode overflowCheck;
                 ConstantNode extremum;
                 if (counted.getDirection() == InductionVariable.Direction.Up) {
                     // limit - counterStride could overflow negatively if limit - min <
                     // counterStride
-                    extremum = ConstantNode.forIntegerBits(bits, CodeUtil.minValue(bits));
+                    extremum = ConstantNode.forIntegerBits(bits, helper.minValue());
                     overflowCheck = IntegerBelowNode.create(SubNode.create(limit, extremum, NodeView.DEFAULT), opaque, NodeView.DEFAULT);
                 } else {
                     assert counted.getDirection() == InductionVariable.Direction.Down;
                     // limit - counterStride could overflow if max - limit < -counterStride
                     // i.e., counterStride < limit - max
-                    extremum = ConstantNode.forIntegerBits(bits, CodeUtil.maxValue(bits));
+                    extremum = ConstantNode.forIntegerBits(bits, helper.maxValue());
                     overflowCheck = IntegerBelowNode.create(opaque, SubNode.create(limit, extremum, NodeView.DEFAULT), NodeView.DEFAULT);
                 }
                 newLimit = ConditionalNode.create(overflowCheck, extremum, newLimit, NodeView.DEFAULT);
                 CompareNode compareNode = (CompareNode) counted.getLimitTest().condition();
                 compareNode.replaceFirstInput(limit, graph.addOrUniqueWithInputs(newLimit));
@@ -230,11 +231,11 @@
                 opaque.setValue(graph.addOrUniqueWithInputs(AddNode.add(counterStride, previousValue, NodeView.DEFAULT)));
                 GraphUtil.tryKillUnused(previousValue);
             }
         }
         mainLoopBegin.setUnrollFactor(mainLoopBegin.getUnrollFactor() * 2);
-        mainLoopBegin.setLoopFrequency(mainLoopBegin.loopFrequency() / 2);
+        mainLoopBegin.setLoopFrequency(Math.max(1.0, mainLoopBegin.loopFrequency() / 2));
         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, "LoopPartialUnroll %s", loop);
 
         mainLoopBegin.getDebug().dump(DebugContext.VERBOSE_LEVEL, mainLoopBegin.graph(), "After insertWithinAfter %s", mainLoopBegin);
     }
 
@@ -242,64 +243,44 @@
         CountedLoopInfo mainCounted = loop.counted();
         LoopBeginNode mainLoopBegin = loop.loopBegin();
         // Discard the segment entry and its flow, after if merging it into the loop
         StructuredGraph graph = mainLoopBegin.graph();
         IfNode loopTest = mainCounted.getLimitTest();
-        IfNode newSegmentTest = getDuplicatedNode(loopTest);
-        AbstractBeginNode trueSuccessor = loopTest.trueSuccessor();
-        AbstractBeginNode falseSuccessor = loopTest.falseSuccessor();
-        FixedNode firstNode;
-        boolean codeInTrueSide = false;
-        if (trueSuccessor == mainCounted.getBody()) {
-            firstNode = trueSuccessor.next();
-            codeInTrueSide = true;
-        } else {
-            assert (falseSuccessor == mainCounted.getBody());
-            firstNode = falseSuccessor.next();
-        }
-        trueSuccessor = newSegmentTest.trueSuccessor();
-        falseSuccessor = newSegmentTest.falseSuccessor();
+        IfNode newSegmentLoopTest = getDuplicatedNode(loopTest);
+
+        // Redirect anchors
+        AbstractBeginNode falseSuccessor = newSegmentLoopTest.falseSuccessor();
         for (Node usage : falseSuccessor.anchored().snapshot()) {
             usage.replaceFirstInput(falseSuccessor, loopTest.falseSuccessor());
         }
+        AbstractBeginNode trueSuccessor = newSegmentLoopTest.trueSuccessor();
         for (Node usage : trueSuccessor.anchored().snapshot()) {
             usage.replaceFirstInput(trueSuccessor, loopTest.trueSuccessor());
         }
-        AbstractBeginNode startBlockNode;
-        if (codeInTrueSide) {
-            startBlockNode = trueSuccessor;
-        } else {
-            graph.getDebug().dump(DebugContext.VERBOSE_LEVEL, mainLoopBegin.graph(), "before");
-            startBlockNode = falseSuccessor;
-        }
-        FixedNode lastNode = getBlockEnd(startBlockNode);
-        LoopEndNode loopEndNode = mainLoopBegin.getSingleLoopEnd();
-        FixedWithNextNode lastCodeNode = (FixedWithNextNode) loopEndNode.predecessor();
-        FixedNode newSegmentFirstNode = getDuplicatedNode(firstNode);
-        FixedWithNextNode newSegmentLastNode = getDuplicatedNode(lastCodeNode);
-        graph.getDebug().dump(DebugContext.DETAILED_LEVEL, loopEndNode.graph(), "Before placing segment");
-        if (firstNode instanceof LoopEndNode) {
+
+        // remove if test
+        graph.removeSplitPropagate(newSegmentLoopTest, loopTest.trueSuccessor() == mainCounted.getBody() ? trueSuccessor : falseSuccessor);
+
+        graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, "Before placing segment");
+        if (mainCounted.getBody().next() instanceof LoopEndNode) {
             GraphUtil.killCFG(getDuplicatedNode(mainLoopBegin));
         } else {
-            newSegmentLastNode.clearSuccessors();
-            startBlockNode.setNext(lastNode);
+            AbstractBeginNode newSegmentBegin = getDuplicatedNode(mainLoopBegin);
+            FixedNode newSegmentFirstNode = newSegmentBegin.next();
+            EndNode newSegmentEnd = getBlockEnd(newSegmentBegin);
+            FixedWithNextNode newSegmentLastNode = (FixedWithNextNode) newSegmentEnd.predecessor();
+            LoopEndNode loopEndNode = mainLoopBegin.getSingleLoopEnd();
+            FixedWithNextNode lastCodeNode = (FixedWithNextNode) loopEndNode.predecessor();
+
+            newSegmentBegin.clearSuccessors();
             lastCodeNode.replaceFirstSuccessor(loopEndNode, newSegmentFirstNode);
-            newSegmentLastNode.replaceFirstSuccessor(lastNode, loopEndNode);
-            lastCodeNode.setNext(newSegmentFirstNode);
-            newSegmentLastNode.setNext(loopEndNode);
-            startBlockNode.clearSuccessors();
-            lastNode.safeDelete();
-            Node newSegmentTestStart = newSegmentTest.predecessor();
-            LogicNode newSegmentIfTest = newSegmentTest.condition();
-            newSegmentTestStart.clearSuccessors();
-            newSegmentTest.safeDelete();
-            newSegmentIfTest.safeDelete();
-            trueSuccessor.safeDelete();
-            falseSuccessor.safeDelete();
-            newSegmentTestStart.safeDelete();
+            newSegmentLastNode.replaceFirstSuccessor(newSegmentEnd, loopEndNode);
+
+            newSegmentBegin.safeDelete();
+            newSegmentEnd.safeDelete();
         }
-        graph.getDebug().dump(DebugContext.DETAILED_LEVEL, loopEndNode.graph(), "After placing segment");
+        graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, "After placing segment");
     }
 
     private static EndNode getBlockEnd(FixedNode node) {
         FixedNode curNode = node;
         while (curNode instanceof FixedWithNextNode) {
@@ -455,11 +436,11 @@
         // new corresponding phis
         for (PhiNode phi : newPhis) {
             for (int i = 0; i < phi.valueCount(); i++) {
                 ValueNode v = phi.valueAt(i);
                 if (loopBegin.isPhiAtMerge(v)) {
-                    PhiNode newV = peel.getDuplicatedNode((ValuePhiNode) v);
+                    PhiNode newV = peel.getDuplicatedNode((PhiNode) v);
                     if (newV != null) {
                         phi.setValueAt(i, newV);
                     }
                 }
             }

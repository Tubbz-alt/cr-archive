<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.loop;
 26 
 27 import java.util.ArrayDeque;
<a name="2" id="anc2"></a>
 28 import java.util.Deque;
 29 import java.util.Iterator;
 30 
 31 import jdk.internal.vm.compiler.collections.EconomicMap;
<a name="3" id="anc3"></a><span class="line-modified"> 32 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;</span>
 33 import org.graalvm.compiler.graph.Graph;
 34 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
 35 import org.graalvm.compiler.graph.Node;
 36 import org.graalvm.compiler.graph.NodeBitMap;
 37 import org.graalvm.compiler.graph.iterators.NodeIterable;
 38 import org.graalvm.compiler.nodes.AbstractBeginNode;
 39 import org.graalvm.compiler.nodes.AbstractMergeNode;
 40 import org.graalvm.compiler.nodes.EndNode;
 41 import org.graalvm.compiler.nodes.FixedNode;
 42 import org.graalvm.compiler.nodes.FrameState;
 43 import org.graalvm.compiler.nodes.GuardNode;
<a name="4" id="anc4"></a>
 44 import org.graalvm.compiler.nodes.GuardProxyNode;
 45 import org.graalvm.compiler.nodes.Invoke;
<a name="5" id="anc5"></a><span class="line-added"> 46 import org.graalvm.compiler.nodes.LoopBeginNode;</span>
 47 import org.graalvm.compiler.nodes.LoopExitNode;
 48 import org.graalvm.compiler.nodes.MergeNode;
<a name="6" id="anc6"></a>
 49 import org.graalvm.compiler.nodes.PhiNode;
 50 import org.graalvm.compiler.nodes.ProxyNode;
 51 import org.graalvm.compiler.nodes.StructuredGraph;
 52 import org.graalvm.compiler.nodes.ValueNode;
<a name="7" id="anc7"></a>

 53 import org.graalvm.compiler.nodes.VirtualState;
 54 import org.graalvm.compiler.nodes.cfg.Block;
 55 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 56 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 57 import org.graalvm.compiler.nodes.spi.NodeWithState;
 58 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
 59 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 60 
 61 import jdk.vm.ci.meta.TriState;
 62 
 63 public abstract class LoopFragment {
 64 
 65     private final LoopEx loop;
 66     private final LoopFragment original;
 67     protected NodeBitMap nodes;
 68     protected boolean nodesReady;
 69     private EconomicMap&lt;Node, Node&gt; duplicationMap;
 70 
 71     public LoopFragment(LoopEx loop) {
 72         this(loop, null);
 73         this.nodesReady = true;
 74     }
 75 
 76     public LoopFragment(LoopEx loop, LoopFragment original) {
 77         this.loop = loop;
 78         this.original = original;
 79         this.nodesReady = false;
 80     }
 81 
 82     /**
 83      * Return the original LoopEx for this fragment. For duplicated fragments this returns null.
 84      */
 85     protected LoopEx loop() {
 86         return loop;
 87     }
 88 
 89     public abstract LoopFragment duplicate();
 90 
 91     public abstract void insertBefore(LoopEx l);
 92 
 93     public void disconnect() {
 94         // TODO (gd) possibly abstract
 95     }
 96 
 97     public boolean contains(Node n) {
 98         return nodes().isMarkedAndGrow(n);
 99     }
100 
101     @SuppressWarnings(&quot;unchecked&quot;)
102     public &lt;New extends Node, Old extends New&gt; New getDuplicatedNode(Old n) {
103         assert isDuplicate();
104         return (New) duplicationMap.get(n);
105     }
106 
107     protected &lt;New extends Node, Old extends New&gt; void putDuplicatedNode(Old oldNode, New newNode) {
108         duplicationMap.put(oldNode, newNode);
109     }
110 
111     /**
112      * Gets the corresponding value in this fragment. Should be called on duplicate fragments with a
113      * node from the original fragment as argument.
114      *
115      * @param b original value
116      * @return corresponding value in the peel
117      */
118     protected abstract ValueNode prim(ValueNode b);
119 
120     public boolean isDuplicate() {
121         return original != null;
122     }
123 
124     public LoopFragment original() {
125         return original;
126     }
127 
128     public abstract NodeBitMap nodes();
129 
130     public StructuredGraph graph() {
131         LoopEx l;
132         if (isDuplicate()) {
133             l = original().loop();
134         } else {
135             l = loop();
136         }
137         return l.loopBegin().graph();
138     }
139 
140     protected abstract DuplicationReplacement getDuplicationReplacement();
141 
142     protected abstract void beforeDuplication();
143 
144     protected void finishDuplication() {
145         LoopEx originalLoopEx = original().loop();
146         ControlFlowGraph cfg = originalLoopEx.loopsData().getCFG();
147         for (LoopExitNode exit : originalLoopEx.loopBegin().loopExits().snapshot()) {
148             if (!originalLoopEx.loop().isLoopExit(cfg.blockFor(exit))) {
149                 // this LoopExitNode is too low, we need to remove it otherwise it will be below
150                 // merged exits
151                 exit.removeExit();
152             }
153         }
154 
155     }
156 
157     protected void patchNodes(final DuplicationReplacement dataFix) {
158         if (isDuplicate() &amp;&amp; !nodesReady) {
159             assert !original.isDuplicate();
160             final DuplicationReplacement cfgFix = original().getDuplicationReplacement();
161             DuplicationReplacement dr;
162             if (cfgFix == null &amp;&amp; dataFix != null) {
163                 dr = dataFix;
164             } else if (cfgFix != null &amp;&amp; dataFix == null) {
165                 dr = cfgFix;
166             } else if (cfgFix != null &amp;&amp; dataFix != null) {
167                 dr = new DuplicationReplacement() {
168 
169                     @Override
170                     public Node replacement(Node o) {
171                         Node r1 = dataFix.replacement(o);
172                         if (r1 != o) {
173                             assert cfgFix.replacement(o) == o;
174                             return r1;
175                         }
176                         Node r2 = cfgFix.replacement(o);
177                         if (r2 != o) {
178                             return r2;
179                         }
180                         return o;
181                     }
182                 };
183             } else {
184                 dr = null;
185             }
186             beforeDuplication();
187             NodeIterable&lt;Node&gt; nodesIterable = original().nodes();
188             duplicationMap = graph().addDuplicates(nodesIterable, graph(), nodesIterable.count(), dr);
189             finishDuplication();
190             nodes = new NodeBitMap(graph());
191             nodes.markAll(duplicationMap.getValues());
192             nodesReady = true;
193         } else {
194             // TODO (gd) apply fix ?
195         }
196     }
197 
<a name="8" id="anc8"></a><span class="line-modified">198     protected static void computeNodes(NodeBitMap nodes, Graph graph, LoopEx loop, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;AbstractBeginNode&gt; earlyExits) {</span>










199         for (AbstractBeginNode b : blocks) {
200             if (b.isDeleted()) {
201                 continue;
202             }
203 
204             for (Node n : b.getBlockNodes()) {
205                 if (n instanceof Invoke) {
206                     nodes.mark(((Invoke) n).callTarget());
207                 }
208                 if (n instanceof NodeWithState) {
209                     NodeWithState withState = (NodeWithState) n;
210                     withState.states().forEach(state -&gt; state.applyToVirtual(node -&gt; nodes.mark(node)));
211                 }
212                 if (n instanceof AbstractMergeNode) {
213                     // if a merge is in the loop, all of its phis are also in the loop
214                     for (PhiNode phi : ((AbstractMergeNode) n).phis()) {
215                         nodes.mark(phi);
216                     }
217                 }
218                 nodes.mark(n);
219             }
220         }
221         for (AbstractBeginNode earlyExit : earlyExits) {
222             if (earlyExit.isDeleted()) {
223                 continue;
224             }
225 
226             nodes.mark(earlyExit);
227 
228             if (earlyExit instanceof LoopExitNode) {
229                 LoopExitNode loopExit = (LoopExitNode) earlyExit;
230                 FrameState stateAfter = loopExit.stateAfter();
231                 if (stateAfter != null) {
232                     stateAfter.applyToVirtual(node -&gt; nodes.mark(node));
233                 }
234                 for (ProxyNode proxy : loopExit.proxies()) {
235                     nodes.mark(proxy);
236                 }
237             }
238         }
239 
240         final NodeBitMap nonLoopNodes = graph.createNodeBitMap();
241         Deque&lt;WorkListEntry&gt; worklist = new ArrayDeque&lt;&gt;();
242         for (AbstractBeginNode b : blocks) {
243             if (b.isDeleted()) {
244                 continue;
245             }
246 
247             for (Node n : b.getBlockNodes()) {
248                 if (n instanceof CommitAllocationNode) {
249                     for (VirtualObjectNode obj : ((CommitAllocationNode) n).getVirtualObjects()) {
<a name="9" id="anc9"></a><span class="line-modified">250                         markFloating(worklist, loop, obj, nodes, nonLoopNodes);</span>
251                     }
252                 }
253                 if (n instanceof MonitorEnterNode) {
<a name="10" id="anc10"></a><span class="line-modified">254                     markFloating(worklist, loop, ((MonitorEnterNode) n).getMonitorId(), nodes, nonLoopNodes);</span>
255                 }
256                 if (n instanceof AbstractMergeNode) {
257                     /*
258                      * Since we already marked all phi nodes as being in the loop to break cycles,
259                      * we also have to iterate over their usages here.
260                      */
261                     for (PhiNode phi : ((AbstractMergeNode) n).phis()) {
262                         for (Node usage : phi.usages()) {
<a name="11" id="anc11"></a><span class="line-modified">263                             markFloating(worklist, loop, usage, nodes, nonLoopNodes);</span>
264                         }
265                     }
266                 }
267                 for (Node usage : n.usages()) {
<a name="12" id="anc12"></a><span class="line-modified">268                     markFloating(worklist, loop, usage, nodes, nonLoopNodes);</span>
269                 }
270             }
271         }
272     }
273 
274     static class WorkListEntry {
275         final Iterator&lt;Node&gt; usages;
276         final Node n;
277         boolean isLoopNode;
278 
279         WorkListEntry(Node n, NodeBitMap loopNodes) {
280             this.n = n;
281             this.usages = n.usages().iterator();
282             this.isLoopNode = loopNodes.isMarked(n);
283         }
284 
285         @Override
286         public boolean equals(Object obj) {
287             if (!(obj instanceof WorkListEntry)) {
288                 return false;
289             }
290             WorkListEntry other = (WorkListEntry) obj;
291             return this.n == other.n;
292         }
293 
294         @Override
295         public int hashCode() {
296             return n.hashCode();
297         }
298     }
299 
300     static TriState isLoopNode(Node n, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {
301         if (loopNodes.isMarked(n)) {
302             return TriState.TRUE;
303         }
304         if (nonLoopNodes.isMarked(n)) {
305             return TriState.FALSE;
306         }
307         if (n instanceof FixedNode || n instanceof PhiNode) {
308             // phi nodes are treated the same as fixed nodes in this algorithm to break cycles
309             return TriState.FALSE;
310         }
311         return TriState.UNKNOWN;
312     }
313 
314     private static void pushWorkList(Deque&lt;WorkListEntry&gt; workList, Node node, NodeBitMap loopNodes) {
315         WorkListEntry entry = new WorkListEntry(node, loopNodes);
316         assert !workList.contains(entry) : &quot;node &quot; + node + &quot; added to worklist twice&quot;;
317         workList.push(entry);
318     }
319 
<a name="13" id="anc13"></a><span class="line-modified">320     private static void markFloating(Deque&lt;WorkListEntry&gt; workList, LoopEx loop, Node start, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {</span>
321         if (isLoopNode(start, loopNodes, nonLoopNodes).isKnown()) {
322             return;
323         }
<a name="14" id="anc14"></a><span class="line-added">324 </span>
<span class="line-added">325         LoopBeginNode loopBeginNode = loop.loopBegin();</span>
<span class="line-added">326         ControlFlowGraph cfg = loop.loopsData().getCFG();</span>
<span class="line-added">327 </span>
328         pushWorkList(workList, start, loopNodes);
329         while (!workList.isEmpty()) {
330             WorkListEntry currentEntry = workList.peek();
331             if (currentEntry.usages.hasNext()) {
332                 Node current = currentEntry.usages.next();
333                 TriState result = isLoopNode(current, loopNodes, nonLoopNodes);
334                 if (result.isKnown()) {
335                     if (result.toBoolean()) {
336                         currentEntry.isLoopNode = true;
337                     }
338                 } else {
339                     pushWorkList(workList, current, loopNodes);
340                 }
341             } else {
342                 workList.pop();
343                 boolean isLoopNode = currentEntry.isLoopNode;
344                 Node current = currentEntry.n;
<a name="15" id="anc15"></a><span class="line-modified">345                 if (!isLoopNode &amp;&amp; current instanceof GuardNode &amp;&amp; !current.hasUsages()) {</span>
<span class="line-modified">346                     GuardNode guard = (GuardNode) current;</span>
<span class="line-modified">347                     if (isLoopNode(guard.getCondition(), loopNodes, nonLoopNodes) != TriState.FALSE) {</span>
<span class="line-modified">348                         ValueNode anchor = guard.getAnchor().asNode();</span>
<span class="line-modified">349                         TriState isAnchorInLoop = isLoopNode(anchor, loopNodes, nonLoopNodes);</span>
<span class="line-modified">350                         if (isAnchorInLoop != TriState.FALSE) {</span>
<span class="line-modified">351                             if (!(anchor instanceof LoopExitNode &amp;&amp; ((LoopExitNode) anchor).loopBegin() == loopBeginNode)) {</span>
<span class="line-added">352                                 // It is undecidable whether the node is in the loop or not. This is</span>
<span class="line-added">353                                 // not an issue for getting counted loop information,</span>
<span class="line-added">354                                 // but causes issues when using the information for actual loop</span>
<span class="line-added">355                                 // transformations. This is why a loop transformation must</span>
<span class="line-added">356                                 // not happen while guards are floating.</span>
<span class="line-added">357                                 isLoopNode = true;</span>
<span class="line-added">358                             }</span>
<span class="line-added">359                         } else if (AbstractControlFlowGraph.strictlyDominates(cfg.blockFor(anchor), cfg.blockFor(loopBeginNode))) {</span>
<span class="line-added">360                             // The anchor is above the loop. The no-usage guard can potentially be</span>
<span class="line-added">361                             // scheduled inside the loop.</span>
<span class="line-added">362                             isLoopNode = true;</span>
<span class="line-added">363                         }</span>
<span class="line-added">364                     }</span>
365                 }
366                 if (isLoopNode) {
367                     loopNodes.mark(current);
368                     for (WorkListEntry e : workList) {
369                         e.isLoopNode = true;
370                     }
371                 } else {
372                     nonLoopNodes.mark(current);
373                 }
374             }
375         }
376     }
377 
378     public static NodeIterable&lt;AbstractBeginNode&gt; toHirBlocks(final Iterable&lt;Block&gt; blocks) {
379         return new NodeIterable&lt;AbstractBeginNode&gt;() {
380 
381             @Override
382             public Iterator&lt;AbstractBeginNode&gt; iterator() {
383                 final Iterator&lt;Block&gt; it = blocks.iterator();
384                 return new Iterator&lt;AbstractBeginNode&gt;() {
385 
386                     @Override
387                     public void remove() {
388                         throw new UnsupportedOperationException();
389                     }
390 
391                     @Override
392                     public AbstractBeginNode next() {
393                         return it.next().getBeginNode();
394                     }
395 
396                     @Override
397                     public boolean hasNext() {
398                         return it.hasNext();
399                     }
400                 };
401             }
402 
403         };
404     }
405 
406     /**
407      * Merges the early exits (i.e. loop exits) that were duplicated as part of this fragment, with
408      * the original fragment&#39;s exits.
409      */
410     protected void mergeEarlyExits() {
411         assert isDuplicate();
412         StructuredGraph graph = graph();
413         for (AbstractBeginNode earlyExit : LoopFragment.toHirBlocks(original().loop().loop().getLoopExits())) {
414             FixedNode next = earlyExit.next();
415             if (earlyExit.isDeleted() || !this.original().contains(earlyExit)) {
416                 continue;
417             }
418             AbstractBeginNode newEarlyExit = getDuplicatedNode(earlyExit);
419             if (newEarlyExit == null) {
420                 continue;
421             }
422             MergeNode merge = graph.add(new MergeNode());
423             EndNode originalEnd = graph.add(new EndNode());
424             EndNode newEnd = graph.add(new EndNode());
425             merge.addForwardEnd(originalEnd);
426             merge.addForwardEnd(newEnd);
427             earlyExit.setNext(originalEnd);
428             newEarlyExit.setNext(newEnd);
429             merge.setNext(next);
430 
431             FrameState exitState = null;
432             if (earlyExit instanceof LoopExitNode) {
433                 LoopExitNode earlyLoopExit = (LoopExitNode) earlyExit;
434                 exitState = earlyLoopExit.stateAfter();
435                 if (exitState != null) {
436                     FrameState originalExitState = exitState;
437                     exitState = exitState.duplicateWithVirtualState();
438                     earlyLoopExit.setStateAfter(exitState);
439                     merge.setStateAfter(originalExitState);
440                     /*
441                      * Using the old exit&#39;s state as the merge&#39;s state is necessary because some of
442                      * the VirtualState nodes contained in the old exit&#39;s state may be shared by
443                      * other dominated VirtualStates. Those dominated virtual states need to see the
444                      * proxy-&gt;phi update that are applied below.
445                      *
446                      * We now update the original fragment&#39;s nodes accordingly:
447                      */
448                     originalExitState.applyToVirtual(node -&gt; original.nodes.clearAndGrow(node));
449                     exitState.applyToVirtual(node -&gt; original.nodes.markAndGrow(node));
450                 }
451             }
452 
453             for (Node anchored : earlyExit.anchored().snapshot()) {
454                 anchored.replaceFirstInput(earlyExit, merge);
455             }
456 
457             if (earlyExit instanceof LoopExitNode) {
458                 LoopExitNode earlyLoopExit = (LoopExitNode) earlyExit;
459                 FrameState finalExitState = exitState;
460                 boolean newEarlyExitIsLoopExit = newEarlyExit instanceof LoopExitNode;
461                 for (ProxyNode vpn : earlyLoopExit.proxies().snapshot()) {
462                     if (vpn.hasNoUsages()) {
463                         continue;
464                     }
465                     if (vpn.value() == null) {
466                         assert vpn instanceof GuardProxyNode;
467                         vpn.replaceAtUsages(null);
468                         continue;
469                     }
470                     final ValueNode replaceWith;
471                     ValueNode newVpn = prim(newEarlyExitIsLoopExit ? vpn : vpn.value());
472                     if (newVpn != null) {
<a name="16" id="anc16"></a><span class="line-modified">473                         PhiNode phi = vpn.createPhi(merge);</span>







474                         phi.addInput(vpn);
475                         phi.addInput(newVpn);
476                         replaceWith = phi;
477                     } else {
478                         replaceWith = vpn.value();
479                     }
480                     vpn.replaceAtMatchingUsages(replaceWith, usage -&gt; {
481                         if (merge.isPhiAtMerge(usage)) {
482                             return false;
483                         }
484                         if (usage instanceof VirtualState) {
485                             VirtualState stateUsage = (VirtualState) usage;
486                             if (finalExitState != null &amp;&amp; finalExitState.isPartOfThisState(stateUsage)) {
487                                 return false;
488                             }
489                         }
490                         return true;
491                     });
492                 }
493             }
494         }
495     }
496 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
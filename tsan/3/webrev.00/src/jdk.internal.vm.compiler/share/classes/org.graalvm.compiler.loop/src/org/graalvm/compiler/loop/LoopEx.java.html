<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopEx.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.loop;
 26 
 27 import java.util.Collection;
 28 import java.util.LinkedList;
 29 import java.util.Queue;
 30 
 31 import jdk.internal.vm.compiler.collections.EconomicMap;
 32 import jdk.internal.vm.compiler.collections.EconomicSet;
 33 import jdk.internal.vm.compiler.collections.Equivalence;
 34 import org.graalvm.compiler.core.common.calc.Condition;
 35 import org.graalvm.compiler.core.common.cfg.Loop;
 36 import org.graalvm.compiler.core.common.type.IntegerStamp;
 37 import org.graalvm.compiler.debug.DebugContext;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.graph.Graph;
 40 import org.graalvm.compiler.graph.Node;
 41 import org.graalvm.compiler.graph.NodeBitMap;
 42 import org.graalvm.compiler.graph.iterators.NodePredicate;
 43 import org.graalvm.compiler.loop.InductionVariable.Direction;
 44 import org.graalvm.compiler.nodes.AbstractBeginNode;
 45 import org.graalvm.compiler.nodes.AbstractEndNode;
 46 import org.graalvm.compiler.nodes.ConstantNode;
 47 import org.graalvm.compiler.nodes.FixedGuardNode;
 48 import org.graalvm.compiler.nodes.FixedNode;
 49 import org.graalvm.compiler.nodes.FixedWithNextNode;
 50 import org.graalvm.compiler.nodes.FrameState;
 51 import org.graalvm.compiler.nodes.FullInfopointNode;
 52 import org.graalvm.compiler.nodes.IfNode;
 53 import org.graalvm.compiler.nodes.LogicNode;
 54 import org.graalvm.compiler.nodes.LoopBeginNode;
 55 import org.graalvm.compiler.nodes.NodeView;
 56 import org.graalvm.compiler.nodes.PhiNode;
 57 import org.graalvm.compiler.nodes.PiNode;
 58 import org.graalvm.compiler.nodes.StructuredGraph;
 59 import org.graalvm.compiler.nodes.ValueNode;
 60 import org.graalvm.compiler.nodes.ValuePhiNode;
 61 import org.graalvm.compiler.nodes.calc.AddNode;
 62 import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;
 63 import org.graalvm.compiler.nodes.calc.CompareNode;
 64 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 65 import org.graalvm.compiler.nodes.calc.MulNode;
 66 import org.graalvm.compiler.nodes.calc.NegateNode;
 67 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 68 import org.graalvm.compiler.nodes.calc.SubNode;
 69 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 70 import org.graalvm.compiler.nodes.cfg.Block;
 71 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 72 import org.graalvm.compiler.nodes.debug.ControlFlowAnchored;
 73 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
 74 import org.graalvm.compiler.nodes.util.GraphUtil;
 75 
 76 public class LoopEx {
 77     private final Loop&lt;Block&gt; loop;
 78     private LoopFragmentInside inside;
 79     private LoopFragmentWhole whole;
 80     private CountedLoopInfo counted;
 81     private LoopsData data;
 82     private EconomicMap&lt;Node, InductionVariable&gt; ivs;
 83     private boolean countedLoopChecked;
 84     private int size = -1;
 85 
 86     LoopEx(Loop&lt;Block&gt; loop, LoopsData data) {
 87         this.loop = loop;
 88         this.data = data;
 89     }
 90 
 91     public Loop&lt;Block&gt; loop() {
 92         return loop;
 93     }
 94 
 95     public LoopFragmentInside inside() {
 96         if (inside == null) {
 97             inside = new LoopFragmentInside(this);
 98         }
 99         return inside;
100     }
101 
102     public LoopFragmentWhole whole() {
103         if (whole == null) {
104             whole = new LoopFragmentWhole(this);
105         }
106         return whole;
107     }
108 
109     public void invalidateFragments() {
110         inside = null;
111         whole = null;
112     }
113 
114     @SuppressWarnings(&quot;unused&quot;)
115     public LoopFragmentInsideFrom insideFrom(FixedNode point) {
116         // TODO (gd)
117         return null;
118     }
119 
120     @SuppressWarnings(&quot;unused&quot;)
121     public LoopFragmentInsideBefore insideBefore(FixedNode point) {
122         // TODO (gd)
123         return null;
124     }
125 
126     public boolean isOutsideLoop(Node n) {
127         return !whole().contains(n);
128     }
129 
130     public LoopBeginNode loopBegin() {
131         return (LoopBeginNode) loop().getHeader().getBeginNode();
132     }
133 
134     public FixedNode predecessor() {
135         return (FixedNode) loopBegin().forwardEnd().predecessor();
136     }
137 
138     public FixedNode entryPoint() {
139         return loopBegin().forwardEnd();
140     }
141 
142     public boolean isCounted() {
143         assert countedLoopChecked;
144         return counted != null;
145     }
146 
147     public CountedLoopInfo counted() {
148         assert countedLoopChecked;
149         return counted;
150     }
151 
152     public LoopEx parent() {
153         if (loop.getParent() == null) {
154             return null;
155         }
156         return data.loop(loop.getParent());
157     }
158 
159     public int size() {
160         if (size == -1) {
161             size = whole().nodes().count();
162         }
163         return size;
164     }
165 
166     @Override
167     public String toString() {
168         return (countedLoopChecked &amp;&amp; isCounted() ? &quot;CountedLoop [&quot; + counted() + &quot;] &quot; : &quot;Loop &quot;) + &quot;(depth=&quot; + loop().getDepth() + &quot;) &quot; + loopBegin();
169     }
170 
171     private class InvariantPredicate implements NodePredicate {
172 
173         private final Graph.Mark mark;
174 
175         InvariantPredicate() {
176             this.mark = loopBegin().graph().getMark();
177         }
178 
179         @Override
180         public boolean apply(Node n) {
181             if (loopBegin().graph().isNew(mark, n)) {
182                 // Newly created nodes are unknown.
183                 return false;
184             }
185             return isOutsideLoop(n);
186         }
187     }
188 
189     public boolean reassociateInvariants() {
190         int count = 0;
191         StructuredGraph graph = loopBegin().graph();
192         InvariantPredicate invariant = new InvariantPredicate();
193         for (BinaryArithmeticNode&lt;?&gt; binary : whole().nodes().filter(BinaryArithmeticNode.class)) {
194             if (!binary.isAssociative()) {
195                 continue;
196             }
197             ValueNode result = BinaryArithmeticNode.reassociate(binary, invariant, binary.getX(), binary.getY(), NodeView.DEFAULT);
198             if (result != binary) {
199                 if (!result.isAlive()) {
200                     assert !result.isDeleted();
201                     result = graph.addOrUniqueWithInputs(result);
202                 }
203                 DebugContext debug = graph.getDebug();
204                 if (debug.isLogEnabled()) {
205                     debug.log(&quot;%s : Reassociated %s into %s&quot;, graph.method().format(&quot;%H::%n&quot;), binary, result);
206                 }
207                 binary.replaceAtUsages(result);
208                 GraphUtil.killWithUnusedFloatingInputs(binary);
209                 count++;
210             }
211         }
212         return count != 0;
213     }
214 
215     @SuppressWarnings(&quot;fallthrough&quot;)
216     public boolean detectCounted() {
217         if (countedLoopChecked) {
218             return isCounted();
219         }
220         countedLoopChecked = true;
221         LoopBeginNode loopBegin = loopBegin();
222         FixedNode next = loopBegin.next();
223         while (next instanceof FixedGuardNode || next instanceof ValueAnchorNode || next instanceof FullInfopointNode) {
224             next = ((FixedWithNextNode) next).next();
225         }
226         if (next instanceof IfNode) {
227             IfNode ifNode = (IfNode) next;
228             boolean negated = false;
229             if (!isCfgLoopExit(ifNode.falseSuccessor())) {
230                 if (!isCfgLoopExit(ifNode.trueSuccessor())) {
231                     return false;
232                 }
233                 negated = true;
234             }
235             LogicNode ifTest = ifNode.condition();
236             if (!(ifTest instanceof CompareNode)) {
237                 return false;
238             }
239             CompareNode compare = (CompareNode) ifTest;
240             Condition condition = null;
241             InductionVariable iv = null;
242             ValueNode limit = null;
243             if (isOutsideLoop(compare.getX())) {
244                 iv = getInductionVariables().get(compare.getY());
245                 if (iv != null) {
246                     condition = compare.condition().asCondition().mirror();
247                     limit = compare.getX();
248                 }
249             } else if (isOutsideLoop(compare.getY())) {
250                 iv = getInductionVariables().get(compare.getX());
251                 if (iv != null) {
252                     condition = compare.condition().asCondition();
253                     limit = compare.getY();
254                 }
255             }
256             if (condition == null) {
257                 return false;
258             }
259             if (negated) {
260                 condition = condition.negate();
261             }
262             boolean oneOff = false;
263             boolean unsigned = false;
264             switch (condition) {
265                 case EQ:
266                     if (iv.initNode() == limit) {
267                         // allow &quot;single iteration&quot; case
268                         oneOff = true;
269                     } else {
270                         return false;
271                     }
272                     break;
273                 case NE: {
274                     IntegerStamp initStamp = (IntegerStamp) iv.initNode().stamp(NodeView.DEFAULT);
275                     IntegerStamp limitStamp = (IntegerStamp) limit.stamp(NodeView.DEFAULT);
276                     IntegerStamp counterStamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);
277                     if (iv.direction() == Direction.Up) {
278                         if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.upperBound()) {
279                             // signed: i &lt; MAX_INT
280                         } else if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.unsignedUpperBound()) {
281                             unsigned = true;
282                         } else if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1 || initStamp.upperBound() &gt; limitStamp.lowerBound()) {
283                             return false;
284                         }
285                     } else if (iv.direction() == Direction.Down) {
286                         if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.lowerBound()) {
287                             // signed: MIN_INT &gt; i
288                         } else if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.unsignedLowerBound()) {
289                             unsigned = true;
290                         } else if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1 || initStamp.lowerBound() &lt; limitStamp.upperBound()) {
291                             return false;
292                         }
293                     } else {
294                         return false;
295                     }
296                     break;
297                 }
298                 case BE:
299                     unsigned = true; // fall through
300                 case LE:
301                     oneOff = true;
302                     if (iv.direction() != Direction.Up) {
303                         return false;
304                     }
305                     break;
306                 case BT:
307                     unsigned = true; // fall through
308                 case LT:
309                     if (iv.direction() != Direction.Up) {
310                         return false;
311                     }
312                     break;
313                 case AE:
314                     unsigned = true; // fall through
315                 case GE:
316                     oneOff = true;
317                     if (iv.direction() != Direction.Down) {
318                         return false;
319                     }
320                     break;
321                 case AT:
322                     unsigned = true; // fall through
323                 case GT:
324                     if (iv.direction() != Direction.Down) {
325                         return false;
326                     }
327                     break;
328                 default:
329                     throw GraalError.shouldNotReachHere(condition.toString());
330             }
331             counted = new CountedLoopInfo(this, iv, ifNode, limit, oneOff, negated ? ifNode.falseSuccessor() : ifNode.trueSuccessor(), unsigned);
332             return true;
333         }
334         return false;
335     }
336 
337     private boolean isCfgLoopExit(AbstractBeginNode begin) {
338         Block block = data.getCFG().blockFor(begin);
339         return loop.getDepth() &gt; block.getLoopDepth() || loop.isNaturalExit(block);
340     }
341 
342     public LoopsData loopsData() {
343         return data;
344     }
345 
346     public void nodesInLoopBranch(NodeBitMap branchNodes, AbstractBeginNode branch) {
347         EconomicSet&lt;AbstractBeginNode&gt; blocks = EconomicSet.create();
348         Collection&lt;AbstractBeginNode&gt; exits = new LinkedList&lt;&gt;();
349         Queue&lt;Block&gt; work = new LinkedList&lt;&gt;();
350         ControlFlowGraph cfg = loopsData().getCFG();
351         work.add(cfg.blockFor(branch));
352         while (!work.isEmpty()) {
353             Block b = work.remove();
354             if (loop().isLoopExit(b)) {
355                 assert !exits.contains(b.getBeginNode());
356                 exits.add(b.getBeginNode());
357             } else if (blocks.add(b.getBeginNode())) {
358                 Block d = b.getDominatedSibling();
359                 while (d != null) {
360                     if (loop.getBlocks().contains(d)) {
361                         work.add(d);
362                     }
363                     d = d.getDominatedSibling();
364                 }
365             }
366         }
367         LoopFragment.computeNodes(branchNodes, branch.graph(), this, blocks, exits);
368     }
369 
370     public EconomicMap&lt;Node, InductionVariable&gt; getInductionVariables() {
371         if (ivs == null) {
372             ivs = findInductionVariables(this);
373         }
374         return ivs;
375     }
376 
377     /**
378      * Collect all the basic induction variables for the loop and the find any induction variables
379      * which are derived from the basic ones.
380      *
381      * @param loop
382      * @return a map from node to induction variable
383      */
384     private static EconomicMap&lt;Node, InductionVariable&gt; findInductionVariables(LoopEx loop) {
385         EconomicMap&lt;Node, InductionVariable&gt; ivs = EconomicMap.create(Equivalence.IDENTITY);
386 
387         Queue&lt;InductionVariable&gt; scanQueue = new LinkedList&lt;&gt;();
388         LoopBeginNode loopBegin = loop.loopBegin();
389         AbstractEndNode forwardEnd = loopBegin.forwardEnd();
390         for (PhiNode phi : loopBegin.valuePhis()) {
391             ValueNode backValue = phi.singleBackValueOrThis();
392             if (backValue == phi) {
393                 continue;
394             }
395             ValueNode stride = addSub(loop, backValue, phi);
396             if (stride != null) {
397                 BasicInductionVariable biv = new BasicInductionVariable(loop, (ValuePhiNode) phi, phi.valueAt(forwardEnd), stride, (BinaryArithmeticNode&lt;?&gt;) backValue);
398                 ivs.put(phi, biv);
399                 scanQueue.add(biv);
400             }
401         }
402 
403         while (!scanQueue.isEmpty()) {
404             InductionVariable baseIv = scanQueue.remove();
405             ValueNode baseIvNode = baseIv.valueNode();
406             for (ValueNode op : baseIvNode.usages().filter(ValueNode.class)) {
407                 if (loop.isOutsideLoop(op)) {
408                     continue;
409                 }
410                 if (op.hasExactlyOneUsage() &amp;&amp; op.usages().first() == baseIvNode) {
411                     /*
412                      * This is just the base induction variable increment with no other uses so
413                      * don&#39;t bother reporting it.
414                      */
415                     continue;
416                 }
417                 InductionVariable iv = null;
418                 ValueNode offset = addSub(loop, op, baseIvNode);
419                 ValueNode scale;
420                 if (offset != null) {
421                     iv = new DerivedOffsetInductionVariable(loop, baseIv, offset, (BinaryArithmeticNode&lt;?&gt;) op);
422                 } else if (op instanceof NegateNode) {
423                     iv = new DerivedScaledInductionVariable(loop, baseIv, (NegateNode) op);
424                 } else if ((scale = mul(loop, op, baseIvNode)) != null) {
425                     iv = new DerivedScaledInductionVariable(loop, baseIv, scale, op);
426                 } else {
427                     boolean isValidConvert = op instanceof PiNode || op instanceof SignExtendNode;
428                     if (!isValidConvert &amp;&amp; op instanceof ZeroExtendNode) {
429                         ZeroExtendNode zeroExtendNode = (ZeroExtendNode) op;
430                         isValidConvert = zeroExtendNode.isInputAlwaysPositive() || ((IntegerStamp) zeroExtendNode.stamp(NodeView.DEFAULT)).isPositive();
431                     }
432 
433                     if (isValidConvert) {
434                         iv = new DerivedConvertedInductionVariable(loop, baseIv, op.stamp(NodeView.DEFAULT), op);
435                     }
436                 }
437 
438                 if (iv != null) {
439                     ivs.put(op, iv);
440                     scanQueue.offer(iv);
441                 }
442             }
443         }
444         return ivs;
445     }
446 
447     private static ValueNode addSub(LoopEx loop, ValueNode op, ValueNode base) {
448         if (op.stamp(NodeView.DEFAULT) instanceof IntegerStamp &amp;&amp; (op instanceof AddNode || op instanceof SubNode)) {
449             BinaryArithmeticNode&lt;?&gt; aritOp = (BinaryArithmeticNode&lt;?&gt;) op;
450             if (aritOp.getX() == base &amp;&amp; loop.isOutsideLoop(aritOp.getY())) {
451                 return aritOp.getY();
452             } else if (aritOp.getY() == base &amp;&amp; loop.isOutsideLoop(aritOp.getX())) {
453                 return aritOp.getX();
454             }
455         }
456         return null;
457     }
458 
459     private static ValueNode mul(LoopEx loop, ValueNode op, ValueNode base) {
460         if (op instanceof MulNode) {
461             MulNode mul = (MulNode) op;
462             if (mul.getX() == base &amp;&amp; loop.isOutsideLoop(mul.getY())) {
463                 return mul.getY();
464             } else if (mul.getY() == base &amp;&amp; loop.isOutsideLoop(mul.getX())) {
465                 return mul.getX();
466             }
467         }
468         if (op instanceof LeftShiftNode) {
469             LeftShiftNode shift = (LeftShiftNode) op;
470             if (shift.getX() == base &amp;&amp; shift.getY().isConstant()) {
471                 return ConstantNode.forIntegerStamp(base.stamp(NodeView.DEFAULT), 1 &lt;&lt; shift.getY().asJavaConstant().asInt(), base.graph());
472             }
473         }
474         return null;
475     }
476 
477     /**
478      * Deletes any nodes created within the scope of this object that have no usages.
479      */
480     public void deleteUnusedNodes() {
481         if (ivs != null) {
482             for (InductionVariable iv : ivs.getValues()) {
483                 iv.deleteUnusedNodes();
484             }
485         }
486     }
487 
488     /**
489      * @return true if all nodes in the loop can be duplicated.
490      */
491     public boolean canDuplicateLoop() {
492         for (Node node : inside().nodes()) {
493             if (node instanceof ControlFlowAnchored) {
494                 return false;
495             }
496             if (node instanceof FrameState) {
497                 FrameState frameState = (FrameState) node;
498                 if (frameState.isExceptionHandlingBCI()) {
499                     return false;
500                 }
501             }
502         }
503         return true;
504     }
505 }
    </pre>
  </body>
</html>
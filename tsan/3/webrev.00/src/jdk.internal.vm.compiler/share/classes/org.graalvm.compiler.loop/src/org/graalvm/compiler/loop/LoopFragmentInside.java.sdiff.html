<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragmentInside.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoopFragment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragmentWhole.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragmentInside.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 54 import org.graalvm.compiler.nodes.LoopEndNode;
 55 import org.graalvm.compiler.nodes.LoopExitNode;
 56 import org.graalvm.compiler.nodes.MergeNode;
 57 import org.graalvm.compiler.nodes.NodeView;
 58 import org.graalvm.compiler.nodes.PhiNode;
 59 import org.graalvm.compiler.nodes.ProxyNode;
 60 import org.graalvm.compiler.nodes.SafepointNode;
 61 import org.graalvm.compiler.nodes.StateSplit;
 62 import org.graalvm.compiler.nodes.StructuredGraph;
 63 import org.graalvm.compiler.nodes.ValueNode;
 64 import org.graalvm.compiler.nodes.ValuePhiNode;
 65 import org.graalvm.compiler.nodes.VirtualState.NodeClosure;
 66 import org.graalvm.compiler.nodes.calc.AddNode;
 67 import org.graalvm.compiler.nodes.calc.CompareNode;
 68 import org.graalvm.compiler.nodes.calc.ConditionalNode;
 69 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 70 import org.graalvm.compiler.nodes.calc.SubNode;
 71 import org.graalvm.compiler.nodes.extended.OpaqueNode;
 72 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 73 import org.graalvm.compiler.nodes.util.GraphUtil;
<span class="line-modified"> 74 </span>
<span class="line-removed"> 75 import jdk.vm.ci.code.CodeUtil;</span>
 76 
 77 public class LoopFragmentInside extends LoopFragment {
 78 
 79     /**
 80      * mergedInitializers. When an inside fragment&#39;s (loop)ends are merged to create a unique exit
 81      * point, some phis must be created : they phis together all the back-values of the loop-phis
 82      * These can then be used to update the loop-phis&#39; forward edge value (&#39;initializer&#39;) in the
 83      * peeling case. In the unrolling case they will be used as the value that replace the loop-phis
 84      * of the duplicated inside fragment
 85      */
 86     private EconomicMap&lt;PhiNode, ValueNode&gt; mergedInitializers;
 87     private final DuplicationReplacement dataFixBefore = new DuplicationReplacement() {
 88 
 89         @Override
 90         public Node replacement(Node oriInput) {
 91             if (!(oriInput instanceof ValueNode)) {
 92                 return oriInput;
 93             }
 94             return prim((ValueNode) oriInput);
 95         }
</pre>
<hr />
<pre>
152         loop.entryPoint().replaceAtPredecessor(entry);
153         end.setNext(loop.entryPoint());
154     }
155 
156     /**
157      * Duplicate the body within the loop after the current copy copy of the body, updating the
158      * iteration limit to account for the duplication.
159      */
160     public void insertWithinAfter(LoopEx loop, EconomicMap&lt;LoopBeginNode, OpaqueNode&gt; opaqueUnrolledStrides) {
161         assert isDuplicate() &amp;&amp; original().loop() == loop;
162 
163         patchNodes(dataFixWithinAfter);
164 
165         /*
166          * Collect any new back edges values before updating them since they might reference each
167          * other.
168          */
169         LoopBeginNode mainLoopBegin = loop.loopBegin();
170         ArrayList&lt;ValueNode&gt; backedgeValues = new ArrayList&lt;&gt;();
171         for (PhiNode mainPhiNode : mainLoopBegin.phis()) {
<span class="line-modified">172             ValueNode duplicatedNode = getDuplicatedNode(mainPhiNode.valueAt(1));</span>

173             if (duplicatedNode == null) {
<span class="line-modified">174                 if (mainLoopBegin.isPhiAtMerge(mainPhiNode.valueAt(1))) {</span>
<span class="line-modified">175                     duplicatedNode = ((PhiNode) (mainPhiNode.valueAt(1))).valueAt(1);</span>
176                 } else {
<span class="line-modified">177                     assert mainPhiNode.valueAt(1).isConstant() : mainPhiNode.valueAt(1);</span>
178                 }
179             }
180             backedgeValues.add(duplicatedNode);
181         }
182         int index = 0;
183         for (PhiNode mainPhiNode : mainLoopBegin.phis()) {
184             ValueNode duplicatedNode = backedgeValues.get(index++);
185             if (duplicatedNode != null) {
186                 mainPhiNode.setValueAt(1, duplicatedNode);
187             }
188         }
189 
190         placeNewSegmentAndCleanup(loop);
191 
192         // Remove any safepoints from the original copy leaving only the duplicated one
193         assert loop.whole().nodes().filter(SafepointNode.class).count() == nodes().filter(SafepointNode.class).count();
194         for (SafepointNode safepoint : loop.whole().nodes().filter(SafepointNode.class)) {
195             graph().removeFixed(safepoint);
196         }
197 
198         StructuredGraph graph = mainLoopBegin.graph();
199         if (opaqueUnrolledStrides != null) {
200             OpaqueNode opaque = opaqueUnrolledStrides.get(loop.loopBegin());
201             CountedLoopInfo counted = loop.counted();
202             ValueNode counterStride = counted.getCounter().strideNode();
203             if (opaque == null) {
204                 opaque = new OpaqueNode(AddNode.add(counterStride, counterStride, NodeView.DEFAULT));
205                 ValueNode limit = counted.getLimit();
206                 int bits = ((IntegerStamp) limit.stamp(NodeView.DEFAULT)).getBits();
207                 ValueNode newLimit = SubNode.create(limit, opaque, NodeView.DEFAULT);

208                 LogicNode overflowCheck;
209                 ConstantNode extremum;
210                 if (counted.getDirection() == InductionVariable.Direction.Up) {
211                     // limit - counterStride could overflow negatively if limit - min &lt;
212                     // counterStride
<span class="line-modified">213                     extremum = ConstantNode.forIntegerBits(bits, CodeUtil.minValue(bits));</span>
214                     overflowCheck = IntegerBelowNode.create(SubNode.create(limit, extremum, NodeView.DEFAULT), opaque, NodeView.DEFAULT);
215                 } else {
216                     assert counted.getDirection() == InductionVariable.Direction.Down;
217                     // limit - counterStride could overflow if max - limit &lt; -counterStride
218                     // i.e., counterStride &lt; limit - max
<span class="line-modified">219                     extremum = ConstantNode.forIntegerBits(bits, CodeUtil.maxValue(bits));</span>
220                     overflowCheck = IntegerBelowNode.create(opaque, SubNode.create(limit, extremum, NodeView.DEFAULT), NodeView.DEFAULT);
221                 }
222                 newLimit = ConditionalNode.create(overflowCheck, extremum, newLimit, NodeView.DEFAULT);
223                 CompareNode compareNode = (CompareNode) counted.getLimitTest().condition();
224                 compareNode.replaceFirstInput(limit, graph.addOrUniqueWithInputs(newLimit));
225                 opaqueUnrolledStrides.put(loop.loopBegin(), opaque);
226             } else {
227                 assert counted.getCounter().isConstantStride();
228                 assert Math.addExact(counted.getCounter().constantStride(), counted.getCounter().constantStride()) == counted.getCounter().constantStride() * 2;
229                 ValueNode previousValue = opaque.getValue();
230                 opaque.setValue(graph.addOrUniqueWithInputs(AddNode.add(counterStride, previousValue, NodeView.DEFAULT)));
231                 GraphUtil.tryKillUnused(previousValue);
232             }
233         }
234         mainLoopBegin.setUnrollFactor(mainLoopBegin.getUnrollFactor() * 2);
<span class="line-modified">235         mainLoopBegin.setLoopFrequency(mainLoopBegin.loopFrequency() / 2);</span>
236         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;LoopPartialUnroll %s&quot;, loop);
237 
238         mainLoopBegin.getDebug().dump(DebugContext.VERBOSE_LEVEL, mainLoopBegin.graph(), &quot;After insertWithinAfter %s&quot;, mainLoopBegin);
239     }
240 
241     private void placeNewSegmentAndCleanup(LoopEx loop) {
242         CountedLoopInfo mainCounted = loop.counted();
243         LoopBeginNode mainLoopBegin = loop.loopBegin();
244         // Discard the segment entry and its flow, after if merging it into the loop
245         StructuredGraph graph = mainLoopBegin.graph();
246         IfNode loopTest = mainCounted.getLimitTest();
<span class="line-modified">247         IfNode newSegmentTest = getDuplicatedNode(loopTest);</span>
<span class="line-modified">248         AbstractBeginNode trueSuccessor = loopTest.trueSuccessor();</span>
<span class="line-modified">249         AbstractBeginNode falseSuccessor = loopTest.falseSuccessor();</span>
<span class="line-modified">250         FixedNode firstNode;</span>
<span class="line-removed">251         boolean codeInTrueSide = false;</span>
<span class="line-removed">252         if (trueSuccessor == mainCounted.getBody()) {</span>
<span class="line-removed">253             firstNode = trueSuccessor.next();</span>
<span class="line-removed">254             codeInTrueSide = true;</span>
<span class="line-removed">255         } else {</span>
<span class="line-removed">256             assert (falseSuccessor == mainCounted.getBody());</span>
<span class="line-removed">257             firstNode = falseSuccessor.next();</span>
<span class="line-removed">258         }</span>
<span class="line-removed">259         trueSuccessor = newSegmentTest.trueSuccessor();</span>
<span class="line-removed">260         falseSuccessor = newSegmentTest.falseSuccessor();</span>
261         for (Node usage : falseSuccessor.anchored().snapshot()) {
262             usage.replaceFirstInput(falseSuccessor, loopTest.falseSuccessor());
263         }

264         for (Node usage : trueSuccessor.anchored().snapshot()) {
265             usage.replaceFirstInput(trueSuccessor, loopTest.trueSuccessor());
266         }
<span class="line-modified">267         AbstractBeginNode startBlockNode;</span>
<span class="line-modified">268         if (codeInTrueSide) {</span>
<span class="line-modified">269             startBlockNode = trueSuccessor;</span>
<span class="line-modified">270         } else {</span>
<span class="line-modified">271             graph.getDebug().dump(DebugContext.VERBOSE_LEVEL, mainLoopBegin.graph(), &quot;before&quot;);</span>
<span class="line-modified">272             startBlockNode = falseSuccessor;</span>
<span class="line-removed">273         }</span>
<span class="line-removed">274         FixedNode lastNode = getBlockEnd(startBlockNode);</span>
<span class="line-removed">275         LoopEndNode loopEndNode = mainLoopBegin.getSingleLoopEnd();</span>
<span class="line-removed">276         FixedWithNextNode lastCodeNode = (FixedWithNextNode) loopEndNode.predecessor();</span>
<span class="line-removed">277         FixedNode newSegmentFirstNode = getDuplicatedNode(firstNode);</span>
<span class="line-removed">278         FixedWithNextNode newSegmentLastNode = getDuplicatedNode(lastCodeNode);</span>
<span class="line-removed">279         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, loopEndNode.graph(), &quot;Before placing segment&quot;);</span>
<span class="line-removed">280         if (firstNode instanceof LoopEndNode) {</span>
281             GraphUtil.killCFG(getDuplicatedNode(mainLoopBegin));
282         } else {
<span class="line-modified">283             newSegmentLastNode.clearSuccessors();</span>
<span class="line-modified">284             startBlockNode.setNext(lastNode);</span>






285             lastCodeNode.replaceFirstSuccessor(loopEndNode, newSegmentFirstNode);
<span class="line-modified">286             newSegmentLastNode.replaceFirstSuccessor(lastNode, loopEndNode);</span>
<span class="line-modified">287             lastCodeNode.setNext(newSegmentFirstNode);</span>
<span class="line-modified">288             newSegmentLastNode.setNext(loopEndNode);</span>
<span class="line-modified">289             startBlockNode.clearSuccessors();</span>
<span class="line-removed">290             lastNode.safeDelete();</span>
<span class="line-removed">291             Node newSegmentTestStart = newSegmentTest.predecessor();</span>
<span class="line-removed">292             LogicNode newSegmentIfTest = newSegmentTest.condition();</span>
<span class="line-removed">293             newSegmentTestStart.clearSuccessors();</span>
<span class="line-removed">294             newSegmentTest.safeDelete();</span>
<span class="line-removed">295             newSegmentIfTest.safeDelete();</span>
<span class="line-removed">296             trueSuccessor.safeDelete();</span>
<span class="line-removed">297             falseSuccessor.safeDelete();</span>
<span class="line-removed">298             newSegmentTestStart.safeDelete();</span>
299         }
<span class="line-modified">300         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, loopEndNode.graph(), &quot;After placing segment&quot;);</span>
301     }
302 
303     private static EndNode getBlockEnd(FixedNode node) {
304         FixedNode curNode = node;
305         while (curNode instanceof FixedWithNextNode) {
306             curNode = ((FixedWithNextNode) curNode).next();
307         }
308         return (EndNode) curNode;
309     }
310 
311     @Override
312     public NodeBitMap nodes() {
313         if (nodes == null) {
314             LoopFragmentWhole whole = loop().whole();
315             whole.nodes(); // init nodes bitmap in whole
316             nodes = whole.nodes.copy();
317             // remove the phis
318             LoopBeginNode loopBegin = loop().loopBegin();
319             for (PhiNode phi : loopBegin.phis()) {
320                 nodes.clear(phi);
</pre>
<hr />
<pre>
440             PhiNode newPhi = patchPhi(graph, phi, loopBegin);
441             newPhi.addInput(first);
442             for (LoopEndNode end : loopBegin.orderedLoopEnds()) {
443                 newPhi.addInput(phi.valueAt(end));
444             }
445             peel.putDuplicatedNode(phi, newPhi);
446             newPhis.add(newPhi);
447             for (Node usage : phi.usages().snapshot()) {
448                 // patch only usages that should use the new phi ie usages that were peeled
449                 if (usagesToPatch.isMarkedAndGrow(usage)) {
450                     usage.replaceFirstInput(phi, newPhi);
451                 }
452             }
453         }
454         // check new phis to see if they have as input some old phis, replace those inputs with the
455         // new corresponding phis
456         for (PhiNode phi : newPhis) {
457             for (int i = 0; i &lt; phi.valueCount(); i++) {
458                 ValueNode v = phi.valueAt(i);
459                 if (loopBegin.isPhiAtMerge(v)) {
<span class="line-modified">460                     PhiNode newV = peel.getDuplicatedNode((ValuePhiNode) v);</span>
461                     if (newV != null) {
462                         phi.setValueAt(i, newV);
463                     }
464                 }
465             }
466         }
467 
468         boolean progress = true;
469         while (progress) {
470             progress = false;
471             int i = 0;
472             outer: while (i &lt; oldPhis.size()) {
473                 PhiNode oldPhi = oldPhis.get(i);
474                 for (Node usage : oldPhi.usages()) {
475                     if (usage instanceof PhiNode &amp;&amp; oldPhis.contains(usage)) {
476                         // Do not mark.
477                     } else {
478                         // Mark alive by removing from delete set.
479                         oldPhis.remove(i);
480                         progress = true;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 54 import org.graalvm.compiler.nodes.LoopEndNode;
 55 import org.graalvm.compiler.nodes.LoopExitNode;
 56 import org.graalvm.compiler.nodes.MergeNode;
 57 import org.graalvm.compiler.nodes.NodeView;
 58 import org.graalvm.compiler.nodes.PhiNode;
 59 import org.graalvm.compiler.nodes.ProxyNode;
 60 import org.graalvm.compiler.nodes.SafepointNode;
 61 import org.graalvm.compiler.nodes.StateSplit;
 62 import org.graalvm.compiler.nodes.StructuredGraph;
 63 import org.graalvm.compiler.nodes.ValueNode;
 64 import org.graalvm.compiler.nodes.ValuePhiNode;
 65 import org.graalvm.compiler.nodes.VirtualState.NodeClosure;
 66 import org.graalvm.compiler.nodes.calc.AddNode;
 67 import org.graalvm.compiler.nodes.calc.CompareNode;
 68 import org.graalvm.compiler.nodes.calc.ConditionalNode;
 69 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 70 import org.graalvm.compiler.nodes.calc.SubNode;
 71 import org.graalvm.compiler.nodes.extended.OpaqueNode;
 72 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 73 import org.graalvm.compiler.nodes.util.GraphUtil;
<span class="line-modified"> 74 import org.graalvm.compiler.nodes.util.IntegerHelper;</span>

 75 
 76 public class LoopFragmentInside extends LoopFragment {
 77 
 78     /**
 79      * mergedInitializers. When an inside fragment&#39;s (loop)ends are merged to create a unique exit
 80      * point, some phis must be created : they phis together all the back-values of the loop-phis
 81      * These can then be used to update the loop-phis&#39; forward edge value (&#39;initializer&#39;) in the
 82      * peeling case. In the unrolling case they will be used as the value that replace the loop-phis
 83      * of the duplicated inside fragment
 84      */
 85     private EconomicMap&lt;PhiNode, ValueNode&gt; mergedInitializers;
 86     private final DuplicationReplacement dataFixBefore = new DuplicationReplacement() {
 87 
 88         @Override
 89         public Node replacement(Node oriInput) {
 90             if (!(oriInput instanceof ValueNode)) {
 91                 return oriInput;
 92             }
 93             return prim((ValueNode) oriInput);
 94         }
</pre>
<hr />
<pre>
151         loop.entryPoint().replaceAtPredecessor(entry);
152         end.setNext(loop.entryPoint());
153     }
154 
155     /**
156      * Duplicate the body within the loop after the current copy copy of the body, updating the
157      * iteration limit to account for the duplication.
158      */
159     public void insertWithinAfter(LoopEx loop, EconomicMap&lt;LoopBeginNode, OpaqueNode&gt; opaqueUnrolledStrides) {
160         assert isDuplicate() &amp;&amp; original().loop() == loop;
161 
162         patchNodes(dataFixWithinAfter);
163 
164         /*
165          * Collect any new back edges values before updating them since they might reference each
166          * other.
167          */
168         LoopBeginNode mainLoopBegin = loop.loopBegin();
169         ArrayList&lt;ValueNode&gt; backedgeValues = new ArrayList&lt;&gt;();
170         for (PhiNode mainPhiNode : mainLoopBegin.phis()) {
<span class="line-modified">171             ValueNode originalNode = mainPhiNode.valueAt(1);</span>
<span class="line-added">172             ValueNode duplicatedNode = getDuplicatedNode(originalNode);</span>
173             if (duplicatedNode == null) {
<span class="line-modified">174                 if (mainLoopBegin.isPhiAtMerge(originalNode)) {</span>
<span class="line-modified">175                     duplicatedNode = ((PhiNode) (originalNode)).valueAt(1);</span>
176                 } else {
<span class="line-modified">177                     assert originalNode.isConstant() || loop.isOutsideLoop(originalNode) : &quot;Not duplicated node &quot; + originalNode;</span>
178                 }
179             }
180             backedgeValues.add(duplicatedNode);
181         }
182         int index = 0;
183         for (PhiNode mainPhiNode : mainLoopBegin.phis()) {
184             ValueNode duplicatedNode = backedgeValues.get(index++);
185             if (duplicatedNode != null) {
186                 mainPhiNode.setValueAt(1, duplicatedNode);
187             }
188         }
189 
190         placeNewSegmentAndCleanup(loop);
191 
192         // Remove any safepoints from the original copy leaving only the duplicated one
193         assert loop.whole().nodes().filter(SafepointNode.class).count() == nodes().filter(SafepointNode.class).count();
194         for (SafepointNode safepoint : loop.whole().nodes().filter(SafepointNode.class)) {
195             graph().removeFixed(safepoint);
196         }
197 
198         StructuredGraph graph = mainLoopBegin.graph();
199         if (opaqueUnrolledStrides != null) {
200             OpaqueNode opaque = opaqueUnrolledStrides.get(loop.loopBegin());
201             CountedLoopInfo counted = loop.counted();
202             ValueNode counterStride = counted.getCounter().strideNode();
203             if (opaque == null) {
204                 opaque = new OpaqueNode(AddNode.add(counterStride, counterStride, NodeView.DEFAULT));
205                 ValueNode limit = counted.getLimit();
206                 int bits = ((IntegerStamp) limit.stamp(NodeView.DEFAULT)).getBits();
207                 ValueNode newLimit = SubNode.create(limit, opaque, NodeView.DEFAULT);
<span class="line-added">208                 IntegerHelper helper = counted.getCounterIntegerHelper();</span>
209                 LogicNode overflowCheck;
210                 ConstantNode extremum;
211                 if (counted.getDirection() == InductionVariable.Direction.Up) {
212                     // limit - counterStride could overflow negatively if limit - min &lt;
213                     // counterStride
<span class="line-modified">214                     extremum = ConstantNode.forIntegerBits(bits, helper.minValue());</span>
215                     overflowCheck = IntegerBelowNode.create(SubNode.create(limit, extremum, NodeView.DEFAULT), opaque, NodeView.DEFAULT);
216                 } else {
217                     assert counted.getDirection() == InductionVariable.Direction.Down;
218                     // limit - counterStride could overflow if max - limit &lt; -counterStride
219                     // i.e., counterStride &lt; limit - max
<span class="line-modified">220                     extremum = ConstantNode.forIntegerBits(bits, helper.maxValue());</span>
221                     overflowCheck = IntegerBelowNode.create(opaque, SubNode.create(limit, extremum, NodeView.DEFAULT), NodeView.DEFAULT);
222                 }
223                 newLimit = ConditionalNode.create(overflowCheck, extremum, newLimit, NodeView.DEFAULT);
224                 CompareNode compareNode = (CompareNode) counted.getLimitTest().condition();
225                 compareNode.replaceFirstInput(limit, graph.addOrUniqueWithInputs(newLimit));
226                 opaqueUnrolledStrides.put(loop.loopBegin(), opaque);
227             } else {
228                 assert counted.getCounter().isConstantStride();
229                 assert Math.addExact(counted.getCounter().constantStride(), counted.getCounter().constantStride()) == counted.getCounter().constantStride() * 2;
230                 ValueNode previousValue = opaque.getValue();
231                 opaque.setValue(graph.addOrUniqueWithInputs(AddNode.add(counterStride, previousValue, NodeView.DEFAULT)));
232                 GraphUtil.tryKillUnused(previousValue);
233             }
234         }
235         mainLoopBegin.setUnrollFactor(mainLoopBegin.getUnrollFactor() * 2);
<span class="line-modified">236         mainLoopBegin.setLoopFrequency(Math.max(1.0, mainLoopBegin.loopFrequency() / 2));</span>
237         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;LoopPartialUnroll %s&quot;, loop);
238 
239         mainLoopBegin.getDebug().dump(DebugContext.VERBOSE_LEVEL, mainLoopBegin.graph(), &quot;After insertWithinAfter %s&quot;, mainLoopBegin);
240     }
241 
242     private void placeNewSegmentAndCleanup(LoopEx loop) {
243         CountedLoopInfo mainCounted = loop.counted();
244         LoopBeginNode mainLoopBegin = loop.loopBegin();
245         // Discard the segment entry and its flow, after if merging it into the loop
246         StructuredGraph graph = mainLoopBegin.graph();
247         IfNode loopTest = mainCounted.getLimitTest();
<span class="line-modified">248         IfNode newSegmentLoopTest = getDuplicatedNode(loopTest);</span>
<span class="line-modified">249 </span>
<span class="line-modified">250         // Redirect anchors</span>
<span class="line-modified">251         AbstractBeginNode falseSuccessor = newSegmentLoopTest.falseSuccessor();</span>










252         for (Node usage : falseSuccessor.anchored().snapshot()) {
253             usage.replaceFirstInput(falseSuccessor, loopTest.falseSuccessor());
254         }
<span class="line-added">255         AbstractBeginNode trueSuccessor = newSegmentLoopTest.trueSuccessor();</span>
256         for (Node usage : trueSuccessor.anchored().snapshot()) {
257             usage.replaceFirstInput(trueSuccessor, loopTest.trueSuccessor());
258         }
<span class="line-modified">259 </span>
<span class="line-modified">260         // remove if test</span>
<span class="line-modified">261         graph.removeSplitPropagate(newSegmentLoopTest, loopTest.trueSuccessor() == mainCounted.getBody() ? trueSuccessor : falseSuccessor);</span>
<span class="line-modified">262 </span>
<span class="line-modified">263         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before placing segment&quot;);</span>
<span class="line-modified">264         if (mainCounted.getBody().next() instanceof LoopEndNode) {</span>








265             GraphUtil.killCFG(getDuplicatedNode(mainLoopBegin));
266         } else {
<span class="line-modified">267             AbstractBeginNode newSegmentBegin = getDuplicatedNode(mainLoopBegin);</span>
<span class="line-modified">268             FixedNode newSegmentFirstNode = newSegmentBegin.next();</span>
<span class="line-added">269             EndNode newSegmentEnd = getBlockEnd(newSegmentBegin);</span>
<span class="line-added">270             FixedWithNextNode newSegmentLastNode = (FixedWithNextNode) newSegmentEnd.predecessor();</span>
<span class="line-added">271             LoopEndNode loopEndNode = mainLoopBegin.getSingleLoopEnd();</span>
<span class="line-added">272             FixedWithNextNode lastCodeNode = (FixedWithNextNode) loopEndNode.predecessor();</span>
<span class="line-added">273 </span>
<span class="line-added">274             newSegmentBegin.clearSuccessors();</span>
275             lastCodeNode.replaceFirstSuccessor(loopEndNode, newSegmentFirstNode);
<span class="line-modified">276             newSegmentLastNode.replaceFirstSuccessor(newSegmentEnd, loopEndNode);</span>
<span class="line-modified">277 </span>
<span class="line-modified">278             newSegmentBegin.safeDelete();</span>
<span class="line-modified">279             newSegmentEnd.safeDelete();</span>









280         }
<span class="line-modified">281         graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;After placing segment&quot;);</span>
282     }
283 
284     private static EndNode getBlockEnd(FixedNode node) {
285         FixedNode curNode = node;
286         while (curNode instanceof FixedWithNextNode) {
287             curNode = ((FixedWithNextNode) curNode).next();
288         }
289         return (EndNode) curNode;
290     }
291 
292     @Override
293     public NodeBitMap nodes() {
294         if (nodes == null) {
295             LoopFragmentWhole whole = loop().whole();
296             whole.nodes(); // init nodes bitmap in whole
297             nodes = whole.nodes.copy();
298             // remove the phis
299             LoopBeginNode loopBegin = loop().loopBegin();
300             for (PhiNode phi : loopBegin.phis()) {
301                 nodes.clear(phi);
</pre>
<hr />
<pre>
421             PhiNode newPhi = patchPhi(graph, phi, loopBegin);
422             newPhi.addInput(first);
423             for (LoopEndNode end : loopBegin.orderedLoopEnds()) {
424                 newPhi.addInput(phi.valueAt(end));
425             }
426             peel.putDuplicatedNode(phi, newPhi);
427             newPhis.add(newPhi);
428             for (Node usage : phi.usages().snapshot()) {
429                 // patch only usages that should use the new phi ie usages that were peeled
430                 if (usagesToPatch.isMarkedAndGrow(usage)) {
431                     usage.replaceFirstInput(phi, newPhi);
432                 }
433             }
434         }
435         // check new phis to see if they have as input some old phis, replace those inputs with the
436         // new corresponding phis
437         for (PhiNode phi : newPhis) {
438             for (int i = 0; i &lt; phi.valueCount(); i++) {
439                 ValueNode v = phi.valueAt(i);
440                 if (loopBegin.isPhiAtMerge(v)) {
<span class="line-modified">441                     PhiNode newV = peel.getDuplicatedNode((PhiNode) v);</span>
442                     if (newV != null) {
443                         phi.setValueAt(i, newV);
444                     }
445                 }
446             }
447         }
448 
449         boolean progress = true;
450         while (progress) {
451             progress = false;
452             int i = 0;
453             outer: while (i &lt; oldPhis.size()) {
454                 PhiNode oldPhi = oldPhis.get(i);
455                 for (Node usage : oldPhi.usages()) {
456                     if (usage instanceof PhiNode &amp;&amp; oldPhis.contains(usage)) {
457                         // Do not mark.
458                     } else {
459                         // Mark alive by removing from delete set.
460                         oldPhis.remove(i);
461                         progress = true;
</pre>
</td>
</tr>
</table>
<center><a href="LoopFragment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragmentWhole.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
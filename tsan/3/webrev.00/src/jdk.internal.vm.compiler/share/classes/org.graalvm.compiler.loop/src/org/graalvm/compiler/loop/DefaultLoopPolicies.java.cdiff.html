<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/DefaultLoopPolicies.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CountedLoopInfo.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopEx.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/DefaultLoopPolicies.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,11 ***</span>
  
  package org.graalvm.compiler.loop;
  
  import static org.graalvm.compiler.core.common.GraalOptions.LoopMaxUnswitch;
  import static org.graalvm.compiler.core.common.GraalOptions.MaximumDesiredSize;
<span class="line-modified">! import static org.graalvm.compiler.core.common.GraalOptions.MinimumPeelProbability;</span>
  
  import java.util.List;
  
  import org.graalvm.compiler.core.common.util.UnsignedLong;
  import org.graalvm.compiler.debug.CounterKey;
<span class="line-new-header">--- 24,11 ---</span>
  
  package org.graalvm.compiler.loop;
  
  import static org.graalvm.compiler.core.common.GraalOptions.LoopMaxUnswitch;
  import static org.graalvm.compiler.core.common.GraalOptions.MaximumDesiredSize;
<span class="line-modified">! import static org.graalvm.compiler.core.common.GraalOptions.MinimumPeelFrequency;</span>
  
  import java.util.List;
  
  import org.graalvm.compiler.core.common.util.UnsignedLong;
  import org.graalvm.compiler.debug.CounterKey;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,24 ***</span>
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.graph.Node;
  import org.graalvm.compiler.graph.NodeBitMap;
  import org.graalvm.compiler.nodes.AbstractBeginNode;
  import org.graalvm.compiler.nodes.ControlSplitNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.DeoptimizeNode;</span>
<span class="line-removed">- import org.graalvm.compiler.nodes.FixedNode;</span>
<span class="line-removed">- import org.graalvm.compiler.nodes.FixedWithNextNode;</span>
  import org.graalvm.compiler.nodes.InvokeNode;
  import org.graalvm.compiler.nodes.LoopBeginNode;
  import org.graalvm.compiler.nodes.MergeNode;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.VirtualState;
  import org.graalvm.compiler.nodes.VirtualState.VirtualClosure;
  import org.graalvm.compiler.nodes.calc.CompareNode;
  import org.graalvm.compiler.nodes.cfg.Block;
  import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.java.TypeSwitchNode;</span>
  import org.graalvm.compiler.options.Option;
  import org.graalvm.compiler.options.OptionKey;
  import org.graalvm.compiler.options.OptionType;
  import org.graalvm.compiler.options.OptionValues;
  
<span class="line-new-header">--- 36,20 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,17 ***</span>
  
      @Override
      public boolean shouldPeel(LoopEx loop, ControlFlowGraph cfg, MetaAccessProvider metaAccess) {
          LoopBeginNode loopBegin = loop.loopBegin();
          double entryProbability = cfg.blockFor(loopBegin.forwardEnd()).getRelativeFrequency();
<span class="line-modified">!         OptionValues options = cfg.graph.getOptions();</span>
<span class="line-modified">!         if (entryProbability &gt; MinimumPeelProbability.getValue(options) &amp;&amp; loop.size() + loopBegin.graph().getNodeCount() &lt; MaximumDesiredSize.getValue(options)) {</span>
<span class="line-modified">!             // check whether we&#39;re allowed to peel this loop</span>
<span class="line-modified">!             return loop.canDuplicateLoop();</span>
<span class="line-modified">!         } else {</span>
              return false;
          }
      }
  
      @Override
      public boolean shouldFullUnroll(LoopEx loop) {
          if (!loop.isCounted() || !loop.counted().isConstantMaxTripCount() || !loop.counted().counterNeverOverflows()) {
<span class="line-new-header">--- 73,36 ---</span>
  
      @Override
      public boolean shouldPeel(LoopEx loop, ControlFlowGraph cfg, MetaAccessProvider metaAccess) {
          LoopBeginNode loopBegin = loop.loopBegin();
          double entryProbability = cfg.blockFor(loopBegin.forwardEnd()).getRelativeFrequency();
<span class="line-modified">!         StructuredGraph graph = cfg.graph;</span>
<span class="line-modified">!         OptionValues options = graph.getOptions();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (entryProbability &lt; MinimumPeelFrequency.getValue(options)) {</span>
<span class="line-modified">!             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (loop.parent() != null) {</span>
<span class="line-added">+             if (loop.size() &gt; loop.parent().size() &gt;&gt; 1) {</span>
<span class="line-added">+                 // This loops make up more than half of the parent loop in terms of number of nodes.</span>
<span class="line-added">+                 // There is a risk that this loop unproportionally increases parent loop body size.</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (loop.loop().getChildren().size() &gt; 0) {</span>
<span class="line-added">+             // This loop has child loops. Loop peeling could explode graph size.</span>
              return false;
          }
<span class="line-added">+ </span>
<span class="line-added">+         if (loop.size() + graph.getNodeCount() &gt; MaximumDesiredSize.getValue(options)) {</span>
<span class="line-added">+             // We are out of budget for peeling.</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return true;</span>
      }
  
      @Override
      public boolean shouldFullUnroll(LoopEx loop) {
          if (!loop.isCounted() || !loop.counted().isConstantMaxTripCount() || !loop.counted().counterNeverOverflows()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,11 ***</span>
          double loopFrequency = loopBegin.loopFrequency();
          if (loopFrequency &lt;= 1.0) {
              return false;
          }
          OptionValues options = loop.entryPoint().getOptions();
<span class="line-modified">!         return loopBegin.unswitches() &lt;= LoopMaxUnswitch.getValue(options);</span>
      }
  
      private static final class CountingClosure implements VirtualClosure {
          int count;
  
<span class="line-new-header">--- 202,11 ---</span>
          double loopFrequency = loopBegin.loopFrequency();
          if (loopFrequency &lt;= 1.0) {
              return false;
          }
          OptionValues options = loop.entryPoint().getOptions();
<span class="line-modified">!         return loopBegin.unswitches() &lt; LoopMaxUnswitch.getValue(options);</span>
      }
  
      private static final class CountingClosure implements VirtualClosure {
          int count;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,23 ***</span>
  
          loop.loopBegin().stateAfter().applyToVirtual(stateNodesCount);
          int loopTotal = loop.size() - loop.loopBegin().phis().count() - stateNodesCount.count - 1;
          int actualDiff = (loopTotal - inBranchTotal);
          ControlSplitNode firstSplit = controlSplits.get(0);
<span class="line-modified">!         if (firstSplit instanceof TypeSwitchNode) {</span>
<span class="line-modified">!             int copies = firstSplit.successors().count() - 1;</span>
<span class="line-modified">!             for (Node succ : firstSplit.successors()) {</span>
<span class="line-removed">-                 FixedNode current = (FixedNode) succ;</span>
<span class="line-removed">-                 while (current instanceof FixedWithNextNode) {</span>
<span class="line-removed">-                     current = ((FixedWithNextNode) current).next();</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (current instanceof DeoptimizeNode) {</span>
<span class="line-removed">-                     copies--;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             actualDiff = actualDiff * copies;</span>
<span class="line-removed">-         }</span>
  
          debug.log(&quot;shouldUnswitch(%s, %s) : delta=%d (%.2f%% inside of branches), max=%d, f=%.2f, phis=%d -&gt; %b&quot;, loop, controlSplits, actualDiff, (double) (inBranchTotal) / loopTotal * 100, maxDiff,
                          loopFrequency, phis, actualDiff &lt;= maxDiff);
          if (actualDiff &lt;= maxDiff) {
              // check whether we&#39;re allowed to unswitch this loop
<span class="line-new-header">--- 251,13 ---</span>
  
          loop.loopBegin().stateAfter().applyToVirtual(stateNodesCount);
          int loopTotal = loop.size() - loop.loopBegin().phis().count() - stateNodesCount.count - 1;
          int actualDiff = (loopTotal - inBranchTotal);
          ControlSplitNode firstSplit = controlSplits.get(0);
<span class="line-modified">! </span>
<span class="line-modified">!         int copies = firstSplit.successors().count() - 1;</span>
<span class="line-modified">!         actualDiff = actualDiff * copies;</span>
  
          debug.log(&quot;shouldUnswitch(%s, %s) : delta=%d (%.2f%% inside of branches), max=%d, f=%.2f, phis=%d -&gt; %b&quot;, loop, controlSplits, actualDiff, (double) (inBranchTotal) / loopTotal * 100, maxDiff,
                          loopFrequency, phis, actualDiff &lt;= maxDiff);
          if (actualDiff &lt;= maxDiff) {
              // check whether we&#39;re allowed to unswitch this loop
</pre>
<center><a href="CountedLoopInfo.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopEx.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopEx.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DefaultLoopPolicies.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopEx.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 44 import org.graalvm.compiler.nodes.AbstractBeginNode;
 45 import org.graalvm.compiler.nodes.AbstractEndNode;
 46 import org.graalvm.compiler.nodes.ConstantNode;
 47 import org.graalvm.compiler.nodes.FixedGuardNode;
 48 import org.graalvm.compiler.nodes.FixedNode;
 49 import org.graalvm.compiler.nodes.FixedWithNextNode;
 50 import org.graalvm.compiler.nodes.FrameState;
 51 import org.graalvm.compiler.nodes.FullInfopointNode;
 52 import org.graalvm.compiler.nodes.IfNode;
 53 import org.graalvm.compiler.nodes.LogicNode;
 54 import org.graalvm.compiler.nodes.LoopBeginNode;
 55 import org.graalvm.compiler.nodes.NodeView;
 56 import org.graalvm.compiler.nodes.PhiNode;
 57 import org.graalvm.compiler.nodes.PiNode;
 58 import org.graalvm.compiler.nodes.StructuredGraph;
 59 import org.graalvm.compiler.nodes.ValueNode;
 60 import org.graalvm.compiler.nodes.ValuePhiNode;
 61 import org.graalvm.compiler.nodes.calc.AddNode;
 62 import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;
 63 import org.graalvm.compiler.nodes.calc.CompareNode;
<span class="line-removed"> 64 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;</span>
<span class="line-removed"> 65 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;</span>
<span class="line-removed"> 66 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;</span>
 67 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 68 import org.graalvm.compiler.nodes.calc.MulNode;
 69 import org.graalvm.compiler.nodes.calc.NegateNode;
 70 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 71 import org.graalvm.compiler.nodes.calc.SubNode;
 72 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 73 import org.graalvm.compiler.nodes.cfg.Block;
 74 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 75 import org.graalvm.compiler.nodes.debug.ControlFlowAnchored;
 76 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
 77 import org.graalvm.compiler.nodes.util.GraphUtil;
 78 
 79 public class LoopEx {
 80     private final Loop&lt;Block&gt; loop;
 81     private LoopFragmentInside inside;
 82     private LoopFragmentWhole whole;
 83     private CountedLoopInfo counted;
 84     private LoopsData data;
 85     private EconomicMap&lt;Node, InductionVariable&gt; ivs;
 86     private boolean countedLoopChecked;

 87 
 88     LoopEx(Loop&lt;Block&gt; loop, LoopsData data) {
 89         this.loop = loop;
 90         this.data = data;
 91     }
 92 
 93     public Loop&lt;Block&gt; loop() {
 94         return loop;
 95     }
 96 
 97     public LoopFragmentInside inside() {
 98         if (inside == null) {
 99             inside = new LoopFragmentInside(this);
100         }
101         return inside;
102     }
103 
104     public LoopFragmentWhole whole() {
105         if (whole == null) {
106             whole = new LoopFragmentWhole(this);
</pre>
<hr />
<pre>
142     }
143 
144     public boolean isCounted() {
145         assert countedLoopChecked;
146         return counted != null;
147     }
148 
149     public CountedLoopInfo counted() {
150         assert countedLoopChecked;
151         return counted;
152     }
153 
154     public LoopEx parent() {
155         if (loop.getParent() == null) {
156             return null;
157         }
158         return data.loop(loop.getParent());
159     }
160 
161     public int size() {
<span class="line-modified">162         return whole().nodes().count();</span>



163     }
164 
165     @Override
166     public String toString() {
<span class="line-modified">167         return (isCounted() ? &quot;CountedLoop [&quot; + counted() + &quot;] &quot; : &quot;Loop &quot;) + &quot;(depth=&quot; + loop().getDepth() + &quot;) &quot; + loopBegin();</span>
168     }
169 
170     private class InvariantPredicate implements NodePredicate {
171 
172         private final Graph.Mark mark;
173 
174         InvariantPredicate() {
175             this.mark = loopBegin().graph().getMark();
176         }
177 
178         @Override
179         public boolean apply(Node n) {
180             if (loopBegin().graph().isNew(mark, n)) {
181                 // Newly created nodes are unknown.
182                 return false;
183             }
184             return isOutsideLoop(n);
185         }
186     }
187 
</pre>
<hr />
<pre>
194                 continue;
195             }
196             ValueNode result = BinaryArithmeticNode.reassociate(binary, invariant, binary.getX(), binary.getY(), NodeView.DEFAULT);
197             if (result != binary) {
198                 if (!result.isAlive()) {
199                     assert !result.isDeleted();
200                     result = graph.addOrUniqueWithInputs(result);
201                 }
202                 DebugContext debug = graph.getDebug();
203                 if (debug.isLogEnabled()) {
204                     debug.log(&quot;%s : Reassociated %s into %s&quot;, graph.method().format(&quot;%H::%n&quot;), binary, result);
205                 }
206                 binary.replaceAtUsages(result);
207                 GraphUtil.killWithUnusedFloatingInputs(binary);
208                 count++;
209             }
210         }
211         return count != 0;
212     }
213 

214     public boolean detectCounted() {
215         if (countedLoopChecked) {
216             return isCounted();
217         }
218         countedLoopChecked = true;
219         LoopBeginNode loopBegin = loopBegin();
220         FixedNode next = loopBegin.next();
221         while (next instanceof FixedGuardNode || next instanceof ValueAnchorNode || next instanceof FullInfopointNode) {
222             next = ((FixedWithNextNode) next).next();
223         }
224         if (next instanceof IfNode) {
225             IfNode ifNode = (IfNode) next;
226             boolean negated = false;
227             if (!isCfgLoopExit(ifNode.falseSuccessor())) {
228                 if (!isCfgLoopExit(ifNode.trueSuccessor())) {
229                     return false;
230                 }
231                 negated = true;
232             }
233             LogicNode ifTest = ifNode.condition();
<span class="line-modified">234             if (!(ifTest instanceof IntegerLessThanNode) &amp;&amp; !(ifTest instanceof IntegerEqualsNode)) {</span>
<span class="line-removed">235                 if (ifTest instanceof IntegerBelowNode) {</span>
<span class="line-removed">236                     ifTest.getDebug().log(&quot;Ignored potential Counted loop at %s with |&lt;|&quot;, loopBegin);</span>
<span class="line-removed">237                 }</span>
238                 return false;
239             }
<span class="line-modified">240             CompareNode lessThan = (CompareNode) ifTest;</span>
241             Condition condition = null;
242             InductionVariable iv = null;
243             ValueNode limit = null;
<span class="line-modified">244             if (isOutsideLoop(lessThan.getX())) {</span>
<span class="line-modified">245                 iv = getInductionVariables().get(lessThan.getY());</span>
246                 if (iv != null) {
<span class="line-modified">247                     condition = lessThan.condition().asCondition().mirror();</span>
<span class="line-modified">248                     limit = lessThan.getX();</span>
249                 }
<span class="line-modified">250             } else if (isOutsideLoop(lessThan.getY())) {</span>
<span class="line-modified">251                 iv = getInductionVariables().get(lessThan.getX());</span>
252                 if (iv != null) {
<span class="line-modified">253                     condition = lessThan.condition().asCondition();</span>
<span class="line-modified">254                     limit = lessThan.getY();</span>
255                 }
256             }
257             if (condition == null) {
258                 return false;
259             }
260             if (negated) {
261                 condition = condition.negate();
262             }
263             boolean oneOff = false;

264             switch (condition) {
265                 case EQ:
<span class="line-modified">266                     return false;</span>
<span class="line-modified">267                 case NE: {</span>
<span class="line-modified">268                     if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1) {</span>

269                         return false;
270                     }


271                     IntegerStamp initStamp = (IntegerStamp) iv.initNode().stamp(NodeView.DEFAULT);
272                     IntegerStamp limitStamp = (IntegerStamp) limit.stamp(NodeView.DEFAULT);

273                     if (iv.direction() == Direction.Up) {
<span class="line-modified">274                         if (initStamp.upperBound() &gt; limitStamp.lowerBound()) {</span>




275                             return false;
276                         }
277                     } else if (iv.direction() == Direction.Down) {
<span class="line-modified">278                         if (initStamp.lowerBound() &lt; limitStamp.upperBound()) {</span>




279                             return false;
280                         }
281                     } else {
282                         return false;
283                     }
284                     break;
285                 }


286                 case LE:
287                     oneOff = true;
288                     if (iv.direction() != Direction.Up) {
289                         return false;
290                     }
291                     break;


292                 case LT:
293                     if (iv.direction() != Direction.Up) {
294                         return false;
295                     }
296                     break;


297                 case GE:
298                     oneOff = true;
299                     if (iv.direction() != Direction.Down) {
300                         return false;
301                     }
302                     break;


303                 case GT:
304                     if (iv.direction() != Direction.Down) {
305                         return false;
306                     }
307                     break;
308                 default:
309                     throw GraalError.shouldNotReachHere(condition.toString());
310             }
<span class="line-modified">311             counted = new CountedLoopInfo(this, iv, ifNode, limit, oneOff, negated ? ifNode.falseSuccessor() : ifNode.trueSuccessor());</span>
312             return true;
313         }
314         return false;
315     }
316 
317     private boolean isCfgLoopExit(AbstractBeginNode begin) {
318         Block block = data.getCFG().blockFor(begin);
319         return loop.getDepth() &gt; block.getLoopDepth() || loop.isNaturalExit(block);
320     }
321 
322     public LoopsData loopsData() {
323         return data;
324     }
325 
326     public void nodesInLoopBranch(NodeBitMap branchNodes, AbstractBeginNode branch) {
327         EconomicSet&lt;AbstractBeginNode&gt; blocks = EconomicSet.create();
328         Collection&lt;AbstractBeginNode&gt; exits = new LinkedList&lt;&gt;();
329         Queue&lt;Block&gt; work = new LinkedList&lt;&gt;();
330         ControlFlowGraph cfg = loopsData().getCFG();
331         work.add(cfg.blockFor(branch));
332         while (!work.isEmpty()) {
333             Block b = work.remove();
334             if (loop().isLoopExit(b)) {
335                 assert !exits.contains(b.getBeginNode());
336                 exits.add(b.getBeginNode());
337             } else if (blocks.add(b.getBeginNode())) {
338                 Block d = b.getDominatedSibling();
339                 while (d != null) {
340                     if (loop.getBlocks().contains(d)) {
341                         work.add(d);
342                     }
343                     d = d.getDominatedSibling();
344                 }
345             }
346         }
<span class="line-modified">347         LoopFragment.computeNodes(branchNodes, branch.graph(), blocks, exits);</span>
348     }
349 
350     public EconomicMap&lt;Node, InductionVariable&gt; getInductionVariables() {
351         if (ivs == null) {
352             ivs = findInductionVariables(this);
353         }
354         return ivs;
355     }
356 
357     /**
358      * Collect all the basic induction variables for the loop and the find any induction variables
359      * which are derived from the basic ones.
360      *
361      * @param loop
362      * @return a map from node to induction variable
363      */
364     private static EconomicMap&lt;Node, InductionVariable&gt; findInductionVariables(LoopEx loop) {
365         EconomicMap&lt;Node, InductionVariable&gt; ivs = EconomicMap.create(Equivalence.IDENTITY);
366 
367         Queue&lt;InductionVariable&gt; scanQueue = new LinkedList&lt;&gt;();
</pre>
<hr />
<pre>
370         for (PhiNode phi : loopBegin.valuePhis()) {
371             ValueNode backValue = phi.singleBackValueOrThis();
372             if (backValue == phi) {
373                 continue;
374             }
375             ValueNode stride = addSub(loop, backValue, phi);
376             if (stride != null) {
377                 BasicInductionVariable biv = new BasicInductionVariable(loop, (ValuePhiNode) phi, phi.valueAt(forwardEnd), stride, (BinaryArithmeticNode&lt;?&gt;) backValue);
378                 ivs.put(phi, biv);
379                 scanQueue.add(biv);
380             }
381         }
382 
383         while (!scanQueue.isEmpty()) {
384             InductionVariable baseIv = scanQueue.remove();
385             ValueNode baseIvNode = baseIv.valueNode();
386             for (ValueNode op : baseIvNode.usages().filter(ValueNode.class)) {
387                 if (loop.isOutsideLoop(op)) {
388                     continue;
389                 }
<span class="line-modified">390                 if (op.usages().count() == 1 &amp;&amp; op.usages().first() == baseIvNode) {</span>
391                     /*
392                      * This is just the base induction variable increment with no other uses so
393                      * don&#39;t bother reporting it.
394                      */
395                     continue;
396                 }
397                 InductionVariable iv = null;
398                 ValueNode offset = addSub(loop, op, baseIvNode);
399                 ValueNode scale;
400                 if (offset != null) {
401                     iv = new DerivedOffsetInductionVariable(loop, baseIv, offset, (BinaryArithmeticNode&lt;?&gt;) op);
402                 } else if (op instanceof NegateNode) {
403                     iv = new DerivedScaledInductionVariable(loop, baseIv, (NegateNode) op);
404                 } else if ((scale = mul(loop, op, baseIvNode)) != null) {
405                     iv = new DerivedScaledInductionVariable(loop, baseIv, scale, op);
406                 } else {
407                     boolean isValidConvert = op instanceof PiNode || op instanceof SignExtendNode;
408                     if (!isValidConvert &amp;&amp; op instanceof ZeroExtendNode) {
409                         ZeroExtendNode zeroExtendNode = (ZeroExtendNode) op;
410                         isValidConvert = zeroExtendNode.isInputAlwaysPositive() || ((IntegerStamp) zeroExtendNode.stamp(NodeView.DEFAULT)).isPositive();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 44 import org.graalvm.compiler.nodes.AbstractBeginNode;
 45 import org.graalvm.compiler.nodes.AbstractEndNode;
 46 import org.graalvm.compiler.nodes.ConstantNode;
 47 import org.graalvm.compiler.nodes.FixedGuardNode;
 48 import org.graalvm.compiler.nodes.FixedNode;
 49 import org.graalvm.compiler.nodes.FixedWithNextNode;
 50 import org.graalvm.compiler.nodes.FrameState;
 51 import org.graalvm.compiler.nodes.FullInfopointNode;
 52 import org.graalvm.compiler.nodes.IfNode;
 53 import org.graalvm.compiler.nodes.LogicNode;
 54 import org.graalvm.compiler.nodes.LoopBeginNode;
 55 import org.graalvm.compiler.nodes.NodeView;
 56 import org.graalvm.compiler.nodes.PhiNode;
 57 import org.graalvm.compiler.nodes.PiNode;
 58 import org.graalvm.compiler.nodes.StructuredGraph;
 59 import org.graalvm.compiler.nodes.ValueNode;
 60 import org.graalvm.compiler.nodes.ValuePhiNode;
 61 import org.graalvm.compiler.nodes.calc.AddNode;
 62 import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;
 63 import org.graalvm.compiler.nodes.calc.CompareNode;



 64 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 65 import org.graalvm.compiler.nodes.calc.MulNode;
 66 import org.graalvm.compiler.nodes.calc.NegateNode;
 67 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 68 import org.graalvm.compiler.nodes.calc.SubNode;
 69 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 70 import org.graalvm.compiler.nodes.cfg.Block;
 71 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 72 import org.graalvm.compiler.nodes.debug.ControlFlowAnchored;
 73 import org.graalvm.compiler.nodes.extended.ValueAnchorNode;
 74 import org.graalvm.compiler.nodes.util.GraphUtil;
 75 
 76 public class LoopEx {
 77     private final Loop&lt;Block&gt; loop;
 78     private LoopFragmentInside inside;
 79     private LoopFragmentWhole whole;
 80     private CountedLoopInfo counted;
 81     private LoopsData data;
 82     private EconomicMap&lt;Node, InductionVariable&gt; ivs;
 83     private boolean countedLoopChecked;
<span class="line-added"> 84     private int size = -1;</span>
 85 
 86     LoopEx(Loop&lt;Block&gt; loop, LoopsData data) {
 87         this.loop = loop;
 88         this.data = data;
 89     }
 90 
 91     public Loop&lt;Block&gt; loop() {
 92         return loop;
 93     }
 94 
 95     public LoopFragmentInside inside() {
 96         if (inside == null) {
 97             inside = new LoopFragmentInside(this);
 98         }
 99         return inside;
100     }
101 
102     public LoopFragmentWhole whole() {
103         if (whole == null) {
104             whole = new LoopFragmentWhole(this);
</pre>
<hr />
<pre>
140     }
141 
142     public boolean isCounted() {
143         assert countedLoopChecked;
144         return counted != null;
145     }
146 
147     public CountedLoopInfo counted() {
148         assert countedLoopChecked;
149         return counted;
150     }
151 
152     public LoopEx parent() {
153         if (loop.getParent() == null) {
154             return null;
155         }
156         return data.loop(loop.getParent());
157     }
158 
159     public int size() {
<span class="line-modified">160         if (size == -1) {</span>
<span class="line-added">161             size = whole().nodes().count();</span>
<span class="line-added">162         }</span>
<span class="line-added">163         return size;</span>
164     }
165 
166     @Override
167     public String toString() {
<span class="line-modified">168         return (countedLoopChecked &amp;&amp; isCounted() ? &quot;CountedLoop [&quot; + counted() + &quot;] &quot; : &quot;Loop &quot;) + &quot;(depth=&quot; + loop().getDepth() + &quot;) &quot; + loopBegin();</span>
169     }
170 
171     private class InvariantPredicate implements NodePredicate {
172 
173         private final Graph.Mark mark;
174 
175         InvariantPredicate() {
176             this.mark = loopBegin().graph().getMark();
177         }
178 
179         @Override
180         public boolean apply(Node n) {
181             if (loopBegin().graph().isNew(mark, n)) {
182                 // Newly created nodes are unknown.
183                 return false;
184             }
185             return isOutsideLoop(n);
186         }
187     }
188 
</pre>
<hr />
<pre>
195                 continue;
196             }
197             ValueNode result = BinaryArithmeticNode.reassociate(binary, invariant, binary.getX(), binary.getY(), NodeView.DEFAULT);
198             if (result != binary) {
199                 if (!result.isAlive()) {
200                     assert !result.isDeleted();
201                     result = graph.addOrUniqueWithInputs(result);
202                 }
203                 DebugContext debug = graph.getDebug();
204                 if (debug.isLogEnabled()) {
205                     debug.log(&quot;%s : Reassociated %s into %s&quot;, graph.method().format(&quot;%H::%n&quot;), binary, result);
206                 }
207                 binary.replaceAtUsages(result);
208                 GraphUtil.killWithUnusedFloatingInputs(binary);
209                 count++;
210             }
211         }
212         return count != 0;
213     }
214 
<span class="line-added">215     @SuppressWarnings(&quot;fallthrough&quot;)</span>
216     public boolean detectCounted() {
217         if (countedLoopChecked) {
218             return isCounted();
219         }
220         countedLoopChecked = true;
221         LoopBeginNode loopBegin = loopBegin();
222         FixedNode next = loopBegin.next();
223         while (next instanceof FixedGuardNode || next instanceof ValueAnchorNode || next instanceof FullInfopointNode) {
224             next = ((FixedWithNextNode) next).next();
225         }
226         if (next instanceof IfNode) {
227             IfNode ifNode = (IfNode) next;
228             boolean negated = false;
229             if (!isCfgLoopExit(ifNode.falseSuccessor())) {
230                 if (!isCfgLoopExit(ifNode.trueSuccessor())) {
231                     return false;
232                 }
233                 negated = true;
234             }
235             LogicNode ifTest = ifNode.condition();
<span class="line-modified">236             if (!(ifTest instanceof CompareNode)) {</span>



237                 return false;
238             }
<span class="line-modified">239             CompareNode compare = (CompareNode) ifTest;</span>
240             Condition condition = null;
241             InductionVariable iv = null;
242             ValueNode limit = null;
<span class="line-modified">243             if (isOutsideLoop(compare.getX())) {</span>
<span class="line-modified">244                 iv = getInductionVariables().get(compare.getY());</span>
245                 if (iv != null) {
<span class="line-modified">246                     condition = compare.condition().asCondition().mirror();</span>
<span class="line-modified">247                     limit = compare.getX();</span>
248                 }
<span class="line-modified">249             } else if (isOutsideLoop(compare.getY())) {</span>
<span class="line-modified">250                 iv = getInductionVariables().get(compare.getX());</span>
251                 if (iv != null) {
<span class="line-modified">252                     condition = compare.condition().asCondition();</span>
<span class="line-modified">253                     limit = compare.getY();</span>
254                 }
255             }
256             if (condition == null) {
257                 return false;
258             }
259             if (negated) {
260                 condition = condition.negate();
261             }
262             boolean oneOff = false;
<span class="line-added">263             boolean unsigned = false;</span>
264             switch (condition) {
265                 case EQ:
<span class="line-modified">266                     if (iv.initNode() == limit) {</span>
<span class="line-modified">267                         // allow &quot;single iteration&quot; case</span>
<span class="line-modified">268                         oneOff = true;</span>
<span class="line-added">269                     } else {</span>
270                         return false;
271                     }
<span class="line-added">272                     break;</span>
<span class="line-added">273                 case NE: {</span>
274                     IntegerStamp initStamp = (IntegerStamp) iv.initNode().stamp(NodeView.DEFAULT);
275                     IntegerStamp limitStamp = (IntegerStamp) limit.stamp(NodeView.DEFAULT);
<span class="line-added">276                     IntegerStamp counterStamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);</span>
277                     if (iv.direction() == Direction.Up) {
<span class="line-modified">278                         if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.upperBound()) {</span>
<span class="line-added">279                             // signed: i &lt; MAX_INT</span>
<span class="line-added">280                         } else if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.unsignedUpperBound()) {</span>
<span class="line-added">281                             unsigned = true;</span>
<span class="line-added">282                         } else if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1 || initStamp.upperBound() &gt; limitStamp.lowerBound()) {</span>
283                             return false;
284                         }
285                     } else if (iv.direction() == Direction.Down) {
<span class="line-modified">286                         if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.lowerBound()) {</span>
<span class="line-added">287                             // signed: MIN_INT &gt; i</span>
<span class="line-added">288                         } else if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.unsignedLowerBound()) {</span>
<span class="line-added">289                             unsigned = true;</span>
<span class="line-added">290                         } else if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1 || initStamp.lowerBound() &lt; limitStamp.upperBound()) {</span>
291                             return false;
292                         }
293                     } else {
294                         return false;
295                     }
296                     break;
297                 }
<span class="line-added">298                 case BE:</span>
<span class="line-added">299                     unsigned = true; // fall through</span>
300                 case LE:
301                     oneOff = true;
302                     if (iv.direction() != Direction.Up) {
303                         return false;
304                     }
305                     break;
<span class="line-added">306                 case BT:</span>
<span class="line-added">307                     unsigned = true; // fall through</span>
308                 case LT:
309                     if (iv.direction() != Direction.Up) {
310                         return false;
311                     }
312                     break;
<span class="line-added">313                 case AE:</span>
<span class="line-added">314                     unsigned = true; // fall through</span>
315                 case GE:
316                     oneOff = true;
317                     if (iv.direction() != Direction.Down) {
318                         return false;
319                     }
320                     break;
<span class="line-added">321                 case AT:</span>
<span class="line-added">322                     unsigned = true; // fall through</span>
323                 case GT:
324                     if (iv.direction() != Direction.Down) {
325                         return false;
326                     }
327                     break;
328                 default:
329                     throw GraalError.shouldNotReachHere(condition.toString());
330             }
<span class="line-modified">331             counted = new CountedLoopInfo(this, iv, ifNode, limit, oneOff, negated ? ifNode.falseSuccessor() : ifNode.trueSuccessor(), unsigned);</span>
332             return true;
333         }
334         return false;
335     }
336 
337     private boolean isCfgLoopExit(AbstractBeginNode begin) {
338         Block block = data.getCFG().blockFor(begin);
339         return loop.getDepth() &gt; block.getLoopDepth() || loop.isNaturalExit(block);
340     }
341 
342     public LoopsData loopsData() {
343         return data;
344     }
345 
346     public void nodesInLoopBranch(NodeBitMap branchNodes, AbstractBeginNode branch) {
347         EconomicSet&lt;AbstractBeginNode&gt; blocks = EconomicSet.create();
348         Collection&lt;AbstractBeginNode&gt; exits = new LinkedList&lt;&gt;();
349         Queue&lt;Block&gt; work = new LinkedList&lt;&gt;();
350         ControlFlowGraph cfg = loopsData().getCFG();
351         work.add(cfg.blockFor(branch));
352         while (!work.isEmpty()) {
353             Block b = work.remove();
354             if (loop().isLoopExit(b)) {
355                 assert !exits.contains(b.getBeginNode());
356                 exits.add(b.getBeginNode());
357             } else if (blocks.add(b.getBeginNode())) {
358                 Block d = b.getDominatedSibling();
359                 while (d != null) {
360                     if (loop.getBlocks().contains(d)) {
361                         work.add(d);
362                     }
363                     d = d.getDominatedSibling();
364                 }
365             }
366         }
<span class="line-modified">367         LoopFragment.computeNodes(branchNodes, branch.graph(), this, blocks, exits);</span>
368     }
369 
370     public EconomicMap&lt;Node, InductionVariable&gt; getInductionVariables() {
371         if (ivs == null) {
372             ivs = findInductionVariables(this);
373         }
374         return ivs;
375     }
376 
377     /**
378      * Collect all the basic induction variables for the loop and the find any induction variables
379      * which are derived from the basic ones.
380      *
381      * @param loop
382      * @return a map from node to induction variable
383      */
384     private static EconomicMap&lt;Node, InductionVariable&gt; findInductionVariables(LoopEx loop) {
385         EconomicMap&lt;Node, InductionVariable&gt; ivs = EconomicMap.create(Equivalence.IDENTITY);
386 
387         Queue&lt;InductionVariable&gt; scanQueue = new LinkedList&lt;&gt;();
</pre>
<hr />
<pre>
390         for (PhiNode phi : loopBegin.valuePhis()) {
391             ValueNode backValue = phi.singleBackValueOrThis();
392             if (backValue == phi) {
393                 continue;
394             }
395             ValueNode stride = addSub(loop, backValue, phi);
396             if (stride != null) {
397                 BasicInductionVariable biv = new BasicInductionVariable(loop, (ValuePhiNode) phi, phi.valueAt(forwardEnd), stride, (BinaryArithmeticNode&lt;?&gt;) backValue);
398                 ivs.put(phi, biv);
399                 scanQueue.add(biv);
400             }
401         }
402 
403         while (!scanQueue.isEmpty()) {
404             InductionVariable baseIv = scanQueue.remove();
405             ValueNode baseIvNode = baseIv.valueNode();
406             for (ValueNode op : baseIvNode.usages().filter(ValueNode.class)) {
407                 if (loop.isOutsideLoop(op)) {
408                     continue;
409                 }
<span class="line-modified">410                 if (op.hasExactlyOneUsage() &amp;&amp; op.usages().first() == baseIvNode) {</span>
411                     /*
412                      * This is just the base induction variable increment with no other uses so
413                      * don&#39;t bother reporting it.
414                      */
415                     continue;
416                 }
417                 InductionVariable iv = null;
418                 ValueNode offset = addSub(loop, op, baseIvNode);
419                 ValueNode scale;
420                 if (offset != null) {
421                     iv = new DerivedOffsetInductionVariable(loop, baseIv, offset, (BinaryArithmeticNode&lt;?&gt;) op);
422                 } else if (op instanceof NegateNode) {
423                     iv = new DerivedScaledInductionVariable(loop, baseIv, (NegateNode) op);
424                 } else if ((scale = mul(loop, op, baseIvNode)) != null) {
425                     iv = new DerivedScaledInductionVariable(loop, baseIv, scale, op);
426                 } else {
427                     boolean isValidConvert = op instanceof PiNode || op instanceof SignExtendNode;
428                     if (!isValidConvert &amp;&amp; op instanceof ZeroExtendNode) {
429                         ZeroExtendNode zeroExtendNode = (ZeroExtendNode) op;
430                         isValidConvert = zeroExtendNode.isInputAlwaysPositive() || ((IntegerStamp) zeroExtendNode.stamp(NodeView.DEFAULT)).isPositive();
</pre>
</td>
</tr>
</table>
<center><a href="DefaultLoopPolicies.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
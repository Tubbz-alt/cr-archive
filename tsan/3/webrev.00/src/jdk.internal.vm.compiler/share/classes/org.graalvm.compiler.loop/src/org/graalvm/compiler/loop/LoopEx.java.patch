diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopEx.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopEx.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopEx.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopEx.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -59,13 +59,10 @@
 import org.graalvm.compiler.nodes.ValueNode;
 import org.graalvm.compiler.nodes.ValuePhiNode;
 import org.graalvm.compiler.nodes.calc.AddNode;
 import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;
 import org.graalvm.compiler.nodes.calc.CompareNode;
-import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
-import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
-import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 import org.graalvm.compiler.nodes.calc.MulNode;
 import org.graalvm.compiler.nodes.calc.NegateNode;
 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 import org.graalvm.compiler.nodes.calc.SubNode;
@@ -82,10 +79,11 @@
     private LoopFragmentWhole whole;
     private CountedLoopInfo counted;
     private LoopsData data;
     private EconomicMap<Node, InductionVariable> ivs;
     private boolean countedLoopChecked;
+    private int size = -1;
 
     LoopEx(Loop<Block> loop, LoopsData data) {
         this.loop = loop;
         this.data = data;
     }
@@ -157,16 +155,19 @@
         }
         return data.loop(loop.getParent());
     }
 
     public int size() {
-        return whole().nodes().count();
+        if (size == -1) {
+            size = whole().nodes().count();
+        }
+        return size;
     }
 
     @Override
     public String toString() {
-        return (isCounted() ? "CountedLoop [" + counted() + "] " : "Loop ") + "(depth=" + loop().getDepth() + ") " + loopBegin();
+        return (countedLoopChecked && isCounted() ? "CountedLoop [" + counted() + "] " : "Loop ") + "(depth=" + loop().getDepth() + ") " + loopBegin();
     }
 
     private class InvariantPredicate implements NodePredicate {
 
         private final Graph.Mark mark;
@@ -209,10 +210,11 @@
             }
         }
         return count != 0;
     }
 
+    @SuppressWarnings("fallthrough")
     public boolean detectCounted() {
         if (countedLoopChecked) {
             return isCounted();
         }
         countedLoopChecked = true;
@@ -229,88 +231,106 @@
                     return false;
                 }
                 negated = true;
             }
             LogicNode ifTest = ifNode.condition();
-            if (!(ifTest instanceof IntegerLessThanNode) && !(ifTest instanceof IntegerEqualsNode)) {
-                if (ifTest instanceof IntegerBelowNode) {
-                    ifTest.getDebug().log("Ignored potential Counted loop at %s with |<|", loopBegin);
-                }
+            if (!(ifTest instanceof CompareNode)) {
                 return false;
             }
-            CompareNode lessThan = (CompareNode) ifTest;
+            CompareNode compare = (CompareNode) ifTest;
             Condition condition = null;
             InductionVariable iv = null;
             ValueNode limit = null;
-            if (isOutsideLoop(lessThan.getX())) {
-                iv = getInductionVariables().get(lessThan.getY());
+            if (isOutsideLoop(compare.getX())) {
+                iv = getInductionVariables().get(compare.getY());
                 if (iv != null) {
-                    condition = lessThan.condition().asCondition().mirror();
-                    limit = lessThan.getX();
+                    condition = compare.condition().asCondition().mirror();
+                    limit = compare.getX();
                 }
-            } else if (isOutsideLoop(lessThan.getY())) {
-                iv = getInductionVariables().get(lessThan.getX());
+            } else if (isOutsideLoop(compare.getY())) {
+                iv = getInductionVariables().get(compare.getX());
                 if (iv != null) {
-                    condition = lessThan.condition().asCondition();
-                    limit = lessThan.getY();
+                    condition = compare.condition().asCondition();
+                    limit = compare.getY();
                 }
             }
             if (condition == null) {
                 return false;
             }
             if (negated) {
                 condition = condition.negate();
             }
             boolean oneOff = false;
+            boolean unsigned = false;
             switch (condition) {
                 case EQ:
-                    return false;
-                case NE: {
-                    if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1) {
+                    if (iv.initNode() == limit) {
+                        // allow "single iteration" case
+                        oneOff = true;
+                    } else {
                         return false;
                     }
+                    break;
+                case NE: {
                     IntegerStamp initStamp = (IntegerStamp) iv.initNode().stamp(NodeView.DEFAULT);
                     IntegerStamp limitStamp = (IntegerStamp) limit.stamp(NodeView.DEFAULT);
+                    IntegerStamp counterStamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);
                     if (iv.direction() == Direction.Up) {
-                        if (initStamp.upperBound() > limitStamp.lowerBound()) {
+                        if (limitStamp.asConstant() != null && limitStamp.asConstant().asLong() == counterStamp.upperBound()) {
+                            // signed: i < MAX_INT
+                        } else if (limitStamp.asConstant() != null && limitStamp.asConstant().asLong() == counterStamp.unsignedUpperBound()) {
+                            unsigned = true;
+                        } else if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1 || initStamp.upperBound() > limitStamp.lowerBound()) {
                             return false;
                         }
                     } else if (iv.direction() == Direction.Down) {
-                        if (initStamp.lowerBound() < limitStamp.upperBound()) {
+                        if (limitStamp.asConstant() != null && limitStamp.asConstant().asLong() == counterStamp.lowerBound()) {
+                            // signed: MIN_INT > i
+                        } else if (limitStamp.asConstant() != null && limitStamp.asConstant().asLong() == counterStamp.unsignedLowerBound()) {
+                            unsigned = true;
+                        } else if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1 || initStamp.lowerBound() < limitStamp.upperBound()) {
                             return false;
                         }
                     } else {
                         return false;
                     }
                     break;
                 }
+                case BE:
+                    unsigned = true; // fall through
                 case LE:
                     oneOff = true;
                     if (iv.direction() != Direction.Up) {
                         return false;
                     }
                     break;
+                case BT:
+                    unsigned = true; // fall through
                 case LT:
                     if (iv.direction() != Direction.Up) {
                         return false;
                     }
                     break;
+                case AE:
+                    unsigned = true; // fall through
                 case GE:
                     oneOff = true;
                     if (iv.direction() != Direction.Down) {
                         return false;
                     }
                     break;
+                case AT:
+                    unsigned = true; // fall through
                 case GT:
                     if (iv.direction() != Direction.Down) {
                         return false;
                     }
                     break;
                 default:
                     throw GraalError.shouldNotReachHere(condition.toString());
             }
-            counted = new CountedLoopInfo(this, iv, ifNode, limit, oneOff, negated ? ifNode.falseSuccessor() : ifNode.trueSuccessor());
+            counted = new CountedLoopInfo(this, iv, ifNode, limit, oneOff, negated ? ifNode.falseSuccessor() : ifNode.trueSuccessor(), unsigned);
             return true;
         }
         return false;
     }
 
@@ -342,11 +362,11 @@
                     }
                     d = d.getDominatedSibling();
                 }
             }
         }
-        LoopFragment.computeNodes(branchNodes, branch.graph(), blocks, exits);
+        LoopFragment.computeNodes(branchNodes, branch.graph(), this, blocks, exits);
     }
 
     public EconomicMap<Node, InductionVariable> getInductionVariables() {
         if (ivs == null) {
             ivs = findInductionVariables(this);
@@ -385,11 +405,11 @@
             ValueNode baseIvNode = baseIv.valueNode();
             for (ValueNode op : baseIvNode.usages().filter(ValueNode.class)) {
                 if (loop.isOutsideLoop(op)) {
                     continue;
                 }
-                if (op.usages().count() == 1 && op.usages().first() == baseIvNode) {
+                if (op.hasExactlyOneUsage() && op.usages().first() == baseIvNode) {
                     /*
                      * This is just the base induction variable increment with no other uses so
                      * don't bother reporting it.
                      */
                     continue;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoopEx.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragmentInside.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopFragment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.loop;
 26 
 27 import java.util.ArrayDeque;
<span class="line-removed"> 28 import java.util.Collections;</span>
 29 import java.util.Deque;
 30 import java.util.Iterator;
 31 
 32 import jdk.internal.vm.compiler.collections.EconomicMap;
<span class="line-modified"> 33 import org.graalvm.compiler.debug.GraalError;</span>
 34 import org.graalvm.compiler.graph.Graph;
 35 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
 36 import org.graalvm.compiler.graph.Node;
 37 import org.graalvm.compiler.graph.NodeBitMap;
 38 import org.graalvm.compiler.graph.iterators.NodeIterable;
 39 import org.graalvm.compiler.nodes.AbstractBeginNode;
 40 import org.graalvm.compiler.nodes.AbstractMergeNode;
 41 import org.graalvm.compiler.nodes.EndNode;
 42 import org.graalvm.compiler.nodes.FixedNode;
 43 import org.graalvm.compiler.nodes.FrameState;
 44 import org.graalvm.compiler.nodes.GuardNode;
<span class="line-removed"> 45 import org.graalvm.compiler.nodes.GuardPhiNode;</span>
 46 import org.graalvm.compiler.nodes.GuardProxyNode;
 47 import org.graalvm.compiler.nodes.Invoke;

 48 import org.graalvm.compiler.nodes.LoopExitNode;
 49 import org.graalvm.compiler.nodes.MergeNode;
<span class="line-removed"> 50 import org.graalvm.compiler.nodes.NodeView;</span>
 51 import org.graalvm.compiler.nodes.PhiNode;
 52 import org.graalvm.compiler.nodes.ProxyNode;
 53 import org.graalvm.compiler.nodes.StructuredGraph;
 54 import org.graalvm.compiler.nodes.ValueNode;
<span class="line-removed"> 55 import org.graalvm.compiler.nodes.ValuePhiNode;</span>
<span class="line-removed"> 56 import org.graalvm.compiler.nodes.ValueProxyNode;</span>
 57 import org.graalvm.compiler.nodes.VirtualState;
 58 import org.graalvm.compiler.nodes.cfg.Block;
 59 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 60 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 61 import org.graalvm.compiler.nodes.spi.NodeWithState;
 62 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
 63 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 64 
 65 import jdk.vm.ci.meta.TriState;
 66 
 67 public abstract class LoopFragment {
 68 
 69     private final LoopEx loop;
 70     private final LoopFragment original;
 71     protected NodeBitMap nodes;
 72     protected boolean nodesReady;
 73     private EconomicMap&lt;Node, Node&gt; duplicationMap;
 74 
 75     public LoopFragment(LoopEx loop) {
 76         this(loop, null);
</pre>
<hr />
<pre>
182                             return r2;
183                         }
184                         return o;
185                     }
186                 };
187             } else {
188                 dr = null;
189             }
190             beforeDuplication();
191             NodeIterable&lt;Node&gt; nodesIterable = original().nodes();
192             duplicationMap = graph().addDuplicates(nodesIterable, graph(), nodesIterable.count(), dr);
193             finishDuplication();
194             nodes = new NodeBitMap(graph());
195             nodes.markAll(duplicationMap.getValues());
196             nodesReady = true;
197         } else {
198             // TODO (gd) apply fix ?
199         }
200     }
201 
<span class="line-modified">202     protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode&gt; blocks) {</span>
<span class="line-removed">203         return computeNodes(graph, blocks, Collections.emptyList());</span>
<span class="line-removed">204     }</span>
<span class="line-removed">205 </span>
<span class="line-removed">206     protected static NodeBitMap computeNodes(Graph graph, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;AbstractBeginNode&gt; earlyExits) {</span>
<span class="line-removed">207         final NodeBitMap nodes = graph.createNodeBitMap();</span>
<span class="line-removed">208         computeNodes(nodes, graph, blocks, earlyExits);</span>
<span class="line-removed">209         return nodes;</span>
<span class="line-removed">210     }</span>
<span class="line-removed">211 </span>
<span class="line-removed">212     protected static void computeNodes(NodeBitMap nodes, Graph graph, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;AbstractBeginNode&gt; earlyExits) {</span>
213         for (AbstractBeginNode b : blocks) {
214             if (b.isDeleted()) {
215                 continue;
216             }
217 
218             for (Node n : b.getBlockNodes()) {
219                 if (n instanceof Invoke) {
220                     nodes.mark(((Invoke) n).callTarget());
221                 }
222                 if (n instanceof NodeWithState) {
223                     NodeWithState withState = (NodeWithState) n;
224                     withState.states().forEach(state -&gt; state.applyToVirtual(node -&gt; nodes.mark(node)));
225                 }
226                 if (n instanceof AbstractMergeNode) {
227                     // if a merge is in the loop, all of its phis are also in the loop
228                     for (PhiNode phi : ((AbstractMergeNode) n).phis()) {
229                         nodes.mark(phi);
230                     }
231                 }
232                 nodes.mark(n);
</pre>
<hr />
<pre>
244                 FrameState stateAfter = loopExit.stateAfter();
245                 if (stateAfter != null) {
246                     stateAfter.applyToVirtual(node -&gt; nodes.mark(node));
247                 }
248                 for (ProxyNode proxy : loopExit.proxies()) {
249                     nodes.mark(proxy);
250                 }
251             }
252         }
253 
254         final NodeBitMap nonLoopNodes = graph.createNodeBitMap();
255         Deque&lt;WorkListEntry&gt; worklist = new ArrayDeque&lt;&gt;();
256         for (AbstractBeginNode b : blocks) {
257             if (b.isDeleted()) {
258                 continue;
259             }
260 
261             for (Node n : b.getBlockNodes()) {
262                 if (n instanceof CommitAllocationNode) {
263                     for (VirtualObjectNode obj : ((CommitAllocationNode) n).getVirtualObjects()) {
<span class="line-modified">264                         markFloating(worklist, obj, nodes, nonLoopNodes);</span>
265                     }
266                 }
267                 if (n instanceof MonitorEnterNode) {
<span class="line-modified">268                     markFloating(worklist, ((MonitorEnterNode) n).getMonitorId(), nodes, nonLoopNodes);</span>
269                 }
270                 if (n instanceof AbstractMergeNode) {
271                     /*
272                      * Since we already marked all phi nodes as being in the loop to break cycles,
273                      * we also have to iterate over their usages here.
274                      */
275                     for (PhiNode phi : ((AbstractMergeNode) n).phis()) {
276                         for (Node usage : phi.usages()) {
<span class="line-modified">277                             markFloating(worklist, usage, nodes, nonLoopNodes);</span>
278                         }
279                     }
280                 }
281                 for (Node usage : n.usages()) {
<span class="line-modified">282                     markFloating(worklist, usage, nodes, nonLoopNodes);</span>
283                 }
284             }
285         }
286     }
287 
288     static class WorkListEntry {
289         final Iterator&lt;Node&gt; usages;
290         final Node n;
291         boolean isLoopNode;
292 
293         WorkListEntry(Node n, NodeBitMap loopNodes) {
294             this.n = n;
295             this.usages = n.usages().iterator();
296             this.isLoopNode = loopNodes.isMarked(n);
297         }
298 
299         @Override
300         public boolean equals(Object obj) {
301             if (!(obj instanceof WorkListEntry)) {
302                 return false;
</pre>
<hr />
<pre>
314     static TriState isLoopNode(Node n, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {
315         if (loopNodes.isMarked(n)) {
316             return TriState.TRUE;
317         }
318         if (nonLoopNodes.isMarked(n)) {
319             return TriState.FALSE;
320         }
321         if (n instanceof FixedNode || n instanceof PhiNode) {
322             // phi nodes are treated the same as fixed nodes in this algorithm to break cycles
323             return TriState.FALSE;
324         }
325         return TriState.UNKNOWN;
326     }
327 
328     private static void pushWorkList(Deque&lt;WorkListEntry&gt; workList, Node node, NodeBitMap loopNodes) {
329         WorkListEntry entry = new WorkListEntry(node, loopNodes);
330         assert !workList.contains(entry) : &quot;node &quot; + node + &quot; added to worklist twice&quot;;
331         workList.push(entry);
332     }
333 
<span class="line-modified">334     private static void markFloating(Deque&lt;WorkListEntry&gt; workList, Node start, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {</span>
335         if (isLoopNode(start, loopNodes, nonLoopNodes).isKnown()) {
336             return;
337         }




338         pushWorkList(workList, start, loopNodes);
339         while (!workList.isEmpty()) {
340             WorkListEntry currentEntry = workList.peek();
341             if (currentEntry.usages.hasNext()) {
342                 Node current = currentEntry.usages.next();
343                 TriState result = isLoopNode(current, loopNodes, nonLoopNodes);
344                 if (result.isKnown()) {
345                     if (result.toBoolean()) {
346                         currentEntry.isLoopNode = true;
347                     }
348                 } else {
349                     pushWorkList(workList, current, loopNodes);
350                 }
351             } else {
352                 workList.pop();
353                 boolean isLoopNode = currentEntry.isLoopNode;
354                 Node current = currentEntry.n;
<span class="line-modified">355                 if (!isLoopNode &amp;&amp; current instanceof GuardNode) {</span>
<span class="line-modified">356                     /*</span>
<span class="line-modified">357                      * (gd) this is only OK if we are not going to make loop transforms based on</span>
<span class="line-modified">358                      * this</span>
<span class="line-modified">359                      */</span>
<span class="line-modified">360                     assert !((GuardNode) current).graph().hasValueProxies();</span>
<span class="line-modified">361                     isLoopNode = true;</span>













362                 }
363                 if (isLoopNode) {
364                     loopNodes.mark(current);
365                     for (WorkListEntry e : workList) {
366                         e.isLoopNode = true;
367                     }
368                 } else {
369                     nonLoopNodes.mark(current);
370                 }
371             }
372         }
373     }
374 
375     public static NodeIterable&lt;AbstractBeginNode&gt; toHirBlocks(final Iterable&lt;Block&gt; blocks) {
376         return new NodeIterable&lt;AbstractBeginNode&gt;() {
377 
378             @Override
379             public Iterator&lt;AbstractBeginNode&gt; iterator() {
380                 final Iterator&lt;Block&gt; it = blocks.iterator();
381                 return new Iterator&lt;AbstractBeginNode&gt;() {
</pre>
<hr />
<pre>
450             for (Node anchored : earlyExit.anchored().snapshot()) {
451                 anchored.replaceFirstInput(earlyExit, merge);
452             }
453 
454             if (earlyExit instanceof LoopExitNode) {
455                 LoopExitNode earlyLoopExit = (LoopExitNode) earlyExit;
456                 FrameState finalExitState = exitState;
457                 boolean newEarlyExitIsLoopExit = newEarlyExit instanceof LoopExitNode;
458                 for (ProxyNode vpn : earlyLoopExit.proxies().snapshot()) {
459                     if (vpn.hasNoUsages()) {
460                         continue;
461                     }
462                     if (vpn.value() == null) {
463                         assert vpn instanceof GuardProxyNode;
464                         vpn.replaceAtUsages(null);
465                         continue;
466                     }
467                     final ValueNode replaceWith;
468                     ValueNode newVpn = prim(newEarlyExitIsLoopExit ? vpn : vpn.value());
469                     if (newVpn != null) {
<span class="line-modified">470                         PhiNode phi;</span>
<span class="line-removed">471                         if (vpn instanceof ValueProxyNode) {</span>
<span class="line-removed">472                             phi = graph.addWithoutUnique(new ValuePhiNode(vpn.stamp(NodeView.DEFAULT), merge));</span>
<span class="line-removed">473                         } else if (vpn instanceof GuardProxyNode) {</span>
<span class="line-removed">474                             phi = graph.addWithoutUnique(new GuardPhiNode(merge));</span>
<span class="line-removed">475                         } else {</span>
<span class="line-removed">476                             throw GraalError.shouldNotReachHere();</span>
<span class="line-removed">477                         }</span>
478                         phi.addInput(vpn);
479                         phi.addInput(newVpn);
480                         replaceWith = phi;
481                     } else {
482                         replaceWith = vpn.value();
483                     }
484                     vpn.replaceAtMatchingUsages(replaceWith, usage -&gt; {
485                         if (merge.isPhiAtMerge(usage)) {
486                             return false;
487                         }
488                         if (usage instanceof VirtualState) {
489                             VirtualState stateUsage = (VirtualState) usage;
490                             if (finalExitState != null &amp;&amp; finalExitState.isPartOfThisState(stateUsage)) {
491                                 return false;
492                             }
493                         }
494                         return true;
495                     });
496                 }
497             }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.loop;
 26 
 27 import java.util.ArrayDeque;

 28 import java.util.Deque;
 29 import java.util.Iterator;
 30 
 31 import jdk.internal.vm.compiler.collections.EconomicMap;
<span class="line-modified"> 32 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;</span>
 33 import org.graalvm.compiler.graph.Graph;
 34 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
 35 import org.graalvm.compiler.graph.Node;
 36 import org.graalvm.compiler.graph.NodeBitMap;
 37 import org.graalvm.compiler.graph.iterators.NodeIterable;
 38 import org.graalvm.compiler.nodes.AbstractBeginNode;
 39 import org.graalvm.compiler.nodes.AbstractMergeNode;
 40 import org.graalvm.compiler.nodes.EndNode;
 41 import org.graalvm.compiler.nodes.FixedNode;
 42 import org.graalvm.compiler.nodes.FrameState;
 43 import org.graalvm.compiler.nodes.GuardNode;

 44 import org.graalvm.compiler.nodes.GuardProxyNode;
 45 import org.graalvm.compiler.nodes.Invoke;
<span class="line-added"> 46 import org.graalvm.compiler.nodes.LoopBeginNode;</span>
 47 import org.graalvm.compiler.nodes.LoopExitNode;
 48 import org.graalvm.compiler.nodes.MergeNode;

 49 import org.graalvm.compiler.nodes.PhiNode;
 50 import org.graalvm.compiler.nodes.ProxyNode;
 51 import org.graalvm.compiler.nodes.StructuredGraph;
 52 import org.graalvm.compiler.nodes.ValueNode;


 53 import org.graalvm.compiler.nodes.VirtualState;
 54 import org.graalvm.compiler.nodes.cfg.Block;
 55 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 56 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 57 import org.graalvm.compiler.nodes.spi.NodeWithState;
 58 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
 59 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 60 
 61 import jdk.vm.ci.meta.TriState;
 62 
 63 public abstract class LoopFragment {
 64 
 65     private final LoopEx loop;
 66     private final LoopFragment original;
 67     protected NodeBitMap nodes;
 68     protected boolean nodesReady;
 69     private EconomicMap&lt;Node, Node&gt; duplicationMap;
 70 
 71     public LoopFragment(LoopEx loop) {
 72         this(loop, null);
</pre>
<hr />
<pre>
178                             return r2;
179                         }
180                         return o;
181                     }
182                 };
183             } else {
184                 dr = null;
185             }
186             beforeDuplication();
187             NodeIterable&lt;Node&gt; nodesIterable = original().nodes();
188             duplicationMap = graph().addDuplicates(nodesIterable, graph(), nodesIterable.count(), dr);
189             finishDuplication();
190             nodes = new NodeBitMap(graph());
191             nodes.markAll(duplicationMap.getValues());
192             nodesReady = true;
193         } else {
194             // TODO (gd) apply fix ?
195         }
196     }
197 
<span class="line-modified">198     protected static void computeNodes(NodeBitMap nodes, Graph graph, LoopEx loop, Iterable&lt;AbstractBeginNode&gt; blocks, Iterable&lt;AbstractBeginNode&gt; earlyExits) {</span>










199         for (AbstractBeginNode b : blocks) {
200             if (b.isDeleted()) {
201                 continue;
202             }
203 
204             for (Node n : b.getBlockNodes()) {
205                 if (n instanceof Invoke) {
206                     nodes.mark(((Invoke) n).callTarget());
207                 }
208                 if (n instanceof NodeWithState) {
209                     NodeWithState withState = (NodeWithState) n;
210                     withState.states().forEach(state -&gt; state.applyToVirtual(node -&gt; nodes.mark(node)));
211                 }
212                 if (n instanceof AbstractMergeNode) {
213                     // if a merge is in the loop, all of its phis are also in the loop
214                     for (PhiNode phi : ((AbstractMergeNode) n).phis()) {
215                         nodes.mark(phi);
216                     }
217                 }
218                 nodes.mark(n);
</pre>
<hr />
<pre>
230                 FrameState stateAfter = loopExit.stateAfter();
231                 if (stateAfter != null) {
232                     stateAfter.applyToVirtual(node -&gt; nodes.mark(node));
233                 }
234                 for (ProxyNode proxy : loopExit.proxies()) {
235                     nodes.mark(proxy);
236                 }
237             }
238         }
239 
240         final NodeBitMap nonLoopNodes = graph.createNodeBitMap();
241         Deque&lt;WorkListEntry&gt; worklist = new ArrayDeque&lt;&gt;();
242         for (AbstractBeginNode b : blocks) {
243             if (b.isDeleted()) {
244                 continue;
245             }
246 
247             for (Node n : b.getBlockNodes()) {
248                 if (n instanceof CommitAllocationNode) {
249                     for (VirtualObjectNode obj : ((CommitAllocationNode) n).getVirtualObjects()) {
<span class="line-modified">250                         markFloating(worklist, loop, obj, nodes, nonLoopNodes);</span>
251                     }
252                 }
253                 if (n instanceof MonitorEnterNode) {
<span class="line-modified">254                     markFloating(worklist, loop, ((MonitorEnterNode) n).getMonitorId(), nodes, nonLoopNodes);</span>
255                 }
256                 if (n instanceof AbstractMergeNode) {
257                     /*
258                      * Since we already marked all phi nodes as being in the loop to break cycles,
259                      * we also have to iterate over their usages here.
260                      */
261                     for (PhiNode phi : ((AbstractMergeNode) n).phis()) {
262                         for (Node usage : phi.usages()) {
<span class="line-modified">263                             markFloating(worklist, loop, usage, nodes, nonLoopNodes);</span>
264                         }
265                     }
266                 }
267                 for (Node usage : n.usages()) {
<span class="line-modified">268                     markFloating(worklist, loop, usage, nodes, nonLoopNodes);</span>
269                 }
270             }
271         }
272     }
273 
274     static class WorkListEntry {
275         final Iterator&lt;Node&gt; usages;
276         final Node n;
277         boolean isLoopNode;
278 
279         WorkListEntry(Node n, NodeBitMap loopNodes) {
280             this.n = n;
281             this.usages = n.usages().iterator();
282             this.isLoopNode = loopNodes.isMarked(n);
283         }
284 
285         @Override
286         public boolean equals(Object obj) {
287             if (!(obj instanceof WorkListEntry)) {
288                 return false;
</pre>
<hr />
<pre>
300     static TriState isLoopNode(Node n, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {
301         if (loopNodes.isMarked(n)) {
302             return TriState.TRUE;
303         }
304         if (nonLoopNodes.isMarked(n)) {
305             return TriState.FALSE;
306         }
307         if (n instanceof FixedNode || n instanceof PhiNode) {
308             // phi nodes are treated the same as fixed nodes in this algorithm to break cycles
309             return TriState.FALSE;
310         }
311         return TriState.UNKNOWN;
312     }
313 
314     private static void pushWorkList(Deque&lt;WorkListEntry&gt; workList, Node node, NodeBitMap loopNodes) {
315         WorkListEntry entry = new WorkListEntry(node, loopNodes);
316         assert !workList.contains(entry) : &quot;node &quot; + node + &quot; added to worklist twice&quot;;
317         workList.push(entry);
318     }
319 
<span class="line-modified">320     private static void markFloating(Deque&lt;WorkListEntry&gt; workList, LoopEx loop, Node start, NodeBitMap loopNodes, NodeBitMap nonLoopNodes) {</span>
321         if (isLoopNode(start, loopNodes, nonLoopNodes).isKnown()) {
322             return;
323         }
<span class="line-added">324 </span>
<span class="line-added">325         LoopBeginNode loopBeginNode = loop.loopBegin();</span>
<span class="line-added">326         ControlFlowGraph cfg = loop.loopsData().getCFG();</span>
<span class="line-added">327 </span>
328         pushWorkList(workList, start, loopNodes);
329         while (!workList.isEmpty()) {
330             WorkListEntry currentEntry = workList.peek();
331             if (currentEntry.usages.hasNext()) {
332                 Node current = currentEntry.usages.next();
333                 TriState result = isLoopNode(current, loopNodes, nonLoopNodes);
334                 if (result.isKnown()) {
335                     if (result.toBoolean()) {
336                         currentEntry.isLoopNode = true;
337                     }
338                 } else {
339                     pushWorkList(workList, current, loopNodes);
340                 }
341             } else {
342                 workList.pop();
343                 boolean isLoopNode = currentEntry.isLoopNode;
344                 Node current = currentEntry.n;
<span class="line-modified">345                 if (!isLoopNode &amp;&amp; current instanceof GuardNode &amp;&amp; !current.hasUsages()) {</span>
<span class="line-modified">346                     GuardNode guard = (GuardNode) current;</span>
<span class="line-modified">347                     if (isLoopNode(guard.getCondition(), loopNodes, nonLoopNodes) != TriState.FALSE) {</span>
<span class="line-modified">348                         ValueNode anchor = guard.getAnchor().asNode();</span>
<span class="line-modified">349                         TriState isAnchorInLoop = isLoopNode(anchor, loopNodes, nonLoopNodes);</span>
<span class="line-modified">350                         if (isAnchorInLoop != TriState.FALSE) {</span>
<span class="line-modified">351                             if (!(anchor instanceof LoopExitNode &amp;&amp; ((LoopExitNode) anchor).loopBegin() == loopBeginNode)) {</span>
<span class="line-added">352                                 // It is undecidable whether the node is in the loop or not. This is</span>
<span class="line-added">353                                 // not an issue for getting counted loop information,</span>
<span class="line-added">354                                 // but causes issues when using the information for actual loop</span>
<span class="line-added">355                                 // transformations. This is why a loop transformation must</span>
<span class="line-added">356                                 // not happen while guards are floating.</span>
<span class="line-added">357                                 isLoopNode = true;</span>
<span class="line-added">358                             }</span>
<span class="line-added">359                         } else if (AbstractControlFlowGraph.strictlyDominates(cfg.blockFor(anchor), cfg.blockFor(loopBeginNode))) {</span>
<span class="line-added">360                             // The anchor is above the loop. The no-usage guard can potentially be</span>
<span class="line-added">361                             // scheduled inside the loop.</span>
<span class="line-added">362                             isLoopNode = true;</span>
<span class="line-added">363                         }</span>
<span class="line-added">364                     }</span>
365                 }
366                 if (isLoopNode) {
367                     loopNodes.mark(current);
368                     for (WorkListEntry e : workList) {
369                         e.isLoopNode = true;
370                     }
371                 } else {
372                     nonLoopNodes.mark(current);
373                 }
374             }
375         }
376     }
377 
378     public static NodeIterable&lt;AbstractBeginNode&gt; toHirBlocks(final Iterable&lt;Block&gt; blocks) {
379         return new NodeIterable&lt;AbstractBeginNode&gt;() {
380 
381             @Override
382             public Iterator&lt;AbstractBeginNode&gt; iterator() {
383                 final Iterator&lt;Block&gt; it = blocks.iterator();
384                 return new Iterator&lt;AbstractBeginNode&gt;() {
</pre>
<hr />
<pre>
453             for (Node anchored : earlyExit.anchored().snapshot()) {
454                 anchored.replaceFirstInput(earlyExit, merge);
455             }
456 
457             if (earlyExit instanceof LoopExitNode) {
458                 LoopExitNode earlyLoopExit = (LoopExitNode) earlyExit;
459                 FrameState finalExitState = exitState;
460                 boolean newEarlyExitIsLoopExit = newEarlyExit instanceof LoopExitNode;
461                 for (ProxyNode vpn : earlyLoopExit.proxies().snapshot()) {
462                     if (vpn.hasNoUsages()) {
463                         continue;
464                     }
465                     if (vpn.value() == null) {
466                         assert vpn instanceof GuardProxyNode;
467                         vpn.replaceAtUsages(null);
468                         continue;
469                     }
470                     final ValueNode replaceWith;
471                     ValueNode newVpn = prim(newEarlyExitIsLoopExit ? vpn : vpn.value());
472                     if (newVpn != null) {
<span class="line-modified">473                         PhiNode phi = vpn.createPhi(merge);</span>







474                         phi.addInput(vpn);
475                         phi.addInput(newVpn);
476                         replaceWith = phi;
477                     } else {
478                         replaceWith = vpn.value();
479                     }
480                     vpn.replaceAtMatchingUsages(replaceWith, usage -&gt; {
481                         if (merge.isPhiAtMerge(usage)) {
482                             return false;
483                         }
484                         if (usage instanceof VirtualState) {
485                             VirtualState stateUsage = (VirtualState) usage;
486                             if (finalExitState != null &amp;&amp; finalExitState.isPartOfThisState(stateUsage)) {
487                                 return false;
488                             }
489                         }
490                         return true;
491                     });
492                 }
493             }
</pre>
</td>
</tr>
</table>
<center><a href="LoopEx.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragmentInside.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
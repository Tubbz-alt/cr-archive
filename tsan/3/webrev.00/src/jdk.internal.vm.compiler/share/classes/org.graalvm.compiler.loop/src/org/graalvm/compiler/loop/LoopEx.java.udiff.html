<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopEx.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DefaultLoopPolicies.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragment.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/LoopEx.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59,13 +59,10 @@</span>
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.ValuePhiNode;
  import org.graalvm.compiler.nodes.calc.AddNode;
  import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;
  import org.graalvm.compiler.nodes.calc.CompareNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.calc.IntegerBelowNode;</span>
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;</span>
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;</span>
  import org.graalvm.compiler.nodes.calc.LeftShiftNode;
  import org.graalvm.compiler.nodes.calc.MulNode;
  import org.graalvm.compiler.nodes.calc.NegateNode;
  import org.graalvm.compiler.nodes.calc.SignExtendNode;
  import org.graalvm.compiler.nodes.calc.SubNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82,10 +79,11 @@</span>
      private LoopFragmentWhole whole;
      private CountedLoopInfo counted;
      private LoopsData data;
      private EconomicMap&lt;Node, InductionVariable&gt; ivs;
      private boolean countedLoopChecked;
<span class="udiff-line-added">+     private int size = -1;</span>
  
      LoopEx(Loop&lt;Block&gt; loop, LoopsData data) {
          this.loop = loop;
          this.data = data;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -157,16 +155,19 @@</span>
          }
          return data.loop(loop.getParent());
      }
  
      public int size() {
<span class="udiff-line-modified-removed">-         return whole().nodes().count();</span>
<span class="udiff-line-modified-added">+         if (size == -1) {</span>
<span class="udiff-line-added">+             size = whole().nodes().count();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return size;</span>
      }
  
      @Override
      public String toString() {
<span class="udiff-line-modified-removed">-         return (isCounted() ? &quot;CountedLoop [&quot; + counted() + &quot;] &quot; : &quot;Loop &quot;) + &quot;(depth=&quot; + loop().getDepth() + &quot;) &quot; + loopBegin();</span>
<span class="udiff-line-modified-added">+         return (countedLoopChecked &amp;&amp; isCounted() ? &quot;CountedLoop [&quot; + counted() + &quot;] &quot; : &quot;Loop &quot;) + &quot;(depth=&quot; + loop().getDepth() + &quot;) &quot; + loopBegin();</span>
      }
  
      private class InvariantPredicate implements NodePredicate {
  
          private final Graph.Mark mark;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -209,10 +210,11 @@</span>
              }
          }
          return count != 0;
      }
  
<span class="udiff-line-added">+     @SuppressWarnings(&quot;fallthrough&quot;)</span>
      public boolean detectCounted() {
          if (countedLoopChecked) {
              return isCounted();
          }
          countedLoopChecked = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -229,88 +231,106 @@</span>
                      return false;
                  }
                  negated = true;
              }
              LogicNode ifTest = ifNode.condition();
<span class="udiff-line-modified-removed">-             if (!(ifTest instanceof IntegerLessThanNode) &amp;&amp; !(ifTest instanceof IntegerEqualsNode)) {</span>
<span class="udiff-line-removed">-                 if (ifTest instanceof IntegerBelowNode) {</span>
<span class="udiff-line-removed">-                     ifTest.getDebug().log(&quot;Ignored potential Counted loop at %s with |&lt;|&quot;, loopBegin);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+             if (!(ifTest instanceof CompareNode)) {</span>
                  return false;
              }
<span class="udiff-line-modified-removed">-             CompareNode lessThan = (CompareNode) ifTest;</span>
<span class="udiff-line-modified-added">+             CompareNode compare = (CompareNode) ifTest;</span>
              Condition condition = null;
              InductionVariable iv = null;
              ValueNode limit = null;
<span class="udiff-line-modified-removed">-             if (isOutsideLoop(lessThan.getX())) {</span>
<span class="udiff-line-modified-removed">-                 iv = getInductionVariables().get(lessThan.getY());</span>
<span class="udiff-line-modified-added">+             if (isOutsideLoop(compare.getX())) {</span>
<span class="udiff-line-modified-added">+                 iv = getInductionVariables().get(compare.getY());</span>
                  if (iv != null) {
<span class="udiff-line-modified-removed">-                     condition = lessThan.condition().asCondition().mirror();</span>
<span class="udiff-line-modified-removed">-                     limit = lessThan.getX();</span>
<span class="udiff-line-modified-added">+                     condition = compare.condition().asCondition().mirror();</span>
<span class="udiff-line-modified-added">+                     limit = compare.getX();</span>
                  }
<span class="udiff-line-modified-removed">-             } else if (isOutsideLoop(lessThan.getY())) {</span>
<span class="udiff-line-modified-removed">-                 iv = getInductionVariables().get(lessThan.getX());</span>
<span class="udiff-line-modified-added">+             } else if (isOutsideLoop(compare.getY())) {</span>
<span class="udiff-line-modified-added">+                 iv = getInductionVariables().get(compare.getX());</span>
                  if (iv != null) {
<span class="udiff-line-modified-removed">-                     condition = lessThan.condition().asCondition();</span>
<span class="udiff-line-modified-removed">-                     limit = lessThan.getY();</span>
<span class="udiff-line-modified-added">+                     condition = compare.condition().asCondition();</span>
<span class="udiff-line-modified-added">+                     limit = compare.getY();</span>
                  }
              }
              if (condition == null) {
                  return false;
              }
              if (negated) {
                  condition = condition.negate();
              }
              boolean oneOff = false;
<span class="udiff-line-added">+             boolean unsigned = false;</span>
              switch (condition) {
                  case EQ:
<span class="udiff-line-modified-removed">-                     return false;</span>
<span class="udiff-line-modified-removed">-                 case NE: {</span>
<span class="udiff-line-modified-removed">-                     if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1) {</span>
<span class="udiff-line-modified-added">+                     if (iv.initNode() == limit) {</span>
<span class="udiff-line-modified-added">+                         // allow &quot;single iteration&quot; case</span>
<span class="udiff-line-modified-added">+                         oneOff = true;</span>
<span class="udiff-line-added">+                     } else {</span>
                          return false;
                      }
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case NE: {</span>
                      IntegerStamp initStamp = (IntegerStamp) iv.initNode().stamp(NodeView.DEFAULT);
                      IntegerStamp limitStamp = (IntegerStamp) limit.stamp(NodeView.DEFAULT);
<span class="udiff-line-added">+                     IntegerStamp counterStamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);</span>
                      if (iv.direction() == Direction.Up) {
<span class="udiff-line-modified-removed">-                         if (initStamp.upperBound() &gt; limitStamp.lowerBound()) {</span>
<span class="udiff-line-modified-added">+                         if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.upperBound()) {</span>
<span class="udiff-line-added">+                             // signed: i &lt; MAX_INT</span>
<span class="udiff-line-added">+                         } else if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.unsignedUpperBound()) {</span>
<span class="udiff-line-added">+                             unsigned = true;</span>
<span class="udiff-line-added">+                         } else if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1 || initStamp.upperBound() &gt; limitStamp.lowerBound()) {</span>
                              return false;
                          }
                      } else if (iv.direction() == Direction.Down) {
<span class="udiff-line-modified-removed">-                         if (initStamp.lowerBound() &lt; limitStamp.upperBound()) {</span>
<span class="udiff-line-modified-added">+                         if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.lowerBound()) {</span>
<span class="udiff-line-added">+                             // signed: MIN_INT &gt; i</span>
<span class="udiff-line-added">+                         } else if (limitStamp.asConstant() != null &amp;&amp; limitStamp.asConstant().asLong() == counterStamp.unsignedLowerBound()) {</span>
<span class="udiff-line-added">+                             unsigned = true;</span>
<span class="udiff-line-added">+                         } else if (!iv.isConstantStride() || Math.abs(iv.constantStride()) != 1 || initStamp.lowerBound() &lt; limitStamp.upperBound()) {</span>
                              return false;
                          }
                      } else {
                          return false;
                      }
                      break;
                  }
<span class="udiff-line-added">+                 case BE:</span>
<span class="udiff-line-added">+                     unsigned = true; // fall through</span>
                  case LE:
                      oneOff = true;
                      if (iv.direction() != Direction.Up) {
                          return false;
                      }
                      break;
<span class="udiff-line-added">+                 case BT:</span>
<span class="udiff-line-added">+                     unsigned = true; // fall through</span>
                  case LT:
                      if (iv.direction() != Direction.Up) {
                          return false;
                      }
                      break;
<span class="udiff-line-added">+                 case AE:</span>
<span class="udiff-line-added">+                     unsigned = true; // fall through</span>
                  case GE:
                      oneOff = true;
                      if (iv.direction() != Direction.Down) {
                          return false;
                      }
                      break;
<span class="udiff-line-added">+                 case AT:</span>
<span class="udiff-line-added">+                     unsigned = true; // fall through</span>
                  case GT:
                      if (iv.direction() != Direction.Down) {
                          return false;
                      }
                      break;
                  default:
                      throw GraalError.shouldNotReachHere(condition.toString());
              }
<span class="udiff-line-modified-removed">-             counted = new CountedLoopInfo(this, iv, ifNode, limit, oneOff, negated ? ifNode.falseSuccessor() : ifNode.trueSuccessor());</span>
<span class="udiff-line-modified-added">+             counted = new CountedLoopInfo(this, iv, ifNode, limit, oneOff, negated ? ifNode.falseSuccessor() : ifNode.trueSuccessor(), unsigned);</span>
              return true;
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -342,11 +362,11 @@</span>
                      }
                      d = d.getDominatedSibling();
                  }
              }
          }
<span class="udiff-line-modified-removed">-         LoopFragment.computeNodes(branchNodes, branch.graph(), blocks, exits);</span>
<span class="udiff-line-modified-added">+         LoopFragment.computeNodes(branchNodes, branch.graph(), this, blocks, exits);</span>
      }
  
      public EconomicMap&lt;Node, InductionVariable&gt; getInductionVariables() {
          if (ivs == null) {
              ivs = findInductionVariables(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -385,11 +405,11 @@</span>
              ValueNode baseIvNode = baseIv.valueNode();
              for (ValueNode op : baseIvNode.usages().filter(ValueNode.class)) {
                  if (loop.isOutsideLoop(op)) {
                      continue;
                  }
<span class="udiff-line-modified-removed">-                 if (op.usages().count() == 1 &amp;&amp; op.usages().first() == baseIvNode) {</span>
<span class="udiff-line-modified-added">+                 if (op.hasExactlyOneUsage() &amp;&amp; op.usages().first() == baseIvNode) {</span>
                      /*
                       * This is just the base induction variable increment with no other uses so
                       * don&#39;t bother reporting it.
                       */
                      continue;
</pre>
<center><a href="DefaultLoopPolicies.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LoopFragment.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/CountedLoopInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DefaultLoopPolicies.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.loop/src/org/graalvm/compiler/loop/CountedLoopInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
  import static java.lang.Math.abs;
  import static org.graalvm.compiler.loop.MathUtil.unsignedDivBefore;
  import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.add;
  import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.sub;
  
<span class="line-removed">- import org.graalvm.compiler.core.common.NumUtil;</span>
  import org.graalvm.compiler.core.common.type.IntegerStamp;
  import org.graalvm.compiler.core.common.type.Stamp;
  import org.graalvm.compiler.core.common.util.UnsignedLong;
  import org.graalvm.compiler.debug.DebugCloseable;
  import org.graalvm.compiler.loop.InductionVariable.Direction;
<span class="line-new-header">--- 27,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,14 ***</span>
  import org.graalvm.compiler.nodes.LogicNode;
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.ConditionalNode;
<span class="line-removed">- import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;</span>
  import org.graalvm.compiler.nodes.calc.NegateNode;
  import org.graalvm.compiler.nodes.extended.GuardingNode;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  
  import jdk.vm.ci.meta.DeoptimizationAction;
  import jdk.vm.ci.meta.DeoptimizationReason;
  import jdk.vm.ci.meta.SpeculationLog;
  
<span class="line-new-header">--- 41,16 ---</span>
  import org.graalvm.compiler.nodes.LogicNode;
  import org.graalvm.compiler.nodes.NodeView;
  import org.graalvm.compiler.nodes.StructuredGraph;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.calc.ConditionalNode;
  import org.graalvm.compiler.nodes.calc.NegateNode;
  import org.graalvm.compiler.nodes.extended.GuardingNode;
  import org.graalvm.compiler.nodes.util.GraphUtil;
<span class="line-added">+ import org.graalvm.compiler.nodes.util.IntegerHelper;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.util.SignedIntegerHelper;</span>
<span class="line-added">+ import org.graalvm.compiler.nodes.util.UnsignedIntegerHelper;</span>
  
  import jdk.vm.ci.meta.DeoptimizationAction;
  import jdk.vm.ci.meta.DeoptimizationReason;
  import jdk.vm.ci.meta.SpeculationLog;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,19 ***</span>
      private InductionVariable iv;
      private ValueNode end;
      private boolean oneOff;
      private AbstractBeginNode body;
      private IfNode ifNode;
  
<span class="line-modified">!     CountedLoopInfo(LoopEx loop, InductionVariable iv, IfNode ifNode, ValueNode end, boolean oneOff, AbstractBeginNode body) {</span>
          assert iv.direction() != null;
          this.loop = loop;
          this.iv = iv;
          this.end = end;
          this.oneOff = oneOff;
          this.body = body;
          this.ifNode = ifNode;
      }
  
      /**
       * Returns a node that computes the maximum trip count of this loop. That is the trip count of
       * this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
<span class="line-new-header">--- 60,21 ---</span>
      private InductionVariable iv;
      private ValueNode end;
      private boolean oneOff;
      private AbstractBeginNode body;
      private IfNode ifNode;
<span class="line-added">+     private final boolean unsigned;</span>
  
<span class="line-modified">!     CountedLoopInfo(LoopEx loop, InductionVariable iv, IfNode ifNode, ValueNode end, boolean oneOff, AbstractBeginNode body, boolean unsigned) {</span>
          assert iv.direction() != null;
          this.loop = loop;
          this.iv = iv;
          this.end = end;
          this.oneOff = oneOff;
          this.body = body;
          this.ifNode = ifNode;
<span class="line-added">+         this.unsigned = unsigned;</span>
      }
  
      /**
       * Returns a node that computes the maximum trip count of this loop. That is the trip count of
       * this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,10 ***</span>
<span class="line-new-header">--- 86,14 ---</span>
       */
      public ValueNode maxTripCountNode() {
          return maxTripCountNode(false);
      }
  
<span class="line-added">+     public boolean isUnsignedCheck() {</span>
<span class="line-added">+         return this.unsigned;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns a node that computes the maximum trip count of this loop. That is the trip count of
       * this loop assuming it is not exited by an other exit than the {@linkplain #getLimitTest()
       * count check}.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,26 ***</span>
              max = iv.initNode();
              min = end;
          }
          ValueNode range = sub(max, min);
  
<span class="line-modified">!         ConstantNode one = ConstantNode.forIntegerStamp(stamp, 1);</span>
          if (oneOff) {
              range = add(range, one);
          }
          // round-away-from-zero divison: (range + stride -/+ 1) / stride
<span class="line-modified">!         ValueNode denominator = add(range, sub(absStride, one));</span>
          ValueNode div = unsignedDivBefore(graph, loop.entryPoint(), denominator, absStride, null);
  
          if (assumeLoopEntered) {
              return graph.addOrUniqueWithInputs(div);
          }
<span class="line-modified">!         ConstantNode zero = ConstantNode.forIntegerStamp(stamp, 0);</span>
<span class="line-modified">!         LogicNode noEntryCheck = IntegerLessThanNode.create(max, min, NodeView.DEFAULT);</span>
          return graph.addOrUniqueWithInputs(ConditionalNode.create(noEntryCheck, zero, div, NodeView.DEFAULT));
      }
  
      /**
       * @return true if the loop has constant bounds.
       */
      public boolean isConstantMaxTripCount() {
          return end instanceof ConstantNode &amp;&amp; iv.isConstantInit() &amp;&amp; iv.isConstantStride();
<span class="line-new-header">--- 120,63 ---</span>
              max = iv.initNode();
              min = end;
          }
          ValueNode range = sub(max, min);
  
<span class="line-modified">!         ConstantNode one = ConstantNode.forIntegerStamp(stamp, 1, graph);</span>
          if (oneOff) {
              range = add(range, one);
          }
          // round-away-from-zero divison: (range + stride -/+ 1) / stride
<span class="line-modified">!         ValueNode denominator = add(graph, range, sub(absStride, one), NodeView.DEFAULT);</span>
          ValueNode div = unsignedDivBefore(graph, loop.entryPoint(), denominator, absStride, null);
  
          if (assumeLoopEntered) {
              return graph.addOrUniqueWithInputs(div);
          }
<span class="line-modified">!         ConstantNode zero = ConstantNode.forIntegerStamp(stamp, 0, graph);</span>
<span class="line-modified">!         // This check is &quot;wide&quot;: it looks like min &lt;= max</span>
<span class="line-added">+         // That&#39;s OK even if the loop is strict (`!isLimitIncluded()`)</span>
<span class="line-added">+         // because in this case, `div` will be zero when min == max</span>
<span class="line-added">+         LogicNode noEntryCheck = getCounterIntegerHelper().createCompareNode(max, min, NodeView.DEFAULT);</span>
          return graph.addOrUniqueWithInputs(ConditionalNode.create(noEntryCheck, zero, div, NodeView.DEFAULT));
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Determine if the loop might be entered. Returns {@code false} if we can tell statically that</span>
<span class="line-added">+      * the loop cannot be entered; returns {@code true} if the loop might possibly be entered,</span>
<span class="line-added">+      * including in the case where we cannot be sure statically.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return false if the loop can definitely not be entered, true otherwise</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public boolean loopMightBeEntered() {</span>
<span class="line-added">+         Stamp stamp = iv.valueNode().stamp(NodeView.DEFAULT);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ValueNode max;</span>
<span class="line-added">+         ValueNode min;</span>
<span class="line-added">+         if (iv.direction() == Direction.Up) {</span>
<span class="line-added">+             max = end;</span>
<span class="line-added">+             min = iv.initNode();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             assert iv.direction() == Direction.Down;</span>
<span class="line-added">+             max = iv.initNode();</span>
<span class="line-added">+             min = end;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (oneOff) {</span>
<span class="line-added">+             max = add(max, ConstantNode.forIntegerStamp(stamp, 1));</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         LogicNode entryCheck = getCounterIntegerHelper().createCompareNode(min, max, NodeView.DEFAULT);</span>
<span class="line-added">+         if (entryCheck.isContradiction()) {</span>
<span class="line-added">+             // We can definitely not enter this loop.</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // We don&#39;t know for sure that the loop can&#39;t be entered, so assume it can.</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * @return true if the loop has constant bounds.
       */
      public boolean isConstantMaxTripCount() {
          return end instanceof ConstantNode &amp;&amp; iv.isConstantInit() &amp;&amp; iv.isConstantStride();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,19 ***</span>
          assert iv.direction() != null;
          long endValue = end.asJavaConstant().asLong();
          long initValue = iv.constantInit();
          long range;
          long absStride;
          if (iv.direction() == Direction.Up) {
<span class="line-modified">!             if (endValue &lt; initValue) {</span>
                  return 0;
              }
              range = endValue - iv.constantInit();
              absStride = iv.constantStride();
          } else {
              assert iv.direction() == Direction.Down;
<span class="line-modified">!             if (initValue &lt; endValue) {</span>
                  return 0;
              }
              range = iv.constantInit() - endValue;
              absStride = -iv.constantStride();
          }
<span class="line-new-header">--- 194,20 ---</span>
          assert iv.direction() != null;
          long endValue = end.asJavaConstant().asLong();
          long initValue = iv.constantInit();
          long range;
          long absStride;
<span class="line-added">+         IntegerHelper helper = getCounterIntegerHelper(64);</span>
          if (iv.direction() == Direction.Up) {
<span class="line-modified">!             if (helper.compare(endValue, initValue) &lt; 0) {</span>
                  return 0;
              }
              range = endValue - iv.constantInit();
              absStride = iv.constantStride();
          } else {
              assert iv.direction() == Direction.Down;
<span class="line-modified">!             if (helper.compare(initValue, endValue) &lt; 0) {</span>
                  return 0;
              }
              range = iv.constantInit() - endValue;
              absStride = -iv.constantStride();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,10 ***</span>
<span class="line-new-header">--- 216,25 ---</span>
          }
          long denominator = range + absStride - 1;
          return Long.divideUnsigned(denominator, absStride);
      }
  
<span class="line-added">+     public IntegerHelper getCounterIntegerHelper() {</span>
<span class="line-added">+         IntegerStamp stamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);</span>
<span class="line-added">+         return getCounterIntegerHelper(stamp.getBits());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public IntegerHelper getCounterIntegerHelper(int bits) {</span>
<span class="line-added">+         IntegerHelper helper;</span>
<span class="line-added">+         if (isUnsignedCheck()) {</span>
<span class="line-added">+             helper = new UnsignedIntegerHelper(bits);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             helper = new SignedIntegerHelper(bits);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return helper;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public boolean isExactTripCount() {
          return loop.loop().getNaturalExits().size() == 1;
      }
  
      public ValueNode exactTripCountNode() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,16 ***</span>
          }
          IntegerStamp endStamp = (IntegerStamp) end.stamp(NodeView.DEFAULT);
          ValueNode strideNode = iv.strideNode();
          IntegerStamp strideStamp = (IntegerStamp) strideNode.stamp(NodeView.DEFAULT);
          GraphUtil.tryKillUnused(strideNode);
          if (getDirection() == Direction.Up) {
<span class="line-modified">!             long max = NumUtil.maxValue(endStamp.getBits());</span>
<span class="line-modified">!             return endStamp.upperBound() &lt;= max - (strideStamp.upperBound() - 1) - (oneOff ? 1 : 0);</span>
          } else if (getDirection() == Direction.Down) {
<span class="line-modified">!             long min = NumUtil.minValue(endStamp.getBits());</span>
<span class="line-modified">!             return min + (1 - strideStamp.lowerBound()) + (oneOff ? 1 : 0) &lt;= endStamp.lowerBound();</span>
          }
          return false;
      }
  
      @SuppressWarnings(&quot;try&quot;)
<span class="line-new-header">--- 304,17 ---</span>
          }
          IntegerStamp endStamp = (IntegerStamp) end.stamp(NodeView.DEFAULT);
          ValueNode strideNode = iv.strideNode();
          IntegerStamp strideStamp = (IntegerStamp) strideNode.stamp(NodeView.DEFAULT);
          GraphUtil.tryKillUnused(strideNode);
<span class="line-added">+         IntegerHelper integerHelper = getCounterIntegerHelper();</span>
          if (getDirection() == Direction.Up) {
<span class="line-modified">!             long max = integerHelper.maxValue();</span>
<span class="line-modified">!             return integerHelper.compare(endStamp.upperBound(), max - (strideStamp.upperBound() - 1) - (oneOff ? 1 : 0)) &lt;= 0;</span>
          } else if (getDirection() == Direction.Down) {
<span class="line-modified">!             long min = integerHelper.minValue();</span>
<span class="line-modified">!             return integerHelper.compare(min + (1 - strideStamp.lowerBound()) + (oneOff ? 1 : 0), endStamp.lowerBound()) &lt;= 0;</span>
          }
          return false;
      }
  
      @SuppressWarnings(&quot;try&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,26 ***</span>
          if (overflowGuard != null || counterNeverOverflows()) {
              return overflowGuard;
          }
          try (DebugCloseable position = loop.loopBegin().withNodeSourcePosition()) {
              IntegerStamp stamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);
              StructuredGraph graph = iv.valueNode().graph();
              LogicNode cond; // we use a negated guard with a &lt; condition to achieve a &gt;=
              ConstantNode one = ConstantNode.forIntegerStamp(stamp, 1, graph);
              if (iv.direction() == Direction.Up) {
<span class="line-modified">!                 ValueNode v1 = sub(ConstantNode.forIntegerStamp(stamp, NumUtil.maxValue(stamp.getBits())), sub(iv.strideNode(), one));</span>
                  if (oneOff) {
                      v1 = sub(v1, one);
                  }
<span class="line-modified">!                 cond = graph.addOrUniqueWithInputs(IntegerLessThanNode.create(v1, end, NodeView.DEFAULT));</span>
              } else {
                  assert iv.direction() == Direction.Down;
<span class="line-modified">!                 ValueNode v1 = add(ConstantNode.forIntegerStamp(stamp, NumUtil.minValue(stamp.getBits())), sub(one, iv.strideNode()));</span>
                  if (oneOff) {
                      v1 = add(v1, one);
                  }
<span class="line-modified">!                 cond = graph.addOrUniqueWithInputs(IntegerLessThanNode.create(end, v1, NodeView.DEFAULT));</span>
              }
              assert graph.getGuardsStage().allowsFloatingGuards();
              overflowGuard = graph.unique(new GuardNode(cond, AbstractBeginNode.prevBegin(loop.entryPoint()), DeoptimizationReason.LoopLimitCheck, DeoptimizationAction.InvalidateRecompile, true,
                              SpeculationLog.NO_SPECULATION, null)); // TODO gd: use speculation
              loop.loopBegin().setOverflowGuard(overflowGuard);
<span class="line-new-header">--- 323,27 ---</span>
          if (overflowGuard != null || counterNeverOverflows()) {
              return overflowGuard;
          }
          try (DebugCloseable position = loop.loopBegin().withNodeSourcePosition()) {
              IntegerStamp stamp = (IntegerStamp) iv.valueNode().stamp(NodeView.DEFAULT);
<span class="line-added">+             IntegerHelper integerHelper = getCounterIntegerHelper();</span>
              StructuredGraph graph = iv.valueNode().graph();
              LogicNode cond; // we use a negated guard with a &lt; condition to achieve a &gt;=
              ConstantNode one = ConstantNode.forIntegerStamp(stamp, 1, graph);
              if (iv.direction() == Direction.Up) {
<span class="line-modified">!                 ValueNode v1 = sub(ConstantNode.forIntegerStamp(stamp, integerHelper.maxValue()), sub(iv.strideNode(), one));</span>
                  if (oneOff) {
                      v1 = sub(v1, one);
                  }
<span class="line-modified">!                 cond = graph.addOrUniqueWithInputs(integerHelper.createCompareNode(v1, end, NodeView.DEFAULT));</span>
              } else {
                  assert iv.direction() == Direction.Down;
<span class="line-modified">!                 ValueNode v1 = add(ConstantNode.forIntegerStamp(stamp, integerHelper.minValue()), sub(one, iv.strideNode()));</span>
                  if (oneOff) {
                      v1 = add(v1, one);
                  }
<span class="line-modified">!                 cond = graph.addOrUniqueWithInputs(integerHelper.createCompareNode(end, v1, NodeView.DEFAULT));</span>
              }
              assert graph.getGuardsStage().allowsFloatingGuards();
              overflowGuard = graph.unique(new GuardNode(cond, AbstractBeginNode.prevBegin(loop.entryPoint()), DeoptimizationReason.LoopLimitCheck, DeoptimizationAction.InvalidateRecompile, true,
                              SpeculationLog.NO_SPECULATION, null)); // TODO gd: use speculation
              loop.loopBegin().setOverflowGuard(overflowGuard);
</pre>
<center><a href="../../../../../../org.graalvm.compiler.loop.test/src/org/graalvm/compiler/loop/test/LoopPartialUnrollTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DefaultLoopPolicies.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.sparc/src/org/graalvm/compiler/asm/sparc/SPARCAssembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AVXKind.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.test/src/org/graalvm/compiler/asm/test/AssemblerTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.sparc/src/org/graalvm/compiler/asm/sparc/SPARCAssembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 611         Fcc1(0b01, &quot;fcc1&quot;, true),
 612         Fcc2(0b10, &quot;fcc2&quot;, true),
 613         Fcc3(0b11, &quot;fcc3&quot;, true);
 614 
 615         // @formatter:on
 616 
 617         private final int value;
 618         private final String operator;
 619         private boolean isFloat;
 620 
 621         CC(int value, String op, boolean isFloat) {
 622             this.value = value;
 623             this.operator = op;
 624             this.isFloat = isFloat;
 625         }
 626 
 627         public int getValue() {
 628             return value;
 629         }
 630 







 631         public String getOperator() {
 632             return operator;
 633         }
 634 
 635         public static CC forKind(PlatformKind kind) {
 636             if (kind.equals(SPARCKind.XWORD)) {
 637                 return Xcc;
 638             } else if (kind.equals(SPARCKind.WORD)) {
 639                 return Icc;
 640             } else if (kind.equals(SPARCKind.SINGLE) || kind.equals(SPARCKind.DOUBLE)) {
 641                 return Fcc0;
 642             } else {
 643                 throw new IllegalArgumentException(&quot;Unknown kind: &quot; + kind);
 644             }
 645         }
 646     }
 647 
 648     public enum ConditionFlag {
 649         // @formatter:off
 650 
</pre>
<hr />
<pre>
1596             List&lt;BitKey[]&gt; keys = super.getKeys();
1597             keys.add(new BitKey[]{new BitKey(BitSpec.op3, op3.value)});
1598             return keys;
1599         }
1600     }
1601 
1602     public static final class FMOVcc extends SPARCOp implements CMOV {
1603         private OpfLow opfLow;
1604 
1605         public FMOVcc(OpfLow opfLow) {
1606             super(ArithOp);
1607             this.opfLow = opfLow;
1608         }
1609 
1610         @Override
1611         public void emit(SPARCMacroAssembler masm, ConditionFlag condition, CC cc, Register rs2, Register rd) {
1612             int inst = setBits(0);
1613             inst = BitSpec.rd.setBits(inst, rd.encoding());
1614             inst = BitSpec.op3.setBits(inst, opfLow.op3.value);
1615             inst = BitSpec.opfCond.setBits(inst, condition.value);
<span class="line-modified">1616             inst = BitSpec.opfCC.setBits(inst, cc.value);</span>
1617             inst = BitSpec.opfLow.setBits(inst, opfLow.value);
1618             inst = BitSpec.rs2.setBits(inst, rs2.encoding());
1619             masm.emitInt(inst);
1620         }
1621 
1622         @Override
1623         public void emit(SPARCMacroAssembler masm, ConditionFlag condition, CC cc, int simm11, Register rd) {
1624             throw new IllegalArgumentException(&quot;FMOVCC cannot be used with immediate value&quot;);
1625         }
1626 
1627         @Override
1628         protected List&lt;BitKey[]&gt; getKeys() {
1629             List&lt;BitKey[]&gt; keys = super.getKeys();
1630             keys.add(new BitKey[]{new BitKey(BitSpec.op3, opfLow.op3.value)});
1631             keys.add(new BitKey[]{new BitKey(BitSpec.opfLow, opfLow.value)});
1632             return keys;
1633         }
1634     }
1635 
1636     public static final class OpfOp extends SPARCOp {
</pre>
<hr />
<pre>
1834 
1835     protected void op3(Op3s op3, Register rs1, int simm13, Register rd) {
1836         assert isSimm13(simm13) : simm13;
1837         int i = 1 &lt;&lt; 13;
1838         int simm13WithX = simm13 | getXBit(op3);
1839         fmt(op3.op.value, rd.encoding, op3.value, rs1.encoding, i | simm13WithX &amp; ((1 &lt;&lt; 13) - 1));
1840     }
1841 
1842     public void insertNopAfterCBCond() {
1843         int pos = position() - INSTRUCTION_SIZE;
1844         if (pos == 0) {
1845             return;
1846         }
1847         int inst = getInt(pos);
1848         if (CBCOND.match(inst)) {
1849             nop();
1850         }
1851     }
1852 
1853     protected int patchUnbound(Label label) {
<span class="line-modified">1854         label.addPatchAt(position());</span>
1855         return 0;
1856     }
1857 
1858     // @formatter:off
1859     /**
1860      * NOP.
1861      * &lt;pre&gt;
1862      * | 00  |00000| 100 |                0                    |
1863      * |31 30|29 25|24 22|21                                  0|
1864      * &lt;/pre&gt;
1865      */
1866     // @formatter:on
1867     public void nop() {
1868         emitInt(1 &lt;&lt; 24);
1869     }
1870 
1871     public void sethi(int imm22, Register dst) {
1872         fmt00(dst.encoding, Op2s.Sethi.value, imm22);
1873     }
1874 
</pre>
<hr />
<pre>
2176 
2177     /**
2178      * @return Position of the jmpl instruction
2179      */
2180     public int jmpl(Register rs1, int simm13, Register rd) {
2181         insertNopAfterCBCond();
2182         int before = position();
2183         op3(Jmpl, rs1, simm13, rd);
2184         return before;
2185     }
2186 
2187     public void fmovdcc(ConditionFlag cond, CC cc, Register rs2, Register rd) {
2188         fmovcc(cond, cc, rs2, rd, OpfLow.Fmovdcc.value);
2189     }
2190 
2191     public void fmovscc(ConditionFlag cond, CC cc, Register rs2, Register rd) {
2192         fmovcc(cond, cc, rs2, rd, OpfLow.Fmovscc.value);
2193     }
2194 
2195     private void fmovcc(ConditionFlag cond, CC cc, Register rs2, Register rd, int opfLow) {
<span class="line-modified">2196         int opfCC = cc.value;</span>
2197         int a = opfCC &lt;&lt; 11 | opfLow &lt;&lt; 5 | rs2.encoding;
2198         fmt10(rd.encoding, Fpop2.value, cond.value, a);
2199     }
2200 
2201     public void movcc(ConditionFlag conditionFlag, CC cc, Register rs2, Register rd) {
2202         movcc(conditionFlag, cc, 0, rs2.encoding, rd);
2203     }
2204 
2205     public void movcc(ConditionFlag conditionFlag, CC cc, int simm11, Register rd) {
2206         assert isSimm11(simm11);
2207         movcc(conditionFlag, cc, 1, simm11 &amp; ((1 &lt;&lt; 11) - 1), rd);
2208     }
2209 
2210     private void movcc(ConditionFlag conditionFlag, CC cc, int i, int imm, Register rd) {
2211         int cc01 = 0b11 &amp; cc.value;
2212         int cc2 = cc.isFloat ? 0 : 1;
2213         int a = cc2 &lt;&lt; 4 | conditionFlag.value;
2214         int b = cc01 &lt;&lt; 11 | i &lt;&lt; 13 | imm;
2215         fmt10(rd.encoding, Movcc.value, a, b);
2216     }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 611         Fcc1(0b01, &quot;fcc1&quot;, true),
 612         Fcc2(0b10, &quot;fcc2&quot;, true),
 613         Fcc3(0b11, &quot;fcc3&quot;, true);
 614 
 615         // @formatter:on
 616 
 617         private final int value;
 618         private final String operator;
 619         private boolean isFloat;
 620 
 621         CC(int value, String op, boolean isFloat) {
 622             this.value = value;
 623             this.operator = op;
 624             this.isFloat = isFloat;
 625         }
 626 
 627         public int getValue() {
 628             return value;
 629         }
 630 
<span class="line-added"> 631         public int getOpfCCValue() {</span>
<span class="line-added"> 632             /*</span>
<span class="line-added"> 633              * In the opf_cc encoding for FMOVcc, the third bit is set to indicate icc/xcc.</span>
<span class="line-added"> 634              */</span>
<span class="line-added"> 635             return (isFloat ? value : (value | 0x4));</span>
<span class="line-added"> 636         }</span>
<span class="line-added"> 637 </span>
 638         public String getOperator() {
 639             return operator;
 640         }
 641 
 642         public static CC forKind(PlatformKind kind) {
 643             if (kind.equals(SPARCKind.XWORD)) {
 644                 return Xcc;
 645             } else if (kind.equals(SPARCKind.WORD)) {
 646                 return Icc;
 647             } else if (kind.equals(SPARCKind.SINGLE) || kind.equals(SPARCKind.DOUBLE)) {
 648                 return Fcc0;
 649             } else {
 650                 throw new IllegalArgumentException(&quot;Unknown kind: &quot; + kind);
 651             }
 652         }
 653     }
 654 
 655     public enum ConditionFlag {
 656         // @formatter:off
 657 
</pre>
<hr />
<pre>
1603             List&lt;BitKey[]&gt; keys = super.getKeys();
1604             keys.add(new BitKey[]{new BitKey(BitSpec.op3, op3.value)});
1605             return keys;
1606         }
1607     }
1608 
1609     public static final class FMOVcc extends SPARCOp implements CMOV {
1610         private OpfLow opfLow;
1611 
1612         public FMOVcc(OpfLow opfLow) {
1613             super(ArithOp);
1614             this.opfLow = opfLow;
1615         }
1616 
1617         @Override
1618         public void emit(SPARCMacroAssembler masm, ConditionFlag condition, CC cc, Register rs2, Register rd) {
1619             int inst = setBits(0);
1620             inst = BitSpec.rd.setBits(inst, rd.encoding());
1621             inst = BitSpec.op3.setBits(inst, opfLow.op3.value);
1622             inst = BitSpec.opfCond.setBits(inst, condition.value);
<span class="line-modified">1623             inst = BitSpec.opfCC.setBits(inst, cc.getOpfCCValue());</span>
1624             inst = BitSpec.opfLow.setBits(inst, opfLow.value);
1625             inst = BitSpec.rs2.setBits(inst, rs2.encoding());
1626             masm.emitInt(inst);
1627         }
1628 
1629         @Override
1630         public void emit(SPARCMacroAssembler masm, ConditionFlag condition, CC cc, int simm11, Register rd) {
1631             throw new IllegalArgumentException(&quot;FMOVCC cannot be used with immediate value&quot;);
1632         }
1633 
1634         @Override
1635         protected List&lt;BitKey[]&gt; getKeys() {
1636             List&lt;BitKey[]&gt; keys = super.getKeys();
1637             keys.add(new BitKey[]{new BitKey(BitSpec.op3, opfLow.op3.value)});
1638             keys.add(new BitKey[]{new BitKey(BitSpec.opfLow, opfLow.value)});
1639             return keys;
1640         }
1641     }
1642 
1643     public static final class OpfOp extends SPARCOp {
</pre>
<hr />
<pre>
1841 
1842     protected void op3(Op3s op3, Register rs1, int simm13, Register rd) {
1843         assert isSimm13(simm13) : simm13;
1844         int i = 1 &lt;&lt; 13;
1845         int simm13WithX = simm13 | getXBit(op3);
1846         fmt(op3.op.value, rd.encoding, op3.value, rs1.encoding, i | simm13WithX &amp; ((1 &lt;&lt; 13) - 1));
1847     }
1848 
1849     public void insertNopAfterCBCond() {
1850         int pos = position() - INSTRUCTION_SIZE;
1851         if (pos == 0) {
1852             return;
1853         }
1854         int inst = getInt(pos);
1855         if (CBCOND.match(inst)) {
1856             nop();
1857         }
1858     }
1859 
1860     protected int patchUnbound(Label label) {
<span class="line-modified">1861         label.addPatchAt(position(), this);</span>
1862         return 0;
1863     }
1864 
1865     // @formatter:off
1866     /**
1867      * NOP.
1868      * &lt;pre&gt;
1869      * | 00  |00000| 100 |                0                    |
1870      * |31 30|29 25|24 22|21                                  0|
1871      * &lt;/pre&gt;
1872      */
1873     // @formatter:on
1874     public void nop() {
1875         emitInt(1 &lt;&lt; 24);
1876     }
1877 
1878     public void sethi(int imm22, Register dst) {
1879         fmt00(dst.encoding, Op2s.Sethi.value, imm22);
1880     }
1881 
</pre>
<hr />
<pre>
2183 
2184     /**
2185      * @return Position of the jmpl instruction
2186      */
2187     public int jmpl(Register rs1, int simm13, Register rd) {
2188         insertNopAfterCBCond();
2189         int before = position();
2190         op3(Jmpl, rs1, simm13, rd);
2191         return before;
2192     }
2193 
2194     public void fmovdcc(ConditionFlag cond, CC cc, Register rs2, Register rd) {
2195         fmovcc(cond, cc, rs2, rd, OpfLow.Fmovdcc.value);
2196     }
2197 
2198     public void fmovscc(ConditionFlag cond, CC cc, Register rs2, Register rd) {
2199         fmovcc(cond, cc, rs2, rd, OpfLow.Fmovscc.value);
2200     }
2201 
2202     private void fmovcc(ConditionFlag cond, CC cc, Register rs2, Register rd, int opfLow) {
<span class="line-modified">2203         int opfCC = cc.getOpfCCValue();</span>
2204         int a = opfCC &lt;&lt; 11 | opfLow &lt;&lt; 5 | rs2.encoding;
2205         fmt10(rd.encoding, Fpop2.value, cond.value, a);
2206     }
2207 
2208     public void movcc(ConditionFlag conditionFlag, CC cc, Register rs2, Register rd) {
2209         movcc(conditionFlag, cc, 0, rs2.encoding, rd);
2210     }
2211 
2212     public void movcc(ConditionFlag conditionFlag, CC cc, int simm11, Register rd) {
2213         assert isSimm11(simm11);
2214         movcc(conditionFlag, cc, 1, simm11 &amp; ((1 &lt;&lt; 11) - 1), rd);
2215     }
2216 
2217     private void movcc(ConditionFlag conditionFlag, CC cc, int i, int imm, Register rd) {
2218         int cc01 = 0b11 &amp; cc.value;
2219         int cc2 = cc.isFloat ? 0 : 1;
2220         int a = cc2 &lt;&lt; 4 | conditionFlag.value;
2221         int b = cc01 &lt;&lt; 11 | i &lt;&lt; 13 | imm;
2222         fmt10(rd.encoding, Movcc.value, a, b);
2223     }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AVXKind.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.test/src/org/graalvm/compiler/asm/test/AssemblerTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
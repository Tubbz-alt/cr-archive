diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.sparc/src/org/graalvm/compiler/asm/sparc/SPARCAssembler.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.sparc/src/org/graalvm/compiler/asm/sparc/SPARCAssembler.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.sparc/src/org/graalvm/compiler/asm/sparc/SPARCAssembler.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.sparc/src/org/graalvm/compiler/asm/sparc/SPARCAssembler.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -626,10 +626,17 @@
 
         public int getValue() {
             return value;
         }
 
+        public int getOpfCCValue() {
+            /*
+             * In the opf_cc encoding for FMOVcc, the third bit is set to indicate icc/xcc.
+             */
+            return (isFloat ? value : (value | 0x4));
+        }
+
         public String getOperator() {
             return operator;
         }
 
         public static CC forKind(PlatformKind kind) {
@@ -1611,11 +1618,11 @@
         public void emit(SPARCMacroAssembler masm, ConditionFlag condition, CC cc, Register rs2, Register rd) {
             int inst = setBits(0);
             inst = BitSpec.rd.setBits(inst, rd.encoding());
             inst = BitSpec.op3.setBits(inst, opfLow.op3.value);
             inst = BitSpec.opfCond.setBits(inst, condition.value);
-            inst = BitSpec.opfCC.setBits(inst, cc.value);
+            inst = BitSpec.opfCC.setBits(inst, cc.getOpfCCValue());
             inst = BitSpec.opfLow.setBits(inst, opfLow.value);
             inst = BitSpec.rs2.setBits(inst, rs2.encoding());
             masm.emitInt(inst);
         }
 
@@ -1849,11 +1856,11 @@
             nop();
         }
     }
 
     protected int patchUnbound(Label label) {
-        label.addPatchAt(position());
+        label.addPatchAt(position(), this);
         return 0;
     }
 
     // @formatter:off
     /**
@@ -2191,11 +2198,11 @@
     public void fmovscc(ConditionFlag cond, CC cc, Register rs2, Register rd) {
         fmovcc(cond, cc, rs2, rd, OpfLow.Fmovscc.value);
     }
 
     private void fmovcc(ConditionFlag cond, CC cc, Register rs2, Register rd, int opfLow) {
-        int opfCC = cc.value;
+        int opfCC = cc.getOpfCCValue();
         int a = opfCC << 11 | opfLow << 5 | rs2.encoding;
         fmt10(rd.encoding, Fpop2.value, cond.value, a);
     }
 
     public void movcc(ConditionFlag conditionFlag, CC cc, Register rs2, Register rd) {

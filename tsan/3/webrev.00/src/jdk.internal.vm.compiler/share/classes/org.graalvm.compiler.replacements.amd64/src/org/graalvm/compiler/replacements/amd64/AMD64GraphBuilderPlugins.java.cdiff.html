<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64GraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64FloatConvertNode.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64StringLatin1InflateNode.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64GraphBuilderPlugins.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,17 ***</span>
  import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.EXP;
  import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG;
  import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG10;
  import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.SIN;
  import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.TAN;
<span class="line-removed">- import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.JAVA_SPECIFICATION_VERSION;</span>
<span class="line-removed">- import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java11OrEarlier;</span>
<span class="line-removed">- import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;</span>
  
  import java.util.Arrays;
  
<span class="line-removed">- import org.graalvm.compiler.bytecode.BytecodeProvider;</span>
  import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool.RoundingMode;
  import org.graalvm.compiler.nodes.PauseNode;
  import org.graalvm.compiler.nodes.ValueNode;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
  import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
<span class="line-new-header">--- 30,13 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,131 ***</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
  import org.graalvm.compiler.nodes.java.AtomicReadAndAddNode;
  import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
  import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
  import org.graalvm.compiler.replacements.ArraysSubstitutions;
<span class="line-removed">- import org.graalvm.compiler.replacements.IntegerSubstitutions;</span>
<span class="line-removed">- import org.graalvm.compiler.replacements.LongSubstitutions;</span>
  import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.UnsafeAccessPlugin;
  import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.UnsafeGetPlugin;
  import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.UnsafePutPlugin;
  import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
  import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode.BinaryOperation;
  import org.graalvm.compiler.replacements.nodes.BitCountNode;
  import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
  import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation;
  
  import jdk.vm.ci.amd64.AMD64;
  import jdk.vm.ci.amd64.AMD64.CPUFeature;
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import sun.misc.Unsafe;
  
<span class="line-modified">! public class AMD64GraphBuilderPlugins {</span>
  
<span class="line-modified">!     public static void register(Plugins plugins, BytecodeProvider replacementsBytecodeProvider, AMD64 arch, boolean explicitUnsafeNullChecks) {</span>
          InvocationPlugins invocationPlugins = plugins.getInvocationPlugins();
          invocationPlugins.defer(new Runnable() {
              @Override
              public void run() {
                  registerThreadPlugins(invocationPlugins, arch);
<span class="line-modified">!                 registerIntegerLongPlugins(invocationPlugins, IntegerSubstitutions.class, JavaKind.Int, arch, replacementsBytecodeProvider);</span>
<span class="line-modified">!                 registerIntegerLongPlugins(invocationPlugins, LongSubstitutions.class, JavaKind.Long, arch, replacementsBytecodeProvider);</span>
<span class="line-modified">!                 registerPlatformSpecificUnsafePlugins(invocationPlugins, replacementsBytecodeProvider, explicitUnsafeNullChecks,</span>
                                  new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object, JavaKind.Boolean, JavaKind.Byte, JavaKind.Short, JavaKind.Char, JavaKind.Float, JavaKind.Double});
<span class="line-modified">!                 registerUnsafePlugins(invocationPlugins, replacementsBytecodeProvider, explicitUnsafeNullChecks);</span>
<span class="line-modified">!                 registerStringPlugins(invocationPlugins, replacementsBytecodeProvider);</span>
<span class="line-modified">!                 registerStringLatin1Plugins(invocationPlugins, replacementsBytecodeProvider);</span>
<span class="line-modified">!                 registerStringUTF16Plugins(invocationPlugins, replacementsBytecodeProvider);</span>
<span class="line-modified">!                 registerMathPlugins(invocationPlugins, arch, replacementsBytecodeProvider);</span>
<span class="line-modified">!                 registerArraysEqualsPlugins(invocationPlugins, replacementsBytecodeProvider);</span>
              }
          });
      }
  
      private static void registerThreadPlugins(InvocationPlugins plugins, AMD64 arch) {
<span class="line-modified">!         if (!Java8OrEarlier) {</span>
              // Pause instruction introduced with SSE2
<span class="line-modified">!             if (arch.getFeatures().contains(AMD64.CPUFeature.SSE2)) {</span>
<span class="line-modified">!                 Registration r = new Registration(plugins, Thread.class);</span>
<span class="line-modified">!                 r.register0(&quot;onSpinWait&quot;, new InvocationPlugin() {</span>
<span class="line-removed">-                     @Override</span>
<span class="line-removed">-                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-removed">-                         b.append(new PauseNode());</span>
<span class="line-removed">-                         return true;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 });</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static void registerIntegerLongPlugins(InvocationPlugins plugins, Class&lt;?&gt; substituteDeclaringClass, JavaKind kind, AMD64 arch, BytecodeProvider bytecodeProvider) {</span>
<span class="line-removed">-         Class&lt;?&gt; declaringClass = kind.toBoxedJavaClass();</span>
<span class="line-removed">-         Class&lt;?&gt; type = kind.toJavaClass();</span>
<span class="line-removed">-         Registration r = new Registration(plugins, declaringClass, bytecodeProvider);</span>
<span class="line-removed">-         if (arch.getFeatures().contains(AMD64.CPUFeature.LZCNT) &amp;&amp; arch.getFlags().contains(AMD64.Flag.UseCountLeadingZerosInstruction)) {</span>
<span class="line-removed">-             r.register1(&quot;numberOfLeadingZeros&quot;, type, new InvocationPlugin() {</span>
<span class="line-removed">-                 @Override</span>
<span class="line-removed">-                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {</span>
<span class="line-removed">-                     ValueNode folded = AMD64CountLeadingZerosNode.tryFold(value);</span>
<span class="line-removed">-                     if (folded != null) {</span>
<span class="line-removed">-                         b.addPush(JavaKind.Int, folded);</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         b.addPush(JavaKind.Int, new AMD64CountLeadingZerosNode(value));</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     return true;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             r.registerMethodSubstitution(substituteDeclaringClass, &quot;numberOfLeadingZeros&quot;, type);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (arch.getFeatures().contains(AMD64.CPUFeature.BMI1) &amp;&amp; arch.getFlags().contains(AMD64.Flag.UseCountTrailingZerosInstruction)) {</span>
<span class="line-removed">-             r.register1(&quot;numberOfTrailingZeros&quot;, type, new InvocationPlugin() {</span>
                  @Override
<span class="line-modified">!                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {</span>
<span class="line-modified">!                     ValueNode folded = AMD64CountTrailingZerosNode.tryFold(value);</span>
<span class="line-removed">-                     if (folded != null) {</span>
<span class="line-removed">-                         b.addPush(JavaKind.Int, folded);</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         b.addPush(JavaKind.Int, new AMD64CountTrailingZerosNode(value));</span>
<span class="line-removed">-                     }</span>
                      return true;
                  }
              });
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             r.registerMethodSubstitution(substituteDeclaringClass, &quot;numberOfTrailingZeros&quot;, type);</span>
          }
  
<span class="line-modified">!         if (arch.getFeatures().contains(AMD64.CPUFeature.POPCNT)) {</span>
<span class="line-modified">!             r.register1(&quot;bitCount&quot;, type, new InvocationPlugin() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {</span>
<span class="line-modified">!                     b.push(JavaKind.Int, b.append(new BitCountNode(value).canonical(null)));</span>
<span class="line-modified">!                     return true;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             });</span>
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     private static void registerMathPlugins(InvocationPlugins plugins, AMD64 arch, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Math.class, bytecodeProvider);</span>
          registerUnaryMath(r, &quot;log&quot;, LOG);
          registerUnaryMath(r, &quot;log10&quot;, LOG10);
          registerUnaryMath(r, &quot;exp&quot;, EXP);
          registerBinaryMath(r, &quot;pow&quot;, POW);
          registerUnaryMath(r, &quot;sin&quot;, SIN);
          registerUnaryMath(r, &quot;cos&quot;, COS);
          registerUnaryMath(r, &quot;tan&quot;, TAN);
  
<span class="line-modified">!         if (arch.getFeatures().contains(CPUFeature.SSE4_1)) {</span>
<span class="line-modified">!             registerRound(r, &quot;rint&quot;, RoundingMode.NEAREST);</span>
<span class="line-modified">!             registerRound(r, &quot;ceil&quot;, RoundingMode.UP);</span>
<span class="line-modified">!             registerRound(r, &quot;floor&quot;, RoundingMode.DOWN);</span>
          }
      }
  
      private static void registerUnaryMath(Registration r, String name, UnaryOperation operation) {
          r.register1(name, Double.TYPE, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
                  b.push(JavaKind.Double, b.append(UnaryMathIntrinsicNode.create(value, operation)));
<span class="line-new-header">--- 45,149 ---</span>
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
  import org.graalvm.compiler.nodes.java.AtomicReadAndAddNode;
  import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
  import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-added">+ import org.graalvm.compiler.nodes.spi.Replacements;</span>
  import org.graalvm.compiler.replacements.ArraysSubstitutions;
  import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.UnsafeAccessPlugin;
  import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.UnsafeGetPlugin;
  import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.UnsafePutPlugin;
<span class="line-added">+ import org.graalvm.compiler.replacements.TargetGraphBuilderPlugins;</span>
  import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
  import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode.BinaryOperation;
  import org.graalvm.compiler.replacements.nodes.BitCountNode;
<span class="line-added">+ import org.graalvm.compiler.replacements.nodes.FusedMultiplyAddNode;</span>
  import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
  import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation;
<span class="line-added">+ import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
  
  import jdk.vm.ci.amd64.AMD64;
  import jdk.vm.ci.amd64.AMD64.CPUFeature;
<span class="line-added">+ import jdk.vm.ci.code.Architecture;</span>
  import jdk.vm.ci.meta.JavaKind;
  import jdk.vm.ci.meta.ResolvedJavaMethod;
  import sun.misc.Unsafe;
  
<span class="line-modified">! public class AMD64GraphBuilderPlugins implements TargetGraphBuilderPlugins {</span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void register(Plugins plugins, Replacements replacements, Architecture architecture, boolean explicitUnsafeNullChecks,</span>
<span class="line-added">+                     boolean registerMathPlugins, boolean emitJDK9StringSubstitutions, boolean useFMAIntrinsics) {</span>
<span class="line-added">+         register(plugins, replacements, (AMD64) architecture, explicitUnsafeNullChecks, emitJDK9StringSubstitutions, useFMAIntrinsics);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     public static void register(Plugins plugins, Replacements replacements, AMD64 arch, boolean explicitUnsafeNullChecks,</span>
<span class="line-added">+                     boolean emitJDK9StringSubstitutions,</span>
<span class="line-added">+                     boolean useFMAIntrinsics) {</span>
          InvocationPlugins invocationPlugins = plugins.getInvocationPlugins();
          invocationPlugins.defer(new Runnable() {
              @Override
              public void run() {
                  registerThreadPlugins(invocationPlugins, arch);
<span class="line-modified">!                 registerIntegerLongPlugins(invocationPlugins, AMD64IntegerSubstitutions.class, JavaKind.Int, arch, replacements);</span>
<span class="line-modified">!                 registerIntegerLongPlugins(invocationPlugins, AMD64LongSubstitutions.class, JavaKind.Long, arch, replacements);</span>
<span class="line-modified">!                 registerPlatformSpecificUnsafePlugins(invocationPlugins, replacements, explicitUnsafeNullChecks,</span>
                                  new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object, JavaKind.Boolean, JavaKind.Byte, JavaKind.Short, JavaKind.Char, JavaKind.Float, JavaKind.Double});
<span class="line-modified">!                 registerUnsafePlugins(invocationPlugins, replacements, explicitUnsafeNullChecks);</span>
<span class="line-modified">!                 registerStringPlugins(invocationPlugins, replacements);</span>
<span class="line-modified">!                 if (emitJDK9StringSubstitutions) {</span>
<span class="line-modified">!                     registerStringLatin1Plugins(invocationPlugins, replacements);</span>
<span class="line-modified">!                     registerStringUTF16Plugins(invocationPlugins, replacements);</span>
<span class="line-modified">!                 }</span>
<span class="line-added">+                 registerMathPlugins(invocationPlugins, useFMAIntrinsics, arch, replacements);</span>
<span class="line-added">+                 registerArraysEqualsPlugins(invocationPlugins, replacements);</span>
              }
          });
      }
  
      private static void registerThreadPlugins(InvocationPlugins plugins, AMD64 arch) {
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
              // Pause instruction introduced with SSE2
<span class="line-modified">!             assert (arch.getFeatures().contains(AMD64.CPUFeature.SSE2));</span>
<span class="line-modified">!             Registration r = new Registration(plugins, Thread.class);</span>
<span class="line-modified">!             r.register0(&quot;onSpinWait&quot;, new InvocationPlugin() {</span>
                  @Override
<span class="line-modified">!                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {</span>
<span class="line-modified">!                     b.append(new PauseNode());</span>
                      return true;
                  }
              });
          }
<span class="line-added">+     }</span>
  
<span class="line-modified">!     private static void registerIntegerLongPlugins(InvocationPlugins plugins, Class&lt;?&gt; substituteDeclaringClass, JavaKind kind, AMD64 arch, Replacements replacements) {</span>
<span class="line-modified">!         Class&lt;?&gt; declaringClass = kind.toBoxedJavaClass();</span>
<span class="line-modified">!         Class&lt;?&gt; type = kind.toJavaClass();</span>
<span class="line-modified">!         Registration r = new Registration(plugins, declaringClass, replacements);</span>
<span class="line-modified">!         r.registerMethodSubstitution(substituteDeclaringClass, &quot;numberOfLeadingZeros&quot;, type);</span>
<span class="line-modified">!         r.registerMethodSubstitution(substituteDeclaringClass, &quot;numberOfTrailingZeros&quot;, type);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         r.registerConditional1(arch.getFeatures().contains(AMD64.CPUFeature.POPCNT),</span>
<span class="line-modified">!                         &quot;bitCount&quot;, type, new InvocationPlugin() {</span>
<span class="line-added">+                             @Override</span>
<span class="line-added">+                             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {</span>
<span class="line-added">+                                 b.push(JavaKind.Int, b.append(new BitCountNode(value).canonical(null)));</span>
<span class="line-added">+                                 return true;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         });</span>
      }
  
<span class="line-modified">!     private static void registerMathPlugins(InvocationPlugins plugins, boolean useFMAIntrinsics, AMD64 arch, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Math.class, replacements);</span>
          registerUnaryMath(r, &quot;log&quot;, LOG);
          registerUnaryMath(r, &quot;log10&quot;, LOG10);
          registerUnaryMath(r, &quot;exp&quot;, EXP);
          registerBinaryMath(r, &quot;pow&quot;, POW);
          registerUnaryMath(r, &quot;sin&quot;, SIN);
          registerUnaryMath(r, &quot;cos&quot;, COS);
          registerUnaryMath(r, &quot;tan&quot;, TAN);
  
<span class="line-modified">!         boolean roundEnabled = arch.getFeatures().contains(CPUFeature.SSE4_1);</span>
<span class="line-modified">!         registerRound(roundEnabled, r, &quot;rint&quot;, RoundingMode.NEAREST);</span>
<span class="line-modified">!         registerRound(roundEnabled, r, &quot;ceil&quot;, RoundingMode.UP);</span>
<span class="line-modified">!         registerRound(roundEnabled, r, &quot;floor&quot;, RoundingMode.DOWN);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-added">+             registerFMA(r, useFMAIntrinsics &amp;&amp; arch.getFeatures().contains(CPUFeature.FMA));</span>
          }
      }
  
<span class="line-added">+     private static void registerFMA(Registration r, boolean isEnabled) {</span>
<span class="line-added">+         r.registerConditional3(isEnabled, &quot;fma&quot;,</span>
<span class="line-added">+                         Double.TYPE,</span>
<span class="line-added">+                         Double.TYPE,</span>
<span class="line-added">+                         Double.TYPE,</span>
<span class="line-added">+                         new InvocationPlugin() {</span>
<span class="line-added">+                             @Override</span>
<span class="line-added">+                             public boolean apply(GraphBuilderContext b,</span>
<span class="line-added">+                                             ResolvedJavaMethod targetMethod,</span>
<span class="line-added">+                                             Receiver receiver,</span>
<span class="line-added">+                                             ValueNode na,</span>
<span class="line-added">+                                             ValueNode nb,</span>
<span class="line-added">+                                             ValueNode nc) {</span>
<span class="line-added">+                                 b.push(JavaKind.Double, b.append(new FusedMultiplyAddNode(na, nb, nc)));</span>
<span class="line-added">+                                 return true;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         });</span>
<span class="line-added">+         r.registerConditional3(isEnabled, &quot;fma&quot;,</span>
<span class="line-added">+                         Float.TYPE,</span>
<span class="line-added">+                         Float.TYPE,</span>
<span class="line-added">+                         Float.TYPE,</span>
<span class="line-added">+                         new InvocationPlugin() {</span>
<span class="line-added">+                             @Override</span>
<span class="line-added">+                             public boolean apply(GraphBuilderContext b,</span>
<span class="line-added">+                                             ResolvedJavaMethod targetMethod,</span>
<span class="line-added">+                                             Receiver receiver,</span>
<span class="line-added">+                                             ValueNode na,</span>
<span class="line-added">+                                             ValueNode nb,</span>
<span class="line-added">+                                             ValueNode nc) {</span>
<span class="line-added">+                                 b.push(JavaKind.Float, b.append(new FusedMultiplyAddNode(na, nb, nc)));</span>
<span class="line-added">+                                 return true;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         });</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private static void registerUnaryMath(Registration r, String name, UnaryOperation operation) {
          r.register1(name, Double.TYPE, new InvocationPlugin() {
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
                  b.push(JavaKind.Double, b.append(UnaryMathIntrinsicNode.create(value, operation)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,64 ***</span>
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerRound(Registration r, String name, RoundingMode mode) {</span>
<span class="line-modified">!         r.register1(name, Double.TYPE, new InvocationPlugin() {</span>
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg) {
                  b.push(JavaKind.Double, b.append(new AMD64RoundNode(arg, mode)));
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerStringPlugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider) {</span>
<span class="line-modified">!         if (Java8OrEarlier) {</span>
              Registration r;
<span class="line-modified">!             r = new Registration(plugins, String.class, replacementsBytecodeProvider);</span>
              r.setAllowOverwrite(true);
              r.registerMethodSubstitution(AMD64StringSubstitutions.class, &quot;indexOf&quot;, char[].class, int.class,
                              int.class, char[].class, int.class, int.class, int.class);
              r.registerMethodSubstitution(AMD64StringSubstitutions.class, &quot;indexOf&quot;, Receiver.class, int.class, int.class);
              r.registerMethodSubstitution(AMD64StringSubstitutions.class, &quot;compareTo&quot;, Receiver.class, String.class);
          }
      }
  
<span class="line-modified">!     private static void registerStringLatin1Plugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider) {</span>
<span class="line-modified">!         if (JAVA_SPECIFICATION_VERSION &gt;= 9) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacementsBytecodeProvider);</span>
<span class="line-modified">!             r.setAllowOverwrite(true);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;compareToUTF16&quot;, byte[].class, byte[].class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;inflate&quot;, byte[].class, int.class, char[].class, int.class, int.class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;inflate&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;indexOf&quot;, byte[].class, int.class, int.class);</span>
<span class="line-removed">-             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     private static void registerStringUTF16Plugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider) {</span>
<span class="line-modified">!         if (JAVA_SPECIFICATION_VERSION &gt;= 9) {</span>
<span class="line-modified">!             Registration r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacementsBytecodeProvider);</span>
<span class="line-modified">!             r.setAllowOverwrite(true);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compareToLatin1&quot;, byte[].class, byte[].class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compress&quot;, char[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compress&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;indexOfCharUnsafe&quot;, byte[].class, int.class, int.class, int.class);</span>
<span class="line-modified">!             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-removed">-             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;indexOfLatin1Unsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     private static void registerUnsafePlugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider, boolean explicitUnsafeNullChecks) {</span>
          registerUnsafePlugins(new Registration(plugins, Unsafe.class), explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
<span class="line-modified">!         if (!Java8OrEarlier) {</span>
<span class="line-modified">!             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacementsBytecodeProvider), explicitUnsafeNullChecks,</span>
<span class="line-modified">!                             new JavaKind[]{JavaKind.Boolean, JavaKind.Byte, JavaKind.Char, JavaKind.Short, JavaKind.Int, JavaKind.Long, JavaKind.Object}, Java11OrEarlier);</span>
          }
      }
  
      private static void registerUnsafePlugins(Registration r, boolean explicitUnsafeNullChecks, JavaKind[] unsafeJavaKinds, boolean java11OrEarlier) {
          for (JavaKind kind : unsafeJavaKinds) {
<span class="line-new-header">--- 204,61 ---</span>
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerRound(boolean isEnabled, Registration r, String name, RoundingMode mode) {</span>
<span class="line-modified">!         r.registerConditional1(isEnabled, name, Double.TYPE, new InvocationPlugin() {</span>
              @Override
              public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg) {
                  b.push(JavaKind.Double, b.append(new AMD64RoundNode(arg, mode)));
                  return true;
              }
          });
      }
  
<span class="line-modified">!     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {</span>
              Registration r;
<span class="line-modified">!             r = new Registration(plugins, String.class, replacements);</span>
              r.setAllowOverwrite(true);
              r.registerMethodSubstitution(AMD64StringSubstitutions.class, &quot;indexOf&quot;, char[].class, int.class,
                              int.class, char[].class, int.class, int.class, int.class);
              r.registerMethodSubstitution(AMD64StringSubstitutions.class, &quot;indexOf&quot;, Receiver.class, int.class, int.class);
              r.registerMethodSubstitution(AMD64StringSubstitutions.class, &quot;compareTo&quot;, Receiver.class, String.class);
          }
      }
  
<span class="line-modified">!     private static void registerStringLatin1Plugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacements);</span>
<span class="line-modified">!         r.setAllowOverwrite(true);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;compareToUTF16&quot;, byte[].class, byte[].class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;inflate&quot;, byte[].class, int.class, char[].class, int.class, int.class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;inflate&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;indexOf&quot;, byte[].class, int.class, int.class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
      }
  
<span class="line-modified">!     private static void registerStringUTF16Plugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);</span>
<span class="line-modified">!         r.setAllowOverwrite(true);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compareToLatin1&quot;, byte[].class, byte[].class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compress&quot;, char[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compress&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;indexOfCharUnsafe&quot;, byte[].class, int.class, int.class, int.class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
<span class="line-modified">!         r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;indexOfLatin1Unsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class);</span>
      }
  
<span class="line-modified">!     private static void registerUnsafePlugins(InvocationPlugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks) {</span>
          registerUnsafePlugins(new Registration(plugins, Unsafe.class), explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
<span class="line-modified">!         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {</span>
<span class="line-modified">!             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements), explicitUnsafeNullChecks,</span>
<span class="line-modified">!                             new JavaKind[]{JavaKind.Boolean, JavaKind.Byte, JavaKind.Char, JavaKind.Short, JavaKind.Int, JavaKind.Long, JavaKind.Object},</span>
<span class="line-added">+                             JavaVersionUtil.JAVA_SPEC &lt;= 11);</span>
          }
      }
  
      private static void registerUnsafePlugins(Registration r, boolean explicitUnsafeNullChecks, JavaKind[] unsafeJavaKinds, boolean java11OrEarlier) {
          for (JavaKind kind : unsafeJavaKinds) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,11 ***</span>
              r.registerOptional3(&quot;get&quot; + kind.name() + &quot;Unaligned&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
              r.registerOptional4(&quot;put&quot; + kind.name() + &quot;Unaligned&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
          }
      }
  
<span class="line-modified">!     private static void registerArraysEqualsPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Arrays.class, bytecodeProvider);</span>
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, float[].class, float[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, double[].class, double[].class);
      }
  }
<span class="line-new-header">--- 291,11 ---</span>
              r.registerOptional3(&quot;get&quot; + kind.name() + &quot;Unaligned&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
              r.registerOptional4(&quot;put&quot; + kind.name() + &quot;Unaligned&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
          }
      }
  
<span class="line-modified">!     private static void registerArraysEqualsPlugins(InvocationPlugins plugins, Replacements replacements) {</span>
<span class="line-modified">!         Registration r = new Registration(plugins, Arrays.class, replacements);</span>
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, float[].class, float[].class);
          r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, double[].class, double[].class);
      }
  }
</pre>
<center><a href="AMD64FloatConvertNode.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64StringLatin1InflateNode.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
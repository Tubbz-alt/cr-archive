<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64StringSubstitutions.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.amd64;
 26 
 27 import org.graalvm.compiler.api.replacements.ClassSubstitution;
 28 import org.graalvm.compiler.api.replacements.Fold;
 29 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
 30 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 31 import org.graalvm.compiler.core.common.SuppressFBWarnings;
 32 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 33 import org.graalvm.compiler.replacements.StringSubstitutions;
 34 import org.graalvm.compiler.replacements.nodes.ArrayCompareToNode;
 35 import org.graalvm.compiler.replacements.nodes.ArrayRegionEqualsNode;
 36 import org.graalvm.compiler.word.Word;
 37 import jdk.internal.vm.compiler.word.Pointer;
 38 
 39 import jdk.vm.ci.meta.JavaKind;
 40 import jdk.vm.ci.meta.MetaAccessProvider;
 41 
 42 // JaCoCo Exclude
 43 
 44 /**
 45  * Substitutions for {@link java.lang.String} methods.
 46  */
 47 @ClassSubstitution(String.class)
 48 public class AMD64StringSubstitutions {
 49 
 50     @Fold
 51     static int charArrayBaseOffset(@InjectedParameter MetaAccessProvider metaAccess) {
 52         return metaAccess.getArrayBaseOffset(JavaKind.Char);
 53     }
 54 
 55     @Fold
 56     static int charArrayIndexScale(@InjectedParameter MetaAccessProvider metaAccess) {
 57         return metaAccess.getArrayIndexScale(JavaKind.Char);
 58     }
 59 
 60     /** Marker value for the {@link InjectedParameter} injected parameter. */
 61     static final MetaAccessProvider INJECTED = null;
 62 
 63     // Only exists in JDK &lt;= 8
 64     @MethodSubstitution(isStatic = true, optional = true)
 65     public static int indexOf(char[] source, int sourceOffset, int sourceCount,
 66                     @ConstantNodeParameter char[] target, int targetOffset, int targetCount,
 67                     int origFromIndex) {
 68         int fromIndex = origFromIndex;
 69         if (fromIndex &gt;= sourceCount) {
 70             return (targetCount == 0 ? sourceCount : -1);
 71         }
 72         if (fromIndex &lt; 0) {
 73             fromIndex = 0;
 74         }
 75         if (targetCount == 0) {
 76             // The empty string is in every string.
 77             return fromIndex;
 78         }
 79 
 80         int totalOffset = sourceOffset + fromIndex;
 81         if (sourceCount - fromIndex &lt; targetCount) {
 82             // The empty string contains nothing except the empty string.
 83             return -1;
 84         }
 85 
 86         if (targetCount == 1) {
 87             Pointer sourcePointer = Word.objectToTrackedPointer(source).add(charArrayBaseOffset(INJECTED)).add(totalOffset * charArrayIndexScale(INJECTED));
 88             int indexOfResult = AMD64ArrayIndexOf.indexOf1Char(sourcePointer, sourceCount - fromIndex, target[targetOffset]);
 89             if (indexOfResult &gt;= 0) {
 90                 return indexOfResult + totalOffset;
 91             }
 92             return indexOfResult;
 93         } else if (targetCount == 2) {
 94             Pointer sourcePointer = Word.objectToTrackedPointer(source).add(charArrayBaseOffset(INJECTED)).add(totalOffset * charArrayIndexScale(INJECTED));
 95             int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(sourcePointer, sourceCount - fromIndex, target[targetOffset], target[targetOffset + 1]);
 96             if (indexOfResult &gt;= 0) {
 97                 return indexOfResult + totalOffset;
 98             }
 99             return indexOfResult;
100         } else {
101             int haystackLength = sourceCount - (fromIndex + (targetCount - 2));
102             while (haystackLength &gt; 0) {
103                 Pointer sourcePointer = Word.objectToTrackedPointer(source).add(charArrayBaseOffset(INJECTED)).add(totalOffset * charArrayIndexScale(INJECTED));
104                 int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(sourcePointer, haystackLength, target[targetOffset], target[targetOffset + 1]);
105                 if (indexOfResult &lt; 0) {
106                     return -1;
107                 }
108                 totalOffset += indexOfResult;
109                 haystackLength -= (indexOfResult + 1);
110                 Pointer cmpSourcePointer = Word.objectToTrackedPointer(source).add(charArrayBaseOffset(INJECTED)).add(totalOffset * charArrayIndexScale(INJECTED));
111                 Pointer targetPointer = Word.objectToTrackedPointer(target).add(charArrayBaseOffset(INJECTED)).add(targetOffset * charArrayIndexScale(INJECTED));
112                 if (ArrayRegionEqualsNode.regionEquals(cmpSourcePointer, targetPointer, targetCount, JavaKind.Char)) {
113                     return totalOffset;
114                 }
115                 totalOffset++;
116             }
117             return -1;
118         }
119     }
120 
121     // Only exists in JDK &lt;= 8
122     @MethodSubstitution(isStatic = false, optional = true)
123     public static int indexOf(String source, int ch, int origFromIndex) {
124         int fromIndex = origFromIndex;
125         final int sourceCount = source.length();
126         if (fromIndex &gt;= sourceCount) {
127             // Note: fromIndex might be near -1&gt;&gt;&gt;1.
128             return -1;
129         }
130         if (fromIndex &lt; 0) {
131             fromIndex = 0;
132         }
133 
134         if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) {
135             char[] sourceArray = StringSubstitutions.getValue(source);
136 
137             Pointer sourcePointer = Word.objectToTrackedPointer(sourceArray).add(charArrayBaseOffset(INJECTED)).add(fromIndex * charArrayIndexScale(INJECTED));
138             int result = AMD64ArrayIndexOf.indexOf1Char(sourcePointer, sourceCount - fromIndex, (char) ch);
139             if (result != -1) {
140                 return result + fromIndex;
141             }
142             return result;
143         } else {
144             return indexOf(source, ch, origFromIndex);
145         }
146     }
147 
148     @MethodSubstitution(isStatic = false)
149     @SuppressFBWarnings(value = &quot;ES_COMPARING_PARAMETER_STRING_WITH_EQ&quot;, justification = &quot;reference equality on the receiver is what we want&quot;)
150     public static int compareTo(String receiver, String anotherString) {
151         if (receiver == anotherString) {
152             return 0;
153         }
154         char[] value = StringSubstitutions.getValue(receiver);
155         char[] other = StringSubstitutions.getValue(anotherString);
156         return ArrayCompareToNode.compareTo(value, other, value.length &lt;&lt; 1, other.length &lt;&lt; 1, JavaKind.Char, JavaKind.Char);
157     }
158 
159 }
    </pre>
  </body>
</html>
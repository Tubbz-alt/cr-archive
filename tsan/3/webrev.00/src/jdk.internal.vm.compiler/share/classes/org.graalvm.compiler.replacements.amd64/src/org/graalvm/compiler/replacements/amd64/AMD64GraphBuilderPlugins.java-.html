<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64GraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.replacements.amd64;
 26 
 27 import static org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.registerPlatformSpecificUnsafePlugins;
 28 import static org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode.BinaryOperation.POW;
 29 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.COS;
 30 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.EXP;
 31 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG;
 32 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.LOG10;
 33 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.SIN;
 34 import static org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation.TAN;
 35 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.JAVA_SPECIFICATION_VERSION;
 36 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java11OrEarlier;
 37 import static org.graalvm.compiler.serviceprovider.JavaVersionUtil.Java8OrEarlier;
 38 
 39 import java.util.Arrays;
 40 
 41 import org.graalvm.compiler.bytecode.BytecodeProvider;
 42 import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool.RoundingMode;
 43 import org.graalvm.compiler.nodes.PauseNode;
 44 import org.graalvm.compiler.nodes.ValueNode;
 45 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 46 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 47 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 48 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 49 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 50 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 51 import org.graalvm.compiler.nodes.java.AtomicReadAndAddNode;
 52 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 53 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 54 import org.graalvm.compiler.replacements.ArraysSubstitutions;
 55 import org.graalvm.compiler.replacements.IntegerSubstitutions;
 56 import org.graalvm.compiler.replacements.LongSubstitutions;
 57 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.UnsafeAccessPlugin;
 58 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.UnsafeGetPlugin;
 59 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins.UnsafePutPlugin;
 60 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
 61 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode.BinaryOperation;
 62 import org.graalvm.compiler.replacements.nodes.BitCountNode;
 63 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
 64 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode.UnaryOperation;
 65 
 66 import jdk.vm.ci.amd64.AMD64;
 67 import jdk.vm.ci.amd64.AMD64.CPUFeature;
 68 import jdk.vm.ci.meta.JavaKind;
 69 import jdk.vm.ci.meta.ResolvedJavaMethod;
 70 import sun.misc.Unsafe;
 71 
 72 public class AMD64GraphBuilderPlugins {
 73 
 74     public static void register(Plugins plugins, BytecodeProvider replacementsBytecodeProvider, AMD64 arch, boolean explicitUnsafeNullChecks) {
 75         InvocationPlugins invocationPlugins = plugins.getInvocationPlugins();
 76         invocationPlugins.defer(new Runnable() {
 77             @Override
 78             public void run() {
 79                 registerThreadPlugins(invocationPlugins, arch);
 80                 registerIntegerLongPlugins(invocationPlugins, IntegerSubstitutions.class, JavaKind.Int, arch, replacementsBytecodeProvider);
 81                 registerIntegerLongPlugins(invocationPlugins, LongSubstitutions.class, JavaKind.Long, arch, replacementsBytecodeProvider);
 82                 registerPlatformSpecificUnsafePlugins(invocationPlugins, replacementsBytecodeProvider, explicitUnsafeNullChecks,
 83                                 new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object, JavaKind.Boolean, JavaKind.Byte, JavaKind.Short, JavaKind.Char, JavaKind.Float, JavaKind.Double});
 84                 registerUnsafePlugins(invocationPlugins, replacementsBytecodeProvider, explicitUnsafeNullChecks);
 85                 registerStringPlugins(invocationPlugins, replacementsBytecodeProvider);
 86                 registerStringLatin1Plugins(invocationPlugins, replacementsBytecodeProvider);
 87                 registerStringUTF16Plugins(invocationPlugins, replacementsBytecodeProvider);
 88                 registerMathPlugins(invocationPlugins, arch, replacementsBytecodeProvider);
 89                 registerArraysEqualsPlugins(invocationPlugins, replacementsBytecodeProvider);
 90             }
 91         });
 92     }
 93 
 94     private static void registerThreadPlugins(InvocationPlugins plugins, AMD64 arch) {
 95         if (!Java8OrEarlier) {
 96             // Pause instruction introduced with SSE2
 97             if (arch.getFeatures().contains(AMD64.CPUFeature.SSE2)) {
 98                 Registration r = new Registration(plugins, Thread.class);
 99                 r.register0(&quot;onSpinWait&quot;, new InvocationPlugin() {
100                     @Override
101                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
102                         b.append(new PauseNode());
103                         return true;
104                     }
105                 });
106             }
107         }
108     }
109 
110     private static void registerIntegerLongPlugins(InvocationPlugins plugins, Class&lt;?&gt; substituteDeclaringClass, JavaKind kind, AMD64 arch, BytecodeProvider bytecodeProvider) {
111         Class&lt;?&gt; declaringClass = kind.toBoxedJavaClass();
112         Class&lt;?&gt; type = kind.toJavaClass();
113         Registration r = new Registration(plugins, declaringClass, bytecodeProvider);
114         if (arch.getFeatures().contains(AMD64.CPUFeature.LZCNT) &amp;&amp; arch.getFlags().contains(AMD64.Flag.UseCountLeadingZerosInstruction)) {
115             r.register1(&quot;numberOfLeadingZeros&quot;, type, new InvocationPlugin() {
116                 @Override
117                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
118                     ValueNode folded = AMD64CountLeadingZerosNode.tryFold(value);
119                     if (folded != null) {
120                         b.addPush(JavaKind.Int, folded);
121                     } else {
122                         b.addPush(JavaKind.Int, new AMD64CountLeadingZerosNode(value));
123                     }
124                     return true;
125                 }
126             });
127         } else {
128             r.registerMethodSubstitution(substituteDeclaringClass, &quot;numberOfLeadingZeros&quot;, type);
129         }
130         if (arch.getFeatures().contains(AMD64.CPUFeature.BMI1) &amp;&amp; arch.getFlags().contains(AMD64.Flag.UseCountTrailingZerosInstruction)) {
131             r.register1(&quot;numberOfTrailingZeros&quot;, type, new InvocationPlugin() {
132                 @Override
133                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
134                     ValueNode folded = AMD64CountTrailingZerosNode.tryFold(value);
135                     if (folded != null) {
136                         b.addPush(JavaKind.Int, folded);
137                     } else {
138                         b.addPush(JavaKind.Int, new AMD64CountTrailingZerosNode(value));
139                     }
140                     return true;
141                 }
142             });
143         } else {
144             r.registerMethodSubstitution(substituteDeclaringClass, &quot;numberOfTrailingZeros&quot;, type);
145         }
146 
147         if (arch.getFeatures().contains(AMD64.CPUFeature.POPCNT)) {
148             r.register1(&quot;bitCount&quot;, type, new InvocationPlugin() {
149                 @Override
150                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
151                     b.push(JavaKind.Int, b.append(new BitCountNode(value).canonical(null)));
152                     return true;
153                 }
154             });
155         }
156     }
157 
158     private static void registerMathPlugins(InvocationPlugins plugins, AMD64 arch, BytecodeProvider bytecodeProvider) {
159         Registration r = new Registration(plugins, Math.class, bytecodeProvider);
160         registerUnaryMath(r, &quot;log&quot;, LOG);
161         registerUnaryMath(r, &quot;log10&quot;, LOG10);
162         registerUnaryMath(r, &quot;exp&quot;, EXP);
163         registerBinaryMath(r, &quot;pow&quot;, POW);
164         registerUnaryMath(r, &quot;sin&quot;, SIN);
165         registerUnaryMath(r, &quot;cos&quot;, COS);
166         registerUnaryMath(r, &quot;tan&quot;, TAN);
167 
168         if (arch.getFeatures().contains(CPUFeature.SSE4_1)) {
169             registerRound(r, &quot;rint&quot;, RoundingMode.NEAREST);
170             registerRound(r, &quot;ceil&quot;, RoundingMode.UP);
171             registerRound(r, &quot;floor&quot;, RoundingMode.DOWN);
172         }
173     }
174 
175     private static void registerUnaryMath(Registration r, String name, UnaryOperation operation) {
176         r.register1(name, Double.TYPE, new InvocationPlugin() {
177             @Override
178             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
179                 b.push(JavaKind.Double, b.append(UnaryMathIntrinsicNode.create(value, operation)));
180                 return true;
181             }
182         });
183     }
184 
185     private static void registerBinaryMath(Registration r, String name, BinaryOperation operation) {
186         r.register2(name, Double.TYPE, Double.TYPE, new InvocationPlugin() {
187             @Override
188             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
189                 b.push(JavaKind.Double, b.append(BinaryMathIntrinsicNode.create(x, y, operation)));
190                 return true;
191             }
192         });
193     }
194 
195     private static void registerRound(Registration r, String name, RoundingMode mode) {
196         r.register1(name, Double.TYPE, new InvocationPlugin() {
197             @Override
198             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg) {
199                 b.push(JavaKind.Double, b.append(new AMD64RoundNode(arg, mode)));
200                 return true;
201             }
202         });
203     }
204 
205     private static void registerStringPlugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider) {
206         if (Java8OrEarlier) {
207             Registration r;
208             r = new Registration(plugins, String.class, replacementsBytecodeProvider);
209             r.setAllowOverwrite(true);
210             r.registerMethodSubstitution(AMD64StringSubstitutions.class, &quot;indexOf&quot;, char[].class, int.class,
211                             int.class, char[].class, int.class, int.class, int.class);
212             r.registerMethodSubstitution(AMD64StringSubstitutions.class, &quot;indexOf&quot;, Receiver.class, int.class, int.class);
213             r.registerMethodSubstitution(AMD64StringSubstitutions.class, &quot;compareTo&quot;, Receiver.class, String.class);
214         }
215     }
216 
217     private static void registerStringLatin1Plugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider) {
218         if (JAVA_SPECIFICATION_VERSION &gt;= 9) {
219             Registration r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacementsBytecodeProvider);
220             r.setAllowOverwrite(true);
221             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);
222             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;compareToUTF16&quot;, byte[].class, byte[].class);
223             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;inflate&quot;, byte[].class, int.class, char[].class, int.class, int.class);
224             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;inflate&quot;, byte[].class, int.class, byte[].class, int.class, int.class);
225             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;indexOf&quot;, byte[].class, int.class, int.class);
226             r.registerMethodSubstitution(AMD64StringLatin1Substitutions.class, &quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class);
227         }
228     }
229 
230     private static void registerStringUTF16Plugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider) {
231         if (JAVA_SPECIFICATION_VERSION &gt;= 9) {
232             Registration r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacementsBytecodeProvider);
233             r.setAllowOverwrite(true);
234             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compareTo&quot;, byte[].class, byte[].class);
235             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compareToLatin1&quot;, byte[].class, byte[].class);
236             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compress&quot;, char[].class, int.class, byte[].class, int.class, int.class);
237             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;compress&quot;, byte[].class, int.class, byte[].class, int.class, int.class);
238             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;indexOfCharUnsafe&quot;, byte[].class, int.class, int.class, int.class);
239             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class);
240             r.registerMethodSubstitution(AMD64StringUTF16Substitutions.class, &quot;indexOfLatin1Unsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class);
241         }
242     }
243 
244     private static void registerUnsafePlugins(InvocationPlugins plugins, BytecodeProvider replacementsBytecodeProvider, boolean explicitUnsafeNullChecks) {
245         registerUnsafePlugins(new Registration(plugins, Unsafe.class), explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
246         if (!Java8OrEarlier) {
247             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacementsBytecodeProvider), explicitUnsafeNullChecks,
248                             new JavaKind[]{JavaKind.Boolean, JavaKind.Byte, JavaKind.Char, JavaKind.Short, JavaKind.Int, JavaKind.Long, JavaKind.Object}, Java11OrEarlier);
249         }
250     }
251 
252     private static void registerUnsafePlugins(Registration r, boolean explicitUnsafeNullChecks, JavaKind[] unsafeJavaKinds, boolean java11OrEarlier) {
253         for (JavaKind kind : unsafeJavaKinds) {
254             Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
255             String kindName = (kind == JavaKind.Object &amp;&amp; !java11OrEarlier) ? &quot;Reference&quot; : kind.name();
256             r.register4(&quot;getAndSet&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new UnsafeAccessPlugin(kind, explicitUnsafeNullChecks) {
257                 @Override
258                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {
259                     // Emits a null-check for the otherwise unused receiver
260                     unsafe.get();
261                     createUnsafeAccess(object, b, (obj, loc) -&gt; new AtomicReadAndWriteNode(obj, offset, value, kind, loc));
262                     return true;
263                 }
264             });
265             if (kind != JavaKind.Boolean &amp;&amp; kind.isNumericInteger()) {
266                 r.register4(&quot;getAndAdd&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new UnsafeAccessPlugin(kind, explicitUnsafeNullChecks) {
267                     @Override
268                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode delta) {
269                         // Emits a null-check for the otherwise unused receiver
270                         unsafe.get();
271                         createUnsafeAccess(object, b, (obj, loc) -&gt; new AtomicReadAndAddNode(b.add(new OffsetAddressNode(obj, offset)), delta, kind, loc));
272                         return true;
273                     }
274                 });
275             }
276         }
277 
278         for (JavaKind kind : new JavaKind[]{JavaKind.Char, JavaKind.Short, JavaKind.Int, JavaKind.Long}) {
279             Class&lt;?&gt; javaClass = kind.toJavaClass();
280             r.registerOptional3(&quot;get&quot; + kind.name() + &quot;Unaligned&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
281             r.registerOptional4(&quot;put&quot; + kind.name() + &quot;Unaligned&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
282         }
283     }
284 
285     private static void registerArraysEqualsPlugins(InvocationPlugins plugins, BytecodeProvider bytecodeProvider) {
286         Registration r = new Registration(plugins, Arrays.class, bytecodeProvider);
287         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, float[].class, float[].class);
288         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, double[].class, double[].class);
289     }
290 }
    </pre>
  </body>
</html>
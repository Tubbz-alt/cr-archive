<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64StringSubstitutions.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64StringLatin1Substitutions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64StringUTF16CompressNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64StringSubstitutions.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 67                     int origFromIndex) {
 68         int fromIndex = origFromIndex;
 69         if (fromIndex &gt;= sourceCount) {
 70             return (targetCount == 0 ? sourceCount : -1);
 71         }
 72         if (fromIndex &lt; 0) {
 73             fromIndex = 0;
 74         }
 75         if (targetCount == 0) {
 76             // The empty string is in every string.
 77             return fromIndex;
 78         }
 79 
 80         int totalOffset = sourceOffset + fromIndex;
 81         if (sourceCount - fromIndex &lt; targetCount) {
 82             // The empty string contains nothing except the empty string.
 83             return -1;
 84         }
 85 
 86         if (targetCount == 1) {
<span class="line-modified"> 87             Pointer sourcePointer = Word.objectToTrackedPointer(source).add(charArrayBaseOffset(INJECTED)).add(totalOffset * charArrayIndexScale(INJECTED));</span>
<span class="line-removed"> 88             int indexOfResult = AMD64ArrayIndexOf.indexOf1Char(sourcePointer, sourceCount - fromIndex, target[targetOffset]);</span>
<span class="line-removed"> 89             if (indexOfResult &gt;= 0) {</span>
<span class="line-removed"> 90                 return indexOfResult + totalOffset;</span>
<span class="line-removed"> 91             }</span>
<span class="line-removed"> 92             return indexOfResult;</span>
<span class="line-removed"> 93         } else if (targetCount == 2) {</span>
<span class="line-removed"> 94             Pointer sourcePointer = Word.objectToTrackedPointer(source).add(charArrayBaseOffset(INJECTED)).add(totalOffset * charArrayIndexScale(INJECTED));</span>
<span class="line-removed"> 95             int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(sourcePointer, sourceCount - fromIndex, target[targetOffset], target[targetOffset + 1]);</span>
<span class="line-removed"> 96             if (indexOfResult &gt;= 0) {</span>
<span class="line-removed"> 97                 return indexOfResult + totalOffset;</span>
<span class="line-removed"> 98             }</span>
<span class="line-removed"> 99             return indexOfResult;</span>
100         } else {
<span class="line-modified">101             int haystackLength = sourceCount - (fromIndex + (targetCount - 2));</span>
<span class="line-modified">102             while (haystackLength &gt; 0) {</span>
<span class="line-modified">103                 Pointer sourcePointer = Word.objectToTrackedPointer(source).add(charArrayBaseOffset(INJECTED)).add(totalOffset * charArrayIndexScale(INJECTED));</span>
<span class="line-removed">104                 int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(sourcePointer, haystackLength, target[targetOffset], target[targetOffset + 1]);</span>
105                 if (indexOfResult &lt; 0) {
106                     return -1;
107                 }
<span class="line-modified">108                 totalOffset += indexOfResult;</span>
<span class="line-modified">109                 haystackLength -= (indexOfResult + 1);</span>
<span class="line-removed">110                 Pointer cmpSourcePointer = Word.objectToTrackedPointer(source).add(charArrayBaseOffset(INJECTED)).add(totalOffset * charArrayIndexScale(INJECTED));</span>
<span class="line-removed">111                 Pointer targetPointer = Word.objectToTrackedPointer(target).add(charArrayBaseOffset(INJECTED)).add(targetOffset * charArrayIndexScale(INJECTED));</span>
<span class="line-removed">112                 if (ArrayRegionEqualsNode.regionEquals(cmpSourcePointer, targetPointer, targetCount, JavaKind.Char)) {</span>
113                     return totalOffset;






114                 }
115                 totalOffset++;
116             }
117             return -1;
118         }
119     }
120 
121     // Only exists in JDK &lt;= 8
122     @MethodSubstitution(isStatic = false, optional = true)
123     public static int indexOf(String source, int ch, int origFromIndex) {
124         int fromIndex = origFromIndex;
125         final int sourceCount = source.length();
126         if (fromIndex &gt;= sourceCount) {
127             // Note: fromIndex might be near -1&gt;&gt;&gt;1.
128             return -1;
129         }
130         if (fromIndex &lt; 0) {
131             fromIndex = 0;
132         }
133 
134         if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) {
135             char[] sourceArray = StringSubstitutions.getValue(source);
<span class="line-modified">136 </span>
<span class="line-removed">137             Pointer sourcePointer = Word.objectToTrackedPointer(sourceArray).add(charArrayBaseOffset(INJECTED)).add(fromIndex * charArrayIndexScale(INJECTED));</span>
<span class="line-removed">138             int result = AMD64ArrayIndexOf.indexOf1Char(sourcePointer, sourceCount - fromIndex, (char) ch);</span>
<span class="line-removed">139             if (result != -1) {</span>
<span class="line-removed">140                 return result + fromIndex;</span>
<span class="line-removed">141             }</span>
<span class="line-removed">142             return result;</span>
143         } else {
144             return indexOf(source, ch, origFromIndex);
145         }
146     }
147 
148     @MethodSubstitution(isStatic = false)
149     @SuppressFBWarnings(value = &quot;ES_COMPARING_PARAMETER_STRING_WITH_EQ&quot;, justification = &quot;reference equality on the receiver is what we want&quot;)
150     public static int compareTo(String receiver, String anotherString) {
151         if (receiver == anotherString) {
152             return 0;
153         }
154         char[] value = StringSubstitutions.getValue(receiver);
155         char[] other = StringSubstitutions.getValue(anotherString);
156         return ArrayCompareToNode.compareTo(value, other, value.length &lt;&lt; 1, other.length &lt;&lt; 1, JavaKind.Char, JavaKind.Char);
157     }
158 
159 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 67                     int origFromIndex) {
 68         int fromIndex = origFromIndex;
 69         if (fromIndex &gt;= sourceCount) {
 70             return (targetCount == 0 ? sourceCount : -1);
 71         }
 72         if (fromIndex &lt; 0) {
 73             fromIndex = 0;
 74         }
 75         if (targetCount == 0) {
 76             // The empty string is in every string.
 77             return fromIndex;
 78         }
 79 
 80         int totalOffset = sourceOffset + fromIndex;
 81         if (sourceCount - fromIndex &lt; targetCount) {
 82             // The empty string contains nothing except the empty string.
 83             return -1;
 84         }
 85 
 86         if (targetCount == 1) {
<span class="line-modified"> 87             return AMD64ArrayIndexOf.indexOf1Char(source, sourceCount, totalOffset, target[targetOffset]);</span>












 88         } else {
<span class="line-modified"> 89             int haystackLength = sourceCount - (targetCount - 2);</span>
<span class="line-modified"> 90             while (totalOffset &lt; haystackLength) {</span>
<span class="line-modified"> 91                 int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(source, haystackLength, totalOffset, target[targetOffset], target[targetOffset + 1]);</span>

 92                 if (indexOfResult &lt; 0) {
 93                     return -1;
 94                 }
<span class="line-modified"> 95                 totalOffset = indexOfResult;</span>
<span class="line-modified"> 96                 if (targetCount == 2) {</span>



 97                     return totalOffset;
<span class="line-added"> 98                 } else {</span>
<span class="line-added"> 99                     Pointer cmpSourcePointer = Word.objectToTrackedPointer(source).add(charArrayBaseOffset(INJECTED)).add(totalOffset * charArrayIndexScale(INJECTED));</span>
<span class="line-added">100                     Pointer targetPointer = Word.objectToTrackedPointer(target).add(charArrayBaseOffset(INJECTED)).add(targetOffset * charArrayIndexScale(INJECTED));</span>
<span class="line-added">101                     if (ArrayRegionEqualsNode.regionEquals(cmpSourcePointer, targetPointer, targetCount, JavaKind.Char)) {</span>
<span class="line-added">102                         return totalOffset;</span>
<span class="line-added">103                     }</span>
104                 }
105                 totalOffset++;
106             }
107             return -1;
108         }
109     }
110 
111     // Only exists in JDK &lt;= 8
112     @MethodSubstitution(isStatic = false, optional = true)
113     public static int indexOf(String source, int ch, int origFromIndex) {
114         int fromIndex = origFromIndex;
115         final int sourceCount = source.length();
116         if (fromIndex &gt;= sourceCount) {
117             // Note: fromIndex might be near -1&gt;&gt;&gt;1.
118             return -1;
119         }
120         if (fromIndex &lt; 0) {
121             fromIndex = 0;
122         }
123 
124         if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) {
125             char[] sourceArray = StringSubstitutions.getValue(source);
<span class="line-modified">126             return AMD64ArrayIndexOf.indexOf1Char(sourceArray, sourceCount, fromIndex, (char) ch);</span>






127         } else {
128             return indexOf(source, ch, origFromIndex);
129         }
130     }
131 
132     @MethodSubstitution(isStatic = false)
133     @SuppressFBWarnings(value = &quot;ES_COMPARING_PARAMETER_STRING_WITH_EQ&quot;, justification = &quot;reference equality on the receiver is what we want&quot;)
134     public static int compareTo(String receiver, String anotherString) {
135         if (receiver == anotherString) {
136             return 0;
137         }
138         char[] value = StringSubstitutions.getValue(receiver);
139         char[] other = StringSubstitutions.getValue(anotherString);
140         return ArrayCompareToNode.compareTo(value, other, value.length &lt;&lt; 1, other.length &lt;&lt; 1, JavaKind.Char, JavaKind.Char);
141     }
142 
143 }
</pre>
</td>
</tr>
</table>
<center><a href="AMD64StringLatin1Substitutions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64StringUTF16CompressNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
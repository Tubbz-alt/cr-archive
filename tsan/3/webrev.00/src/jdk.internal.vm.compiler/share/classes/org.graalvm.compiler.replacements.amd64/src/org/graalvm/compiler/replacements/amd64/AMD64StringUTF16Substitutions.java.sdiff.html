<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64StringUTF16Substitutions.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64StringUTF16CompressNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.replacements.jdk9.test/src/org/graalvm/compiler/replacements/jdk9/test/VarHandleTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements.amd64/src/org/graalvm/compiler/replacements/amd64/AMD64StringUTF16Substitutions.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 86     @MethodSubstitution
 87     public static int compareTo(byte[] value, byte[] other) {
 88         return ArrayCompareToNode.compareTo(value, other, value.length, other.length, JavaKind.Char, JavaKind.Char);
 89     }
 90 
 91     /**
 92      * @param value is char[]
 93      * @param other is byte[]
 94      */
 95     @MethodSubstitution
 96     public static int compareToLatin1(byte[] value, byte[] other) {
 97         /*
 98          * Swapping array arguments because intrinsic expects order to be byte[]/char[] but kind
 99          * arguments stay in original order.
100          */
101         return ArrayCompareToNode.compareTo(other, value, other.length, value.length, JavaKind.Char, JavaKind.Byte);
102     }
103 
104     @MethodSubstitution
105     public static int indexOfCharUnsafe(byte[] value, int ch, int fromIndex, int max) {
<span class="line-modified">106         Pointer sourcePointer = charOffsetPointer(value, fromIndex);</span>
<span class="line-removed">107         int result = AMD64ArrayIndexOf.indexOf1Char(sourcePointer, max - fromIndex, (char) ch);</span>
<span class="line-removed">108         if (result != -1) {</span>
<span class="line-removed">109             return result + fromIndex;</span>
<span class="line-removed">110         }</span>
<span class="line-removed">111         return result;</span>
112     }
113 
114     private static Word pointer(byte[] target) {
115         return Word.objectToTrackedPointer(target).add(byteArrayBaseOffset(INJECTED));
116     }
117 
118     private static Word charOffsetPointer(byte[] value, int offset) {
119         return pointer(value).add(offset * charArrayIndexScale(INJECTED));
120     }
121 
122     @MethodSubstitution
123     public static int indexOfUnsafe(byte[] source, int sourceCount, byte[] target, int targetCount, int fromIndex) {
124         ReplacementsUtil.runtimeAssert(fromIndex &gt;= 0, &quot;StringUTF16.indexOfUnsafe invalid args: fromIndex negative&quot;);
125         ReplacementsUtil.runtimeAssert(targetCount &gt; 0, &quot;StringUTF16.indexOfUnsafe invalid args: targetCount &lt;= 0&quot;);
126         ReplacementsUtil.runtimeAssert(targetCount &lt;= length(target), &quot;StringUTF16.indexOfUnsafe invalid args: targetCount &gt; length(target)&quot;);
127         ReplacementsUtil.runtimeAssert(sourceCount &gt;= targetCount, &quot;StringUTF16.indexOfUnsafe invalid args: sourceCount &lt; targetCount&quot;);
<span class="line-removed">128         int totalOffset = fromIndex;</span>
129         if (targetCount == 1) {
<span class="line-modified">130             Pointer sourcePointer = charOffsetPointer(source, totalOffset);</span>
<span class="line-removed">131             int indexOfResult = AMD64ArrayIndexOf.indexOf1Char(sourcePointer, sourceCount - fromIndex, StringUTF16Substitutions.getChar(target, 0));</span>
<span class="line-removed">132             if (indexOfResult &gt;= 0) {</span>
<span class="line-removed">133                 return indexOfResult + totalOffset;</span>
<span class="line-removed">134             }</span>
<span class="line-removed">135             return indexOfResult;</span>
<span class="line-removed">136         } else if (targetCount == 2) {</span>
<span class="line-removed">137             Pointer sourcePointer = charOffsetPointer(source, totalOffset);</span>
<span class="line-removed">138             int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(sourcePointer, sourceCount - fromIndex, StringUTF16Substitutions.getChar(target, 0),</span>
<span class="line-removed">139                             StringUTF16Substitutions.getChar(target, 1));</span>
<span class="line-removed">140             if (indexOfResult &gt;= 0) {</span>
<span class="line-removed">141                 return indexOfResult + totalOffset;</span>
<span class="line-removed">142             }</span>
<span class="line-removed">143             return indexOfResult;</span>
144         } else {
<span class="line-modified">145             int haystackLength = sourceCount - (fromIndex + (targetCount - 2));</span>
<span class="line-modified">146             while (haystackLength &gt; 0) {</span>
<span class="line-modified">147                 Pointer sourcePointer = charOffsetPointer(source, totalOffset);</span>
<span class="line-modified">148                 int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(sourcePointer, haystackLength, StringUTF16Substitutions.getChar(target, 0),</span>
149                                 StringUTF16Substitutions.getChar(target, 1));
150                 if (indexOfResult &lt; 0) {
151                     return -1;
152                 }
<span class="line-modified">153                 totalOffset += indexOfResult;</span>
<span class="line-modified">154                 haystackLength -= (indexOfResult + 1);</span>
<span class="line-removed">155                 Pointer cmpSourcePointer = charOffsetPointer(source, totalOffset);</span>
156                 Pointer targetPointer = pointer(target);
<span class="line-modified">157                 if (ArrayRegionEqualsNode.regionEquals(cmpSourcePointer, targetPointer, targetCount, JavaKind.Char)) {</span>
<span class="line-modified">158                     return totalOffset;</span>
159                 }
<span class="line-modified">160                 totalOffset++;</span>
161             }
162             return -1;
163         }
164     }
165 
166     @MethodSubstitution
167     public static int indexOfLatin1Unsafe(byte[] source, int sourceCount, byte[] target, int targetCount, int fromIndex) {
168         ReplacementsUtil.runtimeAssert(fromIndex &gt;= 0, &quot;StringUTF16.indexOfLatin1Unsafe invalid args: fromIndex negative&quot;);
169         ReplacementsUtil.runtimeAssert(targetCount &gt; 0, &quot;StringUTF16.indexOfLatin1Unsafe invalid args: targetCount &lt;= 0&quot;);
170         ReplacementsUtil.runtimeAssert(targetCount &lt;= target.length, &quot;StringUTF16.indexOfLatin1Unsafe invalid args: targetCount &gt; length(target)&quot;);
171         ReplacementsUtil.runtimeAssert(sourceCount &gt;= targetCount, &quot;StringUTF16.indexOfLatin1Unsafe invalid args: sourceCount &lt; targetCount&quot;);
<span class="line-removed">172         int totalOffset = fromIndex;</span>
173         if (targetCount == 1) {
<span class="line-modified">174             Pointer sourcePointer = charOffsetPointer(source, totalOffset);</span>
<span class="line-removed">175             int indexOfResult = AMD64ArrayIndexOf.indexOf1Char(sourcePointer, sourceCount - fromIndex, (char) Byte.toUnsignedInt(target[0]));</span>
<span class="line-removed">176             if (indexOfResult &gt;= 0) {</span>
<span class="line-removed">177                 return indexOfResult + totalOffset;</span>
<span class="line-removed">178             }</span>
<span class="line-removed">179             return indexOfResult;</span>
<span class="line-removed">180         } else if (targetCount == 2) {</span>
<span class="line-removed">181             Pointer sourcePointer = charOffsetPointer(source, totalOffset);</span>
<span class="line-removed">182             int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(sourcePointer, sourceCount - fromIndex, (char) Byte.toUnsignedInt(target[0]), (char) Byte.toUnsignedInt(target[1]));</span>
<span class="line-removed">183             if (indexOfResult &gt;= 0) {</span>
<span class="line-removed">184                 return indexOfResult + totalOffset;</span>
<span class="line-removed">185             }</span>
<span class="line-removed">186             return indexOfResult;</span>
187         } else {
<span class="line-modified">188             int haystackLength = sourceCount - (fromIndex + (targetCount - 2));</span>
<span class="line-modified">189             while (haystackLength &gt; 0) {</span>
<span class="line-modified">190                 Pointer sourcePointer = charOffsetPointer(source, totalOffset);</span>
<span class="line-modified">191                 int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(sourcePointer, haystackLength, (char) Byte.toUnsignedInt(target[0]), (char) Byte.toUnsignedInt(target[1]));</span>
192                 if (indexOfResult &lt; 0) {
193                     return -1;
194                 }
<span class="line-modified">195                 totalOffset += indexOfResult;</span>
<span class="line-modified">196                 haystackLength -= (indexOfResult + 1);</span>
<span class="line-removed">197                 Pointer cmpSourcePointer = charOffsetPointer(source, totalOffset);</span>
198                 Pointer targetPointer = pointer(target);
<span class="line-modified">199                 if (ArrayRegionEqualsNode.regionEquals(cmpSourcePointer, targetPointer, targetCount, JavaKind.Char, JavaKind.Byte)) {</span>
<span class="line-modified">200                     return totalOffset;</span>
201                 }
<span class="line-modified">202                 totalOffset++;</span>
203             }
204             return -1;
205         }
206     }
207 
208     /**
209      * Intrinsic for {@code java.lang.StringUTF16.compress([CI[BII)I}.
210      *
211      * &lt;pre&gt;
212      * &amp;#64;HotSpotIntrinsicCandidate
213      * public static int compress(char[] src, int src_indx, byte[] dst, int dst_indx, int len)
214      * &lt;/pre&gt;
215      */
216     @MethodSubstitution
217     public static int compress(char[] src, int srcIndex, byte[] dest, int destIndex, int len) {
<span class="line-modified">218         if (len &lt; 0 || srcIndex &lt; 0 || (srcIndex + len &gt; src.length) || destIndex &lt; 0 || (destIndex + len &gt; dest.length)) {</span>
<span class="line-removed">219             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.BoundsCheckException);</span>
<span class="line-removed">220         }</span>
221 
222         Pointer srcPointer = Word.objectToTrackedPointer(src).add(charArrayBaseOffset(INJECTED)).add(srcIndex * charArrayIndexScale(INJECTED));
223         Pointer destPointer = Word.objectToTrackedPointer(dest).add(byteArrayBaseOffset(INJECTED)).add(destIndex * byteArrayIndexScale(INJECTED));
224         return AMD64StringUTF16CompressNode.compress(srcPointer, destPointer, len, JavaKind.Char);
225     }
226 
227     /**
228      * Intrinsic for {@code }java.lang.StringUTF16.compress([BI[BII)I}.
229      *
230      * &lt;pre&gt;
231      * &amp;#64;HotSpotIntrinsicCandidate
232      * public static int compress(byte[] src, int src_indx, byte[] dst, int dst_indx, int len)
233      * &lt;/pre&gt;
234      * &lt;p&gt;
235      * In this variant {@code dest} refers to a byte array containing 2 byte per char so
236      * {@code srcIndex} and {@code len} are in terms of char elements and have to be scaled by 2
237      * when referring to {@code src}.
238      */
239     @MethodSubstitution
240     public static int compress(byte[] src, int srcIndex, byte[] dest, int destIndex, int len) {
<span class="line-modified">241         if (len &lt; 0 || srcIndex &lt; 0 || (srcIndex * 2 + len * 2 &gt; src.length) || destIndex &lt; 0 || (destIndex + len &gt; dest.length)) {</span>
<span class="line-removed">242             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.BoundsCheckException);</span>
<span class="line-removed">243         }</span>
244 
245         Pointer srcPointer = Word.objectToTrackedPointer(src).add(byteArrayBaseOffset(INJECTED)).add(srcIndex * 2 * byteArrayIndexScale(INJECTED));
246         Pointer destPointer = Word.objectToTrackedPointer(dest).add(byteArrayBaseOffset(INJECTED)).add(destIndex * byteArrayIndexScale(INJECTED));
247         return AMD64StringUTF16CompressNode.compress(srcPointer, destPointer, len, JavaKind.Byte);
248     }
249 






250 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 86     @MethodSubstitution
 87     public static int compareTo(byte[] value, byte[] other) {
 88         return ArrayCompareToNode.compareTo(value, other, value.length, other.length, JavaKind.Char, JavaKind.Char);
 89     }
 90 
 91     /**
 92      * @param value is char[]
 93      * @param other is byte[]
 94      */
 95     @MethodSubstitution
 96     public static int compareToLatin1(byte[] value, byte[] other) {
 97         /*
 98          * Swapping array arguments because intrinsic expects order to be byte[]/char[] but kind
 99          * arguments stay in original order.
100          */
101         return ArrayCompareToNode.compareTo(other, value, other.length, value.length, JavaKind.Char, JavaKind.Byte);
102     }
103 
104     @MethodSubstitution
105     public static int indexOfCharUnsafe(byte[] value, int ch, int fromIndex, int max) {
<span class="line-modified">106         return AMD64ArrayIndexOf.indexOf1Char(value, max, fromIndex, (char) ch);</span>





107     }
108 
109     private static Word pointer(byte[] target) {
110         return Word.objectToTrackedPointer(target).add(byteArrayBaseOffset(INJECTED));
111     }
112 
113     private static Word charOffsetPointer(byte[] value, int offset) {
114         return pointer(value).add(offset * charArrayIndexScale(INJECTED));
115     }
116 
117     @MethodSubstitution
118     public static int indexOfUnsafe(byte[] source, int sourceCount, byte[] target, int targetCount, int fromIndex) {
119         ReplacementsUtil.runtimeAssert(fromIndex &gt;= 0, &quot;StringUTF16.indexOfUnsafe invalid args: fromIndex negative&quot;);
120         ReplacementsUtil.runtimeAssert(targetCount &gt; 0, &quot;StringUTF16.indexOfUnsafe invalid args: targetCount &lt;= 0&quot;);
121         ReplacementsUtil.runtimeAssert(targetCount &lt;= length(target), &quot;StringUTF16.indexOfUnsafe invalid args: targetCount &gt; length(target)&quot;);
122         ReplacementsUtil.runtimeAssert(sourceCount &gt;= targetCount, &quot;StringUTF16.indexOfUnsafe invalid args: sourceCount &lt; targetCount&quot;);

123         if (targetCount == 1) {
<span class="line-modified">124             return AMD64ArrayIndexOf.indexOf1Char(source, sourceCount, fromIndex, StringUTF16Substitutions.getChar(target, 0));</span>













125         } else {
<span class="line-modified">126             int haystackLength = sourceCount - (targetCount - 2);</span>
<span class="line-modified">127             int offset = fromIndex;</span>
<span class="line-modified">128             while (offset &lt; haystackLength) {</span>
<span class="line-modified">129                 int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(source, haystackLength, offset, StringUTF16Substitutions.getChar(target, 0),</span>
130                                 StringUTF16Substitutions.getChar(target, 1));
131                 if (indexOfResult &lt; 0) {
132                     return -1;
133                 }
<span class="line-modified">134                 offset = indexOfResult;</span>
<span class="line-modified">135                 Pointer cmpSourcePointer = charOffsetPointer(source, offset);</span>

136                 Pointer targetPointer = pointer(target);
<span class="line-modified">137                 if (targetCount == 2 || ArrayRegionEqualsNode.regionEquals(cmpSourcePointer, targetPointer, targetCount, JavaKind.Char)) {</span>
<span class="line-modified">138                     return offset;</span>
139                 }
<span class="line-modified">140                 offset++;</span>
141             }
142             return -1;
143         }
144     }
145 
146     @MethodSubstitution
147     public static int indexOfLatin1Unsafe(byte[] source, int sourceCount, byte[] target, int targetCount, int fromIndex) {
148         ReplacementsUtil.runtimeAssert(fromIndex &gt;= 0, &quot;StringUTF16.indexOfLatin1Unsafe invalid args: fromIndex negative&quot;);
149         ReplacementsUtil.runtimeAssert(targetCount &gt; 0, &quot;StringUTF16.indexOfLatin1Unsafe invalid args: targetCount &lt;= 0&quot;);
150         ReplacementsUtil.runtimeAssert(targetCount &lt;= target.length, &quot;StringUTF16.indexOfLatin1Unsafe invalid args: targetCount &gt; length(target)&quot;);
151         ReplacementsUtil.runtimeAssert(sourceCount &gt;= targetCount, &quot;StringUTF16.indexOfLatin1Unsafe invalid args: sourceCount &lt; targetCount&quot;);

152         if (targetCount == 1) {
<span class="line-modified">153             return AMD64ArrayIndexOf.indexOf1Char(source, sourceCount, fromIndex, (char) Byte.toUnsignedInt(target[0]));</span>












154         } else {
<span class="line-modified">155             int haystackLength = sourceCount - (targetCount - 2);</span>
<span class="line-modified">156             int offset = fromIndex;</span>
<span class="line-modified">157             while (offset &lt; haystackLength) {</span>
<span class="line-modified">158                 int indexOfResult = AMD64ArrayIndexOf.indexOfTwoConsecutiveChars(source, haystackLength, offset, (char) Byte.toUnsignedInt(target[0]), (char) Byte.toUnsignedInt(target[1]));</span>
159                 if (indexOfResult &lt; 0) {
160                     return -1;
161                 }
<span class="line-modified">162                 offset = indexOfResult;</span>
<span class="line-modified">163                 Pointer cmpSourcePointer = charOffsetPointer(source, offset);</span>

164                 Pointer targetPointer = pointer(target);
<span class="line-modified">165                 if (targetCount == 2 || ArrayRegionEqualsNode.regionEquals(cmpSourcePointer, targetPointer, targetCount, JavaKind.Char, JavaKind.Byte)) {</span>
<span class="line-modified">166                     return offset;</span>
167                 }
<span class="line-modified">168                 offset++;</span>
169             }
170             return -1;
171         }
172     }
173 
174     /**
175      * Intrinsic for {@code java.lang.StringUTF16.compress([CI[BII)I}.
176      *
177      * &lt;pre&gt;
178      * &amp;#64;HotSpotIntrinsicCandidate
179      * public static int compress(char[] src, int src_indx, byte[] dst, int dst_indx, int len)
180      * &lt;/pre&gt;
181      */
182     @MethodSubstitution
183     public static int compress(char[] src, int srcIndex, byte[] dest, int destIndex, int len) {
<span class="line-modified">184         checkLimits(src.length, srcIndex, dest.length, destIndex, len);</span>


185 
186         Pointer srcPointer = Word.objectToTrackedPointer(src).add(charArrayBaseOffset(INJECTED)).add(srcIndex * charArrayIndexScale(INJECTED));
187         Pointer destPointer = Word.objectToTrackedPointer(dest).add(byteArrayBaseOffset(INJECTED)).add(destIndex * byteArrayIndexScale(INJECTED));
188         return AMD64StringUTF16CompressNode.compress(srcPointer, destPointer, len, JavaKind.Char);
189     }
190 
191     /**
192      * Intrinsic for {@code }java.lang.StringUTF16.compress([BI[BII)I}.
193      *
194      * &lt;pre&gt;
195      * &amp;#64;HotSpotIntrinsicCandidate
196      * public static int compress(byte[] src, int src_indx, byte[] dst, int dst_indx, int len)
197      * &lt;/pre&gt;
198      * &lt;p&gt;
199      * In this variant {@code dest} refers to a byte array containing 2 byte per char so
200      * {@code srcIndex} and {@code len} are in terms of char elements and have to be scaled by 2
201      * when referring to {@code src}.
202      */
203     @MethodSubstitution
204     public static int compress(byte[] src, int srcIndex, byte[] dest, int destIndex, int len) {
<span class="line-modified">205         checkLimits(src.length &gt;&gt; 1, srcIndex, dest.length, destIndex, len);</span>


206 
207         Pointer srcPointer = Word.objectToTrackedPointer(src).add(byteArrayBaseOffset(INJECTED)).add(srcIndex * 2 * byteArrayIndexScale(INJECTED));
208         Pointer destPointer = Word.objectToTrackedPointer(dest).add(byteArrayBaseOffset(INJECTED)).add(destIndex * byteArrayIndexScale(INJECTED));
209         return AMD64StringUTF16CompressNode.compress(srcPointer, destPointer, len, JavaKind.Byte);
210     }
211 
<span class="line-added">212     private static void checkLimits(int srcLen, int srcIndex, int destLen, int destIndex, int len) {</span>
<span class="line-added">213         if (len &lt; 0 || srcIndex &lt; 0 || (srcIndex + len &gt; srcLen) || destIndex &lt; 0 || (destIndex + len &gt; destLen)) {</span>
<span class="line-added">214             DeoptimizeNode.deopt(DeoptimizationAction.None, DeoptimizationReason.BoundsCheckException);</span>
<span class="line-added">215         }</span>
<span class="line-added">216     }</span>
<span class="line-added">217 </span>
218 }
</pre>
</td>
</tr>
</table>
<center><a href="AMD64StringUTF16CompressNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.replacements.jdk9.test/src/org/graalvm/compiler/replacements/jdk9/test/VarHandleTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/hashing/HashFunction.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/hashing/HashFunction.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/hashing/HashFunction.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/hashing/HashFunction.java
@@ -47,11 +47,11 @@
      *
      * @param value the value to be hashed
      * @param min {@code value} is guaranteed to be greater or equal to this minimum
      * @return the hash value within int range
      */
-    public abstract int apply(long value, long min);
+    public abstract int apply(int value, int min);
 
     /**
      * Generates LIR that implements the hash function in terms of value and min.
      *
      * @param value the value to be hashed
@@ -107,29 +107,29 @@
         addWithPrimes("(val * prime) >> min", 3,
                       prime -> (val, min) -> (val * prime) >> min,
                       (gen, prime) -> (val, min) -> gen.emitShr(gen.emitMul(val, prime, false), min));
 
         addWithPrimes("rotateRight(val, prime)", 3,
-                      prime -> (val, min) -> Long.rotateRight(val, prime),
+                      prime -> (val, min) -> Integer.rotateRight(val, prime),
                       (gen, prime) -> (val, min) -> gen.emitRor(val, prime));
 
         addWithPrimes("rotateRight(val, prime) + val", 4,
-                      prime -> (val, min) -> Long.rotateRight(val, prime) + val,
+                      prime -> (val, min) -> Integer.rotateRight(val, prime) + val,
                       (gen, prime) -> (val, min) -> gen.emitAdd(gen.emitRor(val, prime), val, false));
 
         addWithPrimes("rotateRight(val, prime) ^ val", 4,
-                      prime -> (val, min) -> Long.rotateRight(val, prime) ^ val,
+                      prime -> (val, min) -> Integer.rotateRight(val, prime) ^ val,
                       (gen, prime) -> (val, min) -> gen.emitXor(gen.emitRor(val, prime), val));
       //@formatter:on
     }
 
-    private static void add(String toString, int effort, BiFunction<Long, Long, Long> f, Function<ArithmeticLIRGenerator, BiFunction<Value, Value, Value>> gen) {
+    private static void add(String toString, int effort, BiFunction<Integer, Integer, Integer> f, Function<ArithmeticLIRGenerator, BiFunction<Value, Value, Value>> gen) {
         instances.add(new HashFunction() {
 
             @Override
-            public int apply(long value, long min) {
-                return f.apply(value, min).intValue();
+            public int apply(int value, int min) {
+                return f.apply(value, min);
             }
 
             @Override
             public int effort() {
                 return effort;
@@ -145,11 +145,11 @@
                 return gen.apply(t).apply(t.emitNarrow(val, 32), t.emitNarrow(min, 32));
             }
         });
     }
 
-    private static void addWithPrimes(String toString, int effort, Function<Integer, BiFunction<Long, Long, Long>> f,
+    private static void addWithPrimes(String toString, int effort, Function<Integer, BiFunction<Integer, Integer, Integer>> f,
                     BiFunction<ArithmeticLIRGenerator, Value, BiFunction<Value, Value, Value>> gen) {
         for (int p : mersennePrimes) {
             add(toString, effort, f.apply(p), g -> gen.apply(g, g.getLIRGen().emitJavaConstant(JavaConstant.forInt(p))));
         }
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LIRGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../hashing/HashFunction.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,13 ***</span>
   */
  
  
  package org.graalvm.compiler.lir.gen;
  
<span class="line-removed">- import java.util.BitSet;</span>
<span class="line-removed">- import java.util.List;</span>
<span class="line-removed">- </span>
  import org.graalvm.compiler.core.common.CompressEncoding;
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
  import org.graalvm.compiler.core.common.spi.CodeGenProviders;
<span class="line-new-header">--- 22,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,19 ***</span>
      /**
       * Factory for creating moves.
       */
      interface MoveFactory {
  
          /**
           * Checks whether the supplied constant can be used without loading it into a register for
           * most operations, i.e., for commonly used arithmetic, logical, and comparison operations.
           *
<span class="line-modified">!          * @param c The constant to check.</span>
           * @return True if the constant can be used directly, false if the constant needs to be in a
           *         register.
           */
<span class="line-modified">!         boolean canInlineConstant(Constant c);</span>
  
          /**
           * @param constant The constant that might be moved to a stack slot.
           * @return {@code true} if constant to stack moves are supported for this constant.
           */
<span class="line-new-header">--- 62,27 ---</span>
      /**
       * Factory for creating moves.
       */
      interface MoveFactory {
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * Checks whether the loading of the supplied constant can be deferred until usage.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">+         default boolean mayEmbedConstantLoad(Constant constant) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          /**
           * Checks whether the supplied constant can be used without loading it into a register for
           * most operations, i.e., for commonly used arithmetic, logical, and comparison operations.
           *
<span class="line-modified">!          * @param constant The constant to check.</span>
           * @return True if the constant can be used directly, false if the constant needs to be in a
           *         register.
           */
<span class="line-modified">!         boolean canInlineConstant(Constant constant);</span>
  
          /**
           * @param constant The constant that might be moved to a stack slot.
           * @return {@code true} if constant to stack moves are supported for this constant.
           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,10 ***</span>
<span class="line-new-header">--- 136,14 ---</span>
       */
      MoveFactory getSpillMoveFactory();
  
      BlockScope getBlockScope(AbstractBlockBase&lt;?&gt; block);
  
<span class="line-added">+     boolean canInlineConstant(Constant constant);</span>
<span class="line-added">+ </span>
<span class="line-added">+     boolean mayEmbedConstantLoad(Constant constant);</span>
<span class="line-added">+ </span>
      Value emitConstant(LIRKind kind, Constant constant);
  
      Value emitJavaConstant(JavaConstant constant);
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,10 ***</span>
<span class="line-new-header">--- 202,14 ---</span>
  
      Variable emitMove(Value input);
  
      void emitMove(AllocatableValue dst, Value src);
  
<span class="line-added">+     Variable emitReadRegister(Register register, ValueKind&lt;?&gt; kind);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void emitWriteRegister(Register dst, Value src, ValueKind&lt;?&gt; wordStamp);</span>
<span class="line-added">+ </span>
      void emitMoveConstant(AllocatableValue dst, Constant src);
  
      Variable emitAddress(AllocatableValue stackslot);
  
      void emitMembar(int barriers);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,19 ***</span>
      @SuppressWarnings(&quot;unused&quot;)
      default Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
          throw GraalError.unimplemented(&quot;String.compareTo substitution is not implemented on this architecture&quot;);
      }
  
<span class="line-modified">!     Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, int constantLength, boolean directPointers);</span>
  
      @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">!     default Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, int constantLength, boolean directPointers) {</span>
          throw GraalError.unimplemented(&quot;Array.equals with different types substitution is not implemented on this architecture&quot;);
      }
  
      @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">!     default Variable emitArrayIndexOf(JavaKind kind, boolean findTwoConsecutive, Value sourcePointer, Value sourceCount, Value... searchValues) {</span>
          throw GraalError.unimplemented(&quot;String.indexOf substitution is not implemented on this architecture&quot;);
      }
  
      /*
       * The routines emitStringLatin1Inflate/3 and emitStringUTF16Compress/3 models a simplified
<span class="line-new-header">--- 277,22 ---</span>
      @SuppressWarnings(&quot;unused&quot;)
      default Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
          throw GraalError.unimplemented(&quot;String.compareTo substitution is not implemented on this architecture&quot;);
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">+     default Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {</span>
<span class="line-added">+         throw GraalError.unimplemented(&quot;Array.equals substitution is not implemented on this architecture&quot;);</span>
<span class="line-added">+     }</span>
  
      @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">!     default Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, boolean directPointers) {</span>
          throw GraalError.unimplemented(&quot;Array.equals with different types substitution is not implemented on this architecture&quot;);
      }
  
      @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">!     default Variable emitArrayIndexOf(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, Value sourcePointer, Value sourceCount, Value fromIndex, Value... searchValues) {</span>
          throw GraalError.unimplemented(&quot;String.indexOf substitution is not implemented on this architecture&quot;);
      }
  
      /*
       * The routines emitStringLatin1Inflate/3 and emitStringUTF16Compress/3 models a simplified
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,12 ***</span>
       * Emits an instruction that prevents speculative execution from proceeding: no instruction
       * after this fence will execute until all previous instructions have retired.
       */
      void emitSpeculationFence();
  
<span class="line-modified">!     default VirtualStackSlot allocateStackSlots(int slots, BitSet objects, List&lt;VirtualStackSlot&gt; outObjectStackSlots) {</span>
<span class="line-modified">!         return getResult().getFrameMapBuilder().allocateStackSlots(slots, objects, outObjectStackSlots);</span>
      }
  
      default Value emitReadCallerStackPointer(Stamp wordStamp) {
          /*
           * We do not know the frame size yet. So we load the address of the first spill slot
<span class="line-new-header">--- 338,12 ---</span>
       * Emits an instruction that prevents speculative execution from proceeding: no instruction
       * after this fence will execute until all previous instructions have retired.
       */
      void emitSpeculationFence();
  
<span class="line-modified">!     default VirtualStackSlot allocateStackSlots(int slots) {</span>
<span class="line-modified">!         return getResult().getFrameMapBuilder().allocateStackSlots(slots);</span>
      }
  
      default Value emitReadCallerStackPointer(Stamp wordStamp) {
          /*
           * We do not know the frame size yet. So we load the address of the first spill slot
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,6 ***</span>
<span class="line-new-header">--- 354,11 ---</span>
      }
  
      default Value emitReadReturnAddress(Stamp wordStamp, int returnAddressSize) {
          return emitMove(StackSlot.get(getLIRKind(wordStamp), -returnAddressSize, true));
      }
<span class="line-added">+ </span>
<span class="line-added">+     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">+     default void emitZeroMemory(Value address, Value length, boolean isAligned) {</span>
<span class="line-added">+         throw GraalError.unimplemented(&quot;Bulk zeroing is not implemented on this architecture&quot;);</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="LIRGenerator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../hashing/HashFunction.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/stackslotalloc/LSStackSlotAllocator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../ssa/SSAVerifier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="SimpleStackSlotAllocator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/stackslotalloc/LSStackSlotAllocator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.stackslotalloc;
 26 
 27 import static org.graalvm.compiler.debug.DebugContext.BASIC_LEVEL;
 28 import static org.graalvm.compiler.lir.LIRValueUtil.asVirtualStackSlot;
 29 import static org.graalvm.compiler.lir.LIRValueUtil.isVirtualStackSlot;
 30 import static org.graalvm.compiler.lir.phases.LIRPhase.Options.LIROptimization;
 31 
 32 import java.util.ArrayDeque;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Deque;
<span class="line-removed"> 36 import java.util.EnumMap;</span>
 37 import java.util.EnumSet;
 38 import java.util.PriorityQueue;

 39 
 40 import jdk.internal.vm.compiler.collections.EconomicSet;

 41 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 42 import org.graalvm.compiler.debug.DebugCloseable;
 43 import org.graalvm.compiler.debug.DebugContext;
 44 import org.graalvm.compiler.debug.Indent;
 45 import org.graalvm.compiler.debug.TimerKey;
 46 import org.graalvm.compiler.lir.LIR;
 47 import org.graalvm.compiler.lir.LIRInstruction;
 48 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 49 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 50 import org.graalvm.compiler.lir.ValueProcedure;
 51 import org.graalvm.compiler.lir.VirtualStackSlot;

 52 import org.graalvm.compiler.lir.framemap.FrameMapBuilderTool;
 53 import org.graalvm.compiler.lir.framemap.SimpleVirtualStackSlot;
 54 import org.graalvm.compiler.lir.framemap.VirtualStackSlotRange;
 55 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 56 import org.graalvm.compiler.lir.phases.AllocationPhase;
 57 import org.graalvm.compiler.options.NestedBooleanOptionKey;
 58 import org.graalvm.compiler.options.Option;
 59 import org.graalvm.compiler.options.OptionType;
 60 

 61 import jdk.vm.ci.code.StackSlot;
 62 import jdk.vm.ci.code.TargetDescription;
 63 import jdk.vm.ci.meta.Value;
 64 import jdk.vm.ci.meta.ValueKind;
 65 
 66 /**
 67  * Linear Scan {@link StackSlotAllocatorUtil stack slot allocator}.
 68  * &lt;p&gt;
 69  * &lt;b&gt;Remark:&lt;/b&gt; The analysis works under the assumption that a stack slot is no longer live after
 70  * its last usage. If an {@link LIRInstruction instruction} transfers the raw address of the stack
 71  * slot to another location, e.g. a registers, and this location is referenced later on, the
 72  * {@link org.graalvm.compiler.lir.LIRInstruction.Use usage} of the stack slot must be marked with
 73  * the {@link OperandFlag#UNINITIALIZED}. Otherwise the stack slot might be reused and its content
 74  * destroyed.
 75  */
 76 public final class LSStackSlotAllocator extends AllocationPhase {
 77 
 78     public static class Options {
 79         // @formatter:off
 80         @Option(help = &quot;Use linear scan stack slot allocation.&quot;, type = OptionType.Debug)
</pre>
<hr />
<pre>
139             debug.dump(DebugContext.VERBOSE_LEVEL, lir, &quot;After StackSlot numbering&quot;);
140 
141             boolean allocationFramesizeEnabled = StackSlotAllocatorUtil.allocatedFramesize.isEnabled(debug);
142             long currentFrameSize = allocationFramesizeEnabled ? frameMapBuilder.getFrameMap().currentFrameSize() : 0;
143             EconomicSet&lt;LIRInstruction&gt; usePos;
144             // step 2: build intervals
145             try (DebugContext.Scope s = debug.scope(&quot;StackSlotAllocationBuildIntervals&quot;); Indent indent = debug.logAndIndent(&quot;BuildIntervals&quot;); DebugCloseable t = BuildIntervalsTimer.start(debug)) {
146                 usePos = buildIntervals();
147             }
148             // step 3: verify intervals
149             if (debug.areScopesEnabled()) {
150                 try (DebugCloseable t = VerifyIntervalsTimer.start(debug)) {
151                     assert verifyIntervals();
152                 }
153             }
154             if (debug.isDumpEnabled(DebugContext.VERBOSE_LEVEL)) {
155                 dumpIntervals(&quot;Before stack slot allocation&quot;);
156             }
157             // step 4: allocate stack slots
158             try (DebugCloseable t = AllocateSlotsTimer.start(debug)) {
<span class="line-modified">159                 allocateStackSlots();</span>








160             }
161             if (debug.isDumpEnabled(DebugContext.VERBOSE_LEVEL)) {
162                 dumpIntervals(&quot;After stack slot allocation&quot;);
163             }
164 
165             // step 5: assign stack slots
166             try (DebugCloseable t = AssignSlotsTimer.start(debug)) {
167                 assignStackSlots(usePos);
168             }
169             if (allocationFramesizeEnabled) {
170                 StackSlotAllocatorUtil.allocatedFramesize.add(debug, frameMapBuilder.getFrameMap().currentFrameSize() - currentFrameSize);
171             }
172         }
173 
174         // ====================
175         // step 1: number instructions
176         // ====================
177 
178         /**
179          * Numbers all instructions in all blocks.
</pre>
<hr />
<pre>
209         }
210 
211         // ====================
212         // step 3: verify intervals
213         // ====================
214 
215         private boolean verifyIntervals() {
216             for (StackInterval interval : stackSlotMap) {
217                 if (interval != null) {
218                     assert interval.verify(maxOpId());
219                 }
220             }
221             return true;
222         }
223 
224         // ====================
225         // step 4: allocate stack slots
226         // ====================
227 
228         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">229         private void allocateStackSlots() {</span>
<span class="line-removed">230             // create unhandled lists</span>
231             for (StackInterval interval : stackSlotMap) {
<span class="line-modified">232                 if (interval != null) {</span>
233                     unhandled.add(interval);
234                 }
235             }
<span class="line-removed">236 </span>
237             for (StackInterval current = activateNext(); current != null; current = activateNext()) {
238                 try (Indent indent = debug.logAndIndent(&quot;allocate %s&quot;, current)) {
239                     allocateSlot(current);
240                 }
241             }
242 



243         }
244 














245         private void allocateSlot(StackInterval current) {
246             VirtualStackSlot virtualSlot = current.getOperand();
247             final StackSlot location;
248             if (virtualSlot instanceof VirtualStackSlotRange) {
249                 // No reuse of ranges (yet).
250                 VirtualStackSlotRange slotRange = (VirtualStackSlotRange) virtualSlot;
<span class="line-modified">251                 location = frameMapBuilder.getFrameMap().allocateStackSlots(slotRange.getSlots(), slotRange.getObjects());</span>
252                 StackSlotAllocatorUtil.virtualFramesize.add(debug, frameMapBuilder.getFrameMap().spillSlotRangeSize(slotRange.getSlots()));
253                 StackSlotAllocatorUtil.allocatedSlots.increment(debug);
254             } else {
255                 assert virtualSlot instanceof SimpleVirtualStackSlot : &quot;Unexpected VirtualStackSlot type: &quot; + virtualSlot;
256                 StackSlot slot = findFreeSlot((SimpleVirtualStackSlot) virtualSlot);
257                 if (slot != null) {
258                     /*
259                      * Free stack slot available. Note that we create a new one because the kind
260                      * might not match.
261                      */
262                     location = StackSlot.get(current.kind(), slot.getRawOffset(), slot.getRawAddFrameSize());
263                     StackSlotAllocatorUtil.reusedSlots.increment(debug);
264                     debug.log(BASIC_LEVEL, &quot;Reuse stack slot %s (reallocated from %s) for virtual stack slot %s&quot;, location, slot, virtualSlot);
265                 } else {
266                     // Allocate new stack slot.
267                     location = frameMapBuilder.getFrameMap().allocateSpillSlot(virtualSlot.getValueKind());
268                     StackSlotAllocatorUtil.virtualFramesize.add(debug, frameMapBuilder.getFrameMap().spillSlotSize(virtualSlot.getValueKind()));
269                     StackSlotAllocatorUtil.allocatedSlots.increment(debug);
270                     debug.log(BASIC_LEVEL, &quot;New stack slot %s for virtual stack slot %s&quot;, location, virtualSlot);
271                 }
272             }
273             debug.log(&quot;Allocate location %s for interval %s&quot;, location, current);
274             current.setLocation(location);
275         }
276 
<span class="line-modified">277         private enum SlotSize {</span>
<span class="line-modified">278             Size1,</span>
<span class="line-modified">279             Size2,</span>
<span class="line-modified">280             Size4,</span>
<span class="line-modified">281             Size8,</span>
<span class="line-removed">282             Illegal;</span>
<span class="line-removed">283         }</span>
<span class="line-removed">284 </span>
<span class="line-removed">285         private SlotSize forKind(ValueKind&lt;?&gt; kind) {</span>
<span class="line-removed">286             switch (frameMapBuilder.getFrameMap().spillSlotSize(kind)) {</span>
<span class="line-removed">287                 case 1:</span>
<span class="line-removed">288                     return SlotSize.Size1;</span>
<span class="line-removed">289                 case 2:</span>
<span class="line-removed">290                     return SlotSize.Size2;</span>
<span class="line-removed">291                 case 4:</span>
<span class="line-removed">292                     return SlotSize.Size4;</span>
<span class="line-removed">293                 case 8:</span>
<span class="line-removed">294                     return SlotSize.Size8;</span>
<span class="line-removed">295                 default:</span>
<span class="line-removed">296                     return SlotSize.Illegal;</span>
<span class="line-removed">297             }</span>
<span class="line-removed">298         }</span>
<span class="line-removed">299 </span>
<span class="line-removed">300         private EnumMap&lt;SlotSize, Deque&lt;StackSlot&gt;&gt; freeSlots;</span>
301 
302         /**
<span class="line-modified">303          * @return The list of free stack slots for {@code size} or {@code null} if there is none.</span>
304          */
<span class="line-modified">305         private Deque&lt;StackSlot&gt; getOrNullFreeSlots(SlotSize size) {</span>
306             if (freeSlots == null) {
307                 return null;
308             }
<span class="line-modified">309             return freeSlots.get(size);</span>



310         }
311 
312         /**
<span class="line-modified">313          * @return the list of free stack slots for {@code size}. If there is none a list is</span>
314          *         created.
315          */
<span class="line-modified">316         private Deque&lt;StackSlot&gt; getOrInitFreeSlots(SlotSize size) {</span>
<span class="line-modified">317             assert size != SlotSize.Illegal;</span>
<span class="line-modified">318             Deque&lt;StackSlot&gt; freeList;</span>
<span class="line-modified">319             if (freeSlots != null) {</span>
<span class="line-modified">320                 freeList = freeSlots.get(size);</span>
<span class="line-modified">321             } else {</span>
<span class="line-removed">322                 freeSlots = new EnumMap&lt;&gt;(SlotSize.class);</span>
<span class="line-removed">323                 freeList = null;</span>
324             }
325             if (freeList == null) {




326                 freeList = new ArrayDeque&lt;&gt;();
<span class="line-modified">327                 freeSlots.put(size, freeList);</span>
328             }
<span class="line-removed">329             assert freeList != null;</span>
330             return freeList;
331         }
332 
333         /**
334          * Gets a free stack slot for {@code slot} or {@code null} if there is none.
335          */
336         private StackSlot findFreeSlot(SimpleVirtualStackSlot slot) {
337             assert slot != null;
<span class="line-modified">338             SlotSize size = forKind(slot.getValueKind());</span>
<span class="line-modified">339             if (size == SlotSize.Illegal) {</span>
<span class="line-removed">340                 return null;</span>
<span class="line-removed">341             }</span>
<span class="line-removed">342             Deque&lt;StackSlot&gt; freeList = getOrNullFreeSlots(size);</span>
343             if (freeList == null) {
344                 return null;
345             }
346             return freeList.pollLast();
347         }
348 
349         /**
350          * Adds a stack slot to the list of free slots.
351          */
352         private void freeSlot(StackSlot slot) {
<span class="line-modified">353             SlotSize size = forKind(slot.getValueKind());</span>
<span class="line-removed">354             if (size == SlotSize.Illegal) {</span>
<span class="line-removed">355                 return;</span>
<span class="line-removed">356             }</span>
357             getOrInitFreeSlots(size).addLast(slot);
358         }
359 






360         /**
361          * Gets the next unhandled interval and finishes handled intervals.
362          */
363         private StackInterval activateNext() {
364             if (unhandled.isEmpty()) {
365                 return null;
366             }
367             StackInterval next = unhandled.poll();
368             // finish handled intervals
369             for (int id = next.from(); activePeekId() &lt; id;) {
370                 finished(active.poll());
371             }
372             debug.log(&quot;active %s&quot;, next);
373             active.add(next);
374             return next;
375         }
376 
377         /**
378          * Gets the lowest {@link StackInterval#to() end position} of all active intervals. If there
379          * is none {@link Integer#MAX_VALUE} is returned.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.stackslotalloc;
 26 
 27 import static org.graalvm.compiler.debug.DebugContext.BASIC_LEVEL;
 28 import static org.graalvm.compiler.lir.LIRValueUtil.asVirtualStackSlot;
 29 import static org.graalvm.compiler.lir.LIRValueUtil.isVirtualStackSlot;
 30 import static org.graalvm.compiler.lir.phases.LIRPhase.Options.LIROptimization;
 31 
 32 import java.util.ArrayDeque;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Deque;

 36 import java.util.EnumSet;
 37 import java.util.PriorityQueue;
<span class="line-added"> 38 import java.util.function.Predicate;</span>
 39 
 40 import jdk.internal.vm.compiler.collections.EconomicSet;
<span class="line-added"> 41 import org.graalvm.compiler.core.common.LIRKind;</span>
 42 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 43 import org.graalvm.compiler.debug.DebugCloseable;
 44 import org.graalvm.compiler.debug.DebugContext;
 45 import org.graalvm.compiler.debug.Indent;
 46 import org.graalvm.compiler.debug.TimerKey;
 47 import org.graalvm.compiler.lir.LIR;
 48 import org.graalvm.compiler.lir.LIRInstruction;
 49 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 50 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 51 import org.graalvm.compiler.lir.ValueProcedure;
 52 import org.graalvm.compiler.lir.VirtualStackSlot;
<span class="line-added"> 53 import org.graalvm.compiler.lir.framemap.FrameMap;</span>
 54 import org.graalvm.compiler.lir.framemap.FrameMapBuilderTool;
 55 import org.graalvm.compiler.lir.framemap.SimpleVirtualStackSlot;
 56 import org.graalvm.compiler.lir.framemap.VirtualStackSlotRange;
 57 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 58 import org.graalvm.compiler.lir.phases.AllocationPhase;
 59 import org.graalvm.compiler.options.NestedBooleanOptionKey;
 60 import org.graalvm.compiler.options.Option;
 61 import org.graalvm.compiler.options.OptionType;
 62 
<span class="line-added"> 63 import jdk.vm.ci.code.CodeUtil;</span>
 64 import jdk.vm.ci.code.StackSlot;
 65 import jdk.vm.ci.code.TargetDescription;
 66 import jdk.vm.ci.meta.Value;
 67 import jdk.vm.ci.meta.ValueKind;
 68 
 69 /**
 70  * Linear Scan {@link StackSlotAllocatorUtil stack slot allocator}.
 71  * &lt;p&gt;
 72  * &lt;b&gt;Remark:&lt;/b&gt; The analysis works under the assumption that a stack slot is no longer live after
 73  * its last usage. If an {@link LIRInstruction instruction} transfers the raw address of the stack
 74  * slot to another location, e.g. a registers, and this location is referenced later on, the
 75  * {@link org.graalvm.compiler.lir.LIRInstruction.Use usage} of the stack slot must be marked with
 76  * the {@link OperandFlag#UNINITIALIZED}. Otherwise the stack slot might be reused and its content
 77  * destroyed.
 78  */
 79 public final class LSStackSlotAllocator extends AllocationPhase {
 80 
 81     public static class Options {
 82         // @formatter:off
 83         @Option(help = &quot;Use linear scan stack slot allocation.&quot;, type = OptionType.Debug)
</pre>
<hr />
<pre>
142             debug.dump(DebugContext.VERBOSE_LEVEL, lir, &quot;After StackSlot numbering&quot;);
143 
144             boolean allocationFramesizeEnabled = StackSlotAllocatorUtil.allocatedFramesize.isEnabled(debug);
145             long currentFrameSize = allocationFramesizeEnabled ? frameMapBuilder.getFrameMap().currentFrameSize() : 0;
146             EconomicSet&lt;LIRInstruction&gt; usePos;
147             // step 2: build intervals
148             try (DebugContext.Scope s = debug.scope(&quot;StackSlotAllocationBuildIntervals&quot;); Indent indent = debug.logAndIndent(&quot;BuildIntervals&quot;); DebugCloseable t = BuildIntervalsTimer.start(debug)) {
149                 usePos = buildIntervals();
150             }
151             // step 3: verify intervals
152             if (debug.areScopesEnabled()) {
153                 try (DebugCloseable t = VerifyIntervalsTimer.start(debug)) {
154                     assert verifyIntervals();
155                 }
156             }
157             if (debug.isDumpEnabled(DebugContext.VERBOSE_LEVEL)) {
158                 dumpIntervals(&quot;Before stack slot allocation&quot;);
159             }
160             // step 4: allocate stack slots
161             try (DebugCloseable t = AllocateSlotsTimer.start(debug)) {
<span class="line-modified">162                 /*</span>
<span class="line-added">163                  * Allocate primitive spill slots before reference spill slots. This ensures a</span>
<span class="line-added">164                  * ReferenceMap will be as compact as possible and only exceed the encoding limit of</span>
<span class="line-added">165                  * a stack offset if there are really too many objects live on the stack at an</span>
<span class="line-added">166                  * instruction with a ReferenceMap (as opposed to the method simply having a very</span>
<span class="line-added">167                  * large frame).</span>
<span class="line-added">168                  */</span>
<span class="line-added">169                 allocateStackSlots(IS_PRIMITIVE_INTERVAL);</span>
<span class="line-added">170                 allocateStackSlots(IS_REFERENCE_INTERVAL);</span>
171             }
172             if (debug.isDumpEnabled(DebugContext.VERBOSE_LEVEL)) {
173                 dumpIntervals(&quot;After stack slot allocation&quot;);
174             }
175 
176             // step 5: assign stack slots
177             try (DebugCloseable t = AssignSlotsTimer.start(debug)) {
178                 assignStackSlots(usePos);
179             }
180             if (allocationFramesizeEnabled) {
181                 StackSlotAllocatorUtil.allocatedFramesize.add(debug, frameMapBuilder.getFrameMap().currentFrameSize() - currentFrameSize);
182             }
183         }
184 
185         // ====================
186         // step 1: number instructions
187         // ====================
188 
189         /**
190          * Numbers all instructions in all blocks.
</pre>
<hr />
<pre>
220         }
221 
222         // ====================
223         // step 3: verify intervals
224         // ====================
225 
226         private boolean verifyIntervals() {
227             for (StackInterval interval : stackSlotMap) {
228                 if (interval != null) {
229                     assert interval.verify(maxOpId());
230                 }
231             }
232             return true;
233         }
234 
235         // ====================
236         // step 4: allocate stack slots
237         // ====================
238 
239         @SuppressWarnings(&quot;try&quot;)
<span class="line-modified">240         private void allocateStackSlots(Predicate&lt;StackInterval&gt; predicate) {</span>

241             for (StackInterval interval : stackSlotMap) {
<span class="line-modified">242                 if (interval != null &amp;&amp; (predicate == null || predicate.test(interval))) {</span>
243                     unhandled.add(interval);
244                 }
245             }

246             for (StackInterval current = activateNext(); current != null; current = activateNext()) {
247                 try (Indent indent = debug.logAndIndent(&quot;allocate %s&quot;, current)) {
248                     allocateSlot(current);
249                 }
250             }
251 
<span class="line-added">252             // Cannot re-use free slots between rounds of slot allocation</span>
<span class="line-added">253             freeSlots = null;</span>
<span class="line-added">254             active.clear();</span>
255         }
256 
<span class="line-added">257         private static final Predicate&lt;StackInterval&gt; IS_REFERENCE_INTERVAL = new Predicate&lt;StackInterval&gt;() {</span>
<span class="line-added">258             @Override</span>
<span class="line-added">259             public boolean test(StackInterval interval) {</span>
<span class="line-added">260                 return !((LIRKind) interval.kind()).isValue();</span>
<span class="line-added">261             }</span>
<span class="line-added">262         };</span>
<span class="line-added">263 </span>
<span class="line-added">264         private static final Predicate&lt;StackInterval&gt; IS_PRIMITIVE_INTERVAL = new Predicate&lt;StackInterval&gt;() {</span>
<span class="line-added">265             @Override</span>
<span class="line-added">266             public boolean test(StackInterval interval) {</span>
<span class="line-added">267                 return ((LIRKind) interval.kind()).isValue();</span>
<span class="line-added">268             }</span>
<span class="line-added">269         };</span>
<span class="line-added">270 </span>
271         private void allocateSlot(StackInterval current) {
272             VirtualStackSlot virtualSlot = current.getOperand();
273             final StackSlot location;
274             if (virtualSlot instanceof VirtualStackSlotRange) {
275                 // No reuse of ranges (yet).
276                 VirtualStackSlotRange slotRange = (VirtualStackSlotRange) virtualSlot;
<span class="line-modified">277                 location = frameMapBuilder.getFrameMap().allocateStackSlots(slotRange.getSlots());</span>
278                 StackSlotAllocatorUtil.virtualFramesize.add(debug, frameMapBuilder.getFrameMap().spillSlotRangeSize(slotRange.getSlots()));
279                 StackSlotAllocatorUtil.allocatedSlots.increment(debug);
280             } else {
281                 assert virtualSlot instanceof SimpleVirtualStackSlot : &quot;Unexpected VirtualStackSlot type: &quot; + virtualSlot;
282                 StackSlot slot = findFreeSlot((SimpleVirtualStackSlot) virtualSlot);
283                 if (slot != null) {
284                     /*
285                      * Free stack slot available. Note that we create a new one because the kind
286                      * might not match.
287                      */
288                     location = StackSlot.get(current.kind(), slot.getRawOffset(), slot.getRawAddFrameSize());
289                     StackSlotAllocatorUtil.reusedSlots.increment(debug);
290                     debug.log(BASIC_LEVEL, &quot;Reuse stack slot %s (reallocated from %s) for virtual stack slot %s&quot;, location, slot, virtualSlot);
291                 } else {
292                     // Allocate new stack slot.
293                     location = frameMapBuilder.getFrameMap().allocateSpillSlot(virtualSlot.getValueKind());
294                     StackSlotAllocatorUtil.virtualFramesize.add(debug, frameMapBuilder.getFrameMap().spillSlotSize(virtualSlot.getValueKind()));
295                     StackSlotAllocatorUtil.allocatedSlots.increment(debug);
296                     debug.log(BASIC_LEVEL, &quot;New stack slot %s for virtual stack slot %s&quot;, location, virtualSlot);
297                 }
298             }
299             debug.log(&quot;Allocate location %s for interval %s&quot;, location, current);
300             current.setLocation(location);
301         }
302 
<span class="line-modified">303         /**</span>
<span class="line-modified">304          * Map from log2 of {@link FrameMap#spillSlotSize(ValueKind) a spill slot size} to a list of</span>
<span class="line-modified">305          * free stack slots.</span>
<span class="line-modified">306          */</span>
<span class="line-modified">307         private ArrayList&lt;Deque&lt;StackSlot&gt;&gt; freeSlots;</span>



















308 
309         /**
<span class="line-modified">310          * @return The list of free stack slots for {@code index} or {@code null} if there is none.</span>
311          */
<span class="line-modified">312         private Deque&lt;StackSlot&gt; getNullOrFreeSlots(int index) {</span>
313             if (freeSlots == null) {
314                 return null;
315             }
<span class="line-modified">316             if (index &lt; freeSlots.size()) {</span>
<span class="line-added">317                 return freeSlots.get(index);</span>
<span class="line-added">318             }</span>
<span class="line-added">319             return null;</span>
320         }
321 
322         /**
<span class="line-modified">323          * @return the list of free stack slots for {@code index}. If there is none a list is</span>
324          *         created.
325          */
<span class="line-modified">326         private Deque&lt;StackSlot&gt; getOrInitFreeSlots(int index) {</span>
<span class="line-modified">327             Deque&lt;StackSlot&gt; freeList = null;</span>
<span class="line-modified">328             if (freeSlots == null) {</span>
<span class="line-modified">329                 freeSlots = new ArrayList&lt;&gt;(6);</span>
<span class="line-modified">330             } else if (index &lt; freeSlots.size()) {</span>
<span class="line-modified">331                 freeList = freeSlots.get(index);</span>


332             }
333             if (freeList == null) {
<span class="line-added">334                 int requiredSize = index + 1;</span>
<span class="line-added">335                 for (int i = freeSlots.size(); i &lt; requiredSize; i++) {</span>
<span class="line-added">336                     freeSlots.add(null);</span>
<span class="line-added">337                 }</span>
338                 freeList = new ArrayDeque&lt;&gt;();
<span class="line-modified">339                 freeSlots.set(index, freeList);</span>
340             }

341             return freeList;
342         }
343 
344         /**
345          * Gets a free stack slot for {@code slot} or {@code null} if there is none.
346          */
347         private StackSlot findFreeSlot(SimpleVirtualStackSlot slot) {
348             assert slot != null;
<span class="line-modified">349             int size = log2SpillSlotSize(slot.getValueKind());</span>
<span class="line-modified">350             Deque&lt;StackSlot&gt; freeList = getNullOrFreeSlots(size);</span>



351             if (freeList == null) {
352                 return null;
353             }
354             return freeList.pollLast();
355         }
356 
357         /**
358          * Adds a stack slot to the list of free slots.
359          */
360         private void freeSlot(StackSlot slot) {
<span class="line-modified">361             int size = log2SpillSlotSize(slot.getValueKind());</span>



362             getOrInitFreeSlots(size).addLast(slot);
363         }
364 
<span class="line-added">365         private int log2SpillSlotSize(ValueKind&lt;?&gt; kind) {</span>
<span class="line-added">366             int size = frameMapBuilder.getFrameMap().spillSlotSize(kind);</span>
<span class="line-added">367             assert CodeUtil.isPowerOf2(size);</span>
<span class="line-added">368             return CodeUtil.log2(size);</span>
<span class="line-added">369         }</span>
<span class="line-added">370 </span>
371         /**
372          * Gets the next unhandled interval and finishes handled intervals.
373          */
374         private StackInterval activateNext() {
375             if (unhandled.isEmpty()) {
376                 return null;
377             }
378             StackInterval next = unhandled.poll();
379             // finish handled intervals
380             for (int id = next.from(); activePeekId() &lt; id;) {
381                 finished(active.poll());
382             }
383             debug.log(&quot;active %s&quot;, next);
384             active.add(next);
385             return next;
386         }
387 
388         /**
389          * Gets the lowest {@link StackInterval#to() end position} of all active intervals. If there
390          * is none {@link Integer#MAX_VALUE} is returned.
</pre>
</td>
</tr>
</table>
<center><a href="../ssa/SSAVerifier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="SimpleStackSlotAllocator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
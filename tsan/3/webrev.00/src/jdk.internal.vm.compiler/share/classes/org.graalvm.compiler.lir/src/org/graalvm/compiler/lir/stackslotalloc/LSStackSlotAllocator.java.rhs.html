<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/stackslotalloc/LSStackSlotAllocator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.stackslotalloc;
 26 
 27 import static org.graalvm.compiler.debug.DebugContext.BASIC_LEVEL;
 28 import static org.graalvm.compiler.lir.LIRValueUtil.asVirtualStackSlot;
 29 import static org.graalvm.compiler.lir.LIRValueUtil.isVirtualStackSlot;
 30 import static org.graalvm.compiler.lir.phases.LIRPhase.Options.LIROptimization;
 31 
 32 import java.util.ArrayDeque;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Deque;
<a name="2" id="anc2"></a>
 36 import java.util.EnumSet;
 37 import java.util.PriorityQueue;
<a name="3" id="anc3"></a><span class="line-added"> 38 import java.util.function.Predicate;</span>
 39 
 40 import jdk.internal.vm.compiler.collections.EconomicSet;
<a name="4" id="anc4"></a><span class="line-added"> 41 import org.graalvm.compiler.core.common.LIRKind;</span>
 42 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 43 import org.graalvm.compiler.debug.DebugCloseable;
 44 import org.graalvm.compiler.debug.DebugContext;
 45 import org.graalvm.compiler.debug.Indent;
 46 import org.graalvm.compiler.debug.TimerKey;
 47 import org.graalvm.compiler.lir.LIR;
 48 import org.graalvm.compiler.lir.LIRInstruction;
 49 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 50 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 51 import org.graalvm.compiler.lir.ValueProcedure;
 52 import org.graalvm.compiler.lir.VirtualStackSlot;
<a name="5" id="anc5"></a><span class="line-added"> 53 import org.graalvm.compiler.lir.framemap.FrameMap;</span>
 54 import org.graalvm.compiler.lir.framemap.FrameMapBuilderTool;
 55 import org.graalvm.compiler.lir.framemap.SimpleVirtualStackSlot;
 56 import org.graalvm.compiler.lir.framemap.VirtualStackSlotRange;
 57 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 58 import org.graalvm.compiler.lir.phases.AllocationPhase;
 59 import org.graalvm.compiler.options.NestedBooleanOptionKey;
 60 import org.graalvm.compiler.options.Option;
 61 import org.graalvm.compiler.options.OptionType;
 62 
<a name="6" id="anc6"></a><span class="line-added"> 63 import jdk.vm.ci.code.CodeUtil;</span>
 64 import jdk.vm.ci.code.StackSlot;
 65 import jdk.vm.ci.code.TargetDescription;
 66 import jdk.vm.ci.meta.Value;
 67 import jdk.vm.ci.meta.ValueKind;
 68 
 69 /**
 70  * Linear Scan {@link StackSlotAllocatorUtil stack slot allocator}.
 71  * &lt;p&gt;
 72  * &lt;b&gt;Remark:&lt;/b&gt; The analysis works under the assumption that a stack slot is no longer live after
 73  * its last usage. If an {@link LIRInstruction instruction} transfers the raw address of the stack
 74  * slot to another location, e.g. a registers, and this location is referenced later on, the
 75  * {@link org.graalvm.compiler.lir.LIRInstruction.Use usage} of the stack slot must be marked with
 76  * the {@link OperandFlag#UNINITIALIZED}. Otherwise the stack slot might be reused and its content
 77  * destroyed.
 78  */
 79 public final class LSStackSlotAllocator extends AllocationPhase {
 80 
 81     public static class Options {
 82         // @formatter:off
 83         @Option(help = &quot;Use linear scan stack slot allocation.&quot;, type = OptionType.Debug)
 84         public static final NestedBooleanOptionKey LIROptLSStackSlotAllocator = new NestedBooleanOptionKey(LIROptimization, true);
 85         // @formatter:on
 86     }
 87 
 88     private static final TimerKey MainTimer = DebugContext.timer(&quot;LSStackSlotAllocator&quot;);
 89     private static final TimerKey NumInstTimer = DebugContext.timer(&quot;LSStackSlotAllocator[NumberInstruction]&quot;);
 90     private static final TimerKey BuildIntervalsTimer = DebugContext.timer(&quot;LSStackSlotAllocator[BuildIntervals]&quot;);
 91     private static final TimerKey VerifyIntervalsTimer = DebugContext.timer(&quot;LSStackSlotAllocator[VerifyIntervals]&quot;);
 92     private static final TimerKey AllocateSlotsTimer = DebugContext.timer(&quot;LSStackSlotAllocator[AllocateSlots]&quot;);
 93     private static final TimerKey AssignSlotsTimer = DebugContext.timer(&quot;LSStackSlotAllocator[AssignSlots]&quot;);
 94 
 95     @Override
 96     protected void run(TargetDescription target, LIRGenerationResult lirGenRes, AllocationContext context) {
 97         allocateStackSlots((FrameMapBuilderTool) lirGenRes.getFrameMapBuilder(), lirGenRes);
 98         lirGenRes.buildFrameMap();
 99     }
100 
101     @SuppressWarnings(&quot;try&quot;)
102     public static void allocateStackSlots(FrameMapBuilderTool builder, LIRGenerationResult res) {
103         if (builder.getNumberOfStackSlots() &gt; 0) {
104             try (DebugCloseable t = MainTimer.start(res.getLIR().getDebug())) {
105                 new Allocator(res.getLIR(), builder).allocate();
106             }
107         }
108     }
109 
110     private static final class Allocator {
111 
112         private final LIR lir;
113         private final DebugContext debug;
114         private final FrameMapBuilderTool frameMapBuilder;
115         private final StackInterval[] stackSlotMap;
116         private final PriorityQueue&lt;StackInterval&gt; unhandled;
117         private final PriorityQueue&lt;StackInterval&gt; active;
118         private final AbstractBlockBase&lt;?&gt;[] sortedBlocks;
119         private final int maxOpId;
120 
121         @SuppressWarnings(&quot;try&quot;)
122         private Allocator(LIR lir, FrameMapBuilderTool frameMapBuilder) {
123             this.lir = lir;
124             this.debug = lir.getDebug();
125             this.frameMapBuilder = frameMapBuilder;
126             this.stackSlotMap = new StackInterval[frameMapBuilder.getNumberOfStackSlots()];
127             this.sortedBlocks = lir.getControlFlowGraph().getBlocks();
128 
129             // insert by from
130             this.unhandled = new PriorityQueue&lt;&gt;((a, b) -&gt; a.from() - b.from());
131             // insert by to
132             this.active = new PriorityQueue&lt;&gt;((a, b) -&gt; a.to() - b.to());
133 
134             try (DebugCloseable t = NumInstTimer.start(debug)) {
135                 // step 1: number instructions
136                 this.maxOpId = numberInstructions(lir, sortedBlocks);
137             }
138         }
139 
140         @SuppressWarnings(&quot;try&quot;)
141         private void allocate() {
142             debug.dump(DebugContext.VERBOSE_LEVEL, lir, &quot;After StackSlot numbering&quot;);
143 
144             boolean allocationFramesizeEnabled = StackSlotAllocatorUtil.allocatedFramesize.isEnabled(debug);
145             long currentFrameSize = allocationFramesizeEnabled ? frameMapBuilder.getFrameMap().currentFrameSize() : 0;
146             EconomicSet&lt;LIRInstruction&gt; usePos;
147             // step 2: build intervals
148             try (DebugContext.Scope s = debug.scope(&quot;StackSlotAllocationBuildIntervals&quot;); Indent indent = debug.logAndIndent(&quot;BuildIntervals&quot;); DebugCloseable t = BuildIntervalsTimer.start(debug)) {
149                 usePos = buildIntervals();
150             }
151             // step 3: verify intervals
152             if (debug.areScopesEnabled()) {
153                 try (DebugCloseable t = VerifyIntervalsTimer.start(debug)) {
154                     assert verifyIntervals();
155                 }
156             }
157             if (debug.isDumpEnabled(DebugContext.VERBOSE_LEVEL)) {
158                 dumpIntervals(&quot;Before stack slot allocation&quot;);
159             }
160             // step 4: allocate stack slots
161             try (DebugCloseable t = AllocateSlotsTimer.start(debug)) {
<a name="7" id="anc7"></a><span class="line-modified">162                 /*</span>
<span class="line-added">163                  * Allocate primitive spill slots before reference spill slots. This ensures a</span>
<span class="line-added">164                  * ReferenceMap will be as compact as possible and only exceed the encoding limit of</span>
<span class="line-added">165                  * a stack offset if there are really too many objects live on the stack at an</span>
<span class="line-added">166                  * instruction with a ReferenceMap (as opposed to the method simply having a very</span>
<span class="line-added">167                  * large frame).</span>
<span class="line-added">168                  */</span>
<span class="line-added">169                 allocateStackSlots(IS_PRIMITIVE_INTERVAL);</span>
<span class="line-added">170                 allocateStackSlots(IS_REFERENCE_INTERVAL);</span>
171             }
172             if (debug.isDumpEnabled(DebugContext.VERBOSE_LEVEL)) {
173                 dumpIntervals(&quot;After stack slot allocation&quot;);
174             }
175 
176             // step 5: assign stack slots
177             try (DebugCloseable t = AssignSlotsTimer.start(debug)) {
178                 assignStackSlots(usePos);
179             }
180             if (allocationFramesizeEnabled) {
181                 StackSlotAllocatorUtil.allocatedFramesize.add(debug, frameMapBuilder.getFrameMap().currentFrameSize() - currentFrameSize);
182             }
183         }
184 
185         // ====================
186         // step 1: number instructions
187         // ====================
188 
189         /**
190          * Numbers all instructions in all blocks.
191          *
192          * @return The id of the last operation.
193          */
194         private static int numberInstructions(LIR lir, AbstractBlockBase&lt;?&gt;[] sortedBlocks) {
195             int opId = 0;
196             int index = 0;
197             for (AbstractBlockBase&lt;?&gt; block : sortedBlocks) {
198 
199                 ArrayList&lt;LIRInstruction&gt; instructions = lir.getLIRforBlock(block);
200 
201                 int numInst = instructions.size();
202                 for (int j = 0; j &lt; numInst; j++) {
203                     LIRInstruction op = instructions.get(j);
204                     op.setId(opId);
205 
206                     index++;
207                     opId += 2; // numbering of lirOps by two
208                 }
209             }
210             assert (index &lt;&lt; 1) == opId : &quot;must match: &quot; + (index &lt;&lt; 1);
211             return opId - 2;
212         }
213 
214         // ====================
215         // step 2: build intervals
216         // ====================
217 
218         private EconomicSet&lt;LIRInstruction&gt; buildIntervals() {
219             return new FixPointIntervalBuilder(lir, stackSlotMap, maxOpId()).build();
220         }
221 
222         // ====================
223         // step 3: verify intervals
224         // ====================
225 
226         private boolean verifyIntervals() {
227             for (StackInterval interval : stackSlotMap) {
228                 if (interval != null) {
229                     assert interval.verify(maxOpId());
230                 }
231             }
232             return true;
233         }
234 
235         // ====================
236         // step 4: allocate stack slots
237         // ====================
238 
239         @SuppressWarnings(&quot;try&quot;)
<a name="8" id="anc8"></a><span class="line-modified">240         private void allocateStackSlots(Predicate&lt;StackInterval&gt; predicate) {</span>

241             for (StackInterval interval : stackSlotMap) {
<a name="9" id="anc9"></a><span class="line-modified">242                 if (interval != null &amp;&amp; (predicate == null || predicate.test(interval))) {</span>
243                     unhandled.add(interval);
244                 }
245             }
<a name="10" id="anc10"></a>
246             for (StackInterval current = activateNext(); current != null; current = activateNext()) {
247                 try (Indent indent = debug.logAndIndent(&quot;allocate %s&quot;, current)) {
248                     allocateSlot(current);
249                 }
250             }
251 
<a name="11" id="anc11"></a><span class="line-added">252             // Cannot re-use free slots between rounds of slot allocation</span>
<span class="line-added">253             freeSlots = null;</span>
<span class="line-added">254             active.clear();</span>
255         }
256 
<a name="12" id="anc12"></a><span class="line-added">257         private static final Predicate&lt;StackInterval&gt; IS_REFERENCE_INTERVAL = new Predicate&lt;StackInterval&gt;() {</span>
<span class="line-added">258             @Override</span>
<span class="line-added">259             public boolean test(StackInterval interval) {</span>
<span class="line-added">260                 return !((LIRKind) interval.kind()).isValue();</span>
<span class="line-added">261             }</span>
<span class="line-added">262         };</span>
<span class="line-added">263 </span>
<span class="line-added">264         private static final Predicate&lt;StackInterval&gt; IS_PRIMITIVE_INTERVAL = new Predicate&lt;StackInterval&gt;() {</span>
<span class="line-added">265             @Override</span>
<span class="line-added">266             public boolean test(StackInterval interval) {</span>
<span class="line-added">267                 return ((LIRKind) interval.kind()).isValue();</span>
<span class="line-added">268             }</span>
<span class="line-added">269         };</span>
<span class="line-added">270 </span>
271         private void allocateSlot(StackInterval current) {
272             VirtualStackSlot virtualSlot = current.getOperand();
273             final StackSlot location;
274             if (virtualSlot instanceof VirtualStackSlotRange) {
275                 // No reuse of ranges (yet).
276                 VirtualStackSlotRange slotRange = (VirtualStackSlotRange) virtualSlot;
<a name="13" id="anc13"></a><span class="line-modified">277                 location = frameMapBuilder.getFrameMap().allocateStackSlots(slotRange.getSlots());</span>
278                 StackSlotAllocatorUtil.virtualFramesize.add(debug, frameMapBuilder.getFrameMap().spillSlotRangeSize(slotRange.getSlots()));
279                 StackSlotAllocatorUtil.allocatedSlots.increment(debug);
280             } else {
281                 assert virtualSlot instanceof SimpleVirtualStackSlot : &quot;Unexpected VirtualStackSlot type: &quot; + virtualSlot;
282                 StackSlot slot = findFreeSlot((SimpleVirtualStackSlot) virtualSlot);
283                 if (slot != null) {
284                     /*
285                      * Free stack slot available. Note that we create a new one because the kind
286                      * might not match.
287                      */
288                     location = StackSlot.get(current.kind(), slot.getRawOffset(), slot.getRawAddFrameSize());
289                     StackSlotAllocatorUtil.reusedSlots.increment(debug);
290                     debug.log(BASIC_LEVEL, &quot;Reuse stack slot %s (reallocated from %s) for virtual stack slot %s&quot;, location, slot, virtualSlot);
291                 } else {
292                     // Allocate new stack slot.
293                     location = frameMapBuilder.getFrameMap().allocateSpillSlot(virtualSlot.getValueKind());
294                     StackSlotAllocatorUtil.virtualFramesize.add(debug, frameMapBuilder.getFrameMap().spillSlotSize(virtualSlot.getValueKind()));
295                     StackSlotAllocatorUtil.allocatedSlots.increment(debug);
296                     debug.log(BASIC_LEVEL, &quot;New stack slot %s for virtual stack slot %s&quot;, location, virtualSlot);
297                 }
298             }
299             debug.log(&quot;Allocate location %s for interval %s&quot;, location, current);
300             current.setLocation(location);
301         }
302 
<a name="14" id="anc14"></a><span class="line-modified">303         /**</span>
<span class="line-modified">304          * Map from log2 of {@link FrameMap#spillSlotSize(ValueKind) a spill slot size} to a list of</span>
<span class="line-modified">305          * free stack slots.</span>
<span class="line-modified">306          */</span>
<span class="line-modified">307         private ArrayList&lt;Deque&lt;StackSlot&gt;&gt; freeSlots;</span>



















308 
309         /**
<a name="15" id="anc15"></a><span class="line-modified">310          * @return The list of free stack slots for {@code index} or {@code null} if there is none.</span>
311          */
<a name="16" id="anc16"></a><span class="line-modified">312         private Deque&lt;StackSlot&gt; getNullOrFreeSlots(int index) {</span>
313             if (freeSlots == null) {
314                 return null;
315             }
<a name="17" id="anc17"></a><span class="line-modified">316             if (index &lt; freeSlots.size()) {</span>
<span class="line-added">317                 return freeSlots.get(index);</span>
<span class="line-added">318             }</span>
<span class="line-added">319             return null;</span>
320         }
321 
322         /**
<a name="18" id="anc18"></a><span class="line-modified">323          * @return the list of free stack slots for {@code index}. If there is none a list is</span>
324          *         created.
325          */
<a name="19" id="anc19"></a><span class="line-modified">326         private Deque&lt;StackSlot&gt; getOrInitFreeSlots(int index) {</span>
<span class="line-modified">327             Deque&lt;StackSlot&gt; freeList = null;</span>
<span class="line-modified">328             if (freeSlots == null) {</span>
<span class="line-modified">329                 freeSlots = new ArrayList&lt;&gt;(6);</span>
<span class="line-modified">330             } else if (index &lt; freeSlots.size()) {</span>
<span class="line-modified">331                 freeList = freeSlots.get(index);</span>


332             }
333             if (freeList == null) {
<a name="20" id="anc20"></a><span class="line-added">334                 int requiredSize = index + 1;</span>
<span class="line-added">335                 for (int i = freeSlots.size(); i &lt; requiredSize; i++) {</span>
<span class="line-added">336                     freeSlots.add(null);</span>
<span class="line-added">337                 }</span>
338                 freeList = new ArrayDeque&lt;&gt;();
<a name="21" id="anc21"></a><span class="line-modified">339                 freeSlots.set(index, freeList);</span>
340             }
<a name="22" id="anc22"></a>
341             return freeList;
342         }
343 
344         /**
345          * Gets a free stack slot for {@code slot} or {@code null} if there is none.
346          */
347         private StackSlot findFreeSlot(SimpleVirtualStackSlot slot) {
348             assert slot != null;
<a name="23" id="anc23"></a><span class="line-modified">349             int size = log2SpillSlotSize(slot.getValueKind());</span>
<span class="line-modified">350             Deque&lt;StackSlot&gt; freeList = getNullOrFreeSlots(size);</span>



351             if (freeList == null) {
352                 return null;
353             }
354             return freeList.pollLast();
355         }
356 
357         /**
358          * Adds a stack slot to the list of free slots.
359          */
360         private void freeSlot(StackSlot slot) {
<a name="24" id="anc24"></a><span class="line-modified">361             int size = log2SpillSlotSize(slot.getValueKind());</span>



362             getOrInitFreeSlots(size).addLast(slot);
363         }
364 
<a name="25" id="anc25"></a><span class="line-added">365         private int log2SpillSlotSize(ValueKind&lt;?&gt; kind) {</span>
<span class="line-added">366             int size = frameMapBuilder.getFrameMap().spillSlotSize(kind);</span>
<span class="line-added">367             assert CodeUtil.isPowerOf2(size);</span>
<span class="line-added">368             return CodeUtil.log2(size);</span>
<span class="line-added">369         }</span>
<span class="line-added">370 </span>
371         /**
372          * Gets the next unhandled interval and finishes handled intervals.
373          */
374         private StackInterval activateNext() {
375             if (unhandled.isEmpty()) {
376                 return null;
377             }
378             StackInterval next = unhandled.poll();
379             // finish handled intervals
380             for (int id = next.from(); activePeekId() &lt; id;) {
381                 finished(active.poll());
382             }
383             debug.log(&quot;active %s&quot;, next);
384             active.add(next);
385             return next;
386         }
387 
388         /**
389          * Gets the lowest {@link StackInterval#to() end position} of all active intervals. If there
390          * is none {@link Integer#MAX_VALUE} is returned.
391          */
392         private int activePeekId() {
393             StackInterval first = active.peek();
394             if (first == null) {
395                 return Integer.MAX_VALUE;
396             }
397             return first.to();
398         }
399 
400         /**
401          * Finishes {@code interval} by adding its location to the list of free stack slots.
402          */
403         private void finished(StackInterval interval) {
404             StackSlot location = interval.location();
405             debug.log(&quot;finished %s (freeing %s)&quot;, interval, location);
406             freeSlot(location);
407         }
408 
409         // ====================
410         // step 5: assign stack slots
411         // ====================
412 
413         private void assignStackSlots(EconomicSet&lt;LIRInstruction&gt; usePos) {
414             for (LIRInstruction op : usePos) {
415                 op.forEachInput(assignSlot);
416                 op.forEachAlive(assignSlot);
417                 op.forEachState(assignSlot);
418 
419                 op.forEachTemp(assignSlot);
420                 op.forEachOutput(assignSlot);
421             }
422         }
423 
424         ValueProcedure assignSlot = new ValueProcedure() {
425             @Override
426             public Value doValue(Value value, OperandMode mode, EnumSet&lt;OperandFlag&gt; flags) {
427                 if (isVirtualStackSlot(value)) {
428                     VirtualStackSlot slot = asVirtualStackSlot(value);
429                     StackInterval interval = get(slot);
430                     assert interval != null;
431                     return interval.location();
432                 }
433                 return value;
434             }
435         };
436 
437         // ====================
438         //
439         // ====================
440 
441         /**
442          * Gets the highest instruction id.
443          */
444         private int maxOpId() {
445             return maxOpId;
446         }
447 
448         private StackInterval get(VirtualStackSlot stackSlot) {
449             return stackSlotMap[stackSlot.getId()];
450         }
451 
452         private void dumpIntervals(String label) {
453             debug.dump(DebugContext.VERBOSE_LEVEL, new StackIntervalDumper(Arrays.copyOf(stackSlotMap, stackSlotMap.length)), label);
454         }
455 
456     }
457 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../hashing/HashFunction.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.gen;
 26 
<span class="line-removed"> 27 import java.util.BitSet;</span>
<span class="line-removed"> 28 import java.util.List;</span>
<span class="line-removed"> 29 </span>
 30 import org.graalvm.compiler.core.common.CompressEncoding;
 31 import org.graalvm.compiler.core.common.LIRKind;
 32 import org.graalvm.compiler.core.common.calc.Condition;
 33 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 34 import org.graalvm.compiler.core.common.spi.CodeGenProviders;
 35 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 37 import org.graalvm.compiler.core.common.type.Stamp;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.graph.NodeSourcePosition;
 40 import org.graalvm.compiler.lir.LIRFrameState;
 41 import org.graalvm.compiler.lir.LIRInstruction;
 42 import org.graalvm.compiler.lir.LabelRef;
 43 import org.graalvm.compiler.lir.SwitchStrategy;
 44 import org.graalvm.compiler.lir.Variable;
 45 import org.graalvm.compiler.lir.VirtualStackSlot;
 46 
 47 import jdk.vm.ci.code.CodeCacheProvider;
 48 import jdk.vm.ci.code.Register;
 49 import jdk.vm.ci.code.RegisterAttributes;
 50 import jdk.vm.ci.code.RegisterConfig;
 51 import jdk.vm.ci.code.StackSlot;
 52 import jdk.vm.ci.code.TargetDescription;
 53 import jdk.vm.ci.code.ValueKindFactory;
 54 import jdk.vm.ci.meta.AllocatableValue;
 55 import jdk.vm.ci.meta.Constant;
 56 import jdk.vm.ci.meta.JavaConstant;
 57 import jdk.vm.ci.meta.JavaKind;
 58 import jdk.vm.ci.meta.MetaAccessProvider;
 59 import jdk.vm.ci.meta.PlatformKind;
 60 import jdk.vm.ci.meta.Value;
 61 import jdk.vm.ci.meta.ValueKind;
 62 
 63 public interface LIRGeneratorTool extends DiagnosticLIRGeneratorTool, ValueKindFactory&lt;LIRKind&gt; {
 64 
 65     /**
 66      * Factory for creating moves.
 67      */
 68     interface MoveFactory {
 69 








 70         /**
 71          * Checks whether the supplied constant can be used without loading it into a register for
 72          * most operations, i.e., for commonly used arithmetic, logical, and comparison operations.
 73          *
<span class="line-modified"> 74          * @param c The constant to check.</span>
 75          * @return True if the constant can be used directly, false if the constant needs to be in a
 76          *         register.
 77          */
<span class="line-modified"> 78         boolean canInlineConstant(Constant c);</span>
 79 
 80         /**
 81          * @param constant The constant that might be moved to a stack slot.
 82          * @return {@code true} if constant to stack moves are supported for this constant.
 83          */
 84         boolean allowConstantToStackMove(Constant constant);
 85 
 86         LIRInstruction createMove(AllocatableValue result, Value input);
 87 
 88         LIRInstruction createStackMove(AllocatableValue result, AllocatableValue input);
 89 
 90         LIRInstruction createLoad(AllocatableValue result, Constant input);
 91 
 92         LIRInstruction createStackLoad(AllocatableValue result, Constant input);
 93     }
 94 
 95     abstract class BlockScope implements AutoCloseable {
 96 
 97         public abstract AbstractBlockBase&lt;?&gt; getCurrentBlock();
 98 
</pre>
<hr />
<pre>
116     AbstractBlockBase&lt;?&gt; getCurrentBlock();
117 
118     LIRGenerationResult getResult();
119 
120     RegisterConfig getRegisterConfig();
121 
122     boolean hasBlockEnd(AbstractBlockBase&lt;?&gt; block);
123 
124     MoveFactory getMoveFactory();
125 
126     /**
127      * Get a special {@link MoveFactory} for spill moves.
128      *
129      * The instructions returned by this factory must only depend on the input values. References to
130      * values that require interaction with register allocation are strictly forbidden.
131      */
132     MoveFactory getSpillMoveFactory();
133 
134     BlockScope getBlockScope(AbstractBlockBase&lt;?&gt; block);
135 




136     Value emitConstant(LIRKind kind, Constant constant);
137 
138     Value emitJavaConstant(JavaConstant constant);
139 
140     /**
141      * Some backends need to convert sub-word kinds to a larger kind in
142      * {@link ArithmeticLIRGeneratorTool#emitLoad} and {@link #emitLoadConstant} because sub-word
143      * registers can&#39;t be accessed. This method converts the {@link LIRKind} of a memory location or
144      * constant to the {@link LIRKind} that will be used when it is loaded into a register.
145      */
146     &lt;K extends ValueKind&lt;K&gt;&gt; K toRegisterKind(K kind);
147 
148     AllocatableValue emitLoadConstant(ValueKind&lt;?&gt; kind, Constant constant);
149 
150     void emitNullCheck(Value address, LIRFrameState state);
151 
152     Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue);
153 
154     Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue);
155 
</pre>
<hr />
<pre>
178     void emitDeoptimize(Value actionAndReason, Value failedSpeculation, LIRFrameState state);
179 
180     Variable emitForeignCall(ForeignCallLinkage linkage, LIRFrameState state, Value... args);
181 
182     RegisterAttributes attributes(Register register);
183 
184     /**
185      * Create a new {@link Variable}.
186      *
187      * @param kind The type of the value that will be stored in this {@link Variable}. See
188      *            {@link LIRKind} for documentation on what to pass here. Note that in most cases,
189      *            simply passing {@link Value#getValueKind()} is wrong.
190      * @return A new {@link Variable}.
191      */
192     Variable newVariable(ValueKind&lt;?&gt; kind);
193 
194     Variable emitMove(Value input);
195 
196     void emitMove(AllocatableValue dst, Value src);
197 




198     void emitMoveConstant(AllocatableValue dst, Constant src);
199 
200     Variable emitAddress(AllocatableValue stackslot);
201 
202     void emitMembar(int barriers);
203 
204     void emitUnwind(Value operand);
205 
206     /**
207      * Called just before register allocation is performed on the LIR owned by this generator.
208      * Overriding implementations of this method must call the overridden method.
209      */
210     void beforeRegisterAllocation();
211 
212     void emitIncomingValues(Value[] params);
213 
214     /**
215      * Emits a return instruction. Implementations need to insert a move if the input is not in the
216      * correct location.
217      */
</pre>
<hr />
<pre>
249 
250     void emitOverflowCheckBranch(LabelRef overflow, LabelRef noOverflow, LIRKind cmpKind, double overflowProbability);
251 
252     void emitIntegerTestBranch(Value left, Value right, LabelRef trueDestination, LabelRef falseDestination, double trueSuccessorProbability);
253 
254     Variable emitConditionalMove(PlatformKind cmpKind, Value leftVal, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue);
255 
256     Variable emitIntegerTestMove(Value leftVal, Value right, Value trueValue, Value falseValue);
257 
258     void emitStrategySwitch(JavaConstant[] keyConstants, double[] keyProbabilities, LabelRef[] keyTargets, LabelRef defaultTarget, Variable value);
259 
260     void emitStrategySwitch(SwitchStrategy strategy, Variable key, LabelRef[] keyTargets, LabelRef defaultTarget);
261 
262     Variable emitByteSwap(Value operand);
263 
264     @SuppressWarnings(&quot;unused&quot;)
265     default Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
266         throw GraalError.unimplemented(&quot;String.compareTo substitution is not implemented on this architecture&quot;);
267     }
268 
<span class="line-modified">269     Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, int constantLength, boolean directPointers);</span>



270 
271     @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">272     default Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, int constantLength, boolean directPointers) {</span>
273         throw GraalError.unimplemented(&quot;Array.equals with different types substitution is not implemented on this architecture&quot;);
274     }
275 
276     @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">277     default Variable emitArrayIndexOf(JavaKind kind, boolean findTwoConsecutive, Value sourcePointer, Value sourceCount, Value... searchValues) {</span>
278         throw GraalError.unimplemented(&quot;String.indexOf substitution is not implemented on this architecture&quot;);
279     }
280 
281     /*
282      * The routines emitStringLatin1Inflate/3 and emitStringUTF16Compress/3 models a simplified
283      * version of
284      *
285      * emitStringLatin1Inflate(Value src, Value src_ndx, Value dst, Value dst_ndx, Value len) and
286      * emitStringUTF16Compress(Value src, Value src_ndx, Value dst, Value dst_ndx, Value len)
287      *
288      * respectively, where we have hoisted the offset address computations in a method replacement
289      * snippet.
290      */
291     @SuppressWarnings(&quot;unused&quot;)
292     default void emitStringLatin1Inflate(Value src, Value dst, Value len) {
293         throw GraalError.unimplemented(&quot;StringLatin1.inflate substitution is not implemented on this architecture&quot;);
294     }
295 
296     @SuppressWarnings(&quot;unused&quot;)
297     default Variable emitStringUTF16Compress(Value src, Value dst, Value len) {
</pre>
<hr />
<pre>
307     void emitPrefetchAllocate(Value address);
308 
309     Value emitCompress(Value pointer, CompressEncoding encoding, boolean nonNull);
310 
311     Value emitUncompress(Value pointer, CompressEncoding encoding, boolean nonNull);
312 
313     default void emitConvertNullToZero(AllocatableValue result, Value input) {
314         emitMove(result, input);
315     }
316 
317     default void emitConvertZeroToNull(AllocatableValue result, Value input) {
318         emitMove(result, input);
319     }
320 
321     /**
322      * Emits an instruction that prevents speculative execution from proceeding: no instruction
323      * after this fence will execute until all previous instructions have retired.
324      */
325     void emitSpeculationFence();
326 
<span class="line-modified">327     default VirtualStackSlot allocateStackSlots(int slots, BitSet objects, List&lt;VirtualStackSlot&gt; outObjectStackSlots) {</span>
<span class="line-modified">328         return getResult().getFrameMapBuilder().allocateStackSlots(slots, objects, outObjectStackSlots);</span>
329     }
330 
331     default Value emitReadCallerStackPointer(Stamp wordStamp) {
332         /*
333          * We do not know the frame size yet. So we load the address of the first spill slot
334          * relative to the beginning of the frame, which is equivalent to the stack pointer of the
335          * caller.
336          */
337         return emitAddress(StackSlot.get(getLIRKind(wordStamp), 0, true));
338     }
339 
340     default Value emitReadReturnAddress(Stamp wordStamp, int returnAddressSize) {
341         return emitMove(StackSlot.get(getLIRKind(wordStamp), -returnAddressSize, true));
342     }





343 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.gen;
 26 



 27 import org.graalvm.compiler.core.common.CompressEncoding;
 28 import org.graalvm.compiler.core.common.LIRKind;
 29 import org.graalvm.compiler.core.common.calc.Condition;
 30 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 31 import org.graalvm.compiler.core.common.spi.CodeGenProviders;
 32 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 33 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 34 import org.graalvm.compiler.core.common.type.Stamp;
 35 import org.graalvm.compiler.debug.GraalError;
 36 import org.graalvm.compiler.graph.NodeSourcePosition;
 37 import org.graalvm.compiler.lir.LIRFrameState;
 38 import org.graalvm.compiler.lir.LIRInstruction;
 39 import org.graalvm.compiler.lir.LabelRef;
 40 import org.graalvm.compiler.lir.SwitchStrategy;
 41 import org.graalvm.compiler.lir.Variable;
 42 import org.graalvm.compiler.lir.VirtualStackSlot;
 43 
 44 import jdk.vm.ci.code.CodeCacheProvider;
 45 import jdk.vm.ci.code.Register;
 46 import jdk.vm.ci.code.RegisterAttributes;
 47 import jdk.vm.ci.code.RegisterConfig;
 48 import jdk.vm.ci.code.StackSlot;
 49 import jdk.vm.ci.code.TargetDescription;
 50 import jdk.vm.ci.code.ValueKindFactory;
 51 import jdk.vm.ci.meta.AllocatableValue;
 52 import jdk.vm.ci.meta.Constant;
 53 import jdk.vm.ci.meta.JavaConstant;
 54 import jdk.vm.ci.meta.JavaKind;
 55 import jdk.vm.ci.meta.MetaAccessProvider;
 56 import jdk.vm.ci.meta.PlatformKind;
 57 import jdk.vm.ci.meta.Value;
 58 import jdk.vm.ci.meta.ValueKind;
 59 
 60 public interface LIRGeneratorTool extends DiagnosticLIRGeneratorTool, ValueKindFactory&lt;LIRKind&gt; {
 61 
 62     /**
 63      * Factory for creating moves.
 64      */
 65     interface MoveFactory {
 66 
<span class="line-added"> 67         /**</span>
<span class="line-added"> 68          * Checks whether the loading of the supplied constant can be deferred until usage.</span>
<span class="line-added"> 69          */</span>
<span class="line-added"> 70         @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added"> 71         default boolean mayEmbedConstantLoad(Constant constant) {</span>
<span class="line-added"> 72             return false;</span>
<span class="line-added"> 73         }</span>
<span class="line-added"> 74 </span>
 75         /**
 76          * Checks whether the supplied constant can be used without loading it into a register for
 77          * most operations, i.e., for commonly used arithmetic, logical, and comparison operations.
 78          *
<span class="line-modified"> 79          * @param constant The constant to check.</span>
 80          * @return True if the constant can be used directly, false if the constant needs to be in a
 81          *         register.
 82          */
<span class="line-modified"> 83         boolean canInlineConstant(Constant constant);</span>
 84 
 85         /**
 86          * @param constant The constant that might be moved to a stack slot.
 87          * @return {@code true} if constant to stack moves are supported for this constant.
 88          */
 89         boolean allowConstantToStackMove(Constant constant);
 90 
 91         LIRInstruction createMove(AllocatableValue result, Value input);
 92 
 93         LIRInstruction createStackMove(AllocatableValue result, AllocatableValue input);
 94 
 95         LIRInstruction createLoad(AllocatableValue result, Constant input);
 96 
 97         LIRInstruction createStackLoad(AllocatableValue result, Constant input);
 98     }
 99 
100     abstract class BlockScope implements AutoCloseable {
101 
102         public abstract AbstractBlockBase&lt;?&gt; getCurrentBlock();
103 
</pre>
<hr />
<pre>
121     AbstractBlockBase&lt;?&gt; getCurrentBlock();
122 
123     LIRGenerationResult getResult();
124 
125     RegisterConfig getRegisterConfig();
126 
127     boolean hasBlockEnd(AbstractBlockBase&lt;?&gt; block);
128 
129     MoveFactory getMoveFactory();
130 
131     /**
132      * Get a special {@link MoveFactory} for spill moves.
133      *
134      * The instructions returned by this factory must only depend on the input values. References to
135      * values that require interaction with register allocation are strictly forbidden.
136      */
137     MoveFactory getSpillMoveFactory();
138 
139     BlockScope getBlockScope(AbstractBlockBase&lt;?&gt; block);
140 
<span class="line-added">141     boolean canInlineConstant(Constant constant);</span>
<span class="line-added">142 </span>
<span class="line-added">143     boolean mayEmbedConstantLoad(Constant constant);</span>
<span class="line-added">144 </span>
145     Value emitConstant(LIRKind kind, Constant constant);
146 
147     Value emitJavaConstant(JavaConstant constant);
148 
149     /**
150      * Some backends need to convert sub-word kinds to a larger kind in
151      * {@link ArithmeticLIRGeneratorTool#emitLoad} and {@link #emitLoadConstant} because sub-word
152      * registers can&#39;t be accessed. This method converts the {@link LIRKind} of a memory location or
153      * constant to the {@link LIRKind} that will be used when it is loaded into a register.
154      */
155     &lt;K extends ValueKind&lt;K&gt;&gt; K toRegisterKind(K kind);
156 
157     AllocatableValue emitLoadConstant(ValueKind&lt;?&gt; kind, Constant constant);
158 
159     void emitNullCheck(Value address, LIRFrameState state);
160 
161     Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue);
162 
163     Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue);
164 
</pre>
<hr />
<pre>
187     void emitDeoptimize(Value actionAndReason, Value failedSpeculation, LIRFrameState state);
188 
189     Variable emitForeignCall(ForeignCallLinkage linkage, LIRFrameState state, Value... args);
190 
191     RegisterAttributes attributes(Register register);
192 
193     /**
194      * Create a new {@link Variable}.
195      *
196      * @param kind The type of the value that will be stored in this {@link Variable}. See
197      *            {@link LIRKind} for documentation on what to pass here. Note that in most cases,
198      *            simply passing {@link Value#getValueKind()} is wrong.
199      * @return A new {@link Variable}.
200      */
201     Variable newVariable(ValueKind&lt;?&gt; kind);
202 
203     Variable emitMove(Value input);
204 
205     void emitMove(AllocatableValue dst, Value src);
206 
<span class="line-added">207     Variable emitReadRegister(Register register, ValueKind&lt;?&gt; kind);</span>
<span class="line-added">208 </span>
<span class="line-added">209     void emitWriteRegister(Register dst, Value src, ValueKind&lt;?&gt; wordStamp);</span>
<span class="line-added">210 </span>
211     void emitMoveConstant(AllocatableValue dst, Constant src);
212 
213     Variable emitAddress(AllocatableValue stackslot);
214 
215     void emitMembar(int barriers);
216 
217     void emitUnwind(Value operand);
218 
219     /**
220      * Called just before register allocation is performed on the LIR owned by this generator.
221      * Overriding implementations of this method must call the overridden method.
222      */
223     void beforeRegisterAllocation();
224 
225     void emitIncomingValues(Value[] params);
226 
227     /**
228      * Emits a return instruction. Implementations need to insert a move if the input is not in the
229      * correct location.
230      */
</pre>
<hr />
<pre>
262 
263     void emitOverflowCheckBranch(LabelRef overflow, LabelRef noOverflow, LIRKind cmpKind, double overflowProbability);
264 
265     void emitIntegerTestBranch(Value left, Value right, LabelRef trueDestination, LabelRef falseDestination, double trueSuccessorProbability);
266 
267     Variable emitConditionalMove(PlatformKind cmpKind, Value leftVal, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue);
268 
269     Variable emitIntegerTestMove(Value leftVal, Value right, Value trueValue, Value falseValue);
270 
271     void emitStrategySwitch(JavaConstant[] keyConstants, double[] keyProbabilities, LabelRef[] keyTargets, LabelRef defaultTarget, Variable value);
272 
273     void emitStrategySwitch(SwitchStrategy strategy, Variable key, LabelRef[] keyTargets, LabelRef defaultTarget);
274 
275     Variable emitByteSwap(Value operand);
276 
277     @SuppressWarnings(&quot;unused&quot;)
278     default Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
279         throw GraalError.unimplemented(&quot;String.compareTo substitution is not implemented on this architecture&quot;);
280     }
281 
<span class="line-modified">282     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">283     default Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {</span>
<span class="line-added">284         throw GraalError.unimplemented(&quot;Array.equals substitution is not implemented on this architecture&quot;);</span>
<span class="line-added">285     }</span>
286 
287     @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">288     default Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, boolean directPointers) {</span>
289         throw GraalError.unimplemented(&quot;Array.equals with different types substitution is not implemented on this architecture&quot;);
290     }
291 
292     @SuppressWarnings(&quot;unused&quot;)
<span class="line-modified">293     default Variable emitArrayIndexOf(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, Value sourcePointer, Value sourceCount, Value fromIndex, Value... searchValues) {</span>
294         throw GraalError.unimplemented(&quot;String.indexOf substitution is not implemented on this architecture&quot;);
295     }
296 
297     /*
298      * The routines emitStringLatin1Inflate/3 and emitStringUTF16Compress/3 models a simplified
299      * version of
300      *
301      * emitStringLatin1Inflate(Value src, Value src_ndx, Value dst, Value dst_ndx, Value len) and
302      * emitStringUTF16Compress(Value src, Value src_ndx, Value dst, Value dst_ndx, Value len)
303      *
304      * respectively, where we have hoisted the offset address computations in a method replacement
305      * snippet.
306      */
307     @SuppressWarnings(&quot;unused&quot;)
308     default void emitStringLatin1Inflate(Value src, Value dst, Value len) {
309         throw GraalError.unimplemented(&quot;StringLatin1.inflate substitution is not implemented on this architecture&quot;);
310     }
311 
312     @SuppressWarnings(&quot;unused&quot;)
313     default Variable emitStringUTF16Compress(Value src, Value dst, Value len) {
</pre>
<hr />
<pre>
323     void emitPrefetchAllocate(Value address);
324 
325     Value emitCompress(Value pointer, CompressEncoding encoding, boolean nonNull);
326 
327     Value emitUncompress(Value pointer, CompressEncoding encoding, boolean nonNull);
328 
329     default void emitConvertNullToZero(AllocatableValue result, Value input) {
330         emitMove(result, input);
331     }
332 
333     default void emitConvertZeroToNull(AllocatableValue result, Value input) {
334         emitMove(result, input);
335     }
336 
337     /**
338      * Emits an instruction that prevents speculative execution from proceeding: no instruction
339      * after this fence will execute until all previous instructions have retired.
340      */
341     void emitSpeculationFence();
342 
<span class="line-modified">343     default VirtualStackSlot allocateStackSlots(int slots) {</span>
<span class="line-modified">344         return getResult().getFrameMapBuilder().allocateStackSlots(slots);</span>
345     }
346 
347     default Value emitReadCallerStackPointer(Stamp wordStamp) {
348         /*
349          * We do not know the frame size yet. So we load the address of the first spill slot
350          * relative to the beginning of the frame, which is equivalent to the stack pointer of the
351          * caller.
352          */
353         return emitAddress(StackSlot.get(getLIRKind(wordStamp), 0, true));
354     }
355 
356     default Value emitReadReturnAddress(Stamp wordStamp, int returnAddressSize) {
357         return emitMove(StackSlot.get(getLIRKind(wordStamp), -returnAddressSize, true));
358     }
<span class="line-added">359 </span>
<span class="line-added">360     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="line-added">361     default void emitZeroMemory(Value address, Value length, boolean isAligned) {</span>
<span class="line-added">362         throw GraalError.unimplemented(&quot;Bulk zeroing is not implemented on this architecture&quot;);</span>
<span class="line-added">363     }</span>
364 }
</pre>
</td>
</tr>
</table>
<center><a href="LIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../hashing/HashFunction.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
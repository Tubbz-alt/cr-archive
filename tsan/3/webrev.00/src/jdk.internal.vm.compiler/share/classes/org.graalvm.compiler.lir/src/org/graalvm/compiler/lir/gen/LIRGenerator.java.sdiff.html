<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LIRGenerationResult.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRGeneratorTool.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 import static jdk.vm.ci.code.ValueUtil.isLegal;
 30 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 31 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 32 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 33 import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;
 34 import static org.graalvm.compiler.lir.LIRValueUtil.isVirtualStackSlot;
 35 
 36 import java.util.ArrayList;
 37 import java.util.List;
 38 import java.util.Optional;
 39 
 40 import org.graalvm.compiler.asm.Label;
 41 import org.graalvm.compiler.core.common.LIRKind;
 42 import org.graalvm.compiler.core.common.calc.Condition;
 43 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 44 import org.graalvm.compiler.core.common.spi.CodeGenProviders;
 45 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 46 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 47 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 48 import org.graalvm.compiler.core.common.type.Stamp;

 49 import org.graalvm.compiler.debug.GraalError;
 50 import org.graalvm.compiler.debug.TTY;
 51 import org.graalvm.compiler.graph.NodeSourcePosition;
 52 import org.graalvm.compiler.lir.ConstantValue;
 53 import org.graalvm.compiler.lir.LIR;
 54 import org.graalvm.compiler.lir.LIRFrameState;
 55 import org.graalvm.compiler.lir.LIRInstruction;
 56 import org.graalvm.compiler.lir.LIRVerifier;
 57 import org.graalvm.compiler.lir.LabelRef;
 58 import org.graalvm.compiler.lir.StandardOp;
 59 import org.graalvm.compiler.lir.StandardOp.BlockEndOp;
 60 import org.graalvm.compiler.lir.StandardOp.LabelOp;
<span class="line-modified"> 61 import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>
<span class="line-removed"> 62 import org.graalvm.compiler.lir.hashing.Hasher;</span>
 63 import org.graalvm.compiler.lir.SwitchStrategy;
 64 import org.graalvm.compiler.lir.Variable;

 65 import org.graalvm.compiler.options.Option;
 66 import org.graalvm.compiler.options.OptionKey;
 67 import org.graalvm.compiler.options.OptionType;
 68 import org.graalvm.compiler.options.OptionValues;
 69 
 70 import jdk.vm.ci.code.CallingConvention;
 71 import jdk.vm.ci.code.CodeCacheProvider;
 72 import jdk.vm.ci.code.Register;
 73 import jdk.vm.ci.code.RegisterAttributes;
 74 import jdk.vm.ci.code.RegisterConfig;
 75 import jdk.vm.ci.code.StackSlot;
 76 import jdk.vm.ci.code.TargetDescription;
 77 import jdk.vm.ci.meta.AllocatableValue;
 78 import jdk.vm.ci.meta.Constant;
 79 import jdk.vm.ci.meta.JavaConstant;
 80 import jdk.vm.ci.meta.JavaKind;
 81 import jdk.vm.ci.meta.MetaAccessProvider;
 82 import jdk.vm.ci.meta.PlatformKind;
 83 import jdk.vm.ci.meta.Value;
 84 import jdk.vm.ci.meta.ValueKind;
</pre>
<hr />
<pre>
211     }
212 
213     @Override
214     public RegisterAttributes attributes(Register register) {
215         return getRegisterConfig().getAttributesMap()[register.number];
216     }
217 
218     @Override
219     public Variable emitMove(Value input) {
220         assert !(input instanceof Variable) : &quot;Creating a copy of a variable via this method is not supported (and potentially a bug): &quot; + input;
221         Variable result = newVariable(input.getValueKind());
222         emitMove(result, input);
223         return result;
224     }
225 
226     @Override
227     public void emitMove(AllocatableValue dst, Value src) {
228         append(moveFactory.createMove(dst, src));
229     }
230 










231     @Override
232     public void emitMoveConstant(AllocatableValue dst, Constant src) {
233         append(moveFactory.createLoad(dst, src));
234     }
235 










236     @Override
237     public Value emitConstant(LIRKind kind, Constant constant) {
238         if (moveFactory.canInlineConstant(constant)) {
239             return new ConstantValue(toRegisterKind(kind), constant);
240         } else {
241             return emitLoadConstant(toRegisterKind(kind), constant);
242         }
243     }
244 
245     @Override
246     public Value emitJavaConstant(JavaConstant constant) {
247         return emitConstant(getValueKind(constant.getJavaKind()), constant);
248     }
249 
250     @Override
251     public AllocatableValue emitLoadConstant(ValueKind&lt;?&gt; kind, Constant constant) {
252         Variable result = newVariable(kind);
253         emitMoveConstant(result, constant);
254         return result;
255     }
</pre>
<hr />
<pre>
369 
370         @Override
371         public AbstractBlockBase&lt;?&gt; getCurrentBlock() {
372             return currentBlock;
373         }
374 
375         @Override
376         public void close() {
377             doBlockEnd();
378         }
379 
380     }
381 
382     @Override
383     public final BlockScope getBlockScope(AbstractBlockBase&lt;?&gt; block) {
384         BlockScopeImpl blockScope = new BlockScopeImpl(block);
385         blockScope.doBlockStart();
386         return blockScope;
387     }
388 


















389     @Override
390     public void emitIncomingValues(Value[] params) {
391         ((LabelOp) res.getLIR().getLIRforBlock(getCurrentBlock()).get(0)).setIncomingValues(params);
392     }
393 
394     @Override
395     public abstract void emitJump(LabelRef label);
396 
397     @Override
398     public abstract void emitCompareBranch(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination,
399                     double trueDestinationProbability);
400 
401     @Override
402     public abstract void emitOverflowCheckBranch(LabelRef overflow, LabelRef noOverflow, LIRKind cmpKind, double overflowProbability);
403 
404     @Override
405     public abstract void emitIntegerTestBranch(Value left, Value right, LabelRef trueDestination, LabelRef falseDestination, double trueSuccessorProbability);
406 
407     @Override
408     public abstract Variable emitConditionalMove(PlatformKind cmpKind, Value leftVal, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue);
</pre>
<hr />
<pre>
440             argLocations[i] = loc;
441         }
442         res.setForeignCall(true);
443         emitForeignCallOp(linkage, linkageCc.getReturn(), argLocations, linkage.getTemporaries(), state);
444 
445         if (isLegal(linkageCc.getReturn())) {
446             return emitMove(linkageCc.getReturn());
447         } else {
448             return null;
449         }
450     }
451 
452     @Override
453     public void emitStrategySwitch(JavaConstant[] keyConstants, double[] keyProbabilities, LabelRef[] keyTargets, LabelRef defaultTarget, Variable value) {
454         SwitchStrategy strategy = SwitchStrategy.getBestStrategy(keyProbabilities, keyConstants, keyTargets);
455 
456         int keyCount = keyConstants.length;
457         double minDensity = 1 / Math.sqrt(strategy.getAverageEffort());
458         Optional&lt;Hasher&gt; hasher = hasherFor(keyConstants, minDensity);
459         double hashTableSwitchDensity = hasher.map(h -&gt; keyCount / (double) h.cardinality()).orElse(0d);
<span class="line-modified">460         long valueRange = keyConstants[keyCount - 1].asLong() - keyConstants[0].asLong() + 1;</span>

461         double tableSwitchDensity = keyCount / (double) valueRange;
462 
463         /*
464          * This heuristic tries to find a compromise between the effort for the best switch strategy
465          * and the density of a tableswitch. If the effort for the strategy is at least 4, then a
466          * tableswitch is preferred if better than a certain value that starts at 0.5 and lowers
467          * gradually with additional effort.
468          */
469         if (strategy.getAverageEffort() &lt; 4d || (tableSwitchDensity &lt; minDensity &amp;&amp; hashTableSwitchDensity &lt; minDensity)) {
470             emitStrategySwitch(strategy, value, keyTargets, defaultTarget);
471         } else {
472             if (hashTableSwitchDensity &gt; tableSwitchDensity) {
473                 Hasher h = hasher.get();
474                 int cardinality = h.cardinality();
475                 LabelRef[] targets = new LabelRef[cardinality];
476                 JavaConstant[] keys = new JavaConstant[cardinality];
477                 for (int i = 0; i &lt; cardinality; i++) {
478                     keys[i] = JavaConstant.INT_0;
479                     targets[i] = defaultTarget;
480                 }
481                 for (int i = 0; i &lt; keyCount; i++) {
<span class="line-modified">482                     int idx = h.hash(keyConstants[i].asLong());</span>
483                     keys[idx] = keyConstants[i];
484                     targets[idx] = keyTargets[i];
485                 }
486                 emitHashTableSwitch(h, keys, defaultTarget, targets, value);
487             } else {
488                 int minValue = keyConstants[0].asInt();
489                 assert valueRange &lt; Integer.MAX_VALUE;
490                 LabelRef[] targets = new LabelRef[(int) valueRange];
491                 for (int i = 0; i &lt; valueRange; i++) {
492                     targets[i] = defaultTarget;
493                 }
494                 for (int i = 0; i &lt; keyCount; i++) {
495                     targets[keyConstants[i].asInt() - minValue] = keyTargets[i];
496                 }
497                 emitTableSwitch(minValue, defaultTarget, targets, value);
498             }
499         }
500     }
501 
502     @Override
</pre>
<hr />
<pre>
547     public LIRGenerationResult getResult() {
548         return res;
549     }
550 
551     @Override
552     public void emitBlackhole(Value operand) {
553         append(new StandardOp.BlackholeOp(operand));
554     }
555 
556     @Override
557     public LIRInstruction createBenchmarkCounter(String name, String group, Value increment) {
558         throw GraalError.unimplemented();
559     }
560 
561     @Override
562     public LIRInstruction createMultiBenchmarkCounter(String[] names, String[] groups, Value[] increments) {
563         throw GraalError.unimplemented();
564     }
565 
566     @Override
<span class="line-modified">567     public abstract SaveRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues);</span>
568 
569     @Override
<span class="line-modified">570     public SaveRegistersOp createZapRegisters() {</span>
571         Register[] zappedRegisters = getResult().getFrameMap().getRegisterConfig().getAllocatableRegisters().toArray();





572         JavaConstant[] zapValues = new JavaConstant[zappedRegisters.length];
573         for (int i = 0; i &lt; zappedRegisters.length; i++) {
574             PlatformKind kind = target().arch.getLargestStorableKind(zappedRegisters[i].getRegisterCategory());
575             zapValues[i] = zapValueForKind(kind);
576         }
577         return createZapRegisters(zappedRegisters, zapValues);
578     }
579 
580     @Override
581     public abstract LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues);
582 
583     @Override
584     public LIRInstruction zapArgumentSpace() {
585         List&lt;StackSlot&gt; slots = null;
586         for (AllocatableValue arg : res.getCallingConvention().getArguments()) {
587             if (isStackSlot(arg)) {
588                 if (slots == null) {
589                     slots = new ArrayList&lt;&gt;();
590                 }
591                 slots.add((StackSlot) arg);
</pre>
</td>
<td>
<hr />
<pre>
 29 import static jdk.vm.ci.code.ValueUtil.isLegal;
 30 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 31 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 32 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 33 import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;
 34 import static org.graalvm.compiler.lir.LIRValueUtil.isVirtualStackSlot;
 35 
 36 import java.util.ArrayList;
 37 import java.util.List;
 38 import java.util.Optional;
 39 
 40 import org.graalvm.compiler.asm.Label;
 41 import org.graalvm.compiler.core.common.LIRKind;
 42 import org.graalvm.compiler.core.common.calc.Condition;
 43 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 44 import org.graalvm.compiler.core.common.spi.CodeGenProviders;
 45 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 46 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 47 import org.graalvm.compiler.core.common.spi.LIRKindTool;
 48 import org.graalvm.compiler.core.common.type.Stamp;
<span class="line-added"> 49 import org.graalvm.compiler.debug.DebugCloseable;</span>
 50 import org.graalvm.compiler.debug.GraalError;
 51 import org.graalvm.compiler.debug.TTY;
 52 import org.graalvm.compiler.graph.NodeSourcePosition;
 53 import org.graalvm.compiler.lir.ConstantValue;
 54 import org.graalvm.compiler.lir.LIR;
 55 import org.graalvm.compiler.lir.LIRFrameState;
 56 import org.graalvm.compiler.lir.LIRInstruction;
 57 import org.graalvm.compiler.lir.LIRVerifier;
 58 import org.graalvm.compiler.lir.LabelRef;
 59 import org.graalvm.compiler.lir.StandardOp;
 60 import org.graalvm.compiler.lir.StandardOp.BlockEndOp;
 61 import org.graalvm.compiler.lir.StandardOp.LabelOp;
<span class="line-modified"> 62 import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;</span>

 63 import org.graalvm.compiler.lir.SwitchStrategy;
 64 import org.graalvm.compiler.lir.Variable;
<span class="line-added"> 65 import org.graalvm.compiler.lir.hashing.Hasher;</span>
 66 import org.graalvm.compiler.options.Option;
 67 import org.graalvm.compiler.options.OptionKey;
 68 import org.graalvm.compiler.options.OptionType;
 69 import org.graalvm.compiler.options.OptionValues;
 70 
 71 import jdk.vm.ci.code.CallingConvention;
 72 import jdk.vm.ci.code.CodeCacheProvider;
 73 import jdk.vm.ci.code.Register;
 74 import jdk.vm.ci.code.RegisterAttributes;
 75 import jdk.vm.ci.code.RegisterConfig;
 76 import jdk.vm.ci.code.StackSlot;
 77 import jdk.vm.ci.code.TargetDescription;
 78 import jdk.vm.ci.meta.AllocatableValue;
 79 import jdk.vm.ci.meta.Constant;
 80 import jdk.vm.ci.meta.JavaConstant;
 81 import jdk.vm.ci.meta.JavaKind;
 82 import jdk.vm.ci.meta.MetaAccessProvider;
 83 import jdk.vm.ci.meta.PlatformKind;
 84 import jdk.vm.ci.meta.Value;
 85 import jdk.vm.ci.meta.ValueKind;
</pre>
<hr />
<pre>
212     }
213 
214     @Override
215     public RegisterAttributes attributes(Register register) {
216         return getRegisterConfig().getAttributesMap()[register.number];
217     }
218 
219     @Override
220     public Variable emitMove(Value input) {
221         assert !(input instanceof Variable) : &quot;Creating a copy of a variable via this method is not supported (and potentially a bug): &quot; + input;
222         Variable result = newVariable(input.getValueKind());
223         emitMove(result, input);
224         return result;
225     }
226 
227     @Override
228     public void emitMove(AllocatableValue dst, Value src) {
229         append(moveFactory.createMove(dst, src));
230     }
231 
<span class="line-added">232     @Override</span>
<span class="line-added">233     public Variable emitReadRegister(Register register, ValueKind&lt;?&gt; kind) {</span>
<span class="line-added">234         return emitMove(register.asValue(kind));</span>
<span class="line-added">235     }</span>
<span class="line-added">236 </span>
<span class="line-added">237     @Override</span>
<span class="line-added">238     public void emitWriteRegister(Register dst, Value src, ValueKind&lt;?&gt; kind) {</span>
<span class="line-added">239         emitMove(dst.asValue(kind), src);</span>
<span class="line-added">240     }</span>
<span class="line-added">241 </span>
242     @Override
243     public void emitMoveConstant(AllocatableValue dst, Constant src) {
244         append(moveFactory.createLoad(dst, src));
245     }
246 
<span class="line-added">247     @Override</span>
<span class="line-added">248     public boolean canInlineConstant(Constant constant) {</span>
<span class="line-added">249         return moveFactory.canInlineConstant(constant);</span>
<span class="line-added">250     }</span>
<span class="line-added">251 </span>
<span class="line-added">252     @Override</span>
<span class="line-added">253     public boolean mayEmbedConstantLoad(Constant constant) {</span>
<span class="line-added">254         return moveFactory.mayEmbedConstantLoad(constant);</span>
<span class="line-added">255     }</span>
<span class="line-added">256 </span>
257     @Override
258     public Value emitConstant(LIRKind kind, Constant constant) {
259         if (moveFactory.canInlineConstant(constant)) {
260             return new ConstantValue(toRegisterKind(kind), constant);
261         } else {
262             return emitLoadConstant(toRegisterKind(kind), constant);
263         }
264     }
265 
266     @Override
267     public Value emitJavaConstant(JavaConstant constant) {
268         return emitConstant(getValueKind(constant.getJavaKind()), constant);
269     }
270 
271     @Override
272     public AllocatableValue emitLoadConstant(ValueKind&lt;?&gt; kind, Constant constant) {
273         Variable result = newVariable(kind);
274         emitMoveConstant(result, constant);
275         return result;
276     }
</pre>
<hr />
<pre>
390 
391         @Override
392         public AbstractBlockBase&lt;?&gt; getCurrentBlock() {
393             return currentBlock;
394         }
395 
396         @Override
397         public void close() {
398             doBlockEnd();
399         }
400 
401     }
402 
403     @Override
404     public final BlockScope getBlockScope(AbstractBlockBase&lt;?&gt; block) {
405         BlockScopeImpl blockScope = new BlockScopeImpl(block);
406         blockScope.doBlockStart();
407         return blockScope;
408     }
409 
<span class="line-added">410     private final class MatchScope implements DebugCloseable {</span>
<span class="line-added">411 </span>
<span class="line-added">412         private MatchScope(AbstractBlockBase&lt;?&gt; block) {</span>
<span class="line-added">413             currentBlock = block;</span>
<span class="line-added">414         }</span>
<span class="line-added">415 </span>
<span class="line-added">416         @Override</span>
<span class="line-added">417         public void close() {</span>
<span class="line-added">418             currentBlock = null;</span>
<span class="line-added">419         }</span>
<span class="line-added">420 </span>
<span class="line-added">421     }</span>
<span class="line-added">422 </span>
<span class="line-added">423     public final DebugCloseable getMatchScope(AbstractBlockBase&lt;?&gt; block) {</span>
<span class="line-added">424         MatchScope matchScope = new MatchScope(block);</span>
<span class="line-added">425         return matchScope;</span>
<span class="line-added">426     }</span>
<span class="line-added">427 </span>
428     @Override
429     public void emitIncomingValues(Value[] params) {
430         ((LabelOp) res.getLIR().getLIRforBlock(getCurrentBlock()).get(0)).setIncomingValues(params);
431     }
432 
433     @Override
434     public abstract void emitJump(LabelRef label);
435 
436     @Override
437     public abstract void emitCompareBranch(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination,
438                     double trueDestinationProbability);
439 
440     @Override
441     public abstract void emitOverflowCheckBranch(LabelRef overflow, LabelRef noOverflow, LIRKind cmpKind, double overflowProbability);
442 
443     @Override
444     public abstract void emitIntegerTestBranch(Value left, Value right, LabelRef trueDestination, LabelRef falseDestination, double trueSuccessorProbability);
445 
446     @Override
447     public abstract Variable emitConditionalMove(PlatformKind cmpKind, Value leftVal, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue);
</pre>
<hr />
<pre>
479             argLocations[i] = loc;
480         }
481         res.setForeignCall(true);
482         emitForeignCallOp(linkage, linkageCc.getReturn(), argLocations, linkage.getTemporaries(), state);
483 
484         if (isLegal(linkageCc.getReturn())) {
485             return emitMove(linkageCc.getReturn());
486         } else {
487             return null;
488         }
489     }
490 
491     @Override
492     public void emitStrategySwitch(JavaConstant[] keyConstants, double[] keyProbabilities, LabelRef[] keyTargets, LabelRef defaultTarget, Variable value) {
493         SwitchStrategy strategy = SwitchStrategy.getBestStrategy(keyProbabilities, keyConstants, keyTargets);
494 
495         int keyCount = keyConstants.length;
496         double minDensity = 1 / Math.sqrt(strategy.getAverageEffort());
497         Optional&lt;Hasher&gt; hasher = hasherFor(keyConstants, minDensity);
498         double hashTableSwitchDensity = hasher.map(h -&gt; keyCount / (double) h.cardinality()).orElse(0d);
<span class="line-modified">499         // The value range computation below may overflow, so compute it as a long.</span>
<span class="line-added">500         long valueRange = (long) keyConstants[keyCount - 1].asInt() - (long) keyConstants[0].asInt() + 1;</span>
501         double tableSwitchDensity = keyCount / (double) valueRange;
502 
503         /*
504          * This heuristic tries to find a compromise between the effort for the best switch strategy
505          * and the density of a tableswitch. If the effort for the strategy is at least 4, then a
506          * tableswitch is preferred if better than a certain value that starts at 0.5 and lowers
507          * gradually with additional effort.
508          */
509         if (strategy.getAverageEffort() &lt; 4d || (tableSwitchDensity &lt; minDensity &amp;&amp; hashTableSwitchDensity &lt; minDensity)) {
510             emitStrategySwitch(strategy, value, keyTargets, defaultTarget);
511         } else {
512             if (hashTableSwitchDensity &gt; tableSwitchDensity) {
513                 Hasher h = hasher.get();
514                 int cardinality = h.cardinality();
515                 LabelRef[] targets = new LabelRef[cardinality];
516                 JavaConstant[] keys = new JavaConstant[cardinality];
517                 for (int i = 0; i &lt; cardinality; i++) {
518                     keys[i] = JavaConstant.INT_0;
519                     targets[i] = defaultTarget;
520                 }
521                 for (int i = 0; i &lt; keyCount; i++) {
<span class="line-modified">522                     int idx = h.hash(keyConstants[i].asInt());</span>
523                     keys[idx] = keyConstants[i];
524                     targets[idx] = keyTargets[i];
525                 }
526                 emitHashTableSwitch(h, keys, defaultTarget, targets, value);
527             } else {
528                 int minValue = keyConstants[0].asInt();
529                 assert valueRange &lt; Integer.MAX_VALUE;
530                 LabelRef[] targets = new LabelRef[(int) valueRange];
531                 for (int i = 0; i &lt; valueRange; i++) {
532                     targets[i] = defaultTarget;
533                 }
534                 for (int i = 0; i &lt; keyCount; i++) {
535                     targets[keyConstants[i].asInt() - minValue] = keyTargets[i];
536                 }
537                 emitTableSwitch(minValue, defaultTarget, targets, value);
538             }
539         }
540     }
541 
542     @Override
</pre>
<hr />
<pre>
587     public LIRGenerationResult getResult() {
588         return res;
589     }
590 
591     @Override
592     public void emitBlackhole(Value operand) {
593         append(new StandardOp.BlackholeOp(operand));
594     }
595 
596     @Override
597     public LIRInstruction createBenchmarkCounter(String name, String group, Value increment) {
598         throw GraalError.unimplemented();
599     }
600 
601     @Override
602     public LIRInstruction createMultiBenchmarkCounter(String[] names, String[] groups, Value[] increments) {
603         throw GraalError.unimplemented();
604     }
605 
606     @Override
<span class="line-modified">607     public abstract ZapRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues);</span>
608 
609     @Override
<span class="line-modified">610     public ZapRegistersOp createZapRegisters() {</span>
611         Register[] zappedRegisters = getResult().getFrameMap().getRegisterConfig().getAllocatableRegisters().toArray();
<span class="line-added">612         return createZapRegisters(zappedRegisters);</span>
<span class="line-added">613     }</span>
<span class="line-added">614 </span>
<span class="line-added">615     @Override</span>
<span class="line-added">616     public ZapRegistersOp createZapRegisters(Register[] zappedRegisters) {</span>
617         JavaConstant[] zapValues = new JavaConstant[zappedRegisters.length];
618         for (int i = 0; i &lt; zappedRegisters.length; i++) {
619             PlatformKind kind = target().arch.getLargestStorableKind(zappedRegisters[i].getRegisterCategory());
620             zapValues[i] = zapValueForKind(kind);
621         }
622         return createZapRegisters(zappedRegisters, zapValues);
623     }
624 
625     @Override
626     public abstract LIRInstruction createZapArgumentSpace(StackSlot[] zappedStack, JavaConstant[] zapValues);
627 
628     @Override
629     public LIRInstruction zapArgumentSpace() {
630         List&lt;StackSlot&gt; slots = null;
631         for (AllocatableValue arg : res.getCallingConvention().getArguments()) {
632             if (isStackSlot(arg)) {
633                 if (slots == null) {
634                     slots = new ArrayList&lt;&gt;();
635                 }
636                 slots.add((StackSlot) arg);
</pre>
</td>
</tr>
</table>
<center><a href="LIRGenerationResult.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRGeneratorTool.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
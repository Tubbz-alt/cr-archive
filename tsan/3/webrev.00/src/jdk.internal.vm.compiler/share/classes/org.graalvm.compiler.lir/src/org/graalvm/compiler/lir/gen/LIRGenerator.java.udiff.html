<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LIRGenerationResult.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRGeneratorTool.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -44,10 +44,11 @@</span>
  import org.graalvm.compiler.core.common.spi.CodeGenProviders;
  import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
  import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
  import org.graalvm.compiler.core.common.spi.LIRKindTool;
  import org.graalvm.compiler.core.common.type.Stamp;
<span class="udiff-line-added">+ import org.graalvm.compiler.debug.DebugCloseable;</span>
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.debug.TTY;
  import org.graalvm.compiler.graph.NodeSourcePosition;
  import org.graalvm.compiler.lir.ConstantValue;
  import org.graalvm.compiler.lir.LIR;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56,14 +57,14 @@</span>
  import org.graalvm.compiler.lir.LIRVerifier;
  import org.graalvm.compiler.lir.LabelRef;
  import org.graalvm.compiler.lir.StandardOp;
  import org.graalvm.compiler.lir.StandardOp.BlockEndOp;
  import org.graalvm.compiler.lir.StandardOp.LabelOp;
<span class="udiff-line-modified-removed">- import org.graalvm.compiler.lir.StandardOp.SaveRegistersOp;</span>
<span class="udiff-line-removed">- import org.graalvm.compiler.lir.hashing.Hasher;</span>
<span class="udiff-line-modified-added">+ import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;</span>
  import org.graalvm.compiler.lir.SwitchStrategy;
  import org.graalvm.compiler.lir.Variable;
<span class="udiff-line-added">+ import org.graalvm.compiler.lir.hashing.Hasher;</span>
  import org.graalvm.compiler.options.Option;
  import org.graalvm.compiler.options.OptionKey;
  import org.graalvm.compiler.options.OptionType;
  import org.graalvm.compiler.options.OptionValues;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -226,15 +227,35 @@</span>
      @Override
      public void emitMove(AllocatableValue dst, Value src) {
          append(moveFactory.createMove(dst, src));
      }
  
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public Variable emitReadRegister(Register register, ValueKind&lt;?&gt; kind) {</span>
<span class="udiff-line-added">+         return emitMove(register.asValue(kind));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public void emitWriteRegister(Register dst, Value src, ValueKind&lt;?&gt; kind) {</span>
<span class="udiff-line-added">+         emitMove(dst.asValue(kind), src);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override
      public void emitMoveConstant(AllocatableValue dst, Constant src) {
          append(moveFactory.createLoad(dst, src));
      }
  
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public boolean canInlineConstant(Constant constant) {</span>
<span class="udiff-line-added">+         return moveFactory.canInlineConstant(constant);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public boolean mayEmbedConstantLoad(Constant constant) {</span>
<span class="udiff-line-added">+         return moveFactory.mayEmbedConstantLoad(constant);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override
      public Value emitConstant(LIRKind kind, Constant constant) {
          if (moveFactory.canInlineConstant(constant)) {
              return new ConstantValue(toRegisterKind(kind), constant);
          } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -384,10 +405,28 @@</span>
          BlockScopeImpl blockScope = new BlockScopeImpl(block);
          blockScope.doBlockStart();
          return blockScope;
      }
  
<span class="udiff-line-added">+     private final class MatchScope implements DebugCloseable {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private MatchScope(AbstractBlockBase&lt;?&gt; block) {</span>
<span class="udiff-line-added">+             currentBlock = block;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public void close() {</span>
<span class="udiff-line-added">+             currentBlock = null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public final DebugCloseable getMatchScope(AbstractBlockBase&lt;?&gt; block) {</span>
<span class="udiff-line-added">+         MatchScope matchScope = new MatchScope(block);</span>
<span class="udiff-line-added">+         return matchScope;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override
      public void emitIncomingValues(Value[] params) {
          ((LabelOp) res.getLIR().getLIRforBlock(getCurrentBlock()).get(0)).setIncomingValues(params);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -455,11 +494,12 @@</span>
  
          int keyCount = keyConstants.length;
          double minDensity = 1 / Math.sqrt(strategy.getAverageEffort());
          Optional&lt;Hasher&gt; hasher = hasherFor(keyConstants, minDensity);
          double hashTableSwitchDensity = hasher.map(h -&gt; keyCount / (double) h.cardinality()).orElse(0d);
<span class="udiff-line-modified-removed">-         long valueRange = keyConstants[keyCount - 1].asLong() - keyConstants[0].asLong() + 1;</span>
<span class="udiff-line-modified-added">+         // The value range computation below may overflow, so compute it as a long.</span>
<span class="udiff-line-added">+         long valueRange = (long) keyConstants[keyCount - 1].asInt() - (long) keyConstants[0].asInt() + 1;</span>
          double tableSwitchDensity = keyCount / (double) valueRange;
  
          /*
           * This heuristic tries to find a compromise between the effort for the best switch strategy
           * and the density of a tableswitch. If the effort for the strategy is at least 4, then a
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -477,11 +517,11 @@</span>
                  for (int i = 0; i &lt; cardinality; i++) {
                      keys[i] = JavaConstant.INT_0;
                      targets[i] = defaultTarget;
                  }
                  for (int i = 0; i &lt; keyCount; i++) {
<span class="udiff-line-modified-removed">-                     int idx = h.hash(keyConstants[i].asLong());</span>
<span class="udiff-line-modified-added">+                     int idx = h.hash(keyConstants[i].asInt());</span>
                      keys[idx] = keyConstants[i];
                      targets[idx] = keyTargets[i];
                  }
                  emitHashTableSwitch(h, keys, defaultTarget, targets, value);
              } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -562,15 +602,20 @@</span>
      public LIRInstruction createMultiBenchmarkCounter(String[] names, String[] groups, Value[] increments) {
          throw GraalError.unimplemented();
      }
  
      @Override
<span class="udiff-line-modified-removed">-     public abstract SaveRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues);</span>
<span class="udiff-line-modified-added">+     public abstract ZapRegistersOp createZapRegisters(Register[] zappedRegisters, JavaConstant[] zapValues);</span>
  
      @Override
<span class="udiff-line-modified-removed">-     public SaveRegistersOp createZapRegisters() {</span>
<span class="udiff-line-modified-added">+     public ZapRegistersOp createZapRegisters() {</span>
          Register[] zappedRegisters = getResult().getFrameMap().getRegisterConfig().getAllocatableRegisters().toArray();
<span class="udiff-line-added">+         return createZapRegisters(zappedRegisters);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public ZapRegistersOp createZapRegisters(Register[] zappedRegisters) {</span>
          JavaConstant[] zapValues = new JavaConstant[zappedRegisters.length];
          for (int i = 0; i &lt; zappedRegisters.length; i++) {
              PlatformKind kind = target().arch.getLargestStorableKind(zappedRegisters[i].getRegisterCategory());
              zapValues[i] = zapValueForKind(kind);
          }
</pre>
<center><a href="LIRGenerationResult.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRGeneratorTool.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/asm/CompilationResultBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../alloc/lsra/LinearScanWalker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilationResultBuilderFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/asm/CompilationResultBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.lir.asm;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.asStackSlot;
 28 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 29 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 30 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 31 
 32 import java.util.ArrayList;
 33 import java.util.Arrays;
 34 import java.util.List;
 35 import java.util.function.Consumer;
 36 
 37 import jdk.internal.vm.compiler.collections.EconomicMap;
 38 import jdk.internal.vm.compiler.collections.Equivalence;
 39 import org.graalvm.compiler.asm.AbstractAddress;
 40 import org.graalvm.compiler.asm.Assembler;
 41 import org.graalvm.compiler.asm.Label;
 42 import org.graalvm.compiler.code.CompilationResult;
 43 import org.graalvm.compiler.code.CompilationResult.CodeAnnotation;

 44 import org.graalvm.compiler.code.DataSection.Data;
 45 import org.graalvm.compiler.code.DataSection.RawData;
 46 import org.graalvm.compiler.core.common.NumUtil;
 47 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 48 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 49 import org.graalvm.compiler.core.common.type.DataPointerConstant;
 50 import org.graalvm.compiler.debug.DebugContext;
 51 import org.graalvm.compiler.debug.GraalError;
 52 import org.graalvm.compiler.graph.NodeSourcePosition;
 53 import org.graalvm.compiler.lir.LIR;
 54 import org.graalvm.compiler.lir.LIRFrameState;
 55 import org.graalvm.compiler.lir.LIRInstruction;

 56 import org.graalvm.compiler.lir.LabelRef;
 57 import org.graalvm.compiler.lir.StandardOp.LabelHoldingOp;
 58 import org.graalvm.compiler.lir.framemap.FrameMap;
 59 import org.graalvm.compiler.options.Option;
 60 import org.graalvm.compiler.options.OptionKey;
 61 import org.graalvm.compiler.options.OptionType;
 62 import org.graalvm.compiler.options.OptionValues;

 63 
 64 import jdk.vm.ci.code.BailoutException;
 65 import jdk.vm.ci.code.CodeCacheProvider;
 66 import jdk.vm.ci.code.DebugInfo;
 67 import jdk.vm.ci.code.Register;
 68 import jdk.vm.ci.code.StackSlot;
 69 import jdk.vm.ci.code.TargetDescription;
 70 import jdk.vm.ci.code.site.ConstantReference;
 71 import jdk.vm.ci.code.site.DataSectionReference;

 72 import jdk.vm.ci.code.site.InfopointReason;
 73 import jdk.vm.ci.code.site.Mark;
 74 import jdk.vm.ci.meta.Constant;
 75 import jdk.vm.ci.meta.InvokeTarget;
 76 import jdk.vm.ci.meta.JavaConstant;
 77 import jdk.vm.ci.meta.JavaKind;
 78 import jdk.vm.ci.meta.VMConstant;
 79 import jdk.vm.ci.meta.Value;
 80 
 81 /**
 82  * Fills in a {@link CompilationResult} as its code is being assembled.
 83  *
 84  * @see CompilationResultBuilderFactory
 85  */
 86 public class CompilationResultBuilder {
 87 










 88     public static class Options {
 89         @Option(help = &quot;Include the LIR as comments with the final assembly.&quot;, type = OptionType.Debug) //
 90         public static final OptionKey&lt;Boolean&gt; PrintLIRWithAssembly = new OptionKey&lt;&gt;(false);
 91     }
 92 
 93     private static class ExceptionInfo {
 94 
 95         public final int codeOffset;
 96         public final LabelRef exceptionEdge;
 97 
 98         ExceptionInfo(int pcOffset, LabelRef exceptionEdge) {
 99             this.codeOffset = pcOffset;
100             this.exceptionEdge = exceptionEdge;
101         }
102     }
103 
104     /**
105      * Wrapper for a code annotation that was produced by the {@link Assembler}.
106      */
107     public static final class AssemblerAnnotation extends CodeAnnotation {
</pre>
<hr />
<pre>
110 
111         public AssemblerAnnotation(Assembler.CodeAnnotation assemblerCodeAnnotation) {
112             super(assemblerCodeAnnotation.instructionPosition);
113             this.assemblerCodeAnnotation = assemblerCodeAnnotation;
114         }
115 
116         @Override
117         public boolean equals(Object obj) {
118             return this == obj;
119         }
120 
121         @Override
122         public String toString() {
123             return assemblerCodeAnnotation.toString();
124         }
125     }
126 
127     public final Assembler asm;
128     public final DataBuilder dataBuilder;
129     public final CompilationResult compilationResult;
<span class="line-modified">130     public final Register nullRegister;</span>
131     public final TargetDescription target;
132     public final CodeCacheProvider codeCache;
133     public final ForeignCallsProvider foreignCalls;
134     public final FrameMap frameMap;
135 
136     /**
137      * The LIR for which code is being generated.
138      */
139     protected LIR lir;
140 
141     /**
142      * The index of the block currently being emitted.
143      */
144     protected int currentBlockIndex;
145 
146     /**
147      * The object that emits code for managing a method&#39;s frame.
148      */
149     public final FrameContext frameContext;
150 
</pre>
<hr />
<pre>
154     private final DebugContext debug;
155     private final EconomicMap&lt;Constant, Data&gt; dataCache;
156 
157     private Consumer&lt;LIRInstruction&gt; beforeOp;
158     private Consumer&lt;LIRInstruction&gt; afterOp;
159 
160     /**
161      * These position maps are used for estimating offsets of forward branches. Used for
162      * architectures where certain branch instructions have limited displacement such as ARM tbz or
163      * SPARC cbcond.
164      */
165     private EconomicMap&lt;Label, Integer&gt; labelBindLirPositions;
166     private EconomicMap&lt;LIRInstruction, Integer&gt; lirPositions;
167     /**
168      * This flag is for setting the
169      * {@link CompilationResultBuilder#labelWithinRange(LIRInstruction, Label, int)} into a
170      * conservative mode and always answering false.
171      */
172     private boolean conservativeLabelOffsets = false;
173 
<span class="line-modified">174     public final boolean mustReplaceWithNullRegister(JavaConstant nullConstant) {</span>
<span class="line-modified">175         return !nullRegister.equals(Register.None) &amp;&amp; JavaConstant.NULL_POINTER.equals(nullConstant);</span>
<span class="line-modified">176     }</span>
<span class="line-modified">177 </span>
<span class="line-modified">178     public CompilationResultBuilder(CodeCacheProvider codeCache, ForeignCallsProvider foreignCalls, FrameMap frameMap, Assembler asm, DataBuilder dataBuilder, FrameContext frameContext,</span>
<span class="line-modified">179                     OptionValues options, DebugContext debug, CompilationResult compilationResult, Register nullRegister) {</span>
<span class="line-modified">180         this(codeCache, foreignCalls, frameMap, asm, dataBuilder, frameContext, options, debug, compilationResult, nullRegister, EconomicMap.create(Equivalence.DEFAULT));</span>
<span class="line-modified">181     }</span>
<span class="line-modified">182 </span>
<span class="line-modified">183     public CompilationResultBuilder(CodeCacheProvider codeCache, ForeignCallsProvider foreignCalls, FrameMap frameMap, Assembler asm, DataBuilder dataBuilder, FrameContext frameContext,</span>
<span class="line-modified">184                     OptionValues options, DebugContext debug, CompilationResult compilationResult, Register nullRegister, EconomicMap&lt;Constant, Data&gt; dataCache) {</span>



























185         this.target = codeCache.getTarget();
186         this.codeCache = codeCache;
187         this.foreignCalls = foreignCalls;
188         this.frameMap = frameMap;
189         this.asm = asm;
190         this.dataBuilder = dataBuilder;
191         this.compilationResult = compilationResult;
<span class="line-modified">192         this.nullRegister = nullRegister;</span>
193         this.frameContext = frameContext;
194         this.options = options;
195         this.debug = debug;
196         assert frameContext != null;
197         this.dataCache = dataCache;
198     }
199 
200     public void setTotalFrameSize(int frameSize) {
201         compilationResult.setTotalFrameSize(frameSize);
202     }
203 
204     public void setMaxInterpreterFrameSize(int maxInterpreterFrameSize) {
205         compilationResult.setMaxInterpreterFrameSize(maxInterpreterFrameSize);
206     }
207 
208     public Mark recordMark(Object id) {
209         return compilationResult.recordMark(asm.position(), id);
210     }
211 
212     public void blockComment(String s) {
</pre>
<hr />
<pre>
238     protected void closeCompilationResult() {
239         compilationResult.close();
240     }
241 
242     public void recordExceptionHandlers(int pcOffset, LIRFrameState info) {
243         if (info != null) {
244             if (info.exceptionEdge != null) {
245                 if (exceptionInfoList == null) {
246                     exceptionInfoList = new ArrayList&lt;&gt;(4);
247                 }
248                 exceptionInfoList.add(new ExceptionInfo(pcOffset, info.exceptionEdge));
249             }
250         }
251     }
252 
253     public void recordImplicitException(int pcOffset, LIRFrameState info) {
254         compilationResult.recordInfopoint(pcOffset, info.debugInfo(), InfopointReason.IMPLICIT_EXCEPTION);
255         assert info.exceptionEdge == null;
256     }
257 










258     public void recordDirectCall(int posBefore, int posAfter, InvokeTarget callTarget, LIRFrameState info) {
259         DebugInfo debugInfo = info != null ? info.debugInfo() : null;
260         compilationResult.recordCall(posBefore, posAfter - posBefore, callTarget, debugInfo, true);
261     }
262 
263     public void recordIndirectCall(int posBefore, int posAfter, InvokeTarget callTarget, LIRFrameState info) {
264         DebugInfo debugInfo = info != null ? info.debugInfo() : null;
265         compilationResult.recordCall(posBefore, posAfter - posBefore, callTarget, debugInfo, false);
266     }
267 
268     public void recordInfopoint(int pos, LIRFrameState info, InfopointReason reason) {
269         // infopoints always need debug info
270         DebugInfo debugInfo = info.debugInfo();
271         recordInfopoint(pos, debugInfo, reason);
272     }
273 
274     public void recordInfopoint(int pos, DebugInfo debugInfo, InfopointReason reason) {
275         compilationResult.recordInfopoint(pos, debugInfo, reason);
276     }
277 
</pre>
<hr />
<pre>
517     }
518 
519     private void emitBlock(AbstractBlockBase&lt;?&gt; block) {
520         if (block == null) {
521             return;
522         }
523         boolean emitComment = debug.isDumpEnabled(DebugContext.BASIC_LEVEL) || Options.PrintLIRWithAssembly.getValue(getOptions());
524         if (emitComment) {
525             blockComment(String.format(&quot;block B%d %s&quot;, block.getId(), block.getLoop()));
526         }
527 
528         for (LIRInstruction op : lir.getLIRforBlock(block)) {
529             if (emitComment) {
530                 blockComment(String.format(&quot;%d %s&quot;, op.id(), op));
531             }
532 
533             try {
534                 if (beforeOp != null) {
535                     beforeOp.accept(op);
536                 }
<span class="line-modified">537                 emitOp(this, op);</span>
538                 if (afterOp != null) {
539                     afterOp.accept(op);
540                 }
541             } catch (GraalError e) {
542                 throw e.addContext(&quot;lir instruction&quot;, block + &quot;@&quot; + op.id() + &quot; &quot; + op.getClass().getName() + &quot; &quot; + op + &quot;\n&quot; + Arrays.toString(lir.codeEmittingOrder()));
543             }
544         }
545     }
546 
<span class="line-modified">547     private static void emitOp(CompilationResultBuilder crb, LIRInstruction op) {</span>
548         try {
<span class="line-modified">549             int start = crb.asm.position();</span>
<span class="line-modified">550             op.emitCode(crb);</span>
551             if (op.getPosition() != null) {
<span class="line-modified">552                 crb.recordSourceMapping(start, crb.asm.position(), op.getPosition());</span>

















553             }
554         } catch (BailoutException e) {
555             throw e;
556         } catch (AssertionError t) {
557             throw new GraalError(t);
558         } catch (RuntimeException t) {
559             throw new GraalError(t);
560         }
561     }
562 
563     public void resetForEmittingCode() {
564         asm.reset();
565         compilationResult.resetForEmittingCode();
566         if (exceptionInfoList != null) {
567             exceptionInfoList.clear();
568         }
569         if (dataCache != null) {
570             dataCache.clear();
571         }
572         lir = null;
</pre>
<hr />
<pre>
581     public OptionValues getOptions() {
582         return options;
583     }
584 
585     /**
586      * Builds up a map for label and LIR instruction positions where labels are or labels pointing
587      * to.
588      */
589     public void buildLabelOffsets(LIR generatedLIR) {
590         labelBindLirPositions = EconomicMap.create(Equivalence.IDENTITY);
591         lirPositions = EconomicMap.create(Equivalence.IDENTITY);
592         int instructionPosition = 0;
593         for (AbstractBlockBase&lt;?&gt; block : generatedLIR.codeEmittingOrder()) {
594             if (block != null) {
595                 for (LIRInstruction op : generatedLIR.getLIRforBlock(block)) {
596                     if (op instanceof LabelHoldingOp) {
597                         Label label = ((LabelHoldingOp) op).getLabel();
598                         if (label != null) {
599                             labelBindLirPositions.put(label, instructionPosition);
600                         }
<span class="line-removed">601                         lirPositions.put(op, instructionPosition);</span>
602                     }

603                     instructionPosition++;
604                 }
605             }
606         }
607     }
608 
609     /**
610      * Answers the code generator whether the jump from instruction to label is within disp LIR
611      * instructions.
612      *
613      * @param disp Maximum number of LIR instructions between label and instruction
614      */
615     public boolean labelWithinRange(LIRInstruction instruction, Label label, int disp) {
616         if (conservativeLabelOffsets) {
617             return false;
618         }
619         Integer labelPosition = labelBindLirPositions.get(label);
620         Integer instructionPosition = lirPositions.get(instruction);
621         boolean result;
622         if (labelPosition != null &amp;&amp; instructionPosition != null) {
623             result = Math.abs(labelPosition - instructionPosition) &lt; disp;
624         } else {
625             result = false;
626         }
627         return result;
628     }
629 
630     /**
631      * Sets this CompilationResultBuilder into conservative mode. If set,
632      * {@link CompilationResultBuilder#labelWithinRange(LIRInstruction, Label, int)} always returns
633      * false.
634      */
635     public void setConservativeLabelRanges() {
636         this.conservativeLabelOffsets = true;
637     }














638 }
</pre>
</td>
<td>
<hr />
<pre>
 24 
 25 package org.graalvm.compiler.lir.asm;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.asStackSlot;
 28 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 29 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 30 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 31 
 32 import java.util.ArrayList;
 33 import java.util.Arrays;
 34 import java.util.List;
 35 import java.util.function.Consumer;
 36 
 37 import jdk.internal.vm.compiler.collections.EconomicMap;
 38 import jdk.internal.vm.compiler.collections.Equivalence;
 39 import org.graalvm.compiler.asm.AbstractAddress;
 40 import org.graalvm.compiler.asm.Assembler;
 41 import org.graalvm.compiler.asm.Label;
 42 import org.graalvm.compiler.code.CompilationResult;
 43 import org.graalvm.compiler.code.CompilationResult.CodeAnnotation;
<span class="line-added"> 44 import org.graalvm.compiler.code.CompilationResult.JumpTable;</span>
 45 import org.graalvm.compiler.code.DataSection.Data;
 46 import org.graalvm.compiler.code.DataSection.RawData;
 47 import org.graalvm.compiler.core.common.NumUtil;
 48 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 49 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 50 import org.graalvm.compiler.core.common.type.DataPointerConstant;
 51 import org.graalvm.compiler.debug.DebugContext;
 52 import org.graalvm.compiler.debug.GraalError;
 53 import org.graalvm.compiler.graph.NodeSourcePosition;
 54 import org.graalvm.compiler.lir.LIR;
 55 import org.graalvm.compiler.lir.LIRFrameState;
 56 import org.graalvm.compiler.lir.LIRInstruction;
<span class="line-added"> 57 import org.graalvm.compiler.lir.LIRInstructionVerifier;</span>
 58 import org.graalvm.compiler.lir.LabelRef;
 59 import org.graalvm.compiler.lir.StandardOp.LabelHoldingOp;
 60 import org.graalvm.compiler.lir.framemap.FrameMap;
 61 import org.graalvm.compiler.options.Option;
 62 import org.graalvm.compiler.options.OptionKey;
 63 import org.graalvm.compiler.options.OptionType;
 64 import org.graalvm.compiler.options.OptionValues;
<span class="line-added"> 65 import org.graalvm.compiler.serviceprovider.GraalServices;</span>
 66 
 67 import jdk.vm.ci.code.BailoutException;
 68 import jdk.vm.ci.code.CodeCacheProvider;
 69 import jdk.vm.ci.code.DebugInfo;
 70 import jdk.vm.ci.code.Register;
 71 import jdk.vm.ci.code.StackSlot;
 72 import jdk.vm.ci.code.TargetDescription;
 73 import jdk.vm.ci.code.site.ConstantReference;
 74 import jdk.vm.ci.code.site.DataSectionReference;
<span class="line-added"> 75 import jdk.vm.ci.code.site.Infopoint;</span>
 76 import jdk.vm.ci.code.site.InfopointReason;
 77 import jdk.vm.ci.code.site.Mark;
 78 import jdk.vm.ci.meta.Constant;
 79 import jdk.vm.ci.meta.InvokeTarget;
 80 import jdk.vm.ci.meta.JavaConstant;
 81 import jdk.vm.ci.meta.JavaKind;
 82 import jdk.vm.ci.meta.VMConstant;
 83 import jdk.vm.ci.meta.Value;
 84 
 85 /**
 86  * Fills in a {@link CompilationResult} as its code is being assembled.
 87  *
 88  * @see CompilationResultBuilderFactory
 89  */
 90 public class CompilationResultBuilder {
 91 
<span class="line-added"> 92     private static final List&lt;LIRInstructionVerifier&gt; LIR_INSTRUCTION_VERIFIERS = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94     static {</span>
<span class="line-added"> 95         for (LIRInstructionVerifier verifier : GraalServices.load(LIRInstructionVerifier.class)) {</span>
<span class="line-added"> 96             if (verifier.isEnabled()) {</span>
<span class="line-added"> 97                 LIR_INSTRUCTION_VERIFIERS.add(verifier);</span>
<span class="line-added"> 98             }</span>
<span class="line-added"> 99         }</span>
<span class="line-added">100     }</span>
<span class="line-added">101 </span>
102     public static class Options {
103         @Option(help = &quot;Include the LIR as comments with the final assembly.&quot;, type = OptionType.Debug) //
104         public static final OptionKey&lt;Boolean&gt; PrintLIRWithAssembly = new OptionKey&lt;&gt;(false);
105     }
106 
107     private static class ExceptionInfo {
108 
109         public final int codeOffset;
110         public final LabelRef exceptionEdge;
111 
112         ExceptionInfo(int pcOffset, LabelRef exceptionEdge) {
113             this.codeOffset = pcOffset;
114             this.exceptionEdge = exceptionEdge;
115         }
116     }
117 
118     /**
119      * Wrapper for a code annotation that was produced by the {@link Assembler}.
120      */
121     public static final class AssemblerAnnotation extends CodeAnnotation {
</pre>
<hr />
<pre>
124 
125         public AssemblerAnnotation(Assembler.CodeAnnotation assemblerCodeAnnotation) {
126             super(assemblerCodeAnnotation.instructionPosition);
127             this.assemblerCodeAnnotation = assemblerCodeAnnotation;
128         }
129 
130         @Override
131         public boolean equals(Object obj) {
132             return this == obj;
133         }
134 
135         @Override
136         public String toString() {
137             return assemblerCodeAnnotation.toString();
138         }
139     }
140 
141     public final Assembler asm;
142     public final DataBuilder dataBuilder;
143     public final CompilationResult compilationResult;
<span class="line-modified">144     public final Register uncompressedNullRegister;</span>
145     public final TargetDescription target;
146     public final CodeCacheProvider codeCache;
147     public final ForeignCallsProvider foreignCalls;
148     public final FrameMap frameMap;
149 
150     /**
151      * The LIR for which code is being generated.
152      */
153     protected LIR lir;
154 
155     /**
156      * The index of the block currently being emitted.
157      */
158     protected int currentBlockIndex;
159 
160     /**
161      * The object that emits code for managing a method&#39;s frame.
162      */
163     public final FrameContext frameContext;
164 
</pre>
<hr />
<pre>
168     private final DebugContext debug;
169     private final EconomicMap&lt;Constant, Data&gt; dataCache;
170 
171     private Consumer&lt;LIRInstruction&gt; beforeOp;
172     private Consumer&lt;LIRInstruction&gt; afterOp;
173 
174     /**
175      * These position maps are used for estimating offsets of forward branches. Used for
176      * architectures where certain branch instructions have limited displacement such as ARM tbz or
177      * SPARC cbcond.
178      */
179     private EconomicMap&lt;Label, Integer&gt; labelBindLirPositions;
180     private EconomicMap&lt;LIRInstruction, Integer&gt; lirPositions;
181     /**
182      * This flag is for setting the
183      * {@link CompilationResultBuilder#labelWithinRange(LIRInstruction, Label, int)} into a
184      * conservative mode and always answering false.
185      */
186     private boolean conservativeLabelOffsets = false;
187 
<span class="line-modified">188     public final boolean mustReplaceWithUncompressedNullRegister(JavaConstant nullConstant) {</span>
<span class="line-modified">189         return !uncompressedNullRegister.equals(Register.None) &amp;&amp; JavaConstant.NULL_POINTER.equals(nullConstant);</span>
<span class="line-modified">190     }</span>
<span class="line-modified">191 </span>
<span class="line-modified">192     public CompilationResultBuilder(CodeCacheProvider codeCache,</span>
<span class="line-modified">193                     ForeignCallsProvider foreignCalls,</span>
<span class="line-modified">194                     FrameMap frameMap,</span>
<span class="line-modified">195                     Assembler asm,</span>
<span class="line-modified">196                     DataBuilder dataBuilder,</span>
<span class="line-modified">197                     FrameContext frameContext,</span>
<span class="line-modified">198                     OptionValues options,</span>
<span class="line-added">199                     DebugContext debug,</span>
<span class="line-added">200                     CompilationResult compilationResult,</span>
<span class="line-added">201                     Register uncompressedNullRegister) {</span>
<span class="line-added">202         this(codeCache,</span>
<span class="line-added">203                         foreignCalls,</span>
<span class="line-added">204                         frameMap,</span>
<span class="line-added">205                         asm,</span>
<span class="line-added">206                         dataBuilder,</span>
<span class="line-added">207                         frameContext,</span>
<span class="line-added">208                         options,</span>
<span class="line-added">209                         debug,</span>
<span class="line-added">210                         compilationResult,</span>
<span class="line-added">211                         uncompressedNullRegister,</span>
<span class="line-added">212                         EconomicMap.create(Equivalence.DEFAULT));</span>
<span class="line-added">213     }</span>
<span class="line-added">214 </span>
<span class="line-added">215     public CompilationResultBuilder(CodeCacheProvider codeCache,</span>
<span class="line-added">216                     ForeignCallsProvider foreignCalls,</span>
<span class="line-added">217                     FrameMap frameMap,</span>
<span class="line-added">218                     Assembler asm,</span>
<span class="line-added">219                     DataBuilder dataBuilder,</span>
<span class="line-added">220                     FrameContext frameContext,</span>
<span class="line-added">221                     OptionValues options,</span>
<span class="line-added">222                     DebugContext debug,</span>
<span class="line-added">223                     CompilationResult compilationResult,</span>
<span class="line-added">224                     Register uncompressedNullRegister,</span>
<span class="line-added">225                     EconomicMap&lt;Constant, Data&gt; dataCache) {</span>
226         this.target = codeCache.getTarget();
227         this.codeCache = codeCache;
228         this.foreignCalls = foreignCalls;
229         this.frameMap = frameMap;
230         this.asm = asm;
231         this.dataBuilder = dataBuilder;
232         this.compilationResult = compilationResult;
<span class="line-modified">233         this.uncompressedNullRegister = uncompressedNullRegister;</span>
234         this.frameContext = frameContext;
235         this.options = options;
236         this.debug = debug;
237         assert frameContext != null;
238         this.dataCache = dataCache;
239     }
240 
241     public void setTotalFrameSize(int frameSize) {
242         compilationResult.setTotalFrameSize(frameSize);
243     }
244 
245     public void setMaxInterpreterFrameSize(int maxInterpreterFrameSize) {
246         compilationResult.setMaxInterpreterFrameSize(maxInterpreterFrameSize);
247     }
248 
249     public Mark recordMark(Object id) {
250         return compilationResult.recordMark(asm.position(), id);
251     }
252 
253     public void blockComment(String s) {
</pre>
<hr />
<pre>
279     protected void closeCompilationResult() {
280         compilationResult.close();
281     }
282 
283     public void recordExceptionHandlers(int pcOffset, LIRFrameState info) {
284         if (info != null) {
285             if (info.exceptionEdge != null) {
286                 if (exceptionInfoList == null) {
287                     exceptionInfoList = new ArrayList&lt;&gt;(4);
288                 }
289                 exceptionInfoList.add(new ExceptionInfo(pcOffset, info.exceptionEdge));
290             }
291         }
292     }
293 
294     public void recordImplicitException(int pcOffset, LIRFrameState info) {
295         compilationResult.recordInfopoint(pcOffset, info.debugInfo(), InfopointReason.IMPLICIT_EXCEPTION);
296         assert info.exceptionEdge == null;
297     }
298 
<span class="line-added">299     public boolean isImplicitExceptionExist(int pcOffset) {</span>
<span class="line-added">300         List&lt;Infopoint&gt; infopoints = compilationResult.getInfopoints();</span>
<span class="line-added">301         for (Infopoint infopoint : infopoints) {</span>
<span class="line-added">302             if (infopoint.pcOffset == pcOffset &amp;&amp; infopoint.reason == InfopointReason.IMPLICIT_EXCEPTION) {</span>
<span class="line-added">303                 return true;</span>
<span class="line-added">304             }</span>
<span class="line-added">305         }</span>
<span class="line-added">306         return false;</span>
<span class="line-added">307     }</span>
<span class="line-added">308 </span>
309     public void recordDirectCall(int posBefore, int posAfter, InvokeTarget callTarget, LIRFrameState info) {
310         DebugInfo debugInfo = info != null ? info.debugInfo() : null;
311         compilationResult.recordCall(posBefore, posAfter - posBefore, callTarget, debugInfo, true);
312     }
313 
314     public void recordIndirectCall(int posBefore, int posAfter, InvokeTarget callTarget, LIRFrameState info) {
315         DebugInfo debugInfo = info != null ? info.debugInfo() : null;
316         compilationResult.recordCall(posBefore, posAfter - posBefore, callTarget, debugInfo, false);
317     }
318 
319     public void recordInfopoint(int pos, LIRFrameState info, InfopointReason reason) {
320         // infopoints always need debug info
321         DebugInfo debugInfo = info.debugInfo();
322         recordInfopoint(pos, debugInfo, reason);
323     }
324 
325     public void recordInfopoint(int pos, DebugInfo debugInfo, InfopointReason reason) {
326         compilationResult.recordInfopoint(pos, debugInfo, reason);
327     }
328 
</pre>
<hr />
<pre>
568     }
569 
570     private void emitBlock(AbstractBlockBase&lt;?&gt; block) {
571         if (block == null) {
572             return;
573         }
574         boolean emitComment = debug.isDumpEnabled(DebugContext.BASIC_LEVEL) || Options.PrintLIRWithAssembly.getValue(getOptions());
575         if (emitComment) {
576             blockComment(String.format(&quot;block B%d %s&quot;, block.getId(), block.getLoop()));
577         }
578 
579         for (LIRInstruction op : lir.getLIRforBlock(block)) {
580             if (emitComment) {
581                 blockComment(String.format(&quot;%d %s&quot;, op.id(), op));
582             }
583 
584             try {
585                 if (beforeOp != null) {
586                     beforeOp.accept(op);
587                 }
<span class="line-modified">588                 emitOp(op);</span>
589                 if (afterOp != null) {
590                     afterOp.accept(op);
591                 }
592             } catch (GraalError e) {
593                 throw e.addContext(&quot;lir instruction&quot;, block + &quot;@&quot; + op.id() + &quot; &quot; + op.getClass().getName() + &quot; &quot; + op + &quot;\n&quot; + Arrays.toString(lir.codeEmittingOrder()));
594             }
595         }
596     }
597 
<span class="line-modified">598     private void emitOp(LIRInstruction op) {</span>
599         try {
<span class="line-modified">600             int start = asm.position();</span>
<span class="line-modified">601             op.emitCode(this);</span>
602             if (op.getPosition() != null) {
<span class="line-modified">603                 recordSourceMapping(start, asm.position(), op.getPosition());</span>
<span class="line-added">604             }</span>
<span class="line-added">605             if (LIR_INSTRUCTION_VERIFIERS.size() &gt; 0 &amp;&amp; start &lt; asm.position()) {</span>
<span class="line-added">606                 int end = asm.position();</span>
<span class="line-added">607                 for (CodeAnnotation codeAnnotation : compilationResult.getCodeAnnotations()) {</span>
<span class="line-added">608                     if (codeAnnotation instanceof JumpTable) {</span>
<span class="line-added">609                         // Skip jump table. Here we assume the jump table is at the tail of the</span>
<span class="line-added">610                         // emitted code.</span>
<span class="line-added">611                         int jumpTableStart = codeAnnotation.position;</span>
<span class="line-added">612                         if (jumpTableStart &gt;= start &amp;&amp; jumpTableStart &lt; end) {</span>
<span class="line-added">613                             end = jumpTableStart;</span>
<span class="line-added">614                         }</span>
<span class="line-added">615                     }</span>
<span class="line-added">616                 }</span>
<span class="line-added">617                 byte[] emittedCode = asm.copy(start, end);</span>
<span class="line-added">618                 for (LIRInstructionVerifier verifier : LIR_INSTRUCTION_VERIFIERS) {</span>
<span class="line-added">619                     verifier.verify(op, emittedCode);</span>
<span class="line-added">620                 }</span>
621             }
622         } catch (BailoutException e) {
623             throw e;
624         } catch (AssertionError t) {
625             throw new GraalError(t);
626         } catch (RuntimeException t) {
627             throw new GraalError(t);
628         }
629     }
630 
631     public void resetForEmittingCode() {
632         asm.reset();
633         compilationResult.resetForEmittingCode();
634         if (exceptionInfoList != null) {
635             exceptionInfoList.clear();
636         }
637         if (dataCache != null) {
638             dataCache.clear();
639         }
640         lir = null;
</pre>
<hr />
<pre>
649     public OptionValues getOptions() {
650         return options;
651     }
652 
653     /**
654      * Builds up a map for label and LIR instruction positions where labels are or labels pointing
655      * to.
656      */
657     public void buildLabelOffsets(LIR generatedLIR) {
658         labelBindLirPositions = EconomicMap.create(Equivalence.IDENTITY);
659         lirPositions = EconomicMap.create(Equivalence.IDENTITY);
660         int instructionPosition = 0;
661         for (AbstractBlockBase&lt;?&gt; block : generatedLIR.codeEmittingOrder()) {
662             if (block != null) {
663                 for (LIRInstruction op : generatedLIR.getLIRforBlock(block)) {
664                     if (op instanceof LabelHoldingOp) {
665                         Label label = ((LabelHoldingOp) op).getLabel();
666                         if (label != null) {
667                             labelBindLirPositions.put(label, instructionPosition);
668                         }

669                     }
<span class="line-added">670                     lirPositions.put(op, instructionPosition);</span>
671                     instructionPosition++;
672                 }
673             }
674         }
675     }
676 
677     /**
678      * Answers the code generator whether the jump from instruction to label is within disp LIR
679      * instructions.
680      *
681      * @param disp Maximum number of LIR instructions between label and instruction
682      */
683     public boolean labelWithinRange(LIRInstruction instruction, Label label, int disp) {
684         if (conservativeLabelOffsets) {
685             return false;
686         }
687         Integer labelPosition = labelBindLirPositions.get(label);
688         Integer instructionPosition = lirPositions.get(instruction);
689         boolean result;
690         if (labelPosition != null &amp;&amp; instructionPosition != null) {
691             result = Math.abs(labelPosition - instructionPosition) &lt; disp;
692         } else {
693             result = false;
694         }
695         return result;
696     }
697 
698     /**
699      * Sets this CompilationResultBuilder into conservative mode. If set,
700      * {@link CompilationResultBuilder#labelWithinRange(LIRInstruction, Label, int)} always returns
701      * false.
702      */
703     public void setConservativeLabelRanges() {
704         this.conservativeLabelOffsets = true;
705     }
<span class="line-added">706 </span>
<span class="line-added">707     public final boolean needsClearUpperVectorRegisters() {</span>
<span class="line-added">708         for (AbstractBlockBase&lt;?&gt; block : lir.codeEmittingOrder()) {</span>
<span class="line-added">709             if (block == null) {</span>
<span class="line-added">710                 continue;</span>
<span class="line-added">711             }</span>
<span class="line-added">712             for (LIRInstruction op : lir.getLIRforBlock(block)) {</span>
<span class="line-added">713                 if (op.needsClearUpperVectorRegisters()) {</span>
<span class="line-added">714                     return true;</span>
<span class="line-added">715                 }</span>
<span class="line-added">716             }</span>
<span class="line-added">717         }</span>
<span class="line-added">718         return false;</span>
<span class="line-added">719     }</span>
720 }
</pre>
</td>
</tr>
</table>
<center><a href="../alloc/lsra/LinearScanWalker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompilationResultBuilderFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
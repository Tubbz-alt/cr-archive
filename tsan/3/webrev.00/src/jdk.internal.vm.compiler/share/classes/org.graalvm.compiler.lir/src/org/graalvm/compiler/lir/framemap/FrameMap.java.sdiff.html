<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/framemap/FrameMap.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../dfa/LocationMarkerPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameMapBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/framemap/FrameMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.framemap;
 26 
<span class="line-modified"> 27 import java.util.ArrayList;</span>
<span class="line-removed"> 28 import java.util.BitSet;</span>
<span class="line-removed"> 29 import java.util.List;</span>
<span class="line-removed"> 30 </span>
 31 import org.graalvm.compiler.core.common.NumUtil;
 32 import org.graalvm.compiler.core.common.PermanentBailoutException;
<span class="line-removed"> 33 import org.graalvm.compiler.core.common.LIRKind;</span>
 34 
 35 import jdk.vm.ci.code.Architecture;
 36 import jdk.vm.ci.code.CallingConvention;
 37 import jdk.vm.ci.code.CodeCacheProvider;
 38 import jdk.vm.ci.code.RegisterConfig;
 39 import jdk.vm.ci.code.StackSlot;
 40 import jdk.vm.ci.code.TargetDescription;
<span class="line-removed"> 41 import jdk.vm.ci.meta.Value;</span>
 42 import jdk.vm.ci.meta.ValueKind;
 43 
 44 /**
 45  * This class is used to build the stack frame layout for a compiled method. A {@link StackSlot} is
 46  * used to index slots of the frame relative to the stack pointer. The frame size is only fixed
 47  * after register allocation when all spill slots have been allocated. Both the outgoing argument
<span class="line-modified"> 48  * area and the spill are can grow until then. Therefore, outgoing arguments are indexed from the</span>
 49  * stack pointer, while spill slots are indexed from the beginning of the frame (and the total frame
 50  * size has to be added to get the actual offset from the stack pointer).
 51  */
 52 public abstract class FrameMap {
 53 
 54     private final TargetDescription target;
 55     private final RegisterConfig registerConfig;
 56 
 57     public interface ReferenceMapBuilderFactory {
 58 
 59         ReferenceMapBuilder newReferenceMapBuilder(int totalFrameSize);
 60     }
 61 
 62     private final ReferenceMapBuilderFactory referenceMapFactory;
 63 
 64     /**
 65      * The final frame size, not including the size of the
 66      * {@link Architecture#getReturnAddressSize() return address slot}. The value is only set after
 67      * register allocation is complete, i.e., after all spill slots have been allocated.
 68      */
</pre>
<hr />
<pre>
 73      */
 74     protected int initialSpillSize;
 75 
 76     /**
 77      * Size of the area occupied by spill slots and other stack-allocated memory blocks.
 78      */
 79     protected int spillSize;
 80 
 81     /**
 82      * Size of the area occupied by outgoing overflow arguments. This value is adjusted as calling
 83      * conventions for outgoing calls are retrieved. On some platforms, there is a minimum outgoing
 84      * size even if no overflow arguments are on the stack.
 85      */
 86     protected int outgoingSize;
 87 
 88     /**
 89      * Determines if this frame has values on the stack for outgoing calls.
 90      */
 91     protected boolean hasOutgoingStackArguments;
 92 
<span class="line-removed"> 93     /**</span>
<span class="line-removed"> 94      * The list of stack slots allocated in this frame that are present in every reference map.</span>
<span class="line-removed"> 95      */</span>
<span class="line-removed"> 96     private final List&lt;StackSlot&gt; objectStackSlots;</span>
<span class="line-removed"> 97 </span>
 98     /**
 99      * Records whether an offset to an incoming stack argument was ever returned by
100      * {@link #offsetForStackSlot(StackSlot)}.
101      */
102     private boolean accessesCallerFrame;
103 
104     /**
105      * Creates a new frame map for the specified method. The given registerConfig is optional, in
106      * case null is passed the default RegisterConfig from the CodeCacheProvider will be used.
107      */
108     public FrameMap(CodeCacheProvider codeCache, RegisterConfig registerConfig, ReferenceMapBuilderFactory referenceMapFactory) {
109         this.target = codeCache.getTarget();
110         this.registerConfig = registerConfig == null ? codeCache.getRegisterConfig() : registerConfig;
111         this.frameSize = -1;
112         this.outgoingSize = codeCache.getMinimumOutgoingSize();
<span class="line-removed">113         this.objectStackSlots = new ArrayList&lt;&gt;();</span>
114         this.referenceMapFactory = referenceMapFactory;
115     }
116 
117     public RegisterConfig getRegisterConfig() {
118         return registerConfig;
119     }
120 
121     public TargetDescription getTarget() {
122         return target;
123     }
124 
<span class="line-removed">125     public void addLiveValues(ReferenceMapBuilder refMap) {</span>
<span class="line-removed">126         for (Value value : objectStackSlots) {</span>
<span class="line-removed">127             refMap.addLiveValue(value);</span>
<span class="line-removed">128         }</span>
<span class="line-removed">129     }</span>
<span class="line-removed">130 </span>
131     protected int returnAddressSize() {
132         return getTarget().arch.getReturnAddressSize();
133     }
134 
135     /**
136      * Determines if an offset to an incoming stack argument was ever returned by
137      * {@link #offsetForStackSlot(StackSlot)}.
138      */
139     public boolean accessesCallerFrame() {
140         return accessesCallerFrame;
141     }
142 
143     /**
144      * Gets the frame size of the compiled frame, not including the size of the
145      * {@link Architecture#getReturnAddressSize() return address slot}.
146      *
147      * @return The size of the frame (in bytes).
148      */
149     public int frameSize() {
150         assert frameSize != -1 : &quot;frame size not computed yet&quot;;
</pre>
<hr />
<pre>
217      * Informs the frame map that the compiled code calls a particular method, which may need stack
218      * space for outgoing arguments.
219      *
220      * @param cc The calling convention for the called method.
221      */
222     public void callsMethod(CallingConvention cc) {
223         reserveOutgoing(cc.getStackSize());
224     }
225 
226     /**
227      * Reserves space for stack-based outgoing arguments.
228      *
229      * @param argsSize The amount of space (in bytes) to reserve for stack-based outgoing arguments.
230      */
231     public void reserveOutgoing(int argsSize) {
232         assert frameSize == -1 : &quot;frame size must not yet be fixed&quot;;
233         outgoingSize = Math.max(outgoingSize, argsSize);
234         hasOutgoingStackArguments = hasOutgoingStackArguments || argsSize &gt; 0;
235     }
236 
<span class="line-removed">237     /**</span>
<span class="line-removed">238      * Reserves a new spill slot in the frame of the method being compiled. The returned slot is</span>
<span class="line-removed">239      * aligned on its natural alignment, i.e., an 8-byte spill slot is aligned at an 8-byte</span>
<span class="line-removed">240      * boundary.</span>
<span class="line-removed">241      *</span>
<span class="line-removed">242      * @param kind The kind of the spill slot to be reserved.</span>
<span class="line-removed">243      * @param additionalOffset</span>
<span class="line-removed">244      * @return A spill slot denoting the reserved memory area.</span>
<span class="line-removed">245      */</span>
<span class="line-removed">246     protected StackSlot allocateNewSpillSlot(ValueKind&lt;?&gt; kind, int additionalOffset) {</span>
<span class="line-removed">247         return StackSlot.get(kind, -spillSize + additionalOffset, true);</span>
<span class="line-removed">248     }</span>
<span class="line-removed">249 </span>
250     /**
251      * Returns the spill slot size for the given {@link ValueKind}. The default value is the size in
252      * bytes for the target architecture.
253      *
254      * @param kind the {@link ValueKind} to be stored in the spill slot.
255      * @return the size in bytes
256      */
257     public int spillSlotSize(ValueKind&lt;?&gt; kind) {
258         return kind.getPlatformKind().getSizeInBytes();
259     }
260 
261     /**
262      * Reserves a spill slot in the frame of the method being compiled. The returned slot is aligned
263      * on its natural alignment, i.e., an 8-byte spill slot is aligned at an 8-byte boundary, unless
264      * overridden by a subclass.
265      *
266      * @param kind The kind of the spill slot to be reserved.
267      * @return A spill slot denoting the reserved memory area.
268      */
269     public StackSlot allocateSpillSlot(ValueKind&lt;?&gt; kind) {
270         assert frameSize == -1 : &quot;frame size must not yet be fixed&quot;;
271         int size = spillSlotSize(kind);
272         spillSize = NumUtil.roundUp(spillSize + size, size);
<span class="line-modified">273         return allocateNewSpillSlot(kind, 0);</span>




274     }
275 
276     /**
277      * Returns the size of the stack slot range for {@code slots} objects.
278      *
279      * @param slots The number of slots.
280      * @return The size in byte
281      */
282     public int spillSlotRangeSize(int slots) {
283         return slots * getTarget().wordSize;
284     }
285 
286     /**
287      * Reserves a number of contiguous slots in the frame of the method being compiled. If the
288      * requested number of slots is 0, this method returns {@code null}.
289      *
290      * @param slots the number of slots to reserve
<span class="line-removed">291      * @param objects specifies the indexes of the object pointer slots. The caller is responsible</span>
<span class="line-removed">292      *            for guaranteeing that each such object pointer slot is initialized before any</span>
<span class="line-removed">293      *            instruction that uses a reference map. Without this guarantee, the garbage</span>
<span class="line-removed">294      *            collector could see garbage object values.</span>
295      * @return the first reserved stack slot (i.e., at the lowest address)
296      */
<span class="line-modified">297     public StackSlot allocateStackSlots(int slots, BitSet objects) {</span>
298         assert frameSize == -1 : &quot;frame size must not yet be fixed&quot;;
299         if (slots == 0) {
300             return null;
301         }
<span class="line-modified">302         spillSize += spillSlotRangeSize(slots);</span>
<span class="line-modified">303 </span>
<span class="line-removed">304         if (!objects.isEmpty()) {</span>
<span class="line-removed">305             assert objects.length() &lt;= slots;</span>
<span class="line-removed">306             StackSlot result = null;</span>
<span class="line-removed">307             for (int slotIndex = 0; slotIndex &lt; slots; slotIndex++) {</span>
<span class="line-removed">308                 StackSlot objectSlot = null;</span>
<span class="line-removed">309                 if (objects.get(slotIndex)) {</span>
<span class="line-removed">310                     objectSlot = allocateNewSpillSlot(LIRKind.reference(getTarget().arch.getWordKind()), slotIndex * getTarget().wordSize);</span>
<span class="line-removed">311                     addObjectStackSlot(objectSlot);</span>
<span class="line-removed">312                 }</span>
<span class="line-removed">313                 if (slotIndex == 0) {</span>
<span class="line-removed">314                     if (objectSlot != null) {</span>
<span class="line-removed">315                         result = objectSlot;</span>
<span class="line-removed">316                     } else {</span>
<span class="line-removed">317                         result = allocateNewSpillSlot(LIRKind.value(getTarget().arch.getWordKind()), 0);</span>
<span class="line-removed">318                     }</span>
<span class="line-removed">319                 }</span>
<span class="line-removed">320             }</span>
<span class="line-removed">321             assert result != null;</span>
<span class="line-removed">322             return result;</span>
<span class="line-removed">323 </span>
<span class="line-removed">324         } else {</span>
<span class="line-removed">325             return allocateNewSpillSlot(LIRKind.value(getTarget().arch.getWordKind()), 0);</span>
<span class="line-removed">326         }</span>
<span class="line-removed">327     }</span>
<span class="line-removed">328 </span>
<span class="line-removed">329     protected void addObjectStackSlot(StackSlot objectSlot) {</span>
<span class="line-removed">330         objectStackSlots.add(objectSlot);</span>
331     }
332 
333     public ReferenceMapBuilder newReferenceMapBuilder() {
334         return referenceMapFactory.newReferenceMapBuilder(totalFrameSize());
335     }
336 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.framemap;
 26 
<span class="line-modified"> 27 import org.graalvm.compiler.core.common.LIRKind;</span>



 28 import org.graalvm.compiler.core.common.NumUtil;
 29 import org.graalvm.compiler.core.common.PermanentBailoutException;

 30 
 31 import jdk.vm.ci.code.Architecture;
 32 import jdk.vm.ci.code.CallingConvention;
 33 import jdk.vm.ci.code.CodeCacheProvider;
 34 import jdk.vm.ci.code.RegisterConfig;
 35 import jdk.vm.ci.code.StackSlot;
 36 import jdk.vm.ci.code.TargetDescription;

 37 import jdk.vm.ci.meta.ValueKind;
 38 
 39 /**
 40  * This class is used to build the stack frame layout for a compiled method. A {@link StackSlot} is
 41  * used to index slots of the frame relative to the stack pointer. The frame size is only fixed
 42  * after register allocation when all spill slots have been allocated. Both the outgoing argument
<span class="line-modified"> 43  * area and the spill area can grow until then. Therefore, outgoing arguments are indexed from the</span>
 44  * stack pointer, while spill slots are indexed from the beginning of the frame (and the total frame
 45  * size has to be added to get the actual offset from the stack pointer).
 46  */
 47 public abstract class FrameMap {
 48 
 49     private final TargetDescription target;
 50     private final RegisterConfig registerConfig;
 51 
 52     public interface ReferenceMapBuilderFactory {
 53 
 54         ReferenceMapBuilder newReferenceMapBuilder(int totalFrameSize);
 55     }
 56 
 57     private final ReferenceMapBuilderFactory referenceMapFactory;
 58 
 59     /**
 60      * The final frame size, not including the size of the
 61      * {@link Architecture#getReturnAddressSize() return address slot}. The value is only set after
 62      * register allocation is complete, i.e., after all spill slots have been allocated.
 63      */
</pre>
<hr />
<pre>
 68      */
 69     protected int initialSpillSize;
 70 
 71     /**
 72      * Size of the area occupied by spill slots and other stack-allocated memory blocks.
 73      */
 74     protected int spillSize;
 75 
 76     /**
 77      * Size of the area occupied by outgoing overflow arguments. This value is adjusted as calling
 78      * conventions for outgoing calls are retrieved. On some platforms, there is a minimum outgoing
 79      * size even if no overflow arguments are on the stack.
 80      */
 81     protected int outgoingSize;
 82 
 83     /**
 84      * Determines if this frame has values on the stack for outgoing calls.
 85      */
 86     protected boolean hasOutgoingStackArguments;
 87 





 88     /**
 89      * Records whether an offset to an incoming stack argument was ever returned by
 90      * {@link #offsetForStackSlot(StackSlot)}.
 91      */
 92     private boolean accessesCallerFrame;
 93 
 94     /**
 95      * Creates a new frame map for the specified method. The given registerConfig is optional, in
 96      * case null is passed the default RegisterConfig from the CodeCacheProvider will be used.
 97      */
 98     public FrameMap(CodeCacheProvider codeCache, RegisterConfig registerConfig, ReferenceMapBuilderFactory referenceMapFactory) {
 99         this.target = codeCache.getTarget();
100         this.registerConfig = registerConfig == null ? codeCache.getRegisterConfig() : registerConfig;
101         this.frameSize = -1;
102         this.outgoingSize = codeCache.getMinimumOutgoingSize();

103         this.referenceMapFactory = referenceMapFactory;
104     }
105 
106     public RegisterConfig getRegisterConfig() {
107         return registerConfig;
108     }
109 
110     public TargetDescription getTarget() {
111         return target;
112     }
113 






114     protected int returnAddressSize() {
115         return getTarget().arch.getReturnAddressSize();
116     }
117 
118     /**
119      * Determines if an offset to an incoming stack argument was ever returned by
120      * {@link #offsetForStackSlot(StackSlot)}.
121      */
122     public boolean accessesCallerFrame() {
123         return accessesCallerFrame;
124     }
125 
126     /**
127      * Gets the frame size of the compiled frame, not including the size of the
128      * {@link Architecture#getReturnAddressSize() return address slot}.
129      *
130      * @return The size of the frame (in bytes).
131      */
132     public int frameSize() {
133         assert frameSize != -1 : &quot;frame size not computed yet&quot;;
</pre>
<hr />
<pre>
200      * Informs the frame map that the compiled code calls a particular method, which may need stack
201      * space for outgoing arguments.
202      *
203      * @param cc The calling convention for the called method.
204      */
205     public void callsMethod(CallingConvention cc) {
206         reserveOutgoing(cc.getStackSize());
207     }
208 
209     /**
210      * Reserves space for stack-based outgoing arguments.
211      *
212      * @param argsSize The amount of space (in bytes) to reserve for stack-based outgoing arguments.
213      */
214     public void reserveOutgoing(int argsSize) {
215         assert frameSize == -1 : &quot;frame size must not yet be fixed&quot;;
216         outgoingSize = Math.max(outgoingSize, argsSize);
217         hasOutgoingStackArguments = hasOutgoingStackArguments || argsSize &gt; 0;
218     }
219 













220     /**
221      * Returns the spill slot size for the given {@link ValueKind}. The default value is the size in
222      * bytes for the target architecture.
223      *
224      * @param kind the {@link ValueKind} to be stored in the spill slot.
225      * @return the size in bytes
226      */
227     public int spillSlotSize(ValueKind&lt;?&gt; kind) {
228         return kind.getPlatformKind().getSizeInBytes();
229     }
230 
231     /**
232      * Reserves a spill slot in the frame of the method being compiled. The returned slot is aligned
233      * on its natural alignment, i.e., an 8-byte spill slot is aligned at an 8-byte boundary, unless
234      * overridden by a subclass.
235      *
236      * @param kind The kind of the spill slot to be reserved.
237      * @return A spill slot denoting the reserved memory area.
238      */
239     public StackSlot allocateSpillSlot(ValueKind&lt;?&gt; kind) {
240         assert frameSize == -1 : &quot;frame size must not yet be fixed&quot;;
241         int size = spillSlotSize(kind);
242         spillSize = NumUtil.roundUp(spillSize + size, size);
<span class="line-modified">243         return newStackSlot(kind);</span>
<span class="line-added">244     }</span>
<span class="line-added">245 </span>
<span class="line-added">246     private StackSlot newStackSlot(ValueKind&lt;?&gt; kind) {</span>
<span class="line-added">247         return StackSlot.get(kind, -spillSize, true);</span>
248     }
249 
250     /**
251      * Returns the size of the stack slot range for {@code slots} objects.
252      *
253      * @param slots The number of slots.
254      * @return The size in byte
255      */
256     public int spillSlotRangeSize(int slots) {
257         return slots * getTarget().wordSize;
258     }
259 
260     /**
261      * Reserves a number of contiguous slots in the frame of the method being compiled. If the
262      * requested number of slots is 0, this method returns {@code null}.
263      *
264      * @param slots the number of slots to reserve




265      * @return the first reserved stack slot (i.e., at the lowest address)
266      */
<span class="line-modified">267     public StackSlot allocateStackSlots(int slots) {</span>
268         assert frameSize == -1 : &quot;frame size must not yet be fixed&quot;;
269         if (slots == 0) {
270             return null;
271         }
<span class="line-modified">272         spillSize = NumUtil.roundUp(spillSize + spillSlotRangeSize(slots), getTarget().wordSize);</span>
<span class="line-modified">273         return newStackSlot(LIRKind.value(getTarget().arch.getWordKind()));</span>



























274     }
275 
276     public ReferenceMapBuilder newReferenceMapBuilder() {
277         return referenceMapFactory.newReferenceMapBuilder(totalFrameSize());
278     }
279 }
</pre>
</td>
</tr>
</table>
<center><a href="../dfa/LocationMarkerPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FrameMapBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
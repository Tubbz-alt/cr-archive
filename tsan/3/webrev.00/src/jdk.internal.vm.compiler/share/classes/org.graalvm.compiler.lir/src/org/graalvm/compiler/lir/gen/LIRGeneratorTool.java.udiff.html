<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LIRGenerator.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../hashing/HashFunction.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,13 +22,10 @@</span>
   */
  
  
  package org.graalvm.compiler.lir.gen;
  
<span class="udiff-line-removed">- import java.util.BitSet;</span>
<span class="udiff-line-removed">- import java.util.List;</span>
<span class="udiff-line-removed">- </span>
  import org.graalvm.compiler.core.common.CompressEncoding;
  import org.graalvm.compiler.core.common.LIRKind;
  import org.graalvm.compiler.core.common.calc.Condition;
  import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
  import org.graalvm.compiler.core.common.spi.CodeGenProviders;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,19 +62,27 @@</span>
      /**
       * Factory for creating moves.
       */
      interface MoveFactory {
  
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Checks whether the loading of the supplied constant can be deferred until usage.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         @SuppressWarnings(&quot;unused&quot;)</span>
<span class="udiff-line-added">+         default boolean mayEmbedConstantLoad(Constant constant) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          /**
           * Checks whether the supplied constant can be used without loading it into a register for
           * most operations, i.e., for commonly used arithmetic, logical, and comparison operations.
           *
<span class="udiff-line-modified-removed">-          * @param c The constant to check.</span>
<span class="udiff-line-modified-added">+          * @param constant The constant to check.</span>
           * @return True if the constant can be used directly, false if the constant needs to be in a
           *         register.
           */
<span class="udiff-line-modified-removed">-         boolean canInlineConstant(Constant c);</span>
<span class="udiff-line-modified-added">+         boolean canInlineConstant(Constant constant);</span>
  
          /**
           * @param constant The constant that might be moved to a stack slot.
           * @return {@code true} if constant to stack moves are supported for this constant.
           */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131,10 +136,14 @@</span>
       */
      MoveFactory getSpillMoveFactory();
  
      BlockScope getBlockScope(AbstractBlockBase&lt;?&gt; block);
  
<span class="udiff-line-added">+     boolean canInlineConstant(Constant constant);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     boolean mayEmbedConstantLoad(Constant constant);</span>
<span class="udiff-line-added">+ </span>
      Value emitConstant(LIRKind kind, Constant constant);
  
      Value emitJavaConstant(JavaConstant constant);
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -193,10 +202,14 @@</span>
  
      Variable emitMove(Value input);
  
      void emitMove(AllocatableValue dst, Value src);
  
<span class="udiff-line-added">+     Variable emitReadRegister(Register register, ValueKind&lt;?&gt; kind);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void emitWriteRegister(Register dst, Value src, ValueKind&lt;?&gt; wordStamp);</span>
<span class="udiff-line-added">+ </span>
      void emitMoveConstant(AllocatableValue dst, Constant src);
  
      Variable emitAddress(AllocatableValue stackslot);
  
      void emitMembar(int barriers);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -264,19 +277,22 @@</span>
      @SuppressWarnings(&quot;unused&quot;)
      default Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
          throw GraalError.unimplemented(&quot;String.compareTo substitution is not implemented on this architecture&quot;);
      }
  
<span class="udiff-line-modified-removed">-     Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, int constantLength, boolean directPointers);</span>
<span class="udiff-line-modified-added">+     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="udiff-line-added">+     default Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {</span>
<span class="udiff-line-added">+         throw GraalError.unimplemented(&quot;Array.equals substitution is not implemented on this architecture&quot;);</span>
<span class="udiff-line-added">+     }</span>
  
      @SuppressWarnings(&quot;unused&quot;)
<span class="udiff-line-modified-removed">-     default Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, int constantLength, boolean directPointers) {</span>
<span class="udiff-line-modified-added">+     default Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, boolean directPointers) {</span>
          throw GraalError.unimplemented(&quot;Array.equals with different types substitution is not implemented on this architecture&quot;);
      }
  
      @SuppressWarnings(&quot;unused&quot;)
<span class="udiff-line-modified-removed">-     default Variable emitArrayIndexOf(JavaKind kind, boolean findTwoConsecutive, Value sourcePointer, Value sourceCount, Value... searchValues) {</span>
<span class="udiff-line-modified-added">+     default Variable emitArrayIndexOf(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, Value sourcePointer, Value sourceCount, Value fromIndex, Value... searchValues) {</span>
          throw GraalError.unimplemented(&quot;String.indexOf substitution is not implemented on this architecture&quot;);
      }
  
      /*
       * The routines emitStringLatin1Inflate/3 and emitStringUTF16Compress/3 models a simplified
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -322,12 +338,12 @@</span>
       * Emits an instruction that prevents speculative execution from proceeding: no instruction
       * after this fence will execute until all previous instructions have retired.
       */
      void emitSpeculationFence();
  
<span class="udiff-line-modified-removed">-     default VirtualStackSlot allocateStackSlots(int slots, BitSet objects, List&lt;VirtualStackSlot&gt; outObjectStackSlots) {</span>
<span class="udiff-line-modified-removed">-         return getResult().getFrameMapBuilder().allocateStackSlots(slots, objects, outObjectStackSlots);</span>
<span class="udiff-line-modified-added">+     default VirtualStackSlot allocateStackSlots(int slots) {</span>
<span class="udiff-line-modified-added">+         return getResult().getFrameMapBuilder().allocateStackSlots(slots);</span>
      }
  
      default Value emitReadCallerStackPointer(Stamp wordStamp) {
          /*
           * We do not know the frame size yet. So we load the address of the first spill slot
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -338,6 +354,11 @@</span>
      }
  
      default Value emitReadReturnAddress(Stamp wordStamp, int returnAddressSize) {
          return emitMove(StackSlot.get(getLIRKind(wordStamp), -returnAddressSize, true));
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @SuppressWarnings(&quot;unused&quot;)</span>
<span class="udiff-line-added">+     default void emitZeroMemory(Value address, Value length, boolean isAligned) {</span>
<span class="udiff-line-added">+         throw GraalError.unimplemented(&quot;Bulk zeroing is not implemented on this architecture&quot;);</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="LIRGenerator.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../hashing/HashFunction.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/framemap/FrameMap.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.framemap;
 26 
 27 import java.util.ArrayList;
 28 import java.util.BitSet;
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.core.common.NumUtil;
 32 import org.graalvm.compiler.core.common.PermanentBailoutException;
 33 import org.graalvm.compiler.core.common.LIRKind;
 34 
 35 import jdk.vm.ci.code.Architecture;
 36 import jdk.vm.ci.code.CallingConvention;
 37 import jdk.vm.ci.code.CodeCacheProvider;
 38 import jdk.vm.ci.code.RegisterConfig;
 39 import jdk.vm.ci.code.StackSlot;
 40 import jdk.vm.ci.code.TargetDescription;
 41 import jdk.vm.ci.meta.Value;
 42 import jdk.vm.ci.meta.ValueKind;
 43 
 44 /**
 45  * This class is used to build the stack frame layout for a compiled method. A {@link StackSlot} is
 46  * used to index slots of the frame relative to the stack pointer. The frame size is only fixed
 47  * after register allocation when all spill slots have been allocated. Both the outgoing argument
 48  * area and the spill are can grow until then. Therefore, outgoing arguments are indexed from the
 49  * stack pointer, while spill slots are indexed from the beginning of the frame (and the total frame
 50  * size has to be added to get the actual offset from the stack pointer).
 51  */
 52 public abstract class FrameMap {
 53 
 54     private final TargetDescription target;
 55     private final RegisterConfig registerConfig;
 56 
 57     public interface ReferenceMapBuilderFactory {
 58 
 59         ReferenceMapBuilder newReferenceMapBuilder(int totalFrameSize);
 60     }
 61 
 62     private final ReferenceMapBuilderFactory referenceMapFactory;
 63 
 64     /**
 65      * The final frame size, not including the size of the
 66      * {@link Architecture#getReturnAddressSize() return address slot}. The value is only set after
 67      * register allocation is complete, i.e., after all spill slots have been allocated.
 68      */
 69     private int frameSize;
 70 
 71     /**
 72      * Initial size of the area occupied by spill slots and other stack-allocated memory blocks.
 73      */
 74     protected int initialSpillSize;
 75 
 76     /**
 77      * Size of the area occupied by spill slots and other stack-allocated memory blocks.
 78      */
 79     protected int spillSize;
 80 
 81     /**
 82      * Size of the area occupied by outgoing overflow arguments. This value is adjusted as calling
 83      * conventions for outgoing calls are retrieved. On some platforms, there is a minimum outgoing
 84      * size even if no overflow arguments are on the stack.
 85      */
 86     protected int outgoingSize;
 87 
 88     /**
 89      * Determines if this frame has values on the stack for outgoing calls.
 90      */
 91     protected boolean hasOutgoingStackArguments;
 92 
 93     /**
 94      * The list of stack slots allocated in this frame that are present in every reference map.
 95      */
 96     private final List&lt;StackSlot&gt; objectStackSlots;
 97 
 98     /**
 99      * Records whether an offset to an incoming stack argument was ever returned by
100      * {@link #offsetForStackSlot(StackSlot)}.
101      */
102     private boolean accessesCallerFrame;
103 
104     /**
105      * Creates a new frame map for the specified method. The given registerConfig is optional, in
106      * case null is passed the default RegisterConfig from the CodeCacheProvider will be used.
107      */
108     public FrameMap(CodeCacheProvider codeCache, RegisterConfig registerConfig, ReferenceMapBuilderFactory referenceMapFactory) {
109         this.target = codeCache.getTarget();
110         this.registerConfig = registerConfig == null ? codeCache.getRegisterConfig() : registerConfig;
111         this.frameSize = -1;
112         this.outgoingSize = codeCache.getMinimumOutgoingSize();
113         this.objectStackSlots = new ArrayList&lt;&gt;();
114         this.referenceMapFactory = referenceMapFactory;
115     }
116 
117     public RegisterConfig getRegisterConfig() {
118         return registerConfig;
119     }
120 
121     public TargetDescription getTarget() {
122         return target;
123     }
124 
125     public void addLiveValues(ReferenceMapBuilder refMap) {
126         for (Value value : objectStackSlots) {
127             refMap.addLiveValue(value);
128         }
129     }
130 
131     protected int returnAddressSize() {
132         return getTarget().arch.getReturnAddressSize();
133     }
134 
135     /**
136      * Determines if an offset to an incoming stack argument was ever returned by
137      * {@link #offsetForStackSlot(StackSlot)}.
138      */
139     public boolean accessesCallerFrame() {
140         return accessesCallerFrame;
141     }
142 
143     /**
144      * Gets the frame size of the compiled frame, not including the size of the
145      * {@link Architecture#getReturnAddressSize() return address slot}.
146      *
147      * @return The size of the frame (in bytes).
148      */
149     public int frameSize() {
150         assert frameSize != -1 : &quot;frame size not computed yet&quot;;
151         return frameSize;
152     }
153 
154     public int outgoingSize() {
155         return outgoingSize;
156     }
157 
158     /**
159      * Determines if any space is used in the frame apart from the
160      * {@link Architecture#getReturnAddressSize() return address slot}.
161      */
162     public boolean frameNeedsAllocating() {
163         int unalignedFrameSize = spillSize - returnAddressSize();
164         return hasOutgoingStackArguments || unalignedFrameSize != 0;
165     }
166 
167     /**
168      * Gets the total frame size of the compiled frame, including the size of the
169      * {@link Architecture#getReturnAddressSize() return address slot}.
170      *
171      * @return The total size of the frame (in bytes).
172      */
173     public abstract int totalFrameSize();
174 
175     /**
176      * Gets the current size of this frame. This is the size that would be returned by
177      * {@link #frameSize()} if {@link #finish()} were called now.
178      */
179     public abstract int currentFrameSize();
180 
181     /**
182      * Aligns the given frame size to the stack alignment size and return the aligned size.
183      *
184      * @param size the initial frame size to be aligned
185      * @return the aligned frame size
186      */
187     protected int alignFrameSize(int size) {
188         return NumUtil.roundUp(size, getTarget().stackAlignment);
189     }
190 
191     /**
192      * Computes the final size of this frame. After this method has been called, methods that change
193      * the frame size cannot be called anymore, e.g., no more spill slots or outgoing arguments can
194      * be requested.
195      */
196     public void finish() {
197         frameSize = currentFrameSize();
198         if (frameSize &gt; getRegisterConfig().getMaximumFrameSize()) {
199             throw new PermanentBailoutException(&quot;Frame size (%d) exceeded maximum allowed frame size (%d).&quot;, frameSize, getRegisterConfig().getMaximumFrameSize());
200         }
201     }
202 
203     /**
204      * Computes the offset of a stack slot relative to the frame register.
205      *
206      * @param slot a stack slot
207      * @return the offset of the stack slot
208      */
209     public int offsetForStackSlot(StackSlot slot) {
210         if (slot.isInCallerFrame()) {
211             accessesCallerFrame = true;
212         }
213         return slot.getOffset(totalFrameSize());
214     }
215 
216     /**
217      * Informs the frame map that the compiled code calls a particular method, which may need stack
218      * space for outgoing arguments.
219      *
220      * @param cc The calling convention for the called method.
221      */
222     public void callsMethod(CallingConvention cc) {
223         reserveOutgoing(cc.getStackSize());
224     }
225 
226     /**
227      * Reserves space for stack-based outgoing arguments.
228      *
229      * @param argsSize The amount of space (in bytes) to reserve for stack-based outgoing arguments.
230      */
231     public void reserveOutgoing(int argsSize) {
232         assert frameSize == -1 : &quot;frame size must not yet be fixed&quot;;
233         outgoingSize = Math.max(outgoingSize, argsSize);
234         hasOutgoingStackArguments = hasOutgoingStackArguments || argsSize &gt; 0;
235     }
236 
237     /**
238      * Reserves a new spill slot in the frame of the method being compiled. The returned slot is
239      * aligned on its natural alignment, i.e., an 8-byte spill slot is aligned at an 8-byte
240      * boundary.
241      *
242      * @param kind The kind of the spill slot to be reserved.
243      * @param additionalOffset
244      * @return A spill slot denoting the reserved memory area.
245      */
246     protected StackSlot allocateNewSpillSlot(ValueKind&lt;?&gt; kind, int additionalOffset) {
247         return StackSlot.get(kind, -spillSize + additionalOffset, true);
248     }
249 
250     /**
251      * Returns the spill slot size for the given {@link ValueKind}. The default value is the size in
252      * bytes for the target architecture.
253      *
254      * @param kind the {@link ValueKind} to be stored in the spill slot.
255      * @return the size in bytes
256      */
257     public int spillSlotSize(ValueKind&lt;?&gt; kind) {
258         return kind.getPlatformKind().getSizeInBytes();
259     }
260 
261     /**
262      * Reserves a spill slot in the frame of the method being compiled. The returned slot is aligned
263      * on its natural alignment, i.e., an 8-byte spill slot is aligned at an 8-byte boundary, unless
264      * overridden by a subclass.
265      *
266      * @param kind The kind of the spill slot to be reserved.
267      * @return A spill slot denoting the reserved memory area.
268      */
269     public StackSlot allocateSpillSlot(ValueKind&lt;?&gt; kind) {
270         assert frameSize == -1 : &quot;frame size must not yet be fixed&quot;;
271         int size = spillSlotSize(kind);
272         spillSize = NumUtil.roundUp(spillSize + size, size);
273         return allocateNewSpillSlot(kind, 0);
274     }
275 
276     /**
277      * Returns the size of the stack slot range for {@code slots} objects.
278      *
279      * @param slots The number of slots.
280      * @return The size in byte
281      */
282     public int spillSlotRangeSize(int slots) {
283         return slots * getTarget().wordSize;
284     }
285 
286     /**
287      * Reserves a number of contiguous slots in the frame of the method being compiled. If the
288      * requested number of slots is 0, this method returns {@code null}.
289      *
290      * @param slots the number of slots to reserve
291      * @param objects specifies the indexes of the object pointer slots. The caller is responsible
292      *            for guaranteeing that each such object pointer slot is initialized before any
293      *            instruction that uses a reference map. Without this guarantee, the garbage
294      *            collector could see garbage object values.
295      * @return the first reserved stack slot (i.e., at the lowest address)
296      */
297     public StackSlot allocateStackSlots(int slots, BitSet objects) {
298         assert frameSize == -1 : &quot;frame size must not yet be fixed&quot;;
299         if (slots == 0) {
300             return null;
301         }
302         spillSize += spillSlotRangeSize(slots);
303 
304         if (!objects.isEmpty()) {
305             assert objects.length() &lt;= slots;
306             StackSlot result = null;
307             for (int slotIndex = 0; slotIndex &lt; slots; slotIndex++) {
308                 StackSlot objectSlot = null;
309                 if (objects.get(slotIndex)) {
310                     objectSlot = allocateNewSpillSlot(LIRKind.reference(getTarget().arch.getWordKind()), slotIndex * getTarget().wordSize);
311                     addObjectStackSlot(objectSlot);
312                 }
313                 if (slotIndex == 0) {
314                     if (objectSlot != null) {
315                         result = objectSlot;
316                     } else {
317                         result = allocateNewSpillSlot(LIRKind.value(getTarget().arch.getWordKind()), 0);
318                     }
319                 }
320             }
321             assert result != null;
322             return result;
323 
324         } else {
325             return allocateNewSpillSlot(LIRKind.value(getTarget().arch.getWordKind()), 0);
326         }
327     }
328 
329     protected void addObjectStackSlot(StackSlot objectSlot) {
330         objectStackSlots.add(objectSlot);
331     }
332 
333     public ReferenceMapBuilder newReferenceMapBuilder() {
334         return referenceMapFactory.newReferenceMapBuilder(totalFrameSize());
335     }
336 }
    </pre>
  </body>
</html>
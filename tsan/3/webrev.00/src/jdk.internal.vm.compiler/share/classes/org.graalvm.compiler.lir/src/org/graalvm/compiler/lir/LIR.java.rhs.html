<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/LIR.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir;
 26 
 27 import java.util.ArrayList;
 28 import java.util.Arrays;
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.asm.Label;
 32 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 33 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
 34 import org.graalvm.compiler.core.common.cfg.BlockMap;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.lir.StandardOp.BlockEndOp;
<a name="2" id="anc2"></a>
 37 import org.graalvm.compiler.lir.StandardOp.LabelHoldingOp;
<a name="3" id="anc3"></a><span class="line-added"> 38 import org.graalvm.compiler.lir.StandardOp.LabelOp;</span>
 39 import org.graalvm.compiler.lir.gen.LIRGenerator;
 40 import org.graalvm.compiler.options.OptionValues;
 41 
 42 /**
 43  * This class implements the overall container for the LIR graph and directs its construction,
 44  * optimization, and finalization.
 45  */
 46 public final class LIR extends LIRGenerator.VariableProvider {
 47 
 48     private final AbstractControlFlowGraph&lt;?&gt; cfg;
 49 
 50     /**
 51      * The linear-scan ordered list of blocks.
 52      */
 53     private final AbstractBlockBase&lt;?&gt;[] linearScanOrder;
 54 
 55     /**
 56      * The order in which the code is emitted.
 57      */
 58     private final AbstractBlockBase&lt;?&gt;[] codeEmittingOrder;
 59 
 60     /**
 61      * Map from {@linkplain AbstractBlockBase block} to {@linkplain LIRInstruction}s. Note that we
 62      * are using {@link ArrayList} instead of {@link List} to avoid interface dispatch.
 63      */
 64     private final BlockMap&lt;ArrayList&lt;LIRInstruction&gt;&gt; lirInstructions;
 65 
 66     private boolean hasArgInCallerFrame;
 67 
 68     private final OptionValues options;
 69 
 70     private final DebugContext debug;
 71 
 72     /**
 73      * Creates a new LIR instance for the specified compilation.
 74      */
<a name="4" id="anc4"></a><span class="line-modified"> 75     public LIR(AbstractControlFlowGraph&lt;?&gt; cfg,</span>
<span class="line-added"> 76                     AbstractBlockBase&lt;?&gt;[] linearScanOrder,</span>
<span class="line-added"> 77                     AbstractBlockBase&lt;?&gt;[] codeEmittingOrder,</span>
<span class="line-added"> 78                     OptionValues options,</span>
<span class="line-added"> 79                     DebugContext debug) {</span>
 80         this.cfg = cfg;
 81         this.codeEmittingOrder = codeEmittingOrder;
 82         this.linearScanOrder = linearScanOrder;
 83         this.lirInstructions = new BlockMap&lt;&gt;(cfg);
 84         this.options = options;
 85         this.debug = debug;
 86     }
 87 
 88     public AbstractControlFlowGraph&lt;?&gt; getControlFlowGraph() {
 89         return cfg;
 90     }
 91 
 92     public OptionValues getOptions() {
 93         return options;
 94     }
 95 
 96     public DebugContext getDebug() {
 97         return debug;
 98     }
 99 
100     /**
101      * Determines if any instruction in the LIR has debug info associated with it.
102      */
103     public boolean hasDebugInfo() {
104         for (AbstractBlockBase&lt;?&gt; b : linearScanOrder()) {
105             for (LIRInstruction op : getLIRforBlock(b)) {
106                 if (op.hasState()) {
107                     return true;
108                 }
109             }
110         }
111         return false;
112     }
113 
114     public ArrayList&lt;LIRInstruction&gt; getLIRforBlock(AbstractBlockBase&lt;?&gt; block) {
115         return lirInstructions.get(block);
116     }
117 
118     public void setLIRforBlock(AbstractBlockBase&lt;?&gt; block, ArrayList&lt;LIRInstruction&gt; list) {
119         assert getLIRforBlock(block) == null : &quot;lir instruction list should only be initialized once&quot;;
120         lirInstructions.put(block, list);
121     }
122 
123     /**
124      * Gets the linear scan ordering of blocks as an array.
125      *
126      * @return the blocks in linear scan order
127      */
128     public AbstractBlockBase&lt;?&gt;[] linearScanOrder() {
129         return linearScanOrder;
130     }
131 
132     public AbstractBlockBase&lt;?&gt;[] codeEmittingOrder() {
133         return codeEmittingOrder;
134     }
135 
136     public void setHasArgInCallerFrame() {
137         hasArgInCallerFrame = true;
138     }
139 
140     /**
141      * Determines if any of the parameters to the method are passed via the stack where the
142      * parameters are located in the caller&#39;s frame.
143      */
144     public boolean hasArgInCallerFrame() {
145         return hasArgInCallerFrame;
146     }
147 
148     /**
149      * Gets the next non-{@code null} block in a list.
150      *
151      * @param blocks list of blocks
152      * @param blockIndex index of the current block
153      * @return the next block in the list that is none {@code null} or {@code null} if there is no
154      *         such block
155      */
156     public static AbstractBlockBase&lt;?&gt; getNextBlock(AbstractBlockBase&lt;?&gt;[] blocks, int blockIndex) {
157         for (int nextIndex = blockIndex + 1; nextIndex &gt; 0 &amp;&amp; nextIndex &lt; blocks.length; nextIndex++) {
158             AbstractBlockBase&lt;?&gt; nextBlock = blocks[nextIndex];
159             if (nextBlock != null) {
160                 return nextBlock;
161             }
162         }
163         return null;
164     }
165 
166     /**
167      * Gets the exception edge (if any) originating at a given operation.
168      */
169     public static LabelRef getExceptionEdge(LIRInstruction op) {
170         final LabelRef[] exceptionEdge = {null};
171         op.forEachState(state -&gt; {
172             if (state.exceptionEdge != null) {
173                 assert exceptionEdge[0] == null;
174                 exceptionEdge[0] = state.exceptionEdge;
175             }
176         });
177         return exceptionEdge[0];
178     }
179 
180     /**
181      * The maximum distance an operation with an {@linkplain #getExceptionEdge(LIRInstruction)
182      * exception edge} can be from the last instruction of a LIR block. The value of 3 is based on a
183      * non-void call operation that has an exception edge. Such a call may move the result to
184      * another register and then spill it.
185      * &lt;p&gt;
186      * The rationale for such a constant is to limit the search for an insertion point when adding
187      * move operations at the end of a block. Such moves must be inserted before all control flow
188      * instructions.
189      */
190     public static final int MAX_EXCEPTION_EDGE_OP_DISTANCE_FROM_END = 3;
191 
192     public static boolean verifyBlock(LIR lir, AbstractBlockBase&lt;?&gt; block) {
193         ArrayList&lt;LIRInstruction&gt; ops = lir.getLIRforBlock(block);
194         if (ops.size() == 0) {
195             return false;
196         }
197         assert ops.get(0) instanceof LabelOp : String.format(&quot;Not a Label %s (Block %s)&quot;, ops.get(0).getClass(), block);
198         LIRInstruction opWithExceptionEdge = null;
199         int index = 0;
200         int lastIndex = ops.size() - 1;
201         for (LIRInstruction op : ops.subList(0, lastIndex)) {
202             assert !(op instanceof BlockEndOp) : String.format(&quot;BlockEndOp %s (Block %s)&quot;, op.getClass(), block);
203             LabelRef exceptionEdge = getExceptionEdge(op);
204             if (exceptionEdge != null) {
205                 assert opWithExceptionEdge == null : &quot;multiple ops with an exception edge not allowed&quot;;
206                 opWithExceptionEdge = op;
207                 int distanceFromEnd = lastIndex - index;
208                 assert distanceFromEnd &lt;= MAX_EXCEPTION_EDGE_OP_DISTANCE_FROM_END;
209             }
210             index++;
211         }
212         LIRInstruction end = ops.get(lastIndex);
213         assert end instanceof BlockEndOp : String.format(&quot;Not a BlockEndOp %s (Block %s)&quot;, end.getClass(), block);
214         return true;
215     }
216 
217     public static boolean verifyBlocks(LIR lir, AbstractBlockBase&lt;?&gt;[] blocks) {
218         for (AbstractBlockBase&lt;?&gt; block : blocks) {
219             if (block == null) {
220                 continue;
221             }
222             for (AbstractBlockBase&lt;?&gt; sux : block.getSuccessors()) {
223                 assert Arrays.asList(blocks).contains(sux) : &quot;missing successor from: &quot; + block + &quot;to: &quot; + sux;
224             }
225             for (AbstractBlockBase&lt;?&gt; pred : block.getPredecessors()) {
226                 assert Arrays.asList(blocks).contains(pred) : &quot;missing predecessor from: &quot; + block + &quot;to: &quot; + pred;
227             }
228             if (!verifyBlock(lir, block)) {
229                 return false;
230             }
231         }
232         return true;
233     }
234 
235     public void resetLabels() {
236 
237         for (AbstractBlockBase&lt;?&gt; block : codeEmittingOrder()) {
238             if (block == null) {
239                 continue;
240             }
241             for (LIRInstruction inst : lirInstructions.get(block)) {
242                 if (inst instanceof LabelHoldingOp) {
243                     Label label = ((LabelHoldingOp) inst).getLabel();
244                     if (label != null) {
245                         label.reset();
246                     }
247                 }
248             }
249         }
250     }
251 
252 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
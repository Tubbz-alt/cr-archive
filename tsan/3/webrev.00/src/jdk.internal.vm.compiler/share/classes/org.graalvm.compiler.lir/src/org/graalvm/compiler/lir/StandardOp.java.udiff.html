<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/StandardOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LIRVerifier.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="alloc/lsra/LinearScanLifetimeAnalysisPhase.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/StandardOp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22,21 +22,26 @@</span>
   */
  
  
  package org.graalvm.compiler.lir;
  
<span class="udiff-line-added">+ import static jdk.vm.ci.code.ValueUtil.asStackSlot;</span>
<span class="udiff-line-added">+ import static jdk.vm.ci.code.ValueUtil.isStackSlot;</span>
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.OUTGOING;
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
  import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
  
  import java.util.ArrayList;
<span class="udiff-line-added">+ import java.util.Arrays;</span>
  import java.util.EnumSet;
  
  import jdk.internal.vm.compiler.collections.EconomicSet;
<span class="udiff-line-added">+ import jdk.internal.vm.compiler.collections.Equivalence;</span>
  import org.graalvm.compiler.asm.Label;
<span class="udiff-line-added">+ import org.graalvm.compiler.core.common.GraalOptions;</span>
  import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
  import org.graalvm.compiler.debug.GraalError;
  import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  import org.graalvm.compiler.lir.framemap.FrameMap;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,11 +157,11 @@</span>
          }
  
          @Override
          public void emitCode(CompilationResultBuilder crb) {
              if (align) {
<span class="udiff-line-modified-removed">-                 crb.asm.align(crb.target.wordSize * 2);</span>
<span class="udiff-line-modified-added">+                 crb.asm.align(GraalOptions.LoopHeaderAlignment.getValue(crb.getOptions()));</span>
              }
              crb.asm.bind(label);
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -297,36 +302,136 @@</span>
      /**
       * An operation that saves registers to the stack. The set of saved registers can be
       * {@linkplain #remove(EconomicSet) pruned} and a mapping from registers to the frame slots in
       * which they are saved can be {@linkplain #getMap(FrameMap) retrieved}.
       */
<span class="udiff-line-modified-removed">-     public interface SaveRegistersOp {</span>
<span class="udiff-line-modified-added">+     public abstract static class SaveRegistersOp extends LIRInstruction {</span>
<span class="udiff-line-added">+         public static final LIRInstructionClass&lt;SaveRegistersOp&gt; TYPE = LIRInstructionClass.create(SaveRegistersOp.class);</span>
  
          /**
<span class="udiff-line-modified-removed">-          * Determines if the {@link #remove(EconomicSet)} operation is supported for this object.</span>
<span class="udiff-line-modified-added">+          * The registers (potentially) saved by this operation.</span>
           */
<span class="udiff-line-modified-removed">-         boolean supportsRemove();</span>
<span class="udiff-line-modified-added">+         protected final Register[] savedRegisters;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * The slots to which the registers are saved.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         @Def(STACK) protected final AllocatableValue[] slots;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @param savedRegisters the registers saved by this operation which may be subject to</span>
<span class="udiff-line-added">+          *            {@linkplain #remove(EconomicSet) pruning}</span>
<span class="udiff-line-added">+          * @param savedRegisterLocations the slots to which the registers are saved</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         protected SaveRegistersOp(LIRInstructionClass&lt;? extends SaveRegistersOp&gt; c, Register[] savedRegisters, AllocatableValue[] savedRegisterLocations) {</span>
<span class="udiff-line-added">+             super(c);</span>
<span class="udiff-line-added">+             assert Arrays.asList(savedRegisterLocations).stream().allMatch(LIRValueUtil::isVirtualStackSlot);</span>
<span class="udiff-line-added">+             this.savedRegisters = savedRegisters;</span>
<span class="udiff-line-added">+             this.slots = savedRegisterLocations;</span>
<span class="udiff-line-added">+         }</span>
  
          /**
           * Prunes {@code doNotSave} from the registers saved by this operation.
           *
           * @param doNotSave registers that should not be saved by this operation
           * @return the number of registers pruned
<span class="udiff-line-removed">-          * @throws UnsupportedOperationException if removal is not {@linkplain #supportsRemove()</span>
<span class="udiff-line-removed">-          *             supported}</span>
           */
<span class="udiff-line-modified-removed">-         int remove(EconomicSet&lt;Register&gt; doNotSave);</span>
<span class="udiff-line-modified-added">+         public int remove(EconomicSet&lt;Register&gt; doNotSave) {</span>
<span class="udiff-line-added">+             return prune(doNotSave, savedRegisters);</span>
<span class="udiff-line-added">+         }</span>
  
          /**
           * Gets a map from the saved registers saved by this operation to the frame slots in which
           * they are saved.
           *
           * @param frameMap used to {@linkplain FrameMap#offsetForStackSlot(StackSlot) convert} a
           *            virtual slot to a frame slot index
           */
<span class="udiff-line-removed">-         RegisterSaveLayout getMap(FrameMap frameMap);</span>
  
<span class="udiff-line-added">+         public RegisterSaveLayout getMap(FrameMap frameMap) {</span>
<span class="udiff-line-added">+             int total = 0;</span>
<span class="udiff-line-added">+             for (int i = 0; i &lt; savedRegisters.length; i++) {</span>
<span class="udiff-line-added">+                 if (savedRegisters[i] != null) {</span>
<span class="udiff-line-added">+                     total++;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             Register[] keys = new Register[total];</span>
<span class="udiff-line-added">+             int[] values = new int[total];</span>
<span class="udiff-line-added">+             if (total != 0) {</span>
<span class="udiff-line-added">+                 int mapIndex = 0;</span>
<span class="udiff-line-added">+                 for (int i = 0; i &lt; savedRegisters.length; i++) {</span>
<span class="udiff-line-added">+                     if (savedRegisters[i] != null) {</span>
<span class="udiff-line-added">+                         keys[mapIndex] = savedRegisters[i];</span>
<span class="udiff-line-added">+                         assert isStackSlot(slots[i]) : &quot;not a StackSlot: &quot; + slots[i];</span>
<span class="udiff-line-added">+                         StackSlot slot = asStackSlot(slots[i]);</span>
<span class="udiff-line-added">+                         values[mapIndex] = indexForStackSlot(frameMap, slot);</span>
<span class="udiff-line-added">+                         mapIndex++;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 assert mapIndex == total;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return new RegisterSaveLayout(keys, values);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public Register[] getSavedRegisters() {</span>
<span class="udiff-line-added">+             return savedRegisters;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public EconomicSet&lt;Register&gt; getSaveableRegisters() {</span>
<span class="udiff-line-added">+             EconomicSet&lt;Register&gt; registers = EconomicSet.create(Equivalence.IDENTITY);</span>
<span class="udiff-line-added">+             for (Register r : savedRegisters) {</span>
<span class="udiff-line-added">+                 registers.add(r);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return registers;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public AllocatableValue[] getSlots() {</span>
<span class="udiff-line-added">+             return slots;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public abstract void emitCode(CompilationResultBuilder crb);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static int prune(EconomicSet&lt;Register&gt; toRemove, Register[] registers) {</span>
<span class="udiff-line-added">+             int pruned = 0;</span>
<span class="udiff-line-added">+             for (int i = 0; i &lt; registers.length; i++) {</span>
<span class="udiff-line-added">+                 if (registers[i] != null) {</span>
<span class="udiff-line-added">+                     if (toRemove.contains(registers[i])) {</span>
<span class="udiff-line-added">+                         registers[i] = null;</span>
<span class="udiff-line-added">+                         pruned++;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return pruned;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Computes the index of a stack slot relative to slot 0. This is also the bit index of</span>
<span class="udiff-line-added">+          * stack slots in the reference map.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @param slot a stack slot</span>
<span class="udiff-line-added">+          * @return the index of the stack slot</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private static int indexForStackSlot(FrameMap frameMap, StackSlot slot) {</span>
<span class="udiff-line-added">+             assert frameMap.offsetForStackSlot(slot) % frameMap.getTarget().wordSize == 0;</span>
<span class="udiff-line-added">+             int value = frameMap.offsetForStackSlot(slot) / frameMap.getTarget().wordSize;</span>
<span class="udiff-line-added">+             return value;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Marker interface for an operation that restores the registers saved by</span>
<span class="udiff-line-added">+      * {@link SaveRegistersOp}.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public interface RestoreRegistersOp {</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Marker interface for an operation that kills some set register and stack locations.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public interface ZapRegistersOp {</span>
      }
  
      /**
       * A LIR operation that does nothing. If the operation records its position, it can be
       * subsequently {@linkplain #replace(LIR, LIRInstruction) replaced}.
</pre>
<center><a href="LIRVerifier.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="alloc/lsra/LinearScanLifetimeAnalysisPhase.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
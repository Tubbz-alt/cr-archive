<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/LIRIntrospection.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LIRInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRVerifier.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/LIRIntrospection.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
197                 assert getOperandModeAnnotation(field) == null : &quot;Field must not have operand mode annotation: &quot; + field;
198                 assert field.getAnnotation(LIRInstruction.State.class) == null : &quot;Field must not have state annotation: &quot; + field;
199                 super.scanField(field, offset);
200             }
201         }
202 
203         private static boolean verifyFlags(Field field, Class&lt;?&gt; type, EnumSet&lt;OperandFlag&gt; flags) {
204             if (flags.contains(REG)) {
205                 assert type.isAssignableFrom(REGISTER_VALUE_CLASS) || type.isAssignableFrom(VARIABLE_CLASS) : &quot;Cannot assign RegisterValue / Variable to field with REG flag:&quot; + field;
206             }
207             if (flags.contains(STACK)) {
208                 assert type.isAssignableFrom(STACK_SLOT_CLASS) : &quot;Cannot assign StackSlot to field with STACK flag:&quot; + field;
209             }
210             if (flags.contains(CONST)) {
211                 assert type.isAssignableFrom(CONSTANT_VALUE_CLASS) : &quot;Cannot assign Constant to field with CONST flag:&quot; + field;
212             }
213             return true;
214         }
215     }
216 

















217     protected static void forEach(LIRInstruction inst, Values values, OperandMode mode, InstructionValueProcedure proc) {
218         for (int i = 0; i &lt; values.getCount(); i++) {
219             assert LIRInstruction.ALLOWED_FLAGS.get(mode).containsAll(values.getFlags(i));
220 
221             if (i &lt; values.getDirectCount()) {
222                 Value value = values.getValue(inst, i);
223                 Value newValue;
224                 if (value instanceof CompositeValue) {
225                     CompositeValue composite = (CompositeValue) value;
226                     newValue = composite.forEachComponent(inst, mode, proc);
227                 } else {
228                     newValue = proc.doValue(inst, value, mode, values.getFlags(i));
229                 }
230                 if (!value.identityEquals(newValue)) {



231                     values.setValue(inst, i, newValue);
232                 }
233             } else {
234                 Value[] valueArray = values.getValueArray(inst, i);
235                 for (int j = 0; j &lt; valueArray.length; j++) {
236                     Value value = valueArray[j];
237                     Value newValue;
238                     if (value instanceof CompositeValue) {
239                         CompositeValue composite = (CompositeValue) value;
240                         newValue = composite.forEachComponent(inst, mode, proc);
241                     } else {
242                         newValue = proc.doValue(inst, value, mode, values.getFlags(i));
243                     }
244                     if (!value.identityEquals(newValue)) {
245                         valueArray[j] = newValue;
246                     }
247                 }
248             }
249         }
250     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
197                 assert getOperandModeAnnotation(field) == null : &quot;Field must not have operand mode annotation: &quot; + field;
198                 assert field.getAnnotation(LIRInstruction.State.class) == null : &quot;Field must not have state annotation: &quot; + field;
199                 super.scanField(field, offset);
200             }
201         }
202 
203         private static boolean verifyFlags(Field field, Class&lt;?&gt; type, EnumSet&lt;OperandFlag&gt; flags) {
204             if (flags.contains(REG)) {
205                 assert type.isAssignableFrom(REGISTER_VALUE_CLASS) || type.isAssignableFrom(VARIABLE_CLASS) : &quot;Cannot assign RegisterValue / Variable to field with REG flag:&quot; + field;
206             }
207             if (flags.contains(STACK)) {
208                 assert type.isAssignableFrom(STACK_SLOT_CLASS) : &quot;Cannot assign StackSlot to field with STACK flag:&quot; + field;
209             }
210             if (flags.contains(CONST)) {
211                 assert type.isAssignableFrom(CONSTANT_VALUE_CLASS) : &quot;Cannot assign Constant to field with CONST flag:&quot; + field;
212             }
213             return true;
214         }
215     }
216 
<span class="line-added">217     private static boolean verifyAssignment(LIRInstruction inst, Value newValue, EnumSet&lt;OperandFlag&gt; flags) {</span>
<span class="line-added">218         Class&lt;?&gt; type = newValue.getClass();</span>
<span class="line-added">219         if (!flags.contains(REG)) {</span>
<span class="line-added">220             assert !type.isAssignableFrom(REGISTER_VALUE_CLASS) &amp;&amp; !type.isAssignableFrom(VARIABLE_CLASS) : &quot;Cannot assign RegisterValue / Variable to field without REG flag: &quot; + inst + &quot; newValue=&quot; +</span>
<span class="line-added">221                             newValue;</span>
<span class="line-added">222         }</span>
<span class="line-added">223         if (!flags.contains(STACK)) {</span>
<span class="line-added">224             assert !type.isAssignableFrom(STACK_SLOT_CLASS) : &quot;Cannot assign StackSlot to field without STACK flag: &quot; + inst + &quot; newValue=&quot; +</span>
<span class="line-added">225                             newValue;</span>
<span class="line-added">226         }</span>
<span class="line-added">227         if (!flags.contains(CONST)) {</span>
<span class="line-added">228             assert !type.isAssignableFrom(CONSTANT_VALUE_CLASS) : &quot;Cannot assign Constant to field without CONST flag: &quot; + inst + &quot; newValue=&quot; +</span>
<span class="line-added">229                             newValue;</span>
<span class="line-added">230         }</span>
<span class="line-added">231         return true;</span>
<span class="line-added">232     }</span>
<span class="line-added">233 </span>
234     protected static void forEach(LIRInstruction inst, Values values, OperandMode mode, InstructionValueProcedure proc) {
235         for (int i = 0; i &lt; values.getCount(); i++) {
236             assert LIRInstruction.ALLOWED_FLAGS.get(mode).containsAll(values.getFlags(i));
237 
238             if (i &lt; values.getDirectCount()) {
239                 Value value = values.getValue(inst, i);
240                 Value newValue;
241                 if (value instanceof CompositeValue) {
242                     CompositeValue composite = (CompositeValue) value;
243                     newValue = composite.forEachComponent(inst, mode, proc);
244                 } else {
245                     newValue = proc.doValue(inst, value, mode, values.getFlags(i));
246                 }
247                 if (!value.identityEquals(newValue)) {
<span class="line-added">248                     if (!(value instanceof CompositeValue)) {</span>
<span class="line-added">249                         assert verifyAssignment(inst, newValue, values.getFlags(i));</span>
<span class="line-added">250                     }</span>
251                     values.setValue(inst, i, newValue);
252                 }
253             } else {
254                 Value[] valueArray = values.getValueArray(inst, i);
255                 for (int j = 0; j &lt; valueArray.length; j++) {
256                     Value value = valueArray[j];
257                     Value newValue;
258                     if (value instanceof CompositeValue) {
259                         CompositeValue composite = (CompositeValue) value;
260                         newValue = composite.forEachComponent(inst, mode, proc);
261                     } else {
262                         newValue = proc.doValue(inst, value, mode, values.getFlags(i));
263                     }
264                     if (!value.identityEquals(newValue)) {
265                         valueArray[j] = newValue;
266                     }
267                 }
268             }
269         }
270     }
</pre>
</td>
</tr>
</table>
<center><a href="LIRInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LIRVerifier.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/LIR.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir;
 26 
 27 import java.util.ArrayList;
 28 import java.util.Arrays;
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.asm.Label;
 32 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 33 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
 34 import org.graalvm.compiler.core.common.cfg.BlockMap;
 35 import org.graalvm.compiler.debug.DebugContext;
 36 import org.graalvm.compiler.lir.StandardOp.BlockEndOp;
 37 import org.graalvm.compiler.lir.StandardOp.LabelOp;
 38 import org.graalvm.compiler.lir.StandardOp.LabelHoldingOp;
 39 import org.graalvm.compiler.lir.gen.LIRGenerator;
 40 import org.graalvm.compiler.options.OptionValues;
 41 
 42 /**
 43  * This class implements the overall container for the LIR graph and directs its construction,
 44  * optimization, and finalization.
 45  */
 46 public final class LIR extends LIRGenerator.VariableProvider {
 47 
 48     private final AbstractControlFlowGraph&lt;?&gt; cfg;
 49 
 50     /**
 51      * The linear-scan ordered list of blocks.
 52      */
 53     private final AbstractBlockBase&lt;?&gt;[] linearScanOrder;
 54 
 55     /**
 56      * The order in which the code is emitted.
 57      */
 58     private final AbstractBlockBase&lt;?&gt;[] codeEmittingOrder;
 59 
 60     /**
 61      * Map from {@linkplain AbstractBlockBase block} to {@linkplain LIRInstruction}s. Note that we
 62      * are using {@link ArrayList} instead of {@link List} to avoid interface dispatch.
 63      */
 64     private final BlockMap&lt;ArrayList&lt;LIRInstruction&gt;&gt; lirInstructions;
 65 
 66     private boolean hasArgInCallerFrame;
 67 
 68     private final OptionValues options;
 69 
 70     private final DebugContext debug;
 71 
 72     /**
 73      * Creates a new LIR instance for the specified compilation.
 74      */
 75     public LIR(AbstractControlFlowGraph&lt;?&gt; cfg, AbstractBlockBase&lt;?&gt;[] linearScanOrder, AbstractBlockBase&lt;?&gt;[] codeEmittingOrder, OptionValues options, DebugContext debug) {
 76         this.cfg = cfg;
 77         this.codeEmittingOrder = codeEmittingOrder;
 78         this.linearScanOrder = linearScanOrder;
 79         this.lirInstructions = new BlockMap&lt;&gt;(cfg);
 80         this.options = options;
 81         this.debug = debug;
 82     }
 83 
 84     public AbstractControlFlowGraph&lt;?&gt; getControlFlowGraph() {
 85         return cfg;
 86     }
 87 
 88     public OptionValues getOptions() {
 89         return options;
 90     }
 91 
 92     public DebugContext getDebug() {
 93         return debug;
 94     }
 95 
 96     /**
 97      * Determines if any instruction in the LIR has debug info associated with it.
 98      */
 99     public boolean hasDebugInfo() {
100         for (AbstractBlockBase&lt;?&gt; b : linearScanOrder()) {
101             for (LIRInstruction op : getLIRforBlock(b)) {
102                 if (op.hasState()) {
103                     return true;
104                 }
105             }
106         }
107         return false;
108     }
109 
110     public ArrayList&lt;LIRInstruction&gt; getLIRforBlock(AbstractBlockBase&lt;?&gt; block) {
111         return lirInstructions.get(block);
112     }
113 
114     public void setLIRforBlock(AbstractBlockBase&lt;?&gt; block, ArrayList&lt;LIRInstruction&gt; list) {
115         assert getLIRforBlock(block) == null : &quot;lir instruction list should only be initialized once&quot;;
116         lirInstructions.put(block, list);
117     }
118 
119     /**
120      * Gets the linear scan ordering of blocks as an array.
121      *
122      * @return the blocks in linear scan order
123      */
124     public AbstractBlockBase&lt;?&gt;[] linearScanOrder() {
125         return linearScanOrder;
126     }
127 
128     public AbstractBlockBase&lt;?&gt;[] codeEmittingOrder() {
129         return codeEmittingOrder;
130     }
131 
132     public void setHasArgInCallerFrame() {
133         hasArgInCallerFrame = true;
134     }
135 
136     /**
137      * Determines if any of the parameters to the method are passed via the stack where the
138      * parameters are located in the caller&#39;s frame.
139      */
140     public boolean hasArgInCallerFrame() {
141         return hasArgInCallerFrame;
142     }
143 
144     /**
145      * Gets the next non-{@code null} block in a list.
146      *
147      * @param blocks list of blocks
148      * @param blockIndex index of the current block
149      * @return the next block in the list that is none {@code null} or {@code null} if there is no
150      *         such block
151      */
152     public static AbstractBlockBase&lt;?&gt; getNextBlock(AbstractBlockBase&lt;?&gt;[] blocks, int blockIndex) {
153         for (int nextIndex = blockIndex + 1; nextIndex &gt; 0 &amp;&amp; nextIndex &lt; blocks.length; nextIndex++) {
154             AbstractBlockBase&lt;?&gt; nextBlock = blocks[nextIndex];
155             if (nextBlock != null) {
156                 return nextBlock;
157             }
158         }
159         return null;
160     }
161 
162     /**
163      * Gets the exception edge (if any) originating at a given operation.
164      */
165     public static LabelRef getExceptionEdge(LIRInstruction op) {
166         final LabelRef[] exceptionEdge = {null};
167         op.forEachState(state -&gt; {
168             if (state.exceptionEdge != null) {
169                 assert exceptionEdge[0] == null;
170                 exceptionEdge[0] = state.exceptionEdge;
171             }
172         });
173         return exceptionEdge[0];
174     }
175 
176     /**
177      * The maximum distance an operation with an {@linkplain #getExceptionEdge(LIRInstruction)
178      * exception edge} can be from the last instruction of a LIR block. The value of 3 is based on a
179      * non-void call operation that has an exception edge. Such a call may move the result to
180      * another register and then spill it.
181      * &lt;p&gt;
182      * The rationale for such a constant is to limit the search for an insertion point when adding
183      * move operations at the end of a block. Such moves must be inserted before all control flow
184      * instructions.
185      */
186     public static final int MAX_EXCEPTION_EDGE_OP_DISTANCE_FROM_END = 3;
187 
188     public static boolean verifyBlock(LIR lir, AbstractBlockBase&lt;?&gt; block) {
189         ArrayList&lt;LIRInstruction&gt; ops = lir.getLIRforBlock(block);
190         if (ops.size() == 0) {
191             return false;
192         }
193         assert ops.get(0) instanceof LabelOp : String.format(&quot;Not a Label %s (Block %s)&quot;, ops.get(0).getClass(), block);
194         LIRInstruction opWithExceptionEdge = null;
195         int index = 0;
196         int lastIndex = ops.size() - 1;
197         for (LIRInstruction op : ops.subList(0, lastIndex)) {
198             assert !(op instanceof BlockEndOp) : String.format(&quot;BlockEndOp %s (Block %s)&quot;, op.getClass(), block);
199             LabelRef exceptionEdge = getExceptionEdge(op);
200             if (exceptionEdge != null) {
201                 assert opWithExceptionEdge == null : &quot;multiple ops with an exception edge not allowed&quot;;
202                 opWithExceptionEdge = op;
203                 int distanceFromEnd = lastIndex - index;
204                 assert distanceFromEnd &lt;= MAX_EXCEPTION_EDGE_OP_DISTANCE_FROM_END;
205             }
206             index++;
207         }
208         LIRInstruction end = ops.get(lastIndex);
209         assert end instanceof BlockEndOp : String.format(&quot;Not a BlockEndOp %s (Block %s)&quot;, end.getClass(), block);
210         return true;
211     }
212 
213     public static boolean verifyBlocks(LIR lir, AbstractBlockBase&lt;?&gt;[] blocks) {
214         for (AbstractBlockBase&lt;?&gt; block : blocks) {
215             if (block == null) {
216                 continue;
217             }
218             for (AbstractBlockBase&lt;?&gt; sux : block.getSuccessors()) {
219                 assert Arrays.asList(blocks).contains(sux) : &quot;missing successor from: &quot; + block + &quot;to: &quot; + sux;
220             }
221             for (AbstractBlockBase&lt;?&gt; pred : block.getPredecessors()) {
222                 assert Arrays.asList(blocks).contains(pred) : &quot;missing predecessor from: &quot; + block + &quot;to: &quot; + pred;
223             }
224             if (!verifyBlock(lir, block)) {
225                 return false;
226             }
227         }
228         return true;
229     }
230 
231     public void resetLabels() {
232 
233         for (AbstractBlockBase&lt;?&gt; block : codeEmittingOrder()) {
234             if (block == null) {
235                 continue;
236             }
237             for (LIRInstruction inst : lirInstructions.get(block)) {
238                 if (inst instanceof LabelHoldingOp) {
239                     Label label = ((LabelHoldingOp) inst).getLabel();
240                     if (label != null) {
241                         label.reset();
242                     }
243                 }
244             }
245         }
246     }
247 
248 }
    </pre>
  </body>
</html>
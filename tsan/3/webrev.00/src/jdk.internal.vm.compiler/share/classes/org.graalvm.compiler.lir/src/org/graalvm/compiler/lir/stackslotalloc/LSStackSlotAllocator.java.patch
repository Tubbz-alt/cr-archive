diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/stackslotalloc/LSStackSlotAllocator.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/stackslotalloc/LSStackSlotAllocator.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/stackslotalloc/LSStackSlotAllocator.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/stackslotalloc/LSStackSlotAllocator.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,15 +31,16 @@
 
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Deque;
-import java.util.EnumMap;
 import java.util.EnumSet;
 import java.util.PriorityQueue;
+import java.util.function.Predicate;
 
 import jdk.internal.vm.compiler.collections.EconomicSet;
+import org.graalvm.compiler.core.common.LIRKind;
 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 import org.graalvm.compiler.debug.DebugCloseable;
 import org.graalvm.compiler.debug.DebugContext;
 import org.graalvm.compiler.debug.Indent;
 import org.graalvm.compiler.debug.TimerKey;
@@ -47,19 +48,21 @@
 import org.graalvm.compiler.lir.LIRInstruction;
 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 import org.graalvm.compiler.lir.ValueProcedure;
 import org.graalvm.compiler.lir.VirtualStackSlot;
+import org.graalvm.compiler.lir.framemap.FrameMap;
 import org.graalvm.compiler.lir.framemap.FrameMapBuilderTool;
 import org.graalvm.compiler.lir.framemap.SimpleVirtualStackSlot;
 import org.graalvm.compiler.lir.framemap.VirtualStackSlotRange;
 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 import org.graalvm.compiler.lir.phases.AllocationPhase;
 import org.graalvm.compiler.options.NestedBooleanOptionKey;
 import org.graalvm.compiler.options.Option;
 import org.graalvm.compiler.options.OptionType;
 
+import jdk.vm.ci.code.CodeUtil;
 import jdk.vm.ci.code.StackSlot;
 import jdk.vm.ci.code.TargetDescription;
 import jdk.vm.ci.meta.Value;
 import jdk.vm.ci.meta.ValueKind;
 
@@ -154,11 +157,19 @@
             if (debug.isDumpEnabled(DebugContext.VERBOSE_LEVEL)) {
                 dumpIntervals("Before stack slot allocation");
             }
             // step 4: allocate stack slots
             try (DebugCloseable t = AllocateSlotsTimer.start(debug)) {
-                allocateStackSlots();
+                /*
+                 * Allocate primitive spill slots before reference spill slots. This ensures a
+                 * ReferenceMap will be as compact as possible and only exceed the encoding limit of
+                 * a stack offset if there are really too many objects live on the stack at an
+                 * instruction with a ReferenceMap (as opposed to the method simply having a very
+                 * large frame).
+                 */
+                allocateStackSlots(IS_PRIMITIVE_INTERVAL);
+                allocateStackSlots(IS_REFERENCE_INTERVAL);
             }
             if (debug.isDumpEnabled(DebugContext.VERBOSE_LEVEL)) {
                 dumpIntervals("After stack slot allocation");
             }
 
@@ -224,33 +235,48 @@
         // ====================
         // step 4: allocate stack slots
         // ====================
 
         @SuppressWarnings("try")
-        private void allocateStackSlots() {
-            // create unhandled lists
+        private void allocateStackSlots(Predicate<StackInterval> predicate) {
             for (StackInterval interval : stackSlotMap) {
-                if (interval != null) {
+                if (interval != null && (predicate == null || predicate.test(interval))) {
                     unhandled.add(interval);
                 }
             }
-
             for (StackInterval current = activateNext(); current != null; current = activateNext()) {
                 try (Indent indent = debug.logAndIndent("allocate %s", current)) {
                     allocateSlot(current);
                 }
             }
 
+            // Cannot re-use free slots between rounds of slot allocation
+            freeSlots = null;
+            active.clear();
         }
 
+        private static final Predicate<StackInterval> IS_REFERENCE_INTERVAL = new Predicate<StackInterval>() {
+            @Override
+            public boolean test(StackInterval interval) {
+                return !((LIRKind) interval.kind()).isValue();
+            }
+        };
+
+        private static final Predicate<StackInterval> IS_PRIMITIVE_INTERVAL = new Predicate<StackInterval>() {
+            @Override
+            public boolean test(StackInterval interval) {
+                return ((LIRKind) interval.kind()).isValue();
+            }
+        };
+
         private void allocateSlot(StackInterval current) {
             VirtualStackSlot virtualSlot = current.getOperand();
             final StackSlot location;
             if (virtualSlot instanceof VirtualStackSlotRange) {
                 // No reuse of ranges (yet).
                 VirtualStackSlotRange slotRange = (VirtualStackSlotRange) virtualSlot;
-                location = frameMapBuilder.getFrameMap().allocateStackSlots(slotRange.getSlots(), slotRange.getObjects());
+                location = frameMapBuilder.getFrameMap().allocateStackSlots(slotRange.getSlots());
                 StackSlotAllocatorUtil.virtualFramesize.add(debug, frameMapBuilder.getFrameMap().spillSlotRangeSize(slotRange.getSlots()));
                 StackSlotAllocatorUtil.allocatedSlots.increment(debug);
             } else {
                 assert virtualSlot instanceof SimpleVirtualStackSlot : "Unexpected VirtualStackSlot type: " + virtualSlot;
                 StackSlot slot = findFreeSlot((SimpleVirtualStackSlot) virtualSlot);
@@ -272,93 +298,78 @@
             }
             debug.log("Allocate location %s for interval %s", location, current);
             current.setLocation(location);
         }
 
-        private enum SlotSize {
-            Size1,
-            Size2,
-            Size4,
-            Size8,
-            Illegal;
-        }
-
-        private SlotSize forKind(ValueKind<?> kind) {
-            switch (frameMapBuilder.getFrameMap().spillSlotSize(kind)) {
-                case 1:
-                    return SlotSize.Size1;
-                case 2:
-                    return SlotSize.Size2;
-                case 4:
-                    return SlotSize.Size4;
-                case 8:
-                    return SlotSize.Size8;
-                default:
-                    return SlotSize.Illegal;
-            }
-        }
-
-        private EnumMap<SlotSize, Deque<StackSlot>> freeSlots;
+        /**
+         * Map from log2 of {@link FrameMap#spillSlotSize(ValueKind) a spill slot size} to a list of
+         * free stack slots.
+         */
+        private ArrayList<Deque<StackSlot>> freeSlots;
 
         /**
-         * @return The list of free stack slots for {@code size} or {@code null} if there is none.
+         * @return The list of free stack slots for {@code index} or {@code null} if there is none.
          */
-        private Deque<StackSlot> getOrNullFreeSlots(SlotSize size) {
+        private Deque<StackSlot> getNullOrFreeSlots(int index) {
             if (freeSlots == null) {
                 return null;
             }
-            return freeSlots.get(size);
+            if (index < freeSlots.size()) {
+                return freeSlots.get(index);
+            }
+            return null;
         }
 
         /**
-         * @return the list of free stack slots for {@code size}. If there is none a list is
+         * @return the list of free stack slots for {@code index}. If there is none a list is
          *         created.
          */
-        private Deque<StackSlot> getOrInitFreeSlots(SlotSize size) {
-            assert size != SlotSize.Illegal;
-            Deque<StackSlot> freeList;
-            if (freeSlots != null) {
-                freeList = freeSlots.get(size);
-            } else {
-                freeSlots = new EnumMap<>(SlotSize.class);
-                freeList = null;
+        private Deque<StackSlot> getOrInitFreeSlots(int index) {
+            Deque<StackSlot> freeList = null;
+            if (freeSlots == null) {
+                freeSlots = new ArrayList<>(6);
+            } else if (index < freeSlots.size()) {
+                freeList = freeSlots.get(index);
             }
             if (freeList == null) {
+                int requiredSize = index + 1;
+                for (int i = freeSlots.size(); i < requiredSize; i++) {
+                    freeSlots.add(null);
+                }
                 freeList = new ArrayDeque<>();
-                freeSlots.put(size, freeList);
+                freeSlots.set(index, freeList);
             }
-            assert freeList != null;
             return freeList;
         }
 
         /**
          * Gets a free stack slot for {@code slot} or {@code null} if there is none.
          */
         private StackSlot findFreeSlot(SimpleVirtualStackSlot slot) {
             assert slot != null;
-            SlotSize size = forKind(slot.getValueKind());
-            if (size == SlotSize.Illegal) {
-                return null;
-            }
-            Deque<StackSlot> freeList = getOrNullFreeSlots(size);
+            int size = log2SpillSlotSize(slot.getValueKind());
+            Deque<StackSlot> freeList = getNullOrFreeSlots(size);
             if (freeList == null) {
                 return null;
             }
             return freeList.pollLast();
         }
 
         /**
          * Adds a stack slot to the list of free slots.
          */
         private void freeSlot(StackSlot slot) {
-            SlotSize size = forKind(slot.getValueKind());
-            if (size == SlotSize.Illegal) {
-                return;
-            }
+            int size = log2SpillSlotSize(slot.getValueKind());
             getOrInitFreeSlots(size).addLast(slot);
         }
 
+        private int log2SpillSlotSize(ValueKind<?> kind) {
+            int size = frameMapBuilder.getFrameMap().spillSlotSize(kind);
+            assert CodeUtil.isPowerOf2(size);
+            return CodeUtil.log2(size);
+        }
+
         /**
          * Gets the next unhandled interval and finishes handled intervals.
          */
         private StackInterval activateNext() {
             if (unhandled.isEmpty()) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/asm/CompilationResultBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.asm;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.asStackSlot;
 28 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 29 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 30 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 31 
 32 import java.util.ArrayList;
 33 import java.util.Arrays;
 34 import java.util.List;
 35 import java.util.function.Consumer;
 36 
 37 import jdk.internal.vm.compiler.collections.EconomicMap;
 38 import jdk.internal.vm.compiler.collections.Equivalence;
 39 import org.graalvm.compiler.asm.AbstractAddress;
 40 import org.graalvm.compiler.asm.Assembler;
 41 import org.graalvm.compiler.asm.Label;
 42 import org.graalvm.compiler.code.CompilationResult;
 43 import org.graalvm.compiler.code.CompilationResult.CodeAnnotation;
<a name="1" id="anc1"></a>
 44 import org.graalvm.compiler.code.DataSection.Data;
 45 import org.graalvm.compiler.code.DataSection.RawData;
 46 import org.graalvm.compiler.core.common.NumUtil;
 47 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 48 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 49 import org.graalvm.compiler.core.common.type.DataPointerConstant;
 50 import org.graalvm.compiler.debug.DebugContext;
 51 import org.graalvm.compiler.debug.GraalError;
 52 import org.graalvm.compiler.graph.NodeSourcePosition;
 53 import org.graalvm.compiler.lir.LIR;
 54 import org.graalvm.compiler.lir.LIRFrameState;
 55 import org.graalvm.compiler.lir.LIRInstruction;
<a name="2" id="anc2"></a>
 56 import org.graalvm.compiler.lir.LabelRef;
 57 import org.graalvm.compiler.lir.StandardOp.LabelHoldingOp;
 58 import org.graalvm.compiler.lir.framemap.FrameMap;
 59 import org.graalvm.compiler.options.Option;
 60 import org.graalvm.compiler.options.OptionKey;
 61 import org.graalvm.compiler.options.OptionType;
 62 import org.graalvm.compiler.options.OptionValues;
<a name="3" id="anc3"></a>
 63 
 64 import jdk.vm.ci.code.BailoutException;
 65 import jdk.vm.ci.code.CodeCacheProvider;
 66 import jdk.vm.ci.code.DebugInfo;
 67 import jdk.vm.ci.code.Register;
 68 import jdk.vm.ci.code.StackSlot;
 69 import jdk.vm.ci.code.TargetDescription;
 70 import jdk.vm.ci.code.site.ConstantReference;
 71 import jdk.vm.ci.code.site.DataSectionReference;
<a name="4" id="anc4"></a>
 72 import jdk.vm.ci.code.site.InfopointReason;
 73 import jdk.vm.ci.code.site.Mark;
 74 import jdk.vm.ci.meta.Constant;
 75 import jdk.vm.ci.meta.InvokeTarget;
 76 import jdk.vm.ci.meta.JavaConstant;
 77 import jdk.vm.ci.meta.JavaKind;
 78 import jdk.vm.ci.meta.VMConstant;
 79 import jdk.vm.ci.meta.Value;
 80 
 81 /**
 82  * Fills in a {@link CompilationResult} as its code is being assembled.
 83  *
 84  * @see CompilationResultBuilderFactory
 85  */
 86 public class CompilationResultBuilder {
 87 
<a name="5" id="anc5"></a>









 88     public static class Options {
 89         @Option(help = &quot;Include the LIR as comments with the final assembly.&quot;, type = OptionType.Debug) //
 90         public static final OptionKey&lt;Boolean&gt; PrintLIRWithAssembly = new OptionKey&lt;&gt;(false);
 91     }
 92 
 93     private static class ExceptionInfo {
 94 
 95         public final int codeOffset;
 96         public final LabelRef exceptionEdge;
 97 
 98         ExceptionInfo(int pcOffset, LabelRef exceptionEdge) {
 99             this.codeOffset = pcOffset;
100             this.exceptionEdge = exceptionEdge;
101         }
102     }
103 
104     /**
105      * Wrapper for a code annotation that was produced by the {@link Assembler}.
106      */
107     public static final class AssemblerAnnotation extends CodeAnnotation {
108 
109         public final Assembler.CodeAnnotation assemblerCodeAnnotation;
110 
111         public AssemblerAnnotation(Assembler.CodeAnnotation assemblerCodeAnnotation) {
112             super(assemblerCodeAnnotation.instructionPosition);
113             this.assemblerCodeAnnotation = assemblerCodeAnnotation;
114         }
115 
116         @Override
117         public boolean equals(Object obj) {
118             return this == obj;
119         }
120 
121         @Override
122         public String toString() {
123             return assemblerCodeAnnotation.toString();
124         }
125     }
126 
127     public final Assembler asm;
128     public final DataBuilder dataBuilder;
129     public final CompilationResult compilationResult;
<a name="6" id="anc6"></a><span class="line-modified">130     public final Register nullRegister;</span>
131     public final TargetDescription target;
132     public final CodeCacheProvider codeCache;
133     public final ForeignCallsProvider foreignCalls;
134     public final FrameMap frameMap;
135 
136     /**
137      * The LIR for which code is being generated.
138      */
139     protected LIR lir;
140 
141     /**
142      * The index of the block currently being emitted.
143      */
144     protected int currentBlockIndex;
145 
146     /**
147      * The object that emits code for managing a method&#39;s frame.
148      */
149     public final FrameContext frameContext;
150 
151     private List&lt;ExceptionInfo&gt; exceptionInfoList;
152 
153     private final OptionValues options;
154     private final DebugContext debug;
155     private final EconomicMap&lt;Constant, Data&gt; dataCache;
156 
157     private Consumer&lt;LIRInstruction&gt; beforeOp;
158     private Consumer&lt;LIRInstruction&gt; afterOp;
159 
160     /**
161      * These position maps are used for estimating offsets of forward branches. Used for
162      * architectures where certain branch instructions have limited displacement such as ARM tbz or
163      * SPARC cbcond.
164      */
165     private EconomicMap&lt;Label, Integer&gt; labelBindLirPositions;
166     private EconomicMap&lt;LIRInstruction, Integer&gt; lirPositions;
167     /**
168      * This flag is for setting the
169      * {@link CompilationResultBuilder#labelWithinRange(LIRInstruction, Label, int)} into a
170      * conservative mode and always answering false.
171      */
172     private boolean conservativeLabelOffsets = false;
173 
<a name="7" id="anc7"></a><span class="line-modified">174     public final boolean mustReplaceWithNullRegister(JavaConstant nullConstant) {</span>
<span class="line-modified">175         return !nullRegister.equals(Register.None) &amp;&amp; JavaConstant.NULL_POINTER.equals(nullConstant);</span>
<span class="line-modified">176     }</span>
<span class="line-modified">177 </span>
<span class="line-modified">178     public CompilationResultBuilder(CodeCacheProvider codeCache, ForeignCallsProvider foreignCalls, FrameMap frameMap, Assembler asm, DataBuilder dataBuilder, FrameContext frameContext,</span>
<span class="line-modified">179                     OptionValues options, DebugContext debug, CompilationResult compilationResult, Register nullRegister) {</span>
<span class="line-modified">180         this(codeCache, foreignCalls, frameMap, asm, dataBuilder, frameContext, options, debug, compilationResult, nullRegister, EconomicMap.create(Equivalence.DEFAULT));</span>
<span class="line-modified">181     }</span>
<span class="line-modified">182 </span>
<span class="line-modified">183     public CompilationResultBuilder(CodeCacheProvider codeCache, ForeignCallsProvider foreignCalls, FrameMap frameMap, Assembler asm, DataBuilder dataBuilder, FrameContext frameContext,</span>
<span class="line-modified">184                     OptionValues options, DebugContext debug, CompilationResult compilationResult, Register nullRegister, EconomicMap&lt;Constant, Data&gt; dataCache) {</span>



























185         this.target = codeCache.getTarget();
186         this.codeCache = codeCache;
187         this.foreignCalls = foreignCalls;
188         this.frameMap = frameMap;
189         this.asm = asm;
190         this.dataBuilder = dataBuilder;
191         this.compilationResult = compilationResult;
<a name="8" id="anc8"></a><span class="line-modified">192         this.nullRegister = nullRegister;</span>
193         this.frameContext = frameContext;
194         this.options = options;
195         this.debug = debug;
196         assert frameContext != null;
197         this.dataCache = dataCache;
198     }
199 
200     public void setTotalFrameSize(int frameSize) {
201         compilationResult.setTotalFrameSize(frameSize);
202     }
203 
204     public void setMaxInterpreterFrameSize(int maxInterpreterFrameSize) {
205         compilationResult.setMaxInterpreterFrameSize(maxInterpreterFrameSize);
206     }
207 
208     public Mark recordMark(Object id) {
209         return compilationResult.recordMark(asm.position(), id);
210     }
211 
212     public void blockComment(String s) {
213         compilationResult.addAnnotation(new CompilationResult.CodeComment(asm.position(), s));
214     }
215 
216     /**
217      * Sets the {@linkplain CompilationResult#setTargetCode(byte[], int) code} and
218      * {@linkplain CompilationResult#recordExceptionHandler(int, int) exception handler} fields of
219      * the compilation result and then {@linkplain #closeCompilationResult() closes} it.
220      */
221     public void finish() {
222         int position = asm.position();
223         compilationResult.setTargetCode(asm.close(false), position);
224 
225         // Record exception handlers if they exist
226         if (exceptionInfoList != null) {
227             for (ExceptionInfo ei : exceptionInfoList) {
228                 int codeOffset = ei.codeOffset;
229                 compilationResult.recordExceptionHandler(codeOffset, ei.exceptionEdge.label().position());
230             }
231         }
232         closeCompilationResult();
233     }
234 
235     /**
236      * Calls {@link CompilationResult#close()} on {@link #compilationResult}.
237      */
238     protected void closeCompilationResult() {
239         compilationResult.close();
240     }
241 
242     public void recordExceptionHandlers(int pcOffset, LIRFrameState info) {
243         if (info != null) {
244             if (info.exceptionEdge != null) {
245                 if (exceptionInfoList == null) {
246                     exceptionInfoList = new ArrayList&lt;&gt;(4);
247                 }
248                 exceptionInfoList.add(new ExceptionInfo(pcOffset, info.exceptionEdge));
249             }
250         }
251     }
252 
253     public void recordImplicitException(int pcOffset, LIRFrameState info) {
254         compilationResult.recordInfopoint(pcOffset, info.debugInfo(), InfopointReason.IMPLICIT_EXCEPTION);
255         assert info.exceptionEdge == null;
256     }
257 
<a name="9" id="anc9"></a>









258     public void recordDirectCall(int posBefore, int posAfter, InvokeTarget callTarget, LIRFrameState info) {
259         DebugInfo debugInfo = info != null ? info.debugInfo() : null;
260         compilationResult.recordCall(posBefore, posAfter - posBefore, callTarget, debugInfo, true);
261     }
262 
263     public void recordIndirectCall(int posBefore, int posAfter, InvokeTarget callTarget, LIRFrameState info) {
264         DebugInfo debugInfo = info != null ? info.debugInfo() : null;
265         compilationResult.recordCall(posBefore, posAfter - posBefore, callTarget, debugInfo, false);
266     }
267 
268     public void recordInfopoint(int pos, LIRFrameState info, InfopointReason reason) {
269         // infopoints always need debug info
270         DebugInfo debugInfo = info.debugInfo();
271         recordInfopoint(pos, debugInfo, reason);
272     }
273 
274     public void recordInfopoint(int pos, DebugInfo debugInfo, InfopointReason reason) {
275         compilationResult.recordInfopoint(pos, debugInfo, reason);
276     }
277 
278     public void recordSourceMapping(int pcOffset, int endPcOffset, NodeSourcePosition sourcePosition) {
279         compilationResult.recordSourceMapping(pcOffset, endPcOffset, sourcePosition);
280     }
281 
282     public void recordInlineDataInCode(Constant data) {
283         assert data != null;
284         int pos = asm.position();
285         debug.log(&quot;Inline data in code: pos = %d, data = %s&quot;, pos, data);
286         if (data instanceof VMConstant) {
287             compilationResult.recordDataPatch(pos, new ConstantReference((VMConstant) data));
288         }
289     }
290 
291     public void recordInlineDataInCodeWithNote(Constant data, Object note) {
292         assert data != null;
293         int pos = asm.position();
294         debug.log(&quot;Inline data in code: pos = %d, data = %s, note = %s&quot;, pos, data, note);
295         if (data instanceof VMConstant) {
296             compilationResult.recordDataPatchWithNote(pos, new ConstantReference((VMConstant) data), note);
297         }
298     }
299 
300     public AbstractAddress recordDataSectionReference(Data data) {
301         assert data != null;
302         DataSectionReference reference = compilationResult.getDataSection().insertData(data);
303         int instructionStart = asm.position();
304         compilationResult.recordDataPatch(instructionStart, reference);
305         return asm.getPlaceholder(instructionStart);
306     }
307 
308     public AbstractAddress recordDataReferenceInCode(DataPointerConstant constant) {
309         return recordDataReferenceInCode(constant, constant.getAlignment());
310     }
311 
312     public AbstractAddress recordDataReferenceInCode(Constant constant, int alignment) {
313         assert constant != null;
314         debug.log(&quot;Constant reference in code: pos = %d, data = %s&quot;, asm.position(), constant);
315         Data data = createDataItem(constant);
316         data.updateAlignment(alignment);
317         return recordDataSectionReference(data);
318     }
319 
320     public AbstractAddress recordDataReferenceInCode(Data data, int alignment) {
321         assert data != null;
322         data.updateAlignment(alignment);
323         return recordDataSectionReference(data);
324     }
325 
326     public Data createDataItem(Constant constant) {
327         Data data = dataCache.get(constant);
328         if (data == null) {
329             data = dataBuilder.createDataItem(constant);
330             dataCache.put(constant, data);
331         }
332         return data;
333     }
334 
335     public AbstractAddress recordDataReferenceInCode(byte[] data, int alignment) {
336         assert data != null;
337         if (debug.isLogEnabled()) {
338             debug.log(&quot;Data reference in code: pos = %d, data = %s&quot;, asm.position(), Arrays.toString(data));
339         }
340         return recordDataSectionReference(new RawData(data, alignment));
341     }
342 
343     /**
344      * Notifies this object of a branch instruction at offset {@code pcOffset} in the code.
345      *
346      * @param isNegated negation status of the branch&#39;s condition.
347      */
348     @SuppressWarnings(&quot;unused&quot;)
349     public void recordBranch(int pcOffset, boolean isNegated) {
350     }
351 
352     /**
353      * Notifies this object of a call instruction belonging to an INVOKEVIRTUAL or INVOKEINTERFACE
354      * at offset {@code pcOffset} in the code.
355      *
356      * @param nodeSourcePosition source position of the corresponding invoke.
357      */
358     @SuppressWarnings(&quot;unused&quot;)
359     public void recordInvokeVirtualOrInterfaceCallOp(int pcOffset, NodeSourcePosition nodeSourcePosition) {
360     }
361 
362     /**
363      * Notifies this object of a call instruction belonging to an INLINE_INVOKE at offset
364      * {@code pcOffset} in the code.
365      *
366      * @param nodeSourcePosition source position of the corresponding invoke.
367      */
368     @SuppressWarnings(&quot;unused&quot;)
369     public void recordInlineInvokeCallOp(int pcOffset, NodeSourcePosition nodeSourcePosition) {
370     }
371 
372     /**
373      * Returns the integer value of any constant that can be represented by a 32-bit integer value,
374      * including long constants that fit into the 32-bit range.
375      */
376     public int asIntConst(Value value) {
377         assert isJavaConstant(value) &amp;&amp; asJavaConstant(value).getJavaKind().isNumericInteger();
378         JavaConstant constant = asJavaConstant(value);
379         long c = constant.asLong();
380         if (!NumUtil.isInt(c)) {
381             throw GraalError.shouldNotReachHere();
382         }
383         return (int) c;
384     }
385 
386     /**
387      * Returns the float value of any constant that can be represented by a 32-bit float value.
388      */
389     public float asFloatConst(Value value) {
390         assert isJavaConstant(value) &amp;&amp; asJavaConstant(value).getJavaKind() == JavaKind.Float;
391         JavaConstant constant = asJavaConstant(value);
392         return constant.asFloat();
393     }
394 
395     /**
396      * Returns the long value of any constant that can be represented by a 64-bit long value.
397      */
398     public long asLongConst(Value value) {
399         assert isJavaConstant(value) &amp;&amp; asJavaConstant(value).getJavaKind() == JavaKind.Long;
400         JavaConstant constant = asJavaConstant(value);
401         return constant.asLong();
402     }
403 
404     /**
405      * Returns the double value of any constant that can be represented by a 64-bit float value.
406      */
407     public double asDoubleConst(Value value) {
408         assert isJavaConstant(value) &amp;&amp; asJavaConstant(value).getJavaKind() == JavaKind.Double;
409         JavaConstant constant = asJavaConstant(value);
410         return constant.asDouble();
411     }
412 
413     /**
414      * Returns the address of a float constant that is embedded as a data reference into the code.
415      */
416     public AbstractAddress asFloatConstRef(JavaConstant value) {
417         return asFloatConstRef(value, 4);
418     }
419 
420     public AbstractAddress asFloatConstRef(JavaConstant value, int alignment) {
421         assert value.getJavaKind() == JavaKind.Float;
422         return recordDataReferenceInCode(value, alignment);
423     }
424 
425     /**
426      * Returns the address of a double constant that is embedded as a data reference into the code.
427      */
428     public AbstractAddress asDoubleConstRef(JavaConstant value) {
429         return asDoubleConstRef(value, 8);
430     }
431 
432     public AbstractAddress asDoubleConstRef(JavaConstant value, int alignment) {
433         assert value.getJavaKind() == JavaKind.Double;
434         return recordDataReferenceInCode(value, alignment);
435     }
436 
437     /**
438      * Returns the address of a long constant that is embedded as a data reference into the code.
439      */
440     public AbstractAddress asLongConstRef(JavaConstant value) {
441         assert value.getJavaKind() == JavaKind.Long;
442         return recordDataReferenceInCode(value, 8);
443     }
444 
445     /**
446      * Returns the address of an object constant that is embedded as a data reference into the code.
447      */
448     public AbstractAddress asObjectConstRef(JavaConstant value) {
449         assert value.getJavaKind() == JavaKind.Object;
450         return recordDataReferenceInCode(value, 8);
451     }
452 
453     public AbstractAddress asByteAddr(Value value) {
454         assert value.getPlatformKind().getSizeInBytes() &gt;= JavaKind.Byte.getByteCount();
455         return asAddress(value);
456     }
457 
458     public AbstractAddress asShortAddr(Value value) {
459         assert value.getPlatformKind().getSizeInBytes() &gt;= JavaKind.Short.getByteCount();
460         return asAddress(value);
461     }
462 
463     public AbstractAddress asIntAddr(Value value) {
464         assert value.getPlatformKind().getSizeInBytes() &gt;= JavaKind.Int.getByteCount();
465         return asAddress(value);
466     }
467 
468     public AbstractAddress asLongAddr(Value value) {
469         assert value.getPlatformKind().getSizeInBytes() &gt;= JavaKind.Long.getByteCount();
470         return asAddress(value);
471     }
472 
473     public AbstractAddress asFloatAddr(Value value) {
474         assert value.getPlatformKind().getSizeInBytes() &gt;= JavaKind.Float.getByteCount();
475         return asAddress(value);
476     }
477 
478     public AbstractAddress asDoubleAddr(Value value) {
479         assert value.getPlatformKind().getSizeInBytes() &gt;= JavaKind.Double.getByteCount();
480         return asAddress(value);
481     }
482 
483     public AbstractAddress asAddress(Value value) {
484         assert isStackSlot(value);
485         StackSlot slot = asStackSlot(value);
486         return asm.makeAddress(frameMap.getRegisterConfig().getFrameRegister(), frameMap.offsetForStackSlot(slot));
487     }
488 
489     /**
490      * Determines if a given edge from the block currently being emitted goes to its lexical
491      * successor.
492      */
493     public boolean isSuccessorEdge(LabelRef edge) {
494         assert lir != null;
495         AbstractBlockBase&lt;?&gt;[] order = lir.codeEmittingOrder();
496         assert order[currentBlockIndex] == edge.getSourceBlock();
497         AbstractBlockBase&lt;?&gt; nextBlock = LIR.getNextBlock(order, currentBlockIndex);
498         return nextBlock == edge.getTargetBlock();
499     }
500 
501     /**
502      * Emits code for {@code lir} in its {@linkplain LIR#codeEmittingOrder() code emitting order}.
503      */
504     public void emit(@SuppressWarnings(&quot;hiding&quot;) LIR lir) {
505         assert this.lir == null;
506         assert currentBlockIndex == 0;
507         this.lir = lir;
508         this.currentBlockIndex = 0;
509         frameContext.enter(this);
510         for (AbstractBlockBase&lt;?&gt; b : lir.codeEmittingOrder()) {
511             assert (b == null &amp;&amp; lir.codeEmittingOrder()[currentBlockIndex] == null) || lir.codeEmittingOrder()[currentBlockIndex].equals(b);
512             emitBlock(b);
513             currentBlockIndex++;
514         }
515         this.lir = null;
516         this.currentBlockIndex = 0;
517     }
518 
519     private void emitBlock(AbstractBlockBase&lt;?&gt; block) {
520         if (block == null) {
521             return;
522         }
523         boolean emitComment = debug.isDumpEnabled(DebugContext.BASIC_LEVEL) || Options.PrintLIRWithAssembly.getValue(getOptions());
524         if (emitComment) {
525             blockComment(String.format(&quot;block B%d %s&quot;, block.getId(), block.getLoop()));
526         }
527 
528         for (LIRInstruction op : lir.getLIRforBlock(block)) {
529             if (emitComment) {
530                 blockComment(String.format(&quot;%d %s&quot;, op.id(), op));
531             }
532 
533             try {
534                 if (beforeOp != null) {
535                     beforeOp.accept(op);
536                 }
<a name="10" id="anc10"></a><span class="line-modified">537                 emitOp(this, op);</span>
538                 if (afterOp != null) {
539                     afterOp.accept(op);
540                 }
541             } catch (GraalError e) {
542                 throw e.addContext(&quot;lir instruction&quot;, block + &quot;@&quot; + op.id() + &quot; &quot; + op.getClass().getName() + &quot; &quot; + op + &quot;\n&quot; + Arrays.toString(lir.codeEmittingOrder()));
543             }
544         }
545     }
546 
<a name="11" id="anc11"></a><span class="line-modified">547     private static void emitOp(CompilationResultBuilder crb, LIRInstruction op) {</span>
548         try {
<a name="12" id="anc12"></a><span class="line-modified">549             int start = crb.asm.position();</span>
<span class="line-modified">550             op.emitCode(crb);</span>
551             if (op.getPosition() != null) {
<a name="13" id="anc13"></a><span class="line-modified">552                 crb.recordSourceMapping(start, crb.asm.position(), op.getPosition());</span>

















553             }
554         } catch (BailoutException e) {
555             throw e;
556         } catch (AssertionError t) {
557             throw new GraalError(t);
558         } catch (RuntimeException t) {
559             throw new GraalError(t);
560         }
561     }
562 
563     public void resetForEmittingCode() {
564         asm.reset();
565         compilationResult.resetForEmittingCode();
566         if (exceptionInfoList != null) {
567             exceptionInfoList.clear();
568         }
569         if (dataCache != null) {
570             dataCache.clear();
571         }
572         lir = null;
573         currentBlockIndex = 0;
574     }
575 
576     public void setOpCallback(Consumer&lt;LIRInstruction&gt; beforeOp, Consumer&lt;LIRInstruction&gt; afterOp) {
577         this.beforeOp = beforeOp;
578         this.afterOp = afterOp;
579     }
580 
581     public OptionValues getOptions() {
582         return options;
583     }
584 
585     /**
586      * Builds up a map for label and LIR instruction positions where labels are or labels pointing
587      * to.
588      */
589     public void buildLabelOffsets(LIR generatedLIR) {
590         labelBindLirPositions = EconomicMap.create(Equivalence.IDENTITY);
591         lirPositions = EconomicMap.create(Equivalence.IDENTITY);
592         int instructionPosition = 0;
593         for (AbstractBlockBase&lt;?&gt; block : generatedLIR.codeEmittingOrder()) {
594             if (block != null) {
595                 for (LIRInstruction op : generatedLIR.getLIRforBlock(block)) {
596                     if (op instanceof LabelHoldingOp) {
597                         Label label = ((LabelHoldingOp) op).getLabel();
598                         if (label != null) {
599                             labelBindLirPositions.put(label, instructionPosition);
600                         }
<a name="14" id="anc14"></a><span class="line-removed">601                         lirPositions.put(op, instructionPosition);</span>
602                     }
<a name="15" id="anc15"></a>
603                     instructionPosition++;
604                 }
605             }
606         }
607     }
608 
609     /**
610      * Answers the code generator whether the jump from instruction to label is within disp LIR
611      * instructions.
612      *
613      * @param disp Maximum number of LIR instructions between label and instruction
614      */
615     public boolean labelWithinRange(LIRInstruction instruction, Label label, int disp) {
616         if (conservativeLabelOffsets) {
617             return false;
618         }
619         Integer labelPosition = labelBindLirPositions.get(label);
620         Integer instructionPosition = lirPositions.get(instruction);
621         boolean result;
622         if (labelPosition != null &amp;&amp; instructionPosition != null) {
623             result = Math.abs(labelPosition - instructionPosition) &lt; disp;
624         } else {
625             result = false;
626         }
627         return result;
628     }
629 
630     /**
631      * Sets this CompilationResultBuilder into conservative mode. If set,
632      * {@link CompilationResultBuilder#labelWithinRange(LIRInstruction, Label, int)} always returns
633      * false.
634      */
635     public void setConservativeLabelRanges() {
636         this.conservativeLabelOffsets = true;
637     }
<a name="16" id="anc16"></a>













638 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
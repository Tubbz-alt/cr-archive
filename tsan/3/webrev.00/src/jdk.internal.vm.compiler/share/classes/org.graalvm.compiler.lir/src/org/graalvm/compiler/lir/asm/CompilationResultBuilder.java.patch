diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/asm/CompilationResultBuilder.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/asm/CompilationResultBuilder.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/asm/CompilationResultBuilder.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/asm/CompilationResultBuilder.java
@@ -39,10 +39,11 @@
 import org.graalvm.compiler.asm.AbstractAddress;
 import org.graalvm.compiler.asm.Assembler;
 import org.graalvm.compiler.asm.Label;
 import org.graalvm.compiler.code.CompilationResult;
 import org.graalvm.compiler.code.CompilationResult.CodeAnnotation;
+import org.graalvm.compiler.code.CompilationResult.JumpTable;
 import org.graalvm.compiler.code.DataSection.Data;
 import org.graalvm.compiler.code.DataSection.RawData;
 import org.graalvm.compiler.core.common.NumUtil;
 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
@@ -51,26 +52,29 @@
 import org.graalvm.compiler.debug.GraalError;
 import org.graalvm.compiler.graph.NodeSourcePosition;
 import org.graalvm.compiler.lir.LIR;
 import org.graalvm.compiler.lir.LIRFrameState;
 import org.graalvm.compiler.lir.LIRInstruction;
+import org.graalvm.compiler.lir.LIRInstructionVerifier;
 import org.graalvm.compiler.lir.LabelRef;
 import org.graalvm.compiler.lir.StandardOp.LabelHoldingOp;
 import org.graalvm.compiler.lir.framemap.FrameMap;
 import org.graalvm.compiler.options.Option;
 import org.graalvm.compiler.options.OptionKey;
 import org.graalvm.compiler.options.OptionType;
 import org.graalvm.compiler.options.OptionValues;
+import org.graalvm.compiler.serviceprovider.GraalServices;
 
 import jdk.vm.ci.code.BailoutException;
 import jdk.vm.ci.code.CodeCacheProvider;
 import jdk.vm.ci.code.DebugInfo;
 import jdk.vm.ci.code.Register;
 import jdk.vm.ci.code.StackSlot;
 import jdk.vm.ci.code.TargetDescription;
 import jdk.vm.ci.code.site.ConstantReference;
 import jdk.vm.ci.code.site.DataSectionReference;
+import jdk.vm.ci.code.site.Infopoint;
 import jdk.vm.ci.code.site.InfopointReason;
 import jdk.vm.ci.code.site.Mark;
 import jdk.vm.ci.meta.Constant;
 import jdk.vm.ci.meta.InvokeTarget;
 import jdk.vm.ci.meta.JavaConstant;
@@ -83,10 +87,20 @@
  *
  * @see CompilationResultBuilderFactory
  */
 public class CompilationResultBuilder {
 
+    private static final List<LIRInstructionVerifier> LIR_INSTRUCTION_VERIFIERS = new ArrayList<>();
+
+    static {
+        for (LIRInstructionVerifier verifier : GraalServices.load(LIRInstructionVerifier.class)) {
+            if (verifier.isEnabled()) {
+                LIR_INSTRUCTION_VERIFIERS.add(verifier);
+            }
+        }
+    }
+
     public static class Options {
         @Option(help = "Include the LIR as comments with the final assembly.", type = OptionType.Debug) //
         public static final OptionKey<Boolean> PrintLIRWithAssembly = new OptionKey<>(false);
     }
 
@@ -125,11 +139,11 @@
     }
 
     public final Assembler asm;
     public final DataBuilder dataBuilder;
     public final CompilationResult compilationResult;
-    public final Register nullRegister;
+    public final Register uncompressedNullRegister;
     public final TargetDescription target;
     public final CodeCacheProvider codeCache;
     public final ForeignCallsProvider foreignCalls;
     public final FrameMap frameMap;
 
@@ -169,29 +183,56 @@
      * {@link CompilationResultBuilder#labelWithinRange(LIRInstruction, Label, int)} into a
      * conservative mode and always answering false.
      */
     private boolean conservativeLabelOffsets = false;
 
-    public final boolean mustReplaceWithNullRegister(JavaConstant nullConstant) {
-        return !nullRegister.equals(Register.None) && JavaConstant.NULL_POINTER.equals(nullConstant);
-    }
-
-    public CompilationResultBuilder(CodeCacheProvider codeCache, ForeignCallsProvider foreignCalls, FrameMap frameMap, Assembler asm, DataBuilder dataBuilder, FrameContext frameContext,
-                    OptionValues options, DebugContext debug, CompilationResult compilationResult, Register nullRegister) {
-        this(codeCache, foreignCalls, frameMap, asm, dataBuilder, frameContext, options, debug, compilationResult, nullRegister, EconomicMap.create(Equivalence.DEFAULT));
-    }
-
-    public CompilationResultBuilder(CodeCacheProvider codeCache, ForeignCallsProvider foreignCalls, FrameMap frameMap, Assembler asm, DataBuilder dataBuilder, FrameContext frameContext,
-                    OptionValues options, DebugContext debug, CompilationResult compilationResult, Register nullRegister, EconomicMap<Constant, Data> dataCache) {
+    public final boolean mustReplaceWithUncompressedNullRegister(JavaConstant nullConstant) {
+        return !uncompressedNullRegister.equals(Register.None) && JavaConstant.NULL_POINTER.equals(nullConstant);
+    }
+
+    public CompilationResultBuilder(CodeCacheProvider codeCache,
+                    ForeignCallsProvider foreignCalls,
+                    FrameMap frameMap,
+                    Assembler asm,
+                    DataBuilder dataBuilder,
+                    FrameContext frameContext,
+                    OptionValues options,
+                    DebugContext debug,
+                    CompilationResult compilationResult,
+                    Register uncompressedNullRegister) {
+        this(codeCache,
+                        foreignCalls,
+                        frameMap,
+                        asm,
+                        dataBuilder,
+                        frameContext,
+                        options,
+                        debug,
+                        compilationResult,
+                        uncompressedNullRegister,
+                        EconomicMap.create(Equivalence.DEFAULT));
+    }
+
+    public CompilationResultBuilder(CodeCacheProvider codeCache,
+                    ForeignCallsProvider foreignCalls,
+                    FrameMap frameMap,
+                    Assembler asm,
+                    DataBuilder dataBuilder,
+                    FrameContext frameContext,
+                    OptionValues options,
+                    DebugContext debug,
+                    CompilationResult compilationResult,
+                    Register uncompressedNullRegister,
+                    EconomicMap<Constant, Data> dataCache) {
         this.target = codeCache.getTarget();
         this.codeCache = codeCache;
         this.foreignCalls = foreignCalls;
         this.frameMap = frameMap;
         this.asm = asm;
         this.dataBuilder = dataBuilder;
         this.compilationResult = compilationResult;
-        this.nullRegister = nullRegister;
+        this.uncompressedNullRegister = uncompressedNullRegister;
         this.frameContext = frameContext;
         this.options = options;
         this.debug = debug;
         assert frameContext != null;
         this.dataCache = dataCache;
@@ -253,10 +294,20 @@
     public void recordImplicitException(int pcOffset, LIRFrameState info) {
         compilationResult.recordInfopoint(pcOffset, info.debugInfo(), InfopointReason.IMPLICIT_EXCEPTION);
         assert info.exceptionEdge == null;
     }
 
+    public boolean isImplicitExceptionExist(int pcOffset) {
+        List<Infopoint> infopoints = compilationResult.getInfopoints();
+        for (Infopoint infopoint : infopoints) {
+            if (infopoint.pcOffset == pcOffset && infopoint.reason == InfopointReason.IMPLICIT_EXCEPTION) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     public void recordDirectCall(int posBefore, int posAfter, InvokeTarget callTarget, LIRFrameState info) {
         DebugInfo debugInfo = info != null ? info.debugInfo() : null;
         compilationResult.recordCall(posBefore, posAfter - posBefore, callTarget, debugInfo, true);
     }
 
@@ -532,26 +583,43 @@
 
             try {
                 if (beforeOp != null) {
                     beforeOp.accept(op);
                 }
-                emitOp(this, op);
+                emitOp(op);
                 if (afterOp != null) {
                     afterOp.accept(op);
                 }
             } catch (GraalError e) {
                 throw e.addContext("lir instruction", block + "@" + op.id() + " " + op.getClass().getName() + " " + op + "\n" + Arrays.toString(lir.codeEmittingOrder()));
             }
         }
     }
 
-    private static void emitOp(CompilationResultBuilder crb, LIRInstruction op) {
+    private void emitOp(LIRInstruction op) {
         try {
-            int start = crb.asm.position();
-            op.emitCode(crb);
+            int start = asm.position();
+            op.emitCode(this);
             if (op.getPosition() != null) {
-                crb.recordSourceMapping(start, crb.asm.position(), op.getPosition());
+                recordSourceMapping(start, asm.position(), op.getPosition());
+            }
+            if (LIR_INSTRUCTION_VERIFIERS.size() > 0 && start < asm.position()) {
+                int end = asm.position();
+                for (CodeAnnotation codeAnnotation : compilationResult.getCodeAnnotations()) {
+                    if (codeAnnotation instanceof JumpTable) {
+                        // Skip jump table. Here we assume the jump table is at the tail of the
+                        // emitted code.
+                        int jumpTableStart = codeAnnotation.position;
+                        if (jumpTableStart >= start && jumpTableStart < end) {
+                            end = jumpTableStart;
+                        }
+                    }
+                }
+                byte[] emittedCode = asm.copy(start, end);
+                for (LIRInstructionVerifier verifier : LIR_INSTRUCTION_VERIFIERS) {
+                    verifier.verify(op, emittedCode);
+                }
             }
         } catch (BailoutException e) {
             throw e;
         } catch (AssertionError t) {
             throw new GraalError(t);
@@ -596,12 +664,12 @@
                     if (op instanceof LabelHoldingOp) {
                         Label label = ((LabelHoldingOp) op).getLabel();
                         if (label != null) {
                             labelBindLirPositions.put(label, instructionPosition);
                         }
-                        lirPositions.put(op, instructionPosition);
                     }
+                    lirPositions.put(op, instructionPosition);
                     instructionPosition++;
                 }
             }
         }
     }
@@ -633,6 +701,20 @@
      * false.
      */
     public void setConservativeLabelRanges() {
         this.conservativeLabelOffsets = true;
     }
+
+    public final boolean needsClearUpperVectorRegisters() {
+        for (AbstractBlockBase<?> block : lir.codeEmittingOrder()) {
+            if (block == null) {
+                continue;
+            }
+            for (LIRInstruction op : lir.getLIRforBlock(block)) {
+                if (op.needsClearUpperVectorRegisters()) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
 }

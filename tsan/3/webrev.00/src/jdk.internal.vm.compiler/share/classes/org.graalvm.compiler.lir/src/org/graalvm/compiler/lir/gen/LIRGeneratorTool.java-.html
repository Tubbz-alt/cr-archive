<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.gen;
 26 
 27 import java.util.BitSet;
 28 import java.util.List;
 29 
 30 import org.graalvm.compiler.core.common.CompressEncoding;
 31 import org.graalvm.compiler.core.common.LIRKind;
 32 import org.graalvm.compiler.core.common.calc.Condition;
 33 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 34 import org.graalvm.compiler.core.common.spi.CodeGenProviders;
 35 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 37 import org.graalvm.compiler.core.common.type.Stamp;
 38 import org.graalvm.compiler.debug.GraalError;
 39 import org.graalvm.compiler.graph.NodeSourcePosition;
 40 import org.graalvm.compiler.lir.LIRFrameState;
 41 import org.graalvm.compiler.lir.LIRInstruction;
 42 import org.graalvm.compiler.lir.LabelRef;
 43 import org.graalvm.compiler.lir.SwitchStrategy;
 44 import org.graalvm.compiler.lir.Variable;
 45 import org.graalvm.compiler.lir.VirtualStackSlot;
 46 
 47 import jdk.vm.ci.code.CodeCacheProvider;
 48 import jdk.vm.ci.code.Register;
 49 import jdk.vm.ci.code.RegisterAttributes;
 50 import jdk.vm.ci.code.RegisterConfig;
 51 import jdk.vm.ci.code.StackSlot;
 52 import jdk.vm.ci.code.TargetDescription;
 53 import jdk.vm.ci.code.ValueKindFactory;
 54 import jdk.vm.ci.meta.AllocatableValue;
 55 import jdk.vm.ci.meta.Constant;
 56 import jdk.vm.ci.meta.JavaConstant;
 57 import jdk.vm.ci.meta.JavaKind;
 58 import jdk.vm.ci.meta.MetaAccessProvider;
 59 import jdk.vm.ci.meta.PlatformKind;
 60 import jdk.vm.ci.meta.Value;
 61 import jdk.vm.ci.meta.ValueKind;
 62 
 63 public interface LIRGeneratorTool extends DiagnosticLIRGeneratorTool, ValueKindFactory&lt;LIRKind&gt; {
 64 
 65     /**
 66      * Factory for creating moves.
 67      */
 68     interface MoveFactory {
 69 
 70         /**
 71          * Checks whether the supplied constant can be used without loading it into a register for
 72          * most operations, i.e., for commonly used arithmetic, logical, and comparison operations.
 73          *
 74          * @param c The constant to check.
 75          * @return True if the constant can be used directly, false if the constant needs to be in a
 76          *         register.
 77          */
 78         boolean canInlineConstant(Constant c);
 79 
 80         /**
 81          * @param constant The constant that might be moved to a stack slot.
 82          * @return {@code true} if constant to stack moves are supported for this constant.
 83          */
 84         boolean allowConstantToStackMove(Constant constant);
 85 
 86         LIRInstruction createMove(AllocatableValue result, Value input);
 87 
 88         LIRInstruction createStackMove(AllocatableValue result, AllocatableValue input);
 89 
 90         LIRInstruction createLoad(AllocatableValue result, Constant input);
 91 
 92         LIRInstruction createStackLoad(AllocatableValue result, Constant input);
 93     }
 94 
 95     abstract class BlockScope implements AutoCloseable {
 96 
 97         public abstract AbstractBlockBase&lt;?&gt; getCurrentBlock();
 98 
 99         @Override
100         public abstract void close();
101 
102     }
103 
104     ArithmeticLIRGeneratorTool getArithmetic();
105 
106     CodeGenProviders getProviders();
107 
108     TargetDescription target();
109 
110     MetaAccessProvider getMetaAccess();
111 
112     CodeCacheProvider getCodeCache();
113 
114     ForeignCallsProvider getForeignCalls();
115 
116     AbstractBlockBase&lt;?&gt; getCurrentBlock();
117 
118     LIRGenerationResult getResult();
119 
120     RegisterConfig getRegisterConfig();
121 
122     boolean hasBlockEnd(AbstractBlockBase&lt;?&gt; block);
123 
124     MoveFactory getMoveFactory();
125 
126     /**
127      * Get a special {@link MoveFactory} for spill moves.
128      *
129      * The instructions returned by this factory must only depend on the input values. References to
130      * values that require interaction with register allocation are strictly forbidden.
131      */
132     MoveFactory getSpillMoveFactory();
133 
134     BlockScope getBlockScope(AbstractBlockBase&lt;?&gt; block);
135 
136     Value emitConstant(LIRKind kind, Constant constant);
137 
138     Value emitJavaConstant(JavaConstant constant);
139 
140     /**
141      * Some backends need to convert sub-word kinds to a larger kind in
142      * {@link ArithmeticLIRGeneratorTool#emitLoad} and {@link #emitLoadConstant} because sub-word
143      * registers can&#39;t be accessed. This method converts the {@link LIRKind} of a memory location or
144      * constant to the {@link LIRKind} that will be used when it is loaded into a register.
145      */
146     &lt;K extends ValueKind&lt;K&gt;&gt; K toRegisterKind(K kind);
147 
148     AllocatableValue emitLoadConstant(ValueKind&lt;?&gt; kind, Constant constant);
149 
150     void emitNullCheck(Value address, LIRFrameState state);
151 
152     Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue);
153 
154     Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue);
155 
156     /**
157      * Emit an atomic read-and-add instruction.
158      *
159      * @param address address of the value to be read and written
160      * @param valueKind the access kind for the value to be written
161      * @param delta the value to be added
162      */
163     default Value emitAtomicReadAndAdd(Value address, ValueKind&lt;?&gt; valueKind, Value delta) {
164         throw GraalError.unimplemented();
165     }
166 
167     /**
168      * Emit an atomic read-and-write instruction.
169      *
170      * @param address address of the value to be read and written
171      * @param valueKind the access kind for the value to be written
172      * @param newValue the new value to be written
173      */
174     default Value emitAtomicReadAndWrite(Value address, ValueKind&lt;?&gt; valueKind, Value newValue) {
175         throw GraalError.unimplemented();
176     }
177 
178     void emitDeoptimize(Value actionAndReason, Value failedSpeculation, LIRFrameState state);
179 
180     Variable emitForeignCall(ForeignCallLinkage linkage, LIRFrameState state, Value... args);
181 
182     RegisterAttributes attributes(Register register);
183 
184     /**
185      * Create a new {@link Variable}.
186      *
187      * @param kind The type of the value that will be stored in this {@link Variable}. See
188      *            {@link LIRKind} for documentation on what to pass here. Note that in most cases,
189      *            simply passing {@link Value#getValueKind()} is wrong.
190      * @return A new {@link Variable}.
191      */
192     Variable newVariable(ValueKind&lt;?&gt; kind);
193 
194     Variable emitMove(Value input);
195 
196     void emitMove(AllocatableValue dst, Value src);
197 
198     void emitMoveConstant(AllocatableValue dst, Constant src);
199 
200     Variable emitAddress(AllocatableValue stackslot);
201 
202     void emitMembar(int barriers);
203 
204     void emitUnwind(Value operand);
205 
206     /**
207      * Called just before register allocation is performed on the LIR owned by this generator.
208      * Overriding implementations of this method must call the overridden method.
209      */
210     void beforeRegisterAllocation();
211 
212     void emitIncomingValues(Value[] params);
213 
214     /**
215      * Emits a return instruction. Implementations need to insert a move if the input is not in the
216      * correct location.
217      */
218     void emitReturn(JavaKind javaKind, Value input);
219 
220     AllocatableValue asAllocatable(Value value);
221 
222     Variable load(Value value);
223 
224     Value loadNonConst(Value value);
225 
226     /**
227      * Determines if only oop maps are required for the code generated from the LIR.
228      */
229     boolean needOnlyOopMaps();
230 
231     /**
232      * Gets the ABI specific operand used to return a value of a given kind from a method.
233      *
234      * @param javaKind the {@link JavaKind} of value being returned
235      * @param valueKind the backend type of the value being returned
236      * @return the operand representing the ABI defined location used return a value of kind
237      *         {@code kind}
238      */
239     AllocatableValue resultOperandFor(JavaKind javaKind, ValueKind&lt;?&gt; valueKind);
240 
241     &lt;I extends LIRInstruction&gt; I append(I op);
242 
243     void setSourcePosition(NodeSourcePosition position);
244 
245     void emitJump(LabelRef label);
246 
247     void emitCompareBranch(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination,
248                     double trueDestinationProbability);
249 
250     void emitOverflowCheckBranch(LabelRef overflow, LabelRef noOverflow, LIRKind cmpKind, double overflowProbability);
251 
252     void emitIntegerTestBranch(Value left, Value right, LabelRef trueDestination, LabelRef falseDestination, double trueSuccessorProbability);
253 
254     Variable emitConditionalMove(PlatformKind cmpKind, Value leftVal, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue);
255 
256     Variable emitIntegerTestMove(Value leftVal, Value right, Value trueValue, Value falseValue);
257 
258     void emitStrategySwitch(JavaConstant[] keyConstants, double[] keyProbabilities, LabelRef[] keyTargets, LabelRef defaultTarget, Variable value);
259 
260     void emitStrategySwitch(SwitchStrategy strategy, Variable key, LabelRef[] keyTargets, LabelRef defaultTarget);
261 
262     Variable emitByteSwap(Value operand);
263 
264     @SuppressWarnings(&quot;unused&quot;)
265     default Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
266         throw GraalError.unimplemented(&quot;String.compareTo substitution is not implemented on this architecture&quot;);
267     }
268 
269     Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, int constantLength, boolean directPointers);
270 
271     @SuppressWarnings(&quot;unused&quot;)
272     default Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, int constantLength, boolean directPointers) {
273         throw GraalError.unimplemented(&quot;Array.equals with different types substitution is not implemented on this architecture&quot;);
274     }
275 
276     @SuppressWarnings(&quot;unused&quot;)
277     default Variable emitArrayIndexOf(JavaKind kind, boolean findTwoConsecutive, Value sourcePointer, Value sourceCount, Value... searchValues) {
278         throw GraalError.unimplemented(&quot;String.indexOf substitution is not implemented on this architecture&quot;);
279     }
280 
281     /*
282      * The routines emitStringLatin1Inflate/3 and emitStringUTF16Compress/3 models a simplified
283      * version of
284      *
285      * emitStringLatin1Inflate(Value src, Value src_ndx, Value dst, Value dst_ndx, Value len) and
286      * emitStringUTF16Compress(Value src, Value src_ndx, Value dst, Value dst_ndx, Value len)
287      *
288      * respectively, where we have hoisted the offset address computations in a method replacement
289      * snippet.
290      */
291     @SuppressWarnings(&quot;unused&quot;)
292     default void emitStringLatin1Inflate(Value src, Value dst, Value len) {
293         throw GraalError.unimplemented(&quot;StringLatin1.inflate substitution is not implemented on this architecture&quot;);
294     }
295 
296     @SuppressWarnings(&quot;unused&quot;)
297     default Variable emitStringUTF16Compress(Value src, Value dst, Value len) {
298         throw GraalError.unimplemented(&quot;StringUTF16.compress substitution is not implemented on this architecture&quot;);
299     }
300 
301     void emitBlackhole(Value operand);
302 
303     LIRKind getLIRKind(Stamp stamp);
304 
305     void emitPause();
306 
307     void emitPrefetchAllocate(Value address);
308 
309     Value emitCompress(Value pointer, CompressEncoding encoding, boolean nonNull);
310 
311     Value emitUncompress(Value pointer, CompressEncoding encoding, boolean nonNull);
312 
313     default void emitConvertNullToZero(AllocatableValue result, Value input) {
314         emitMove(result, input);
315     }
316 
317     default void emitConvertZeroToNull(AllocatableValue result, Value input) {
318         emitMove(result, input);
319     }
320 
321     /**
322      * Emits an instruction that prevents speculative execution from proceeding: no instruction
323      * after this fence will execute until all previous instructions have retired.
324      */
325     void emitSpeculationFence();
326 
327     default VirtualStackSlot allocateStackSlots(int slots, BitSet objects, List&lt;VirtualStackSlot&gt; outObjectStackSlots) {
328         return getResult().getFrameMapBuilder().allocateStackSlots(slots, objects, outObjectStackSlots);
329     }
330 
331     default Value emitReadCallerStackPointer(Stamp wordStamp) {
332         /*
333          * We do not know the frame size yet. So we load the address of the first spill slot
334          * relative to the beginning of the frame, which is equivalent to the stack pointer of the
335          * caller.
336          */
337         return emitAddress(StackSlot.get(getLIRKind(wordStamp), 0, true));
338     }
339 
340     default Value emitReadReturnAddress(Stamp wordStamp, int returnAddressSize) {
341         return emitMove(StackSlot.get(getLIRKind(wordStamp), -returnAddressSize, true));
342     }
343 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/aix/native/libnet/aix_close.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../libjli/java_md_aix.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../libnio/fs/AixNativeDispatcher.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/aix/native/libnet/aix_close.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">  3  * Copyright (c) 2016, 2017, SAP SE and/or its affiliates. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.  Oracle designates this
  9  * particular file as subject to the &quot;Classpath&quot; exception as provided
 10  * by Oracle in the LICENSE file that accompanied this code.
 11  *
 12  * This code is distributed in the hope that it will be useful, but WITHOUT
 13  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 14  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 15  * version 2 for more details (a copy is included in the LICENSE file that
 16  * accompanied this code).
 17  *
 18  * You should have received a copy of the GNU General Public License version
 19  * 2 along with this work; if not, write to the Free Software Foundation,
 20  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 21  *
 22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 23  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
399     if (fdEntry == NULL) {                      \
400         errno = EBADF;                          \
401         return -1;                              \
402     }                                           \
403     do {                                        \
404         startOp(fdEntry, &amp;self);                \
405         ret = FUNC;                             \
406         endOp(fdEntry, &amp;self);                  \
407     } while (ret == -1 &amp;&amp; errno == EINTR);      \
408     return ret;                                 \
409 }
410 
411 int NET_Read(int s, void* buf, size_t len) {
412     BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );
413 }
414 
415 int NET_NonBlockingRead(int s, void* buf, size_t len) {
416     BLOCKING_IO_RETURN_INT(s, recv(s, buf, len, MSG_NONBLOCK));
417 }
418 
<span class="line-removed">419 int NET_ReadV(int s, const struct iovec * vector, int count) {</span>
<span class="line-removed">420     BLOCKING_IO_RETURN_INT( s, readv(s, vector, count) );</span>
<span class="line-removed">421 }</span>
<span class="line-removed">422 </span>
423 int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
424        struct sockaddr *from, socklen_t *fromlen) {
425     BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );
426 }
427 
428 int NET_Send(int s, void *msg, int len, unsigned int flags) {
429     BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );
430 }
431 
432 int NET_SendTo(int s, const void *msg, int len,  unsigned  int
433        flags, const struct sockaddr *to, int tolen) {
434     BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );
435 }
436 
437 int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {
438     BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );
439 }
440 
441 int NET_Connect(int s, struct sockaddr *addr, int addrlen) {
442     int crc = -1, prc = -1;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">  3  * Copyright (c) 2016, 2019, SAP SE and/or its affiliates. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.  Oracle designates this
  9  * particular file as subject to the &quot;Classpath&quot; exception as provided
 10  * by Oracle in the LICENSE file that accompanied this code.
 11  *
 12  * This code is distributed in the hope that it will be useful, but WITHOUT
 13  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 14  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 15  * version 2 for more details (a copy is included in the LICENSE file that
 16  * accompanied this code).
 17  *
 18  * You should have received a copy of the GNU General Public License version
 19  * 2 along with this work; if not, write to the Free Software Foundation,
 20  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 21  *
 22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 23  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
399     if (fdEntry == NULL) {                      \
400         errno = EBADF;                          \
401         return -1;                              \
402     }                                           \
403     do {                                        \
404         startOp(fdEntry, &amp;self);                \
405         ret = FUNC;                             \
406         endOp(fdEntry, &amp;self);                  \
407     } while (ret == -1 &amp;&amp; errno == EINTR);      \
408     return ret;                                 \
409 }
410 
411 int NET_Read(int s, void* buf, size_t len) {
412     BLOCKING_IO_RETURN_INT( s, recv(s, buf, len, 0) );
413 }
414 
415 int NET_NonBlockingRead(int s, void* buf, size_t len) {
416     BLOCKING_IO_RETURN_INT(s, recv(s, buf, len, MSG_NONBLOCK));
417 }
418 




419 int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
420        struct sockaddr *from, socklen_t *fromlen) {
421     BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );
422 }
423 
424 int NET_Send(int s, void *msg, int len, unsigned int flags) {
425     BLOCKING_IO_RETURN_INT( s, send(s, msg, len, flags) );
426 }
427 
428 int NET_SendTo(int s, const void *msg, int len,  unsigned  int
429        flags, const struct sockaddr *to, int tolen) {
430     BLOCKING_IO_RETURN_INT( s, sendto(s, msg, len, flags, to, tolen) );
431 }
432 
433 int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {
434     BLOCKING_IO_RETURN_INT( s, accept(s, addr, addrlen) );
435 }
436 
437 int NET_Connect(int s, struct sockaddr *addr, int addrlen) {
438     int crc = -1, prc = -1;
</pre>
</td>
</tr>
</table>
<center><a href="../libjli/java_md_aix.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../libnio/fs/AixNativeDispatcher.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/native/libjli/java_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;windows.h&gt;
  27 #include &lt;io.h&gt;
  28 #include &lt;process.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stdio.h&gt;
  31 #include &lt;stdarg.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;sys/types.h&gt;
  34 #include &lt;sys/stat.h&gt;
  35 #include &lt;wtypes.h&gt;
  36 #include &lt;commctrl.h&gt;
<a name="1" id="anc1"></a><span class="line-added">  37 #include &lt;assert.h&gt;</span>
  38 
  39 #include &lt;jni.h&gt;
  40 #include &quot;java.h&quot;
  41 
  42 #define JVM_DLL &quot;jvm.dll&quot;
  43 #define JAVA_DLL &quot;java.dll&quot;
  44 
<a name="2" id="anc2"></a>

  45 /*
  46  * Prototypes.
  47  */
  48 static jboolean GetJVMPath(const char *jrepath, const char *jvmtype,
  49                            char *jvmpath, jint jvmpathsize);
  50 static jboolean GetJREPath(char *path, jint pathsize);
  51 
  52 #ifdef USE_REGISTRY_LOOKUP
  53 jboolean GetPublicJREHome(char *buf, jint bufsize);
  54 #endif
  55 
  56 /* We supports warmup for UI stack that is performed in parallel
  57  * to VM initialization.
  58  * This helps to improve startup of UI application as warmup phase
  59  * might be long due to initialization of OS or hardware resources.
  60  * It is not CPU bound and therefore it does not interfere with VM init.
  61  * Obviously such warmup only has sense for UI apps and therefore it needs
  62  * to be explicitly requested by passing -Dsun.awt.warmup=true property
  63  * (this is always the case for plugin/javaws).
  64  *
  65  * Implementation launches new thread after VM starts and use it to perform
  66  * warmup code (platform dependent).
  67  * This thread is later reused as AWT toolkit thread as graphics toolkit
  68  * often assume that they are used from the same thread they were launched on.
  69  *
  70  * At the moment we only support warmup for D3D. It only possible on windows
  71  * and only if other flags do not prohibit this (e.g. OpenGL support requested).
  72  */
  73 #undef ENABLE_AWT_PRELOAD
  74 #ifndef JAVA_ARGS /* turn off AWT preloading for javac, jar, etc */
  75     /* CR6999872: fastdebug crashes if awt library is loaded before JVM is
  76      * initialized*/
  77     #if !defined(DEBUG)
  78         #define ENABLE_AWT_PRELOAD
  79     #endif
  80 #endif
  81 
  82 #ifdef ENABLE_AWT_PRELOAD
  83 /* &quot;AWT was preloaded&quot; flag;
  84  * turned on by AWTPreload().
  85  */
  86 int awtPreloaded = 0;
  87 
  88 /* Calls a function with the name specified
  89  * the function must be int(*fn)(void).
  90  */
  91 int AWTPreload(const char *funcName);
  92 /* stops AWT preloading */
  93 void AWTPreloadStop();
  94 
  95 /* D3D preloading */
  96 /* -1: not initialized; 0: OFF, 1: ON */
  97 int awtPreloadD3D = -1;
  98 /* command line parameter to swith D3D preloading on */
  99 #define PARAM_PRELOAD_D3D &quot;-Dsun.awt.warmup&quot;
 100 /* D3D/OpenGL management parameters */
 101 #define PARAM_NODDRAW &quot;-Dsun.java2d.noddraw&quot;
 102 #define PARAM_D3D &quot;-Dsun.java2d.d3d&quot;
 103 #define PARAM_OPENGL &quot;-Dsun.java2d.opengl&quot;
 104 /* funtion in awt.dll (src/windows/native/sun/java2d/d3d/D3DPipelineManager.cpp) */
 105 #define D3D_PRELOAD_FUNC &quot;preloadD3D&quot;
 106 
 107 /* Extracts value of a parameter with the specified name
 108  * from command line argument (returns pointer in the argument).
 109  * Returns NULL if the argument does not contains the parameter.
 110  * e.g.:
 111  * GetParamValue(&quot;theParam&quot;, &quot;theParam=value&quot;) returns pointer to &quot;value&quot;.
 112  */
 113 const char * GetParamValue(const char *paramName, const char *arg) {
 114     size_t nameLen = JLI_StrLen(paramName);
 115     if (JLI_StrNCmp(paramName, arg, nameLen) == 0) {
 116         /* arg[nameLen] is valid (may contain final NULL) */
 117         if (arg[nameLen] == &#39;=&#39;) {
 118             return arg + nameLen + 1;
 119         }
 120     }
 121     return NULL;
 122 }
 123 
 124 /* Checks if commandline argument contains property specified
 125  * and analyze it as boolean property (true/false).
 126  * Returns -1 if the argument does not contain the parameter;
 127  * Returns 1 if the argument contains the parameter and its value is &quot;true&quot;;
 128  * Returns 0 if the argument contains the parameter and its value is &quot;false&quot;.
 129  */
 130 int GetBoolParamValue(const char *paramName, const char *arg) {
 131     const char * paramValue = GetParamValue(paramName, arg);
 132     if (paramValue != NULL) {
 133         if (JLI_StrCaseCmp(paramValue, &quot;true&quot;) == 0) {
 134             return 1;
 135         }
 136         if (JLI_StrCaseCmp(paramValue, &quot;false&quot;) == 0) {
 137             return 0;
 138         }
 139     }
 140     return -1;
 141 }
 142 #endif /* ENABLE_AWT_PRELOAD */
 143 
 144 
 145 static jboolean _isjavaw = JNI_FALSE;
 146 
 147 
 148 jboolean
 149 IsJavaw()
 150 {
 151     return _isjavaw;
 152 }
 153 
 154 /*
 155  *
 156  */
 157 void
 158 CreateExecutionEnvironment(int *pargc, char ***pargv,
 159                            char *jrepath, jint so_jrepath,
 160                            char *jvmpath, jint so_jvmpath,
 161                            char *jvmcfg,  jint so_jvmcfg) {
 162 
 163     char *jvmtype;
 164     int i = 0;
 165     char** argv = *pargv;
 166 
 167     /* Find out where the JRE is that we will be using. */
 168     if (!GetJREPath(jrepath, so_jrepath)) {
 169         JLI_ReportErrorMessage(JRE_ERROR1);
 170         exit(2);
 171     }
 172 
 173     JLI_Snprintf(jvmcfg, so_jvmcfg, &quot;%s%slib%sjvm.cfg&quot;,
 174         jrepath, FILESEP, FILESEP);
 175 
 176     /* Find the specified JVM type */
 177     if (ReadKnownVMs(jvmcfg, JNI_FALSE) &lt; 1) {
 178         JLI_ReportErrorMessage(CFG_ERROR7);
 179         exit(1);
 180     }
 181 
 182     jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);
 183     if (JLI_StrCmp(jvmtype, &quot;ERROR&quot;) == 0) {
 184         JLI_ReportErrorMessage(CFG_ERROR9);
 185         exit(4);
 186     }
 187 
 188     jvmpath[0] = &#39;\0&#39;;
 189     if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) {
 190         JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);
 191         exit(4);
 192     }
 193     /* If we got here, jvmpath has been correctly initialized. */
 194 
 195     /* Check if we need preload AWT */
 196 #ifdef ENABLE_AWT_PRELOAD
 197     argv = *pargv;
 198     for (i = 0; i &lt; *pargc ; i++) {
 199         /* Tests the &quot;turn on&quot; parameter only if not set yet. */
 200         if (awtPreloadD3D &lt; 0) {
 201             if (GetBoolParamValue(PARAM_PRELOAD_D3D, argv[i]) == 1) {
 202                 awtPreloadD3D = 1;
 203             }
 204         }
 205         /* Test parameters which can disable preloading if not already disabled. */
 206         if (awtPreloadD3D != 0) {
 207             if (GetBoolParamValue(PARAM_NODDRAW, argv[i]) == 1
 208                 || GetBoolParamValue(PARAM_D3D, argv[i]) == 0
 209                 || GetBoolParamValue(PARAM_OPENGL, argv[i]) == 1)
 210             {
 211                 awtPreloadD3D = 0;
 212                 /* no need to test the rest of the parameters */
 213                 break;
 214             }
 215         }
 216     }
 217 #endif /* ENABLE_AWT_PRELOAD */
 218 }
 219 
 220 
 221 static jboolean
 222 LoadMSVCRT()
 223 {
 224     // Only do this once
 225     static int loaded = 0;
 226     char crtpath[MAXPATHLEN];
 227 
 228     if (!loaded) {
 229         /*
 230          * The Microsoft C Runtime Library needs to be loaded first.  A copy is
 231          * assumed to be present in the &quot;JRE path&quot; directory.  If it is not found
 232          * there (or &quot;JRE path&quot; fails to resolve), skip the explicit load and let
 233          * nature take its course, which is likely to be a failure to execute.
 234          * The makefiles will provide the correct lib contained in quotes in the
 235          * macro MSVCR_DLL_NAME.
 236          */
 237 #ifdef MSVCR_DLL_NAME
 238         if (GetJREPath(crtpath, MAXPATHLEN)) {
 239             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 240                     JLI_StrLen(MSVCR_DLL_NAME) &gt;= MAXPATHLEN) {
 241                 JLI_ReportErrorMessage(JRE_ERROR11);
 242                 return JNI_FALSE;
 243             }
 244             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCR_DLL_NAME);   /* Add crt dll */
 245             JLI_TraceLauncher(&quot;CRT path is %s\n&quot;, crtpath);
 246             if (_access(crtpath, 0) == 0) {
 247                 if (LoadLibrary(crtpath) == 0) {
 248                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 249                     return JNI_FALSE;
 250                 }
 251             }
 252         }
 253 #endif /* MSVCR_DLL_NAME */
 254 #ifdef MSVCP_DLL_NAME
 255         if (GetJREPath(crtpath, MAXPATHLEN)) {
 256             if (JLI_StrLen(crtpath) + JLI_StrLen(&quot;\\bin\\&quot;) +
 257                     JLI_StrLen(MSVCP_DLL_NAME) &gt;= MAXPATHLEN) {
 258                 JLI_ReportErrorMessage(JRE_ERROR11);
 259                 return JNI_FALSE;
 260             }
 261             (void)JLI_StrCat(crtpath, &quot;\\bin\\&quot; MSVCP_DLL_NAME);   /* Add prt dll */
 262             JLI_TraceLauncher(&quot;PRT path is %s\n&quot;, crtpath);
 263             if (_access(crtpath, 0) == 0) {
 264                 if (LoadLibrary(crtpath) == 0) {
 265                     JLI_ReportErrorMessage(DLL_ERROR4, crtpath);
 266                     return JNI_FALSE;
 267                 }
 268             }
 269         }
 270 #endif /* MSVCP_DLL_NAME */
 271         loaded = 1;
 272     }
 273     return JNI_TRUE;
 274 }
 275 
 276 
 277 /*
 278  * Find path to JRE based on .exe&#39;s location or registry settings.
 279  */
 280 jboolean
 281 GetJREPath(char *path, jint pathsize)
 282 {
 283     char javadll[MAXPATHLEN];
 284     struct stat s;
 285 
 286     if (GetApplicationHome(path, pathsize)) {
 287         /* Is JRE co-located with the application? */
 288         JLI_Snprintf(javadll, sizeof(javadll), &quot;%s\\bin\\&quot; JAVA_DLL, path);
 289         if (stat(javadll, &amp;s) == 0) {
 290             JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 291             return JNI_TRUE;
 292         }
 293         /* ensure storage for path + \jre + NULL */
 294         if ((JLI_StrLen(path) + 4 + 1) &gt; (size_t) pathsize) {
 295             JLI_TraceLauncher(&quot;Insufficient space to store JRE path\n&quot;);
 296             return JNI_FALSE;
 297         }
 298         /* Does this app ship a private JRE in &lt;apphome&gt;\jre directory? */
 299         JLI_Snprintf(javadll, sizeof (javadll), &quot;%s\\jre\\bin\\&quot; JAVA_DLL, path);
 300         if (stat(javadll, &amp;s) == 0) {
 301             JLI_StrCat(path, &quot;\\jre&quot;);
 302             JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 303             return JNI_TRUE;
 304         }
 305     }
 306 
 307     /* Try getting path to JRE from path to JLI.DLL */
 308     if (GetApplicationHomeFromDll(path, pathsize)) {
 309         JLI_Snprintf(javadll, sizeof(javadll), &quot;%s\\bin\\&quot; JAVA_DLL, path);
 310         if (stat(javadll, &amp;s) == 0) {
 311             JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 312             return JNI_TRUE;
 313         }
 314     }
 315 
 316 #ifdef USE_REGISTRY_LOOKUP
 317     /* Lookup public JRE using Windows registry. */
 318     if (GetPublicJREHome(path, pathsize)) {
 319         JLI_TraceLauncher(&quot;JRE path is %s\n&quot;, path);
 320         return JNI_TRUE;
 321     }
 322 #endif
 323 
 324     JLI_ReportErrorMessage(JRE_ERROR8 JAVA_DLL);
 325     return JNI_FALSE;
 326 }
 327 
 328 /*
 329  * Given a JRE location and a JVM type, construct what the name the
 330  * JVM shared library will be.  Return true, if such a library
 331  * exists, false otherwise.
 332  */
 333 static jboolean
 334 GetJVMPath(const char *jrepath, const char *jvmtype,
 335            char *jvmpath, jint jvmpathsize)
 336 {
 337     struct stat s;
 338     if (JLI_StrChr(jvmtype, &#39;/&#39;) || JLI_StrChr(jvmtype, &#39;\\&#39;)) {
 339         JLI_Snprintf(jvmpath, jvmpathsize, &quot;%s\\&quot; JVM_DLL, jvmtype);
 340     } else {
 341         JLI_Snprintf(jvmpath, jvmpathsize, &quot;%s\\bin\\%s\\&quot; JVM_DLL,
 342                      jrepath, jvmtype);
 343     }
 344     if (stat(jvmpath, &amp;s) == 0) {
 345         return JNI_TRUE;
 346     } else {
 347         return JNI_FALSE;
 348     }
 349 }
 350 
 351 /*
 352  * Load a jvm from &quot;jvmpath&quot; and initialize the invocation functions.
 353  */
 354 jboolean
 355 LoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)
 356 {
 357     HINSTANCE handle;
 358 
 359     JLI_TraceLauncher(&quot;JVM path is %s\n&quot;, jvmpath);
 360 
 361     /*
 362      * The Microsoft C Runtime Library needs to be loaded first.  A copy is
 363      * assumed to be present in the &quot;JRE path&quot; directory.  If it is not found
 364      * there (or &quot;JRE path&quot; fails to resolve), skip the explicit load and let
 365      * nature take its course, which is likely to be a failure to execute.
 366      *
 367      */
 368     LoadMSVCRT();
 369 
 370     /* Load the Java VM DLL */
 371     if ((handle = LoadLibrary(jvmpath)) == 0) {
 372         JLI_ReportErrorMessage(DLL_ERROR4, (char *)jvmpath);
 373         return JNI_FALSE;
 374     }
 375 
 376     /* Now get the function addresses */
 377     ifn-&gt;CreateJavaVM =
 378         (void *)GetProcAddress(handle, &quot;JNI_CreateJavaVM&quot;);
 379     ifn-&gt;GetDefaultJavaVMInitArgs =
 380         (void *)GetProcAddress(handle, &quot;JNI_GetDefaultJavaVMInitArgs&quot;);
 381     if (ifn-&gt;CreateJavaVM == 0 || ifn-&gt;GetDefaultJavaVMInitArgs == 0) {
 382         JLI_ReportErrorMessage(JNI_ERROR1, (char *)jvmpath);
 383         return JNI_FALSE;
 384     }
 385 
 386     return JNI_TRUE;
 387 }
 388 
 389 /*
 390  * Removes the trailing file name and one sub-folder from a path.
 391  * If buf is &quot;c:\foo\bin\javac&quot;, then put &quot;c:\foo&quot; into buf.
 392  */
 393 jboolean
 394 TruncatePath(char *buf)
 395 {
 396     char *cp;
 397     *JLI_StrRChr(buf, &#39;\\&#39;) = &#39;\0&#39;; /* remove .exe file name */
 398     if ((cp = JLI_StrRChr(buf, &#39;\\&#39;)) == 0) {
 399         /* This happens if the application is in a drive root, and
 400          * there is no bin directory. */
 401         buf[0] = &#39;\0&#39;;
 402         return JNI_FALSE;
 403     }
 404     *cp = &#39;\0&#39;; /* remove the bin\ part */
 405     return JNI_TRUE;
 406 }
 407 
 408 /*
 409  * Retrieves the path to the JRE home by locating the executable file
 410  * of the current process and then truncating the path to the executable
 411  */
 412 jboolean
 413 GetApplicationHome(char *buf, jint bufsize)
 414 {
 415     GetModuleFileName(NULL, buf, bufsize);
 416     return TruncatePath(buf);
 417 }
 418 
 419 /*
 420  * Retrieves the path to the JRE home by locating JLI.DLL and
 421  * then truncating the path to JLI.DLL
 422  */
 423 jboolean
 424 GetApplicationHomeFromDll(char *buf, jint bufsize)
 425 {
 426     HMODULE module;
 427     DWORD flags = GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
 428                   GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT;
 429 
 430     if (GetModuleHandleEx(flags, (LPCSTR)&amp;GetJREPath, &amp;module) != 0) {
 431         if (GetModuleFileName(module, buf, bufsize) != 0) {
 432             return TruncatePath(buf);
 433         }
 434     }
 435     return JNI_FALSE;
 436 }
 437 
 438 /*
 439  * Support for doing cheap, accurate interval timing.
 440  */
 441 static jboolean counterAvailable = JNI_FALSE;
 442 static jboolean counterInitialized = JNI_FALSE;
 443 static LARGE_INTEGER counterFrequency;
 444 
 445 jlong CounterGet()
 446 {
 447     LARGE_INTEGER count;
 448 
 449     if (!counterInitialized) {
 450         counterAvailable = QueryPerformanceFrequency(&amp;counterFrequency);
 451         counterInitialized = JNI_TRUE;
 452     }
 453     if (!counterAvailable) {
 454         return 0;
 455     }
 456     QueryPerformanceCounter(&amp;count);
 457     return (jlong)(count.QuadPart);
 458 }
 459 
 460 jlong Counter2Micros(jlong counts)
 461 {
 462     if (!counterAvailable || !counterInitialized) {
 463         return 0;
 464     }
 465     return (counts * 1000 * 1000)/counterFrequency.QuadPart;
 466 }
 467 /*
 468  * windows snprintf does not guarantee a null terminator in the buffer,
 469  * if the computed size is equal to or greater than the buffer size,
 470  * as well as error conditions. This function guarantees a null terminator
 471  * under all these conditions. An unreasonable buffer or size will return
 472  * an error value. Under all other conditions this function will return the
 473  * size of the bytes actually written minus the null terminator, similar
 474  * to ansi snprintf api. Thus when calling this function the caller must
 475  * ensure storage for the null terminator.
 476  */
 477 int
 478 JLI_Snprintf(char* buffer, size_t size, const char* format, ...) {
 479     int rc;
 480     va_list vl;
 481     if (size == 0 || buffer == NULL)
 482         return -1;
 483     buffer[0] = &#39;\0&#39;;
 484     va_start(vl, format);
 485     rc = vsnprintf(buffer, size, format, vl);
 486     va_end(vl);
 487     /* force a null terminator, if something is amiss */
 488     if (rc &lt; 0) {
 489         /* apply ansi semantics */
 490         buffer[size - 1] = &#39;\0&#39;;
 491         return (int)size;
 492     } else if (rc == size) {
 493         /* force a null terminator */
 494         buffer[size - 1] = &#39;\0&#39;;
 495     }
 496     return rc;
 497 }
 498 
<a name="3" id="anc3"></a><span class="line-modified"> 499 /* taken from hotspot and slightly adjusted for jli lib;</span>
<span class="line-modified"> 500  * creates a UNC/ELP path from input &#39;path&#39;</span>
<span class="line-modified"> 501  * the return buffer is allocated in C heap and needs to be freed using</span>
<span class="line-modified"> 502  * JLI_MemFree by the caller.</span>
<span class="line-modified"> 503  */</span>
<span class="line-modified"> 504 static wchar_t* create_unc_path(const char* path, errno_t* err) {</span>
<span class="line-modified"> 505     wchar_t* wpath = NULL;</span>
<span class="line-modified"> 506     size_t converted_chars = 0;</span>
<span class="line-modified"> 507     size_t path_len = strlen(path) + 1; /* includes the terminating NULL */</span>
<span class="line-modified"> 508     if (path[0] == &#39;\\&#39; &amp;&amp; path[1] == &#39;\\&#39;) {</span>
<span class="line-modified"> 509         if (path[2] == &#39;?&#39; &amp;&amp; path[3] == &#39;\\&#39;) {</span>
<span class="line-modified"> 510             /* if it already has a \\?\ don&#39;t do the prefix */</span>
<span class="line-modified"> 511             wpath = (wchar_t*) JLI_MemAlloc(path_len * sizeof(wchar_t));</span>
<span class="line-modified"> 512             if (wpath != NULL) {</span>
<span class="line-modified"> 513                 *err = mbstowcs_s(&amp;converted_chars, wpath, path_len, path, path_len);</span>
<span class="line-modified"> 514             } else {</span>
<span class="line-modified"> 515                 *err = ENOMEM;</span>
<span class="line-modified"> 516             }</span>
<span class="line-modified"> 517         } else {</span>
<span class="line-added"> 518             /* only UNC pathname includes double slashes here */</span>
<span class="line-added"> 519             wpath = (wchar_t*) JLI_MemAlloc((path_len + 7) * sizeof(wchar_t));</span>
<span class="line-added"> 520             if (wpath != NULL) {</span>
<span class="line-added"> 521                 wcscpy(wpath, L&quot;\\\\?\\UNC\0&quot;);</span>
<span class="line-added"> 522                 *err = mbstowcs_s(&amp;converted_chars, &amp;wpath[7], path_len, path, path_len);</span>
<span class="line-added"> 523             } else {</span>
<span class="line-added"> 524                 *err = ENOMEM;</span>
<span class="line-added"> 525             }</span>
 526         }
<a name="4" id="anc4"></a><span class="line-modified"> 527     } else {</span>
<span class="line-modified"> 528         wpath = (wchar_t*) JLI_MemAlloc((path_len + 4) * sizeof(wchar_t));</span>
<span class="line-modified"> 529         if (wpath != NULL) {</span>
<span class="line-modified"> 530             wcscpy(wpath, L&quot;\\\\?\\\0&quot;);</span>
<span class="line-added"> 531             *err = mbstowcs_s(&amp;converted_chars, &amp;wpath[4], path_len, path, path_len);</span>
<span class="line-added"> 532         } else {</span>
<span class="line-added"> 533             *err = ENOMEM;</span>
 534         }
<a name="5" id="anc5"></a><span class="line-added"> 535     }</span>
<span class="line-added"> 536     return wpath;</span>
<span class="line-added"> 537 }</span>
 538 
<a name="6" id="anc6"></a><span class="line-modified"> 539 int JLI_Open(const char* name, int flags) {</span>
<span class="line-modified"> 540     int fd;</span>
<span class="line-modified"> 541     if (strlen(name) &lt; MAX_PATH) {</span>
<span class="line-modified"> 542         fd = _open(name, flags);</span>
<span class="line-modified"> 543     } else {</span>
<span class="line-modified"> 544         errno_t err = ERROR_SUCCESS;</span>
<span class="line-modified"> 545         wchar_t* wpath = create_unc_path(name, &amp;err);</span>
<span class="line-modified"> 546         if (err != ERROR_SUCCESS) {</span>
<span class="line-modified"> 547             if (wpath != NULL) JLI_MemFree(wpath);</span>
<span class="line-modified"> 548             errno = err;</span>
<span class="line-modified"> 549             return -1;</span>



 550         }
<a name="7" id="anc7"></a><span class="line-modified"> 551         fd = _wopen(wpath, flags);</span>
<span class="line-modified"> 552         if (fd == -1) {</span>
<span class="line-modified"> 553             errno = GetLastError();</span>
<span class="line-modified"> 554         }</span>
<span class="line-added"> 555         JLI_MemFree(wpath);</span>
 556     }
 557     return fd;
 558 }
 559 
<a name="8" id="anc8"></a>

 560 JNIEXPORT void JNICALL
 561 JLI_ReportErrorMessage(const char* fmt, ...) {
 562     va_list vl;
 563     va_start(vl,fmt);
 564 
 565     if (IsJavaw()) {
 566         char *message;
 567 
 568         /* get the length of the string we need */
 569         int n = _vscprintf(fmt, vl);
 570 
 571         message = (char *)JLI_MemAlloc(n + 1);
 572         _vsnprintf(message, n, fmt, vl);
 573         message[n]=&#39;\0&#39;;
 574         MessageBox(NULL, message, &quot;Java Virtual Machine Launcher&quot;,
 575             (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 576         JLI_MemFree(message);
 577     } else {
 578         vfprintf(stderr, fmt, vl);
 579         fprintf(stderr, &quot;\n&quot;);
 580     }
 581     va_end(vl);
 582 }
 583 
 584 /*
 585  * Just like JLI_ReportErrorMessage, except that it concatenates the system
 586  * error message if any, its upto the calling routine to correctly
 587  * format the separation of the messages.
 588  */
 589 JNIEXPORT void JNICALL
 590 JLI_ReportErrorMessageSys(const char *fmt, ...)
 591 {
 592     va_list vl;
 593 
 594     int save_errno = errno;
 595     DWORD       errval;
 596     jboolean freeit = JNI_FALSE;
 597     char  *errtext = NULL;
 598 
 599     va_start(vl, fmt);
 600 
 601     if ((errval = GetLastError()) != 0) {               /* Platform SDK / DOS Error */
 602         int n = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|
 603             FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_ALLOCATE_BUFFER,
 604             NULL, errval, 0, (LPTSTR)&amp;errtext, 0, NULL);
 605         if (errtext == NULL || n == 0) {                /* Paranoia check */
 606             errtext = &quot;&quot;;
 607             n = 0;
 608         } else {
 609             freeit = JNI_TRUE;
 610             if (n &gt; 2) {                                /* Drop final CR, LF */
 611                 if (errtext[n - 1] == &#39;\n&#39;) n--;
 612                 if (errtext[n - 1] == &#39;\r&#39;) n--;
 613                 errtext[n] = &#39;\0&#39;;
 614             }
 615         }
 616     } else {   /* C runtime error that has no corresponding DOS error code */
 617         errtext = strerror(save_errno);
 618     }
 619 
 620     if (IsJavaw()) {
 621         char *message;
 622         int mlen;
 623         /* get the length of the string we need */
 624         int len = mlen =  _vscprintf(fmt, vl) + 1;
 625         if (freeit) {
 626            mlen += (int)JLI_StrLen(errtext);
 627         }
 628 
 629         message = (char *)JLI_MemAlloc(mlen);
 630         _vsnprintf(message, len, fmt, vl);
 631         message[len]=&#39;\0&#39;;
 632 
 633         if (freeit) {
 634            JLI_StrCat(message, errtext);
 635         }
 636 
 637         MessageBox(NULL, message, &quot;Java Virtual Machine Launcher&quot;,
 638             (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 639 
 640         JLI_MemFree(message);
 641     } else {
 642         vfprintf(stderr, fmt, vl);
 643         if (freeit) {
 644            fprintf(stderr, &quot;%s&quot;, errtext);
 645         }
 646     }
 647     if (freeit) {
 648         (void)LocalFree((HLOCAL)errtext);
 649     }
 650     va_end(vl);
 651 }
 652 
 653 JNIEXPORT void JNICALL
 654 JLI_ReportExceptionDescription(JNIEnv * env) {
 655     if (IsJavaw()) {
 656        /*
 657         * This code should be replaced by code which opens a window with
 658         * the exception detail message, for now atleast put a dialog up.
 659         */
 660         MessageBox(NULL, &quot;A Java Exception has occurred.&quot;, &quot;Java Virtual Machine Launcher&quot;,
 661                (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 662     } else {
 663         (*env)-&gt;ExceptionDescribe(env);
 664     }
 665 }
 666 
 667 /*
 668  * Wrapper for platform dependent unsetenv function.
 669  */
 670 int
 671 UnsetEnv(char *name)
 672 {
 673     int ret;
 674     char *buf = JLI_MemAlloc(JLI_StrLen(name) + 2);
 675     buf = JLI_StrCat(JLI_StrCpy(buf, name), &quot;=&quot;);
 676     ret = _putenv(buf);
 677     JLI_MemFree(buf);
 678     return (ret);
 679 }
 680 
 681 /* --- Splash Screen shared library support --- */
 682 
 683 static const char* SPLASHSCREEN_SO = &quot;\\bin\\splashscreen.dll&quot;;
 684 
 685 static HMODULE hSplashLib = NULL;
 686 
 687 void* SplashProcAddress(const char* name) {
 688     char libraryPath[MAXPATHLEN]; /* some extra space for JLI_StrCat&#39;ing SPLASHSCREEN_SO */
 689 
 690     if (!GetJREPath(libraryPath, MAXPATHLEN)) {
 691         return NULL;
 692     }
 693     if (JLI_StrLen(libraryPath)+JLI_StrLen(SPLASHSCREEN_SO) &gt;= MAXPATHLEN) {
 694         return NULL;
 695     }
 696     JLI_StrCat(libraryPath, SPLASHSCREEN_SO);
 697 
 698     if (!hSplashLib) {
 699         hSplashLib = LoadLibrary(libraryPath);
 700     }
 701     if (hSplashLib) {
 702         return GetProcAddress(hSplashLib, name);
 703     } else {
 704         return NULL;
 705     }
 706 }
 707 
<a name="9" id="anc9"></a>






 708 /*
 709  * Signature adapter for _beginthreadex().
 710  */
 711 static unsigned __stdcall ThreadJavaMain(void* args) {
 712     return (unsigned)JavaMain(args);
 713 }
 714 
 715 /*
 716  * Block current thread and continue execution in a new thread.
 717  */
 718 int
 719 CallJavaMainInNewThread(jlong stack_size, void* args) {
 720     int rslt = 0;
 721     unsigned thread_id;
 722 
 723 #ifndef STACK_SIZE_PARAM_IS_A_RESERVATION
 724 #define STACK_SIZE_PARAM_IS_A_RESERVATION  (0x10000)
 725 #endif
 726 
 727     /*
 728      * STACK_SIZE_PARAM_IS_A_RESERVATION is what we want, but it&#39;s not
 729      * supported on older version of Windows. Try first with the flag; and
 730      * if that fails try again without the flag. See MSDN document or HotSpot
 731      * source (os_win32.cpp) for details.
 732      */
 733     HANDLE thread_handle =
 734         (HANDLE)_beginthreadex(NULL,
 735                                (unsigned)stack_size,
 736                                ThreadJavaMain,
 737                                args,
 738                                STACK_SIZE_PARAM_IS_A_RESERVATION,
 739                                &amp;thread_id);
 740     if (thread_handle == NULL) {
 741         thread_handle =
 742         (HANDLE)_beginthreadex(NULL,
 743                                (unsigned)stack_size,
 744                                ThreadJavaMain,
 745                                args,
 746                                0,
 747                                &amp;thread_id);
 748     }
 749 
 750     /* AWT preloading (AFTER main thread start) */
 751 #ifdef ENABLE_AWT_PRELOAD
 752     /* D3D preloading */
 753     if (awtPreloadD3D != 0) {
 754         char *envValue;
 755         /* D3D routines checks env.var J2D_D3D if no appropriate
 756          * command line params was specified
 757          */
 758         envValue = getenv(&quot;J2D_D3D&quot;);
 759         if (envValue != NULL &amp;&amp; JLI_StrCaseCmp(envValue, &quot;false&quot;) == 0) {
 760             awtPreloadD3D = 0;
 761         }
 762         /* Test that AWT preloading isn&#39;t disabled by J2D_D3D_PRELOAD env.var */
 763         envValue = getenv(&quot;J2D_D3D_PRELOAD&quot;);
 764         if (envValue != NULL &amp;&amp; JLI_StrCaseCmp(envValue, &quot;false&quot;) == 0) {
 765             awtPreloadD3D = 0;
 766         }
 767         if (awtPreloadD3D &lt; 0) {
 768             /* If awtPreloadD3D is still undefined (-1), test
 769              * if it is turned on by J2D_D3D_PRELOAD env.var.
 770              * By default it&#39;s turned OFF.
 771              */
 772             awtPreloadD3D = 0;
 773             if (envValue != NULL &amp;&amp; JLI_StrCaseCmp(envValue, &quot;true&quot;) == 0) {
 774                 awtPreloadD3D = 1;
 775             }
 776          }
 777     }
 778     if (awtPreloadD3D) {
 779         AWTPreload(D3D_PRELOAD_FUNC);
 780     }
 781 #endif /* ENABLE_AWT_PRELOAD */
 782 
 783     if (thread_handle) {
 784         WaitForSingleObject(thread_handle, INFINITE);
 785         GetExitCodeThread(thread_handle, &amp;rslt);
 786         CloseHandle(thread_handle);
 787     } else {
 788         rslt = JavaMain(args);
 789     }
 790 
 791 #ifdef ENABLE_AWT_PRELOAD
 792     if (awtPreloaded) {
 793         AWTPreloadStop();
 794     }
 795 #endif /* ENABLE_AWT_PRELOAD */
 796 
 797     return rslt;
 798 }
 799 
<a name="10" id="anc10"></a>


 800 /*
 801  * The implementation for finding classes from the bootstrap
 802  * class loader, refer to java.h
 803  */
 804 static FindClassFromBootLoader_t *findBootClass = NULL;
 805 
 806 jclass FindBootStrapClass(JNIEnv *env, const char *classname)
 807 {
 808    HMODULE hJvm;
 809 
 810    if (findBootClass == NULL) {
 811        hJvm = GetModuleHandle(JVM_DLL);
 812        if (hJvm == NULL) return NULL;
 813        /* need to use the demangled entry point */
 814        findBootClass = (FindClassFromBootLoader_t *)GetProcAddress(hJvm,
 815             &quot;JVM_FindClassFromBootLoader&quot;);
 816        if (findBootClass == NULL) {
 817           JLI_ReportErrorMessage(DLL_ERROR4, &quot;JVM_FindClassFromBootLoader&quot;);
 818           return NULL;
 819        }
 820    }
 821    return findBootClass(env, classname);
 822 }
 823 
 824 void
 825 InitLauncher(boolean javaw)
 826 {
 827     INITCOMMONCONTROLSEX icx;
 828 
 829     /*
 830      * Required for javaw mode MessageBox output as well as for
 831      * HotSpot -XX:+ShowMessageBoxOnError in java mode, an empty
 832      * flag field is sufficient to perform the basic UI initialization.
 833      */
 834     memset(&amp;icx, 0, sizeof(INITCOMMONCONTROLSEX));
 835     icx.dwSize = sizeof(INITCOMMONCONTROLSEX);
 836     InitCommonControlsEx(&amp;icx);
 837     _isjavaw = javaw;
 838     JLI_SetTraceLauncher();
 839 }
 840 
 841 
 842 /* ============================== */
 843 /* AWT preloading */
 844 #ifdef ENABLE_AWT_PRELOAD
 845 
 846 typedef int FnPreloadStart(void);
 847 typedef void FnPreloadStop(void);
 848 static FnPreloadStop *fnPreloadStop = NULL;
 849 static HMODULE hPreloadAwt = NULL;
 850 
 851 /*
 852  * Starts AWT preloading
 853  */
 854 int AWTPreload(const char *funcName)
 855 {
 856     int result = -1;
 857     /* load AWT library once (if several preload function should be called) */
 858     if (hPreloadAwt == NULL) {
 859         /* awt.dll is not loaded yet */
 860         char libraryPath[MAXPATHLEN];
 861         size_t jrePathLen = 0;
 862         HMODULE hJava = NULL;
 863         HMODULE hVerify = NULL;
 864 
 865         while (1) {
 866             /* awt.dll depends on jvm.dll &amp; java.dll;
 867              * jvm.dll is already loaded, so we need only java.dll;
 868              * java.dll depends on MSVCRT lib &amp; verify.dll.
 869              */
 870             if (!GetJREPath(libraryPath, MAXPATHLEN)) {
 871                 break;
 872             }
 873 
 874             /* save path length */
 875             jrePathLen = JLI_StrLen(libraryPath);
 876 
 877             if (jrePathLen + JLI_StrLen(&quot;\\bin\\verify.dll&quot;) &gt;= MAXPATHLEN) {
 878               /* jre path is too long, the library path will not fit there;
 879                * report and abort preloading
 880                */
 881               JLI_ReportErrorMessage(JRE_ERROR11);
 882               break;
 883             }
 884 
 885             /* load msvcrt 1st */
 886             LoadMSVCRT();
 887 
 888             /* load verify.dll */
 889             JLI_StrCat(libraryPath, &quot;\\bin\\verify.dll&quot;);
 890             hVerify = LoadLibrary(libraryPath);
 891             if (hVerify == NULL) {
 892                 break;
 893             }
 894 
 895             /* restore jrePath */
 896             libraryPath[jrePathLen] = 0;
 897             /* load java.dll */
 898             JLI_StrCat(libraryPath, &quot;\\bin\\&quot; JAVA_DLL);
 899             hJava = LoadLibrary(libraryPath);
 900             if (hJava == NULL) {
 901                 break;
 902             }
 903 
 904             /* restore jrePath */
 905             libraryPath[jrePathLen] = 0;
 906             /* load awt.dll */
 907             JLI_StrCat(libraryPath, &quot;\\bin\\awt.dll&quot;);
 908             hPreloadAwt = LoadLibrary(libraryPath);
 909             if (hPreloadAwt == NULL) {
 910                 break;
 911             }
 912 
 913             /* get &quot;preloadStop&quot; func ptr */
 914             fnPreloadStop = (FnPreloadStop *)GetProcAddress(hPreloadAwt, &quot;preloadStop&quot;);
 915 
 916             break;
 917         }
 918     }
 919 
 920     if (hPreloadAwt != NULL) {
 921         FnPreloadStart *fnInit = (FnPreloadStart *)GetProcAddress(hPreloadAwt, funcName);
 922         if (fnInit != NULL) {
 923             /* don&#39;t forget to stop preloading */
 924             awtPreloaded = 1;
 925 
 926             result = fnInit();
 927         }
 928     }
 929 
 930     return result;
 931 }
 932 
 933 /*
 934  * Terminates AWT preloading
 935  */
 936 void AWTPreloadStop() {
 937     if (fnPreloadStop != NULL) {
 938         fnPreloadStop();
 939     }
 940 }
 941 
 942 #endif /* ENABLE_AWT_PRELOAD */
 943 
 944 int
 945 JVMInit(InvocationFunctions* ifn, jlong threadStackSize,
 946         int argc, char **argv,
 947         int mode, char *what, int ret)
 948 {
 949     ShowSplashScreen();
 950     return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);
 951 }
 952 
 953 void
 954 PostJVMInit(JNIEnv *env, jclass mainClass, JavaVM *vm)
 955 {
 956     // stubbed out for windows and *nixes.
 957 }
 958 
 959 void
 960 RegisterThread()
 961 {
 962     // stubbed out for windows and *nixes.
 963 }
 964 
 965 /*
 966  * on windows, we return a false to indicate this option is not applicable
 967  */
 968 jboolean
 969 ProcessPlatformOption(const char *arg)
 970 {
 971     return JNI_FALSE;
 972 }
 973 
 974 /*
 975  * At this point we have the arguments to the application, and we need to
 976  * check with original stdargs in order to compare which of these truly
 977  * needs expansion. cmdtoargs will specify this if it finds a bare
 978  * (unquoted) argument containing a glob character(s) ie. * or ?
 979  */
 980 jobjectArray
 981 CreateApplicationArgs(JNIEnv *env, char **strv, int argc)
 982 {
 983     int i, j, idx;
 984     size_t tlen;
 985     jobjectArray outArray, inArray;
 986     char *arg, **nargv;
 987     jboolean needs_expansion = JNI_FALSE;
 988     jmethodID mid;
 989     int stdargc;
 990     StdArg *stdargs;
 991     int *appArgIdx;
 992     int isTool;
 993     jclass cls = GetLauncherHelperClass(env);
 994     NULL_CHECK0(cls);
 995 
 996     if (argc == 0) {
 997         return NewPlatformStringArray(env, strv, argc);
 998     }
 999     // the holy grail we need to compare with.
1000     stdargs = JLI_GetStdArgs();
1001     stdargc = JLI_GetStdArgc();
1002 
1003     // sanity check, this should never happen
1004     if (argc &gt; stdargc) {
1005         JLI_TraceLauncher(&quot;Warning: app args is larger than the original, %d %d\n&quot;, argc, stdargc);
1006         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1007         return NewPlatformStringArray(env, strv, argc);
1008     }
1009 
1010     // sanity check, match the args we have, to the holy grail
1011     idx = JLI_GetAppArgIndex();
<a name="11" id="anc11"></a><span class="line-added">1012 </span>
<span class="line-added">1013     // First arg index is NOT_FOUND</span>
<span class="line-added">1014     if (idx &lt; 0) {</span>
<span class="line-added">1015         // The only allowed value should be NOT_FOUND (-1) unless another change introduces</span>
<span class="line-added">1016         // a different negative index</span>
<span class="line-added">1017         assert (idx == -1);</span>
<span class="line-added">1018         JLI_TraceLauncher(&quot;Warning: first app arg index not found, %d\n&quot;, idx);</span>
<span class="line-added">1019         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);</span>
<span class="line-added">1020         return NewPlatformStringArray(env, strv, argc);</span>
<span class="line-added">1021     }</span>
<span class="line-added">1022 </span>
1023     isTool = (idx == 0);
1024     if (isTool) { idx++; } // skip tool name
1025     JLI_TraceLauncher(&quot;AppArgIndex: %d points to %s\n&quot;, idx, stdargs[idx].arg);
1026 
1027     appArgIdx = calloc(argc, sizeof(int));
1028     for (i = idx, j = 0; i &lt; stdargc; i++) {
1029         if (isTool) { // filter -J used by tools to pass JVM options
1030             arg = stdargs[i].arg;
1031             if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1032                 continue;
1033             }
1034         }
1035         appArgIdx[j++] = i;
1036     }
1037     // sanity check, ensure same number of arguments for application
1038     if (j != argc) {
1039         JLI_TraceLauncher(&quot;Warning: app args count doesn&#39;t match, %d %d\n&quot;, j, argc);
1040         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1041         JLI_MemFree(appArgIdx);
1042         return NewPlatformStringArray(env, strv, argc);
1043     }
1044 
1045     // make a copy of the args which will be expanded in java if required.
1046     nargv = (char **)JLI_MemAlloc(argc * sizeof(char*));
1047     for (i = 0; i &lt; argc; i++) {
1048         jboolean arg_expand;
1049         j = appArgIdx[i];
1050         arg_expand = (JLI_StrCmp(stdargs[j].arg, strv[i]) == 0)
1051             ? stdargs[j].has_wildcard
1052             : JNI_FALSE;
1053         if (needs_expansion == JNI_FALSE)
1054             needs_expansion = arg_expand;
1055 
1056         // indicator char + String + NULL terminator, the java method will strip
1057         // out the first character, the indicator character, so no matter what
1058         // we add the indicator
1059         tlen = 1 + JLI_StrLen(strv[i]) + 1;
1060         nargv[i] = (char *) JLI_MemAlloc(tlen);
1061         if (JLI_Snprintf(nargv[i], tlen, &quot;%c%s&quot;, arg_expand ? &#39;T&#39; : &#39;F&#39;,
1062                          strv[i]) &lt; 0) {
1063             return NULL;
1064         }
1065         JLI_TraceLauncher(&quot;%s\n&quot;, nargv[i]);
1066     }
1067 
1068     if (!needs_expansion) {
1069         // clean up any allocated memory and return back the old arguments
1070         for (i = 0 ; i &lt; argc ; i++) {
1071             JLI_MemFree(nargv[i]);
1072         }
1073         JLI_MemFree(nargv);
1074         JLI_MemFree(appArgIdx);
1075         return NewPlatformStringArray(env, strv, argc);
1076     }
1077     NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
1078                                                 &quot;expandArgs&quot;,
1079                                                 &quot;([Ljava/lang/String;)[Ljava/lang/String;&quot;));
1080 
1081     // expand the arguments that require expansion, the java method will strip
1082     // out the indicator character.
1083     NULL_CHECK0(inArray = NewPlatformStringArray(env, nargv, argc));
1084     outArray = (*env)-&gt;CallStaticObjectMethod(env, cls, mid, inArray);
1085     for (i = 0; i &lt; argc; i++) {
1086         JLI_MemFree(nargv[i]);
1087     }
1088     JLI_MemFree(nargv);
1089     JLI_MemFree(appArgIdx);
1090     return outArray;
1091 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
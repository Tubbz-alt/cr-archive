<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libjli/java_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../libjava/jdk_util_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../libnet/Inet4AddressImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libjli/java_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;windows.h&gt;
  27 #include &lt;io.h&gt;
  28 #include &lt;process.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stdio.h&gt;
  31 #include &lt;stdarg.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;sys/types.h&gt;
  34 #include &lt;sys/stat.h&gt;
  35 #include &lt;wtypes.h&gt;
  36 #include &lt;commctrl.h&gt;

  37 
  38 #include &lt;jni.h&gt;
  39 #include &quot;java.h&quot;
  40 
  41 #define JVM_DLL &quot;jvm.dll&quot;
  42 #define JAVA_DLL &quot;java.dll&quot;
  43 
<span class="line-removed">  44 #define ELP_PREFIX L&quot;\\\\?\\&quot;</span>
<span class="line-removed">  45 </span>
  46 /*
  47  * Prototypes.
  48  */
  49 static jboolean GetJVMPath(const char *jrepath, const char *jvmtype,
  50                            char *jvmpath, jint jvmpathsize);
  51 static jboolean GetJREPath(char *path, jint pathsize);
  52 
  53 #ifdef USE_REGISTRY_LOOKUP
  54 jboolean GetPublicJREHome(char *buf, jint bufsize);
  55 #endif
  56 
  57 /* We supports warmup for UI stack that is performed in parallel
  58  * to VM initialization.
  59  * This helps to improve startup of UI application as warmup phase
  60  * might be long due to initialization of OS or hardware resources.
  61  * It is not CPU bound and therefore it does not interfere with VM init.
  62  * Obviously such warmup only has sense for UI apps and therefore it needs
  63  * to be explicitly requested by passing -Dsun.awt.warmup=true property
  64  * (this is always the case for plugin/javaws).
  65  *
</pre>
<hr />
<pre>
 480     int rc;
 481     va_list vl;
 482     if (size == 0 || buffer == NULL)
 483         return -1;
 484     buffer[0] = &#39;\0&#39;;
 485     va_start(vl, format);
 486     rc = vsnprintf(buffer, size, format, vl);
 487     va_end(vl);
 488     /* force a null terminator, if something is amiss */
 489     if (rc &lt; 0) {
 490         /* apply ansi semantics */
 491         buffer[size - 1] = &#39;\0&#39;;
 492         return (int)size;
 493     } else if (rc == size) {
 494         /* force a null terminator */
 495         buffer[size - 1] = &#39;\0&#39;;
 496     }
 497     return rc;
 498 }
 499 
<span class="line-modified"> 500 /* On Windows, if _open fails, retry again with CreateFileW and</span>
<span class="line-modified"> 501  *  &quot;\\?\&quot; prefix ( extended-length paths) - this allows to open paths with larger file names;</span>
<span class="line-modified"> 502  * otherwise we run into the MAX_PATH limitation */</span>
<span class="line-modified"> 503 int JLI_Open(const char* name, int flags) {</span>
<span class="line-modified"> 504     int fd = _open(name, flags);</span>
<span class="line-modified"> 505     if (fd == -1 &amp;&amp; errno == ENOENT) {</span>
<span class="line-modified"> 506         wchar_t* wname = NULL;</span>
<span class="line-modified"> 507         wchar_t* wfullname = NULL;</span>
<span class="line-modified"> 508         wchar_t* wfullname_w_prefix = NULL;</span>
<span class="line-modified"> 509         size_t wnamelen, wfullnamelen, elplen;</span>
<span class="line-modified"> 510         HANDLE h;</span>
<span class="line-modified"> 511 </span>
<span class="line-modified"> 512         wnamelen = strlen(name) + 1;</span>
<span class="line-modified"> 513         wname = (wchar_t*) malloc(wnamelen*sizeof(wchar_t));</span>
<span class="line-modified"> 514         if (wname == NULL) {</span>
<span class="line-modified"> 515             goto end;</span>
<span class="line-modified"> 516         }</span>
<span class="line-modified"> 517         if (mbstowcs(wname, name, wnamelen - 1) == -1) {</span>
<span class="line-modified"> 518             goto end;</span>








 519         }
<span class="line-modified"> 520         wname[wnamelen - 1] = L&#39;\0&#39;;</span>
<span class="line-modified"> 521         wfullname = _wfullpath(wfullname, wname, 0);</span>
<span class="line-modified"> 522         if (wfullname == NULL) {</span>
<span class="line-modified"> 523             goto end;</span>



 524         }



 525 
<span class="line-modified"> 526         wfullnamelen = wcslen(wfullname);</span>
<span class="line-modified"> 527         if (wfullnamelen &gt; 247) {</span>
<span class="line-modified"> 528             elplen = wcslen(ELP_PREFIX);</span>
<span class="line-modified"> 529             wfullname_w_prefix = (wchar_t*) malloc((elplen+wfullnamelen+1)*sizeof(wchar_t));</span>
<span class="line-modified"> 530             wcscpy(wfullname_w_prefix, ELP_PREFIX);</span>
<span class="line-modified"> 531             wcscpy(wfullname_w_prefix+elplen, wfullname);</span>
<span class="line-modified"> 532 </span>
<span class="line-modified"> 533             h = CreateFileW(wfullname_w_prefix, GENERIC_READ, FILE_SHARE_READ, NULL,</span>
<span class="line-modified"> 534                             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</span>
<span class="line-modified"> 535             if (h == INVALID_HANDLE_VALUE) {</span>
<span class="line-modified"> 536                 goto end;</span>
<span class="line-removed"> 537             }</span>
<span class="line-removed"> 538             /* associates fd with handle */</span>
<span class="line-removed"> 539             fd = _open_osfhandle((intptr_t)h, _O_RDONLY);</span>
 540         }
<span class="line-modified"> 541 end:</span>
<span class="line-modified"> 542         free(wname);</span>
<span class="line-modified"> 543         free(wfullname);</span>
<span class="line-modified"> 544         free(wfullname_w_prefix);</span>

 545     }
 546     return fd;
 547 }
 548 
<span class="line-removed"> 549 </span>
<span class="line-removed"> 550 </span>
 551 JNIEXPORT void JNICALL
 552 JLI_ReportErrorMessage(const char* fmt, ...) {
 553     va_list vl;
 554     va_start(vl,fmt);
 555 
 556     if (IsJavaw()) {
 557         char *message;
 558 
 559         /* get the length of the string we need */
 560         int n = _vscprintf(fmt, vl);
 561 
 562         message = (char *)JLI_MemAlloc(n + 1);
 563         _vsnprintf(message, n, fmt, vl);
 564         message[n]=&#39;\0&#39;;
 565         MessageBox(NULL, message, &quot;Java Virtual Machine Launcher&quot;,
 566             (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 567         JLI_MemFree(message);
 568     } else {
 569         vfprintf(stderr, fmt, vl);
 570         fprintf(stderr, &quot;\n&quot;);
</pre>
<hr />
<pre>
 679     char libraryPath[MAXPATHLEN]; /* some extra space for JLI_StrCat&#39;ing SPLASHSCREEN_SO */
 680 
 681     if (!GetJREPath(libraryPath, MAXPATHLEN)) {
 682         return NULL;
 683     }
 684     if (JLI_StrLen(libraryPath)+JLI_StrLen(SPLASHSCREEN_SO) &gt;= MAXPATHLEN) {
 685         return NULL;
 686     }
 687     JLI_StrCat(libraryPath, SPLASHSCREEN_SO);
 688 
 689     if (!hSplashLib) {
 690         hSplashLib = LoadLibrary(libraryPath);
 691     }
 692     if (hSplashLib) {
 693         return GetProcAddress(hSplashLib, name);
 694     } else {
 695         return NULL;
 696     }
 697 }
 698 
<span class="line-removed"> 699 void SplashFreeLibrary() {</span>
<span class="line-removed"> 700     if (hSplashLib) {</span>
<span class="line-removed"> 701         FreeLibrary(hSplashLib);</span>
<span class="line-removed"> 702         hSplashLib = NULL;</span>
<span class="line-removed"> 703     }</span>
<span class="line-removed"> 704 }</span>
<span class="line-removed"> 705 </span>
 706 /*
 707  * Signature adapter for _beginthreadex().
 708  */
 709 static unsigned __stdcall ThreadJavaMain(void* args) {
 710     return (unsigned)JavaMain(args);
 711 }
 712 
 713 /*
 714  * Block current thread and continue execution in a new thread.
 715  */
 716 int
 717 CallJavaMainInNewThread(jlong stack_size, void* args) {
 718     int rslt = 0;
 719     unsigned thread_id;
 720 
 721 #ifndef STACK_SIZE_PARAM_IS_A_RESERVATION
 722 #define STACK_SIZE_PARAM_IS_A_RESERVATION  (0x10000)
 723 #endif
 724 
 725     /*
</pre>
<hr />
<pre>
 778     }
 779 #endif /* ENABLE_AWT_PRELOAD */
 780 
 781     if (thread_handle) {
 782         WaitForSingleObject(thread_handle, INFINITE);
 783         GetExitCodeThread(thread_handle, &amp;rslt);
 784         CloseHandle(thread_handle);
 785     } else {
 786         rslt = JavaMain(args);
 787     }
 788 
 789 #ifdef ENABLE_AWT_PRELOAD
 790     if (awtPreloaded) {
 791         AWTPreloadStop();
 792     }
 793 #endif /* ENABLE_AWT_PRELOAD */
 794 
 795     return rslt;
 796 }
 797 
<span class="line-removed"> 798 /* Unix only, empty on windows. */</span>
<span class="line-removed"> 799 void SetJavaLauncherPlatformProps() {}</span>
<span class="line-removed"> 800 </span>
 801 /*
 802  * The implementation for finding classes from the bootstrap
 803  * class loader, refer to java.h
 804  */
 805 static FindClassFromBootLoader_t *findBootClass = NULL;
 806 
 807 jclass FindBootStrapClass(JNIEnv *env, const char *classname)
 808 {
 809    HMODULE hJvm;
 810 
 811    if (findBootClass == NULL) {
 812        hJvm = GetModuleHandle(JVM_DLL);
 813        if (hJvm == NULL) return NULL;
 814        /* need to use the demangled entry point */
 815        findBootClass = (FindClassFromBootLoader_t *)GetProcAddress(hJvm,
 816             &quot;JVM_FindClassFromBootLoader&quot;);
 817        if (findBootClass == NULL) {
 818           JLI_ReportErrorMessage(DLL_ERROR4, &quot;JVM_FindClassFromBootLoader&quot;);
 819           return NULL;
 820        }
</pre>
<hr />
<pre>
 993     int isTool;
 994     jclass cls = GetLauncherHelperClass(env);
 995     NULL_CHECK0(cls);
 996 
 997     if (argc == 0) {
 998         return NewPlatformStringArray(env, strv, argc);
 999     }
1000     // the holy grail we need to compare with.
1001     stdargs = JLI_GetStdArgs();
1002     stdargc = JLI_GetStdArgc();
1003 
1004     // sanity check, this should never happen
1005     if (argc &gt; stdargc) {
1006         JLI_TraceLauncher(&quot;Warning: app args is larger than the original, %d %d\n&quot;, argc, stdargc);
1007         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1008         return NewPlatformStringArray(env, strv, argc);
1009     }
1010 
1011     // sanity check, match the args we have, to the holy grail
1012     idx = JLI_GetAppArgIndex();











1013     isTool = (idx == 0);
1014     if (isTool) { idx++; } // skip tool name
1015     JLI_TraceLauncher(&quot;AppArgIndex: %d points to %s\n&quot;, idx, stdargs[idx].arg);
1016 
1017     appArgIdx = calloc(argc, sizeof(int));
1018     for (i = idx, j = 0; i &lt; stdargc; i++) {
1019         if (isTool) { // filter -J used by tools to pass JVM options
1020             arg = stdargs[i].arg;
1021             if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1022                 continue;
1023             }
1024         }
1025         appArgIdx[j++] = i;
1026     }
1027     // sanity check, ensure same number of arguments for application
1028     if (j != argc) {
1029         JLI_TraceLauncher(&quot;Warning: app args count doesn&#39;t match, %d %d\n&quot;, j, argc);
1030         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1031         JLI_MemFree(appArgIdx);
1032         return NewPlatformStringArray(env, strv, argc);
</pre>
</td>
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;windows.h&gt;
  27 #include &lt;io.h&gt;
  28 #include &lt;process.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stdio.h&gt;
  31 #include &lt;stdarg.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;sys/types.h&gt;
  34 #include &lt;sys/stat.h&gt;
  35 #include &lt;wtypes.h&gt;
  36 #include &lt;commctrl.h&gt;
<span class="line-added">  37 #include &lt;assert.h&gt;</span>
  38 
  39 #include &lt;jni.h&gt;
  40 #include &quot;java.h&quot;
  41 
  42 #define JVM_DLL &quot;jvm.dll&quot;
  43 #define JAVA_DLL &quot;java.dll&quot;
  44 


  45 /*
  46  * Prototypes.
  47  */
  48 static jboolean GetJVMPath(const char *jrepath, const char *jvmtype,
  49                            char *jvmpath, jint jvmpathsize);
  50 static jboolean GetJREPath(char *path, jint pathsize);
  51 
  52 #ifdef USE_REGISTRY_LOOKUP
  53 jboolean GetPublicJREHome(char *buf, jint bufsize);
  54 #endif
  55 
  56 /* We supports warmup for UI stack that is performed in parallel
  57  * to VM initialization.
  58  * This helps to improve startup of UI application as warmup phase
  59  * might be long due to initialization of OS or hardware resources.
  60  * It is not CPU bound and therefore it does not interfere with VM init.
  61  * Obviously such warmup only has sense for UI apps and therefore it needs
  62  * to be explicitly requested by passing -Dsun.awt.warmup=true property
  63  * (this is always the case for plugin/javaws).
  64  *
</pre>
<hr />
<pre>
 479     int rc;
 480     va_list vl;
 481     if (size == 0 || buffer == NULL)
 482         return -1;
 483     buffer[0] = &#39;\0&#39;;
 484     va_start(vl, format);
 485     rc = vsnprintf(buffer, size, format, vl);
 486     va_end(vl);
 487     /* force a null terminator, if something is amiss */
 488     if (rc &lt; 0) {
 489         /* apply ansi semantics */
 490         buffer[size - 1] = &#39;\0&#39;;
 491         return (int)size;
 492     } else if (rc == size) {
 493         /* force a null terminator */
 494         buffer[size - 1] = &#39;\0&#39;;
 495     }
 496     return rc;
 497 }
 498 
<span class="line-modified"> 499 /* taken from hotspot and slightly adjusted for jli lib;</span>
<span class="line-modified"> 500  * creates a UNC/ELP path from input &#39;path&#39;</span>
<span class="line-modified"> 501  * the return buffer is allocated in C heap and needs to be freed using</span>
<span class="line-modified"> 502  * JLI_MemFree by the caller.</span>
<span class="line-modified"> 503  */</span>
<span class="line-modified"> 504 static wchar_t* create_unc_path(const char* path, errno_t* err) {</span>
<span class="line-modified"> 505     wchar_t* wpath = NULL;</span>
<span class="line-modified"> 506     size_t converted_chars = 0;</span>
<span class="line-modified"> 507     size_t path_len = strlen(path) + 1; /* includes the terminating NULL */</span>
<span class="line-modified"> 508     if (path[0] == &#39;\\&#39; &amp;&amp; path[1] == &#39;\\&#39;) {</span>
<span class="line-modified"> 509         if (path[2] == &#39;?&#39; &amp;&amp; path[3] == &#39;\\&#39;) {</span>
<span class="line-modified"> 510             /* if it already has a \\?\ don&#39;t do the prefix */</span>
<span class="line-modified"> 511             wpath = (wchar_t*) JLI_MemAlloc(path_len * sizeof(wchar_t));</span>
<span class="line-modified"> 512             if (wpath != NULL) {</span>
<span class="line-modified"> 513                 *err = mbstowcs_s(&amp;converted_chars, wpath, path_len, path, path_len);</span>
<span class="line-modified"> 514             } else {</span>
<span class="line-modified"> 515                 *err = ENOMEM;</span>
<span class="line-modified"> 516             }</span>
<span class="line-modified"> 517         } else {</span>
<span class="line-added"> 518             /* only UNC pathname includes double slashes here */</span>
<span class="line-added"> 519             wpath = (wchar_t*) JLI_MemAlloc((path_len + 7) * sizeof(wchar_t));</span>
<span class="line-added"> 520             if (wpath != NULL) {</span>
<span class="line-added"> 521                 wcscpy(wpath, L&quot;\\\\?\\UNC\0&quot;);</span>
<span class="line-added"> 522                 *err = mbstowcs_s(&amp;converted_chars, &amp;wpath[7], path_len, path, path_len);</span>
<span class="line-added"> 523             } else {</span>
<span class="line-added"> 524                 *err = ENOMEM;</span>
<span class="line-added"> 525             }</span>
 526         }
<span class="line-modified"> 527     } else {</span>
<span class="line-modified"> 528         wpath = (wchar_t*) JLI_MemAlloc((path_len + 4) * sizeof(wchar_t));</span>
<span class="line-modified"> 529         if (wpath != NULL) {</span>
<span class="line-modified"> 530             wcscpy(wpath, L&quot;\\\\?\\\0&quot;);</span>
<span class="line-added"> 531             *err = mbstowcs_s(&amp;converted_chars, &amp;wpath[4], path_len, path, path_len);</span>
<span class="line-added"> 532         } else {</span>
<span class="line-added"> 533             *err = ENOMEM;</span>
 534         }
<span class="line-added"> 535     }</span>
<span class="line-added"> 536     return wpath;</span>
<span class="line-added"> 537 }</span>
 538 
<span class="line-modified"> 539 int JLI_Open(const char* name, int flags) {</span>
<span class="line-modified"> 540     int fd;</span>
<span class="line-modified"> 541     if (strlen(name) &lt; MAX_PATH) {</span>
<span class="line-modified"> 542         fd = _open(name, flags);</span>
<span class="line-modified"> 543     } else {</span>
<span class="line-modified"> 544         errno_t err = ERROR_SUCCESS;</span>
<span class="line-modified"> 545         wchar_t* wpath = create_unc_path(name, &amp;err);</span>
<span class="line-modified"> 546         if (err != ERROR_SUCCESS) {</span>
<span class="line-modified"> 547             if (wpath != NULL) JLI_MemFree(wpath);</span>
<span class="line-modified"> 548             errno = err;</span>
<span class="line-modified"> 549             return -1;</span>



 550         }
<span class="line-modified"> 551         fd = _wopen(wpath, flags);</span>
<span class="line-modified"> 552         if (fd == -1) {</span>
<span class="line-modified"> 553             errno = GetLastError();</span>
<span class="line-modified"> 554         }</span>
<span class="line-added"> 555         JLI_MemFree(wpath);</span>
 556     }
 557     return fd;
 558 }
 559 


 560 JNIEXPORT void JNICALL
 561 JLI_ReportErrorMessage(const char* fmt, ...) {
 562     va_list vl;
 563     va_start(vl,fmt);
 564 
 565     if (IsJavaw()) {
 566         char *message;
 567 
 568         /* get the length of the string we need */
 569         int n = _vscprintf(fmt, vl);
 570 
 571         message = (char *)JLI_MemAlloc(n + 1);
 572         _vsnprintf(message, n, fmt, vl);
 573         message[n]=&#39;\0&#39;;
 574         MessageBox(NULL, message, &quot;Java Virtual Machine Launcher&quot;,
 575             (MB_OK|MB_ICONSTOP|MB_APPLMODAL));
 576         JLI_MemFree(message);
 577     } else {
 578         vfprintf(stderr, fmt, vl);
 579         fprintf(stderr, &quot;\n&quot;);
</pre>
<hr />
<pre>
 688     char libraryPath[MAXPATHLEN]; /* some extra space for JLI_StrCat&#39;ing SPLASHSCREEN_SO */
 689 
 690     if (!GetJREPath(libraryPath, MAXPATHLEN)) {
 691         return NULL;
 692     }
 693     if (JLI_StrLen(libraryPath)+JLI_StrLen(SPLASHSCREEN_SO) &gt;= MAXPATHLEN) {
 694         return NULL;
 695     }
 696     JLI_StrCat(libraryPath, SPLASHSCREEN_SO);
 697 
 698     if (!hSplashLib) {
 699         hSplashLib = LoadLibrary(libraryPath);
 700     }
 701     if (hSplashLib) {
 702         return GetProcAddress(hSplashLib, name);
 703     } else {
 704         return NULL;
 705     }
 706 }
 707 







 708 /*
 709  * Signature adapter for _beginthreadex().
 710  */
 711 static unsigned __stdcall ThreadJavaMain(void* args) {
 712     return (unsigned)JavaMain(args);
 713 }
 714 
 715 /*
 716  * Block current thread and continue execution in a new thread.
 717  */
 718 int
 719 CallJavaMainInNewThread(jlong stack_size, void* args) {
 720     int rslt = 0;
 721     unsigned thread_id;
 722 
 723 #ifndef STACK_SIZE_PARAM_IS_A_RESERVATION
 724 #define STACK_SIZE_PARAM_IS_A_RESERVATION  (0x10000)
 725 #endif
 726 
 727     /*
</pre>
<hr />
<pre>
 780     }
 781 #endif /* ENABLE_AWT_PRELOAD */
 782 
 783     if (thread_handle) {
 784         WaitForSingleObject(thread_handle, INFINITE);
 785         GetExitCodeThread(thread_handle, &amp;rslt);
 786         CloseHandle(thread_handle);
 787     } else {
 788         rslt = JavaMain(args);
 789     }
 790 
 791 #ifdef ENABLE_AWT_PRELOAD
 792     if (awtPreloaded) {
 793         AWTPreloadStop();
 794     }
 795 #endif /* ENABLE_AWT_PRELOAD */
 796 
 797     return rslt;
 798 }
 799 



 800 /*
 801  * The implementation for finding classes from the bootstrap
 802  * class loader, refer to java.h
 803  */
 804 static FindClassFromBootLoader_t *findBootClass = NULL;
 805 
 806 jclass FindBootStrapClass(JNIEnv *env, const char *classname)
 807 {
 808    HMODULE hJvm;
 809 
 810    if (findBootClass == NULL) {
 811        hJvm = GetModuleHandle(JVM_DLL);
 812        if (hJvm == NULL) return NULL;
 813        /* need to use the demangled entry point */
 814        findBootClass = (FindClassFromBootLoader_t *)GetProcAddress(hJvm,
 815             &quot;JVM_FindClassFromBootLoader&quot;);
 816        if (findBootClass == NULL) {
 817           JLI_ReportErrorMessage(DLL_ERROR4, &quot;JVM_FindClassFromBootLoader&quot;);
 818           return NULL;
 819        }
</pre>
<hr />
<pre>
 992     int isTool;
 993     jclass cls = GetLauncherHelperClass(env);
 994     NULL_CHECK0(cls);
 995 
 996     if (argc == 0) {
 997         return NewPlatformStringArray(env, strv, argc);
 998     }
 999     // the holy grail we need to compare with.
1000     stdargs = JLI_GetStdArgs();
1001     stdargc = JLI_GetStdArgc();
1002 
1003     // sanity check, this should never happen
1004     if (argc &gt; stdargc) {
1005         JLI_TraceLauncher(&quot;Warning: app args is larger than the original, %d %d\n&quot;, argc, stdargc);
1006         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1007         return NewPlatformStringArray(env, strv, argc);
1008     }
1009 
1010     // sanity check, match the args we have, to the holy grail
1011     idx = JLI_GetAppArgIndex();
<span class="line-added">1012 </span>
<span class="line-added">1013     // First arg index is NOT_FOUND</span>
<span class="line-added">1014     if (idx &lt; 0) {</span>
<span class="line-added">1015         // The only allowed value should be NOT_FOUND (-1) unless another change introduces</span>
<span class="line-added">1016         // a different negative index</span>
<span class="line-added">1017         assert (idx == -1);</span>
<span class="line-added">1018         JLI_TraceLauncher(&quot;Warning: first app arg index not found, %d\n&quot;, idx);</span>
<span class="line-added">1019         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);</span>
<span class="line-added">1020         return NewPlatformStringArray(env, strv, argc);</span>
<span class="line-added">1021     }</span>
<span class="line-added">1022 </span>
1023     isTool = (idx == 0);
1024     if (isTool) { idx++; } // skip tool name
1025     JLI_TraceLauncher(&quot;AppArgIndex: %d points to %s\n&quot;, idx, stdargs[idx].arg);
1026 
1027     appArgIdx = calloc(argc, sizeof(int));
1028     for (i = idx, j = 0; i &lt; stdargc; i++) {
1029         if (isTool) { // filter -J used by tools to pass JVM options
1030             arg = stdargs[i].arg;
1031             if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1032                 continue;
1033             }
1034         }
1035         appArgIdx[j++] = i;
1036     }
1037     // sanity check, ensure same number of arguments for application
1038     if (j != argc) {
1039         JLI_TraceLauncher(&quot;Warning: app args count doesn&#39;t match, %d %d\n&quot;, j, argc);
1040         JLI_TraceLauncher(&quot;passing arguments as-is.\n&quot;);
1041         JLI_MemFree(appArgIdx);
1042         return NewPlatformStringArray(env, strv, argc);
</pre>
</td>
</tr>
</table>
<center><a href="../libjava/jdk_util_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../libnet/Inet4AddressImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
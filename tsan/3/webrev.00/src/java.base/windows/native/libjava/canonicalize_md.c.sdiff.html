<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libjava/canonicalize_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="HostLocaleProviderAdapter_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="io_util_md.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libjava/canonicalize_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Pathname canonicalization for Win32 file systems
 28  */
 29 
 30 #include &lt;stdio.h&gt;
 31 #include &lt;stdlib.h&gt;
 32 #include &lt;string.h&gt;
 33 #include &lt;ctype.h&gt;
 34 #include &lt;assert.h&gt;
 35 #include &lt;sys/stat.h&gt;
 36 
 37 #include &lt;windows.h&gt;
 38 #include &lt;winbase.h&gt;
 39 #include &lt;errno.h&gt;
<span class="line-removed"> 40 #include &quot;io_util_md.h&quot;</span>
<span class="line-removed"> 41 </span>
<span class="line-removed"> 42 #undef DEBUG_PATH        /* Define this to debug path code */</span>
<span class="line-removed"> 43 </span>
<span class="line-removed"> 44 #define isfilesep(c) ((c) == &#39;/&#39; || (c) == &#39;\\&#39;)</span>
<span class="line-removed"> 45 #define wisfilesep(c) ((c) == L&#39;/&#39; || (c) == L&#39;\\&#39;)</span>
<span class="line-removed"> 46 #define islb(c)      (IsDBCSLeadByte((BYTE)(c)))</span>
 47 





 48 
 49 /* Copy bytes to dst, not going past dend; return dst + number of bytes copied,
 50    or NULL if dend would have been exceeded.  If first != &#39;\0&#39;, copy that byte
 51    before copying bytes from src to send - 1. */
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53 static char *</span>
<span class="line-removed"> 54 cp(char *dst, char *dend, char first, char *src, char *send)</span>
<span class="line-removed"> 55 {</span>
<span class="line-removed"> 56     char *p = src, *q = dst;</span>
<span class="line-removed"> 57     if (first != &#39;\0&#39;) {</span>
<span class="line-removed"> 58         if (q &lt; dend) {</span>
<span class="line-removed"> 59             *q++ = first;</span>
<span class="line-removed"> 60         } else {</span>
<span class="line-removed"> 61             errno = ENAMETOOLONG;</span>
<span class="line-removed"> 62             return NULL;</span>
<span class="line-removed"> 63         }</span>
<span class="line-removed"> 64     }</span>
<span class="line-removed"> 65     if (send - p &gt; dend - q) {</span>
<span class="line-removed"> 66         errno = ENAMETOOLONG;</span>
<span class="line-removed"> 67         return NULL;</span>
<span class="line-removed"> 68     }</span>
<span class="line-removed"> 69     while (p &lt; send) {</span>
<span class="line-removed"> 70         *q++ = *p++;</span>
<span class="line-removed"> 71     }</span>
<span class="line-removed"> 72     return q;</span>
<span class="line-removed"> 73 }</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75 /* Wide character version of cp */</span>
<span class="line-removed"> 76 </span>
 77 static WCHAR*
 78 wcp(WCHAR *dst, WCHAR *dend, WCHAR first, WCHAR *src, WCHAR *send)
 79 {
 80     WCHAR *p = src, *q = dst;
 81     if (first != L&#39;\0&#39;) {
 82         if (q &lt; dend) {
 83             *q++ = first;
 84         } else {
 85             errno = ENAMETOOLONG;
 86             return NULL;
 87         }
 88     }
 89     if (send - p &gt; dend - q) {
 90         errno = ENAMETOOLONG;
 91         return NULL;
 92     }
 93     while (p &lt; send)
 94         *q++ = *p++;
 95     return q;
 96 }
 97 
<span class="line-removed"> 98 </span>
 99 /* Find first instance of &#39;\\&#39; at or following start.  Return the address of
100    that byte or the address of the null terminator if &#39;\\&#39; is not found. */
<span class="line-removed">101 </span>
<span class="line-removed">102 static char *</span>
<span class="line-removed">103 nextsep(char *start)</span>
<span class="line-removed">104 {</span>
<span class="line-removed">105     char *p = start;</span>
<span class="line-removed">106     int c;</span>
<span class="line-removed">107     while ((c = *p) &amp;&amp; (c != &#39;\\&#39;)) {</span>
<span class="line-removed">108         p += ((islb(c) &amp;&amp; p[1]) ? 2 : 1);</span>
<span class="line-removed">109     }</span>
<span class="line-removed">110     return p;</span>
<span class="line-removed">111 }</span>
<span class="line-removed">112 </span>
<span class="line-removed">113 /* Wide character version of nextsep */</span>
<span class="line-removed">114 </span>
115 static WCHAR *
116 wnextsep(WCHAR *start)
117 {
118     WCHAR *p = start;
119     int c;
120     while ((c = *p) &amp;&amp; (c != L&#39;\\&#39;))
121         p++;
122     return p;
123 }
124 
125 /* Tell whether the given string contains any wildcard characters */
<span class="line-removed">126 </span>
<span class="line-removed">127 static int</span>
<span class="line-removed">128 wild(char *start)</span>
<span class="line-removed">129 {</span>
<span class="line-removed">130     char *p = start;</span>
<span class="line-removed">131     int c;</span>
<span class="line-removed">132     while (c = *p) {</span>
<span class="line-removed">133         if ((c == &#39;*&#39;) || (c == &#39;?&#39;)) return 1;</span>
<span class="line-removed">134         p += ((islb(c) &amp;&amp; p[1]) ? 2 : 1);</span>
<span class="line-removed">135     }</span>
<span class="line-removed">136     return 0;</span>
<span class="line-removed">137 }</span>
<span class="line-removed">138 </span>
<span class="line-removed">139 /* Wide character version of wild */</span>
<span class="line-removed">140 </span>
141 static int
142 wwild(WCHAR *start)
143 {
144     WCHAR *p = start;
145     int c;
146     while (c = *p) {
147         if ((c == L&#39;*&#39;) || (c == L&#39;?&#39;))
148             return 1;
149         p++;
150     }
151     return 0;
152 }
153 
154 /* Tell whether the given string contains prohibited combinations of dots.
155    In the canonicalized form no path element may have dots at its end.
156    Allowed canonical paths: c:\xa...dksd\..ksa\.lk    c:\...a\.b\cd..x.x
157    Prohibited canonical paths: c:\..\x  c:\x.\d c:\...
158 */
159 static int
<span class="line-removed">160 dots(char *start)</span>
<span class="line-removed">161 {</span>
<span class="line-removed">162     char *p = start;</span>
<span class="line-removed">163     while (*p) {</span>
<span class="line-removed">164         if ((p = strchr(p, &#39;.&#39;)) == NULL) // find next occurrence of &#39;.&#39;</span>
<span class="line-removed">165             return 0; // no more dots</span>
<span class="line-removed">166         p++; // next char</span>
<span class="line-removed">167         while ((*p) == &#39;.&#39;) // go to the end of dots</span>
<span class="line-removed">168             p++;</span>
<span class="line-removed">169         if (*p &amp;&amp; (*p != &#39;\\&#39;)) // path element does not end with a dot</span>
<span class="line-removed">170             p++; // go to the next char</span>
<span class="line-removed">171         else</span>
<span class="line-removed">172             return 1; // path element does end with a dot - prohibited</span>
<span class="line-removed">173     }</span>
<span class="line-removed">174     return 0; // no prohibited combinations of dots found</span>
<span class="line-removed">175 }</span>
<span class="line-removed">176 </span>
<span class="line-removed">177 /* Wide character version of dots */</span>
<span class="line-removed">178 static int</span>
179 wdots(WCHAR *start)
180 {
181     WCHAR *p = start;
182     // Skip &quot;\\.\&quot; prefix
183     if (wcslen(p) &gt; 4 &amp;&amp; !wcsncmp(p, L&quot;\\\\.\\&quot;, 4))
184         p = p + 4;
185 
186     while (*p) {
187         if ((p = wcschr(p, L&#39;.&#39;)) == NULL) // find next occurrence of &#39;.&#39;
188             return 0; // no more dots
189         p++; // next char
190         while ((*p) == L&#39;.&#39;) // go to the end of dots
191             p++;
192         if (*p &amp;&amp; (*p != L&#39;\\&#39;)) // path element does not end with a dot
193             p++; // go to the next char
194         else
195             return 1; // path element does end with a dot - prohibited
196     }
197     return 0; // no prohibited combinations of dots found
198 }
199 
200 /* If the lookup of a particular prefix fails because the file does not exist,
201    because it is of the wrong type, because access is denied, or because the
202    network is unreachable then canonicalization does not fail, it terminates
203    successfully after copying the rest of the original path to the result path.
204    Other I/O errors cause an error return.
205 */
<span class="line-removed">206 </span>
207 int
208 lastErrorReportable()
209 {
210     DWORD errval = GetLastError();
211     if ((errval == ERROR_FILE_NOT_FOUND)
212         || (errval == ERROR_DIRECTORY)
213         || (errval == ERROR_PATH_NOT_FOUND)
214         || (errval == ERROR_BAD_NETPATH)
215         || (errval == ERROR_BAD_NET_NAME)
216         || (errval == ERROR_ACCESS_DENIED)
217         || (errval == ERROR_NETWORK_UNREACHABLE)
218         || (errval == ERROR_NETWORK_ACCESS_DENIED)) {
219         return 0;
220     }
<span class="line-removed">221 </span>
<span class="line-removed">222 #ifdef DEBUG_PATH</span>
<span class="line-removed">223     jio_fprintf(stderr, &quot;canonicalize: errval %d\n&quot;, errval);</span>
<span class="line-removed">224 #endif</span>
225     return 1;
226 }
227 
<span class="line-removed">228 int wcanonicalize(WCHAR *orig_path, WCHAR *result, int size);</span>
<span class="line-removed">229 </span>
230 /* Convert a pathname to canonical form.  The input orig_path is assumed to
231    have been converted to native form already, via JVM_NativePath().  This is
232    necessary because _fullpath() rejects duplicate separator characters on
233    Win95, though it accepts them on NT. */
<span class="line-removed">234 </span>
<span class="line-removed">235 int</span>
<span class="line-removed">236 canonicalize(char *orig_path, char *result, int size)</span>
<span class="line-removed">237 {</span>
<span class="line-removed">238     WIN32_FIND_DATA fd;</span>
<span class="line-removed">239     HANDLE h;</span>
<span class="line-removed">240     char path[1024];    /* Working copy of path */</span>
<span class="line-removed">241     char *src, *dst, *dend;</span>
<span class="line-removed">242     wchar_t *worig_path, *wresult;</span>
<span class="line-removed">243     size_t converted_chars = 0;</span>
<span class="line-removed">244 </span>
<span class="line-removed">245     /* handle long path with length &gt;= MAX_PATH */</span>
<span class="line-removed">246     if (strlen(orig_path) &gt;= MAX_PATH) {</span>
<span class="line-removed">247         if ((worig_path = (WCHAR*)malloc(size * sizeof(WCHAR))) == NULL)</span>
<span class="line-removed">248             return -1;</span>
<span class="line-removed">249 </span>
<span class="line-removed">250         if (mbstowcs_s(&amp;converted_chars, worig_path, (size_t)size, orig_path, (size_t)(size - 1)) != 0) {</span>
<span class="line-removed">251             free(worig_path);</span>
<span class="line-removed">252             return -1;</span>
<span class="line-removed">253         }</span>
<span class="line-removed">254 </span>
<span class="line-removed">255         if ((wresult = (WCHAR*)malloc(size * sizeof(WCHAR))) == NULL)</span>
<span class="line-removed">256             return -1;</span>
<span class="line-removed">257 </span>
<span class="line-removed">258         if (wcanonicalize(worig_path, wresult, size) != 0) {</span>
<span class="line-removed">259             free(worig_path);</span>
<span class="line-removed">260             free(wresult);</span>
<span class="line-removed">261             return -1;</span>
<span class="line-removed">262         }</span>
<span class="line-removed">263 </span>
<span class="line-removed">264         if (wcstombs_s(&amp;converted_chars, result, (size_t)size, wresult, (size_t)(size - 1)) != 0) {</span>
<span class="line-removed">265             free(worig_path);</span>
<span class="line-removed">266             free(wresult);</span>
<span class="line-removed">267             return -1;</span>
<span class="line-removed">268         }</span>
<span class="line-removed">269 </span>
<span class="line-removed">270         free(worig_path);</span>
<span class="line-removed">271         free(wresult);</span>
<span class="line-removed">272         return 0;</span>
<span class="line-removed">273     }</span>
<span class="line-removed">274 </span>
<span class="line-removed">275     /* Reject paths that contain wildcards */</span>
<span class="line-removed">276     if (wild(orig_path)) {</span>
<span class="line-removed">277         errno = EINVAL;</span>
<span class="line-removed">278         return -1;</span>
<span class="line-removed">279     }</span>
<span class="line-removed">280 </span>
<span class="line-removed">281     /* Collapse instances of &quot;foo\..&quot; and ensure absoluteness.  Note that</span>
<span class="line-removed">282       contrary to the documentation, the _fullpath procedure does not require</span>
<span class="line-removed">283       the drive to be available.  It also does not reliably change all</span>
<span class="line-removed">284       occurrences of &#39;/&#39; to &#39;\\&#39; on Win95, so now JVM_NativePath does that. */</span>
<span class="line-removed">285     if (!_fullpath(path, orig_path, sizeof(path))) {</span>
<span class="line-removed">286         return -1;</span>
<span class="line-removed">287     }</span>
<span class="line-removed">288 </span>
<span class="line-removed">289     /* Correction for Win95: _fullpath may leave a trailing &quot;\\&quot;</span>
<span class="line-removed">290       on a UNC pathname */</span>
<span class="line-removed">291     if ((path[0] == &#39;\\&#39;) &amp;&amp; (path[1] == &#39;\\&#39;)) {</span>
<span class="line-removed">292         char *p = path + strlen(path);</span>
<span class="line-removed">293         if ((p[-1] == &#39;\\&#39;) &amp;&amp; !islb(p[-2])) {</span>
<span class="line-removed">294             p[-1] = &#39;\0&#39;;</span>
<span class="line-removed">295         }</span>
<span class="line-removed">296     }</span>
<span class="line-removed">297 </span>
<span class="line-removed">298     if (dots(path)) /* Check for prohibited combinations of dots */</span>
<span class="line-removed">299         return -1;</span>
<span class="line-removed">300 </span>
<span class="line-removed">301     src = path;            /* Start scanning here */</span>
<span class="line-removed">302     dst = result;        /* Place results here */</span>
<span class="line-removed">303     dend = dst + size;        /* Don&#39;t go to or past here */</span>
<span class="line-removed">304 </span>
<span class="line-removed">305     /* Copy prefix, assuming path is absolute */</span>
<span class="line-removed">306     if (isalpha(src[0]) &amp;&amp; (src[1] == &#39;:&#39;) &amp;&amp; (src[2] == &#39;\\&#39;)) {</span>
<span class="line-removed">307         /* Drive specifier */</span>
<span class="line-removed">308         *src = toupper(*src);    /* Canonicalize drive letter */</span>
<span class="line-removed">309         if (!(dst = cp(dst, dend, &#39;\0&#39;, src, src + 2))) {</span>
<span class="line-removed">310             return -1;</span>
<span class="line-removed">311         }</span>
<span class="line-removed">312         src += 2;</span>
<span class="line-removed">313     } else if ((src[0] == &#39;\\&#39;) &amp;&amp; (src[1] == &#39;\\&#39;)) {</span>
<span class="line-removed">314         /* UNC pathname */</span>
<span class="line-removed">315         char *p;</span>
<span class="line-removed">316         p = nextsep(src + 2);    /* Skip past host name */</span>
<span class="line-removed">317         if (!*p) {</span>
<span class="line-removed">318             /* A UNC pathname must begin with &quot;\\\\host\\share&quot;,</span>
<span class="line-removed">319             so reject this path as invalid if there is no share name */</span>
<span class="line-removed">320             errno = EINVAL;</span>
<span class="line-removed">321             return -1;</span>
<span class="line-removed">322         }</span>
<span class="line-removed">323         p = nextsep(p + 1);    /* Skip past share name */</span>
<span class="line-removed">324         if (!(dst = cp(dst, dend, &#39;\0&#39;, src, p))) {</span>
<span class="line-removed">325             return -1;</span>
<span class="line-removed">326         }</span>
<span class="line-removed">327         src = p;</span>
<span class="line-removed">328     } else {</span>
<span class="line-removed">329         /* Invalid path */</span>
<span class="line-removed">330         errno = EINVAL;</span>
<span class="line-removed">331         return -1;</span>
<span class="line-removed">332     }</span>
<span class="line-removed">333 </span>
<span class="line-removed">334     /* Windows 95/98/Me bug - FindFirstFile fails on network mounted drives */</span>
<span class="line-removed">335     /* for root pathes like &quot;E:\&quot; . If the path has this form, we should  */</span>
<span class="line-removed">336     /* simply return it, it is already canonicalized. */</span>
<span class="line-removed">337     if (strlen(path) == 3 &amp;&amp; path[1] == &#39;:&#39; &amp;&amp; path[2] == &#39;\\&#39;) {</span>
<span class="line-removed">338         /* At this point we have already copied the drive specifier (&quot;z:&quot;)*/</span>
<span class="line-removed">339         /* so we need to copy &quot;\&quot; and the null character. */</span>
<span class="line-removed">340         result[2] = &#39;\\&#39;;</span>
<span class="line-removed">341         result[3] = &#39;\0&#39;;</span>
<span class="line-removed">342         return 0;</span>
<span class="line-removed">343     }</span>
<span class="line-removed">344 </span>
<span class="line-removed">345     /* At this point we have copied either a drive specifier (&quot;z:&quot;) or a UNC</span>
<span class="line-removed">346     prefix (&quot;\\\\host\\share&quot;) to the result buffer, and src points to the</span>
<span class="line-removed">347     first byte of the remainder of the path.  We now scan through the rest</span>
<span class="line-removed">348     of the path, looking up each prefix in order to find the true name of</span>
<span class="line-removed">349     the last element of each prefix, thereby computing the full true name of</span>
<span class="line-removed">350     the original path. */</span>
<span class="line-removed">351     while (*src) {</span>
<span class="line-removed">352         char *p = nextsep(src + 1);    /* Find next separator */</span>
<span class="line-removed">353         char c = *p;</span>
<span class="line-removed">354         assert(*src == &#39;\\&#39;);        /* Invariant */</span>
<span class="line-removed">355         *p = &#39;\0&#39;;            /* Temporarily clear separator */</span>
<span class="line-removed">356         h = FindFirstFile(path, &amp;fd);    /* Look up prefix */</span>
<span class="line-removed">357         *p = c;                /* Restore separator */</span>
<span class="line-removed">358         if (h != INVALID_HANDLE_VALUE) {</span>
<span class="line-removed">359             /* Lookup succeeded; append true name to result and continue */</span>
<span class="line-removed">360             FindClose(h);</span>
<span class="line-removed">361             if (!(dst = cp(dst, dend, &#39;\\&#39;,</span>
<span class="line-removed">362                 fd.cFileName,</span>
<span class="line-removed">363                 fd.cFileName + strlen(fd.cFileName)))) {</span>
<span class="line-removed">364                 return -1;</span>
<span class="line-removed">365             }</span>
<span class="line-removed">366             src = p;</span>
<span class="line-removed">367             continue;</span>
<span class="line-removed">368         } else {</span>
<span class="line-removed">369             if (!lastErrorReportable()) {</span>
<span class="line-removed">370                 if (!(dst = cp(dst, dend, &#39;\0&#39;, src, src + strlen(src)))) {</span>
<span class="line-removed">371                     return -1;</span>
<span class="line-removed">372                 }</span>
<span class="line-removed">373                 break;</span>
<span class="line-removed">374             } else {</span>
<span class="line-removed">375                 return -1;</span>
<span class="line-removed">376             }</span>
<span class="line-removed">377         }</span>
<span class="line-removed">378     }</span>
<span class="line-removed">379 </span>
<span class="line-removed">380     if (dst &gt;= dend) {</span>
<span class="line-removed">381         errno = ENAMETOOLONG;</span>
<span class="line-removed">382         return -1;</span>
<span class="line-removed">383     }</span>
<span class="line-removed">384     *dst = &#39;\0&#39;;</span>
<span class="line-removed">385     return 0;</span>
<span class="line-removed">386 </span>
<span class="line-removed">387 }</span>
<span class="line-removed">388 </span>
<span class="line-removed">389 </span>
<span class="line-removed">390 /* Convert a pathname to canonical form.  The input prefix is assumed</span>
<span class="line-removed">391    to be in canonical form already, and the trailing filename must not</span>
<span class="line-removed">392    contain any wildcard, dot/double dot, or other &quot;tricky&quot; characters</span>
<span class="line-removed">393    that are rejected by the canonicalize() routine above.  This</span>
<span class="line-removed">394    routine is present to allow the canonicalization prefix cache to be</span>
<span class="line-removed">395    used while still returning canonical names with the correct</span>
<span class="line-removed">396    capitalization. */</span>
<span class="line-removed">397 </span>
<span class="line-removed">398 int</span>
<span class="line-removed">399 canonicalizeWithPrefix(char* canonicalPrefix, char* pathWithCanonicalPrefix, char *result, int size)</span>
<span class="line-removed">400 {</span>
<span class="line-removed">401     WIN32_FIND_DATA fd;</span>
<span class="line-removed">402     HANDLE h;</span>
<span class="line-removed">403     char *src, *dst, *dend;</span>
<span class="line-removed">404 </span>
<span class="line-removed">405     src = pathWithCanonicalPrefix;</span>
<span class="line-removed">406     dst = result;        /* Place results here */</span>
<span class="line-removed">407     dend = dst + size;   /* Don&#39;t go to or past here */</span>
<span class="line-removed">408 </span>
<span class="line-removed">409     h = FindFirstFile(pathWithCanonicalPrefix, &amp;fd);    /* Look up file */</span>
<span class="line-removed">410     if (h != INVALID_HANDLE_VALUE) {</span>
<span class="line-removed">411         /* Lookup succeeded; concatenate true name to prefix */</span>
<span class="line-removed">412         FindClose(h);</span>
<span class="line-removed">413         if (!(dst = cp(dst, dend, &#39;\0&#39;,</span>
<span class="line-removed">414                        canonicalPrefix,</span>
<span class="line-removed">415                        canonicalPrefix + strlen(canonicalPrefix)))) {</span>
<span class="line-removed">416             return -1;</span>
<span class="line-removed">417         }</span>
<span class="line-removed">418         if (!(dst = cp(dst, dend, &#39;\\&#39;,</span>
<span class="line-removed">419                        fd.cFileName,</span>
<span class="line-removed">420                        fd.cFileName + strlen(fd.cFileName)))) {</span>
<span class="line-removed">421             return -1;</span>
<span class="line-removed">422         }</span>
<span class="line-removed">423     } else {</span>
<span class="line-removed">424         if (!lastErrorReportable()) {</span>
<span class="line-removed">425             if (!(dst = cp(dst, dend, &#39;\0&#39;, src, src + strlen(src)))) {</span>
<span class="line-removed">426                 return -1;</span>
<span class="line-removed">427             }</span>
<span class="line-removed">428         } else {</span>
<span class="line-removed">429             return -1;</span>
<span class="line-removed">430         }</span>
<span class="line-removed">431     }</span>
<span class="line-removed">432 </span>
<span class="line-removed">433     if (dst &gt;= dend) {</span>
<span class="line-removed">434         errno = ENAMETOOLONG;</span>
<span class="line-removed">435         return -1;</span>
<span class="line-removed">436     }</span>
<span class="line-removed">437     *dst = &#39;\0&#39;;</span>
<span class="line-removed">438     return 0;</span>
<span class="line-removed">439 }</span>
<span class="line-removed">440 </span>
<span class="line-removed">441 </span>
<span class="line-removed">442 /* Wide character version of canonicalize. Size is a wide-character size. */</span>
<span class="line-removed">443 </span>
444 int
445 wcanonicalize(WCHAR *orig_path, WCHAR *result, int size)
446 {
447     WIN32_FIND_DATAW fd;
448     HANDLE h;
449     WCHAR *path;    /* Working copy of path */
450     WCHAR *src, *dst, *dend, c;
451 
452     /* Reject paths that contain wildcards */
453     if (wwild(orig_path)) {
454         errno = EINVAL;
455         return -1;
456     }
457 
458     if ((path = (WCHAR*)malloc(size * sizeof(WCHAR))) == NULL)
459         return -1;
460 
461     /* Collapse instances of &quot;foo\..&quot; and ensure absoluteness.  Note that
462        contrary to the documentation, the _fullpath procedure does not require
463        the drive to be available.  */
</pre>
<hr />
<pre>
542                 break;
543             } else {
544                 goto err;
545             }
546         }
547     }
548 
549     if (dst &gt;= dend) {
550     errno = ENAMETOOLONG;
551         goto err;
552     }
553     *dst = L&#39;\0&#39;;
554     free(path);
555     return 0;
556 
557  err:
558     free(path);
559     return -1;
560 }
561 
<span class="line-modified">562 </span>
<span class="line-modified">563 /* Wide character version of canonicalizeWithPrefix. */</span>
<span class="line-modified">564 </span>




565 int
566 wcanonicalizeWithPrefix(WCHAR *canonicalPrefix, WCHAR *pathWithCanonicalPrefix, WCHAR *result, int size)
567 {
568     WIN32_FIND_DATAW fd;
569     HANDLE h;
570     WCHAR *src, *dst, *dend;
571     WCHAR *pathbuf;
572     int pathlen;
573 
574     src = pathWithCanonicalPrefix;
575     dst = result;        /* Place results here */
576     dend = dst + size;   /* Don&#39;t go to or past here */
577 
578 
579     if ((pathlen=(int)wcslen(pathWithCanonicalPrefix)) &gt; MAX_PATH - 1) {
580         pathbuf = getPrefixed(pathWithCanonicalPrefix, pathlen);
581         h = FindFirstFileW(pathbuf, &amp;fd);    /* Look up prefix */
582         free(pathbuf);
583     } else
584         h = FindFirstFileW(pathWithCanonicalPrefix, &amp;fd);    /* Look up prefix */
</pre>
<hr />
<pre>
596             return -1;
597         }
598     } else {
599         if (!lastErrorReportable()) {
600             if (!(dst = wcp(dst, dend, L&#39;\0&#39;, src, src + wcslen(src)))) {
601                 return -1;
602             }
603         } else {
604             return -1;
605         }
606     }
607 
608     if (dst &gt;= dend) {
609         errno = ENAMETOOLONG;
610         return -1;
611     }
612     *dst = L&#39;\0&#39;;
613     return 0;
614 }
615 







































616 
<span class="line-modified">617 /* The appropriate location of getPrefixed() should be io_util_md.c, but</span>
<span class="line-modified">618    java.lang.instrument package has hardwired canonicalize_md.c into their</span>
<span class="line-modified">619    dll, to avoid complicate solution such as including io_util_md.c into</span>
<span class="line-modified">620    that package, as a workaround we put this method here.</span>
621  */
622 
<span class="line-modified">623 /* copy \\?\ or \\?\UNC\ to the front of path*/</span>
<span class="line-modified">624 __declspec(dllexport) WCHAR*</span>
625 getPrefixed(const WCHAR* path, int pathlen) {
626     WCHAR* pathbuf = (WCHAR*)malloc((pathlen + 10) * sizeof (WCHAR));
627     if (pathbuf != 0) {
628         if (path[0] == L&#39;\\&#39; &amp;&amp; path[1] == L&#39;\\&#39;) {
629             if (path[2] == L&#39;?&#39; &amp;&amp; path[3] == L&#39;\\&#39;){
630                 /* if it already has a \\?\ don&#39;t do the prefix */
631                 wcscpy(pathbuf, path );
632             } else {
633                 /* only UNC pathname includes double slashes here */
634                 wcscpy(pathbuf, L&quot;\\\\?\\UNC\0&quot;);
635                 wcscat(pathbuf, path + 1);
636             }
637         } else {
638             wcscpy(pathbuf, L&quot;\\\\?\\\0&quot;);
639             wcscat(pathbuf, path );
640         }
641     }
642     return pathbuf;
643 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * Pathname canonicalization for Win32 file systems
 28  */
 29 
 30 #include &lt;stdio.h&gt;
 31 #include &lt;stdlib.h&gt;
 32 #include &lt;string.h&gt;
 33 #include &lt;ctype.h&gt;
 34 #include &lt;assert.h&gt;
 35 #include &lt;sys/stat.h&gt;
 36 
 37 #include &lt;windows.h&gt;
 38 #include &lt;winbase.h&gt;
 39 #include &lt;errno.h&gt;







 40 
<span class="line-added"> 41 /* We should also include jdk_util.h here, for the prototype of JDK_Canonicalize.</span>
<span class="line-added"> 42    This isn&#39;t possible though because canonicalize_md.c is as well used in</span>
<span class="line-added"> 43    different contexts within Oracle.</span>
<span class="line-added"> 44  */</span>
<span class="line-added"> 45 #include &quot;io_util_md.h&quot;</span>
 46 
 47 /* Copy bytes to dst, not going past dend; return dst + number of bytes copied,
 48    or NULL if dend would have been exceeded.  If first != &#39;\0&#39;, copy that byte
 49    before copying bytes from src to send - 1. */

























 50 static WCHAR*
 51 wcp(WCHAR *dst, WCHAR *dend, WCHAR first, WCHAR *src, WCHAR *send)
 52 {
 53     WCHAR *p = src, *q = dst;
 54     if (first != L&#39;\0&#39;) {
 55         if (q &lt; dend) {
 56             *q++ = first;
 57         } else {
 58             errno = ENAMETOOLONG;
 59             return NULL;
 60         }
 61     }
 62     if (send - p &gt; dend - q) {
 63         errno = ENAMETOOLONG;
 64         return NULL;
 65     }
 66     while (p &lt; send)
 67         *q++ = *p++;
 68     return q;
 69 }
 70 

 71 /* Find first instance of &#39;\\&#39; at or following start.  Return the address of
 72    that byte or the address of the null terminator if &#39;\\&#39; is not found. */














 73 static WCHAR *
 74 wnextsep(WCHAR *start)
 75 {
 76     WCHAR *p = start;
 77     int c;
 78     while ((c = *p) &amp;&amp; (c != L&#39;\\&#39;))
 79         p++;
 80     return p;
 81 }
 82 
 83 /* Tell whether the given string contains any wildcard characters */















 84 static int
 85 wwild(WCHAR *start)
 86 {
 87     WCHAR *p = start;
 88     int c;
 89     while (c = *p) {
 90         if ((c == L&#39;*&#39;) || (c == L&#39;?&#39;))
 91             return 1;
 92         p++;
 93     }
 94     return 0;
 95 }
 96 
 97 /* Tell whether the given string contains prohibited combinations of dots.
 98    In the canonicalized form no path element may have dots at its end.
 99    Allowed canonical paths: c:\xa...dksd\..ksa\.lk    c:\...a\.b\cd..x.x
100    Prohibited canonical paths: c:\..\x  c:\x.\d c:\...
101 */
102 static int



















103 wdots(WCHAR *start)
104 {
105     WCHAR *p = start;
106     // Skip &quot;\\.\&quot; prefix
107     if (wcslen(p) &gt; 4 &amp;&amp; !wcsncmp(p, L&quot;\\\\.\\&quot;, 4))
108         p = p + 4;
109 
110     while (*p) {
111         if ((p = wcschr(p, L&#39;.&#39;)) == NULL) // find next occurrence of &#39;.&#39;
112             return 0; // no more dots
113         p++; // next char
114         while ((*p) == L&#39;.&#39;) // go to the end of dots
115             p++;
116         if (*p &amp;&amp; (*p != L&#39;\\&#39;)) // path element does not end with a dot
117             p++; // go to the next char
118         else
119             return 1; // path element does end with a dot - prohibited
120     }
121     return 0; // no prohibited combinations of dots found
122 }
123 
124 /* If the lookup of a particular prefix fails because the file does not exist,
125    because it is of the wrong type, because access is denied, or because the
126    network is unreachable then canonicalization does not fail, it terminates
127    successfully after copying the rest of the original path to the result path.
128    Other I/O errors cause an error return.
129 */

130 int
131 lastErrorReportable()
132 {
133     DWORD errval = GetLastError();
134     if ((errval == ERROR_FILE_NOT_FOUND)
135         || (errval == ERROR_DIRECTORY)
136         || (errval == ERROR_PATH_NOT_FOUND)
137         || (errval == ERROR_BAD_NETPATH)
138         || (errval == ERROR_BAD_NET_NAME)
139         || (errval == ERROR_ACCESS_DENIED)
140         || (errval == ERROR_NETWORK_UNREACHABLE)
141         || (errval == ERROR_NETWORK_ACCESS_DENIED)) {
142         return 0;
143     }




144     return 1;
145 }
146 


147 /* Convert a pathname to canonical form.  The input orig_path is assumed to
148    have been converted to native form already, via JVM_NativePath().  This is
149    necessary because _fullpath() rejects duplicate separator characters on
150    Win95, though it accepts them on NT. */


















































































































































































































151 int
152 wcanonicalize(WCHAR *orig_path, WCHAR *result, int size)
153 {
154     WIN32_FIND_DATAW fd;
155     HANDLE h;
156     WCHAR *path;    /* Working copy of path */
157     WCHAR *src, *dst, *dend, c;
158 
159     /* Reject paths that contain wildcards */
160     if (wwild(orig_path)) {
161         errno = EINVAL;
162         return -1;
163     }
164 
165     if ((path = (WCHAR*)malloc(size * sizeof(WCHAR))) == NULL)
166         return -1;
167 
168     /* Collapse instances of &quot;foo\..&quot; and ensure absoluteness.  Note that
169        contrary to the documentation, the _fullpath procedure does not require
170        the drive to be available.  */
</pre>
<hr />
<pre>
249                 break;
250             } else {
251                 goto err;
252             }
253         }
254     }
255 
256     if (dst &gt;= dend) {
257     errno = ENAMETOOLONG;
258         goto err;
259     }
260     *dst = L&#39;\0&#39;;
261     free(path);
262     return 0;
263 
264  err:
265     free(path);
266     return -1;
267 }
268 
<span class="line-modified">269 /* Convert a pathname to canonical form.  The input prefix is assumed</span>
<span class="line-modified">270    to be in canonical form already, and the trailing filename must not</span>
<span class="line-modified">271    contain any wildcard, dot/double dot, or other &quot;tricky&quot; characters</span>
<span class="line-added">272    that are rejected by the canonicalize() routine above.  This</span>
<span class="line-added">273    routine is present to allow the canonicalization prefix cache to be</span>
<span class="line-added">274    used while still returning canonical names with the correct</span>
<span class="line-added">275    capitalization. */</span>
276 int
277 wcanonicalizeWithPrefix(WCHAR *canonicalPrefix, WCHAR *pathWithCanonicalPrefix, WCHAR *result, int size)
278 {
279     WIN32_FIND_DATAW fd;
280     HANDLE h;
281     WCHAR *src, *dst, *dend;
282     WCHAR *pathbuf;
283     int pathlen;
284 
285     src = pathWithCanonicalPrefix;
286     dst = result;        /* Place results here */
287     dend = dst + size;   /* Don&#39;t go to or past here */
288 
289 
290     if ((pathlen=(int)wcslen(pathWithCanonicalPrefix)) &gt; MAX_PATH - 1) {
291         pathbuf = getPrefixed(pathWithCanonicalPrefix, pathlen);
292         h = FindFirstFileW(pathbuf, &amp;fd);    /* Look up prefix */
293         free(pathbuf);
294     } else
295         h = FindFirstFileW(pathWithCanonicalPrefix, &amp;fd);    /* Look up prefix */
</pre>
<hr />
<pre>
307             return -1;
308         }
309     } else {
310         if (!lastErrorReportable()) {
311             if (!(dst = wcp(dst, dend, L&#39;\0&#39;, src, src + wcslen(src)))) {
312                 return -1;
313             }
314         } else {
315             return -1;
316         }
317     }
318 
319     if (dst &gt;= dend) {
320         errno = ENAMETOOLONG;
321         return -1;
322     }
323     *dst = L&#39;\0&#39;;
324     return 0;
325 }
326 
<span class="line-added">327 /* Non-Wide character version of canonicalize.</span>
<span class="line-added">328    Converts to wchar and delegates to wcanonicalize. */</span>
<span class="line-added">329 JNIEXPORT int</span>
<span class="line-added">330 JDK_Canonicalize(const char *orig, char *out, int len) {</span>
<span class="line-added">331     wchar_t* wpath = NULL;</span>
<span class="line-added">332     wchar_t* wresult = NULL;</span>
<span class="line-added">333     size_t conv;</span>
<span class="line-added">334     size_t path_len = strlen(orig);</span>
<span class="line-added">335     int ret = -1;</span>
<span class="line-added">336 </span>
<span class="line-added">337     if ((wpath = (wchar_t*) malloc(sizeof(wchar_t) * (path_len + 1))) == NULL) {</span>
<span class="line-added">338         goto finish;</span>
<span class="line-added">339     }</span>
<span class="line-added">340 </span>
<span class="line-added">341     if (mbstowcs_s(&amp;conv, wpath, path_len + 1, orig, path_len) != 0) {</span>
<span class="line-added">342         goto finish;</span>
<span class="line-added">343     }</span>
<span class="line-added">344 </span>
<span class="line-added">345     if ((wresult = (wchar_t*) malloc(sizeof(wchar_t) * len)) == NULL) {</span>
<span class="line-added">346         goto finish;</span>
<span class="line-added">347     }</span>
<span class="line-added">348 </span>
<span class="line-added">349     if (wcanonicalize(wpath, wresult, len) != 0) {</span>
<span class="line-added">350         goto finish;</span>
<span class="line-added">351     }</span>
<span class="line-added">352 </span>
<span class="line-added">353     if (wcstombs_s(&amp;conv, out, (size_t) len, wresult, (size_t) (len - 1)) != 0) {</span>
<span class="line-added">354         goto finish;</span>
<span class="line-added">355     }</span>
<span class="line-added">356 </span>
<span class="line-added">357     // Change return value to success.</span>
<span class="line-added">358     ret = 0;</span>
<span class="line-added">359 </span>
<span class="line-added">360 finish:</span>
<span class="line-added">361     free(wresult);</span>
<span class="line-added">362     free(wpath);</span>
<span class="line-added">363 </span>
<span class="line-added">364     return ret;</span>
<span class="line-added">365 }</span>
366 
<span class="line-modified">367 /* The appropriate location of getPrefixed() is io_util_md.c, but it is</span>
<span class="line-modified">368    also used in a non-OpenJDK context within Oracle. There, canonicalize_md.c</span>
<span class="line-modified">369    is already pulled in and compiled, so to avoid more complicated solutions</span>
<span class="line-modified">370    we keep this method here.</span>
371  */
372 
<span class="line-modified">373 /* copy \\?\ or \\?\UNC\ to the front of path */</span>
<span class="line-modified">374 JNIEXPORT WCHAR*</span>
375 getPrefixed(const WCHAR* path, int pathlen) {
376     WCHAR* pathbuf = (WCHAR*)malloc((pathlen + 10) * sizeof (WCHAR));
377     if (pathbuf != 0) {
378         if (path[0] == L&#39;\\&#39; &amp;&amp; path[1] == L&#39;\\&#39;) {
379             if (path[2] == L&#39;?&#39; &amp;&amp; path[3] == L&#39;\\&#39;){
380                 /* if it already has a \\?\ don&#39;t do the prefix */
381                 wcscpy(pathbuf, path );
382             } else {
383                 /* only UNC pathname includes double slashes here */
384                 wcscpy(pathbuf, L&quot;\\\\?\\UNC\0&quot;);
385                 wcscat(pathbuf, path + 1);
386             }
387         } else {
388             wcscpy(pathbuf, L&quot;\\\\?\\\0&quot;);
389             wcscat(pathbuf, path );
390         }
391     }
392     return pathbuf;
393 }
</pre>
</td>
</tr>
</table>
<center><a href="HostLocaleProviderAdapter_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="io_util_md.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
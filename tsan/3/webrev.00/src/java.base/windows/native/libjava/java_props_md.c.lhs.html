<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/native/libjava/java_props_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /* Access APIs for Windows Vista and above */
 27 #ifndef _WIN32_WINNT
 28 #define _WIN32_WINNT 0x0601
 29 #endif
 30 
 31 #include &quot;jni.h&quot;
 32 #include &quot;jni_util.h&quot;
 33 
 34 #include &lt;windows.h&gt;
 35 #include &lt;shlobj.h&gt;
 36 #include &lt;objidl.h&gt;
 37 #include &lt;locale.h&gt;
 38 #include &lt;sys/types.h&gt;
 39 #include &lt;sys/timeb.h&gt;
 40 #include &lt;tchar.h&gt;
 41 
 42 #include &lt;stdlib.h&gt;
 43 #include &lt;Wincon.h&gt;
 44 
 45 #include &quot;locale_str.h&quot;
 46 #include &quot;java_props.h&quot;
 47 
 48 #ifndef VER_PLATFORM_WIN32_WINDOWS
 49 #define VER_PLATFORM_WIN32_WINDOWS 1
 50 #endif
 51 
 52 #ifndef PROCESSOR_ARCHITECTURE_AMD64
 53 #define PROCESSOR_ARCHITECTURE_AMD64 9
 54 #endif
 55 
 56 typedef void (WINAPI *PGNSI)(LPSYSTEM_INFO);
 57 static boolean SetupI18nProps(LCID lcid, char** language, char** script, char** country,
 58                char** variant, char** encoding);
 59 
 60 #define PROPSIZE 9      // eight-letter + null terminator
 61 #define SNAMESIZE 86    // max number of chars for LOCALE_SNAME is 85
 62 
 63 static char *
 64 getEncodingInternal(LCID lcid)
 65 {
 66     int codepage;
 67     char * ret = malloc(16);
 68     if (ret == NULL) {
 69         return NULL;
 70     }
 71 
 72     if (GetLocaleInfo(lcid,
 73                       LOCALE_IDEFAULTANSICODEPAGE,
 74                       ret+2, 14) == 0) {
 75         codepage = 1252;
 76     } else {
 77         codepage = atoi(ret+2);
 78     }
 79 
 80     switch (codepage) {
 81     case 0:
 82         strcpy(ret, &quot;UTF-8&quot;);
 83         break;
 84     case 874:     /*  9:Thai     */
 85     case 932:     /* 10:Japanese */
 86     case 949:     /* 12:Korean Extended Wansung */
 87     case 950:     /* 13:Chinese (Taiwan, Hongkong, Macau) */
 88     case 1361:    /* 15:Korean Johab */
 89         ret[0] = &#39;M&#39;;
 90         ret[1] = &#39;S&#39;;
 91         break;
 92     case 936:
 93         strcpy(ret, &quot;GBK&quot;);
 94         break;
 95     case 54936:
 96         strcpy(ret, &quot;GB18030&quot;);
 97         break;
 98     default:
 99         ret[0] = &#39;C&#39;;
100         ret[1] = &#39;p&#39;;
101         break;
102     }
103 
104     //Traditional Chinese Windows should use MS950_HKSCS_XP as the
105     //default encoding, if HKSCS patch has been installed.
106     // &quot;old&quot; MS950 0xfa41 -&gt; u+e001
107     // &quot;new&quot; MS950 0xfa41 -&gt; u+92db
108     if (strcmp(ret, &quot;MS950&quot;) == 0) {
109         TCHAR  mbChar[2] = {(char)0xfa, (char)0x41};
110         WCHAR  unicodeChar;
111         MultiByteToWideChar(CP_ACP, 0, mbChar, 2, &amp;unicodeChar, 1);
112         if (unicodeChar == 0x92db) {
113             strcpy(ret, &quot;MS950_HKSCS_XP&quot;);
114         }
115     } else {
116         //SimpChinese Windows should use GB18030 as the default
117         //encoding, if gb18030 patch has been installed (on windows
118         //2000/XP, (1)Codepage 54936 will be available
119         //(2)simsun18030.ttc will exist under system fonts dir )
120         if (strcmp(ret, &quot;GBK&quot;) == 0 &amp;&amp; IsValidCodePage(54936)) {
121             char systemPath[MAX_PATH + 1];
122             char* gb18030Font = &quot;\\FONTS\\SimSun18030.ttc&quot;;
123             FILE *f = NULL;
124             if (GetWindowsDirectory(systemPath, MAX_PATH + 1) != 0 &amp;&amp;
125                 strlen(systemPath) + strlen(gb18030Font) &lt; MAX_PATH + 1) {
126                 strcat(systemPath, &quot;\\FONTS\\SimSun18030.ttc&quot;);
127                 if ((f = fopen(systemPath, &quot;r&quot;)) != NULL) {
128                     fclose(f);
129                     strcpy(ret, &quot;GB18030&quot;);
130                 }
131             }
132         }
133     }
134 
135     return ret;
136 }
137 
138 static char* getConsoleEncoding()
139 {
140     char* buf = malloc(16);
141     int cp;
142     if (buf == NULL) {
143         return NULL;
144     }
145     cp = GetConsoleCP();
146     if (cp &gt;= 874 &amp;&amp; cp &lt;= 950)
147         sprintf(buf, &quot;ms%d&quot;, cp);
148     else
149         sprintf(buf, &quot;cp%d&quot;, cp);
150     return buf;
151 }
152 
153 // Exported entries for AWT
154 DllExport const char *
155 getEncodingFromLangID(LANGID langID)
156 {
157     return getEncodingInternal(MAKELCID(langID, SORT_DEFAULT));
158 }
159 
160 // Returns BCP47 Language Tag
161 DllExport const char *
162 getJavaIDFromLangID(LANGID langID)
163 {
164     char * elems[5]; // lang, script, ctry, variant, encoding
165     char * ret;
166     int index;
167 
168     ret = malloc(SNAMESIZE);
169     if (ret == NULL) {
170         return NULL;
171     }
172 
173     for (index = 0; index &lt; 5; index++) {
174         elems[index] = NULL;
175     }
176 
177     if (SetupI18nProps(MAKELCID(langID, SORT_DEFAULT),
178                    &amp;(elems[0]), &amp;(elems[1]), &amp;(elems[2]), &amp;(elems[3]), &amp;(elems[4]))) {
179 
180         // there always is the &quot;language&quot; tag
181         strcpy(ret, elems[0]);
182 
183         // append other elements, if any
184         for (index = 1; index &lt; 4; index++) {
185             if ((elems[index])[0] != &#39;\0&#39;) {
186                 strcat(ret, &quot;-&quot;);
187                 strcat(ret, elems[index]);
188             }
189         }
190     } else {
191         free(ret);
192         ret = NULL;
193     }
194 
195     for (index = 0; index &lt; 5; index++) {
196         if (elems[index] != NULL) {
197             free(elems[index]);
198         }
199     }
200 
201     return ret;
202 }
203 
204 /*
205  * Code to figure out the user&#39;s home directory using shell32.dll
206  */
207 WCHAR*
208 getHomeFromShell32()
209 {
210     /*
211      * Note that we don&#39;t free the memory allocated
212      * by getHomeFromShell32.
213      */
214     static WCHAR *u_path = NULL;
215     if (u_path == NULL) {
216         HRESULT hr;
217 
218         /*
219          * SHELL32 DLL is delay load DLL and we can use the trick with
220          * __try/__except block.
221          */
222         __try {
223             /*
224              * For Windows Vista and later (or patched MS OS) we need to use
225              * [SHGetKnownFolderPath] call to avoid MAX_PATH length limitation.
226              * Shell32.dll (version 6.0.6000 or later)
227              */
228             hr = SHGetKnownFolderPath(&amp;FOLDERID_Profile, KF_FLAG_DONT_VERIFY, NULL, &amp;u_path);
229         } __except(EXCEPTION_EXECUTE_HANDLER) {
230             /* Exception: no [SHGetKnownFolderPath] entry */
231             hr = E_FAIL;
232         }
233 
234         if (FAILED(hr)) {
235             WCHAR path[MAX_PATH+1];
236 
237             /* fallback solution for WinXP and Windows 2000 */
238             hr = SHGetFolderPathW(NULL, CSIDL_FLAG_DONT_VERIFY | CSIDL_PROFILE, NULL, SHGFP_TYPE_CURRENT, path);
239             if (FAILED(hr)) {
240                 /* we can&#39;t find the shell folder. */
241                 u_path = NULL;
242             } else {
243                 /* Just to be sure about the path length until Windows Vista approach.
244                  * [S_FALSE] could not be returned due to [CSIDL_FLAG_DONT_VERIFY] flag and UNICODE version.
245                  */
246                 path[MAX_PATH] = 0;
247                 u_path = _wcsdup(path);
248             }
249         }
250     }
251     return u_path;
252 }
253 
254 static boolean
255 haveMMX(void)
256 {
257     return IsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE);
258 }
259 
260 static const char *
261 cpu_isalist(void)
262 {
263     SYSTEM_INFO info;
264     GetSystemInfo(&amp;info);
265     switch (info.wProcessorArchitecture) {
266 #ifdef PROCESSOR_ARCHITECTURE_IA64
267     case PROCESSOR_ARCHITECTURE_IA64: return &quot;ia64&quot;;
268 #endif
269 #ifdef PROCESSOR_ARCHITECTURE_AMD64
270     case PROCESSOR_ARCHITECTURE_AMD64: return &quot;amd64&quot;;
271 #endif
272     case PROCESSOR_ARCHITECTURE_INTEL:
273         switch (info.wProcessorLevel) {
274         case 6: return haveMMX()
275             ? &quot;pentium_pro+mmx pentium_pro pentium+mmx pentium i486 i386 i86&quot;
276             : &quot;pentium_pro pentium i486 i386 i86&quot;;
277         case 5: return haveMMX()
278             ? &quot;pentium+mmx pentium i486 i386 i86&quot;
279             : &quot;pentium i486 i386 i86&quot;;
280         case 4: return &quot;i486 i386 i86&quot;;
281         case 3: return &quot;i386 i86&quot;;
282         }
283     }
284     return NULL;
285 }
286 
287 static boolean
288 SetupI18nProps(LCID lcid, char** language, char** script, char** country,
289                char** variant, char** encoding) {
290     /* script */
291     char tmp[SNAMESIZE];
292     *script = malloc(PROPSIZE);
293     if (*script == NULL) {
294         return FALSE;
295     }
296     if (GetLocaleInfo(lcid,
297                       LOCALE_SNAME, tmp, SNAMESIZE) == 0 ||
298         sscanf(tmp, &quot;%*[a-z\\-]%1[A-Z]%[a-z]&quot;, *script, &amp;((*script)[1])) == 0 ||
299         strlen(*script) != 4) {
300         (*script)[0] = &#39;\0&#39;;
301     }
302 
303     /* country */
304     *country = malloc(PROPSIZE);
305     if (*country == NULL) {
306         return FALSE;
307     }
308     if (GetLocaleInfo(lcid,
309                       LOCALE_SISO3166CTRYNAME, *country, PROPSIZE) == 0 &amp;&amp;
310         GetLocaleInfo(lcid,
311                       LOCALE_SISO3166CTRYNAME2, *country, PROPSIZE) == 0) {
312         (*country)[0] = &#39;\0&#39;;
313     }
314 
315     /* language */
316     *language = malloc(PROPSIZE);
317     if (*language == NULL) {
318         return FALSE;
319     }
320     if (GetLocaleInfo(lcid,
321                       LOCALE_SISO639LANGNAME, *language, PROPSIZE) == 0 &amp;&amp;
322         GetLocaleInfo(lcid,
323                       LOCALE_SISO639LANGNAME2, *language, PROPSIZE) == 0) {
324             /* defaults to en_US */
325             strcpy(*language, &quot;en&quot;);
326             strcpy(*country, &quot;US&quot;);
327         }
328 
329     /* variant */
330     *variant = malloc(PROPSIZE);
331     if (*variant == NULL) {
332         return FALSE;
333     }
334     (*variant)[0] = &#39;\0&#39;;
335 
336     /* handling for Norwegian */
337     if (strcmp(*language, &quot;nb&quot;) == 0) {
338         strcpy(*language, &quot;no&quot;);
339         strcpy(*country , &quot;NO&quot;);
340     } else if (strcmp(*language, &quot;nn&quot;) == 0) {
341         strcpy(*language, &quot;no&quot;);
342         strcpy(*country , &quot;NO&quot;);
343         strcpy(*variant, &quot;NY&quot;);
344     }
345 
346     /* encoding */
347     *encoding = getEncodingInternal(lcid);
348     if (*encoding == NULL) {
349         return FALSE;
350     }
351     return TRUE;
352 }
353 
354 // GetVersionEx is deprecated; disable the warning until a replacement is found
355 #pragma warning(disable : 4996)
356 java_props_t *
357 GetJavaProperties(JNIEnv* env)
358 {
359     static java_props_t sprops = {0};
360     int majorVersion;
361     int minorVersion;
362     int buildNumber = 0;
363 
364     if (sprops.line_separator) {
365         return &amp;sprops;
366     }
367 
<a name="2" id="anc2"></a><span class="line-removed">368     /* AWT properties */</span>
<span class="line-removed">369     sprops.awt_toolkit = &quot;sun.awt.windows.WToolkit&quot;;</span>
<span class="line-removed">370 </span>
371     /* tmp dir */
372     {
373         WCHAR tmpdir[MAX_PATH + 1];
374         /* we might want to check that this succeed */
375         GetTempPathW(MAX_PATH + 1, tmpdir);
376         sprops.tmp_dir = _wcsdup(tmpdir);
377     }
378 
<a name="3" id="anc3"></a><span class="line-removed">379     /* Java2D properties */</span>
<span class="line-removed">380     sprops.graphics_env = &quot;sun.awt.Win32GraphicsEnvironment&quot;;</span>
<span class="line-removed">381 </span>
382     /* OS properties */
383     {
384         char buf[100];
385         boolean is_workstation;
386         boolean is_64bit;
387         DWORD platformId;
388         {
389             OSVERSIONINFOEX ver;
390             ver.dwOSVersionInfoSize = sizeof(ver);
391             GetVersionEx((OSVERSIONINFO *) &amp;ver);
392             majorVersion = ver.dwMajorVersion;
393             minorVersion = ver.dwMinorVersion;
394             /* distinguish Windows Server 2016 and 2019 by build number */
395             buildNumber = ver.dwBuildNumber;
396             is_workstation = (ver.wProductType == VER_NT_WORKSTATION);
397             platformId = ver.dwPlatformId;
398             sprops.patch_level = _strdup(ver.szCSDVersion);
399         }
400 
401         {
402             SYSTEM_INFO si;
403             ZeroMemory(&amp;si, sizeof(SYSTEM_INFO));
404             GetNativeSystemInfo(&amp;si);
405 
406             is_64bit = (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64);
407         }
408         do {
409             // Read the major and minor version number from kernel32.dll
410             VS_FIXEDFILEINFO *file_info;
411             WCHAR kernel32_path[MAX_PATH];
412             DWORD version_size;
413             LPTSTR version_info;
414             UINT len, ret;
415 
416             // Get the full path to \Windows\System32\kernel32.dll and use that for
417             // determining what version of Windows we&#39;re running on.
418             len = MAX_PATH - (UINT)strlen(&quot;\\kernel32.dll&quot;) - 1;
419             ret = GetSystemDirectoryW(kernel32_path, len);
420             if (ret == 0 || ret &gt; len) {
421                 break;
422             }
423             wcsncat(kernel32_path, L&quot;\\kernel32.dll&quot;, MAX_PATH - ret);
424 
425             version_size = GetFileVersionInfoSizeW(kernel32_path, NULL);
426             if (version_size == 0) {
427                 break;
428             }
429 
430             version_info = (LPTSTR)malloc(version_size);
431             if (version_info == NULL) {
432                 break;
433             }
434 
435             if (!GetFileVersionInfoW(kernel32_path, 0, version_size, version_info)) {
436                 free(version_info);
437                 break;
438             }
439 
440             if (!VerQueryValueW(version_info, L&quot;\\&quot;, (LPVOID*)&amp;file_info, &amp;len)) {
441                 free(version_info);
442                 break;
443             }
444             majorVersion = HIWORD(file_info-&gt;dwProductVersionMS);
445             minorVersion = LOWORD(file_info-&gt;dwProductVersionMS);
446             buildNumber  = HIWORD(file_info-&gt;dwProductVersionLS);
447             free(version_info);
448         } while (0);
449 
450         /*
451          * From msdn page on OSVERSIONINFOEX, current as of this
452          * writing, decoding of dwMajorVersion and dwMinorVersion.
453          *
454          *  Operating system            dwMajorVersion  dwMinorVersion
455          * ==================           ==============  ==============
456          *
457          * Windows 95                   4               0
458          * Windows 98                   4               10
459          * Windows ME                   4               90
460          * Windows 3.51                 3               51
461          * Windows NT 4.0               4               0
462          * Windows 2000                 5               0
463          * Windows XP 32 bit            5               1
464          * Windows Server 2003 family   5               2
465          * Windows XP 64 bit            5               2
466          *       where ((&amp;ver.wServicePackMinor) + 2) = 1
467          *       and  si.wProcessorArchitecture = 9
468          * Windows Vista family         6               0  (VER_NT_WORKSTATION)
469          * Windows Server 2008          6               0  (!VER_NT_WORKSTATION)
470          * Windows 7                    6               1  (VER_NT_WORKSTATION)
471          * Windows Server 2008 R2       6               1  (!VER_NT_WORKSTATION)
472          * Windows 8                    6               2  (VER_NT_WORKSTATION)
473          * Windows Server 2012          6               2  (!VER_NT_WORKSTATION)
474          * Windows Server 2012 R2       6               3  (!VER_NT_WORKSTATION)
475          * Windows 10                   10              0  (VER_NT_WORKSTATION)
476          * Windows Server 2016          10              0  (!VER_NT_WORKSTATION)
477          * Windows Server 2019          10              0  (!VER_NT_WORKSTATION)
478          *       where (buildNumber &gt; 17762)
479          *
480          * This mapping will presumably be augmented as new Windows
481          * versions are released.
482          */
483         switch (platformId) {
484         case VER_PLATFORM_WIN32_WINDOWS:
485            if (majorVersion == 4) {
486                 switch (minorVersion) {
487                 case  0: sprops.os_name = &quot;Windows 95&quot;;           break;
488                 case 10: sprops.os_name = &quot;Windows 98&quot;;           break;
489                 case 90: sprops.os_name = &quot;Windows Me&quot;;           break;
490                 default: sprops.os_name = &quot;Windows 9X (unknown)&quot;; break;
491                 }
492             } else {
493                 sprops.os_name = &quot;Windows 9X (unknown)&quot;;
494             }
495             break;
496         case VER_PLATFORM_WIN32_NT:
497             if (majorVersion &lt;= 4) {
498                 sprops.os_name = &quot;Windows NT&quot;;
499             } else if (majorVersion == 5) {
500                 switch (minorVersion) {
501                 case  0: sprops.os_name = &quot;Windows 2000&quot;;         break;
502                 case  1: sprops.os_name = &quot;Windows XP&quot;;           break;
503                 case  2:
504                    /*
505                     * From MSDN OSVERSIONINFOEX and SYSTEM_INFO documentation:
506                     *
507                     * &quot;Because the version numbers for Windows Server 2003
508                     * and Windows XP 6u4 bit are identical, you must also test
509                     * whether the wProductType member is VER_NT_WORKSTATION.
510                     * and si.wProcessorArchitecture is
511                     * PROCESSOR_ARCHITECTURE_AMD64 (which is 9)
512                     * If it is, the operating system is Windows XP 64 bit;
513                     * otherwise, it is Windows Server 2003.&quot;
514                     */
515                     if (is_workstation &amp;&amp; is_64bit) {
516                         sprops.os_name = &quot;Windows XP&quot;; /* 64 bit */
517                     } else {
518                         sprops.os_name = &quot;Windows 2003&quot;;
519                     }
520                     break;
521                 default: sprops.os_name = &quot;Windows NT (unknown)&quot;; break;
522                 }
523             } else if (majorVersion == 6) {
524                 /*
525                  * See table in MSDN OSVERSIONINFOEX documentation.
526                  */
527                 if (is_workstation) {
528                     switch (minorVersion) {
529                     case  0: sprops.os_name = &quot;Windows Vista&quot;;        break;
530                     case  1: sprops.os_name = &quot;Windows 7&quot;;            break;
531                     case  2: sprops.os_name = &quot;Windows 8&quot;;            break;
532                     case  3: sprops.os_name = &quot;Windows 8.1&quot;;          break;
533                     default: sprops.os_name = &quot;Windows NT (unknown)&quot;;
534                     }
535                 } else {
536                     switch (minorVersion) {
537                     case  0: sprops.os_name = &quot;Windows Server 2008&quot;;    break;
538                     case  1: sprops.os_name = &quot;Windows Server 2008 R2&quot;; break;
539                     case  2: sprops.os_name = &quot;Windows Server 2012&quot;;    break;
540                     case  3: sprops.os_name = &quot;Windows Server 2012 R2&quot;; break;
541                     default: sprops.os_name = &quot;Windows NT (unknown)&quot;;
542                     }
543                 }
544             } else if (majorVersion == 10) {
545                 if (is_workstation) {
546                     switch (minorVersion) {
547                     case  0: sprops.os_name = &quot;Windows 10&quot;;           break;
548                     default: sprops.os_name = &quot;Windows NT (unknown)&quot;;
549                     }
550                 } else {
551                     switch (minorVersion) {
552                     case  0:
553                         /* Windows server 2019 GA 10/2018 build number is 17763 */
554                         if (buildNumber &gt; 17762) {
555                             sprops.os_name = &quot;Windows Server 2019&quot;;
556                         } else {
557                             sprops.os_name = &quot;Windows Server 2016&quot;;
558                         }
559                         break;
560                     default: sprops.os_name = &quot;Windows NT (unknown)&quot;;
561                     }
562                 }
563             } else {
564                 sprops.os_name = &quot;Windows NT (unknown)&quot;;
565             }
566             break;
567         default:
568             sprops.os_name = &quot;Windows (unknown)&quot;;
569             break;
570         }
571         sprintf(buf, &quot;%d.%d&quot;, majorVersion, minorVersion);
572         sprops.os_version = _strdup(buf);
<a name="4" id="anc4"></a><span class="line-modified">573 #if _M_AMD64</span>
574         sprops.os_arch = &quot;amd64&quot;;
<a name="5" id="anc5"></a><span class="line-modified">575 #elif _X86_</span>
576         sprops.os_arch = &quot;x86&quot;;
577 #else
578         sprops.os_arch = &quot;unknown&quot;;
579 #endif
<a name="6" id="anc6"></a><span class="line-removed">580         sprops.desktop = &quot;windows&quot;;</span>
581     }
582 
583     /* Endianness of platform */
584     {
585         unsigned int endianTest = 0xff000000;
586         if (((char*)(&amp;endianTest))[0] != 0) {
587             sprops.cpu_endian = &quot;big&quot;;
588         } else {
589             sprops.cpu_endian = &quot;little&quot;;
590         }
591     }
592 
593     /* CPU ISA list */
594     sprops.cpu_isalist = cpu_isalist();
595 
596     /*
597      * User name
598      * We try to avoid calling GetUserName as it turns out to
599      * be surprisingly expensive on NT.  It pulls in an extra
600      * 100 K of footprint.
601      */
602     {
603         WCHAR *uname = _wgetenv(L&quot;USERNAME&quot;);
604         if (uname != NULL &amp;&amp; wcslen(uname) &gt; 0) {
605             sprops.user_name = _wcsdup(uname);
606         } else {
607             DWORD buflen = 0;
608             if (GetUserNameW(NULL, &amp;buflen) == 0 &amp;&amp;
609                 GetLastError() == ERROR_INSUFFICIENT_BUFFER)
610             {
611                 uname = (WCHAR*)malloc(buflen * sizeof(WCHAR));
612                 if (uname != NULL &amp;&amp; GetUserNameW(uname, &amp;buflen) == 0) {
613                     free(uname);
614                     uname = NULL;
615                 }
616             } else {
617                 uname = NULL;
618             }
619             sprops.user_name = (uname != NULL) ? uname : L&quot;unknown&quot;;
620         }
621     }
622 
623     /*
624      * Home directory
625      *
626      * The normal result is that for a given user name XXX:
627      *     On multi-user NT, user.home gets set to c:\winnt\profiles\XXX.
628      *     On multi-user Win95, user.home gets set to c:\windows\profiles\XXX.
629      *     On single-user Win95, user.home gets set to c:\windows.
630      */
631     {
632         WCHAR *homep = getHomeFromShell32();
633         if (homep == NULL) {
634             homep = L&quot;C:\\&quot;;
635         }
636         sprops.user_home = homep;
637     }
638 
639     /*
640      *  user.language
641      *  user.script, user.country, user.variant (if user&#39;s environment specifies them)
642      *  file.encoding
643      */
644     {
645         /*
646          * query the system for the current system default locale
647          * (which is a Windows LCID value),
648          */
649         LCID userDefaultLCID = GetUserDefaultLCID();
650         LCID systemDefaultLCID = GetSystemDefaultLCID();
<a name="7" id="anc7"></a><span class="line-modified">651         LCID userDefaultUILang = GetUserDefaultUILanguage();</span>

652 
653         {
654             char * display_encoding;
655             HANDLE hStdOutErr;
656 
657             // Windows UI Language selection list only cares &quot;language&quot;
658             // information of the UI Language. For example, the list
659             // just lists &quot;English&quot; but it actually means &quot;en_US&quot;, and
660             // the user cannot select &quot;en_GB&quot; (if exists) in the list.
661             // So, this hack is to use the user LCID region information
662             // for the UI Language, if the &quot;language&quot; portion of those
663             // two locales are the same.
664             if (PRIMARYLANGID(LANGIDFROMLCID(userDefaultLCID)) ==
<a name="8" id="anc8"></a><span class="line-modified">665                 PRIMARYLANGID(LANGIDFROMLCID(userDefaultUILang))) {</span>
<span class="line-modified">666                 userDefaultUILang = userDefaultLCID;</span>
667             }
668 
669             SetupI18nProps(userDefaultLCID,
670                            &amp;sprops.format_language,
671                            &amp;sprops.format_script,
672                            &amp;sprops.format_country,
673                            &amp;sprops.format_variant,
674                            &amp;sprops.encoding);
<a name="9" id="anc9"></a><span class="line-modified">675             SetupI18nProps(userDefaultUILang,</span>
676                            &amp;sprops.display_language,
677                            &amp;sprops.display_script,
678                            &amp;sprops.display_country,
679                            &amp;sprops.display_variant,
680                            &amp;display_encoding);
681 
682             sprops.sun_jnu_encoding = getEncodingInternal(systemDefaultLCID);
683             if (LANGIDFROMLCID(userDefaultLCID) == 0x0c04 &amp;&amp; majorVersion == 6) {
684                 // MS claims &quot;Vista has built-in support for HKSCS-2004.
685                 // All of the HKSCS-2004 characters have Unicode 4.1.
686                 // PUA code point assignments&quot;. But what it really means
687                 // is that the HKSCS-2004 is ONLY supported in Unicode.
688                 // Test indicates the MS950 in its zh_HK locale is a
689                 // &quot;regular&quot; MS950 which does not handle HKSCS-2004 at
690                 // all. Set encoding to MS950_HKSCS.
691                 sprops.encoding = &quot;MS950_HKSCS&quot;;
692                 sprops.sun_jnu_encoding = &quot;MS950_HKSCS&quot;;
693             }
694 
695             hStdOutErr = GetStdHandle(STD_OUTPUT_HANDLE);
696             if (hStdOutErr != INVALID_HANDLE_VALUE &amp;&amp;
697                 GetFileType(hStdOutErr) == FILE_TYPE_CHAR) {
698                 sprops.sun_stdout_encoding = getConsoleEncoding();
699             }
700             hStdOutErr = GetStdHandle(STD_ERROR_HANDLE);
701             if (hStdOutErr != INVALID_HANDLE_VALUE &amp;&amp;
702                 GetFileType(hStdOutErr) == FILE_TYPE_CHAR) {
703                 if (sprops.sun_stdout_encoding != NULL)
704                     sprops.sun_stderr_encoding = sprops.sun_stdout_encoding;
705                 else
706                     sprops.sun_stderr_encoding = getConsoleEncoding();
707             }
708         }
709     }
710 
711     sprops.unicode_encoding = &quot;UnicodeLittle&quot;;
712 
713     /* User TIMEZONE
714      * We defer setting up timezone until it&#39;s actually necessary.
715      * Refer to TimeZone.getDefault(). The system property
716      * is able to be set by the command line interface -Duser.timezone.
717      */
718 
719     /* Current directory */
720     {
721         WCHAR buf[MAX_PATH];
722         if (GetCurrentDirectoryW(sizeof(buf)/sizeof(WCHAR), buf) != 0)
723             sprops.user_dir = _wcsdup(buf);
724     }
725 
726     sprops.file_separator = &quot;\\&quot;;
727     sprops.path_separator = &quot;;&quot;;
728     sprops.line_separator = &quot;\r\n&quot;;
729 
730     return &amp;sprops;
731 }
732 
733 jstring
734 GetStringPlatform(JNIEnv *env, nchar* wcstr)
735 {
736     return (*env)-&gt;NewString(env, wcstr, (jsize)wcslen(wcstr));
737 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
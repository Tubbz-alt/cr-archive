<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libjava/java_props_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="io_util_md.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jdk_util_md.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libjava/java_props_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
348     if (*encoding == NULL) {
349         return FALSE;
350     }
351     return TRUE;
352 }
353 
354 // GetVersionEx is deprecated; disable the warning until a replacement is found
355 #pragma warning(disable : 4996)
356 java_props_t *
357 GetJavaProperties(JNIEnv* env)
358 {
359     static java_props_t sprops = {0};
360     int majorVersion;
361     int minorVersion;
362     int buildNumber = 0;
363 
364     if (sprops.line_separator) {
365         return &amp;sprops;
366     }
367 
<span class="line-removed">368     /* AWT properties */</span>
<span class="line-removed">369     sprops.awt_toolkit = &quot;sun.awt.windows.WToolkit&quot;;</span>
<span class="line-removed">370 </span>
371     /* tmp dir */
372     {
373         WCHAR tmpdir[MAX_PATH + 1];
374         /* we might want to check that this succeed */
375         GetTempPathW(MAX_PATH + 1, tmpdir);
376         sprops.tmp_dir = _wcsdup(tmpdir);
377     }
378 
<span class="line-removed">379     /* Java2D properties */</span>
<span class="line-removed">380     sprops.graphics_env = &quot;sun.awt.Win32GraphicsEnvironment&quot;;</span>
<span class="line-removed">381 </span>
382     /* OS properties */
383     {
384         char buf[100];
385         boolean is_workstation;
386         boolean is_64bit;
387         DWORD platformId;
388         {
389             OSVERSIONINFOEX ver;
390             ver.dwOSVersionInfoSize = sizeof(ver);
391             GetVersionEx((OSVERSIONINFO *) &amp;ver);
392             majorVersion = ver.dwMajorVersion;
393             minorVersion = ver.dwMinorVersion;
394             /* distinguish Windows Server 2016 and 2019 by build number */
395             buildNumber = ver.dwBuildNumber;
396             is_workstation = (ver.wProductType == VER_NT_WORKSTATION);
397             platformId = ver.dwPlatformId;
398             sprops.patch_level = _strdup(ver.szCSDVersion);
399         }
400 
401         {
</pre>
<hr />
<pre>
553                         /* Windows server 2019 GA 10/2018 build number is 17763 */
554                         if (buildNumber &gt; 17762) {
555                             sprops.os_name = &quot;Windows Server 2019&quot;;
556                         } else {
557                             sprops.os_name = &quot;Windows Server 2016&quot;;
558                         }
559                         break;
560                     default: sprops.os_name = &quot;Windows NT (unknown)&quot;;
561                     }
562                 }
563             } else {
564                 sprops.os_name = &quot;Windows NT (unknown)&quot;;
565             }
566             break;
567         default:
568             sprops.os_name = &quot;Windows (unknown)&quot;;
569             break;
570         }
571         sprintf(buf, &quot;%d.%d&quot;, majorVersion, minorVersion);
572         sprops.os_version = _strdup(buf);
<span class="line-modified">573 #if _M_AMD64</span>
574         sprops.os_arch = &quot;amd64&quot;;
<span class="line-modified">575 #elif _X86_</span>
576         sprops.os_arch = &quot;x86&quot;;
577 #else
578         sprops.os_arch = &quot;unknown&quot;;
579 #endif
<span class="line-removed">580         sprops.desktop = &quot;windows&quot;;</span>
581     }
582 
583     /* Endianness of platform */
584     {
585         unsigned int endianTest = 0xff000000;
586         if (((char*)(&amp;endianTest))[0] != 0) {
587             sprops.cpu_endian = &quot;big&quot;;
588         } else {
589             sprops.cpu_endian = &quot;little&quot;;
590         }
591     }
592 
593     /* CPU ISA list */
594     sprops.cpu_isalist = cpu_isalist();
595 
596     /*
597      * User name
598      * We try to avoid calling GetUserName as it turns out to
599      * be surprisingly expensive on NT.  It pulls in an extra
600      * 100 K of footprint.
</pre>
<hr />
<pre>
631     {
632         WCHAR *homep = getHomeFromShell32();
633         if (homep == NULL) {
634             homep = L&quot;C:\\&quot;;
635         }
636         sprops.user_home = homep;
637     }
638 
639     /*
640      *  user.language
641      *  user.script, user.country, user.variant (if user&#39;s environment specifies them)
642      *  file.encoding
643      */
644     {
645         /*
646          * query the system for the current system default locale
647          * (which is a Windows LCID value),
648          */
649         LCID userDefaultLCID = GetUserDefaultLCID();
650         LCID systemDefaultLCID = GetSystemDefaultLCID();
<span class="line-modified">651         LCID userDefaultUILang = GetUserDefaultUILanguage();</span>

652 
653         {
654             char * display_encoding;
655             HANDLE hStdOutErr;
656 
657             // Windows UI Language selection list only cares &quot;language&quot;
658             // information of the UI Language. For example, the list
659             // just lists &quot;English&quot; but it actually means &quot;en_US&quot;, and
660             // the user cannot select &quot;en_GB&quot; (if exists) in the list.
661             // So, this hack is to use the user LCID region information
662             // for the UI Language, if the &quot;language&quot; portion of those
663             // two locales are the same.
664             if (PRIMARYLANGID(LANGIDFROMLCID(userDefaultLCID)) ==
<span class="line-modified">665                 PRIMARYLANGID(LANGIDFROMLCID(userDefaultUILang))) {</span>
<span class="line-modified">666                 userDefaultUILang = userDefaultLCID;</span>
667             }
668 
669             SetupI18nProps(userDefaultLCID,
670                            &amp;sprops.format_language,
671                            &amp;sprops.format_script,
672                            &amp;sprops.format_country,
673                            &amp;sprops.format_variant,
674                            &amp;sprops.encoding);
<span class="line-modified">675             SetupI18nProps(userDefaultUILang,</span>
676                            &amp;sprops.display_language,
677                            &amp;sprops.display_script,
678                            &amp;sprops.display_country,
679                            &amp;sprops.display_variant,
680                            &amp;display_encoding);
681 
682             sprops.sun_jnu_encoding = getEncodingInternal(systemDefaultLCID);
683             if (LANGIDFROMLCID(userDefaultLCID) == 0x0c04 &amp;&amp; majorVersion == 6) {
684                 // MS claims &quot;Vista has built-in support for HKSCS-2004.
685                 // All of the HKSCS-2004 characters have Unicode 4.1.
686                 // PUA code point assignments&quot;. But what it really means
687                 // is that the HKSCS-2004 is ONLY supported in Unicode.
688                 // Test indicates the MS950 in its zh_HK locale is a
689                 // &quot;regular&quot; MS950 which does not handle HKSCS-2004 at
690                 // all. Set encoding to MS950_HKSCS.
691                 sprops.encoding = &quot;MS950_HKSCS&quot;;
692                 sprops.sun_jnu_encoding = &quot;MS950_HKSCS&quot;;
693             }
694 
695             hStdOutErr = GetStdHandle(STD_OUTPUT_HANDLE);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
348     if (*encoding == NULL) {
349         return FALSE;
350     }
351     return TRUE;
352 }
353 
354 // GetVersionEx is deprecated; disable the warning until a replacement is found
355 #pragma warning(disable : 4996)
356 java_props_t *
357 GetJavaProperties(JNIEnv* env)
358 {
359     static java_props_t sprops = {0};
360     int majorVersion;
361     int minorVersion;
362     int buildNumber = 0;
363 
364     if (sprops.line_separator) {
365         return &amp;sprops;
366     }
367 



368     /* tmp dir */
369     {
370         WCHAR tmpdir[MAX_PATH + 1];
371         /* we might want to check that this succeed */
372         GetTempPathW(MAX_PATH + 1, tmpdir);
373         sprops.tmp_dir = _wcsdup(tmpdir);
374     }
375 



376     /* OS properties */
377     {
378         char buf[100];
379         boolean is_workstation;
380         boolean is_64bit;
381         DWORD platformId;
382         {
383             OSVERSIONINFOEX ver;
384             ver.dwOSVersionInfoSize = sizeof(ver);
385             GetVersionEx((OSVERSIONINFO *) &amp;ver);
386             majorVersion = ver.dwMajorVersion;
387             minorVersion = ver.dwMinorVersion;
388             /* distinguish Windows Server 2016 and 2019 by build number */
389             buildNumber = ver.dwBuildNumber;
390             is_workstation = (ver.wProductType == VER_NT_WORKSTATION);
391             platformId = ver.dwPlatformId;
392             sprops.patch_level = _strdup(ver.szCSDVersion);
393         }
394 
395         {
</pre>
<hr />
<pre>
547                         /* Windows server 2019 GA 10/2018 build number is 17763 */
548                         if (buildNumber &gt; 17762) {
549                             sprops.os_name = &quot;Windows Server 2019&quot;;
550                         } else {
551                             sprops.os_name = &quot;Windows Server 2016&quot;;
552                         }
553                         break;
554                     default: sprops.os_name = &quot;Windows NT (unknown)&quot;;
555                     }
556                 }
557             } else {
558                 sprops.os_name = &quot;Windows NT (unknown)&quot;;
559             }
560             break;
561         default:
562             sprops.os_name = &quot;Windows (unknown)&quot;;
563             break;
564         }
565         sprintf(buf, &quot;%d.%d&quot;, majorVersion, minorVersion);
566         sprops.os_version = _strdup(buf);
<span class="line-modified">567 #if defined(_M_AMD64)</span>
568         sprops.os_arch = &quot;amd64&quot;;
<span class="line-modified">569 #elif defined(_X86_)</span>
570         sprops.os_arch = &quot;x86&quot;;
571 #else
572         sprops.os_arch = &quot;unknown&quot;;
573 #endif

574     }
575 
576     /* Endianness of platform */
577     {
578         unsigned int endianTest = 0xff000000;
579         if (((char*)(&amp;endianTest))[0] != 0) {
580             sprops.cpu_endian = &quot;big&quot;;
581         } else {
582             sprops.cpu_endian = &quot;little&quot;;
583         }
584     }
585 
586     /* CPU ISA list */
587     sprops.cpu_isalist = cpu_isalist();
588 
589     /*
590      * User name
591      * We try to avoid calling GetUserName as it turns out to
592      * be surprisingly expensive on NT.  It pulls in an extra
593      * 100 K of footprint.
</pre>
<hr />
<pre>
624     {
625         WCHAR *homep = getHomeFromShell32();
626         if (homep == NULL) {
627             homep = L&quot;C:\\&quot;;
628         }
629         sprops.user_home = homep;
630     }
631 
632     /*
633      *  user.language
634      *  user.script, user.country, user.variant (if user&#39;s environment specifies them)
635      *  file.encoding
636      */
637     {
638         /*
639          * query the system for the current system default locale
640          * (which is a Windows LCID value),
641          */
642         LCID userDefaultLCID = GetUserDefaultLCID();
643         LCID systemDefaultLCID = GetSystemDefaultLCID();
<span class="line-modified">644         LANGID userDefaultUILang = GetUserDefaultUILanguage();</span>
<span class="line-added">645         LCID userDefaultUILCID = MAKELCID(userDefaultUILang, SORTIDFROMLCID(userDefaultLCID));</span>
646 
647         {
648             char * display_encoding;
649             HANDLE hStdOutErr;
650 
651             // Windows UI Language selection list only cares &quot;language&quot;
652             // information of the UI Language. For example, the list
653             // just lists &quot;English&quot; but it actually means &quot;en_US&quot;, and
654             // the user cannot select &quot;en_GB&quot; (if exists) in the list.
655             // So, this hack is to use the user LCID region information
656             // for the UI Language, if the &quot;language&quot; portion of those
657             // two locales are the same.
658             if (PRIMARYLANGID(LANGIDFROMLCID(userDefaultLCID)) ==
<span class="line-modified">659                 PRIMARYLANGID(userDefaultUILang)) {</span>
<span class="line-modified">660                 userDefaultUILCID = userDefaultLCID;</span>
661             }
662 
663             SetupI18nProps(userDefaultLCID,
664                            &amp;sprops.format_language,
665                            &amp;sprops.format_script,
666                            &amp;sprops.format_country,
667                            &amp;sprops.format_variant,
668                            &amp;sprops.encoding);
<span class="line-modified">669             SetupI18nProps(userDefaultUILCID,</span>
670                            &amp;sprops.display_language,
671                            &amp;sprops.display_script,
672                            &amp;sprops.display_country,
673                            &amp;sprops.display_variant,
674                            &amp;display_encoding);
675 
676             sprops.sun_jnu_encoding = getEncodingInternal(systemDefaultLCID);
677             if (LANGIDFROMLCID(userDefaultLCID) == 0x0c04 &amp;&amp; majorVersion == 6) {
678                 // MS claims &quot;Vista has built-in support for HKSCS-2004.
679                 // All of the HKSCS-2004 characters have Unicode 4.1.
680                 // PUA code point assignments&quot;. But what it really means
681                 // is that the HKSCS-2004 is ONLY supported in Unicode.
682                 // Test indicates the MS950 in its zh_HK locale is a
683                 // &quot;regular&quot; MS950 which does not handle HKSCS-2004 at
684                 // all. Set encoding to MS950_HKSCS.
685                 sprops.encoding = &quot;MS950_HKSCS&quot;;
686                 sprops.sun_jnu_encoding = &quot;MS950_HKSCS&quot;;
687             }
688 
689             hStdOutErr = GetStdHandle(STD_OUTPUT_HANDLE);
</pre>
</td>
</tr>
</table>
<center><a href="io_util_md.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jdk_util_md.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/windows/native/libjava/canonicalize_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="HostLocaleProviderAdapter_md.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="io_util_md.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libjava/canonicalize_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,47 ***</span>
  #include &lt;sys/stat.h&gt;
  
  #include &lt;windows.h&gt;
  #include &lt;winbase.h&gt;
  #include &lt;errno.h&gt;
<span class="line-removed">- #include &quot;io_util_md.h&quot;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #undef DEBUG_PATH        /* Define this to debug path code */</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define isfilesep(c) ((c) == &#39;/&#39; || (c) == &#39;\\&#39;)</span>
<span class="line-removed">- #define wisfilesep(c) ((c) == L&#39;/&#39; || (c) == L&#39;\\&#39;)</span>
<span class="line-removed">- #define islb(c)      (IsDBCSLeadByte((BYTE)(c)))</span>
  
  
  /* Copy bytes to dst, not going past dend; return dst + number of bytes copied,
     or NULL if dend would have been exceeded.  If first != &#39;\0&#39;, copy that byte
     before copying bytes from src to send - 1. */
<span class="line-removed">- </span>
<span class="line-removed">- static char *</span>
<span class="line-removed">- cp(char *dst, char *dend, char first, char *src, char *send)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     char *p = src, *q = dst;</span>
<span class="line-removed">-     if (first != &#39;\0&#39;) {</span>
<span class="line-removed">-         if (q &lt; dend) {</span>
<span class="line-removed">-             *q++ = first;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             errno = ENAMETOOLONG;</span>
<span class="line-removed">-             return NULL;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (send - p &gt; dend - q) {</span>
<span class="line-removed">-         errno = ENAMETOOLONG;</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     while (p &lt; send) {</span>
<span class="line-removed">-         *q++ = *p++;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return q;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- /* Wide character version of cp */</span>
<span class="line-removed">- </span>
  static WCHAR*
  wcp(WCHAR *dst, WCHAR *dend, WCHAR first, WCHAR *src, WCHAR *send)
  {
      WCHAR *p = src, *q = dst;
      if (first != L&#39;\0&#39;) {
<span class="line-new-header">--- 35,20 ---</span>
  #include &lt;sys/stat.h&gt;
  
  #include &lt;windows.h&gt;
  #include &lt;winbase.h&gt;
  #include &lt;errno.h&gt;
  
<span class="line-added">+ /* We should also include jdk_util.h here, for the prototype of JDK_Canonicalize.</span>
<span class="line-added">+    This isn&#39;t possible though because canonicalize_md.c is as well used in</span>
<span class="line-added">+    different contexts within Oracle.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ #include &quot;io_util_md.h&quot;</span>
  
  /* Copy bytes to dst, not going past dend; return dst + number of bytes copied,
     or NULL if dend would have been exceeded.  If first != &#39;\0&#39;, copy that byte
     before copying bytes from src to send - 1. */
  static WCHAR*
  wcp(WCHAR *dst, WCHAR *dend, WCHAR first, WCHAR *src, WCHAR *send)
  {
      WCHAR *p = src, *q = dst;
      if (first != L&#39;\0&#39;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,27 ***</span>
      while (p &lt; send)
          *q++ = *p++;
      return q;
  }
  
<span class="line-removed">- </span>
  /* Find first instance of &#39;\\&#39; at or following start.  Return the address of
     that byte or the address of the null terminator if &#39;\\&#39; is not found. */
<span class="line-removed">- </span>
<span class="line-removed">- static char *</span>
<span class="line-removed">- nextsep(char *start)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     char *p = start;</span>
<span class="line-removed">-     int c;</span>
<span class="line-removed">-     while ((c = *p) &amp;&amp; (c != &#39;\\&#39;)) {</span>
<span class="line-removed">-         p += ((islb(c) &amp;&amp; p[1]) ? 2 : 1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return p;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- /* Wide character version of nextsep */</span>
<span class="line-removed">- </span>
  static WCHAR *
  wnextsep(WCHAR *start)
  {
      WCHAR *p = start;
      int c;
<span class="line-new-header">--- 66,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,25 ***</span>
          p++;
      return p;
  }
  
  /* Tell whether the given string contains any wildcard characters */
<span class="line-removed">- </span>
<span class="line-removed">- static int</span>
<span class="line-removed">- wild(char *start)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     char *p = start;</span>
<span class="line-removed">-     int c;</span>
<span class="line-removed">-     while (c = *p) {</span>
<span class="line-removed">-         if ((c == &#39;*&#39;) || (c == &#39;?&#39;)) return 1;</span>
<span class="line-removed">-         p += ((islb(c) &amp;&amp; p[1]) ? 2 : 1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- /* Wide character version of wild */</span>
<span class="line-removed">- </span>
  static int
  wwild(WCHAR *start)
  {
      WCHAR *p = start;
      int c;
<span class="line-new-header">--- 79,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,29 ***</span>
     In the canonicalized form no path element may have dots at its end.
     Allowed canonical paths: c:\xa...dksd\..ksa\.lk    c:\...a\.b\cd..x.x
     Prohibited canonical paths: c:\..\x  c:\x.\d c:\...
  */
  static int
<span class="line-removed">- dots(char *start)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     char *p = start;</span>
<span class="line-removed">-     while (*p) {</span>
<span class="line-removed">-         if ((p = strchr(p, &#39;.&#39;)) == NULL) // find next occurrence of &#39;.&#39;</span>
<span class="line-removed">-             return 0; // no more dots</span>
<span class="line-removed">-         p++; // next char</span>
<span class="line-removed">-         while ((*p) == &#39;.&#39;) // go to the end of dots</span>
<span class="line-removed">-             p++;</span>
<span class="line-removed">-         if (*p &amp;&amp; (*p != &#39;\\&#39;)) // path element does not end with a dot</span>
<span class="line-removed">-             p++; // go to the next char</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             return 1; // path element does end with a dot - prohibited</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return 0; // no prohibited combinations of dots found</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- /* Wide character version of dots */</span>
<span class="line-removed">- static int</span>
  wdots(WCHAR *start)
  {
      WCHAR *p = start;
      // Skip &quot;\\.\&quot; prefix
      if (wcslen(p) &gt; 4 &amp;&amp; !wcsncmp(p, L&quot;\\\\.\\&quot;, 4))
<span class="line-new-header">--- 98,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,11 ***</span>
     because it is of the wrong type, because access is denied, or because the
     network is unreachable then canonicalization does not fail, it terminates
     successfully after copying the rest of the original path to the result path.
     Other I/O errors cause an error return.
  */
<span class="line-removed">- </span>
  int
  lastErrorReportable()
  {
      DWORD errval = GetLastError();
      if ((errval == ERROR_FILE_NOT_FOUND)
<span class="line-new-header">--- 125,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,233 ***</span>
          || (errval == ERROR_ACCESS_DENIED)
          || (errval == ERROR_NETWORK_UNREACHABLE)
          || (errval == ERROR_NETWORK_ACCESS_DENIED)) {
          return 0;
      }
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef DEBUG_PATH</span>
<span class="line-removed">-     jio_fprintf(stderr, &quot;canonicalize: errval %d\n&quot;, errval);</span>
<span class="line-removed">- #endif</span>
      return 1;
  }
  
<span class="line-removed">- int wcanonicalize(WCHAR *orig_path, WCHAR *result, int size);</span>
<span class="line-removed">- </span>
  /* Convert a pathname to canonical form.  The input orig_path is assumed to
     have been converted to native form already, via JVM_NativePath().  This is
     necessary because _fullpath() rejects duplicate separator characters on
     Win95, though it accepts them on NT. */
<span class="line-removed">- </span>
<span class="line-removed">- int</span>
<span class="line-removed">- canonicalize(char *orig_path, char *result, int size)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     WIN32_FIND_DATA fd;</span>
<span class="line-removed">-     HANDLE h;</span>
<span class="line-removed">-     char path[1024];    /* Working copy of path */</span>
<span class="line-removed">-     char *src, *dst, *dend;</span>
<span class="line-removed">-     wchar_t *worig_path, *wresult;</span>
<span class="line-removed">-     size_t converted_chars = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* handle long path with length &gt;= MAX_PATH */</span>
<span class="line-removed">-     if (strlen(orig_path) &gt;= MAX_PATH) {</span>
<span class="line-removed">-         if ((worig_path = (WCHAR*)malloc(size * sizeof(WCHAR))) == NULL)</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (mbstowcs_s(&amp;converted_chars, worig_path, (size_t)size, orig_path, (size_t)(size - 1)) != 0) {</span>
<span class="line-removed">-             free(worig_path);</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if ((wresult = (WCHAR*)malloc(size * sizeof(WCHAR))) == NULL)</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (wcanonicalize(worig_path, wresult, size) != 0) {</span>
<span class="line-removed">-             free(worig_path);</span>
<span class="line-removed">-             free(wresult);</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (wcstombs_s(&amp;converted_chars, result, (size_t)size, wresult, (size_t)(size - 1)) != 0) {</span>
<span class="line-removed">-             free(worig_path);</span>
<span class="line-removed">-             free(wresult);</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         free(worig_path);</span>
<span class="line-removed">-         free(wresult);</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Reject paths that contain wildcards */</span>
<span class="line-removed">-     if (wild(orig_path)) {</span>
<span class="line-removed">-         errno = EINVAL;</span>
<span class="line-removed">-         return -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Collapse instances of &quot;foo\..&quot; and ensure absoluteness.  Note that</span>
<span class="line-removed">-       contrary to the documentation, the _fullpath procedure does not require</span>
<span class="line-removed">-       the drive to be available.  It also does not reliably change all</span>
<span class="line-removed">-       occurrences of &#39;/&#39; to &#39;\\&#39; on Win95, so now JVM_NativePath does that. */</span>
<span class="line-removed">-     if (!_fullpath(path, orig_path, sizeof(path))) {</span>
<span class="line-removed">-         return -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Correction for Win95: _fullpath may leave a trailing &quot;\\&quot;</span>
<span class="line-removed">-       on a UNC pathname */</span>
<span class="line-removed">-     if ((path[0] == &#39;\\&#39;) &amp;&amp; (path[1] == &#39;\\&#39;)) {</span>
<span class="line-removed">-         char *p = path + strlen(path);</span>
<span class="line-removed">-         if ((p[-1] == &#39;\\&#39;) &amp;&amp; !islb(p[-2])) {</span>
<span class="line-removed">-             p[-1] = &#39;\0&#39;;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (dots(path)) /* Check for prohibited combinations of dots */</span>
<span class="line-removed">-         return -1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     src = path;            /* Start scanning here */</span>
<span class="line-removed">-     dst = result;        /* Place results here */</span>
<span class="line-removed">-     dend = dst + size;        /* Don&#39;t go to or past here */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Copy prefix, assuming path is absolute */</span>
<span class="line-removed">-     if (isalpha(src[0]) &amp;&amp; (src[1] == &#39;:&#39;) &amp;&amp; (src[2] == &#39;\\&#39;)) {</span>
<span class="line-removed">-         /* Drive specifier */</span>
<span class="line-removed">-         *src = toupper(*src);    /* Canonicalize drive letter */</span>
<span class="line-removed">-         if (!(dst = cp(dst, dend, &#39;\0&#39;, src, src + 2))) {</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         src += 2;</span>
<span class="line-removed">-     } else if ((src[0] == &#39;\\&#39;) &amp;&amp; (src[1] == &#39;\\&#39;)) {</span>
<span class="line-removed">-         /* UNC pathname */</span>
<span class="line-removed">-         char *p;</span>
<span class="line-removed">-         p = nextsep(src + 2);    /* Skip past host name */</span>
<span class="line-removed">-         if (!*p) {</span>
<span class="line-removed">-             /* A UNC pathname must begin with &quot;\\\\host\\share&quot;,</span>
<span class="line-removed">-             so reject this path as invalid if there is no share name */</span>
<span class="line-removed">-             errno = EINVAL;</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         p = nextsep(p + 1);    /* Skip past share name */</span>
<span class="line-removed">-         if (!(dst = cp(dst, dend, &#39;\0&#39;, src, p))) {</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         src = p;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         /* Invalid path */</span>
<span class="line-removed">-         errno = EINVAL;</span>
<span class="line-removed">-         return -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Windows 95/98/Me bug - FindFirstFile fails on network mounted drives */</span>
<span class="line-removed">-     /* for root pathes like &quot;E:\&quot; . If the path has this form, we should  */</span>
<span class="line-removed">-     /* simply return it, it is already canonicalized. */</span>
<span class="line-removed">-     if (strlen(path) == 3 &amp;&amp; path[1] == &#39;:&#39; &amp;&amp; path[2] == &#39;\\&#39;) {</span>
<span class="line-removed">-         /* At this point we have already copied the drive specifier (&quot;z:&quot;)*/</span>
<span class="line-removed">-         /* so we need to copy &quot;\&quot; and the null character. */</span>
<span class="line-removed">-         result[2] = &#39;\\&#39;;</span>
<span class="line-removed">-         result[3] = &#39;\0&#39;;</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* At this point we have copied either a drive specifier (&quot;z:&quot;) or a UNC</span>
<span class="line-removed">-     prefix (&quot;\\\\host\\share&quot;) to the result buffer, and src points to the</span>
<span class="line-removed">-     first byte of the remainder of the path.  We now scan through the rest</span>
<span class="line-removed">-     of the path, looking up each prefix in order to find the true name of</span>
<span class="line-removed">-     the last element of each prefix, thereby computing the full true name of</span>
<span class="line-removed">-     the original path. */</span>
<span class="line-removed">-     while (*src) {</span>
<span class="line-removed">-         char *p = nextsep(src + 1);    /* Find next separator */</span>
<span class="line-removed">-         char c = *p;</span>
<span class="line-removed">-         assert(*src == &#39;\\&#39;);        /* Invariant */</span>
<span class="line-removed">-         *p = &#39;\0&#39;;            /* Temporarily clear separator */</span>
<span class="line-removed">-         h = FindFirstFile(path, &amp;fd);    /* Look up prefix */</span>
<span class="line-removed">-         *p = c;                /* Restore separator */</span>
<span class="line-removed">-         if (h != INVALID_HANDLE_VALUE) {</span>
<span class="line-removed">-             /* Lookup succeeded; append true name to result and continue */</span>
<span class="line-removed">-             FindClose(h);</span>
<span class="line-removed">-             if (!(dst = cp(dst, dend, &#39;\\&#39;,</span>
<span class="line-removed">-                 fd.cFileName,</span>
<span class="line-removed">-                 fd.cFileName + strlen(fd.cFileName)))) {</span>
<span class="line-removed">-                 return -1;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             src = p;</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             if (!lastErrorReportable()) {</span>
<span class="line-removed">-                 if (!(dst = cp(dst, dend, &#39;\0&#39;, src, src + strlen(src)))) {</span>
<span class="line-removed">-                     return -1;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return -1;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (dst &gt;= dend) {</span>
<span class="line-removed">-         errno = ENAMETOOLONG;</span>
<span class="line-removed">-         return -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     *dst = &#39;\0&#39;;</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- /* Convert a pathname to canonical form.  The input prefix is assumed</span>
<span class="line-removed">-    to be in canonical form already, and the trailing filename must not</span>
<span class="line-removed">-    contain any wildcard, dot/double dot, or other &quot;tricky&quot; characters</span>
<span class="line-removed">-    that are rejected by the canonicalize() routine above.  This</span>
<span class="line-removed">-    routine is present to allow the canonicalization prefix cache to be</span>
<span class="line-removed">-    used while still returning canonical names with the correct</span>
<span class="line-removed">-    capitalization. */</span>
<span class="line-removed">- </span>
<span class="line-removed">- int</span>
<span class="line-removed">- canonicalizeWithPrefix(char* canonicalPrefix, char* pathWithCanonicalPrefix, char *result, int size)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     WIN32_FIND_DATA fd;</span>
<span class="line-removed">-     HANDLE h;</span>
<span class="line-removed">-     char *src, *dst, *dend;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     src = pathWithCanonicalPrefix;</span>
<span class="line-removed">-     dst = result;        /* Place results here */</span>
<span class="line-removed">-     dend = dst + size;   /* Don&#39;t go to or past here */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     h = FindFirstFile(pathWithCanonicalPrefix, &amp;fd);    /* Look up file */</span>
<span class="line-removed">-     if (h != INVALID_HANDLE_VALUE) {</span>
<span class="line-removed">-         /* Lookup succeeded; concatenate true name to prefix */</span>
<span class="line-removed">-         FindClose(h);</span>
<span class="line-removed">-         if (!(dst = cp(dst, dend, &#39;\0&#39;,</span>
<span class="line-removed">-                        canonicalPrefix,</span>
<span class="line-removed">-                        canonicalPrefix + strlen(canonicalPrefix)))) {</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!(dst = cp(dst, dend, &#39;\\&#39;,</span>
<span class="line-removed">-                        fd.cFileName,</span>
<span class="line-removed">-                        fd.cFileName + strlen(fd.cFileName)))) {</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         if (!lastErrorReportable()) {</span>
<span class="line-removed">-             if (!(dst = cp(dst, dend, &#39;\0&#39;, src, src + strlen(src)))) {</span>
<span class="line-removed">-                 return -1;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (dst &gt;= dend) {</span>
<span class="line-removed">-         errno = ENAMETOOLONG;</span>
<span class="line-removed">-         return -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     *dst = &#39;\0&#39;;</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- /* Wide character version of canonicalize. Size is a wide-character size. */</span>
<span class="line-removed">- </span>
  int
  wcanonicalize(WCHAR *orig_path, WCHAR *result, int size)
  {
      WIN32_FIND_DATAW fd;
      HANDLE h;
<span class="line-new-header">--- 139,17 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 557,13 ***</span>
   err:
      free(path);
      return -1;
  }
  
<span class="line-modified">! </span>
<span class="line-modified">! /* Wide character version of canonicalizeWithPrefix. */</span>
<span class="line-modified">! </span>
  int
  wcanonicalizeWithPrefix(WCHAR *canonicalPrefix, WCHAR *pathWithCanonicalPrefix, WCHAR *result, int size)
  {
      WIN32_FIND_DATAW fd;
      HANDLE h;
<span class="line-new-header">--- 264,17 ---</span>
   err:
      free(path);
      return -1;
  }
  
<span class="line-modified">! /* Convert a pathname to canonical form.  The input prefix is assumed</span>
<span class="line-modified">!    to be in canonical form already, and the trailing filename must not</span>
<span class="line-modified">!    contain any wildcard, dot/double dot, or other &quot;tricky&quot; characters</span>
<span class="line-added">+    that are rejected by the canonicalize() routine above.  This</span>
<span class="line-added">+    routine is present to allow the canonicalization prefix cache to be</span>
<span class="line-added">+    used while still returning canonical names with the correct</span>
<span class="line-added">+    capitalization. */</span>
  int
  wcanonicalizeWithPrefix(WCHAR *canonicalPrefix, WCHAR *pathWithCanonicalPrefix, WCHAR *result, int size)
  {
      WIN32_FIND_DATAW fd;
      HANDLE h;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,19 ***</span>
      }
      *dst = L&#39;\0&#39;;
      return 0;
  }
  
  
<span class="line-modified">! /* The appropriate location of getPrefixed() should be io_util_md.c, but</span>
<span class="line-modified">!    java.lang.instrument package has hardwired canonicalize_md.c into their</span>
<span class="line-modified">!    dll, to avoid complicate solution such as including io_util_md.c into</span>
<span class="line-modified">!    that package, as a workaround we put this method here.</span>
   */
  
<span class="line-modified">! /* copy \\?\ or \\?\UNC\ to the front of path*/</span>
<span class="line-modified">! __declspec(dllexport) WCHAR*</span>
  getPrefixed(const WCHAR* path, int pathlen) {
      WCHAR* pathbuf = (WCHAR*)malloc((pathlen + 10) * sizeof (WCHAR));
      if (pathbuf != 0) {
          if (path[0] == L&#39;\\&#39; &amp;&amp; path[1] == L&#39;\\&#39;) {
              if (path[2] == L&#39;?&#39; &amp;&amp; path[3] == L&#39;\\&#39;){
<span class="line-new-header">--- 322,58 ---</span>
      }
      *dst = L&#39;\0&#39;;
      return 0;
  }
  
<span class="line-added">+ /* Non-Wide character version of canonicalize.</span>
<span class="line-added">+    Converts to wchar and delegates to wcanonicalize. */</span>
<span class="line-added">+ JNIEXPORT int</span>
<span class="line-added">+ JDK_Canonicalize(const char *orig, char *out, int len) {</span>
<span class="line-added">+     wchar_t* wpath = NULL;</span>
<span class="line-added">+     wchar_t* wresult = NULL;</span>
<span class="line-added">+     size_t conv;</span>
<span class="line-added">+     size_t path_len = strlen(orig);</span>
<span class="line-added">+     int ret = -1;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if ((wpath = (wchar_t*) malloc(sizeof(wchar_t) * (path_len + 1))) == NULL) {</span>
<span class="line-added">+         goto finish;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (mbstowcs_s(&amp;conv, wpath, path_len + 1, orig, path_len) != 0) {</span>
<span class="line-added">+         goto finish;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if ((wresult = (wchar_t*) malloc(sizeof(wchar_t) * len)) == NULL) {</span>
<span class="line-added">+         goto finish;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (wcanonicalize(wpath, wresult, len) != 0) {</span>
<span class="line-added">+         goto finish;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (wcstombs_s(&amp;conv, out, (size_t) len, wresult, (size_t) (len - 1)) != 0) {</span>
<span class="line-added">+         goto finish;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Change return value to success.</span>
<span class="line-added">+     ret = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ finish:</span>
<span class="line-added">+     free(wresult);</span>
<span class="line-added">+     free(wpath);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ret;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! /* The appropriate location of getPrefixed() is io_util_md.c, but it is</span>
<span class="line-modified">!    also used in a non-OpenJDK context within Oracle. There, canonicalize_md.c</span>
<span class="line-modified">!    is already pulled in and compiled, so to avoid more complicated solutions</span>
<span class="line-modified">!    we keep this method here.</span>
   */
  
<span class="line-modified">! /* copy \\?\ or \\?\UNC\ to the front of path */</span>
<span class="line-modified">! JNIEXPORT WCHAR*</span>
  getPrefixed(const WCHAR* path, int pathlen) {
      WCHAR* pathbuf = (WCHAR*)malloc((pathlen + 10) * sizeof (WCHAR));
      if (pathbuf != 0) {
          if (path[0] == L&#39;\\&#39; &amp;&amp; path[1] == L&#39;\\&#39;) {
              if (path[2] == L&#39;?&#39; &amp;&amp; path[3] == L&#39;\\&#39;){
</pre>
<center><a href="HostLocaleProviderAdapter_md.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="io_util_md.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
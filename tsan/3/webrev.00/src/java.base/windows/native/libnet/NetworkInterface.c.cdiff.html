<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/windows/native/libnet/NetworkInterface.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="NTLMAuthentication.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NetworkInterface_winXP.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnet/NetworkInterface.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,11 ---</span>
   * questions.
   */
  #include &quot;net_util.h&quot;
  #include &quot;NetworkInterface.h&quot;
  
<span class="line-added">+ #include &quot;java_net_InetAddress.h&quot;</span>
  #include &quot;java_net_NetworkInterface.h&quot;
  
  /*
   * Windows implementation of the java.net.NetworkInterface native methods.
   * This module provides the implementations of getAll, getByName, getByIndex,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,36 ***</span>
      }
  
      /*
       * Free the interface table and return the interface list
       */
<span class="line-modified">!     if (tableP) {</span>
          free(tableP);
      }
      *netifPP = netifP;
      return count;
  }
  
  /*
<span class="line-modified">!  * Enumerate the IP addresses on an interface using the IP helper library</span>
<span class="line-removed">-  * routine GetIfAddrTable and matching based on the index name. There are</span>
<span class="line-removed">-  * more efficient routines but we use GetIfAddrTable because it&#39;s avaliable</span>
<span class="line-removed">-  * on 98 and NT.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Returns the count of addresses, or -1 if error. If no error occurs then</span>
<span class="line-removed">-  * netaddrPP will return a list of netaddr structures with the IP addresses.</span>
   */
<span class="line-modified">! int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP)</span>
  {
      MIB_IPADDRTABLE *tableP;
      ULONG size;
      DWORD ret;
<span class="line-removed">-     DWORD i;</span>
<span class="line-removed">-     netaddr *netaddrP;</span>
<span class="line-removed">-     int count = 0;</span>
<span class="line-removed">-     unsigned long mask;</span>
<span class="line-removed">- </span>
      /*
       * Use GetIpAddrTable to enumerate the IP Addresses
       */
      size = sizeof(MIB_IPADDRTABLE);
      tableP = (MIB_IPADDRTABLE *)malloc(size);
<span class="line-new-header">--- 346,25 ---</span>
      }
  
      /*
       * Free the interface table and return the interface list
       */
<span class="line-modified">!     if (tableP != NULL) {</span>
          free(tableP);
      }
      *netifPP = netifP;
      return count;
  }
  
  /*
<span class="line-modified">!  * Enumerate all addresses using the IP helper library</span>
   */
<span class="line-modified">! int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP)</span>
  {
      MIB_IPADDRTABLE *tableP;
      ULONG size;
      DWORD ret;
      /*
       * Use GetIpAddrTable to enumerate the IP Addresses
       */
      size = sizeof(MIB_IPADDRTABLE);
      tableP = (MIB_IPADDRTABLE *)malloc(size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 394,29 ***</span>
          tableP = newTableP;
  
          ret = GetIpAddrTable(tableP, &amp;size, FALSE);
      }
      if (ret != NO_ERROR) {
<span class="line-modified">!         if (tableP) {</span>
              free(tableP);
          }
          JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
                  &quot;IP Helper Library GetIpAddrTable function failed&quot;);
          // this different error code is to handle the case when we call
          // GetIpAddrTable in pure IPv6 environment
          return -2;
      }
  
      /*
       * Iterate through the table to find the addresses with the
       * matching dwIndex. Ignore 0.0.0.0 addresses.
       */
      count = 0;
      netaddrP = NULL;
  
      i = 0;
<span class="line-modified">!     while (i&lt;tableP-&gt;dwNumEntries) {</span>
          if (tableP-&gt;table[i].dwIndex == netifP-&gt;dwIndex &amp;&amp;
              tableP-&gt;table[i].dwAddr != 0) {
  
              netaddr *curr = (netaddr *)malloc(sizeof(netaddr));
              if (curr == NULL) {
<span class="line-new-header">--- 384,48 ---</span>
          tableP = newTableP;
  
          ret = GetIpAddrTable(tableP, &amp;size, FALSE);
      }
      if (ret != NO_ERROR) {
<span class="line-modified">!         if (tableP != NULL) {</span>
              free(tableP);
          }
          JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
                  &quot;IP Helper Library GetIpAddrTable function failed&quot;);
          // this different error code is to handle the case when we call
          // GetIpAddrTable in pure IPv6 environment
          return -2;
      }
<span class="line-added">+     *tablePP = tableP;</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * Enumerate the IP addresses on an interface, given an IP address table</span>
<span class="line-added">+  * and matching based on index.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returns the count of addresses, or -1 if error. If no error occurs then</span>
<span class="line-added">+  * netaddrPP will return a list of netaddr structures with the IP addresses.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DWORD i;</span>
<span class="line-added">+     netaddr *netaddrP;</span>
<span class="line-added">+     int count = 0;</span>
<span class="line-added">+     unsigned long mask;</span>
  
      /*
       * Iterate through the table to find the addresses with the
       * matching dwIndex. Ignore 0.0.0.0 addresses.
       */
<span class="line-added">+     if (tableP == NULL)</span>
<span class="line-added">+         return 0;</span>
      count = 0;
      netaddrP = NULL;
  
      i = 0;
<span class="line-modified">!     while (i &lt; tableP-&gt;dwNumEntries) {</span>
          if (tableP-&gt;table[i].dwIndex == netifP-&gt;dwIndex &amp;&amp;
              tableP-&gt;table[i].dwAddr != 0) {
  
              netaddr *curr = (netaddr *)malloc(sizeof(netaddr));
              if (curr == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 435,51 ***</span>
              case MIB_IF_TYPE_ETHERNET:
              case MIB_IF_TYPE_TOKENRING:
              case MIB_IF_TYPE_FDDI:
              case MIB_IF_TYPE_LOOPBACK:
              case IF_TYPE_IEEE80211:
<span class="line-modified">!               /**</span>
<span class="line-modified">!                * Contrary to what it seems to indicate, dwBCastAddr doesn&#39;t</span>
<span class="line-modified">!                * contain the broadcast address but 0 or 1 depending on whether</span>
<span class="line-modified">!                * the broadcast address should set the bits of the host part</span>
<span class="line-modified">!                * to 0 or 1.</span>
<span class="line-modified">!                * Yes, I know it&#39;s stupid, but what can I say, it&#39;s MSFTs API.</span>
<span class="line-modified">!                */</span>
<span class="line-modified">!               curr-&gt;brdcast.sa4.sin_family = AF_INET;</span>
<span class="line-modified">!               if (tableP-&gt;table[i].dwBCastAddr == 1)</span>
<span class="line-modified">!                 curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask) | (0xffffffff ^ tableP-&gt;table[i].dwMask);</span>
<span class="line-modified">!               else</span>
<span class="line-modified">!                 curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask);</span>
<span class="line-modified">!               mask = ntohl(tableP-&gt;table[i].dwMask);</span>
<span class="line-modified">!               curr-&gt;mask = 0;</span>
<span class="line-modified">!               while (mask) {</span>
<span class="line-modified">!                 mask &lt;&lt;= 1;</span>
<span class="line-modified">!                 curr-&gt;mask++;</span>
<span class="line-modified">!               }</span>
<span class="line-modified">!               break;</span>
              case MIB_IF_TYPE_PPP:
              case MIB_IF_TYPE_SLIP:
              default:
<span class="line-modified">!               /**</span>
<span class="line-modified">!                * these don&#39;t have broadcast/subnet</span>
<span class="line-modified">!                */</span>
<span class="line-modified">!               curr-&gt;mask = -1;</span>
<span class="line-modified">!                 break;</span>
              }
  
              curr-&gt;next = netaddrP;
              netaddrP = curr;
              count++;
          }
          i++;
      }
  
      *netaddrPP = netaddrP;
      free(tableP);
      return count;
  }
  
  /*
   * Class:     java_net_NetworkInterface
   * Method:    init
   * Signature: ()V
   */
<span class="line-new-header">--- 444,71 ---</span>
              case MIB_IF_TYPE_ETHERNET:
              case MIB_IF_TYPE_TOKENRING:
              case MIB_IF_TYPE_FDDI:
              case MIB_IF_TYPE_LOOPBACK:
              case IF_TYPE_IEEE80211:
<span class="line-modified">!                 /**</span>
<span class="line-modified">!                  * Contrary to what it seems to indicate, dwBCastAddr doesn&#39;t</span>
<span class="line-modified">!                  * contain the broadcast address but 0 or 1 depending on whether</span>
<span class="line-modified">!                  * the broadcast address should set the bits of the host part</span>
<span class="line-modified">!                  * to 0 or 1.</span>
<span class="line-modified">!                  * Yes, I know it&#39;s stupid, but what can I say, it&#39;s MSFTs API.</span>
<span class="line-modified">!                  */</span>
<span class="line-modified">!                 curr-&gt;brdcast.sa4.sin_family = AF_INET;</span>
<span class="line-modified">!                 if (tableP-&gt;table[i].dwBCastAddr == 1)</span>
<span class="line-modified">!                     curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask) | (0xffffffff ^ tableP-&gt;table[i].dwMask);</span>
<span class="line-modified">!                 else</span>
<span class="line-modified">!                     curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask);</span>
<span class="line-modified">!                 mask = ntohl(tableP-&gt;table[i].dwMask);</span>
<span class="line-modified">!                 curr-&gt;mask = 0;</span>
<span class="line-modified">!                 while (mask) {</span>
<span class="line-modified">!                     mask &lt;&lt;= 1;</span>
<span class="line-modified">!                     curr-&gt;mask++;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 break;</span>
              case MIB_IF_TYPE_PPP:
              case MIB_IF_TYPE_SLIP:
              default:
<span class="line-modified">!                 /**</span>
<span class="line-modified">!                  * these don&#39;t have broadcast/subnet</span>
<span class="line-modified">!                  */</span>
<span class="line-modified">!                 curr-&gt;mask = -1;</span>
<span class="line-modified">!                     break;</span>
              }
  
              curr-&gt;next = netaddrP;
              netaddrP = curr;
              count++;
          }
          i++;
      }
  
      *netaddrPP = netaddrP;
<span class="line-added">+     return count;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * Enumerate the IP addresses on an interface, using an IP address table</span>
<span class="line-added">+  * retrieved using GetIPAddrTable and matching based on index.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returns the count of addresses, or -1 if error. If no error occurs then</span>
<span class="line-added">+  * netaddrPP will return a list of netaddr structures with the IP addresses.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP) {</span>
<span class="line-added">+     MIB_IPADDRTABLE *tableP;</span>
<span class="line-added">+     int count;</span>
<span class="line-added">+     int ret = lookupIPAddrTable(env, &amp;tableP);</span>
<span class="line-added">+     if (ret &lt; 0) {</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     count = enumAddresses_win_ipaddrtable(env, netifP, netaddrPP, tableP);</span>
      free(tableP);
      return count;
  }
  
<span class="line-added">+ </span>
  /*
   * Class:     java_net_NetworkInterface
   * Method:    init
   * Signature: ()V
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 756,24 ***</span>
      free_netif(ifList);
  
      return netifObj;
  }
  
  /*
   * Class:     java_net_NetworkInterface
   * Method:    getByInetAddress0
   * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;
   */
  JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0
      (JNIEnv *env, jclass cls, jobject iaObj)
  {
      netif *ifList, *curr;
      jobject netifObj = NULL;
      jint addr = getInetAddress_addr(env, iaObj);
      JNU_CHECK_EXCEPTION_RETURN(env, NULL);
  
<span class="line-removed">-     // Retained for now to support IPv4 only stack, java.net.preferIPv4Stack</span>
      if (ipv6_available()) {
          return Java_java_net_NetworkInterface_getByInetAddress0_XP (env, cls, iaObj);
      }
  
      /* get the list of interfaces */
<span class="line-new-header">--- 785,68 ---</span>
      free_netif(ifList);
  
      return netifObj;
  }
  
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * Class:     java_net_NetworkInterface</span>
<span class="line-added">+  * Method:    boundInetAddress0</span>
<span class="line-added">+  * Signature: (Ljava/net/InetAddress;)Z</span>
<span class="line-added">+  */</span>
<span class="line-added">+ JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0</span>
<span class="line-added">+     (JNIEnv *env, jclass cls, jobject iaObj)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     jobject netifObj = NULL;</span>
<span class="line-added">+     DWORD i;</span>
<span class="line-added">+ </span>
<span class="line-added">+     int family = getInetAddress_family(env, iaObj);</span>
<span class="line-added">+     JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (family == java_net_InetAddress_IPv6) {</span>
<span class="line-added">+         if (!ipv6_available())</span>
<span class="line-added">+             return JNI_FALSE;</span>
<span class="line-added">+         return Java_java_net_NetworkInterface_getByInetAddress0_XP(env, cls, iaObj) != NULL;</span>
<span class="line-added">+     } else if (family == java_net_InetAddress_IPv4) {</span>
<span class="line-added">+         jint addr = getInetAddress_addr(env, iaObj);</span>
<span class="line-added">+         JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);</span>
<span class="line-added">+ </span>
<span class="line-added">+         jboolean found = JNI_FALSE;</span>
<span class="line-added">+         MIB_IPADDRTABLE *tableP;</span>
<span class="line-added">+         if (lookupIPAddrTable(env, &amp;tableP) &gt;= 0 &amp;&amp; tableP != NULL) {</span>
<span class="line-added">+             for (i = 0; i &lt; tableP-&gt;dwNumEntries; i++) {</span>
<span class="line-added">+                 if (tableP-&gt;table[i].dwAddr != 0 &amp;&amp;</span>
<span class="line-added">+                     (unsigned long)addr == ntohl(tableP-&gt;table[i].dwAddr)) {</span>
<span class="line-added">+                     found = JNI_TRUE;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (tableP != NULL) {</span>
<span class="line-added">+           free(tableP);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return found;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       // Unknown address family</span>
<span class="line-added">+       return JNI_FALSE;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /*
   * Class:     java_net_NetworkInterface
   * Method:    getByInetAddress0
   * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;
   */
  JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0
      (JNIEnv *env, jclass cls, jobject iaObj)
  {
      netif *ifList, *curr;
<span class="line-added">+     MIB_IPADDRTABLE *tableP;</span>
      jobject netifObj = NULL;
      jint addr = getInetAddress_addr(env, iaObj);
      JNU_CHECK_EXCEPTION_RETURN(env, NULL);
  
      if (ipv6_available()) {
          return Java_java_net_NetworkInterface_getByInetAddress0_XP (env, cls, iaObj);
      }
  
      /* get the list of interfaces */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 783,47 ***</span>
  
      /*
       * Enumerate the addresses on each interface until we find a
       * matching address.
       */
<span class="line-modified">!     curr = ifList;</span>
<span class="line-modified">!     while (curr != NULL) {</span>
<span class="line-modified">!         int count;</span>
<span class="line-modified">!         netaddr *addrList;</span>
<span class="line-modified">!         netaddr *addrP;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /* enumerate the addresses on this interface */</span>
<span class="line-modified">!         count = enumAddresses_win(env, curr, &amp;addrList);</span>
<span class="line-modified">!         if (count &lt; 0) {</span>
<span class="line-modified">!             free_netif(ifList);</span>
<span class="line-modified">!             return NULL;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         /* iterate through each address */</span>
<span class="line-modified">!         addrP = addrList;</span>
  
<span class="line-modified">!         while (addrP != NULL) {</span>
<span class="line-modified">!             if ((unsigned long)addr == ntohl(addrP-&gt;addr.sa4.sin_addr.s_addr)) {</span>
                  break;
              }
<span class="line-removed">-             addrP = addrP-&gt;next;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         /*</span>
<span class="line-modified">!          * Address matched so create NetworkInterface for this interface</span>
<span class="line-removed">-          * and address list.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         if (addrP != NULL) {</span>
<span class="line-removed">-             /* createNetworkInterface will free addrList */</span>
<span class="line-removed">-             netifObj = createNetworkInterface(env, curr, count, addrList);</span>
<span class="line-removed">-             break;</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         /* on next interface */</span>
<span class="line-removed">-         curr = curr-&gt;next;</span>
      }
  
      /* release the interface list */
      free_netif(ifList);
  
      return netifObj;
  }
<span class="line-new-header">--- 856,55 ---</span>
  
      /*
       * Enumerate the addresses on each interface until we find a
       * matching address.
       */
<span class="line-modified">!     tableP = NULL;</span>
<span class="line-modified">!     if (lookupIPAddrTable(env, &amp;tableP) &gt;= 0) {</span>
<span class="line-modified">!         curr = ifList;</span>
<span class="line-modified">!         while (curr != NULL) {</span>
<span class="line-modified">!             int count;</span>
<span class="line-modified">!             netaddr *addrList;</span>
<span class="line-modified">!             netaddr *addrP;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             /* enumerate the addresses on this interface */</span>
<span class="line-modified">!             count = enumAddresses_win_ipaddrtable(env, curr, &amp;addrList, tableP);</span>
<span class="line-modified">!             if (count &lt; 0) {</span>
<span class="line-modified">!                 free_netif(ifList);</span>
<span class="line-added">+                 free(tableP);</span>
<span class="line-added">+                 return NULL;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             /* iterate through each address */</span>
<span class="line-modified">!             addrP = addrList;</span>
  
<span class="line-modified">!             while (addrP != NULL) {</span>
<span class="line-modified">!                 if ((unsigned long)addr == ntohl(addrP-&gt;addr.sa4.sin_addr.s_addr)) {</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 addrP = addrP-&gt;next;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             /*</span>
<span class="line-added">+              * Address matched so create NetworkInterface for this interface</span>
<span class="line-added">+              * and address list.</span>
<span class="line-added">+              */</span>
<span class="line-added">+             if (addrP != NULL) {</span>
<span class="line-added">+                 /* createNetworkInterface will free addrList */</span>
<span class="line-added">+                 netifObj = createNetworkInterface(env, curr, count, addrList);</span>
                  break;
              }
  
<span class="line-modified">!             /* on next interface */</span>
<span class="line-modified">!             curr = curr-&gt;next;</span>
          }
      }
  
<span class="line-added">+     /* release the IP address table */</span>
<span class="line-added">+     if (tableP != NULL)</span>
<span class="line-added">+         free(tableP);</span>
<span class="line-added">+ </span>
      /* release the interface list */
      free_netif(ifList);
  
      return netifObj;
  }
</pre>
<center><a href="NTLMAuthentication.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NetworkInterface_winXP.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libnet/Inet4AddressImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../libjli/java_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NTLMAuthentication.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnet/Inet4AddressImpl.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
342                                 // seem to have an undocumented minimum
343                                 // timeout of 1000ms below which the
344                                 // api behaves inconsistently.
345                                 (timeout &lt; 1000) ? 1000 : timeout); // DWORD Timeout
346     } else {
347         dwRetVal = IcmpSendEcho2Ex(hIcmpFile,  // HANDLE IcmpHandle,
348                                    NULL,       // HANDLE Event
349                                    NULL,       // PIO_APC_ROUTINE ApcRoutine
350                                    NULL,       // ApcContext
351                                    netif-&gt;sa4.sin_addr.s_addr, // IPAddr SourceAddress,
352                                    sa-&gt;sa4.sin_addr.s_addr, // IPAddr DestinationAddress,
353                                    SendData,   // LPVOID RequestData,
354                                    sizeof(SendData), // WORD RequestSize,
355                                    NULL,       // PIP_OPTION_INFORMATION RequestOptions,
356                                    ReplyBuffer,// LPVOID ReplyBuffer,
357                                    ReplySize,  // DWORD ReplySize,
358                                    (timeout &lt; 1000) ? 1000 : timeout); // DWORD Timeout
359     }
360 
361     if (dwRetVal == 0) { // if the call failed
<span class="line-modified">362         TCHAR *buf;</span>

363         DWORD err = WSAGetLastError();
364         switch (err) {
365             case ERROR_NO_NETWORK:
366             case ERROR_NETWORK_UNREACHABLE:
367             case ERROR_HOST_UNREACHABLE:
368             case ERROR_PROTOCOL_UNREACHABLE:
369             case ERROR_PORT_UNREACHABLE:
370             case ERROR_REQUEST_ABORTED:
371             case ERROR_INCORRECT_ADDRESS:
372             case ERROR_HOST_DOWN:
373             case ERROR_INVALID_COMPUTERNAME:
374             case ERROR_INVALID_NETNAME:
375             case WSAEHOSTUNREACH:   /* Host Unreachable */
376             case WSAENETUNREACH:    /* Network Unreachable */
377             case WSAENETDOWN:       /* Network is down */
378             case WSAEPFNOSUPPORT:   /* Protocol Family unsupported */
379             case IP_REQ_TIMED_OUT:
380                 break;
381             default:
<span class="line-modified">382                 FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,</span>
<span class="line-modified">383                               NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),</span>
<span class="line-modified">384                               (LPTSTR)&amp;buf, 0, NULL);</span>








385                 NET_ThrowNew(env, err, buf);
386                 LocalFree(buf);
387                 break;
388         }
389     } else {
390         PICMP_ECHO_REPLY pEchoReply = (PICMP_ECHO_REPLY)ReplyBuffer;
391 
392         // This is to take into account the undocumented minimum
393         // timeout mentioned in the IcmpSendEcho call above.
394         // We perform an extra check to make sure that our
395         // roundtrip time was less than our desired timeout
396         // for cases where that timeout is &lt; 1000ms.
397         if (pEchoReply-&gt;Status == IP_SUCCESS &amp;&amp;
398             (int)pEchoReply-&gt;RoundTripTime &lt;= timeout)
399         {
400             ret = JNI_TRUE;
401         }
402     }
403 
404     free(ReplyBuffer);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
342                                 // seem to have an undocumented minimum
343                                 // timeout of 1000ms below which the
344                                 // api behaves inconsistently.
345                                 (timeout &lt; 1000) ? 1000 : timeout); // DWORD Timeout
346     } else {
347         dwRetVal = IcmpSendEcho2Ex(hIcmpFile,  // HANDLE IcmpHandle,
348                                    NULL,       // HANDLE Event
349                                    NULL,       // PIO_APC_ROUTINE ApcRoutine
350                                    NULL,       // ApcContext
351                                    netif-&gt;sa4.sin_addr.s_addr, // IPAddr SourceAddress,
352                                    sa-&gt;sa4.sin_addr.s_addr, // IPAddr DestinationAddress,
353                                    SendData,   // LPVOID RequestData,
354                                    sizeof(SendData), // WORD RequestSize,
355                                    NULL,       // PIP_OPTION_INFORMATION RequestOptions,
356                                    ReplyBuffer,// LPVOID ReplyBuffer,
357                                    ReplySize,  // DWORD ReplySize,
358                                    (timeout &lt; 1000) ? 1000 : timeout); // DWORD Timeout
359     }
360 
361     if (dwRetVal == 0) { // if the call failed
<span class="line-modified">362         TCHAR *buf = NULL;</span>
<span class="line-added">363         DWORD n;</span>
364         DWORD err = WSAGetLastError();
365         switch (err) {
366             case ERROR_NO_NETWORK:
367             case ERROR_NETWORK_UNREACHABLE:
368             case ERROR_HOST_UNREACHABLE:
369             case ERROR_PROTOCOL_UNREACHABLE:
370             case ERROR_PORT_UNREACHABLE:
371             case ERROR_REQUEST_ABORTED:
372             case ERROR_INCORRECT_ADDRESS:
373             case ERROR_HOST_DOWN:
374             case ERROR_INVALID_COMPUTERNAME:
375             case ERROR_INVALID_NETNAME:
376             case WSAEHOSTUNREACH:   /* Host Unreachable */
377             case WSAENETUNREACH:    /* Network Unreachable */
378             case WSAENETDOWN:       /* Network is down */
379             case WSAEPFNOSUPPORT:   /* Protocol Family unsupported */
380             case IP_REQ_TIMED_OUT:
381                 break;
382             default:
<span class="line-modified">383                 n = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |</span>
<span class="line-modified">384                         FORMAT_MESSAGE_FROM_SYSTEM,</span>
<span class="line-modified">385                         NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),</span>
<span class="line-added">386                         (LPTSTR)&amp;buf, 0, NULL);</span>
<span class="line-added">387                 if (n &gt; 3) {</span>
<span class="line-added">388                     // Drop final &#39;.&#39;, CR, LF</span>
<span class="line-added">389                     if (buf[n - 1] == TEXT(&#39;\n&#39;)) n--;</span>
<span class="line-added">390                     if (buf[n - 1] == TEXT(&#39;\r&#39;)) n--;</span>
<span class="line-added">391                     if (buf[n - 1] == TEXT(&#39;.&#39;)) n--;</span>
<span class="line-added">392                     buf[n] = TEXT(&#39;\0&#39;);</span>
<span class="line-added">393                 }</span>
394                 NET_ThrowNew(env, err, buf);
395                 LocalFree(buf);
396                 break;
397         }
398     } else {
399         PICMP_ECHO_REPLY pEchoReply = (PICMP_ECHO_REPLY)ReplyBuffer;
400 
401         // This is to take into account the undocumented minimum
402         // timeout mentioned in the IcmpSendEcho call above.
403         // We perform an extra check to make sure that our
404         // roundtrip time was less than our desired timeout
405         // for cases where that timeout is &lt; 1000ms.
406         if (pEchoReply-&gt;Status == IP_SUCCESS &amp;&amp;
407             (int)pEchoReply-&gt;RoundTripTime &lt;= timeout)
408         {
409             ret = JNI_TRUE;
410         }
411     }
412 
413     free(ReplyBuffer);
</pre>
</td>
</tr>
</table>
<center><a href="../libjli/java_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NTLMAuthentication.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
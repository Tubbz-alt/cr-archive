<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libnet/NetworkInterface_winXP.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="NetworkInterface.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ResolverConfigurationImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnet/NetworkInterface_winXP.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 #include &quot;net_util.h&quot;
 26 #include &quot;NetworkInterface.h&quot;
 27 
 28 #include &quot;java_net_NetworkInterface.h&quot;
 29 
 30 /*
 31  * Windows implementation of the java.net.NetworkInterface native methods.
 32  * This module provides the implementations of getAll, getByName, getByIndex,
 33  * and getByAddress.
 34  */
 35 

 36 extern int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP);

 37 int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP);
 38 
 39 #ifdef DEBUG
 40 void printnif (netif *nif) {
 41 #ifdef _WIN64
 42         printf (&quot;nif:0x%I64x name:%s\n&quot;, (UINT_PTR)nif, nif-&gt;name);
 43 #else
<span class="line-modified"> 44         printf (&quot;nif:0x%x name:%s\n&quot;, nif, nif-&gt;name);</span>
 45 #endif
 46         if (nif-&gt;dNameIsUnicode) {
 47             printf (&quot;dName:%S index:%d &quot;, (unsigned short *)nif-&gt;displayName,
 48                 nif-&gt;index);
 49         } else {
 50             printf (&quot;dName:%s index:%d &quot;, nif-&gt;displayName, nif-&gt;index);
 51         }
 52         printf (&quot;naddrs:%d\n&quot;, nif-&gt;naddrs);
 53 }
 54 
 55 void printnifs (netif *netifPP, char *str) {
 56     netif *nif;
 57     printf (&quot;%s\n&quot;, str);
 58     for (nif=netifPP; nif!=NULL; nif=nif-&gt;next) {
 59         printnif (nif);
 60     }
 61     printf(&quot;-----------------\n&quot;);
 62 }
 63 
 64 #endif
 65 
 66 const ULONG BUFF_SIZE = 15360;
 67 const int MAX_TRIES = 3;
 68 
 69 /*
 70  * return an array of IP_ADAPTER_ADDRESSES containing one element
 71  * for each adapter on the system. Returned in *adapters.
 72  * Buffer is malloc&#39;d and must be freed (unless error returned)
 73  */
<span class="line-modified"> 74 static int getAdapters (JNIEnv *env, IP_ADAPTER_ADDRESSES **adapters) {</span>
<span class="line-modified"> 75     DWORD ret, flags;</span>
 76     IP_ADAPTER_ADDRESSES *adapterInfo;
 77     ULONG len;
 78     int try;
 79 
 80     adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);
 81     if (adapterInfo == NULL) {
 82         JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;,
 83             &quot;Native heap allocation failure&quot;);
 84         return -1;
 85     }
 86 
 87     len = BUFF_SIZE;
<span class="line-removed"> 88     flags = GAA_FLAG_SKIP_DNS_SERVER;</span>
<span class="line-removed"> 89     flags |= GAA_FLAG_SKIP_MULTICAST;</span>
<span class="line-removed"> 90     flags |= GAA_FLAG_INCLUDE_PREFIX;</span>
 91     ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &amp;len);
 92 
 93     for (try = 0; ret == ERROR_BUFFER_OVERFLOW &amp;&amp; try &lt; MAX_TRIES; ++try) {
 94         IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;
 95         if (len &lt; (ULONG_MAX - BUFF_SIZE)) {
 96             len += BUFF_SIZE;
 97         }
 98         newAdapterInfo =
 99             (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);
100         if (newAdapterInfo == NULL) {
101             free(adapterInfo);
102             JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;,
103                 &quot;Native heap allocation failure&quot;);
104             return -1;
105         }
106 
107         adapterInfo = newAdapterInfo;
108 
109         ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &amp;len);
110     }
</pre>
<hr />
<pre>
221             return NULL;
222         }
223 
224         //copy the memory and break out of the while loop.
225         memcpy(ret, ptr, sizeof(IP_ADAPTER_ADDRESSES));
226         break;
227 
228       }
229       ptr=ptr-&gt;Next;
230     }
231     free(adapterInfo);
232     return ret;
233 }
234 
235 static int ipinflen = 2048;
236 
237 /*
238  */
239 int getAllInterfacesAndAddresses (JNIEnv *env, netif **netifPP)
240 {
<span class="line-modified">241     DWORD ret;</span>

242     IP_ADAPTER_ADDRESSES *ptr, *adapters=NULL;
243     ULONG len=ipinflen, count=0;
244     netif *nif=NULL, *dup_nif, *last=NULL, *loopif=NULL, *curr;
245     int tun=0, net=0;
246 
247     *netifPP = NULL;
248    /*
249     * Get the IPv4 interfaces. This information is the same
250     * as what previous JDK versions would return.
251     */
252 
253     ret = enumInterfaces(env, netifPP);
254     if (ret == -1) {
255         return -1;
256     } else if( ret == -2){
257         if ((*env)-&gt;ExceptionCheck(env)) {
258             (*env)-&gt;ExceptionClear(env);
259         }
260     } else {
261         count = ret;
262     }
263 
264     /* locate the loopback (and the last) interface */
265     for (nif=*netifPP, last=nif; nif!=NULL; nif=nif-&gt;next) {
266         if (nif-&gt;ifType == MIB_IF_TYPE_LOOPBACK) {
267             loopif = nif;
268         }
269         last = nif;
270     }
271 
272     // Retrieve IPv4 addresses with the IP Helper API
273     curr = *netifPP;




274     while (curr != NULL) {
275         netaddr *netaddrP;
<span class="line-modified">276         ret = enumAddresses_win(env, curr, &amp;netaddrP);</span>
277         if (ret == -1) {

278             return -1;
279         } else if (ret == -2) {
280             if ((*env)-&gt;ExceptionCheck(env)) {
281                 (*env)-&gt;ExceptionClear(env);
282             }
283             break;
284         } else{
285             curr-&gt;addrs = netaddrP;
286             curr-&gt;naddrs += ret;
287             curr = curr-&gt;next;
288         }
289     }

290 
<span class="line-modified">291     ret = getAdapters (env, &amp;adapters);</span>



292     if (ret != ERROR_SUCCESS) {
293         goto err;
294     }
295 
296     /* Now get the IPv6 information. This includes:
297      *  (a)  IPv6 information associated with interfaces already found
298      *  (b)  IPv6 information for IPv6 only interfaces (probably tunnels)
299      *
300      * For compatibility with previous releases we use the naming
301      * information gotten from enumInterfaces() for (a) entries
302      * However, the index numbers are taken from the new API.
303      *
304      * The procedure is to go through the list of adapters returned
305      * by the new API looking for entries that correspond to IPv4 interfaces
306      * already found.
307      */
308 
309     ptr = adapters;
310     while (ptr != NULL) {
311         int c;
312         netif *nif0;
313         if (ptr-&gt;IfType == IF_TYPE_SOFTWARE_LOOPBACK &amp;&amp; (loopif != NULL)) {
314             c = getAddrsFromAdapter(ptr, &amp;loopif-&gt;addrs);
315             if (c == -1) {
316                 goto err;
317             }
318             loopif-&gt;naddrs += c;

319         } else {
320             int index = ptr-&gt;IfIndex;
321             if (index != 0) {
322                 /* This entry is associated with an IPv4 interface */
323                 for (nif=*netifPP; nif!=NULL; nif=nif-&gt;next) {
324                     if (nif-&gt;index == index) {
325                         /* found the interface entry
326                          * set the index to the IPv6 index and add the
327                          * IPv6 addresses
328                          */
329                         nif-&gt;ipv6Index = ptr-&gt;Ipv6IfIndex;
330                         c = getAddrsFromAdapter(ptr, &amp;nif-&gt;addrs);
331                         nif-&gt;naddrs += c;
332                         break;
333                     }
334                 }
335             } else {
336                 /* This entry is IPv6 only */
337                 char newname [128];
338                 int c;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 #include &quot;net_util.h&quot;
 26 #include &quot;NetworkInterface.h&quot;
 27 
 28 #include &quot;java_net_NetworkInterface.h&quot;
 29 
 30 /*
 31  * Windows implementation of the java.net.NetworkInterface native methods.
 32  * This module provides the implementations of getAll, getByName, getByIndex,
 33  * and getByAddress.
 34  */
 35 
<span class="line-added"> 36 extern int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP);</span>
 37 extern int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP);
<span class="line-added"> 38 extern int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP);</span>
 39 int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP);
 40 
 41 #ifdef DEBUG
 42 void printnif (netif *nif) {
 43 #ifdef _WIN64
 44         printf (&quot;nif:0x%I64x name:%s\n&quot;, (UINT_PTR)nif, nif-&gt;name);
 45 #else
<span class="line-modified"> 46         printf (&quot;nif:0x%x name:%s\n&quot;, (UINT_PTR)nif, nif-&gt;name);</span>
 47 #endif
 48         if (nif-&gt;dNameIsUnicode) {
 49             printf (&quot;dName:%S index:%d &quot;, (unsigned short *)nif-&gt;displayName,
 50                 nif-&gt;index);
 51         } else {
 52             printf (&quot;dName:%s index:%d &quot;, nif-&gt;displayName, nif-&gt;index);
 53         }
 54         printf (&quot;naddrs:%d\n&quot;, nif-&gt;naddrs);
 55 }
 56 
 57 void printnifs (netif *netifPP, char *str) {
 58     netif *nif;
 59     printf (&quot;%s\n&quot;, str);
 60     for (nif=netifPP; nif!=NULL; nif=nif-&gt;next) {
 61         printnif (nif);
 62     }
 63     printf(&quot;-----------------\n&quot;);
 64 }
 65 
 66 #endif
 67 
 68 const ULONG BUFF_SIZE = 15360;
 69 const int MAX_TRIES = 3;
 70 
 71 /*
 72  * return an array of IP_ADAPTER_ADDRESSES containing one element
 73  * for each adapter on the system. Returned in *adapters.
 74  * Buffer is malloc&#39;d and must be freed (unless error returned)
 75  */
<span class="line-modified"> 76 int getAdapters (JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters) {</span>
<span class="line-modified"> 77     DWORD ret;</span>
 78     IP_ADAPTER_ADDRESSES *adapterInfo;
 79     ULONG len;
 80     int try;
 81 
 82     adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);
 83     if (adapterInfo == NULL) {
 84         JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;,
 85             &quot;Native heap allocation failure&quot;);
 86         return -1;
 87     }
 88 
 89     len = BUFF_SIZE;



 90     ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &amp;len);
 91 
 92     for (try = 0; ret == ERROR_BUFFER_OVERFLOW &amp;&amp; try &lt; MAX_TRIES; ++try) {
 93         IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;
 94         if (len &lt; (ULONG_MAX - BUFF_SIZE)) {
 95             len += BUFF_SIZE;
 96         }
 97         newAdapterInfo =
 98             (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);
 99         if (newAdapterInfo == NULL) {
100             free(adapterInfo);
101             JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;,
102                 &quot;Native heap allocation failure&quot;);
103             return -1;
104         }
105 
106         adapterInfo = newAdapterInfo;
107 
108         ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &amp;len);
109     }
</pre>
<hr />
<pre>
220             return NULL;
221         }
222 
223         //copy the memory and break out of the while loop.
224         memcpy(ret, ptr, sizeof(IP_ADAPTER_ADDRESSES));
225         break;
226 
227       }
228       ptr=ptr-&gt;Next;
229     }
230     free(adapterInfo);
231     return ret;
232 }
233 
234 static int ipinflen = 2048;
235 
236 /*
237  */
238 int getAllInterfacesAndAddresses (JNIEnv *env, netif **netifPP)
239 {
<span class="line-modified">240     DWORD ret, flags;</span>
<span class="line-added">241     MIB_IPADDRTABLE *tableP;</span>
242     IP_ADAPTER_ADDRESSES *ptr, *adapters=NULL;
243     ULONG len=ipinflen, count=0;
244     netif *nif=NULL, *dup_nif, *last=NULL, *loopif=NULL, *curr;
245     int tun=0, net=0;
246 
247     *netifPP = NULL;
248    /*
249     * Get the IPv4 interfaces. This information is the same
250     * as what previous JDK versions would return.
251     */
252 
253     ret = enumInterfaces(env, netifPP);
254     if (ret == -1) {
255         return -1;
256     } else if( ret == -2){
257         if ((*env)-&gt;ExceptionCheck(env)) {
258             (*env)-&gt;ExceptionClear(env);
259         }
260     } else {
261         count = ret;
262     }
263 
264     /* locate the loopback (and the last) interface */
265     for (nif=*netifPP, last=nif; nif!=NULL; nif=nif-&gt;next) {
266         if (nif-&gt;ifType == MIB_IF_TYPE_LOOPBACK) {
267             loopif = nif;
268         }
269         last = nif;
270     }
271 
272     // Retrieve IPv4 addresses with the IP Helper API
273     curr = *netifPP;
<span class="line-added">274     ret = lookupIPAddrTable(env, &amp;tableP);</span>
<span class="line-added">275     if (ret &lt; 0) {</span>
<span class="line-added">276       return -1;</span>
<span class="line-added">277     }</span>
278     while (curr != NULL) {
279         netaddr *netaddrP;
<span class="line-modified">280         ret = enumAddresses_win_ipaddrtable(env, curr, &amp;netaddrP, tableP);</span>
281         if (ret == -1) {
<span class="line-added">282             free(tableP);</span>
283             return -1;
284         } else if (ret == -2) {
285             if ((*env)-&gt;ExceptionCheck(env)) {
286                 (*env)-&gt;ExceptionClear(env);
287             }
288             break;
289         } else{
290             curr-&gt;addrs = netaddrP;
291             curr-&gt;naddrs += ret;
292             curr = curr-&gt;next;
293         }
294     }
<span class="line-added">295     free(tableP);</span>
296 
<span class="line-modified">297     flags = GAA_FLAG_SKIP_DNS_SERVER;</span>
<span class="line-added">298     flags |= GAA_FLAG_SKIP_MULTICAST;</span>
<span class="line-added">299     flags |= GAA_FLAG_INCLUDE_PREFIX;</span>
<span class="line-added">300     ret = getAdapters (env, flags, &amp;adapters);</span>
301     if (ret != ERROR_SUCCESS) {
302         goto err;
303     }
304 
305     /* Now get the IPv6 information. This includes:
306      *  (a)  IPv6 information associated with interfaces already found
307      *  (b)  IPv6 information for IPv6 only interfaces (probably tunnels)
308      *
309      * For compatibility with previous releases we use the naming
310      * information gotten from enumInterfaces() for (a) entries
311      * However, the index numbers are taken from the new API.
312      *
313      * The procedure is to go through the list of adapters returned
314      * by the new API looking for entries that correspond to IPv4 interfaces
315      * already found.
316      */
317 
318     ptr = adapters;
319     while (ptr != NULL) {
320         int c;
321         netif *nif0;
322         if (ptr-&gt;IfType == IF_TYPE_SOFTWARE_LOOPBACK &amp;&amp; (loopif != NULL)) {
323             c = getAddrsFromAdapter(ptr, &amp;loopif-&gt;addrs);
324             if (c == -1) {
325                 goto err;
326             }
327             loopif-&gt;naddrs += c;
<span class="line-added">328             loopif-&gt;ipv6Index = ptr-&gt;Ipv6IfIndex;</span>
329         } else {
330             int index = ptr-&gt;IfIndex;
331             if (index != 0) {
332                 /* This entry is associated with an IPv4 interface */
333                 for (nif=*netifPP; nif!=NULL; nif=nif-&gt;next) {
334                     if (nif-&gt;index == index) {
335                         /* found the interface entry
336                          * set the index to the IPv6 index and add the
337                          * IPv6 addresses
338                          */
339                         nif-&gt;ipv6Index = ptr-&gt;Ipv6IfIndex;
340                         c = getAddrsFromAdapter(ptr, &amp;nif-&gt;addrs);
341                         nif-&gt;naddrs += c;
342                         break;
343                     }
344                 }
345             } else {
346                 /* This entry is IPv6 only */
347                 char newname [128];
348                 int c;
</pre>
</td>
</tr>
</table>
<center><a href="NetworkInterface.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ResolverConfigurationImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
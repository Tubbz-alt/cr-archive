<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/native/libnet/net_util_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 #include &quot;net_util.h&quot;
 26 
 27 #include &quot;java_net_InetAddress.h&quot;
 28 #include &quot;java_net_SocketOptions.h&quot;
 29 
 30 // Taken from mstcpip.h in Windows SDK 8.0 or newer.
 31 #define SIO_LOOPBACK_FAST_PATH              _WSAIOW(IOC_VENDOR,16)
 32 
 33 #ifndef IPTOS_TOS_MASK
 34 #define IPTOS_TOS_MASK 0x1e
 35 #endif
 36 #ifndef IPTOS_PREC_MASK
 37 #define IPTOS_PREC_MASK 0xe0
 38 #endif
 39 
 40 /* true if SO_RCVTIMEO is supported */
 41 jboolean isRcvTimeoutSupported = JNI_TRUE;
 42 
 43 /*
 44  * Table of Windows Sockets errors, the specific exception we
 45  * throw for the error, and the error text.
 46  *
 47  * Note that this table excludes OS dependent errors.
 48  *
 49  * Latest list of Windows Sockets errors can be found at :-
 50  * http://msdn.microsoft.com/library/psdk/winsock/errors_3wc2.htm
 51  */
 52 static struct {
 53     int errCode;
 54     const char *exc;
 55     const char *errString;
 56 } const winsock_errors[] = {
 57     { WSAEACCES,                0,      &quot;Permission denied&quot; },
 58     { WSAEADDRINUSE,            &quot;BindException&quot;,        &quot;Address already in use&quot; },
 59     { WSAEADDRNOTAVAIL,         &quot;BindException&quot;,        &quot;Cannot assign requested address&quot; },
 60     { WSAEAFNOSUPPORT,          0,      &quot;Address family not supported by protocol family&quot; },
 61     { WSAEALREADY,              0,      &quot;Operation already in progress&quot; },
 62     { WSAECONNABORTED,          0,      &quot;Software caused connection abort&quot; },
 63     { WSAECONNREFUSED,          &quot;ConnectException&quot;,     &quot;Connection refused&quot; },
 64     { WSAECONNRESET,            0,      &quot;Connection reset by peer&quot; },
 65     { WSAEDESTADDRREQ,          0,      &quot;Destination address required&quot; },
 66     { WSAEFAULT,                0,      &quot;Bad address&quot; },
 67     { WSAEHOSTDOWN,             0,      &quot;Host is down&quot; },
 68     { WSAEHOSTUNREACH,          &quot;NoRouteToHostException&quot;,       &quot;No route to host&quot; },
 69     { WSAEINPROGRESS,           0,      &quot;Operation now in progress&quot; },
 70     { WSAEINTR,                 0,      &quot;Interrupted function call&quot; },
 71     { WSAEINVAL,                0,      &quot;Invalid argument&quot; },
 72     { WSAEISCONN,               0,      &quot;Socket is already connected&quot; },
 73     { WSAEMFILE,                0,      &quot;Too many open files&quot; },
 74     { WSAEMSGSIZE,              0,      &quot;The message is larger than the maximum supported by the underlying transport&quot; },
 75     { WSAENETDOWN,              0,      &quot;Network is down&quot; },
 76     { WSAENETRESET,             0,      &quot;Network dropped connection on reset&quot; },
 77     { WSAENETUNREACH,           0,      &quot;Network is unreachable&quot; },
 78     { WSAENOBUFS,               0,      &quot;No buffer space available (maximum connections reached?)&quot; },
 79     { WSAENOPROTOOPT,           0,      &quot;Bad protocol option&quot; },
 80     { WSAENOTCONN,              0,      &quot;Socket is not connected&quot; },
 81     { WSAENOTSOCK,              0,      &quot;Socket operation on nonsocket&quot; },
 82     { WSAEOPNOTSUPP,            0,      &quot;Operation not supported&quot; },
 83     { WSAEPFNOSUPPORT,          0,      &quot;Protocol family not supported&quot; },
 84     { WSAEPROCLIM,              0,      &quot;Too many processes&quot; },
 85     { WSAEPROTONOSUPPORT,       0,      &quot;Protocol not supported&quot; },
 86     { WSAEPROTOTYPE,            0,      &quot;Protocol wrong type for socket&quot; },
 87     { WSAESHUTDOWN,             0,      &quot;Cannot send after socket shutdown&quot; },
 88     { WSAESOCKTNOSUPPORT,       0,      &quot;Socket type not supported&quot; },
 89     { WSAETIMEDOUT,             &quot;ConnectException&quot;,     &quot;Connection timed out&quot; },
 90     { WSATYPE_NOT_FOUND,        0,      &quot;Class type not found&quot; },
 91     { WSAEWOULDBLOCK,           0,      &quot;Resource temporarily unavailable&quot; },
 92     { WSAHOST_NOT_FOUND,        0,      &quot;Host not found&quot; },
 93     { WSA_NOT_ENOUGH_MEMORY,    0,      &quot;Insufficient memory available&quot; },
 94     { WSANOTINITIALISED,        0,      &quot;Successful WSAStartup not yet performed&quot; },
 95     { WSANO_DATA,               0,      &quot;Valid name, no data record of requested type&quot; },
 96     { WSANO_RECOVERY,           0,      &quot;This is a nonrecoverable error&quot; },
 97     { WSASYSNOTREADY,           0,      &quot;Network subsystem is unavailable&quot; },
 98     { WSATRY_AGAIN,             0,      &quot;Nonauthoritative host not found&quot; },
 99     { WSAVERNOTSUPPORTED,       0,      &quot;Winsock.dll version out of range&quot; },
100     { WSAEDISCON,               0,      &quot;Graceful shutdown in progress&quot; },
101     { WSA_OPERATION_ABORTED,    0,      &quot;Overlapped operation aborted&quot; },
102 };
103 
104 /*
105  * Initialize Windows Sockets API support
106  */
107 BOOL WINAPI
108 DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved)
109 {
110     WSADATA wsadata;
111 
112     switch (reason) {
113         case DLL_PROCESS_ATTACH:
114             if (WSAStartup(MAKEWORD(2,2), &amp;wsadata) != 0) {
115                 return FALSE;
116             }
117             break;
118 
119         case DLL_PROCESS_DETACH:
120             WSACleanup();
121             break;
122 
123         default:
124             break;
125     }
126     return TRUE;
127 }
128 
129 void platformInit() {}
130 void parseExclusiveBindProperty(JNIEnv *env) {}
131 
132 /*
133  * Since winsock doesn&#39;t have the equivalent of strerror(errno)
134  * use table to lookup error text for the error.
135  */
136 JNIEXPORT void JNICALL
137 NET_ThrowNew(JNIEnv *env, int errorNum, char *msg)
138 {
139     int i;
140     int table_size = sizeof(winsock_errors) /
141                      sizeof(winsock_errors[0]);
142     char exc[256];
143     char fullMsg[256];
144     char *excP = NULL;
145 
146     /*
147      * If exception already throw then don&#39;t overwrite it.
148      */
149     if ((*env)-&gt;ExceptionOccurred(env)) {
150         return;
151     }
152 
153     /*
154      * Default message text if not provided
155      */
156     if (!msg) {
157         msg = &quot;no further information&quot;;
158     }
159 
160     /*
161      * Check table for known winsock errors
162      */
163     i=0;
164     while (i &lt; table_size) {
165         if (errorNum == winsock_errors[i].errCode) {
166             break;
167         }
168         i++;
169     }
170 
171     /*
172      * If found get pick the specific exception and error
173      * message corresponding to this error.
174      */
175     if (i &lt; table_size) {
176         excP = (char *)winsock_errors[i].exc;
177         jio_snprintf(fullMsg, sizeof(fullMsg), &quot;%s: %s&quot;,
178                      (char *)winsock_errors[i].errString, msg);
179     } else {
180         jio_snprintf(fullMsg, sizeof(fullMsg),
181                      &quot;Unrecognized Windows Sockets error: %d: %s&quot;,
182                      errorNum, msg);
183 
184     }
185 
186     /*
187      * Throw SocketException if no specific exception for this
188      * error.
189      */
190     if (excP == NULL) {
191         excP = &quot;SocketException&quot;;
192     }
193     sprintf(exc, &quot;%s%s&quot;, JNU_JAVANETPKG, excP);
194     JNU_ThrowByName(env, exc, fullMsg);
195 }
196 
197 void
198 NET_ThrowCurrent(JNIEnv *env, char *msg)
199 {
200     NET_ThrowNew(env, WSAGetLastError(), msg);
201 }
202 
203 void
204 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
205                    const char *defaultDetail) {
206     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
207 }
208 
209 jfieldID
210 NET_GetFileDescriptorID(JNIEnv *env)
211 {
212     jclass cls = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;);
213     CHECK_NULL_RETURN(cls, NULL);
214     return (*env)-&gt;GetFieldID(env, cls, &quot;fd&quot;, &quot;I&quot;);
215 }
216 
<a name="1" id="anc1"></a><span class="line-added">217 jint  IPv4_supported()</span>
<span class="line-added">218 {</span>
<span class="line-added">219     /* TODO: properly check for IPv4 support on Windows */</span>
<span class="line-added">220     return JNI_TRUE;</span>
<span class="line-added">221 }</span>
<span class="line-added">222 </span>
223 jint  IPv6_supported()
224 {
225     SOCKET s = socket(AF_INET6, SOCK_STREAM, 0) ;
226     if (s == INVALID_SOCKET) {
227         return JNI_FALSE;
228     }
229     closesocket(s);
230 
231     return JNI_TRUE;
232 }
233 
234 jint reuseport_supported()
235 {
236     /* SO_REUSEPORT is not supported on Windows */
237     return JNI_FALSE;
238 }
239 
240 /* call NET_MapSocketOptionV6 for the IPv6 fd only
241  * and NET_MapSocketOption for the IPv4 fd
242  */
243 JNIEXPORT int JNICALL
244 NET_MapSocketOptionV6(jint cmd, int *level, int *optname) {
245 
246     switch (cmd) {
247         case java_net_SocketOptions_IP_MULTICAST_IF:
248         case java_net_SocketOptions_IP_MULTICAST_IF2:
249             *level = IPPROTO_IPV6;
250             *optname = IPV6_MULTICAST_IF;
251             return 0;
252 
253         case java_net_SocketOptions_IP_MULTICAST_LOOP:
254             *level = IPPROTO_IPV6;
255             *optname = IPV6_MULTICAST_LOOP;
256             return 0;
257     }
258     return NET_MapSocketOption (cmd, level, optname);
259 }
260 
261 /*
262  * Map the Java level socket option to the platform specific
263  * level and option name.
264  */
265 
266 JNIEXPORT int JNICALL
267 NET_MapSocketOption(jint cmd, int *level, int *optname) {
268 
269     typedef struct {
270         jint cmd;
271         int level;
272         int optname;
273     } sockopts;
274 
275     static sockopts opts[] = {
276         { java_net_SocketOptions_TCP_NODELAY,   IPPROTO_TCP,    TCP_NODELAY },
277         { java_net_SocketOptions_SO_OOBINLINE,  SOL_SOCKET,     SO_OOBINLINE },
278         { java_net_SocketOptions_SO_LINGER,     SOL_SOCKET,     SO_LINGER },
279         { java_net_SocketOptions_SO_SNDBUF,     SOL_SOCKET,     SO_SNDBUF },
280         { java_net_SocketOptions_SO_RCVBUF,     SOL_SOCKET,     SO_RCVBUF },
281         { java_net_SocketOptions_SO_KEEPALIVE,  SOL_SOCKET,     SO_KEEPALIVE },
282         { java_net_SocketOptions_SO_REUSEADDR,  SOL_SOCKET,     SO_REUSEADDR },
283         { java_net_SocketOptions_SO_BROADCAST,  SOL_SOCKET,     SO_BROADCAST },
284         { java_net_SocketOptions_IP_MULTICAST_IF,   IPPROTO_IP, IP_MULTICAST_IF },
285         { java_net_SocketOptions_IP_MULTICAST_LOOP, IPPROTO_IP, IP_MULTICAST_LOOP },
286         { java_net_SocketOptions_IP_TOS,            IPPROTO_IP, IP_TOS },
287 
288     };
289 
290 
291     int i;
292 
293     /*
294      * Map the Java level option to the native level
295      */
296     for (i=0; i&lt;(int)(sizeof(opts) / sizeof(opts[0])); i++) {
297         if (cmd == opts[i].cmd) {
298             *level = opts[i].level;
299             *optname = opts[i].optname;
300             return 0;
301         }
302     }
303 
304     /* not found */
305     return -1;
306 }
307 
308 
309 /*
310  * Wrapper for setsockopt dealing with Windows specific issues :-
311  *
312  * IP_TOS and IP_MULTICAST_LOOP can&#39;t be set on some Windows
313  * editions.
314  *
315  * The value for the type-of-service (TOS) needs to be masked
316  * to get consistent behaviour with other operating systems.
317  */
318 JNIEXPORT int JNICALL
319 NET_SetSockOpt(int s, int level, int optname, const void *optval,
320                int optlen)
321 {
322     int rv = 0;
323     int parg = 0;
324     int plen = sizeof(parg);
325 
326     if (level == IPPROTO_IP &amp;&amp; optname == IP_TOS) {
327         int *tos = (int *)optval;
328         *tos &amp;= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
329     }
330 
331     if (optname == SO_REUSEADDR) {
332         /*
333          * Do not set SO_REUSEADDE if SO_EXCLUSIVEADDUSE is already set
334          */
335         rv = NET_GetSockOpt(s, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *)&amp;parg, &amp;plen);
336         if (rv == 0 &amp;&amp; parg == 1) {
337             return rv;
338         }
339     }
340 
341     rv = setsockopt(s, level, optname, optval, optlen);
342 
343     if (rv == SOCKET_ERROR) {
344         /*
345          * IP_TOS &amp; IP_MULTICAST_LOOP can&#39;t be set on some versions
346          * of Windows.
347          */
348         if ((WSAGetLastError() == WSAENOPROTOOPT) &amp;&amp;
349             (level == IPPROTO_IP) &amp;&amp;
350             (optname == IP_TOS || optname == IP_MULTICAST_LOOP)) {
351             rv = 0;
352         }
353 
354         /*
355          * IP_TOS can&#39;t be set on unbound UDP sockets.
356          */
357         if ((WSAGetLastError() == WSAEINVAL) &amp;&amp;
358             (level == IPPROTO_IP) &amp;&amp;
359             (optname == IP_TOS)) {
360             rv = 0;
361         }
362     }
363 
364     return rv;
365 }
366 
367 /*
368  * Wrapper for setsockopt dealing with Windows specific issues :-
369  *
370  * IP_TOS is not supported on some versions of Windows so
371  * instead return the default value for the OS.
372  */
373 JNIEXPORT int JNICALL
374 NET_GetSockOpt(int s, int level, int optname, void *optval,
375                int *optlen)
376 {
377     int rv;
378 
379     if (level == IPPROTO_IPV6 &amp;&amp; optname == IPV6_TCLASS) {
380         int *intopt = (int *)optval;
381         *intopt = 0;
382         *optlen = sizeof(*intopt);
383         return 0;
384     }
385 
386     rv = getsockopt(s, level, optname, optval, optlen);
387 
388 
389     /*
390      * IPPROTO_IP/IP_TOS is not supported on some Windows
391      * editions so return the default type-of-service
392      * value.
393      */
394     if (rv == SOCKET_ERROR) {
395 
396         if (WSAGetLastError() == WSAENOPROTOOPT &amp;&amp;
397             level == IPPROTO_IP &amp;&amp; optname == IP_TOS) {
398 
399             *((int *)optval) = 0;
400             rv = 0;
401         }
402     }
403 
404     return rv;
405 }
406 
407 JNIEXPORT int JNICALL
408 NET_SocketAvailable(int s, int *pbytes) {
409     u_long arg;
410     if (ioctlsocket((SOCKET)s, FIONREAD, &amp;arg) == SOCKET_ERROR) {
411         return -1;
412     } else {
413         *pbytes = (int) arg;
414         return 0;
415     }
416 }
417 
418 /*
419  * Sets SO_ECLUSIVEADDRUSE if SO_REUSEADDR is not already set.
420  */
421 void setExclusiveBind(int fd) {
422     int parg = 0;
423     int plen = sizeof(parg);
424     int rv = 0;
425     rv = NET_GetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;parg, &amp;plen);
426     if (rv == 0 &amp;&amp; parg == 0) {
427         parg = 1;
428         rv = NET_SetSockOpt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char*)&amp;parg, plen);
429     }
430 }
431 
432 /*
433  * Wrapper for bind winsock call - transparent converts an
434  * error related to binding to a port that has exclusive access
435  * into an error indicating the port is in use (facilitates
436  * better error reporting).
437  *
438  * Should be only called by the wrapper method NET_WinBind
439  */
440 JNIEXPORT int JNICALL
441 NET_Bind(int s, SOCKETADDRESS *sa, int len)
442 {
443     int rv = 0;
444     rv = bind(s, &amp;sa-&gt;sa, len);
445 
446     if (rv == SOCKET_ERROR) {
447         /*
448          * If bind fails with WSAEACCES it means that a privileged
449          * process has done an exclusive bind (NT SP4/2000/XP only).
450          */
451         if (WSAGetLastError() == WSAEACCES) {
452             WSASetLastError(WSAEADDRINUSE);
453         }
454     }
455 
456     return rv;
457 }
458 
459 /*
460  * Wrapper for NET_Bind call. Sets SO_EXCLUSIVEADDRUSE
461  * if required, and then calls NET_BIND
462  */
463 JNIEXPORT int JNICALL
464 NET_WinBind(int s, SOCKETADDRESS *sa, int len, jboolean exclBind)
465 {
466     if (exclBind == JNI_TRUE)
467         setExclusiveBind(s);
468     return NET_Bind(s, sa, len);
469 }
470 
471 JNIEXPORT int JNICALL
472 NET_SocketClose(int fd) {
473     struct linger l = {0, 0};
474     int ret = 0;
475     int len = sizeof (l);
476     if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&amp;l, &amp;len) == 0) {
477         if (l.l_onoff == 0) {
478             shutdown(fd, SD_SEND);
479         }
480     }
481     ret = closesocket (fd);
482     return ret;
483 }
484 
485 JNIEXPORT int JNICALL
486 NET_Timeout(int fd, long timeout) {
487     int ret;
488     fd_set tbl;
489     struct timeval t;
490     t.tv_sec = timeout / 1000;
491     t.tv_usec = (timeout % 1000) * 1000;
492     FD_ZERO(&amp;tbl);
493     FD_SET(fd, &amp;tbl);
494     ret = select (fd + 1, &amp;tbl, 0, 0, &amp;t);
495     return ret;
496 }
497 
498 
499 /*
500  * differs from NET_Timeout() as follows:
501  *
502  * If timeout = -1, it blocks forever.
503  *
504  * returns 1 or 2 depending if only one or both sockets
505  * fire at same time.
506  *
507  * *fdret is (one of) the active fds. If both sockets
508  * fire at same time, *fdret = fd always.
509  */
510 JNIEXPORT int JNICALL
511 NET_Timeout2(int fd, int fd1, long timeout, int *fdret) {
512     int ret;
513     fd_set tbl;
514     struct timeval t, *tP = &amp;t;
515     if (timeout == -1) {
516         tP = 0;
517     } else {
518         t.tv_sec = timeout / 1000;
519         t.tv_usec = (timeout % 1000) * 1000;
520     }
521     FD_ZERO(&amp;tbl);
522     FD_SET(fd, &amp;tbl);
523     FD_SET(fd1, &amp;tbl);
524     ret = select (0, &amp;tbl, 0, 0, tP);
525     switch (ret) {
526     case 0:
527         return 0; /* timeout */
528     case 1:
529         if (FD_ISSET (fd, &amp;tbl)) {
530             *fdret= fd;
531         } else {
532             *fdret= fd1;
533         }
534         return 1;
535     case 2:
536         *fdret= fd;
537         return 2;
538     }
539     return -1;
540 }
541 
542 
543 void dumpAddr (char *str, void *addr) {
544     struct sockaddr_in6 *a = (struct sockaddr_in6 *)addr;
545     int family = a-&gt;sin6_family;
546     printf (&quot;%s\n&quot;, str);
547     if (family == AF_INET) {
548         struct sockaddr_in *him = (struct sockaddr_in *)addr;
549         printf (&quot;AF_INET: port %d: %x\n&quot;, ntohs(him-&gt;sin_port),
550                                           ntohl(him-&gt;sin_addr.s_addr));
551     } else {
552         int i;
553         struct in6_addr *in = &amp;a-&gt;sin6_addr;
554         printf (&quot;AF_INET6 &quot;);
555         printf (&quot;port %d &quot;, ntohs (a-&gt;sin6_port));
556         printf (&quot;flow %d &quot;, a-&gt;sin6_flowinfo);
557         printf (&quot;addr &quot;);
558         for (i=0; i&lt;7; i++) {
559             printf (&quot;%04x:&quot;, ntohs(in-&gt;s6_words[i]));
560         }
561         printf (&quot;%04x&quot;, ntohs(in-&gt;s6_words[7]));
562         printf (&quot; scope %d\n&quot;, a-&gt;sin6_scope_id);
563     }
564 }
565 
566 /* Macro, which cleans-up the iv6bind structure,
567  * closes the two sockets (if open),
568  * and returns SOCKET_ERROR. Used in NET_BindV6 only.
569  */
570 
571 #define CLOSE_SOCKETS_AND_RETURN do {   \
572     if (fd != -1) {                     \
573         closesocket (fd);               \
574         fd = -1;                        \
575     }                                   \
576     if (ofd != -1) {                    \
577         closesocket (ofd);              \
578         ofd = -1;                       \
579     }                                   \
580     if (close_fd != -1) {               \
581         closesocket (close_fd);         \
582         close_fd = -1;                  \
583     }                                   \
584     if (close_ofd != -1) {              \
585         closesocket (close_ofd);        \
586         close_ofd = -1;                 \
587     }                                   \
588     b-&gt;ipv4_fd = b-&gt;ipv6_fd = -1;       \
589     return SOCKET_ERROR;                \
590 } while(0)
591 
592 /*
593  * if ipv6 is available, call NET_BindV6 to bind to the required address/port.
594  * Because the same port number may need to be reserved in both v4 and v6 space,
595  * this may require socket(s) to be re-opened. Therefore, all of this information
596  * is passed in and returned through the ipv6bind structure.
597  *
598  * If the request is to bind to a specific address, then this (by definition) means
599  * only bind in either v4 or v6, and this is just the same as normal. ie. a single
600  * call to bind() will suffice. The other socket is closed in this case.
601  *
602  * The more complicated case is when the requested address is ::0 or 0.0.0.0.
603  *
604  * Two further cases:
605  * 2. If the requested port is 0 (ie. any port) then we try to bind in v4 space
606  *    first with a wild-card port argument. We then try to bind in v6 space
607  *    using the returned port number. If this fails, we repeat the process
608  *    until a free port common to both spaces becomes available.
609  *
610  * 3. If the requested port is a specific port, then we just try to get that
611  *    port in both spaces, and if it is not free in both, then the bind fails.
612  *
613  * On failure, sockets are closed and an error returned with CLOSE_SOCKETS_AND_RETURN
614  */
615 
616 JNIEXPORT int JNICALL
617 NET_BindV6(struct ipv6bind *b, jboolean exclBind) {
618     int fd=-1, ofd=-1, rv, len;
619     /* need to defer close until new sockets created */
620     int close_fd=-1, close_ofd=-1;
621     SOCKETADDRESS oaddr; /* other address to bind */
622     int family = b-&gt;addr-&gt;sa.sa_family;
623     int ofamily;
624     u_short port; /* requested port parameter */
625     u_short bound_port;
626 
627     if (family == AF_INET &amp;&amp; (b-&gt;addr-&gt;sa4.sin_addr.s_addr != INADDR_ANY)) {
628         /* bind to v4 only */
629         int ret;
630         ret = NET_WinBind((int)b-&gt;ipv4_fd, b-&gt;addr,
631                           sizeof(SOCKETADDRESS), exclBind);
632         if (ret == SOCKET_ERROR) {
633             CLOSE_SOCKETS_AND_RETURN;
634         }
635         closesocket (b-&gt;ipv6_fd);
636         b-&gt;ipv6_fd = -1;
637         return 0;
638     }
639     if (family == AF_INET6 &amp;&amp; (!IN6_IS_ADDR_ANY(&amp;b-&gt;addr-&gt;sa6.sin6_addr))) {
640         /* bind to v6 only */
641         int ret;
642         ret = NET_WinBind((int)b-&gt;ipv6_fd, b-&gt;addr,
643                           sizeof(SOCKETADDRESS), exclBind);
644         if (ret == SOCKET_ERROR) {
645             CLOSE_SOCKETS_AND_RETURN;
646         }
647         closesocket (b-&gt;ipv4_fd);
648         b-&gt;ipv4_fd = -1;
649         return 0;
650     }
651 
652     /* We need to bind on both stacks, with the same port number */
653 
654     memset (&amp;oaddr, 0, sizeof(oaddr));
655     if (family == AF_INET) {
656         ofamily = AF_INET6;
657         fd = (int)b-&gt;ipv4_fd;
658         ofd = (int)b-&gt;ipv6_fd;
659         port = (u_short)GET_PORT (b-&gt;addr);
660         IN6ADDR_SETANY(&amp;oaddr.sa6);
661         oaddr.sa6.sin6_port = port;
662     } else {
663         ofamily = AF_INET;
664         ofd = (int)b-&gt;ipv4_fd;
665         fd = (int)b-&gt;ipv6_fd;
666         port = (u_short)GET_PORT (b-&gt;addr);
667         oaddr.sa4.sin_family = AF_INET;
668         oaddr.sa4.sin_port = port;
669         oaddr.sa4.sin_addr.s_addr = INADDR_ANY;
670     }
671 
672     rv = NET_WinBind(fd, b-&gt;addr, sizeof(SOCKETADDRESS), exclBind);
673     if (rv == SOCKET_ERROR) {
674         CLOSE_SOCKETS_AND_RETURN;
675     }
676 
677     /* get the port and set it in the other address */
678     len = sizeof(SOCKETADDRESS);
679     if (getsockname(fd, (struct sockaddr *)b-&gt;addr, &amp;len) == -1) {
680         CLOSE_SOCKETS_AND_RETURN;
681     }
682     bound_port = GET_PORT (b-&gt;addr);
683     SET_PORT (&amp;oaddr, bound_port);
684     if ((rv = NET_WinBind(ofd, &amp;oaddr,
685                           sizeof(SOCKETADDRESS), exclBind)) == SOCKET_ERROR) {
686         int retries;
687         int sotype, arglen=sizeof(sotype);
688 
689         /* no retries unless, the request was for any free port */
690 
691         if (port != 0) {
692             CLOSE_SOCKETS_AND_RETURN;
693         }
694 
695         getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype, &amp;arglen);
696 
697 #define SOCK_RETRIES 50
698         /* 50 is an arbitrary limit, just to ensure that this
699          * cannot be an endless loop. Would expect socket creation to
700          * succeed sooner.
701          */
702         for (retries = 0; retries &lt; SOCK_RETRIES; retries ++) {
703             int len;
704             close_fd = fd; fd = -1;
705             close_ofd = ofd; ofd = -1;
706             b-&gt;ipv4_fd = SOCKET_ERROR;
707             b-&gt;ipv6_fd = SOCKET_ERROR;
708 
709             /* create two new sockets */
710             fd = (int)socket (family, sotype, 0);
711             if (fd == SOCKET_ERROR) {
712                 CLOSE_SOCKETS_AND_RETURN;
713             }
714             ofd = (int)socket (ofamily, sotype, 0);
715             if (ofd == SOCKET_ERROR) {
716                 CLOSE_SOCKETS_AND_RETURN;
717             }
718 
719             /* bind random port on first socket */
720             SET_PORT (&amp;oaddr, 0);
721             rv = NET_WinBind(ofd, &amp;oaddr, sizeof(SOCKETADDRESS), exclBind);
722             if (rv == SOCKET_ERROR) {
723                 CLOSE_SOCKETS_AND_RETURN;
724             }
725             /* close the original pair of sockets before continuing */
726             closesocket (close_fd);
727             closesocket (close_ofd);
728             close_fd = close_ofd = -1;
729 
730             /* bind new port on second socket */
731             len = sizeof(SOCKETADDRESS);
732             if (getsockname(ofd, &amp;oaddr.sa, &amp;len) == -1) {
733                 CLOSE_SOCKETS_AND_RETURN;
734             }
735             bound_port = GET_PORT (&amp;oaddr);
736             SET_PORT (b-&gt;addr, bound_port);
737             rv = NET_WinBind(fd, b-&gt;addr, sizeof(SOCKETADDRESS), exclBind);
738 
739             if (rv != SOCKET_ERROR) {
740                 if (family == AF_INET) {
741                     b-&gt;ipv4_fd = fd;
742                     b-&gt;ipv6_fd = ofd;
743                 } else {
744                     b-&gt;ipv4_fd = ofd;
745                     b-&gt;ipv6_fd = fd;
746                 }
747                 return 0;
748             }
749         }
750         CLOSE_SOCKETS_AND_RETURN;
751     }
752     return 0;
753 }
754 
<a name="2" id="anc2"></a>






























755 /**
756  * Enables SIO_LOOPBACK_FAST_PATH
757  */
758 JNIEXPORT jint JNICALL
759 NET_EnableFastTcpLoopback(int fd) {
760     int enabled = 1;
761     DWORD result_byte_count = -1;
762     int result = WSAIoctl(fd,
763                           SIO_LOOPBACK_FAST_PATH,
764                           &amp;enabled,
765                           sizeof(enabled),
766                           NULL,
767                           0,
768                           &amp;result_byte_count,
769                           NULL,
770                           NULL);
771     return result == SOCKET_ERROR ? WSAGetLastError() : 0;
772 }
773 
774 /**
775  * See net_util.h for documentation
776  */
777 JNIEXPORT int JNICALL
778 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port,
779                           SOCKETADDRESS *sa, int *len,
780                           jboolean v4MappedAddress)
781 {
782     jint family = getInetAddress_family(env, iaObj);
783     JNU_CHECK_EXCEPTION_RETURN(env, -1);
784     memset((char *)sa, 0, sizeof(SOCKETADDRESS));
785 
786     if (ipv6_available() &amp;&amp;
787         !(family == java_net_InetAddress_IPv4 &amp;&amp;
788           v4MappedAddress == JNI_FALSE))
789     {
790         jbyte caddr[16];
791         jint address;
<a name="3" id="anc3"></a><span class="line-modified">792         unsigned int scopeid = 0;</span>
793 
794         if (family == java_net_InetAddress_IPv4) {
795             // convert to IPv4-mapped address
796             memset((char *)caddr, 0, 16);
797             address = getInetAddress_addr(env, iaObj);
798             JNU_CHECK_EXCEPTION_RETURN(env, -1);
799             if (address == INADDR_ANY) {
800                 /* we would always prefer IPv6 wildcard address
801                  * caddr[10] = 0xff;
802                  * caddr[11] = 0xff; */
803             } else {
804                 caddr[10] = 0xff;
805                 caddr[11] = 0xff;
806                 caddr[12] = ((address &gt;&gt; 24) &amp; 0xff);
807                 caddr[13] = ((address &gt;&gt; 16) &amp; 0xff);
808                 caddr[14] = ((address &gt;&gt; 8) &amp; 0xff);
809                 caddr[15] = (address &amp; 0xff);
810             }
811         } else {
812             getInet6Address_ipaddress(env, iaObj, (char *)caddr);
813             scopeid = getInet6Address_scopeid(env, iaObj);
<a name="4" id="anc4"></a>
814         }
815         sa-&gt;sa6.sin6_port = (u_short)htons((u_short)port);
816         memcpy((void *)&amp;sa-&gt;sa6.sin6_addr, caddr, sizeof(struct in6_addr));
817         sa-&gt;sa6.sin6_family = AF_INET6;
<a name="5" id="anc5"></a><span class="line-modified">818         sa-&gt;sa6.sin6_scope_id = scopeid;</span>







819         if (len != NULL) {
820             *len = sizeof(struct sockaddr_in6);
821         }
822     } else {
823         jint address;
824         if (family != java_net_InetAddress_IPv4) {
825             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Protocol family unavailable&quot;);
826             return -1;
827         }
828         address = getInetAddress_addr(env, iaObj);
829         JNU_CHECK_EXCEPTION_RETURN(env, -1);
830         sa-&gt;sa4.sin_port = htons((short)port);
831         sa-&gt;sa4.sin_addr.s_addr = (u_long)htonl(address);
832         sa-&gt;sa4.sin_family = AF_INET;
833         if (len != NULL) {
834             *len = sizeof(struct sockaddr_in);
835         }
836     }
837     return 0;
838 }
839 
840 int
841 NET_IsIPv4Mapped(jbyte* caddr) {
842     int i;
843     for (i = 0; i &lt; 10; i++) {
844         if (caddr[i] != 0x00) {
845             return 0; /* false */
846         }
847     }
848 
849     if (((caddr[10] &amp; 0xff) == 0xff) &amp;&amp; ((caddr[11] &amp; 0xff) == 0xff)) {
850         return 1; /* true */
851     }
852     return 0; /* false */
853 }
854 
855 int
856 NET_IPv4MappedToIPv4(jbyte* caddr) {
857     return ((caddr[12] &amp; 0xff) &lt;&lt; 24) | ((caddr[13] &amp; 0xff) &lt;&lt; 16) | ((caddr[14] &amp; 0xff) &lt;&lt; 8)
858         | (caddr[15] &amp; 0xff);
859 }
860 
861 int
862 NET_IsEqual(jbyte* caddr1, jbyte* caddr2) {
863     int i;
864     for (i = 0; i &lt; 16; i++) {
865         if (caddr1[i] != caddr2[i]) {
866             return 0; /* false */
867         }
868     }
869     return 1;
870 }
871 
872 /**
873  * Wrapper for select/poll with timeout on a single file descriptor.
874  *
875  * flags (defined in net_util_md.h can be any combination of
876  * NET_WAIT_READ, NET_WAIT_WRITE &amp; NET_WAIT_CONNECT.
877  *
878  * The function will return when either the socket is ready for one
879  * of the specified operation or the timeout expired.
880  *
881  * It returns the time left from the timeout, or -1 if it expired.
882  */
883 
884 jint
885 NET_Wait(JNIEnv *env, jint fd, jint flags, jint timeout)
886 {
887     jlong prevTime = JVM_CurrentTimeMillis(env, 0);
888     jint read_rv;
889 
890     while (1) {
891         jlong newTime;
892         fd_set rd, wr, ex;
893         struct timeval t;
894 
895         t.tv_sec = timeout / 1000;
896         t.tv_usec = (timeout % 1000) * 1000;
897 
898         FD_ZERO(&amp;rd);
899         FD_ZERO(&amp;wr);
900         FD_ZERO(&amp;ex);
901         if (flags &amp; NET_WAIT_READ) {
902           FD_SET(fd, &amp;rd);
903         }
904         if (flags &amp; NET_WAIT_WRITE) {
905           FD_SET(fd, &amp;wr);
906         }
907         if (flags &amp; NET_WAIT_CONNECT) {
908           FD_SET(fd, &amp;wr);
909           FD_SET(fd, &amp;ex);
910         }
911 
912         errno = 0;
913         read_rv = select(fd+1, &amp;rd, &amp;wr, &amp;ex, &amp;t);
914 
915         newTime = JVM_CurrentTimeMillis(env, 0);
916         timeout -= (jint)(newTime - prevTime);
917         if (timeout &lt;= 0) {
918           return read_rv &gt; 0 ? 0 : -1;
919         }
920         newTime = prevTime;
921 
922         if (read_rv &gt; 0) {
923           break;
924         }
925 
926 
927       } /* while */
928 
929     return timeout;
930 }
931 
932 int NET_Socket (int domain, int type, int protocol) {
933     SOCKET sock;
934     sock = socket (domain, type, protocol);
935     if (sock != INVALID_SOCKET) {
936         SetHandleInformation((HANDLE)(uintptr_t)sock, HANDLE_FLAG_INHERIT, FALSE);
937     }
938     return (int)sock;
939 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
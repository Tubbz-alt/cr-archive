<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/windows/native/libnet/NetworkInterface_winXP.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 #include &quot;net_util.h&quot;
 26 #include &quot;NetworkInterface.h&quot;
 27 
 28 #include &quot;java_net_NetworkInterface.h&quot;
 29 
 30 /*
 31  * Windows implementation of the java.net.NetworkInterface native methods.
 32  * This module provides the implementations of getAll, getByName, getByIndex,
 33  * and getByAddress.
 34  */
 35 
 36 extern int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP);
 37 int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP);
 38 
 39 #ifdef DEBUG
 40 void printnif (netif *nif) {
 41 #ifdef _WIN64
 42         printf (&quot;nif:0x%I64x name:%s\n&quot;, (UINT_PTR)nif, nif-&gt;name);
 43 #else
 44         printf (&quot;nif:0x%x name:%s\n&quot;, nif, nif-&gt;name);
 45 #endif
 46         if (nif-&gt;dNameIsUnicode) {
 47             printf (&quot;dName:%S index:%d &quot;, (unsigned short *)nif-&gt;displayName,
 48                 nif-&gt;index);
 49         } else {
 50             printf (&quot;dName:%s index:%d &quot;, nif-&gt;displayName, nif-&gt;index);
 51         }
 52         printf (&quot;naddrs:%d\n&quot;, nif-&gt;naddrs);
 53 }
 54 
 55 void printnifs (netif *netifPP, char *str) {
 56     netif *nif;
 57     printf (&quot;%s\n&quot;, str);
 58     for (nif=netifPP; nif!=NULL; nif=nif-&gt;next) {
 59         printnif (nif);
 60     }
 61     printf(&quot;-----------------\n&quot;);
 62 }
 63 
 64 #endif
 65 
 66 const ULONG BUFF_SIZE = 15360;
 67 const int MAX_TRIES = 3;
 68 
 69 /*
 70  * return an array of IP_ADAPTER_ADDRESSES containing one element
 71  * for each adapter on the system. Returned in *adapters.
 72  * Buffer is malloc&#39;d and must be freed (unless error returned)
 73  */
 74 static int getAdapters (JNIEnv *env, IP_ADAPTER_ADDRESSES **adapters) {
 75     DWORD ret, flags;
 76     IP_ADAPTER_ADDRESSES *adapterInfo;
 77     ULONG len;
 78     int try;
 79 
 80     adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);
 81     if (adapterInfo == NULL) {
 82         JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;,
 83             &quot;Native heap allocation failure&quot;);
 84         return -1;
 85     }
 86 
 87     len = BUFF_SIZE;
 88     flags = GAA_FLAG_SKIP_DNS_SERVER;
 89     flags |= GAA_FLAG_SKIP_MULTICAST;
 90     flags |= GAA_FLAG_INCLUDE_PREFIX;
 91     ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &amp;len);
 92 
 93     for (try = 0; ret == ERROR_BUFFER_OVERFLOW &amp;&amp; try &lt; MAX_TRIES; ++try) {
 94         IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;
 95         if (len &lt; (ULONG_MAX - BUFF_SIZE)) {
 96             len += BUFF_SIZE;
 97         }
 98         newAdapterInfo =
 99             (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);
100         if (newAdapterInfo == NULL) {
101             free(adapterInfo);
102             JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;,
103                 &quot;Native heap allocation failure&quot;);
104             return -1;
105         }
106 
107         adapterInfo = newAdapterInfo;
108 
109         ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &amp;len);
110     }
111 
112     if (ret != ERROR_SUCCESS) {
113         free (adapterInfo);
114         if (ret == ERROR_INSUFFICIENT_BUFFER) {
115             JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
116                 &quot;IP Helper Library GetAdaptersAddresses function failed &quot;
117                 &quot;with ERROR_INSUFFICIENT_BUFFER&quot;);
118         } else if (ret == ERROR_ADDRESS_NOT_ASSOCIATED ) {
119             JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
120                 &quot;IP Helper Library GetAdaptersAddresses function failed &quot;
121                 &quot;with ERROR_ADDRESS_NOT_ASSOCIATED&quot;);
122         } else {
123             char error_msg_buf[100];
124             int _sr;
125             _sr = _snprintf_s(error_msg_buf, sizeof(error_msg_buf),
126                 _TRUNCATE, &quot;IP Helper Library GetAdaptersAddresses &quot;
127                             &quot;function failed with error == %d&quot;, ret);
128             if (_sr != -1) {
129                 JNU_ThrowByName(env, &quot;java/lang/Error&quot;, error_msg_buf);
130             } else {
131                 JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
132                     &quot;IP Helper Library GetAdaptersAddresses function failure&quot;);
133             }
134         }
135         return -1;
136     }
137     *adapters = adapterInfo;
138     return ERROR_SUCCESS;
139 }
140 
141 /*
142  * return an array of IP_ADAPTER_ADDRESSES containing one element
143  * for each adapter on the system. Returned in *adapters.
144  * Buffer is malloc&#39;d and must be freed (unless error returned)
145  */
146 IP_ADAPTER_ADDRESSES *getAdapter (JNIEnv *env,  jint index) {
147     DWORD flags, val;
148     IP_ADAPTER_ADDRESSES *adapterInfo, *ptr, *ret;
149     ULONG len;
150     int try;
151     adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);
152     if (adapterInfo == NULL) {
153         JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;,
154             &quot;Native heap allocation failure&quot;);
155         return NULL;
156     }
157     len = BUFF_SIZE;
158     flags = GAA_FLAG_SKIP_DNS_SERVER;
159     flags |= GAA_FLAG_SKIP_MULTICAST;
160     flags |= GAA_FLAG_INCLUDE_PREFIX;
161     val = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &amp;len);
162     for (try = 0; val == ERROR_BUFFER_OVERFLOW &amp;&amp; try &lt; MAX_TRIES; ++try) {
163         IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;
164         if (len &lt; (ULONG_MAX - BUFF_SIZE)) {
165             len += BUFF_SIZE;
166         }
167         newAdapterInfo =
168                 (IP_ADAPTER_ADDRESSES *) realloc (adapterInfo, len);
169         if (newAdapterInfo == NULL) {
170             free(adapterInfo);
171             JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;,
172                 &quot;Native heap allocation failure&quot;);
173             return NULL;
174         }
175 
176         adapterInfo = newAdapterInfo;
177 
178         val = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &amp;len);
179     }
180 
181     if (val != ERROR_SUCCESS) {
182         free (adapterInfo);
183         if (val == ERROR_INSUFFICIENT_BUFFER) {
184             JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
185                 &quot;IP Helper Library GetAdaptersAddresses function failed &quot;
186                 &quot;with ERROR_INSUFFICIENT_BUFFER&quot;);
187         } else if (val == ERROR_ADDRESS_NOT_ASSOCIATED ) {
188             JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
189                 &quot;IP Helper Library GetAdaptersAddresses function failed &quot;
190                 &quot;with ERROR_ADDRESS_NOT_ASSOCIATED&quot;);
191         } else {
192             char error_msg_buf[100];
193             int _sr;
194             _sr = _snprintf_s(error_msg_buf, sizeof(error_msg_buf),
195                 _TRUNCATE, &quot;IP Helper Library GetAdaptersAddresses function failed &quot;
196                            &quot;with error == %d&quot;, val);
197             if (_sr != -1) {
198                 JNU_ThrowByName(env, &quot;java/lang/Error&quot;, error_msg_buf);
199             } else {
200                 JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
201                     &quot;IP Helper Library GetAdaptersAddresses function failure&quot;);
202             }
203         }
204         return NULL;
205     }
206 
207     ptr = adapterInfo;
208     ret = NULL;
209     while (ptr != NULL) {
210       // in theory the IPv4 index and the IPv6 index can be the same
211       // where an interface is enabled for v4 and v6
212       // IfIndex == 0 IPv4 not available on this interface
213       // Ipv6IfIndex == 0 IPv6 not available on this interface
214       if (((ptr-&gt;IfIndex != 0)&amp;&amp;(ptr-&gt;IfIndex == index)) ||
215           ((ptr-&gt;Ipv6IfIndex !=0) &amp;&amp; (ptr-&gt;Ipv6IfIndex == index))) {
216         ret = (IP_ADAPTER_ADDRESSES *) malloc(sizeof(IP_ADAPTER_ADDRESSES));
217         if (ret == NULL) {
218             free(adapterInfo);
219             JNU_ThrowByName(env, &quot;java/lang/OutOfMemoryError&quot;,
220                 &quot;Native heap allocation failure&quot;);
221             return NULL;
222         }
223 
224         //copy the memory and break out of the while loop.
225         memcpy(ret, ptr, sizeof(IP_ADAPTER_ADDRESSES));
226         break;
227 
228       }
229       ptr=ptr-&gt;Next;
230     }
231     free(adapterInfo);
232     return ret;
233 }
234 
235 static int ipinflen = 2048;
236 
237 /*
238  */
239 int getAllInterfacesAndAddresses (JNIEnv *env, netif **netifPP)
240 {
241     DWORD ret;
242     IP_ADAPTER_ADDRESSES *ptr, *adapters=NULL;
243     ULONG len=ipinflen, count=0;
244     netif *nif=NULL, *dup_nif, *last=NULL, *loopif=NULL, *curr;
245     int tun=0, net=0;
246 
247     *netifPP = NULL;
248    /*
249     * Get the IPv4 interfaces. This information is the same
250     * as what previous JDK versions would return.
251     */
252 
253     ret = enumInterfaces(env, netifPP);
254     if (ret == -1) {
255         return -1;
256     } else if( ret == -2){
257         if ((*env)-&gt;ExceptionCheck(env)) {
258             (*env)-&gt;ExceptionClear(env);
259         }
260     } else {
261         count = ret;
262     }
263 
264     /* locate the loopback (and the last) interface */
265     for (nif=*netifPP, last=nif; nif!=NULL; nif=nif-&gt;next) {
266         if (nif-&gt;ifType == MIB_IF_TYPE_LOOPBACK) {
267             loopif = nif;
268         }
269         last = nif;
270     }
271 
272     // Retrieve IPv4 addresses with the IP Helper API
273     curr = *netifPP;
274     while (curr != NULL) {
275         netaddr *netaddrP;
276         ret = enumAddresses_win(env, curr, &amp;netaddrP);
277         if (ret == -1) {
278             return -1;
279         } else if (ret == -2) {
280             if ((*env)-&gt;ExceptionCheck(env)) {
281                 (*env)-&gt;ExceptionClear(env);
282             }
283             break;
284         } else{
285             curr-&gt;addrs = netaddrP;
286             curr-&gt;naddrs += ret;
287             curr = curr-&gt;next;
288         }
289     }
290 
291     ret = getAdapters (env, &amp;adapters);
292     if (ret != ERROR_SUCCESS) {
293         goto err;
294     }
295 
296     /* Now get the IPv6 information. This includes:
297      *  (a)  IPv6 information associated with interfaces already found
298      *  (b)  IPv6 information for IPv6 only interfaces (probably tunnels)
299      *
300      * For compatibility with previous releases we use the naming
301      * information gotten from enumInterfaces() for (a) entries
302      * However, the index numbers are taken from the new API.
303      *
304      * The procedure is to go through the list of adapters returned
305      * by the new API looking for entries that correspond to IPv4 interfaces
306      * already found.
307      */
308 
309     ptr = adapters;
310     while (ptr != NULL) {
311         int c;
312         netif *nif0;
313         if (ptr-&gt;IfType == IF_TYPE_SOFTWARE_LOOPBACK &amp;&amp; (loopif != NULL)) {
314             c = getAddrsFromAdapter(ptr, &amp;loopif-&gt;addrs);
315             if (c == -1) {
316                 goto err;
317             }
318             loopif-&gt;naddrs += c;
319         } else {
320             int index = ptr-&gt;IfIndex;
321             if (index != 0) {
322                 /* This entry is associated with an IPv4 interface */
323                 for (nif=*netifPP; nif!=NULL; nif=nif-&gt;next) {
324                     if (nif-&gt;index == index) {
325                         /* found the interface entry
326                          * set the index to the IPv6 index and add the
327                          * IPv6 addresses
328                          */
329                         nif-&gt;ipv6Index = ptr-&gt;Ipv6IfIndex;
330                         c = getAddrsFromAdapter(ptr, &amp;nif-&gt;addrs);
331                         nif-&gt;naddrs += c;
332                         break;
333                     }
334                 }
335             } else {
336                 /* This entry is IPv6 only */
337                 char newname [128];
338                 int c;
339 
340                 /* Windows allocates duplicate adapter entries
341                  * for tunnel interfaces when there are multiple
342                  * physical adapters. Need to check
343                  * if this is a duplicate (ipv6Index is the same)
344                  */
345                 dup_nif = 0;
346                 for (nif0=*netifPP; nif0!=NULL; nif0=nif0-&gt;next) {
347                     if (nif0-&gt;hasIpv6Address &amp;&amp;
348                                 ptr-&gt;Ipv6IfIndex == nif0-&gt;ipv6Index) {
349                         dup_nif = nif0;
350                         break;
351                     }
352                 }
353                 if (dup_nif == 0) {
354                     /* new interface */
355                         nif = (netif *) calloc (1, sizeof(netif));
356                         if (nif == 0) {
357                             goto err;
358                         }
359                         if (ptr-&gt;IfType == IF_TYPE_TUNNEL) {
360                                 sprintf (newname, &quot;tun%d&quot;, tun);
361                                 tun ++;
362                         } else {
363                                 sprintf (newname, &quot;net%d&quot;, net);
364                                 net ++;
365                         }
366                         nif-&gt;name = malloc (strlen(newname)+1);
367                         nif-&gt;displayName = malloc (wcslen(ptr-&gt;FriendlyName)*2+2);
368                         if (nif-&gt;name == 0 || nif-&gt;displayName == 0) {
369                                 goto err;
370                         }
371                         strcpy (nif-&gt;name, newname);
372                         wcscpy ((PWCHAR)nif-&gt;displayName, ptr-&gt;FriendlyName);
373                         nif-&gt;dNameIsUnicode = TRUE;
374 
375                         // the java.net.NetworkInterface abstraction only has index
376                         // so the Ipv6IfIndex needs to map onto index
377                         nif-&gt;index = ptr-&gt;Ipv6IfIndex;
378                         nif-&gt;ipv6Index = ptr-&gt;Ipv6IfIndex;
379                         nif-&gt;hasIpv6Address = TRUE;
380 
381                         last-&gt;next = nif;
382                         last = nif;
383                         count++;
384                         c = getAddrsFromAdapter(ptr, &amp;nif-&gt;addrs);
385                         if (c == -1) {
386                                 goto err;
387                         }
388                         nif-&gt;naddrs += c;
389                  } else {
390                         /* add the addresses from this adapter to the
391                          * original (dup_nif)
392                          */
393                         c = getAddrsFromAdapter(ptr, &amp;dup_nif-&gt;addrs);
394                         if (c == -1) {
395                                 goto err;
396                         }
397                         dup_nif-&gt;naddrs += c;
398                 }
399             }
400         }
401         ptr=ptr-&gt;Next;
402     }
403 
404     free (adapters);
405     return count;
406 
407 err:
408     if (*netifPP) {
409         free_netif (*netifPP);
410     }
411     if (adapters) {
412         free (adapters);
413     }
414     return -1;
415 }
416 
417 /* If *netaddrPP is null, then the addresses are allocated and the beginning
418  * of the allocated chain is returned in *netaddrPP.
419  * If *netaddrPP is not null, then the addresses allocated here are appended
420  * to the existing chain.
421  *
422  * Returns count of addresses or -1 on error.
423  */
424 
425 static int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP) {
426         LPSOCKADDR sock;
427         int        count = 0;
428         netaddr    *curr, *start = NULL, *prev = NULL;
429         PIP_ADAPTER_UNICAST_ADDRESS uni_addr;
430         PIP_ADAPTER_ANYCAST_ADDRESS any_addr;
431         PIP_ADAPTER_PREFIX prefix;
432 
433         /* If chain passed in, find end */
434         if (*netaddrPP != NULL) {
435             for (start=*netaddrPP; start-&gt;next!=NULL; start=start-&gt;next)
436                 ;
437 
438             prev=start;
439         }
440 
441         prefix = ptr-&gt;FirstPrefix;
442         /* Unicast */
443         uni_addr = ptr-&gt;FirstUnicastAddress;
444         while (uni_addr != NULL) {
445         /* address is only usable if dad state is preferred or deprecated */
446                 if (uni_addr-&gt;DadState == IpDadStateDeprecated ||
447                                 uni_addr-&gt;DadState == IpDadStatePreferred) {
448                         sock = uni_addr-&gt;Address.lpSockaddr;
449 
450                         // IPv4 addresses already retrieved with enumAddresses_win
451                         if (sock-&gt;sa_family == AF_INET) {
452                                 uni_addr = uni_addr-&gt;Next;
453                                 continue;
454                         }
455 
456             curr = (netaddr *)calloc (1, sizeof (netaddr));
457 
458             if (curr == NULL)
459                 goto freeAllocatedMemory;
460 
461             if (start == NULL)
462                 start = curr;
463 
464             if (prev != NULL)
465                prev-&gt;next = curr;
466 
467             prev = curr;
468             SOCKETADDRESS_COPY (&amp;curr-&gt;addr, sock);
469             if (prefix != NULL) {
470               curr-&gt;mask = (short)prefix-&gt;PrefixLength;
471               prefix = prefix-&gt;Next;
472             }
473             count ++;
474         }
475         uni_addr = uni_addr-&gt;Next;
476     }
477     /* Anycast */
478     any_addr = ptr-&gt;FirstAnycastAddress;
479     while (any_addr != NULL) {
480         curr = (netaddr *)calloc (1, sizeof (netaddr));
481 
482         if (curr == NULL)
483             goto freeAllocatedMemory;
484 
485         if (start == NULL)
486             start = curr;
487 
488         if (prev != NULL)
489             prev-&gt;next = curr;
490 
491         prev = curr;
492         sock = any_addr-&gt;Address.lpSockaddr;
493         SOCKETADDRESS_COPY (&amp;curr-&gt;addr, sock);
494         count ++;
495         any_addr = any_addr-&gt;Next;
496     }
497     if (*netaddrPP == NULL) {
498         *netaddrPP = start;
499     }
500     return count;
501 
502 freeAllocatedMemory:
503 
504     if (*netaddrPP != NULL) {
505         //N.B. the variable &quot;start&quot; cannot be NULL at this point because we started with an
506         //existing list.
507         curr=start-&gt;next;
508         start-&gt;next = NULL;
509         start = curr;
510     }
511     // otherwise, &quot;start&quot; points to the beginning of an incomplete list that we must deallocate.
512 
513     while (start != NULL) {
514         curr = start-&gt;next;
515         free(start);
516         start = curr;
517     }
518 
519     return -1;
520 }
521 
522 /*
523  * Create a NetworkInterface object, populate the name and index, and
524  * populate the InetAddress array based on the IP addresses for this
525  * interface.
526  */
527 static jobject createNetworkInterfaceXP(JNIEnv *env, netif *ifs)
528 {
529     jobject netifObj;
530     jobject name, displayName;
531     jobjectArray addrArr, bindsArr, childArr;
532     netaddr *addrs;
533     jint addr_index;
534     int netaddrCount = ifs-&gt;naddrs;
535     netaddr *netaddrP = ifs-&gt;addrs;
536     netaddr *netaddrPToFree = NULL;
537     jint bind_index;
538 
539     /*
540      * Create a NetworkInterface object and populate it
541      */
542     netifObj = (*env)-&gt;NewObject(env, ni_class, ni_ctor);
543     if (netifObj == NULL) {
544         return NULL;
545     }
546     name = (*env)-&gt;NewStringUTF(env, ifs-&gt;name);
547     if (name == NULL) {
548         return NULL;
549     }
550     if (ifs-&gt;dNameIsUnicode) {
551         displayName = (*env)-&gt;NewString(env, (PWCHAR)ifs-&gt;displayName,
552                                         (jsize)wcslen ((PWCHAR)ifs-&gt;displayName));
553     } else {
554         displayName = (*env)-&gt;NewStringUTF(env, ifs-&gt;displayName);
555     }
556     if (displayName == NULL) {
557         return NULL;
558     }
559     (*env)-&gt;SetObjectField(env, netifObj, ni_nameID, name);
560     (*env)-&gt;SetObjectField(env, netifObj, ni_displayNameID, displayName);
561     (*env)-&gt;SetIntField(env, netifObj, ni_indexID, ifs-&gt;index);
562     /*
563      * Get the IP addresses for this interface if necessary
564      * Note that 0 is a valid number of addresses.
565      */
566     if (netaddrCount &lt; 0) {
567         netaddrCount = enumAddresses_win(env, ifs, &amp;netaddrPToFree);
568         if (netaddrCount == -1) {
569             return NULL;
570         }
571         if (netaddrCount == -2) {
572             // Clear the exception and continue.
573             if ((*env)-&gt;ExceptionCheck(env)) {
574                 (*env)-&gt;ExceptionClear(env);
575             }
576         }
577         netaddrP = netaddrPToFree;
578     }
579 
580     addrArr = (*env)-&gt;NewObjectArray(env, netaddrCount, ia_class, NULL);
581     if (addrArr == NULL) {
582         free_netaddr(netaddrPToFree);
583         return NULL;
584     }
585 
586     bindsArr = (*env)-&gt;NewObjectArray(env, netaddrCount, ni_ibcls, NULL);
587     if (bindsArr == NULL) {
588         free_netaddr(netaddrPToFree);
589         return NULL;
590     }
591 
592     addrs = netaddrP;
593     addr_index = 0;
594     bind_index = 0;
595     while (addrs != NULL) {
596         jobject iaObj, ia2Obj;
597         jobject ibObj = NULL;
598         if (addrs-&gt;addr.sa.sa_family == AF_INET) {
599             iaObj = (*env)-&gt;NewObject(env, ia4_class, ia4_ctrID);
600             if (iaObj == NULL) {
601                 free_netaddr(netaddrPToFree);
602                 return NULL;
603             }
604             /* default ctor will set family to AF_INET */
605 
606             setInetAddress_addr(env, iaObj, ntohl(addrs-&gt;addr.sa4.sin_addr.s_addr));
607             if ((*env)-&gt;ExceptionCheck(env)) {
608                 free_netaddr(netaddrPToFree);
609                 return NULL;
610             }
611             ibObj = (*env)-&gt;NewObject(env, ni_ibcls, ni_ibctrID);
612             if (ibObj == NULL) {
613                 free_netaddr(netaddrPToFree);
614                 return NULL;
615             }
616             (*env)-&gt;SetObjectField(env, ibObj, ni_ibaddressID, iaObj);
617             ia2Obj = (*env)-&gt;NewObject(env, ia4_class, ia4_ctrID);
618             if (ia2Obj == NULL) {
619                 free_netaddr(netaddrPToFree);
620                 return NULL;
621             }
622             setInetAddress_addr(env, ia2Obj, ntohl(addrs-&gt;brdcast.sa4.sin_addr.s_addr));
623             if ((*env)-&gt;ExceptionCheck(env)) {
624                 free_netaddr(netaddrPToFree);
625                 return NULL;
626             }
627             (*env)-&gt;SetObjectField(env, ibObj, ni_ibbroadcastID, ia2Obj);
628             (*env)-&gt;SetShortField(env, ibObj, ni_ibmaskID, addrs-&gt;mask);
629             (*env)-&gt;SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);
630         } else /* AF_INET6 */ {
631             int scope;
632             jboolean ret;
633             iaObj = (*env)-&gt;NewObject(env, ia6_class, ia6_ctrID);
634             if (iaObj == NULL) {
635                 free_netaddr(netaddrPToFree);
636                 return NULL;
637             }
638             ret = setInet6Address_ipaddress(env, iaObj, (jbyte *)&amp;(addrs-&gt;addr.sa6.sin6_addr.s6_addr));
639             if (ret == JNI_FALSE) {
640                 free_netaddr(netaddrPToFree);
641                 return NULL;
642             }
643             scope = addrs-&gt;addr.sa6.sin6_scope_id;
644             if (scope != 0) { /* zero is default value, no need to set */
645                 setInet6Address_scopeid(env, iaObj, scope);
646                 setInet6Address_scopeifname(env, iaObj, netifObj);
647             }
648             ibObj = (*env)-&gt;NewObject(env, ni_ibcls, ni_ibctrID);
649             if (ibObj == NULL) {
650                 free_netaddr(netaddrPToFree);
651                 return NULL;
652             }
653             (*env)-&gt;SetObjectField(env, ibObj, ni_ibaddressID, iaObj);
654             (*env)-&gt;SetShortField(env, ibObj, ni_ibmaskID, addrs-&gt;mask);
655             (*env)-&gt;SetObjectArrayElement(env, bindsArr, bind_index++, ibObj);
656         }
657         (*env)-&gt;SetObjectArrayElement(env, addrArr, addr_index, iaObj);
658         addrs = addrs-&gt;next;
659         addr_index++;
660     }
661     (*env)-&gt;SetObjectField(env, netifObj, ni_addrsID, addrArr);
662     (*env)-&gt;SetObjectField(env, netifObj, ni_bindsID, bindsArr);
663 
664     free_netaddr(netaddrPToFree);
665 
666     /*
667      * Windows doesn&#39;t have virtual interfaces, so child array
668      * is always empty.
669      */
670     childArr = (*env)-&gt;NewObjectArray(env, 0, ni_class, NULL);
671     if (childArr == NULL) {
672       return NULL;
673     }
674     (*env)-&gt;SetObjectField(env, netifObj, ni_childsID, childArr);
675 
676     /* return the NetworkInterface */
677     return netifObj;
678 }
679 
680 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0_XP
681     (JNIEnv *env, jclass cls, jstring name)
682 {
683     netif *ifList, *curr;
684     jboolean isCopy;
685     const char *name_utf;
686     jobject netifObj = NULL;
687 
688     if (getAllInterfacesAndAddresses (env, &amp;ifList) &lt; 0) {
689         return NULL;
690     }
691 
692     /* get the name as a C string */
693     name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
694 
695     /* Search by name */
696     curr = ifList;
697     while (curr != NULL) {
698         if (strcmp(name_utf, curr-&gt;name) == 0) {
699             break;
700         }
701         curr = curr-&gt;next;
702     }
703 
704     /* if found create a NetworkInterface */
705     if (curr != NULL) {
706         netifObj = createNetworkInterfaceXP(env, curr);
707     }
708 
709     /* release the UTF string */
710     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
711 
712     /* release the interface list */
713     free_netif(ifList);
714 
715     return netifObj;
716 }
717 
718 /*
719  * Class:     NetworkInterface
720  * Method:    getByIndex0_XP
721  * Signature: (I)LNetworkInterface;
722  */
723 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0_XP
724   (JNIEnv *env, jclass cls, jint index)
725 {
726     netif *ifList, *curr;
727     jobject netifObj = NULL;
728 
729     if (getAllInterfacesAndAddresses (env, &amp;ifList) &lt; 0) {
730         return NULL;
731     }
732 
733     /* search by index */
734     curr = ifList;
735     while (curr != NULL) {
736         if (index == curr-&gt;index) {
737             break;
738         }
739         curr = curr-&gt;next;
740     }
741 
742     /* if found create a NetworkInterface */
743     if (curr != NULL) {
744         netifObj = createNetworkInterfaceXP(env, curr);
745     }
746 
747     /* release the interface list */
748     free_netif(ifList);
749 
750     return netifObj;
751 }
752 
753 /*
754  * Class:     java_net_NetworkInterface
755  * Method:    getByInetAddress0
756  * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;
757  */
758 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0_XP
759     (JNIEnv *env, jclass cls, jobject iaObj)
760 {
761     netif *ifList, *curr;
762     jobject netifObj = NULL;
763 
764     /* get the list of interfaces */
765     if (getAllInterfacesAndAddresses (env, &amp;ifList) &lt; 0) {
766         return NULL;
767     }
768 
769     /*
770      * Enumerate the addresses on each interface until we find a
771      * matching address.
772      */
773     curr = ifList;
774     while (curr != NULL) {
775         netaddr *addrList = curr-&gt;addrs;
776         netaddr *addrP;
777 
778         /* iterate through each address */
779         addrP = addrList;
780 
781         while (addrP != NULL) {
782             if (NET_SockaddrEqualsInetAddress(env,
783                                 (struct sockaddr*)&amp;addrP-&gt;addr, iaObj)) {
784                 break;
785             }
786             addrP = addrP-&gt;next;
787         }
788 
789         /*
790          * Address matched so create NetworkInterface for this interface
791          * and address list.
792          */
793         if (addrP != NULL) {
794             netifObj = createNetworkInterfaceXP(env, curr);
795             break;
796         }
797 
798         /* on next interface */
799         curr = curr-&gt;next;
800     }
801 
802     /* release the interface list */
803     free_netif(ifList);
804 
805     return netifObj;
806 }
807 
808 /*
809  * Class:     java_net_NetworkInterface
810  * Method:    getAll
811  * Signature: ()[Ljava/net/NetworkInterface;
812  */
813 JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll_XP
814     (JNIEnv *env, jclass cls)
815 {
816     int count;
817     netif *ifList = NULL, *curr;
818     jobjectArray netIFArr;
819     jint arr_index;
820 
821     /*
822      * Get list of interfaces
823      */
824     count = getAllInterfacesAndAddresses (env, &amp;ifList);
825     if (count &lt; 0) {
826         return NULL;
827     }
828 
829     /* allocate a NetworkInterface array */
830     netIFArr = (*env)-&gt;NewObjectArray(env, count, cls, NULL);
831     if (netIFArr == NULL) {
832         free_netif(ifList);
833         return NULL;
834     }
835 
836     /*
837      * Iterate through the interfaces, create a NetworkInterface instance
838      * for each array element and populate the object.
839      */
840     curr = ifList;
841     arr_index = 0;
842     while (curr != NULL) {
843         jobject netifObj;
844 
845         netifObj = createNetworkInterfaceXP(env, curr);
846         if (netifObj == NULL) {
847             free_netif(ifList);
848             return NULL;
849         }
850 
851         /* put the NetworkInterface into the array */
852         (*env)-&gt;SetObjectArrayElement(env, netIFArr, arr_index++, netifObj);
853         curr = curr-&gt;next;
854     }
855 
856     /* release the interface list */
857     free_netif(ifList);
858 
859     return netIFArr;
860 }
861 
862 /*
863  * Class:     java_net_NetworkInterface
864  * Method:    supportsMulticast0
865  * Signature: (Ljava/lang/String;I)Z
866  */
867 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0_XP
868     (JNIEnv *env, jclass cls, jstring name, jint index) {
869       IP_ADAPTER_ADDRESSES *ptr;
870       jboolean val = JNI_TRUE;
871 
872       ptr = getAdapter(env, index);
873       if (ptr != NULL) {
874         val = ptr-&gt;Flags &amp; IP_ADAPTER_NO_MULTICAST ? JNI_FALSE : JNI_TRUE;
875         free(ptr);
876       }
877       return val;
878 }
879 
880 /*
881  * Class:     java_net_NetworkInterface
882  * Method:    isUp0
883  * Signature: (Ljava/lang/String;I)Z
884  */
885 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0_XP
886     (JNIEnv *env, jclass cls, jstring name, jint index) {
887       IP_ADAPTER_ADDRESSES *ptr;
888       jboolean val = JNI_FALSE;
889 
890       ptr = getAdapter(env, index);
891       if (ptr != NULL) {
892         val = ptr-&gt;OperStatus == IfOperStatusUp ? JNI_TRUE : JNI_FALSE;
893         free(ptr);
894       }
895       return val;
896 }
897 
898 /*
899  * Class:     java_net_NetworkInterface
900  * Method:    getMacAddr0
901  * Signature: (Ljava/lang/String;I)Z
902  */
903 JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0_XP
904     (JNIEnv *env, jclass cls, jstring name, jint index) {
905       IP_ADAPTER_ADDRESSES *ptr;
906       jbyteArray ret = NULL;
907       int len;
908 
909       ptr = getAdapter(env, index);
910       if (ptr != NULL) {
911         len = ptr-&gt;PhysicalAddressLength;
912         if (len &gt; 0) {
913           ret = (*env)-&gt;NewByteArray(env, len);
914           if (!IS_NULL(ret)) {
915             (*env)-&gt;SetByteArrayRegion(env, ret, 0, len,
916                                        (jbyte*) ptr-&gt;PhysicalAddress);
917           }
918         }
919         free(ptr);
920       }
921       return ret;
922 }
923 
924 /*
925  * Class:       java_net_NetworkInterface
926  * Method:      getMTU0
927  * Signature:   ([bLjava/lang/String;I)I
928  */
929 JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0_XP
930     (JNIEnv *env, jclass cls, jstring name, jint index) {
931       IP_ADAPTER_ADDRESSES *ptr;
932       jint ret = -1;
933 
934       ptr = getAdapter(env, index);
935       if (ptr != NULL) {
936         ret = ptr-&gt;Mtu;
937         free(ptr);
938       }
939       return ret;
940 }
941 
942 /*
943  * Class:     java_net_NetworkInterface
944  * Method:    isLoopback0
945  * Signature: (Ljava/lang/String;I)Z
946  */
947 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0_XP
948     (JNIEnv *env, jclass cls, jstring name, jint index) {
949       IP_ADAPTER_ADDRESSES *ptr;
950       jboolean val = JNI_FALSE;
951 
952       ptr = getAdapter(env, index);
953       if (ptr != NULL) {
954         val = ptr-&gt;IfType == IF_TYPE_SOFTWARE_LOOPBACK ? JNI_TRUE : JNI_FALSE;
955         free(ptr);
956       }
957       return val;
958 }
959 
960 /*
961  * Class:     java_net_NetworkInterface
962  * Method:    isP2P0
963  * Signature: (Ljava/lang/String;I)Z
964  */
965 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0_XP
966     (JNIEnv *env, jclass cls, jstring name, jint index) {
967       IP_ADAPTER_ADDRESSES *ptr;
968       jboolean val = JNI_FALSE;
969 
970       ptr = getAdapter(env, index);
971       if (ptr != NULL) {
972         if (ptr-&gt;IfType == IF_TYPE_PPP || ptr-&gt;IfType == IF_TYPE_SLIP ||
973            ptr-&gt;IfType == IF_TYPE_TUNNEL) {
974           val = JNI_TRUE;
975         }
976         free(ptr);
977       }
978       return val;
979 }
    </pre>
  </body>
</html>
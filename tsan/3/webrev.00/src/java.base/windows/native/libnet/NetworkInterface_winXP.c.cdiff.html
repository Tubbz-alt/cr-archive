<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/windows/native/libnet/NetworkInterface_winXP.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="NetworkInterface.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ResolverConfigurationImpl.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnet/NetworkInterface_winXP.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,19 ***</span>
   * Windows implementation of the java.net.NetworkInterface native methods.
   * This module provides the implementations of getAll, getByName, getByIndex,
   * and getByAddress.
   */
  
  extern int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP);
  int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP);
  
  #ifdef DEBUG
  void printnif (netif *nif) {
  #ifdef _WIN64
          printf (&quot;nif:0x%I64x name:%s\n&quot;, (UINT_PTR)nif, nif-&gt;name);
  #else
<span class="line-modified">!         printf (&quot;nif:0x%x name:%s\n&quot;, nif, nif-&gt;name);</span>
  #endif
          if (nif-&gt;dNameIsUnicode) {
              printf (&quot;dName:%S index:%d &quot;, (unsigned short *)nif-&gt;displayName,
                  nif-&gt;index);
          } else {
<span class="line-new-header">--- 31,21 ---</span>
   * Windows implementation of the java.net.NetworkInterface native methods.
   * This module provides the implementations of getAll, getByName, getByIndex,
   * and getByAddress.
   */
  
<span class="line-added">+ extern int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP);</span>
  extern int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP);
<span class="line-added">+ extern int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP);</span>
  int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP);
  
  #ifdef DEBUG
  void printnif (netif *nif) {
  #ifdef _WIN64
          printf (&quot;nif:0x%I64x name:%s\n&quot;, (UINT_PTR)nif, nif-&gt;name);
  #else
<span class="line-modified">!         printf (&quot;nif:0x%x name:%s\n&quot;, (UINT_PTR)nif, nif-&gt;name);</span>
  #endif
          if (nif-&gt;dNameIsUnicode) {
              printf (&quot;dName:%S index:%d &quot;, (unsigned short *)nif-&gt;displayName,
                  nif-&gt;index);
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,12 ***</span>
  /*
   * return an array of IP_ADAPTER_ADDRESSES containing one element
   * for each adapter on the system. Returned in *adapters.
   * Buffer is malloc&#39;d and must be freed (unless error returned)
   */
<span class="line-modified">! static int getAdapters (JNIEnv *env, IP_ADAPTER_ADDRESSES **adapters) {</span>
<span class="line-modified">!     DWORD ret, flags;</span>
      IP_ADAPTER_ADDRESSES *adapterInfo;
      ULONG len;
      int try;
  
      adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);
<span class="line-new-header">--- 71,12 ---</span>
  /*
   * return an array of IP_ADAPTER_ADDRESSES containing one element
   * for each adapter on the system. Returned in *adapters.
   * Buffer is malloc&#39;d and must be freed (unless error returned)
   */
<span class="line-modified">! int getAdapters (JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters) {</span>
<span class="line-modified">!     DWORD ret;</span>
      IP_ADAPTER_ADDRESSES *adapterInfo;
      ULONG len;
      int try;
  
      adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,13 ***</span>
              &quot;Native heap allocation failure&quot;);
          return -1;
      }
  
      len = BUFF_SIZE;
<span class="line-removed">-     flags = GAA_FLAG_SKIP_DNS_SERVER;</span>
<span class="line-removed">-     flags |= GAA_FLAG_SKIP_MULTICAST;</span>
<span class="line-removed">-     flags |= GAA_FLAG_INCLUDE_PREFIX;</span>
      ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &amp;len);
  
      for (try = 0; ret == ERROR_BUFFER_OVERFLOW &amp;&amp; try &lt; MAX_TRIES; ++try) {
          IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;
          if (len &lt; (ULONG_MAX - BUFF_SIZE)) {
<span class="line-new-header">--- 85,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,11 ***</span>
  
  /*
   */
  int getAllInterfacesAndAddresses (JNIEnv *env, netif **netifPP)
  {
<span class="line-modified">!     DWORD ret;</span>
      IP_ADAPTER_ADDRESSES *ptr, *adapters=NULL;
      ULONG len=ipinflen, count=0;
      netif *nif=NULL, *dup_nif, *last=NULL, *loopif=NULL, *curr;
      int tun=0, net=0;
  
<span class="line-new-header">--- 235,12 ---</span>
  
  /*
   */
  int getAllInterfacesAndAddresses (JNIEnv *env, netif **netifPP)
  {
<span class="line-modified">!     DWORD ret, flags;</span>
<span class="line-added">+     MIB_IPADDRTABLE *tableP;</span>
      IP_ADAPTER_ADDRESSES *ptr, *adapters=NULL;
      ULONG len=ipinflen, count=0;
      netif *nif=NULL, *dup_nif, *last=NULL, *loopif=NULL, *curr;
      int tun=0, net=0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,14 ***</span>
          last = nif;
      }
  
      // Retrieve IPv4 addresses with the IP Helper API
      curr = *netifPP;
      while (curr != NULL) {
          netaddr *netaddrP;
<span class="line-modified">!         ret = enumAddresses_win(env, curr, &amp;netaddrP);</span>
          if (ret == -1) {
              return -1;
          } else if (ret == -2) {
              if ((*env)-&gt;ExceptionCheck(env)) {
                  (*env)-&gt;ExceptionClear(env);
              }
<span class="line-new-header">--- 269,19 ---</span>
          last = nif;
      }
  
      // Retrieve IPv4 addresses with the IP Helper API
      curr = *netifPP;
<span class="line-added">+     ret = lookupIPAddrTable(env, &amp;tableP);</span>
<span class="line-added">+     if (ret &lt; 0) {</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     }</span>
      while (curr != NULL) {
          netaddr *netaddrP;
<span class="line-modified">!         ret = enumAddresses_win_ipaddrtable(env, curr, &amp;netaddrP, tableP);</span>
          if (ret == -1) {
<span class="line-added">+             free(tableP);</span>
              return -1;
          } else if (ret == -2) {
              if ((*env)-&gt;ExceptionCheck(env)) {
                  (*env)-&gt;ExceptionClear(env);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,12 ***</span>
              curr-&gt;addrs = netaddrP;
              curr-&gt;naddrs += ret;
              curr = curr-&gt;next;
          }
      }
  
<span class="line-modified">!     ret = getAdapters (env, &amp;adapters);</span>
      if (ret != ERROR_SUCCESS) {
          goto err;
      }
  
      /* Now get the IPv6 information. This includes:
<span class="line-new-header">--- 290,16 ---</span>
              curr-&gt;addrs = netaddrP;
              curr-&gt;naddrs += ret;
              curr = curr-&gt;next;
          }
      }
<span class="line-added">+     free(tableP);</span>
  
<span class="line-modified">!     flags = GAA_FLAG_SKIP_DNS_SERVER;</span>
<span class="line-added">+     flags |= GAA_FLAG_SKIP_MULTICAST;</span>
<span class="line-added">+     flags |= GAA_FLAG_INCLUDE_PREFIX;</span>
<span class="line-added">+     ret = getAdapters (env, flags, &amp;adapters);</span>
      if (ret != ERROR_SUCCESS) {
          goto err;
      }
  
      /* Now get the IPv6 information. This includes:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,10 ***</span>
<span class="line-new-header">--- 323,11 ---</span>
              c = getAddrsFromAdapter(ptr, &amp;loopif-&gt;addrs);
              if (c == -1) {
                  goto err;
              }
              loopif-&gt;naddrs += c;
<span class="line-added">+             loopif-&gt;ipv6Index = ptr-&gt;Ipv6IfIndex;</span>
          } else {
              int index = ptr-&gt;IfIndex;
              if (index != 0) {
                  /* This entry is associated with an IPv4 interface */
                  for (nif=*netifPP; nif!=NULL; nif=nif-&gt;next) {
</pre>
<center><a href="NetworkInterface.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="ResolverConfigurationImpl.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libnet/ResolverConfigurationImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="NetworkInterface_winXP.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TwoStacksPlainDatagramSocketImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnet/ResolverConfigurationImpl.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;
<span class="line-removed"> 27 #include &lt;windows.h&gt;</span>
 28 #include &lt;stdio.h&gt;
 29 #include &lt;stddef.h&gt;
<span class="line-removed"> 30 #include &lt;iprtrmib.h&gt;</span>
 31 #include &lt;time.h&gt;
 32 #include &lt;assert.h&gt;
<span class="line-removed"> 33 #include &lt;iphlpapi.h&gt;</span>
 34 

 35 #include &quot;jni_util.h&quot;
 36 
<span class="line-modified"> 37 #define MAX_STR_LEN         256</span>
 38 
 39 #define STS_NO_CONFIG       0x0             /* no configuration found */
 40 #define STS_SL_FOUND        0x1             /* search list found */
 41 #define STS_NS_FOUND        0x2             /* name servers found */
 42 #define STS_ERROR           -1              /* error return  lodConfig failed memory allccation failure*/
 43 
 44 #define IS_SL_FOUND(sts)    (sts &amp; STS_SL_FOUND)
 45 #define IS_NS_FOUND(sts)    (sts &amp; STS_NS_FOUND)
 46 
 47 /* JNI ids */
 48 static jfieldID searchlistID;
 49 static jfieldID nameserversID;
 50 


 51 /*
<span class="line-modified"> 52  * Utility routine to append s2 to s1 with a space delimiter.</span>
<span class="line-modified"> 53  *  strappend(s1=&quot;abc&quot;, &quot;def&quot;)  =&gt; &quot;abc def&quot;</span>
 54  *  strappend(s1=&quot;&quot;, &quot;def&quot;)     =&gt; &quot;def
 55  */
 56 void strappend(char *s1, char *s2) {
 57     size_t len;
 58 
 59     if (s2[0] == &#39;\0&#39;)                      /* nothing to append */
 60         return;
 61 
 62     len = strlen(s1)+1;
<span class="line-modified"> 63     if (s1[0] != 0)                         /* needs space character */</span>
 64         len++;
 65     if (len + strlen(s2) &gt; MAX_STR_LEN)     /* insufficient space */
 66         return;
 67 
 68     if (s1[0] != 0) {
<span class="line-modified"> 69         strcat(s1, &quot; &quot;);</span>
 70     }
 71     strcat(s1, s2);
 72 }
 73 
 74 /*
<span class="line-modified"> 75  * Windows 2000/XP</span>
<span class="line-modified"> 76  *</span>
<span class="line-removed"> 77  * Use registry approach based on settings described in Appendix C</span>
<span class="line-removed"> 78  * of &quot;Microsoft Windows 2000 TCP/IP Implementation Details&quot;.</span>
<span class="line-removed"> 79  *</span>
<span class="line-removed"> 80  * DNS suffix list is obtained from SearchList registry setting. If</span>
<span class="line-removed"> 81  * this is not specified we compile suffix list based on the</span>
<span class="line-removed"> 82  * per-connection domain suffix.</span>
<span class="line-removed"> 83  *</span>
<span class="line-removed"> 84  * DNS name servers and domain settings are on a per-connection</span>
<span class="line-removed"> 85  * basic. We therefore enumerate the network adapters to get the</span>
<span class="line-removed"> 86  * names of each adapter and then query the corresponding registry</span>
<span class="line-removed"> 87  * settings to obtain NameServer/DhcpNameServer and Domain/DhcpDomain.</span>
 88  */
<span class="line-modified"> 89 static int loadConfig(char *sl, char *ns) {</span>
<span class="line-modified"> 90     IP_ADAPTER_INFO *adapterP;</span>
<span class="line-modified"> 91     ULONG size;</span>
<span class="line-modified"> 92     DWORD ret;</span>

 93     DWORD dwLen;
 94     ULONG ulType;
 95     char result[MAX_STR_LEN];
 96     HANDLE hKey;
<span class="line-modified"> 97     int gotSearchList = 0;</span>

 98 
 99     /*
100      * First see if there is a global suffix list specified.
101      */
102     ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
103                        &quot;SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters&quot;,
104                        0,
105                        KEY_READ,
106                        (PHKEY)&amp;hKey);
107     if (ret == ERROR_SUCCESS) {
108         dwLen = sizeof(result);
109         ret = RegQueryValueEx(hKey, &quot;SearchList&quot;, NULL, &amp;ulType,
110                              (LPBYTE)&amp;result, &amp;dwLen);
111         if (ret == ERROR_SUCCESS) {
112             assert(ulType == REG_SZ);
113             if (strlen(result) &gt; 0) {
114                 strappend(sl, result);
<span class="line-removed">115                 gotSearchList = 1;</span>
116             }
117         }
118         RegCloseKey(hKey);
119     }
120 
<span class="line-removed">121     /*</span>
<span class="line-removed">122      * Ask the IP Helper library to enumerate the adapters</span>
<span class="line-removed">123      */</span>
<span class="line-removed">124     size = sizeof(IP_ADAPTER_INFO);</span>
<span class="line-removed">125     adapterP = (IP_ADAPTER_INFO *)malloc(size);</span>
<span class="line-removed">126     if (adapterP == NULL) {</span>
<span class="line-removed">127         return STS_ERROR;</span>
<span class="line-removed">128     }</span>
<span class="line-removed">129     ret = GetAdaptersInfo(adapterP, &amp;size);</span>
<span class="line-removed">130     if (ret == ERROR_BUFFER_OVERFLOW) {</span>
<span class="line-removed">131         IP_ADAPTER_INFO *newAdapterP = (IP_ADAPTER_INFO *)realloc(adapterP, size);</span>
<span class="line-removed">132         if (newAdapterP == NULL) {</span>
<span class="line-removed">133             free(adapterP);</span>
<span class="line-removed">134             return STS_ERROR;</span>
<span class="line-removed">135         }</span>
<span class="line-removed">136         adapterP = newAdapterP;</span>
137 
<span class="line-modified">138         ret = GetAdaptersInfo(adapterP, &amp;size);</span>








139     }
140 
<span class="line-modified">141     /*</span>
<span class="line-modified">142      * Iterate through the list of adapters as registry settings are</span>
<span class="line-modified">143      * keyed on the adapter name (GUID).</span>
<span class="line-modified">144      */</span>
<span class="line-modified">145     if (ret == ERROR_SUCCESS) {</span>
<span class="line-modified">146         IP_ADAPTER_INFO *curr = adapterP;</span>
<span class="line-modified">147         while (curr != NULL) {</span>
<span class="line-modified">148             char key[MAX_STR_LEN];</span>
<span class="line-modified">149 </span>
<span class="line-modified">150             sprintf(key,</span>
<span class="line-modified">151                 &quot;SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\%s&quot;,</span>
<span class="line-modified">152                 curr-&gt;AdapterName);</span>
<span class="line-modified">153 </span>
<span class="line-modified">154             ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span>
<span class="line-modified">155                                key,</span>
<span class="line-removed">156                                0,</span>
<span class="line-removed">157                                KEY_READ,</span>
<span class="line-removed">158                                (PHKEY)&amp;hKey);</span>
<span class="line-removed">159             if (ret == ERROR_SUCCESS) {</span>
<span class="line-removed">160                 DWORD enableDhcp = 0;</span>
<span class="line-removed">161 </span>
<span class="line-removed">162                 /*</span>
<span class="line-removed">163                  * Is DHCP enabled on this interface</span>
<span class="line-removed">164                  */</span>
<span class="line-removed">165                 dwLen = sizeof(enableDhcp);</span>
<span class="line-removed">166                 ret = RegQueryValueEx(hKey, &quot;EnableDhcp&quot;, NULL, &amp;ulType,</span>
<span class="line-removed">167                                      (LPBYTE)&amp;enableDhcp, &amp;dwLen);</span>
<span class="line-removed">168 </span>
<span class="line-removed">169                 /*</span>
<span class="line-removed">170                  * If we don&#39;t have the suffix list when get the Domain</span>
<span class="line-removed">171                  * or DhcpDomain. If DHCP is enabled then Domain overides</span>
<span class="line-removed">172                  * DhcpDomain</span>
<span class="line-removed">173                  */</span>
<span class="line-removed">174                 if (!gotSearchList) {</span>
<span class="line-removed">175                     result[0] = &#39;\0&#39;;</span>
<span class="line-removed">176                     dwLen = sizeof(result);</span>
<span class="line-removed">177                     ret = RegQueryValueEx(hKey, &quot;Domain&quot;, NULL, &amp;ulType,</span>
<span class="line-removed">178                                          (LPBYTE)&amp;result, &amp;dwLen);</span>
<span class="line-removed">179                     if (((ret != ERROR_SUCCESS) || (strlen(result) == 0)) &amp;&amp;</span>
<span class="line-removed">180                         enableDhcp) {</span>
<span class="line-removed">181                         dwLen = sizeof(result);</span>
<span class="line-removed">182                         ret = RegQueryValueEx(hKey, &quot;DhcpDomain&quot;, NULL, &amp;ulType,</span>
<span class="line-removed">183                                               (LPBYTE)&amp;result, &amp;dwLen);</span>
<span class="line-removed">184                     }</span>
<span class="line-removed">185                     if (ret == ERROR_SUCCESS) {</span>
<span class="line-removed">186                         assert(ulType == REG_SZ);</span>
<span class="line-removed">187                         strappend(sl, result);</span>
188                     }
189                 }
190 
<span class="line-removed">191                 /*</span>
<span class="line-removed">192                  * Get DNS servers based on NameServer or DhcpNameServer</span>
<span class="line-removed">193                  * registry setting. If NameServer is set then it overrides</span>
<span class="line-removed">194                  * DhcpNameServer (even if DHCP is enabled).</span>
<span class="line-removed">195                  */</span>
<span class="line-removed">196                 result[0] = &#39;\0&#39;;</span>
197                 dwLen = sizeof(result);
<span class="line-modified">198                 ret = RegQueryValueEx(hKey, &quot;NameServer&quot;, NULL, &amp;ulType,</span>
<span class="line-modified">199                                      (LPBYTE)&amp;result, &amp;dwLen);</span>
<span class="line-modified">200                 if (((ret != ERROR_SUCCESS) || (strlen(result) == 0)) &amp;&amp;</span>
<span class="line-modified">201                     enableDhcp) {</span>
<span class="line-removed">202                     dwLen = sizeof(result);</span>
<span class="line-removed">203                     ret = RegQueryValueEx(hKey, &quot;DhcpNameServer&quot;, NULL, &amp;ulType,</span>
<span class="line-removed">204                                           (LPBYTE)&amp;result, &amp;dwLen);</span>
<span class="line-removed">205                 }</span>
<span class="line-removed">206                 if (ret == ERROR_SUCCESS) {</span>
<span class="line-removed">207                     assert(ulType == REG_SZ);</span>
208                     strappend(ns, result);
209                 }
210 
<span class="line-modified">211                 /*</span>
<span class="line-removed">212                  * Finished with this registry key</span>
<span class="line-removed">213                  */</span>
<span class="line-removed">214                 RegCloseKey(hKey);</span>
215             }
216 
<span class="line-modified">217             /*</span>
<span class="line-modified">218              * Onto the next adapeter</span>
<span class="line-modified">219              */</span>
<span class="line-modified">220             curr = curr-&gt;Next;</span>





221         }
<span class="line-removed">222     }</span>
223 
<span class="line-modified">224     /*</span>
<span class="line-removed">225      * Free the adpater structure</span>
<span class="line-removed">226      */</span>
<span class="line-removed">227     if (adapterP) {</span>
<span class="line-removed">228         free(adapterP);</span>
229     }
230 


231     return STS_SL_FOUND &amp; STS_NS_FOUND;
232 }
233 
234 
235 /*
<span class="line-modified">236  * Initialize JNI field IDs.</span>
237  */
238 JNIEXPORT void JNICALL
239 Java_sun_net_dns_ResolverConfigurationImpl_init0(JNIEnv *env, jclass cls)
240 {
241     searchlistID = (*env)-&gt;GetStaticFieldID(env, cls, &quot;os_searchlist&quot;,
242                                       &quot;Ljava/lang/String;&quot;);
243     CHECK_NULL(searchlistID);
244     nameserversID = (*env)-&gt;GetStaticFieldID(env, cls, &quot;os_nameservers&quot;,
245                                       &quot;Ljava/lang/String;&quot;);
246 }
247 
248 /*
249  * Class:     sun_net_dns_ResolverConfgurationImpl
250  * Method:    loadConfig0
251  * Signature: ()V
252  */
253 JNIEXPORT void JNICALL
254 Java_sun_net_dns_ResolverConfigurationImpl_loadDNSconfig0(JNIEnv *env, jclass cls)
255 {
256     char searchlist[MAX_STR_LEN];
257     char nameservers[MAX_STR_LEN];
258     jstring obj;
259 
260     searchlist[0] = &#39;\0&#39;;
261     nameservers[0] = &#39;\0&#39;;
262 
<span class="line-modified">263     if (loadConfig(searchlist, nameservers) != STS_ERROR) {</span>
264 
265         /*
266          * Populate static fields in sun.net.DefaultResolverConfiguration
267          */
268         obj = (*env)-&gt;NewStringUTF(env, searchlist);
269         CHECK_NULL(obj);
270         (*env)-&gt;SetStaticObjectField(env, cls, searchlistID, obj);
271 
272         obj = (*env)-&gt;NewStringUTF(env, nameservers);
273         CHECK_NULL(obj);
274         (*env)-&gt;SetStaticObjectField(env, cls, nameserversID, obj);
<span class="line-removed">275     } else {</span>
<span class="line-removed">276         JNU_ThrowOutOfMemoryError(env, &quot;native memory allocation failed&quot;);</span>
277     }
278 }
279 
280 
281 /*
282  * Class:     sun_net_dns_ResolverConfgurationImpl
283  * Method:    notifyAddrChange0
284  * Signature: ()I
285  */
286 JNIEXPORT jint JNICALL
287 Java_sun_net_dns_ResolverConfigurationImpl_notifyAddrChange0(JNIEnv *env, jclass cls)
288 {
289     OVERLAPPED ol;
290     HANDLE h;
291     DWORD rc, xfer;
292 
293     ol.hEvent = (HANDLE)0;
294     rc = NotifyAddrChange(&amp;h, &amp;ol);
295     if (rc == ERROR_IO_PENDING) {
296         rc = GetOverlappedResult(h, &amp;ol, &amp;xfer, TRUE);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;

 27 #include &lt;stdio.h&gt;
 28 #include &lt;stddef.h&gt;

 29 #include &lt;time.h&gt;
 30 #include &lt;assert.h&gt;

 31 
<span class="line-added"> 32 #include &quot;net_util.h&quot;</span>
 33 #include &quot;jni_util.h&quot;
 34 
<span class="line-modified"> 35 #define MAX_STR_LEN         1024</span>
 36 
 37 #define STS_NO_CONFIG       0x0             /* no configuration found */
 38 #define STS_SL_FOUND        0x1             /* search list found */
 39 #define STS_NS_FOUND        0x2             /* name servers found */
 40 #define STS_ERROR           -1              /* error return  lodConfig failed memory allccation failure*/
 41 
 42 #define IS_SL_FOUND(sts)    (sts &amp; STS_SL_FOUND)
 43 #define IS_NS_FOUND(sts)    (sts &amp; STS_NS_FOUND)
 44 
 45 /* JNI ids */
 46 static jfieldID searchlistID;
 47 static jfieldID nameserversID;
 48 
<span class="line-added"> 49 extern int getAdapters(JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters);</span>
<span class="line-added"> 50 </span>
 51 /*
<span class="line-modified"> 52  * Utility routine to append s2 to s1 with a comma delimiter.</span>
<span class="line-modified"> 53  *  strappend(s1=&quot;abc&quot;, &quot;def&quot;)  =&gt; &quot;abc,def&quot;</span>
 54  *  strappend(s1=&quot;&quot;, &quot;def&quot;)     =&gt; &quot;def
 55  */
 56 void strappend(char *s1, char *s2) {
 57     size_t len;
 58 
 59     if (s2[0] == &#39;\0&#39;)                      /* nothing to append */
 60         return;
 61 
 62     len = strlen(s1)+1;
<span class="line-modified"> 63     if (s1[0] != 0)                         /* needs comma character */</span>
 64         len++;
 65     if (len + strlen(s2) &gt; MAX_STR_LEN)     /* insufficient space */
 66         return;
 67 
 68     if (s1[0] != 0) {
<span class="line-modified"> 69         strcat(s1, &quot;,&quot;);</span>
 70     }
 71     strcat(s1, s2);
 72 }
 73 
 74 /*
<span class="line-modified"> 75  * Use DNS server addresses returned by GetAdaptersAddresses for currently</span>
<span class="line-modified"> 76  * active interfaces.</span>











 77  */
<span class="line-modified"> 78 static int loadConfig(JNIEnv *env, char *sl, char *ns) {</span>
<span class="line-modified"> 79     IP_ADAPTER_ADDRESSES *adapters, *adapter;</span>
<span class="line-modified"> 80     IP_ADAPTER_DNS_SERVER_ADDRESS *dnsServer;</span>
<span class="line-modified"> 81     WCHAR *suffix;</span>
<span class="line-added"> 82     DWORD ret, flags;</span>
 83     DWORD dwLen;
 84     ULONG ulType;
 85     char result[MAX_STR_LEN];
 86     HANDLE hKey;
<span class="line-modified"> 87     SOCKADDR *sockAddr;</span>
<span class="line-added"> 88     struct sockaddr_in6 *sockAddrIpv6;</span>
 89 
 90     /*
 91      * First see if there is a global suffix list specified.
 92      */
 93     ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
 94                        &quot;SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters&quot;,
 95                        0,
 96                        KEY_READ,
 97                        (PHKEY)&amp;hKey);
 98     if (ret == ERROR_SUCCESS) {
 99         dwLen = sizeof(result);
100         ret = RegQueryValueEx(hKey, &quot;SearchList&quot;, NULL, &amp;ulType,
101                              (LPBYTE)&amp;result, &amp;dwLen);
102         if (ret == ERROR_SUCCESS) {
103             assert(ulType == REG_SZ);
104             if (strlen(result) &gt; 0) {
105                 strappend(sl, result);

106             }
107         }
108         RegCloseKey(hKey);
109     }
110 
















111 
<span class="line-modified">112     // We only need DNS server addresses so skip everything else.</span>
<span class="line-added">113     flags = GAA_FLAG_SKIP_UNICAST;</span>
<span class="line-added">114     flags |= GAA_FLAG_SKIP_ANYCAST;</span>
<span class="line-added">115     flags |= GAA_FLAG_SKIP_MULTICAST;</span>
<span class="line-added">116     flags |= GAA_FLAG_SKIP_FRIENDLY_NAME;</span>
<span class="line-added">117     ret = getAdapters(env, flags, &amp;adapters);</span>
<span class="line-added">118 </span>
<span class="line-added">119     if (ret != ERROR_SUCCESS) {</span>
<span class="line-added">120         return STS_ERROR;</span>
121     }
122 
<span class="line-modified">123     adapter = adapters;</span>
<span class="line-modified">124     while (adapter != NULL) {</span>
<span class="line-modified">125         // Only load config from enabled adapters.</span>
<span class="line-modified">126         if (adapter-&gt;OperStatus == IfOperStatusUp) {</span>
<span class="line-modified">127             dnsServer = adapter-&gt;FirstDnsServerAddress;</span>
<span class="line-modified">128             while (dnsServer != NULL) {</span>
<span class="line-modified">129                 sockAddr = dnsServer-&gt;Address.lpSockaddr;</span>
<span class="line-modified">130                 if (sockAddr-&gt;sa_family == AF_INET6) {</span>
<span class="line-modified">131                     sockAddrIpv6 = (struct sockaddr_in6 *)sockAddr;</span>
<span class="line-modified">132                     if (sockAddrIpv6-&gt;sin6_scope_id != 0) {</span>
<span class="line-modified">133                         // An address with a scope is either link-local or</span>
<span class="line-modified">134                         // site-local, which aren&#39;t valid for DNS queries so</span>
<span class="line-modified">135                         // we can skip them.</span>
<span class="line-modified">136                         dnsServer = dnsServer-&gt;Next;</span>
<span class="line-modified">137                         continue;</span>
































138                     }
139                 }
140 






141                 dwLen = sizeof(result);
<span class="line-modified">142                 ret = WSAAddressToStringA(sockAddr,</span>
<span class="line-modified">143                           dnsServer-&gt;Address.iSockaddrLength, NULL,</span>
<span class="line-modified">144                           result, &amp;dwLen);</span>
<span class="line-modified">145                 if (ret == 0) {</span>






146                     strappend(ns, result);
147                 }
148 
<span class="line-modified">149                 dnsServer = dnsServer-&gt;Next;</span>



150             }
151 
<span class="line-modified">152             // Add connection-specific search domains in addition to global one.</span>
<span class="line-modified">153             suffix = adapter-&gt;DnsSuffix;</span>
<span class="line-modified">154             if (suffix != NULL) {</span>
<span class="line-modified">155                 ret = WideCharToMultiByte(CP_UTF8, 0, suffix, -1,</span>
<span class="line-added">156                     result, sizeof(result), NULL, NULL);</span>
<span class="line-added">157                 if (ret != 0) {</span>
<span class="line-added">158                     strappend(sl, result);</span>
<span class="line-added">159                 }</span>
<span class="line-added">160             }</span>
161         }

162 
<span class="line-modified">163         adapter = adapter-&gt;Next;</span>




164     }
165 
<span class="line-added">166     free(adapters);</span>
<span class="line-added">167 </span>
168     return STS_SL_FOUND &amp; STS_NS_FOUND;
169 }
170 
171 
172 /*
<span class="line-modified">173  * Initialize JNI field IDs and classes.</span>
174  */
175 JNIEXPORT void JNICALL
176 Java_sun_net_dns_ResolverConfigurationImpl_init0(JNIEnv *env, jclass cls)
177 {
178     searchlistID = (*env)-&gt;GetStaticFieldID(env, cls, &quot;os_searchlist&quot;,
179                                       &quot;Ljava/lang/String;&quot;);
180     CHECK_NULL(searchlistID);
181     nameserversID = (*env)-&gt;GetStaticFieldID(env, cls, &quot;os_nameservers&quot;,
182                                       &quot;Ljava/lang/String;&quot;);
183 }
184 
185 /*
186  * Class:     sun_net_dns_ResolverConfgurationImpl
187  * Method:    loadConfig0
188  * Signature: ()V
189  */
190 JNIEXPORT void JNICALL
191 Java_sun_net_dns_ResolverConfigurationImpl_loadDNSconfig0(JNIEnv *env, jclass cls)
192 {
193     char searchlist[MAX_STR_LEN];
194     char nameservers[MAX_STR_LEN];
195     jstring obj;
196 
197     searchlist[0] = &#39;\0&#39;;
198     nameservers[0] = &#39;\0&#39;;
199 
<span class="line-modified">200     if (loadConfig(env, searchlist, nameservers) != STS_ERROR) {</span>
201 
202         /*
203          * Populate static fields in sun.net.DefaultResolverConfiguration
204          */
205         obj = (*env)-&gt;NewStringUTF(env, searchlist);
206         CHECK_NULL(obj);
207         (*env)-&gt;SetStaticObjectField(env, cls, searchlistID, obj);
208 
209         obj = (*env)-&gt;NewStringUTF(env, nameservers);
210         CHECK_NULL(obj);
211         (*env)-&gt;SetStaticObjectField(env, cls, nameserversID, obj);


212     }
213 }
214 
215 
216 /*
217  * Class:     sun_net_dns_ResolverConfgurationImpl
218  * Method:    notifyAddrChange0
219  * Signature: ()I
220  */
221 JNIEXPORT jint JNICALL
222 Java_sun_net_dns_ResolverConfigurationImpl_notifyAddrChange0(JNIEnv *env, jclass cls)
223 {
224     OVERLAPPED ol;
225     HANDLE h;
226     DWORD rc, xfer;
227 
228     ol.hEvent = (HANDLE)0;
229     rc = NotifyAddrChange(&amp;h, &amp;ol);
230     if (rc == ERROR_IO_PENDING) {
231         rc = GetOverlappedResult(h, &amp;ol, &amp;xfer, TRUE);
</pre>
</td>
</tr>
</table>
<center><a href="NetworkInterface_winXP.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="TwoStacksPlainDatagramSocketImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
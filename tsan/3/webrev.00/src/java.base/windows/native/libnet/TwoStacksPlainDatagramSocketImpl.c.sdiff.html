<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libnet/TwoStacksPlainDatagramSocketImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ResolverConfigurationImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="net_util_md.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnet/TwoStacksPlainDatagramSocketImpl.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 398 
 399     if (IS_NULL(fdObj)) {
 400         /* disconnect doesn&#39;t throw any exceptions */
 401         return;
 402     }
 403     fd = (*env)-&gt;GetIntField(env, fdObj, IO_fd_fdID);
 404 
 405     memset((char *)&amp;addr, 0, len);
 406     connect(fd, &amp;addr.sa, len);
 407 
 408     /*
 409      * use SIO_UDP_CONNRESET
 410      * to disable ICMP port unreachable handling here.
 411      */
 412     t = FALSE;
 413     WSAIoctl(fd, SIO_UDP_CONNRESET, &amp;t, sizeof(t), &amp;x1, sizeof(x1), &amp;x2, 0, 0);
 414 }
 415 
 416 /*
 417  * Class:     java_net_TwoStacksPlainDatagramSocketImpl
<span class="line-modified"> 418  * Method:    send</span>
 419  * Signature: (Ljava/net/DatagramPacket;)V
 420  */
 421 JNIEXPORT void JNICALL
<span class="line-modified"> 422 Java_java_net_TwoStacksPlainDatagramSocketImpl_send</span>
 423   (JNIEnv *env, jobject this, jobject packet)
 424 {
 425     char BUF[MAX_BUFFER_LEN];
 426     char *fullPacket;
 427     jobject fdObj;
 428     jint fd;
 429 
 430     jobject iaObj;
 431     jint family;
 432 
 433     jint packetBufferOffset, packetBufferLen, packetPort;
 434     jbyteArray packetBuffer;
 435     jboolean connected;
 436 
 437     SOCKETADDRESS rmtaddr;
 438     struct sockaddr *addrp = 0;
 439     int addrlen = 0;
 440 
 441     if (IS_NULL(packet)) {
 442         JNU_ThrowNullPointerException(env, &quot;null packet&quot;);
</pre>
<hr />
<pre>
1438  *              IPPROTO_IP/IP_MULTICAST_IF
1439  *
1440  *      IPv6:   Obtain NetworkInterface.index
1441  *              Set outgoing multicast interface using
1442  *              IPPROTO_IPV6/IPV6_MULTICAST_IF
1443  *
1444  */
1445 static void setMulticastInterface(JNIEnv *env, jobject this, int fd, int fd1,
1446                                   jint opt, jobject value)
1447 {
1448     int ipv6_supported = ipv6_available();
1449 
1450     if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {
1451         /*
1452          * value is an InetAddress.
1453          * On IPv4 system use IP_MULTICAST_IF socket option
1454          * On IPv6 system get the NetworkInterface that this IP
1455          * address is bound to and use the IPV6_MULTICAST_IF
1456          * option instead of IP_MULTICAST_IF
1457          */
<span class="line-modified">1458         if (ipv6_supported) {</span>
1459             static jclass ni_class = NULL;
1460             if (ni_class == NULL) {
1461                 jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
1462                 CHECK_NULL(c);
1463                 ni_class = (*env)-&gt;NewGlobalRef(env, c);
1464                 CHECK_NULL(ni_class);
1465             }
1466 
1467             value = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, value);
1468             if (value == NULL) {
1469                 if (!(*env)-&gt;ExceptionOccurred(env)) {
1470                     JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,
1471                          &quot;bad argument for IP_MULTICAST_IF&quot;
1472                          &quot;: address not bound to any interface&quot;);
1473                 }
1474                 return;
1475             }
1476             opt = java_net_SocketOptions_IP_MULTICAST_IF2;
1477         } else {
1478             struct in_addr in;
1479 
1480             in.s_addr = htonl(getInetAddress_addr(env, value));
1481             JNU_CHECK_EXCEPTION(env);
1482             if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,
1483                                (const char*)&amp;in, sizeof(in)) &lt; 0) {
1484                 JNU_ThrowByNameWithMessageAndLastError
1485                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error setting socket option&quot;);
1486             }
1487             return;
1488         }
1489     }
1490 
1491     if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {
1492         /*
1493          * value is a NetworkInterface.
1494          * On IPv6 system get the index of the interface and use the
1495          * IPV6_MULTICAST_IF socket option
1496          * On IPv4 system extract addr[0] and use the IP_MULTICAST_IF
1497          * option. For IPv6 both must be done.
1498          */
<span class="line-modified">1499         if (ipv6_supported) {</span>
1500             static jfieldID ni_indexID = NULL;
1501             struct in_addr in;
1502             int index;
1503 
1504             if (ni_indexID == NULL) {
1505                 jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
1506                 CHECK_NULL(c);
1507                 ni_indexID = (*env)-&gt;GetFieldID(env, c, &quot;index&quot;, &quot;I&quot;);
1508                 CHECK_NULL(ni_indexID);
1509             }
1510             index = (*env)-&gt;GetIntField(env, value, ni_indexID);
<span class="line-removed">1511 </span>
1512             if (isAdapterIpv6Enabled(env, index) != 0) {
1513                 if (setsockopt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_IF,
1514                                (const char*)&amp;index, sizeof(index)) &lt; 0) {
1515                     if (errno == EINVAL &amp;&amp; index &gt; 0) {
1516                         JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,
1517                             &quot;IPV6_MULTICAST_IF failed (interface has IPv4 &quot;
1518                             &quot;address only?)&quot;);
1519                     } else {
1520                         JNU_ThrowByNameWithMessageAndLastError
1521                             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error setting socket option&quot;);
1522                     }
1523                     return;
1524                 }
1525             }
<span class="line-modified">1526             /* If there are any IPv4 addresses on this interface then</span>
<span class="line-modified">1527              * repeat the operation on the IPv4 fd */</span>

1528 
<span class="line-modified">1529             if (getInet4AddrFromIf(env, value, &amp;in) &lt; 0) {</span>
<span class="line-modified">1530                 return;</span>
<span class="line-modified">1531             }</span>
<span class="line-modified">1532             if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,</span>
<span class="line-modified">1533                                (const char*)&amp;in, sizeof(in)) &lt; 0) {</span>
<span class="line-modified">1534                 JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-modified">1535                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error setting socket option&quot;);</span>

1536             }
1537             return;
1538         } else {
1539             struct in_addr in;
1540 
1541             if (getInet4AddrFromIf (env, value, &amp;in) &lt; 0) {
1542                 if ((*env)-&gt;ExceptionOccurred(env)) {
1543                     return;
1544                 }
1545                 JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,
1546                         &quot;no InetAddress instances of requested type&quot;);
1547                 return;
1548             }
1549 
1550             if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,
1551                                (const char*)&amp;in, sizeof(in)) &lt; 0) {
1552                 JNU_ThrowByNameWithMessageAndLastError
1553                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error setting socket option&quot;);
1554             }
1555             return;
</pre>
<hr />
<pre>
1674 
1675 /*
1676  *
1677  * called by getMulticastInterface to retrieve a NetworkInterface
1678  * configured for IPv4.
1679  * The ipv4Mode parameter, is a closet boolean, which allows for a NULL return,
1680  * or forces the creation of a NetworkInterface object with null data.
1681  * It relates to its calling context in getMulticastInterface.
1682  * ipv4Mode == 1, the context is IPV4 processing only.
1683  * ipv4Mode == 0, the context is IPV6 processing
1684  *
1685  */
1686 static jobject getIPv4NetworkInterface (JNIEnv *env, jobject this, int fd, jint opt, int ipv4Mode) {
1687         static jclass inet4_class;
1688         static jmethodID inet4_ctrID;
1689 
1690         static jclass ni_class; static jmethodID ni_ctrID;
1691         static jfieldID ni_indexID;
1692         static jfieldID ni_addrsID;
1693 
<span class="line-removed">1694         jobjectArray addrArray;</span>
1695         jobject addr;
1696         jobject ni;
1697 
1698         struct in_addr in;
1699         struct in_addr *inP = &amp;in;
1700         int len = sizeof(struct in_addr);
1701         if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,
1702                            (char *)inP, &amp;len) &lt; 0) {
1703             JNU_ThrowByNameWithMessageAndLastError
1704                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error getting socket option&quot;);
1705             return NULL;
1706         }
1707 
1708         /*
1709          * Construct and populate an Inet4Address
1710          */
1711         if (inet4_class == NULL) {
1712             jclass c = (*env)-&gt;FindClass(env, &quot;java/net/Inet4Address&quot;);
1713             CHECK_NULL_RETURN(c, NULL);
1714             inet4_ctrID = (*env)-&gt;GetMethodID(env, c, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
</pre>
<hr />
<pre>
1732          * For IP_MULTICAST_IF2 we get the NetworkInterface for
1733          * this address and return it
1734          */
1735         if (ni_class == NULL) {
1736             jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
1737             CHECK_NULL_RETURN(c, NULL);
1738             ni_ctrID = (*env)-&gt;GetMethodID(env, c, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
1739             CHECK_NULL_RETURN(ni_ctrID, NULL);
1740             ni_indexID = (*env)-&gt;GetFieldID(env, c, &quot;index&quot;, &quot;I&quot;);
1741             CHECK_NULL_RETURN(ni_indexID, NULL);
1742             ni_addrsID = (*env)-&gt;GetFieldID(env, c, &quot;addrs&quot;,
1743                                             &quot;[Ljava/net/InetAddress;&quot;);
1744             CHECK_NULL_RETURN(ni_addrsID, NULL);
1745             ni_class = (*env)-&gt;NewGlobalRef(env, c);
1746             CHECK_NULL_RETURN(ni_class, NULL);
1747         }
1748         ni = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, addr);
1749         if (ni) {
1750             return ni;
1751         }
<span class="line-modified">1752         if (ipv4Mode) {</span>
<span class="line-removed">1753             ni = (*env)-&gt;NewObject(env, ni_class, ni_ctrID, 0);</span>
<span class="line-removed">1754             CHECK_NULL_RETURN(ni, NULL);</span>
<span class="line-removed">1755 </span>
<span class="line-removed">1756             (*env)-&gt;SetIntField(env, ni, ni_indexID, -1);</span>
<span class="line-removed">1757             addrArray = (*env)-&gt;NewObjectArray(env, 1, inet4_class, NULL);</span>
<span class="line-removed">1758             CHECK_NULL_RETURN(addrArray, NULL);</span>
<span class="line-removed">1759             (*env)-&gt;SetObjectArrayElement(env, addrArray, 0, addr);</span>
<span class="line-removed">1760             (*env)-&gt;SetObjectField(env, ni, ni_addrsID, addrArray);</span>
<span class="line-removed">1761         } else {</span>
<span class="line-removed">1762             ni = NULL;</span>
<span class="line-removed">1763         }</span>
<span class="line-removed">1764         return ni;</span>
1765 }
1766 
1767 /*
1768  * Return the multicast interface:
1769  *
1770  * SocketOptions.IP_MULTICAST_IF
1771  *      IPv4:   Query IPPROTO_IP/IP_MULTICAST_IF
1772  *              Create InetAddress
1773  *              IP_MULTICAST_IF returns struct ip_mreqn on 2.2
1774  *              kernel but struct in_addr on 2.4 kernel
1775  *      IPv6:   Query IPPROTO_IPV6 / IPV6_MULTICAST_IF or
1776  *              obtain from impl is Linux 2.2 kernel
1777  *              If index == 0 return InetAddress representing
1778  *              anyLocalAddress.
1779  *              If index &gt; 0 query NetworkInterface by index
1780  *              and returns addrs[0]
1781  *
1782  * SocketOptions.IP_MULTICAST_IF2
1783  *      IPv4:   Query IPPROTO_IP/IP_MULTICAST_IF
1784  *              Query NetworkInterface by IP address and
</pre>
<hr />
<pre>
1873 
1874             /*
1875              * For IP_MULTICAST_IF2 return the NetworkInterface
1876              */
1877             if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {
1878                 return ni;
1879             }
1880 
1881             /*
1882              * For IP_MULTICAST_IF return addrs[0]
1883              */
1884             addrArray = (*env)-&gt;GetObjectField(env, ni, ni_addrsID);
1885             if ((*env)-&gt;GetArrayLength(env, addrArray) &lt; 1) {
1886                 JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,
1887                     &quot;IPV6_MULTICAST_IF returned interface without IP bindings&quot;);
1888                 return NULL;
1889             }
1890 
1891             addr = (*env)-&gt;GetObjectArrayElement(env, addrArray, 0);
1892             return addr;
<span class="line-modified">1893         } else if (index == 0) { // index == 0 typically means IPv6 not configured on the interfaces</span>
1894             // falling back to treat interface as configured for IPv4
1895             jobject netObject = NULL;
1896             netObject = getIPv4NetworkInterface(env, this, fd, opt, 0);
1897             if (netObject != NULL) {
1898                 return netObject;
1899             }
1900         }
<span class="line-removed">1901 </span>
<span class="line-removed">1902         /*</span>
<span class="line-removed">1903          * Multicast to any address - return anyLocalAddress</span>
<span class="line-removed">1904          * or a NetworkInterface with addrs[0] set to anyLocalAddress</span>
<span class="line-removed">1905          */</span>
<span class="line-removed">1906 </span>
<span class="line-removed">1907         addr = (*env)-&gt;CallStaticObjectMethod(env, ia_class, ia_anyLocalAddressID,</span>
<span class="line-removed">1908                                               NULL);</span>
<span class="line-removed">1909         if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {</span>
<span class="line-removed">1910             return addr;</span>
<span class="line-removed">1911         }</span>
<span class="line-removed">1912 </span>
<span class="line-removed">1913         ni = (*env)-&gt;NewObject(env, ni_class, ni_ctrID, 0);</span>
<span class="line-removed">1914         CHECK_NULL_RETURN(ni, NULL);</span>
<span class="line-removed">1915         (*env)-&gt;SetIntField(env, ni, ni_indexID, -1);</span>
<span class="line-removed">1916         addrArray = (*env)-&gt;NewObjectArray(env, 1, ia_class, NULL);</span>
<span class="line-removed">1917         CHECK_NULL_RETURN(addrArray, NULL);</span>
<span class="line-removed">1918         (*env)-&gt;SetObjectArrayElement(env, addrArray, 0, addr);</span>
<span class="line-removed">1919         (*env)-&gt;SetObjectField(env, ni, ni_addrsID, addrArray);</span>
<span class="line-removed">1920         return ni;</span>
1921     }
1922     return NULL;
1923 }
1924 
1925 
1926 /*
1927  * Returns relevant info as a jint.
1928  *
1929  * Class:     java_net_TwoStacksPlainDatagramSocketImpl
1930  * Method:    socketGetOption
1931  * Signature: (I)Ljava/lang/Object;
1932  */
1933 JNIEXPORT jobject JNICALL
1934 Java_java_net_TwoStacksPlainDatagramSocketImpl_socketGetOption
1935   (JNIEnv *env, jobject this, jint opt)
1936 {
1937     int fd = -1, fd1 = -1;
1938     int level, optname, optlen;
1939     union {
1940         int i;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 398 
 399     if (IS_NULL(fdObj)) {
 400         /* disconnect doesn&#39;t throw any exceptions */
 401         return;
 402     }
 403     fd = (*env)-&gt;GetIntField(env, fdObj, IO_fd_fdID);
 404 
 405     memset((char *)&amp;addr, 0, len);
 406     connect(fd, &amp;addr.sa, len);
 407 
 408     /*
 409      * use SIO_UDP_CONNRESET
 410      * to disable ICMP port unreachable handling here.
 411      */
 412     t = FALSE;
 413     WSAIoctl(fd, SIO_UDP_CONNRESET, &amp;t, sizeof(t), &amp;x1, sizeof(x1), &amp;x2, 0, 0);
 414 }
 415 
 416 /*
 417  * Class:     java_net_TwoStacksPlainDatagramSocketImpl
<span class="line-modified"> 418  * Method:    send0</span>
 419  * Signature: (Ljava/net/DatagramPacket;)V
 420  */
 421 JNIEXPORT void JNICALL
<span class="line-modified"> 422 Java_java_net_TwoStacksPlainDatagramSocketImpl_send0</span>
 423   (JNIEnv *env, jobject this, jobject packet)
 424 {
 425     char BUF[MAX_BUFFER_LEN];
 426     char *fullPacket;
 427     jobject fdObj;
 428     jint fd;
 429 
 430     jobject iaObj;
 431     jint family;
 432 
 433     jint packetBufferOffset, packetBufferLen, packetPort;
 434     jbyteArray packetBuffer;
 435     jboolean connected;
 436 
 437     SOCKETADDRESS rmtaddr;
 438     struct sockaddr *addrp = 0;
 439     int addrlen = 0;
 440 
 441     if (IS_NULL(packet)) {
 442         JNU_ThrowNullPointerException(env, &quot;null packet&quot;);
</pre>
<hr />
<pre>
1438  *              IPPROTO_IP/IP_MULTICAST_IF
1439  *
1440  *      IPv6:   Obtain NetworkInterface.index
1441  *              Set outgoing multicast interface using
1442  *              IPPROTO_IPV6/IPV6_MULTICAST_IF
1443  *
1444  */
1445 static void setMulticastInterface(JNIEnv *env, jobject this, int fd, int fd1,
1446                                   jint opt, jobject value)
1447 {
1448     int ipv6_supported = ipv6_available();
1449 
1450     if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {
1451         /*
1452          * value is an InetAddress.
1453          * On IPv4 system use IP_MULTICAST_IF socket option
1454          * On IPv6 system get the NetworkInterface that this IP
1455          * address is bound to and use the IPV6_MULTICAST_IF
1456          * option instead of IP_MULTICAST_IF
1457          */
<span class="line-modified">1458         if (ipv6_supported &amp;&amp; fd1 &gt;= 0) {</span>
1459             static jclass ni_class = NULL;
1460             if (ni_class == NULL) {
1461                 jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
1462                 CHECK_NULL(c);
1463                 ni_class = (*env)-&gt;NewGlobalRef(env, c);
1464                 CHECK_NULL(ni_class);
1465             }
1466 
1467             value = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, value);
1468             if (value == NULL) {
1469                 if (!(*env)-&gt;ExceptionOccurred(env)) {
1470                     JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,
1471                          &quot;bad argument for IP_MULTICAST_IF&quot;
1472                          &quot;: address not bound to any interface&quot;);
1473                 }
1474                 return;
1475             }
1476             opt = java_net_SocketOptions_IP_MULTICAST_IF2;
1477         } else {
1478             struct in_addr in;
1479 
1480             in.s_addr = htonl(getInetAddress_addr(env, value));
1481             JNU_CHECK_EXCEPTION(env);
1482             if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,
1483                                (const char*)&amp;in, sizeof(in)) &lt; 0) {
1484                 JNU_ThrowByNameWithMessageAndLastError
1485                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error setting socket option&quot;);
1486             }
1487             return;
1488         }
1489     }
1490 
1491     if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {
1492         /*
1493          * value is a NetworkInterface.
1494          * On IPv6 system get the index of the interface and use the
1495          * IPV6_MULTICAST_IF socket option
1496          * On IPv4 system extract addr[0] and use the IP_MULTICAST_IF
1497          * option. For IPv6 both must be done.
1498          */
<span class="line-modified">1499         if (ipv6_supported &amp;&amp; fd1 &gt;= 0) {</span>
1500             static jfieldID ni_indexID = NULL;
1501             struct in_addr in;
1502             int index;
1503 
1504             if (ni_indexID == NULL) {
1505                 jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
1506                 CHECK_NULL(c);
1507                 ni_indexID = (*env)-&gt;GetFieldID(env, c, &quot;index&quot;, &quot;I&quot;);
1508                 CHECK_NULL(ni_indexID);
1509             }
1510             index = (*env)-&gt;GetIntField(env, value, ni_indexID);

1511             if (isAdapterIpv6Enabled(env, index) != 0) {
1512                 if (setsockopt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_IF,
1513                                (const char*)&amp;index, sizeof(index)) &lt; 0) {
1514                     if (errno == EINVAL &amp;&amp; index &gt; 0) {
1515                         JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,
1516                             &quot;IPV6_MULTICAST_IF failed (interface has IPv4 &quot;
1517                             &quot;address only?)&quot;);
1518                     } else {
1519                         JNU_ThrowByNameWithMessageAndLastError
1520                             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error setting socket option&quot;);
1521                     }
1522                     return;
1523                 }
1524             }
<span class="line-modified">1525             if (fd &gt;= 0) {</span>
<span class="line-modified">1526                 /* If there are any IPv4 addresses on this interface then</span>
<span class="line-added">1527                  * repeat the operation on the IPv4 fd */</span>
1528 
<span class="line-modified">1529                 if (getInet4AddrFromIf(env, value, &amp;in) &lt; 0) {</span>
<span class="line-modified">1530                     return;</span>
<span class="line-modified">1531                 }</span>
<span class="line-modified">1532                 if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,</span>
<span class="line-modified">1533                                    (const char*)&amp;in, sizeof(in)) &lt; 0) {</span>
<span class="line-modified">1534                     JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-modified">1535                         (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error setting socket option&quot;);</span>
<span class="line-added">1536                 }</span>
1537             }
1538             return;
1539         } else {
1540             struct in_addr in;
1541 
1542             if (getInet4AddrFromIf (env, value, &amp;in) &lt; 0) {
1543                 if ((*env)-&gt;ExceptionOccurred(env)) {
1544                     return;
1545                 }
1546                 JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,
1547                         &quot;no InetAddress instances of requested type&quot;);
1548                 return;
1549             }
1550 
1551             if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,
1552                                (const char*)&amp;in, sizeof(in)) &lt; 0) {
1553                 JNU_ThrowByNameWithMessageAndLastError
1554                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error setting socket option&quot;);
1555             }
1556             return;
</pre>
<hr />
<pre>
1675 
1676 /*
1677  *
1678  * called by getMulticastInterface to retrieve a NetworkInterface
1679  * configured for IPv4.
1680  * The ipv4Mode parameter, is a closet boolean, which allows for a NULL return,
1681  * or forces the creation of a NetworkInterface object with null data.
1682  * It relates to its calling context in getMulticastInterface.
1683  * ipv4Mode == 1, the context is IPV4 processing only.
1684  * ipv4Mode == 0, the context is IPV6 processing
1685  *
1686  */
1687 static jobject getIPv4NetworkInterface (JNIEnv *env, jobject this, int fd, jint opt, int ipv4Mode) {
1688         static jclass inet4_class;
1689         static jmethodID inet4_ctrID;
1690 
1691         static jclass ni_class; static jmethodID ni_ctrID;
1692         static jfieldID ni_indexID;
1693         static jfieldID ni_addrsID;
1694 

1695         jobject addr;
1696         jobject ni;
1697 
1698         struct in_addr in;
1699         struct in_addr *inP = &amp;in;
1700         int len = sizeof(struct in_addr);
1701         if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,
1702                            (char *)inP, &amp;len) &lt; 0) {
1703             JNU_ThrowByNameWithMessageAndLastError
1704                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Error getting socket option&quot;);
1705             return NULL;
1706         }
1707 
1708         /*
1709          * Construct and populate an Inet4Address
1710          */
1711         if (inet4_class == NULL) {
1712             jclass c = (*env)-&gt;FindClass(env, &quot;java/net/Inet4Address&quot;);
1713             CHECK_NULL_RETURN(c, NULL);
1714             inet4_ctrID = (*env)-&gt;GetMethodID(env, c, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
</pre>
<hr />
<pre>
1732          * For IP_MULTICAST_IF2 we get the NetworkInterface for
1733          * this address and return it
1734          */
1735         if (ni_class == NULL) {
1736             jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
1737             CHECK_NULL_RETURN(c, NULL);
1738             ni_ctrID = (*env)-&gt;GetMethodID(env, c, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
1739             CHECK_NULL_RETURN(ni_ctrID, NULL);
1740             ni_indexID = (*env)-&gt;GetFieldID(env, c, &quot;index&quot;, &quot;I&quot;);
1741             CHECK_NULL_RETURN(ni_indexID, NULL);
1742             ni_addrsID = (*env)-&gt;GetFieldID(env, c, &quot;addrs&quot;,
1743                                             &quot;[Ljava/net/InetAddress;&quot;);
1744             CHECK_NULL_RETURN(ni_addrsID, NULL);
1745             ni_class = (*env)-&gt;NewGlobalRef(env, c);
1746             CHECK_NULL_RETURN(ni_class, NULL);
1747         }
1748         ni = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, addr);
1749         if (ni) {
1750             return ni;
1751         }
<span class="line-modified">1752         return NULL;</span>












1753 }
1754 
1755 /*
1756  * Return the multicast interface:
1757  *
1758  * SocketOptions.IP_MULTICAST_IF
1759  *      IPv4:   Query IPPROTO_IP/IP_MULTICAST_IF
1760  *              Create InetAddress
1761  *              IP_MULTICAST_IF returns struct ip_mreqn on 2.2
1762  *              kernel but struct in_addr on 2.4 kernel
1763  *      IPv6:   Query IPPROTO_IPV6 / IPV6_MULTICAST_IF or
1764  *              obtain from impl is Linux 2.2 kernel
1765  *              If index == 0 return InetAddress representing
1766  *              anyLocalAddress.
1767  *              If index &gt; 0 query NetworkInterface by index
1768  *              and returns addrs[0]
1769  *
1770  * SocketOptions.IP_MULTICAST_IF2
1771  *      IPv4:   Query IPPROTO_IP/IP_MULTICAST_IF
1772  *              Query NetworkInterface by IP address and
</pre>
<hr />
<pre>
1861 
1862             /*
1863              * For IP_MULTICAST_IF2 return the NetworkInterface
1864              */
1865             if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {
1866                 return ni;
1867             }
1868 
1869             /*
1870              * For IP_MULTICAST_IF return addrs[0]
1871              */
1872             addrArray = (*env)-&gt;GetObjectField(env, ni, ni_addrsID);
1873             if ((*env)-&gt;GetArrayLength(env, addrArray) &lt; 1) {
1874                 JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,
1875                     &quot;IPV6_MULTICAST_IF returned interface without IP bindings&quot;);
1876                 return NULL;
1877             }
1878 
1879             addr = (*env)-&gt;GetObjectArrayElement(env, addrArray, 0);
1880             return addr;
<span class="line-modified">1881         } else if (index == 0 &amp;&amp; fd &gt;= 0) {</span>
1882             // falling back to treat interface as configured for IPv4
1883             jobject netObject = NULL;
1884             netObject = getIPv4NetworkInterface(env, this, fd, opt, 0);
1885             if (netObject != NULL) {
1886                 return netObject;
1887             }
1888         }




















1889     }
1890     return NULL;
1891 }
1892 
1893 
1894 /*
1895  * Returns relevant info as a jint.
1896  *
1897  * Class:     java_net_TwoStacksPlainDatagramSocketImpl
1898  * Method:    socketGetOption
1899  * Signature: (I)Ljava/lang/Object;
1900  */
1901 JNIEXPORT jobject JNICALL
1902 Java_java_net_TwoStacksPlainDatagramSocketImpl_socketGetOption
1903   (JNIEnv *env, jobject this, jint opt)
1904 {
1905     int fd = -1, fd1 = -1;
1906     int level, optname, optlen;
1907     union {
1908         int i;
</pre>
</td>
</tr>
</table>
<center><a href="ResolverConfigurationImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="net_util_md.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
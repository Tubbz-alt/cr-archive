<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/windows/native/libnet/ResolverConfigurationImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;
 27 #include &lt;windows.h&gt;
 28 #include &lt;stdio.h&gt;
 29 #include &lt;stddef.h&gt;
 30 #include &lt;iprtrmib.h&gt;
 31 #include &lt;time.h&gt;
 32 #include &lt;assert.h&gt;
 33 #include &lt;iphlpapi.h&gt;
 34 
 35 #include &quot;jni_util.h&quot;
 36 
 37 #define MAX_STR_LEN         256
 38 
 39 #define STS_NO_CONFIG       0x0             /* no configuration found */
 40 #define STS_SL_FOUND        0x1             /* search list found */
 41 #define STS_NS_FOUND        0x2             /* name servers found */
 42 #define STS_ERROR           -1              /* error return  lodConfig failed memory allccation failure*/
 43 
 44 #define IS_SL_FOUND(sts)    (sts &amp; STS_SL_FOUND)
 45 #define IS_NS_FOUND(sts)    (sts &amp; STS_NS_FOUND)
 46 
 47 /* JNI ids */
 48 static jfieldID searchlistID;
 49 static jfieldID nameserversID;
 50 
 51 /*
 52  * Utility routine to append s2 to s1 with a space delimiter.
 53  *  strappend(s1=&quot;abc&quot;, &quot;def&quot;)  =&gt; &quot;abc def&quot;
 54  *  strappend(s1=&quot;&quot;, &quot;def&quot;)     =&gt; &quot;def
 55  */
 56 void strappend(char *s1, char *s2) {
 57     size_t len;
 58 
 59     if (s2[0] == &#39;\0&#39;)                      /* nothing to append */
 60         return;
 61 
 62     len = strlen(s1)+1;
 63     if (s1[0] != 0)                         /* needs space character */
 64         len++;
 65     if (len + strlen(s2) &gt; MAX_STR_LEN)     /* insufficient space */
 66         return;
 67 
 68     if (s1[0] != 0) {
 69         strcat(s1, &quot; &quot;);
 70     }
 71     strcat(s1, s2);
 72 }
 73 
 74 /*
 75  * Windows 2000/XP
 76  *
 77  * Use registry approach based on settings described in Appendix C
 78  * of &quot;Microsoft Windows 2000 TCP/IP Implementation Details&quot;.
 79  *
 80  * DNS suffix list is obtained from SearchList registry setting. If
 81  * this is not specified we compile suffix list based on the
 82  * per-connection domain suffix.
 83  *
 84  * DNS name servers and domain settings are on a per-connection
 85  * basic. We therefore enumerate the network adapters to get the
 86  * names of each adapter and then query the corresponding registry
 87  * settings to obtain NameServer/DhcpNameServer and Domain/DhcpDomain.
 88  */
 89 static int loadConfig(char *sl, char *ns) {
 90     IP_ADAPTER_INFO *adapterP;
 91     ULONG size;
 92     DWORD ret;
 93     DWORD dwLen;
 94     ULONG ulType;
 95     char result[MAX_STR_LEN];
 96     HANDLE hKey;
 97     int gotSearchList = 0;
 98 
 99     /*
100      * First see if there is a global suffix list specified.
101      */
102     ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
103                        &quot;SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters&quot;,
104                        0,
105                        KEY_READ,
106                        (PHKEY)&amp;hKey);
107     if (ret == ERROR_SUCCESS) {
108         dwLen = sizeof(result);
109         ret = RegQueryValueEx(hKey, &quot;SearchList&quot;, NULL, &amp;ulType,
110                              (LPBYTE)&amp;result, &amp;dwLen);
111         if (ret == ERROR_SUCCESS) {
112             assert(ulType == REG_SZ);
113             if (strlen(result) &gt; 0) {
114                 strappend(sl, result);
115                 gotSearchList = 1;
116             }
117         }
118         RegCloseKey(hKey);
119     }
120 
121     /*
122      * Ask the IP Helper library to enumerate the adapters
123      */
124     size = sizeof(IP_ADAPTER_INFO);
125     adapterP = (IP_ADAPTER_INFO *)malloc(size);
126     if (adapterP == NULL) {
127         return STS_ERROR;
128     }
129     ret = GetAdaptersInfo(adapterP, &amp;size);
130     if (ret == ERROR_BUFFER_OVERFLOW) {
131         IP_ADAPTER_INFO *newAdapterP = (IP_ADAPTER_INFO *)realloc(adapterP, size);
132         if (newAdapterP == NULL) {
133             free(adapterP);
134             return STS_ERROR;
135         }
136         adapterP = newAdapterP;
137 
138         ret = GetAdaptersInfo(adapterP, &amp;size);
139     }
140 
141     /*
142      * Iterate through the list of adapters as registry settings are
143      * keyed on the adapter name (GUID).
144      */
145     if (ret == ERROR_SUCCESS) {
146         IP_ADAPTER_INFO *curr = adapterP;
147         while (curr != NULL) {
148             char key[MAX_STR_LEN];
149 
150             sprintf(key,
151                 &quot;SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\%s&quot;,
152                 curr-&gt;AdapterName);
153 
154             ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
155                                key,
156                                0,
157                                KEY_READ,
158                                (PHKEY)&amp;hKey);
159             if (ret == ERROR_SUCCESS) {
160                 DWORD enableDhcp = 0;
161 
162                 /*
163                  * Is DHCP enabled on this interface
164                  */
165                 dwLen = sizeof(enableDhcp);
166                 ret = RegQueryValueEx(hKey, &quot;EnableDhcp&quot;, NULL, &amp;ulType,
167                                      (LPBYTE)&amp;enableDhcp, &amp;dwLen);
168 
169                 /*
170                  * If we don&#39;t have the suffix list when get the Domain
171                  * or DhcpDomain. If DHCP is enabled then Domain overides
172                  * DhcpDomain
173                  */
174                 if (!gotSearchList) {
175                     result[0] = &#39;\0&#39;;
176                     dwLen = sizeof(result);
177                     ret = RegQueryValueEx(hKey, &quot;Domain&quot;, NULL, &amp;ulType,
178                                          (LPBYTE)&amp;result, &amp;dwLen);
179                     if (((ret != ERROR_SUCCESS) || (strlen(result) == 0)) &amp;&amp;
180                         enableDhcp) {
181                         dwLen = sizeof(result);
182                         ret = RegQueryValueEx(hKey, &quot;DhcpDomain&quot;, NULL, &amp;ulType,
183                                               (LPBYTE)&amp;result, &amp;dwLen);
184                     }
185                     if (ret == ERROR_SUCCESS) {
186                         assert(ulType == REG_SZ);
187                         strappend(sl, result);
188                     }
189                 }
190 
191                 /*
192                  * Get DNS servers based on NameServer or DhcpNameServer
193                  * registry setting. If NameServer is set then it overrides
194                  * DhcpNameServer (even if DHCP is enabled).
195                  */
196                 result[0] = &#39;\0&#39;;
197                 dwLen = sizeof(result);
198                 ret = RegQueryValueEx(hKey, &quot;NameServer&quot;, NULL, &amp;ulType,
199                                      (LPBYTE)&amp;result, &amp;dwLen);
200                 if (((ret != ERROR_SUCCESS) || (strlen(result) == 0)) &amp;&amp;
201                     enableDhcp) {
202                     dwLen = sizeof(result);
203                     ret = RegQueryValueEx(hKey, &quot;DhcpNameServer&quot;, NULL, &amp;ulType,
204                                           (LPBYTE)&amp;result, &amp;dwLen);
205                 }
206                 if (ret == ERROR_SUCCESS) {
207                     assert(ulType == REG_SZ);
208                     strappend(ns, result);
209                 }
210 
211                 /*
212                  * Finished with this registry key
213                  */
214                 RegCloseKey(hKey);
215             }
216 
217             /*
218              * Onto the next adapeter
219              */
220             curr = curr-&gt;Next;
221         }
222     }
223 
224     /*
225      * Free the adpater structure
226      */
227     if (adapterP) {
228         free(adapterP);
229     }
230 
231     return STS_SL_FOUND &amp; STS_NS_FOUND;
232 }
233 
234 
235 /*
236  * Initialize JNI field IDs.
237  */
238 JNIEXPORT void JNICALL
239 Java_sun_net_dns_ResolverConfigurationImpl_init0(JNIEnv *env, jclass cls)
240 {
241     searchlistID = (*env)-&gt;GetStaticFieldID(env, cls, &quot;os_searchlist&quot;,
242                                       &quot;Ljava/lang/String;&quot;);
243     CHECK_NULL(searchlistID);
244     nameserversID = (*env)-&gt;GetStaticFieldID(env, cls, &quot;os_nameservers&quot;,
245                                       &quot;Ljava/lang/String;&quot;);
246 }
247 
248 /*
249  * Class:     sun_net_dns_ResolverConfgurationImpl
250  * Method:    loadConfig0
251  * Signature: ()V
252  */
253 JNIEXPORT void JNICALL
254 Java_sun_net_dns_ResolverConfigurationImpl_loadDNSconfig0(JNIEnv *env, jclass cls)
255 {
256     char searchlist[MAX_STR_LEN];
257     char nameservers[MAX_STR_LEN];
258     jstring obj;
259 
260     searchlist[0] = &#39;\0&#39;;
261     nameservers[0] = &#39;\0&#39;;
262 
263     if (loadConfig(searchlist, nameservers) != STS_ERROR) {
264 
265         /*
266          * Populate static fields in sun.net.DefaultResolverConfiguration
267          */
268         obj = (*env)-&gt;NewStringUTF(env, searchlist);
269         CHECK_NULL(obj);
270         (*env)-&gt;SetStaticObjectField(env, cls, searchlistID, obj);
271 
272         obj = (*env)-&gt;NewStringUTF(env, nameservers);
273         CHECK_NULL(obj);
274         (*env)-&gt;SetStaticObjectField(env, cls, nameserversID, obj);
275     } else {
276         JNU_ThrowOutOfMemoryError(env, &quot;native memory allocation failed&quot;);
277     }
278 }
279 
280 
281 /*
282  * Class:     sun_net_dns_ResolverConfgurationImpl
283  * Method:    notifyAddrChange0
284  * Signature: ()I
285  */
286 JNIEXPORT jint JNICALL
287 Java_sun_net_dns_ResolverConfigurationImpl_notifyAddrChange0(JNIEnv *env, jclass cls)
288 {
289     OVERLAPPED ol;
290     HANDLE h;
291     DWORD rc, xfer;
292 
293     ol.hEvent = (HANDLE)0;
294     rc = NotifyAddrChange(&amp;h, &amp;ol);
295     if (rc == ERROR_IO_PENDING) {
296         rc = GetOverlappedResult(h, &amp;ol, &amp;xfer, TRUE);
297         if (rc != 0) {
298             return 0;   /* address changed */
299         }
300     }
301 
302     /* error */
303     return -1;
304 }
    </pre>
  </body>
</html>
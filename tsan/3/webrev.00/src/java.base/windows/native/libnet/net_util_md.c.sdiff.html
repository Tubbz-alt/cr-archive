<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libnet/net_util_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="TwoStacksPlainDatagramSocketImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../libnio/ch/DatagramChannelImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnet/net_util_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
197 void
198 NET_ThrowCurrent(JNIEnv *env, char *msg)
199 {
200     NET_ThrowNew(env, WSAGetLastError(), msg);
201 }
202 
203 void
204 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
205                    const char *defaultDetail) {
206     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
207 }
208 
209 jfieldID
210 NET_GetFileDescriptorID(JNIEnv *env)
211 {
212     jclass cls = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;);
213     CHECK_NULL_RETURN(cls, NULL);
214     return (*env)-&gt;GetFieldID(env, cls, &quot;fd&quot;, &quot;I&quot;);
215 }
216 






217 jint  IPv6_supported()
218 {
219     SOCKET s = socket(AF_INET6, SOCK_STREAM, 0) ;
220     if (s == INVALID_SOCKET) {
221         return JNI_FALSE;
222     }
223     closesocket(s);
224 
225     return JNI_TRUE;
226 }
227 
228 jint reuseport_supported()
229 {
230     /* SO_REUSEPORT is not supported on Windows */
231     return JNI_FALSE;
232 }
233 
234 /* call NET_MapSocketOptionV6 for the IPv6 fd only
235  * and NET_MapSocketOption for the IPv4 fd
236  */
</pre>
<hr />
<pre>
729             bound_port = GET_PORT (&amp;oaddr);
730             SET_PORT (b-&gt;addr, bound_port);
731             rv = NET_WinBind(fd, b-&gt;addr, sizeof(SOCKETADDRESS), exclBind);
732 
733             if (rv != SOCKET_ERROR) {
734                 if (family == AF_INET) {
735                     b-&gt;ipv4_fd = fd;
736                     b-&gt;ipv6_fd = ofd;
737                 } else {
738                     b-&gt;ipv4_fd = ofd;
739                     b-&gt;ipv6_fd = fd;
740                 }
741                 return 0;
742             }
743         }
744         CLOSE_SOCKETS_AND_RETURN;
745     }
746     return 0;
747 }
748 
<span class="line-removed">749 /*</span>
<span class="line-removed">750  * Determine the default interface for an IPv6 address.</span>
<span class="line-removed">751  *</span>
<span class="line-removed">752  * Returns :-</span>
<span class="line-removed">753  *      0 if error</span>
<span class="line-removed">754  *      &gt; 0 interface index to use</span>
<span class="line-removed">755  */</span>
<span class="line-removed">756 jint getDefaultIPv6Interface(JNIEnv *env, struct sockaddr_in6 *target_addr)</span>
<span class="line-removed">757 {</span>
<span class="line-removed">758     int ret;</span>
<span class="line-removed">759     DWORD b;</span>
<span class="line-removed">760     struct sockaddr_in6 route;</span>
<span class="line-removed">761     SOCKET fd = socket(AF_INET6, SOCK_STREAM, 0);</span>
<span class="line-removed">762     if (fd == INVALID_SOCKET) {</span>
<span class="line-removed">763         return 0;</span>
<span class="line-removed">764     }</span>
<span class="line-removed">765 </span>
<span class="line-removed">766     ret = WSAIoctl(fd, SIO_ROUTING_INTERFACE_QUERY,</span>
<span class="line-removed">767                    (void *)target_addr, sizeof(struct sockaddr_in6),</span>
<span class="line-removed">768                    (void *)&amp;route, sizeof(struct sockaddr_in6),</span>
<span class="line-removed">769                    &amp;b, 0, 0);</span>
<span class="line-removed">770     if (ret == SOCKET_ERROR) {</span>
<span class="line-removed">771         // error</span>
<span class="line-removed">772         closesocket(fd);</span>
<span class="line-removed">773         return 0;</span>
<span class="line-removed">774     } else {</span>
<span class="line-removed">775         closesocket(fd);</span>
<span class="line-removed">776         return route.sin6_scope_id;</span>
<span class="line-removed">777     }</span>
<span class="line-removed">778 }</span>
<span class="line-removed">779 </span>
780 /**
781  * Enables SIO_LOOPBACK_FAST_PATH
782  */
783 JNIEXPORT jint JNICALL
784 NET_EnableFastTcpLoopback(int fd) {
785     int enabled = 1;
786     DWORD result_byte_count = -1;
787     int result = WSAIoctl(fd,
788                           SIO_LOOPBACK_FAST_PATH,
789                           &amp;enabled,
790                           sizeof(enabled),
791                           NULL,
792                           0,
793                           &amp;result_byte_count,
794                           NULL,
795                           NULL);
796     return result == SOCKET_ERROR ? WSAGetLastError() : 0;
797 }
798 
799 /**
800  * See net_util.h for documentation
801  */
802 JNIEXPORT int JNICALL
803 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port,
804                           SOCKETADDRESS *sa, int *len,
805                           jboolean v4MappedAddress)
806 {
807     jint family = getInetAddress_family(env, iaObj);
808     JNU_CHECK_EXCEPTION_RETURN(env, -1);
809     memset((char *)sa, 0, sizeof(SOCKETADDRESS));
810 
811     if (ipv6_available() &amp;&amp;
812         !(family == java_net_InetAddress_IPv4 &amp;&amp;
813           v4MappedAddress == JNI_FALSE))
814     {
815         jbyte caddr[16];
816         jint address;
<span class="line-modified">817         unsigned int scopeid = 0, cached_scope_id = 0;</span>
818 
819         if (family == java_net_InetAddress_IPv4) {
820             // convert to IPv4-mapped address
821             memset((char *)caddr, 0, 16);
822             address = getInetAddress_addr(env, iaObj);
823             JNU_CHECK_EXCEPTION_RETURN(env, -1);
824             if (address == INADDR_ANY) {
825                 /* we would always prefer IPv6 wildcard address
826                  * caddr[10] = 0xff;
827                  * caddr[11] = 0xff; */
828             } else {
829                 caddr[10] = 0xff;
830                 caddr[11] = 0xff;
831                 caddr[12] = ((address &gt;&gt; 24) &amp; 0xff);
832                 caddr[13] = ((address &gt;&gt; 16) &amp; 0xff);
833                 caddr[14] = ((address &gt;&gt; 8) &amp; 0xff);
834                 caddr[15] = (address &amp; 0xff);
835             }
836         } else {
837             getInet6Address_ipaddress(env, iaObj, (char *)caddr);
838             scopeid = getInet6Address_scopeid(env, iaObj);
<span class="line-removed">839             cached_scope_id = (unsigned int)(*env)-&gt;GetIntField(env, iaObj, ia6_cachedscopeidID);</span>
840         }
841         sa-&gt;sa6.sin6_port = (u_short)htons((u_short)port);
842         memcpy((void *)&amp;sa-&gt;sa6.sin6_addr, caddr, sizeof(struct in6_addr));
843         sa-&gt;sa6.sin6_family = AF_INET6;
<span class="line-modified">844         if ((family == java_net_InetAddress_IPv6) &amp;&amp;</span>
<span class="line-removed">845             IN6_IS_ADDR_LINKLOCAL(&amp;sa-&gt;sa6.sin6_addr) &amp;&amp;</span>
<span class="line-removed">846             (!scopeid &amp;&amp; !cached_scope_id))</span>
<span class="line-removed">847         {</span>
<span class="line-removed">848             cached_scope_id = getDefaultIPv6Interface(env, &amp;sa-&gt;sa6);</span>
<span class="line-removed">849             (*env)-&gt;SetIntField(env, iaObj, ia6_cachedscopeidID, cached_scope_id);</span>
<span class="line-removed">850         }</span>
<span class="line-removed">851         sa-&gt;sa6.sin6_scope_id = scopeid == 0 ? cached_scope_id : scopeid;</span>
852         if (len != NULL) {
853             *len = sizeof(struct sockaddr_in6);
854         }
855     } else {
856         jint address;
857         if (family != java_net_InetAddress_IPv4) {
858             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Protocol family unavailable&quot;);
859             return -1;
860         }
861         address = getInetAddress_addr(env, iaObj);
862         JNU_CHECK_EXCEPTION_RETURN(env, -1);
863         sa-&gt;sa4.sin_port = htons((short)port);
864         sa-&gt;sa4.sin_addr.s_addr = (u_long)htonl(address);
865         sa-&gt;sa4.sin_family = AF_INET;
866         if (len != NULL) {
867             *len = sizeof(struct sockaddr_in);
868         }
869     }
870     return 0;
871 }
</pre>
</td>
<td>
<hr />
<pre>
197 void
198 NET_ThrowCurrent(JNIEnv *env, char *msg)
199 {
200     NET_ThrowNew(env, WSAGetLastError(), msg);
201 }
202 
203 void
204 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
205                    const char *defaultDetail) {
206     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
207 }
208 
209 jfieldID
210 NET_GetFileDescriptorID(JNIEnv *env)
211 {
212     jclass cls = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;);
213     CHECK_NULL_RETURN(cls, NULL);
214     return (*env)-&gt;GetFieldID(env, cls, &quot;fd&quot;, &quot;I&quot;);
215 }
216 
<span class="line-added">217 jint  IPv4_supported()</span>
<span class="line-added">218 {</span>
<span class="line-added">219     /* TODO: properly check for IPv4 support on Windows */</span>
<span class="line-added">220     return JNI_TRUE;</span>
<span class="line-added">221 }</span>
<span class="line-added">222 </span>
223 jint  IPv6_supported()
224 {
225     SOCKET s = socket(AF_INET6, SOCK_STREAM, 0) ;
226     if (s == INVALID_SOCKET) {
227         return JNI_FALSE;
228     }
229     closesocket(s);
230 
231     return JNI_TRUE;
232 }
233 
234 jint reuseport_supported()
235 {
236     /* SO_REUSEPORT is not supported on Windows */
237     return JNI_FALSE;
238 }
239 
240 /* call NET_MapSocketOptionV6 for the IPv6 fd only
241  * and NET_MapSocketOption for the IPv4 fd
242  */
</pre>
<hr />
<pre>
735             bound_port = GET_PORT (&amp;oaddr);
736             SET_PORT (b-&gt;addr, bound_port);
737             rv = NET_WinBind(fd, b-&gt;addr, sizeof(SOCKETADDRESS), exclBind);
738 
739             if (rv != SOCKET_ERROR) {
740                 if (family == AF_INET) {
741                     b-&gt;ipv4_fd = fd;
742                     b-&gt;ipv6_fd = ofd;
743                 } else {
744                     b-&gt;ipv4_fd = ofd;
745                     b-&gt;ipv6_fd = fd;
746                 }
747                 return 0;
748             }
749         }
750         CLOSE_SOCKETS_AND_RETURN;
751     }
752     return 0;
753 }
754 































755 /**
756  * Enables SIO_LOOPBACK_FAST_PATH
757  */
758 JNIEXPORT jint JNICALL
759 NET_EnableFastTcpLoopback(int fd) {
760     int enabled = 1;
761     DWORD result_byte_count = -1;
762     int result = WSAIoctl(fd,
763                           SIO_LOOPBACK_FAST_PATH,
764                           &amp;enabled,
765                           sizeof(enabled),
766                           NULL,
767                           0,
768                           &amp;result_byte_count,
769                           NULL,
770                           NULL);
771     return result == SOCKET_ERROR ? WSAGetLastError() : 0;
772 }
773 
774 /**
775  * See net_util.h for documentation
776  */
777 JNIEXPORT int JNICALL
778 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port,
779                           SOCKETADDRESS *sa, int *len,
780                           jboolean v4MappedAddress)
781 {
782     jint family = getInetAddress_family(env, iaObj);
783     JNU_CHECK_EXCEPTION_RETURN(env, -1);
784     memset((char *)sa, 0, sizeof(SOCKETADDRESS));
785 
786     if (ipv6_available() &amp;&amp;
787         !(family == java_net_InetAddress_IPv4 &amp;&amp;
788           v4MappedAddress == JNI_FALSE))
789     {
790         jbyte caddr[16];
791         jint address;
<span class="line-modified">792         unsigned int scopeid = 0;</span>
793 
794         if (family == java_net_InetAddress_IPv4) {
795             // convert to IPv4-mapped address
796             memset((char *)caddr, 0, 16);
797             address = getInetAddress_addr(env, iaObj);
798             JNU_CHECK_EXCEPTION_RETURN(env, -1);
799             if (address == INADDR_ANY) {
800                 /* we would always prefer IPv6 wildcard address
801                  * caddr[10] = 0xff;
802                  * caddr[11] = 0xff; */
803             } else {
804                 caddr[10] = 0xff;
805                 caddr[11] = 0xff;
806                 caddr[12] = ((address &gt;&gt; 24) &amp; 0xff);
807                 caddr[13] = ((address &gt;&gt; 16) &amp; 0xff);
808                 caddr[14] = ((address &gt;&gt; 8) &amp; 0xff);
809                 caddr[15] = (address &amp; 0xff);
810             }
811         } else {
812             getInet6Address_ipaddress(env, iaObj, (char *)caddr);
813             scopeid = getInet6Address_scopeid(env, iaObj);

814         }
815         sa-&gt;sa6.sin6_port = (u_short)htons((u_short)port);
816         memcpy((void *)&amp;sa-&gt;sa6.sin6_addr, caddr, sizeof(struct in6_addr));
817         sa-&gt;sa6.sin6_family = AF_INET6;
<span class="line-modified">818         sa-&gt;sa6.sin6_scope_id = scopeid;</span>







819         if (len != NULL) {
820             *len = sizeof(struct sockaddr_in6);
821         }
822     } else {
823         jint address;
824         if (family != java_net_InetAddress_IPv4) {
825             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Protocol family unavailable&quot;);
826             return -1;
827         }
828         address = getInetAddress_addr(env, iaObj);
829         JNU_CHECK_EXCEPTION_RETURN(env, -1);
830         sa-&gt;sa4.sin_port = htons((short)port);
831         sa-&gt;sa4.sin_addr.s_addr = (u_long)htonl(address);
832         sa-&gt;sa4.sin_family = AF_INET;
833         if (len != NULL) {
834             *len = sizeof(struct sockaddr_in);
835         }
836     }
837     return 0;
838 }
</pre>
</td>
</tr>
</table>
<center><a href="TwoStacksPlainDatagramSocketImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../libnio/ch/DatagramChannelImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
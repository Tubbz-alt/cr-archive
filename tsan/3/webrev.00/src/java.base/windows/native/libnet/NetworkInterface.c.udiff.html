<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/windows/native/libnet/NetworkInterface.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="NTLMAuthentication.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NetworkInterface_winXP.c.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnet/NetworkInterface.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,10 +23,11 @@</span>
   * questions.
   */
  #include &quot;net_util.h&quot;
  #include &quot;NetworkInterface.h&quot;
  
<span class="udiff-line-added">+ #include &quot;java_net_InetAddress.h&quot;</span>
  #include &quot;java_net_NetworkInterface.h&quot;
  
  /*
   * Windows implementation of the java.net.NetworkInterface native methods.
   * This module provides the implementations of getAll, getByName, getByIndex,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -345,36 +346,25 @@</span>
      }
  
      /*
       * Free the interface table and return the interface list
       */
<span class="udiff-line-modified-removed">-     if (tableP) {</span>
<span class="udiff-line-modified-added">+     if (tableP != NULL) {</span>
          free(tableP);
      }
      *netifPP = netifP;
      return count;
  }
  
  /*
<span class="udiff-line-modified-removed">-  * Enumerate the IP addresses on an interface using the IP helper library</span>
<span class="udiff-line-removed">-  * routine GetIfAddrTable and matching based on the index name. There are</span>
<span class="udiff-line-removed">-  * more efficient routines but we use GetIfAddrTable because it&#39;s avaliable</span>
<span class="udiff-line-removed">-  * on 98 and NT.</span>
<span class="udiff-line-removed">-  *</span>
<span class="udiff-line-removed">-  * Returns the count of addresses, or -1 if error. If no error occurs then</span>
<span class="udiff-line-removed">-  * netaddrPP will return a list of netaddr structures with the IP addresses.</span>
<span class="udiff-line-modified-added">+  * Enumerate all addresses using the IP helper library</span>
   */
<span class="udiff-line-modified-removed">- int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP)</span>
<span class="udiff-line-modified-added">+ int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP)</span>
  {
      MIB_IPADDRTABLE *tableP;
      ULONG size;
      DWORD ret;
<span class="udiff-line-removed">-     DWORD i;</span>
<span class="udiff-line-removed">-     netaddr *netaddrP;</span>
<span class="udiff-line-removed">-     int count = 0;</span>
<span class="udiff-line-removed">-     unsigned long mask;</span>
<span class="udiff-line-removed">- </span>
      /*
       * Use GetIpAddrTable to enumerate the IP Addresses
       */
      size = sizeof(MIB_IPADDRTABLE);
      tableP = (MIB_IPADDRTABLE *)malloc(size);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -394,29 +384,48 @@</span>
          tableP = newTableP;
  
          ret = GetIpAddrTable(tableP, &amp;size, FALSE);
      }
      if (ret != NO_ERROR) {
<span class="udiff-line-modified-removed">-         if (tableP) {</span>
<span class="udiff-line-modified-added">+         if (tableP != NULL) {</span>
              free(tableP);
          }
          JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
                  &quot;IP Helper Library GetIpAddrTable function failed&quot;);
          // this different error code is to handle the case when we call
          // GetIpAddrTable in pure IPv6 environment
          return -2;
      }
<span class="udiff-line-added">+     *tablePP = tableP;</span>
<span class="udiff-line-added">+     return 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+  * Enumerate the IP addresses on an interface, given an IP address table</span>
<span class="udiff-line-added">+  * and matching based on index.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Returns the count of addresses, or -1 if error. If no error occurs then</span>
<span class="udiff-line-added">+  * netaddrPP will return a list of netaddr structures with the IP addresses.</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     DWORD i;</span>
<span class="udiff-line-added">+     netaddr *netaddrP;</span>
<span class="udiff-line-added">+     int count = 0;</span>
<span class="udiff-line-added">+     unsigned long mask;</span>
  
      /*
       * Iterate through the table to find the addresses with the
       * matching dwIndex. Ignore 0.0.0.0 addresses.
       */
<span class="udiff-line-added">+     if (tableP == NULL)</span>
<span class="udiff-line-added">+         return 0;</span>
      count = 0;
      netaddrP = NULL;
  
      i = 0;
<span class="udiff-line-modified-removed">-     while (i&lt;tableP-&gt;dwNumEntries) {</span>
<span class="udiff-line-modified-added">+     while (i &lt; tableP-&gt;dwNumEntries) {</span>
          if (tableP-&gt;table[i].dwIndex == netifP-&gt;dwIndex &amp;&amp;
              tableP-&gt;table[i].dwAddr != 0) {
  
              netaddr *curr = (netaddr *)malloc(sizeof(netaddr));
              if (curr == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -435,51 +444,71 @@</span>
              case MIB_IF_TYPE_ETHERNET:
              case MIB_IF_TYPE_TOKENRING:
              case MIB_IF_TYPE_FDDI:
              case MIB_IF_TYPE_LOOPBACK:
              case IF_TYPE_IEEE80211:
<span class="udiff-line-modified-removed">-               /**</span>
<span class="udiff-line-modified-removed">-                * Contrary to what it seems to indicate, dwBCastAddr doesn&#39;t</span>
<span class="udiff-line-modified-removed">-                * contain the broadcast address but 0 or 1 depending on whether</span>
<span class="udiff-line-modified-removed">-                * the broadcast address should set the bits of the host part</span>
<span class="udiff-line-modified-removed">-                * to 0 or 1.</span>
<span class="udiff-line-modified-removed">-                * Yes, I know it&#39;s stupid, but what can I say, it&#39;s MSFTs API.</span>
<span class="udiff-line-modified-removed">-                */</span>
<span class="udiff-line-modified-removed">-               curr-&gt;brdcast.sa4.sin_family = AF_INET;</span>
<span class="udiff-line-modified-removed">-               if (tableP-&gt;table[i].dwBCastAddr == 1)</span>
<span class="udiff-line-modified-removed">-                 curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask) | (0xffffffff ^ tableP-&gt;table[i].dwMask);</span>
<span class="udiff-line-modified-removed">-               else</span>
<span class="udiff-line-modified-removed">-                 curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask);</span>
<span class="udiff-line-modified-removed">-               mask = ntohl(tableP-&gt;table[i].dwMask);</span>
<span class="udiff-line-modified-removed">-               curr-&gt;mask = 0;</span>
<span class="udiff-line-modified-removed">-               while (mask) {</span>
<span class="udiff-line-modified-removed">-                 mask &lt;&lt;= 1;</span>
<span class="udiff-line-modified-removed">-                 curr-&gt;mask++;</span>
<span class="udiff-line-modified-removed">-               }</span>
<span class="udiff-line-modified-removed">-               break;</span>
<span class="udiff-line-modified-added">+                 /**</span>
<span class="udiff-line-modified-added">+                  * Contrary to what it seems to indicate, dwBCastAddr doesn&#39;t</span>
<span class="udiff-line-modified-added">+                  * contain the broadcast address but 0 or 1 depending on whether</span>
<span class="udiff-line-modified-added">+                  * the broadcast address should set the bits of the host part</span>
<span class="udiff-line-modified-added">+                  * to 0 or 1.</span>
<span class="udiff-line-modified-added">+                  * Yes, I know it&#39;s stupid, but what can I say, it&#39;s MSFTs API.</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 curr-&gt;brdcast.sa4.sin_family = AF_INET;</span>
<span class="udiff-line-modified-added">+                 if (tableP-&gt;table[i].dwBCastAddr == 1)</span>
<span class="udiff-line-modified-added">+                     curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask) | (0xffffffff ^ tableP-&gt;table[i].dwMask);</span>
<span class="udiff-line-modified-added">+                 else</span>
<span class="udiff-line-modified-added">+                     curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask);</span>
<span class="udiff-line-modified-added">+                 mask = ntohl(tableP-&gt;table[i].dwMask);</span>
<span class="udiff-line-modified-added">+                 curr-&gt;mask = 0;</span>
<span class="udiff-line-modified-added">+                 while (mask) {</span>
<span class="udiff-line-modified-added">+                     mask &lt;&lt;= 1;</span>
<span class="udiff-line-modified-added">+                     curr-&gt;mask++;</span>
<span class="udiff-line-modified-added">+                 }</span>
<span class="udiff-line-modified-added">+                 break;</span>
              case MIB_IF_TYPE_PPP:
              case MIB_IF_TYPE_SLIP:
              default:
<span class="udiff-line-modified-removed">-               /**</span>
<span class="udiff-line-modified-removed">-                * these don&#39;t have broadcast/subnet</span>
<span class="udiff-line-modified-removed">-                */</span>
<span class="udiff-line-modified-removed">-               curr-&gt;mask = -1;</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-added">+                 /**</span>
<span class="udiff-line-modified-added">+                  * these don&#39;t have broadcast/subnet</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 curr-&gt;mask = -1;</span>
<span class="udiff-line-modified-added">+                     break;</span>
              }
  
              curr-&gt;next = netaddrP;
              netaddrP = curr;
              count++;
          }
          i++;
      }
  
      *netaddrPP = netaddrP;
<span class="udiff-line-added">+     return count;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+  * Enumerate the IP addresses on an interface, using an IP address table</span>
<span class="udiff-line-added">+  * retrieved using GetIPAddrTable and matching based on index.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Returns the count of addresses, or -1 if error. If no error occurs then</span>
<span class="udiff-line-added">+  * netaddrPP will return a list of netaddr structures with the IP addresses.</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP) {</span>
<span class="udiff-line-added">+     MIB_IPADDRTABLE *tableP;</span>
<span class="udiff-line-added">+     int count;</span>
<span class="udiff-line-added">+     int ret = lookupIPAddrTable(env, &amp;tableP);</span>
<span class="udiff-line-added">+     if (ret &lt; 0) {</span>
<span class="udiff-line-added">+       return NULL;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     count = enumAddresses_win_ipaddrtable(env, netifP, netaddrPP, tableP);</span>
      free(tableP);
      return count;
  }
  
<span class="udiff-line-added">+ </span>
  /*
   * Class:     java_net_NetworkInterface
   * Method:    init
   * Signature: ()V
   */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -756,24 +785,68 @@</span>
      free_netif(ifList);
  
      return netifObj;
  }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+  * Class:     java_net_NetworkInterface</span>
<span class="udiff-line-added">+  * Method:    boundInetAddress0</span>
<span class="udiff-line-added">+  * Signature: (Ljava/net/InetAddress;)Z</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0</span>
<span class="udiff-line-added">+     (JNIEnv *env, jclass cls, jobject iaObj)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     jobject netifObj = NULL;</span>
<span class="udiff-line-added">+     DWORD i;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     int family = getInetAddress_family(env, iaObj);</span>
<span class="udiff-line-added">+     JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (family == java_net_InetAddress_IPv6) {</span>
<span class="udiff-line-added">+         if (!ipv6_available())</span>
<span class="udiff-line-added">+             return JNI_FALSE;</span>
<span class="udiff-line-added">+         return Java_java_net_NetworkInterface_getByInetAddress0_XP(env, cls, iaObj) != NULL;</span>
<span class="udiff-line-added">+     } else if (family == java_net_InetAddress_IPv4) {</span>
<span class="udiff-line-added">+         jint addr = getInetAddress_addr(env, iaObj);</span>
<span class="udiff-line-added">+         JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         jboolean found = JNI_FALSE;</span>
<span class="udiff-line-added">+         MIB_IPADDRTABLE *tableP;</span>
<span class="udiff-line-added">+         if (lookupIPAddrTable(env, &amp;tableP) &gt;= 0 &amp;&amp; tableP != NULL) {</span>
<span class="udiff-line-added">+             for (i = 0; i &lt; tableP-&gt;dwNumEntries; i++) {</span>
<span class="udiff-line-added">+                 if (tableP-&gt;table[i].dwAddr != 0 &amp;&amp;</span>
<span class="udiff-line-added">+                     (unsigned long)addr == ntohl(tableP-&gt;table[i].dwAddr)) {</span>
<span class="udiff-line-added">+                     found = JNI_TRUE;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (tableP != NULL) {</span>
<span class="udiff-line-added">+           free(tableP);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return found;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       // Unknown address family</span>
<span class="udiff-line-added">+       return JNI_FALSE;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
   * Class:     java_net_NetworkInterface
   * Method:    getByInetAddress0
   * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;
   */
  JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0
      (JNIEnv *env, jclass cls, jobject iaObj)
  {
      netif *ifList, *curr;
<span class="udiff-line-added">+     MIB_IPADDRTABLE *tableP;</span>
      jobject netifObj = NULL;
      jint addr = getInetAddress_addr(env, iaObj);
      JNU_CHECK_EXCEPTION_RETURN(env, NULL);
  
<span class="udiff-line-removed">-     // Retained for now to support IPv4 only stack, java.net.preferIPv4Stack</span>
      if (ipv6_available()) {
          return Java_java_net_NetworkInterface_getByInetAddress0_XP (env, cls, iaObj);
      }
  
      /* get the list of interfaces */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -783,47 +856,55 @@</span>
  
      /*
       * Enumerate the addresses on each interface until we find a
       * matching address.
       */
<span class="udiff-line-modified-removed">-     curr = ifList;</span>
<span class="udiff-line-modified-removed">-     while (curr != NULL) {</span>
<span class="udiff-line-modified-removed">-         int count;</span>
<span class="udiff-line-modified-removed">-         netaddr *addrList;</span>
<span class="udiff-line-modified-removed">-         netaddr *addrP;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         /* enumerate the addresses on this interface */</span>
<span class="udiff-line-modified-removed">-         count = enumAddresses_win(env, curr, &amp;addrList);</span>
<span class="udiff-line-modified-removed">-         if (count &lt; 0) {</span>
<span class="udiff-line-modified-removed">-             free_netif(ifList);</span>
<span class="udiff-line-modified-removed">-             return NULL;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     tableP = NULL;</span>
<span class="udiff-line-modified-added">+     if (lookupIPAddrTable(env, &amp;tableP) &gt;= 0) {</span>
<span class="udiff-line-modified-added">+         curr = ifList;</span>
<span class="udiff-line-modified-added">+         while (curr != NULL) {</span>
<span class="udiff-line-modified-added">+             int count;</span>
<span class="udiff-line-modified-added">+             netaddr *addrList;</span>
<span class="udiff-line-modified-added">+             netaddr *addrP;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             /* enumerate the addresses on this interface */</span>
<span class="udiff-line-modified-added">+             count = enumAddresses_win_ipaddrtable(env, curr, &amp;addrList, tableP);</span>
<span class="udiff-line-modified-added">+             if (count &lt; 0) {</span>
<span class="udiff-line-modified-added">+                 free_netif(ifList);</span>
<span class="udiff-line-added">+                 free(tableP);</span>
<span class="udiff-line-added">+                 return NULL;</span>
<span class="udiff-line-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         /* iterate through each address */</span>
<span class="udiff-line-modified-removed">-         addrP = addrList;</span>
<span class="udiff-line-modified-added">+             /* iterate through each address */</span>
<span class="udiff-line-modified-added">+             addrP = addrList;</span>
  
<span class="udiff-line-modified-removed">-         while (addrP != NULL) {</span>
<span class="udiff-line-modified-removed">-             if ((unsigned long)addr == ntohl(addrP-&gt;addr.sa4.sin_addr.s_addr)) {</span>
<span class="udiff-line-modified-added">+             while (addrP != NULL) {</span>
<span class="udiff-line-modified-added">+                 if ((unsigned long)addr == ntohl(addrP-&gt;addr.sa4.sin_addr.s_addr)) {</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 addrP = addrP-&gt;next;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Address matched so create NetworkInterface for this interface</span>
<span class="udiff-line-added">+              * and address list.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             if (addrP != NULL) {</span>
<span class="udiff-line-added">+                 /* createNetworkInterface will free addrList */</span>
<span class="udiff-line-added">+                 netifObj = createNetworkInterface(env, curr, count, addrList);</span>
                  break;
              }
<span class="udiff-line-removed">-             addrP = addrP-&gt;next;</span>
<span class="udiff-line-removed">-         }</span>
  
<span class="udiff-line-modified-removed">-         /*</span>
<span class="udiff-line-modified-removed">-          * Address matched so create NetworkInterface for this interface</span>
<span class="udiff-line-removed">-          * and address list.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         if (addrP != NULL) {</span>
<span class="udiff-line-removed">-             /* createNetworkInterface will free addrList */</span>
<span class="udiff-line-removed">-             netifObj = createNetworkInterface(env, curr, count, addrList);</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-modified-added">+             /* on next interface */</span>
<span class="udiff-line-modified-added">+             curr = curr-&gt;next;</span>
          }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /* on next interface */</span>
<span class="udiff-line-removed">-         curr = curr-&gt;next;</span>
      }
  
<span class="udiff-line-added">+     /* release the IP address table */</span>
<span class="udiff-line-added">+     if (tableP != NULL)</span>
<span class="udiff-line-added">+         free(tableP);</span>
<span class="udiff-line-added">+ </span>
      /* release the interface list */
      free_netif(ifList);
  
      return netifObj;
  }
</pre>
<center><a href="NTLMAuthentication.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NetworkInterface_winXP.c.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/windows/native/libnet/NetworkInterface_winXP.c b/src/java.base/windows/native/libnet/NetworkInterface_winXP.c
--- a/src/java.base/windows/native/libnet/NetworkInterface_winXP.c
+++ b/src/java.base/windows/native/libnet/NetworkInterface_winXP.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -31,19 +31,21 @@
  * Windows implementation of the java.net.NetworkInterface native methods.
  * This module provides the implementations of getAll, getByName, getByIndex,
  * and getByAddress.
  */
 
+extern int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP);
 extern int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP);
+extern int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP);
 int getAddrsFromAdapter(IP_ADAPTER_ADDRESSES *ptr, netaddr **netaddrPP);
 
 #ifdef DEBUG
 void printnif (netif *nif) {
 #ifdef _WIN64
         printf ("nif:0x%I64x name:%s\n", (UINT_PTR)nif, nif->name);
 #else
-        printf ("nif:0x%x name:%s\n", nif, nif->name);
+        printf ("nif:0x%x name:%s\n", (UINT_PTR)nif, nif->name);
 #endif
         if (nif->dNameIsUnicode) {
             printf ("dName:%S index:%d ", (unsigned short *)nif->displayName,
                 nif->index);
         } else {
@@ -69,12 +71,12 @@
 /*
  * return an array of IP_ADAPTER_ADDRESSES containing one element
  * for each adapter on the system. Returned in *adapters.
  * Buffer is malloc'd and must be freed (unless error returned)
  */
-static int getAdapters (JNIEnv *env, IP_ADAPTER_ADDRESSES **adapters) {
-    DWORD ret, flags;
+int getAdapters (JNIEnv *env, int flags, IP_ADAPTER_ADDRESSES **adapters) {
+    DWORD ret;
     IP_ADAPTER_ADDRESSES *adapterInfo;
     ULONG len;
     int try;
 
     adapterInfo = (IP_ADAPTER_ADDRESSES *) malloc(BUFF_SIZE);
@@ -83,13 +85,10 @@
             "Native heap allocation failure");
         return -1;
     }
 
     len = BUFF_SIZE;
-    flags = GAA_FLAG_SKIP_DNS_SERVER;
-    flags |= GAA_FLAG_SKIP_MULTICAST;
-    flags |= GAA_FLAG_INCLUDE_PREFIX;
     ret = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, adapterInfo, &len);
 
     for (try = 0; ret == ERROR_BUFFER_OVERFLOW && try < MAX_TRIES; ++try) {
         IP_ADAPTER_ADDRESSES * newAdapterInfo = NULL;
         if (len < (ULONG_MAX - BUFF_SIZE)) {
@@ -236,11 +235,12 @@
 
 /*
  */
 int getAllInterfacesAndAddresses (JNIEnv *env, netif **netifPP)
 {
-    DWORD ret;
+    DWORD ret, flags;
+    MIB_IPADDRTABLE *tableP;
     IP_ADAPTER_ADDRESSES *ptr, *adapters=NULL;
     ULONG len=ipinflen, count=0;
     netif *nif=NULL, *dup_nif, *last=NULL, *loopif=NULL, *curr;
     int tun=0, net=0;
 
@@ -269,14 +269,19 @@
         last = nif;
     }
 
     // Retrieve IPv4 addresses with the IP Helper API
     curr = *netifPP;
+    ret = lookupIPAddrTable(env, &tableP);
+    if (ret < 0) {
+      return -1;
+    }
     while (curr != NULL) {
         netaddr *netaddrP;
-        ret = enumAddresses_win(env, curr, &netaddrP);
+        ret = enumAddresses_win_ipaddrtable(env, curr, &netaddrP, tableP);
         if (ret == -1) {
+            free(tableP);
             return -1;
         } else if (ret == -2) {
             if ((*env)->ExceptionCheck(env)) {
                 (*env)->ExceptionClear(env);
             }
@@ -285,12 +290,16 @@
             curr->addrs = netaddrP;
             curr->naddrs += ret;
             curr = curr->next;
         }
     }
+    free(tableP);
 
-    ret = getAdapters (env, &adapters);
+    flags = GAA_FLAG_SKIP_DNS_SERVER;
+    flags |= GAA_FLAG_SKIP_MULTICAST;
+    flags |= GAA_FLAG_INCLUDE_PREFIX;
+    ret = getAdapters (env, flags, &adapters);
     if (ret != ERROR_SUCCESS) {
         goto err;
     }
 
     /* Now get the IPv6 information. This includes:
@@ -314,10 +323,11 @@
             c = getAddrsFromAdapter(ptr, &loopif->addrs);
             if (c == -1) {
                 goto err;
             }
             loopif->naddrs += c;
+            loopif->ipv6Index = ptr->Ipv6IfIndex;
         } else {
             int index = ptr->IfIndex;
             if (index != 0) {
                 /* This entry is associated with an IPv4 interface */
                 for (nif=*netifPP; nif!=NULL; nif=nif->next) {

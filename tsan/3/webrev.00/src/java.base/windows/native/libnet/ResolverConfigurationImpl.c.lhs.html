<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/native/libnet/ResolverConfigurationImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;
<a name="2" id="anc2"></a><span class="line-removed"> 27 #include &lt;windows.h&gt;</span>
 28 #include &lt;stdio.h&gt;
 29 #include &lt;stddef.h&gt;
<a name="3" id="anc3"></a><span class="line-removed"> 30 #include &lt;iprtrmib.h&gt;</span>
 31 #include &lt;time.h&gt;
 32 #include &lt;assert.h&gt;
<a name="4" id="anc4"></a><span class="line-removed"> 33 #include &lt;iphlpapi.h&gt;</span>
 34 
<a name="5" id="anc5"></a>
 35 #include &quot;jni_util.h&quot;
 36 
<a name="6" id="anc6"></a><span class="line-modified"> 37 #define MAX_STR_LEN         256</span>
 38 
 39 #define STS_NO_CONFIG       0x0             /* no configuration found */
 40 #define STS_SL_FOUND        0x1             /* search list found */
 41 #define STS_NS_FOUND        0x2             /* name servers found */
 42 #define STS_ERROR           -1              /* error return  lodConfig failed memory allccation failure*/
 43 
 44 #define IS_SL_FOUND(sts)    (sts &amp; STS_SL_FOUND)
 45 #define IS_NS_FOUND(sts)    (sts &amp; STS_NS_FOUND)
 46 
 47 /* JNI ids */
 48 static jfieldID searchlistID;
 49 static jfieldID nameserversID;
 50 
<a name="7" id="anc7"></a>

 51 /*
<a name="8" id="anc8"></a><span class="line-modified"> 52  * Utility routine to append s2 to s1 with a space delimiter.</span>
<span class="line-modified"> 53  *  strappend(s1=&quot;abc&quot;, &quot;def&quot;)  =&gt; &quot;abc def&quot;</span>
 54  *  strappend(s1=&quot;&quot;, &quot;def&quot;)     =&gt; &quot;def
 55  */
 56 void strappend(char *s1, char *s2) {
 57     size_t len;
 58 
 59     if (s2[0] == &#39;\0&#39;)                      /* nothing to append */
 60         return;
 61 
 62     len = strlen(s1)+1;
<a name="9" id="anc9"></a><span class="line-modified"> 63     if (s1[0] != 0)                         /* needs space character */</span>
 64         len++;
 65     if (len + strlen(s2) &gt; MAX_STR_LEN)     /* insufficient space */
 66         return;
 67 
 68     if (s1[0] != 0) {
<a name="10" id="anc10"></a><span class="line-modified"> 69         strcat(s1, &quot; &quot;);</span>
 70     }
 71     strcat(s1, s2);
 72 }
 73 
 74 /*
<a name="11" id="anc11"></a><span class="line-modified"> 75  * Windows 2000/XP</span>
<span class="line-modified"> 76  *</span>
<span class="line-removed"> 77  * Use registry approach based on settings described in Appendix C</span>
<span class="line-removed"> 78  * of &quot;Microsoft Windows 2000 TCP/IP Implementation Details&quot;.</span>
<span class="line-removed"> 79  *</span>
<span class="line-removed"> 80  * DNS suffix list is obtained from SearchList registry setting. If</span>
<span class="line-removed"> 81  * this is not specified we compile suffix list based on the</span>
<span class="line-removed"> 82  * per-connection domain suffix.</span>
<span class="line-removed"> 83  *</span>
<span class="line-removed"> 84  * DNS name servers and domain settings are on a per-connection</span>
<span class="line-removed"> 85  * basic. We therefore enumerate the network adapters to get the</span>
<span class="line-removed"> 86  * names of each adapter and then query the corresponding registry</span>
<span class="line-removed"> 87  * settings to obtain NameServer/DhcpNameServer and Domain/DhcpDomain.</span>
 88  */
<a name="12" id="anc12"></a><span class="line-modified"> 89 static int loadConfig(char *sl, char *ns) {</span>
<span class="line-modified"> 90     IP_ADAPTER_INFO *adapterP;</span>
<span class="line-modified"> 91     ULONG size;</span>
<span class="line-modified"> 92     DWORD ret;</span>

 93     DWORD dwLen;
 94     ULONG ulType;
 95     char result[MAX_STR_LEN];
 96     HANDLE hKey;
<a name="13" id="anc13"></a><span class="line-modified"> 97     int gotSearchList = 0;</span>

 98 
 99     /*
100      * First see if there is a global suffix list specified.
101      */
102     ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
103                        &quot;SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters&quot;,
104                        0,
105                        KEY_READ,
106                        (PHKEY)&amp;hKey);
107     if (ret == ERROR_SUCCESS) {
108         dwLen = sizeof(result);
109         ret = RegQueryValueEx(hKey, &quot;SearchList&quot;, NULL, &amp;ulType,
110                              (LPBYTE)&amp;result, &amp;dwLen);
111         if (ret == ERROR_SUCCESS) {
112             assert(ulType == REG_SZ);
113             if (strlen(result) &gt; 0) {
114                 strappend(sl, result);
<a name="14" id="anc14"></a><span class="line-removed">115                 gotSearchList = 1;</span>
116             }
117         }
118         RegCloseKey(hKey);
119     }
120 
<a name="15" id="anc15"></a><span class="line-removed">121     /*</span>
<span class="line-removed">122      * Ask the IP Helper library to enumerate the adapters</span>
<span class="line-removed">123      */</span>
<span class="line-removed">124     size = sizeof(IP_ADAPTER_INFO);</span>
<span class="line-removed">125     adapterP = (IP_ADAPTER_INFO *)malloc(size);</span>
<span class="line-removed">126     if (adapterP == NULL) {</span>
<span class="line-removed">127         return STS_ERROR;</span>
<span class="line-removed">128     }</span>
<span class="line-removed">129     ret = GetAdaptersInfo(adapterP, &amp;size);</span>
<span class="line-removed">130     if (ret == ERROR_BUFFER_OVERFLOW) {</span>
<span class="line-removed">131         IP_ADAPTER_INFO *newAdapterP = (IP_ADAPTER_INFO *)realloc(adapterP, size);</span>
<span class="line-removed">132         if (newAdapterP == NULL) {</span>
<span class="line-removed">133             free(adapterP);</span>
<span class="line-removed">134             return STS_ERROR;</span>
<span class="line-removed">135         }</span>
<span class="line-removed">136         adapterP = newAdapterP;</span>
137 
<a name="16" id="anc16"></a><span class="line-modified">138         ret = GetAdaptersInfo(adapterP, &amp;size);</span>








139     }
140 
<a name="17" id="anc17"></a><span class="line-modified">141     /*</span>
<span class="line-modified">142      * Iterate through the list of adapters as registry settings are</span>
<span class="line-modified">143      * keyed on the adapter name (GUID).</span>
<span class="line-modified">144      */</span>
<span class="line-modified">145     if (ret == ERROR_SUCCESS) {</span>
<span class="line-modified">146         IP_ADAPTER_INFO *curr = adapterP;</span>
<span class="line-modified">147         while (curr != NULL) {</span>
<span class="line-modified">148             char key[MAX_STR_LEN];</span>
<span class="line-modified">149 </span>
<span class="line-modified">150             sprintf(key,</span>
<span class="line-modified">151                 &quot;SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\%s&quot;,</span>
<span class="line-modified">152                 curr-&gt;AdapterName);</span>
<span class="line-modified">153 </span>
<span class="line-modified">154             ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span>
<span class="line-modified">155                                key,</span>
<span class="line-removed">156                                0,</span>
<span class="line-removed">157                                KEY_READ,</span>
<span class="line-removed">158                                (PHKEY)&amp;hKey);</span>
<span class="line-removed">159             if (ret == ERROR_SUCCESS) {</span>
<span class="line-removed">160                 DWORD enableDhcp = 0;</span>
<span class="line-removed">161 </span>
<span class="line-removed">162                 /*</span>
<span class="line-removed">163                  * Is DHCP enabled on this interface</span>
<span class="line-removed">164                  */</span>
<span class="line-removed">165                 dwLen = sizeof(enableDhcp);</span>
<span class="line-removed">166                 ret = RegQueryValueEx(hKey, &quot;EnableDhcp&quot;, NULL, &amp;ulType,</span>
<span class="line-removed">167                                      (LPBYTE)&amp;enableDhcp, &amp;dwLen);</span>
<span class="line-removed">168 </span>
<span class="line-removed">169                 /*</span>
<span class="line-removed">170                  * If we don&#39;t have the suffix list when get the Domain</span>
<span class="line-removed">171                  * or DhcpDomain. If DHCP is enabled then Domain overides</span>
<span class="line-removed">172                  * DhcpDomain</span>
<span class="line-removed">173                  */</span>
<span class="line-removed">174                 if (!gotSearchList) {</span>
<span class="line-removed">175                     result[0] = &#39;\0&#39;;</span>
<span class="line-removed">176                     dwLen = sizeof(result);</span>
<span class="line-removed">177                     ret = RegQueryValueEx(hKey, &quot;Domain&quot;, NULL, &amp;ulType,</span>
<span class="line-removed">178                                          (LPBYTE)&amp;result, &amp;dwLen);</span>
<span class="line-removed">179                     if (((ret != ERROR_SUCCESS) || (strlen(result) == 0)) &amp;&amp;</span>
<span class="line-removed">180                         enableDhcp) {</span>
<span class="line-removed">181                         dwLen = sizeof(result);</span>
<span class="line-removed">182                         ret = RegQueryValueEx(hKey, &quot;DhcpDomain&quot;, NULL, &amp;ulType,</span>
<span class="line-removed">183                                               (LPBYTE)&amp;result, &amp;dwLen);</span>
<span class="line-removed">184                     }</span>
<span class="line-removed">185                     if (ret == ERROR_SUCCESS) {</span>
<span class="line-removed">186                         assert(ulType == REG_SZ);</span>
<span class="line-removed">187                         strappend(sl, result);</span>
188                     }
189                 }
190 
<a name="18" id="anc18"></a><span class="line-removed">191                 /*</span>
<span class="line-removed">192                  * Get DNS servers based on NameServer or DhcpNameServer</span>
<span class="line-removed">193                  * registry setting. If NameServer is set then it overrides</span>
<span class="line-removed">194                  * DhcpNameServer (even if DHCP is enabled).</span>
<span class="line-removed">195                  */</span>
<span class="line-removed">196                 result[0] = &#39;\0&#39;;</span>
197                 dwLen = sizeof(result);
<a name="19" id="anc19"></a><span class="line-modified">198                 ret = RegQueryValueEx(hKey, &quot;NameServer&quot;, NULL, &amp;ulType,</span>
<span class="line-modified">199                                      (LPBYTE)&amp;result, &amp;dwLen);</span>
<span class="line-modified">200                 if (((ret != ERROR_SUCCESS) || (strlen(result) == 0)) &amp;&amp;</span>
<span class="line-modified">201                     enableDhcp) {</span>
<span class="line-removed">202                     dwLen = sizeof(result);</span>
<span class="line-removed">203                     ret = RegQueryValueEx(hKey, &quot;DhcpNameServer&quot;, NULL, &amp;ulType,</span>
<span class="line-removed">204                                           (LPBYTE)&amp;result, &amp;dwLen);</span>
<span class="line-removed">205                 }</span>
<span class="line-removed">206                 if (ret == ERROR_SUCCESS) {</span>
<span class="line-removed">207                     assert(ulType == REG_SZ);</span>
208                     strappend(ns, result);
209                 }
210 
<a name="20" id="anc20"></a><span class="line-modified">211                 /*</span>
<span class="line-removed">212                  * Finished with this registry key</span>
<span class="line-removed">213                  */</span>
<span class="line-removed">214                 RegCloseKey(hKey);</span>
215             }
216 
<a name="21" id="anc21"></a><span class="line-modified">217             /*</span>
<span class="line-modified">218              * Onto the next adapeter</span>
<span class="line-modified">219              */</span>
<span class="line-modified">220             curr = curr-&gt;Next;</span>





221         }
<a name="22" id="anc22"></a><span class="line-removed">222     }</span>
223 
<a name="23" id="anc23"></a><span class="line-modified">224     /*</span>
<span class="line-removed">225      * Free the adpater structure</span>
<span class="line-removed">226      */</span>
<span class="line-removed">227     if (adapterP) {</span>
<span class="line-removed">228         free(adapterP);</span>
229     }
230 
<a name="24" id="anc24"></a>

231     return STS_SL_FOUND &amp; STS_NS_FOUND;
232 }
233 
234 
235 /*
<a name="25" id="anc25"></a><span class="line-modified">236  * Initialize JNI field IDs.</span>
237  */
238 JNIEXPORT void JNICALL
239 Java_sun_net_dns_ResolverConfigurationImpl_init0(JNIEnv *env, jclass cls)
240 {
241     searchlistID = (*env)-&gt;GetStaticFieldID(env, cls, &quot;os_searchlist&quot;,
242                                       &quot;Ljava/lang/String;&quot;);
243     CHECK_NULL(searchlistID);
244     nameserversID = (*env)-&gt;GetStaticFieldID(env, cls, &quot;os_nameservers&quot;,
245                                       &quot;Ljava/lang/String;&quot;);
246 }
247 
248 /*
249  * Class:     sun_net_dns_ResolverConfgurationImpl
250  * Method:    loadConfig0
251  * Signature: ()V
252  */
253 JNIEXPORT void JNICALL
254 Java_sun_net_dns_ResolverConfigurationImpl_loadDNSconfig0(JNIEnv *env, jclass cls)
255 {
256     char searchlist[MAX_STR_LEN];
257     char nameservers[MAX_STR_LEN];
258     jstring obj;
259 
260     searchlist[0] = &#39;\0&#39;;
261     nameservers[0] = &#39;\0&#39;;
262 
<a name="26" id="anc26"></a><span class="line-modified">263     if (loadConfig(searchlist, nameservers) != STS_ERROR) {</span>
264 
265         /*
266          * Populate static fields in sun.net.DefaultResolverConfiguration
267          */
268         obj = (*env)-&gt;NewStringUTF(env, searchlist);
269         CHECK_NULL(obj);
270         (*env)-&gt;SetStaticObjectField(env, cls, searchlistID, obj);
271 
272         obj = (*env)-&gt;NewStringUTF(env, nameservers);
273         CHECK_NULL(obj);
274         (*env)-&gt;SetStaticObjectField(env, cls, nameserversID, obj);
<a name="27" id="anc27"></a><span class="line-removed">275     } else {</span>
<span class="line-removed">276         JNU_ThrowOutOfMemoryError(env, &quot;native memory allocation failed&quot;);</span>
277     }
278 }
279 
280 
281 /*
282  * Class:     sun_net_dns_ResolverConfgurationImpl
283  * Method:    notifyAddrChange0
284  * Signature: ()I
285  */
286 JNIEXPORT jint JNICALL
287 Java_sun_net_dns_ResolverConfigurationImpl_notifyAddrChange0(JNIEnv *env, jclass cls)
288 {
289     OVERLAPPED ol;
290     HANDLE h;
291     DWORD rc, xfer;
292 
293     ol.hEvent = (HANDLE)0;
294     rc = NotifyAddrChange(&amp;h, &amp;ol);
295     if (rc == ERROR_IO_PENDING) {
296         rc = GetOverlappedResult(h, &amp;ol, &amp;xfer, TRUE);
297         if (rc != 0) {
298             return 0;   /* address changed */
299         }
300     }
301 
302     /* error */
303     return -1;
304 }
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
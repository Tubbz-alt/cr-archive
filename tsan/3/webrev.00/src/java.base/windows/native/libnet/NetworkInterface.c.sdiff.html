<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libnet/NetworkInterface.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="NTLMAuthentication.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NetworkInterface_winXP.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnet/NetworkInterface.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &quot;net_util.h&quot;
  26 #include &quot;NetworkInterface.h&quot;
  27 

  28 #include &quot;java_net_NetworkInterface.h&quot;
  29 
  30 /*
  31  * Windows implementation of the java.net.NetworkInterface native methods.
  32  * This module provides the implementations of getAll, getByName, getByIndex,
  33  * and getByAddress.
  34  *
  35  * Interfaces and addresses are enumerated using the IP helper routines
  36  * GetIfTable, GetIfAddrTable resp. These routines are available on Windows
  37  * 98, NT SP+4, 2000, and XP. They are also available on Windows 95 if
  38  * IE is upgraded to 5.x.
  39  *
  40  * Windows does not have any standard for device names so we are forced
  41  * to use our own convention which is based on the normal Unix naming
  42  * convention (&quot;lo&quot; for the loopback, eth0, eth1, .. for ethernet devices,
  43  * tr0, tr1, .. for token ring, and so on). This convention gives us
  44  * consistency across multiple Windows editions and also consistency with
  45  * Solaris/Linux device names. Note that we always enumerate in index
  46  * order and this ensures consistent device number across invocations.
  47  */
</pre>
<hr />
<pre>
 330          * returning the interfaces in index order.
 331          */
 332         count++;
 333         if (netifP == NULL) {
 334             netifP = curr;
 335         } else {
 336             netif *tail = netifP;
 337             while (tail-&gt;next != NULL) {
 338                 tail = tail-&gt;next;
 339             }
 340             tail-&gt;next = curr;
 341         }
 342 
 343         /* onto the next interface */
 344         ifrowP++;
 345     }
 346 
 347     /*
 348      * Free the interface table and return the interface list
 349      */
<span class="line-modified"> 350     if (tableP) {</span>
 351         free(tableP);
 352     }
 353     *netifPP = netifP;
 354     return count;
 355 }
 356 
 357 /*
<span class="line-modified"> 358  * Enumerate the IP addresses on an interface using the IP helper library</span>
<span class="line-removed"> 359  * routine GetIfAddrTable and matching based on the index name. There are</span>
<span class="line-removed"> 360  * more efficient routines but we use GetIfAddrTable because it&#39;s avaliable</span>
<span class="line-removed"> 361  * on 98 and NT.</span>
<span class="line-removed"> 362  *</span>
<span class="line-removed"> 363  * Returns the count of addresses, or -1 if error. If no error occurs then</span>
<span class="line-removed"> 364  * netaddrPP will return a list of netaddr structures with the IP addresses.</span>
 365  */
<span class="line-modified"> 366 int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP)</span>
 367 {
 368     MIB_IPADDRTABLE *tableP;
 369     ULONG size;
 370     DWORD ret;
<span class="line-removed"> 371     DWORD i;</span>
<span class="line-removed"> 372     netaddr *netaddrP;</span>
<span class="line-removed"> 373     int count = 0;</span>
<span class="line-removed"> 374     unsigned long mask;</span>
<span class="line-removed"> 375 </span>
 376     /*
 377      * Use GetIpAddrTable to enumerate the IP Addresses
 378      */
 379     size = sizeof(MIB_IPADDRTABLE);
 380     tableP = (MIB_IPADDRTABLE *)malloc(size);
 381     if (tableP == NULL) {
 382         JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failure&quot;);
 383         return -1;
 384     }
 385 
 386     ret = GetIpAddrTable(tableP, &amp;size, FALSE);
 387     if (ret == ERROR_INSUFFICIENT_BUFFER || ret == ERROR_BUFFER_OVERFLOW) {
 388         MIB_IPADDRTABLE * newTableP = (MIB_IPADDRTABLE *)realloc(tableP, size);
 389         if (newTableP == NULL) {
 390             free(tableP);
 391             JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failure&quot;);
 392             return -1;
 393         }
 394         tableP = newTableP;
 395 
 396         ret = GetIpAddrTable(tableP, &amp;size, FALSE);
 397     }
 398     if (ret != NO_ERROR) {
<span class="line-modified"> 399         if (tableP) {</span>
 400             free(tableP);
 401         }
 402         JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
 403                 &quot;IP Helper Library GetIpAddrTable function failed&quot;);
 404         // this different error code is to handle the case when we call
 405         // GetIpAddrTable in pure IPv6 environment
 406         return -2;
 407     }

















 408 
 409     /*
 410      * Iterate through the table to find the addresses with the
 411      * matching dwIndex. Ignore 0.0.0.0 addresses.
 412      */


 413     count = 0;
 414     netaddrP = NULL;
 415 
 416     i = 0;
<span class="line-modified"> 417     while (i&lt;tableP-&gt;dwNumEntries) {</span>
 418         if (tableP-&gt;table[i].dwIndex == netifP-&gt;dwIndex &amp;&amp;
 419             tableP-&gt;table[i].dwAddr != 0) {
 420 
 421             netaddr *curr = (netaddr *)malloc(sizeof(netaddr));
 422             if (curr == NULL) {
 423                 JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failure&quot;);
 424                 free_netaddr(netaddrP);
 425                 free(tableP);
 426                 return -1;
 427             }
 428 
 429             curr-&gt;addr.sa4.sin_family = AF_INET;
 430             curr-&gt;addr.sa4.sin_addr.s_addr = tableP-&gt;table[i].dwAddr;
 431             /*
 432              * Get netmask / broadcast address
 433              */
 434             switch (netifP-&gt;ifType) {
 435             case MIB_IF_TYPE_ETHERNET:
 436             case MIB_IF_TYPE_TOKENRING:
 437             case MIB_IF_TYPE_FDDI:
 438             case MIB_IF_TYPE_LOOPBACK:
 439             case IF_TYPE_IEEE80211:
<span class="line-modified"> 440               /**</span>
<span class="line-modified"> 441                * Contrary to what it seems to indicate, dwBCastAddr doesn&#39;t</span>
<span class="line-modified"> 442                * contain the broadcast address but 0 or 1 depending on whether</span>
<span class="line-modified"> 443                * the broadcast address should set the bits of the host part</span>
<span class="line-modified"> 444                * to 0 or 1.</span>
<span class="line-modified"> 445                * Yes, I know it&#39;s stupid, but what can I say, it&#39;s MSFTs API.</span>
<span class="line-modified"> 446                */</span>
<span class="line-modified"> 447               curr-&gt;brdcast.sa4.sin_family = AF_INET;</span>
<span class="line-modified"> 448               if (tableP-&gt;table[i].dwBCastAddr == 1)</span>
<span class="line-modified"> 449                 curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask) | (0xffffffff ^ tableP-&gt;table[i].dwMask);</span>
<span class="line-modified"> 450               else</span>
<span class="line-modified"> 451                 curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask);</span>
<span class="line-modified"> 452               mask = ntohl(tableP-&gt;table[i].dwMask);</span>
<span class="line-modified"> 453               curr-&gt;mask = 0;</span>
<span class="line-modified"> 454               while (mask) {</span>
<span class="line-modified"> 455                 mask &lt;&lt;= 1;</span>
<span class="line-modified"> 456                 curr-&gt;mask++;</span>
<span class="line-modified"> 457               }</span>
<span class="line-modified"> 458               break;</span>
 459             case MIB_IF_TYPE_PPP:
 460             case MIB_IF_TYPE_SLIP:
 461             default:
<span class="line-modified"> 462               /**</span>
<span class="line-modified"> 463                * these don&#39;t have broadcast/subnet</span>
<span class="line-modified"> 464                */</span>
<span class="line-modified"> 465               curr-&gt;mask = -1;</span>
<span class="line-modified"> 466                 break;</span>
 467             }
 468 
 469             curr-&gt;next = netaddrP;
 470             netaddrP = curr;
 471             count++;
 472         }
 473         i++;
 474     }
 475 
 476     *netaddrPP = netaddrP;



















 477     free(tableP);
 478     return count;
 479 }
 480 

 481 /*
 482  * Class:     java_net_NetworkInterface
 483  * Method:    init
 484  * Signature: ()V
 485  */
 486 JNIEXPORT void JNICALL
 487 Java_java_net_NetworkInterface_init(JNIEnv *env, jclass cls)
 488 {
 489     /*
 490      * Get the various JNI ids that we require
 491      */
 492     ni_class = (*env)-&gt;NewGlobalRef(env, cls);
 493     CHECK_NULL(ni_class);
 494     ni_nameID = (*env)-&gt;GetFieldID(env, ni_class, &quot;name&quot;, &quot;Ljava/lang/String;&quot;);
 495     CHECK_NULL(ni_nameID);
 496     ni_displayNameID = (*env)-&gt;GetFieldID(env, ni_class, &quot;displayName&quot;, &quot;Ljava/lang/String;&quot;);
 497     CHECK_NULL(ni_displayNameID);
 498     ni_indexID = (*env)-&gt;GetFieldID(env, ni_class, &quot;index&quot;, &quot;I&quot;);
 499     CHECK_NULL(ni_indexID);
 500     ni_addrsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;addrs&quot;, &quot;[Ljava/net/InetAddress;&quot;);
</pre>
<hr />
<pre>
 741     /* search by index */
 742     curr = ifList;
 743     while (curr != NULL) {
 744         if (index == curr-&gt;index) {
 745             break;
 746         }
 747         curr = curr-&gt;next;
 748     }
 749 
 750     /* if found create a NetworkInterface */
 751     if (curr != NULL) {
 752         netifObj = createNetworkInterface(env, curr, -1, NULL);
 753     }
 754 
 755     /* release the interface list */
 756     free_netif(ifList);
 757 
 758     return netifObj;
 759 }
 760 












































 761 /*
 762  * Class:     java_net_NetworkInterface
 763  * Method:    getByInetAddress0
 764  * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;
 765  */
 766 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0
 767     (JNIEnv *env, jclass cls, jobject iaObj)
 768 {
 769     netif *ifList, *curr;

 770     jobject netifObj = NULL;
 771     jint addr = getInetAddress_addr(env, iaObj);
 772     JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 773 
<span class="line-removed"> 774     // Retained for now to support IPv4 only stack, java.net.preferIPv4Stack</span>
 775     if (ipv6_available()) {
 776         return Java_java_net_NetworkInterface_getByInetAddress0_XP (env, cls, iaObj);
 777     }
 778 
 779     /* get the list of interfaces */
 780     if (enumInterfaces(env, &amp;ifList) &lt; 0) {
 781         return NULL;
 782     }
 783 
 784     /*
 785      * Enumerate the addresses on each interface until we find a
 786      * matching address.
 787      */
<span class="line-modified"> 788     curr = ifList;</span>
<span class="line-modified"> 789     while (curr != NULL) {</span>
<span class="line-modified"> 790         int count;</span>
<span class="line-modified"> 791         netaddr *addrList;</span>
<span class="line-modified"> 792         netaddr *addrP;</span>
<span class="line-modified"> 793 </span>
<span class="line-modified"> 794         /* enumerate the addresses on this interface */</span>
<span class="line-modified"> 795         count = enumAddresses_win(env, curr, &amp;addrList);</span>
<span class="line-modified"> 796         if (count &lt; 0) {</span>
<span class="line-modified"> 797             free_netif(ifList);</span>
<span class="line-modified"> 798             return NULL;</span>
<span class="line-modified"> 799         }</span>



 800 
<span class="line-modified"> 801         /* iterate through each address */</span>
<span class="line-modified"> 802         addrP = addrList;</span>
 803 
<span class="line-modified"> 804         while (addrP != NULL) {</span>
<span class="line-modified"> 805             if ((unsigned long)addr == ntohl(addrP-&gt;addr.sa4.sin_addr.s_addr)) {</span>












 806                 break;
 807             }
<span class="line-removed"> 808             addrP = addrP-&gt;next;</span>
<span class="line-removed"> 809         }</span>
 810 
<span class="line-modified"> 811         /*</span>
<span class="line-modified"> 812          * Address matched so create NetworkInterface for this interface</span>
<span class="line-removed"> 813          * and address list.</span>
<span class="line-removed"> 814          */</span>
<span class="line-removed"> 815         if (addrP != NULL) {</span>
<span class="line-removed"> 816             /* createNetworkInterface will free addrList */</span>
<span class="line-removed"> 817             netifObj = createNetworkInterface(env, curr, count, addrList);</span>
<span class="line-removed"> 818             break;</span>
 819         }
<span class="line-removed"> 820 </span>
<span class="line-removed"> 821         /* on next interface */</span>
<span class="line-removed"> 822         curr = curr-&gt;next;</span>
 823     }
 824 




 825     /* release the interface list */
 826     free_netif(ifList);
 827 
 828     return netifObj;
 829 }
 830 
 831 /*
 832  * Class:     java_net_NetworkInterface
 833  * Method:    getAll
 834  * Signature: ()[Ljava/net/NetworkInterface;
 835  */
 836 JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll
 837     (JNIEnv *env, jclass cls)
 838 {
 839     int count;
 840     netif *ifList = NULL, *curr;
 841     jobjectArray netIFArr;
 842     jint arr_index;
 843 
 844     // Retained for now to support IPv4 only stack, java.net.preferIPv4Stack
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &quot;net_util.h&quot;
  26 #include &quot;NetworkInterface.h&quot;
  27 
<span class="line-added">  28 #include &quot;java_net_InetAddress.h&quot;</span>
  29 #include &quot;java_net_NetworkInterface.h&quot;
  30 
  31 /*
  32  * Windows implementation of the java.net.NetworkInterface native methods.
  33  * This module provides the implementations of getAll, getByName, getByIndex,
  34  * and getByAddress.
  35  *
  36  * Interfaces and addresses are enumerated using the IP helper routines
  37  * GetIfTable, GetIfAddrTable resp. These routines are available on Windows
  38  * 98, NT SP+4, 2000, and XP. They are also available on Windows 95 if
  39  * IE is upgraded to 5.x.
  40  *
  41  * Windows does not have any standard for device names so we are forced
  42  * to use our own convention which is based on the normal Unix naming
  43  * convention (&quot;lo&quot; for the loopback, eth0, eth1, .. for ethernet devices,
  44  * tr0, tr1, .. for token ring, and so on). This convention gives us
  45  * consistency across multiple Windows editions and also consistency with
  46  * Solaris/Linux device names. Note that we always enumerate in index
  47  * order and this ensures consistent device number across invocations.
  48  */
</pre>
<hr />
<pre>
 331          * returning the interfaces in index order.
 332          */
 333         count++;
 334         if (netifP == NULL) {
 335             netifP = curr;
 336         } else {
 337             netif *tail = netifP;
 338             while (tail-&gt;next != NULL) {
 339                 tail = tail-&gt;next;
 340             }
 341             tail-&gt;next = curr;
 342         }
 343 
 344         /* onto the next interface */
 345         ifrowP++;
 346     }
 347 
 348     /*
 349      * Free the interface table and return the interface list
 350      */
<span class="line-modified"> 351     if (tableP != NULL) {</span>
 352         free(tableP);
 353     }
 354     *netifPP = netifP;
 355     return count;
 356 }
 357 
 358 /*
<span class="line-modified"> 359  * Enumerate all addresses using the IP helper library</span>






 360  */
<span class="line-modified"> 361 int lookupIPAddrTable(JNIEnv *env, MIB_IPADDRTABLE **tablePP)</span>
 362 {
 363     MIB_IPADDRTABLE *tableP;
 364     ULONG size;
 365     DWORD ret;





 366     /*
 367      * Use GetIpAddrTable to enumerate the IP Addresses
 368      */
 369     size = sizeof(MIB_IPADDRTABLE);
 370     tableP = (MIB_IPADDRTABLE *)malloc(size);
 371     if (tableP == NULL) {
 372         JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failure&quot;);
 373         return -1;
 374     }
 375 
 376     ret = GetIpAddrTable(tableP, &amp;size, FALSE);
 377     if (ret == ERROR_INSUFFICIENT_BUFFER || ret == ERROR_BUFFER_OVERFLOW) {
 378         MIB_IPADDRTABLE * newTableP = (MIB_IPADDRTABLE *)realloc(tableP, size);
 379         if (newTableP == NULL) {
 380             free(tableP);
 381             JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failure&quot;);
 382             return -1;
 383         }
 384         tableP = newTableP;
 385 
 386         ret = GetIpAddrTable(tableP, &amp;size, FALSE);
 387     }
 388     if (ret != NO_ERROR) {
<span class="line-modified"> 389         if (tableP != NULL) {</span>
 390             free(tableP);
 391         }
 392         JNU_ThrowByName(env, &quot;java/lang/Error&quot;,
 393                 &quot;IP Helper Library GetIpAddrTable function failed&quot;);
 394         // this different error code is to handle the case when we call
 395         // GetIpAddrTable in pure IPv6 environment
 396         return -2;
 397     }
<span class="line-added"> 398     *tablePP = tableP;</span>
<span class="line-added"> 399     return 0;</span>
<span class="line-added"> 400 }</span>
<span class="line-added"> 401 </span>
<span class="line-added"> 402 /*</span>
<span class="line-added"> 403  * Enumerate the IP addresses on an interface, given an IP address table</span>
<span class="line-added"> 404  * and matching based on index.</span>
<span class="line-added"> 405  *</span>
<span class="line-added"> 406  * Returns the count of addresses, or -1 if error. If no error occurs then</span>
<span class="line-added"> 407  * netaddrPP will return a list of netaddr structures with the IP addresses.</span>
<span class="line-added"> 408  */</span>
<span class="line-added"> 409 int enumAddresses_win_ipaddrtable(JNIEnv *env, netif *netifP, netaddr **netaddrPP, MIB_IPADDRTABLE *tableP)</span>
<span class="line-added"> 410 {</span>
<span class="line-added"> 411     DWORD i;</span>
<span class="line-added"> 412     netaddr *netaddrP;</span>
<span class="line-added"> 413     int count = 0;</span>
<span class="line-added"> 414     unsigned long mask;</span>
 415 
 416     /*
 417      * Iterate through the table to find the addresses with the
 418      * matching dwIndex. Ignore 0.0.0.0 addresses.
 419      */
<span class="line-added"> 420     if (tableP == NULL)</span>
<span class="line-added"> 421         return 0;</span>
 422     count = 0;
 423     netaddrP = NULL;
 424 
 425     i = 0;
<span class="line-modified"> 426     while (i &lt; tableP-&gt;dwNumEntries) {</span>
 427         if (tableP-&gt;table[i].dwIndex == netifP-&gt;dwIndex &amp;&amp;
 428             tableP-&gt;table[i].dwAddr != 0) {
 429 
 430             netaddr *curr = (netaddr *)malloc(sizeof(netaddr));
 431             if (curr == NULL) {
 432                 JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failure&quot;);
 433                 free_netaddr(netaddrP);
 434                 free(tableP);
 435                 return -1;
 436             }
 437 
 438             curr-&gt;addr.sa4.sin_family = AF_INET;
 439             curr-&gt;addr.sa4.sin_addr.s_addr = tableP-&gt;table[i].dwAddr;
 440             /*
 441              * Get netmask / broadcast address
 442              */
 443             switch (netifP-&gt;ifType) {
 444             case MIB_IF_TYPE_ETHERNET:
 445             case MIB_IF_TYPE_TOKENRING:
 446             case MIB_IF_TYPE_FDDI:
 447             case MIB_IF_TYPE_LOOPBACK:
 448             case IF_TYPE_IEEE80211:
<span class="line-modified"> 449                 /**</span>
<span class="line-modified"> 450                  * Contrary to what it seems to indicate, dwBCastAddr doesn&#39;t</span>
<span class="line-modified"> 451                  * contain the broadcast address but 0 or 1 depending on whether</span>
<span class="line-modified"> 452                  * the broadcast address should set the bits of the host part</span>
<span class="line-modified"> 453                  * to 0 or 1.</span>
<span class="line-modified"> 454                  * Yes, I know it&#39;s stupid, but what can I say, it&#39;s MSFTs API.</span>
<span class="line-modified"> 455                  */</span>
<span class="line-modified"> 456                 curr-&gt;brdcast.sa4.sin_family = AF_INET;</span>
<span class="line-modified"> 457                 if (tableP-&gt;table[i].dwBCastAddr == 1)</span>
<span class="line-modified"> 458                     curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask) | (0xffffffff ^ tableP-&gt;table[i].dwMask);</span>
<span class="line-modified"> 459                 else</span>
<span class="line-modified"> 460                     curr-&gt;brdcast.sa4.sin_addr.s_addr = (tableP-&gt;table[i].dwAddr &amp; tableP-&gt;table[i].dwMask);</span>
<span class="line-modified"> 461                 mask = ntohl(tableP-&gt;table[i].dwMask);</span>
<span class="line-modified"> 462                 curr-&gt;mask = 0;</span>
<span class="line-modified"> 463                 while (mask) {</span>
<span class="line-modified"> 464                     mask &lt;&lt;= 1;</span>
<span class="line-modified"> 465                     curr-&gt;mask++;</span>
<span class="line-modified"> 466                 }</span>
<span class="line-modified"> 467                 break;</span>
 468             case MIB_IF_TYPE_PPP:
 469             case MIB_IF_TYPE_SLIP:
 470             default:
<span class="line-modified"> 471                 /**</span>
<span class="line-modified"> 472                  * these don&#39;t have broadcast/subnet</span>
<span class="line-modified"> 473                  */</span>
<span class="line-modified"> 474                 curr-&gt;mask = -1;</span>
<span class="line-modified"> 475                     break;</span>
 476             }
 477 
 478             curr-&gt;next = netaddrP;
 479             netaddrP = curr;
 480             count++;
 481         }
 482         i++;
 483     }
 484 
 485     *netaddrPP = netaddrP;
<span class="line-added"> 486     return count;</span>
<span class="line-added"> 487 }</span>
<span class="line-added"> 488 </span>
<span class="line-added"> 489 </span>
<span class="line-added"> 490 /*</span>
<span class="line-added"> 491  * Enumerate the IP addresses on an interface, using an IP address table</span>
<span class="line-added"> 492  * retrieved using GetIPAddrTable and matching based on index.</span>
<span class="line-added"> 493  *</span>
<span class="line-added"> 494  * Returns the count of addresses, or -1 if error. If no error occurs then</span>
<span class="line-added"> 495  * netaddrPP will return a list of netaddr structures with the IP addresses.</span>
<span class="line-added"> 496  */</span>
<span class="line-added"> 497 int enumAddresses_win(JNIEnv *env, netif *netifP, netaddr **netaddrPP) {</span>
<span class="line-added"> 498     MIB_IPADDRTABLE *tableP;</span>
<span class="line-added"> 499     int count;</span>
<span class="line-added"> 500     int ret = lookupIPAddrTable(env, &amp;tableP);</span>
<span class="line-added"> 501     if (ret &lt; 0) {</span>
<span class="line-added"> 502       return NULL;</span>
<span class="line-added"> 503     }</span>
<span class="line-added"> 504     count = enumAddresses_win_ipaddrtable(env, netifP, netaddrPP, tableP);</span>
 505     free(tableP);
 506     return count;
 507 }
 508 
<span class="line-added"> 509 </span>
 510 /*
 511  * Class:     java_net_NetworkInterface
 512  * Method:    init
 513  * Signature: ()V
 514  */
 515 JNIEXPORT void JNICALL
 516 Java_java_net_NetworkInterface_init(JNIEnv *env, jclass cls)
 517 {
 518     /*
 519      * Get the various JNI ids that we require
 520      */
 521     ni_class = (*env)-&gt;NewGlobalRef(env, cls);
 522     CHECK_NULL(ni_class);
 523     ni_nameID = (*env)-&gt;GetFieldID(env, ni_class, &quot;name&quot;, &quot;Ljava/lang/String;&quot;);
 524     CHECK_NULL(ni_nameID);
 525     ni_displayNameID = (*env)-&gt;GetFieldID(env, ni_class, &quot;displayName&quot;, &quot;Ljava/lang/String;&quot;);
 526     CHECK_NULL(ni_displayNameID);
 527     ni_indexID = (*env)-&gt;GetFieldID(env, ni_class, &quot;index&quot;, &quot;I&quot;);
 528     CHECK_NULL(ni_indexID);
 529     ni_addrsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;addrs&quot;, &quot;[Ljava/net/InetAddress;&quot;);
</pre>
<hr />
<pre>
 770     /* search by index */
 771     curr = ifList;
 772     while (curr != NULL) {
 773         if (index == curr-&gt;index) {
 774             break;
 775         }
 776         curr = curr-&gt;next;
 777     }
 778 
 779     /* if found create a NetworkInterface */
 780     if (curr != NULL) {
 781         netifObj = createNetworkInterface(env, curr, -1, NULL);
 782     }
 783 
 784     /* release the interface list */
 785     free_netif(ifList);
 786 
 787     return netifObj;
 788 }
 789 
<span class="line-added"> 790 </span>
<span class="line-added"> 791 /*</span>
<span class="line-added"> 792  * Class:     java_net_NetworkInterface</span>
<span class="line-added"> 793  * Method:    boundInetAddress0</span>
<span class="line-added"> 794  * Signature: (Ljava/net/InetAddress;)Z</span>
<span class="line-added"> 795  */</span>
<span class="line-added"> 796 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0</span>
<span class="line-added"> 797     (JNIEnv *env, jclass cls, jobject iaObj)</span>
<span class="line-added"> 798 {</span>
<span class="line-added"> 799     jobject netifObj = NULL;</span>
<span class="line-added"> 800     DWORD i;</span>
<span class="line-added"> 801 </span>
<span class="line-added"> 802     int family = getInetAddress_family(env, iaObj);</span>
<span class="line-added"> 803     JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);</span>
<span class="line-added"> 804 </span>
<span class="line-added"> 805     if (family == java_net_InetAddress_IPv6) {</span>
<span class="line-added"> 806         if (!ipv6_available())</span>
<span class="line-added"> 807             return JNI_FALSE;</span>
<span class="line-added"> 808         return Java_java_net_NetworkInterface_getByInetAddress0_XP(env, cls, iaObj) != NULL;</span>
<span class="line-added"> 809     } else if (family == java_net_InetAddress_IPv4) {</span>
<span class="line-added"> 810         jint addr = getInetAddress_addr(env, iaObj);</span>
<span class="line-added"> 811         JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);</span>
<span class="line-added"> 812 </span>
<span class="line-added"> 813         jboolean found = JNI_FALSE;</span>
<span class="line-added"> 814         MIB_IPADDRTABLE *tableP;</span>
<span class="line-added"> 815         if (lookupIPAddrTable(env, &amp;tableP) &gt;= 0 &amp;&amp; tableP != NULL) {</span>
<span class="line-added"> 816             for (i = 0; i &lt; tableP-&gt;dwNumEntries; i++) {</span>
<span class="line-added"> 817                 if (tableP-&gt;table[i].dwAddr != 0 &amp;&amp;</span>
<span class="line-added"> 818                     (unsigned long)addr == ntohl(tableP-&gt;table[i].dwAddr)) {</span>
<span class="line-added"> 819                     found = JNI_TRUE;</span>
<span class="line-added"> 820                     break;</span>
<span class="line-added"> 821                 }</span>
<span class="line-added"> 822             }</span>
<span class="line-added"> 823         }</span>
<span class="line-added"> 824         if (tableP != NULL) {</span>
<span class="line-added"> 825           free(tableP);</span>
<span class="line-added"> 826         }</span>
<span class="line-added"> 827         return found;</span>
<span class="line-added"> 828     } else {</span>
<span class="line-added"> 829       // Unknown address family</span>
<span class="line-added"> 830       return JNI_FALSE;</span>
<span class="line-added"> 831     }</span>
<span class="line-added"> 832 }</span>
<span class="line-added"> 833 </span>
 834 /*
 835  * Class:     java_net_NetworkInterface
 836  * Method:    getByInetAddress0
 837  * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;
 838  */
 839 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0
 840     (JNIEnv *env, jclass cls, jobject iaObj)
 841 {
 842     netif *ifList, *curr;
<span class="line-added"> 843     MIB_IPADDRTABLE *tableP;</span>
 844     jobject netifObj = NULL;
 845     jint addr = getInetAddress_addr(env, iaObj);
 846     JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 847 

 848     if (ipv6_available()) {
 849         return Java_java_net_NetworkInterface_getByInetAddress0_XP (env, cls, iaObj);
 850     }
 851 
 852     /* get the list of interfaces */
 853     if (enumInterfaces(env, &amp;ifList) &lt; 0) {
 854         return NULL;
 855     }
 856 
 857     /*
 858      * Enumerate the addresses on each interface until we find a
 859      * matching address.
 860      */
<span class="line-modified"> 861     tableP = NULL;</span>
<span class="line-modified"> 862     if (lookupIPAddrTable(env, &amp;tableP) &gt;= 0) {</span>
<span class="line-modified"> 863         curr = ifList;</span>
<span class="line-modified"> 864         while (curr != NULL) {</span>
<span class="line-modified"> 865             int count;</span>
<span class="line-modified"> 866             netaddr *addrList;</span>
<span class="line-modified"> 867             netaddr *addrP;</span>
<span class="line-modified"> 868 </span>
<span class="line-modified"> 869             /* enumerate the addresses on this interface */</span>
<span class="line-modified"> 870             count = enumAddresses_win_ipaddrtable(env, curr, &amp;addrList, tableP);</span>
<span class="line-modified"> 871             if (count &lt; 0) {</span>
<span class="line-modified"> 872                 free_netif(ifList);</span>
<span class="line-added"> 873                 free(tableP);</span>
<span class="line-added"> 874                 return NULL;</span>
<span class="line-added"> 875             }</span>
 876 
<span class="line-modified"> 877             /* iterate through each address */</span>
<span class="line-modified"> 878             addrP = addrList;</span>
 879 
<span class="line-modified"> 880             while (addrP != NULL) {</span>
<span class="line-modified"> 881                 if ((unsigned long)addr == ntohl(addrP-&gt;addr.sa4.sin_addr.s_addr)) {</span>
<span class="line-added"> 882                     break;</span>
<span class="line-added"> 883                 }</span>
<span class="line-added"> 884                 addrP = addrP-&gt;next;</span>
<span class="line-added"> 885             }</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887             /*</span>
<span class="line-added"> 888              * Address matched so create NetworkInterface for this interface</span>
<span class="line-added"> 889              * and address list.</span>
<span class="line-added"> 890              */</span>
<span class="line-added"> 891             if (addrP != NULL) {</span>
<span class="line-added"> 892                 /* createNetworkInterface will free addrList */</span>
<span class="line-added"> 893                 netifObj = createNetworkInterface(env, curr, count, addrList);</span>
 894                 break;
 895             }


 896 
<span class="line-modified"> 897             /* on next interface */</span>
<span class="line-modified"> 898             curr = curr-&gt;next;</span>






 899         }



 900     }
 901 
<span class="line-added"> 902     /* release the IP address table */</span>
<span class="line-added"> 903     if (tableP != NULL)</span>
<span class="line-added"> 904         free(tableP);</span>
<span class="line-added"> 905 </span>
 906     /* release the interface list */
 907     free_netif(ifList);
 908 
 909     return netifObj;
 910 }
 911 
 912 /*
 913  * Class:     java_net_NetworkInterface
 914  * Method:    getAll
 915  * Signature: ()[Ljava/net/NetworkInterface;
 916  */
 917 JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll
 918     (JNIEnv *env, jclass cls)
 919 {
 920     int count;
 921     netif *ifList = NULL, *curr;
 922     jobjectArray netIFArr;
 923     jint arr_index;
 924 
 925     // Retained for now to support IPv4 only stack, java.net.preferIPv4Stack
</pre>
</td>
</tr>
</table>
<center><a href="NTLMAuthentication.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NetworkInterface_winXP.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/windows/native/libnet/net_util_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 #include &quot;net_util.h&quot;
 26 
 27 #include &quot;java_net_InetAddress.h&quot;
 28 #include &quot;java_net_SocketOptions.h&quot;
 29 
 30 // Taken from mstcpip.h in Windows SDK 8.0 or newer.
 31 #define SIO_LOOPBACK_FAST_PATH              _WSAIOW(IOC_VENDOR,16)
 32 
 33 #ifndef IPTOS_TOS_MASK
 34 #define IPTOS_TOS_MASK 0x1e
 35 #endif
 36 #ifndef IPTOS_PREC_MASK
 37 #define IPTOS_PREC_MASK 0xe0
 38 #endif
 39 
 40 /* true if SO_RCVTIMEO is supported */
 41 jboolean isRcvTimeoutSupported = JNI_TRUE;
 42 
 43 /*
 44  * Table of Windows Sockets errors, the specific exception we
 45  * throw for the error, and the error text.
 46  *
 47  * Note that this table excludes OS dependent errors.
 48  *
 49  * Latest list of Windows Sockets errors can be found at :-
 50  * http://msdn.microsoft.com/library/psdk/winsock/errors_3wc2.htm
 51  */
 52 static struct {
 53     int errCode;
 54     const char *exc;
 55     const char *errString;
 56 } const winsock_errors[] = {
 57     { WSAEACCES,                0,      &quot;Permission denied&quot; },
 58     { WSAEADDRINUSE,            &quot;BindException&quot;,        &quot;Address already in use&quot; },
 59     { WSAEADDRNOTAVAIL,         &quot;BindException&quot;,        &quot;Cannot assign requested address&quot; },
 60     { WSAEAFNOSUPPORT,          0,      &quot;Address family not supported by protocol family&quot; },
 61     { WSAEALREADY,              0,      &quot;Operation already in progress&quot; },
 62     { WSAECONNABORTED,          0,      &quot;Software caused connection abort&quot; },
 63     { WSAECONNREFUSED,          &quot;ConnectException&quot;,     &quot;Connection refused&quot; },
 64     { WSAECONNRESET,            0,      &quot;Connection reset by peer&quot; },
 65     { WSAEDESTADDRREQ,          0,      &quot;Destination address required&quot; },
 66     { WSAEFAULT,                0,      &quot;Bad address&quot; },
 67     { WSAEHOSTDOWN,             0,      &quot;Host is down&quot; },
 68     { WSAEHOSTUNREACH,          &quot;NoRouteToHostException&quot;,       &quot;No route to host&quot; },
 69     { WSAEINPROGRESS,           0,      &quot;Operation now in progress&quot; },
 70     { WSAEINTR,                 0,      &quot;Interrupted function call&quot; },
 71     { WSAEINVAL,                0,      &quot;Invalid argument&quot; },
 72     { WSAEISCONN,               0,      &quot;Socket is already connected&quot; },
 73     { WSAEMFILE,                0,      &quot;Too many open files&quot; },
 74     { WSAEMSGSIZE,              0,      &quot;The message is larger than the maximum supported by the underlying transport&quot; },
 75     { WSAENETDOWN,              0,      &quot;Network is down&quot; },
 76     { WSAENETRESET,             0,      &quot;Network dropped connection on reset&quot; },
 77     { WSAENETUNREACH,           0,      &quot;Network is unreachable&quot; },
 78     { WSAENOBUFS,               0,      &quot;No buffer space available (maximum connections reached?)&quot; },
 79     { WSAENOPROTOOPT,           0,      &quot;Bad protocol option&quot; },
 80     { WSAENOTCONN,              0,      &quot;Socket is not connected&quot; },
 81     { WSAENOTSOCK,              0,      &quot;Socket operation on nonsocket&quot; },
 82     { WSAEOPNOTSUPP,            0,      &quot;Operation not supported&quot; },
 83     { WSAEPFNOSUPPORT,          0,      &quot;Protocol family not supported&quot; },
 84     { WSAEPROCLIM,              0,      &quot;Too many processes&quot; },
 85     { WSAEPROTONOSUPPORT,       0,      &quot;Protocol not supported&quot; },
 86     { WSAEPROTOTYPE,            0,      &quot;Protocol wrong type for socket&quot; },
 87     { WSAESHUTDOWN,             0,      &quot;Cannot send after socket shutdown&quot; },
 88     { WSAESOCKTNOSUPPORT,       0,      &quot;Socket type not supported&quot; },
 89     { WSAETIMEDOUT,             &quot;ConnectException&quot;,     &quot;Connection timed out&quot; },
 90     { WSATYPE_NOT_FOUND,        0,      &quot;Class type not found&quot; },
 91     { WSAEWOULDBLOCK,           0,      &quot;Resource temporarily unavailable&quot; },
 92     { WSAHOST_NOT_FOUND,        0,      &quot;Host not found&quot; },
 93     { WSA_NOT_ENOUGH_MEMORY,    0,      &quot;Insufficient memory available&quot; },
 94     { WSANOTINITIALISED,        0,      &quot;Successful WSAStartup not yet performed&quot; },
 95     { WSANO_DATA,               0,      &quot;Valid name, no data record of requested type&quot; },
 96     { WSANO_RECOVERY,           0,      &quot;This is a nonrecoverable error&quot; },
 97     { WSASYSNOTREADY,           0,      &quot;Network subsystem is unavailable&quot; },
 98     { WSATRY_AGAIN,             0,      &quot;Nonauthoritative host not found&quot; },
 99     { WSAVERNOTSUPPORTED,       0,      &quot;Winsock.dll version out of range&quot; },
100     { WSAEDISCON,               0,      &quot;Graceful shutdown in progress&quot; },
101     { WSA_OPERATION_ABORTED,    0,      &quot;Overlapped operation aborted&quot; },
102 };
103 
104 /*
105  * Initialize Windows Sockets API support
106  */
107 BOOL WINAPI
108 DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved)
109 {
110     WSADATA wsadata;
111 
112     switch (reason) {
113         case DLL_PROCESS_ATTACH:
114             if (WSAStartup(MAKEWORD(2,2), &amp;wsadata) != 0) {
115                 return FALSE;
116             }
117             break;
118 
119         case DLL_PROCESS_DETACH:
120             WSACleanup();
121             break;
122 
123         default:
124             break;
125     }
126     return TRUE;
127 }
128 
129 void platformInit() {}
130 void parseExclusiveBindProperty(JNIEnv *env) {}
131 
132 /*
133  * Since winsock doesn&#39;t have the equivalent of strerror(errno)
134  * use table to lookup error text for the error.
135  */
136 JNIEXPORT void JNICALL
137 NET_ThrowNew(JNIEnv *env, int errorNum, char *msg)
138 {
139     int i;
140     int table_size = sizeof(winsock_errors) /
141                      sizeof(winsock_errors[0]);
142     char exc[256];
143     char fullMsg[256];
144     char *excP = NULL;
145 
146     /*
147      * If exception already throw then don&#39;t overwrite it.
148      */
149     if ((*env)-&gt;ExceptionOccurred(env)) {
150         return;
151     }
152 
153     /*
154      * Default message text if not provided
155      */
156     if (!msg) {
157         msg = &quot;no further information&quot;;
158     }
159 
160     /*
161      * Check table for known winsock errors
162      */
163     i=0;
164     while (i &lt; table_size) {
165         if (errorNum == winsock_errors[i].errCode) {
166             break;
167         }
168         i++;
169     }
170 
171     /*
172      * If found get pick the specific exception and error
173      * message corresponding to this error.
174      */
175     if (i &lt; table_size) {
176         excP = (char *)winsock_errors[i].exc;
177         jio_snprintf(fullMsg, sizeof(fullMsg), &quot;%s: %s&quot;,
178                      (char *)winsock_errors[i].errString, msg);
179     } else {
180         jio_snprintf(fullMsg, sizeof(fullMsg),
181                      &quot;Unrecognized Windows Sockets error: %d: %s&quot;,
182                      errorNum, msg);
183 
184     }
185 
186     /*
187      * Throw SocketException if no specific exception for this
188      * error.
189      */
190     if (excP == NULL) {
191         excP = &quot;SocketException&quot;;
192     }
193     sprintf(exc, &quot;%s%s&quot;, JNU_JAVANETPKG, excP);
194     JNU_ThrowByName(env, exc, fullMsg);
195 }
196 
197 void
198 NET_ThrowCurrent(JNIEnv *env, char *msg)
199 {
200     NET_ThrowNew(env, WSAGetLastError(), msg);
201 }
202 
203 void
204 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
205                    const char *defaultDetail) {
206     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
207 }
208 
209 jfieldID
210 NET_GetFileDescriptorID(JNIEnv *env)
211 {
212     jclass cls = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;);
213     CHECK_NULL_RETURN(cls, NULL);
214     return (*env)-&gt;GetFieldID(env, cls, &quot;fd&quot;, &quot;I&quot;);
215 }
216 
217 jint  IPv6_supported()
218 {
219     SOCKET s = socket(AF_INET6, SOCK_STREAM, 0) ;
220     if (s == INVALID_SOCKET) {
221         return JNI_FALSE;
222     }
223     closesocket(s);
224 
225     return JNI_TRUE;
226 }
227 
228 jint reuseport_supported()
229 {
230     /* SO_REUSEPORT is not supported on Windows */
231     return JNI_FALSE;
232 }
233 
234 /* call NET_MapSocketOptionV6 for the IPv6 fd only
235  * and NET_MapSocketOption for the IPv4 fd
236  */
237 JNIEXPORT int JNICALL
238 NET_MapSocketOptionV6(jint cmd, int *level, int *optname) {
239 
240     switch (cmd) {
241         case java_net_SocketOptions_IP_MULTICAST_IF:
242         case java_net_SocketOptions_IP_MULTICAST_IF2:
243             *level = IPPROTO_IPV6;
244             *optname = IPV6_MULTICAST_IF;
245             return 0;
246 
247         case java_net_SocketOptions_IP_MULTICAST_LOOP:
248             *level = IPPROTO_IPV6;
249             *optname = IPV6_MULTICAST_LOOP;
250             return 0;
251     }
252     return NET_MapSocketOption (cmd, level, optname);
253 }
254 
255 /*
256  * Map the Java level socket option to the platform specific
257  * level and option name.
258  */
259 
260 JNIEXPORT int JNICALL
261 NET_MapSocketOption(jint cmd, int *level, int *optname) {
262 
263     typedef struct {
264         jint cmd;
265         int level;
266         int optname;
267     } sockopts;
268 
269     static sockopts opts[] = {
270         { java_net_SocketOptions_TCP_NODELAY,   IPPROTO_TCP,    TCP_NODELAY },
271         { java_net_SocketOptions_SO_OOBINLINE,  SOL_SOCKET,     SO_OOBINLINE },
272         { java_net_SocketOptions_SO_LINGER,     SOL_SOCKET,     SO_LINGER },
273         { java_net_SocketOptions_SO_SNDBUF,     SOL_SOCKET,     SO_SNDBUF },
274         { java_net_SocketOptions_SO_RCVBUF,     SOL_SOCKET,     SO_RCVBUF },
275         { java_net_SocketOptions_SO_KEEPALIVE,  SOL_SOCKET,     SO_KEEPALIVE },
276         { java_net_SocketOptions_SO_REUSEADDR,  SOL_SOCKET,     SO_REUSEADDR },
277         { java_net_SocketOptions_SO_BROADCAST,  SOL_SOCKET,     SO_BROADCAST },
278         { java_net_SocketOptions_IP_MULTICAST_IF,   IPPROTO_IP, IP_MULTICAST_IF },
279         { java_net_SocketOptions_IP_MULTICAST_LOOP, IPPROTO_IP, IP_MULTICAST_LOOP },
280         { java_net_SocketOptions_IP_TOS,            IPPROTO_IP, IP_TOS },
281 
282     };
283 
284 
285     int i;
286 
287     /*
288      * Map the Java level option to the native level
289      */
290     for (i=0; i&lt;(int)(sizeof(opts) / sizeof(opts[0])); i++) {
291         if (cmd == opts[i].cmd) {
292             *level = opts[i].level;
293             *optname = opts[i].optname;
294             return 0;
295         }
296     }
297 
298     /* not found */
299     return -1;
300 }
301 
302 
303 /*
304  * Wrapper for setsockopt dealing with Windows specific issues :-
305  *
306  * IP_TOS and IP_MULTICAST_LOOP can&#39;t be set on some Windows
307  * editions.
308  *
309  * The value for the type-of-service (TOS) needs to be masked
310  * to get consistent behaviour with other operating systems.
311  */
312 JNIEXPORT int JNICALL
313 NET_SetSockOpt(int s, int level, int optname, const void *optval,
314                int optlen)
315 {
316     int rv = 0;
317     int parg = 0;
318     int plen = sizeof(parg);
319 
320     if (level == IPPROTO_IP &amp;&amp; optname == IP_TOS) {
321         int *tos = (int *)optval;
322         *tos &amp;= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
323     }
324 
325     if (optname == SO_REUSEADDR) {
326         /*
327          * Do not set SO_REUSEADDE if SO_EXCLUSIVEADDUSE is already set
328          */
329         rv = NET_GetSockOpt(s, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *)&amp;parg, &amp;plen);
330         if (rv == 0 &amp;&amp; parg == 1) {
331             return rv;
332         }
333     }
334 
335     rv = setsockopt(s, level, optname, optval, optlen);
336 
337     if (rv == SOCKET_ERROR) {
338         /*
339          * IP_TOS &amp; IP_MULTICAST_LOOP can&#39;t be set on some versions
340          * of Windows.
341          */
342         if ((WSAGetLastError() == WSAENOPROTOOPT) &amp;&amp;
343             (level == IPPROTO_IP) &amp;&amp;
344             (optname == IP_TOS || optname == IP_MULTICAST_LOOP)) {
345             rv = 0;
346         }
347 
348         /*
349          * IP_TOS can&#39;t be set on unbound UDP sockets.
350          */
351         if ((WSAGetLastError() == WSAEINVAL) &amp;&amp;
352             (level == IPPROTO_IP) &amp;&amp;
353             (optname == IP_TOS)) {
354             rv = 0;
355         }
356     }
357 
358     return rv;
359 }
360 
361 /*
362  * Wrapper for setsockopt dealing with Windows specific issues :-
363  *
364  * IP_TOS is not supported on some versions of Windows so
365  * instead return the default value for the OS.
366  */
367 JNIEXPORT int JNICALL
368 NET_GetSockOpt(int s, int level, int optname, void *optval,
369                int *optlen)
370 {
371     int rv;
372 
373     if (level == IPPROTO_IPV6 &amp;&amp; optname == IPV6_TCLASS) {
374         int *intopt = (int *)optval;
375         *intopt = 0;
376         *optlen = sizeof(*intopt);
377         return 0;
378     }
379 
380     rv = getsockopt(s, level, optname, optval, optlen);
381 
382 
383     /*
384      * IPPROTO_IP/IP_TOS is not supported on some Windows
385      * editions so return the default type-of-service
386      * value.
387      */
388     if (rv == SOCKET_ERROR) {
389 
390         if (WSAGetLastError() == WSAENOPROTOOPT &amp;&amp;
391             level == IPPROTO_IP &amp;&amp; optname == IP_TOS) {
392 
393             *((int *)optval) = 0;
394             rv = 0;
395         }
396     }
397 
398     return rv;
399 }
400 
401 JNIEXPORT int JNICALL
402 NET_SocketAvailable(int s, int *pbytes) {
403     u_long arg;
404     if (ioctlsocket((SOCKET)s, FIONREAD, &amp;arg) == SOCKET_ERROR) {
405         return -1;
406     } else {
407         *pbytes = (int) arg;
408         return 0;
409     }
410 }
411 
412 /*
413  * Sets SO_ECLUSIVEADDRUSE if SO_REUSEADDR is not already set.
414  */
415 void setExclusiveBind(int fd) {
416     int parg = 0;
417     int plen = sizeof(parg);
418     int rv = 0;
419     rv = NET_GetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;parg, &amp;plen);
420     if (rv == 0 &amp;&amp; parg == 0) {
421         parg = 1;
422         rv = NET_SetSockOpt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char*)&amp;parg, plen);
423     }
424 }
425 
426 /*
427  * Wrapper for bind winsock call - transparent converts an
428  * error related to binding to a port that has exclusive access
429  * into an error indicating the port is in use (facilitates
430  * better error reporting).
431  *
432  * Should be only called by the wrapper method NET_WinBind
433  */
434 JNIEXPORT int JNICALL
435 NET_Bind(int s, SOCKETADDRESS *sa, int len)
436 {
437     int rv = 0;
438     rv = bind(s, &amp;sa-&gt;sa, len);
439 
440     if (rv == SOCKET_ERROR) {
441         /*
442          * If bind fails with WSAEACCES it means that a privileged
443          * process has done an exclusive bind (NT SP4/2000/XP only).
444          */
445         if (WSAGetLastError() == WSAEACCES) {
446             WSASetLastError(WSAEADDRINUSE);
447         }
448     }
449 
450     return rv;
451 }
452 
453 /*
454  * Wrapper for NET_Bind call. Sets SO_EXCLUSIVEADDRUSE
455  * if required, and then calls NET_BIND
456  */
457 JNIEXPORT int JNICALL
458 NET_WinBind(int s, SOCKETADDRESS *sa, int len, jboolean exclBind)
459 {
460     if (exclBind == JNI_TRUE)
461         setExclusiveBind(s);
462     return NET_Bind(s, sa, len);
463 }
464 
465 JNIEXPORT int JNICALL
466 NET_SocketClose(int fd) {
467     struct linger l = {0, 0};
468     int ret = 0;
469     int len = sizeof (l);
470     if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&amp;l, &amp;len) == 0) {
471         if (l.l_onoff == 0) {
472             shutdown(fd, SD_SEND);
473         }
474     }
475     ret = closesocket (fd);
476     return ret;
477 }
478 
479 JNIEXPORT int JNICALL
480 NET_Timeout(int fd, long timeout) {
481     int ret;
482     fd_set tbl;
483     struct timeval t;
484     t.tv_sec = timeout / 1000;
485     t.tv_usec = (timeout % 1000) * 1000;
486     FD_ZERO(&amp;tbl);
487     FD_SET(fd, &amp;tbl);
488     ret = select (fd + 1, &amp;tbl, 0, 0, &amp;t);
489     return ret;
490 }
491 
492 
493 /*
494  * differs from NET_Timeout() as follows:
495  *
496  * If timeout = -1, it blocks forever.
497  *
498  * returns 1 or 2 depending if only one or both sockets
499  * fire at same time.
500  *
501  * *fdret is (one of) the active fds. If both sockets
502  * fire at same time, *fdret = fd always.
503  */
504 JNIEXPORT int JNICALL
505 NET_Timeout2(int fd, int fd1, long timeout, int *fdret) {
506     int ret;
507     fd_set tbl;
508     struct timeval t, *tP = &amp;t;
509     if (timeout == -1) {
510         tP = 0;
511     } else {
512         t.tv_sec = timeout / 1000;
513         t.tv_usec = (timeout % 1000) * 1000;
514     }
515     FD_ZERO(&amp;tbl);
516     FD_SET(fd, &amp;tbl);
517     FD_SET(fd1, &amp;tbl);
518     ret = select (0, &amp;tbl, 0, 0, tP);
519     switch (ret) {
520     case 0:
521         return 0; /* timeout */
522     case 1:
523         if (FD_ISSET (fd, &amp;tbl)) {
524             *fdret= fd;
525         } else {
526             *fdret= fd1;
527         }
528         return 1;
529     case 2:
530         *fdret= fd;
531         return 2;
532     }
533     return -1;
534 }
535 
536 
537 void dumpAddr (char *str, void *addr) {
538     struct sockaddr_in6 *a = (struct sockaddr_in6 *)addr;
539     int family = a-&gt;sin6_family;
540     printf (&quot;%s\n&quot;, str);
541     if (family == AF_INET) {
542         struct sockaddr_in *him = (struct sockaddr_in *)addr;
543         printf (&quot;AF_INET: port %d: %x\n&quot;, ntohs(him-&gt;sin_port),
544                                           ntohl(him-&gt;sin_addr.s_addr));
545     } else {
546         int i;
547         struct in6_addr *in = &amp;a-&gt;sin6_addr;
548         printf (&quot;AF_INET6 &quot;);
549         printf (&quot;port %d &quot;, ntohs (a-&gt;sin6_port));
550         printf (&quot;flow %d &quot;, a-&gt;sin6_flowinfo);
551         printf (&quot;addr &quot;);
552         for (i=0; i&lt;7; i++) {
553             printf (&quot;%04x:&quot;, ntohs(in-&gt;s6_words[i]));
554         }
555         printf (&quot;%04x&quot;, ntohs(in-&gt;s6_words[7]));
556         printf (&quot; scope %d\n&quot;, a-&gt;sin6_scope_id);
557     }
558 }
559 
560 /* Macro, which cleans-up the iv6bind structure,
561  * closes the two sockets (if open),
562  * and returns SOCKET_ERROR. Used in NET_BindV6 only.
563  */
564 
565 #define CLOSE_SOCKETS_AND_RETURN do {   \
566     if (fd != -1) {                     \
567         closesocket (fd);               \
568         fd = -1;                        \
569     }                                   \
570     if (ofd != -1) {                    \
571         closesocket (ofd);              \
572         ofd = -1;                       \
573     }                                   \
574     if (close_fd != -1) {               \
575         closesocket (close_fd);         \
576         close_fd = -1;                  \
577     }                                   \
578     if (close_ofd != -1) {              \
579         closesocket (close_ofd);        \
580         close_ofd = -1;                 \
581     }                                   \
582     b-&gt;ipv4_fd = b-&gt;ipv6_fd = -1;       \
583     return SOCKET_ERROR;                \
584 } while(0)
585 
586 /*
587  * if ipv6 is available, call NET_BindV6 to bind to the required address/port.
588  * Because the same port number may need to be reserved in both v4 and v6 space,
589  * this may require socket(s) to be re-opened. Therefore, all of this information
590  * is passed in and returned through the ipv6bind structure.
591  *
592  * If the request is to bind to a specific address, then this (by definition) means
593  * only bind in either v4 or v6, and this is just the same as normal. ie. a single
594  * call to bind() will suffice. The other socket is closed in this case.
595  *
596  * The more complicated case is when the requested address is ::0 or 0.0.0.0.
597  *
598  * Two further cases:
599  * 2. If the requested port is 0 (ie. any port) then we try to bind in v4 space
600  *    first with a wild-card port argument. We then try to bind in v6 space
601  *    using the returned port number. If this fails, we repeat the process
602  *    until a free port common to both spaces becomes available.
603  *
604  * 3. If the requested port is a specific port, then we just try to get that
605  *    port in both spaces, and if it is not free in both, then the bind fails.
606  *
607  * On failure, sockets are closed and an error returned with CLOSE_SOCKETS_AND_RETURN
608  */
609 
610 JNIEXPORT int JNICALL
611 NET_BindV6(struct ipv6bind *b, jboolean exclBind) {
612     int fd=-1, ofd=-1, rv, len;
613     /* need to defer close until new sockets created */
614     int close_fd=-1, close_ofd=-1;
615     SOCKETADDRESS oaddr; /* other address to bind */
616     int family = b-&gt;addr-&gt;sa.sa_family;
617     int ofamily;
618     u_short port; /* requested port parameter */
619     u_short bound_port;
620 
621     if (family == AF_INET &amp;&amp; (b-&gt;addr-&gt;sa4.sin_addr.s_addr != INADDR_ANY)) {
622         /* bind to v4 only */
623         int ret;
624         ret = NET_WinBind((int)b-&gt;ipv4_fd, b-&gt;addr,
625                           sizeof(SOCKETADDRESS), exclBind);
626         if (ret == SOCKET_ERROR) {
627             CLOSE_SOCKETS_AND_RETURN;
628         }
629         closesocket (b-&gt;ipv6_fd);
630         b-&gt;ipv6_fd = -1;
631         return 0;
632     }
633     if (family == AF_INET6 &amp;&amp; (!IN6_IS_ADDR_ANY(&amp;b-&gt;addr-&gt;sa6.sin6_addr))) {
634         /* bind to v6 only */
635         int ret;
636         ret = NET_WinBind((int)b-&gt;ipv6_fd, b-&gt;addr,
637                           sizeof(SOCKETADDRESS), exclBind);
638         if (ret == SOCKET_ERROR) {
639             CLOSE_SOCKETS_AND_RETURN;
640         }
641         closesocket (b-&gt;ipv4_fd);
642         b-&gt;ipv4_fd = -1;
643         return 0;
644     }
645 
646     /* We need to bind on both stacks, with the same port number */
647 
648     memset (&amp;oaddr, 0, sizeof(oaddr));
649     if (family == AF_INET) {
650         ofamily = AF_INET6;
651         fd = (int)b-&gt;ipv4_fd;
652         ofd = (int)b-&gt;ipv6_fd;
653         port = (u_short)GET_PORT (b-&gt;addr);
654         IN6ADDR_SETANY(&amp;oaddr.sa6);
655         oaddr.sa6.sin6_port = port;
656     } else {
657         ofamily = AF_INET;
658         ofd = (int)b-&gt;ipv4_fd;
659         fd = (int)b-&gt;ipv6_fd;
660         port = (u_short)GET_PORT (b-&gt;addr);
661         oaddr.sa4.sin_family = AF_INET;
662         oaddr.sa4.sin_port = port;
663         oaddr.sa4.sin_addr.s_addr = INADDR_ANY;
664     }
665 
666     rv = NET_WinBind(fd, b-&gt;addr, sizeof(SOCKETADDRESS), exclBind);
667     if (rv == SOCKET_ERROR) {
668         CLOSE_SOCKETS_AND_RETURN;
669     }
670 
671     /* get the port and set it in the other address */
672     len = sizeof(SOCKETADDRESS);
673     if (getsockname(fd, (struct sockaddr *)b-&gt;addr, &amp;len) == -1) {
674         CLOSE_SOCKETS_AND_RETURN;
675     }
676     bound_port = GET_PORT (b-&gt;addr);
677     SET_PORT (&amp;oaddr, bound_port);
678     if ((rv = NET_WinBind(ofd, &amp;oaddr,
679                           sizeof(SOCKETADDRESS), exclBind)) == SOCKET_ERROR) {
680         int retries;
681         int sotype, arglen=sizeof(sotype);
682 
683         /* no retries unless, the request was for any free port */
684 
685         if (port != 0) {
686             CLOSE_SOCKETS_AND_RETURN;
687         }
688 
689         getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype, &amp;arglen);
690 
691 #define SOCK_RETRIES 50
692         /* 50 is an arbitrary limit, just to ensure that this
693          * cannot be an endless loop. Would expect socket creation to
694          * succeed sooner.
695          */
696         for (retries = 0; retries &lt; SOCK_RETRIES; retries ++) {
697             int len;
698             close_fd = fd; fd = -1;
699             close_ofd = ofd; ofd = -1;
700             b-&gt;ipv4_fd = SOCKET_ERROR;
701             b-&gt;ipv6_fd = SOCKET_ERROR;
702 
703             /* create two new sockets */
704             fd = (int)socket (family, sotype, 0);
705             if (fd == SOCKET_ERROR) {
706                 CLOSE_SOCKETS_AND_RETURN;
707             }
708             ofd = (int)socket (ofamily, sotype, 0);
709             if (ofd == SOCKET_ERROR) {
710                 CLOSE_SOCKETS_AND_RETURN;
711             }
712 
713             /* bind random port on first socket */
714             SET_PORT (&amp;oaddr, 0);
715             rv = NET_WinBind(ofd, &amp;oaddr, sizeof(SOCKETADDRESS), exclBind);
716             if (rv == SOCKET_ERROR) {
717                 CLOSE_SOCKETS_AND_RETURN;
718             }
719             /* close the original pair of sockets before continuing */
720             closesocket (close_fd);
721             closesocket (close_ofd);
722             close_fd = close_ofd = -1;
723 
724             /* bind new port on second socket */
725             len = sizeof(SOCKETADDRESS);
726             if (getsockname(ofd, &amp;oaddr.sa, &amp;len) == -1) {
727                 CLOSE_SOCKETS_AND_RETURN;
728             }
729             bound_port = GET_PORT (&amp;oaddr);
730             SET_PORT (b-&gt;addr, bound_port);
731             rv = NET_WinBind(fd, b-&gt;addr, sizeof(SOCKETADDRESS), exclBind);
732 
733             if (rv != SOCKET_ERROR) {
734                 if (family == AF_INET) {
735                     b-&gt;ipv4_fd = fd;
736                     b-&gt;ipv6_fd = ofd;
737                 } else {
738                     b-&gt;ipv4_fd = ofd;
739                     b-&gt;ipv6_fd = fd;
740                 }
741                 return 0;
742             }
743         }
744         CLOSE_SOCKETS_AND_RETURN;
745     }
746     return 0;
747 }
748 
749 /*
750  * Determine the default interface for an IPv6 address.
751  *
752  * Returns :-
753  *      0 if error
754  *      &gt; 0 interface index to use
755  */
756 jint getDefaultIPv6Interface(JNIEnv *env, struct sockaddr_in6 *target_addr)
757 {
758     int ret;
759     DWORD b;
760     struct sockaddr_in6 route;
761     SOCKET fd = socket(AF_INET6, SOCK_STREAM, 0);
762     if (fd == INVALID_SOCKET) {
763         return 0;
764     }
765 
766     ret = WSAIoctl(fd, SIO_ROUTING_INTERFACE_QUERY,
767                    (void *)target_addr, sizeof(struct sockaddr_in6),
768                    (void *)&amp;route, sizeof(struct sockaddr_in6),
769                    &amp;b, 0, 0);
770     if (ret == SOCKET_ERROR) {
771         // error
772         closesocket(fd);
773         return 0;
774     } else {
775         closesocket(fd);
776         return route.sin6_scope_id;
777     }
778 }
779 
780 /**
781  * Enables SIO_LOOPBACK_FAST_PATH
782  */
783 JNIEXPORT jint JNICALL
784 NET_EnableFastTcpLoopback(int fd) {
785     int enabled = 1;
786     DWORD result_byte_count = -1;
787     int result = WSAIoctl(fd,
788                           SIO_LOOPBACK_FAST_PATH,
789                           &amp;enabled,
790                           sizeof(enabled),
791                           NULL,
792                           0,
793                           &amp;result_byte_count,
794                           NULL,
795                           NULL);
796     return result == SOCKET_ERROR ? WSAGetLastError() : 0;
797 }
798 
799 /**
800  * See net_util.h for documentation
801  */
802 JNIEXPORT int JNICALL
803 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port,
804                           SOCKETADDRESS *sa, int *len,
805                           jboolean v4MappedAddress)
806 {
807     jint family = getInetAddress_family(env, iaObj);
808     JNU_CHECK_EXCEPTION_RETURN(env, -1);
809     memset((char *)sa, 0, sizeof(SOCKETADDRESS));
810 
811     if (ipv6_available() &amp;&amp;
812         !(family == java_net_InetAddress_IPv4 &amp;&amp;
813           v4MappedAddress == JNI_FALSE))
814     {
815         jbyte caddr[16];
816         jint address;
817         unsigned int scopeid = 0, cached_scope_id = 0;
818 
819         if (family == java_net_InetAddress_IPv4) {
820             // convert to IPv4-mapped address
821             memset((char *)caddr, 0, 16);
822             address = getInetAddress_addr(env, iaObj);
823             JNU_CHECK_EXCEPTION_RETURN(env, -1);
824             if (address == INADDR_ANY) {
825                 /* we would always prefer IPv6 wildcard address
826                  * caddr[10] = 0xff;
827                  * caddr[11] = 0xff; */
828             } else {
829                 caddr[10] = 0xff;
830                 caddr[11] = 0xff;
831                 caddr[12] = ((address &gt;&gt; 24) &amp; 0xff);
832                 caddr[13] = ((address &gt;&gt; 16) &amp; 0xff);
833                 caddr[14] = ((address &gt;&gt; 8) &amp; 0xff);
834                 caddr[15] = (address &amp; 0xff);
835             }
836         } else {
837             getInet6Address_ipaddress(env, iaObj, (char *)caddr);
838             scopeid = getInet6Address_scopeid(env, iaObj);
839             cached_scope_id = (unsigned int)(*env)-&gt;GetIntField(env, iaObj, ia6_cachedscopeidID);
840         }
841         sa-&gt;sa6.sin6_port = (u_short)htons((u_short)port);
842         memcpy((void *)&amp;sa-&gt;sa6.sin6_addr, caddr, sizeof(struct in6_addr));
843         sa-&gt;sa6.sin6_family = AF_INET6;
844         if ((family == java_net_InetAddress_IPv6) &amp;&amp;
845             IN6_IS_ADDR_LINKLOCAL(&amp;sa-&gt;sa6.sin6_addr) &amp;&amp;
846             (!scopeid &amp;&amp; !cached_scope_id))
847         {
848             cached_scope_id = getDefaultIPv6Interface(env, &amp;sa-&gt;sa6);
849             (*env)-&gt;SetIntField(env, iaObj, ia6_cachedscopeidID, cached_scope_id);
850         }
851         sa-&gt;sa6.sin6_scope_id = scopeid == 0 ? cached_scope_id : scopeid;
852         if (len != NULL) {
853             *len = sizeof(struct sockaddr_in6);
854         }
855     } else {
856         jint address;
857         if (family != java_net_InetAddress_IPv4) {
858             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Protocol family unavailable&quot;);
859             return -1;
860         }
861         address = getInetAddress_addr(env, iaObj);
862         JNU_CHECK_EXCEPTION_RETURN(env, -1);
863         sa-&gt;sa4.sin_port = htons((short)port);
864         sa-&gt;sa4.sin_addr.s_addr = (u_long)htonl(address);
865         sa-&gt;sa4.sin_family = AF_INET;
866         if (len != NULL) {
867             *len = sizeof(struct sockaddr_in);
868         }
869     }
870     return 0;
871 }
872 
873 int
874 NET_IsIPv4Mapped(jbyte* caddr) {
875     int i;
876     for (i = 0; i &lt; 10; i++) {
877         if (caddr[i] != 0x00) {
878             return 0; /* false */
879         }
880     }
881 
882     if (((caddr[10] &amp; 0xff) == 0xff) &amp;&amp; ((caddr[11] &amp; 0xff) == 0xff)) {
883         return 1; /* true */
884     }
885     return 0; /* false */
886 }
887 
888 int
889 NET_IPv4MappedToIPv4(jbyte* caddr) {
890     return ((caddr[12] &amp; 0xff) &lt;&lt; 24) | ((caddr[13] &amp; 0xff) &lt;&lt; 16) | ((caddr[14] &amp; 0xff) &lt;&lt; 8)
891         | (caddr[15] &amp; 0xff);
892 }
893 
894 int
895 NET_IsEqual(jbyte* caddr1, jbyte* caddr2) {
896     int i;
897     for (i = 0; i &lt; 16; i++) {
898         if (caddr1[i] != caddr2[i]) {
899             return 0; /* false */
900         }
901     }
902     return 1;
903 }
904 
905 /**
906  * Wrapper for select/poll with timeout on a single file descriptor.
907  *
908  * flags (defined in net_util_md.h can be any combination of
909  * NET_WAIT_READ, NET_WAIT_WRITE &amp; NET_WAIT_CONNECT.
910  *
911  * The function will return when either the socket is ready for one
912  * of the specified operation or the timeout expired.
913  *
914  * It returns the time left from the timeout, or -1 if it expired.
915  */
916 
917 jint
918 NET_Wait(JNIEnv *env, jint fd, jint flags, jint timeout)
919 {
920     jlong prevTime = JVM_CurrentTimeMillis(env, 0);
921     jint read_rv;
922 
923     while (1) {
924         jlong newTime;
925         fd_set rd, wr, ex;
926         struct timeval t;
927 
928         t.tv_sec = timeout / 1000;
929         t.tv_usec = (timeout % 1000) * 1000;
930 
931         FD_ZERO(&amp;rd);
932         FD_ZERO(&amp;wr);
933         FD_ZERO(&amp;ex);
934         if (flags &amp; NET_WAIT_READ) {
935           FD_SET(fd, &amp;rd);
936         }
937         if (flags &amp; NET_WAIT_WRITE) {
938           FD_SET(fd, &amp;wr);
939         }
940         if (flags &amp; NET_WAIT_CONNECT) {
941           FD_SET(fd, &amp;wr);
942           FD_SET(fd, &amp;ex);
943         }
944 
945         errno = 0;
946         read_rv = select(fd+1, &amp;rd, &amp;wr, &amp;ex, &amp;t);
947 
948         newTime = JVM_CurrentTimeMillis(env, 0);
949         timeout -= (jint)(newTime - prevTime);
950         if (timeout &lt;= 0) {
951           return read_rv &gt; 0 ? 0 : -1;
952         }
953         newTime = prevTime;
954 
955         if (read_rv &gt; 0) {
956           break;
957         }
958 
959 
960       } /* while */
961 
962     return timeout;
963 }
964 
965 int NET_Socket (int domain, int type, int protocol) {
966     SOCKET sock;
967     sock = socket (domain, type, protocol);
968     if (sock != INVALID_SOCKET) {
969         SetHandleInformation((HANDLE)(uintptr_t)sock, HANDLE_FLAG_INHERIT, FALSE);
970     }
971     return (int)sock;
972 }
    </pre>
  </body>
</html>
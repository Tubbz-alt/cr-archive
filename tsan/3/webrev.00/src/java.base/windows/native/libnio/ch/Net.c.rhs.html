<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/native/libnio/ch/Net.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;windows.h&gt;
 27 #include &lt;winsock2.h&gt;
<a name="1" id="anc1"></a><span class="line-added"> 28 </span>
 29 #include &quot;jni.h&quot;
 30 #include &quot;jni_util.h&quot;
 31 #include &quot;jvm.h&quot;
 32 #include &quot;jlong.h&quot;
<a name="2" id="anc2"></a>
 33 #include &quot;nio.h&quot;
 34 #include &quot;nio_util.h&quot;
 35 #include &quot;net_util.h&quot;
 36 
 37 #include &quot;sun_nio_ch_Net.h&quot;
 38 #include &quot;sun_nio_ch_PollArrayWrapper.h&quot;
 39 
 40 /**
 41  * Definitions to allow for building with older SDK include files.
 42  */
 43 
 44 #ifndef MCAST_BLOCK_SOURCE
 45 
 46 #define MCAST_BLOCK_SOURCE          43
 47 #define MCAST_UNBLOCK_SOURCE        44
 48 #define MCAST_JOIN_SOURCE_GROUP     45
 49 #define MCAST_LEAVE_SOURCE_GROUP    46
 50 
 51 #endif  /* MCAST_BLOCK_SOURCE */
 52 
 53 struct my_ip_mreq_source {
 54     IN_ADDR imr_multiaddr;
 55     IN_ADDR imr_sourceaddr;
 56     IN_ADDR imr_interface;
 57 };
 58 
 59 struct my_group_source_req {
 60     ULONG gsr_interface;
 61     SOCKADDR_STORAGE gsr_group;
 62     SOCKADDR_STORAGE gsr_source;
 63 };
 64 
 65 /**
 66  * Copy IPv6 address as jbytearray to target
 67  */
 68 #define COPY_INET6_ADDRESS(env, source, target) \
 69     (*env)-&gt;GetByteArrayRegion(env, source, 0, 16, target)
 70 
 71 /**
 72  * Enable or disable receipt of WSAECONNRESET errors.
 73  */
 74 static void setConnectionReset(SOCKET s, BOOL enable) {
 75     DWORD bytesReturned = 0;
 76     WSAIoctl(s, SIO_UDP_CONNRESET, &amp;enable, sizeof(enable),
 77              NULL, 0, &amp;bytesReturned, NULL, NULL);
 78 }
 79 
 80 jint handleSocketError(JNIEnv *env, int errorValue)
 81 {
 82     NET_ThrowNew(env, errorValue, NULL);
 83     return IOS_THROWN;
 84 }
 85 
<a name="3" id="anc3"></a><span class="line-added"> 86 static jclass isa_class;        /* java.net.InetSocketAddress */</span>
<span class="line-added"> 87 static jmethodID isa_ctorID;    /* InetSocketAddress(InetAddress, int) */</span>
<span class="line-added"> 88 </span>
 89 JNIEXPORT void JNICALL
 90 Java_sun_nio_ch_Net_initIDs(JNIEnv *env, jclass clazz)
 91 {
<a name="4" id="anc4"></a><span class="line-modified"> 92      jclass cls = (*env)-&gt;FindClass(env, &quot;java/net/InetSocketAddress&quot;);</span>
<span class="line-added"> 93      CHECK_NULL(cls);</span>
<span class="line-added"> 94      isa_class = (*env)-&gt;NewGlobalRef(env, cls);</span>
<span class="line-added"> 95      if (isa_class == NULL) {</span>
<span class="line-added"> 96          JNU_ThrowOutOfMemoryError(env, NULL);</span>
<span class="line-added"> 97          return;</span>
<span class="line-added"> 98      }</span>
<span class="line-added"> 99      isa_ctorID = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;(Ljava/net/InetAddress;I)V&quot;);</span>
<span class="line-added">100      CHECK_NULL(isa_ctorID);</span>
<span class="line-added">101 </span>
<span class="line-added">102      initInetAddressIDs(env);</span>
103 }
104 
105 JNIEXPORT jboolean JNICALL
106 Java_sun_nio_ch_Net_isIPv6Available0(JNIEnv* env, jclass cl)
107 {
108     /*
109      * Return true if IPv6 is configured
110      */
111     return ipv6_available() ? JNI_TRUE : JNI_FALSE;
112 }
113 
114 JNIEXPORT jboolean JNICALL
115 Java_sun_nio_ch_Net_isReusePortAvailable0(JNIEnv* env, jclass c1)
116 {
117     // SO_REUSEPORT is not supported on Windows
118     return JNI_FALSE;
119 }
120 
121 JNIEXPORT jint JNICALL
122 Java_sun_nio_ch_Net_isExclusiveBindAvailable(JNIEnv *env, jclass clazz) {
123     return 1;
124 }
125 
<a name="5" id="anc5"></a><span class="line-added">126 JNIEXPORT jboolean JNICALL</span>
<span class="line-added">127 Java_sun_nio_ch_Net_shouldSetBothIPv4AndIPv6Options0(JNIEnv* env, jclass cl)</span>
<span class="line-added">128 {</span>
<span class="line-added">129     /* Set both IPv4 and IPv6 socket options when setting multicast options */</span>
<span class="line-added">130     return JNI_TRUE;</span>
<span class="line-added">131 }</span>
132 
133 JNIEXPORT jboolean JNICALL
134 Java_sun_nio_ch_Net_canIPv6SocketJoinIPv4Group0(JNIEnv* env, jclass cl)
135 {
<a name="6" id="anc6"></a><span class="line-modified">136     /* IPv6 sockets can join IPv4 multicast groups */</span>
<span class="line-added">137     return JNI_TRUE;</span>
138 }
139 
140 JNIEXPORT jboolean JNICALL
141 Java_sun_nio_ch_Net_canJoin6WithIPv4Group0(JNIEnv* env, jclass cl)
142 {
<a name="7" id="anc7"></a><span class="line-added">143     /* IPV6_ADD_MEMBERSHIP cannot be used to join IPv4 multicast groups */</span>
<span class="line-added">144     return JNI_FALSE;</span>
<span class="line-added">145 }</span>
<span class="line-added">146 </span>
<span class="line-added">147 JNIEXPORT jboolean JNICALL</span>
<span class="line-added">148 Java_sun_nio_ch_Net_canUseIPv6OptionsWithIPv4LocalAddress0(JNIEnv* env, jclass cl)</span>
<span class="line-added">149 {</span>
<span class="line-added">150     /* IPV6_XXX socket options cannot be used on IPv6 sockets bound to IPv4 address */</span>
151     return JNI_FALSE;
152 }
153 
154 JNIEXPORT jint JNICALL
155 Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,
156                             jboolean stream, jboolean reuse, jboolean fastLoopback)
157 {
158     SOCKET s;
159     int domain = (preferIPv6) ? AF_INET6 : AF_INET;
160 
161     s = socket(domain, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
162     if (s != INVALID_SOCKET) {
163         SetHandleInformation((HANDLE)s, HANDLE_FLAG_INHERIT, 0);
164 
165         /* IPV6_V6ONLY is true by default */
166         if (domain == AF_INET6) {
167             int opt = 0;
168             setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
169                        (const char *)&amp;opt, sizeof(opt));
170         }
171 
172         /* Disable WSAECONNRESET errors for initially unconnected UDP sockets */
173         if (!stream) {
174             setConnectionReset(s, FALSE);
175         }
176 
177     } else {
178         NET_ThrowNew(env, WSAGetLastError(), &quot;socket&quot;);
179     }
180 
181     if (stream &amp;&amp; fastLoopback) {
182         static int loopback_available = 1;
183         if (loopback_available) {
184             int rv = NET_EnableFastTcpLoopback((jint)s);
185             if (rv) {
186                 if (rv == WSAEOPNOTSUPP) {
187                     loopback_available = 0;
188                 } else {
189                     NET_ThrowNew(env, rv, &quot;fastLoopback&quot;);
190                 }
191             }
192         }
193     }
194 
195     return (jint)s;
196 }
197 
198 JNIEXPORT void JNICALL
199 Java_sun_nio_ch_Net_bind0(JNIEnv *env, jclass clazz, jobject fdo, jboolean preferIPv6,
200                           jboolean isExclBind, jobject iao, jint port)
201 {
202     SOCKETADDRESS sa;
203     int rv;
204     int sa_len = 0;
205 
206     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
207         return;
208     }
209 
210     rv = NET_WinBind(fdval(env, fdo), &amp;sa, sa_len, isExclBind);
211     if (rv == SOCKET_ERROR)
212         NET_ThrowNew(env, WSAGetLastError(), &quot;bind&quot;);
213 }
214 
215 JNIEXPORT void JNICALL
216 Java_sun_nio_ch_Net_listen(JNIEnv *env, jclass cl, jobject fdo, jint backlog)
217 {
218     if (listen(fdval(env,fdo), backlog) == SOCKET_ERROR) {
219         NET_ThrowNew(env, WSAGetLastError(), &quot;listen&quot;);
220     }
221 }
222 
<a name="8" id="anc8"></a>
223 JNIEXPORT jint JNICALL
224 Java_sun_nio_ch_Net_connect0(JNIEnv *env, jclass clazz, jboolean preferIPv6, jobject fdo,
225                              jobject iao, jint port)
226 {
227     SOCKETADDRESS sa;
228     int rv;
229     int sa_len = 0;
230     SOCKET s = (SOCKET)fdval(env, fdo);
231 
232     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
233         return IOS_THROWN;
234     }
235 
236     rv = connect(s, &amp;sa.sa, sa_len);
237     if (rv != 0) {
238         int err = WSAGetLastError();
239         if (err == WSAEINPROGRESS || err == WSAEWOULDBLOCK) {
240             return IOS_UNAVAILABLE;
241         }
242         NET_ThrowNew(env, err, &quot;connect&quot;);
243         return IOS_THROWN;
244     } else {
245         /* Enable WSAECONNRESET errors when a UDP socket is connected */
246         int type = 0, optlen = sizeof(type);
247         rv = getsockopt(s, SOL_SOCKET, SO_TYPE, (char*)&amp;type, &amp;optlen);
248         if (rv == 0 &amp;&amp; type == SOCK_DGRAM) {
249             setConnectionReset(s, TRUE);
250         }
251     }
252     return 1;
253 }
254 
<a name="9" id="anc9"></a><span class="line-added">255 JNIEXPORT jint JNICALL</span>
<span class="line-added">256 Java_sun_nio_ch_Net_accept(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,</span>
<span class="line-added">257                            jobjectArray isaa)</span>
<span class="line-added">258 {</span>
<span class="line-added">259     jint fd = fdval(env,fdo);</span>
<span class="line-added">260     jint newfd;</span>
<span class="line-added">261     SOCKETADDRESS sa;</span>
<span class="line-added">262     int addrlen = sizeof(sa);</span>
<span class="line-added">263     jobject remote_ia;</span>
<span class="line-added">264     jint remote_port = 0;</span>
<span class="line-added">265     jobject isa;</span>
<span class="line-added">266 </span>
<span class="line-added">267     memset((char *)&amp;sa, 0, sizeof(sa));</span>
<span class="line-added">268     newfd = (jint) accept(fd, &amp;sa.sa, &amp;addrlen);</span>
<span class="line-added">269     if (newfd == INVALID_SOCKET) {</span>
<span class="line-added">270         int theErr = (jint)WSAGetLastError();</span>
<span class="line-added">271         if (theErr == WSAEWOULDBLOCK) {</span>
<span class="line-added">272             return IOS_UNAVAILABLE;</span>
<span class="line-added">273         }</span>
<span class="line-added">274         JNU_ThrowIOExceptionWithLastError(env, &quot;Accept failed&quot;);</span>
<span class="line-added">275         return IOS_THROWN;</span>
<span class="line-added">276     }</span>
<span class="line-added">277 </span>
<span class="line-added">278     SetHandleInformation((HANDLE)(UINT_PTR)newfd, HANDLE_FLAG_INHERIT, 0);</span>
<span class="line-added">279     setfdval(env, newfdo, newfd);</span>
<span class="line-added">280 </span>
<span class="line-added">281     remote_ia = NET_SockaddrToInetAddress(env, &amp;sa, (int *)&amp;remote_port);</span>
<span class="line-added">282     CHECK_NULL_RETURN(remote_ia, IOS_THROWN);</span>
<span class="line-added">283 </span>
<span class="line-added">284     isa = (*env)-&gt;NewObject(env, isa_class, isa_ctorID, remote_ia, remote_port);</span>
<span class="line-added">285     CHECK_NULL_RETURN(isa, IOS_THROWN);</span>
<span class="line-added">286     (*env)-&gt;SetObjectArrayElement(env, isaa, 0, isa);</span>
<span class="line-added">287 </span>
<span class="line-added">288     return 1;</span>
<span class="line-added">289 }</span>
<span class="line-added">290 </span>
291 JNIEXPORT jint JNICALL
292 Java_sun_nio_ch_Net_localPort(JNIEnv *env, jclass clazz, jobject fdo)
293 {
294     SOCKETADDRESS sa;
295     int sa_len = sizeof(sa);
296 
<a name="10" id="anc10"></a><span class="line-modified">297     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) == SOCKET_ERROR) {</span>
298         int error = WSAGetLastError();
299         if (error == WSAEINVAL) {
300             return 0;
301         }
302         NET_ThrowNew(env, error, &quot;getsockname&quot;);
303         return IOS_THROWN;
304     }
305     return NET_GetPortFromSockaddr(&amp;sa);
306 }
307 
308 JNIEXPORT jobject JNICALL
309 Java_sun_nio_ch_Net_localInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
310 {
311     SOCKETADDRESS sa;
312     int sa_len = sizeof(sa);
313     int port;
314 
<a name="11" id="anc11"></a><span class="line-modified">315     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) == SOCKET_ERROR) {</span>
316         NET_ThrowNew(env, WSAGetLastError(), &quot;getsockname&quot;);
317         return NULL;
318     }
319     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
320 }
321 
322 JNIEXPORT jint JNICALL
323 Java_sun_nio_ch_Net_remotePort(JNIEnv *env, jclass clazz, jobject fdo)
324 {
325     SOCKETADDRESS sa;
326     int sa_len = sizeof(sa);
327 
<a name="12" id="anc12"></a><span class="line-modified">328     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) == SOCKET_ERROR) {</span>
329         int error = WSAGetLastError();
330         if (error == WSAEINVAL) {
331             return 0;
332         }
333         NET_ThrowNew(env, error, &quot;getsockname&quot;);
334         return IOS_THROWN;
335     }
336     return NET_GetPortFromSockaddr(&amp;sa);
337 }
338 
339 JNIEXPORT jobject JNICALL
340 Java_sun_nio_ch_Net_remoteInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
341 {
342     SOCKETADDRESS sa;
343     int sa_len = sizeof(sa);
344     int port;
345 
<a name="13" id="anc13"></a><span class="line-modified">346     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) == SOCKET_ERROR) {</span>
347         NET_ThrowNew(env, WSAGetLastError(), &quot;getsockname&quot;);
348         return NULL;
349     }
350     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
351 }
352 
353 JNIEXPORT jint JNICALL
354 Java_sun_nio_ch_Net_getIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
355                                   jboolean mayNeedConversion, jint level, jint opt)
356 {
357     int result = 0;
358     struct linger linger;
359     char *arg;
360     int arglen, n;
361 
362     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
363         arg = (char *)&amp;linger;
364         arglen = sizeof(linger);
365     } else {
366         arg = (char *)&amp;result;
367         arglen = sizeof(result);
368     }
369 
370     /**
371      * HACK: IP_TOS is deprecated on Windows and querying the option
372      * returns a protocol error. NET_GetSockOpt handles this and uses
373      * a fallback mechanism. Same applies to IPV6_TCLASS
374      */
375     if ((level == IPPROTO_IP &amp;&amp; opt == IP_TOS) || (level == IPPROTO_IPV6 &amp;&amp; opt == IPV6_TCLASS)) {
376         mayNeedConversion = JNI_TRUE;
377     }
378 
379     if (mayNeedConversion) {
380         n = NET_GetSockOpt(fdval(env, fdo), level, opt, arg, &amp;arglen);
381     } else {
382         n = getsockopt(fdval(env, fdo), level, opt, arg, &amp;arglen);
383     }
<a name="14" id="anc14"></a><span class="line-modified">384     if (n == SOCKET_ERROR) {</span>
385         handleSocketError(env, WSAGetLastError());
386         return IOS_THROWN;
387     }
388 
389     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER)
390         return linger.l_onoff ? linger.l_linger : -1;
391     else
392         return result;
393 }
394 
395 JNIEXPORT void JNICALL
396 Java_sun_nio_ch_Net_setIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
397                                   jboolean mayNeedConversion, jint level, jint opt, jint arg, jboolean ipv6)
398 {
399     struct linger linger;
400     char *parg;
401     int arglen, n;
402 
403     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
404         parg = (char *)&amp;linger;
405         arglen = sizeof(linger);
406         if (arg &gt;= 0) {
407             linger.l_onoff = 1;
408             linger.l_linger = (unsigned short)arg;
409         } else {
410             linger.l_onoff = 0;
411             linger.l_linger = 0;
412         }
413     } else {
414         parg = (char *)&amp;arg;
415         arglen = sizeof(arg);
416     }
417 
418     if (level == IPPROTO_IPV6 &amp;&amp; opt == IPV6_TCLASS) {
419         /* No op */
420         return;
421     }
422 
423     if (mayNeedConversion) {
424         n = NET_SetSockOpt(fdval(env, fdo), level, opt, parg, arglen);
425     } else {
426         n = setsockopt(fdval(env, fdo), level, opt, parg, arglen);
427     }
<a name="15" id="anc15"></a><span class="line-modified">428     if (n == SOCKET_ERROR)</span>
429         handleSocketError(env, WSAGetLastError());
430 }
431 
432 JNIEXPORT jint JNICALL
433 Java_sun_nio_ch_Net_joinOrDrop4(JNIEnv *env, jobject this, jboolean join, jobject fdo,
434                                 jint group, jint interf, jint source)
435 {
436     struct ip_mreq mreq;
437     struct my_ip_mreq_source mreq_source;
438     int opt, n, optlen;
439     void* optval;
440 
441     if (source == 0) {
442         mreq.imr_multiaddr.s_addr = htonl(group);
443         mreq.imr_interface.s_addr = htonl(interf);
444         opt = (join) ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;
445         optval = (void*)&amp;mreq;
446         optlen = sizeof(mreq);
447     } else {
448         mreq_source.imr_multiaddr.s_addr = htonl(group);
449         mreq_source.imr_sourceaddr.s_addr = htonl(source);
450         mreq_source.imr_interface.s_addr = htonl(interf);
451         opt = (join) ? IP_ADD_SOURCE_MEMBERSHIP : IP_DROP_SOURCE_MEMBERSHIP;
452         optval = (void*)&amp;mreq_source;
453         optlen = sizeof(mreq_source);
454     }
455 
456     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt, optval, optlen);
<a name="16" id="anc16"></a><span class="line-modified">457     if (n == SOCKET_ERROR) {</span>
458         if (join &amp;&amp; (WSAGetLastError() == WSAENOPROTOOPT))
459             return IOS_UNAVAILABLE;
460         handleSocketError(env, WSAGetLastError());
461     }
462     return 0;
463 }
464 
465 JNIEXPORT jint JNICALL
466 Java_sun_nio_ch_Net_blockOrUnblock4(JNIEnv *env, jobject this, jboolean block, jobject fdo,
467                                    jint group, jint interf, jint source)
468 {
469     struct my_ip_mreq_source mreq_source;
470     int n;
471     int opt = (block) ? IP_BLOCK_SOURCE : IP_UNBLOCK_SOURCE;
472 
473     mreq_source.imr_multiaddr.s_addr = htonl(group);
474     mreq_source.imr_sourceaddr.s_addr = htonl(source);
475     mreq_source.imr_interface.s_addr = htonl(interf);
476 
477     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt,
478                    (void*)&amp;mreq_source, sizeof(mreq_source));
<a name="17" id="anc17"></a><span class="line-modified">479     if (n == SOCKET_ERROR) {</span>
480         if (block &amp;&amp; (WSAGetLastError() == WSAENOPROTOOPT))
481             return IOS_UNAVAILABLE;
482         handleSocketError(env, WSAGetLastError());
483     }
484     return 0;
485 }
486 
487 /**
488  * Call setsockopt with a IPPROTO_IPV6 level socket option
489  * and a group_source_req structure as the option value. The
490  * given IPv6 group, interface index, and IPv6 source address
491  * are copied into the structure.
492  */
493 static int setGroupSourceReqOption(JNIEnv* env,
494                                    jobject fdo,
495                                    int opt,
496                                    jbyteArray group,
497                                    jint index,
498                                    jbyteArray source)
499 {
500     struct my_group_source_req req;
501     struct sockaddr_in6* sin6;
502 
503     req.gsr_interface = (ULONG)index;
504 
505     sin6 = (struct sockaddr_in6*)&amp;(req.gsr_group);
506     sin6-&gt;sin6_family = AF_INET6;
507     COPY_INET6_ADDRESS(env, group, (jbyte*)&amp;(sin6-&gt;sin6_addr));
508 
509     sin6 = (struct sockaddr_in6*)&amp;(req.gsr_source);
510     sin6-&gt;sin6_family = AF_INET6;
511     COPY_INET6_ADDRESS(env, source, (jbyte*)&amp;(sin6-&gt;sin6_addr));
512 
513     return setsockopt(fdval(env,fdo), IPPROTO_IPV6, opt, (void*)&amp;req, sizeof(req));
514 }
515 
516 JNIEXPORT jint JNICALL
517 Java_sun_nio_ch_Net_joinOrDrop6(JNIEnv *env, jobject this, jboolean join, jobject fdo,
518                                 jbyteArray group, jint index, jbyteArray source)
519 {
520     struct ipv6_mreq mreq6;
521     int n;
522 
523     if (source == NULL) {
524         int opt = (join) ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP;
525         COPY_INET6_ADDRESS(env, group, (jbyte*)&amp;(mreq6.ipv6mr_multiaddr));
526         mreq6.ipv6mr_interface = (int)index;
527         n = setsockopt(fdval(env,fdo), IPPROTO_IPV6, opt,
528                        (void*)&amp;mreq6, sizeof(mreq6));
529     } else {
530         int opt = (join) ? MCAST_JOIN_SOURCE_GROUP : MCAST_LEAVE_SOURCE_GROUP;
531         n = setGroupSourceReqOption(env, fdo, opt, group, index, source);
532     }
533 
<a name="18" id="anc18"></a><span class="line-modified">534     if (n == SOCKET_ERROR) {</span>
<span class="line-modified">535         handleSocketError(env, WSAGetLastError());</span>
536     }
537     return 0;
538 }
539 
540 JNIEXPORT jint JNICALL
541 Java_sun_nio_ch_Net_blockOrUnblock6(JNIEnv *env, jobject this, jboolean block, jobject fdo,
542                                     jbyteArray group, jint index, jbyteArray source)
543 {
544     int opt = (block) ? MCAST_BLOCK_SOURCE : MCAST_UNBLOCK_SOURCE;
545     int n = setGroupSourceReqOption(env, fdo, opt, group, index, source);
<a name="19" id="anc19"></a><span class="line-modified">546     if (n == SOCKET_ERROR) {</span>
<span class="line-modified">547         handleSocketError(env, WSAGetLastError());</span>
548     }
549     return 0;
550 }
551 
552 JNIEXPORT void JNICALL
553 Java_sun_nio_ch_Net_setInterface4(JNIEnv* env, jobject this, jobject fdo, jint interf)
554 {
555     struct in_addr in;
556     int arglen = sizeof(struct in_addr);
557     int n;
558 
559     in.s_addr = htonl(interf);
560 
561     n = setsockopt(fdval(env, fdo), IPPROTO_IP, IP_MULTICAST_IF,
562                    (void*)&amp;(in.s_addr), arglen);
<a name="20" id="anc20"></a><span class="line-modified">563     if (n == SOCKET_ERROR) {</span>
564         handleSocketError(env, WSAGetLastError());
565     }
566 }
567 
568 JNIEXPORT jint JNICALL
569 Java_sun_nio_ch_Net_getInterface4(JNIEnv* env, jobject this, jobject fdo)
570 {
571     struct in_addr in;
572     int arglen = sizeof(struct in_addr);
573     int n;
574 
575     n = getsockopt(fdval(env, fdo), IPPROTO_IP, IP_MULTICAST_IF, (void*)&amp;in, &amp;arglen);
<a name="21" id="anc21"></a><span class="line-modified">576     if (n == SOCKET_ERROR) {</span>
577         handleSocketError(env, WSAGetLastError());
578         return IOS_THROWN;
579     }
580     return ntohl(in.s_addr);
581 }
582 
583 JNIEXPORT void JNICALL
584 Java_sun_nio_ch_Net_setInterface6(JNIEnv* env, jobject this, jobject fdo, jint index)
585 {
<a name="22" id="anc22"></a><span class="line-modified">586     DWORD value = (jint)index;</span>
587     int arglen = sizeof(value);
588     int n;
589 
590     n = setsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF,
591                    (void*)&amp;(index), arglen);
<a name="23" id="anc23"></a><span class="line-modified">592     if (n == SOCKET_ERROR) {</span>
<span class="line-modified">593         handleSocketError(env, WSAGetLastError());</span>
594     }
595 }
596 
597 JNIEXPORT jint JNICALL
598 Java_sun_nio_ch_Net_getInterface6(JNIEnv* env, jobject this, jobject fdo)
599 {
<a name="24" id="anc24"></a><span class="line-modified">600     DWORD index;</span>
601     int arglen = sizeof(index);
602     int n;
603 
604     n = getsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF, (void*)&amp;index, &amp;arglen);
<a name="25" id="anc25"></a><span class="line-modified">605     if (n == SOCKET_ERROR) {</span>
<span class="line-modified">606         handleSocketError(env, WSAGetLastError());</span>
607         return -1;
608     }
609     return (jint)index;
610 }
611 
612 JNIEXPORT void JNICALL
613 Java_sun_nio_ch_Net_shutdown(JNIEnv *env, jclass cl, jobject fdo, jint jhow) {
614     int how = (jhow == sun_nio_ch_Net_SHUT_RD) ? SD_RECEIVE :
615         (jhow == sun_nio_ch_Net_SHUT_WR) ? SD_SEND : SD_BOTH;
616     if (shutdown(fdval(env, fdo), how) == SOCKET_ERROR) {
617         NET_ThrowNew(env, WSAGetLastError(), &quot;shutdown&quot;);
618     }
619 }
620 
621 JNIEXPORT jint JNICALL
622 Java_sun_nio_ch_Net_available(JNIEnv *env, jclass cl, jobject fdo)
623 {
624     int count = 0;
625     if (NET_SocketAvailable(fdval(env, fdo), &amp;count) != 0) {
626         handleSocketError(env, WSAGetLastError());
627         return IOS_THROWN;
628     }
629     return (jint) count;
630 }
631 
632 JNIEXPORT jint JNICALL
633 Java_sun_nio_ch_Net_poll(JNIEnv* env, jclass this, jobject fdo, jint events, jlong timeout)
634 {
635     int rv;
636     int revents = 0;
637     struct timeval t;
<a name="26" id="anc26"></a>
638     fd_set rd, wr, ex;
639     jint fd = fdval(env, fdo);
640 
<a name="27" id="anc27"></a>


641     FD_ZERO(&amp;rd);
642     FD_ZERO(&amp;wr);
643     FD_ZERO(&amp;ex);
644     if (events &amp; POLLIN) {
645         FD_SET(fd, &amp;rd);
646     }
647     if (events &amp; POLLOUT ||
648         events &amp; POLLCONN) {
649         FD_SET(fd, &amp;wr);
650     }
651     FD_SET(fd, &amp;ex);
652 
<a name="28" id="anc28"></a><span class="line-modified">653     if (timeout &gt;= 0) {</span>
<span class="line-added">654         t.tv_sec = (long)(timeout / 1000);</span>
<span class="line-added">655         t.tv_usec = (timeout % 1000) * 1000;</span>
<span class="line-added">656     }</span>
<span class="line-added">657 </span>
<span class="line-added">658     rv = select(fd+1, &amp;rd, &amp;wr, &amp;ex, (timeout &gt;= 0) ? &amp;t : NULL);</span>
659 
660     /* save last winsock error */
661     if (rv == SOCKET_ERROR) {
<a name="29" id="anc29"></a><span class="line-modified">662         handleSocketError(env, WSAGetLastError());</span>
663         return IOS_THROWN;
664     } else if (rv &gt;= 0) {
665         rv = 0;
666         if (FD_ISSET(fd, &amp;rd)) {
667             rv |= POLLIN;
668         }
669         if (FD_ISSET(fd, &amp;wr)) {
670             rv |= POLLOUT;
671         }
672         if (FD_ISSET(fd, &amp;ex)) {
673             rv |= POLLERR;
674         }
675     }
676     return rv;
677 }
678 
<a name="30" id="anc30"></a><span class="line-modified">679 JNIEXPORT jboolean JNICALL</span>
680 Java_sun_nio_ch_Net_pollConnect(JNIEnv* env, jclass this, jobject fdo, jlong timeout)
681 {
682     int optError = 0;
683     int result;
684     int n = sizeof(int);
685     jint fd = fdval(env, fdo);
686     fd_set wr, ex;
687     struct timeval t;
688 
689     FD_ZERO(&amp;wr);
690     FD_ZERO(&amp;ex);
691     FD_SET((u_int)fd, &amp;wr);
692     FD_SET((u_int)fd, &amp;ex);
693 
694     if (timeout &gt;= 0) {
695         t.tv_sec = (long)(timeout / 1000);
696         t.tv_usec = (timeout % 1000) * 1000;
697     }
698 
699     result = select(fd+1, 0, &amp;wr, &amp;ex, (timeout &gt;= 0) ? &amp;t : NULL);
700 
701     if (result == SOCKET_ERROR) {
702         handleSocketError(env, WSAGetLastError());
<a name="31" id="anc31"></a><span class="line-modified">703         return JNI_FALSE;</span>
704     } else if (result == 0) {
<a name="32" id="anc32"></a><span class="line-modified">705         return JNI_FALSE;</span>
706     } else {
707         // connection established if writable and no error to check
708         if (FD_ISSET(fd, &amp;wr) &amp;&amp; !FD_ISSET(fd, &amp;ex)) {
<a name="33" id="anc33"></a><span class="line-modified">709             return JNI_TRUE;</span>
710         }
711         result = getsockopt((SOCKET)fd,
712                             SOL_SOCKET,
713                             SO_ERROR,
714                             (char *)&amp;optError,
715                             &amp;n);
716         if (result == SOCKET_ERROR) {
717             int lastError = WSAGetLastError();
<a name="34" id="anc34"></a><span class="line-modified">718             if (lastError != WSAEINPROGRESS) {</span>
<span class="line-modified">719                 NET_ThrowNew(env, lastError, &quot;getsockopt&quot;);</span>
720             }
<a name="35" id="anc35"></a><span class="line-modified">721         } else if (optError != NO_ERROR) {</span>



722             handleSocketError(env, optError);
<a name="36" id="anc36"></a>
723         }
<a name="37" id="anc37"></a><span class="line-modified">724         return JNI_FALSE;</span>
725     }
726 }
727 
728 JNIEXPORT jshort JNICALL
729 Java_sun_nio_ch_Net_pollinValue(JNIEnv *env, jclass this)
730 {
731     return (jshort)POLLIN;
732 }
733 
734 JNIEXPORT jshort JNICALL
735 Java_sun_nio_ch_Net_polloutValue(JNIEnv *env, jclass this)
736 {
737     return (jshort)POLLOUT;
738 }
739 
740 JNIEXPORT jshort JNICALL
741 Java_sun_nio_ch_Net_pollerrValue(JNIEnv *env, jclass this)
742 {
743     return (jshort)POLLERR;
744 }
745 
746 JNIEXPORT jshort JNICALL
747 Java_sun_nio_ch_Net_pollhupValue(JNIEnv *env, jclass this)
748 {
749     return (jshort)POLLHUP;
750 }
751 
752 JNIEXPORT jshort JNICALL
753 Java_sun_nio_ch_Net_pollnvalValue(JNIEnv *env, jclass this)
754 {
755     return (jshort)POLLNVAL;
756 }
757 
758 JNIEXPORT jshort JNICALL
759 Java_sun_nio_ch_Net_pollconnValue(JNIEnv *env, jclass this)
760 {
761     return (jshort)POLLCONN;
762 }
763 
764 JNIEXPORT jint JNICALL
765 Java_sun_nio_ch_Net_sendOOB(JNIEnv* env, jclass this, jobject fdo, jbyte b)
766 {
767     int n = send(fdval(env, fdo), (const char*)&amp;b, 1, MSG_OOB);
768     if (n == SOCKET_ERROR) {
769         if (WSAGetLastError() == WSAEWOULDBLOCK) {
770             return IOS_UNAVAILABLE;
771         } else {
772             JNU_ThrowIOExceptionWithLastError(env, &quot;send failed&quot;);
773             return IOS_THROWN;
774         }
775     } else {
776         return n;
777     }
778 }
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
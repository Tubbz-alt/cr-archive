<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libnio/ch/Net.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Iocp.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketDispatcher.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnio/ch/Net.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;windows.h&gt;
 27 #include &lt;winsock2.h&gt;

 28 #include &quot;jni.h&quot;
 29 #include &quot;jni_util.h&quot;
 30 #include &quot;jvm.h&quot;
 31 #include &quot;jlong.h&quot;
<span class="line-removed"> 32 </span>
 33 #include &quot;nio.h&quot;
 34 #include &quot;nio_util.h&quot;
 35 #include &quot;net_util.h&quot;
 36 
 37 #include &quot;sun_nio_ch_Net.h&quot;
 38 #include &quot;sun_nio_ch_PollArrayWrapper.h&quot;
 39 
 40 /**
 41  * Definitions to allow for building with older SDK include files.
 42  */
 43 
 44 #ifndef MCAST_BLOCK_SOURCE
 45 
 46 #define MCAST_BLOCK_SOURCE          43
 47 #define MCAST_UNBLOCK_SOURCE        44
 48 #define MCAST_JOIN_SOURCE_GROUP     45
 49 #define MCAST_LEAVE_SOURCE_GROUP    46
 50 
 51 #endif  /* MCAST_BLOCK_SOURCE */
 52 
</pre>
<hr />
<pre>
 66  * Copy IPv6 address as jbytearray to target
 67  */
 68 #define COPY_INET6_ADDRESS(env, source, target) \
 69     (*env)-&gt;GetByteArrayRegion(env, source, 0, 16, target)
 70 
 71 /**
 72  * Enable or disable receipt of WSAECONNRESET errors.
 73  */
 74 static void setConnectionReset(SOCKET s, BOOL enable) {
 75     DWORD bytesReturned = 0;
 76     WSAIoctl(s, SIO_UDP_CONNRESET, &amp;enable, sizeof(enable),
 77              NULL, 0, &amp;bytesReturned, NULL, NULL);
 78 }
 79 
 80 jint handleSocketError(JNIEnv *env, int errorValue)
 81 {
 82     NET_ThrowNew(env, errorValue, NULL);
 83     return IOS_THROWN;
 84 }
 85 



 86 JNIEXPORT void JNICALL
 87 Java_sun_nio_ch_Net_initIDs(JNIEnv *env, jclass clazz)
 88 {
<span class="line-modified"> 89     initInetAddressIDs(env);</span>










 90 }
 91 
 92 JNIEXPORT jboolean JNICALL
 93 Java_sun_nio_ch_Net_isIPv6Available0(JNIEnv* env, jclass cl)
 94 {
 95     /*
 96      * Return true if IPv6 is configured
 97      */
 98     return ipv6_available() ? JNI_TRUE : JNI_FALSE;
 99 }
100 
101 JNIEXPORT jboolean JNICALL
102 Java_sun_nio_ch_Net_isReusePortAvailable0(JNIEnv* env, jclass c1)
103 {
104     // SO_REUSEPORT is not supported on Windows
105     return JNI_FALSE;
106 }
107 
108 JNIEXPORT jint JNICALL
109 Java_sun_nio_ch_Net_isExclusiveBindAvailable(JNIEnv *env, jclass clazz) {
110     return 1;
111 }
112 






113 
114 JNIEXPORT jboolean JNICALL
115 Java_sun_nio_ch_Net_canIPv6SocketJoinIPv4Group0(JNIEnv* env, jclass cl)
116 {
<span class="line-modified">117     return JNI_FALSE;</span>

118 }
119 
120 JNIEXPORT jboolean JNICALL
121 Java_sun_nio_ch_Net_canJoin6WithIPv4Group0(JNIEnv* env, jclass cl)
122 {








123     return JNI_FALSE;
124 }
125 
126 JNIEXPORT jint JNICALL
127 Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,
128                             jboolean stream, jboolean reuse, jboolean fastLoopback)
129 {
130     SOCKET s;
131     int domain = (preferIPv6) ? AF_INET6 : AF_INET;
132 
133     s = socket(domain, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
134     if (s != INVALID_SOCKET) {
135         SetHandleInformation((HANDLE)s, HANDLE_FLAG_INHERIT, 0);
136 
137         /* IPV6_V6ONLY is true by default */
138         if (domain == AF_INET6) {
139             int opt = 0;
140             setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
141                        (const char *)&amp;opt, sizeof(opt));
142         }
</pre>
<hr />
<pre>
175     int rv;
176     int sa_len = 0;
177 
178     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
179         return;
180     }
181 
182     rv = NET_WinBind(fdval(env, fdo), &amp;sa, sa_len, isExclBind);
183     if (rv == SOCKET_ERROR)
184         NET_ThrowNew(env, WSAGetLastError(), &quot;bind&quot;);
185 }
186 
187 JNIEXPORT void JNICALL
188 Java_sun_nio_ch_Net_listen(JNIEnv *env, jclass cl, jobject fdo, jint backlog)
189 {
190     if (listen(fdval(env,fdo), backlog) == SOCKET_ERROR) {
191         NET_ThrowNew(env, WSAGetLastError(), &quot;listen&quot;);
192     }
193 }
194 
<span class="line-removed">195 </span>
196 JNIEXPORT jint JNICALL
197 Java_sun_nio_ch_Net_connect0(JNIEnv *env, jclass clazz, jboolean preferIPv6, jobject fdo,
198                              jobject iao, jint port)
199 {
200     SOCKETADDRESS sa;
201     int rv;
202     int sa_len = 0;
203     SOCKET s = (SOCKET)fdval(env, fdo);
204 
205     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
206         return IOS_THROWN;
207     }
208 
209     rv = connect(s, &amp;sa.sa, sa_len);
210     if (rv != 0) {
211         int err = WSAGetLastError();
212         if (err == WSAEINPROGRESS || err == WSAEWOULDBLOCK) {
213             return IOS_UNAVAILABLE;
214         }
215         NET_ThrowNew(env, err, &quot;connect&quot;);
216         return IOS_THROWN;
217     } else {
218         /* Enable WSAECONNRESET errors when a UDP socket is connected */
219         int type = 0, optlen = sizeof(type);
220         rv = getsockopt(s, SOL_SOCKET, SO_TYPE, (char*)&amp;type, &amp;optlen);
221         if (rv == 0 &amp;&amp; type == SOCK_DGRAM) {
222             setConnectionReset(s, TRUE);
223         }
224     }
225     return 1;
226 }
227 




































228 JNIEXPORT jint JNICALL
229 Java_sun_nio_ch_Net_localPort(JNIEnv *env, jclass clazz, jobject fdo)
230 {
231     SOCKETADDRESS sa;
232     int sa_len = sizeof(sa);
233 
<span class="line-modified">234     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
235         int error = WSAGetLastError();
236         if (error == WSAEINVAL) {
237             return 0;
238         }
239         NET_ThrowNew(env, error, &quot;getsockname&quot;);
240         return IOS_THROWN;
241     }
242     return NET_GetPortFromSockaddr(&amp;sa);
243 }
244 
245 JNIEXPORT jobject JNICALL
246 Java_sun_nio_ch_Net_localInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
247 {
248     SOCKETADDRESS sa;
249     int sa_len = sizeof(sa);
250     int port;
251 
<span class="line-modified">252     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
253         NET_ThrowNew(env, WSAGetLastError(), &quot;getsockname&quot;);
254         return NULL;
255     }
256     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
257 }
258 
259 JNIEXPORT jint JNICALL
260 Java_sun_nio_ch_Net_remotePort(JNIEnv *env, jclass clazz, jobject fdo)
261 {
262     SOCKETADDRESS sa;
263     int sa_len = sizeof(sa);
264 
<span class="line-modified">265     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
266         int error = WSAGetLastError();
267         if (error == WSAEINVAL) {
268             return 0;
269         }
270         NET_ThrowNew(env, error, &quot;getsockname&quot;);
271         return IOS_THROWN;
272     }
273     return NET_GetPortFromSockaddr(&amp;sa);
274 }
275 
276 JNIEXPORT jobject JNICALL
277 Java_sun_nio_ch_Net_remoteInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
278 {
279     SOCKETADDRESS sa;
280     int sa_len = sizeof(sa);
281     int port;
282 
<span class="line-modified">283     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
284         NET_ThrowNew(env, WSAGetLastError(), &quot;getsockname&quot;);
285         return NULL;
286     }
287     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
288 }
289 
290 JNIEXPORT jint JNICALL
291 Java_sun_nio_ch_Net_getIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
292                                   jboolean mayNeedConversion, jint level, jint opt)
293 {
294     int result = 0;
295     struct linger linger;
296     char *arg;
297     int arglen, n;
298 
299     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
300         arg = (char *)&amp;linger;
301         arglen = sizeof(linger);
302     } else {
303         arg = (char *)&amp;result;
304         arglen = sizeof(result);
305     }
306 
307     /**
308      * HACK: IP_TOS is deprecated on Windows and querying the option
309      * returns a protocol error. NET_GetSockOpt handles this and uses
310      * a fallback mechanism. Same applies to IPV6_TCLASS
311      */
312     if ((level == IPPROTO_IP &amp;&amp; opt == IP_TOS) || (level == IPPROTO_IPV6 &amp;&amp; opt == IPV6_TCLASS)) {
313         mayNeedConversion = JNI_TRUE;
314     }
315 
316     if (mayNeedConversion) {
317         n = NET_GetSockOpt(fdval(env, fdo), level, opt, arg, &amp;arglen);
318     } else {
319         n = getsockopt(fdval(env, fdo), level, opt, arg, &amp;arglen);
320     }
<span class="line-modified">321     if (n &lt; 0) {</span>
322         handleSocketError(env, WSAGetLastError());
323         return IOS_THROWN;
324     }
325 
326     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER)
327         return linger.l_onoff ? linger.l_linger : -1;
328     else
329         return result;
330 }
331 
332 JNIEXPORT void JNICALL
333 Java_sun_nio_ch_Net_setIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
334                                   jboolean mayNeedConversion, jint level, jint opt, jint arg, jboolean ipv6)
335 {
336     struct linger linger;
337     char *parg;
338     int arglen, n;
339 
340     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
341         parg = (char *)&amp;linger;
</pre>
<hr />
<pre>
345             linger.l_linger = (unsigned short)arg;
346         } else {
347             linger.l_onoff = 0;
348             linger.l_linger = 0;
349         }
350     } else {
351         parg = (char *)&amp;arg;
352         arglen = sizeof(arg);
353     }
354 
355     if (level == IPPROTO_IPV6 &amp;&amp; opt == IPV6_TCLASS) {
356         /* No op */
357         return;
358     }
359 
360     if (mayNeedConversion) {
361         n = NET_SetSockOpt(fdval(env, fdo), level, opt, parg, arglen);
362     } else {
363         n = setsockopt(fdval(env, fdo), level, opt, parg, arglen);
364     }
<span class="line-modified">365     if (n &lt; 0)</span>
366         handleSocketError(env, WSAGetLastError());
367 }
368 
369 JNIEXPORT jint JNICALL
370 Java_sun_nio_ch_Net_joinOrDrop4(JNIEnv *env, jobject this, jboolean join, jobject fdo,
371                                 jint group, jint interf, jint source)
372 {
373     struct ip_mreq mreq;
374     struct my_ip_mreq_source mreq_source;
375     int opt, n, optlen;
376     void* optval;
377 
378     if (source == 0) {
379         mreq.imr_multiaddr.s_addr = htonl(group);
380         mreq.imr_interface.s_addr = htonl(interf);
381         opt = (join) ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;
382         optval = (void*)&amp;mreq;
383         optlen = sizeof(mreq);
384     } else {
385         mreq_source.imr_multiaddr.s_addr = htonl(group);
386         mreq_source.imr_sourceaddr.s_addr = htonl(source);
387         mreq_source.imr_interface.s_addr = htonl(interf);
388         opt = (join) ? IP_ADD_SOURCE_MEMBERSHIP : IP_DROP_SOURCE_MEMBERSHIP;
389         optval = (void*)&amp;mreq_source;
390         optlen = sizeof(mreq_source);
391     }
392 
393     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt, optval, optlen);
<span class="line-modified">394     if (n &lt; 0) {</span>
395         if (join &amp;&amp; (WSAGetLastError() == WSAENOPROTOOPT))
396             return IOS_UNAVAILABLE;
397         handleSocketError(env, WSAGetLastError());
398     }
399     return 0;
400 }
401 
402 JNIEXPORT jint JNICALL
403 Java_sun_nio_ch_Net_blockOrUnblock4(JNIEnv *env, jobject this, jboolean block, jobject fdo,
404                                    jint group, jint interf, jint source)
405 {
406     struct my_ip_mreq_source mreq_source;
407     int n;
408     int opt = (block) ? IP_BLOCK_SOURCE : IP_UNBLOCK_SOURCE;
409 
410     mreq_source.imr_multiaddr.s_addr = htonl(group);
411     mreq_source.imr_sourceaddr.s_addr = htonl(source);
412     mreq_source.imr_interface.s_addr = htonl(interf);
413 
414     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt,
415                    (void*)&amp;mreq_source, sizeof(mreq_source));
<span class="line-modified">416     if (n &lt; 0) {</span>
417         if (block &amp;&amp; (WSAGetLastError() == WSAENOPROTOOPT))
418             return IOS_UNAVAILABLE;
419         handleSocketError(env, WSAGetLastError());
420     }
421     return 0;
422 }
423 
424 /**
425  * Call setsockopt with a IPPROTO_IPV6 level socket option
426  * and a group_source_req structure as the option value. The
427  * given IPv6 group, interface index, and IPv6 source address
428  * are copied into the structure.
429  */
430 static int setGroupSourceReqOption(JNIEnv* env,
431                                    jobject fdo,
432                                    int opt,
433                                    jbyteArray group,
434                                    jint index,
435                                    jbyteArray source)
436 {
</pre>
<hr />
<pre>
451 }
452 
453 JNIEXPORT jint JNICALL
454 Java_sun_nio_ch_Net_joinOrDrop6(JNIEnv *env, jobject this, jboolean join, jobject fdo,
455                                 jbyteArray group, jint index, jbyteArray source)
456 {
457     struct ipv6_mreq mreq6;
458     int n;
459 
460     if (source == NULL) {
461         int opt = (join) ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP;
462         COPY_INET6_ADDRESS(env, group, (jbyte*)&amp;(mreq6.ipv6mr_multiaddr));
463         mreq6.ipv6mr_interface = (int)index;
464         n = setsockopt(fdval(env,fdo), IPPROTO_IPV6, opt,
465                        (void*)&amp;mreq6, sizeof(mreq6));
466     } else {
467         int opt = (join) ? MCAST_JOIN_SOURCE_GROUP : MCAST_LEAVE_SOURCE_GROUP;
468         n = setGroupSourceReqOption(env, fdo, opt, group, index, source);
469     }
470 
<span class="line-modified">471     if (n &lt; 0) {</span>
<span class="line-modified">472         handleSocketError(env, errno);</span>
473     }
474     return 0;
475 }
476 
477 JNIEXPORT jint JNICALL
478 Java_sun_nio_ch_Net_blockOrUnblock6(JNIEnv *env, jobject this, jboolean block, jobject fdo,
479                                     jbyteArray group, jint index, jbyteArray source)
480 {
481     int opt = (block) ? MCAST_BLOCK_SOURCE : MCAST_UNBLOCK_SOURCE;
482     int n = setGroupSourceReqOption(env, fdo, opt, group, index, source);
<span class="line-modified">483     if (n &lt; 0) {</span>
<span class="line-modified">484         handleSocketError(env, errno);</span>
485     }
486     return 0;
487 }
488 
489 JNIEXPORT void JNICALL
490 Java_sun_nio_ch_Net_setInterface4(JNIEnv* env, jobject this, jobject fdo, jint interf)
491 {
492     struct in_addr in;
493     int arglen = sizeof(struct in_addr);
494     int n;
495 
496     in.s_addr = htonl(interf);
497 
498     n = setsockopt(fdval(env, fdo), IPPROTO_IP, IP_MULTICAST_IF,
499                    (void*)&amp;(in.s_addr), arglen);
<span class="line-modified">500     if (n &lt; 0) {</span>
501         handleSocketError(env, WSAGetLastError());
502     }
503 }
504 
505 JNIEXPORT jint JNICALL
506 Java_sun_nio_ch_Net_getInterface4(JNIEnv* env, jobject this, jobject fdo)
507 {
508     struct in_addr in;
509     int arglen = sizeof(struct in_addr);
510     int n;
511 
512     n = getsockopt(fdval(env, fdo), IPPROTO_IP, IP_MULTICAST_IF, (void*)&amp;in, &amp;arglen);
<span class="line-modified">513     if (n &lt; 0) {</span>
514         handleSocketError(env, WSAGetLastError());
515         return IOS_THROWN;
516     }
517     return ntohl(in.s_addr);
518 }
519 
520 JNIEXPORT void JNICALL
521 Java_sun_nio_ch_Net_setInterface6(JNIEnv* env, jobject this, jobject fdo, jint index)
522 {
<span class="line-modified">523     int value = (jint)index;</span>
524     int arglen = sizeof(value);
525     int n;
526 
527     n = setsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF,
528                    (void*)&amp;(index), arglen);
<span class="line-modified">529     if (n &lt; 0) {</span>
<span class="line-modified">530         handleSocketError(env, errno);</span>
531     }
532 }
533 
534 JNIEXPORT jint JNICALL
535 Java_sun_nio_ch_Net_getInterface6(JNIEnv* env, jobject this, jobject fdo)
536 {
<span class="line-modified">537     int index;</span>
538     int arglen = sizeof(index);
539     int n;
540 
541     n = getsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF, (void*)&amp;index, &amp;arglen);
<span class="line-modified">542     if (n &lt; 0) {</span>
<span class="line-modified">543         handleSocketError(env, errno);</span>
544         return -1;
545     }
546     return (jint)index;
547 }
548 
549 JNIEXPORT void JNICALL
550 Java_sun_nio_ch_Net_shutdown(JNIEnv *env, jclass cl, jobject fdo, jint jhow) {
551     int how = (jhow == sun_nio_ch_Net_SHUT_RD) ? SD_RECEIVE :
552         (jhow == sun_nio_ch_Net_SHUT_WR) ? SD_SEND : SD_BOTH;
553     if (shutdown(fdval(env, fdo), how) == SOCKET_ERROR) {
554         NET_ThrowNew(env, WSAGetLastError(), &quot;shutdown&quot;);
555     }
556 }
557 
558 JNIEXPORT jint JNICALL
559 Java_sun_nio_ch_Net_available(JNIEnv *env, jclass cl, jobject fdo)
560 {
561     int count = 0;
562     if (NET_SocketAvailable(fdval(env, fdo), &amp;count) != 0) {
563         handleSocketError(env, WSAGetLastError());
564         return IOS_THROWN;
565     }
566     return (jint) count;
567 }
568 
569 JNIEXPORT jint JNICALL
570 Java_sun_nio_ch_Net_poll(JNIEnv* env, jclass this, jobject fdo, jint events, jlong timeout)
571 {
572     int rv;
573     int revents = 0;
574     struct timeval t;
<span class="line-removed">575     int lastError = 0;</span>
576     fd_set rd, wr, ex;
577     jint fd = fdval(env, fdo);
578 
<span class="line-removed">579     t.tv_sec = (long)(timeout / 1000);</span>
<span class="line-removed">580     t.tv_usec = (timeout % 1000) * 1000;</span>
<span class="line-removed">581 </span>
582     FD_ZERO(&amp;rd);
583     FD_ZERO(&amp;wr);
584     FD_ZERO(&amp;ex);
585     if (events &amp; POLLIN) {
586         FD_SET(fd, &amp;rd);
587     }
588     if (events &amp; POLLOUT ||
589         events &amp; POLLCONN) {
590         FD_SET(fd, &amp;wr);
591     }
592     FD_SET(fd, &amp;ex);
593 
<span class="line-modified">594     rv = select(fd+1, &amp;rd, &amp;wr, &amp;ex, &amp;t);</span>





595 
596     /* save last winsock error */
597     if (rv == SOCKET_ERROR) {
<span class="line-modified">598         handleSocketError(env, lastError);</span>
599         return IOS_THROWN;
600     } else if (rv &gt;= 0) {
601         rv = 0;
602         if (FD_ISSET(fd, &amp;rd)) {
603             rv |= POLLIN;
604         }
605         if (FD_ISSET(fd, &amp;wr)) {
606             rv |= POLLOUT;
607         }
608         if (FD_ISSET(fd, &amp;ex)) {
609             rv |= POLLERR;
610         }
611     }
612     return rv;
613 }
614 
<span class="line-modified">615 JNIEXPORT jint JNICALL</span>
616 Java_sun_nio_ch_Net_pollConnect(JNIEnv* env, jclass this, jobject fdo, jlong timeout)
617 {
618     int optError = 0;
619     int result;
620     int n = sizeof(int);
621     jint fd = fdval(env, fdo);
622     fd_set wr, ex;
623     struct timeval t;
624 
625     FD_ZERO(&amp;wr);
626     FD_ZERO(&amp;ex);
627     FD_SET((u_int)fd, &amp;wr);
628     FD_SET((u_int)fd, &amp;ex);
629 
630     if (timeout &gt;= 0) {
631         t.tv_sec = (long)(timeout / 1000);
632         t.tv_usec = (timeout % 1000) * 1000;
633     }
634 
635     result = select(fd+1, 0, &amp;wr, &amp;ex, (timeout &gt;= 0) ? &amp;t : NULL);
636 
637     if (result == SOCKET_ERROR) {
638         handleSocketError(env, WSAGetLastError());
<span class="line-modified">639         return IOS_THROWN;</span>
640     } else if (result == 0) {
<span class="line-modified">641         return 0;</span>
642     } else {
643         // connection established if writable and no error to check
644         if (FD_ISSET(fd, &amp;wr) &amp;&amp; !FD_ISSET(fd, &amp;ex)) {
<span class="line-modified">645             return 1;</span>
646         }
647         result = getsockopt((SOCKET)fd,
648                             SOL_SOCKET,
649                             SO_ERROR,
650                             (char *)&amp;optError,
651                             &amp;n);
652         if (result == SOCKET_ERROR) {
653             int lastError = WSAGetLastError();
<span class="line-modified">654             if (lastError == WSAEINPROGRESS) {</span>
<span class="line-modified">655                 return IOS_UNAVAILABLE;</span>
656             }
<span class="line-modified">657             NET_ThrowNew(env, lastError, &quot;getsockopt&quot;);</span>
<span class="line-removed">658             return IOS_THROWN;</span>
<span class="line-removed">659         }</span>
<span class="line-removed">660         if (optError != NO_ERROR) {</span>
661             handleSocketError(env, optError);
<span class="line-removed">662             return IOS_THROWN;</span>
663         }
<span class="line-modified">664         return 0;</span>
665     }
666 }
667 
668 JNIEXPORT jshort JNICALL
669 Java_sun_nio_ch_Net_pollinValue(JNIEnv *env, jclass this)
670 {
671     return (jshort)POLLIN;
672 }
673 
674 JNIEXPORT jshort JNICALL
675 Java_sun_nio_ch_Net_polloutValue(JNIEnv *env, jclass this)
676 {
677     return (jshort)POLLOUT;
678 }
679 
680 JNIEXPORT jshort JNICALL
681 Java_sun_nio_ch_Net_pollerrValue(JNIEnv *env, jclass this)
682 {
683     return (jshort)POLLERR;
684 }
</pre>
</td>
<td>
<hr />
<pre>
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;windows.h&gt;
 27 #include &lt;winsock2.h&gt;
<span class="line-added"> 28 </span>
 29 #include &quot;jni.h&quot;
 30 #include &quot;jni_util.h&quot;
 31 #include &quot;jvm.h&quot;
 32 #include &quot;jlong.h&quot;

 33 #include &quot;nio.h&quot;
 34 #include &quot;nio_util.h&quot;
 35 #include &quot;net_util.h&quot;
 36 
 37 #include &quot;sun_nio_ch_Net.h&quot;
 38 #include &quot;sun_nio_ch_PollArrayWrapper.h&quot;
 39 
 40 /**
 41  * Definitions to allow for building with older SDK include files.
 42  */
 43 
 44 #ifndef MCAST_BLOCK_SOURCE
 45 
 46 #define MCAST_BLOCK_SOURCE          43
 47 #define MCAST_UNBLOCK_SOURCE        44
 48 #define MCAST_JOIN_SOURCE_GROUP     45
 49 #define MCAST_LEAVE_SOURCE_GROUP    46
 50 
 51 #endif  /* MCAST_BLOCK_SOURCE */
 52 
</pre>
<hr />
<pre>
 66  * Copy IPv6 address as jbytearray to target
 67  */
 68 #define COPY_INET6_ADDRESS(env, source, target) \
 69     (*env)-&gt;GetByteArrayRegion(env, source, 0, 16, target)
 70 
 71 /**
 72  * Enable or disable receipt of WSAECONNRESET errors.
 73  */
 74 static void setConnectionReset(SOCKET s, BOOL enable) {
 75     DWORD bytesReturned = 0;
 76     WSAIoctl(s, SIO_UDP_CONNRESET, &amp;enable, sizeof(enable),
 77              NULL, 0, &amp;bytesReturned, NULL, NULL);
 78 }
 79 
 80 jint handleSocketError(JNIEnv *env, int errorValue)
 81 {
 82     NET_ThrowNew(env, errorValue, NULL);
 83     return IOS_THROWN;
 84 }
 85 
<span class="line-added"> 86 static jclass isa_class;        /* java.net.InetSocketAddress */</span>
<span class="line-added"> 87 static jmethodID isa_ctorID;    /* InetSocketAddress(InetAddress, int) */</span>
<span class="line-added"> 88 </span>
 89 JNIEXPORT void JNICALL
 90 Java_sun_nio_ch_Net_initIDs(JNIEnv *env, jclass clazz)
 91 {
<span class="line-modified"> 92      jclass cls = (*env)-&gt;FindClass(env, &quot;java/net/InetSocketAddress&quot;);</span>
<span class="line-added"> 93      CHECK_NULL(cls);</span>
<span class="line-added"> 94      isa_class = (*env)-&gt;NewGlobalRef(env, cls);</span>
<span class="line-added"> 95      if (isa_class == NULL) {</span>
<span class="line-added"> 96          JNU_ThrowOutOfMemoryError(env, NULL);</span>
<span class="line-added"> 97          return;</span>
<span class="line-added"> 98      }</span>
<span class="line-added"> 99      isa_ctorID = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;(Ljava/net/InetAddress;I)V&quot;);</span>
<span class="line-added">100      CHECK_NULL(isa_ctorID);</span>
<span class="line-added">101 </span>
<span class="line-added">102      initInetAddressIDs(env);</span>
103 }
104 
105 JNIEXPORT jboolean JNICALL
106 Java_sun_nio_ch_Net_isIPv6Available0(JNIEnv* env, jclass cl)
107 {
108     /*
109      * Return true if IPv6 is configured
110      */
111     return ipv6_available() ? JNI_TRUE : JNI_FALSE;
112 }
113 
114 JNIEXPORT jboolean JNICALL
115 Java_sun_nio_ch_Net_isReusePortAvailable0(JNIEnv* env, jclass c1)
116 {
117     // SO_REUSEPORT is not supported on Windows
118     return JNI_FALSE;
119 }
120 
121 JNIEXPORT jint JNICALL
122 Java_sun_nio_ch_Net_isExclusiveBindAvailable(JNIEnv *env, jclass clazz) {
123     return 1;
124 }
125 
<span class="line-added">126 JNIEXPORT jboolean JNICALL</span>
<span class="line-added">127 Java_sun_nio_ch_Net_shouldSetBothIPv4AndIPv6Options0(JNIEnv* env, jclass cl)</span>
<span class="line-added">128 {</span>
<span class="line-added">129     /* Set both IPv4 and IPv6 socket options when setting multicast options */</span>
<span class="line-added">130     return JNI_TRUE;</span>
<span class="line-added">131 }</span>
132 
133 JNIEXPORT jboolean JNICALL
134 Java_sun_nio_ch_Net_canIPv6SocketJoinIPv4Group0(JNIEnv* env, jclass cl)
135 {
<span class="line-modified">136     /* IPv6 sockets can join IPv4 multicast groups */</span>
<span class="line-added">137     return JNI_TRUE;</span>
138 }
139 
140 JNIEXPORT jboolean JNICALL
141 Java_sun_nio_ch_Net_canJoin6WithIPv4Group0(JNIEnv* env, jclass cl)
142 {
<span class="line-added">143     /* IPV6_ADD_MEMBERSHIP cannot be used to join IPv4 multicast groups */</span>
<span class="line-added">144     return JNI_FALSE;</span>
<span class="line-added">145 }</span>
<span class="line-added">146 </span>
<span class="line-added">147 JNIEXPORT jboolean JNICALL</span>
<span class="line-added">148 Java_sun_nio_ch_Net_canUseIPv6OptionsWithIPv4LocalAddress0(JNIEnv* env, jclass cl)</span>
<span class="line-added">149 {</span>
<span class="line-added">150     /* IPV6_XXX socket options cannot be used on IPv6 sockets bound to IPv4 address */</span>
151     return JNI_FALSE;
152 }
153 
154 JNIEXPORT jint JNICALL
155 Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,
156                             jboolean stream, jboolean reuse, jboolean fastLoopback)
157 {
158     SOCKET s;
159     int domain = (preferIPv6) ? AF_INET6 : AF_INET;
160 
161     s = socket(domain, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
162     if (s != INVALID_SOCKET) {
163         SetHandleInformation((HANDLE)s, HANDLE_FLAG_INHERIT, 0);
164 
165         /* IPV6_V6ONLY is true by default */
166         if (domain == AF_INET6) {
167             int opt = 0;
168             setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
169                        (const char *)&amp;opt, sizeof(opt));
170         }
</pre>
<hr />
<pre>
203     int rv;
204     int sa_len = 0;
205 
206     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
207         return;
208     }
209 
210     rv = NET_WinBind(fdval(env, fdo), &amp;sa, sa_len, isExclBind);
211     if (rv == SOCKET_ERROR)
212         NET_ThrowNew(env, WSAGetLastError(), &quot;bind&quot;);
213 }
214 
215 JNIEXPORT void JNICALL
216 Java_sun_nio_ch_Net_listen(JNIEnv *env, jclass cl, jobject fdo, jint backlog)
217 {
218     if (listen(fdval(env,fdo), backlog) == SOCKET_ERROR) {
219         NET_ThrowNew(env, WSAGetLastError(), &quot;listen&quot;);
220     }
221 }
222 

223 JNIEXPORT jint JNICALL
224 Java_sun_nio_ch_Net_connect0(JNIEnv *env, jclass clazz, jboolean preferIPv6, jobject fdo,
225                              jobject iao, jint port)
226 {
227     SOCKETADDRESS sa;
228     int rv;
229     int sa_len = 0;
230     SOCKET s = (SOCKET)fdval(env, fdo);
231 
232     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
233         return IOS_THROWN;
234     }
235 
236     rv = connect(s, &amp;sa.sa, sa_len);
237     if (rv != 0) {
238         int err = WSAGetLastError();
239         if (err == WSAEINPROGRESS || err == WSAEWOULDBLOCK) {
240             return IOS_UNAVAILABLE;
241         }
242         NET_ThrowNew(env, err, &quot;connect&quot;);
243         return IOS_THROWN;
244     } else {
245         /* Enable WSAECONNRESET errors when a UDP socket is connected */
246         int type = 0, optlen = sizeof(type);
247         rv = getsockopt(s, SOL_SOCKET, SO_TYPE, (char*)&amp;type, &amp;optlen);
248         if (rv == 0 &amp;&amp; type == SOCK_DGRAM) {
249             setConnectionReset(s, TRUE);
250         }
251     }
252     return 1;
253 }
254 
<span class="line-added">255 JNIEXPORT jint JNICALL</span>
<span class="line-added">256 Java_sun_nio_ch_Net_accept(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,</span>
<span class="line-added">257                            jobjectArray isaa)</span>
<span class="line-added">258 {</span>
<span class="line-added">259     jint fd = fdval(env,fdo);</span>
<span class="line-added">260     jint newfd;</span>
<span class="line-added">261     SOCKETADDRESS sa;</span>
<span class="line-added">262     int addrlen = sizeof(sa);</span>
<span class="line-added">263     jobject remote_ia;</span>
<span class="line-added">264     jint remote_port = 0;</span>
<span class="line-added">265     jobject isa;</span>
<span class="line-added">266 </span>
<span class="line-added">267     memset((char *)&amp;sa, 0, sizeof(sa));</span>
<span class="line-added">268     newfd = (jint) accept(fd, &amp;sa.sa, &amp;addrlen);</span>
<span class="line-added">269     if (newfd == INVALID_SOCKET) {</span>
<span class="line-added">270         int theErr = (jint)WSAGetLastError();</span>
<span class="line-added">271         if (theErr == WSAEWOULDBLOCK) {</span>
<span class="line-added">272             return IOS_UNAVAILABLE;</span>
<span class="line-added">273         }</span>
<span class="line-added">274         JNU_ThrowIOExceptionWithLastError(env, &quot;Accept failed&quot;);</span>
<span class="line-added">275         return IOS_THROWN;</span>
<span class="line-added">276     }</span>
<span class="line-added">277 </span>
<span class="line-added">278     SetHandleInformation((HANDLE)(UINT_PTR)newfd, HANDLE_FLAG_INHERIT, 0);</span>
<span class="line-added">279     setfdval(env, newfdo, newfd);</span>
<span class="line-added">280 </span>
<span class="line-added">281     remote_ia = NET_SockaddrToInetAddress(env, &amp;sa, (int *)&amp;remote_port);</span>
<span class="line-added">282     CHECK_NULL_RETURN(remote_ia, IOS_THROWN);</span>
<span class="line-added">283 </span>
<span class="line-added">284     isa = (*env)-&gt;NewObject(env, isa_class, isa_ctorID, remote_ia, remote_port);</span>
<span class="line-added">285     CHECK_NULL_RETURN(isa, IOS_THROWN);</span>
<span class="line-added">286     (*env)-&gt;SetObjectArrayElement(env, isaa, 0, isa);</span>
<span class="line-added">287 </span>
<span class="line-added">288     return 1;</span>
<span class="line-added">289 }</span>
<span class="line-added">290 </span>
291 JNIEXPORT jint JNICALL
292 Java_sun_nio_ch_Net_localPort(JNIEnv *env, jclass clazz, jobject fdo)
293 {
294     SOCKETADDRESS sa;
295     int sa_len = sizeof(sa);
296 
<span class="line-modified">297     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) == SOCKET_ERROR) {</span>
298         int error = WSAGetLastError();
299         if (error == WSAEINVAL) {
300             return 0;
301         }
302         NET_ThrowNew(env, error, &quot;getsockname&quot;);
303         return IOS_THROWN;
304     }
305     return NET_GetPortFromSockaddr(&amp;sa);
306 }
307 
308 JNIEXPORT jobject JNICALL
309 Java_sun_nio_ch_Net_localInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
310 {
311     SOCKETADDRESS sa;
312     int sa_len = sizeof(sa);
313     int port;
314 
<span class="line-modified">315     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) == SOCKET_ERROR) {</span>
316         NET_ThrowNew(env, WSAGetLastError(), &quot;getsockname&quot;);
317         return NULL;
318     }
319     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
320 }
321 
322 JNIEXPORT jint JNICALL
323 Java_sun_nio_ch_Net_remotePort(JNIEnv *env, jclass clazz, jobject fdo)
324 {
325     SOCKETADDRESS sa;
326     int sa_len = sizeof(sa);
327 
<span class="line-modified">328     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) == SOCKET_ERROR) {</span>
329         int error = WSAGetLastError();
330         if (error == WSAEINVAL) {
331             return 0;
332         }
333         NET_ThrowNew(env, error, &quot;getsockname&quot;);
334         return IOS_THROWN;
335     }
336     return NET_GetPortFromSockaddr(&amp;sa);
337 }
338 
339 JNIEXPORT jobject JNICALL
340 Java_sun_nio_ch_Net_remoteInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
341 {
342     SOCKETADDRESS sa;
343     int sa_len = sizeof(sa);
344     int port;
345 
<span class="line-modified">346     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) == SOCKET_ERROR) {</span>
347         NET_ThrowNew(env, WSAGetLastError(), &quot;getsockname&quot;);
348         return NULL;
349     }
350     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
351 }
352 
353 JNIEXPORT jint JNICALL
354 Java_sun_nio_ch_Net_getIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
355                                   jboolean mayNeedConversion, jint level, jint opt)
356 {
357     int result = 0;
358     struct linger linger;
359     char *arg;
360     int arglen, n;
361 
362     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
363         arg = (char *)&amp;linger;
364         arglen = sizeof(linger);
365     } else {
366         arg = (char *)&amp;result;
367         arglen = sizeof(result);
368     }
369 
370     /**
371      * HACK: IP_TOS is deprecated on Windows and querying the option
372      * returns a protocol error. NET_GetSockOpt handles this and uses
373      * a fallback mechanism. Same applies to IPV6_TCLASS
374      */
375     if ((level == IPPROTO_IP &amp;&amp; opt == IP_TOS) || (level == IPPROTO_IPV6 &amp;&amp; opt == IPV6_TCLASS)) {
376         mayNeedConversion = JNI_TRUE;
377     }
378 
379     if (mayNeedConversion) {
380         n = NET_GetSockOpt(fdval(env, fdo), level, opt, arg, &amp;arglen);
381     } else {
382         n = getsockopt(fdval(env, fdo), level, opt, arg, &amp;arglen);
383     }
<span class="line-modified">384     if (n == SOCKET_ERROR) {</span>
385         handleSocketError(env, WSAGetLastError());
386         return IOS_THROWN;
387     }
388 
389     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER)
390         return linger.l_onoff ? linger.l_linger : -1;
391     else
392         return result;
393 }
394 
395 JNIEXPORT void JNICALL
396 Java_sun_nio_ch_Net_setIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
397                                   jboolean mayNeedConversion, jint level, jint opt, jint arg, jboolean ipv6)
398 {
399     struct linger linger;
400     char *parg;
401     int arglen, n;
402 
403     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
404         parg = (char *)&amp;linger;
</pre>
<hr />
<pre>
408             linger.l_linger = (unsigned short)arg;
409         } else {
410             linger.l_onoff = 0;
411             linger.l_linger = 0;
412         }
413     } else {
414         parg = (char *)&amp;arg;
415         arglen = sizeof(arg);
416     }
417 
418     if (level == IPPROTO_IPV6 &amp;&amp; opt == IPV6_TCLASS) {
419         /* No op */
420         return;
421     }
422 
423     if (mayNeedConversion) {
424         n = NET_SetSockOpt(fdval(env, fdo), level, opt, parg, arglen);
425     } else {
426         n = setsockopt(fdval(env, fdo), level, opt, parg, arglen);
427     }
<span class="line-modified">428     if (n == SOCKET_ERROR)</span>
429         handleSocketError(env, WSAGetLastError());
430 }
431 
432 JNIEXPORT jint JNICALL
433 Java_sun_nio_ch_Net_joinOrDrop4(JNIEnv *env, jobject this, jboolean join, jobject fdo,
434                                 jint group, jint interf, jint source)
435 {
436     struct ip_mreq mreq;
437     struct my_ip_mreq_source mreq_source;
438     int opt, n, optlen;
439     void* optval;
440 
441     if (source == 0) {
442         mreq.imr_multiaddr.s_addr = htonl(group);
443         mreq.imr_interface.s_addr = htonl(interf);
444         opt = (join) ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;
445         optval = (void*)&amp;mreq;
446         optlen = sizeof(mreq);
447     } else {
448         mreq_source.imr_multiaddr.s_addr = htonl(group);
449         mreq_source.imr_sourceaddr.s_addr = htonl(source);
450         mreq_source.imr_interface.s_addr = htonl(interf);
451         opt = (join) ? IP_ADD_SOURCE_MEMBERSHIP : IP_DROP_SOURCE_MEMBERSHIP;
452         optval = (void*)&amp;mreq_source;
453         optlen = sizeof(mreq_source);
454     }
455 
456     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt, optval, optlen);
<span class="line-modified">457     if (n == SOCKET_ERROR) {</span>
458         if (join &amp;&amp; (WSAGetLastError() == WSAENOPROTOOPT))
459             return IOS_UNAVAILABLE;
460         handleSocketError(env, WSAGetLastError());
461     }
462     return 0;
463 }
464 
465 JNIEXPORT jint JNICALL
466 Java_sun_nio_ch_Net_blockOrUnblock4(JNIEnv *env, jobject this, jboolean block, jobject fdo,
467                                    jint group, jint interf, jint source)
468 {
469     struct my_ip_mreq_source mreq_source;
470     int n;
471     int opt = (block) ? IP_BLOCK_SOURCE : IP_UNBLOCK_SOURCE;
472 
473     mreq_source.imr_multiaddr.s_addr = htonl(group);
474     mreq_source.imr_sourceaddr.s_addr = htonl(source);
475     mreq_source.imr_interface.s_addr = htonl(interf);
476 
477     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt,
478                    (void*)&amp;mreq_source, sizeof(mreq_source));
<span class="line-modified">479     if (n == SOCKET_ERROR) {</span>
480         if (block &amp;&amp; (WSAGetLastError() == WSAENOPROTOOPT))
481             return IOS_UNAVAILABLE;
482         handleSocketError(env, WSAGetLastError());
483     }
484     return 0;
485 }
486 
487 /**
488  * Call setsockopt with a IPPROTO_IPV6 level socket option
489  * and a group_source_req structure as the option value. The
490  * given IPv6 group, interface index, and IPv6 source address
491  * are copied into the structure.
492  */
493 static int setGroupSourceReqOption(JNIEnv* env,
494                                    jobject fdo,
495                                    int opt,
496                                    jbyteArray group,
497                                    jint index,
498                                    jbyteArray source)
499 {
</pre>
<hr />
<pre>
514 }
515 
516 JNIEXPORT jint JNICALL
517 Java_sun_nio_ch_Net_joinOrDrop6(JNIEnv *env, jobject this, jboolean join, jobject fdo,
518                                 jbyteArray group, jint index, jbyteArray source)
519 {
520     struct ipv6_mreq mreq6;
521     int n;
522 
523     if (source == NULL) {
524         int opt = (join) ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP;
525         COPY_INET6_ADDRESS(env, group, (jbyte*)&amp;(mreq6.ipv6mr_multiaddr));
526         mreq6.ipv6mr_interface = (int)index;
527         n = setsockopt(fdval(env,fdo), IPPROTO_IPV6, opt,
528                        (void*)&amp;mreq6, sizeof(mreq6));
529     } else {
530         int opt = (join) ? MCAST_JOIN_SOURCE_GROUP : MCAST_LEAVE_SOURCE_GROUP;
531         n = setGroupSourceReqOption(env, fdo, opt, group, index, source);
532     }
533 
<span class="line-modified">534     if (n == SOCKET_ERROR) {</span>
<span class="line-modified">535         handleSocketError(env, WSAGetLastError());</span>
536     }
537     return 0;
538 }
539 
540 JNIEXPORT jint JNICALL
541 Java_sun_nio_ch_Net_blockOrUnblock6(JNIEnv *env, jobject this, jboolean block, jobject fdo,
542                                     jbyteArray group, jint index, jbyteArray source)
543 {
544     int opt = (block) ? MCAST_BLOCK_SOURCE : MCAST_UNBLOCK_SOURCE;
545     int n = setGroupSourceReqOption(env, fdo, opt, group, index, source);
<span class="line-modified">546     if (n == SOCKET_ERROR) {</span>
<span class="line-modified">547         handleSocketError(env, WSAGetLastError());</span>
548     }
549     return 0;
550 }
551 
552 JNIEXPORT void JNICALL
553 Java_sun_nio_ch_Net_setInterface4(JNIEnv* env, jobject this, jobject fdo, jint interf)
554 {
555     struct in_addr in;
556     int arglen = sizeof(struct in_addr);
557     int n;
558 
559     in.s_addr = htonl(interf);
560 
561     n = setsockopt(fdval(env, fdo), IPPROTO_IP, IP_MULTICAST_IF,
562                    (void*)&amp;(in.s_addr), arglen);
<span class="line-modified">563     if (n == SOCKET_ERROR) {</span>
564         handleSocketError(env, WSAGetLastError());
565     }
566 }
567 
568 JNIEXPORT jint JNICALL
569 Java_sun_nio_ch_Net_getInterface4(JNIEnv* env, jobject this, jobject fdo)
570 {
571     struct in_addr in;
572     int arglen = sizeof(struct in_addr);
573     int n;
574 
575     n = getsockopt(fdval(env, fdo), IPPROTO_IP, IP_MULTICAST_IF, (void*)&amp;in, &amp;arglen);
<span class="line-modified">576     if (n == SOCKET_ERROR) {</span>
577         handleSocketError(env, WSAGetLastError());
578         return IOS_THROWN;
579     }
580     return ntohl(in.s_addr);
581 }
582 
583 JNIEXPORT void JNICALL
584 Java_sun_nio_ch_Net_setInterface6(JNIEnv* env, jobject this, jobject fdo, jint index)
585 {
<span class="line-modified">586     DWORD value = (jint)index;</span>
587     int arglen = sizeof(value);
588     int n;
589 
590     n = setsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF,
591                    (void*)&amp;(index), arglen);
<span class="line-modified">592     if (n == SOCKET_ERROR) {</span>
<span class="line-modified">593         handleSocketError(env, WSAGetLastError());</span>
594     }
595 }
596 
597 JNIEXPORT jint JNICALL
598 Java_sun_nio_ch_Net_getInterface6(JNIEnv* env, jobject this, jobject fdo)
599 {
<span class="line-modified">600     DWORD index;</span>
601     int arglen = sizeof(index);
602     int n;
603 
604     n = getsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF, (void*)&amp;index, &amp;arglen);
<span class="line-modified">605     if (n == SOCKET_ERROR) {</span>
<span class="line-modified">606         handleSocketError(env, WSAGetLastError());</span>
607         return -1;
608     }
609     return (jint)index;
610 }
611 
612 JNIEXPORT void JNICALL
613 Java_sun_nio_ch_Net_shutdown(JNIEnv *env, jclass cl, jobject fdo, jint jhow) {
614     int how = (jhow == sun_nio_ch_Net_SHUT_RD) ? SD_RECEIVE :
615         (jhow == sun_nio_ch_Net_SHUT_WR) ? SD_SEND : SD_BOTH;
616     if (shutdown(fdval(env, fdo), how) == SOCKET_ERROR) {
617         NET_ThrowNew(env, WSAGetLastError(), &quot;shutdown&quot;);
618     }
619 }
620 
621 JNIEXPORT jint JNICALL
622 Java_sun_nio_ch_Net_available(JNIEnv *env, jclass cl, jobject fdo)
623 {
624     int count = 0;
625     if (NET_SocketAvailable(fdval(env, fdo), &amp;count) != 0) {
626         handleSocketError(env, WSAGetLastError());
627         return IOS_THROWN;
628     }
629     return (jint) count;
630 }
631 
632 JNIEXPORT jint JNICALL
633 Java_sun_nio_ch_Net_poll(JNIEnv* env, jclass this, jobject fdo, jint events, jlong timeout)
634 {
635     int rv;
636     int revents = 0;
637     struct timeval t;

638     fd_set rd, wr, ex;
639     jint fd = fdval(env, fdo);
640 



641     FD_ZERO(&amp;rd);
642     FD_ZERO(&amp;wr);
643     FD_ZERO(&amp;ex);
644     if (events &amp; POLLIN) {
645         FD_SET(fd, &amp;rd);
646     }
647     if (events &amp; POLLOUT ||
648         events &amp; POLLCONN) {
649         FD_SET(fd, &amp;wr);
650     }
651     FD_SET(fd, &amp;ex);
652 
<span class="line-modified">653     if (timeout &gt;= 0) {</span>
<span class="line-added">654         t.tv_sec = (long)(timeout / 1000);</span>
<span class="line-added">655         t.tv_usec = (timeout % 1000) * 1000;</span>
<span class="line-added">656     }</span>
<span class="line-added">657 </span>
<span class="line-added">658     rv = select(fd+1, &amp;rd, &amp;wr, &amp;ex, (timeout &gt;= 0) ? &amp;t : NULL);</span>
659 
660     /* save last winsock error */
661     if (rv == SOCKET_ERROR) {
<span class="line-modified">662         handleSocketError(env, WSAGetLastError());</span>
663         return IOS_THROWN;
664     } else if (rv &gt;= 0) {
665         rv = 0;
666         if (FD_ISSET(fd, &amp;rd)) {
667             rv |= POLLIN;
668         }
669         if (FD_ISSET(fd, &amp;wr)) {
670             rv |= POLLOUT;
671         }
672         if (FD_ISSET(fd, &amp;ex)) {
673             rv |= POLLERR;
674         }
675     }
676     return rv;
677 }
678 
<span class="line-modified">679 JNIEXPORT jboolean JNICALL</span>
680 Java_sun_nio_ch_Net_pollConnect(JNIEnv* env, jclass this, jobject fdo, jlong timeout)
681 {
682     int optError = 0;
683     int result;
684     int n = sizeof(int);
685     jint fd = fdval(env, fdo);
686     fd_set wr, ex;
687     struct timeval t;
688 
689     FD_ZERO(&amp;wr);
690     FD_ZERO(&amp;ex);
691     FD_SET((u_int)fd, &amp;wr);
692     FD_SET((u_int)fd, &amp;ex);
693 
694     if (timeout &gt;= 0) {
695         t.tv_sec = (long)(timeout / 1000);
696         t.tv_usec = (timeout % 1000) * 1000;
697     }
698 
699     result = select(fd+1, 0, &amp;wr, &amp;ex, (timeout &gt;= 0) ? &amp;t : NULL);
700 
701     if (result == SOCKET_ERROR) {
702         handleSocketError(env, WSAGetLastError());
<span class="line-modified">703         return JNI_FALSE;</span>
704     } else if (result == 0) {
<span class="line-modified">705         return JNI_FALSE;</span>
706     } else {
707         // connection established if writable and no error to check
708         if (FD_ISSET(fd, &amp;wr) &amp;&amp; !FD_ISSET(fd, &amp;ex)) {
<span class="line-modified">709             return JNI_TRUE;</span>
710         }
711         result = getsockopt((SOCKET)fd,
712                             SOL_SOCKET,
713                             SO_ERROR,
714                             (char *)&amp;optError,
715                             &amp;n);
716         if (result == SOCKET_ERROR) {
717             int lastError = WSAGetLastError();
<span class="line-modified">718             if (lastError != WSAEINPROGRESS) {</span>
<span class="line-modified">719                 NET_ThrowNew(env, lastError, &quot;getsockopt&quot;);</span>
720             }
<span class="line-modified">721         } else if (optError != NO_ERROR) {</span>



722             handleSocketError(env, optError);

723         }
<span class="line-modified">724         return JNI_FALSE;</span>
725     }
726 }
727 
728 JNIEXPORT jshort JNICALL
729 Java_sun_nio_ch_Net_pollinValue(JNIEnv *env, jclass this)
730 {
731     return (jshort)POLLIN;
732 }
733 
734 JNIEXPORT jshort JNICALL
735 Java_sun_nio_ch_Net_polloutValue(JNIEnv *env, jclass this)
736 {
737     return (jshort)POLLOUT;
738 }
739 
740 JNIEXPORT jshort JNICALL
741 Java_sun_nio_ch_Net_pollerrValue(JNIEnv *env, jclass this)
742 {
743     return (jshort)POLLERR;
744 }
</pre>
</td>
</tr>
</table>
<center><a href="Iocp.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketDispatcher.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
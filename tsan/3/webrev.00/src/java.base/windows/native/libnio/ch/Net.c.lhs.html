<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/native/libnio/ch/Net.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;windows.h&gt;
 27 #include &lt;winsock2.h&gt;
<a name="1" id="anc1"></a>
 28 #include &quot;jni.h&quot;
 29 #include &quot;jni_util.h&quot;
 30 #include &quot;jvm.h&quot;
 31 #include &quot;jlong.h&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 32 </span>
 33 #include &quot;nio.h&quot;
 34 #include &quot;nio_util.h&quot;
 35 #include &quot;net_util.h&quot;
 36 
 37 #include &quot;sun_nio_ch_Net.h&quot;
 38 #include &quot;sun_nio_ch_PollArrayWrapper.h&quot;
 39 
 40 /**
 41  * Definitions to allow for building with older SDK include files.
 42  */
 43 
 44 #ifndef MCAST_BLOCK_SOURCE
 45 
 46 #define MCAST_BLOCK_SOURCE          43
 47 #define MCAST_UNBLOCK_SOURCE        44
 48 #define MCAST_JOIN_SOURCE_GROUP     45
 49 #define MCAST_LEAVE_SOURCE_GROUP    46
 50 
 51 #endif  /* MCAST_BLOCK_SOURCE */
 52 
 53 struct my_ip_mreq_source {
 54     IN_ADDR imr_multiaddr;
 55     IN_ADDR imr_sourceaddr;
 56     IN_ADDR imr_interface;
 57 };
 58 
 59 struct my_group_source_req {
 60     ULONG gsr_interface;
 61     SOCKADDR_STORAGE gsr_group;
 62     SOCKADDR_STORAGE gsr_source;
 63 };
 64 
 65 /**
 66  * Copy IPv6 address as jbytearray to target
 67  */
 68 #define COPY_INET6_ADDRESS(env, source, target) \
 69     (*env)-&gt;GetByteArrayRegion(env, source, 0, 16, target)
 70 
 71 /**
 72  * Enable or disable receipt of WSAECONNRESET errors.
 73  */
 74 static void setConnectionReset(SOCKET s, BOOL enable) {
 75     DWORD bytesReturned = 0;
 76     WSAIoctl(s, SIO_UDP_CONNRESET, &amp;enable, sizeof(enable),
 77              NULL, 0, &amp;bytesReturned, NULL, NULL);
 78 }
 79 
 80 jint handleSocketError(JNIEnv *env, int errorValue)
 81 {
 82     NET_ThrowNew(env, errorValue, NULL);
 83     return IOS_THROWN;
 84 }
 85 
<a name="3" id="anc3"></a>


 86 JNIEXPORT void JNICALL
 87 Java_sun_nio_ch_Net_initIDs(JNIEnv *env, jclass clazz)
 88 {
<a name="4" id="anc4"></a><span class="line-modified"> 89     initInetAddressIDs(env);</span>










 90 }
 91 
 92 JNIEXPORT jboolean JNICALL
 93 Java_sun_nio_ch_Net_isIPv6Available0(JNIEnv* env, jclass cl)
 94 {
 95     /*
 96      * Return true if IPv6 is configured
 97      */
 98     return ipv6_available() ? JNI_TRUE : JNI_FALSE;
 99 }
100 
101 JNIEXPORT jboolean JNICALL
102 Java_sun_nio_ch_Net_isReusePortAvailable0(JNIEnv* env, jclass c1)
103 {
104     // SO_REUSEPORT is not supported on Windows
105     return JNI_FALSE;
106 }
107 
108 JNIEXPORT jint JNICALL
109 Java_sun_nio_ch_Net_isExclusiveBindAvailable(JNIEnv *env, jclass clazz) {
110     return 1;
111 }
112 
<a name="5" id="anc5"></a>





113 
114 JNIEXPORT jboolean JNICALL
115 Java_sun_nio_ch_Net_canIPv6SocketJoinIPv4Group0(JNIEnv* env, jclass cl)
116 {
<a name="6" id="anc6"></a><span class="line-modified">117     return JNI_FALSE;</span>

118 }
119 
120 JNIEXPORT jboolean JNICALL
121 Java_sun_nio_ch_Net_canJoin6WithIPv4Group0(JNIEnv* env, jclass cl)
122 {
<a name="7" id="anc7"></a>







123     return JNI_FALSE;
124 }
125 
126 JNIEXPORT jint JNICALL
127 Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,
128                             jboolean stream, jboolean reuse, jboolean fastLoopback)
129 {
130     SOCKET s;
131     int domain = (preferIPv6) ? AF_INET6 : AF_INET;
132 
133     s = socket(domain, (stream ? SOCK_STREAM : SOCK_DGRAM), 0);
134     if (s != INVALID_SOCKET) {
135         SetHandleInformation((HANDLE)s, HANDLE_FLAG_INHERIT, 0);
136 
137         /* IPV6_V6ONLY is true by default */
138         if (domain == AF_INET6) {
139             int opt = 0;
140             setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
141                        (const char *)&amp;opt, sizeof(opt));
142         }
143 
144         /* Disable WSAECONNRESET errors for initially unconnected UDP sockets */
145         if (!stream) {
146             setConnectionReset(s, FALSE);
147         }
148 
149     } else {
150         NET_ThrowNew(env, WSAGetLastError(), &quot;socket&quot;);
151     }
152 
153     if (stream &amp;&amp; fastLoopback) {
154         static int loopback_available = 1;
155         if (loopback_available) {
156             int rv = NET_EnableFastTcpLoopback((jint)s);
157             if (rv) {
158                 if (rv == WSAEOPNOTSUPP) {
159                     loopback_available = 0;
160                 } else {
161                     NET_ThrowNew(env, rv, &quot;fastLoopback&quot;);
162                 }
163             }
164         }
165     }
166 
167     return (jint)s;
168 }
169 
170 JNIEXPORT void JNICALL
171 Java_sun_nio_ch_Net_bind0(JNIEnv *env, jclass clazz, jobject fdo, jboolean preferIPv6,
172                           jboolean isExclBind, jobject iao, jint port)
173 {
174     SOCKETADDRESS sa;
175     int rv;
176     int sa_len = 0;
177 
178     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
179         return;
180     }
181 
182     rv = NET_WinBind(fdval(env, fdo), &amp;sa, sa_len, isExclBind);
183     if (rv == SOCKET_ERROR)
184         NET_ThrowNew(env, WSAGetLastError(), &quot;bind&quot;);
185 }
186 
187 JNIEXPORT void JNICALL
188 Java_sun_nio_ch_Net_listen(JNIEnv *env, jclass cl, jobject fdo, jint backlog)
189 {
190     if (listen(fdval(env,fdo), backlog) == SOCKET_ERROR) {
191         NET_ThrowNew(env, WSAGetLastError(), &quot;listen&quot;);
192     }
193 }
194 
<a name="8" id="anc8"></a><span class="line-removed">195 </span>
196 JNIEXPORT jint JNICALL
197 Java_sun_nio_ch_Net_connect0(JNIEnv *env, jclass clazz, jboolean preferIPv6, jobject fdo,
198                              jobject iao, jint port)
199 {
200     SOCKETADDRESS sa;
201     int rv;
202     int sa_len = 0;
203     SOCKET s = (SOCKET)fdval(env, fdo);
204 
205     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
206         return IOS_THROWN;
207     }
208 
209     rv = connect(s, &amp;sa.sa, sa_len);
210     if (rv != 0) {
211         int err = WSAGetLastError();
212         if (err == WSAEINPROGRESS || err == WSAEWOULDBLOCK) {
213             return IOS_UNAVAILABLE;
214         }
215         NET_ThrowNew(env, err, &quot;connect&quot;);
216         return IOS_THROWN;
217     } else {
218         /* Enable WSAECONNRESET errors when a UDP socket is connected */
219         int type = 0, optlen = sizeof(type);
220         rv = getsockopt(s, SOL_SOCKET, SO_TYPE, (char*)&amp;type, &amp;optlen);
221         if (rv == 0 &amp;&amp; type == SOCK_DGRAM) {
222             setConnectionReset(s, TRUE);
223         }
224     }
225     return 1;
226 }
227 
<a name="9" id="anc9"></a>



































228 JNIEXPORT jint JNICALL
229 Java_sun_nio_ch_Net_localPort(JNIEnv *env, jclass clazz, jobject fdo)
230 {
231     SOCKETADDRESS sa;
232     int sa_len = sizeof(sa);
233 
<a name="10" id="anc10"></a><span class="line-modified">234     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
235         int error = WSAGetLastError();
236         if (error == WSAEINVAL) {
237             return 0;
238         }
239         NET_ThrowNew(env, error, &quot;getsockname&quot;);
240         return IOS_THROWN;
241     }
242     return NET_GetPortFromSockaddr(&amp;sa);
243 }
244 
245 JNIEXPORT jobject JNICALL
246 Java_sun_nio_ch_Net_localInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
247 {
248     SOCKETADDRESS sa;
249     int sa_len = sizeof(sa);
250     int port;
251 
<a name="11" id="anc11"></a><span class="line-modified">252     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
253         NET_ThrowNew(env, WSAGetLastError(), &quot;getsockname&quot;);
254         return NULL;
255     }
256     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
257 }
258 
259 JNIEXPORT jint JNICALL
260 Java_sun_nio_ch_Net_remotePort(JNIEnv *env, jclass clazz, jobject fdo)
261 {
262     SOCKETADDRESS sa;
263     int sa_len = sizeof(sa);
264 
<a name="12" id="anc12"></a><span class="line-modified">265     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
266         int error = WSAGetLastError();
267         if (error == WSAEINVAL) {
268             return 0;
269         }
270         NET_ThrowNew(env, error, &quot;getsockname&quot;);
271         return IOS_THROWN;
272     }
273     return NET_GetPortFromSockaddr(&amp;sa);
274 }
275 
276 JNIEXPORT jobject JNICALL
277 Java_sun_nio_ch_Net_remoteInetAddress(JNIEnv *env, jclass clazz, jobject fdo)
278 {
279     SOCKETADDRESS sa;
280     int sa_len = sizeof(sa);
281     int port;
282 
<a name="13" id="anc13"></a><span class="line-modified">283     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
284         NET_ThrowNew(env, WSAGetLastError(), &quot;getsockname&quot;);
285         return NULL;
286     }
287     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
288 }
289 
290 JNIEXPORT jint JNICALL
291 Java_sun_nio_ch_Net_getIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
292                                   jboolean mayNeedConversion, jint level, jint opt)
293 {
294     int result = 0;
295     struct linger linger;
296     char *arg;
297     int arglen, n;
298 
299     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
300         arg = (char *)&amp;linger;
301         arglen = sizeof(linger);
302     } else {
303         arg = (char *)&amp;result;
304         arglen = sizeof(result);
305     }
306 
307     /**
308      * HACK: IP_TOS is deprecated on Windows and querying the option
309      * returns a protocol error. NET_GetSockOpt handles this and uses
310      * a fallback mechanism. Same applies to IPV6_TCLASS
311      */
312     if ((level == IPPROTO_IP &amp;&amp; opt == IP_TOS) || (level == IPPROTO_IPV6 &amp;&amp; opt == IPV6_TCLASS)) {
313         mayNeedConversion = JNI_TRUE;
314     }
315 
316     if (mayNeedConversion) {
317         n = NET_GetSockOpt(fdval(env, fdo), level, opt, arg, &amp;arglen);
318     } else {
319         n = getsockopt(fdval(env, fdo), level, opt, arg, &amp;arglen);
320     }
<a name="14" id="anc14"></a><span class="line-modified">321     if (n &lt; 0) {</span>
322         handleSocketError(env, WSAGetLastError());
323         return IOS_THROWN;
324     }
325 
326     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER)
327         return linger.l_onoff ? linger.l_linger : -1;
328     else
329         return result;
330 }
331 
332 JNIEXPORT void JNICALL
333 Java_sun_nio_ch_Net_setIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
334                                   jboolean mayNeedConversion, jint level, jint opt, jint arg, jboolean ipv6)
335 {
336     struct linger linger;
337     char *parg;
338     int arglen, n;
339 
340     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
341         parg = (char *)&amp;linger;
342         arglen = sizeof(linger);
343         if (arg &gt;= 0) {
344             linger.l_onoff = 1;
345             linger.l_linger = (unsigned short)arg;
346         } else {
347             linger.l_onoff = 0;
348             linger.l_linger = 0;
349         }
350     } else {
351         parg = (char *)&amp;arg;
352         arglen = sizeof(arg);
353     }
354 
355     if (level == IPPROTO_IPV6 &amp;&amp; opt == IPV6_TCLASS) {
356         /* No op */
357         return;
358     }
359 
360     if (mayNeedConversion) {
361         n = NET_SetSockOpt(fdval(env, fdo), level, opt, parg, arglen);
362     } else {
363         n = setsockopt(fdval(env, fdo), level, opt, parg, arglen);
364     }
<a name="15" id="anc15"></a><span class="line-modified">365     if (n &lt; 0)</span>
366         handleSocketError(env, WSAGetLastError());
367 }
368 
369 JNIEXPORT jint JNICALL
370 Java_sun_nio_ch_Net_joinOrDrop4(JNIEnv *env, jobject this, jboolean join, jobject fdo,
371                                 jint group, jint interf, jint source)
372 {
373     struct ip_mreq mreq;
374     struct my_ip_mreq_source mreq_source;
375     int opt, n, optlen;
376     void* optval;
377 
378     if (source == 0) {
379         mreq.imr_multiaddr.s_addr = htonl(group);
380         mreq.imr_interface.s_addr = htonl(interf);
381         opt = (join) ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;
382         optval = (void*)&amp;mreq;
383         optlen = sizeof(mreq);
384     } else {
385         mreq_source.imr_multiaddr.s_addr = htonl(group);
386         mreq_source.imr_sourceaddr.s_addr = htonl(source);
387         mreq_source.imr_interface.s_addr = htonl(interf);
388         opt = (join) ? IP_ADD_SOURCE_MEMBERSHIP : IP_DROP_SOURCE_MEMBERSHIP;
389         optval = (void*)&amp;mreq_source;
390         optlen = sizeof(mreq_source);
391     }
392 
393     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt, optval, optlen);
<a name="16" id="anc16"></a><span class="line-modified">394     if (n &lt; 0) {</span>
395         if (join &amp;&amp; (WSAGetLastError() == WSAENOPROTOOPT))
396             return IOS_UNAVAILABLE;
397         handleSocketError(env, WSAGetLastError());
398     }
399     return 0;
400 }
401 
402 JNIEXPORT jint JNICALL
403 Java_sun_nio_ch_Net_blockOrUnblock4(JNIEnv *env, jobject this, jboolean block, jobject fdo,
404                                    jint group, jint interf, jint source)
405 {
406     struct my_ip_mreq_source mreq_source;
407     int n;
408     int opt = (block) ? IP_BLOCK_SOURCE : IP_UNBLOCK_SOURCE;
409 
410     mreq_source.imr_multiaddr.s_addr = htonl(group);
411     mreq_source.imr_sourceaddr.s_addr = htonl(source);
412     mreq_source.imr_interface.s_addr = htonl(interf);
413 
414     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt,
415                    (void*)&amp;mreq_source, sizeof(mreq_source));
<a name="17" id="anc17"></a><span class="line-modified">416     if (n &lt; 0) {</span>
417         if (block &amp;&amp; (WSAGetLastError() == WSAENOPROTOOPT))
418             return IOS_UNAVAILABLE;
419         handleSocketError(env, WSAGetLastError());
420     }
421     return 0;
422 }
423 
424 /**
425  * Call setsockopt with a IPPROTO_IPV6 level socket option
426  * and a group_source_req structure as the option value. The
427  * given IPv6 group, interface index, and IPv6 source address
428  * are copied into the structure.
429  */
430 static int setGroupSourceReqOption(JNIEnv* env,
431                                    jobject fdo,
432                                    int opt,
433                                    jbyteArray group,
434                                    jint index,
435                                    jbyteArray source)
436 {
437     struct my_group_source_req req;
438     struct sockaddr_in6* sin6;
439 
440     req.gsr_interface = (ULONG)index;
441 
442     sin6 = (struct sockaddr_in6*)&amp;(req.gsr_group);
443     sin6-&gt;sin6_family = AF_INET6;
444     COPY_INET6_ADDRESS(env, group, (jbyte*)&amp;(sin6-&gt;sin6_addr));
445 
446     sin6 = (struct sockaddr_in6*)&amp;(req.gsr_source);
447     sin6-&gt;sin6_family = AF_INET6;
448     COPY_INET6_ADDRESS(env, source, (jbyte*)&amp;(sin6-&gt;sin6_addr));
449 
450     return setsockopt(fdval(env,fdo), IPPROTO_IPV6, opt, (void*)&amp;req, sizeof(req));
451 }
452 
453 JNIEXPORT jint JNICALL
454 Java_sun_nio_ch_Net_joinOrDrop6(JNIEnv *env, jobject this, jboolean join, jobject fdo,
455                                 jbyteArray group, jint index, jbyteArray source)
456 {
457     struct ipv6_mreq mreq6;
458     int n;
459 
460     if (source == NULL) {
461         int opt = (join) ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP;
462         COPY_INET6_ADDRESS(env, group, (jbyte*)&amp;(mreq6.ipv6mr_multiaddr));
463         mreq6.ipv6mr_interface = (int)index;
464         n = setsockopt(fdval(env,fdo), IPPROTO_IPV6, opt,
465                        (void*)&amp;mreq6, sizeof(mreq6));
466     } else {
467         int opt = (join) ? MCAST_JOIN_SOURCE_GROUP : MCAST_LEAVE_SOURCE_GROUP;
468         n = setGroupSourceReqOption(env, fdo, opt, group, index, source);
469     }
470 
<a name="18" id="anc18"></a><span class="line-modified">471     if (n &lt; 0) {</span>
<span class="line-modified">472         handleSocketError(env, errno);</span>
473     }
474     return 0;
475 }
476 
477 JNIEXPORT jint JNICALL
478 Java_sun_nio_ch_Net_blockOrUnblock6(JNIEnv *env, jobject this, jboolean block, jobject fdo,
479                                     jbyteArray group, jint index, jbyteArray source)
480 {
481     int opt = (block) ? MCAST_BLOCK_SOURCE : MCAST_UNBLOCK_SOURCE;
482     int n = setGroupSourceReqOption(env, fdo, opt, group, index, source);
<a name="19" id="anc19"></a><span class="line-modified">483     if (n &lt; 0) {</span>
<span class="line-modified">484         handleSocketError(env, errno);</span>
485     }
486     return 0;
487 }
488 
489 JNIEXPORT void JNICALL
490 Java_sun_nio_ch_Net_setInterface4(JNIEnv* env, jobject this, jobject fdo, jint interf)
491 {
492     struct in_addr in;
493     int arglen = sizeof(struct in_addr);
494     int n;
495 
496     in.s_addr = htonl(interf);
497 
498     n = setsockopt(fdval(env, fdo), IPPROTO_IP, IP_MULTICAST_IF,
499                    (void*)&amp;(in.s_addr), arglen);
<a name="20" id="anc20"></a><span class="line-modified">500     if (n &lt; 0) {</span>
501         handleSocketError(env, WSAGetLastError());
502     }
503 }
504 
505 JNIEXPORT jint JNICALL
506 Java_sun_nio_ch_Net_getInterface4(JNIEnv* env, jobject this, jobject fdo)
507 {
508     struct in_addr in;
509     int arglen = sizeof(struct in_addr);
510     int n;
511 
512     n = getsockopt(fdval(env, fdo), IPPROTO_IP, IP_MULTICAST_IF, (void*)&amp;in, &amp;arglen);
<a name="21" id="anc21"></a><span class="line-modified">513     if (n &lt; 0) {</span>
514         handleSocketError(env, WSAGetLastError());
515         return IOS_THROWN;
516     }
517     return ntohl(in.s_addr);
518 }
519 
520 JNIEXPORT void JNICALL
521 Java_sun_nio_ch_Net_setInterface6(JNIEnv* env, jobject this, jobject fdo, jint index)
522 {
<a name="22" id="anc22"></a><span class="line-modified">523     int value = (jint)index;</span>
524     int arglen = sizeof(value);
525     int n;
526 
527     n = setsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF,
528                    (void*)&amp;(index), arglen);
<a name="23" id="anc23"></a><span class="line-modified">529     if (n &lt; 0) {</span>
<span class="line-modified">530         handleSocketError(env, errno);</span>
531     }
532 }
533 
534 JNIEXPORT jint JNICALL
535 Java_sun_nio_ch_Net_getInterface6(JNIEnv* env, jobject this, jobject fdo)
536 {
<a name="24" id="anc24"></a><span class="line-modified">537     int index;</span>
538     int arglen = sizeof(index);
539     int n;
540 
541     n = getsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF, (void*)&amp;index, &amp;arglen);
<a name="25" id="anc25"></a><span class="line-modified">542     if (n &lt; 0) {</span>
<span class="line-modified">543         handleSocketError(env, errno);</span>
544         return -1;
545     }
546     return (jint)index;
547 }
548 
549 JNIEXPORT void JNICALL
550 Java_sun_nio_ch_Net_shutdown(JNIEnv *env, jclass cl, jobject fdo, jint jhow) {
551     int how = (jhow == sun_nio_ch_Net_SHUT_RD) ? SD_RECEIVE :
552         (jhow == sun_nio_ch_Net_SHUT_WR) ? SD_SEND : SD_BOTH;
553     if (shutdown(fdval(env, fdo), how) == SOCKET_ERROR) {
554         NET_ThrowNew(env, WSAGetLastError(), &quot;shutdown&quot;);
555     }
556 }
557 
558 JNIEXPORT jint JNICALL
559 Java_sun_nio_ch_Net_available(JNIEnv *env, jclass cl, jobject fdo)
560 {
561     int count = 0;
562     if (NET_SocketAvailable(fdval(env, fdo), &amp;count) != 0) {
563         handleSocketError(env, WSAGetLastError());
564         return IOS_THROWN;
565     }
566     return (jint) count;
567 }
568 
569 JNIEXPORT jint JNICALL
570 Java_sun_nio_ch_Net_poll(JNIEnv* env, jclass this, jobject fdo, jint events, jlong timeout)
571 {
572     int rv;
573     int revents = 0;
574     struct timeval t;
<a name="26" id="anc26"></a><span class="line-removed">575     int lastError = 0;</span>
576     fd_set rd, wr, ex;
577     jint fd = fdval(env, fdo);
578 
<a name="27" id="anc27"></a><span class="line-removed">579     t.tv_sec = (long)(timeout / 1000);</span>
<span class="line-removed">580     t.tv_usec = (timeout % 1000) * 1000;</span>
<span class="line-removed">581 </span>
582     FD_ZERO(&amp;rd);
583     FD_ZERO(&amp;wr);
584     FD_ZERO(&amp;ex);
585     if (events &amp; POLLIN) {
586         FD_SET(fd, &amp;rd);
587     }
588     if (events &amp; POLLOUT ||
589         events &amp; POLLCONN) {
590         FD_SET(fd, &amp;wr);
591     }
592     FD_SET(fd, &amp;ex);
593 
<a name="28" id="anc28"></a><span class="line-modified">594     rv = select(fd+1, &amp;rd, &amp;wr, &amp;ex, &amp;t);</span>





595 
596     /* save last winsock error */
597     if (rv == SOCKET_ERROR) {
<a name="29" id="anc29"></a><span class="line-modified">598         handleSocketError(env, lastError);</span>
599         return IOS_THROWN;
600     } else if (rv &gt;= 0) {
601         rv = 0;
602         if (FD_ISSET(fd, &amp;rd)) {
603             rv |= POLLIN;
604         }
605         if (FD_ISSET(fd, &amp;wr)) {
606             rv |= POLLOUT;
607         }
608         if (FD_ISSET(fd, &amp;ex)) {
609             rv |= POLLERR;
610         }
611     }
612     return rv;
613 }
614 
<a name="30" id="anc30"></a><span class="line-modified">615 JNIEXPORT jint JNICALL</span>
616 Java_sun_nio_ch_Net_pollConnect(JNIEnv* env, jclass this, jobject fdo, jlong timeout)
617 {
618     int optError = 0;
619     int result;
620     int n = sizeof(int);
621     jint fd = fdval(env, fdo);
622     fd_set wr, ex;
623     struct timeval t;
624 
625     FD_ZERO(&amp;wr);
626     FD_ZERO(&amp;ex);
627     FD_SET((u_int)fd, &amp;wr);
628     FD_SET((u_int)fd, &amp;ex);
629 
630     if (timeout &gt;= 0) {
631         t.tv_sec = (long)(timeout / 1000);
632         t.tv_usec = (timeout % 1000) * 1000;
633     }
634 
635     result = select(fd+1, 0, &amp;wr, &amp;ex, (timeout &gt;= 0) ? &amp;t : NULL);
636 
637     if (result == SOCKET_ERROR) {
638         handleSocketError(env, WSAGetLastError());
<a name="31" id="anc31"></a><span class="line-modified">639         return IOS_THROWN;</span>
640     } else if (result == 0) {
<a name="32" id="anc32"></a><span class="line-modified">641         return 0;</span>
642     } else {
643         // connection established if writable and no error to check
644         if (FD_ISSET(fd, &amp;wr) &amp;&amp; !FD_ISSET(fd, &amp;ex)) {
<a name="33" id="anc33"></a><span class="line-modified">645             return 1;</span>
646         }
647         result = getsockopt((SOCKET)fd,
648                             SOL_SOCKET,
649                             SO_ERROR,
650                             (char *)&amp;optError,
651                             &amp;n);
652         if (result == SOCKET_ERROR) {
653             int lastError = WSAGetLastError();
<a name="34" id="anc34"></a><span class="line-modified">654             if (lastError == WSAEINPROGRESS) {</span>
<span class="line-modified">655                 return IOS_UNAVAILABLE;</span>
656             }
<a name="35" id="anc35"></a><span class="line-modified">657             NET_ThrowNew(env, lastError, &quot;getsockopt&quot;);</span>
<span class="line-removed">658             return IOS_THROWN;</span>
<span class="line-removed">659         }</span>
<span class="line-removed">660         if (optError != NO_ERROR) {</span>
661             handleSocketError(env, optError);
<a name="36" id="anc36"></a><span class="line-removed">662             return IOS_THROWN;</span>
663         }
<a name="37" id="anc37"></a><span class="line-modified">664         return 0;</span>
665     }
666 }
667 
668 JNIEXPORT jshort JNICALL
669 Java_sun_nio_ch_Net_pollinValue(JNIEnv *env, jclass this)
670 {
671     return (jshort)POLLIN;
672 }
673 
674 JNIEXPORT jshort JNICALL
675 Java_sun_nio_ch_Net_polloutValue(JNIEnv *env, jclass this)
676 {
677     return (jshort)POLLOUT;
678 }
679 
680 JNIEXPORT jshort JNICALL
681 Java_sun_nio_ch_Net_pollerrValue(JNIEnv *env, jclass this)
682 {
683     return (jshort)POLLERR;
684 }
685 
686 JNIEXPORT jshort JNICALL
687 Java_sun_nio_ch_Net_pollhupValue(JNIEnv *env, jclass this)
688 {
689     return (jshort)POLLHUP;
690 }
691 
692 JNIEXPORT jshort JNICALL
693 Java_sun_nio_ch_Net_pollnvalValue(JNIEnv *env, jclass this)
694 {
695     return (jshort)POLLNVAL;
696 }
697 
698 JNIEXPORT jshort JNICALL
699 Java_sun_nio_ch_Net_pollconnValue(JNIEnv *env, jclass this)
700 {
701     return (jshort)POLLCONN;
702 }
703 
704 JNIEXPORT jint JNICALL
705 Java_sun_nio_ch_Net_sendOOB(JNIEnv* env, jclass this, jobject fdo, jbyte b)
706 {
707     int n = send(fdval(env, fdo), (const char*)&amp;b, 1, MSG_OOB);
708     if (n == SOCKET_ERROR) {
709         if (WSAGetLastError() == WSAEWOULDBLOCK) {
710             return IOS_UNAVAILABLE;
711         } else {
712             JNU_ThrowIOExceptionWithLastError(env, &quot;send failed&quot;);
713             return IOS_THROWN;
714         }
715     } else {
716         return n;
717     }
718 }
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
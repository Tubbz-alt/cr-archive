<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/windows/native/libnio/ch/DatagramChannelImpl.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../libnet/net_util_md.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DatagramDispatcher.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnio/ch/DatagramChannelImpl.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 21,55 ***</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
  #include &quot;jni.h&quot;
  #include &quot;jni_util.h&quot;
<span class="line-removed">- #include &quot;jvm.h&quot;</span>
  #include &quot;jlong.h&quot;
<span class="line-modified">! #include &lt;io.h&gt;</span>
<span class="line-removed">- #include &quot;sun_nio_ch_DatagramChannelImpl.h&quot;</span>
  #include &quot;nio.h&quot;
  #include &quot;nio_util.h&quot;
<span class="line-removed">- #include &quot;net_util.h&quot;</span>
<span class="line-removed">- #include &lt;winsock2.h&gt;</span>
<span class="line-removed">- </span>
<span class="line-removed">- static jfieldID dci_senderID;   /* sender in sun.nio.ch.DatagramChannelImpl */</span>
<span class="line-removed">- static jfieldID dci_senderAddrID; /* sender InetAddress in sun.nio.ch.DatagramChannelImpl */</span>
<span class="line-removed">- static jfieldID dci_senderPortID; /* sender port in sun.nio.ch.DatagramChannelImpl */</span>
<span class="line-removed">- static jclass isa_class;        /* java.net.InetSocketAddress */</span>
<span class="line-removed">- static jmethodID isa_ctorID;    /* java.net.InetSocketAddress(InetAddress, int) */</span>
  
<span class="line-modified">! </span>
<span class="line-removed">- JNIEXPORT void JNICALL</span>
<span class="line-removed">- Java_sun_nio_ch_DatagramChannelImpl_initIDs(JNIEnv *env, jclass clazz)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     clazz = (*env)-&gt;FindClass(env, &quot;java/net/InetSocketAddress&quot;);</span>
<span class="line-removed">-     CHECK_NULL(clazz);</span>
<span class="line-removed">-     isa_class = (*env)-&gt;NewGlobalRef(env, clazz);</span>
<span class="line-removed">-     if (isa_class == NULL) {</span>
<span class="line-removed">-         JNU_ThrowOutOfMemoryError(env, NULL);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     isa_ctorID = (*env)-&gt;GetMethodID(env, clazz, &quot;&lt;init&gt;&quot;,</span>
<span class="line-removed">-                                      &quot;(Ljava/net/InetAddress;I)V&quot;);</span>
<span class="line-removed">-     CHECK_NULL(isa_ctorID);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     clazz = (*env)-&gt;FindClass(env, &quot;sun/nio/ch/DatagramChannelImpl&quot;);</span>
<span class="line-removed">-     CHECK_NULL(clazz);</span>
<span class="line-removed">-     dci_senderID = (*env)-&gt;GetFieldID(env, clazz, &quot;sender&quot;,</span>
<span class="line-removed">-                                       &quot;Ljava/net/SocketAddress;&quot;);</span>
<span class="line-removed">-     CHECK_NULL(dci_senderID);</span>
<span class="line-removed">-     dci_senderAddrID = (*env)-&gt;GetFieldID(env, clazz,</span>
<span class="line-removed">-                                           &quot;cachedSenderInetAddress&quot;,</span>
<span class="line-removed">-                                           &quot;Ljava/net/InetAddress;&quot;);</span>
<span class="line-removed">-     CHECK_NULL(dci_senderAddrID);</span>
<span class="line-removed">-     dci_senderPortID = (*env)-&gt;GetFieldID(env, clazz,</span>
<span class="line-removed">-                                           &quot;cachedSenderPort&quot;, &quot;I&quot;);</span>
<span class="line-removed">-     CHECK_NULL(dci_senderPortID);</span>
<span class="line-removed">- }</span>
  
  /*
   * This function &quot;purges&quot; all outstanding ICMP port unreachable packets
   * outstanding on a socket and returns JNI_TRUE if any ICMP messages
   * have been purged. The rational for purging is to emulate normal BSD
<span class="line-new-header">--- 21,20 ---</span>
   * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   * or visit www.oracle.com if you need additional information or have any
   * questions.
   */
  
<span class="line-added">+ #include &lt;winsock2.h&gt;</span>
<span class="line-added">+ </span>
  #include &quot;jni.h&quot;
  #include &quot;jni_util.h&quot;
  #include &quot;jlong.h&quot;
<span class="line-modified">! #include &quot;net_util.h&quot;</span>
  #include &quot;nio.h&quot;
  #include &quot;nio_util.h&quot;
  
<span class="line-modified">! #include &quot;sun_nio_ch_DatagramChannelImpl.h&quot;</span>
  
  /*
   * This function &quot;purges&quot; all outstanding ICMP port unreachable packets
   * outstanding on a socket and returns JNI_TRUE if any ICMP messages
   * have been purged. The rational for purging is to emulate normal BSD
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,11 ***</span>
  
      return got_icmp;
  }
  
  JNIEXPORT void JNICALL
<span class="line-modified">! Java_sun_nio_ch_DatagramChannelImpl_disconnect0(JNIEnv *env, jobject this,</span>
                                                  jobject fdo, jboolean isIPv6)
  {
      jint fd = fdval(env, fdo);
      int rv = 0;
      SOCKETADDRESS sa;
<span class="line-new-header">--- 75,11 ---</span>
  
      return got_icmp;
  }
  
  JNIEXPORT void JNICALL
<span class="line-modified">! Java_sun_nio_ch_DatagramChannelImpl_disconnect0(JNIEnv *env, jclass clazz,</span>
                                                  jobject fdo, jboolean isIPv6)
  {
      jint fd = fdval(env, fdo);
      int rv = 0;
      SOCKETADDRESS sa;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,38 ***</span>
                   NULL, 0, &amp;bytesReturned, NULL, NULL);
      }
  }
  
  JNIEXPORT jint JNICALL
<span class="line-modified">! Java_sun_nio_ch_DatagramChannelImpl_receive0(JNIEnv *env, jobject this,</span>
<span class="line-modified">!                                             jobject fdo, jlong address,</span>
<span class="line-modified">!                                             jint len, jboolean connected)</span>
  {
      jint fd = fdval(env, fdo);
<span class="line-modified">!     void *buf = (void *)jlong_to_ptr(address);</span>
<span class="line-modified">!     SOCKETADDRESS sa;</span>
<span class="line-modified">!     int sa_len = sizeof(sa);</span>
      BOOL retry = FALSE;
      jint n;
<span class="line-removed">-     jobject senderAddr;</span>
  
      do {
          retry = FALSE;
          n = recvfrom((SOCKET)fd,
                       (char *)buf,
                       len,
                       0,
<span class="line-modified">!                      &amp;sa.sa,</span>
                       &amp;sa_len);
  
          if (n == SOCKET_ERROR) {
              int theErr = (jint)WSAGetLastError();
              if (theErr == WSAEMSGSIZE) {
                  /* Spec says the rest of the data will be discarded... */
                  n = len;
              } else if (theErr == WSAECONNRESET) {
<span class="line-modified">!                 purgeOutstandingICMP(env, this, fd);</span>
                  if (connected == JNI_FALSE) {
                      retry = TRUE;
                  } else {
                      JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);
                      return IOS_THROWN;
<span class="line-new-header">--- 98,38 ---</span>
                   NULL, 0, &amp;bytesReturned, NULL, NULL);
      }
  }
  
  JNIEXPORT jint JNICALL
<span class="line-modified">! Java_sun_nio_ch_DatagramChannelImpl_receive0(JNIEnv *env, jclass clazz,</span>
<span class="line-modified">!                                              jobject fdo, jlong bufAddress,</span>
<span class="line-modified">!                                              jint len, jlong senderAddress,</span>
<span class="line-added">+                                              jboolean connected)</span>
  {
      jint fd = fdval(env, fdo);
<span class="line-modified">!     void *buf = (void *)jlong_to_ptr(bufAddress);</span>
<span class="line-modified">!     SOCKETADDRESS *sa = (SOCKETADDRESS *)jlong_to_ptr(senderAddress);</span>
<span class="line-modified">!     int sa_len = sizeof(SOCKETADDRESS);</span>
      BOOL retry = FALSE;
      jint n;
  
      do {
          retry = FALSE;
          n = recvfrom((SOCKET)fd,
                       (char *)buf,
                       len,
                       0,
<span class="line-modified">!                      (struct sockaddr *)sa,</span>
                       &amp;sa_len);
  
          if (n == SOCKET_ERROR) {
              int theErr = (jint)WSAGetLastError();
              if (theErr == WSAEMSGSIZE) {
                  /* Spec says the rest of the data will be discarded... */
                  n = len;
              } else if (theErr == WSAECONNRESET) {
<span class="line-modified">!                 purgeOutstandingICMP(env, clazz, fd);</span>
                  if (connected == JNI_FALSE) {
                      retry = TRUE;
                  } else {
                      JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);
                      return IOS_THROWN;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,62 ***</span>
                  return IOS_UNAVAILABLE;
              } else return handleSocketError(env, theErr);
          }
      } while (retry);
  
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * If the source address and port match the cached address</span>
<span class="line-removed">-      * and port in DatagramChannelImpl then we don&#39;t need to</span>
<span class="line-removed">-      * create InetAddress and InetSocketAddress objects.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     senderAddr = (*env)-&gt;GetObjectField(env, this, dci_senderAddrID);</span>
<span class="line-removed">-     if (senderAddr != NULL) {</span>
<span class="line-removed">-         if (!NET_SockaddrEqualsInetAddress(env, &amp;sa, senderAddr)) {</span>
<span class="line-removed">-             senderAddr = NULL;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             jint port = (*env)-&gt;GetIntField(env, this, dci_senderPortID);</span>
<span class="line-removed">-             if (port != NET_GetPortFromSockaddr(&amp;sa)) {</span>
<span class="line-removed">-                 senderAddr = NULL;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (senderAddr == NULL) {</span>
<span class="line-removed">-         jobject isa = NULL;</span>
<span class="line-removed">-         int port;</span>
<span class="line-removed">-         jobject ia = NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);</span>
<span class="line-removed">-         if (ia != NULL) {</span>
<span class="line-removed">-             isa = (*env)-&gt;NewObject(env, isa_class, isa_ctorID, ia, port);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         CHECK_NULL_RETURN(isa, IOS_THROWN);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // update cachedSenderInetAddress/cachedSenderPort</span>
<span class="line-removed">-         (*env)-&gt;SetObjectField(env, this, dci_senderAddrID, ia);</span>
<span class="line-removed">-         (*env)-&gt;SetIntField(env, this, dci_senderPortID,</span>
<span class="line-removed">-                             NET_GetPortFromSockaddr(&amp;sa));</span>
<span class="line-removed">-         (*env)-&gt;SetObjectField(env, this, dci_senderID, isa);</span>
<span class="line-removed">-     }</span>
      return n;
  }
  
  JNIEXPORT jint JNICALL
<span class="line-modified">! Java_sun_nio_ch_DatagramChannelImpl_send0(JNIEnv *env, jobject this,</span>
<span class="line-modified">!                                           jboolean preferIPv6, jobject fdo,</span>
<span class="line-modified">!                                           jlong address, jint len,</span>
<span class="line-removed">-                                           jobject destAddress, jint destPort)</span>
  {
      jint fd = fdval(env, fdo);
<span class="line-modified">!     void *buf = (void *)jlong_to_ptr(address);</span>
<span class="line-modified">!     SOCKETADDRESS sa;</span>
<span class="line-modified">!     int sa_len = 0;</span>
<span class="line-modified">!     jint rv = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (NET_InetAddressToSockaddr(env, destAddress, destPort, &amp;sa,</span>
<span class="line-removed">-                                   &amp;sa_len, preferIPv6) != 0) {</span>
<span class="line-removed">-       return IOS_THROWN;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     rv = sendto((SOCKET)fd, buf, len, 0, &amp;sa.sa, sa_len);</span>
      if (rv == SOCKET_ERROR) {
          int theErr = (jint)WSAGetLastError();
          if (theErr == WSAEWOULDBLOCK) {
              return IOS_UNAVAILABLE;
          }
<span class="line-new-header">--- 138,25 ---</span>
                  return IOS_UNAVAILABLE;
              } else return handleSocketError(env, theErr);
          }
      } while (retry);
  
      return n;
  }
  
  JNIEXPORT jint JNICALL
<span class="line-modified">! Java_sun_nio_ch_DatagramChannelImpl_send0(JNIEnv *env, jclass clazz,</span>
<span class="line-modified">!                                           jobject fdo, jlong bufAddress, jint len,</span>
<span class="line-modified">!                                           jlong targetAddress, jint targetAddressLen)</span>
  {
      jint fd = fdval(env, fdo);
<span class="line-modified">!     void *buf = (void *)jlong_to_ptr(bufAddress);</span>
<span class="line-modified">!     SOCKETADDRESS *sa = (SOCKETADDRESS *)jlong_to_ptr(targetAddress);</span>
<span class="line-modified">!     int sa_len = targetAddressLen;</span>
<span class="line-modified">!     jint rv;</span>
  
<span class="line-modified">!     rv = sendto((SOCKET)fd, buf, len, 0,(struct sockaddr *)sa, sa_len);</span>
      if (rv == SOCKET_ERROR) {
          int theErr = (jint)WSAGetLastError();
          if (theErr == WSAEWOULDBLOCK) {
              return IOS_UNAVAILABLE;
          }
</pre>
<center><a href="../../libnet/net_util_md.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DatagramDispatcher.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
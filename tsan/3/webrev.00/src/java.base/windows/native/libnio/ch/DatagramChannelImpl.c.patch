diff a/src/java.base/windows/native/libnio/ch/DatagramChannelImpl.c b/src/java.base/windows/native/libnio/ch/DatagramChannelImpl.c
--- a/src/java.base/windows/native/libnio/ch/DatagramChannelImpl.c
+++ b/src/java.base/windows/native/libnio/ch/DatagramChannelImpl.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -21,55 +21,20 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
+#include <winsock2.h>
+
 #include "jni.h"
 #include "jni_util.h"
-#include "jvm.h"
 #include "jlong.h"
-#include <io.h>
-#include "sun_nio_ch_DatagramChannelImpl.h"
+#include "net_util.h"
 #include "nio.h"
 #include "nio_util.h"
-#include "net_util.h"
-#include <winsock2.h>
-
-static jfieldID dci_senderID;   /* sender in sun.nio.ch.DatagramChannelImpl */
-static jfieldID dci_senderAddrID; /* sender InetAddress in sun.nio.ch.DatagramChannelImpl */
-static jfieldID dci_senderPortID; /* sender port in sun.nio.ch.DatagramChannelImpl */
-static jclass isa_class;        /* java.net.InetSocketAddress */
-static jmethodID isa_ctorID;    /* java.net.InetSocketAddress(InetAddress, int) */
 
-
-JNIEXPORT void JNICALL
-Java_sun_nio_ch_DatagramChannelImpl_initIDs(JNIEnv *env, jclass clazz)
-{
-    clazz = (*env)->FindClass(env, "java/net/InetSocketAddress");
-    CHECK_NULL(clazz);
-    isa_class = (*env)->NewGlobalRef(env, clazz);
-    if (isa_class == NULL) {
-        JNU_ThrowOutOfMemoryError(env, NULL);
-        return;
-    }
-    isa_ctorID = (*env)->GetMethodID(env, clazz, "<init>",
-                                     "(Ljava/net/InetAddress;I)V");
-    CHECK_NULL(isa_ctorID);
-
-    clazz = (*env)->FindClass(env, "sun/nio/ch/DatagramChannelImpl");
-    CHECK_NULL(clazz);
-    dci_senderID = (*env)->GetFieldID(env, clazz, "sender",
-                                      "Ljava/net/SocketAddress;");
-    CHECK_NULL(dci_senderID);
-    dci_senderAddrID = (*env)->GetFieldID(env, clazz,
-                                          "cachedSenderInetAddress",
-                                          "Ljava/net/InetAddress;");
-    CHECK_NULL(dci_senderAddrID);
-    dci_senderPortID = (*env)->GetFieldID(env, clazz,
-                                          "cachedSenderPort", "I");
-    CHECK_NULL(dci_senderPortID);
-}
+#include "sun_nio_ch_DatagramChannelImpl.h"
 
 /*
  * This function "purges" all outstanding ICMP port unreachable packets
  * outstanding on a socket and returns JNI_TRUE if any ICMP messages
  * have been purged. The rational for purging is to emulate normal BSD
@@ -110,11 +75,11 @@
 
     return got_icmp;
 }
 
 JNIEXPORT void JNICALL
-Java_sun_nio_ch_DatagramChannelImpl_disconnect0(JNIEnv *env, jobject this,
+Java_sun_nio_ch_DatagramChannelImpl_disconnect0(JNIEnv *env, jclass clazz,
                                                 jobject fdo, jboolean isIPv6)
 {
     jint fd = fdval(env, fdo);
     int rv = 0;
     SOCKETADDRESS sa;
@@ -133,38 +98,38 @@
                  NULL, 0, &bytesReturned, NULL, NULL);
     }
 }
 
 JNIEXPORT jint JNICALL
-Java_sun_nio_ch_DatagramChannelImpl_receive0(JNIEnv *env, jobject this,
-                                            jobject fdo, jlong address,
-                                            jint len, jboolean connected)
+Java_sun_nio_ch_DatagramChannelImpl_receive0(JNIEnv *env, jclass clazz,
+                                             jobject fdo, jlong bufAddress,
+                                             jint len, jlong senderAddress,
+                                             jboolean connected)
 {
     jint fd = fdval(env, fdo);
-    void *buf = (void *)jlong_to_ptr(address);
-    SOCKETADDRESS sa;
-    int sa_len = sizeof(sa);
+    void *buf = (void *)jlong_to_ptr(bufAddress);
+    SOCKETADDRESS *sa = (SOCKETADDRESS *)jlong_to_ptr(senderAddress);
+    int sa_len = sizeof(SOCKETADDRESS);
     BOOL retry = FALSE;
     jint n;
-    jobject senderAddr;
 
     do {
         retry = FALSE;
         n = recvfrom((SOCKET)fd,
                      (char *)buf,
                      len,
                      0,
-                     &sa.sa,
+                     (struct sockaddr *)sa,
                      &sa_len);
 
         if (n == SOCKET_ERROR) {
             int theErr = (jint)WSAGetLastError();
             if (theErr == WSAEMSGSIZE) {
                 /* Spec says the rest of the data will be discarded... */
                 n = len;
             } else if (theErr == WSAECONNRESET) {
-                purgeOutstandingICMP(env, this, fd);
+                purgeOutstandingICMP(env, clazz, fd);
                 if (connected == JNI_FALSE) {
                     retry = TRUE;
                 } else {
                     JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
                     return IOS_THROWN;
@@ -173,62 +138,25 @@
                 return IOS_UNAVAILABLE;
             } else return handleSocketError(env, theErr);
         }
     } while (retry);
 
-    /*
-     * If the source address and port match the cached address
-     * and port in DatagramChannelImpl then we don't need to
-     * create InetAddress and InetSocketAddress objects.
-     */
-    senderAddr = (*env)->GetObjectField(env, this, dci_senderAddrID);
-    if (senderAddr != NULL) {
-        if (!NET_SockaddrEqualsInetAddress(env, &sa, senderAddr)) {
-            senderAddr = NULL;
-        } else {
-            jint port = (*env)->GetIntField(env, this, dci_senderPortID);
-            if (port != NET_GetPortFromSockaddr(&sa)) {
-                senderAddr = NULL;
-            }
-        }
-    }
-    if (senderAddr == NULL) {
-        jobject isa = NULL;
-        int port;
-        jobject ia = NET_SockaddrToInetAddress(env, &sa, &port);
-        if (ia != NULL) {
-            isa = (*env)->NewObject(env, isa_class, isa_ctorID, ia, port);
-        }
-        CHECK_NULL_RETURN(isa, IOS_THROWN);
-
-        // update cachedSenderInetAddress/cachedSenderPort
-        (*env)->SetObjectField(env, this, dci_senderAddrID, ia);
-        (*env)->SetIntField(env, this, dci_senderPortID,
-                            NET_GetPortFromSockaddr(&sa));
-        (*env)->SetObjectField(env, this, dci_senderID, isa);
-    }
     return n;
 }
 
 JNIEXPORT jint JNICALL
-Java_sun_nio_ch_DatagramChannelImpl_send0(JNIEnv *env, jobject this,
-                                          jboolean preferIPv6, jobject fdo,
-                                          jlong address, jint len,
-                                          jobject destAddress, jint destPort)
+Java_sun_nio_ch_DatagramChannelImpl_send0(JNIEnv *env, jclass clazz,
+                                          jobject fdo, jlong bufAddress, jint len,
+                                          jlong targetAddress, jint targetAddressLen)
 {
     jint fd = fdval(env, fdo);
-    void *buf = (void *)jlong_to_ptr(address);
-    SOCKETADDRESS sa;
-    int sa_len = 0;
-    jint rv = 0;
-
-    if (NET_InetAddressToSockaddr(env, destAddress, destPort, &sa,
-                                  &sa_len, preferIPv6) != 0) {
-      return IOS_THROWN;
-    }
+    void *buf = (void *)jlong_to_ptr(bufAddress);
+    SOCKETADDRESS *sa = (SOCKETADDRESS *)jlong_to_ptr(targetAddress);
+    int sa_len = targetAddressLen;
+    jint rv;
 
-    rv = sendto((SOCKET)fd, buf, len, 0, &sa.sa, sa_len);
+    rv = sendto((SOCKET)fd, buf, len, 0,(struct sockaddr *)sa, sa_len);
     if (rv == SOCKET_ERROR) {
         int theErr = (jint)WSAGetLastError();
         if (theErr == WSAEWOULDBLOCK) {
             return IOS_UNAVAILABLE;
         }

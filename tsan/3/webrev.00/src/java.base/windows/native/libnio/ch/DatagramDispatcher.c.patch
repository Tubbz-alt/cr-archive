diff a/src/java.base/windows/native/libnio/ch/DatagramDispatcher.c b/src/java.base/windows/native/libnio/ch/DatagramDispatcher.c
--- a/src/java.base/windows/native/libnio/ch/DatagramDispatcher.c
+++ b/src/java.base/windows/native/libnio/ch/DatagramDispatcher.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -21,33 +21,31 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-/*
- */
-
 #include <windows.h>
 #include <winsock2.h>
 #include <ctype.h>
+
 #include "jni.h"
 #include "jni_util.h"
 #include "jvm.h"
 #include "jlong.h"
-#include "sun_nio_ch_DatagramDispatcher.h"
-
 #include "nio.h"
 #include "nio_util.h"
 
+#include "sun_nio_ch_DatagramDispatcher.h"
+
 
 /**************************************************************
  * DatagramDispatcher.c
  */
 
 JNIEXPORT jint JNICALL
 Java_sun_nio_ch_DatagramDispatcher_read0(JNIEnv *env, jclass clazz, jobject fdo,
-                                      jlong address, jint len)
+                                         jlong address, jint len)
 {
     /* set up */
     int i = 0;
     DWORD read = 0;
     DWORD flags = 0;
@@ -67,20 +65,22 @@
             0,              /* no overlapped sockets */
             0);             /* no completion routine */
 
     if (i == SOCKET_ERROR) {
         int theErr = (jint)WSAGetLastError();
-        if (theErr == WSAEWOULDBLOCK) {
-            return IOS_UNAVAILABLE;
-        }
-        if (theErr == WSAECONNRESET) {
-            purgeOutstandingICMP(env, clazz, fd);
-            JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
+        if (theErr != WSAEMSGSIZE) {
+            if (theErr == WSAEWOULDBLOCK) {
+                return IOS_UNAVAILABLE;
+            }
+            if (theErr == WSAECONNRESET) {
+                purgeOutstandingICMP(env, clazz, fd);
+                JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
+                return IOS_THROWN;
+            }
+            JNU_ThrowIOExceptionWithLastError(env, "WSARecv failed");
             return IOS_THROWN;
         }
-        JNU_ThrowIOExceptionWithLastError(env, "Write failed");
-        return IOS_THROWN;
     }
 
     return convertReturnVal(env, (jint)read, JNI_TRUE);
 }
 
@@ -102,11 +102,11 @@
 
     /* copy iovec into WSABUF */
     for(i=0; i<len; i++) {
         bufs[i].buf = (char *)iovp[i].iov_base;
         bufs[i].len = (u_long)iovp[i].iov_len;
-    }
+     }
 
     /* read into the buffers */
     i = WSARecv((SOCKET)fd, /* Socket */
             bufs,           /* pointers to the buffers */
             (DWORD)len,     /* number of buffers to process */
@@ -118,20 +118,22 @@
     /* clean up */
     free(bufs);
 
     if (i != 0) {
         int theErr = (jint)WSAGetLastError();
-        if (theErr == WSAEWOULDBLOCK) {
-            return IOS_UNAVAILABLE;
-        }
-        if (theErr == WSAECONNRESET) {
-            purgeOutstandingICMP(env, clazz, fd);
-            JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
+        if (theErr != WSAEMSGSIZE) {
+            if (theErr == WSAEWOULDBLOCK) {
+                return IOS_UNAVAILABLE;
+            }
+            if (theErr == WSAECONNRESET) {
+                purgeOutstandingICMP(env, clazz, fd);
+                JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
+                return IOS_THROWN;
+            }
+            JNU_ThrowIOExceptionWithLastError(env, "WSARecv failed");
             return IOS_THROWN;
         }
-        JNU_ThrowIOExceptionWithLastError(env, "Write failed");
-        return IOS_THROWN;
     }
 
     return convertLongReturnVal(env, (jlong)read, JNI_TRUE);
 }
 
@@ -167,20 +169,20 @@
         if (theErr == WSAECONNRESET) {
             purgeOutstandingICMP(env, clazz, fd);
             JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
             return IOS_THROWN;
         }
-        JNU_ThrowIOExceptionWithLastError(env, "Write failed");
+        JNU_ThrowIOExceptionWithLastError(env, "WSASend failed");
         return IOS_THROWN;
     }
 
     return convertReturnVal(env, (jint)written, JNI_FALSE);
 }
 
 JNIEXPORT jlong JNICALL
 Java_sun_nio_ch_DatagramDispatcher_writev0(JNIEnv *env, jclass clazz,
-                                         jobject fdo, jlong address, jint len)
+                                           jobject fdo, jlong address, jint len)
 {
     /* set up */
     int i = 0;
     DWORD written = 0;
     jint fd = fdval(env, fdo);
@@ -217,11 +219,11 @@
         if (theErr == WSAECONNRESET) {
             purgeOutstandingICMP(env, clazz, fd);
             JNU_ThrowByName(env, JNU_JAVANETPKG "PortUnreachableException", 0);
             return IOS_THROWN;
         }
-        JNU_ThrowIOExceptionWithLastError(env, "Write failed");
+        JNU_ThrowIOExceptionWithLastError(env, "WSASend failed");
         return IOS_THROWN;
     }
 
     return convertLongReturnVal(env, (jlong)written, JNI_FALSE);
 }

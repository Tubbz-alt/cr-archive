<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libnio/ch/DatagramDispatcher.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramChannelImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileChannelImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnio/ch/DatagramDispatcher.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
<span class="line-removed"> 26 /*</span>
<span class="line-removed"> 27  */</span>
<span class="line-removed"> 28 </span>
 29 #include &lt;windows.h&gt;
 30 #include &lt;winsock2.h&gt;
 31 #include &lt;ctype.h&gt;

 32 #include &quot;jni.h&quot;
 33 #include &quot;jni_util.h&quot;
 34 #include &quot;jvm.h&quot;
 35 #include &quot;jlong.h&quot;
<span class="line-removed"> 36 #include &quot;sun_nio_ch_DatagramDispatcher.h&quot;</span>
<span class="line-removed"> 37 </span>
 38 #include &quot;nio.h&quot;
 39 #include &quot;nio_util.h&quot;
 40 


 41 
 42 /**************************************************************
 43  * DatagramDispatcher.c
 44  */
 45 
 46 JNIEXPORT jint JNICALL
 47 Java_sun_nio_ch_DatagramDispatcher_read0(JNIEnv *env, jclass clazz, jobject fdo,
<span class="line-modified"> 48                                       jlong address, jint len)</span>
 49 {
 50     /* set up */
 51     int i = 0;
 52     DWORD read = 0;
 53     DWORD flags = 0;
 54     jint fd = fdval(env, fdo);
 55     WSABUF buf;
 56 
 57     /* destination buffer and size */
 58     buf.buf = (char *)address;
 59     buf.len = (u_long)len;
 60 
 61     /* read into the buffers */
 62     i = WSARecv((SOCKET)fd, /* Socket */
 63             &amp;buf,           /* pointers to the buffers */
 64             (DWORD)1,       /* number of buffers to process */
 65             &amp;read,          /* receives number of bytes read */
 66             &amp;flags,         /* no flags */
 67             0,              /* no overlapped sockets */
 68             0);             /* no completion routine */
 69 
 70     if (i == SOCKET_ERROR) {
 71         int theErr = (jint)WSAGetLastError();
<span class="line-modified"> 72         if (theErr == WSAEWOULDBLOCK) {</span>
<span class="line-modified"> 73             return IOS_UNAVAILABLE;</span>
<span class="line-modified"> 74         }</span>
<span class="line-modified"> 75         if (theErr == WSAECONNRESET) {</span>
<span class="line-modified"> 76             purgeOutstandingICMP(env, clazz, fd);</span>
<span class="line-modified"> 77             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);</span>




 78             return IOS_THROWN;
 79         }
<span class="line-removed"> 80         JNU_ThrowIOExceptionWithLastError(env, &quot;Write failed&quot;);</span>
<span class="line-removed"> 81         return IOS_THROWN;</span>
 82     }
 83 
 84     return convertReturnVal(env, (jint)read, JNI_TRUE);
 85 }
 86 
 87 JNIEXPORT jlong JNICALL
 88 Java_sun_nio_ch_DatagramDispatcher_readv0(JNIEnv *env, jclass clazz,
 89                                           jobject fdo, jlong address, jint len)
 90 {
 91     /* set up */
 92     int i = 0;
 93     DWORD read = 0;
 94     DWORD flags = 0;
 95     jint fd = fdval(env, fdo);
 96     struct iovec *iovp = (struct iovec *)address;
 97     WSABUF *bufs = malloc(len * sizeof(WSABUF));
 98     if (bufs == NULL) {
 99         JNU_ThrowOutOfMemoryError(env, NULL);
100         return IOS_THROWN;
101     }
102 
103     /* copy iovec into WSABUF */
104     for(i=0; i&lt;len; i++) {
105         bufs[i].buf = (char *)iovp[i].iov_base;
106         bufs[i].len = (u_long)iovp[i].iov_len;
<span class="line-modified">107     }</span>
108 
109     /* read into the buffers */
110     i = WSARecv((SOCKET)fd, /* Socket */
111             bufs,           /* pointers to the buffers */
112             (DWORD)len,     /* number of buffers to process */
113             &amp;read,          /* receives number of bytes read */
114             &amp;flags,         /* no flags */
115             0,              /* no overlapped sockets */
116             0);             /* no completion routine */
117 
118     /* clean up */
119     free(bufs);
120 
121     if (i != 0) {
122         int theErr = (jint)WSAGetLastError();
<span class="line-modified">123         if (theErr == WSAEWOULDBLOCK) {</span>
<span class="line-modified">124             return IOS_UNAVAILABLE;</span>
<span class="line-modified">125         }</span>
<span class="line-modified">126         if (theErr == WSAECONNRESET) {</span>
<span class="line-modified">127             purgeOutstandingICMP(env, clazz, fd);</span>
<span class="line-modified">128             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);</span>




129             return IOS_THROWN;
130         }
<span class="line-removed">131         JNU_ThrowIOExceptionWithLastError(env, &quot;Write failed&quot;);</span>
<span class="line-removed">132         return IOS_THROWN;</span>
133     }
134 
135     return convertLongReturnVal(env, (jlong)read, JNI_TRUE);
136 }
137 
138 
139 JNIEXPORT jint JNICALL
140 Java_sun_nio_ch_DatagramDispatcher_write0(JNIEnv *env, jclass clazz,
141                                           jobject fdo, jlong address, jint len)
142 {
143     /* set up */
144     int i = 0;
145     DWORD written = 0;
146     jint fd = fdval(env, fdo);
147     WSABUF buf;
148 
149     /* copy iovec into WSABUF */
150     buf.buf = (char *)address;
151     buf.len = (u_long)len;
152 
153     /* read into the buffers */
154     i = WSASend((SOCKET)fd, /* Socket */
155             &amp;buf,           /* pointers to the buffers */
156             (DWORD)1,       /* number of buffers to process */
157             &amp;written,       /* receives number of bytes written */
158             0,              /* no flags */
159             0,              /* no overlapped sockets */
160             0);             /* no completion routine */
161 
162     if (i == SOCKET_ERROR) {
163         int theErr = (jint)WSAGetLastError();
164         if (theErr == WSAEWOULDBLOCK) {
165             return IOS_UNAVAILABLE;
166         }
167         if (theErr == WSAECONNRESET) {
168             purgeOutstandingICMP(env, clazz, fd);
169             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);
170             return IOS_THROWN;
171         }
<span class="line-modified">172         JNU_ThrowIOExceptionWithLastError(env, &quot;Write failed&quot;);</span>
173         return IOS_THROWN;
174     }
175 
176     return convertReturnVal(env, (jint)written, JNI_FALSE);
177 }
178 
179 JNIEXPORT jlong JNICALL
180 Java_sun_nio_ch_DatagramDispatcher_writev0(JNIEnv *env, jclass clazz,
<span class="line-modified">181                                          jobject fdo, jlong address, jint len)</span>
182 {
183     /* set up */
184     int i = 0;
185     DWORD written = 0;
186     jint fd = fdval(env, fdo);
187     struct iovec *iovp = (struct iovec *)address;
188     WSABUF *bufs = malloc(len * sizeof(WSABUF));
189     if (bufs == NULL) {
190         JNU_ThrowOutOfMemoryError(env, NULL);
191         return IOS_THROWN;
192     }
193 
194     /* copy iovec into WSABUF */
195     for(i=0; i&lt;len; i++) {
196         bufs[i].buf = (char *)iovp[i].iov_base;
197         bufs[i].len = (u_long)iovp[i].iov_len;
198     }
199 
200     /* read into the buffers */
201     i = WSASend((SOCKET)fd, /* Socket */
202             bufs,           /* pointers to the buffers */
203             (DWORD)len,     /* number of buffers to process */
204             &amp;written,       /* receives number of bytes written */
205             0,              /* no flags */
206             0,              /* no overlapped sockets */
207             0);             /* no completion routine */
208 
209     /* clean up */
210     free(bufs);
211 
212     if (i != 0) {
213         int theErr = (jint)WSAGetLastError();
214         if (theErr == WSAEWOULDBLOCK) {
215             return IOS_UNAVAILABLE;
216         }
217         if (theErr == WSAECONNRESET) {
218             purgeOutstandingICMP(env, clazz, fd);
219             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);
220             return IOS_THROWN;
221         }
<span class="line-modified">222         JNU_ThrowIOExceptionWithLastError(env, &quot;Write failed&quot;);</span>
223         return IOS_THROWN;
224     }
225 
226     return convertLongReturnVal(env, (jlong)written, JNI_FALSE);
227 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 



 26 #include &lt;windows.h&gt;
 27 #include &lt;winsock2.h&gt;
 28 #include &lt;ctype.h&gt;
<span class="line-added"> 29 </span>
 30 #include &quot;jni.h&quot;
 31 #include &quot;jni_util.h&quot;
 32 #include &quot;jvm.h&quot;
 33 #include &quot;jlong.h&quot;


 34 #include &quot;nio.h&quot;
 35 #include &quot;nio_util.h&quot;
 36 
<span class="line-added"> 37 #include &quot;sun_nio_ch_DatagramDispatcher.h&quot;</span>
<span class="line-added"> 38 </span>
 39 
 40 /**************************************************************
 41  * DatagramDispatcher.c
 42  */
 43 
 44 JNIEXPORT jint JNICALL
 45 Java_sun_nio_ch_DatagramDispatcher_read0(JNIEnv *env, jclass clazz, jobject fdo,
<span class="line-modified"> 46                                          jlong address, jint len)</span>
 47 {
 48     /* set up */
 49     int i = 0;
 50     DWORD read = 0;
 51     DWORD flags = 0;
 52     jint fd = fdval(env, fdo);
 53     WSABUF buf;
 54 
 55     /* destination buffer and size */
 56     buf.buf = (char *)address;
 57     buf.len = (u_long)len;
 58 
 59     /* read into the buffers */
 60     i = WSARecv((SOCKET)fd, /* Socket */
 61             &amp;buf,           /* pointers to the buffers */
 62             (DWORD)1,       /* number of buffers to process */
 63             &amp;read,          /* receives number of bytes read */
 64             &amp;flags,         /* no flags */
 65             0,              /* no overlapped sockets */
 66             0);             /* no completion routine */
 67 
 68     if (i == SOCKET_ERROR) {
 69         int theErr = (jint)WSAGetLastError();
<span class="line-modified"> 70         if (theErr != WSAEMSGSIZE) {</span>
<span class="line-modified"> 71             if (theErr == WSAEWOULDBLOCK) {</span>
<span class="line-modified"> 72                 return IOS_UNAVAILABLE;</span>
<span class="line-modified"> 73             }</span>
<span class="line-modified"> 74             if (theErr == WSAECONNRESET) {</span>
<span class="line-modified"> 75                 purgeOutstandingICMP(env, clazz, fd);</span>
<span class="line-added"> 76                 JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);</span>
<span class="line-added"> 77                 return IOS_THROWN;</span>
<span class="line-added"> 78             }</span>
<span class="line-added"> 79             JNU_ThrowIOExceptionWithLastError(env, &quot;WSARecv failed&quot;);</span>
 80             return IOS_THROWN;
 81         }


 82     }
 83 
 84     return convertReturnVal(env, (jint)read, JNI_TRUE);
 85 }
 86 
 87 JNIEXPORT jlong JNICALL
 88 Java_sun_nio_ch_DatagramDispatcher_readv0(JNIEnv *env, jclass clazz,
 89                                           jobject fdo, jlong address, jint len)
 90 {
 91     /* set up */
 92     int i = 0;
 93     DWORD read = 0;
 94     DWORD flags = 0;
 95     jint fd = fdval(env, fdo);
 96     struct iovec *iovp = (struct iovec *)address;
 97     WSABUF *bufs = malloc(len * sizeof(WSABUF));
 98     if (bufs == NULL) {
 99         JNU_ThrowOutOfMemoryError(env, NULL);
100         return IOS_THROWN;
101     }
102 
103     /* copy iovec into WSABUF */
104     for(i=0; i&lt;len; i++) {
105         bufs[i].buf = (char *)iovp[i].iov_base;
106         bufs[i].len = (u_long)iovp[i].iov_len;
<span class="line-modified">107      }</span>
108 
109     /* read into the buffers */
110     i = WSARecv((SOCKET)fd, /* Socket */
111             bufs,           /* pointers to the buffers */
112             (DWORD)len,     /* number of buffers to process */
113             &amp;read,          /* receives number of bytes read */
114             &amp;flags,         /* no flags */
115             0,              /* no overlapped sockets */
116             0);             /* no completion routine */
117 
118     /* clean up */
119     free(bufs);
120 
121     if (i != 0) {
122         int theErr = (jint)WSAGetLastError();
<span class="line-modified">123         if (theErr != WSAEMSGSIZE) {</span>
<span class="line-modified">124             if (theErr == WSAEWOULDBLOCK) {</span>
<span class="line-modified">125                 return IOS_UNAVAILABLE;</span>
<span class="line-modified">126             }</span>
<span class="line-modified">127             if (theErr == WSAECONNRESET) {</span>
<span class="line-modified">128                 purgeOutstandingICMP(env, clazz, fd);</span>
<span class="line-added">129                 JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);</span>
<span class="line-added">130                 return IOS_THROWN;</span>
<span class="line-added">131             }</span>
<span class="line-added">132             JNU_ThrowIOExceptionWithLastError(env, &quot;WSARecv failed&quot;);</span>
133             return IOS_THROWN;
134         }


135     }
136 
137     return convertLongReturnVal(env, (jlong)read, JNI_TRUE);
138 }
139 
140 
141 JNIEXPORT jint JNICALL
142 Java_sun_nio_ch_DatagramDispatcher_write0(JNIEnv *env, jclass clazz,
143                                           jobject fdo, jlong address, jint len)
144 {
145     /* set up */
146     int i = 0;
147     DWORD written = 0;
148     jint fd = fdval(env, fdo);
149     WSABUF buf;
150 
151     /* copy iovec into WSABUF */
152     buf.buf = (char *)address;
153     buf.len = (u_long)len;
154 
155     /* read into the buffers */
156     i = WSASend((SOCKET)fd, /* Socket */
157             &amp;buf,           /* pointers to the buffers */
158             (DWORD)1,       /* number of buffers to process */
159             &amp;written,       /* receives number of bytes written */
160             0,              /* no flags */
161             0,              /* no overlapped sockets */
162             0);             /* no completion routine */
163 
164     if (i == SOCKET_ERROR) {
165         int theErr = (jint)WSAGetLastError();
166         if (theErr == WSAEWOULDBLOCK) {
167             return IOS_UNAVAILABLE;
168         }
169         if (theErr == WSAECONNRESET) {
170             purgeOutstandingICMP(env, clazz, fd);
171             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);
172             return IOS_THROWN;
173         }
<span class="line-modified">174         JNU_ThrowIOExceptionWithLastError(env, &quot;WSASend failed&quot;);</span>
175         return IOS_THROWN;
176     }
177 
178     return convertReturnVal(env, (jint)written, JNI_FALSE);
179 }
180 
181 JNIEXPORT jlong JNICALL
182 Java_sun_nio_ch_DatagramDispatcher_writev0(JNIEnv *env, jclass clazz,
<span class="line-modified">183                                            jobject fdo, jlong address, jint len)</span>
184 {
185     /* set up */
186     int i = 0;
187     DWORD written = 0;
188     jint fd = fdval(env, fdo);
189     struct iovec *iovp = (struct iovec *)address;
190     WSABUF *bufs = malloc(len * sizeof(WSABUF));
191     if (bufs == NULL) {
192         JNU_ThrowOutOfMemoryError(env, NULL);
193         return IOS_THROWN;
194     }
195 
196     /* copy iovec into WSABUF */
197     for(i=0; i&lt;len; i++) {
198         bufs[i].buf = (char *)iovp[i].iov_base;
199         bufs[i].len = (u_long)iovp[i].iov_len;
200     }
201 
202     /* read into the buffers */
203     i = WSASend((SOCKET)fd, /* Socket */
204             bufs,           /* pointers to the buffers */
205             (DWORD)len,     /* number of buffers to process */
206             &amp;written,       /* receives number of bytes written */
207             0,              /* no flags */
208             0,              /* no overlapped sockets */
209             0);             /* no completion routine */
210 
211     /* clean up */
212     free(bufs);
213 
214     if (i != 0) {
215         int theErr = (jint)WSAGetLastError();
216         if (theErr == WSAEWOULDBLOCK) {
217             return IOS_UNAVAILABLE;
218         }
219         if (theErr == WSAECONNRESET) {
220             purgeOutstandingICMP(env, clazz, fd);
221             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;PortUnreachableException&quot;, 0);
222             return IOS_THROWN;
223         }
<span class="line-modified">224         JNU_ThrowIOExceptionWithLastError(env, &quot;WSASend failed&quot;);</span>
225         return IOS_THROWN;
226     }
227 
228     return convertLongReturnVal(env, (jlong)written, JNI_FALSE);
229 }
</pre>
</td>
</tr>
</table>
<center><a href="DatagramChannelImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileChannelImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
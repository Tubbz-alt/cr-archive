<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/native/libnio/ch/SocketDispatcher.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Net.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="WindowsAsynchronousFileChannelImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/native/libnio/ch/SocketDispatcher.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 55         len = MAX_BUFFER_SIZE;
 56 
 57     /* destination buffer and size */
 58     buf.buf = (char *)address;
 59     buf.len = (u_long)len;
 60 
 61     /* read into the buffers */
 62     i = WSARecv((SOCKET)fd, /* Socket */
 63             &amp;buf,           /* pointers to the buffers */
 64             (DWORD)1,       /* number of buffers to process */
 65             &amp;read,          /* receives number of bytes read */
 66             &amp;flags,         /* no flags */
 67             0,              /* no overlapped sockets */
 68             0);             /* no completion routine */
 69 
 70     if (i == SOCKET_ERROR) {
 71         int theErr = (jint)WSAGetLastError();
 72         if (theErr == WSAEWOULDBLOCK) {
 73             return IOS_UNAVAILABLE;
 74         }
<span class="line-modified"> 75         JNU_ThrowIOExceptionWithLastError(env, &quot;Read failed&quot;);</span>




 76         return IOS_THROWN;
 77     }
 78 
 79     return convertReturnVal(env, (jint)read, JNI_TRUE);
 80 }
 81 
 82 JNIEXPORT jlong JNICALL
 83 Java_sun_nio_ch_SocketDispatcher_readv0(JNIEnv *env, jclass clazz, jobject fdo,
 84                                        jlong address, jint len)
 85 {
 86     /* set up */
 87     int i = 0;
 88     DWORD read = 0;
 89     DWORD flags = 0;
 90     jint fd = fdval(env, fdo);
 91     struct iovec *iovp = (struct iovec *)address;
 92     WSABUF *bufs = malloc(len * sizeof(WSABUF));
 93     jint rem = MAX_BUFFER_SIZE;
 94 
 95     if (bufs == 0) {
</pre>
<hr />
<pre>
111         }
112     }
113 
114     /* read into the buffers */
115     i = WSARecv((SOCKET)fd, /* Socket */
116             bufs,           /* pointers to the buffers */
117             (DWORD)len,     /* number of buffers to process */
118             &amp;read,          /* receives number of bytes read */
119             &amp;flags,         /* no flags */
120             0,              /* no overlapped sockets */
121             0);             /* no completion routine */
122 
123     /* clean up */
124     free(bufs);
125 
126     if (i != 0) {
127         int theErr = (jint)WSAGetLastError();
128         if (theErr == WSAEWOULDBLOCK) {
129             return IOS_UNAVAILABLE;
130         }
<span class="line-modified">131         JNU_ThrowIOExceptionWithLastError(env, &quot;Vector read failed&quot;);</span>




132         return IOS_THROWN;
133     }
134 
135     return convertLongReturnVal(env, (jlong)read, JNI_TRUE);
136 }
137 
138 JNIEXPORT jint JNICALL
139 Java_sun_nio_ch_SocketDispatcher_write0(JNIEnv *env, jclass clazz, jobject fdo,
140                                        jlong address, jint total)
141 {
142     /* set up */
143     int i = 0;
144     DWORD written = 0;
145     jint count = 0;
146     jint fd = fdval(env, fdo);
147     WSABUF buf;
148 
149     do {
150         /* limit size */
151         jint len = total - count;
</pre>
<hr />
<pre>
157         buf.len = (u_long)len;
158 
159         /* write from the buffer */
160         i = WSASend((SOCKET)fd,     /* Socket */
161                     &amp;buf,           /* pointers to the buffers */
162                     (DWORD)1,       /* number of buffers to process */
163                     &amp;written,       /* receives number of bytes written */
164                     0,              /* no flags */
165                     0,              /* no overlapped sockets */
166                     0);             /* no completion routine */
167 
168         if (i == SOCKET_ERROR) {
169             if (count &gt; 0) {
170                 /* can&#39;t throw exception when some bytes have been written */
171                 break;
172             } else {
173                int theErr = (jint)WSAGetLastError();
174                if (theErr == WSAEWOULDBLOCK) {
175                    return IOS_UNAVAILABLE;
176                }
<span class="line-modified">177                JNU_ThrowIOExceptionWithLastError(env, &quot;Write failed&quot;);</span>




178                return IOS_THROWN;
179             }
180         }
181 
182         count += (jint)written;
183         address += written;
184 
185     } while ((count &lt; total) &amp;&amp; (written == MAX_BUFFER_SIZE));
186 
187     return count;
188 }
189 
190 JNIEXPORT jlong JNICALL
191 Java_sun_nio_ch_SocketDispatcher_writev0(JNIEnv *env, jclass clazz,
192                                          jobject fdo, jlong address, jint len)
193 {
194     /* set up */
195     int next_index, next_offset, ret=0;
196     DWORD written = 0;
197     jint fd = fdval(env, fdo);
</pre>
<hr />
<pre>
239                               &amp;written,     /* receives number of bytes written */
240                               0,            /* no flags */
241                               0,            /* no overlapped sockets */
242                               0);           /* no completion routine */
243 
244         if (ret == SOCKET_ERROR) {
245             break;
246         }
247 
248         count += written;
249     }
250 
251     /* clean up */
252     free(bufs);
253 
254     if (ret == SOCKET_ERROR &amp;&amp; count == 0) {
255         int theErr = (jint)WSAGetLastError();
256         if (theErr == WSAEWOULDBLOCK) {
257             return IOS_UNAVAILABLE;
258         }
<span class="line-modified">259         JNU_ThrowIOExceptionWithLastError(env, &quot;Vector write failed&quot;);</span>




260         return IOS_THROWN;
261     }
262 
263     return convertLongReturnVal(env, count, JNI_FALSE);
264 }
265 
266 JNIEXPORT void JNICALL
<span class="line-modified">267 Java_sun_nio_ch_SocketDispatcher_preClose0(JNIEnv *env, jclass clazz,</span>
<span class="line-removed">268                                            jobject fdo)</span>
<span class="line-removed">269 {</span>
<span class="line-removed">270     jint fd = fdval(env, fdo);</span>
<span class="line-removed">271     struct linger l;</span>
<span class="line-removed">272     int len = sizeof(l);</span>
<span class="line-removed">273     if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&amp;l, &amp;len) == 0) {</span>
<span class="line-removed">274         if (l.l_onoff == 0) {</span>
<span class="line-removed">275             shutdown(fd, SD_SEND);</span>
<span class="line-removed">276         }</span>
<span class="line-removed">277     }</span>
<span class="line-removed">278 }</span>
<span class="line-removed">279 </span>
<span class="line-removed">280 JNIEXPORT void JNICALL</span>
<span class="line-removed">281 Java_sun_nio_ch_SocketDispatcher_close0(JNIEnv *env, jclass clazz,</span>
<span class="line-removed">282                                          jobject fdo)</span>
283 {
<span class="line-removed">284     jint fd = fdval(env, fdo);</span>
285     if (closesocket(fd) == SOCKET_ERROR) {
286         JNU_ThrowIOExceptionWithLastError(env, &quot;Socket close failed&quot;);
287     }
288 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 55         len = MAX_BUFFER_SIZE;
 56 
 57     /* destination buffer and size */
 58     buf.buf = (char *)address;
 59     buf.len = (u_long)len;
 60 
 61     /* read into the buffers */
 62     i = WSARecv((SOCKET)fd, /* Socket */
 63             &amp;buf,           /* pointers to the buffers */
 64             (DWORD)1,       /* number of buffers to process */
 65             &amp;read,          /* receives number of bytes read */
 66             &amp;flags,         /* no flags */
 67             0,              /* no overlapped sockets */
 68             0);             /* no completion routine */
 69 
 70     if (i == SOCKET_ERROR) {
 71         int theErr = (jint)WSAGetLastError();
 72         if (theErr == WSAEWOULDBLOCK) {
 73             return IOS_UNAVAILABLE;
 74         }
<span class="line-modified"> 75         if (theErr == WSAECONNRESET) {</span>
<span class="line-added"> 76             JNU_ThrowByName(env, &quot;sun/net/ConnectionResetException&quot;, &quot;Connection reset&quot;);</span>
<span class="line-added"> 77         } else {</span>
<span class="line-added"> 78             JNU_ThrowIOExceptionWithLastError(env, &quot;Read failed&quot;);</span>
<span class="line-added"> 79         }</span>
 80         return IOS_THROWN;
 81     }
 82 
 83     return convertReturnVal(env, (jint)read, JNI_TRUE);
 84 }
 85 
 86 JNIEXPORT jlong JNICALL
 87 Java_sun_nio_ch_SocketDispatcher_readv0(JNIEnv *env, jclass clazz, jobject fdo,
 88                                        jlong address, jint len)
 89 {
 90     /* set up */
 91     int i = 0;
 92     DWORD read = 0;
 93     DWORD flags = 0;
 94     jint fd = fdval(env, fdo);
 95     struct iovec *iovp = (struct iovec *)address;
 96     WSABUF *bufs = malloc(len * sizeof(WSABUF));
 97     jint rem = MAX_BUFFER_SIZE;
 98 
 99     if (bufs == 0) {
</pre>
<hr />
<pre>
115         }
116     }
117 
118     /* read into the buffers */
119     i = WSARecv((SOCKET)fd, /* Socket */
120             bufs,           /* pointers to the buffers */
121             (DWORD)len,     /* number of buffers to process */
122             &amp;read,          /* receives number of bytes read */
123             &amp;flags,         /* no flags */
124             0,              /* no overlapped sockets */
125             0);             /* no completion routine */
126 
127     /* clean up */
128     free(bufs);
129 
130     if (i != 0) {
131         int theErr = (jint)WSAGetLastError();
132         if (theErr == WSAEWOULDBLOCK) {
133             return IOS_UNAVAILABLE;
134         }
<span class="line-modified">135         if (theErr == WSAECONNRESET) {</span>
<span class="line-added">136             JNU_ThrowByName(env, &quot;sun/net/ConnectionResetException&quot;, &quot;Connection reset&quot;);</span>
<span class="line-added">137         } else {</span>
<span class="line-added">138             JNU_ThrowIOExceptionWithLastError(env, &quot;Vector read failed&quot;);</span>
<span class="line-added">139         }</span>
140         return IOS_THROWN;
141     }
142 
143     return convertLongReturnVal(env, (jlong)read, JNI_TRUE);
144 }
145 
146 JNIEXPORT jint JNICALL
147 Java_sun_nio_ch_SocketDispatcher_write0(JNIEnv *env, jclass clazz, jobject fdo,
148                                        jlong address, jint total)
149 {
150     /* set up */
151     int i = 0;
152     DWORD written = 0;
153     jint count = 0;
154     jint fd = fdval(env, fdo);
155     WSABUF buf;
156 
157     do {
158         /* limit size */
159         jint len = total - count;
</pre>
<hr />
<pre>
165         buf.len = (u_long)len;
166 
167         /* write from the buffer */
168         i = WSASend((SOCKET)fd,     /* Socket */
169                     &amp;buf,           /* pointers to the buffers */
170                     (DWORD)1,       /* number of buffers to process */
171                     &amp;written,       /* receives number of bytes written */
172                     0,              /* no flags */
173                     0,              /* no overlapped sockets */
174                     0);             /* no completion routine */
175 
176         if (i == SOCKET_ERROR) {
177             if (count &gt; 0) {
178                 /* can&#39;t throw exception when some bytes have been written */
179                 break;
180             } else {
181                int theErr = (jint)WSAGetLastError();
182                if (theErr == WSAEWOULDBLOCK) {
183                    return IOS_UNAVAILABLE;
184                }
<span class="line-modified">185                if (theErr == WSAECONNRESET) {</span>
<span class="line-added">186                    JNU_ThrowIOException(env, &quot;Connection reset by peer&quot;);</span>
<span class="line-added">187                } else {</span>
<span class="line-added">188                    JNU_ThrowIOExceptionWithLastError(env, &quot;Write failed&quot;);</span>
<span class="line-added">189                }</span>
190                return IOS_THROWN;
191             }
192         }
193 
194         count += (jint)written;
195         address += written;
196 
197     } while ((count &lt; total) &amp;&amp; (written == MAX_BUFFER_SIZE));
198 
199     return count;
200 }
201 
202 JNIEXPORT jlong JNICALL
203 Java_sun_nio_ch_SocketDispatcher_writev0(JNIEnv *env, jclass clazz,
204                                          jobject fdo, jlong address, jint len)
205 {
206     /* set up */
207     int next_index, next_offset, ret=0;
208     DWORD written = 0;
209     jint fd = fdval(env, fdo);
</pre>
<hr />
<pre>
251                               &amp;written,     /* receives number of bytes written */
252                               0,            /* no flags */
253                               0,            /* no overlapped sockets */
254                               0);           /* no completion routine */
255 
256         if (ret == SOCKET_ERROR) {
257             break;
258         }
259 
260         count += written;
261     }
262 
263     /* clean up */
264     free(bufs);
265 
266     if (ret == SOCKET_ERROR &amp;&amp; count == 0) {
267         int theErr = (jint)WSAGetLastError();
268         if (theErr == WSAEWOULDBLOCK) {
269             return IOS_UNAVAILABLE;
270         }
<span class="line-modified">271         if (theErr == WSAECONNRESET) {</span>
<span class="line-added">272             JNU_ThrowIOException(env, &quot;Connection reset by peer&quot;);</span>
<span class="line-added">273         } else {</span>
<span class="line-added">274             JNU_ThrowIOExceptionWithLastError(env, &quot;Vector write failed&quot;);</span>
<span class="line-added">275         }</span>
276         return IOS_THROWN;
277     }
278 
279     return convertLongReturnVal(env, count, JNI_FALSE);
280 }
281 
282 JNIEXPORT void JNICALL
<span class="line-modified">283 Java_sun_nio_ch_SocketDispatcher_close0(JNIEnv *env, jclass clazz, jint fd)</span>















284 {

285     if (closesocket(fd) == SOCKET_ERROR) {
286         JNU_ThrowIOExceptionWithLastError(env, &quot;Socket close failed&quot;);
287     }
288 }
</pre>
</td>
</tr>
</table>
<center><a href="Net.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="WindowsAsynchronousFileChannelImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/classes/sun/nio/ch/WindowsSelectorImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.nio.channels.ClosedSelectorException;
 30 import java.nio.channels.Pipe;
 31 import java.nio.channels.SelectionKey;
 32 import java.nio.channels.Selector;
 33 import java.nio.channels.spi.SelectorProvider;
 34 import java.util.ArrayDeque;
 35 import java.util.ArrayList;
 36 import java.util.Deque;
 37 import java.util.HashMap;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.function.Consumer;
<a name="1" id="anc1"></a>
 41 
 42 /**
 43  * A multi-threaded implementation of Selector for Windows.
 44  *
 45  * @author Konstantin Kladko
 46  * @author Mark Reinhold
 47  */
 48 
 49 class WindowsSelectorImpl extends SelectorImpl {
<a name="2" id="anc2"></a>






 50     // Initial capacity of the poll array
 51     private final int INIT_CAP = 8;
 52     // Maximum number of sockets for select().
 53     // Should be INIT_CAP times a power of 2
 54     private static final int MAX_SELECTABLE_FDS = 1024;
 55 
<a name="3" id="anc3"></a>






 56     // The list of SelectableChannels serviced by this Selector. Every mod
 57     // MAX_SELECTABLE_FDS entry is bogus, to align this array with the poll
 58     // array,  where the corresponding entry is occupied by the wakeupSocket
 59     private SelectionKeyImpl[] channelArray = new SelectionKeyImpl[INIT_CAP];
 60 
 61     // The global native poll array holds file decriptors and event masks
 62     private PollArrayWrapper pollWrapper;
 63 
 64     // The number of valid entries in  poll array, including entries occupied
 65     // by wakeup socket handle.
 66     private int totalChannels = 1;
 67 
 68     // Number of helper threads needed for select. We need one thread per
 69     // each additional set of MAX_SELECTABLE_FDS - 1 channels.
 70     private int threadsCount = 0;
 71 
 72     // A list of helper threads for select.
 73     private final List&lt;SelectThread&gt; threads = new ArrayList&lt;SelectThread&gt;();
 74 
 75     //Pipe used as a wakeup object.
 76     private final Pipe wakeupPipe;
 77 
 78     // File descriptors corresponding to source and sink
 79     private final int wakeupSourceFd, wakeupSinkFd;
 80 
 81     // Maps file descriptors to their indices in  pollArray
 82     private static final class FdMap extends HashMap&lt;Integer, MapEntry&gt; {
 83         static final long serialVersionUID = 0L;
 84         private MapEntry get(int desc) {
 85             return get(Integer.valueOf(desc));
 86         }
 87         private MapEntry put(SelectionKeyImpl ski) {
 88             return put(Integer.valueOf(ski.getFDVal()), new MapEntry(ski));
 89         }
 90         private MapEntry remove(SelectionKeyImpl ski) {
 91             Integer fd = Integer.valueOf(ski.getFDVal());
 92             MapEntry x = get(fd);
 93             if ((x != null) &amp;&amp; (x.ski.channel() == ski.channel()))
 94                 return remove(fd);
 95             return null;
 96         }
 97     }
 98 
 99     // class for fdMap entries
100     private static final class MapEntry {
101         final SelectionKeyImpl ski;
102         long updateCount = 0;
103         MapEntry(SelectionKeyImpl ski) {
104             this.ski = ski;
105         }
106     }
107     private final FdMap fdMap = new FdMap();
108 
109     // SubSelector for the main thread
110     private final SubSelector subSelector = new SubSelector();
111 
112     private long timeout; //timeout for poll
113 
114     // Lock for interrupt triggering and clearing
115     private final Object interruptLock = new Object();
116     private volatile boolean interruptTriggered;
117 
118     // pending new registrations/updates, queued by implRegister and setEventOps
119     private final Object updateLock = new Object();
120     private final Deque&lt;SelectionKeyImpl&gt; newKeys = new ArrayDeque&lt;&gt;();
121     private final Deque&lt;SelectionKeyImpl&gt; updateKeys = new ArrayDeque&lt;&gt;();
122 
123 
124     WindowsSelectorImpl(SelectorProvider sp) throws IOException {
125         super(sp);
126         pollWrapper = new PollArrayWrapper(INIT_CAP);
127         wakeupPipe = Pipe.open();
128         wakeupSourceFd = ((SelChImpl)wakeupPipe.source()).getFDVal();
129 
130         // Disable the Nagle algorithm so that the wakeup is more immediate
131         SinkChannelImpl sink = (SinkChannelImpl)wakeupPipe.sink();
132         (sink.sc).socket().setTcpNoDelay(true);
133         wakeupSinkFd = ((SelChImpl)sink).getFDVal();
134 
135         pollWrapper.addWakeupSocket(wakeupSourceFd, 0);
136     }
137 
138     private void ensureOpen() {
139         if (!isOpen())
140             throw new ClosedSelectorException();
141     }
142 
143     @Override
144     protected int doSelect(Consumer&lt;SelectionKey&gt; action, long timeout)
145         throws IOException
146     {
147         assert Thread.holdsLock(this);
148         this.timeout = timeout; // set selector timeout
149         processUpdateQueue();
150         processDeregisterQueue();
151         if (interruptTriggered) {
152             resetWakeupSocket();
153             return 0;
154         }
155         // Calculate number of helper threads needed for poll. If necessary
156         // threads are created here and start waiting on startLock
157         adjustThreadsCount();
158         finishLock.reset(); // reset finishLock
159         // Wakeup helper threads, waiting on startLock, so they start polling.
160         // Redundant threads will exit here after wakeup.
161         startLock.startThreads();
162         // do polling in the main thread. Main thread is responsible for
163         // first MAX_SELECTABLE_FDS entries in pollArray.
164         try {
165             begin();
166             try {
167                 subSelector.poll();
168             } catch (IOException e) {
169                 finishLock.setException(e); // Save this exception
170             }
171             // Main thread is out of poll(). Wakeup others and wait for them
172             if (threads.size() &gt; 0)
173                 finishLock.waitForHelperThreads();
174           } finally {
175               end();
176           }
177         // Done with poll(). Set wakeupSocket to nonsignaled  for the next run.
178         finishLock.checkForException();
179         processDeregisterQueue();
180         int updated = updateSelectedKeys(action);
181         // Done with poll(). Set wakeupSocket to nonsignaled  for the next run.
182         resetWakeupSocket();
183         return updated;
184     }
185 
186     /**
187      * Process new registrations and changes to the interest ops.
188      */
189     private void processUpdateQueue() {
190         assert Thread.holdsLock(this);
191 
192         synchronized (updateLock) {
193             SelectionKeyImpl ski;
194 
195             // new registrations
196             while ((ski = newKeys.pollFirst()) != null) {
197                 if (ski.isValid()) {
198                     growIfNeeded();
199                     channelArray[totalChannels] = ski;
200                     ski.setIndex(totalChannels);
201                     pollWrapper.putEntry(totalChannels, ski);
202                     totalChannels++;
203                     MapEntry previous = fdMap.put(ski);
204                     assert previous == null;
205                 }
206             }
207 
208             // changes to interest ops
209             while ((ski = updateKeys.pollFirst()) != null) {
210                 int events = ski.translateInterestOps();
211                 int fd = ski.getFDVal();
212                 if (ski.isValid() &amp;&amp; fdMap.containsKey(fd)) {
213                     int index = ski.getIndex();
214                     assert index &gt;= 0 &amp;&amp; index &lt; totalChannels;
215                     pollWrapper.putEventOps(index, events);
216                 }
217             }
218         }
219     }
220 
221     // Helper threads wait on this lock for the next poll.
222     private final StartLock startLock = new StartLock();
223 
224     private final class StartLock {
225         // A variable which distinguishes the current run of doSelect from the
226         // previous one. Incrementing runsCounter and notifying threads will
227         // trigger another round of poll.
228         private long runsCounter;
229        // Triggers threads, waiting on this lock to start polling.
230         private synchronized void startThreads() {
231             runsCounter++; // next run
232             notifyAll(); // wake up threads.
233         }
234         // This function is called by a helper thread to wait for the
235         // next round of poll(). It also checks, if this thread became
236         // redundant. If yes, it returns true, notifying the thread
237         // that it should exit.
238         private synchronized boolean waitForStart(SelectThread thread) {
239             while (true) {
240                 while (runsCounter == thread.lastRun) {
241                     try {
242                         startLock.wait();
243                     } catch (InterruptedException e) {
244                         Thread.currentThread().interrupt();
245                     }
246                 }
247                 if (thread.isZombie()) { // redundant thread
248                     return true; // will cause run() to exit.
249                 } else {
250                     thread.lastRun = runsCounter; // update lastRun
251                     return false; //   will cause run() to poll.
252                 }
253             }
254         }
255     }
256 
257     // Main thread waits on this lock, until all helper threads are done
258     // with poll().
259     private final FinishLock finishLock = new FinishLock();
260 
261     private final class FinishLock  {
262         // Number of helper threads, that did not finish yet.
263         private int threadsToFinish;
264 
265         // IOException which occurred during the last run.
266         IOException exception = null;
267 
268         // Called before polling.
269         private void reset() {
270             threadsToFinish = threads.size(); // helper threads
271         }
272 
273         // Each helper thread invokes this function on finishLock, when
274         // the thread is done with poll().
275         private synchronized void threadFinished() {
276             if (threadsToFinish == threads.size()) { // finished poll() first
277                 // if finished first, wakeup others
278                 wakeup();
279             }
280             threadsToFinish--;
281             if (threadsToFinish == 0) // all helper threads finished poll().
282                 notify();             // notify the main thread
283         }
284 
285         // The main thread invokes this function on finishLock to wait
286         // for helper threads to finish poll().
287         private synchronized void waitForHelperThreads() {
288             if (threadsToFinish == threads.size()) {
289                 // no helper threads finished yet. Wakeup them up.
290                 wakeup();
291             }
292             while (threadsToFinish != 0) {
293                 try {
294                     finishLock.wait();
295                 } catch (InterruptedException e) {
296                     // Interrupted - set interrupted state.
297                     Thread.currentThread().interrupt();
298                 }
299             }
300         }
301 
302         // sets IOException for this run
303         private synchronized void setException(IOException e) {
304             exception = e;
305         }
306 
307         // Checks if there was any exception during the last run.
308         // If yes, throws it
309         private void checkForException() throws IOException {
310             if (exception == null)
311                 return;
312             StringBuffer message =  new StringBuffer(&quot;An exception occurred&quot; +
313                                        &quot; during the execution of select(): \n&quot;);
314             message.append(exception);
315             message.append(&#39;\n&#39;);
316             exception = null;
317             throw new IOException(message.toString());
318         }
319     }
320 
321     private final class SubSelector {
322         private final int pollArrayIndex; // starting index in pollArray to poll
323         // These arrays will hold result of native select().
324         // The first element of each array is the number of selected sockets.
325         // Other elements are file descriptors of selected sockets.
326         private final int[] readFds = new int [MAX_SELECTABLE_FDS + 1];
327         private final int[] writeFds = new int [MAX_SELECTABLE_FDS + 1];
328         private final int[] exceptFds = new int [MAX_SELECTABLE_FDS + 1];
<a name="4" id="anc4"></a>


329 
330         private SubSelector() {
331             this.pollArrayIndex = 0; // main thread
332         }
333 
334         private SubSelector(int threadIndex) { // helper threads
335             this.pollArrayIndex = (threadIndex + 1) * MAX_SELECTABLE_FDS;
336         }
337 
338         private int poll() throws IOException{ // poll for the main thread
339             return poll0(pollWrapper.pollArrayAddress,
340                          Math.min(totalChannels, MAX_SELECTABLE_FDS),
<a name="5" id="anc5"></a><span class="line-modified">341                          readFds, writeFds, exceptFds, timeout);</span>
342         }
343 
344         private int poll(int index) throws IOException {
345             // poll for helper threads
346             return  poll0(pollWrapper.pollArrayAddress +
347                      (pollArrayIndex * PollArrayWrapper.SIZE_POLLFD),
348                      Math.min(MAX_SELECTABLE_FDS,
349                              totalChannels - (index + 1) * MAX_SELECTABLE_FDS),
<a name="6" id="anc6"></a><span class="line-modified">350                      readFds, writeFds, exceptFds, timeout);</span>
351         }
352 
353         private native int poll0(long pollAddress, int numfds,
<a name="7" id="anc7"></a><span class="line-modified">354              int[] readFds, int[] writeFds, int[] exceptFds, long timeout);</span>
355 
356         private int processSelectedKeys(long updateCount, Consumer&lt;SelectionKey&gt; action) {
357             int numKeysUpdated = 0;
358             numKeysUpdated += processFDSet(updateCount, action, readFds,
359                                            Net.POLLIN,
360                                            false);
361             numKeysUpdated += processFDSet(updateCount, action, writeFds,
362                                            Net.POLLCONN |
363                                            Net.POLLOUT,
364                                            false);
365             numKeysUpdated += processFDSet(updateCount, action, exceptFds,
366                                            Net.POLLIN |
367                                            Net.POLLCONN |
368                                            Net.POLLOUT,
369                                            true);
370             return numKeysUpdated;
371         }
372 
373         /**
374          * updateCount is used to tell if a key has been counted as updated
375          * in this select operation.
376          *
377          * me.updateCount &lt;= updateCount
378          */
379         private int processFDSet(long updateCount,
380                                  Consumer&lt;SelectionKey&gt; action,
381                                  int[] fds, int rOps,
382                                  boolean isExceptFds)
383         {
384             int numKeysUpdated = 0;
385             for (int i = 1; i &lt;= fds[0]; i++) {
386                 int desc = fds[i];
387                 if (desc == wakeupSourceFd) {
388                     synchronized (interruptLock) {
389                         interruptTriggered = true;
390                     }
391                     continue;
392                 }
393                 MapEntry me = fdMap.get(desc);
394                 // If me is null, the key was deregistered in the previous
395                 // processDeregisterQueue.
396                 if (me == null)
397                     continue;
398                 SelectionKeyImpl sk = me.ski;
399 
400                 // The descriptor may be in the exceptfds set because there is
401                 // OOB data queued to the socket. If there is OOB data then it
402                 // is discarded and the key is not added to the selected set.
403                 if (isExceptFds &amp;&amp;
404                     (sk.channel() instanceof SocketChannelImpl) &amp;&amp;
405                     discardUrgentData(desc))
406                 {
407                     continue;
408                 }
409 
410                 int updated = processReadyEvents(rOps, sk, action);
411                 if (updated &gt; 0 &amp;&amp; me.updateCount != updateCount) {
412                     me.updateCount = updateCount;
413                     numKeysUpdated++;
414                 }
415             }
416             return numKeysUpdated;
417         }
<a name="8" id="anc8"></a>



418     }
419 
420     // Represents a helper thread used for select.
421     private final class SelectThread extends Thread {
422         private final int index; // index of this thread
423         final SubSelector subSelector;
424         private long lastRun = 0; // last run number
425         private volatile boolean zombie;
426         // Creates a new thread
427         private SelectThread(int i) {
428             super(null, null, &quot;SelectorHelper&quot;, 0, false);
429             this.index = i;
430             this.subSelector = new SubSelector(i);
431             //make sure we wait for next round of poll
432             this.lastRun = startLock.runsCounter;
433         }
434         void makeZombie() {
435             zombie = true;
436         }
437         boolean isZombie() {
438             return zombie;
439         }
440         public void run() {
441             while (true) { // poll loop
442                 // wait for the start of poll. If this thread has become
443                 // redundant, then exit.
<a name="9" id="anc9"></a><span class="line-modified">444                 if (startLock.waitForStart(this))</span>

445                     return;
<a name="10" id="anc10"></a>
446                 // call poll()
447                 try {
448                     subSelector.poll(index);
449                 } catch (IOException e) {
450                     // Save this exception and let other threads finish.
451                     finishLock.setException(e);
452                 }
453                 // notify main thread, that this thread has finished, and
454                 // wakeup others, if this thread is the first to finish.
455                 finishLock.threadFinished();
456             }
457         }
458     }
459 
460     // After some channels registered/deregistered, the number of required
461     // helper threads may have changed. Adjust this number.
462     private void adjustThreadsCount() {
463         if (threadsCount &gt; threads.size()) {
464             // More threads needed. Start more threads.
465             for (int i = threads.size(); i &lt; threadsCount; i++) {
466                 SelectThread newThread = new SelectThread(i);
467                 threads.add(newThread);
468                 newThread.setDaemon(true);
469                 newThread.start();
470             }
471         } else if (threadsCount &lt; threads.size()) {
472             // Some threads become redundant. Remove them from the threads List.
473             for (int i = threads.size() - 1 ; i &gt;= threadsCount; i--)
474                 threads.remove(i).makeZombie();
475         }
476     }
477 
478     // Sets Windows wakeup socket to a signaled state.
479     private void setWakeupSocket() {
480         setWakeupSocket0(wakeupSinkFd);
481     }
482     private native void setWakeupSocket0(int wakeupSinkFd);
483 
484     // Sets Windows wakeup socket to a non-signaled state.
485     private void resetWakeupSocket() {
486         synchronized (interruptLock) {
487             if (interruptTriggered == false)
488                 return;
489             resetWakeupSocket0(wakeupSourceFd);
490             interruptTriggered = false;
491         }
492     }
493 
494     private native void resetWakeupSocket0(int wakeupSourceFd);
495 
496     private native boolean discardUrgentData(int fd);
497 
498     // We increment this counter on each call to updateSelectedKeys()
499     // each entry in  SubSelector.fdsMap has a memorized value of
500     // updateCount. When we increment numKeysUpdated we set updateCount
501     // for the corresponding entry to its current value. This is used to
502     // avoid counting the same key more than once - the same key can
503     // appear in readfds and writefds.
504     private long updateCount = 0;
505 
506     // Update ops of the corresponding Channels. Add the ready keys to the
507     // ready queue.
508     private int updateSelectedKeys(Consumer&lt;SelectionKey&gt; action) {
509         updateCount++;
510         int numKeysUpdated = 0;
511         numKeysUpdated += subSelector.processSelectedKeys(updateCount, action);
512         for (SelectThread t: threads) {
513             numKeysUpdated += t.subSelector.processSelectedKeys(updateCount, action);
514         }
515         return numKeysUpdated;
516     }
517 
518     @Override
519     protected void implClose() throws IOException {
520         assert !isOpen();
521         assert Thread.holdsLock(this);
522 
523         // prevent further wakeup
524         synchronized (interruptLock) {
525             interruptTriggered = true;
526         }
527 
528         wakeupPipe.sink().close();
529         wakeupPipe.source().close();
530         pollWrapper.free();
531 
532         // Make all remaining helper threads exit
533         for (SelectThread t: threads)
534              t.makeZombie();
535         startLock.startThreads();
<a name="11" id="anc11"></a>
536     }
537 
538     @Override
539     protected void implRegister(SelectionKeyImpl ski) {
540         ensureOpen();
541         synchronized (updateLock) {
542             newKeys.addLast(ski);
543         }
544     }
545 
546     private void growIfNeeded() {
547         if (channelArray.length == totalChannels) {
548             int newSize = totalChannels * 2; // Make a larger array
549             SelectionKeyImpl temp[] = new SelectionKeyImpl[newSize];
550             System.arraycopy(channelArray, 1, temp, 1, totalChannels - 1);
551             channelArray = temp;
552             pollWrapper.grow(newSize);
553         }
554         if (totalChannels % MAX_SELECTABLE_FDS == 0) { // more threads needed
555             pollWrapper.addWakeupSocket(wakeupSourceFd, totalChannels);
556             totalChannels++;
557             threadsCount++;
558         }
559     }
560 
561     @Override
562     protected void implDereg(SelectionKeyImpl ski) {
563         assert !ski.isValid();
564         assert Thread.holdsLock(this);
565 
566         if (fdMap.remove(ski) != null) {
567             int i = ski.getIndex();
568             assert (i &gt;= 0);
569 
570             if (i != totalChannels - 1) {
571                 // Copy end one over it
572                 SelectionKeyImpl endChannel = channelArray[totalChannels-1];
573                 channelArray[i] = endChannel;
574                 endChannel.setIndex(i);
575                 pollWrapper.replaceEntry(pollWrapper, totalChannels-1, pollWrapper, i);
576             }
577             ski.setIndex(-1);
578 
579             channelArray[totalChannels - 1] = null;
580             totalChannels--;
581             if (totalChannels != 1 &amp;&amp; totalChannels % MAX_SELECTABLE_FDS == 1) {
582                 totalChannels--;
583                 threadsCount--; // The last thread has become redundant.
584             }
585         }
586     }
587 
588     @Override
589     public void setEventOps(SelectionKeyImpl ski) {
590         ensureOpen();
591         synchronized (updateLock) {
592             updateKeys.addLast(ski);
593         }
594     }
595 
596     @Override
597     public Selector wakeup() {
598         synchronized (interruptLock) {
599             if (!interruptTriggered) {
600                 setWakeupSocket();
601                 interruptTriggered = true;
602             }
603         }
604         return this;
605     }
606 
607     static {
608         IOUtil.load();
609     }
610 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
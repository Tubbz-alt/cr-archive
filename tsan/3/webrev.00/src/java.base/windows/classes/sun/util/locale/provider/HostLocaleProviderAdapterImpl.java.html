<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/windows/classes/sun/util/locale/provider/HostLocaleProviderAdapterImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.util.locale.provider;
 26 
 27 import java.lang.ref.SoftReference;
 28 import java.text.DateFormat;
 29 import java.text.DateFormatSymbols;
 30 import java.text.DecimalFormat;
 31 import java.text.DecimalFormatSymbols;
 32 import java.text.NumberFormat;
 33 import java.text.SimpleDateFormat;
 34 import java.text.spi.DateFormatProvider;
 35 import java.text.spi.DateFormatSymbolsProvider;
 36 import java.text.spi.DecimalFormatSymbolsProvider;
 37 import java.text.spi.NumberFormatProvider;
 38 import java.util.Calendar;
 39 import java.util.Collections;
 40 import java.util.Currency;
 41 import java.util.HashMap;
 42 import java.util.HashSet;
 43 import java.util.Locale;
 44 import java.util.Map;
 45 import java.util.ResourceBundle.Control;
 46 import java.util.Set;
 47 import java.util.TimeZone;
 48 import java.util.concurrent.ConcurrentHashMap;
 49 import java.util.concurrent.ConcurrentMap;
 50 import java.util.concurrent.atomic.AtomicReferenceArray;
 51 import java.util.spi.CalendarDataProvider;
 52 import java.util.spi.CalendarNameProvider;
 53 import java.util.spi.CurrencyNameProvider;
 54 import java.util.spi.LocaleNameProvider;
 55 import sun.text.spi.JavaTimeDateTimePatternProvider;
 56 import sun.util.spi.CalendarProvider;
 57 
 58 /**
 59  * LocaleProviderdapter implementation for the Windows locale data.
 60  *
 61  * @author Naoto Sato
 62  */
 63 public class HostLocaleProviderAdapterImpl {
 64 
 65     // locale categories
 66     private static final int CAT_DISPLAY = 0;
 67     private static final int CAT_FORMAT  = 1;
 68 
 69     // NumberFormat styles
 70     private static final int NF_NUMBER   = 0;
 71     private static final int NF_CURRENCY = 1;
 72     private static final int NF_PERCENT  = 2;
 73     private static final int NF_INTEGER  = 3;
 74     private static final int NF_MAX = NF_INTEGER;
 75 
 76     // CalendarData value types
 77     private static final int CD_FIRSTDAYOFWEEK = 0;
 78     private static final int CD_MINIMALDAYSINFIRSTWEEK = 1;
 79 
 80     // Currency/Locale display name types
 81     private static final int DN_CURRENCY_NAME   = 0;
 82     private static final int DN_CURRENCY_SYMBOL = 1;
 83     private static final int DN_LOCALE_LANGUAGE = 2;
 84     private static final int DN_LOCALE_SCRIPT   = 3;
 85     private static final int DN_LOCALE_REGION   = 4;
 86     private static final int DN_LOCALE_VARIANT  = 5;
 87 
 88     // Windows Calendar IDs
 89     private static final int CAL_JAPAN  = 3;
 90 
 91     // Native Calendar ID to LDML calendar type map
 92     private static final String[] calIDToLDML = {
 93         &quot;&quot;,
 94         &quot;gregory&quot;,
 95         &quot;gregory_en-US&quot;,
 96         &quot;japanese&quot;,
 97         &quot;roc&quot;,
 98         &quot;&quot;,          // No appropriate type for CAL_KOREA
 99         &quot;islamic&quot;,
100         &quot;buddhist&quot;,
101         &quot;hebrew&quot;,
102         &quot;gregory_fr&quot;,
103         &quot;gregory_ar&quot;,
104         &quot;gregory_en&quot;,
105         &quot;gregory_fr&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,
106         &quot;islamic-umalqura&quot;,
107     };
108 
109     // Caches
110     private static final ConcurrentMap&lt;Locale, SoftReference&lt;AtomicReferenceArray&lt;String&gt;&gt;&gt; dateFormatCache = new ConcurrentHashMap&lt;&gt;();
111     private static final ConcurrentMap&lt;Locale, SoftReference&lt;DateFormatSymbols&gt;&gt; dateFormatSymbolsCache = new ConcurrentHashMap&lt;&gt;();
112     private static final ConcurrentMap&lt;Locale, SoftReference&lt;AtomicReferenceArray&lt;String&gt;&gt;&gt; numberFormatCache = new ConcurrentHashMap&lt;&gt;();
113     private static final ConcurrentMap&lt;Locale, SoftReference&lt;DecimalFormatSymbols&gt;&gt; decimalFormatSymbolsCache = new ConcurrentHashMap&lt;&gt;();
114 
115     private static final Set&lt;Locale&gt; supportedLocaleSet;
116     private static final String nativeDisplayLanguage;
117     static {
118         Set&lt;Locale&gt; tmpSet = new HashSet&lt;&gt;();
119         if (initialize()) {
120             // Assuming the default locales do not include any extensions, so
121             // no stripping is needed here.
122             Control c = Control.getNoFallbackControl(Control.FORMAT_DEFAULT);
123             String displayLocale = getDefaultLocale(CAT_DISPLAY);
124             Locale l = Locale.forLanguageTag(displayLocale.replace(&#39;_&#39;, &#39;-&#39;));
125             tmpSet.addAll(c.getCandidateLocales(&quot;&quot;, l));
126             nativeDisplayLanguage = l.getLanguage();
127 
128             String formatLocale = getDefaultLocale(CAT_FORMAT);
129             if (!formatLocale.equals(displayLocale)) {
130                 l = Locale.forLanguageTag(formatLocale.replace(&#39;_&#39;, &#39;-&#39;));
131                 tmpSet.addAll(c.getCandidateLocales(&quot;&quot;, l));
132             }
133         } else {
134             nativeDisplayLanguage = &quot;&quot;;
135         }
136         supportedLocaleSet = Collections.unmodifiableSet(tmpSet);
137     }
138     private static final Locale[] supportedLocale = supportedLocaleSet.toArray(new Locale[0]);
139 
140     public static DateFormatProvider getDateFormatProvider() {
141         return new DateFormatProvider() {
142             @Override
143             public Locale[] getAvailableLocales() {
144                 return getSupportedCalendarLocales();
145             }
146 
147             @Override
148             public boolean isSupportedLocale(Locale locale) {
149                 return isSupportedCalendarLocale(locale);
150             }
151 
152             @Override
153             public DateFormat getDateInstance(int style, Locale locale) {
154                 AtomicReferenceArray&lt;String&gt; patterns = getDateTimePatterns(locale);
155                 return new SimpleDateFormat(patterns.get(style/2),
156                                             getCalendarLocale(locale));
157             }
158 
159             @Override
160             public DateFormat getTimeInstance(int style, Locale locale) {
161                 AtomicReferenceArray&lt;String&gt; patterns = getDateTimePatterns(locale);
162                 return new SimpleDateFormat(patterns.get(style/2+2),
163                                             getCalendarLocale(locale));
164             }
165 
166             @Override
167             public DateFormat getDateTimeInstance(int dateStyle,
168                     int timeStyle, Locale locale) {
169                 AtomicReferenceArray&lt;String&gt; patterns = getDateTimePatterns(locale);
170                 String pattern = new StringBuilder(patterns.get(dateStyle/2))
171                                        .append(&quot; &quot;)
172                                        .append(patterns.get(timeStyle/2+2))
173                                        .toString();
174                 return new SimpleDateFormat(pattern, getCalendarLocale(locale));
175             }
176 
177             private AtomicReferenceArray&lt;String&gt; getDateTimePatterns(Locale locale) {
178                 AtomicReferenceArray&lt;String&gt; patterns;
179                 SoftReference&lt;AtomicReferenceArray&lt;String&gt;&gt; ref = dateFormatCache.get(locale);
180 
181                 if (ref == null || (patterns = ref.get()) == null) {
182                     String langtag = removeExtensions(locale).toLanguageTag();
183                     patterns = new AtomicReferenceArray&lt;&gt;(4);
184                     patterns.compareAndSet(0, null, convertDateTimePattern(
185                         getDateTimePattern(DateFormat.LONG, -1, langtag)));
186                     patterns.compareAndSet(1, null, convertDateTimePattern(
187                         getDateTimePattern(DateFormat.SHORT, -1, langtag)));
188                     patterns.compareAndSet(2, null, convertDateTimePattern(
189                         getDateTimePattern(-1, DateFormat.LONG, langtag)));
190                     patterns.compareAndSet(3, null, convertDateTimePattern(
191                         getDateTimePattern(-1, DateFormat.SHORT, langtag)));
192                     ref = new SoftReference&lt;&gt;(patterns);
193                     dateFormatCache.put(locale, ref);
194                 }
195 
196                 return patterns;
197             }
198         };
199     }
200 
201     public static DateFormatSymbolsProvider getDateFormatSymbolsProvider() {
202         return new DateFormatSymbolsProvider() {
203 
204             @Override
205             public Locale[] getAvailableLocales() {
206                 return getSupportedCalendarLocales();
207             }
208 
209             @Override
210             public boolean isSupportedLocale(Locale locale) {
211                 return isSupportedCalendarLocale(locale);
212             }
213 
214             @Override
215             public DateFormatSymbols getInstance(Locale locale) {
216                 DateFormatSymbols dfs;
217                 SoftReference&lt;DateFormatSymbols&gt; ref =
218                     dateFormatSymbolsCache.get(locale);
219 
220                 if (ref == null || (dfs = ref.get()) == null) {
221                     dfs = new DateFormatSymbols(locale);
222                     String langTag = removeExtensions(locale).toLanguageTag();
223 
224                     dfs.setAmPmStrings(getAmPmStrings(langTag, dfs.getAmPmStrings()));
225                     dfs.setEras(getEras(langTag, dfs.getEras()));
226                     dfs.setMonths(getMonths(langTag, dfs.getMonths()));
227                     dfs.setShortMonths(getShortMonths(langTag, dfs.getShortMonths()));
228                     dfs.setWeekdays(getWeekdays(langTag, dfs.getWeekdays()));
229                     dfs.setShortWeekdays(getShortWeekdays(langTag, dfs.getShortWeekdays()));
230                     ref = new SoftReference&lt;&gt;(dfs);
231                     dateFormatSymbolsCache.put(locale, ref);
232                 }
233                 return (DateFormatSymbols)dfs.clone();
234             }
235         };
236     }
237 
238     public static NumberFormatProvider getNumberFormatProvider() {
239         return new NumberFormatProvider() {
240 
241             @Override
242             public Locale[] getAvailableLocales() {
243                 return getSupportedNativeDigitLocales();
244             }
245 
246             @Override
247             public boolean isSupportedLocale(Locale locale) {
248                 return isSupportedNativeDigitLocale(locale);
249             }
250 
251             @Override
252             public NumberFormat getCurrencyInstance(Locale locale) {
253                 AtomicReferenceArray&lt;String&gt; patterns = getNumberPatterns(locale);
254                 return new DecimalFormat(patterns.get(NF_CURRENCY),
255                     DecimalFormatSymbols.getInstance(locale));
256             }
257 
258             @Override
259             public NumberFormat getIntegerInstance(Locale locale) {
260                 AtomicReferenceArray&lt;String&gt; patterns = getNumberPatterns(locale);
261                 DecimalFormat format = new DecimalFormat(patterns.get(NF_INTEGER),
262                     DecimalFormatSymbols.getInstance(locale));
263                 return HostLocaleProviderAdapter.makeIntegerFormatter(format);
264             }
265 
266             @Override
267             public NumberFormat getNumberInstance(Locale locale) {
268                 AtomicReferenceArray&lt;String&gt; patterns = getNumberPatterns(locale);
269                 return new DecimalFormat(patterns.get(NF_NUMBER),
270                     DecimalFormatSymbols.getInstance(locale));
271             }
272 
273             @Override
274             public NumberFormat getPercentInstance(Locale locale) {
275                 AtomicReferenceArray&lt;String&gt; patterns = getNumberPatterns(locale);
276                 return new DecimalFormat(patterns.get(NF_PERCENT),
277                     DecimalFormatSymbols.getInstance(locale));
278             }
279 
280             private AtomicReferenceArray&lt;String&gt; getNumberPatterns(Locale locale) {
281                 AtomicReferenceArray&lt;String&gt; patterns;
282                 SoftReference&lt;AtomicReferenceArray&lt;String&gt;&gt; ref = numberFormatCache.get(locale);
283 
284                 if (ref == null || (patterns = ref.get()) == null) {
285                     String langtag = locale.toLanguageTag();
286                     patterns = new AtomicReferenceArray&lt;&gt;(NF_MAX+1);
287                     for (int i = 0; i &lt;= NF_MAX; i++) {
288                         patterns.compareAndSet(i, null, getNumberPattern(i, langtag));
289                     }
290                     ref = new SoftReference&lt;&gt;(patterns);
291                     numberFormatCache.put(locale, ref);
292                 }
293                 return patterns;
294             }
295         };
296     }
297 
298     public static DecimalFormatSymbolsProvider getDecimalFormatSymbolsProvider() {
299         return new DecimalFormatSymbolsProvider() {
300 
301             @Override
302             public Locale[] getAvailableLocales() {
303                 return getSupportedNativeDigitLocales();
304             }
305 
306             @Override
307             public boolean isSupportedLocale(Locale locale) {
308                 return isSupportedNativeDigitLocale(locale);
309             }
310 
311             @Override
312             public DecimalFormatSymbols getInstance(Locale locale) {
313                 DecimalFormatSymbols dfs;
314                 SoftReference&lt;DecimalFormatSymbols&gt; ref =
315                     decimalFormatSymbolsCache.get(locale);
316 
317                 if (ref == null || (dfs = ref.get()) == null) {
318                     dfs = new DecimalFormatSymbols(getNumberLocale(locale));
319                     String langTag = removeExtensions(locale).toLanguageTag();
320 
321                     // DecimalFormatSymbols.setInternationalCurrencySymbol() has
322                     // a side effect of setting the currency symbol as well. So
323                     // the calling order is relevant here.
324                     dfs.setInternationalCurrencySymbol(getInternationalCurrencySymbol(langTag, dfs.getInternationalCurrencySymbol()));
325                     dfs.setCurrencySymbol(getCurrencySymbol(langTag, dfs.getCurrencySymbol()));
326                     dfs.setDecimalSeparator(getDecimalSeparator(langTag, dfs.getDecimalSeparator()));
327                     dfs.setGroupingSeparator(getGroupingSeparator(langTag, dfs.getGroupingSeparator()));
328                     dfs.setInfinity(getInfinity(langTag, dfs.getInfinity()));
329                     dfs.setMinusSign(getMinusSign(langTag, dfs.getMinusSign()));
330                     dfs.setMonetaryDecimalSeparator(getMonetaryDecimalSeparator(langTag, dfs.getMonetaryDecimalSeparator()));
331                     dfs.setNaN(getNaN(langTag, dfs.getNaN()));
332                     dfs.setPercent(getPercent(langTag, dfs.getPercent()));
333                     dfs.setPerMill(getPerMill(langTag, dfs.getPerMill()));
334                     dfs.setZeroDigit(getZeroDigit(langTag, dfs.getZeroDigit()));
335                     ref = new SoftReference&lt;&gt;(dfs);
336                     decimalFormatSymbolsCache.put(locale, ref);
337                 }
338                 return (DecimalFormatSymbols)dfs.clone();
339             }
340         };
341     }
342 
343     public static CalendarDataProvider getCalendarDataProvider() {
344         return new CalendarDataProvider() {
345             @Override
346             public Locale[] getAvailableLocales() {
347                 return getSupportedCalendarLocales();
348             }
349 
350             @Override
351             public boolean isSupportedLocale(Locale locale) {
352                 return isSupportedCalendarLocale(locale);
353             }
354 
355             @Override
356             public int getFirstDayOfWeek(Locale locale) {
357                 int first = getCalendarDataValue(
358                                  removeExtensions(locale).toLanguageTag(),
359                                  CD_FIRSTDAYOFWEEK);
360                 if (first != -1) {
361                     return (first + 1) % 7 + 1;
362                 } else {
363                     return 0;
364                 }
365             }
366 
367             @Override
368             public int getMinimalDaysInFirstWeek(Locale locale) {
369                 return 0;
370             }
371         };
372     }
373 
374     public static CalendarNameProvider getCalendarNameProvider() {
375         return new CalendarNameProvider() {
376             @Override
377             public Locale[] getAvailableLocales() {
378                 return getSupportedCalendarLocales();
379             }
380 
381             @Override
382             public boolean isSupportedLocale(Locale locale) {
383                 return isSupportedCalendarLocale(locale);
384             }
385 
386             @Override
387             public String getDisplayName(String calendarType, int field,
388                 int value, int style, Locale locale) {
389                 String[] names = getCalendarDisplayStrings(removeExtensions(locale).toLanguageTag(),
390                             getCalendarIDFromLDMLType(calendarType), field, style);
391                 if (names != null &amp;&amp; value &gt;= 0 &amp;&amp; value &lt; names.length) {
392                     return names[value];
393                 } else {
394                     return null;
395                 }
396             }
397 
398             @Override
399             public Map&lt;String, Integer&gt; getDisplayNames(String calendarType,
400                 int field, int style, Locale locale) {
401                 Map&lt;String, Integer&gt; map = null;
402                 String[] names = getCalendarDisplayStrings(removeExtensions(locale).toLanguageTag(),
403                             getCalendarIDFromLDMLType(calendarType), field, style);
404                 if (names != null) {
405                     map = new HashMap&lt;&gt;();
406                     for (int value = 0; value &lt; names.length; value++) {
407                         if (names[value] != null) {
408                             map.put(names[value], value);
409                         }
410                     }
411                     map = map.isEmpty() ? null : map;
412                 }
413                 return map;
414             }
415         };
416     }
417 
418     public static CalendarProvider getCalendarProvider() {
419         return new CalendarProvider() {
420             @Override
421             public Locale[] getAvailableLocales() {
422                 return getSupportedCalendarLocales();
423             }
424 
425             @Override
426             public boolean isSupportedLocale(Locale locale) {
427                 return isSupportedCalendarLocale(locale);
428             }
429 
430             @Override
431             public Calendar getInstance(TimeZone zone, Locale locale) {
432                 return new Calendar.Builder()
433                              .setLocale(getCalendarLocale(locale))
434                              .setTimeZone(zone)
435                              .setInstant(System.currentTimeMillis())
436                              .build();
437             }
438         };
439     }
440 
441     public static CurrencyNameProvider getCurrencyNameProvider() {
442         return new CurrencyNameProvider() {
443             @Override
444             public Locale[] getAvailableLocales() {
445                 return supportedLocale;
446             }
447 
448             @Override
449             public boolean isSupportedLocale(Locale locale) {
450                 // Ignore the extensions for now
451                 return supportedLocaleSet.contains(locale.stripExtensions()) &amp;&amp;
452                        locale.getLanguage().equals(nativeDisplayLanguage);
453             }
454 
455             @Override
456             public String getSymbol(String currencyCode, Locale locale) {
457                 // Retrieves the currency symbol by calling
458                 // GetLocaleInfoEx(LOCALE_SCURRENCY).
459                 // It only works with the &quot;locale&quot;&#39;s currency in its native
460                 // language.
461                 try {
462                     if (Currency.getInstance(locale).getCurrencyCode()
463                         .equals(currencyCode)) {
464                         return getDisplayString(locale.toLanguageTag(),
465                                 DN_CURRENCY_SYMBOL, currencyCode);
466                     }
467                 } catch (IllegalArgumentException iae) {}
468                 return null;
469             }
470 
471             @Override
472             public String getDisplayName(String currencyCode, Locale locale) {
473                 // Retrieves the display name by calling
474                 // GetLocaleInfoEx(LOCALE_SNATIVECURRNAME).
475                 // It only works with the &quot;locale&quot;&#39;s currency in its native
476                 // language.
477                 try {
478                     if (Currency.getInstance(locale).getCurrencyCode()
479                         .equals(currencyCode)) {
480                         return getDisplayString(locale.toLanguageTag(),
481                                 DN_CURRENCY_NAME, currencyCode);
482                     }
483                 } catch (IllegalArgumentException iae) {}
484                 return null;
485             }
486         };
487     }
488 
489     public static LocaleNameProvider getLocaleNameProvider() {
490         return new LocaleNameProvider() {
491             @Override
492             public Locale[] getAvailableLocales() {
493                 return supportedLocale;
494             }
495 
496             @Override
497             public boolean isSupportedLocale(Locale locale) {
498                 return supportedLocaleSet.contains(locale.stripExtensions()) &amp;&amp;
499                        locale.getLanguage().equals(nativeDisplayLanguage);
500             }
501 
502             @Override
503             public String getDisplayLanguage(String languageCode, Locale locale) {
504                 // Retrieves the display language name by calling
505                 // GetLocaleInfoEx(LOCALE_SLOCALIZEDLANGUAGENAME).
506                 return getDisplayString(locale.toLanguageTag(),
507                             DN_LOCALE_LANGUAGE, languageCode);
508             }
509 
510             @Override
511             public String getDisplayCountry(String countryCode, Locale locale) {
512                 // Retrieves the display country name by calling
513                 // GetLocaleInfoEx(LOCALE_SLOCALIZEDCOUNTRYNAME).
514                 String str = getDisplayString(locale.toLanguageTag(),
515                                  DN_LOCALE_REGION,
516                                  nativeDisplayLanguage+&quot;-&quot;+countryCode);
517                 // Hack: Windows 10 returns translated &quot;Unknown Region (XX)&quot;
518                 // for localized XX region name. Take that as not known.
519                 if (str != null &amp;&amp; str.endsWith(&quot;(&quot;+countryCode+&quot;)&quot;)) {
520                     return null;
521                 }
522                 return str;
523             }
524 
525             @Override
526             public String getDisplayScript(String scriptCode, Locale locale) {
527                 return null;
528             }
529 
530             @Override
531             public String getDisplayVariant(String variantCode, Locale locale) {
532                 return null;
533             }
534         };
535     }
536 
537     public static JavaTimeDateTimePatternProvider getJavaTimeDateTimePatternProvider() {
538         return new JavaTimeDateTimePatternProvider() {
539             @Override
540             public Locale[] getAvailableLocales() {
541                 return getSupportedCalendarLocales();
542             }
543 
544             @Override
545             public boolean isSupportedLocale(Locale locale) {
546                 return isSupportedCalendarLocale(locale);
547             }
548 
549             @Override
550             public String getJavaTimeDateTimePattern(int timeStyle, int dateStyle, String calType, Locale locale) {
551                 AtomicReferenceArray&lt;String&gt; patterns = getDateTimePatterns(locale);
552                 String pattern = new StringBuilder(patterns.get(dateStyle / 2))
553                         .append(&quot; &quot;)
554                         .append(patterns.get(timeStyle / 2 + 2))
555                         .toString();
556                 return toJavaTimeDateTimePattern(calType, pattern);
557 
558             }
559 
560             private AtomicReferenceArray&lt;String&gt; getDateTimePatterns(Locale locale) {
561                 AtomicReferenceArray&lt;String&gt; patterns;
562                 SoftReference&lt;AtomicReferenceArray&lt;String&gt;&gt; ref = dateFormatCache.get(locale);
563 
564                 if (ref == null || (patterns = ref.get()) == null) {
565                     String langtag = removeExtensions(locale).toLanguageTag();
566                     patterns = new AtomicReferenceArray&lt;&gt;(4);
567                     patterns.compareAndSet(0, null, convertDateTimePattern(
568                             getDateTimePattern(DateFormat.LONG, -1, langtag)));
569                     patterns.compareAndSet(1, null, convertDateTimePattern(
570                             getDateTimePattern(DateFormat.SHORT, -1, langtag)));
571                     patterns.compareAndSet(2, null, convertDateTimePattern(
572                             getDateTimePattern(-1, DateFormat.LONG, langtag)));
573                     patterns.compareAndSet(3, null, convertDateTimePattern(
574                             getDateTimePattern(-1, DateFormat.SHORT, langtag)));
575                     ref = new SoftReference&lt;&gt;(patterns);
576                     dateFormatCache.put(locale, ref);
577                 }
578                 return patterns;
579             }
580             /**
581              * This method will convert JRE Date/time Pattern String to JSR310
582              * type Date/Time Pattern
583              */
584             private String toJavaTimeDateTimePattern(String calendarType, String jrePattern) {
585                 int length = jrePattern.length();
586                 StringBuilder sb = new StringBuilder(length);
587                 boolean inQuote = false;
588                 int count = 0;
589                 char lastLetter = 0;
590                 for (int i = 0; i &lt; length; i++) {
591                     char c = jrePattern.charAt(i);
592                     if (c == &#39;\&#39;&#39;) {
593                         // &#39;&#39; is treated as a single quote regardless of being
594                         // in a quoted section.
595                         if ((i + 1) &lt; length) {
596                             char nextc = jrePattern.charAt(i + 1);
597                             if (nextc == &#39;\&#39;&#39;) {
598                                 i++;
599                                 if (count != 0) {
600                                     convert(calendarType, lastLetter, count, sb);
601                                     lastLetter = 0;
602                                     count = 0;
603                                 }
604                                 sb.append(&quot;&#39;&#39;&quot;);
605                                 continue;
606                             }
607                         }
608                         if (!inQuote) {
609                             if (count != 0) {
610                                 convert(calendarType, lastLetter, count, sb);
611                                 lastLetter = 0;
612                                 count = 0;
613                             }
614                             inQuote = true;
615                         } else {
616                             inQuote = false;
617                         }
618                         sb.append(c);
619                         continue;
620                     }
621                     if (inQuote) {
622                         sb.append(c);
623                         continue;
624                     }
625                     if (!(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39; || c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)) {
626                         if (count != 0) {
627                             convert(calendarType, lastLetter, count, sb);
628                             lastLetter = 0;
629                             count = 0;
630                         }
631                         sb.append(c);
632                         continue;
633                     }
634                     if (lastLetter == 0 || lastLetter == c) {
635                         lastLetter = c;
636                         count++;
637                         continue;
638                     }
639                     convert(calendarType, lastLetter, count, sb);
640                     lastLetter = c;
641                     count = 1;
642                 }
643                 if (inQuote) {
644                     // should not come here.
645                     // returning null so that FALLBACK provider will kick in.
646                     return null;
647                 }
648                 if (count != 0) {
649                     convert(calendarType, lastLetter, count, sb);
650                 }
651                 return sb.toString();
652             }
653 
654             private void convert(String calendarType, char letter, int count, StringBuilder sb) {
655                 switch (letter) {
656                     case &#39;G&#39;:
657                         if (calendarType.equals(&quot;japanese&quot;)) {
658                             if (count &gt;= 4) {
659                                 count = 1;
660                             } else {
661                                 count = 5;
662                             }
663                         } else if (!calendarType.equals(&quot;iso8601&quot;)) {
664                             // Adjust the number of &#39;G&#39;s
665                             // Gregorian calendar is iso8601 for java.time
666                             if (count &gt;= 4) {
667                                 // JRE full -&gt; JavaTime full
668                                 count = 4;
669                             } else {
670                                 // JRE short -&gt; JavaTime short
671                                 count = 1;
672                             }
673                         }
674                         break;
675                     case &#39;y&#39;:
676                         if (calendarType.equals(&quot;japanese&quot;) &amp;&amp; count &gt;= 4) {
677                             // JRE specific &quot;gan-nen&quot; support
678                             count = 1;
679                         }
680                         break;
681                     default:
682                         // JSR 310 and CLDR define 5-letter patterns for narrow text.
683                         if (count &gt; 4) {
684                             count = 4;
685                         }
686                         break;
687                 }
688                 appendN(letter, count, sb);
689             }
690 
691             private void appendN(char c, int n, StringBuilder sb) {
692                 for (int i = 0; i &lt; n; i++) {
693                     sb.append(c);
694                 }
695             }
696         };
697     }
698 
699     private static String convertDateTimePattern(String winPattern) {
700         String ret = winPattern.replaceAll(&quot;dddd&quot;, &quot;EEEE&quot;);
701         ret = ret.replaceAll(&quot;ddd&quot;, &quot;EEE&quot;);
702         ret = ret.replaceAll(&quot;tt&quot;, &quot;aa&quot;);
703         ret = ret.replaceAll(&quot;g&quot;, &quot;GG&quot;);
704         return ret;
705     }
706 
707     private static Locale[] getSupportedCalendarLocales() {
708         if (supportedLocale.length != 0 &amp;&amp;
709             supportedLocaleSet.contains(Locale.JAPAN) &amp;&amp;
710             isJapaneseCalendar()) {
711             Locale[] sup = new Locale[supportedLocale.length+1];
712             sup[0] = JRELocaleConstants.JA_JP_JP;
713             System.arraycopy(supportedLocale, 0, sup, 1, supportedLocale.length);
714             return sup;
715         }
716         return supportedLocale;
717     }
718 
719     private static boolean isSupportedCalendarLocale(Locale locale) {
720         Locale base = stripVariantAndExtensions(locale);
721 
722         if (!supportedLocaleSet.contains(base)) {
723             return false;
724         }
725 
726         int calid = getCalendarID(base.toLanguageTag());
727         if (calid &lt;= 0 || calid &gt;= calIDToLDML.length) {
728             return false;
729         }
730 
731         String requestedCalType = locale.getUnicodeLocaleType(&quot;ca&quot;);
732         String nativeCalType = calIDToLDML[calid]
733                 .replaceFirst(&quot;_.*&quot;, &quot;&quot;); // remove locale part.
734 
735         if (requestedCalType == null) {
736             return Calendar.getAvailableCalendarTypes().contains(nativeCalType);
737         } else {
738             return requestedCalType.equals(nativeCalType);
739         }
740     }
741 
742     private static Locale[] getSupportedNativeDigitLocales() {
743         if (supportedLocale.length != 0 &amp;&amp;
744             supportedLocaleSet.contains(JRELocaleConstants.TH_TH) &amp;&amp;
745             isNativeDigit(&quot;th-TH&quot;)) {
746             Locale[] sup = new Locale[supportedLocale.length+1];
747             sup[0] = JRELocaleConstants.TH_TH_TH;
748             System.arraycopy(supportedLocale, 0, sup, 1, supportedLocale.length);
749             return sup;
750         }
751         return supportedLocale;
752     }
753 
754     private static boolean isSupportedNativeDigitLocale(Locale locale) {
755         // special case for th_TH_TH
756         if (JRELocaleConstants.TH_TH_TH.equals(locale)) {
757             return isNativeDigit(&quot;th-TH&quot;);
758         }
759 
760         String numtype = null;
761         Locale base = locale;
762         if (locale.hasExtensions()) {
763             numtype = locale.getUnicodeLocaleType(&quot;nu&quot;);
764             base = locale.stripExtensions();
765         }
766 
767         if (supportedLocaleSet.contains(base)) {
768             // Only supports Latin or Thai (in thai locales) digits.
769             if (numtype == null || numtype.equals(&quot;latn&quot;)) {
770                 return true;
771             } else if (locale.getLanguage().equals(&quot;th&quot;)) {
772                 return &quot;thai&quot;.equals(numtype) &amp;&amp;
773                        isNativeDigit(locale.toLanguageTag());
774             }
775         }
776 
777         return false;
778     }
779 
780     private static Locale removeExtensions(Locale src) {
781         return new Locale.Builder().setLocale(src).clearExtensions().build();
782     }
783 
784     private static boolean isJapaneseCalendar() {
785         return getCalendarID(&quot;ja-JP&quot;) == CAL_JAPAN;
786     }
787 
788     private static Locale stripVariantAndExtensions(Locale locale) {
789         if (locale.hasExtensions() || locale.getVariant() != &quot;&quot;) {
790             // strip off extensions and variant.
791             locale = new Locale.Builder()
792                             .setLocale(locale)
793                             .clearExtensions()
794                             .build();
795         }
796 
797         return locale;
798     }
799 
800     private static Locale getCalendarLocale(Locale locale) {
801         int calid = getCalendarID(stripVariantAndExtensions(locale).toLanguageTag());
802         if (calid &gt; 0 &amp;&amp; calid &lt; calIDToLDML.length) {
803             Locale.Builder lb = new Locale.Builder();
804             String[] caltype = calIDToLDML[calid].split(&quot;_&quot;);
805             if (caltype.length &gt; 1) {
806                 lb.setLocale(Locale.forLanguageTag(caltype[1]));
807             } else {
808                 lb.setLocale(locale);
809             }
810             lb.setUnicodeLocaleKeyword(&quot;ca&quot;, caltype[0]);
811             return lb.build();
812         }
813 
814         return locale;
815     }
816 
817     private static int getCalendarIDFromLDMLType(String ldmlType) {
818         for (int i = 0; i &lt; calIDToLDML.length; i++) {
819             if (calIDToLDML[i].startsWith(ldmlType)) {
820                 return i;
821             }
822         }
823         return -1;
824     }
825 
826     private static Locale getNumberLocale(Locale src) {
827         if (JRELocaleConstants.TH_TH.equals(src)) {
828             if (isNativeDigit(&quot;th-TH&quot;)) {
829                 Locale.Builder lb = new Locale.Builder().setLocale(src);
830                 lb.setUnicodeLocaleKeyword(&quot;nu&quot;, &quot;thai&quot;);
831                 return lb.build();
832             }
833         }
834 
835         return src;
836     }
837 
838     // native methods
839 
840     // initialize
841     private static native boolean initialize();
842     private static native String getDefaultLocale(int cat);
843 
844     // For DateFormatProvider
845     private static native String getDateTimePattern(int dateStyle, int timeStyle, String langTag);
846     private static native int getCalendarID(String langTag);
847 
848     // For DateFormatSymbolsProvider
849     private static native String[] getAmPmStrings(String langTag, String[] ampm);
850     private static native String[] getEras(String langTag, String[] eras);
851     private static native String[] getMonths(String langTag, String[] months);
852     private static native String[] getShortMonths(String langTag, String[] smonths);
853     private static native String[] getWeekdays(String langTag, String[] wdays);
854     private static native String[] getShortWeekdays(String langTag, String[] swdays);
855 
856     // For NumberFormatProvider
857     private static native String getNumberPattern(int numberStyle, String langTag);
858     private static native boolean isNativeDigit(String langTag);
859 
860     // For DecimalFormatSymbolsProvider
861     private static native String getCurrencySymbol(String langTag, String currencySymbol);
862     private static native char getDecimalSeparator(String langTag, char decimalSeparator);
863     private static native char getGroupingSeparator(String langTag, char groupingSeparator);
864     private static native String getInfinity(String langTag, String infinity);
865     private static native String getInternationalCurrencySymbol(String langTag, String internationalCurrencySymbol);
866     private static native char getMinusSign(String langTag, char minusSign);
867     private static native char getMonetaryDecimalSeparator(String langTag, char monetaryDecimalSeparator);
868     private static native String getNaN(String langTag, String nan);
869     private static native char getPercent(String langTag, char percent);
870     private static native char getPerMill(String langTag, char perMill);
871     private static native char getZeroDigit(String langTag, char zeroDigit);
872 
873     // For CalendarDataProvider
874     private static native int getCalendarDataValue(String langTag, int type);
875 
876     // For CalendarNameProvider
877     private static native String[] getCalendarDisplayStrings(String langTag, int calid, int field, int style);
878 
879     // For Locale/CurrencyNameProvider
880     private static native String getDisplayString(String langTag, int key, String value);
881 }
    </pre>
  </body>
</html>
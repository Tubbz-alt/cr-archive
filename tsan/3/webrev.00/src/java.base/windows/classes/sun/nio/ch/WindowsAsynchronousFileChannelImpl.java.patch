diff a/src/java.base/windows/classes/sun/nio/ch/WindowsAsynchronousFileChannelImpl.java b/src/java.base/windows/classes/sun/nio/ch/WindowsAsynchronousFileChannelImpl.java
--- a/src/java.base/windows/classes/sun/nio/ch/WindowsAsynchronousFileChannelImpl.java
+++ b/src/java.base/windows/classes/sun/nio/ch/WindowsAsynchronousFileChannelImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -226,11 +226,10 @@
         }
 
         @Override
         public void run() {
             long overlapped = 0L;
-            boolean pending = false;
             try {
                 begin();
 
                 // allocate OVERLAPPED structure
                 overlapped = ioCache.add(result);
@@ -240,24 +239,23 @@
                 synchronized (result) {
                     int n = lockFile(handle, position, fli.size(), fli.isShared(),
                                      overlapped);
                     if (n == IOStatus.UNAVAILABLE) {
                         // I/O is pending
-                        pending = true;
                         return;
                     }
                     // acquired lock immediately
                     result.setResult(fli);
                 }
 
             } catch (Throwable x) {
                 // lock failed or channel closed
                 removeFromFileLockTable(fli);
                 result.setFailure(toIOException(x));
-            } finally {
-                if (!pending && overlapped != 0L)
+                if (overlapped != 0L)
                     ioCache.remove(overlapped);
+            } finally {
                 end();
             }
 
             // invoke completion handler
             Invoker.invoke(result);
@@ -446,17 +444,16 @@
                 }
 
             } catch (Throwable x) {
                 // failed to initiate read
                 result.setFailure(toIOException(x));
+                if (overlapped != 0L)
+                    ioCache.remove(overlapped);
             } finally {
-                if (!pending) {
+                if (!pending)
                     // release resources
-                    if (overlapped != 0L)
-                        ioCache.remove(overlapped);
                     releaseBufferIfSubstituted();
-                }
                 end();
             }
 
             // invoke completion handler
             Invoker.invoke(result);
@@ -626,13 +623,13 @@
             } catch (Throwable x) {
                 // failed to initiate read:
                 result.setFailure(toIOException(x));
 
                 // release resources
+                releaseBufferIfSubstituted();
                 if (overlapped != 0L)
                     ioCache.remove(overlapped);
-                releaseBufferIfSubstituted();
 
             } finally {
                 end();
             }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/windows/classes/sun/nio/ch/WindowsSelectorImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="WindowsAsynchronousFileChannelImpl.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../fs/RegistryFileTypeDetector.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/classes/sun/nio/ch/WindowsSelectorImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -36,25 +36,40 @@</span>
  import java.util.Deque;
  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;
  import java.util.function.Consumer;
<span class="udiff-line-added">+ import jdk.internal.misc.Unsafe;</span>
  
  /**
   * A multi-threaded implementation of Selector for Windows.
   *
   * @author Konstantin Kladko
   * @author Mark Reinhold
   */
  
  class WindowsSelectorImpl extends SelectorImpl {
<span class="udiff-line-added">+     private static final Unsafe unsafe = Unsafe.getUnsafe();</span>
<span class="udiff-line-added">+     private static int addressSize = unsafe.addressSize();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static int dependsArch(int value32, int value64) {</span>
<span class="udiff-line-added">+         return (addressSize == 4) ? value32 : value64;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      // Initial capacity of the poll array
      private final int INIT_CAP = 8;
      // Maximum number of sockets for select().
      // Should be INIT_CAP times a power of 2
      private static final int MAX_SELECTABLE_FDS = 1024;
  
<span class="udiff-line-added">+     // Size of FD_SET struct to allocate a buffer for it in SubSelector,</span>
<span class="udiff-line-added">+     // aligned to 8 bytes on 64-bit:</span>
<span class="udiff-line-added">+     // struct { unsigned int fd_count; SOCKET fd_array[MAX_SELECTABLE_FDS]; }.</span>
<span class="udiff-line-added">+     private static final long SIZEOF_FD_SET = dependsArch(</span>
<span class="udiff-line-added">+             4 + MAX_SELECTABLE_FDS * 4,      // SOCKET = unsigned int</span>
<span class="udiff-line-added">+             4 + MAX_SELECTABLE_FDS * 8 + 4); // SOCKET = unsigned __int64</span>
<span class="udiff-line-added">+ </span>
      // The list of SelectableChannels serviced by this Selector. Every mod
      // MAX_SELECTABLE_FDS entry is bogus, to align this array with the poll
      // array,  where the corresponding entry is occupied by the wakeupSocket
      private SelectionKeyImpl[] channelArray = new SelectionKeyImpl[INIT_CAP];
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -324,10 +339,13 @@</span>
          // The first element of each array is the number of selected sockets.
          // Other elements are file descriptors of selected sockets.
          private final int[] readFds = new int [MAX_SELECTABLE_FDS + 1];
          private final int[] writeFds = new int [MAX_SELECTABLE_FDS + 1];
          private final int[] exceptFds = new int [MAX_SELECTABLE_FDS + 1];
<span class="udiff-line-added">+         // Buffer for readfds, writefds and exceptfds structs that are passed</span>
<span class="udiff-line-added">+         // to native select().</span>
<span class="udiff-line-added">+         private final long fdsBuffer = unsafe.allocateMemory(SIZEOF_FD_SET * 3);</span>
  
          private SubSelector() {
              this.pollArrayIndex = 0; // main thread
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,24 +354,24 @@</span>
          }
  
          private int poll() throws IOException{ // poll for the main thread
              return poll0(pollWrapper.pollArrayAddress,
                           Math.min(totalChannels, MAX_SELECTABLE_FDS),
<span class="udiff-line-modified-removed">-                          readFds, writeFds, exceptFds, timeout);</span>
<span class="udiff-line-modified-added">+                          readFds, writeFds, exceptFds, timeout, fdsBuffer);</span>
          }
  
          private int poll(int index) throws IOException {
              // poll for helper threads
              return  poll0(pollWrapper.pollArrayAddress +
                       (pollArrayIndex * PollArrayWrapper.SIZE_POLLFD),
                       Math.min(MAX_SELECTABLE_FDS,
                               totalChannels - (index + 1) * MAX_SELECTABLE_FDS),
<span class="udiff-line-modified-removed">-                      readFds, writeFds, exceptFds, timeout);</span>
<span class="udiff-line-modified-added">+                      readFds, writeFds, exceptFds, timeout, fdsBuffer);</span>
          }
  
          private native int poll0(long pollAddress, int numfds,
<span class="udiff-line-modified-removed">-              int[] readFds, int[] writeFds, int[] exceptFds, long timeout);</span>
<span class="udiff-line-modified-added">+              int[] readFds, int[] writeFds, int[] exceptFds, long timeout, long fdsBuffer);</span>
  
          private int processSelectedKeys(long updateCount, Consumer&lt;SelectionKey&gt; action) {
              int numKeysUpdated = 0;
              numKeysUpdated += processFDSet(updateCount, action, readFds,
                                             Net.POLLIN,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -413,10 +431,14 @@</span>
                      numKeysUpdated++;
                  }
              }
              return numKeysUpdated;
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private void freeFDSetBuffer() {</span>
<span class="udiff-line-added">+             unsafe.freeMemory(fdsBuffer);</span>
<span class="udiff-line-added">+         }</span>
      }
  
      // Represents a helper thread used for select.
      private final class SelectThread extends Thread {
          private final int index; // index of this thread
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -439,12 +461,14 @@</span>
          }
          public void run() {
              while (true) { // poll loop
                  // wait for the start of poll. If this thread has become
                  // redundant, then exit.
<span class="udiff-line-modified-removed">-                 if (startLock.waitForStart(this))</span>
<span class="udiff-line-modified-added">+                 if (startLock.waitForStart(this)) {</span>
<span class="udiff-line-added">+                     subSelector.freeFDSetBuffer();</span>
                      return;
<span class="udiff-line-added">+                 }</span>
                  // call poll()
                  try {
                      subSelector.poll(index);
                  } catch (IOException e) {
                      // Save this exception and let other threads finish.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -531,10 +555,11 @@</span>
  
          // Make all remaining helper threads exit
          for (SelectThread t: threads)
               t.makeZombie();
          startLock.startThreads();
<span class="udiff-line-added">+         subSelector.freeFDSetBuffer();</span>
      }
  
      @Override
      protected void implRegister(SelectionKeyImpl ski) {
          ensureOpen();
</pre>
<center><a href="WindowsAsynchronousFileChannelImpl.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../fs/RegistryFileTypeDetector.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
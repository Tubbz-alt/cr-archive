<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/classes/sun/nio/ch/WindowsSelectorImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="WindowsAsynchronousFileChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../fs/RegistryFileTypeDetector.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/classes/sun/nio/ch/WindowsSelectorImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.nio.channels.ClosedSelectorException;
 30 import java.nio.channels.Pipe;
 31 import java.nio.channels.SelectionKey;
 32 import java.nio.channels.Selector;
 33 import java.nio.channels.spi.SelectorProvider;
 34 import java.util.ArrayDeque;
 35 import java.util.ArrayList;
 36 import java.util.Deque;
 37 import java.util.HashMap;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.function.Consumer;

 41 
 42 /**
 43  * A multi-threaded implementation of Selector for Windows.
 44  *
 45  * @author Konstantin Kladko
 46  * @author Mark Reinhold
 47  */
 48 
 49 class WindowsSelectorImpl extends SelectorImpl {







 50     // Initial capacity of the poll array
 51     private final int INIT_CAP = 8;
 52     // Maximum number of sockets for select().
 53     // Should be INIT_CAP times a power of 2
 54     private static final int MAX_SELECTABLE_FDS = 1024;
 55 







 56     // The list of SelectableChannels serviced by this Selector. Every mod
 57     // MAX_SELECTABLE_FDS entry is bogus, to align this array with the poll
 58     // array,  where the corresponding entry is occupied by the wakeupSocket
 59     private SelectionKeyImpl[] channelArray = new SelectionKeyImpl[INIT_CAP];
 60 
 61     // The global native poll array holds file decriptors and event masks
 62     private PollArrayWrapper pollWrapper;
 63 
 64     // The number of valid entries in  poll array, including entries occupied
 65     // by wakeup socket handle.
 66     private int totalChannels = 1;
 67 
 68     // Number of helper threads needed for select. We need one thread per
 69     // each additional set of MAX_SELECTABLE_FDS - 1 channels.
 70     private int threadsCount = 0;
 71 
 72     // A list of helper threads for select.
 73     private final List&lt;SelectThread&gt; threads = new ArrayList&lt;SelectThread&gt;();
 74 
 75     //Pipe used as a wakeup object.
</pre>
<hr />
<pre>
309         private void checkForException() throws IOException {
310             if (exception == null)
311                 return;
312             StringBuffer message =  new StringBuffer(&quot;An exception occurred&quot; +
313                                        &quot; during the execution of select(): \n&quot;);
314             message.append(exception);
315             message.append(&#39;\n&#39;);
316             exception = null;
317             throw new IOException(message.toString());
318         }
319     }
320 
321     private final class SubSelector {
322         private final int pollArrayIndex; // starting index in pollArray to poll
323         // These arrays will hold result of native select().
324         // The first element of each array is the number of selected sockets.
325         // Other elements are file descriptors of selected sockets.
326         private final int[] readFds = new int [MAX_SELECTABLE_FDS + 1];
327         private final int[] writeFds = new int [MAX_SELECTABLE_FDS + 1];
328         private final int[] exceptFds = new int [MAX_SELECTABLE_FDS + 1];



329 
330         private SubSelector() {
331             this.pollArrayIndex = 0; // main thread
332         }
333 
334         private SubSelector(int threadIndex) { // helper threads
335             this.pollArrayIndex = (threadIndex + 1) * MAX_SELECTABLE_FDS;
336         }
337 
338         private int poll() throws IOException{ // poll for the main thread
339             return poll0(pollWrapper.pollArrayAddress,
340                          Math.min(totalChannels, MAX_SELECTABLE_FDS),
<span class="line-modified">341                          readFds, writeFds, exceptFds, timeout);</span>
342         }
343 
344         private int poll(int index) throws IOException {
345             // poll for helper threads
346             return  poll0(pollWrapper.pollArrayAddress +
347                      (pollArrayIndex * PollArrayWrapper.SIZE_POLLFD),
348                      Math.min(MAX_SELECTABLE_FDS,
349                              totalChannels - (index + 1) * MAX_SELECTABLE_FDS),
<span class="line-modified">350                      readFds, writeFds, exceptFds, timeout);</span>
351         }
352 
353         private native int poll0(long pollAddress, int numfds,
<span class="line-modified">354              int[] readFds, int[] writeFds, int[] exceptFds, long timeout);</span>
355 
356         private int processSelectedKeys(long updateCount, Consumer&lt;SelectionKey&gt; action) {
357             int numKeysUpdated = 0;
358             numKeysUpdated += processFDSet(updateCount, action, readFds,
359                                            Net.POLLIN,
360                                            false);
361             numKeysUpdated += processFDSet(updateCount, action, writeFds,
362                                            Net.POLLCONN |
363                                            Net.POLLOUT,
364                                            false);
365             numKeysUpdated += processFDSet(updateCount, action, exceptFds,
366                                            Net.POLLIN |
367                                            Net.POLLCONN |
368                                            Net.POLLOUT,
369                                            true);
370             return numKeysUpdated;
371         }
372 
373         /**
374          * updateCount is used to tell if a key has been counted as updated
</pre>
<hr />
<pre>
398                 SelectionKeyImpl sk = me.ski;
399 
400                 // The descriptor may be in the exceptfds set because there is
401                 // OOB data queued to the socket. If there is OOB data then it
402                 // is discarded and the key is not added to the selected set.
403                 if (isExceptFds &amp;&amp;
404                     (sk.channel() instanceof SocketChannelImpl) &amp;&amp;
405                     discardUrgentData(desc))
406                 {
407                     continue;
408                 }
409 
410                 int updated = processReadyEvents(rOps, sk, action);
411                 if (updated &gt; 0 &amp;&amp; me.updateCount != updateCount) {
412                     me.updateCount = updateCount;
413                     numKeysUpdated++;
414                 }
415             }
416             return numKeysUpdated;
417         }




418     }
419 
420     // Represents a helper thread used for select.
421     private final class SelectThread extends Thread {
422         private final int index; // index of this thread
423         final SubSelector subSelector;
424         private long lastRun = 0; // last run number
425         private volatile boolean zombie;
426         // Creates a new thread
427         private SelectThread(int i) {
428             super(null, null, &quot;SelectorHelper&quot;, 0, false);
429             this.index = i;
430             this.subSelector = new SubSelector(i);
431             //make sure we wait for next round of poll
432             this.lastRun = startLock.runsCounter;
433         }
434         void makeZombie() {
435             zombie = true;
436         }
437         boolean isZombie() {
438             return zombie;
439         }
440         public void run() {
441             while (true) { // poll loop
442                 // wait for the start of poll. If this thread has become
443                 // redundant, then exit.
<span class="line-modified">444                 if (startLock.waitForStart(this))</span>

445                     return;

446                 // call poll()
447                 try {
448                     subSelector.poll(index);
449                 } catch (IOException e) {
450                     // Save this exception and let other threads finish.
451                     finishLock.setException(e);
452                 }
453                 // notify main thread, that this thread has finished, and
454                 // wakeup others, if this thread is the first to finish.
455                 finishLock.threadFinished();
456             }
457         }
458     }
459 
460     // After some channels registered/deregistered, the number of required
461     // helper threads may have changed. Adjust this number.
462     private void adjustThreadsCount() {
463         if (threadsCount &gt; threads.size()) {
464             // More threads needed. Start more threads.
465             for (int i = threads.size(); i &lt; threadsCount; i++) {
</pre>
<hr />
<pre>
516     }
517 
518     @Override
519     protected void implClose() throws IOException {
520         assert !isOpen();
521         assert Thread.holdsLock(this);
522 
523         // prevent further wakeup
524         synchronized (interruptLock) {
525             interruptTriggered = true;
526         }
527 
528         wakeupPipe.sink().close();
529         wakeupPipe.source().close();
530         pollWrapper.free();
531 
532         // Make all remaining helper threads exit
533         for (SelectThread t: threads)
534              t.makeZombie();
535         startLock.startThreads();

536     }
537 
538     @Override
539     protected void implRegister(SelectionKeyImpl ski) {
540         ensureOpen();
541         synchronized (updateLock) {
542             newKeys.addLast(ski);
543         }
544     }
545 
546     private void growIfNeeded() {
547         if (channelArray.length == totalChannels) {
548             int newSize = totalChannels * 2; // Make a larger array
549             SelectionKeyImpl temp[] = new SelectionKeyImpl[newSize];
550             System.arraycopy(channelArray, 1, temp, 1, totalChannels - 1);
551             channelArray = temp;
552             pollWrapper.grow(newSize);
553         }
554         if (totalChannels % MAX_SELECTABLE_FDS == 0) { // more threads needed
555             pollWrapper.addWakeupSocket(wakeupSourceFd, totalChannels);
</pre>
</td>
<td>
<hr />
<pre>
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.io.IOException;
 29 import java.nio.channels.ClosedSelectorException;
 30 import java.nio.channels.Pipe;
 31 import java.nio.channels.SelectionKey;
 32 import java.nio.channels.Selector;
 33 import java.nio.channels.spi.SelectorProvider;
 34 import java.util.ArrayDeque;
 35 import java.util.ArrayList;
 36 import java.util.Deque;
 37 import java.util.HashMap;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.function.Consumer;
<span class="line-added"> 41 import jdk.internal.misc.Unsafe;</span>
 42 
 43 /**
 44  * A multi-threaded implementation of Selector for Windows.
 45  *
 46  * @author Konstantin Kladko
 47  * @author Mark Reinhold
 48  */
 49 
 50 class WindowsSelectorImpl extends SelectorImpl {
<span class="line-added"> 51     private static final Unsafe unsafe = Unsafe.getUnsafe();</span>
<span class="line-added"> 52     private static int addressSize = unsafe.addressSize();</span>
<span class="line-added"> 53 </span>
<span class="line-added"> 54     private static int dependsArch(int value32, int value64) {</span>
<span class="line-added"> 55         return (addressSize == 4) ? value32 : value64;</span>
<span class="line-added"> 56     }</span>
<span class="line-added"> 57 </span>
 58     // Initial capacity of the poll array
 59     private final int INIT_CAP = 8;
 60     // Maximum number of sockets for select().
 61     // Should be INIT_CAP times a power of 2
 62     private static final int MAX_SELECTABLE_FDS = 1024;
 63 
<span class="line-added"> 64     // Size of FD_SET struct to allocate a buffer for it in SubSelector,</span>
<span class="line-added"> 65     // aligned to 8 bytes on 64-bit:</span>
<span class="line-added"> 66     // struct { unsigned int fd_count; SOCKET fd_array[MAX_SELECTABLE_FDS]; }.</span>
<span class="line-added"> 67     private static final long SIZEOF_FD_SET = dependsArch(</span>
<span class="line-added"> 68             4 + MAX_SELECTABLE_FDS * 4,      // SOCKET = unsigned int</span>
<span class="line-added"> 69             4 + MAX_SELECTABLE_FDS * 8 + 4); // SOCKET = unsigned __int64</span>
<span class="line-added"> 70 </span>
 71     // The list of SelectableChannels serviced by this Selector. Every mod
 72     // MAX_SELECTABLE_FDS entry is bogus, to align this array with the poll
 73     // array,  where the corresponding entry is occupied by the wakeupSocket
 74     private SelectionKeyImpl[] channelArray = new SelectionKeyImpl[INIT_CAP];
 75 
 76     // The global native poll array holds file decriptors and event masks
 77     private PollArrayWrapper pollWrapper;
 78 
 79     // The number of valid entries in  poll array, including entries occupied
 80     // by wakeup socket handle.
 81     private int totalChannels = 1;
 82 
 83     // Number of helper threads needed for select. We need one thread per
 84     // each additional set of MAX_SELECTABLE_FDS - 1 channels.
 85     private int threadsCount = 0;
 86 
 87     // A list of helper threads for select.
 88     private final List&lt;SelectThread&gt; threads = new ArrayList&lt;SelectThread&gt;();
 89 
 90     //Pipe used as a wakeup object.
</pre>
<hr />
<pre>
324         private void checkForException() throws IOException {
325             if (exception == null)
326                 return;
327             StringBuffer message =  new StringBuffer(&quot;An exception occurred&quot; +
328                                        &quot; during the execution of select(): \n&quot;);
329             message.append(exception);
330             message.append(&#39;\n&#39;);
331             exception = null;
332             throw new IOException(message.toString());
333         }
334     }
335 
336     private final class SubSelector {
337         private final int pollArrayIndex; // starting index in pollArray to poll
338         // These arrays will hold result of native select().
339         // The first element of each array is the number of selected sockets.
340         // Other elements are file descriptors of selected sockets.
341         private final int[] readFds = new int [MAX_SELECTABLE_FDS + 1];
342         private final int[] writeFds = new int [MAX_SELECTABLE_FDS + 1];
343         private final int[] exceptFds = new int [MAX_SELECTABLE_FDS + 1];
<span class="line-added">344         // Buffer for readfds, writefds and exceptfds structs that are passed</span>
<span class="line-added">345         // to native select().</span>
<span class="line-added">346         private final long fdsBuffer = unsafe.allocateMemory(SIZEOF_FD_SET * 3);</span>
347 
348         private SubSelector() {
349             this.pollArrayIndex = 0; // main thread
350         }
351 
352         private SubSelector(int threadIndex) { // helper threads
353             this.pollArrayIndex = (threadIndex + 1) * MAX_SELECTABLE_FDS;
354         }
355 
356         private int poll() throws IOException{ // poll for the main thread
357             return poll0(pollWrapper.pollArrayAddress,
358                          Math.min(totalChannels, MAX_SELECTABLE_FDS),
<span class="line-modified">359                          readFds, writeFds, exceptFds, timeout, fdsBuffer);</span>
360         }
361 
362         private int poll(int index) throws IOException {
363             // poll for helper threads
364             return  poll0(pollWrapper.pollArrayAddress +
365                      (pollArrayIndex * PollArrayWrapper.SIZE_POLLFD),
366                      Math.min(MAX_SELECTABLE_FDS,
367                              totalChannels - (index + 1) * MAX_SELECTABLE_FDS),
<span class="line-modified">368                      readFds, writeFds, exceptFds, timeout, fdsBuffer);</span>
369         }
370 
371         private native int poll0(long pollAddress, int numfds,
<span class="line-modified">372              int[] readFds, int[] writeFds, int[] exceptFds, long timeout, long fdsBuffer);</span>
373 
374         private int processSelectedKeys(long updateCount, Consumer&lt;SelectionKey&gt; action) {
375             int numKeysUpdated = 0;
376             numKeysUpdated += processFDSet(updateCount, action, readFds,
377                                            Net.POLLIN,
378                                            false);
379             numKeysUpdated += processFDSet(updateCount, action, writeFds,
380                                            Net.POLLCONN |
381                                            Net.POLLOUT,
382                                            false);
383             numKeysUpdated += processFDSet(updateCount, action, exceptFds,
384                                            Net.POLLIN |
385                                            Net.POLLCONN |
386                                            Net.POLLOUT,
387                                            true);
388             return numKeysUpdated;
389         }
390 
391         /**
392          * updateCount is used to tell if a key has been counted as updated
</pre>
<hr />
<pre>
416                 SelectionKeyImpl sk = me.ski;
417 
418                 // The descriptor may be in the exceptfds set because there is
419                 // OOB data queued to the socket. If there is OOB data then it
420                 // is discarded and the key is not added to the selected set.
421                 if (isExceptFds &amp;&amp;
422                     (sk.channel() instanceof SocketChannelImpl) &amp;&amp;
423                     discardUrgentData(desc))
424                 {
425                     continue;
426                 }
427 
428                 int updated = processReadyEvents(rOps, sk, action);
429                 if (updated &gt; 0 &amp;&amp; me.updateCount != updateCount) {
430                     me.updateCount = updateCount;
431                     numKeysUpdated++;
432                 }
433             }
434             return numKeysUpdated;
435         }
<span class="line-added">436 </span>
<span class="line-added">437         private void freeFDSetBuffer() {</span>
<span class="line-added">438             unsafe.freeMemory(fdsBuffer);</span>
<span class="line-added">439         }</span>
440     }
441 
442     // Represents a helper thread used for select.
443     private final class SelectThread extends Thread {
444         private final int index; // index of this thread
445         final SubSelector subSelector;
446         private long lastRun = 0; // last run number
447         private volatile boolean zombie;
448         // Creates a new thread
449         private SelectThread(int i) {
450             super(null, null, &quot;SelectorHelper&quot;, 0, false);
451             this.index = i;
452             this.subSelector = new SubSelector(i);
453             //make sure we wait for next round of poll
454             this.lastRun = startLock.runsCounter;
455         }
456         void makeZombie() {
457             zombie = true;
458         }
459         boolean isZombie() {
460             return zombie;
461         }
462         public void run() {
463             while (true) { // poll loop
464                 // wait for the start of poll. If this thread has become
465                 // redundant, then exit.
<span class="line-modified">466                 if (startLock.waitForStart(this)) {</span>
<span class="line-added">467                     subSelector.freeFDSetBuffer();</span>
468                     return;
<span class="line-added">469                 }</span>
470                 // call poll()
471                 try {
472                     subSelector.poll(index);
473                 } catch (IOException e) {
474                     // Save this exception and let other threads finish.
475                     finishLock.setException(e);
476                 }
477                 // notify main thread, that this thread has finished, and
478                 // wakeup others, if this thread is the first to finish.
479                 finishLock.threadFinished();
480             }
481         }
482     }
483 
484     // After some channels registered/deregistered, the number of required
485     // helper threads may have changed. Adjust this number.
486     private void adjustThreadsCount() {
487         if (threadsCount &gt; threads.size()) {
488             // More threads needed. Start more threads.
489             for (int i = threads.size(); i &lt; threadsCount; i++) {
</pre>
<hr />
<pre>
540     }
541 
542     @Override
543     protected void implClose() throws IOException {
544         assert !isOpen();
545         assert Thread.holdsLock(this);
546 
547         // prevent further wakeup
548         synchronized (interruptLock) {
549             interruptTriggered = true;
550         }
551 
552         wakeupPipe.sink().close();
553         wakeupPipe.source().close();
554         pollWrapper.free();
555 
556         // Make all remaining helper threads exit
557         for (SelectThread t: threads)
558              t.makeZombie();
559         startLock.startThreads();
<span class="line-added">560         subSelector.freeFDSetBuffer();</span>
561     }
562 
563     @Override
564     protected void implRegister(SelectionKeyImpl ski) {
565         ensureOpen();
566         synchronized (updateLock) {
567             newKeys.addLast(ski);
568         }
569     }
570 
571     private void growIfNeeded() {
572         if (channelArray.length == totalChannels) {
573             int newSize = totalChannels * 2; // Make a larger array
574             SelectionKeyImpl temp[] = new SelectionKeyImpl[newSize];
575             System.arraycopy(channelArray, 1, temp, 1, totalChannels - 1);
576             channelArray = temp;
577             pollWrapper.grow(newSize);
578         }
579         if (totalChannels % MAX_SELECTABLE_FDS == 0) { // more threads needed
580             pollWrapper.addWakeupSocket(wakeupSourceFd, totalChannels);
</pre>
</td>
</tr>
</table>
<center><a href="WindowsAsynchronousFileChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../fs/RegistryFileTypeDetector.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
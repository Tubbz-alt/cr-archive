<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/classes/sun/nio/fs/WindowsFileStore.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.fs;
 27 
 28 import java.nio.file.*;
 29 import java.nio.file.attribute.*;
 30 import java.io.IOException;
 31 
 32 import static sun.nio.fs.WindowsConstants.*;
 33 import static sun.nio.fs.WindowsNativeDispatcher.*;
 34 
 35 /**
 36  * Windows implementation of FileStore.
 37  */
 38 
 39 class WindowsFileStore
 40     extends FileStore
 41 {
 42     private final String root;
 43     private final VolumeInformation volInfo;
 44     private final int volType;
 45     private final String displayName;   // returned by toString
 46 
 47     private WindowsFileStore(String root) throws WindowsException {
 48         assert root.charAt(root.length()-1) == &#39;\\&#39;;
 49         this.root = root;
 50         this.volInfo = GetVolumeInformation(root);
 51         this.volType = GetDriveType(root);
 52 
 53         // file store &quot;display name&quot; is the volume name if available
 54         String vol = volInfo.volumeName();
 55         if (!vol.isEmpty()) {
 56             this.displayName = vol;
 57         } else {
 58             // TBD - should we map all types? Does this need to be localized?
 59             this.displayName = (volType == DRIVE_REMOVABLE) ? &quot;Removable Disk&quot; : &quot;&quot;;
 60         }
 61     }
 62 
 63     static WindowsFileStore create(String root, boolean ignoreNotReady)
 64         throws IOException
 65     {
 66         try {
 67             return new WindowsFileStore(root);
 68         } catch (WindowsException x) {
 69             if (ignoreNotReady &amp;&amp; x.lastError() == ERROR_NOT_READY)
 70                 return null;
 71             x.rethrowAsIOException(root);
 72             return null; // keep compiler happy
 73         }
 74     }
 75 
 76     static WindowsFileStore create(WindowsPath file) throws IOException {
 77         try {
 78             // if the file is a link then GetVolumePathName returns the
 79             // volume that the link is on so we need to call it with the
 80             // final target
 81             String target = WindowsLinkSupport.getFinalPath(file, true);
 82             try {
 83                 return createFromPath(target);
 84             } catch (WindowsException e) {
 85                 if (e.lastError() != ERROR_DIR_NOT_ROOT)
 86                     throw e;
 87                 target = WindowsLinkSupport.getFinalPath(file);
 88                 if (target == null)
 89                     throw new FileSystemException(file.getPathForExceptionMessage(),
 90                             null, &quot;Couldn&#39;t resolve path&quot;);
 91                 return createFromPath(target);
 92             }
 93         } catch (WindowsException x) {
 94             x.rethrowAsIOException(file);
 95             return null; // keep compiler happy
 96         }
 97     }
 98 
 99     private static WindowsFileStore createFromPath(String target) throws WindowsException {
100         String root = GetVolumePathName(target);
101         return new WindowsFileStore(root);
102     }
103 
104     VolumeInformation volumeInformation() {
105         return volInfo;
106     }
107 
108     int volumeType() {
109         return volType;
110     }
111 
112     @Override
113     public String name() {
114         return volInfo.volumeName();   // &quot;SYSTEM&quot;, &quot;DVD-RW&quot;, ...
115     }
116 
117     @Override
118     public String type() {
119         return volInfo.fileSystemName();  // &quot;FAT&quot;, &quot;NTFS&quot;, ...
120     }
121 
122     @Override
123     public boolean isReadOnly() {
124         return ((volInfo.flags() &amp; FILE_READ_ONLY_VOLUME) != 0);
125     }
126 
127     // read the free space info
128     private DiskFreeSpace readDiskFreeSpaceEx() throws IOException {
129         try {
130             return GetDiskFreeSpaceEx(root);
131         } catch (WindowsException x) {
132             x.rethrowAsIOException(root);
133             return null;
134         }
135     }
136 
137     private DiskFreeSpace readDiskFreeSpace() throws IOException {
138         try {
139             return GetDiskFreeSpace(root);
140         } catch (WindowsException x) {
141             x.rethrowAsIOException(root);
142             return null;
143         }
144     }
145 
146     @Override
147     public long getTotalSpace() throws IOException {
<a name="2" id="anc2"></a><span class="line-modified">148         long space = readDiskFreeSpaceEx().totalNumberOfBytes();</span>
<span class="line-added">149         return space &gt;= 0 ? space : Long.MAX_VALUE;</span>
150     }
151 
152     @Override
153     public long getUsableSpace() throws IOException {
<a name="3" id="anc3"></a><span class="line-modified">154         long space = readDiskFreeSpaceEx().freeBytesAvailable();</span>
<span class="line-added">155         return space &gt;= 0 ? space : Long.MAX_VALUE;</span>
156     }
157 
<a name="4" id="anc4"></a><span class="line-modified">158     @Override</span>
<span class="line-modified">159     public long getUnallocatedSpace() throws IOException {</span>
<span class="line-added">160         long space = readDiskFreeSpaceEx().freeBytesAvailable();</span>
<span class="line-added">161         return space &gt;= 0 ? space : Long.MAX_VALUE;</span>
162     }
163 
164     @Override
<a name="5" id="anc5"></a><span class="line-modified">165     public long getBlockSize() throws IOException {</span>
<span class="line-modified">166         return readDiskFreeSpace().bytesPerSector();</span>
167     }
168 
169     @Override
170     public &lt;V extends FileStoreAttributeView&gt; V getFileStoreAttributeView(Class&lt;V&gt; type) {
171         if (type == null)
172             throw new NullPointerException();
173         return (V) null;
174     }
175 
176     @Override
177     public Object getAttribute(String attribute) throws IOException {
178         // standard
179         if (attribute.equals(&quot;totalSpace&quot;))
180             return getTotalSpace();
181         if (attribute.equals(&quot;usableSpace&quot;))
182             return getUsableSpace();
183         if (attribute.equals(&quot;unallocatedSpace&quot;))
184             return getUnallocatedSpace();
185         if (attribute.equals(&quot;bytesPerSector&quot;))
186             return getBlockSize();
187         // windows specific for testing purposes
188         if (attribute.equals(&quot;volume:vsn&quot;))
189             return volInfo.volumeSerialNumber();
190         if (attribute.equals(&quot;volume:isRemovable&quot;))
191             return volType == DRIVE_REMOVABLE;
192         if (attribute.equals(&quot;volume:isCdrom&quot;))
193             return volType == DRIVE_CDROM;
194         throw new UnsupportedOperationException(&quot;&#39;&quot; + attribute + &quot;&#39; not recognized&quot;);
195     }
196 
197     @Override
198     public boolean supportsFileAttributeView(Class&lt;? extends FileAttributeView&gt; type) {
199         if (type == null)
200             throw new NullPointerException();
201         if (type == BasicFileAttributeView.class || type == DosFileAttributeView.class)
202             return true;
203         if (type == AclFileAttributeView.class || type == FileOwnerAttributeView.class)
204             return ((volInfo.flags() &amp; FILE_PERSISTENT_ACLS) != 0);
205         if (type == UserDefinedFileAttributeView.class)
206             return ((volInfo.flags() &amp; FILE_NAMED_STREAMS) != 0);
207         return false;
208     }
209 
210     @Override
211     public boolean supportsFileAttributeView(String name) {
212         if (name.equals(&quot;basic&quot;) || name.equals(&quot;dos&quot;))
213             return true;
214         if (name.equals(&quot;acl&quot;))
215             return supportsFileAttributeView(AclFileAttributeView.class);
216         if (name.equals(&quot;owner&quot;))
217             return supportsFileAttributeView(FileOwnerAttributeView.class);
218         if (name.equals(&quot;user&quot;))
219             return supportsFileAttributeView(UserDefinedFileAttributeView.class);
220         return false;
221     }
222 
223     @Override
224     public boolean equals(Object ob) {
225         if (ob == this)
226             return true;
227         if (!(ob instanceof WindowsFileStore))
228             return false;
229         WindowsFileStore other = (WindowsFileStore)ob;
230         return root.equals(other.root);
231     }
232 
233     @Override
234     public int hashCode() {
235         return root.hashCode();
236     }
237 
238     @Override
239     public String toString() {
240         StringBuilder sb = new StringBuilder(displayName);
241         if (sb.length() &gt; 0)
242             sb.append(&quot; &quot;);
243         sb.append(&quot;(&quot;);
244         // drop trailing slash
245         sb.append(root.subSequence(0, root.length()-1));
246         sb.append(&quot;)&quot;);
247         return sb.toString();
248     }
249  }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/windows/classes/java/net/DualStackPlainDatagramSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
 26 
 27 import java.io.IOException;
<a name="2" id="anc2"></a><span class="line-added"> 28 import java.util.Collections;</span>
<span class="line-added"> 29 import java.util.HashSet;</span>
<span class="line-added"> 30 import java.util.Set;</span>
 31 import jdk.internal.access.SharedSecrets;
 32 import jdk.internal.access.JavaIOFileDescriptorAccess;
 33 
<a name="3" id="anc3"></a><span class="line-added"> 34 import sun.net.ext.ExtendedSocketOptions;</span>
<span class="line-added"> 35 </span>
 36 /**
 37  * This class defines the plain DatagramSocketImpl that is used on
 38  * Windows platforms greater than or equal to Windows Vista. These
 39  * platforms have a dual layer TCP/IP stack and can handle both IPv4
 40  * and IPV6 through a single file descriptor.
 41  * &lt;p&gt;
 42  * Note: Multicasting on a dual layer TCP/IP stack is always done with
 43  * TwoStacksPlainDatagramSocketImpl. This is to overcome the lack
 44  * of behavior defined for multicasting over a dual layer socket by the RFC.
 45  *
 46  * @author Chris Hegarty
 47  */
 48 
 49 class DualStackPlainDatagramSocketImpl extends AbstractPlainDatagramSocketImpl
 50 {
 51     static JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();
 52 
 53     static {
 54         initIDs();
 55     }
 56 
 57     // true if this socket is exclusively bound
 58     private final boolean exclusiveBind;
 59 
 60     /*
 61      * Set to true if SO_REUSEADDR is set after the socket is bound to
 62      * indicate SO_REUSEADDR is being emulated
 63      */
 64     private boolean reuseAddressEmulated;
 65 
 66     // emulates SO_REUSEADDR when exclusiveBind is true and socket is bound
 67     private boolean isReuseAddress;
 68 
 69     DualStackPlainDatagramSocketImpl(boolean exclBind) {
<a name="4" id="anc4"></a><span class="line-added"> 70         super(false);</span>
 71         exclusiveBind = exclBind;
 72     }
 73 
 74     protected void datagramSocketCreate() throws SocketException {
 75         if (fd == null)
 76             throw new SocketException(&quot;Socket closed&quot;);
 77 
 78         int newfd = socketCreate();
 79 
 80         fdAccess.set(fd, newfd);
 81     }
 82 
 83     protected synchronized void bind0(int lport, InetAddress laddr)
 84         throws SocketException {
 85         int nativefd = checkAndReturnNativeFD();
 86 
 87         if (laddr == null)
 88             throw new NullPointerException(&quot;argument address&quot;);
 89 
 90         socketBind(nativefd, laddr, lport, exclusiveBind);
 91         if (lport == 0) {
 92             localPort = socketLocalPort(nativefd);
 93         } else {
 94             localPort = lport;
 95         }
 96     }
 97 
 98     protected synchronized int peek(InetAddress address) throws IOException {
 99         int nativefd = checkAndReturnNativeFD();
100 
101         if (address == null)
102             throw new NullPointerException(&quot;Null address in peek()&quot;);
103 
104         // Use peekData()
105         DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);
106         int peekPort = peekData(peekPacket);
107         address = peekPacket.getAddress();
108         return peekPort;
109     }
110 
111     protected synchronized int peekData(DatagramPacket p) throws IOException {
112         int nativefd = checkAndReturnNativeFD();
113 
114         if (p == null)
115             throw new NullPointerException(&quot;packet&quot;);
116         if (p.getData() == null)
117             throw new NullPointerException(&quot;packet buffer&quot;);
118 
119         return socketReceiveOrPeekData(nativefd, p, timeout, connected, true /*peek*/);
120     }
121 
122     protected synchronized void receive0(DatagramPacket p) throws IOException {
123         int nativefd = checkAndReturnNativeFD();
124 
125         if (p == null)
126             throw new NullPointerException(&quot;packet&quot;);
127         if (p.getData() == null)
128             throw new NullPointerException(&quot;packet buffer&quot;);
129 
130         socketReceiveOrPeekData(nativefd, p, timeout, connected, false /*receive*/);
131     }
132 
<a name="5" id="anc5"></a><span class="line-modified">133     protected void send0(DatagramPacket p) throws IOException {</span>
134         int nativefd = checkAndReturnNativeFD();
135 
136         if (p == null)
137             throw new NullPointerException(&quot;null packet&quot;);
138 
139         if (p.getAddress() == null ||p.getData() ==null)
140             throw new NullPointerException(&quot;null address || null buffer&quot;);
141 
142         socketSend(nativefd, p.getData(), p.getOffset(), p.getLength(),
143                    p.getAddress(), p.getPort(), connected);
144     }
145 
146     protected void connect0(InetAddress address, int port) throws SocketException {
147         int nativefd = checkAndReturnNativeFD();
148 
149         if (address == null)
150             throw new NullPointerException(&quot;address&quot;);
151 
152         socketConnect(nativefd, address, port);
153     }
154 
155     protected void disconnect0(int family /*unused*/) {
156         if (fd == null || !fd.valid())
157             return;   // disconnect doesn&#39;t throw any exceptions
158 
159         socketDisconnect(fdAccess.get(fd));
160     }
161 
162     protected void datagramSocketClose() {
163         if (fd == null || !fd.valid())
164             return;   // close doesn&#39;t throw any exceptions
165 
166         socketClose(fdAccess.get(fd));
167         fdAccess.set(fd, -1);
168     }
169 
170     @SuppressWarnings(&quot;fallthrough&quot;)
171     protected void socketSetOption(int opt, Object val) throws SocketException {
172         int nativefd = checkAndReturnNativeFD();
173 
174         int optionValue = 0;
175 
176         // SO_REUSEPORT is not supported on Windows.
177         if (opt == SO_REUSEPORT) {
178             throw new UnsupportedOperationException(&quot;unsupported option&quot;);
179         }
180 
181         switch(opt) {
182             case IP_TOS :
183             case SO_RCVBUF :
184             case SO_SNDBUF :
185                 optionValue = ((Integer)val).intValue();
186                 break;
187             case SO_REUSEADDR :
188                 if (exclusiveBind &amp;&amp; localPort != 0)  {
189                     // socket already bound, emulate SO_REUSEADDR
190                     reuseAddressEmulated = true;
191                     isReuseAddress = (Boolean)val;
192                     return;
193                 }
194                 //Intentional fallthrough
195             case SO_BROADCAST :
196                 optionValue = ((Boolean)val).booleanValue() ? 1 : 0;
197                 break;
198             default: /* shouldn&#39;t get here */
199                 throw new SocketException(&quot;Option not supported&quot;);
200         }
201 
202         socketSetIntOption(nativefd, opt, optionValue);
203     }
204 
205     protected Object socketGetOption(int opt) throws SocketException {
206         int nativefd = checkAndReturnNativeFD();
207 
208          // SO_BINDADDR is not a socket option.
209         if (opt == SO_BINDADDR) {
210             return socketLocalAddress(nativefd);
211         }
212         if (opt == SO_REUSEADDR &amp;&amp; reuseAddressEmulated)
213             return isReuseAddress;
214         // SO_REUSEPORT is not supported on Windows.
215         if (opt == SO_REUSEPORT)
216             throw new UnsupportedOperationException(&quot;unsupported option&quot;);
217 
218         int value = socketGetIntOption(nativefd, opt);
219         Object returnValue = null;
220 
221         switch (opt) {
222             case SO_REUSEADDR :
223             case SO_BROADCAST :
224                 returnValue =  (value == 0) ? Boolean.FALSE : Boolean.TRUE;
225                 break;
226             case IP_TOS :
227             case SO_RCVBUF :
228             case SO_SNDBUF :
229                 returnValue = Integer.valueOf(value);
230                 break;
231             default: /* shouldn&#39;t get here */
232                 throw new SocketException(&quot;Option not supported&quot;);
233         }
234 
235         return returnValue;
236     }
237 
<a name="6" id="anc6"></a><span class="line-added">238     @Override</span>
<span class="line-added">239     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">240         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();</span>
<span class="line-added">241         options.add(StandardSocketOptions.SO_SNDBUF);</span>
<span class="line-added">242         options.add(StandardSocketOptions.SO_RCVBUF);</span>
<span class="line-added">243         options.add(StandardSocketOptions.SO_REUSEADDR);</span>
<span class="line-added">244         options.add(StandardSocketOptions.SO_BROADCAST);</span>
<span class="line-added">245         options.add(StandardSocketOptions.IP_TOS);</span>
<span class="line-added">246 </span>
<span class="line-added">247         options.addAll(ExtendedSocketOptions.datagramSocketOptions());</span>
<span class="line-added">248         return Collections.unmodifiableSet(options);</span>
<span class="line-added">249     }</span>
<span class="line-added">250 </span>
251     /* Multicast specific methods.
252      * Multicasting on a dual layer TCP/IP stack is always done with
253      * TwoStacksPlainDatagramSocketImpl. This is to overcome the lack
254      * of behavior defined for multicasting over a dual layer socket by the RFC.
255      */
256     protected void join(InetAddress inetaddr, NetworkInterface netIf)
257         throws IOException {
258         throw new IOException(&quot;Method not implemented!&quot;);
259     }
260 
261     protected void leave(InetAddress inetaddr, NetworkInterface netIf)
262         throws IOException {
263         throw new IOException(&quot;Method not implemented!&quot;);
264     }
265 
266     protected void setTimeToLive(int ttl) throws IOException {
267         throw new IOException(&quot;Method not implemented!&quot;);
268     }
269 
270     protected int getTimeToLive() throws IOException {
271         throw new IOException(&quot;Method not implemented!&quot;);
272     }
273 
274     @Deprecated
275     protected void setTTL(byte ttl) throws IOException {
276         throw new IOException(&quot;Method not implemented!&quot;);
277     }
278 
279     @Deprecated
280     protected byte getTTL() throws IOException {
281         throw new IOException(&quot;Method not implemented!&quot;);
282     }
283     /* END Multicast specific methods */
284 
285     private int checkAndReturnNativeFD() throws SocketException {
286         if (fd == null || !fd.valid())
287             throw new SocketException(&quot;Socket closed&quot;);
288 
289         return fdAccess.get(fd);
290     }
291 
292     /* Native methods */
293 
294     private static native void initIDs();
295 
296     private static native int socketCreate();
297 
298     private static native void socketBind(int fd, InetAddress localAddress,
299             int localport, boolean exclBind) throws SocketException;
300 
301     private static native void socketConnect(int fd, InetAddress address, int port)
302         throws SocketException;
303 
304     private static native void socketDisconnect(int fd);
305 
306     private static native void socketClose(int fd);
307 
308     private static native int socketLocalPort(int fd) throws SocketException;
309 
310     private static native Object socketLocalAddress(int fd) throws SocketException;
311 
312     private static native int socketReceiveOrPeekData(int fd, DatagramPacket packet,
313         int timeout, boolean connected, boolean peek) throws IOException;
314 
315     private static native void socketSend(int fd, byte[] data, int offset, int length,
316         InetAddress address, int port, boolean connected) throws IOException;
317 
318     private static native void socketSetIntOption(int fd, int cmd,
319         int optionValue) throws SocketException;
320 
321     private static native int socketGetIntOption(int fd, int cmd) throws SocketException;
322 
323     native int dataAvailable();
324 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
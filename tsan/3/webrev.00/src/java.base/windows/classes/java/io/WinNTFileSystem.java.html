<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/windows/classes/java/io/WinNTFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 import java.io.File;
 29 import java.nio.file.Path;
 30 import java.util.BitSet;
 31 import java.util.Locale;
 32 import java.util.Properties;
 33 import sun.security.action.GetPropertyAction;
 34 
 35 /**
 36  * Unicode-aware FileSystem for Windows NT/2000.
 37  *
 38  * @author Konstantin Kladko
 39  * @since 1.4
 40  */
 41 class WinNTFileSystem extends FileSystem {
 42 
 43     private final char slash;
 44     private final char altSlash;
 45     private final char semicolon;
 46     private final String userDir;
 47 
 48     public WinNTFileSystem() {
 49         Properties props = GetPropertyAction.privilegedGetProperties();
 50         slash = props.getProperty(&quot;file.separator&quot;).charAt(0);
 51         semicolon = props.getProperty(&quot;path.separator&quot;).charAt(0);
 52         altSlash = (this.slash == &#39;\\&#39;) ? &#39;/&#39; : &#39;\\&#39;;
 53         userDir = normalize(props.getProperty(&quot;user.dir&quot;));
 54         cache = useCanonCaches ? new ExpiringCache() : null;
 55         prefixCache = useCanonPrefixCache ? new ExpiringCache() : null;
 56     }
 57 
 58     private boolean isSlash(char c) {
 59         return (c == &#39;\\&#39;) || (c == &#39;/&#39;);
 60     }
 61 
 62     private boolean isLetter(char c) {
 63         return ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) || ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;));
 64     }
 65 
 66     private String slashify(String p) {
 67         if (!p.isEmpty() &amp;&amp; p.charAt(0) != slash) return slash + p;
 68         else return p;
 69     }
 70 
 71     /* -- Normalization and construction -- */
 72 
 73     @Override
 74     public char getSeparator() {
 75         return slash;
 76     }
 77 
 78     @Override
 79     public char getPathSeparator() {
 80         return semicolon;
 81     }
 82 
 83     /* Check that the given pathname is normal.  If not, invoke the real
 84        normalizer on the part of the pathname that requires normalization.
 85        This way we iterate through the whole pathname string only once. */
 86     @Override
 87     public String normalize(String path) {
 88         int n = path.length();
 89         char slash = this.slash;
 90         char altSlash = this.altSlash;
 91         char prev = 0;
 92         for (int i = 0; i &lt; n; i++) {
 93             char c = path.charAt(i);
 94             if (c == altSlash)
 95                 return normalize(path, n, (prev == slash) ? i - 1 : i);
 96             if ((c == slash) &amp;&amp; (prev == slash) &amp;&amp; (i &gt; 1))
 97                 return normalize(path, n, i - 1);
 98             if ((c == &#39;:&#39;) &amp;&amp; (i &gt; 1))
 99                 return normalize(path, n, 0);
100             prev = c;
101         }
102         if (prev == slash) return normalize(path, n, n - 1);
103         return path;
104     }
105 
106     /* Normalize the given pathname, whose length is len, starting at the given
107        offset; everything before this offset is already normal. */
108     private String normalize(String path, int len, int off) {
109         if (len == 0) return path;
110         if (off &lt; 3) off = 0;   /* Avoid fencepost cases with UNC pathnames */
111         int src;
112         char slash = this.slash;
113         StringBuilder sb = new StringBuilder(len);
114 
115         if (off == 0) {
116             /* Complete normalization, including prefix */
117             src = normalizePrefix(path, len, sb);
118         } else {
119             /* Partial normalization */
120             src = off;
121             sb.append(path, 0, off);
122         }
123 
124         /* Remove redundant slashes from the remainder of the path, forcing all
125            slashes into the preferred slash */
126         while (src &lt; len) {
127             char c = path.charAt(src++);
128             if (isSlash(c)) {
129                 while ((src &lt; len) &amp;&amp; isSlash(path.charAt(src))) src++;
130                 if (src == len) {
131                     /* Check for trailing separator */
132                     int sn = sb.length();
133                     if ((sn == 2) &amp;&amp; (sb.charAt(1) == &#39;:&#39;)) {
134                         /* &quot;z:\\&quot; */
135                         sb.append(slash);
136                         break;
137                     }
138                     if (sn == 0) {
139                         /* &quot;\\&quot; */
140                         sb.append(slash);
141                         break;
142                     }
143                     if ((sn == 1) &amp;&amp; (isSlash(sb.charAt(0)))) {
144                         /* &quot;\\\\&quot; is not collapsed to &quot;\\&quot; because &quot;\\\\&quot; marks
145                            the beginning of a UNC pathname.  Even though it is
146                            not, by itself, a valid UNC pathname, we leave it as
147                            is in order to be consistent with the win32 APIs,
148                            which treat this case as an invalid UNC pathname
149                            rather than as an alias for the root directory of
150                            the current drive. */
151                         sb.append(slash);
152                         break;
153                     }
154                     /* Path does not denote a root directory, so do not append
155                        trailing slash */
156                     break;
157                 } else {
158                     sb.append(slash);
159                 }
160             } else {
161                 sb.append(c);
162             }
163         }
164 
165         return sb.toString();
166     }
167 
168     /* A normal Win32 pathname contains no duplicate slashes, except possibly
169        for a UNC prefix, and does not end with a slash.  It may be the empty
170        string.  Normalized Win32 pathnames have the convenient property that
171        the length of the prefix almost uniquely identifies the type of the path
172        and whether it is absolute or relative:
173 
174            0  relative to both drive and directory
175            1  drive-relative (begins with &#39;\\&#39;)
176            2  absolute UNC (if first char is &#39;\\&#39;),
177                 else directory-relative (has form &quot;z:foo&quot;)
178            3  absolute local pathname (begins with &quot;z:\\&quot;)
179      */
180     private int normalizePrefix(String path, int len, StringBuilder sb) {
181         int src = 0;
182         while ((src &lt; len) &amp;&amp; isSlash(path.charAt(src))) src++;
183         char c;
184         if ((len - src &gt;= 2)
185             &amp;&amp; isLetter(c = path.charAt(src))
186             &amp;&amp; path.charAt(src + 1) == &#39;:&#39;) {
187             /* Remove leading slashes if followed by drive specifier.
188                This hack is necessary to support file URLs containing drive
189                specifiers (e.g., &quot;file://c:/path&quot;).  As a side effect,
190                &quot;/c:/path&quot; can be used as an alternative to &quot;c:/path&quot;. */
191             sb.append(c);
192             sb.append(&#39;:&#39;);
193             src += 2;
194         } else {
195             src = 0;
196             if ((len &gt;= 2)
197                 &amp;&amp; isSlash(path.charAt(0))
198                 &amp;&amp; isSlash(path.charAt(1))) {
199                 /* UNC pathname: Retain first slash; leave src pointed at
200                    second slash so that further slashes will be collapsed
201                    into the second slash.  The result will be a pathname
202                    beginning with &quot;\\\\&quot; followed (most likely) by a host
203                    name. */
204                 src = 1;
205                 sb.append(slash);
206             }
207         }
208         return src;
209     }
210 
211     @Override
212     public int prefixLength(String path) {
213         char slash = this.slash;
214         int n = path.length();
215         if (n == 0) return 0;
216         char c0 = path.charAt(0);
217         char c1 = (n &gt; 1) ? path.charAt(1) : 0;
218         if (c0 == slash) {
219             if (c1 == slash) return 2;  /* Absolute UNC pathname &quot;\\\\foo&quot; */
220             return 1;                   /* Drive-relative &quot;\\foo&quot; */
221         }
222         if (isLetter(c0) &amp;&amp; (c1 == &#39;:&#39;)) {
223             if ((n &gt; 2) &amp;&amp; (path.charAt(2) == slash))
224                 return 3;               /* Absolute local pathname &quot;z:\\foo&quot; */
225             return 2;                   /* Directory-relative &quot;z:foo&quot; */
226         }
227         return 0;                       /* Completely relative */
228     }
229 
230     @Override
231     public String resolve(String parent, String child) {
232         int pn = parent.length();
233         if (pn == 0) return child;
234         int cn = child.length();
235         if (cn == 0) return parent;
236 
237         String c = child;
238         int childStart = 0;
239         int parentEnd = pn;
240 
241         boolean isDirectoryRelative =
242             pn == 2 &amp;&amp; isLetter(parent.charAt(0)) &amp;&amp; parent.charAt(1) == &#39;:&#39;;
243 
244         if ((cn &gt; 1) &amp;&amp; (c.charAt(0) == slash)) {
245             if (c.charAt(1) == slash) {
246                 /* Drop prefix when child is a UNC pathname */
247                 childStart = 2;
248             } else if (!isDirectoryRelative) {
249                 /* Drop prefix when child is drive-relative */
250                 childStart = 1;
251 
252             }
253             if (cn == childStart) { // Child is double slash
254                 if (parent.charAt(pn - 1) == slash)
255                     return parent.substring(0, pn - 1);
256                 return parent;
257             }
258         }
259 
260         if (parent.charAt(pn - 1) == slash)
261             parentEnd--;
262 
263         int strlen = parentEnd + cn - childStart;
264         char[] theChars = null;
265         if (child.charAt(childStart) == slash || isDirectoryRelative) {
266             theChars = new char[strlen];
267             parent.getChars(0, parentEnd, theChars, 0);
268             child.getChars(childStart, cn, theChars, parentEnd);
269         } else {
270             theChars = new char[strlen + 1];
271             parent.getChars(0, parentEnd, theChars, 0);
272             theChars[parentEnd] = slash;
273             child.getChars(childStart, cn, theChars, parentEnd + 1);
274         }
275         return new String(theChars);
276     }
277 
278     @Override
279     public String getDefaultParent() {
280         return (&quot;&quot; + slash);
281     }
282 
283     @Override
284     public String fromURIPath(String path) {
285         String p = path;
286         if ((p.length() &gt; 2) &amp;&amp; (p.charAt(2) == &#39;:&#39;)) {
287             // &quot;/c:/foo&quot; --&gt; &quot;c:/foo&quot;
288             p = p.substring(1);
289             // &quot;c:/foo/&quot; --&gt; &quot;c:/foo&quot;, but &quot;c:/&quot; --&gt; &quot;c:/&quot;
290             if ((p.length() &gt; 3) &amp;&amp; p.endsWith(&quot;/&quot;))
291                 p = p.substring(0, p.length() - 1);
292         } else if ((p.length() &gt; 1) &amp;&amp; p.endsWith(&quot;/&quot;)) {
293             // &quot;/foo/&quot; --&gt; &quot;/foo&quot;
294             p = p.substring(0, p.length() - 1);
295         }
296         return p;
297     }
298 
299     /* -- Path operations -- */
300 
301     @Override
302     public boolean isAbsolute(File f) {
303         int pl = f.getPrefixLength();
304         return (((pl == 2) &amp;&amp; (f.getPath().charAt(0) == slash))
305                 || (pl == 3));
306     }
307 
308     @Override
309     public String resolve(File f) {
310         String path = f.getPath();
311         int pl = f.getPrefixLength();
312         if ((pl == 2) &amp;&amp; (path.charAt(0) == slash))
313             return path;                        /* UNC */
314         if (pl == 3)
315             return path;                        /* Absolute local */
316         if (pl == 0)
317             return getUserPath() + slashify(path); /* Completely relative */
318         if (pl == 1) {                          /* Drive-relative */
319             String up = getUserPath();
320             String ud = getDrive(up);
321             if (ud != null) return ud + path;
322             return up + path;                   /* User dir is a UNC path */
323         }
324         if (pl == 2) {                          /* Directory-relative */
325             String up = getUserPath();
326             String ud = getDrive(up);
327             if ((ud != null) &amp;&amp; path.startsWith(ud))
328                 return up + slashify(path.substring(2));
329             char drive = path.charAt(0);
330             String dir = getDriveDirectory(drive);
331             if (dir != null) {
332                 /* When resolving a directory-relative path that refers to a
333                    drive other than the current drive, insist that the caller
334                    have read permission on the result */
335                 String p = drive + (&#39;:&#39; + dir + slashify(path.substring(2)));
336                 SecurityManager security = System.getSecurityManager();
337                 try {
338                     if (security != null) security.checkRead(p);
339                 } catch (SecurityException x) {
340                     /* Don&#39;t disclose the drive&#39;s directory in the exception */
341                     throw new SecurityException(&quot;Cannot resolve path &quot; + path);
342                 }
343                 return p;
344             }
345             return drive + &quot;:&quot; + slashify(path.substring(2)); /* fake it */
346         }
347         throw new InternalError(&quot;Unresolvable path: &quot; + path);
348     }
349 
350     private String getUserPath() {
351         /* For both compatibility and security,
352            we must look this up every time */
353         SecurityManager sm = System.getSecurityManager();
354         if (sm != null) {
355             sm.checkPropertyAccess(&quot;user.dir&quot;);
356         }
357         return normalize(userDir);
358     }
359 
360     private String getDrive(String path) {
361         int pl = prefixLength(path);
362         return (pl == 3) ? path.substring(0, 2) : null;
363     }
364 
365     private static String[] driveDirCache = new String[26];
366 
367     private static int driveIndex(char d) {
368         if ((d &gt;= &#39;a&#39;) &amp;&amp; (d &lt;= &#39;z&#39;)) return d - &#39;a&#39;;
369         if ((d &gt;= &#39;A&#39;) &amp;&amp; (d &lt;= &#39;Z&#39;)) return d - &#39;A&#39;;
370         return -1;
371     }
372 
373     private native String getDriveDirectory(int drive);
374 
375     private String getDriveDirectory(char drive) {
376         int i = driveIndex(drive);
377         if (i &lt; 0) return null;
378         String s = driveDirCache[i];
379         if (s != null) return s;
380         s = getDriveDirectory(i + 1);
381         driveDirCache[i] = s;
382         return s;
383     }
384 
385     // Caches for canonicalization results to improve startup performance.
386     // The first cache handles repeated canonicalizations of the same path
387     // name. The prefix cache handles repeated canonicalizations within the
388     // same directory, and must not create results differing from the true
389     // canonicalization algorithm in canonicalize_md.c. For this reason the
390     // prefix cache is conservative and is not used for complex path names.
391     private final ExpiringCache cache;
392     private final ExpiringCache prefixCache;
393 
394     @Override
395     public String canonicalize(String path) throws IOException {
396         // If path is a drive letter only then skip canonicalization
397         int len = path.length();
398         if ((len == 2) &amp;&amp;
399             (isLetter(path.charAt(0))) &amp;&amp;
400             (path.charAt(1) == &#39;:&#39;)) {
401             char c = path.charAt(0);
402             if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;))
403                 return path;
404             return &quot;&quot; + ((char) (c-32)) + &#39;:&#39;;
405         } else if ((len == 3) &amp;&amp;
406                    (isLetter(path.charAt(0))) &amp;&amp;
407                    (path.charAt(1) == &#39;:&#39;) &amp;&amp;
408                    (path.charAt(2) == &#39;\\&#39;)) {
409             char c = path.charAt(0);
410             if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;))
411                 return path;
412             return &quot;&quot; + ((char) (c-32)) + &#39;:&#39; + &#39;\\&#39;;
413         }
414         if (!useCanonCaches) {
415             return canonicalize0(path);
416         } else {
417             String res = cache.get(path);
418             if (res == null) {
419                 String dir = null;
420                 String resDir = null;
421                 if (useCanonPrefixCache) {
422                     dir = parentOrNull(path);
423                     if (dir != null) {
424                         resDir = prefixCache.get(dir);
425                         if (resDir != null) {
426                             /*
427                              * Hit only in prefix cache; full path is canonical,
428                              * but we need to get the canonical name of the file
429                              * in this directory to get the appropriate
430                              * capitalization
431                              */
432                             String filename = path.substring(1 + dir.length());
433                             res = canonicalizeWithPrefix(resDir, filename);
434                             cache.put(dir + File.separatorChar + filename, res);
435                         }
436                     }
437                 }
438                 if (res == null) {
439                     res = canonicalize0(path);
440                     cache.put(path, res);
441                     if (useCanonPrefixCache &amp;&amp; dir != null) {
442                         resDir = parentOrNull(res);
443                         if (resDir != null) {
444                             File f = new File(res);
445                             if (f.exists() &amp;&amp; !f.isDirectory()) {
446                                 prefixCache.put(dir, resDir);
447                             }
448                         }
449                     }
450                 }
451             }
452             return res;
453         }
454     }
455 
456     private native String canonicalize0(String path)
457             throws IOException;
458 
459     private String canonicalizeWithPrefix(String canonicalPrefix,
460             String filename) throws IOException
461     {
462         return canonicalizeWithPrefix0(canonicalPrefix,
463                 canonicalPrefix + File.separatorChar + filename);
464     }
465 
466     // Run the canonicalization operation assuming that the prefix
467     // (everything up to the last filename) is canonical; just gets
468     // the canonical name of the last element of the path
469     private native String canonicalizeWithPrefix0(String canonicalPrefix,
470             String pathWithCanonicalPrefix)
471             throws IOException;
472 
473     // Best-effort attempt to get parent of this path; used for
474     // optimization of filename canonicalization. This must return null for
475     // any cases where the code in canonicalize_md.c would throw an
476     // exception or otherwise deal with non-simple pathnames like handling
477     // of &quot;.&quot; and &quot;..&quot;. It may conservatively return null in other
478     // situations as well. Returning null will cause the underlying
479     // (expensive) canonicalization routine to be called.
480     private static String parentOrNull(String path) {
481         if (path == null) return null;
482         char sep = File.separatorChar;
483         char altSep = &#39;/&#39;;
484         int last = path.length() - 1;
485         int idx = last;
486         int adjacentDots = 0;
487         int nonDotCount = 0;
488         while (idx &gt; 0) {
489             char c = path.charAt(idx);
490             if (c == &#39;.&#39;) {
491                 if (++adjacentDots &gt;= 2) {
492                     // Punt on pathnames containing . and ..
493                     return null;
494                 }
495                 if (nonDotCount == 0) {
496                     // Punt on pathnames ending in a .
497                     return null;
498                 }
499             } else if (c == sep) {
500                 if (adjacentDots == 1 &amp;&amp; nonDotCount == 0) {
501                     // Punt on pathnames containing . and ..
502                     return null;
503                 }
504                 if (idx == 0 ||
505                     idx &gt;= last - 1 ||
506                     path.charAt(idx - 1) == sep ||
507                     path.charAt(idx - 1) == altSep) {
508                     // Punt on pathnames containing adjacent slashes
509                     // toward the end
510                     return null;
511                 }
512                 return path.substring(0, idx);
513             } else if (c == altSep) {
514                 // Punt on pathnames containing both backward and
515                 // forward slashes
516                 return null;
517             } else if (c == &#39;*&#39; || c == &#39;?&#39;) {
518                 // Punt on pathnames containing wildcards
519                 return null;
520             } else {
521                 ++nonDotCount;
522                 adjacentDots = 0;
523             }
524             --idx;
525         }
526         return null;
527     }
528 
529     /* -- Attribute accessors -- */
530 
531     @Override
532     public native int getBooleanAttributes(File f);
533 
534     @Override
535     public native boolean checkAccess(File f, int access);
536 
537     @Override
538     public native long getLastModifiedTime(File f);
539 
540     @Override
541     public native long getLength(File f);
542 
543     @Override
544     public native boolean setPermission(File f, int access, boolean enable,
545             boolean owneronly);
546 
547     /* -- File operations -- */
548 
549     @Override
550     public native boolean createFileExclusively(String path)
551             throws IOException;
552 
553     @Override
554     public native String[] list(File f);
555 
556     @Override
557     public native boolean createDirectory(File f);
558 
559     @Override
560     public native boolean setLastModifiedTime(File f, long time);
561 
562     @Override
563     public native boolean setReadOnly(File f);
564 
565     @Override
566     public boolean delete(File f) {
567         // Keep canonicalization caches in sync after file deletion
568         // and renaming operations. Could be more clever than this
569         // (i.e., only remove/update affected entries) but probably
570         // not worth it since these entries expire after 30 seconds
571         // anyway.
572         if (useCanonCaches) {
573             cache.clear();
574         }
575         if (useCanonPrefixCache) {
576             prefixCache.clear();
577         }
578         return delete0(f);
579     }
580 
581     private native boolean delete0(File f);
582 
583     @Override
584     public boolean rename(File f1, File f2) {
585         // Keep canonicalization caches in sync after file deletion
586         // and renaming operations. Could be more clever than this
587         // (i.e., only remove/update affected entries) but probably
588         // not worth it since these entries expire after 30 seconds
589         // anyway.
590         if (useCanonCaches) {
591             cache.clear();
592         }
593         if (useCanonPrefixCache) {
594             prefixCache.clear();
595         }
596         return rename0(f1, f2);
597     }
598 
599     private native boolean rename0(File f1, File f2);
600 
601     /* -- Filesystem interface -- */
602 
603     @Override
604     public File[] listRoots() {
605         return BitSet
606             .valueOf(new long[] {listRoots0()})
607             .stream()
608             .mapToObj(i -&gt; new File((char)(&#39;A&#39; + i) + &quot;:&quot; + slash))
609             .filter(f -&gt; access(f.getPath()) &amp;&amp; f.exists())
610             .toArray(File[]::new);
611     }
612 
613     private static native int listRoots0();
614 
615     private boolean access(String path) {
616         try {
617             SecurityManager security = System.getSecurityManager();
618             if (security != null) security.checkRead(path);
619             return true;
620         } catch (SecurityException x) {
621             return false;
622         }
623     }
624 
625     /* -- Disk usage -- */
626 
627     @Override
628     public long getSpace(File f, int t) {
629         if (f.exists()) {
630             return getSpace0(f, t);
631         }
632         return 0;
633     }
634 
635     private native long getSpace0(File f, int t);
636 
637     /* -- Basic infrastructure -- */
638 
639     // Obtain maximum file component length from GetVolumeInformation which
640     // expects the path to be null or a root component ending in a backslash
641     private native int getNameMax0(String path);
642 
643     @Override
644     public int getNameMax(String path) {
645         String s = null;
646         if (path != null) {
647             File f = new File(path);
648             if (f.isAbsolute()) {
649                 Path root = f.toPath().getRoot();
650                 if (root != null) {
651                     s = root.toString();
652                     if (!s.endsWith(&quot;\\&quot;)) {
653                         s = s + &quot;\\&quot;;
654                     }
655                 }
656             }
657         }
658         return getNameMax0(s);
659     }
660 
661     @Override
662     public int compare(File f1, File f2) {
663         return f1.getPath().compareToIgnoreCase(f2.getPath());
664     }
665 
666     @Override
667     public int hashCode(File f) {
668         /* Could make this more efficient: String.hashCodeIgnoreCase */
669         return f.getPath().toLowerCase(Locale.ENGLISH).hashCode() ^ 1234321;
670     }
671 
672     private static native void initIDs();
673 
674     static {
675         initIDs();
676     }
677 }
    </pre>
  </body>
</html>
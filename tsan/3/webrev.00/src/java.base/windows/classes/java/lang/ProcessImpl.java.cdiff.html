<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/windows/classes/java/lang/ProcessImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassLoaderHelper.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../net/DefaultDatagramSocketImplFactory.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/classes/java/lang/ProcessImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,18 ***</span>
<span class="line-new-header">--- 36,21 ---</span>
  import java.io.OutputStream;
  import java.lang.ProcessBuilder.Redirect;
  import java.security.AccessController;
  import java.security.PrivilegedAction;
  import java.util.ArrayList;
<span class="line-added">+ import java.util.Locale;</span>
  import java.util.concurrent.CompletableFuture;
  import java.util.concurrent.TimeUnit;
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;
  
  import jdk.internal.access.JavaIOFileDescriptorAccess;
  import jdk.internal.access.SharedSecrets;
  import jdk.internal.ref.CleanerFactory;
<span class="line-added">+ import sun.security.action.GetBooleanAction;</span>
<span class="line-added">+ import sun.security.action.GetPropertyAction;</span>
  
  /* This class is for the exclusive use of ProcessBuilder.start() to
   * create new processes.
   *
   * @author Martin Buchholz
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,16 ***</span>
          return matchList.toArray(new String[matchList.size()]);
      }
  
      private static final int VERIFICATION_CMD_BAT = 0;
      private static final int VERIFICATION_WIN32 = 1;
<span class="line-modified">!     private static final int VERIFICATION_LEGACY = 2;</span>
      private static final char ESCAPE_VERIFICATION[][] = {
          // We guarantee the only command file execution for implicit [cmd.exe] run.
          //    http://technet.microsoft.com/en-us/library/bb490954.aspx
          {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;},
<span class="line-modified">! </span>
          {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;},
          {&#39; &#39;, &#39;\t&#39;}
      };
  
      private static String createCommandLine(int verificationType,
<span class="line-new-header">--- 210,19 ---</span>
          return matchList.toArray(new String[matchList.size()]);
      }
  
      private static final int VERIFICATION_CMD_BAT = 0;
      private static final int VERIFICATION_WIN32 = 1;
<span class="line-modified">!     private static final int VERIFICATION_WIN32_SAFE = 2; // inside quotes not allowed</span>
<span class="line-added">+     private static final int VERIFICATION_LEGACY = 3;</span>
<span class="line-added">+     // See Command shell overview for documentation of special characters.</span>
<span class="line-added">+     // https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490954(v=technet.10)</span>
      private static final char ESCAPE_VERIFICATION[][] = {
          // We guarantee the only command file execution for implicit [cmd.exe] run.
          //    http://technet.microsoft.com/en-us/library/bb490954.aspx
          {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;},
<span class="line-modified">!         {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;},</span>
          {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;},
          {&#39; &#39;, &#39;\t&#39;}
      };
  
      private static String createCommandLine(int verificationType,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,12 ***</span>
  
          for (int i = 1; i &lt; cmd.length; ++i) {
              cmdbuf.append(&#39; &#39;);
              String s = cmd[i];
              if (needsEscaping(verificationType, s)) {
<span class="line-modified">!                 cmdbuf.append(&#39;&quot;&#39;).append(s);</span>
  
                  // The code protects the [java.exe] and console command line
                  // parser, that interprets the [\&quot;] combination as an escape
                  // sequence for the [&quot;] char.
                  //     http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
                  //
<span class="line-new-header">--- 235,29 ---</span>
  
          for (int i = 1; i &lt; cmd.length; ++i) {
              cmdbuf.append(&#39; &#39;);
              String s = cmd[i];
              if (needsEscaping(verificationType, s)) {
<span class="line-modified">!                 cmdbuf.append(&#39;&quot;&#39;);</span>
  
<span class="line-added">+                 if (verificationType == VERIFICATION_WIN32_SAFE) {</span>
<span class="line-added">+                     // Insert the argument, adding &#39;\&#39; to quote any interior quotes</span>
<span class="line-added">+                     int length = s.length();</span>
<span class="line-added">+                     for (int j = 0; j &lt; length; j++) {</span>
<span class="line-added">+                         char c = s.charAt(j);</span>
<span class="line-added">+                         if (c == DOUBLEQUOTE) {</span>
<span class="line-added">+                             int count = countLeadingBackslash(verificationType, s, j);</span>
<span class="line-added">+                             while (count-- &gt; 0) {</span>
<span class="line-added">+                                 cmdbuf.append(BACKSLASH);   // double the number of backslashes</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             cmdbuf.append(BACKSLASH);       // backslash to quote the quote</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         cmdbuf.append(c);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     cmdbuf.append(s);</span>
<span class="line-added">+                 }</span>
                  // The code protects the [java.exe] and console command line
                  // parser, that interprets the [\&quot;] combination as an escape
                  // sequence for the [&quot;] char.
                  //     http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
                  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 243,54 ***</span>
                  //
                  // The [\&quot;] sequence is not an escape sequence for the [cmd.exe]
                  // command line parser. The case of the [&quot;&quot;] tail escape
                  // sequence could not be realized due to the argument validation
                  // procedure.
<span class="line-modified">!                 if ((verificationType != VERIFICATION_CMD_BAT) &amp;&amp; s.endsWith(&quot;\\&quot;)) {</span>
<span class="line-modified">!                     cmdbuf.append(&#39;\\&#39;);</span>
                  }
                  cmdbuf.append(&#39;&quot;&#39;);
              } else {
                  cmdbuf.append(s);
              }
          }
          return cmdbuf.toString();
      }
  
<span class="line-modified">!     private static boolean isQuoted(boolean noQuotesInside, String arg,</span>
<span class="line-modified">!             String errorMessage) {</span>
<span class="line-modified">!         int lastPos = arg.length() - 1;</span>
<span class="line-modified">!         if (lastPos &gt;=1 &amp;&amp; arg.charAt(0) == &#39;&quot;&#39; &amp;&amp; arg.charAt(lastPos) == &#39;&quot;&#39;) {</span>
<span class="line-modified">!             // The argument has already been quoted.</span>
<span class="line-modified">!             if (noQuotesInside) {</span>
<span class="line-modified">!                 if (arg.indexOf(&#39;&quot;&#39;, 1) != lastPos) {</span>
<span class="line-modified">!                     // There is [&quot;] inside.</span>
<span class="line-modified">!                     throw new IllegalArgumentException(errorMessage);</span>
<span class="line-modified">!                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (noQuotesInside) {</span>
<span class="line-removed">-             if (arg.indexOf(&#39;&quot;&#39;) &gt;= 0) {</span>
<span class="line-removed">-                 // There is [&quot;] inside.</span>
<span class="line-removed">-                 throw new IllegalArgumentException(errorMessage);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return false;</span>
      }
  
      private static boolean needsEscaping(int verificationType, String arg) {
          // Switch off MS heuristic for internal [&quot;].
          // Please, use the explicit [cmd.exe] call
          // if you need the internal [&quot;].
          //    Example: &quot;cmd.exe&quot;, &quot;/C&quot;, &quot;Extended_MS_Syntax&quot;
  
          // For [.exe] or [.com] file the unpaired/internal [&quot;]
          // in the argument is not a problem.
<span class="line-modified">!         boolean argIsQuoted = isQuoted(</span>
<span class="line-modified">!             (verificationType == VERIFICATION_CMD_BAT),</span>
<span class="line-modified">!             arg, &quot;Argument has embedded quote, use the explicit CMD.EXE call.&quot;);</span>
  
          if (!argIsQuoted) {
              char testEscape[] = ESCAPE_VERIFICATION[verificationType];
              for (int i = 0; i &lt; testEscape.length; ++i) {
                  if (arg.indexOf(testEscape[i]) &gt;= 0) {
<span class="line-new-header">--- 266,62 ---</span>
                  //
                  // The [\&quot;] sequence is not an escape sequence for the [cmd.exe]
                  // command line parser. The case of the [&quot;&quot;] tail escape
                  // sequence could not be realized due to the argument validation
                  // procedure.
<span class="line-modified">!                 int count = countLeadingBackslash(verificationType, s, s.length());</span>
<span class="line-modified">!                 while (count-- &gt; 0) {</span>
<span class="line-added">+                     cmdbuf.append(BACKSLASH);   // double the number of backslashes</span>
                  }
                  cmdbuf.append(&#39;&quot;&#39;);
              } else {
                  cmdbuf.append(s);
              }
          }
          return cmdbuf.toString();
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Return the argument without quotes (1st and last) if present, else the arg.</span>
<span class="line-modified">!      * @param str a string</span>
<span class="line-modified">!      * @return the string without 1st and last quotes</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static String unQuote(String str) {</span>
<span class="line-modified">!         int len = str.length();</span>
<span class="line-modified">!         return (len &gt;= 2 &amp;&amp; str.charAt(0) == DOUBLEQUOTE &amp;&amp; str.charAt(len - 1) == DOUBLEQUOTE)</span>
<span class="line-modified">!                 ? str.substring(1, len - 1)</span>
<span class="line-modified">!                 : str;</span>
      }
  
      private static boolean needsEscaping(int verificationType, String arg) {
          // Switch off MS heuristic for internal [&quot;].
          // Please, use the explicit [cmd.exe] call
          // if you need the internal [&quot;].
          //    Example: &quot;cmd.exe&quot;, &quot;/C&quot;, &quot;Extended_MS_Syntax&quot;
  
          // For [.exe] or [.com] file the unpaired/internal [&quot;]
          // in the argument is not a problem.
<span class="line-modified">!         String unquotedArg = unQuote(arg);</span>
<span class="line-modified">!         boolean argIsQuoted = !arg.equals(unquotedArg);</span>
<span class="line-modified">!         boolean embeddedQuote = unquotedArg.indexOf(DOUBLEQUOTE) &gt;= 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (verificationType) {</span>
<span class="line-added">+             case VERIFICATION_CMD_BAT:</span>
<span class="line-added">+                 if (embeddedQuote) {</span>
<span class="line-added">+                     throw new IllegalArgumentException(&quot;Argument has embedded quote, &quot; +</span>
<span class="line-added">+                             &quot;use the explicit CMD.EXE call.&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 break;  // break determine whether to quote</span>
<span class="line-added">+             case VERIFICATION_WIN32_SAFE:</span>
<span class="line-added">+                 if (argIsQuoted &amp;&amp; embeddedQuote)  {</span>
<span class="line-added">+                     throw new IllegalArgumentException(&quot;Malformed argument has embedded quote: &quot;</span>
<span class="line-added">+                             + unquotedArg);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+         }</span>
  
          if (!argIsQuoted) {
              char testEscape[] = ESCAPE_VERIFICATION[verificationType];
              for (int i = 0; i &lt; testEscape.length; ++i) {
                  if (arg.indexOf(testEscape[i]) &gt;= 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,17 ***</span>
      }
  
      private static String getExecutablePath(String path)
          throws IOException
      {
<span class="line-modified">!         boolean pathIsQuoted = isQuoted(true, path,</span>
<span class="line-modified">!                 &quot;Executable name has embedded quote, split the arguments&quot;);</span>
<span class="line-modified">! </span>
          // Win32 CreateProcess requires path to be normalized
<span class="line-modified">!         File fileToRun = new File(pathIsQuoted</span>
<span class="line-removed">-             ? path.substring(1, path.length() - 1)</span>
<span class="line-removed">-             : path);</span>
  
          // From the [CreateProcess] function documentation:
          //
          // &quot;If the file name does not contain an extension, .exe is appended.
          // Therefore, if the file name extension is .com, this parameter
<span class="line-new-header">--- 333,17 ---</span>
      }
  
      private static String getExecutablePath(String path)
          throws IOException
      {
<span class="line-modified">!         String name = unQuote(path);</span>
<span class="line-modified">!         if (name.indexOf(DOUBLEQUOTE) &gt;= 0) {</span>
<span class="line-modified">!             throw new IllegalArgumentException(&quot;Executable name has embedded quote, &quot; +</span>
<span class="line-added">+                     &quot;split the arguments: &quot; + name);</span>
<span class="line-added">+         }</span>
          // Win32 CreateProcess requires path to be normalized
<span class="line-modified">!         File fileToRun = new File(name);</span>
  
          // From the [CreateProcess] function documentation:
          //
          // &quot;If the file name does not contain an extension, .exe is appended.
          // Therefore, if the file name extension is .com, this parameter
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,27 ***</span>
          // &quot;If the file name !does not contain a directory path!,
          // the system searches for the executable file in the following
          // sequence:...&quot;
          //
          // In practice ANY non-existent path is extended by [.exe] extension
<span class="line-modified">!         // in the [CreateProcess] funcion with the only exception:</span>
          // the path ends by (.)
  
          return fileToRun.getPath();
      }
  
  
      private boolean isShellFile(String executablePath) {
          String upPath = executablePath.toUpperCase();
          return (upPath.endsWith(&quot;.CMD&quot;) || upPath.endsWith(&quot;.BAT&quot;));
      }
  
      private String quoteString(String arg) {
          StringBuilder argbuf = new StringBuilder(arg.length() + 2);
          return argbuf.append(&#39;&quot;&#39;).append(arg).append(&#39;&quot;&#39;).toString();
      }
  
  
      private final long handle;
      private final ProcessHandle processHandle;
      private OutputStream stdin_stream;
      private InputStream stdout_stream;
<span class="line-new-header">--- 354,55 ---</span>
          // &quot;If the file name !does not contain a directory path!,
          // the system searches for the executable file in the following
          // sequence:...&quot;
          //
          // In practice ANY non-existent path is extended by [.exe] extension
<span class="line-modified">!         // in the [CreateProcess] function with the only exception:</span>
          // the path ends by (.)
  
          return fileToRun.getPath();
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * An executable is any program that is an EXE or does not have an extension</span>
<span class="line-added">+      * and the Windows createProcess will be looking for .exe.</span>
<span class="line-added">+      * The comparison is case insensitive based on the name.</span>
<span class="line-added">+      * @param executablePath the executable file</span>
<span class="line-added">+      * @return true if the path ends in .exe or does not have an extension.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private boolean isExe(String executablePath) {</span>
<span class="line-added">+         File file = new File(executablePath);</span>
<span class="line-added">+         String upName = file.getName().toUpperCase(Locale.ROOT);</span>
<span class="line-added">+         return (upName.endsWith(&quot;.EXE&quot;) || upName.indexOf(&#39;.&#39;) &lt; 0);</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     // Old version that can be bypassed</span>
      private boolean isShellFile(String executablePath) {
          String upPath = executablePath.toUpperCase();
          return (upPath.endsWith(&quot;.CMD&quot;) || upPath.endsWith(&quot;.BAT&quot;));
      }
  
      private String quoteString(String arg) {
          StringBuilder argbuf = new StringBuilder(arg.length() + 2);
          return argbuf.append(&#39;&quot;&#39;).append(arg).append(&#39;&quot;&#39;).toString();
      }
  
<span class="line-added">+     // Count backslashes before start index of string.</span>
<span class="line-added">+     // .bat files don&#39;t include backslashes as part of the quote</span>
<span class="line-added">+     private static int countLeadingBackslash(int verificationType,</span>
<span class="line-added">+                                              CharSequence input, int start) {</span>
<span class="line-added">+         if (verificationType == VERIFICATION_CMD_BAT)</span>
<span class="line-added">+             return 0;</span>
<span class="line-added">+         int j;</span>
<span class="line-added">+         for (j = start - 1; j &gt;= 0 &amp;&amp; input.charAt(j) == BACKSLASH; j--) {</span>
<span class="line-added">+             // just scanning backwards</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return (start - 1) - j;  // number of BACKSLASHES</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final char DOUBLEQUOTE = &#39;\&quot;&#39;;</span>
<span class="line-added">+     private static final char BACKSLASH = &#39;\\&#39;;</span>
  
      private final long handle;
      private final ProcessHandle processHandle;
      private OutputStream stdin_stream;
      private InputStream stdout_stream;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,19 ***</span>
                          boolean forceNullOutputStream,
                          final boolean redirectErrorStream)
          throws IOException
      {
          String cmdstr;
<span class="line-modified">!         SecurityManager security = System.getSecurityManager();</span>
<span class="line-modified">!         boolean allowAmbiguousCommands = false;</span>
<span class="line-modified">!         if (security == null) {</span>
<span class="line-modified">!             allowAmbiguousCommands = true;</span>
<span class="line-modified">!             String value = System.getProperty(&quot;jdk.lang.Process.allowAmbiguousCommands&quot;);</span>
<span class="line-modified">!             if (value != null)</span>
<span class="line-modified">!                 allowAmbiguousCommands = !&quot;false&quot;.equalsIgnoreCase(value);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (allowAmbiguousCommands) {</span>
              // Legacy mode.
  
              // Normalize path if possible.
              String executablePath = new File(cmd[0]).getPath();
  
<span class="line-new-header">--- 415,17 ---</span>
                          boolean forceNullOutputStream,
                          final boolean redirectErrorStream)
          throws IOException
      {
          String cmdstr;
<span class="line-modified">!         final SecurityManager security = System.getSecurityManager();</span>
<span class="line-modified">!         final String value = GetPropertyAction.</span>
<span class="line-modified">!                 privilegedGetProperty(&quot;jdk.lang.Process.allowAmbiguousCommands&quot;,</span>
<span class="line-modified">!                         (security == null ? &quot;true&quot; : &quot;false&quot;));</span>
<span class="line-modified">!         final boolean allowAmbiguousCommands = !&quot;false&quot;.equalsIgnoreCase(value);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (allowAmbiguousCommands &amp;&amp; security == null) {</span>
              // Legacy mode.
  
              // Normalize path if possible.
              String executablePath = new File(cmd[0]).getPath();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,15 ***</span>
              }
  
              // Quotation protects from interpretation of the [path] argument as
              // start of longer path with spaces. Quotation has no influence to
              // [.exe] extension heuristic.
              cmdstr = createCommandLine(
<span class="line-modified">!                     // We need the extended verification procedure for CMD files.</span>
<span class="line-modified">!                     isShellFile(executablePath)</span>
<span class="line-modified">!                         ? VERIFICATION_CMD_BAT</span>
<span class="line-removed">-                         : VERIFICATION_WIN32,</span>
                      quoteString(executablePath),
                      cmd);
          }
  
          handle = create(cmdstr, envblock, path,
<span class="line-new-header">--- 468,16 ---</span>
              }
  
              // Quotation protects from interpretation of the [path] argument as
              // start of longer path with spaces. Quotation has no influence to
              // [.exe] extension heuristic.
<span class="line-added">+             boolean isShell = allowAmbiguousCommands ? isShellFile(executablePath)</span>
<span class="line-added">+                     : !isExe(executablePath);</span>
              cmdstr = createCommandLine(
<span class="line-modified">!                     // We need the extended verification procedures</span>
<span class="line-modified">!                     isShell ? VERIFICATION_CMD_BAT</span>
<span class="line-modified">!                             : (allowAmbiguousCommands ? VERIFICATION_WIN32 : VERIFICATION_WIN32_SAFE),</span>
                      quoteString(executablePath),
                      cmd);
          }
  
          handle = create(cmdstr, envblock, path,
</pre>
<center><a href="ClassLoaderHelper.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../net/DefaultDatagramSocketImplFactory.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/classes/java/lang/ProcessImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassLoaderHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../net/DefaultDatagramSocketImplFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/classes/java/lang/ProcessImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 
 28 import java.io.BufferedInputStream;
 29 import java.io.BufferedOutputStream;
 30 import java.io.File;
 31 import java.io.FileDescriptor;
 32 import java.io.FileInputStream;
 33 import java.io.FileOutputStream;
 34 import java.io.IOException;
 35 import java.io.InputStream;
 36 import java.io.OutputStream;
 37 import java.lang.ProcessBuilder.Redirect;
 38 import java.security.AccessController;
 39 import java.security.PrivilegedAction;
 40 import java.util.ArrayList;

 41 import java.util.concurrent.CompletableFuture;
 42 import java.util.concurrent.TimeUnit;
 43 import java.util.regex.Matcher;
 44 import java.util.regex.Pattern;
 45 
 46 import jdk.internal.access.JavaIOFileDescriptorAccess;
 47 import jdk.internal.access.SharedSecrets;
 48 import jdk.internal.ref.CleanerFactory;


 49 
 50 /* This class is for the exclusive use of ProcessBuilder.start() to
 51  * create new processes.
 52  *
 53  * @author Martin Buchholz
 54  * @since   1.5
 55  */
 56 
 57 final class ProcessImpl extends Process {
 58     private static final JavaIOFileDescriptorAccess fdAccess
 59         = SharedSecrets.getJavaIOFileDescriptorAccess();
 60 
 61     // Windows platforms support a forcible kill signal.
 62     static final boolean SUPPORTS_NORMAL_TERMINATION = false;
 63 
 64     /**
 65      * Open a file for writing. If {@code append} is {@code true} then the file
 66      * is opened for atomic append directly and a FileOutputStream constructed
 67      * with the resulting handle. This is because a FileOutputStream created
 68      * to append to a file does not open the file in a manner that guarantees
</pre>
<hr />
<pre>
192             Pattern.compile(&quot;[^\\s\&quot;]+|\&quot;[^\&quot;]*\&quot;&quot;);
193     };
194 
195     /* Parses the command string parameter into the executable name and
196      * program arguments.
197      *
198      * The command string is broken into tokens. The token separator is a space
199      * or quota character. The space inside quotation is not a token separator.
200      * There are no escape sequences.
201      */
202     private static String[] getTokensFromCommand(String command) {
203         ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;(8);
204         Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);
205         while (regexMatcher.find())
206             matchList.add(regexMatcher.group());
207         return matchList.toArray(new String[matchList.size()]);
208     }
209 
210     private static final int VERIFICATION_CMD_BAT = 0;
211     private static final int VERIFICATION_WIN32 = 1;
<span class="line-modified">212     private static final int VERIFICATION_LEGACY = 2;</span>



213     private static final char ESCAPE_VERIFICATION[][] = {
214         // We guarantee the only command file execution for implicit [cmd.exe] run.
215         //    http://technet.microsoft.com/en-us/library/bb490954.aspx
216         {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;},
<span class="line-modified">217 </span>
218         {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;},
219         {&#39; &#39;, &#39;\t&#39;}
220     };
221 
222     private static String createCommandLine(int verificationType,
223                                      final String executablePath,
224                                      final String cmd[])
225     {
226         StringBuilder cmdbuf = new StringBuilder(80);
227 
228         cmdbuf.append(executablePath);
229 
230         for (int i = 1; i &lt; cmd.length; ++i) {
231             cmdbuf.append(&#39; &#39;);
232             String s = cmd[i];
233             if (needsEscaping(verificationType, s)) {
<span class="line-modified">234                 cmdbuf.append(&#39;&quot;&#39;).append(s);</span>
235 

















236                 // The code protects the [java.exe] and console command line
237                 // parser, that interprets the [\&quot;] combination as an escape
238                 // sequence for the [&quot;] char.
239                 //     http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
240                 //
241                 // If the argument is an FS path, doubling of the tail [\]
242                 // char is not a problem for non-console applications.
243                 //
244                 // The [\&quot;] sequence is not an escape sequence for the [cmd.exe]
245                 // command line parser. The case of the [&quot;&quot;] tail escape
246                 // sequence could not be realized due to the argument validation
247                 // procedure.
<span class="line-modified">248                 if ((verificationType != VERIFICATION_CMD_BAT) &amp;&amp; s.endsWith(&quot;\\&quot;)) {</span>
<span class="line-modified">249                     cmdbuf.append(&#39;\\&#39;);</span>

250                 }
251                 cmdbuf.append(&#39;&quot;&#39;);
252             } else {
253                 cmdbuf.append(s);
254             }
255         }
256         return cmdbuf.toString();
257     }
258 
<span class="line-modified">259     private static boolean isQuoted(boolean noQuotesInside, String arg,</span>
<span class="line-modified">260             String errorMessage) {</span>
<span class="line-modified">261         int lastPos = arg.length() - 1;</span>
<span class="line-modified">262         if (lastPos &gt;=1 &amp;&amp; arg.charAt(0) == &#39;&quot;&#39; &amp;&amp; arg.charAt(lastPos) == &#39;&quot;&#39;) {</span>
<span class="line-modified">263             // The argument has already been quoted.</span>
<span class="line-modified">264             if (noQuotesInside) {</span>
<span class="line-modified">265                 if (arg.indexOf(&#39;&quot;&#39;, 1) != lastPos) {</span>
<span class="line-modified">266                     // There is [&quot;] inside.</span>
<span class="line-modified">267                     throw new IllegalArgumentException(errorMessage);</span>
<span class="line-modified">268                 }</span>
<span class="line-removed">269             }</span>
<span class="line-removed">270             return true;</span>
<span class="line-removed">271         }</span>
<span class="line-removed">272         if (noQuotesInside) {</span>
<span class="line-removed">273             if (arg.indexOf(&#39;&quot;&#39;) &gt;= 0) {</span>
<span class="line-removed">274                 // There is [&quot;] inside.</span>
<span class="line-removed">275                 throw new IllegalArgumentException(errorMessage);</span>
<span class="line-removed">276             }</span>
<span class="line-removed">277         }</span>
<span class="line-removed">278         return false;</span>
279     }
280 
281     private static boolean needsEscaping(int verificationType, String arg) {
282         // Switch off MS heuristic for internal [&quot;].
283         // Please, use the explicit [cmd.exe] call
284         // if you need the internal [&quot;].
285         //    Example: &quot;cmd.exe&quot;, &quot;/C&quot;, &quot;Extended_MS_Syntax&quot;
286 
287         // For [.exe] or [.com] file the unpaired/internal [&quot;]
288         // in the argument is not a problem.
<span class="line-modified">289         boolean argIsQuoted = isQuoted(</span>
<span class="line-modified">290             (verificationType == VERIFICATION_CMD_BAT),</span>
<span class="line-modified">291             arg, &quot;Argument has embedded quote, use the explicit CMD.EXE call.&quot;);</span>

















292 
293         if (!argIsQuoted) {
294             char testEscape[] = ESCAPE_VERIFICATION[verificationType];
295             for (int i = 0; i &lt; testEscape.length; ++i) {
296                 if (arg.indexOf(testEscape[i]) &gt;= 0) {
297                     return true;
298                 }
299             }
300         }
301         return false;
302     }
303 
304     private static String getExecutablePath(String path)
305         throws IOException
306     {
<span class="line-modified">307         boolean pathIsQuoted = isQuoted(true, path,</span>
<span class="line-modified">308                 &quot;Executable name has embedded quote, split the arguments&quot;);</span>
<span class="line-modified">309 </span>


310         // Win32 CreateProcess requires path to be normalized
<span class="line-modified">311         File fileToRun = new File(pathIsQuoted</span>
<span class="line-removed">312             ? path.substring(1, path.length() - 1)</span>
<span class="line-removed">313             : path);</span>
314 
315         // From the [CreateProcess] function documentation:
316         //
317         // &quot;If the file name does not contain an extension, .exe is appended.
318         // Therefore, if the file name extension is .com, this parameter
319         // must include the .com extension. If the file name ends in
320         // a period (.) with no extension, or if the file name contains a path,
321         // .exe is not appended.&quot;
322         //
323         // &quot;If the file name !does not contain a directory path!,
324         // the system searches for the executable file in the following
325         // sequence:...&quot;
326         //
327         // In practice ANY non-existent path is extended by [.exe] extension
<span class="line-modified">328         // in the [CreateProcess] funcion with the only exception:</span>
329         // the path ends by (.)
330 
331         return fileToRun.getPath();
332     }
333 












334 

335     private boolean isShellFile(String executablePath) {
336         String upPath = executablePath.toUpperCase();
337         return (upPath.endsWith(&quot;.CMD&quot;) || upPath.endsWith(&quot;.BAT&quot;));
338     }
339 
340     private String quoteString(String arg) {
341         StringBuilder argbuf = new StringBuilder(arg.length() + 2);
342         return argbuf.append(&#39;&quot;&#39;).append(arg).append(&#39;&quot;&#39;).toString();
343     }
344 















345 
346     private final long handle;
347     private final ProcessHandle processHandle;
348     private OutputStream stdin_stream;
349     private InputStream stdout_stream;
350     private InputStream stderr_stream;
351 
352     private ProcessImpl(String cmd[],
353                         final String envblock,
354                         final String path,
355                         final long[] stdHandles,
356                         boolean forceNullOutputStream,
357                         final boolean redirectErrorStream)
358         throws IOException
359     {
360         String cmdstr;
<span class="line-modified">361         SecurityManager security = System.getSecurityManager();</span>
<span class="line-modified">362         boolean allowAmbiguousCommands = false;</span>
<span class="line-modified">363         if (security == null) {</span>
<span class="line-modified">364             allowAmbiguousCommands = true;</span>
<span class="line-modified">365             String value = System.getProperty(&quot;jdk.lang.Process.allowAmbiguousCommands&quot;);</span>
<span class="line-modified">366             if (value != null)</span>
<span class="line-modified">367                 allowAmbiguousCommands = !&quot;false&quot;.equalsIgnoreCase(value);</span>
<span class="line-removed">368         }</span>
<span class="line-removed">369         if (allowAmbiguousCommands) {</span>
370             // Legacy mode.
371 
372             // Normalize path if possible.
373             String executablePath = new File(cmd[0]).getPath();
374 
375             // No worry about internal, unpaired [&quot;], and redirection/piping.
376             if (needsEscaping(VERIFICATION_LEGACY, executablePath) )
377                 executablePath = quoteString(executablePath);
378 
379             cmdstr = createCommandLine(
380                 //legacy mode doesn&#39;t worry about extended verification
381                 VERIFICATION_LEGACY,
382                 executablePath,
383                 cmd);
384         } else {
385             String executablePath;
386             try {
387                 executablePath = getExecutablePath(cmd[0]);
388             } catch (IllegalArgumentException e) {
389                 // Workaround for the calls like
</pre>
<hr />
<pre>
396                 // calls with internal [&quot;] and escape sequences.
397 
398                 // Restore original command line.
399                 StringBuilder join = new StringBuilder();
400                 // terminal space in command line is ok
401                 for (String s : cmd)
402                     join.append(s).append(&#39; &#39;);
403 
404                 // Parse the command line again.
405                 cmd = getTokensFromCommand(join.toString());
406                 executablePath = getExecutablePath(cmd[0]);
407 
408                 // Check new executable name once more
409                 if (security != null)
410                     security.checkExec(executablePath);
411             }
412 
413             // Quotation protects from interpretation of the [path] argument as
414             // start of longer path with spaces. Quotation has no influence to
415             // [.exe] extension heuristic.


416             cmdstr = createCommandLine(
<span class="line-modified">417                     // We need the extended verification procedure for CMD files.</span>
<span class="line-modified">418                     isShellFile(executablePath)</span>
<span class="line-modified">419                         ? VERIFICATION_CMD_BAT</span>
<span class="line-removed">420                         : VERIFICATION_WIN32,</span>
421                     quoteString(executablePath),
422                     cmd);
423         }
424 
425         handle = create(cmdstr, envblock, path,
426                         stdHandles, redirectErrorStream);
427         // Register a cleaning function to close the handle
428         final long local_handle = handle;    // local to prevent capture of this
429         CleanerFactory.cleaner().register(this, () -&gt; closeHandle(local_handle));
430 
431         processHandle = ProcessHandleImpl.getInternal(getProcessId0(handle));
432 
433         java.security.AccessController.doPrivileged(
434         new java.security.PrivilegedAction&lt;Void&gt;() {
435         public Void run() {
436             if (stdHandles[0] == -1L)
437                 stdin_stream = ProcessBuilder.NullOutputStream.INSTANCE;
438             else {
439                 FileDescriptor stdin_fd = new FileDescriptor();
440                 fdAccess.setHandle(stdin_fd, stdHandles[0]);
</pre>
</td>
<td>
<hr />
<pre>
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 
 28 import java.io.BufferedInputStream;
 29 import java.io.BufferedOutputStream;
 30 import java.io.File;
 31 import java.io.FileDescriptor;
 32 import java.io.FileInputStream;
 33 import java.io.FileOutputStream;
 34 import java.io.IOException;
 35 import java.io.InputStream;
 36 import java.io.OutputStream;
 37 import java.lang.ProcessBuilder.Redirect;
 38 import java.security.AccessController;
 39 import java.security.PrivilegedAction;
 40 import java.util.ArrayList;
<span class="line-added"> 41 import java.util.Locale;</span>
 42 import java.util.concurrent.CompletableFuture;
 43 import java.util.concurrent.TimeUnit;
 44 import java.util.regex.Matcher;
 45 import java.util.regex.Pattern;
 46 
 47 import jdk.internal.access.JavaIOFileDescriptorAccess;
 48 import jdk.internal.access.SharedSecrets;
 49 import jdk.internal.ref.CleanerFactory;
<span class="line-added"> 50 import sun.security.action.GetBooleanAction;</span>
<span class="line-added"> 51 import sun.security.action.GetPropertyAction;</span>
 52 
 53 /* This class is for the exclusive use of ProcessBuilder.start() to
 54  * create new processes.
 55  *
 56  * @author Martin Buchholz
 57  * @since   1.5
 58  */
 59 
 60 final class ProcessImpl extends Process {
 61     private static final JavaIOFileDescriptorAccess fdAccess
 62         = SharedSecrets.getJavaIOFileDescriptorAccess();
 63 
 64     // Windows platforms support a forcible kill signal.
 65     static final boolean SUPPORTS_NORMAL_TERMINATION = false;
 66 
 67     /**
 68      * Open a file for writing. If {@code append} is {@code true} then the file
 69      * is opened for atomic append directly and a FileOutputStream constructed
 70      * with the resulting handle. This is because a FileOutputStream created
 71      * to append to a file does not open the file in a manner that guarantees
</pre>
<hr />
<pre>
195             Pattern.compile(&quot;[^\\s\&quot;]+|\&quot;[^\&quot;]*\&quot;&quot;);
196     };
197 
198     /* Parses the command string parameter into the executable name and
199      * program arguments.
200      *
201      * The command string is broken into tokens. The token separator is a space
202      * or quota character. The space inside quotation is not a token separator.
203      * There are no escape sequences.
204      */
205     private static String[] getTokensFromCommand(String command) {
206         ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;(8);
207         Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);
208         while (regexMatcher.find())
209             matchList.add(regexMatcher.group());
210         return matchList.toArray(new String[matchList.size()]);
211     }
212 
213     private static final int VERIFICATION_CMD_BAT = 0;
214     private static final int VERIFICATION_WIN32 = 1;
<span class="line-modified">215     private static final int VERIFICATION_WIN32_SAFE = 2; // inside quotes not allowed</span>
<span class="line-added">216     private static final int VERIFICATION_LEGACY = 3;</span>
<span class="line-added">217     // See Command shell overview for documentation of special characters.</span>
<span class="line-added">218     // https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490954(v=technet.10)</span>
219     private static final char ESCAPE_VERIFICATION[][] = {
220         // We guarantee the only command file execution for implicit [cmd.exe] run.
221         //    http://technet.microsoft.com/en-us/library/bb490954.aspx
222         {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;},
<span class="line-modified">223         {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;},</span>
224         {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;},
225         {&#39; &#39;, &#39;\t&#39;}
226     };
227 
228     private static String createCommandLine(int verificationType,
229                                      final String executablePath,
230                                      final String cmd[])
231     {
232         StringBuilder cmdbuf = new StringBuilder(80);
233 
234         cmdbuf.append(executablePath);
235 
236         for (int i = 1; i &lt; cmd.length; ++i) {
237             cmdbuf.append(&#39; &#39;);
238             String s = cmd[i];
239             if (needsEscaping(verificationType, s)) {
<span class="line-modified">240                 cmdbuf.append(&#39;&quot;&#39;);</span>
241 
<span class="line-added">242                 if (verificationType == VERIFICATION_WIN32_SAFE) {</span>
<span class="line-added">243                     // Insert the argument, adding &#39;\&#39; to quote any interior quotes</span>
<span class="line-added">244                     int length = s.length();</span>
<span class="line-added">245                     for (int j = 0; j &lt; length; j++) {</span>
<span class="line-added">246                         char c = s.charAt(j);</span>
<span class="line-added">247                         if (c == DOUBLEQUOTE) {</span>
<span class="line-added">248                             int count = countLeadingBackslash(verificationType, s, j);</span>
<span class="line-added">249                             while (count-- &gt; 0) {</span>
<span class="line-added">250                                 cmdbuf.append(BACKSLASH);   // double the number of backslashes</span>
<span class="line-added">251                             }</span>
<span class="line-added">252                             cmdbuf.append(BACKSLASH);       // backslash to quote the quote</span>
<span class="line-added">253                         }</span>
<span class="line-added">254                         cmdbuf.append(c);</span>
<span class="line-added">255                     }</span>
<span class="line-added">256                 } else {</span>
<span class="line-added">257                     cmdbuf.append(s);</span>
<span class="line-added">258                 }</span>
259                 // The code protects the [java.exe] and console command line
260                 // parser, that interprets the [\&quot;] combination as an escape
261                 // sequence for the [&quot;] char.
262                 //     http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
263                 //
264                 // If the argument is an FS path, doubling of the tail [\]
265                 // char is not a problem for non-console applications.
266                 //
267                 // The [\&quot;] sequence is not an escape sequence for the [cmd.exe]
268                 // command line parser. The case of the [&quot;&quot;] tail escape
269                 // sequence could not be realized due to the argument validation
270                 // procedure.
<span class="line-modified">271                 int count = countLeadingBackslash(verificationType, s, s.length());</span>
<span class="line-modified">272                 while (count-- &gt; 0) {</span>
<span class="line-added">273                     cmdbuf.append(BACKSLASH);   // double the number of backslashes</span>
274                 }
275                 cmdbuf.append(&#39;&quot;&#39;);
276             } else {
277                 cmdbuf.append(s);
278             }
279         }
280         return cmdbuf.toString();
281     }
282 
<span class="line-modified">283     /**</span>
<span class="line-modified">284      * Return the argument without quotes (1st and last) if present, else the arg.</span>
<span class="line-modified">285      * @param str a string</span>
<span class="line-modified">286      * @return the string without 1st and last quotes</span>
<span class="line-modified">287      */</span>
<span class="line-modified">288     private static String unQuote(String str) {</span>
<span class="line-modified">289         int len = str.length();</span>
<span class="line-modified">290         return (len &gt;= 2 &amp;&amp; str.charAt(0) == DOUBLEQUOTE &amp;&amp; str.charAt(len - 1) == DOUBLEQUOTE)</span>
<span class="line-modified">291                 ? str.substring(1, len - 1)</span>
<span class="line-modified">292                 : str;</span>










293     }
294 
295     private static boolean needsEscaping(int verificationType, String arg) {
296         // Switch off MS heuristic for internal [&quot;].
297         // Please, use the explicit [cmd.exe] call
298         // if you need the internal [&quot;].
299         //    Example: &quot;cmd.exe&quot;, &quot;/C&quot;, &quot;Extended_MS_Syntax&quot;
300 
301         // For [.exe] or [.com] file the unpaired/internal [&quot;]
302         // in the argument is not a problem.
<span class="line-modified">303         String unquotedArg = unQuote(arg);</span>
<span class="line-modified">304         boolean argIsQuoted = !arg.equals(unquotedArg);</span>
<span class="line-modified">305         boolean embeddedQuote = unquotedArg.indexOf(DOUBLEQUOTE) &gt;= 0;</span>
<span class="line-added">306 </span>
<span class="line-added">307         switch (verificationType) {</span>
<span class="line-added">308             case VERIFICATION_CMD_BAT:</span>
<span class="line-added">309                 if (embeddedQuote) {</span>
<span class="line-added">310                     throw new IllegalArgumentException(&quot;Argument has embedded quote, &quot; +</span>
<span class="line-added">311                             &quot;use the explicit CMD.EXE call.&quot;);</span>
<span class="line-added">312                 }</span>
<span class="line-added">313                 break;  // break determine whether to quote</span>
<span class="line-added">314             case VERIFICATION_WIN32_SAFE:</span>
<span class="line-added">315                 if (argIsQuoted &amp;&amp; embeddedQuote)  {</span>
<span class="line-added">316                     throw new IllegalArgumentException(&quot;Malformed argument has embedded quote: &quot;</span>
<span class="line-added">317                             + unquotedArg);</span>
<span class="line-added">318                 }</span>
<span class="line-added">319                 break;</span>
<span class="line-added">320             default:</span>
<span class="line-added">321                 break;</span>
<span class="line-added">322         }</span>
323 
324         if (!argIsQuoted) {
325             char testEscape[] = ESCAPE_VERIFICATION[verificationType];
326             for (int i = 0; i &lt; testEscape.length; ++i) {
327                 if (arg.indexOf(testEscape[i]) &gt;= 0) {
328                     return true;
329                 }
330             }
331         }
332         return false;
333     }
334 
335     private static String getExecutablePath(String path)
336         throws IOException
337     {
<span class="line-modified">338         String name = unQuote(path);</span>
<span class="line-modified">339         if (name.indexOf(DOUBLEQUOTE) &gt;= 0) {</span>
<span class="line-modified">340             throw new IllegalArgumentException(&quot;Executable name has embedded quote, &quot; +</span>
<span class="line-added">341                     &quot;split the arguments: &quot; + name);</span>
<span class="line-added">342         }</span>
343         // Win32 CreateProcess requires path to be normalized
<span class="line-modified">344         File fileToRun = new File(name);</span>


345 
346         // From the [CreateProcess] function documentation:
347         //
348         // &quot;If the file name does not contain an extension, .exe is appended.
349         // Therefore, if the file name extension is .com, this parameter
350         // must include the .com extension. If the file name ends in
351         // a period (.) with no extension, or if the file name contains a path,
352         // .exe is not appended.&quot;
353         //
354         // &quot;If the file name !does not contain a directory path!,
355         // the system searches for the executable file in the following
356         // sequence:...&quot;
357         //
358         // In practice ANY non-existent path is extended by [.exe] extension
<span class="line-modified">359         // in the [CreateProcess] function with the only exception:</span>
360         // the path ends by (.)
361 
362         return fileToRun.getPath();
363     }
364 
<span class="line-added">365     /**</span>
<span class="line-added">366      * An executable is any program that is an EXE or does not have an extension</span>
<span class="line-added">367      * and the Windows createProcess will be looking for .exe.</span>
<span class="line-added">368      * The comparison is case insensitive based on the name.</span>
<span class="line-added">369      * @param executablePath the executable file</span>
<span class="line-added">370      * @return true if the path ends in .exe or does not have an extension.</span>
<span class="line-added">371      */</span>
<span class="line-added">372     private boolean isExe(String executablePath) {</span>
<span class="line-added">373         File file = new File(executablePath);</span>
<span class="line-added">374         String upName = file.getName().toUpperCase(Locale.ROOT);</span>
<span class="line-added">375         return (upName.endsWith(&quot;.EXE&quot;) || upName.indexOf(&#39;.&#39;) &lt; 0);</span>
<span class="line-added">376     }</span>
377 
<span class="line-added">378     // Old version that can be bypassed</span>
379     private boolean isShellFile(String executablePath) {
380         String upPath = executablePath.toUpperCase();
381         return (upPath.endsWith(&quot;.CMD&quot;) || upPath.endsWith(&quot;.BAT&quot;));
382     }
383 
384     private String quoteString(String arg) {
385         StringBuilder argbuf = new StringBuilder(arg.length() + 2);
386         return argbuf.append(&#39;&quot;&#39;).append(arg).append(&#39;&quot;&#39;).toString();
387     }
388 
<span class="line-added">389     // Count backslashes before start index of string.</span>
<span class="line-added">390     // .bat files don&#39;t include backslashes as part of the quote</span>
<span class="line-added">391     private static int countLeadingBackslash(int verificationType,</span>
<span class="line-added">392                                              CharSequence input, int start) {</span>
<span class="line-added">393         if (verificationType == VERIFICATION_CMD_BAT)</span>
<span class="line-added">394             return 0;</span>
<span class="line-added">395         int j;</span>
<span class="line-added">396         for (j = start - 1; j &gt;= 0 &amp;&amp; input.charAt(j) == BACKSLASH; j--) {</span>
<span class="line-added">397             // just scanning backwards</span>
<span class="line-added">398         }</span>
<span class="line-added">399         return (start - 1) - j;  // number of BACKSLASHES</span>
<span class="line-added">400     }</span>
<span class="line-added">401 </span>
<span class="line-added">402     private static final char DOUBLEQUOTE = &#39;\&quot;&#39;;</span>
<span class="line-added">403     private static final char BACKSLASH = &#39;\\&#39;;</span>
404 
405     private final long handle;
406     private final ProcessHandle processHandle;
407     private OutputStream stdin_stream;
408     private InputStream stdout_stream;
409     private InputStream stderr_stream;
410 
411     private ProcessImpl(String cmd[],
412                         final String envblock,
413                         final String path,
414                         final long[] stdHandles,
415                         boolean forceNullOutputStream,
416                         final boolean redirectErrorStream)
417         throws IOException
418     {
419         String cmdstr;
<span class="line-modified">420         final SecurityManager security = System.getSecurityManager();</span>
<span class="line-modified">421         final String value = GetPropertyAction.</span>
<span class="line-modified">422                 privilegedGetProperty(&quot;jdk.lang.Process.allowAmbiguousCommands&quot;,</span>
<span class="line-modified">423                         (security == null ? &quot;true&quot; : &quot;false&quot;));</span>
<span class="line-modified">424         final boolean allowAmbiguousCommands = !&quot;false&quot;.equalsIgnoreCase(value);</span>
<span class="line-modified">425 </span>
<span class="line-modified">426         if (allowAmbiguousCommands &amp;&amp; security == null) {</span>


427             // Legacy mode.
428 
429             // Normalize path if possible.
430             String executablePath = new File(cmd[0]).getPath();
431 
432             // No worry about internal, unpaired [&quot;], and redirection/piping.
433             if (needsEscaping(VERIFICATION_LEGACY, executablePath) )
434                 executablePath = quoteString(executablePath);
435 
436             cmdstr = createCommandLine(
437                 //legacy mode doesn&#39;t worry about extended verification
438                 VERIFICATION_LEGACY,
439                 executablePath,
440                 cmd);
441         } else {
442             String executablePath;
443             try {
444                 executablePath = getExecutablePath(cmd[0]);
445             } catch (IllegalArgumentException e) {
446                 // Workaround for the calls like
</pre>
<hr />
<pre>
453                 // calls with internal [&quot;] and escape sequences.
454 
455                 // Restore original command line.
456                 StringBuilder join = new StringBuilder();
457                 // terminal space in command line is ok
458                 for (String s : cmd)
459                     join.append(s).append(&#39; &#39;);
460 
461                 // Parse the command line again.
462                 cmd = getTokensFromCommand(join.toString());
463                 executablePath = getExecutablePath(cmd[0]);
464 
465                 // Check new executable name once more
466                 if (security != null)
467                     security.checkExec(executablePath);
468             }
469 
470             // Quotation protects from interpretation of the [path] argument as
471             // start of longer path with spaces. Quotation has no influence to
472             // [.exe] extension heuristic.
<span class="line-added">473             boolean isShell = allowAmbiguousCommands ? isShellFile(executablePath)</span>
<span class="line-added">474                     : !isExe(executablePath);</span>
475             cmdstr = createCommandLine(
<span class="line-modified">476                     // We need the extended verification procedures</span>
<span class="line-modified">477                     isShell ? VERIFICATION_CMD_BAT</span>
<span class="line-modified">478                             : (allowAmbiguousCommands ? VERIFICATION_WIN32 : VERIFICATION_WIN32_SAFE),</span>

479                     quoteString(executablePath),
480                     cmd);
481         }
482 
483         handle = create(cmdstr, envblock, path,
484                         stdHandles, redirectErrorStream);
485         // Register a cleaning function to close the handle
486         final long local_handle = handle;    // local to prevent capture of this
487         CleanerFactory.cleaner().register(this, () -&gt; closeHandle(local_handle));
488 
489         processHandle = ProcessHandleImpl.getInternal(getProcessId0(handle));
490 
491         java.security.AccessController.doPrivileged(
492         new java.security.PrivilegedAction&lt;Void&gt;() {
493         public Void run() {
494             if (stdHandles[0] == -1L)
495                 stdin_stream = ProcessBuilder.NullOutputStream.INSTANCE;
496             else {
497                 FileDescriptor stdin_fd = new FileDescriptor();
498                 fdAccess.setHandle(stdin_fd, stdHandles[0]);
</pre>
</td>
</tr>
</table>
<center><a href="ClassLoaderHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../net/DefaultDatagramSocketImplFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
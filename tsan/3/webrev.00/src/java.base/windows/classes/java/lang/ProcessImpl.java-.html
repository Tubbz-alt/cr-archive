<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/windows/classes/java/lang/ProcessImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 
 28 import java.io.BufferedInputStream;
 29 import java.io.BufferedOutputStream;
 30 import java.io.File;
 31 import java.io.FileDescriptor;
 32 import java.io.FileInputStream;
 33 import java.io.FileOutputStream;
 34 import java.io.IOException;
 35 import java.io.InputStream;
 36 import java.io.OutputStream;
 37 import java.lang.ProcessBuilder.Redirect;
 38 import java.security.AccessController;
 39 import java.security.PrivilegedAction;
 40 import java.util.ArrayList;
 41 import java.util.concurrent.CompletableFuture;
 42 import java.util.concurrent.TimeUnit;
 43 import java.util.regex.Matcher;
 44 import java.util.regex.Pattern;
 45 
 46 import jdk.internal.access.JavaIOFileDescriptorAccess;
 47 import jdk.internal.access.SharedSecrets;
 48 import jdk.internal.ref.CleanerFactory;
 49 
 50 /* This class is for the exclusive use of ProcessBuilder.start() to
 51  * create new processes.
 52  *
 53  * @author Martin Buchholz
 54  * @since   1.5
 55  */
 56 
 57 final class ProcessImpl extends Process {
 58     private static final JavaIOFileDescriptorAccess fdAccess
 59         = SharedSecrets.getJavaIOFileDescriptorAccess();
 60 
 61     // Windows platforms support a forcible kill signal.
 62     static final boolean SUPPORTS_NORMAL_TERMINATION = false;
 63 
 64     /**
 65      * Open a file for writing. If {@code append} is {@code true} then the file
 66      * is opened for atomic append directly and a FileOutputStream constructed
 67      * with the resulting handle. This is because a FileOutputStream created
 68      * to append to a file does not open the file in a manner that guarantees
 69      * that writes by the child process will be atomic.
 70      */
 71     private static FileOutputStream newFileOutputStream(File f, boolean append)
 72         throws IOException
 73     {
 74         if (append) {
 75             String path = f.getPath();
 76             SecurityManager sm = System.getSecurityManager();
 77             if (sm != null)
 78                 sm.checkWrite(path);
 79             long handle = openForAtomicAppend(path);
 80             final FileDescriptor fd = new FileDescriptor();
 81             fdAccess.setHandle(fd, handle);
 82             return AccessController.doPrivileged(
 83                 new PrivilegedAction&lt;FileOutputStream&gt;() {
 84                     public FileOutputStream run() {
 85                         return new FileOutputStream(fd);
 86                     }
 87                 }
 88             );
 89         } else {
 90             return new FileOutputStream(f);
 91         }
 92     }
 93 
 94     // System-dependent portion of ProcessBuilder.start()
 95     static Process start(String cmdarray[],
 96                          java.util.Map&lt;String,String&gt; environment,
 97                          String dir,
 98                          ProcessBuilder.Redirect[] redirects,
 99                          boolean redirectErrorStream)
100         throws IOException
101     {
102         String envblock = ProcessEnvironment.toEnvironmentBlock(environment);
103 
104         FileInputStream  f0 = null;
105         FileOutputStream f1 = null;
106         FileOutputStream f2 = null;
107 
108         try {
109             boolean forceNullOutputStream = false;
110             long[] stdHandles;
111             if (redirects == null) {
112                 stdHandles = new long[] { -1L, -1L, -1L };
113             } else {
114                 stdHandles = new long[3];
115 
116                 if (redirects[0] == Redirect.PIPE) {
117                     stdHandles[0] = -1L;
118                 } else if (redirects[0] == Redirect.INHERIT) {
119                     stdHandles[0] = fdAccess.getHandle(FileDescriptor.in);
120                 } else if (redirects[0] instanceof ProcessBuilder.RedirectPipeImpl) {
121                     stdHandles[0] = fdAccess.getHandle(((ProcessBuilder.RedirectPipeImpl) redirects[0]).getFd());
122                 } else {
123                     f0 = new FileInputStream(redirects[0].file());
124                     stdHandles[0] = fdAccess.getHandle(f0.getFD());
125                 }
126 
127                 if (redirects[1] == Redirect.PIPE) {
128                     stdHandles[1] = -1L;
129                 } else if (redirects[1] == Redirect.INHERIT) {
130                     stdHandles[1] = fdAccess.getHandle(FileDescriptor.out);
131                 } else if (redirects[1] instanceof ProcessBuilder.RedirectPipeImpl) {
132                     stdHandles[1] = fdAccess.getHandle(((ProcessBuilder.RedirectPipeImpl) redirects[1]).getFd());
133                     // Force getInputStream to return a null stream,
134                     // the handle is directly assigned to the next process.
135                     forceNullOutputStream = true;
136                 } else {
137                     f1 = newFileOutputStream(redirects[1].file(),
138                                              redirects[1].append());
139                     stdHandles[1] = fdAccess.getHandle(f1.getFD());
140                 }
141 
142                 if (redirects[2] == Redirect.PIPE) {
143                     stdHandles[2] = -1L;
144                 } else if (redirects[2] == Redirect.INHERIT) {
145                     stdHandles[2] = fdAccess.getHandle(FileDescriptor.err);
146                 } else if (redirects[2] instanceof ProcessBuilder.RedirectPipeImpl) {
147                     stdHandles[2] = fdAccess.getHandle(((ProcessBuilder.RedirectPipeImpl) redirects[2]).getFd());
148                 } else {
149                     f2 = newFileOutputStream(redirects[2].file(),
150                                              redirects[2].append());
151                     stdHandles[2] = fdAccess.getHandle(f2.getFD());
152                 }
153             }
154 
155             Process p = new ProcessImpl(cmdarray, envblock, dir,
156                                    stdHandles, forceNullOutputStream, redirectErrorStream);
157             if (redirects != null) {
158                 // Copy the handles&#39;s if they are to be redirected to another process
159                 if (stdHandles[0] &gt;= 0
160                         &amp;&amp; redirects[0] instanceof ProcessBuilder.RedirectPipeImpl) {
161                     fdAccess.setHandle(((ProcessBuilder.RedirectPipeImpl) redirects[0]).getFd(),
162                             stdHandles[0]);
163                 }
164                 if (stdHandles[1] &gt;= 0
165                         &amp;&amp; redirects[1] instanceof ProcessBuilder.RedirectPipeImpl) {
166                     fdAccess.setHandle(((ProcessBuilder.RedirectPipeImpl) redirects[1]).getFd(),
167                             stdHandles[1]);
168                 }
169                 if (stdHandles[2] &gt;= 0
170                         &amp;&amp; redirects[2] instanceof ProcessBuilder.RedirectPipeImpl) {
171                     fdAccess.setHandle(((ProcessBuilder.RedirectPipeImpl) redirects[2]).getFd(),
172                             stdHandles[2]);
173                 }
174             }
175             return p;
176         } finally {
177             // In theory, close() can throw IOException
178             // (although it is rather unlikely to happen here)
179             try { if (f0 != null) f0.close(); }
180             finally {
181                 try { if (f1 != null) f1.close(); }
182                 finally { if (f2 != null) f2.close(); }
183             }
184         }
185 
186     }
187 
188     private static class LazyPattern {
189         // Escape-support version:
190         //    &quot;(\&quot;)((?:\\\\\\1|.)+?)\\1|([^\\s\&quot;]+)&quot;;
191         private static final Pattern PATTERN =
192             Pattern.compile(&quot;[^\\s\&quot;]+|\&quot;[^\&quot;]*\&quot;&quot;);
193     };
194 
195     /* Parses the command string parameter into the executable name and
196      * program arguments.
197      *
198      * The command string is broken into tokens. The token separator is a space
199      * or quota character. The space inside quotation is not a token separator.
200      * There are no escape sequences.
201      */
202     private static String[] getTokensFromCommand(String command) {
203         ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;(8);
204         Matcher regexMatcher = LazyPattern.PATTERN.matcher(command);
205         while (regexMatcher.find())
206             matchList.add(regexMatcher.group());
207         return matchList.toArray(new String[matchList.size()]);
208     }
209 
210     private static final int VERIFICATION_CMD_BAT = 0;
211     private static final int VERIFICATION_WIN32 = 1;
212     private static final int VERIFICATION_LEGACY = 2;
213     private static final char ESCAPE_VERIFICATION[][] = {
214         // We guarantee the only command file execution for implicit [cmd.exe] run.
215         //    http://technet.microsoft.com/en-us/library/bb490954.aspx
216         {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;},
217 
218         {&#39; &#39;, &#39;\t&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;},
219         {&#39; &#39;, &#39;\t&#39;}
220     };
221 
222     private static String createCommandLine(int verificationType,
223                                      final String executablePath,
224                                      final String cmd[])
225     {
226         StringBuilder cmdbuf = new StringBuilder(80);
227 
228         cmdbuf.append(executablePath);
229 
230         for (int i = 1; i &lt; cmd.length; ++i) {
231             cmdbuf.append(&#39; &#39;);
232             String s = cmd[i];
233             if (needsEscaping(verificationType, s)) {
234                 cmdbuf.append(&#39;&quot;&#39;).append(s);
235 
236                 // The code protects the [java.exe] and console command line
237                 // parser, that interprets the [\&quot;] combination as an escape
238                 // sequence for the [&quot;] char.
239                 //     http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
240                 //
241                 // If the argument is an FS path, doubling of the tail [\]
242                 // char is not a problem for non-console applications.
243                 //
244                 // The [\&quot;] sequence is not an escape sequence for the [cmd.exe]
245                 // command line parser. The case of the [&quot;&quot;] tail escape
246                 // sequence could not be realized due to the argument validation
247                 // procedure.
248                 if ((verificationType != VERIFICATION_CMD_BAT) &amp;&amp; s.endsWith(&quot;\\&quot;)) {
249                     cmdbuf.append(&#39;\\&#39;);
250                 }
251                 cmdbuf.append(&#39;&quot;&#39;);
252             } else {
253                 cmdbuf.append(s);
254             }
255         }
256         return cmdbuf.toString();
257     }
258 
259     private static boolean isQuoted(boolean noQuotesInside, String arg,
260             String errorMessage) {
261         int lastPos = arg.length() - 1;
262         if (lastPos &gt;=1 &amp;&amp; arg.charAt(0) == &#39;&quot;&#39; &amp;&amp; arg.charAt(lastPos) == &#39;&quot;&#39;) {
263             // The argument has already been quoted.
264             if (noQuotesInside) {
265                 if (arg.indexOf(&#39;&quot;&#39;, 1) != lastPos) {
266                     // There is [&quot;] inside.
267                     throw new IllegalArgumentException(errorMessage);
268                 }
269             }
270             return true;
271         }
272         if (noQuotesInside) {
273             if (arg.indexOf(&#39;&quot;&#39;) &gt;= 0) {
274                 // There is [&quot;] inside.
275                 throw new IllegalArgumentException(errorMessage);
276             }
277         }
278         return false;
279     }
280 
281     private static boolean needsEscaping(int verificationType, String arg) {
282         // Switch off MS heuristic for internal [&quot;].
283         // Please, use the explicit [cmd.exe] call
284         // if you need the internal [&quot;].
285         //    Example: &quot;cmd.exe&quot;, &quot;/C&quot;, &quot;Extended_MS_Syntax&quot;
286 
287         // For [.exe] or [.com] file the unpaired/internal [&quot;]
288         // in the argument is not a problem.
289         boolean argIsQuoted = isQuoted(
290             (verificationType == VERIFICATION_CMD_BAT),
291             arg, &quot;Argument has embedded quote, use the explicit CMD.EXE call.&quot;);
292 
293         if (!argIsQuoted) {
294             char testEscape[] = ESCAPE_VERIFICATION[verificationType];
295             for (int i = 0; i &lt; testEscape.length; ++i) {
296                 if (arg.indexOf(testEscape[i]) &gt;= 0) {
297                     return true;
298                 }
299             }
300         }
301         return false;
302     }
303 
304     private static String getExecutablePath(String path)
305         throws IOException
306     {
307         boolean pathIsQuoted = isQuoted(true, path,
308                 &quot;Executable name has embedded quote, split the arguments&quot;);
309 
310         // Win32 CreateProcess requires path to be normalized
311         File fileToRun = new File(pathIsQuoted
312             ? path.substring(1, path.length() - 1)
313             : path);
314 
315         // From the [CreateProcess] function documentation:
316         //
317         // &quot;If the file name does not contain an extension, .exe is appended.
318         // Therefore, if the file name extension is .com, this parameter
319         // must include the .com extension. If the file name ends in
320         // a period (.) with no extension, or if the file name contains a path,
321         // .exe is not appended.&quot;
322         //
323         // &quot;If the file name !does not contain a directory path!,
324         // the system searches for the executable file in the following
325         // sequence:...&quot;
326         //
327         // In practice ANY non-existent path is extended by [.exe] extension
328         // in the [CreateProcess] funcion with the only exception:
329         // the path ends by (.)
330 
331         return fileToRun.getPath();
332     }
333 
334 
335     private boolean isShellFile(String executablePath) {
336         String upPath = executablePath.toUpperCase();
337         return (upPath.endsWith(&quot;.CMD&quot;) || upPath.endsWith(&quot;.BAT&quot;));
338     }
339 
340     private String quoteString(String arg) {
341         StringBuilder argbuf = new StringBuilder(arg.length() + 2);
342         return argbuf.append(&#39;&quot;&#39;).append(arg).append(&#39;&quot;&#39;).toString();
343     }
344 
345 
346     private final long handle;
347     private final ProcessHandle processHandle;
348     private OutputStream stdin_stream;
349     private InputStream stdout_stream;
350     private InputStream stderr_stream;
351 
352     private ProcessImpl(String cmd[],
353                         final String envblock,
354                         final String path,
355                         final long[] stdHandles,
356                         boolean forceNullOutputStream,
357                         final boolean redirectErrorStream)
358         throws IOException
359     {
360         String cmdstr;
361         SecurityManager security = System.getSecurityManager();
362         boolean allowAmbiguousCommands = false;
363         if (security == null) {
364             allowAmbiguousCommands = true;
365             String value = System.getProperty(&quot;jdk.lang.Process.allowAmbiguousCommands&quot;);
366             if (value != null)
367                 allowAmbiguousCommands = !&quot;false&quot;.equalsIgnoreCase(value);
368         }
369         if (allowAmbiguousCommands) {
370             // Legacy mode.
371 
372             // Normalize path if possible.
373             String executablePath = new File(cmd[0]).getPath();
374 
375             // No worry about internal, unpaired [&quot;], and redirection/piping.
376             if (needsEscaping(VERIFICATION_LEGACY, executablePath) )
377                 executablePath = quoteString(executablePath);
378 
379             cmdstr = createCommandLine(
380                 //legacy mode doesn&#39;t worry about extended verification
381                 VERIFICATION_LEGACY,
382                 executablePath,
383                 cmd);
384         } else {
385             String executablePath;
386             try {
387                 executablePath = getExecutablePath(cmd[0]);
388             } catch (IllegalArgumentException e) {
389                 // Workaround for the calls like
390                 // Runtime.getRuntime().exec(&quot;\&quot;C:\\Program Files\\foo\&quot; bar&quot;)
391 
392                 // No chance to avoid CMD/BAT injection, except to do the work
393                 // right from the beginning. Otherwise we have too many corner
394                 // cases from
395                 //    Runtime.getRuntime().exec(String[] cmd [, ...])
396                 // calls with internal [&quot;] and escape sequences.
397 
398                 // Restore original command line.
399                 StringBuilder join = new StringBuilder();
400                 // terminal space in command line is ok
401                 for (String s : cmd)
402                     join.append(s).append(&#39; &#39;);
403 
404                 // Parse the command line again.
405                 cmd = getTokensFromCommand(join.toString());
406                 executablePath = getExecutablePath(cmd[0]);
407 
408                 // Check new executable name once more
409                 if (security != null)
410                     security.checkExec(executablePath);
411             }
412 
413             // Quotation protects from interpretation of the [path] argument as
414             // start of longer path with spaces. Quotation has no influence to
415             // [.exe] extension heuristic.
416             cmdstr = createCommandLine(
417                     // We need the extended verification procedure for CMD files.
418                     isShellFile(executablePath)
419                         ? VERIFICATION_CMD_BAT
420                         : VERIFICATION_WIN32,
421                     quoteString(executablePath),
422                     cmd);
423         }
424 
425         handle = create(cmdstr, envblock, path,
426                         stdHandles, redirectErrorStream);
427         // Register a cleaning function to close the handle
428         final long local_handle = handle;    // local to prevent capture of this
429         CleanerFactory.cleaner().register(this, () -&gt; closeHandle(local_handle));
430 
431         processHandle = ProcessHandleImpl.getInternal(getProcessId0(handle));
432 
433         java.security.AccessController.doPrivileged(
434         new java.security.PrivilegedAction&lt;Void&gt;() {
435         public Void run() {
436             if (stdHandles[0] == -1L)
437                 stdin_stream = ProcessBuilder.NullOutputStream.INSTANCE;
438             else {
439                 FileDescriptor stdin_fd = new FileDescriptor();
440                 fdAccess.setHandle(stdin_fd, stdHandles[0]);
441                 stdin_stream = new BufferedOutputStream(
442                     new FileOutputStream(stdin_fd));
443             }
444 
445             if (stdHandles[1] == -1L || forceNullOutputStream)
446                 stdout_stream = ProcessBuilder.NullInputStream.INSTANCE;
447             else {
448                 FileDescriptor stdout_fd = new FileDescriptor();
449                 fdAccess.setHandle(stdout_fd, stdHandles[1]);
450                 stdout_stream = new BufferedInputStream(
451                     new PipeInputStream(stdout_fd));
452             }
453 
454             if (stdHandles[2] == -1L)
455                 stderr_stream = ProcessBuilder.NullInputStream.INSTANCE;
456             else {
457                 FileDescriptor stderr_fd = new FileDescriptor();
458                 fdAccess.setHandle(stderr_fd, stdHandles[2]);
459                 stderr_stream = new PipeInputStream(stderr_fd);
460             }
461 
462             return null; }});
463     }
464 
465     public OutputStream getOutputStream() {
466         return stdin_stream;
467     }
468 
469     public InputStream getInputStream() {
470         return stdout_stream;
471     }
472 
473     public InputStream getErrorStream() {
474         return stderr_stream;
475     }
476 
477     private static final int STILL_ACTIVE = getStillActive();
478     private static native int getStillActive();
479 
480     public int exitValue() {
481         int exitCode = getExitCodeProcess(handle);
482         if (exitCode == STILL_ACTIVE)
483             throw new IllegalThreadStateException(&quot;process has not exited&quot;);
484         return exitCode;
485     }
486     private static native int getExitCodeProcess(long handle);
487 
488     public int waitFor() throws InterruptedException {
489         waitForInterruptibly(handle);
490         if (Thread.interrupted())
491             throw new InterruptedException();
492         return exitValue();
493     }
494 
495     private static native void waitForInterruptibly(long handle);
496 
497     @Override
498     public boolean waitFor(long timeout, TimeUnit unit)
499         throws InterruptedException
500     {
501         long remainingNanos = unit.toNanos(timeout);    // throw NPE before other conditions
502         if (getExitCodeProcess(handle) != STILL_ACTIVE) return true;
503         if (timeout &lt;= 0) return false;
504 
505         long deadline = System.nanoTime() + remainingNanos;
506         do {
507             // Round up to next millisecond
508             long msTimeout = TimeUnit.NANOSECONDS.toMillis(remainingNanos + 999_999L);
509             if (msTimeout &lt; 0) {
510                 // if wraps around then wait a long while
511                 msTimeout = Integer.MAX_VALUE;
512             }
513             waitForTimeoutInterruptibly(handle, msTimeout);
514             if (Thread.interrupted())
515                 throw new InterruptedException();
516             if (getExitCodeProcess(handle) != STILL_ACTIVE) {
517                 return true;
518             }
519             remainingNanos = deadline - System.nanoTime();
520         } while (remainingNanos &gt; 0);
521 
522         return (getExitCodeProcess(handle) != STILL_ACTIVE);
523     }
524 
525     private static native void waitForTimeoutInterruptibly(
526         long handle, long timeoutMillis);
527 
528     @Override
529     public void destroy() {
530         terminateProcess(handle);
531     }
532 
533     @Override
534     public CompletableFuture&lt;Process&gt; onExit() {
535         return ProcessHandleImpl.completion(pid(), false)
536                 .handleAsync((exitStatus, unusedThrowable) -&gt; this);
537     }
538 
539     @Override
540     public ProcessHandle toHandle() {
541         SecurityManager sm = System.getSecurityManager();
542         if (sm != null) {
543             sm.checkPermission(new RuntimePermission(&quot;manageProcess&quot;));
544         }
545         return processHandle;
546     }
547 
548     @Override
549     public boolean supportsNormalTermination() {
550         return ProcessImpl.SUPPORTS_NORMAL_TERMINATION;
551     }
552 
553     @Override
554     public Process destroyForcibly() {
555         destroy();
556         return this;
557     }
558 
559     private static native void terminateProcess(long handle);
560 
561     @Override
562     public long pid() {
563         return processHandle.pid();
564     }
565 
566     private static native int getProcessId0(long handle);
567 
568     @Override
569     public boolean isAlive() {
570         return isProcessAlive(handle);
571     }
572 
573     private static native boolean isProcessAlive(long handle);
574 
575     /**
576      * The {@code toString} method returns a string consisting of
577      * the native process ID of the process and the exit value of the process.
578      *
579      * @return a string representation of the object.
580      */
581     @Override
582     public String toString() {
583         int exitCode = getExitCodeProcess(handle);
584         return new StringBuilder(&quot;Process[pid=&quot;).append(pid())
585                 .append(&quot;, exitValue=&quot;).append(exitCode == STILL_ACTIVE ? &quot;\&quot;not exited\&quot;&quot; : exitCode)
586                 .append(&quot;]&quot;).toString();
587     }
588 
589     /**
590      * Create a process using the win32 function CreateProcess.
591      * The method is synchronized due to MS kb315939 problem.
592      * All native handles should restore the inherit flag at the end of call.
593      *
594      * @param cmdstr the Windows command line
595      * @param envblock NUL-separated, double-NUL-terminated list of
596      *        environment strings in VAR=VALUE form
597      * @param dir the working directory of the process, or null if
598      *        inheriting the current directory from the parent process
599      * @param stdHandles array of windows HANDLEs.  Indexes 0, 1, and
600      *        2 correspond to standard input, standard output and
601      *        standard error, respectively.  On input, a value of -1
602      *        means to create a pipe to connect child and parent
603      *        processes.  On output, a value which is not -1 is the
604      *        parent pipe handle corresponding to the pipe which has
605      *        been created.  An element of this array is -1 on input
606      *        if and only if it is &lt;em&gt;not&lt;/em&gt; -1 on output.
607      * @param redirectErrorStream redirectErrorStream attribute
608      * @return the native subprocess HANDLE returned by CreateProcess
609      */
610     private static synchronized native long create(String cmdstr,
611                                       String envblock,
612                                       String dir,
613                                       long[] stdHandles,
614                                       boolean redirectErrorStream)
615         throws IOException;
616 
617     /**
618      * Opens a file for atomic append. The file is created if it doesn&#39;t
619      * already exist.
620      *
621      * @param path the file to open or create
622      * @return the native HANDLE
623      */
624     private static native long openForAtomicAppend(String path)
625         throws IOException;
626 
627     private static native boolean closeHandle(long handle);
628 }
    </pre>
  </body>
</html>
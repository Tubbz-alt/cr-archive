<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/windows/classes/java/net/PlainSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
 26 
 27 import java.io.IOException;
 28 import java.io.FileDescriptor;
 29 import java.security.AccessController;
 30 
 31 import sun.security.action.GetPropertyAction;
 32 import jdk.internal.access.SharedSecrets;
 33 import jdk.internal.access.JavaIOFileDescriptorAccess;
 34 
 35 /**
 36  * On Windows system we simply delegate to native methods.
 37  *
 38  * @author Chris Hegarty
 39  */
 40 
 41 class PlainSocketImpl extends AbstractPlainSocketImpl {
 42 
 43     private static final JavaIOFileDescriptorAccess fdAccess =
 44         SharedSecrets.getJavaIOFileDescriptorAccess();
 45 
 46     private static final boolean preferIPv4Stack =
 47             Boolean.parseBoolean(AccessController.doPrivileged(
 48                 new GetPropertyAction(&quot;java.net.preferIPv4Stack&quot;, &quot;false&quot;)));
 49 
 50     /**
 51      * Empty value of sun.net.useExclusiveBind is treated as &#39;true&#39;.
 52      */
 53     private static final boolean useExclusiveBind;
 54 
 55     static {
 56         String exclBindProp = AccessController.doPrivileged(
 57                 new GetPropertyAction(&quot;sun.net.useExclusiveBind&quot;, &quot;&quot;));
 58         useExclusiveBind = exclBindProp.isEmpty()
 59                 || Boolean.parseBoolean(exclBindProp);
 60     }
 61 
 62     // emulates SO_REUSEADDR when useExclusiveBind is true
 63     private boolean isReuseAddress;
 64 
 65     /**
 66      * Constructs an empty instance.
 67      */
 68     PlainSocketImpl(boolean isServer) {
 69         super(isServer);
 70     }
 71 
 72     @Override
 73     void socketCreate(boolean stream) throws IOException {
 74         if (fd == null)
 75             throw new SocketException(&quot;Socket closed&quot;);
 76 
 77         int newfd = socket0(stream);
 78 
 79         fdAccess.set(fd, newfd);
 80     }
 81 
 82     @Override
 83     void socketConnect(InetAddress address, int port, int timeout)
 84         throws IOException {
 85         int nativefd = checkAndReturnNativeFD();
 86 
 87         if (address == null)
 88             throw new NullPointerException(&quot;inet address argument is null.&quot;);
 89 
 90         if (preferIPv4Stack &amp;&amp; !(address instanceof Inet4Address))
 91             throw new SocketException(&quot;Protocol family not supported&quot;);
 92 
 93         int connectResult;
 94         if (timeout &lt;= 0) {
 95             connectResult = connect0(nativefd, address, port);
 96         } else {
 97             configureBlocking(nativefd, false);
 98             try {
 99                 connectResult = connect0(nativefd, address, port);
100                 if (connectResult == WOULDBLOCK) {
101                     waitForConnect(nativefd, timeout);
102                 }
103             } finally {
104                 configureBlocking(nativefd, true);
105             }
106         }
107         /*
108          * We need to set the local port field. If bind was called
109          * previous to the connect (by the client) then localport field
110          * will already be set.
111          */
112         if (localport == 0)
113             localport = localPort0(nativefd);
114     }
115 
116     @Override
117     void socketBind(InetAddress address, int port) throws IOException {
118         int nativefd = checkAndReturnNativeFD();
119 
120         if (address == null)
121             throw new NullPointerException(&quot;inet address argument is null.&quot;);
122 
123         if (preferIPv4Stack &amp;&amp; !(address instanceof Inet4Address))
124             throw new SocketException(&quot;Protocol family not supported&quot;);
125 
126         bind0(nativefd, address, port, useExclusiveBind);
127         if (port == 0) {
128             localport = localPort0(nativefd);
129         } else {
130             localport = port;
131         }
132 
133         this.address = address;
134     }
135 
136     @Override
137     void socketListen(int backlog) throws IOException {
138         int nativefd = checkAndReturnNativeFD();
139 
140         listen0(nativefd, backlog);
141     }
142 
143     @Override
144     void socketAccept(SocketImpl s) throws IOException {
145         int nativefd = checkAndReturnNativeFD();
146 
147         if (s == null)
148             throw new NullPointerException(&quot;socket is null&quot;);
149 
150         int newfd = -1;
151         InetSocketAddress[] isaa = new InetSocketAddress[1];
152         if (timeout &lt;= 0) {
153             newfd = accept0(nativefd, isaa);
154         } else {
155             configureBlocking(nativefd, false);
156             try {
157                 waitForNewConnection(nativefd, timeout);
158                 newfd = accept0(nativefd, isaa);
159                 if (newfd != -1) {
160                     configureBlocking(newfd, true);
161                 }
162             } finally {
163                 configureBlocking(nativefd, true);
164             }
165         }
166         /* Update (SocketImpl)s&#39; fd */
167         fdAccess.set(s.fd, newfd);
168         /* Update socketImpls remote port, address and localport */
169         InetSocketAddress isa = isaa[0];
170         s.port = isa.getPort();
171         s.address = isa.getAddress();
172         s.localport = localport;
173         if (preferIPv4Stack &amp;&amp; !(s.address instanceof Inet4Address))
174             throw new SocketException(&quot;Protocol family not supported&quot;);
175     }
176 
177     @Override
178     int socketAvailable() throws IOException {
179         int nativefd = checkAndReturnNativeFD();
180         return available0(nativefd);
181     }
182 
183     @Override
184     void socketClose0(boolean useDeferredClose/*unused*/) throws IOException {
185         if (fd == null)
186             throw new SocketException(&quot;Socket closed&quot;);
187 
188         if (!fd.valid())
189             return;
190 
191         final int nativefd = fdAccess.get(fd);
192         fdAccess.set(fd, -1);
193         close0(nativefd);
194     }
195 
196     @Override
197     void socketShutdown(int howto) throws IOException {
198         int nativefd = checkAndReturnNativeFD();
199         shutdown0(nativefd, howto);
200     }
201 
202     // Intentional fallthrough after SO_REUSEADDR
203     @SuppressWarnings(&quot;fallthrough&quot;)
204     @Override
205     void socketSetOption(int opt, boolean on, Object value)
206         throws SocketException {
207 
208         // SO_REUSEPORT is not supported on Windows.
209         if (opt == SO_REUSEPORT) {
210             throw new UnsupportedOperationException(&quot;unsupported option&quot;);
211         }
212 
213         int nativefd = checkAndReturnNativeFD();
214 
215         if (opt == SO_TIMEOUT) {
216             if (preferIPv4Stack) {
217                 // Don&#39;t enable the socket option on ServerSocket as it&#39;s
218                 // meaningless (we don&#39;t receive on a ServerSocket).
219                 if (!isServer) {
220                     setSoTimeout0(nativefd, ((Integer)value).intValue());
221                 }
222             } // else timeout is implemented through select.
223             return;
224         }
225 
226         int optionValue = 0;
227 
228         switch(opt) {
229             case SO_REUSEADDR:
230                 if (useExclusiveBind) {
231                     // SO_REUSEADDR emulated when using exclusive bind
232                     isReuseAddress = on;
233                     return;
234                 }
235                 // intentional fallthrough
236             case TCP_NODELAY:
237             case SO_OOBINLINE:
238             case SO_KEEPALIVE:
239                 optionValue = on ? 1 : 0;
240                 break;
241             case SO_SNDBUF:
242             case SO_RCVBUF:
243             case IP_TOS:
244                 optionValue = ((Integer)value).intValue();
245                 break;
246             case SO_LINGER:
247                 if (on) {
248                     optionValue = ((Integer)value).intValue();
249                 } else {
250                     optionValue = -1;
251                 }
252                 break;
253             default :/* shouldn&#39;t get here */
254                 throw new SocketException(&quot;Option not supported&quot;);
255         }
256 
257         setIntOption(nativefd, opt, optionValue);
258     }
259 
260     @Override
261     int socketGetOption(int opt, Object iaContainerObj)
262         throws SocketException {
263 
264         // SO_REUSEPORT is not supported on Windows.
265         if (opt == SO_REUSEPORT) {
266             throw new UnsupportedOperationException(&quot;unsupported option&quot;);
267         }
268 
269         int nativefd = checkAndReturnNativeFD();
270 
271         // SO_BINDADDR is not a socket option.
272         if (opt == SO_BINDADDR) {
273             localAddress(nativefd, (InetAddressContainer)iaContainerObj);
274             return 0;  // return value doesn&#39;t matter.
275         }
276 
277         // SO_REUSEADDR emulated when using exclusive bind
278         if (opt == SO_REUSEADDR &amp;&amp; useExclusiveBind)
279             return isReuseAddress ? 1 : -1;
280 
281         int value = getIntOption(nativefd, opt);
282 
283         switch (opt) {
284             case TCP_NODELAY:
285             case SO_OOBINLINE:
286             case SO_KEEPALIVE:
287             case SO_REUSEADDR:
288                 return (value == 0) ? -1 : 1;
289         }
290         return value;
291     }
292 
293     @Override
294     void socketSendUrgentData(int data) throws IOException {
295         int nativefd = checkAndReturnNativeFD();
296         sendOOB(nativefd, data);
297     }
298 
299     private int checkAndReturnNativeFD() throws SocketException {
300         if (fd == null || !fd.valid())
301             throw new SocketException(&quot;Socket closed&quot;);
302 
303         return fdAccess.get(fd);
304     }
305 
306     static final int WOULDBLOCK = -2;       // Nothing available (non-blocking)
307 
308     static {
309         initIDs();
310     }
311 
312     /* Native methods */
313 
314     static native void initIDs();
315 
316     static native int socket0(boolean stream) throws IOException;
317 
318     static native void bind0(int fd, InetAddress localAddress, int localport,
319                              boolean exclBind)
320         throws IOException;
321 
322     static native int connect0(int fd, InetAddress remote, int remotePort)
323         throws IOException;
324 
325     static native void waitForConnect(int fd, int timeout) throws IOException;
326 
327     static native int localPort0(int fd) throws IOException;
328 
329     static native void localAddress(int fd, InetAddressContainer in) throws SocketException;
330 
331     static native void listen0(int fd, int backlog) throws IOException;
332 
333     static native int accept0(int fd, InetSocketAddress[] isaa) throws IOException;
334 
335     static native void waitForNewConnection(int fd, int timeout) throws IOException;
336 
337     static native int available0(int fd) throws IOException;
338 
339     static native void close0(int fd) throws IOException;
340 
341     static native void shutdown0(int fd, int howto) throws IOException;
342 
343     static native void setIntOption(int fd, int cmd, int optionValue) throws SocketException;
344 
345     static native void setSoTimeout0(int fd, int timeout) throws SocketException;
346 
347     static native int getIntOption(int fd, int cmd) throws SocketException;
348 
349     static native void sendOOB(int fd, int data) throws IOException;
350 
351     static native void configureBlocking(int fd, boolean blocking) throws IOException;
352 }
    </pre>
  </body>
</html>
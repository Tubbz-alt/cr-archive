<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/windows/classes/java/io/WinNTFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../unix/native/libnio/fs/UnixNativeDispatcher.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../lang/ClassLoaderHelper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/windows/classes/java/io/WinNTFileSystem.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
311         int pl = f.getPrefixLength();
312         if ((pl == 2) &amp;&amp; (path.charAt(0) == slash))
313             return path;                        /* UNC */
314         if (pl == 3)
315             return path;                        /* Absolute local */
316         if (pl == 0)
317             return getUserPath() + slashify(path); /* Completely relative */
318         if (pl == 1) {                          /* Drive-relative */
319             String up = getUserPath();
320             String ud = getDrive(up);
321             if (ud != null) return ud + path;
322             return up + path;                   /* User dir is a UNC path */
323         }
324         if (pl == 2) {                          /* Directory-relative */
325             String up = getUserPath();
326             String ud = getDrive(up);
327             if ((ud != null) &amp;&amp; path.startsWith(ud))
328                 return up + slashify(path.substring(2));
329             char drive = path.charAt(0);
330             String dir = getDriveDirectory(drive);
<span class="line-removed">331             String np;</span>
332             if (dir != null) {
333                 /* When resolving a directory-relative path that refers to a
334                    drive other than the current drive, insist that the caller
335                    have read permission on the result */
336                 String p = drive + (&#39;:&#39; + dir + slashify(path.substring(2)));
337                 SecurityManager security = System.getSecurityManager();
338                 try {
339                     if (security != null) security.checkRead(p);
340                 } catch (SecurityException x) {
341                     /* Don&#39;t disclose the drive&#39;s directory in the exception */
342                     throw new SecurityException(&quot;Cannot resolve path &quot; + path);
343                 }
344                 return p;
345             }
346             return drive + &quot;:&quot; + slashify(path.substring(2)); /* fake it */
347         }
348         throw new InternalError(&quot;Unresolvable path: &quot; + path);
349     }
350 
351     private String getUserPath() {
</pre>
<hr />
<pre>
624     }
625 
626     /* -- Disk usage -- */
627 
628     @Override
629     public long getSpace(File f, int t) {
630         if (f.exists()) {
631             return getSpace0(f, t);
632         }
633         return 0;
634     }
635 
636     private native long getSpace0(File f, int t);
637 
638     /* -- Basic infrastructure -- */
639 
640     // Obtain maximum file component length from GetVolumeInformation which
641     // expects the path to be null or a root component ending in a backslash
642     private native int getNameMax0(String path);
643 

644     public int getNameMax(String path) {
645         String s = null;
646         if (path != null) {
647             File f = new File(path);
648             if (f.isAbsolute()) {
649                 Path root = f.toPath().getRoot();
650                 if (root != null) {
651                     s = root.toString();
652                     if (!s.endsWith(&quot;\\&quot;)) {
653                         s = s + &quot;\\&quot;;
654                     }
655                 }
656             }
657         }
658         return getNameMax0(s);
659     }
660 
661     @Override
662     public int compare(File f1, File f2) {
663         return f1.getPath().compareToIgnoreCase(f2.getPath());
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
311         int pl = f.getPrefixLength();
312         if ((pl == 2) &amp;&amp; (path.charAt(0) == slash))
313             return path;                        /* UNC */
314         if (pl == 3)
315             return path;                        /* Absolute local */
316         if (pl == 0)
317             return getUserPath() + slashify(path); /* Completely relative */
318         if (pl == 1) {                          /* Drive-relative */
319             String up = getUserPath();
320             String ud = getDrive(up);
321             if (ud != null) return ud + path;
322             return up + path;                   /* User dir is a UNC path */
323         }
324         if (pl == 2) {                          /* Directory-relative */
325             String up = getUserPath();
326             String ud = getDrive(up);
327             if ((ud != null) &amp;&amp; path.startsWith(ud))
328                 return up + slashify(path.substring(2));
329             char drive = path.charAt(0);
330             String dir = getDriveDirectory(drive);

331             if (dir != null) {
332                 /* When resolving a directory-relative path that refers to a
333                    drive other than the current drive, insist that the caller
334                    have read permission on the result */
335                 String p = drive + (&#39;:&#39; + dir + slashify(path.substring(2)));
336                 SecurityManager security = System.getSecurityManager();
337                 try {
338                     if (security != null) security.checkRead(p);
339                 } catch (SecurityException x) {
340                     /* Don&#39;t disclose the drive&#39;s directory in the exception */
341                     throw new SecurityException(&quot;Cannot resolve path &quot; + path);
342                 }
343                 return p;
344             }
345             return drive + &quot;:&quot; + slashify(path.substring(2)); /* fake it */
346         }
347         throw new InternalError(&quot;Unresolvable path: &quot; + path);
348     }
349 
350     private String getUserPath() {
</pre>
<hr />
<pre>
623     }
624 
625     /* -- Disk usage -- */
626 
627     @Override
628     public long getSpace(File f, int t) {
629         if (f.exists()) {
630             return getSpace0(f, t);
631         }
632         return 0;
633     }
634 
635     private native long getSpace0(File f, int t);
636 
637     /* -- Basic infrastructure -- */
638 
639     // Obtain maximum file component length from GetVolumeInformation which
640     // expects the path to be null or a root component ending in a backslash
641     private native int getNameMax0(String path);
642 
<span class="line-added">643     @Override</span>
644     public int getNameMax(String path) {
645         String s = null;
646         if (path != null) {
647             File f = new File(path);
648             if (f.isAbsolute()) {
649                 Path root = f.toPath().getRoot();
650                 if (root != null) {
651                     s = root.toString();
652                     if (!s.endsWith(&quot;\\&quot;)) {
653                         s = s + &quot;\\&quot;;
654                     }
655                 }
656             }
657         }
658         return getNameMax0(s);
659     }
660 
661     @Override
662     public int compare(File f1, File f2) {
663         return f1.getPath().compareToIgnoreCase(f2.getPath());
</pre>
</td>
</tr>
</table>
<center><a href="../../../../unix/native/libnio/fs/UnixNativeDispatcher.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../lang/ClassLoaderHelper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/solaris/native/libnet/solaris_close.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;errno.h&gt;
 27 #include &lt;sys/socket.h&gt;
 28 #include &lt;stropts.h&gt;
 29 #include &lt;unistd.h&gt;
 30 #include &quot;jvm.h&quot;
 31 #include &quot;net_util.h&quot;
 32 
 33 /* Support for restartable system calls on Solaris. */
 34 
 35 #define RESTARTABLE_RETURN_INT(_cmd) do {             \
 36     int _result;                                      \
 37     if (1) {                                          \
 38         do {                                          \
 39             _result = _cmd;                           \
 40         } while((_result == -1) &amp;&amp; (errno == EINTR));      \
 41         return _result;                               \
 42     }                                                 \
 43 } while(0)
 44 
 45 int NET_Read(int s, void* buf, size_t len) {
 46     RESTARTABLE_RETURN_INT(recv(s, buf, len, 0));
 47 }
 48 
 49 int NET_NonBlockingRead(int s, void* buf, size_t len) {
 50     RESTARTABLE_RETURN_INT(recv(s, buf, len, MSG_DONTWAIT));
 51 }
 52 
 53 int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
 54                  struct sockaddr *from, socklen_t *fromlen) {
 55     RESTARTABLE_RETURN_INT(recvfrom(s, buf, len, flags, from, fromlen));
 56 }
 57 
<a name="1" id="anc1"></a>



 58 int NET_Send(int s, void *msg, int len, unsigned int flags) {
 59     RESTARTABLE_RETURN_INT(send(s, msg, len, flags));
 60 }
 61 
 62 int NET_SendTo(int s, const void *msg, int len,  unsigned  int flags,
 63                const struct sockaddr *to, int tolen) {
 64     RESTARTABLE_RETURN_INT(sendto(s, msg, len, flags, to, tolen));
 65 }
 66 
 67 int NET_Connect(int s, struct sockaddr *addr, int addrlen) {
 68     RESTARTABLE_RETURN_INT(connect(s, addr, addrlen));
 69 }
 70 
 71 int NET_Accept(int s, struct sockaddr *addr, socklen_t *addrlen) {
 72     RESTARTABLE_RETURN_INT(accept(s, addr, addrlen));
 73 }
 74 
 75 int NET_SocketClose(int fd) {
 76     return close(fd);
 77 }
 78 
 79 int NET_Dup2(int fd, int fd2) {
 80     return dup2(fd, fd2);
 81 }
 82 
 83 int NET_Poll(struct pollfd *ufds, unsigned int nfds, int timeout) {
 84     RESTARTABLE_RETURN_INT(poll(ufds, nfds, timeout));
 85 }
 86 
 87 int NET_Timeout(JNIEnv *env, int s, long timeout, jlong nanoTimeStamp) {
 88     int result;
 89     jlong prevNanoTime = nanoTimeStamp;
 90     jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;
 91     struct pollfd pfd;
 92     pfd.fd = s;
 93     pfd.events = POLLIN;
 94 
 95     for(;;) {
 96         result = poll(&amp;pfd, 1, nanoTimeout / NET_NSEC_PER_MSEC);
 97         if (result &lt; 0 &amp;&amp; errno == EINTR) {
 98             jlong newNanoTime = JVM_NanoTime(env, 0);
 99             nanoTimeout -= newNanoTime - prevNanoTime;
100             if (nanoTimeout &lt; NET_NSEC_PER_MSEC)
101                 return 0;
102             prevNanoTime = newNanoTime;
103         } else {
104             return result;
105         }
106     }
107 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
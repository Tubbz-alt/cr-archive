<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/unix/native/libnet/net_util_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;dlfcn.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #include &lt;netinet/tcp.h&gt; // defines TCP_NODELAY
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;string.h&gt;
  31 #include &lt;sys/ioctl.h&gt;
  32 #include &lt;sys/time.h&gt;
  33 
  34 #if defined(__linux__)
  35 #include &lt;arpa/inet.h&gt;
  36 #include &lt;net/route.h&gt;
  37 #include &lt;sys/utsname.h&gt;
  38 #endif
  39 
  40 #if defined(__solaris__)
  41 #include &lt;inet/nd.h&gt;
  42 #include &lt;limits.h&gt;
  43 #include &lt;stropts.h&gt;
  44 #include &lt;sys/filio.h&gt;
  45 #include &lt;sys/sockio.h&gt;
  46 #endif
  47 
  48 #if defined(MACOSX)
  49 #include &lt;sys/sysctl.h&gt;
  50 #endif
  51 
  52 #include &quot;jvm.h&quot;
  53 #include &quot;net_util.h&quot;
  54 
  55 #include &quot;java_net_SocketOptions.h&quot;
  56 #include &quot;java_net_InetAddress.h&quot;
  57 
  58 #if defined(__linux__) &amp;&amp; !defined(IPV6_FLOWINFO_SEND)
  59 #define IPV6_FLOWINFO_SEND      33
  60 #endif
  61 
  62 #if defined(__solaris__) &amp;&amp; !defined(MAXINT)
  63 #define MAXINT INT_MAX
  64 #endif
  65 
  66 /*
  67  * EXCLBIND socket options only on Solaris
  68  */
  69 #if defined(__solaris__) &amp;&amp; !defined(TCP_EXCLBIND)
  70 #define TCP_EXCLBIND            0x21
  71 #endif
  72 #if defined(__solaris__) &amp;&amp; !defined(UDP_EXCLBIND)
  73 #define UDP_EXCLBIND            0x0101
  74 #endif
  75 
  76 void setDefaultScopeID(JNIEnv *env, struct sockaddr *him)
  77 {
  78 #ifdef MACOSX
  79     static jclass ni_class = NULL;
  80     static jfieldID ni_defaultIndexID;
  81     if (ni_class == NULL) {
  82         jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
  83         CHECK_NULL(c);
  84         c = (*env)-&gt;NewGlobalRef(env, c);
  85         CHECK_NULL(c);
  86         ni_defaultIndexID = (*env)-&gt;GetStaticFieldID(env, c, &quot;defaultIndex&quot;, &quot;I&quot;);
  87         CHECK_NULL(ni_defaultIndexID);
  88         ni_class = c;
  89     }
  90     int defaultIndex;
  91     struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)him;
  92     if (sin6-&gt;sin6_family == AF_INET6 &amp;&amp; (sin6-&gt;sin6_scope_id == 0) &amp;&amp;
  93         (IN6_IS_ADDR_LINKLOCAL(&amp;sin6-&gt;sin6_addr) ||
  94          IN6_IS_ADDR_MULTICAST(&amp;sin6-&gt;sin6_addr))) {
  95         defaultIndex = (*env)-&gt;GetStaticIntField(env, ni_class,
  96                                                  ni_defaultIndexID);
  97         sin6-&gt;sin6_scope_id = defaultIndex;
  98     }
  99 #endif
 100 }
 101 
 102 int getDefaultScopeID(JNIEnv *env) {
 103     int defaultIndex = 0;
 104     static jclass ni_class = NULL;
 105     static jfieldID ni_defaultIndexID;
 106     if (ni_class == NULL) {
 107         jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
 108         CHECK_NULL_RETURN(c, 0);
 109         c = (*env)-&gt;NewGlobalRef(env, c);
 110         CHECK_NULL_RETURN(c, 0);
 111         ni_defaultIndexID = (*env)-&gt;GetStaticFieldID(env, c, &quot;defaultIndex&quot;, &quot;I&quot;);
 112         CHECK_NULL_RETURN(ni_defaultIndexID, 0);
 113         ni_class = c;
 114     }
 115     defaultIndex = (*env)-&gt;GetStaticIntField(env, ni_class,
 116                                              ni_defaultIndexID);
 117     return defaultIndex;
 118 }
 119 
 120 #define RESTARTABLE(_cmd, _result) do { \
 121     do { \
 122         _result = _cmd; \
 123     } while((_result == -1) &amp;&amp; (errno == EINTR)); \
 124 } while(0)
 125 
 126 int NET_SocketAvailable(int s, int *pbytes) {
 127     int result;
 128     RESTARTABLE(ioctl(s, FIONREAD, pbytes), result);
 129     return result;
 130 }
 131 
 132 #ifdef __solaris__
 133 static int init_tcp_max_buf, init_udp_max_buf;
 134 static int tcp_max_buf;
 135 static int udp_max_buf;
 136 static int useExclBind = 0;
 137 
 138 /*
 139  * Get the specified parameter from the specified driver. The value
 140  * of the parameter is assumed to be an &#39;int&#39;. If the parameter
 141  * cannot be obtained return -1
 142  */
 143 int net_getParam(char *driver, char *param)
 144 {
 145     struct strioctl stri;
 146     char buf [64];
 147     int s;
 148     int value;
 149 
 150     s = open (driver, O_RDWR);
 151     if (s &lt; 0) {
 152         return -1;
 153     }
 154     strncpy (buf, param, sizeof(buf));
 155     stri.ic_cmd = ND_GET;
 156     stri.ic_timout = 0;
 157     stri.ic_dp = buf;
 158     stri.ic_len = sizeof(buf);
 159     if (ioctl (s, I_STR, &amp;stri) &lt; 0) {
 160         value = -1;
 161     } else {
 162         value = atoi(buf);
 163     }
 164     close (s);
 165     return value;
 166 }
 167 
 168 /*
 169  * Iterative way to find the max value that SO_SNDBUF or SO_RCVBUF
 170  * for Solaris versions that do not support the ioctl() in net_getParam().
 171  * Ugly, but only called once (for each sotype).
 172  *
 173  * As an optimization, we make a guess using the default values for Solaris
 174  * assuming they haven&#39;t been modified with ndd.
 175  */
 176 
 177 #define MAX_TCP_GUESS 1024 * 1024
 178 #define MAX_UDP_GUESS 2 * 1024 * 1024
 179 
 180 #define FAIL_IF_NOT_ENOBUFS if (errno != ENOBUFS) return -1
 181 
 182 static int findMaxBuf(int fd, int opt, int sotype) {
 183     int a = 0;
 184     int b = MAXINT;
 185     int initial_guess;
 186     int limit = -1;
 187 
 188     if (sotype == SOCK_DGRAM) {
 189         initial_guess = MAX_UDP_GUESS;
 190     } else {
 191         initial_guess = MAX_TCP_GUESS;
 192     }
 193 
 194     if (setsockopt(fd, SOL_SOCKET, opt, &amp;initial_guess, sizeof(int)) == 0) {
 195         initial_guess++;
 196         if (setsockopt(fd, SOL_SOCKET, opt, &amp;initial_guess,sizeof(int)) &lt; 0) {
 197             FAIL_IF_NOT_ENOBUFS;
 198             return initial_guess - 1;
 199         }
 200         a = initial_guess;
 201     } else {
 202         FAIL_IF_NOT_ENOBUFS;
 203         b = initial_guess - 1;
 204     }
 205     do {
 206         int mid = a + (b-a)/2;
 207         if (setsockopt(fd, SOL_SOCKET, opt, &amp;mid, sizeof(int)) == 0) {
 208             limit = mid;
 209             a = mid + 1;
 210         } else {
 211             FAIL_IF_NOT_ENOBUFS;
 212             b = mid - 1;
 213         }
 214     } while (b &gt;= a);
 215 
 216     return limit;
 217 }
 218 #endif
 219 
 220 #ifdef __linux__
 221 static int vinit = 0;
 222 static int kernelV24 = 0;
 223 static int vinit24 = 0;
 224 
 225 int kernelIsV24 () {
 226     if (!vinit24) {
 227         struct utsname sysinfo;
 228         if (uname(&amp;sysinfo) == 0) {
 229             sysinfo.release[3] = &#39;\0&#39;;
 230             if (strcmp(sysinfo.release, &quot;2.4&quot;) == 0) {
 231                 kernelV24 = JNI_TRUE;
 232             }
 233         }
 234         vinit24 = 1;
 235     }
 236     return kernelV24;
 237 }
 238 #endif
 239 
 240 void
 241 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
 242                    const char *defaultDetail) {
 243     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
 244 }
 245 
 246 void
 247 NET_ThrowCurrent(JNIEnv *env, char *msg) {
 248     NET_ThrowNew(env, errno, msg);
 249 }
 250 
 251 void
 252 NET_ThrowNew(JNIEnv *env, int errorNumber, char *msg) {
 253     char fullMsg[512];
 254     if (!msg) {
 255         msg = &quot;no further information&quot;;
 256     }
 257     switch(errorNumber) {
 258     case EBADF:
 259         jio_snprintf(fullMsg, sizeof(fullMsg), &quot;socket closed: %s&quot;, msg);
 260         JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, fullMsg);
 261         break;
 262     case EINTR:
 263         JNU_ThrowByName(env, JNU_JAVAIOPKG &quot;InterruptedIOException&quot;, msg);
 264         break;
 265     default:
 266         errno = errorNumber;
 267         JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG &quot;SocketException&quot;, msg);
 268         break;
 269     }
 270 }
 271 
 272 
 273 jfieldID
 274 NET_GetFileDescriptorID(JNIEnv *env)
 275 {
 276     jclass cls = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;);
 277     CHECK_NULL_RETURN(cls, NULL);
 278     return (*env)-&gt;GetFieldID(env, cls, &quot;fd&quot;, &quot;I&quot;);
 279 }
 280 
 281 #if defined(DONT_ENABLE_IPV6)
 282 jint  IPv6_supported()
 283 {
 284     return JNI_FALSE;
 285 }
 286 
 287 #else /* !DONT_ENABLE_IPV6 */
 288 
 289 jint  IPv6_supported()
 290 {
 291     int fd;
 292     void *ipv6_fn;
 293     SOCKETADDRESS sa;
 294     socklen_t sa_len = sizeof(SOCKETADDRESS);
 295 
 296     fd = socket(AF_INET6, SOCK_STREAM, 0) ;
 297     if (fd &lt; 0) {
 298         /*
 299          *  TODO: We really cant tell since it may be an unrelated error
 300          *  for now we will assume that AF_INET6 is not available
 301          */
 302         return JNI_FALSE;
 303     }
 304 
 305     /*
 306      * If fd 0 is a socket it means we may have been launched from inetd or
 307      * xinetd. If it&#39;s a socket then check the family - if it&#39;s an
 308      * IPv4 socket then we need to disable IPv6.
 309      */
 310     if (getsockname(0, &amp;sa.sa, &amp;sa_len) == 0) {
 311         if (sa.sa.sa_family == AF_INET) {
 312             close(fd);
 313             return JNI_FALSE;
 314         }
 315     }
 316 
 317     /**
 318      * Linux - check if any interface has an IPv6 address.
 319      * Don&#39;t need to parse the line - we just need an indication.
 320      */
 321 #ifdef __linux__
 322     {
 323         FILE *fP = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;);
 324         char buf[255];
 325         char *bufP;
 326 
 327         if (fP == NULL) {
 328             close(fd);
 329             return JNI_FALSE;
 330         }
 331         bufP = fgets(buf, sizeof(buf), fP);
 332         fclose(fP);
 333         if (bufP == NULL) {
 334             close(fd);
 335             return JNI_FALSE;
 336         }
 337     }
 338 #endif
 339 
 340     /**
 341      * On Solaris 8 it&#39;s possible to create INET6 sockets even
 342      * though IPv6 is not enabled on all interfaces. Thus we
 343      * query the number of IPv6 addresses to verify that IPv6
 344      * has been configured on at least one interface.
 345      *
 346      * On Linux it doesn&#39;t matter - if IPv6 is built-in the
 347      * kernel then IPv6 addresses will be bound automatically
 348      * to all interfaces.
 349      */
 350 #ifdef __solaris__
 351 
 352 #ifdef SIOCGLIFNUM
 353     {
 354         struct lifnum numifs;
 355 
 356         numifs.lifn_family = AF_INET6;
 357         numifs.lifn_flags = 0;
 358         if (ioctl(fd, SIOCGLIFNUM, (char *)&amp;numifs) &lt; 0) {
 359             /**
 360              * SIOCGLIFNUM failed - assume IPv6 not configured
 361              */
 362             close(fd);
 363             return JNI_FALSE;
 364         }
 365         /**
 366          * If no IPv6 addresses then return false. If count &gt; 0
 367          * it&#39;s possible that all IPv6 addresses are &quot;down&quot; but
 368          * that&#39;s okay as they may be brought &quot;up&quot; while the
 369          * VM is running.
 370          */
 371         if (numifs.lifn_count == 0) {
 372             close(fd);
 373             return JNI_FALSE;
 374         }
 375     }
 376 #else
 377     /* SIOCGLIFNUM not defined in build environment ??? */
 378     close(fd);
 379     return JNI_FALSE;
 380 #endif
 381 
 382 #endif /* __solaris */
 383 
 384     /*
 385      *  OK we may have the stack available in the kernel,
 386      *  we should also check if the APIs are available.
 387      */
 388     ipv6_fn = JVM_FindLibraryEntry(RTLD_DEFAULT, &quot;inet_pton&quot;);
 389     close(fd);
 390     if (ipv6_fn == NULL ) {
 391         return JNI_FALSE;
 392     } else {
 393         return JNI_TRUE;
 394     }
 395 }
 396 #endif /* DONT_ENABLE_IPV6 */
 397 
 398 jint reuseport_supported()
 399 {
 400     /* Do a simple dummy call, and try to figure out from that */
 401     int one = 1;
 402     int rv, s;
 403     s = socket(PF_INET, SOCK_STREAM, 0);
 404     if (s &lt; 0) {
 405         return JNI_FALSE;
 406     }
 407     rv = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, (void *)&amp;one, sizeof(one));
 408     if (rv != 0) {
 409         rv = JNI_FALSE;
 410     } else {
 411         rv = JNI_TRUE;
 412     }
 413     close(s);
 414     return rv;
 415 }
 416 
 417 void NET_ThrowUnknownHostExceptionWithGaiError(JNIEnv *env,
 418                                                const char* hostname,
 419                                                int gai_error)
 420 {
 421     int size;
 422     char *buf;
 423     const char *format = &quot;%s: %s&quot;;
 424     const char *error_string = gai_strerror(gai_error);
 425     if (error_string == NULL)
 426         error_string = &quot;unknown error&quot;;
 427 
 428     size = strlen(format) + strlen(hostname) + strlen(error_string) + 2;
 429     buf = (char *) malloc(size);
 430     if (buf) {
 431         jstring s;
 432         sprintf(buf, format, hostname, error_string);
 433         s = JNU_NewStringPlatform(env, buf);
 434         if (s != NULL) {
 435             jobject x = JNU_NewObjectByName(env,
 436                                             &quot;java/net/UnknownHostException&quot;,
 437                                             &quot;(Ljava/lang/String;)V&quot;, s);
 438             if (x != NULL)
 439                 (*env)-&gt;Throw(env, x);
 440         }
 441         free(buf);
 442     }
 443 }
 444 
 445 #if defined(__linux__)
 446 
 447 /* following code creates a list of addresses from the kernel
 448  * routing table that are routed via the loopback address.
 449  * We check all destination addresses against this table
 450  * and override the scope_id field to use the relevant value for &quot;lo&quot;
 451  * in order to work-around the Linux bug that prevents packets destined
 452  * for certain local addresses from being sent via a physical interface.
 453  */
 454 
 455 struct loopback_route {
 456     struct in6_addr addr; /* destination address */
 457     int plen; /* prefix length */
 458 };
 459 
 460 static struct loopback_route *loRoutes = 0;
 461 static int nRoutes = 0; /* number of routes */
 462 static int loRoutes_size = 16; /* initial size */
 463 static int lo_scope_id = 0;
 464 
 465 static void initLoopbackRoutes();
 466 
 467 void printAddr (struct in6_addr *addr) {
 468     int i;
 469     for (i=0; i&lt;16; i++) {
 470         printf (&quot;%02x&quot;, addr-&gt;s6_addr[i]);
 471     }
 472     printf (&quot;\n&quot;);
 473 }
 474 
 475 static jboolean needsLoopbackRoute (struct in6_addr* dest_addr) {
 476     int byte_count;
 477     int extra_bits, i;
 478     struct loopback_route *ptr;
 479 
 480     if (loRoutes == 0) {
 481         initLoopbackRoutes();
 482     }
 483 
 484     for (ptr = loRoutes, i=0; i&lt;nRoutes; i++, ptr++) {
 485         struct in6_addr *target_addr=&amp;ptr-&gt;addr;
 486         int dest_plen = ptr-&gt;plen;
 487         byte_count = dest_plen &gt;&gt; 3;
 488         extra_bits = dest_plen &amp; 0x3;
 489 
 490         if (byte_count &gt; 0) {
 491             if (memcmp(target_addr, dest_addr, byte_count)) {
 492                 continue;  /* no match */
 493             }
 494         }
 495 
 496         if (extra_bits &gt; 0) {
 497             unsigned char c1 = ((unsigned char *)target_addr)[byte_count];
 498             unsigned char c2 = ((unsigned char *)&amp;dest_addr)[byte_count];
 499             unsigned char mask = 0xff &lt;&lt; (8 - extra_bits);
 500             if ((c1 &amp; mask) != (c2 &amp; mask)) {
 501                 continue;
 502             }
 503         }
 504         return JNI_TRUE;
 505     }
 506     return JNI_FALSE;
 507 }
 508 
 509 
 510 static void initLoopbackRoutes() {
 511     FILE *f;
 512     char srcp[8][5];
 513     char hopp[8][5];
 514     int dest_plen, src_plen, use, refcnt, metric;
 515     unsigned long flags;
 516     char dest_str[40];
 517     struct in6_addr dest_addr;
 518     char device[16];
 519     struct loopback_route *loRoutesTemp;
 520 
 521     if (loRoutes != 0) {
 522         free (loRoutes);
 523     }
 524     loRoutes = calloc (loRoutes_size, sizeof(struct loopback_route));
 525     if (loRoutes == 0) {
 526         return;
 527     }
 528     /*
 529      * Scan /proc/net/ipv6_route looking for a matching
 530      * route.
 531      */
 532     if ((f = fopen(&quot;/proc/net/ipv6_route&quot;, &quot;r&quot;)) == NULL) {
 533         return ;
 534     }
 535     while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %02x &quot;
 536                      &quot;%4s%4s%4s%4s%4s%4s%4s%4s %02x &quot;
 537                      &quot;%4s%4s%4s%4s%4s%4s%4s%4s &quot;
 538                      &quot;%08x %08x %08x %08lx %8s&quot;,
 539                      dest_str, &amp;dest_str[5], &amp;dest_str[10], &amp;dest_str[15],
 540                      &amp;dest_str[20], &amp;dest_str[25], &amp;dest_str[30], &amp;dest_str[35],
 541                      &amp;dest_plen,
 542                      srcp[0], srcp[1], srcp[2], srcp[3],
 543                      srcp[4], srcp[5], srcp[6], srcp[7],
 544                      &amp;src_plen,
 545                      hopp[0], hopp[1], hopp[2], hopp[3],
 546                      hopp[4], hopp[5], hopp[6], hopp[7],
 547                      &amp;metric, &amp;use, &amp;refcnt, &amp;flags, device) == 31) {
 548 
 549         /*
 550          * Some routes should be ignored
 551          */
 552         if ( (dest_plen &lt; 0 || dest_plen &gt; 128)  ||
 553              (src_plen != 0) ||
 554              (flags &amp; (RTF_POLICY | RTF_FLOW)) ||
 555              ((flags &amp; RTF_REJECT) &amp;&amp; dest_plen == 0) ) {
 556             continue;
 557         }
 558 
 559         /*
 560          * Convert the destination address
 561          */
 562         dest_str[4] = &#39;:&#39;;
 563         dest_str[9] = &#39;:&#39;;
 564         dest_str[14] = &#39;:&#39;;
 565         dest_str[19] = &#39;:&#39;;
 566         dest_str[24] = &#39;:&#39;;
 567         dest_str[29] = &#39;:&#39;;
 568         dest_str[34] = &#39;:&#39;;
 569         dest_str[39] = &#39;\0&#39;;
 570 
 571         if (inet_pton(AF_INET6, dest_str, &amp;dest_addr) &lt; 0) {
 572             /* not an Ipv6 address */
 573             continue;
 574         }
 575         if (strcmp(device, &quot;lo&quot;) != 0) {
 576             /* Not a loopback route */
 577             continue;
 578         } else {
 579             if (nRoutes == loRoutes_size) {
 580                 loRoutesTemp = realloc (loRoutes, loRoutes_size *
 581                                         sizeof (struct loopback_route) * 2);
 582 
 583                 if (loRoutesTemp == 0) {
 584                     free(loRoutes);
 585                     loRoutes = NULL;
 586                     nRoutes = 0;
 587                     fclose (f);
 588                     return;
 589                 }
 590                 loRoutes=loRoutesTemp;
 591                 loRoutes_size *= 2;
 592             }
 593             memcpy (&amp;loRoutes[nRoutes].addr,&amp;dest_addr,sizeof(struct in6_addr));
 594             loRoutes[nRoutes].plen = dest_plen;
 595             nRoutes ++;
 596         }
 597     }
 598 
 599     fclose (f);
 600     {
 601         /* now find the scope_id for &quot;lo&quot; */
 602 
 603         char devname[21];
 604         char addr6p[8][5];
 605         int plen, scope, dad_status, if_idx;
 606 
 607         if ((f = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;)) != NULL) {
 608             while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\n&quot;,
 609                       addr6p[0], addr6p[1], addr6p[2], addr6p[3],
 610                       addr6p[4], addr6p[5], addr6p[6], addr6p[7],
 611                   &amp;if_idx, &amp;plen, &amp;scope, &amp;dad_status, devname) == 13) {
 612 
 613                 if (strcmp(devname, &quot;lo&quot;) == 0) {
 614                     /*
 615                      * Found - so just return the index
 616                      */
 617                     fclose(f);
 618                     lo_scope_id = if_idx;
 619                     return;
 620                 }
 621             }
 622             fclose(f);
 623         }
 624     }
 625 }
 626 
 627 /*
 628  * Following is used for binding to local addresses. Equivalent
 629  * to code above, for bind().
 630  */
 631 
 632 struct localinterface {
 633     int index;
 634     char localaddr [16];
 635 };
 636 
 637 static struct localinterface *localifs = 0;
 638 static int localifsSize = 0;    /* size of array */
 639 static int nifs = 0;            /* number of entries used in array */
 640 
 641 /* not thread safe: make sure called once from one thread */
 642 
 643 static void initLocalIfs () {
 644     FILE *f;
 645     unsigned char staddr [16];
 646     char ifname [33];
 647     struct localinterface *lif=0;
 648     struct localinterface *localifsTemp;
 649     int index, x1, x2, x3;
 650     unsigned int u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,ua,ub,uc,ud,ue,uf;
 651 
 652     if ((f = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;)) == NULL) {
 653         return ;
 654     }
 655     while (fscanf (f, &quot;%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x &quot;
 656                 &quot;%d %x %x %x %32s&quot;,&amp;u0,&amp;u1,&amp;u2,&amp;u3,&amp;u4,&amp;u5,&amp;u6,&amp;u7,
 657                 &amp;u8,&amp;u9,&amp;ua,&amp;ub,&amp;uc,&amp;ud,&amp;ue,&amp;uf,
 658                 &amp;index, &amp;x1, &amp;x2, &amp;x3, ifname) == 21) {
 659         staddr[0] = (unsigned char)u0;
 660         staddr[1] = (unsigned char)u1;
 661         staddr[2] = (unsigned char)u2;
 662         staddr[3] = (unsigned char)u3;
 663         staddr[4] = (unsigned char)u4;
 664         staddr[5] = (unsigned char)u5;
 665         staddr[6] = (unsigned char)u6;
 666         staddr[7] = (unsigned char)u7;
 667         staddr[8] = (unsigned char)u8;
 668         staddr[9] = (unsigned char)u9;
 669         staddr[10] = (unsigned char)ua;
 670         staddr[11] = (unsigned char)ub;
 671         staddr[12] = (unsigned char)uc;
 672         staddr[13] = (unsigned char)ud;
 673         staddr[14] = (unsigned char)ue;
 674         staddr[15] = (unsigned char)uf;
 675         nifs ++;
 676         if (nifs &gt; localifsSize) {
 677             localifsTemp = (struct localinterface *) realloc(
 678                         localifs, sizeof (struct localinterface)* (localifsSize+5));
 679             if (localifsTemp == 0) {
 680                 free(localifs);
 681                 localifs = 0;
 682                 localifsSize = 0;
 683                 nifs = 0;
 684                 fclose(f);
 685                 return;
 686             }
 687             localifs = localifsTemp;
 688             lif = localifs + localifsSize;
 689             localifsSize += 5;
 690         } else {
 691             lif ++;
 692         }
 693         memcpy (lif-&gt;localaddr, staddr, 16);
 694         lif-&gt;index = index;
 695     }
 696     fclose (f);
 697 }
 698 
 699 /* return the scope_id (interface index) of the
 700  * interface corresponding to the given address
 701  * returns 0 if no match found
 702  */
 703 
 704 static int getLocalScopeID (char *addr) {
 705     struct localinterface *lif;
 706     int i;
 707     if (localifs == 0) {
 708         initLocalIfs();
 709     }
 710     for (i=0, lif=localifs; i&lt;nifs; i++, lif++) {
 711         if (memcmp (addr, lif-&gt;localaddr, 16) == 0) {
 712             return lif-&gt;index;
 713         }
 714     }
 715     return 0;
 716 }
 717 
 718 void platformInit () {
 719     initLoopbackRoutes();
 720     initLocalIfs();
 721 }
 722 
 723 #elif defined(_AIX)
 724 
 725 /* Initialize stubs for blocking I/O workarounds (see src/solaris/native/java/net/linux_close.c) */
 726 extern void aix_close_init();
 727 
 728 void platformInit () {
 729     aix_close_init();
 730 }
 731 
 732 #else
 733 
 734 void platformInit () {}
 735 
 736 #endif
 737 
 738 void parseExclusiveBindProperty(JNIEnv *env) {
 739 #ifdef __solaris__
 740     jstring s, flagSet;
 741     jclass iCls;
 742     jmethodID mid;
 743 
 744     s = (*env)-&gt;NewStringUTF(env, &quot;sun.net.useExclusiveBind&quot;);
 745     CHECK_NULL(s);
 746     iCls = (*env)-&gt;FindClass(env, &quot;java/lang/System&quot;);
 747     CHECK_NULL(iCls);
 748     mid = (*env)-&gt;GetStaticMethodID(env, iCls, &quot;getProperty&quot;,
 749                 &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);
 750     CHECK_NULL(mid);
 751     flagSet = (*env)-&gt;CallStaticObjectMethod(env, iCls, mid, s);
 752     if (flagSet != NULL) {
 753         useExclBind = 1;
 754     }
 755 #endif
 756 }
 757 
 758 JNIEXPORT jint JNICALL
 759 NET_EnableFastTcpLoopback(int fd) {
 760     return 0;
 761 }
 762 
 763 /**
 764  * See net_util.h for documentation
 765  */
 766 JNIEXPORT int JNICALL
 767 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port,
 768                           SOCKETADDRESS *sa, int *len,
 769                           jboolean v4MappedAddress)
 770 {
 771     jint family = getInetAddress_family(env, iaObj);
 772     JNU_CHECK_EXCEPTION_RETURN(env, -1);
 773     memset((char *)sa, 0, sizeof(SOCKETADDRESS));
 774 
 775     if (ipv6_available() &amp;&amp;
 776         !(family == java_net_InetAddress_IPv4 &amp;&amp;
 777           v4MappedAddress == JNI_FALSE))
 778     {
 779         jbyte caddr[16];
 780         jint address;
 781 
 782         if (family == java_net_InetAddress_IPv4) {
 783             // convert to IPv4-mapped address
 784             memset((char *)caddr, 0, 16);
 785             address = getInetAddress_addr(env, iaObj);
 786             JNU_CHECK_EXCEPTION_RETURN(env, -1);
 787             if (address == INADDR_ANY) {
 788                 /* we would always prefer IPv6 wildcard address
 789                  * caddr[10] = 0xff;
 790                  * caddr[11] = 0xff; */
 791             } else {
 792                 caddr[10] = 0xff;
 793                 caddr[11] = 0xff;
 794                 caddr[12] = ((address &gt;&gt; 24) &amp; 0xff);
 795                 caddr[13] = ((address &gt;&gt; 16) &amp; 0xff);
 796                 caddr[14] = ((address &gt;&gt; 8) &amp; 0xff);
 797                 caddr[15] = (address &amp; 0xff);
 798             }
 799         } else {
 800             getInet6Address_ipaddress(env, iaObj, (char *)caddr);
 801         }
 802         sa-&gt;sa6.sin6_port = htons(port);
 803         memcpy((void *)&amp;sa-&gt;sa6.sin6_addr, caddr, sizeof(struct in6_addr));
 804         sa-&gt;sa6.sin6_family = AF_INET6;
 805         if (len != NULL) {
 806             *len = sizeof(struct sockaddr_in6);
 807         }
 808 
 809 #ifdef __linux__
 810         /*
 811          * On Linux if we are connecting to a link-local address
 812          * we need to specify the interface in the scope_id (2.4 kernel only)
 813          *
 814          * If the scope was cached then we use the cached value. If not cached but
 815          * specified in the Inet6Address we use that, but we first check if the
 816          * address needs to be routed via the loopback interface. In this case,
 817          * we override the specified value with that of the loopback interface.
 818          * If no cached value exists and no value was specified by user, then
 819          * we try to determine a value from the routing table. In all these
 820          * cases the used value is cached for further use.
 821          */
 822         if (IN6_IS_ADDR_LINKLOCAL(&amp;sa-&gt;sa6.sin6_addr)) {
 823             unsigned int cached_scope_id = 0, scope_id = 0;
 824 
 825             if (ia6_cachedscopeidID) {
 826                 cached_scope_id = (int)(*env)-&gt;GetIntField(env, iaObj, ia6_cachedscopeidID);
 827                 /* if cached value exists then use it. Otherwise, check
 828                  * if scope is set in the address.
 829                  */
 830                 if (!cached_scope_id) {
 831                     if (ia6_scopeidID) {
 832                         scope_id = getInet6Address_scopeid(env, iaObj);
 833                     }
 834                     if (scope_id != 0) {
 835                         /* check user-specified value for loopback case
 836                          * that needs to be overridden
 837                          */
 838                         if (kernelIsV24() &amp;&amp; needsLoopbackRoute(&amp;sa-&gt;sa6.sin6_addr)) {
 839                             cached_scope_id = lo_scope_id;
 840                             (*env)-&gt;SetIntField(env, iaObj, ia6_cachedscopeidID, cached_scope_id);
 841                         }
 842                     } else {
 843                         /*
 844                          * Otherwise consult the IPv6 routing tables to
 845                          * try determine the appropriate interface.
 846                          */
 847                         if (kernelIsV24()) {
 848                             cached_scope_id = getDefaultIPv6Interface(&amp;sa-&gt;sa6.sin6_addr);
 849                         } else {
 850                             cached_scope_id = getLocalScopeID((char *)&amp;(sa-&gt;sa6.sin6_addr));
 851                             if (cached_scope_id == 0) {
 852                                 cached_scope_id = getDefaultIPv6Interface(&amp;sa-&gt;sa6.sin6_addr);
 853                             }
 854                         }
 855                         (*env)-&gt;SetIntField(env, iaObj, ia6_cachedscopeidID, cached_scope_id);
 856                     }
 857                 }
 858             }
 859 
 860             /*
 861              * If we have a scope_id use the extended form
 862              * of sockaddr_in6.
 863              */
 864             sa-&gt;sa6.sin6_scope_id = cached_scope_id == 0 ? scope_id : cached_scope_id;
 865         }
 866 #else
 867         /* handle scope_id */
 868         if (family != java_net_InetAddress_IPv4) {
 869             if (ia6_scopeidID) {
 870                 sa-&gt;sa6.sin6_scope_id = getInet6Address_scopeid(env, iaObj);
 871             }
 872         }
 873 #endif
 874     } else {
 875         jint address;
 876         if (family != java_net_InetAddress_IPv4) {
 877             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Protocol family unavailable&quot;);
 878             return -1;
 879         }
 880         address = getInetAddress_addr(env, iaObj);
 881         JNU_CHECK_EXCEPTION_RETURN(env, -1);
 882         sa-&gt;sa4.sin_port = htons(port);
 883         sa-&gt;sa4.sin_addr.s_addr = htonl(address);
 884         sa-&gt;sa4.sin_family = AF_INET;
 885         if (len != NULL) {
 886             *len = sizeof(struct sockaddr_in);
 887         }
 888     }
 889     return 0;
 890 }
 891 
 892 void
 893 NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass) {
 894     if (sa-&gt;sa.sa_family == AF_INET6) {
 895         sa-&gt;sa6.sin6_flowinfo = htonl((trafficClass &amp; 0xff) &lt;&lt; 20);
 896     }
 897 }
 898 
 899 int
 900 NET_IsIPv4Mapped(jbyte* caddr) {
 901     int i;
 902     for (i = 0; i &lt; 10; i++) {
 903         if (caddr[i] != 0x00) {
 904             return 0; /* false */
 905         }
 906     }
 907 
 908     if (((caddr[10] &amp; 0xff) == 0xff) &amp;&amp; ((caddr[11] &amp; 0xff) == 0xff)) {
 909         return 1; /* true */
 910     }
 911     return 0; /* false */
 912 }
 913 
 914 int
 915 NET_IPv4MappedToIPv4(jbyte* caddr) {
 916     return ((caddr[12] &amp; 0xff) &lt;&lt; 24) | ((caddr[13] &amp; 0xff) &lt;&lt; 16) | ((caddr[14] &amp; 0xff) &lt;&lt; 8)
 917         | (caddr[15] &amp; 0xff);
 918 }
 919 
 920 int
 921 NET_IsEqual(jbyte* caddr1, jbyte* caddr2) {
 922     int i;
 923     for (i = 0; i &lt; 16; i++) {
 924         if (caddr1[i] != caddr2[i]) {
 925             return 0; /* false */
 926         }
 927     }
 928     return 1;
 929 }
 930 
 931 int NET_IsZeroAddr(jbyte* caddr) {
 932     int i;
 933     for (i = 0; i &lt; 16; i++) {
 934         if (caddr[i] != 0) {
 935             return 0;
 936         }
 937     }
 938     return 1;
 939 }
 940 
 941 /*
 942  * Map the Java level socket option to the platform specific
 943  * level and option name.
 944  */
 945 int
 946 NET_MapSocketOption(jint cmd, int *level, int *optname) {
 947     static struct {
 948         jint cmd;
 949         int level;
 950         int optname;
 951     } const opts[] = {
 952         { java_net_SocketOptions_TCP_NODELAY,           IPPROTO_TCP,    TCP_NODELAY },
 953         { java_net_SocketOptions_SO_OOBINLINE,          SOL_SOCKET,     SO_OOBINLINE },
 954         { java_net_SocketOptions_SO_LINGER,             SOL_SOCKET,     SO_LINGER },
 955         { java_net_SocketOptions_SO_SNDBUF,             SOL_SOCKET,     SO_SNDBUF },
 956         { java_net_SocketOptions_SO_RCVBUF,             SOL_SOCKET,     SO_RCVBUF },
 957         { java_net_SocketOptions_SO_KEEPALIVE,          SOL_SOCKET,     SO_KEEPALIVE },
 958         { java_net_SocketOptions_SO_REUSEADDR,          SOL_SOCKET,     SO_REUSEADDR },
 959         { java_net_SocketOptions_SO_REUSEPORT,          SOL_SOCKET,     SO_REUSEPORT },
 960         { java_net_SocketOptions_SO_BROADCAST,          SOL_SOCKET,     SO_BROADCAST },
 961         { java_net_SocketOptions_IP_TOS,                IPPROTO_IP,     IP_TOS },
 962         { java_net_SocketOptions_IP_MULTICAST_IF,       IPPROTO_IP,     IP_MULTICAST_IF },
 963         { java_net_SocketOptions_IP_MULTICAST_IF2,      IPPROTO_IP,     IP_MULTICAST_IF },
 964         { java_net_SocketOptions_IP_MULTICAST_LOOP,     IPPROTO_IP,     IP_MULTICAST_LOOP },
 965     };
 966 
 967     int i;
 968 
 969     if (ipv6_available()) {
 970         switch (cmd) {
 971             // Different multicast options if IPv6 is enabled
 972             case java_net_SocketOptions_IP_MULTICAST_IF:
 973             case java_net_SocketOptions_IP_MULTICAST_IF2:
 974                 *level = IPPROTO_IPV6;
 975                 *optname = IPV6_MULTICAST_IF;
 976                 return 0;
 977 
 978             case java_net_SocketOptions_IP_MULTICAST_LOOP:
 979                 *level = IPPROTO_IPV6;
 980                 *optname = IPV6_MULTICAST_LOOP;
 981                 return 0;
 982 #if (defined(__solaris__) || defined(MACOSX))
 983             // Map IP_TOS request to IPV6_TCLASS
 984             case java_net_SocketOptions_IP_TOS:
 985                 *level = IPPROTO_IPV6;
 986                 *optname = IPV6_TCLASS;
 987                 return 0;
 988 #endif
 989         }
 990     }
 991 
 992     /*
 993      * Map the Java level option to the native level
 994      */
 995     for (i=0; i&lt;(int)(sizeof(opts) / sizeof(opts[0])); i++) {
 996         if (cmd == opts[i].cmd) {
 997             *level = opts[i].level;
 998             *optname = opts[i].optname;
 999             return 0;
1000         }
1001     }
1002 
1003     /* not found */
1004     return -1;
1005 }
1006 
1007 /*
1008  * Determine the default interface for an IPv6 address.
1009  *
1010  * 1. Scans /proc/net/ipv6_route for a matching route
1011  *    (eg: fe80::/10 or a route for the specific address).
1012  *    This will tell us the interface to use (eg: &quot;eth0&quot;).
1013  *
1014  * 2. Lookup /proc/net/if_inet6 to map the interface
1015  *    name to an interface index.
1016  *
1017  * Returns :-
1018  *      -1 if error
1019  *       0 if no matching interface
1020  *      &gt;1 interface index to use for the link-local address.
1021  */
1022 #if defined(__linux__)
1023 int getDefaultIPv6Interface(struct in6_addr *target_addr) {
1024     FILE *f;
1025     char srcp[8][5];
1026     char hopp[8][5];
1027     int dest_plen, src_plen, use, refcnt, metric;
1028     unsigned long flags;
1029     char dest_str[40];
1030     struct in6_addr dest_addr;
1031     char device[16];
1032     jboolean match = JNI_FALSE;
1033 
1034     /*
1035      * Scan /proc/net/ipv6_route looking for a matching
1036      * route.
1037      */
1038     if ((f = fopen(&quot;/proc/net/ipv6_route&quot;, &quot;r&quot;)) == NULL) {
1039         return -1;
1040     }
1041     while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %02x &quot;
1042                      &quot;%4s%4s%4s%4s%4s%4s%4s%4s %02x &quot;
1043                      &quot;%4s%4s%4s%4s%4s%4s%4s%4s &quot;
1044                      &quot;%08x %08x %08x %08lx %8s&quot;,
1045                      dest_str, &amp;dest_str[5], &amp;dest_str[10], &amp;dest_str[15],
1046                      &amp;dest_str[20], &amp;dest_str[25], &amp;dest_str[30], &amp;dest_str[35],
1047                      &amp;dest_plen,
1048                      srcp[0], srcp[1], srcp[2], srcp[3],
1049                      srcp[4], srcp[5], srcp[6], srcp[7],
1050                      &amp;src_plen,
1051                      hopp[0], hopp[1], hopp[2], hopp[3],
1052                      hopp[4], hopp[5], hopp[6], hopp[7],
1053                      &amp;metric, &amp;use, &amp;refcnt, &amp;flags, device) == 31) {
1054 
1055         /*
1056          * Some routes should be ignored
1057          */
1058         if ( (dest_plen &lt; 0 || dest_plen &gt; 128)  ||
1059              (src_plen != 0) ||
1060              (flags &amp; (RTF_POLICY | RTF_FLOW)) ||
1061              ((flags &amp; RTF_REJECT) &amp;&amp; dest_plen == 0) ) {
1062             continue;
1063         }
1064 
1065         /*
1066          * Convert the destination address
1067          */
1068         dest_str[4] = &#39;:&#39;;
1069         dest_str[9] = &#39;:&#39;;
1070         dest_str[14] = &#39;:&#39;;
1071         dest_str[19] = &#39;:&#39;;
1072         dest_str[24] = &#39;:&#39;;
1073         dest_str[29] = &#39;:&#39;;
1074         dest_str[34] = &#39;:&#39;;
1075         dest_str[39] = &#39;\0&#39;;
1076 
1077         if (inet_pton(AF_INET6, dest_str, &amp;dest_addr) &lt; 0) {
1078             /* not an Ipv6 address */
1079             continue;
1080         } else {
1081             /*
1082              * The prefix len (dest_plen) indicates the number of bits we
1083              * need to match on.
1084              *
1085              * dest_plen / 8    =&gt; number of bytes to match
1086              * dest_plen % 8    =&gt; number of additional bits to match
1087              *
1088              * eg: fe80::/10 =&gt; match 1 byte + 2 additional bits in the
1089              *                  next byte.
1090              */
1091             int byte_count = dest_plen &gt;&gt; 3;
1092             int extra_bits = dest_plen &amp; 0x3;
1093 
1094             if (byte_count &gt; 0) {
1095                 if (memcmp(target_addr, &amp;dest_addr, byte_count)) {
1096                     continue;  /* no match */
1097                 }
1098             }
1099 
1100             if (extra_bits &gt; 0) {
1101                 unsigned char c1 = ((unsigned char *)target_addr)[byte_count];
1102                 unsigned char c2 = ((unsigned char *)&amp;dest_addr)[byte_count];
1103                 unsigned char mask = 0xff &lt;&lt; (8 - extra_bits);
1104                 if ((c1 &amp; mask) != (c2 &amp; mask)) {
1105                     continue;
1106                 }
1107             }
1108 
1109             /*
1110              * We have a match
1111              */
1112             match = JNI_TRUE;
1113             break;
1114         }
1115     }
1116     fclose(f);
1117 
1118     /*
1119      * If there&#39;s a match then we lookup the interface
1120      * index.
1121      */
1122     if (match) {
1123         char devname[21];
1124         char addr6p[8][5];
1125         int plen, scope, dad_status, if_idx;
1126 
1127         if ((f = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;)) != NULL) {
1128             while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\n&quot;,
1129                       addr6p[0], addr6p[1], addr6p[2], addr6p[3],
1130                       addr6p[4], addr6p[5], addr6p[6], addr6p[7],
1131                   &amp;if_idx, &amp;plen, &amp;scope, &amp;dad_status, devname) == 13) {
1132 
1133                 if (strcmp(devname, device) == 0) {
1134                     /*
1135                      * Found - so just return the index
1136                      */
1137                     fclose(f);
1138                     return if_idx;
1139                 }
1140             }
1141             fclose(f);
1142         } else {
1143             /*
1144              * Couldn&#39;t open /proc/net/if_inet6
1145              */
1146             return -1;
1147         }
1148     }
1149 
1150     /*
1151      * If we get here it means we didn&#39;t there wasn&#39;t any
1152      * route or we couldn&#39;t get the index of the interface.
1153      */
1154     return 0;
1155 }
1156 #endif
1157 
1158 
1159 /*
1160  * Wrapper for getsockopt system routine - does any necessary
1161  * pre/post processing to deal with OS specific oddities :-
1162  *
1163  * On Linux the SO_SNDBUF/SO_RCVBUF values must be post-processed
1164  * to compensate for an incorrect value returned by the kernel.
1165  */
1166 int
1167 NET_GetSockOpt(int fd, int level, int opt, void *result,
1168                int *len)
1169 {
1170     int rv;
1171     socklen_t socklen = *len;
1172 
1173     rv = getsockopt(fd, level, opt, result, &amp;socklen);
1174     *len = socklen;
1175 
1176     if (rv &lt; 0) {
1177         return rv;
1178     }
1179 
1180 #ifdef __linux__
1181     /*
1182      * On Linux SO_SNDBUF/SO_RCVBUF aren&#39;t symmetric. This
1183      * stems from additional socket structures in the send
1184      * and receive buffers.
1185      */
1186     if ((level == SOL_SOCKET) &amp;&amp; ((opt == SO_SNDBUF)
1187                                   || (opt == SO_RCVBUF))) {
1188         int n = *((int *)result);
1189         n /= 2;
1190         *((int *)result) = n;
1191     }
1192 #endif
1193 
1194 /* Workaround for Mac OS treating linger value as
1195  *  signed integer
1196  */
1197 #ifdef MACOSX
1198     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
1199         struct linger* to_cast = (struct linger*)result;
1200         to_cast-&gt;l_linger = (unsigned short)to_cast-&gt;l_linger;
1201     }
1202 #endif
1203     return rv;
1204 }
1205 
1206 /*
1207  * Wrapper for setsockopt system routine - performs any
1208  * necessary pre/post processing to deal with OS specific
1209  * issue :-
1210  *
1211  * On Solaris need to limit the suggested value for SO_SNDBUF
1212  * and SO_RCVBUF to the kernel configured limit
1213  *
1214  * For IP_TOS socket option need to mask off bits as this
1215  * aren&#39;t automatically masked by the kernel and results in
1216  * an error.
1217  */
1218 int
1219 NET_SetSockOpt(int fd, int level, int  opt, const void *arg,
1220                int len)
1221 {
1222 
1223 #ifndef IPTOS_TOS_MASK
1224 #define IPTOS_TOS_MASK 0x1e
1225 #endif
1226 #ifndef IPTOS_PREC_MASK
1227 #define IPTOS_PREC_MASK 0xe0
1228 #endif
1229 
1230 #if defined(_ALLBSD_SOURCE)
1231 #if defined(KIPC_MAXSOCKBUF)
1232     int mib[3];
1233     size_t rlen;
1234 #endif
1235 
1236     int *bufsize;
1237 
1238 #ifdef __APPLE__
1239     static int maxsockbuf = -1;
1240 #else
1241     static long maxsockbuf = -1;
1242 #endif
1243 #endif
1244 
1245     /*
1246      * IPPROTO/IP_TOS :-
1247      * 1. IPv6 on Solaris/Mac OS:
1248      *    Set the TOS OR Traffic Class value to cater for
1249      *    IPv6 and IPv4 scenarios.
1250      * 2. IPv6 on Linux: By default Linux ignores flowinfo
1251      *    field so enable IPV6_FLOWINFO_SEND so that flowinfo
1252      *    will be examined. We also set the IPv4 TOS option in this case.
1253      * 3. IPv4: set socket option based on ToS and Precedence
1254      *    fields (otherwise get invalid argument)
1255      */
1256     if (level == IPPROTO_IP &amp;&amp; opt == IP_TOS) {
1257         int *iptos;
1258 
1259 #if defined(__linux__)
1260         if (ipv6_available()) {
1261             int optval = 1;
1262             if (setsockopt(fd, IPPROTO_IPV6, IPV6_FLOWINFO_SEND,
1263                            (void *)&amp;optval, sizeof(optval)) &lt; 0) {
1264                 return -1;
1265             }
1266            /*
1267             * Let&#39;s also set the IPV6_TCLASS flag.
1268             * Linux appears to allow both IP_TOS and IPV6_TCLASS to be set
1269             * This helps in mixed environments where IPv4 and IPv6 sockets
1270             * are connecting.
1271             */
1272            if (setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS,
1273                            arg, len) &lt; 0) {
1274                 return -1;
1275             }
1276         }
1277 #endif
1278 
1279         iptos = (int *)arg;
1280         *iptos &amp;= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
1281     }
1282 
1283     /*
1284      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On Solaris we may need to clamp
1285      * the value when it exceeds the system limit.
1286      */
1287 #ifdef __solaris__
1288     if (level == SOL_SOCKET) {
1289         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
1290             int sotype=0;
1291             socklen_t arglen;
1292             int *bufsize, maxbuf;
1293             int ret;
1294 
1295             /* Attempt with the original size */
1296             ret = setsockopt(fd, level, opt, arg, len);
1297             if ((ret == 0) || (ret == -1 &amp;&amp; errno != ENOBUFS))
1298                 return ret;
1299 
1300             /* Exceeded system limit so clamp and retry */
1301 
1302             arglen = sizeof(sotype);
1303             if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype,
1304                            &amp;arglen) &lt; 0) {
1305                 return -1;
1306             }
1307 
1308             /*
1309              * We try to get tcp_maxbuf (and udp_max_buf) using
1310              * an ioctl() that isn&#39;t available on all versions of Solaris.
1311              * If that fails, we use the search algorithm in findMaxBuf()
1312              */
1313             if (!init_tcp_max_buf &amp;&amp; sotype == SOCK_STREAM) {
1314                 tcp_max_buf = net_getParam(&quot;/dev/tcp&quot;, &quot;tcp_max_buf&quot;);
1315                 if (tcp_max_buf == -1) {
1316                     tcp_max_buf = findMaxBuf(fd, opt, SOCK_STREAM);
1317                     if (tcp_max_buf == -1) {
1318                         return -1;
1319                     }
1320                 }
1321                 init_tcp_max_buf = 1;
1322             } else if (!init_udp_max_buf &amp;&amp; sotype == SOCK_DGRAM) {
1323                 udp_max_buf = net_getParam(&quot;/dev/udp&quot;, &quot;udp_max_buf&quot;);
1324                 if (udp_max_buf == -1) {
1325                     udp_max_buf = findMaxBuf(fd, opt, SOCK_DGRAM);
1326                     if (udp_max_buf == -1) {
1327                         return -1;
1328                     }
1329                 }
1330                 init_udp_max_buf = 1;
1331             }
1332 
1333             maxbuf = (sotype == SOCK_STREAM) ? tcp_max_buf : udp_max_buf;
1334             bufsize = (int *)arg;
1335             if (*bufsize &gt; maxbuf) {
1336                 *bufsize = maxbuf;
1337             }
1338         }
1339     }
1340 #endif
1341 
1342 #ifdef _AIX
1343     if (level == SOL_SOCKET) {
1344         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
1345             /*
1346              * Just try to set the requested size. If it fails we will leave the
1347              * socket option as is. Setting the buffer size means only a hint in
1348              * the jse2/java software layer, see javadoc. In the previous
1349              * solution the buffer has always been truncated to a length of
1350              * 0x100000 Byte, even if the technical limit has not been reached.
1351              * This kind of absolute truncation was unexpected in the jck tests.
1352              */
1353             int ret = setsockopt(fd, level, opt, arg, len);
1354             if ((ret == 0) || (ret == -1 &amp;&amp; errno == ENOBUFS)) {
1355                 // Accept failure because of insufficient buffer memory resources.
1356                 return 0;
1357             } else {
1358                 // Deliver all other kinds of errors.
1359                 return ret;
1360             }
1361         }
1362     }
1363 #endif
1364 
1365     /*
1366      * On Linux the receive buffer is used for both socket
1367      * structures and the packet payload. The implication
1368      * is that if SO_RCVBUF is too small then small packets
1369      * must be discarded.
1370      */
1371 #ifdef __linux__
1372     if (level == SOL_SOCKET &amp;&amp; opt == SO_RCVBUF) {
1373         int *bufsize = (int *)arg;
1374         if (*bufsize &lt; 1024) {
1375             *bufsize = 1024;
1376         }
1377     }
1378 #endif
1379 
1380 #if defined(_ALLBSD_SOURCE)
1381     /*
1382      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On FreeBSD need to
1383      * ensure that value is &lt;= kern.ipc.maxsockbuf as otherwise we get
1384      * an ENOBUFS error.
1385      */
1386     if (level == SOL_SOCKET) {
1387         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
1388 #ifdef KIPC_MAXSOCKBUF
1389             if (maxsockbuf == -1) {
1390                mib[0] = CTL_KERN;
1391                mib[1] = KERN_IPC;
1392                mib[2] = KIPC_MAXSOCKBUF;
1393                rlen = sizeof(maxsockbuf);
1394                if (sysctl(mib, 3, &amp;maxsockbuf, &amp;rlen, NULL, 0) == -1)
1395                    maxsockbuf = 1024;
1396 
1397 #if 1
1398                /* XXXBSD: This is a hack to workaround mb_max/mb_max_adj
1399                   problem.  It should be removed when kern.ipc.maxsockbuf
1400                   will be real value. */
1401                maxsockbuf = (maxsockbuf/5)*4;
1402 #endif
1403            }
1404 #elif defined(__OpenBSD__)
1405            maxsockbuf = SB_MAX;
1406 #else
1407            maxsockbuf = 64 * 1024;      /* XXX: NetBSD */
1408 #endif
1409 
1410            bufsize = (int *)arg;
1411            if (*bufsize &gt; maxsockbuf) {
1412                *bufsize = maxsockbuf;
1413            }
1414 
1415            if (opt == SO_RCVBUF &amp;&amp; *bufsize &lt; 1024) {
1416                 *bufsize = 1024;
1417            }
1418 
1419         }
1420     }
1421 #endif
1422 
1423 #if defined(_ALLBSD_SOURCE) || defined(_AIX)
1424     /*
1425      * On Solaris, SO_REUSEADDR will allow multiple datagram
1426      * sockets to bind to the same port. The network jck tests check
1427      * for this &quot;feature&quot;, so we need to emulate it by turning on
1428      * SO_REUSEPORT as well for that combination.
1429      */
1430     if (level == SOL_SOCKET &amp;&amp; opt == SO_REUSEADDR) {
1431         int sotype;
1432         socklen_t arglen;
1433 
1434         arglen = sizeof(sotype);
1435         if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype, &amp;arglen) &lt; 0) {
1436             return -1;
1437         }
1438 
1439         if (sotype == SOCK_DGRAM) {
1440             setsockopt(fd, level, SO_REUSEPORT, arg, len);
1441         }
1442     }
1443 #endif
1444 
1445     return setsockopt(fd, level, opt, arg, len);
1446 }
1447 
1448 /*
1449  * Wrapper for bind system call - performs any necessary pre/post
1450  * processing to deal with OS specific issues :-
1451  *
1452  * Linux allows a socket to bind to 127.0.0.255 which must be
1453  * caught.
1454  *
1455  * On Solaris with IPv6 enabled we must use an exclusive
1456  * bind to guarantee a unique port number across the IPv4 and
1457  * IPv6 port spaces.
1458  *
1459  */
1460 int
1461 NET_Bind(int fd, SOCKETADDRESS *sa, int len)
1462 {
1463 #if defined(__solaris__)
1464     int level = -1;
1465     int exclbind = -1;
1466 #endif
1467     int rv;
1468     int arg, alen;
1469 
1470 #ifdef __linux__
1471     /*
1472      * ## get bugId for this issue - goes back to 1.2.2 port ##
1473      * ## When IPv6 is enabled this will be an IPv4-mapped
1474      * ## with family set to AF_INET6
1475      */
1476     if (sa-&gt;sa.sa_family == AF_INET) {
1477         if ((ntohl(sa-&gt;sa4.sin_addr.s_addr) &amp; 0x7f0000ff) == 0x7f0000ff) {
1478             errno = EADDRNOTAVAIL;
1479             return -1;
1480         }
1481     }
1482 #endif
1483 
1484 #if defined(__solaris__)
1485     /*
1486      * Solaris has separate IPv4 and IPv6 port spaces so we
1487      * use an exclusive bind when SO_REUSEADDR is not used to
1488      * give the illusion of a unified port space.
1489      * This also avoids problems with IPv6 sockets connecting
1490      * to IPv4 mapped addresses whereby the socket conversion
1491      * results in a late bind that fails because the
1492      * corresponding IPv4 port is in use.
1493      */
1494     alen = sizeof(arg);
1495 
1496     if (useExclBind ||
1497         getsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;arg, &amp;alen) == 0)
1498     {
1499         if (useExclBind || arg == 0) {
1500             /*
1501              * SO_REUSEADDR is disabled or sun.net.useExclusiveBind
1502              * property is true so enable TCP_EXCLBIND or
1503              * UDP_EXCLBIND
1504              */
1505             alen = sizeof(arg);
1506             if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&amp;arg, &amp;alen) == 0)
1507             {
1508                 if (arg == SOCK_STREAM) {
1509                     level = IPPROTO_TCP;
1510                     exclbind = TCP_EXCLBIND;
1511                 } else {
1512                     level = IPPROTO_UDP;
1513                     exclbind = UDP_EXCLBIND;
1514                 }
1515             }
1516 
1517             arg = 1;
1518             setsockopt(fd, level, exclbind, (char *)&amp;arg, sizeof(arg));
1519         }
1520     }
1521 
1522 #endif
1523 
1524     rv = bind(fd, &amp;sa-&gt;sa, len);
1525 
1526 #if defined(__solaris__)
1527     if (rv &lt; 0) {
1528         int en = errno;
1529         /* Restore *_EXCLBIND if the bind fails */
1530         if (exclbind != -1) {
1531             int arg = 0;
1532             setsockopt(fd, level, exclbind, (char *)&amp;arg,
1533                        sizeof(arg));
1534         }
1535         errno = en;
1536     }
1537 #endif
1538 
1539     return rv;
1540 }
1541 
1542 /**
1543  * Wrapper for poll with timeout on a single file descriptor.
1544  *
1545  * flags (defined in net_util_md.h can be any combination of
1546  * NET_WAIT_READ, NET_WAIT_WRITE &amp; NET_WAIT_CONNECT.
1547  *
1548  * The function will return when either the socket is ready for one
1549  * of the specified operations or the timeout expired.
1550  *
1551  * It returns the time left from the timeout (possibly 0), or -1 if it expired.
1552  */
1553 
1554 jint
1555 NET_Wait(JNIEnv *env, jint fd, jint flags, jint timeout)
1556 {
1557     jlong prevNanoTime = JVM_NanoTime(env, 0);
1558     jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;
1559     jint read_rv;
1560 
1561     while (1) {
1562         jlong newNanoTime;
1563         struct pollfd pfd;
1564         pfd.fd = fd;
1565         pfd.events = 0;
1566         if (flags &amp; NET_WAIT_READ)
1567           pfd.events |= POLLIN;
1568         if (flags &amp; NET_WAIT_WRITE)
1569           pfd.events |= POLLOUT;
1570         if (flags &amp; NET_WAIT_CONNECT)
1571           pfd.events |= POLLOUT;
1572 
1573         errno = 0;
1574         read_rv = NET_Poll(&amp;pfd, 1, nanoTimeout / NET_NSEC_PER_MSEC);
1575 
1576         newNanoTime = JVM_NanoTime(env, 0);
1577         nanoTimeout -= (newNanoTime - prevNanoTime);
1578         if (nanoTimeout &lt; NET_NSEC_PER_MSEC) {
1579           return read_rv &gt; 0 ? 0 : -1;
1580         }
1581         prevNanoTime = newNanoTime;
1582 
1583         if (read_rv &gt; 0) {
1584           break;
1585         }
1586       } /* while */
1587     return (nanoTimeout / NET_NSEC_PER_MSEC);
1588 }
    </pre>
  </body>
</html>
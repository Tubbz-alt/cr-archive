<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libnet/net_util_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="PlainSocketImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="net_util_md.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libnet/net_util_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  56 #include &quot;java_net_InetAddress.h&quot;
  57 
  58 #if defined(__linux__) &amp;&amp; !defined(IPV6_FLOWINFO_SEND)
  59 #define IPV6_FLOWINFO_SEND      33
  60 #endif
  61 
  62 #if defined(__solaris__) &amp;&amp; !defined(MAXINT)
  63 #define MAXINT INT_MAX
  64 #endif
  65 
  66 /*
  67  * EXCLBIND socket options only on Solaris
  68  */
  69 #if defined(__solaris__) &amp;&amp; !defined(TCP_EXCLBIND)
  70 #define TCP_EXCLBIND            0x21
  71 #endif
  72 #if defined(__solaris__) &amp;&amp; !defined(UDP_EXCLBIND)
  73 #define UDP_EXCLBIND            0x0101
  74 #endif
  75 
<span class="line-removed">  76 void setDefaultScopeID(JNIEnv *env, struct sockaddr *him)</span>
<span class="line-removed">  77 {</span>
<span class="line-removed">  78 #ifdef MACOSX</span>
<span class="line-removed">  79     static jclass ni_class = NULL;</span>
<span class="line-removed">  80     static jfieldID ni_defaultIndexID;</span>
<span class="line-removed">  81     if (ni_class == NULL) {</span>
<span class="line-removed">  82         jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);</span>
<span class="line-removed">  83         CHECK_NULL(c);</span>
<span class="line-removed">  84         c = (*env)-&gt;NewGlobalRef(env, c);</span>
<span class="line-removed">  85         CHECK_NULL(c);</span>
<span class="line-removed">  86         ni_defaultIndexID = (*env)-&gt;GetStaticFieldID(env, c, &quot;defaultIndex&quot;, &quot;I&quot;);</span>
<span class="line-removed">  87         CHECK_NULL(ni_defaultIndexID);</span>
<span class="line-removed">  88         ni_class = c;</span>
<span class="line-removed">  89     }</span>
<span class="line-removed">  90     int defaultIndex;</span>
<span class="line-removed">  91     struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)him;</span>
<span class="line-removed">  92     if (sin6-&gt;sin6_family == AF_INET6 &amp;&amp; (sin6-&gt;sin6_scope_id == 0) &amp;&amp;</span>
<span class="line-removed">  93         (IN6_IS_ADDR_LINKLOCAL(&amp;sin6-&gt;sin6_addr) ||</span>
<span class="line-removed">  94          IN6_IS_ADDR_MULTICAST(&amp;sin6-&gt;sin6_addr))) {</span>
<span class="line-removed">  95         defaultIndex = (*env)-&gt;GetStaticIntField(env, ni_class,</span>
<span class="line-removed">  96                                                  ni_defaultIndexID);</span>
<span class="line-removed">  97         sin6-&gt;sin6_scope_id = defaultIndex;</span>
<span class="line-removed">  98     }</span>
<span class="line-removed">  99 #endif</span>
<span class="line-removed"> 100 }</span>
<span class="line-removed"> 101 </span>
<span class="line-removed"> 102 int getDefaultScopeID(JNIEnv *env) {</span>
<span class="line-removed"> 103     int defaultIndex = 0;</span>
<span class="line-removed"> 104     static jclass ni_class = NULL;</span>
<span class="line-removed"> 105     static jfieldID ni_defaultIndexID;</span>
<span class="line-removed"> 106     if (ni_class == NULL) {</span>
<span class="line-removed"> 107         jclass c = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);</span>
<span class="line-removed"> 108         CHECK_NULL_RETURN(c, 0);</span>
<span class="line-removed"> 109         c = (*env)-&gt;NewGlobalRef(env, c);</span>
<span class="line-removed"> 110         CHECK_NULL_RETURN(c, 0);</span>
<span class="line-removed"> 111         ni_defaultIndexID = (*env)-&gt;GetStaticFieldID(env, c, &quot;defaultIndex&quot;, &quot;I&quot;);</span>
<span class="line-removed"> 112         CHECK_NULL_RETURN(ni_defaultIndexID, 0);</span>
<span class="line-removed"> 113         ni_class = c;</span>
<span class="line-removed"> 114     }</span>
<span class="line-removed"> 115     defaultIndex = (*env)-&gt;GetStaticIntField(env, ni_class,</span>
<span class="line-removed"> 116                                              ni_defaultIndexID);</span>
<span class="line-removed"> 117     return defaultIndex;</span>
<span class="line-removed"> 118 }</span>
<span class="line-removed"> 119 </span>
 120 #define RESTARTABLE(_cmd, _result) do { \
 121     do { \
 122         _result = _cmd; \
 123     } while((_result == -1) &amp;&amp; (errno == EINTR)); \
 124 } while(0)
 125 
 126 int NET_SocketAvailable(int s, int *pbytes) {
 127     int result;
 128     RESTARTABLE(ioctl(s, FIONREAD, pbytes), result);
 129     return result;
 130 }
 131 
 132 #ifdef __solaris__
 133 static int init_tcp_max_buf, init_udp_max_buf;
 134 static int tcp_max_buf;
 135 static int udp_max_buf;
 136 static int useExclBind = 0;
 137 
 138 /*
 139  * Get the specified parameter from the specified driver. The value
</pre>
<hr />
<pre>
 200         a = initial_guess;
 201     } else {
 202         FAIL_IF_NOT_ENOBUFS;
 203         b = initial_guess - 1;
 204     }
 205     do {
 206         int mid = a + (b-a)/2;
 207         if (setsockopt(fd, SOL_SOCKET, opt, &amp;mid, sizeof(int)) == 0) {
 208             limit = mid;
 209             a = mid + 1;
 210         } else {
 211             FAIL_IF_NOT_ENOBUFS;
 212             b = mid - 1;
 213         }
 214     } while (b &gt;= a);
 215 
 216     return limit;
 217 }
 218 #endif
 219 
<span class="line-removed"> 220 #ifdef __linux__</span>
<span class="line-removed"> 221 static int vinit = 0;</span>
<span class="line-removed"> 222 static int kernelV24 = 0;</span>
<span class="line-removed"> 223 static int vinit24 = 0;</span>
<span class="line-removed"> 224 </span>
<span class="line-removed"> 225 int kernelIsV24 () {</span>
<span class="line-removed"> 226     if (!vinit24) {</span>
<span class="line-removed"> 227         struct utsname sysinfo;</span>
<span class="line-removed"> 228         if (uname(&amp;sysinfo) == 0) {</span>
<span class="line-removed"> 229             sysinfo.release[3] = &#39;\0&#39;;</span>
<span class="line-removed"> 230             if (strcmp(sysinfo.release, &quot;2.4&quot;) == 0) {</span>
<span class="line-removed"> 231                 kernelV24 = JNI_TRUE;</span>
<span class="line-removed"> 232             }</span>
<span class="line-removed"> 233         }</span>
<span class="line-removed"> 234         vinit24 = 1;</span>
<span class="line-removed"> 235     }</span>
<span class="line-removed"> 236     return kernelV24;</span>
<span class="line-removed"> 237 }</span>
<span class="line-removed"> 238 #endif</span>
<span class="line-removed"> 239 </span>
 240 void
 241 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
 242                    const char *defaultDetail) {
 243     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
 244 }
 245 
 246 void
 247 NET_ThrowCurrent(JNIEnv *env, char *msg) {
 248     NET_ThrowNew(env, errno, msg);
 249 }
 250 
 251 void
 252 NET_ThrowNew(JNIEnv *env, int errorNumber, char *msg) {
 253     char fullMsg[512];
 254     if (!msg) {
 255         msg = &quot;no further information&quot;;
 256     }
 257     switch(errorNumber) {
 258     case EBADF:
 259         jio_snprintf(fullMsg, sizeof(fullMsg), &quot;socket closed: %s&quot;, msg);
</pre>
<hr />
<pre>
 261         break;
 262     case EINTR:
 263         JNU_ThrowByName(env, JNU_JAVAIOPKG &quot;InterruptedIOException&quot;, msg);
 264         break;
 265     default:
 266         errno = errorNumber;
 267         JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG &quot;SocketException&quot;, msg);
 268         break;
 269     }
 270 }
 271 
 272 
 273 jfieldID
 274 NET_GetFileDescriptorID(JNIEnv *env)
 275 {
 276     jclass cls = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;);
 277     CHECK_NULL_RETURN(cls, NULL);
 278     return (*env)-&gt;GetFieldID(env, cls, &quot;fd&quot;, &quot;I&quot;);
 279 }
 280 










 281 #if defined(DONT_ENABLE_IPV6)
 282 jint  IPv6_supported()
 283 {
 284     return JNI_FALSE;
 285 }
 286 
 287 #else /* !DONT_ENABLE_IPV6 */
 288 
 289 jint  IPv6_supported()
 290 {
 291     int fd;
 292     void *ipv6_fn;
 293     SOCKETADDRESS sa;
 294     socklen_t sa_len = sizeof(SOCKETADDRESS);
 295 
 296     fd = socket(AF_INET6, SOCK_STREAM, 0) ;
 297     if (fd &lt; 0) {
 298         /*
 299          *  TODO: We really cant tell since it may be an unrelated error
 300          *  for now we will assume that AF_INET6 is not available
</pre>
<hr />
<pre>
 425     if (error_string == NULL)
 426         error_string = &quot;unknown error&quot;;
 427 
 428     size = strlen(format) + strlen(hostname) + strlen(error_string) + 2;
 429     buf = (char *) malloc(size);
 430     if (buf) {
 431         jstring s;
 432         sprintf(buf, format, hostname, error_string);
 433         s = JNU_NewStringPlatform(env, buf);
 434         if (s != NULL) {
 435             jobject x = JNU_NewObjectByName(env,
 436                                             &quot;java/net/UnknownHostException&quot;,
 437                                             &quot;(Ljava/lang/String;)V&quot;, s);
 438             if (x != NULL)
 439                 (*env)-&gt;Throw(env, x);
 440         }
 441         free(buf);
 442     }
 443 }
 444 
<span class="line-modified"> 445 #if defined(__linux__)</span>
<span class="line-removed"> 446 </span>
<span class="line-removed"> 447 /* following code creates a list of addresses from the kernel</span>
<span class="line-removed"> 448  * routing table that are routed via the loopback address.</span>
<span class="line-removed"> 449  * We check all destination addresses against this table</span>
<span class="line-removed"> 450  * and override the scope_id field to use the relevant value for &quot;lo&quot;</span>
<span class="line-removed"> 451  * in order to work-around the Linux bug that prevents packets destined</span>
<span class="line-removed"> 452  * for certain local addresses from being sent via a physical interface.</span>
<span class="line-removed"> 453  */</span>
<span class="line-removed"> 454 </span>
<span class="line-removed"> 455 struct loopback_route {</span>
<span class="line-removed"> 456     struct in6_addr addr; /* destination address */</span>
<span class="line-removed"> 457     int plen; /* prefix length */</span>
<span class="line-removed"> 458 };</span>
<span class="line-removed"> 459 </span>
<span class="line-removed"> 460 static struct loopback_route *loRoutes = 0;</span>
<span class="line-removed"> 461 static int nRoutes = 0; /* number of routes */</span>
<span class="line-removed"> 462 static int loRoutes_size = 16; /* initial size */</span>
<span class="line-removed"> 463 static int lo_scope_id = 0;</span>
<span class="line-removed"> 464 </span>
<span class="line-removed"> 465 static void initLoopbackRoutes();</span>
<span class="line-removed"> 466 </span>
<span class="line-removed"> 467 void printAddr (struct in6_addr *addr) {</span>
<span class="line-removed"> 468     int i;</span>
<span class="line-removed"> 469     for (i=0; i&lt;16; i++) {</span>
<span class="line-removed"> 470         printf (&quot;%02x&quot;, addr-&gt;s6_addr[i]);</span>
<span class="line-removed"> 471     }</span>
<span class="line-removed"> 472     printf (&quot;\n&quot;);</span>
<span class="line-removed"> 473 }</span>
<span class="line-removed"> 474 </span>
<span class="line-removed"> 475 static jboolean needsLoopbackRoute (struct in6_addr* dest_addr) {</span>
<span class="line-removed"> 476     int byte_count;</span>
<span class="line-removed"> 477     int extra_bits, i;</span>
<span class="line-removed"> 478     struct loopback_route *ptr;</span>
<span class="line-removed"> 479 </span>
<span class="line-removed"> 480     if (loRoutes == 0) {</span>
<span class="line-removed"> 481         initLoopbackRoutes();</span>
<span class="line-removed"> 482     }</span>
<span class="line-removed"> 483 </span>
<span class="line-removed"> 484     for (ptr = loRoutes, i=0; i&lt;nRoutes; i++, ptr++) {</span>
<span class="line-removed"> 485         struct in6_addr *target_addr=&amp;ptr-&gt;addr;</span>
<span class="line-removed"> 486         int dest_plen = ptr-&gt;plen;</span>
<span class="line-removed"> 487         byte_count = dest_plen &gt;&gt; 3;</span>
<span class="line-removed"> 488         extra_bits = dest_plen &amp; 0x3;</span>
<span class="line-removed"> 489 </span>
<span class="line-removed"> 490         if (byte_count &gt; 0) {</span>
<span class="line-removed"> 491             if (memcmp(target_addr, dest_addr, byte_count)) {</span>
<span class="line-removed"> 492                 continue;  /* no match */</span>
<span class="line-removed"> 493             }</span>
<span class="line-removed"> 494         }</span>
<span class="line-removed"> 495 </span>
<span class="line-removed"> 496         if (extra_bits &gt; 0) {</span>
<span class="line-removed"> 497             unsigned char c1 = ((unsigned char *)target_addr)[byte_count];</span>
<span class="line-removed"> 498             unsigned char c2 = ((unsigned char *)&amp;dest_addr)[byte_count];</span>
<span class="line-removed"> 499             unsigned char mask = 0xff &lt;&lt; (8 - extra_bits);</span>
<span class="line-removed"> 500             if ((c1 &amp; mask) != (c2 &amp; mask)) {</span>
<span class="line-removed"> 501                 continue;</span>
<span class="line-removed"> 502             }</span>
<span class="line-removed"> 503         }</span>
<span class="line-removed"> 504         return JNI_TRUE;</span>
<span class="line-removed"> 505     }</span>
<span class="line-removed"> 506     return JNI_FALSE;</span>
<span class="line-removed"> 507 }</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509 </span>
<span class="line-removed"> 510 static void initLoopbackRoutes() {</span>
<span class="line-removed"> 511     FILE *f;</span>
<span class="line-removed"> 512     char srcp[8][5];</span>
<span class="line-removed"> 513     char hopp[8][5];</span>
<span class="line-removed"> 514     int dest_plen, src_plen, use, refcnt, metric;</span>
<span class="line-removed"> 515     unsigned long flags;</span>
<span class="line-removed"> 516     char dest_str[40];</span>
<span class="line-removed"> 517     struct in6_addr dest_addr;</span>
<span class="line-removed"> 518     char device[16];</span>
<span class="line-removed"> 519     struct loopback_route *loRoutesTemp;</span>
<span class="line-removed"> 520 </span>
<span class="line-removed"> 521     if (loRoutes != 0) {</span>
<span class="line-removed"> 522         free (loRoutes);</span>
<span class="line-removed"> 523     }</span>
<span class="line-removed"> 524     loRoutes = calloc (loRoutes_size, sizeof(struct loopback_route));</span>
<span class="line-removed"> 525     if (loRoutes == 0) {</span>
<span class="line-removed"> 526         return;</span>
<span class="line-removed"> 527     }</span>
<span class="line-removed"> 528     /*</span>
<span class="line-removed"> 529      * Scan /proc/net/ipv6_route looking for a matching</span>
<span class="line-removed"> 530      * route.</span>
<span class="line-removed"> 531      */</span>
<span class="line-removed"> 532     if ((f = fopen(&quot;/proc/net/ipv6_route&quot;, &quot;r&quot;)) == NULL) {</span>
<span class="line-removed"> 533         return ;</span>
<span class="line-removed"> 534     }</span>
<span class="line-removed"> 535     while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %02x &quot;</span>
<span class="line-removed"> 536                      &quot;%4s%4s%4s%4s%4s%4s%4s%4s %02x &quot;</span>
<span class="line-removed"> 537                      &quot;%4s%4s%4s%4s%4s%4s%4s%4s &quot;</span>
<span class="line-removed"> 538                      &quot;%08x %08x %08x %08lx %8s&quot;,</span>
<span class="line-removed"> 539                      dest_str, &amp;dest_str[5], &amp;dest_str[10], &amp;dest_str[15],</span>
<span class="line-removed"> 540                      &amp;dest_str[20], &amp;dest_str[25], &amp;dest_str[30], &amp;dest_str[35],</span>
<span class="line-removed"> 541                      &amp;dest_plen,</span>
<span class="line-removed"> 542                      srcp[0], srcp[1], srcp[2], srcp[3],</span>
<span class="line-removed"> 543                      srcp[4], srcp[5], srcp[6], srcp[7],</span>
<span class="line-removed"> 544                      &amp;src_plen,</span>
<span class="line-removed"> 545                      hopp[0], hopp[1], hopp[2], hopp[3],</span>
<span class="line-removed"> 546                      hopp[4], hopp[5], hopp[6], hopp[7],</span>
<span class="line-removed"> 547                      &amp;metric, &amp;use, &amp;refcnt, &amp;flags, device) == 31) {</span>
<span class="line-removed"> 548 </span>
<span class="line-removed"> 549         /*</span>
<span class="line-removed"> 550          * Some routes should be ignored</span>
<span class="line-removed"> 551          */</span>
<span class="line-removed"> 552         if ( (dest_plen &lt; 0 || dest_plen &gt; 128)  ||</span>
<span class="line-removed"> 553              (src_plen != 0) ||</span>
<span class="line-removed"> 554              (flags &amp; (RTF_POLICY | RTF_FLOW)) ||</span>
<span class="line-removed"> 555              ((flags &amp; RTF_REJECT) &amp;&amp; dest_plen == 0) ) {</span>
<span class="line-removed"> 556             continue;</span>
<span class="line-removed"> 557         }</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559         /*</span>
<span class="line-removed"> 560          * Convert the destination address</span>
<span class="line-removed"> 561          */</span>
<span class="line-removed"> 562         dest_str[4] = &#39;:&#39;;</span>
<span class="line-removed"> 563         dest_str[9] = &#39;:&#39;;</span>
<span class="line-removed"> 564         dest_str[14] = &#39;:&#39;;</span>
<span class="line-removed"> 565         dest_str[19] = &#39;:&#39;;</span>
<span class="line-removed"> 566         dest_str[24] = &#39;:&#39;;</span>
<span class="line-removed"> 567         dest_str[29] = &#39;:&#39;;</span>
<span class="line-removed"> 568         dest_str[34] = &#39;:&#39;;</span>
<span class="line-removed"> 569         dest_str[39] = &#39;\0&#39;;</span>
<span class="line-removed"> 570 </span>
<span class="line-removed"> 571         if (inet_pton(AF_INET6, dest_str, &amp;dest_addr) &lt; 0) {</span>
<span class="line-removed"> 572             /* not an Ipv6 address */</span>
<span class="line-removed"> 573             continue;</span>
<span class="line-removed"> 574         }</span>
<span class="line-removed"> 575         if (strcmp(device, &quot;lo&quot;) != 0) {</span>
<span class="line-removed"> 576             /* Not a loopback route */</span>
<span class="line-removed"> 577             continue;</span>
<span class="line-removed"> 578         } else {</span>
<span class="line-removed"> 579             if (nRoutes == loRoutes_size) {</span>
<span class="line-removed"> 580                 loRoutesTemp = realloc (loRoutes, loRoutes_size *</span>
<span class="line-removed"> 581                                         sizeof (struct loopback_route) * 2);</span>
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583                 if (loRoutesTemp == 0) {</span>
<span class="line-removed"> 584                     free(loRoutes);</span>
<span class="line-removed"> 585                     loRoutes = NULL;</span>
<span class="line-removed"> 586                     nRoutes = 0;</span>
<span class="line-removed"> 587                     fclose (f);</span>
<span class="line-removed"> 588                     return;</span>
<span class="line-removed"> 589                 }</span>
<span class="line-removed"> 590                 loRoutes=loRoutesTemp;</span>
<span class="line-removed"> 591                 loRoutes_size *= 2;</span>
<span class="line-removed"> 592             }</span>
<span class="line-removed"> 593             memcpy (&amp;loRoutes[nRoutes].addr,&amp;dest_addr,sizeof(struct in6_addr));</span>
<span class="line-removed"> 594             loRoutes[nRoutes].plen = dest_plen;</span>
<span class="line-removed"> 595             nRoutes ++;</span>
<span class="line-removed"> 596         }</span>
<span class="line-removed"> 597     }</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599     fclose (f);</span>
<span class="line-removed"> 600     {</span>
<span class="line-removed"> 601         /* now find the scope_id for &quot;lo&quot; */</span>
<span class="line-removed"> 602 </span>
<span class="line-removed"> 603         char devname[21];</span>
<span class="line-removed"> 604         char addr6p[8][5];</span>
<span class="line-removed"> 605         int plen, scope, dad_status, if_idx;</span>
<span class="line-removed"> 606 </span>
<span class="line-removed"> 607         if ((f = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;)) != NULL) {</span>
<span class="line-removed"> 608             while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\n&quot;,</span>
<span class="line-removed"> 609                       addr6p[0], addr6p[1], addr6p[2], addr6p[3],</span>
<span class="line-removed"> 610                       addr6p[4], addr6p[5], addr6p[6], addr6p[7],</span>
<span class="line-removed"> 611                   &amp;if_idx, &amp;plen, &amp;scope, &amp;dad_status, devname) == 13) {</span>
<span class="line-removed"> 612 </span>
<span class="line-removed"> 613                 if (strcmp(devname, &quot;lo&quot;) == 0) {</span>
<span class="line-removed"> 614                     /*</span>
<span class="line-removed"> 615                      * Found - so just return the index</span>
<span class="line-removed"> 616                      */</span>
<span class="line-removed"> 617                     fclose(f);</span>
<span class="line-removed"> 618                     lo_scope_id = if_idx;</span>
<span class="line-removed"> 619                     return;</span>
<span class="line-removed"> 620                 }</span>
<span class="line-removed"> 621             }</span>
<span class="line-removed"> 622             fclose(f);</span>
<span class="line-removed"> 623         }</span>
<span class="line-removed"> 624     }</span>
<span class="line-removed"> 625 }</span>
<span class="line-removed"> 626 </span>
<span class="line-removed"> 627 /*</span>
<span class="line-removed"> 628  * Following is used for binding to local addresses. Equivalent</span>
<span class="line-removed"> 629  * to code above, for bind().</span>
<span class="line-removed"> 630  */</span>
<span class="line-removed"> 631 </span>
<span class="line-removed"> 632 struct localinterface {</span>
<span class="line-removed"> 633     int index;</span>
<span class="line-removed"> 634     char localaddr [16];</span>
<span class="line-removed"> 635 };</span>
<span class="line-removed"> 636 </span>
<span class="line-removed"> 637 static struct localinterface *localifs = 0;</span>
<span class="line-removed"> 638 static int localifsSize = 0;    /* size of array */</span>
<span class="line-removed"> 639 static int nifs = 0;            /* number of entries used in array */</span>
<span class="line-removed"> 640 </span>
<span class="line-removed"> 641 /* not thread safe: make sure called once from one thread */</span>
<span class="line-removed"> 642 </span>
<span class="line-removed"> 643 static void initLocalIfs () {</span>
<span class="line-removed"> 644     FILE *f;</span>
<span class="line-removed"> 645     unsigned char staddr [16];</span>
<span class="line-removed"> 646     char ifname [33];</span>
<span class="line-removed"> 647     struct localinterface *lif=0;</span>
<span class="line-removed"> 648     struct localinterface *localifsTemp;</span>
<span class="line-removed"> 649     int index, x1, x2, x3;</span>
<span class="line-removed"> 650     unsigned int u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,ua,ub,uc,ud,ue,uf;</span>
<span class="line-removed"> 651 </span>
<span class="line-removed"> 652     if ((f = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;)) == NULL) {</span>
<span class="line-removed"> 653         return ;</span>
<span class="line-removed"> 654     }</span>
<span class="line-removed"> 655     while (fscanf (f, &quot;%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x &quot;</span>
<span class="line-removed"> 656                 &quot;%d %x %x %x %32s&quot;,&amp;u0,&amp;u1,&amp;u2,&amp;u3,&amp;u4,&amp;u5,&amp;u6,&amp;u7,</span>
<span class="line-removed"> 657                 &amp;u8,&amp;u9,&amp;ua,&amp;ub,&amp;uc,&amp;ud,&amp;ue,&amp;uf,</span>
<span class="line-removed"> 658                 &amp;index, &amp;x1, &amp;x2, &amp;x3, ifname) == 21) {</span>
<span class="line-removed"> 659         staddr[0] = (unsigned char)u0;</span>
<span class="line-removed"> 660         staddr[1] = (unsigned char)u1;</span>
<span class="line-removed"> 661         staddr[2] = (unsigned char)u2;</span>
<span class="line-removed"> 662         staddr[3] = (unsigned char)u3;</span>
<span class="line-removed"> 663         staddr[4] = (unsigned char)u4;</span>
<span class="line-removed"> 664         staddr[5] = (unsigned char)u5;</span>
<span class="line-removed"> 665         staddr[6] = (unsigned char)u6;</span>
<span class="line-removed"> 666         staddr[7] = (unsigned char)u7;</span>
<span class="line-removed"> 667         staddr[8] = (unsigned char)u8;</span>
<span class="line-removed"> 668         staddr[9] = (unsigned char)u9;</span>
<span class="line-removed"> 669         staddr[10] = (unsigned char)ua;</span>
<span class="line-removed"> 670         staddr[11] = (unsigned char)ub;</span>
<span class="line-removed"> 671         staddr[12] = (unsigned char)uc;</span>
<span class="line-removed"> 672         staddr[13] = (unsigned char)ud;</span>
<span class="line-removed"> 673         staddr[14] = (unsigned char)ue;</span>
<span class="line-removed"> 674         staddr[15] = (unsigned char)uf;</span>
<span class="line-removed"> 675         nifs ++;</span>
<span class="line-removed"> 676         if (nifs &gt; localifsSize) {</span>
<span class="line-removed"> 677             localifsTemp = (struct localinterface *) realloc(</span>
<span class="line-removed"> 678                         localifs, sizeof (struct localinterface)* (localifsSize+5));</span>
<span class="line-removed"> 679             if (localifsTemp == 0) {</span>
<span class="line-removed"> 680                 free(localifs);</span>
<span class="line-removed"> 681                 localifs = 0;</span>
<span class="line-removed"> 682                 localifsSize = 0;</span>
<span class="line-removed"> 683                 nifs = 0;</span>
<span class="line-removed"> 684                 fclose(f);</span>
<span class="line-removed"> 685                 return;</span>
<span class="line-removed"> 686             }</span>
<span class="line-removed"> 687             localifs = localifsTemp;</span>
<span class="line-removed"> 688             lif = localifs + localifsSize;</span>
<span class="line-removed"> 689             localifsSize += 5;</span>
<span class="line-removed"> 690         } else {</span>
<span class="line-removed"> 691             lif ++;</span>
<span class="line-removed"> 692         }</span>
<span class="line-removed"> 693         memcpy (lif-&gt;localaddr, staddr, 16);</span>
<span class="line-removed"> 694         lif-&gt;index = index;</span>
<span class="line-removed"> 695     }</span>
<span class="line-removed"> 696     fclose (f);</span>
<span class="line-removed"> 697 }</span>
<span class="line-removed"> 698 </span>
<span class="line-removed"> 699 /* return the scope_id (interface index) of the</span>
<span class="line-removed"> 700  * interface corresponding to the given address</span>
<span class="line-removed"> 701  * returns 0 if no match found</span>
<span class="line-removed"> 702  */</span>
<span class="line-removed"> 703 </span>
<span class="line-removed"> 704 static int getLocalScopeID (char *addr) {</span>
<span class="line-removed"> 705     struct localinterface *lif;</span>
<span class="line-removed"> 706     int i;</span>
<span class="line-removed"> 707     if (localifs == 0) {</span>
<span class="line-removed"> 708         initLocalIfs();</span>
<span class="line-removed"> 709     }</span>
<span class="line-removed"> 710     for (i=0, lif=localifs; i&lt;nifs; i++, lif++) {</span>
<span class="line-removed"> 711         if (memcmp (addr, lif-&gt;localaddr, 16) == 0) {</span>
<span class="line-removed"> 712             return lif-&gt;index;</span>
<span class="line-removed"> 713         }</span>
<span class="line-removed"> 714     }</span>
<span class="line-removed"> 715     return 0;</span>
<span class="line-removed"> 716 }</span>
<span class="line-removed"> 717 </span>
<span class="line-removed"> 718 void platformInit () {</span>
<span class="line-removed"> 719     initLoopbackRoutes();</span>
<span class="line-removed"> 720     initLocalIfs();</span>
<span class="line-removed"> 721 }</span>
<span class="line-removed"> 722 </span>
<span class="line-removed"> 723 #elif defined(_AIX)</span>
 724 
 725 /* Initialize stubs for blocking I/O workarounds (see src/solaris/native/java/net/linux_close.c) */
 726 extern void aix_close_init();
 727 
 728 void platformInit () {
 729     aix_close_init();
 730 }
 731 
 732 #else
 733 
 734 void platformInit () {}
 735 
 736 #endif
 737 
 738 void parseExclusiveBindProperty(JNIEnv *env) {
 739 #ifdef __solaris__
 740     jstring s, flagSet;
 741     jclass iCls;
 742     jmethodID mid;
 743 
</pre>
<hr />
<pre>
 789                  * caddr[10] = 0xff;
 790                  * caddr[11] = 0xff; */
 791             } else {
 792                 caddr[10] = 0xff;
 793                 caddr[11] = 0xff;
 794                 caddr[12] = ((address &gt;&gt; 24) &amp; 0xff);
 795                 caddr[13] = ((address &gt;&gt; 16) &amp; 0xff);
 796                 caddr[14] = ((address &gt;&gt; 8) &amp; 0xff);
 797                 caddr[15] = (address &amp; 0xff);
 798             }
 799         } else {
 800             getInet6Address_ipaddress(env, iaObj, (char *)caddr);
 801         }
 802         sa-&gt;sa6.sin6_port = htons(port);
 803         memcpy((void *)&amp;sa-&gt;sa6.sin6_addr, caddr, sizeof(struct in6_addr));
 804         sa-&gt;sa6.sin6_family = AF_INET6;
 805         if (len != NULL) {
 806             *len = sizeof(struct sockaddr_in6);
 807         }
 808 
<span class="line-removed"> 809 #ifdef __linux__</span>
<span class="line-removed"> 810         /*</span>
<span class="line-removed"> 811          * On Linux if we are connecting to a link-local address</span>
<span class="line-removed"> 812          * we need to specify the interface in the scope_id (2.4 kernel only)</span>
<span class="line-removed"> 813          *</span>
<span class="line-removed"> 814          * If the scope was cached then we use the cached value. If not cached but</span>
<span class="line-removed"> 815          * specified in the Inet6Address we use that, but we first check if the</span>
<span class="line-removed"> 816          * address needs to be routed via the loopback interface. In this case,</span>
<span class="line-removed"> 817          * we override the specified value with that of the loopback interface.</span>
<span class="line-removed"> 818          * If no cached value exists and no value was specified by user, then</span>
<span class="line-removed"> 819          * we try to determine a value from the routing table. In all these</span>
<span class="line-removed"> 820          * cases the used value is cached for further use.</span>
<span class="line-removed"> 821          */</span>
<span class="line-removed"> 822         if (IN6_IS_ADDR_LINKLOCAL(&amp;sa-&gt;sa6.sin6_addr)) {</span>
<span class="line-removed"> 823             unsigned int cached_scope_id = 0, scope_id = 0;</span>
<span class="line-removed"> 824 </span>
<span class="line-removed"> 825             if (ia6_cachedscopeidID) {</span>
<span class="line-removed"> 826                 cached_scope_id = (int)(*env)-&gt;GetIntField(env, iaObj, ia6_cachedscopeidID);</span>
<span class="line-removed"> 827                 /* if cached value exists then use it. Otherwise, check</span>
<span class="line-removed"> 828                  * if scope is set in the address.</span>
<span class="line-removed"> 829                  */</span>
<span class="line-removed"> 830                 if (!cached_scope_id) {</span>
<span class="line-removed"> 831                     if (ia6_scopeidID) {</span>
<span class="line-removed"> 832                         scope_id = getInet6Address_scopeid(env, iaObj);</span>
<span class="line-removed"> 833                     }</span>
<span class="line-removed"> 834                     if (scope_id != 0) {</span>
<span class="line-removed"> 835                         /* check user-specified value for loopback case</span>
<span class="line-removed"> 836                          * that needs to be overridden</span>
<span class="line-removed"> 837                          */</span>
<span class="line-removed"> 838                         if (kernelIsV24() &amp;&amp; needsLoopbackRoute(&amp;sa-&gt;sa6.sin6_addr)) {</span>
<span class="line-removed"> 839                             cached_scope_id = lo_scope_id;</span>
<span class="line-removed"> 840                             (*env)-&gt;SetIntField(env, iaObj, ia6_cachedscopeidID, cached_scope_id);</span>
<span class="line-removed"> 841                         }</span>
<span class="line-removed"> 842                     } else {</span>
<span class="line-removed"> 843                         /*</span>
<span class="line-removed"> 844                          * Otherwise consult the IPv6 routing tables to</span>
<span class="line-removed"> 845                          * try determine the appropriate interface.</span>
<span class="line-removed"> 846                          */</span>
<span class="line-removed"> 847                         if (kernelIsV24()) {</span>
<span class="line-removed"> 848                             cached_scope_id = getDefaultIPv6Interface(&amp;sa-&gt;sa6.sin6_addr);</span>
<span class="line-removed"> 849                         } else {</span>
<span class="line-removed"> 850                             cached_scope_id = getLocalScopeID((char *)&amp;(sa-&gt;sa6.sin6_addr));</span>
<span class="line-removed"> 851                             if (cached_scope_id == 0) {</span>
<span class="line-removed"> 852                                 cached_scope_id = getDefaultIPv6Interface(&amp;sa-&gt;sa6.sin6_addr);</span>
<span class="line-removed"> 853                             }</span>
<span class="line-removed"> 854                         }</span>
<span class="line-removed"> 855                         (*env)-&gt;SetIntField(env, iaObj, ia6_cachedscopeidID, cached_scope_id);</span>
<span class="line-removed"> 856                     }</span>
<span class="line-removed"> 857                 }</span>
<span class="line-removed"> 858             }</span>
<span class="line-removed"> 859 </span>
<span class="line-removed"> 860             /*</span>
<span class="line-removed"> 861              * If we have a scope_id use the extended form</span>
<span class="line-removed"> 862              * of sockaddr_in6.</span>
<span class="line-removed"> 863              */</span>
<span class="line-removed"> 864             sa-&gt;sa6.sin6_scope_id = cached_scope_id == 0 ? scope_id : cached_scope_id;</span>
<span class="line-removed"> 865         }</span>
<span class="line-removed"> 866 #else</span>
 867         /* handle scope_id */
 868         if (family != java_net_InetAddress_IPv4) {
 869             if (ia6_scopeidID) {
 870                 sa-&gt;sa6.sin6_scope_id = getInet6Address_scopeid(env, iaObj);
 871             }
 872         }
<span class="line-removed"> 873 #endif</span>
 874     } else {
 875         jint address;
 876         if (family != java_net_InetAddress_IPv4) {
 877             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Protocol family unavailable&quot;);
 878             return -1;
 879         }
 880         address = getInetAddress_addr(env, iaObj);
 881         JNU_CHECK_EXCEPTION_RETURN(env, -1);
 882         sa-&gt;sa4.sin_port = htons(port);
 883         sa-&gt;sa4.sin_addr.s_addr = htonl(address);
 884         sa-&gt;sa4.sin_family = AF_INET;
 885         if (len != NULL) {
 886             *len = sizeof(struct sockaddr_in);
 887         }
 888     }
 889     return 0;
 890 }
 891 
 892 void
 893 NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass) {
</pre>
<hr />
<pre>
 987                 return 0;
 988 #endif
 989         }
 990     }
 991 
 992     /*
 993      * Map the Java level option to the native level
 994      */
 995     for (i=0; i&lt;(int)(sizeof(opts) / sizeof(opts[0])); i++) {
 996         if (cmd == opts[i].cmd) {
 997             *level = opts[i].level;
 998             *optname = opts[i].optname;
 999             return 0;
1000         }
1001     }
1002 
1003     /* not found */
1004     return -1;
1005 }
1006 
<span class="line-removed">1007 /*</span>
<span class="line-removed">1008  * Determine the default interface for an IPv6 address.</span>
<span class="line-removed">1009  *</span>
<span class="line-removed">1010  * 1. Scans /proc/net/ipv6_route for a matching route</span>
<span class="line-removed">1011  *    (eg: fe80::/10 or a route for the specific address).</span>
<span class="line-removed">1012  *    This will tell us the interface to use (eg: &quot;eth0&quot;).</span>
<span class="line-removed">1013  *</span>
<span class="line-removed">1014  * 2. Lookup /proc/net/if_inet6 to map the interface</span>
<span class="line-removed">1015  *    name to an interface index.</span>
<span class="line-removed">1016  *</span>
<span class="line-removed">1017  * Returns :-</span>
<span class="line-removed">1018  *      -1 if error</span>
<span class="line-removed">1019  *       0 if no matching interface</span>
<span class="line-removed">1020  *      &gt;1 interface index to use for the link-local address.</span>
<span class="line-removed">1021  */</span>
<span class="line-removed">1022 #if defined(__linux__)</span>
<span class="line-removed">1023 int getDefaultIPv6Interface(struct in6_addr *target_addr) {</span>
<span class="line-removed">1024     FILE *f;</span>
<span class="line-removed">1025     char srcp[8][5];</span>
<span class="line-removed">1026     char hopp[8][5];</span>
<span class="line-removed">1027     int dest_plen, src_plen, use, refcnt, metric;</span>
<span class="line-removed">1028     unsigned long flags;</span>
<span class="line-removed">1029     char dest_str[40];</span>
<span class="line-removed">1030     struct in6_addr dest_addr;</span>
<span class="line-removed">1031     char device[16];</span>
<span class="line-removed">1032     jboolean match = JNI_FALSE;</span>
<span class="line-removed">1033 </span>
<span class="line-removed">1034     /*</span>
<span class="line-removed">1035      * Scan /proc/net/ipv6_route looking for a matching</span>
<span class="line-removed">1036      * route.</span>
<span class="line-removed">1037      */</span>
<span class="line-removed">1038     if ((f = fopen(&quot;/proc/net/ipv6_route&quot;, &quot;r&quot;)) == NULL) {</span>
<span class="line-removed">1039         return -1;</span>
<span class="line-removed">1040     }</span>
<span class="line-removed">1041     while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %02x &quot;</span>
<span class="line-removed">1042                      &quot;%4s%4s%4s%4s%4s%4s%4s%4s %02x &quot;</span>
<span class="line-removed">1043                      &quot;%4s%4s%4s%4s%4s%4s%4s%4s &quot;</span>
<span class="line-removed">1044                      &quot;%08x %08x %08x %08lx %8s&quot;,</span>
<span class="line-removed">1045                      dest_str, &amp;dest_str[5], &amp;dest_str[10], &amp;dest_str[15],</span>
<span class="line-removed">1046                      &amp;dest_str[20], &amp;dest_str[25], &amp;dest_str[30], &amp;dest_str[35],</span>
<span class="line-removed">1047                      &amp;dest_plen,</span>
<span class="line-removed">1048                      srcp[0], srcp[1], srcp[2], srcp[3],</span>
<span class="line-removed">1049                      srcp[4], srcp[5], srcp[6], srcp[7],</span>
<span class="line-removed">1050                      &amp;src_plen,</span>
<span class="line-removed">1051                      hopp[0], hopp[1], hopp[2], hopp[3],</span>
<span class="line-removed">1052                      hopp[4], hopp[5], hopp[6], hopp[7],</span>
<span class="line-removed">1053                      &amp;metric, &amp;use, &amp;refcnt, &amp;flags, device) == 31) {</span>
<span class="line-removed">1054 </span>
<span class="line-removed">1055         /*</span>
<span class="line-removed">1056          * Some routes should be ignored</span>
<span class="line-removed">1057          */</span>
<span class="line-removed">1058         if ( (dest_plen &lt; 0 || dest_plen &gt; 128)  ||</span>
<span class="line-removed">1059              (src_plen != 0) ||</span>
<span class="line-removed">1060              (flags &amp; (RTF_POLICY | RTF_FLOW)) ||</span>
<span class="line-removed">1061              ((flags &amp; RTF_REJECT) &amp;&amp; dest_plen == 0) ) {</span>
<span class="line-removed">1062             continue;</span>
<span class="line-removed">1063         }</span>
<span class="line-removed">1064 </span>
<span class="line-removed">1065         /*</span>
<span class="line-removed">1066          * Convert the destination address</span>
<span class="line-removed">1067          */</span>
<span class="line-removed">1068         dest_str[4] = &#39;:&#39;;</span>
<span class="line-removed">1069         dest_str[9] = &#39;:&#39;;</span>
<span class="line-removed">1070         dest_str[14] = &#39;:&#39;;</span>
<span class="line-removed">1071         dest_str[19] = &#39;:&#39;;</span>
<span class="line-removed">1072         dest_str[24] = &#39;:&#39;;</span>
<span class="line-removed">1073         dest_str[29] = &#39;:&#39;;</span>
<span class="line-removed">1074         dest_str[34] = &#39;:&#39;;</span>
<span class="line-removed">1075         dest_str[39] = &#39;\0&#39;;</span>
<span class="line-removed">1076 </span>
<span class="line-removed">1077         if (inet_pton(AF_INET6, dest_str, &amp;dest_addr) &lt; 0) {</span>
<span class="line-removed">1078             /* not an Ipv6 address */</span>
<span class="line-removed">1079             continue;</span>
<span class="line-removed">1080         } else {</span>
<span class="line-removed">1081             /*</span>
<span class="line-removed">1082              * The prefix len (dest_plen) indicates the number of bits we</span>
<span class="line-removed">1083              * need to match on.</span>
<span class="line-removed">1084              *</span>
<span class="line-removed">1085              * dest_plen / 8    =&gt; number of bytes to match</span>
<span class="line-removed">1086              * dest_plen % 8    =&gt; number of additional bits to match</span>
<span class="line-removed">1087              *</span>
<span class="line-removed">1088              * eg: fe80::/10 =&gt; match 1 byte + 2 additional bits in the</span>
<span class="line-removed">1089              *                  next byte.</span>
<span class="line-removed">1090              */</span>
<span class="line-removed">1091             int byte_count = dest_plen &gt;&gt; 3;</span>
<span class="line-removed">1092             int extra_bits = dest_plen &amp; 0x3;</span>
<span class="line-removed">1093 </span>
<span class="line-removed">1094             if (byte_count &gt; 0) {</span>
<span class="line-removed">1095                 if (memcmp(target_addr, &amp;dest_addr, byte_count)) {</span>
<span class="line-removed">1096                     continue;  /* no match */</span>
<span class="line-removed">1097                 }</span>
<span class="line-removed">1098             }</span>
<span class="line-removed">1099 </span>
<span class="line-removed">1100             if (extra_bits &gt; 0) {</span>
<span class="line-removed">1101                 unsigned char c1 = ((unsigned char *)target_addr)[byte_count];</span>
<span class="line-removed">1102                 unsigned char c2 = ((unsigned char *)&amp;dest_addr)[byte_count];</span>
<span class="line-removed">1103                 unsigned char mask = 0xff &lt;&lt; (8 - extra_bits);</span>
<span class="line-removed">1104                 if ((c1 &amp; mask) != (c2 &amp; mask)) {</span>
<span class="line-removed">1105                     continue;</span>
<span class="line-removed">1106                 }</span>
<span class="line-removed">1107             }</span>
<span class="line-removed">1108 </span>
<span class="line-removed">1109             /*</span>
<span class="line-removed">1110              * We have a match</span>
<span class="line-removed">1111              */</span>
<span class="line-removed">1112             match = JNI_TRUE;</span>
<span class="line-removed">1113             break;</span>
<span class="line-removed">1114         }</span>
<span class="line-removed">1115     }</span>
<span class="line-removed">1116     fclose(f);</span>
<span class="line-removed">1117 </span>
<span class="line-removed">1118     /*</span>
<span class="line-removed">1119      * If there&#39;s a match then we lookup the interface</span>
<span class="line-removed">1120      * index.</span>
<span class="line-removed">1121      */</span>
<span class="line-removed">1122     if (match) {</span>
<span class="line-removed">1123         char devname[21];</span>
<span class="line-removed">1124         char addr6p[8][5];</span>
<span class="line-removed">1125         int plen, scope, dad_status, if_idx;</span>
<span class="line-removed">1126 </span>
<span class="line-removed">1127         if ((f = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;)) != NULL) {</span>
<span class="line-removed">1128             while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\n&quot;,</span>
<span class="line-removed">1129                       addr6p[0], addr6p[1], addr6p[2], addr6p[3],</span>
<span class="line-removed">1130                       addr6p[4], addr6p[5], addr6p[6], addr6p[7],</span>
<span class="line-removed">1131                   &amp;if_idx, &amp;plen, &amp;scope, &amp;dad_status, devname) == 13) {</span>
<span class="line-removed">1132 </span>
<span class="line-removed">1133                 if (strcmp(devname, device) == 0) {</span>
<span class="line-removed">1134                     /*</span>
<span class="line-removed">1135                      * Found - so just return the index</span>
<span class="line-removed">1136                      */</span>
<span class="line-removed">1137                     fclose(f);</span>
<span class="line-removed">1138                     return if_idx;</span>
<span class="line-removed">1139                 }</span>
<span class="line-removed">1140             }</span>
<span class="line-removed">1141             fclose(f);</span>
<span class="line-removed">1142         } else {</span>
<span class="line-removed">1143             /*</span>
<span class="line-removed">1144              * Couldn&#39;t open /proc/net/if_inet6</span>
<span class="line-removed">1145              */</span>
<span class="line-removed">1146             return -1;</span>
<span class="line-removed">1147         }</span>
<span class="line-removed">1148     }</span>
<span class="line-removed">1149 </span>
<span class="line-removed">1150     /*</span>
<span class="line-removed">1151      * If we get here it means we didn&#39;t there wasn&#39;t any</span>
<span class="line-removed">1152      * route or we couldn&#39;t get the index of the interface.</span>
<span class="line-removed">1153      */</span>
<span class="line-removed">1154     return 0;</span>
<span class="line-removed">1155 }</span>
<span class="line-removed">1156 #endif</span>
<span class="line-removed">1157 </span>
<span class="line-removed">1158 </span>
1159 /*
1160  * Wrapper for getsockopt system routine - does any necessary
1161  * pre/post processing to deal with OS specific oddities :-
1162  *
1163  * On Linux the SO_SNDBUF/SO_RCVBUF values must be post-processed
1164  * to compensate for an incorrect value returned by the kernel.
1165  */
1166 int
1167 NET_GetSockOpt(int fd, int level, int opt, void *result,
1168                int *len)
1169 {
1170     int rv;
1171     socklen_t socklen = *len;
1172 
1173     rv = getsockopt(fd, level, opt, result, &amp;socklen);
1174     *len = socklen;
1175 
1176     if (rv &lt; 0) {
1177         return rv;
1178     }
</pre>
</td>
<td>
<hr />
<pre>
  56 #include &quot;java_net_InetAddress.h&quot;
  57 
  58 #if defined(__linux__) &amp;&amp; !defined(IPV6_FLOWINFO_SEND)
  59 #define IPV6_FLOWINFO_SEND      33
  60 #endif
  61 
  62 #if defined(__solaris__) &amp;&amp; !defined(MAXINT)
  63 #define MAXINT INT_MAX
  64 #endif
  65 
  66 /*
  67  * EXCLBIND socket options only on Solaris
  68  */
  69 #if defined(__solaris__) &amp;&amp; !defined(TCP_EXCLBIND)
  70 #define TCP_EXCLBIND            0x21
  71 #endif
  72 #if defined(__solaris__) &amp;&amp; !defined(UDP_EXCLBIND)
  73 #define UDP_EXCLBIND            0x0101
  74 #endif
  75 












































  76 #define RESTARTABLE(_cmd, _result) do { \
  77     do { \
  78         _result = _cmd; \
  79     } while((_result == -1) &amp;&amp; (errno == EINTR)); \
  80 } while(0)
  81 
  82 int NET_SocketAvailable(int s, int *pbytes) {
  83     int result;
  84     RESTARTABLE(ioctl(s, FIONREAD, pbytes), result);
  85     return result;
  86 }
  87 
  88 #ifdef __solaris__
  89 static int init_tcp_max_buf, init_udp_max_buf;
  90 static int tcp_max_buf;
  91 static int udp_max_buf;
  92 static int useExclBind = 0;
  93 
  94 /*
  95  * Get the specified parameter from the specified driver. The value
</pre>
<hr />
<pre>
 156         a = initial_guess;
 157     } else {
 158         FAIL_IF_NOT_ENOBUFS;
 159         b = initial_guess - 1;
 160     }
 161     do {
 162         int mid = a + (b-a)/2;
 163         if (setsockopt(fd, SOL_SOCKET, opt, &amp;mid, sizeof(int)) == 0) {
 164             limit = mid;
 165             a = mid + 1;
 166         } else {
 167             FAIL_IF_NOT_ENOBUFS;
 168             b = mid - 1;
 169         }
 170     } while (b &gt;= a);
 171 
 172     return limit;
 173 }
 174 #endif
 175 




















 176 void
 177 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
 178                    const char *defaultDetail) {
 179     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
 180 }
 181 
 182 void
 183 NET_ThrowCurrent(JNIEnv *env, char *msg) {
 184     NET_ThrowNew(env, errno, msg);
 185 }
 186 
 187 void
 188 NET_ThrowNew(JNIEnv *env, int errorNumber, char *msg) {
 189     char fullMsg[512];
 190     if (!msg) {
 191         msg = &quot;no further information&quot;;
 192     }
 193     switch(errorNumber) {
 194     case EBADF:
 195         jio_snprintf(fullMsg, sizeof(fullMsg), &quot;socket closed: %s&quot;, msg);
</pre>
<hr />
<pre>
 197         break;
 198     case EINTR:
 199         JNU_ThrowByName(env, JNU_JAVAIOPKG &quot;InterruptedIOException&quot;, msg);
 200         break;
 201     default:
 202         errno = errorNumber;
 203         JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG &quot;SocketException&quot;, msg);
 204         break;
 205     }
 206 }
 207 
 208 
 209 jfieldID
 210 NET_GetFileDescriptorID(JNIEnv *env)
 211 {
 212     jclass cls = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;);
 213     CHECK_NULL_RETURN(cls, NULL);
 214     return (*env)-&gt;GetFieldID(env, cls, &quot;fd&quot;, &quot;I&quot;);
 215 }
 216 
<span class="line-added"> 217 jint  IPv4_supported()</span>
<span class="line-added"> 218 {</span>
<span class="line-added"> 219     int fd = socket(AF_INET, SOCK_STREAM, 0) ;</span>
<span class="line-added"> 220     if (fd &lt; 0) {</span>
<span class="line-added"> 221         return JNI_FALSE;</span>
<span class="line-added"> 222     }</span>
<span class="line-added"> 223     close(fd);</span>
<span class="line-added"> 224     return JNI_TRUE;</span>
<span class="line-added"> 225 }</span>
<span class="line-added"> 226 </span>
 227 #if defined(DONT_ENABLE_IPV6)
 228 jint  IPv6_supported()
 229 {
 230     return JNI_FALSE;
 231 }
 232 
 233 #else /* !DONT_ENABLE_IPV6 */
 234 
 235 jint  IPv6_supported()
 236 {
 237     int fd;
 238     void *ipv6_fn;
 239     SOCKETADDRESS sa;
 240     socklen_t sa_len = sizeof(SOCKETADDRESS);
 241 
 242     fd = socket(AF_INET6, SOCK_STREAM, 0) ;
 243     if (fd &lt; 0) {
 244         /*
 245          *  TODO: We really cant tell since it may be an unrelated error
 246          *  for now we will assume that AF_INET6 is not available
</pre>
<hr />
<pre>
 371     if (error_string == NULL)
 372         error_string = &quot;unknown error&quot;;
 373 
 374     size = strlen(format) + strlen(hostname) + strlen(error_string) + 2;
 375     buf = (char *) malloc(size);
 376     if (buf) {
 377         jstring s;
 378         sprintf(buf, format, hostname, error_string);
 379         s = JNU_NewStringPlatform(env, buf);
 380         if (s != NULL) {
 381             jobject x = JNU_NewObjectByName(env,
 382                                             &quot;java/net/UnknownHostException&quot;,
 383                                             &quot;(Ljava/lang/String;)V&quot;, s);
 384             if (x != NULL)
 385                 (*env)-&gt;Throw(env, x);
 386         }
 387         free(buf);
 388     }
 389 }
 390 
<span class="line-modified"> 391 #if defined(_AIX)</span>






















































































































































































































































































 392 
 393 /* Initialize stubs for blocking I/O workarounds (see src/solaris/native/java/net/linux_close.c) */
 394 extern void aix_close_init();
 395 
 396 void platformInit () {
 397     aix_close_init();
 398 }
 399 
 400 #else
 401 
 402 void platformInit () {}
 403 
 404 #endif
 405 
 406 void parseExclusiveBindProperty(JNIEnv *env) {
 407 #ifdef __solaris__
 408     jstring s, flagSet;
 409     jclass iCls;
 410     jmethodID mid;
 411 
</pre>
<hr />
<pre>
 457                  * caddr[10] = 0xff;
 458                  * caddr[11] = 0xff; */
 459             } else {
 460                 caddr[10] = 0xff;
 461                 caddr[11] = 0xff;
 462                 caddr[12] = ((address &gt;&gt; 24) &amp; 0xff);
 463                 caddr[13] = ((address &gt;&gt; 16) &amp; 0xff);
 464                 caddr[14] = ((address &gt;&gt; 8) &amp; 0xff);
 465                 caddr[15] = (address &amp; 0xff);
 466             }
 467         } else {
 468             getInet6Address_ipaddress(env, iaObj, (char *)caddr);
 469         }
 470         sa-&gt;sa6.sin6_port = htons(port);
 471         memcpy((void *)&amp;sa-&gt;sa6.sin6_addr, caddr, sizeof(struct in6_addr));
 472         sa-&gt;sa6.sin6_family = AF_INET6;
 473         if (len != NULL) {
 474             *len = sizeof(struct sockaddr_in6);
 475         }
 476 


























































 477         /* handle scope_id */
 478         if (family != java_net_InetAddress_IPv4) {
 479             if (ia6_scopeidID) {
 480                 sa-&gt;sa6.sin6_scope_id = getInet6Address_scopeid(env, iaObj);
 481             }
 482         }

 483     } else {
 484         jint address;
 485         if (family != java_net_InetAddress_IPv4) {
 486             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Protocol family unavailable&quot;);
 487             return -1;
 488         }
 489         address = getInetAddress_addr(env, iaObj);
 490         JNU_CHECK_EXCEPTION_RETURN(env, -1);
 491         sa-&gt;sa4.sin_port = htons(port);
 492         sa-&gt;sa4.sin_addr.s_addr = htonl(address);
 493         sa-&gt;sa4.sin_family = AF_INET;
 494         if (len != NULL) {
 495             *len = sizeof(struct sockaddr_in);
 496         }
 497     }
 498     return 0;
 499 }
 500 
 501 void
 502 NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass) {
</pre>
<hr />
<pre>
 596                 return 0;
 597 #endif
 598         }
 599     }
 600 
 601     /*
 602      * Map the Java level option to the native level
 603      */
 604     for (i=0; i&lt;(int)(sizeof(opts) / sizeof(opts[0])); i++) {
 605         if (cmd == opts[i].cmd) {
 606             *level = opts[i].level;
 607             *optname = opts[i].optname;
 608             return 0;
 609         }
 610     }
 611 
 612     /* not found */
 613     return -1;
 614 }
 615 
























































































































































 616 /*
 617  * Wrapper for getsockopt system routine - does any necessary
 618  * pre/post processing to deal with OS specific oddities :-
 619  *
 620  * On Linux the SO_SNDBUF/SO_RCVBUF values must be post-processed
 621  * to compensate for an incorrect value returned by the kernel.
 622  */
 623 int
 624 NET_GetSockOpt(int fd, int level, int opt, void *result,
 625                int *len)
 626 {
 627     int rv;
 628     socklen_t socklen = *len;
 629 
 630     rv = getsockopt(fd, level, opt, result, &amp;socklen);
 631     *len = socklen;
 632 
 633     if (rv &lt; 0) {
 634         return rv;
 635     }
</pre>
</td>
</tr>
</table>
<center><a href="PlainSocketImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="net_util_md.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
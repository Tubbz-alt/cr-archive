<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libnet/NetworkInterface.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Inet6AddressImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PlainDatagramSocketImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libnet/NetworkInterface.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;arpa/inet.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #include &lt;net/if_arp.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;string.h&gt;
  31 #include &lt;sys/ioctl.h&gt;
  32 
  33 #if defined(_AIX)
  34 #include &lt;netinet/in6_var.h&gt;
  35 #include &lt;sys/ndd_var.h&gt;
  36 #include &lt;sys/kinfo.h&gt;

  37 #endif
  38 
  39 #if defined(__solaris__)
  40 #include &lt;stropts.h&gt;
  41 #include &lt;sys/dlpi.h&gt;
  42 #include &lt;sys/sockio.h&gt;
  43 #endif
  44 
  45 #if defined(_ALLBSD_SOURCE)
  46 #include &lt;net/ethernet.h&gt;
  47 #include &lt;net/if_dl.h&gt;
  48 #include &lt;ifaddrs.h&gt;
  49 #endif
  50 
  51 #include &quot;net_util.h&quot;
  52 
  53 #include &quot;java_net_InetAddress.h&quot;
  54 
  55 #if defined(__linux__)
  56     #define _PATH_PROCNET_IFINET6 &quot;/proc/net/if_inet6&quot;
</pre>
<hr />
<pre>
 221     const char* name_utf;
 222     char *colonP;
 223     char searchName[IFNAMESIZE];
 224     jobject obj = NULL;
 225 
 226     if (name != NULL) {
 227         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 228     } else {
 229         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 230         return NULL;
 231     }
 232 
 233     if (name_utf == NULL) {
 234         if (!(*env)-&gt;ExceptionCheck(env))
 235             JNU_ThrowOutOfMemoryError(env, NULL);
 236         return NULL;
 237     }
 238 
 239     ifs = enumInterfaces(env);
 240     if (ifs == NULL) {

 241         return NULL;
 242     }
 243 
 244     // search the list of interfaces based on name,
 245     // if it is virtual sub interface search with parent first.
 246     strncpy(searchName, name_utf, IFNAMESIZE);
 247     searchName[IFNAMESIZE - 1] = &#39;\0&#39;;
 248     colonP = strchr(searchName, &#39;:&#39;);
 249     if (colonP != NULL) {
 250         *colonP = &#39;\0&#39;;
 251     }
 252     curr = ifs;
 253     while (curr != NULL) {
 254         if (strcmp(searchName, curr-&gt;name) == 0) {
 255             break;
 256         }
 257         curr = curr-&gt;next;
 258     }
 259 
 260     // search the child list
</pre>
<hr />
<pre>
 303     // search the list of interfaces based on index
 304     curr = ifs;
 305     while (curr != NULL) {
 306         if (index == curr-&gt;index) {
 307             break;
 308         }
 309         curr = curr-&gt;next;
 310     }
 311 
 312     // if found create a NetworkInterface
 313     if (curr != NULL) {
 314         obj = createNetworkInterface(env, curr);
 315     }
 316 
 317     // release the interface list
 318     freeif(ifs);
 319 
 320     return obj;
 321 }
 322 
<span class="line-modified"> 323 /*</span>
<span class="line-modified"> 324  * Class:     java_net_NetworkInterface</span>
<span class="line-modified"> 325  * Method:    getByInetAddress0</span>
<span class="line-removed"> 326  * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;</span>
<span class="line-removed"> 327  */</span>
<span class="line-removed"> 328 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0</span>
<span class="line-removed"> 329   (JNIEnv *env, jclass cls, jobject iaObj)</span>
<span class="line-removed"> 330 {</span>
<span class="line-removed"> 331     netif *ifs, *curr;</span>
<span class="line-removed"> 332     jobject obj = NULL;</span>
<span class="line-removed"> 333     jboolean match = JNI_FALSE;</span>
<span class="line-removed"> 334     int family = getInetAddress_family(env, iaObj);</span>
<span class="line-removed"> 335     JNU_CHECK_EXCEPTION_RETURN(env, NULL);</span>
<span class="line-removed"> 336 </span>
<span class="line-removed"> 337     if (family == java_net_InetAddress_IPv4) {</span>
<span class="line-removed"> 338         family = AF_INET;</span>
<span class="line-removed"> 339     } else if (family == java_net_InetAddress_IPv6) {</span>
<span class="line-removed"> 340         family = AF_INET6;</span>
<span class="line-removed"> 341     } else {</span>
<span class="line-removed"> 342         return NULL; // Invalid family</span>
<span class="line-removed"> 343     }</span>
<span class="line-removed"> 344     ifs = enumInterfaces(env);</span>
<span class="line-removed"> 345     if (ifs == NULL) {</span>
<span class="line-removed"> 346         return NULL;</span>
<span class="line-removed"> 347     }</span>
<span class="line-removed"> 348 </span>
<span class="line-removed"> 349     curr = ifs;</span>
 350     while (curr != NULL) {
 351         netaddr *addrP = curr-&gt;addr;
 352 
 353         // iterate through each address on the interface
 354         while (addrP != NULL) {
 355 
 356             if (family == addrP-&gt;family) {
 357                 if (family == AF_INET) {
 358                     int address1 = htonl(
 359                         ((struct sockaddr_in *)addrP-&gt;addr)-&gt;sin_addr.s_addr);
 360                     int address2 = getInetAddress_addr(env, iaObj);
 361                     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 362                         goto cleanup;</span>
 363                     }
 364                     if (address1 == address2) {
<span class="line-modified"> 365                         match = JNI_TRUE;</span>
<span class="line-removed"> 366                         break;</span>
 367                     }
 368                 } else if (family == AF_INET6) {
 369                     jbyte *bytes = (jbyte *)&amp;(
 370                         ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_addr);
 371                     jbyte caddr[16];
 372                     int i;
 373                     unsigned int scopeid;
 374                     getInet6Address_ipaddress(env, iaObj, (char *)caddr);
 375                     scopeid = (unsigned int)getInet6Address_scopeid(env, iaObj);
 376                     if (scopeid != 0 &amp;&amp; scopeid != ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_scope_id)
 377                         break;
 378                     i = 0;
 379                     while (i &lt; 16) {
 380                         if (caddr[i] != bytes[i]) {
 381                             break;
 382                         }
 383                         i++;
 384                     }
 385                     if (i &gt;= 16) {
<span class="line-modified"> 386                         match = JNI_TRUE;</span>
<span class="line-removed"> 387                         break;</span>
 388                     }
 389                 }
 390             }
 391 
<span class="line-removed"> 392             if (match) {</span>
<span class="line-removed"> 393                 break;</span>
<span class="line-removed"> 394             }</span>
 395             addrP = addrP-&gt;next;
 396         }


 397 
<span class="line-modified"> 398         if (match) {</span>
<span class="line-modified"> 399             break;</span>




























 400         }
<span class="line-modified"> 401         curr = curr-&gt;next;</span>





























 402     }
 403 

































 404     // if found create a NetworkInterface
<span class="line-modified"> 405     if (match) {</span>
 406         obj = createNetworkInterface(env, curr);
 407     }
 408 
<span class="line-removed"> 409 cleanup:</span>
 410     // release the interface list
 411     freeif(ifs);
 412 
 413     return obj;
 414 }
 415 
 416 /*
 417  * Class:     java_net_NetworkInterface
 418  * Method:    getAll
 419  * Signature: ()[Ljava/net/NetworkInterface;
 420  */
 421 JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll
 422   (JNIEnv *env, jclass cls)
 423 {
 424     netif *ifs, *curr;
 425     jobjectArray netIFArr;
 426     jint arr_index, ifCount;
 427 
 428     ifs = enumInterfaces(env);
 429     if (ifs == NULL) {
</pre>
<hr />
<pre>
 790         (*env)-&gt;SetObjectField(env, tmp, ni_parentID, netifObj);
 791         (*env)-&gt;SetObjectArrayElement(env, childArr, child_index++, tmp);
 792         childP = childP-&gt;next;
 793     }
 794     (*env)-&gt;SetObjectField(env, netifObj, ni_addrsID, addrArr);
 795     (*env)-&gt;SetObjectField(env, netifObj, ni_bindsID, bindArr);
 796     (*env)-&gt;SetObjectField(env, netifObj, ni_childsID, childArr);
 797 
 798     // return the NetworkInterface
 799     return netifObj;
 800 }
 801 
 802 /*
 803  * Enumerates all interfaces
 804  */
 805 static netif *enumInterfaces(JNIEnv *env) {
 806     netif *ifs = NULL;
 807     int sock;
 808 
 809     sock = openSocket(env, AF_INET);
<span class="line-modified"> 810     if (sock &lt; 0) {</span>
 811         return NULL;
 812     }
 813 
 814     // enumerate IPv4 addresses
<span class="line-modified"> 815     ifs = enumIPv4Interfaces(env, sock, NULL);</span>
<span class="line-modified"> 816     close(sock);</span>

 817 
<span class="line-modified"> 818     // return partial list if an exception occurs in the middle of process ???</span>
<span class="line-modified"> 819     if (ifs == NULL &amp;&amp; (*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-modified"> 820         return NULL;</span>

 821     }
 822 
 823     // If IPv6 is available then enumerate IPv6 addresses.
 824     // User can disable ipv6 explicitly by -Djava.net.preferIPv4Stack=true,
 825     // so we have to call ipv6_available()
 826     if (ipv6_available()) {
 827         sock = openSocket(env, AF_INET6);
 828         if (sock &lt; 0) {
 829             freeif(ifs);
 830             return NULL;
 831         }
 832 
 833         ifs = enumIPv6Interfaces(env, sock, ifs);
 834         close(sock);
 835 
 836         if ((*env)-&gt;ExceptionOccurred(env)) {
 837             freeif(ifs);
 838             return NULL;
 839         }
 840     }
</pre>
<hr />
<pre>
1059         if (prefix &gt; 0) {
1060             byte++;
1061             for (; byte &lt; sizeof(struct in6_addr); byte++) {
1062                 if (addrBytes[byte]) {
1063                     prefix = 0;
1064                 }
1065             }
1066         }
1067     }
1068 
1069     return prefix;
1070 }
1071 
1072 /*
1073  * Opens a socket for further ioct calls. proto is one of AF_INET or AF_INET6.
1074  */
1075 static int openSocket(JNIEnv *env, int proto) {
1076     int sock;
1077 
1078     if ((sock = socket(proto, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">1079         // If EPROTONOSUPPORT is returned it means we don&#39;t have</span>
<span class="line-modified">1080         // support for this proto so don&#39;t throw an exception.</span>
<span class="line-modified">1081         if (errno != EPROTONOSUPPORT) {</span>
1082             JNU_ThrowByNameWithMessageAndLastError
1083                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Socket creation failed&quot;);
1084         }
1085         return -1;
1086     }
1087 
1088     return sock;
1089 }
1090 
1091 /** Linux **/
1092 #if defined(__linux__)
1093 
1094 /*
1095  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1096  * if it fails return AF_INET6 socket.
1097  */
1098 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1099     int sock;
1100 
1101     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">1102         if (errno == EPROTONOSUPPORT) {</span>
1103             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1104                 JNU_ThrowByNameWithMessageAndLastError
1105                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1106                 return -1;
1107             }
1108         } else { // errno is not NOSUPPORT
1109             JNU_ThrowByNameWithMessageAndLastError
1110                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1111             return -1;
1112         }
1113     }
1114 
1115     // Linux starting from 2.6.? kernel allows ioctl call with either IPv4 or
1116     // IPv6 socket regardless of type of address of an interface.
1117     return sock;
1118 }
1119 
1120 /*
1121  * Enumerates and returns all IPv4 interfaces on Linux.
1122  */
</pre>
<hr />
<pre>
1311     memset((char *)&amp;if2, 0, sizeof(if2));
1312     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1313 
1314     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1315         return -1;
1316     }
1317 
1318     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1319         *flags = (if2.ifr_flags &amp; 0xffff);
1320     } else {
1321         *flags = if2.ifr_flags;
1322     }
1323     return 0;
1324 }
1325 
1326 #endif /* __linux__ */
1327 
1328 /** AIX **/
1329 #if defined(_AIX)
1330 




1331 /*
1332  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1333  * if it fails return AF_INET6 socket.
1334  */
1335 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1336     int sock;
1337 
1338     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">1339         if (errno == EPROTONOSUPPORT) {</span>
1340             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1341                 JNU_ThrowByNameWithMessageAndLastError
1342                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1343                 return -1;
1344             }
1345         } else { // errno is not NOSUPPORT
1346             JNU_ThrowByNameWithMessageAndLastError
1347                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1348             return -1;
1349         }
1350     }
1351 
1352     return sock;
1353 }
1354 
1355 /*
1356  * Enumerates and returns all IPv4 interfaces on AIX.
1357  */
1358 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1359     struct ifconf ifc;
</pre>
<hr />
<pre>
1530     void *end;
1531 
1532     size = getkerninfo(KINFO_NDD, 0, 0, 0);
1533     if (size == 0) {
1534         return -1;
1535     }
1536 
1537     if (size &lt; 0) {
1538         perror(&quot;getkerninfo 1&quot;);
1539         return -1;
1540     }
1541 
1542     nddp = (struct kinfo_ndd *)malloc(size);
1543 
1544     if (!nddp) {
1545         JNU_ThrowOutOfMemoryError(env,
1546             &quot;Network interface getMacAddress native buffer allocation failed&quot;);
1547         return -1;
1548     }
1549 
<span class="line-modified">1550     if (getkerninfo(KINFO_NDD, nddp, &amp;size, 0) &lt; 0) {</span>
1551         perror(&quot;getkerninfo 2&quot;);
1552         free(nddp);
1553         return -1;
1554     }
1555 
1556     end = (void *)nddp + size;
1557     while ((void *)nddp &lt; end) {
1558         if (!strcmp(nddp-&gt;ndd_alias, ifname) ||
1559                  !strcmp(nddp-&gt;ndd_name, ifname)) {
1560             bcopy(nddp-&gt;ndd_addr, buf, 6);
1561             free(nddp);
1562             return 6;
1563         } else {
1564             nddp++;
1565         }
1566     }
1567 
1568     free(nddp);
1569     return -1;
1570 }
</pre>
<hr />
<pre>
1597     } else {
1598         *flags = if2.ifr_flags;
1599     }
1600     return 0;
1601 }
1602 
1603 #endif /* _AIX */
1604 
1605 /** Solaris **/
1606 #if defined(__solaris__)
1607 
1608 /*
1609  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1610  * if it fails return AF_INET6 socket.
1611  */
1612 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1613     int sock, alreadyV6 = 0;
1614     struct lifreq if2;
1615 
1616     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">1617         if (errno == EPROTONOSUPPORT) {</span>
1618             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1619                 JNU_ThrowByNameWithMessageAndLastError
1620                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1621                 return -1;
1622             }
1623             alreadyV6 = 1;
1624         } else { // errno is not NOSUPPORT
1625             JNU_ThrowByNameWithMessageAndLastError
1626                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1627             return -1;
1628         }
1629     }
1630 
1631     // Solaris requires that we have an IPv6 socket to query an  interface
1632     // without an IPv4 address - check it here. POSIX 1 require the kernel to
1633     // return ENOTTY if the call is inappropriate for a device e.g. the NETMASK
1634     // for a device having IPv6 only address but not all devices follow the
1635     // standard so fall back on any error. It&#39;s not an ecologically friendly
1636     // gesture but more reliable.
1637     if (!alreadyV6) {
</pre>
<hr />
<pre>
1948         return -1;
1949     }
1950 
1951     *flags = if2.lifr_flags;
1952     return 0;
1953 }
1954 
1955 #endif /* __solaris__ */
1956 
1957 /** BSD **/
1958 #if defined(_ALLBSD_SOURCE)
1959 
1960 /*
1961  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1962  * if it fails return AF_INET6 socket.
1963  */
1964 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1965     int sock;
1966 
1967     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">1968         if (errno == EPROTONOSUPPORT) {</span>
1969             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1970                 JNU_ThrowByNameWithMessageAndLastError
1971                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1972                 return -1;
1973             }
1974         } else { // errno is not NOSUPPORT
1975             JNU_ThrowByNameWithMessageAndLastError
1976                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1977             return -1;
1978         }
1979     }
1980 
1981     return sock;
1982 }
1983 
1984 /*
1985  * Enumerates and returns all IPv4 interfaces on BSD.
1986  */
1987 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1988     struct ifaddrs *ifa, *origifa;
</pre>
</td>
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;arpa/inet.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #include &lt;net/if_arp.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;string.h&gt;
  31 #include &lt;sys/ioctl.h&gt;
  32 
  33 #if defined(_AIX)
  34 #include &lt;netinet/in6_var.h&gt;
  35 #include &lt;sys/ndd_var.h&gt;
  36 #include &lt;sys/kinfo.h&gt;
<span class="line-added">  37 #include &lt;strings.h&gt;</span>
  38 #endif
  39 
  40 #if defined(__solaris__)
  41 #include &lt;stropts.h&gt;
  42 #include &lt;sys/dlpi.h&gt;
  43 #include &lt;sys/sockio.h&gt;
  44 #endif
  45 
  46 #if defined(_ALLBSD_SOURCE)
  47 #include &lt;net/ethernet.h&gt;
  48 #include &lt;net/if_dl.h&gt;
  49 #include &lt;ifaddrs.h&gt;
  50 #endif
  51 
  52 #include &quot;net_util.h&quot;
  53 
  54 #include &quot;java_net_InetAddress.h&quot;
  55 
  56 #if defined(__linux__)
  57     #define _PATH_PROCNET_IFINET6 &quot;/proc/net/if_inet6&quot;
</pre>
<hr />
<pre>
 222     const char* name_utf;
 223     char *colonP;
 224     char searchName[IFNAMESIZE];
 225     jobject obj = NULL;
 226 
 227     if (name != NULL) {
 228         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 229     } else {
 230         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 231         return NULL;
 232     }
 233 
 234     if (name_utf == NULL) {
 235         if (!(*env)-&gt;ExceptionCheck(env))
 236             JNU_ThrowOutOfMemoryError(env, NULL);
 237         return NULL;
 238     }
 239 
 240     ifs = enumInterfaces(env);
 241     if (ifs == NULL) {
<span class="line-added"> 242         (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);</span>
 243         return NULL;
 244     }
 245 
 246     // search the list of interfaces based on name,
 247     // if it is virtual sub interface search with parent first.
 248     strncpy(searchName, name_utf, IFNAMESIZE);
 249     searchName[IFNAMESIZE - 1] = &#39;\0&#39;;
 250     colonP = strchr(searchName, &#39;:&#39;);
 251     if (colonP != NULL) {
 252         *colonP = &#39;\0&#39;;
 253     }
 254     curr = ifs;
 255     while (curr != NULL) {
 256         if (strcmp(searchName, curr-&gt;name) == 0) {
 257             break;
 258         }
 259         curr = curr-&gt;next;
 260     }
 261 
 262     // search the child list
</pre>
<hr />
<pre>
 305     // search the list of interfaces based on index
 306     curr = ifs;
 307     while (curr != NULL) {
 308         if (index == curr-&gt;index) {
 309             break;
 310         }
 311         curr = curr-&gt;next;
 312     }
 313 
 314     // if found create a NetworkInterface
 315     if (curr != NULL) {
 316         obj = createNetworkInterface(env, curr);
 317     }
 318 
 319     // release the interface list
 320     freeif(ifs);
 321 
 322     return obj;
 323 }
 324 
<span class="line-modified"> 325 // Return the interface in ifs that iaObj is bound to, if any - otherwise NULL</span>
<span class="line-modified"> 326 static netif* find_bound_interface(JNIEnv *env, netif* ifs, jobject iaObj, int family) {</span>
<span class="line-modified"> 327     netif* curr = ifs;</span>
























 328     while (curr != NULL) {
 329         netaddr *addrP = curr-&gt;addr;
 330 
 331         // iterate through each address on the interface
 332         while (addrP != NULL) {
 333 
 334             if (family == addrP-&gt;family) {
 335                 if (family == AF_INET) {
 336                     int address1 = htonl(
 337                         ((struct sockaddr_in *)addrP-&gt;addr)-&gt;sin_addr.s_addr);
 338                     int address2 = getInetAddress_addr(env, iaObj);
 339                     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 340                         return NULL;</span>
 341                     }
 342                     if (address1 == address2) {
<span class="line-modified"> 343                         return curr;</span>

 344                     }
 345                 } else if (family == AF_INET6) {
 346                     jbyte *bytes = (jbyte *)&amp;(
 347                         ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_addr);
 348                     jbyte caddr[16];
 349                     int i;
 350                     unsigned int scopeid;
 351                     getInet6Address_ipaddress(env, iaObj, (char *)caddr);
 352                     scopeid = (unsigned int)getInet6Address_scopeid(env, iaObj);
 353                     if (scopeid != 0 &amp;&amp; scopeid != ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_scope_id)
 354                         break;
 355                     i = 0;
 356                     while (i &lt; 16) {
 357                         if (caddr[i] != bytes[i]) {
 358                             break;
 359                         }
 360                         i++;
 361                     }
 362                     if (i &gt;= 16) {
<span class="line-modified"> 363                         return curr;</span>

 364                     }
 365                 }
 366             }
 367 



 368             addrP = addrP-&gt;next;
 369         }
<span class="line-added"> 370         curr = curr-&gt;next;</span>
<span class="line-added"> 371     }</span>
 372 
<span class="line-modified"> 373     return NULL;</span>
<span class="line-modified"> 374 }</span>
<span class="line-added"> 375 </span>
<span class="line-added"> 376 /*</span>
<span class="line-added"> 377  * Class:     java_net_NetworkInterface</span>
<span class="line-added"> 378  * Method:    boundInetAddress0</span>
<span class="line-added"> 379  * Signature: (Ljava/net/InetAddress;)boundInetAddress;</span>
<span class="line-added"> 380  */</span>
<span class="line-added"> 381 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0</span>
<span class="line-added"> 382     (JNIEnv *env, jclass cls, jobject iaObj)</span>
<span class="line-added"> 383 {</span>
<span class="line-added"> 384     netif *ifs = NULL;</span>
<span class="line-added"> 385     jboolean bound = JNI_FALSE;</span>
<span class="line-added"> 386     int sock;</span>
<span class="line-added"> 387 </span>
<span class="line-added"> 388     int family = getInetAddress_family(env, iaObj);</span>
<span class="line-added"> 389     JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);</span>
<span class="line-added"> 390 </span>
<span class="line-added"> 391     if (family == java_net_InetAddress_IPv4) {</span>
<span class="line-added"> 392         family = AF_INET;</span>
<span class="line-added"> 393     } else if (family == java_net_InetAddress_IPv6) {</span>
<span class="line-added"> 394         family = AF_INET6;</span>
<span class="line-added"> 395     } else {</span>
<span class="line-added"> 396         return JNI_FALSE; // Invalid family</span>
<span class="line-added"> 397     }</span>
<span class="line-added"> 398 </span>
<span class="line-added"> 399     if (family == AF_INET) {</span>
<span class="line-added"> 400         sock = openSocket(env, AF_INET);</span>
<span class="line-added"> 401         if (sock &lt; 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-added"> 402             return JNI_FALSE;</span>
 403         }
<span class="line-modified"> 404 </span>
<span class="line-added"> 405         // enumerate IPv4 addresses</span>
<span class="line-added"> 406         if (sock &gt;= 0) {</span>
<span class="line-added"> 407             ifs = enumIPv4Interfaces(env, sock, ifs);</span>
<span class="line-added"> 408             close(sock);</span>
<span class="line-added"> 409 </span>
<span class="line-added"> 410             if ((*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-added"> 411                 goto cleanup;</span>
<span class="line-added"> 412             }</span>
<span class="line-added"> 413         }</span>
<span class="line-added"> 414         if (find_bound_interface(env, ifs, iaObj, family) != NULL)</span>
<span class="line-added"> 415             bound = JNI_TRUE;</span>
<span class="line-added"> 416     } else if (ipv6_available()) {</span>
<span class="line-added"> 417         // If IPv6 is available then enumerate IPv6 addresses.</span>
<span class="line-added"> 418         // User can disable ipv6 explicitly by -Djava.net.preferIPv4Stack=true,</span>
<span class="line-added"> 419         // so we have to call ipv6_available()</span>
<span class="line-added"> 420         sock = openSocket(env, AF_INET6);</span>
<span class="line-added"> 421         if (sock &lt; 0) {</span>
<span class="line-added"> 422             return JNI_FALSE;</span>
<span class="line-added"> 423         }</span>
<span class="line-added"> 424 </span>
<span class="line-added"> 425         ifs = enumIPv6Interfaces(env, sock, ifs);</span>
<span class="line-added"> 426         close(sock);</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428         if ((*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-added"> 429             goto cleanup;</span>
<span class="line-added"> 430         }</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432         if (find_bound_interface(env, ifs, iaObj, family) != NULL)</span>
<span class="line-added"> 433             bound = JNI_TRUE;</span>
 434     }
 435 
<span class="line-added"> 436 cleanup:</span>
<span class="line-added"> 437     freeif(ifs);</span>
<span class="line-added"> 438 </span>
<span class="line-added"> 439     return bound;</span>
<span class="line-added"> 440 }</span>
<span class="line-added"> 441 </span>
<span class="line-added"> 442 /*</span>
<span class="line-added"> 443  * Class:     java_net_NetworkInterface</span>
<span class="line-added"> 444  * Method:    getByInetAddress0</span>
<span class="line-added"> 445  * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;</span>
<span class="line-added"> 446  */</span>
<span class="line-added"> 447 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0</span>
<span class="line-added"> 448   (JNIEnv *env, jclass cls, jobject iaObj)</span>
<span class="line-added"> 449 {</span>
<span class="line-added"> 450     netif *ifs, *curr;</span>
<span class="line-added"> 451     jobject obj = NULL;</span>
<span class="line-added"> 452     int family = getInetAddress_family(env, iaObj);</span>
<span class="line-added"> 453     JNU_CHECK_EXCEPTION_RETURN(env, NULL);</span>
<span class="line-added"> 454 </span>
<span class="line-added"> 455     if (family == java_net_InetAddress_IPv4) {</span>
<span class="line-added"> 456         family = AF_INET;</span>
<span class="line-added"> 457     } else if (family == java_net_InetAddress_IPv6) {</span>
<span class="line-added"> 458         family = AF_INET6;</span>
<span class="line-added"> 459     } else {</span>
<span class="line-added"> 460         return NULL; // Invalid family</span>
<span class="line-added"> 461     }</span>
<span class="line-added"> 462     ifs = enumInterfaces(env);</span>
<span class="line-added"> 463     if (ifs == NULL) {</span>
<span class="line-added"> 464         return NULL;</span>
<span class="line-added"> 465     }</span>
<span class="line-added"> 466 </span>
<span class="line-added"> 467     curr = find_bound_interface(env, ifs, iaObj, family);</span>
<span class="line-added"> 468 </span>
 469     // if found create a NetworkInterface
<span class="line-modified"> 470     if (curr != NULL) {</span>
 471         obj = createNetworkInterface(env, curr);
 472     }
 473 

 474     // release the interface list
 475     freeif(ifs);
 476 
 477     return obj;
 478 }
 479 
 480 /*
 481  * Class:     java_net_NetworkInterface
 482  * Method:    getAll
 483  * Signature: ()[Ljava/net/NetworkInterface;
 484  */
 485 JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll
 486   (JNIEnv *env, jclass cls)
 487 {
 488     netif *ifs, *curr;
 489     jobjectArray netIFArr;
 490     jint arr_index, ifCount;
 491 
 492     ifs = enumInterfaces(env);
 493     if (ifs == NULL) {
</pre>
<hr />
<pre>
 854         (*env)-&gt;SetObjectField(env, tmp, ni_parentID, netifObj);
 855         (*env)-&gt;SetObjectArrayElement(env, childArr, child_index++, tmp);
 856         childP = childP-&gt;next;
 857     }
 858     (*env)-&gt;SetObjectField(env, netifObj, ni_addrsID, addrArr);
 859     (*env)-&gt;SetObjectField(env, netifObj, ni_bindsID, bindArr);
 860     (*env)-&gt;SetObjectField(env, netifObj, ni_childsID, childArr);
 861 
 862     // return the NetworkInterface
 863     return netifObj;
 864 }
 865 
 866 /*
 867  * Enumerates all interfaces
 868  */
 869 static netif *enumInterfaces(JNIEnv *env) {
 870     netif *ifs = NULL;
 871     int sock;
 872 
 873     sock = openSocket(env, AF_INET);
<span class="line-modified"> 874     if (sock &lt; 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env)) {</span>
 875         return NULL;
 876     }
 877 
 878     // enumerate IPv4 addresses
<span class="line-modified"> 879     if (sock &gt;= 0) {</span>
<span class="line-modified"> 880         ifs = enumIPv4Interfaces(env, sock, ifs);</span>
<span class="line-added"> 881         close(sock);</span>
 882 
<span class="line-modified"> 883         if ((*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-modified"> 884             freeif(ifs);</span>
<span class="line-modified"> 885             return NULL;</span>
<span class="line-added"> 886         }</span>
 887     }
 888 
 889     // If IPv6 is available then enumerate IPv6 addresses.
 890     // User can disable ipv6 explicitly by -Djava.net.preferIPv4Stack=true,
 891     // so we have to call ipv6_available()
 892     if (ipv6_available()) {
 893         sock = openSocket(env, AF_INET6);
 894         if (sock &lt; 0) {
 895             freeif(ifs);
 896             return NULL;
 897         }
 898 
 899         ifs = enumIPv6Interfaces(env, sock, ifs);
 900         close(sock);
 901 
 902         if ((*env)-&gt;ExceptionOccurred(env)) {
 903             freeif(ifs);
 904             return NULL;
 905         }
 906     }
</pre>
<hr />
<pre>
1125         if (prefix &gt; 0) {
1126             byte++;
1127             for (; byte &lt; sizeof(struct in6_addr); byte++) {
1128                 if (addrBytes[byte]) {
1129                     prefix = 0;
1130                 }
1131             }
1132         }
1133     }
1134 
1135     return prefix;
1136 }
1137 
1138 /*
1139  * Opens a socket for further ioct calls. proto is one of AF_INET or AF_INET6.
1140  */
1141 static int openSocket(JNIEnv *env, int proto) {
1142     int sock;
1143 
1144     if ((sock = socket(proto, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">1145         // If we lack support for this address family or protocol,</span>
<span class="line-modified">1146         // don&#39;t throw an exception.</span>
<span class="line-modified">1147         if (errno != EPROTONOSUPPORT &amp;&amp; errno != EAFNOSUPPORT) {</span>
1148             JNU_ThrowByNameWithMessageAndLastError
1149                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Socket creation failed&quot;);
1150         }
1151         return -1;
1152     }
1153 
1154     return sock;
1155 }
1156 
1157 /** Linux **/
1158 #if defined(__linux__)
1159 
1160 /*
1161  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1162  * if it fails return AF_INET6 socket.
1163  */
1164 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1165     int sock;
1166 
1167     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">1168         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {</span>
1169             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1170                 JNU_ThrowByNameWithMessageAndLastError
1171                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1172                 return -1;
1173             }
1174         } else { // errno is not NOSUPPORT
1175             JNU_ThrowByNameWithMessageAndLastError
1176                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1177             return -1;
1178         }
1179     }
1180 
1181     // Linux starting from 2.6.? kernel allows ioctl call with either IPv4 or
1182     // IPv6 socket regardless of type of address of an interface.
1183     return sock;
1184 }
1185 
1186 /*
1187  * Enumerates and returns all IPv4 interfaces on Linux.
1188  */
</pre>
<hr />
<pre>
1377     memset((char *)&amp;if2, 0, sizeof(if2));
1378     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1379 
1380     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1381         return -1;
1382     }
1383 
1384     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1385         *flags = (if2.ifr_flags &amp; 0xffff);
1386     } else {
1387         *flags = if2.ifr_flags;
1388     }
1389     return 0;
1390 }
1391 
1392 #endif /* __linux__ */
1393 
1394 /** AIX **/
1395 #if defined(_AIX)
1396 
<span class="line-added">1397 /* seems getkerninfo is guarded by _KERNEL in the system headers */</span>
<span class="line-added">1398 /* see net/proto_uipc.h */</span>
<span class="line-added">1399 int getkerninfo(int, char *, int *, int32long64_t);</span>
<span class="line-added">1400 </span>
1401 /*
1402  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1403  * if it fails return AF_INET6 socket.
1404  */
1405 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1406     int sock;
1407 
1408     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">1409         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {</span>
1410             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1411                 JNU_ThrowByNameWithMessageAndLastError
1412                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1413                 return -1;
1414             }
1415         } else { // errno is not NOSUPPORT
1416             JNU_ThrowByNameWithMessageAndLastError
1417                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1418             return -1;
1419         }
1420     }
1421 
1422     return sock;
1423 }
1424 
1425 /*
1426  * Enumerates and returns all IPv4 interfaces on AIX.
1427  */
1428 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1429     struct ifconf ifc;
</pre>
<hr />
<pre>
1600     void *end;
1601 
1602     size = getkerninfo(KINFO_NDD, 0, 0, 0);
1603     if (size == 0) {
1604         return -1;
1605     }
1606 
1607     if (size &lt; 0) {
1608         perror(&quot;getkerninfo 1&quot;);
1609         return -1;
1610     }
1611 
1612     nddp = (struct kinfo_ndd *)malloc(size);
1613 
1614     if (!nddp) {
1615         JNU_ThrowOutOfMemoryError(env,
1616             &quot;Network interface getMacAddress native buffer allocation failed&quot;);
1617         return -1;
1618     }
1619 
<span class="line-modified">1620     if (getkerninfo(KINFO_NDD, (char*) nddp, &amp;size, 0) &lt; 0) {</span>
1621         perror(&quot;getkerninfo 2&quot;);
1622         free(nddp);
1623         return -1;
1624     }
1625 
1626     end = (void *)nddp + size;
1627     while ((void *)nddp &lt; end) {
1628         if (!strcmp(nddp-&gt;ndd_alias, ifname) ||
1629                  !strcmp(nddp-&gt;ndd_name, ifname)) {
1630             bcopy(nddp-&gt;ndd_addr, buf, 6);
1631             free(nddp);
1632             return 6;
1633         } else {
1634             nddp++;
1635         }
1636     }
1637 
1638     free(nddp);
1639     return -1;
1640 }
</pre>
<hr />
<pre>
1667     } else {
1668         *flags = if2.ifr_flags;
1669     }
1670     return 0;
1671 }
1672 
1673 #endif /* _AIX */
1674 
1675 /** Solaris **/
1676 #if defined(__solaris__)
1677 
1678 /*
1679  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1680  * if it fails return AF_INET6 socket.
1681  */
1682 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1683     int sock, alreadyV6 = 0;
1684     struct lifreq if2;
1685 
1686     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">1687         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {</span>
1688             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1689                 JNU_ThrowByNameWithMessageAndLastError
1690                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1691                 return -1;
1692             }
1693             alreadyV6 = 1;
1694         } else { // errno is not NOSUPPORT
1695             JNU_ThrowByNameWithMessageAndLastError
1696                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1697             return -1;
1698         }
1699     }
1700 
1701     // Solaris requires that we have an IPv6 socket to query an  interface
1702     // without an IPv4 address - check it here. POSIX 1 require the kernel to
1703     // return ENOTTY if the call is inappropriate for a device e.g. the NETMASK
1704     // for a device having IPv6 only address but not all devices follow the
1705     // standard so fall back on any error. It&#39;s not an ecologically friendly
1706     // gesture but more reliable.
1707     if (!alreadyV6) {
</pre>
<hr />
<pre>
2018         return -1;
2019     }
2020 
2021     *flags = if2.lifr_flags;
2022     return 0;
2023 }
2024 
2025 #endif /* __solaris__ */
2026 
2027 /** BSD **/
2028 #if defined(_ALLBSD_SOURCE)
2029 
2030 /*
2031  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
2032  * if it fails return AF_INET6 socket.
2033  */
2034 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
2035     int sock;
2036 
2037     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
<span class="line-modified">2038         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {</span>
2039             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
2040                 JNU_ThrowByNameWithMessageAndLastError
2041                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
2042                 return -1;
2043             }
2044         } else { // errno is not NOSUPPORT
2045             JNU_ThrowByNameWithMessageAndLastError
2046                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
2047             return -1;
2048         }
2049     }
2050 
2051     return sock;
2052 }
2053 
2054 /*
2055  * Enumerates and returns all IPv4 interfaces on BSD.
2056  */
2057 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
2058     struct ifaddrs *ifa, *origifa;
</pre>
</td>
</tr>
</table>
<center><a href="Inet6AddressImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PlainDatagramSocketImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
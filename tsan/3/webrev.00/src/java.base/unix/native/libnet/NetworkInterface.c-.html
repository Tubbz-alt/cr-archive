<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/unix/native/libnet/NetworkInterface.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;arpa/inet.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #include &lt;net/if_arp.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;string.h&gt;
  31 #include &lt;sys/ioctl.h&gt;
  32 
  33 #if defined(_AIX)
  34 #include &lt;netinet/in6_var.h&gt;
  35 #include &lt;sys/ndd_var.h&gt;
  36 #include &lt;sys/kinfo.h&gt;
  37 #endif
  38 
  39 #if defined(__solaris__)
  40 #include &lt;stropts.h&gt;
  41 #include &lt;sys/dlpi.h&gt;
  42 #include &lt;sys/sockio.h&gt;
  43 #endif
  44 
  45 #if defined(_ALLBSD_SOURCE)
  46 #include &lt;net/ethernet.h&gt;
  47 #include &lt;net/if_dl.h&gt;
  48 #include &lt;ifaddrs.h&gt;
  49 #endif
  50 
  51 #include &quot;net_util.h&quot;
  52 
  53 #include &quot;java_net_InetAddress.h&quot;
  54 
  55 #if defined(__linux__)
  56     #define _PATH_PROCNET_IFINET6 &quot;/proc/net/if_inet6&quot;
  57 #elif defined(__solaris__)
  58     #ifndef SIOCGLIFHWADDR
  59         #define SIOCGLIFHWADDR _IOWR(&#39;i&#39;, 192, struct lifreq)
  60     #endif
  61     #define DEV_PREFIX &quot;/dev/&quot;
  62 #endif
  63 
  64 #ifdef LIFNAMSIZ
  65     #define IFNAMESIZE LIFNAMSIZ
  66 #else
  67     #define IFNAMESIZE IFNAMSIZ
  68 #endif
  69 
  70 #define CHECKED_MALLOC3(_pointer, _type, _size) \
  71     do { \
  72         _pointer = (_type)malloc(_size); \
  73         if (_pointer == NULL) { \
  74             JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failed&quot;); \
  75             return ifs; /* return untouched list */ \
  76         } \
  77     } while(0)
  78 
  79 typedef struct _netaddr  {
  80     struct sockaddr *addr;
  81     struct sockaddr *brdcast;
  82     short mask;
  83     int family; /* to make searches simple */
  84     struct _netaddr *next;
  85 } netaddr;
  86 
  87 typedef struct _netif {
  88     char *name;
  89     int index;
  90     char virtual;
  91     netaddr *addr;
  92     struct _netif *childs;
  93     struct _netif *next;
  94 } netif;
  95 
  96 /************************************************************************
  97  * NetworkInterface
  98  */
  99 
 100 #include &quot;java_net_NetworkInterface.h&quot;
 101 
 102 /************************************************************************
 103  * NetworkInterface
 104  */
 105 jclass ni_class;
 106 jfieldID ni_nameID;
 107 jfieldID ni_indexID;
 108 jfieldID ni_descID;
 109 jfieldID ni_addrsID;
 110 jfieldID ni_bindsID;
 111 jfieldID ni_virutalID;
 112 jfieldID ni_childsID;
 113 jfieldID ni_parentID;
 114 jfieldID ni_defaultIndexID;
 115 jmethodID ni_ctrID;
 116 
 117 static jclass ni_ibcls;
 118 static jmethodID ni_ibctrID;
 119 static jfieldID ni_ibaddressID;
 120 static jfieldID ni_ib4broadcastID;
 121 static jfieldID ni_ib4maskID;
 122 
 123 /** Private methods declarations **/
 124 static jobject createNetworkInterface(JNIEnv *env, netif *ifs);
 125 static int     getFlags0(JNIEnv *env, jstring  ifname);
 126 
 127 static netif  *enumInterfaces(JNIEnv *env);
 128 static netif  *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs);
 129 static netif  *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs);
 130 
 131 static netif  *addif(JNIEnv *env, int sock, const char *if_name, netif *ifs,
 132                      struct sockaddr *ifr_addrP,
 133                      struct sockaddr *ifr_broadaddrP,
 134                      int family, short prefix);
 135 static void    freeif(netif *ifs);
 136 
 137 static int     openSocket(JNIEnv *env, int proto);
 138 static int     openSocketWithFallback(JNIEnv *env, const char *ifname);
 139 
 140 static short   translateIPv4AddressToPrefix(struct sockaddr_in *addr);
 141 static short   translateIPv6AddressToPrefix(struct sockaddr_in6 *addr);
 142 
 143 static int     getIndex(int sock, const char *ifname);
 144 static int     getFlags(int sock, const char *ifname, int *flags);
 145 static int     getMacAddress(JNIEnv *env, const char *ifname,
 146                              const struct in_addr *addr, unsigned char *buf);
 147 static int     getMTU(JNIEnv *env, int sock, const char *ifname);
 148 
 149 #if defined(__solaris__)
 150 static int     getMacFromDevice(JNIEnv *env, const char *ifname,
 151                                 unsigned char *retbuf);
 152 #endif
 153 
 154 /******************* Java entry points *****************************/
 155 
 156 /*
 157  * Class:     java_net_NetworkInterface
 158  * Method:    init
 159  * Signature: ()V
 160  */
 161 JNIEXPORT void JNICALL Java_java_net_NetworkInterface_init
 162   (JNIEnv *env, jclass cls)
 163 {
 164     ni_class = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
 165     CHECK_NULL(ni_class);
 166     ni_class = (*env)-&gt;NewGlobalRef(env, ni_class);
 167     CHECK_NULL(ni_class);
 168     ni_nameID = (*env)-&gt;GetFieldID(env, ni_class, &quot;name&quot;, &quot;Ljava/lang/String;&quot;);
 169     CHECK_NULL(ni_nameID);
 170     ni_indexID = (*env)-&gt;GetFieldID(env, ni_class, &quot;index&quot;, &quot;I&quot;);
 171     CHECK_NULL(ni_indexID);
 172     ni_addrsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;addrs&quot;,
 173                                     &quot;[Ljava/net/InetAddress;&quot;);
 174     CHECK_NULL(ni_addrsID);
 175     ni_bindsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;bindings&quot;,
 176                                     &quot;[Ljava/net/InterfaceAddress;&quot;);
 177     CHECK_NULL(ni_bindsID);
 178     ni_descID = (*env)-&gt;GetFieldID(env, ni_class, &quot;displayName&quot;,
 179                                    &quot;Ljava/lang/String;&quot;);
 180     CHECK_NULL(ni_descID);
 181     ni_virutalID = (*env)-&gt;GetFieldID(env, ni_class, &quot;virtual&quot;, &quot;Z&quot;);
 182     CHECK_NULL(ni_virutalID);
 183     ni_childsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;childs&quot;,
 184                                      &quot;[Ljava/net/NetworkInterface;&quot;);
 185     CHECK_NULL(ni_childsID);
 186     ni_parentID = (*env)-&gt;GetFieldID(env, ni_class, &quot;parent&quot;,
 187                                      &quot;Ljava/net/NetworkInterface;&quot;);
 188     CHECK_NULL(ni_parentID);
 189     ni_ctrID = (*env)-&gt;GetMethodID(env, ni_class, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 190     CHECK_NULL(ni_ctrID);
 191     ni_ibcls = (*env)-&gt;FindClass(env, &quot;java/net/InterfaceAddress&quot;);
 192     CHECK_NULL(ni_ibcls);
 193     ni_ibcls = (*env)-&gt;NewGlobalRef(env, ni_ibcls);
 194     CHECK_NULL(ni_ibcls);
 195     ni_ibctrID = (*env)-&gt;GetMethodID(env, ni_ibcls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 196     CHECK_NULL(ni_ibctrID);
 197     ni_ibaddressID = (*env)-&gt;GetFieldID(env, ni_ibcls, &quot;address&quot;,
 198                                         &quot;Ljava/net/InetAddress;&quot;);
 199     CHECK_NULL(ni_ibaddressID);
 200     ni_ib4broadcastID = (*env)-&gt;GetFieldID(env, ni_ibcls, &quot;broadcast&quot;,
 201                                            &quot;Ljava/net/Inet4Address;&quot;);
 202     CHECK_NULL(ni_ib4broadcastID);
 203     ni_ib4maskID = (*env)-&gt;GetFieldID(env, ni_ibcls, &quot;maskLength&quot;, &quot;S&quot;);
 204     CHECK_NULL(ni_ib4maskID);
 205     ni_defaultIndexID = (*env)-&gt;GetStaticFieldID(env, ni_class, &quot;defaultIndex&quot;,
 206                                                  &quot;I&quot;);
 207     CHECK_NULL(ni_defaultIndexID);
 208     initInetAddressIDs(env);
 209 }
 210 
 211 /*
 212  * Class:     java_net_NetworkInterface
 213  * Method:    getByName0
 214  * Signature: (Ljava/lang/String;)Ljava/net/NetworkInterface;
 215  */
 216 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0
 217   (JNIEnv *env, jclass cls, jstring name)
 218 {
 219     netif *ifs, *curr;
 220     jboolean isCopy;
 221     const char* name_utf;
 222     char *colonP;
 223     char searchName[IFNAMESIZE];
 224     jobject obj = NULL;
 225 
 226     if (name != NULL) {
 227         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 228     } else {
 229         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 230         return NULL;
 231     }
 232 
 233     if (name_utf == NULL) {
 234         if (!(*env)-&gt;ExceptionCheck(env))
 235             JNU_ThrowOutOfMemoryError(env, NULL);
 236         return NULL;
 237     }
 238 
 239     ifs = enumInterfaces(env);
 240     if (ifs == NULL) {
 241         return NULL;
 242     }
 243 
 244     // search the list of interfaces based on name,
 245     // if it is virtual sub interface search with parent first.
 246     strncpy(searchName, name_utf, IFNAMESIZE);
 247     searchName[IFNAMESIZE - 1] = &#39;\0&#39;;
 248     colonP = strchr(searchName, &#39;:&#39;);
 249     if (colonP != NULL) {
 250         *colonP = &#39;\0&#39;;
 251     }
 252     curr = ifs;
 253     while (curr != NULL) {
 254         if (strcmp(searchName, curr-&gt;name) == 0) {
 255             break;
 256         }
 257         curr = curr-&gt;next;
 258     }
 259 
 260     // search the child list
 261     if (colonP != NULL &amp;&amp; curr != NULL) {
 262         curr = curr-&gt;childs;
 263         while (curr != NULL) {
 264             if (strcmp(name_utf, curr-&gt;name) == 0) {
 265                 break;
 266             }
 267             curr = curr-&gt;next;
 268         }
 269     }
 270 
 271     // if found create a NetworkInterface
 272     if (curr != NULL) {
 273         obj = createNetworkInterface(env, curr);
 274     }
 275 
 276     // release the UTF string and interface list
 277     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 278     freeif(ifs);
 279 
 280     return obj;
 281 }
 282 
 283 /*
 284  * Class:     java_net_NetworkInterface
 285  * Method:    getByIndex0
 286  * Signature: (Ljava/lang/String;)Ljava/net/NetworkInterface;
 287  */
 288 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0
 289   (JNIEnv *env, jclass cls, jint index)
 290 {
 291     netif *ifs, *curr;
 292     jobject obj = NULL;
 293 
 294     if (index &lt;= 0) {
 295         return NULL;
 296     }
 297 
 298     ifs = enumInterfaces(env);
 299     if (ifs == NULL) {
 300         return NULL;
 301     }
 302 
 303     // search the list of interfaces based on index
 304     curr = ifs;
 305     while (curr != NULL) {
 306         if (index == curr-&gt;index) {
 307             break;
 308         }
 309         curr = curr-&gt;next;
 310     }
 311 
 312     // if found create a NetworkInterface
 313     if (curr != NULL) {
 314         obj = createNetworkInterface(env, curr);
 315     }
 316 
 317     // release the interface list
 318     freeif(ifs);
 319 
 320     return obj;
 321 }
 322 
 323 /*
 324  * Class:     java_net_NetworkInterface
 325  * Method:    getByInetAddress0
 326  * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;
 327  */
 328 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0
 329   (JNIEnv *env, jclass cls, jobject iaObj)
 330 {
 331     netif *ifs, *curr;
 332     jobject obj = NULL;
 333     jboolean match = JNI_FALSE;
 334     int family = getInetAddress_family(env, iaObj);
 335     JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 336 
 337     if (family == java_net_InetAddress_IPv4) {
 338         family = AF_INET;
 339     } else if (family == java_net_InetAddress_IPv6) {
 340         family = AF_INET6;
 341     } else {
 342         return NULL; // Invalid family
 343     }
 344     ifs = enumInterfaces(env);
 345     if (ifs == NULL) {
 346         return NULL;
 347     }
 348 
 349     curr = ifs;
 350     while (curr != NULL) {
 351         netaddr *addrP = curr-&gt;addr;
 352 
 353         // iterate through each address on the interface
 354         while (addrP != NULL) {
 355 
 356             if (family == addrP-&gt;family) {
 357                 if (family == AF_INET) {
 358                     int address1 = htonl(
 359                         ((struct sockaddr_in *)addrP-&gt;addr)-&gt;sin_addr.s_addr);
 360                     int address2 = getInetAddress_addr(env, iaObj);
 361                     if ((*env)-&gt;ExceptionCheck(env)) {
 362                         goto cleanup;
 363                     }
 364                     if (address1 == address2) {
 365                         match = JNI_TRUE;
 366                         break;
 367                     }
 368                 } else if (family == AF_INET6) {
 369                     jbyte *bytes = (jbyte *)&amp;(
 370                         ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_addr);
 371                     jbyte caddr[16];
 372                     int i;
 373                     unsigned int scopeid;
 374                     getInet6Address_ipaddress(env, iaObj, (char *)caddr);
 375                     scopeid = (unsigned int)getInet6Address_scopeid(env, iaObj);
 376                     if (scopeid != 0 &amp;&amp; scopeid != ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_scope_id)
 377                         break;
 378                     i = 0;
 379                     while (i &lt; 16) {
 380                         if (caddr[i] != bytes[i]) {
 381                             break;
 382                         }
 383                         i++;
 384                     }
 385                     if (i &gt;= 16) {
 386                         match = JNI_TRUE;
 387                         break;
 388                     }
 389                 }
 390             }
 391 
 392             if (match) {
 393                 break;
 394             }
 395             addrP = addrP-&gt;next;
 396         }
 397 
 398         if (match) {
 399             break;
 400         }
 401         curr = curr-&gt;next;
 402     }
 403 
 404     // if found create a NetworkInterface
 405     if (match) {
 406         obj = createNetworkInterface(env, curr);
 407     }
 408 
 409 cleanup:
 410     // release the interface list
 411     freeif(ifs);
 412 
 413     return obj;
 414 }
 415 
 416 /*
 417  * Class:     java_net_NetworkInterface
 418  * Method:    getAll
 419  * Signature: ()[Ljava/net/NetworkInterface;
 420  */
 421 JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll
 422   (JNIEnv *env, jclass cls)
 423 {
 424     netif *ifs, *curr;
 425     jobjectArray netIFArr;
 426     jint arr_index, ifCount;
 427 
 428     ifs = enumInterfaces(env);
 429     if (ifs == NULL) {
 430         return NULL;
 431     }
 432 
 433     // count the interfaces
 434     ifCount = 0;
 435     curr = ifs;
 436     while (curr != NULL) {
 437         ifCount++;
 438         curr = curr-&gt;next;
 439     }
 440 
 441     // allocate a NetworkInterface array
 442     netIFArr = (*env)-&gt;NewObjectArray(env, ifCount, cls, NULL);
 443     if (netIFArr == NULL) {
 444         freeif(ifs);
 445         return NULL;
 446     }
 447 
 448     // iterate through the interfaces, create a NetworkInterface instance
 449     // for each array element and populate the object
 450     curr = ifs;
 451     arr_index = 0;
 452     while (curr != NULL) {
 453         jobject netifObj;
 454 
 455         netifObj = createNetworkInterface(env, curr);
 456         if (netifObj == NULL) {
 457             freeif(ifs);
 458             return NULL;
 459         }
 460 
 461         // put the NetworkInterface into the array
 462         (*env)-&gt;SetObjectArrayElement(env, netIFArr, arr_index++, netifObj);
 463 
 464         curr = curr-&gt;next;
 465     }
 466 
 467     // release the interface list
 468     freeif(ifs);
 469 
 470     return netIFArr;
 471 }
 472 
 473 /*
 474  * Class:     java_net_NetworkInterface
 475  * Method:    isUp0
 476  * Signature: (Ljava/lang/String;I)Z
 477  */
 478 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0
 479   (JNIEnv *env, jclass cls, jstring name, jint index)
 480 {
 481     int ret = getFlags0(env, name);
 482     return ((ret &amp; IFF_UP) &amp;&amp; (ret &amp; IFF_RUNNING)) ? JNI_TRUE :  JNI_FALSE;
 483 }
 484 
 485 /*
 486  * Class:     java_net_NetworkInterface
 487  * Method:    isP2P0
 488  * Signature: (Ljava/lang/String;I)Z
 489  */
 490 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0
 491   (JNIEnv *env, jclass cls, jstring name, jint index)
 492 {
 493     int ret = getFlags0(env, name);
 494     return (ret &amp; IFF_POINTOPOINT) ? JNI_TRUE :  JNI_FALSE;
 495 }
 496 
 497 /*
 498  * Class:     java_net_NetworkInterface
 499  * Method:    isLoopback0
 500  * Signature: (Ljava/lang/String;I)Z
 501  */
 502 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0
 503   (JNIEnv *env, jclass cls, jstring name, jint index)
 504 {
 505     int ret = getFlags0(env, name);
 506     return (ret &amp; IFF_LOOPBACK) ? JNI_TRUE :  JNI_FALSE;
 507 }
 508 
 509 /*
 510  * Class:     java_net_NetworkInterface
 511  * Method:    supportsMulticast0
 512  * Signature: (Ljava/lang/String;I)Z
 513  */
 514 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0
 515   (JNIEnv *env, jclass cls, jstring name, jint index)
 516 {
 517     int ret = getFlags0(env, name);
 518     return (ret &amp; IFF_MULTICAST) ? JNI_TRUE :  JNI_FALSE;
 519 }
 520 
 521 /*
 522  * Class:     java_net_NetworkInterface
 523  * Method:    getMacAddr0
 524  * Signature: ([bLjava/lang/String;I)[b
 525  */
 526 JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0
 527   (JNIEnv *env, jclass cls, jbyteArray addrArray, jstring name, jint index)
 528 {
 529     jint addr;
 530     jbyte caddr[4];
 531     struct in_addr iaddr;
 532     jbyteArray ret = NULL;
 533     unsigned char mac[16];
 534     int len;
 535     jboolean isCopy;
 536     const char *name_utf;
 537 
 538     if (name != NULL) {
 539         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 540     } else {
 541         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 542         return NULL;
 543     }
 544 
 545     if (name_utf == NULL) {
 546         if (!(*env)-&gt;ExceptionCheck(env))
 547             JNU_ThrowOutOfMemoryError(env, NULL);
 548         return NULL;
 549     }
 550 
 551     if (!IS_NULL(addrArray)) {
 552         (*env)-&gt;GetByteArrayRegion(env, addrArray, 0, 4, caddr);
 553         addr = ((caddr[0]&lt;&lt;24) &amp; 0xff000000);
 554         addr |= ((caddr[1] &lt;&lt;16) &amp; 0xff0000);
 555         addr |= ((caddr[2] &lt;&lt;8) &amp; 0xff00);
 556         addr |= (caddr[3] &amp; 0xff);
 557         iaddr.s_addr = htonl(addr);
 558         len = getMacAddress(env, name_utf, &amp;iaddr, mac);
 559     } else {
 560         len = getMacAddress(env, name_utf, NULL, mac);
 561     }
 562 
 563     if (len &gt; 0) {
 564         ret = (*env)-&gt;NewByteArray(env, len);
 565         if (!IS_NULL(ret)) {
 566             (*env)-&gt;SetByteArrayRegion(env, ret, 0, len, (jbyte *)(mac));
 567         }
 568     }
 569 
 570     // release the UTF string and interface list
 571     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 572 
 573     return ret;
 574 }
 575 
 576 /*
 577  * Class:       java_net_NetworkInterface
 578  * Method:      getMTU0
 579  * Signature:   ([bLjava/lang/String;I)I
 580  */
 581 JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0
 582   (JNIEnv *env, jclass cls, jstring name, jint index)
 583 {
 584     jboolean isCopy;
 585     int sock, ret = -1;
 586     const char* name_utf = NULL;
 587 
 588     if (name != NULL) {
 589         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 590     } else {
 591         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 592         return ret;
 593     }
 594 
 595     if (name_utf == NULL) {
 596         if (!(*env)-&gt;ExceptionCheck(env))
 597             JNU_ThrowOutOfMemoryError(env, NULL);
 598         return ret;
 599     }
 600 
 601     if ((sock = openSocketWithFallback(env, name_utf)) &lt; 0) {
 602         (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 603         return JNI_FALSE;
 604     }
 605 
 606     ret = getMTU(env, sock, name_utf);
 607 
 608     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 609 
 610     close(sock);
 611     return ret;
 612 }
 613 
 614 /*** Private methods definitions ****/
 615 
 616 static int getFlags0(JNIEnv *env, jstring name) {
 617     jboolean isCopy;
 618     int ret, sock, flags = 0;
 619     const char *name_utf;
 620 
 621     if (name != NULL) {
 622         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 623     } else {
 624         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 625         return -1;
 626     }
 627 
 628     if (name_utf == NULL) {
 629         if (!(*env)-&gt;ExceptionCheck(env))
 630             JNU_ThrowOutOfMemoryError(env, NULL);
 631         return -1;
 632     }
 633     if ((sock = openSocketWithFallback(env, name_utf)) &lt; 0) {
 634         (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 635         return -1;
 636     }
 637 
 638     ret = getFlags(sock, name_utf, &amp;flags);
 639 
 640     close(sock);
 641     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 642 
 643     if (ret &lt; 0) {
 644         JNU_ThrowByNameWithMessageAndLastError
 645             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getFlags() failed&quot;);
 646         return -1;
 647     }
 648 
 649     return flags;
 650 }
 651 
 652 /*
 653  * Creates a NetworkInterface object, populates the name, the index, and
 654  * populates the InetAddress array based on the IP addresses for this
 655  * interface.
 656  */
 657 static jobject createNetworkInterface(JNIEnv *env, netif *ifs) {
 658     jobject netifObj;
 659     jobject name;
 660     jobjectArray addrArr;
 661     jobjectArray bindArr;
 662     jobjectArray childArr;
 663     netaddr *addrs;
 664     jint addr_index, addr_count, bind_index;
 665     jint child_count, child_index;
 666     netaddr *addrP;
 667     netif *childP;
 668     jobject tmp;
 669 
 670     // create a NetworkInterface object and populate it
 671     netifObj = (*env)-&gt;NewObject(env, ni_class, ni_ctrID);
 672     CHECK_NULL_RETURN(netifObj, NULL);
 673     name = (*env)-&gt;NewStringUTF(env, ifs-&gt;name);
 674     CHECK_NULL_RETURN(name, NULL);
 675     (*env)-&gt;SetObjectField(env, netifObj, ni_nameID, name);
 676     (*env)-&gt;SetObjectField(env, netifObj, ni_descID, name);
 677     (*env)-&gt;SetIntField(env, netifObj, ni_indexID, ifs-&gt;index);
 678     (*env)-&gt;SetBooleanField(env, netifObj, ni_virutalID,
 679                             ifs-&gt;virtual ? JNI_TRUE : JNI_FALSE);
 680 
 681     // count the number of addresses on this interface
 682     addr_count = 0;
 683     addrP = ifs-&gt;addr;
 684     while (addrP != NULL) {
 685         addr_count++;
 686         addrP = addrP-&gt;next;
 687     }
 688 
 689     // create the array of InetAddresses
 690     addrArr = (*env)-&gt;NewObjectArray(env, addr_count, ia_class, NULL);
 691     if (addrArr == NULL) {
 692         return NULL;
 693     }
 694 
 695     bindArr = (*env)-&gt;NewObjectArray(env, addr_count, ni_ibcls, NULL);
 696     if (bindArr == NULL) {
 697        return NULL;
 698     }
 699     addrP = ifs-&gt;addr;
 700     addr_index = 0;
 701     bind_index = 0;
 702     while (addrP != NULL) {
 703         jobject iaObj = NULL;
 704         jobject ibObj = NULL;
 705 
 706         if (addrP-&gt;family == AF_INET) {
 707             iaObj = (*env)-&gt;NewObject(env, ia4_class, ia4_ctrID);
 708             if (iaObj) {
 709                 setInetAddress_addr(env, iaObj, htonl(
 710                     ((struct sockaddr_in*)addrP-&gt;addr)-&gt;sin_addr.s_addr));
 711                 JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 712             } else {
 713                 return NULL;
 714             }
 715             ibObj = (*env)-&gt;NewObject(env, ni_ibcls, ni_ibctrID);
 716             if (ibObj) {
 717                 (*env)-&gt;SetObjectField(env, ibObj, ni_ibaddressID, iaObj);
 718                 if (addrP-&gt;brdcast) {
 719                     jobject ia2Obj = NULL;
 720                     ia2Obj = (*env)-&gt;NewObject(env, ia4_class, ia4_ctrID);
 721                     if (ia2Obj) {
 722                         setInetAddress_addr(env, ia2Obj, htonl(
 723                             ((struct sockaddr_in*)addrP-&gt;brdcast)-&gt;sin_addr.s_addr));
 724                         JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 725                         (*env)-&gt;SetObjectField(env, ibObj, ni_ib4broadcastID, ia2Obj);
 726                     } else {
 727                         return NULL;
 728                     }
 729                 }
 730                 (*env)-&gt;SetShortField(env, ibObj, ni_ib4maskID, addrP-&gt;mask);
 731                 (*env)-&gt;SetObjectArrayElement(env, bindArr, bind_index++, ibObj);
 732             } else {
 733                 return NULL;
 734             }
 735         }
 736         if (addrP-&gt;family == AF_INET6) {
 737             int scope=0;
 738             iaObj = (*env)-&gt;NewObject(env, ia6_class, ia6_ctrID);
 739             if (iaObj) {
 740                 jboolean ret = setInet6Address_ipaddress(env, iaObj,
 741                     (char *)&amp;(((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_addr));
 742                 if (ret == JNI_FALSE) {
 743                     return NULL;
 744                 }
 745 
 746                 scope = ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_scope_id;
 747 
 748                 if (scope != 0) { /* zero is default value, no need to set */
 749                     setInet6Address_scopeid(env, iaObj, scope);
 750                     setInet6Address_scopeifname(env, iaObj, netifObj);
 751                 }
 752             } else {
 753                 return NULL;
 754             }
 755             ibObj = (*env)-&gt;NewObject(env, ni_ibcls, ni_ibctrID);
 756             if (ibObj) {
 757                 (*env)-&gt;SetObjectField(env, ibObj, ni_ibaddressID, iaObj);
 758                 (*env)-&gt;SetShortField(env, ibObj, ni_ib4maskID, addrP-&gt;mask);
 759                 (*env)-&gt;SetObjectArrayElement(env, bindArr, bind_index++, ibObj);
 760             } else {
 761                 return NULL;
 762             }
 763         }
 764 
 765         (*env)-&gt;SetObjectArrayElement(env, addrArr, addr_index++, iaObj);
 766         addrP = addrP-&gt;next;
 767     }
 768 
 769     // see if there is any virtual interface attached to this one.
 770     child_count = 0;
 771     childP = ifs-&gt;childs;
 772     while (childP) {
 773         child_count++;
 774         childP = childP-&gt;next;
 775     }
 776 
 777     childArr = (*env)-&gt;NewObjectArray(env, child_count, ni_class, NULL);
 778     if (childArr == NULL) {
 779         return NULL;
 780     }
 781 
 782     // create the NetworkInterface instances for the sub-interfaces as well
 783     child_index = 0;
 784     childP = ifs-&gt;childs;
 785     while(childP) {
 786         tmp = createNetworkInterface(env, childP);
 787         if (tmp == NULL) {
 788             return NULL;
 789         }
 790         (*env)-&gt;SetObjectField(env, tmp, ni_parentID, netifObj);
 791         (*env)-&gt;SetObjectArrayElement(env, childArr, child_index++, tmp);
 792         childP = childP-&gt;next;
 793     }
 794     (*env)-&gt;SetObjectField(env, netifObj, ni_addrsID, addrArr);
 795     (*env)-&gt;SetObjectField(env, netifObj, ni_bindsID, bindArr);
 796     (*env)-&gt;SetObjectField(env, netifObj, ni_childsID, childArr);
 797 
 798     // return the NetworkInterface
 799     return netifObj;
 800 }
 801 
 802 /*
 803  * Enumerates all interfaces
 804  */
 805 static netif *enumInterfaces(JNIEnv *env) {
 806     netif *ifs = NULL;
 807     int sock;
 808 
 809     sock = openSocket(env, AF_INET);
 810     if (sock &lt; 0) {
 811         return NULL;
 812     }
 813 
 814     // enumerate IPv4 addresses
 815     ifs = enumIPv4Interfaces(env, sock, NULL);
 816     close(sock);
 817 
 818     // return partial list if an exception occurs in the middle of process ???
 819     if (ifs == NULL &amp;&amp; (*env)-&gt;ExceptionOccurred(env)) {
 820         return NULL;
 821     }
 822 
 823     // If IPv6 is available then enumerate IPv6 addresses.
 824     // User can disable ipv6 explicitly by -Djava.net.preferIPv4Stack=true,
 825     // so we have to call ipv6_available()
 826     if (ipv6_available()) {
 827         sock = openSocket(env, AF_INET6);
 828         if (sock &lt; 0) {
 829             freeif(ifs);
 830             return NULL;
 831         }
 832 
 833         ifs = enumIPv6Interfaces(env, sock, ifs);
 834         close(sock);
 835 
 836         if ((*env)-&gt;ExceptionOccurred(env)) {
 837             freeif(ifs);
 838             return NULL;
 839         }
 840     }
 841 
 842     return ifs;
 843 }
 844 
 845 /*
 846  * Frees an interface list (including any attached addresses).
 847  */
 848 static void freeif(netif *ifs) {
 849     netif *currif = ifs;
 850     netif *child = NULL;
 851 
 852     while (currif != NULL) {
 853         netaddr *addrP = currif-&gt;addr;
 854         while (addrP != NULL) {
 855             netaddr *next = addrP-&gt;next;
 856             free(addrP);
 857             addrP = next;
 858         }
 859 
 860         // don&#39;t forget to free the sub-interfaces
 861         if (currif-&gt;childs != NULL) {
 862             freeif(currif-&gt;childs);
 863         }
 864 
 865         ifs = currif-&gt;next;
 866         free(currif);
 867         currif = ifs;
 868     }
 869 }
 870 
 871 static netif *addif(JNIEnv *env, int sock, const char *if_name, netif *ifs,
 872                     struct sockaddr *ifr_addrP,
 873                     struct sockaddr *ifr_broadaddrP,
 874                     int family, short prefix)
 875 {
 876     netif *currif = ifs, *parent;
 877     netaddr *addrP;
 878     char name[IFNAMESIZE], vname[IFNAMESIZE];
 879     char *name_colonP;
 880     int isVirtual = 0;
 881     int addr_size;
 882 
 883     // If the interface name is a logical interface then we remove the unit
 884     // number so that we have the physical interface (eg: hme0:1 -&gt; hme0).
 885     // NetworkInterface currently doesn&#39;t have any concept of physical vs.
 886     // logical interfaces.
 887     strncpy(name, if_name, IFNAMESIZE);
 888     name[IFNAMESIZE - 1] = &#39;\0&#39;;
 889     *vname = 0;
 890 
 891     // Create and populate the netaddr node. If allocation fails
 892     // return an un-updated list.
 893 
 894     // Allocate for addr and brdcast at once
 895 
 896     addr_size = (family == AF_INET) ? sizeof(struct sockaddr_in)
 897                                     : sizeof(struct sockaddr_in6);
 898 
 899     CHECKED_MALLOC3(addrP, netaddr *, sizeof(netaddr) + 2 * addr_size);
 900     addrP-&gt;addr = (struct sockaddr *)((char *)addrP + sizeof(netaddr));
 901     memcpy(addrP-&gt;addr, ifr_addrP, addr_size);
 902 
 903     addrP-&gt;family = family;
 904     addrP-&gt;mask = prefix;
 905     addrP-&gt;next = 0;
 906 
 907     // for IPv4 add broadcast address
 908     if (family == AF_INET &amp;&amp; ifr_broadaddrP != NULL) {
 909         addrP-&gt;brdcast = (struct sockaddr *)
 910                              ((char *)addrP + sizeof(netaddr) + addr_size);
 911         memcpy(addrP-&gt;brdcast, ifr_broadaddrP, addr_size);
 912     } else {
 913         addrP-&gt;brdcast = NULL;
 914     }
 915 
 916     // Deal with virtual interface with colon notation e.g. eth0:1
 917     name_colonP = strchr(name, &#39;:&#39;);
 918     if (name_colonP != NULL) {
 919         int flags = 0;
 920         // This is a virtual interface. If we are able to access the parent
 921         // we need to create a new entry if it doesn&#39;t exist yet *and* update
 922         // the &#39;parent&#39; interface with the new records.
 923         *name_colonP = 0;
 924         if (getFlags(sock, name, &amp;flags) &lt; 0 || flags &lt; 0) {
 925             // failed to access parent interface do not create parent.
 926             // We are a virtual interface with no parent.
 927             isVirtual = 1;
 928             *name_colonP = &#39;:&#39;;
 929         } else {
 930             // Got access to parent, so create it if necessary.
 931             // Save original name to vname and truncate name by &#39;:&#39;
 932             memcpy(vname, name, sizeof(vname));
 933             vname[name_colonP - name] = &#39;:&#39;;
 934         }
 935     }
 936 
 937     // Check if this is a &quot;new&quot; interface. Use the interface name for
 938     // matching because index isn&#39;t supported on Solaris 2.6 &amp; 7.
 939     while (currif != NULL) {
 940         if (strcmp(name, currif-&gt;name) == 0) {
 941             break;
 942         }
 943         currif = currif-&gt;next;
 944     }
 945 
 946     // If &quot;new&quot; then create a netif structure and insert it into the list.
 947     if (currif == NULL) {
 948          CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);
 949          currif-&gt;name = (char *)currif + sizeof(netif);
 950          strncpy(currif-&gt;name, name, IFNAMESIZE);
 951          currif-&gt;name[IFNAMESIZE - 1] = &#39;\0&#39;;
 952          currif-&gt;index = getIndex(sock, name);
 953          currif-&gt;addr = NULL;
 954          currif-&gt;childs = NULL;
 955          currif-&gt;virtual = isVirtual;
 956          currif-&gt;next = ifs;
 957          ifs = currif;
 958     }
 959 
 960     // Finally insert the address on the interface
 961     addrP-&gt;next = currif-&gt;addr;
 962     currif-&gt;addr = addrP;
 963 
 964     parent = currif;
 965 
 966     // Deal with the virtual interface now.
 967     if (vname[0]) {
 968         netaddr *tmpaddr;
 969 
 970         currif = parent-&gt;childs;
 971 
 972         while (currif != NULL) {
 973             if (strcmp(vname, currif-&gt;name) == 0) {
 974                 break;
 975             }
 976             currif = currif-&gt;next;
 977         }
 978 
 979         if (currif == NULL) {
 980             CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);
 981             currif-&gt;name = (char *)currif + sizeof(netif);
 982             strncpy(currif-&gt;name, vname, IFNAMESIZE);
 983             currif-&gt;name[IFNAMESIZE - 1] = &#39;\0&#39;;
 984             currif-&gt;index = getIndex(sock, vname);
 985             currif-&gt;addr = NULL; // Need to duplicate the addr entry?
 986             currif-&gt;virtual = 1;
 987             currif-&gt;childs = NULL;
 988             currif-&gt;next = parent-&gt;childs;
 989             parent-&gt;childs = currif;
 990         }
 991 
 992         CHECKED_MALLOC3(tmpaddr, netaddr *, sizeof(netaddr) + 2 * addr_size);
 993         memcpy(tmpaddr, addrP, sizeof(netaddr));
 994         if (addrP-&gt;addr != NULL) {
 995             tmpaddr-&gt;addr = (struct sockaddr *)
 996                 ((char*)tmpaddr + sizeof(netaddr));
 997             memcpy(tmpaddr-&gt;addr, addrP-&gt;addr, addr_size);
 998         }
 999 
1000         if (addrP-&gt;brdcast != NULL) {
1001             tmpaddr-&gt;brdcast = (struct sockaddr *)
1002                 ((char *)tmpaddr + sizeof(netaddr) + addr_size);
1003             memcpy(tmpaddr-&gt;brdcast, addrP-&gt;brdcast, addr_size);
1004         }
1005 
1006         tmpaddr-&gt;next = currif-&gt;addr;
1007         currif-&gt;addr = tmpaddr;
1008     }
1009 
1010     return ifs;
1011 }
1012 
1013 /*
1014  * Determines the prefix value for an AF_INET subnet address.
1015  */
1016 static short translateIPv4AddressToPrefix(struct sockaddr_in *addr) {
1017     short prefix = 0;
1018     unsigned int mask;
1019     if (addr == NULL) {
1020         return 0;
1021     }
1022     mask = ntohl(addr-&gt;sin_addr.s_addr);
1023     while (mask) {
1024         mask &lt;&lt;= 1;
1025         prefix++;
1026     }
1027     return prefix;
1028 }
1029 
1030 /*
1031  * Determines the prefix value for an AF_INET6 subnet address.
1032  */
1033 static short translateIPv6AddressToPrefix(struct sockaddr_in6 *addr) {
1034     short prefix = 0;
1035     u_char *addrBytes;
1036     if (addr == NULL) {
1037         return 0;
1038     }
1039     addrBytes = (u_char *)&amp;(addr-&gt;sin6_addr);
1040     unsigned int byte, bit;
1041 
1042     for (byte = 0; byte &lt; sizeof(struct in6_addr); byte++, prefix += 8) {
1043         if (addrBytes[byte] != 0xff) {
1044             break;
1045         }
1046     }
1047     if (byte != sizeof(struct in6_addr)) {
1048         for (bit = 7; bit != 0; bit--, prefix++) {
1049             if (!(addrBytes[byte] &amp; (1 &lt;&lt; bit))) {
1050                 break;
1051             }
1052         }
1053         for (; bit != 0; bit--) {
1054             if (addrBytes[byte] &amp; (1 &lt;&lt; bit)) {
1055                 prefix = 0;
1056                 break;
1057             }
1058         }
1059         if (prefix &gt; 0) {
1060             byte++;
1061             for (; byte &lt; sizeof(struct in6_addr); byte++) {
1062                 if (addrBytes[byte]) {
1063                     prefix = 0;
1064                 }
1065             }
1066         }
1067     }
1068 
1069     return prefix;
1070 }
1071 
1072 /*
1073  * Opens a socket for further ioct calls. proto is one of AF_INET or AF_INET6.
1074  */
1075 static int openSocket(JNIEnv *env, int proto) {
1076     int sock;
1077 
1078     if ((sock = socket(proto, SOCK_DGRAM, 0)) &lt; 0) {
1079         // If EPROTONOSUPPORT is returned it means we don&#39;t have
1080         // support for this proto so don&#39;t throw an exception.
1081         if (errno != EPROTONOSUPPORT) {
1082             JNU_ThrowByNameWithMessageAndLastError
1083                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Socket creation failed&quot;);
1084         }
1085         return -1;
1086     }
1087 
1088     return sock;
1089 }
1090 
1091 /** Linux **/
1092 #if defined(__linux__)
1093 
1094 /*
1095  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1096  * if it fails return AF_INET6 socket.
1097  */
1098 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1099     int sock;
1100 
1101     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1102         if (errno == EPROTONOSUPPORT) {
1103             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1104                 JNU_ThrowByNameWithMessageAndLastError
1105                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1106                 return -1;
1107             }
1108         } else { // errno is not NOSUPPORT
1109             JNU_ThrowByNameWithMessageAndLastError
1110                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1111             return -1;
1112         }
1113     }
1114 
1115     // Linux starting from 2.6.? kernel allows ioctl call with either IPv4 or
1116     // IPv6 socket regardless of type of address of an interface.
1117     return sock;
1118 }
1119 
1120 /*
1121  * Enumerates and returns all IPv4 interfaces on Linux.
1122  */
1123 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1124     struct ifconf ifc;
1125     struct ifreq *ifreqP;
1126     char *buf = NULL;
1127     unsigned i;
1128 
1129     // do a dummy SIOCGIFCONF to determine the buffer size
1130     // SIOCGIFCOUNT doesn&#39;t work
1131     ifc.ifc_buf = NULL;
1132     if (ioctl(sock, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1133         JNU_ThrowByNameWithMessageAndLastError
1134             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFCONF) failed&quot;);
1135         return ifs;
1136     }
1137 
1138     // call SIOCGIFCONF to enumerate the interfaces
1139     CHECKED_MALLOC3(buf, char *, ifc.ifc_len);
1140     ifc.ifc_buf = buf;
1141     if (ioctl(sock, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1142         JNU_ThrowByNameWithMessageAndLastError
1143             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFCONF) failed&quot;);
1144         free(buf);
1145         return ifs;
1146     }
1147 
1148     // iterate through each interface
1149     ifreqP = ifc.ifc_req;
1150     for (i = 0; i &lt; ifc.ifc_len / sizeof(struct ifreq); i++, ifreqP++) {
1151         struct sockaddr addr, broadaddr, *broadaddrP = NULL;
1152         short prefix = 0;
1153 
1154         // ignore non IPv4 addresses
1155         if (ifreqP-&gt;ifr_addr.sa_family != AF_INET) {
1156             continue;
1157         }
1158 
1159         // save socket address
1160         memcpy(&amp;addr, &amp;(ifreqP-&gt;ifr_addr), sizeof(struct sockaddr));
1161 
1162         // determine broadcast address, if applicable
1163         if ((ioctl(sock, SIOCGIFFLAGS, ifreqP) == 0) &amp;&amp;
1164             ifreqP-&gt;ifr_flags &amp; IFF_BROADCAST) {
1165 
1166             // restore socket address to ifreqP
1167             memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1168 
1169             if (ioctl(sock, SIOCGIFBRDADDR, ifreqP) == 0) {
1170                 memcpy(&amp;broadaddr, &amp;(ifreqP-&gt;ifr_broadaddr),
1171                        sizeof(struct sockaddr));
1172                 broadaddrP = &amp;broadaddr;
1173             }
1174         }
1175 
1176         // restore socket address to ifreqP
1177         memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1178 
1179         // determine netmask
1180         if (ioctl(sock, SIOCGIFNETMASK, ifreqP) == 0) {
1181             prefix = translateIPv4AddressToPrefix(
1182                          (struct sockaddr_in *)&amp;(ifreqP-&gt;ifr_netmask));
1183         }
1184 
1185         // add interface to the list
1186         ifs = addif(env, sock, ifreqP-&gt;ifr_name, ifs,
1187                     &amp;addr, broadaddrP, AF_INET, prefix);
1188 
1189         // in case of exception, free interface list and buffer and return NULL
1190         if ((*env)-&gt;ExceptionOccurred(env)) {
1191             free(buf);
1192             freeif(ifs);
1193             return NULL;
1194         }
1195     }
1196 
1197     // free buffer
1198     free(buf);
1199     return ifs;
1200 }
1201 
1202 /*
1203  * Enumerates and returns all IPv6 interfaces on Linux.
1204  */
1205 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
1206     FILE *f;
1207     char devname[21], addr6p[8][5];
1208     int prefix, scope, dad_status, if_idx;
1209 
1210     if ((f = fopen(_PATH_PROCNET_IFINET6, &quot;r&quot;)) != NULL) {
1211         while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\n&quot;,
1212                       addr6p[0], addr6p[1], addr6p[2], addr6p[3],
1213                       addr6p[4], addr6p[5], addr6p[6], addr6p[7],
1214                       &amp;if_idx, &amp;prefix, &amp;scope, &amp;dad_status, devname) != EOF) {
1215 
1216             char addr6[40];
1217             struct sockaddr_in6 addr;
1218 
1219             sprintf(addr6, &quot;%s:%s:%s:%s:%s:%s:%s:%s&quot;,
1220                     addr6p[0], addr6p[1], addr6p[2], addr6p[3],
1221                     addr6p[4], addr6p[5], addr6p[6], addr6p[7]);
1222 
1223             memset(&amp;addr, 0, sizeof(struct sockaddr_in6));
1224             inet_pton(AF_INET6, addr6, (void*)addr.sin6_addr.s6_addr);
1225 
1226             // set scope ID to interface index
1227             addr.sin6_scope_id = if_idx;
1228 
1229             // add interface to the list
1230             ifs = addif(env, sock, devname, ifs, (struct sockaddr *)&amp;addr,
1231                         NULL, AF_INET6, (short)prefix);
1232 
1233             // if an exception occurred then return the list as is
1234             if ((*env)-&gt;ExceptionOccurred(env)) {
1235                 break;
1236             }
1237        }
1238        fclose(f);
1239     }
1240     return ifs;
1241 }
1242 
1243 /*
1244  * Try to get the interface index.
1245  */
1246 static int getIndex(int sock, const char *name) {
1247     struct ifreq if2;
1248     memset((char *)&amp;if2, 0, sizeof(if2));
1249     strncpy(if2.ifr_name, name, sizeof(if2.ifr_name) - 1);
1250 
1251     if (ioctl(sock, SIOCGIFINDEX, (char *)&amp;if2) &lt; 0) {
1252         return -1;
1253     }
1254 
1255     return if2.ifr_ifindex;
1256 }
1257 
1258 /*
1259  * Gets the Hardware address (usually MAC address) for the named interface.
1260  * On return puts the data in buf, and returns the length, in byte, of the
1261  * MAC address. Returns -1 if there is no hardware address on that interface.
1262  */
1263 static int getMacAddress
1264   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
1265    unsigned char *buf)
1266 {
1267     struct ifreq ifr;
1268     int i, sock;
1269 
1270     if ((sock = openSocketWithFallback(env, ifname)) &lt; 0) {
1271         return -1;
1272     }
1273 
1274     memset((char *)&amp;ifr, 0, sizeof(ifr));
1275     strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
1276     if (ioctl(sock, SIOCGIFHWADDR, &amp;ifr) &lt; 0) {
1277         JNU_ThrowByNameWithMessageAndLastError
1278             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFHWADDR) failed&quot;);
1279         close(sock);
1280         return -1;
1281     }
1282 
1283     close(sock);
1284     memcpy(buf, &amp;ifr.ifr_hwaddr.sa_data, IFHWADDRLEN);
1285 
1286     // all bytes to 0 means no hardware address
1287     for (i = 0; i &lt; IFHWADDRLEN; i++) {
1288         if (buf[i] != 0)
1289             return IFHWADDRLEN;
1290     }
1291 
1292     return -1;
1293 }
1294 
1295 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
1296     struct ifreq if2;
1297     memset((char *)&amp;if2, 0, sizeof(if2));
1298     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1299 
1300     if (ioctl(sock, SIOCGIFMTU, (char *)&amp;if2) &lt; 0) {
1301         JNU_ThrowByNameWithMessageAndLastError
1302             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFMTU) failed&quot;);
1303         return -1;
1304     }
1305 
1306     return if2.ifr_mtu;
1307 }
1308 
1309 static int getFlags(int sock, const char *ifname, int *flags) {
1310     struct ifreq if2;
1311     memset((char *)&amp;if2, 0, sizeof(if2));
1312     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1313 
1314     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1315         return -1;
1316     }
1317 
1318     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1319         *flags = (if2.ifr_flags &amp; 0xffff);
1320     } else {
1321         *flags = if2.ifr_flags;
1322     }
1323     return 0;
1324 }
1325 
1326 #endif /* __linux__ */
1327 
1328 /** AIX **/
1329 #if defined(_AIX)
1330 
1331 /*
1332  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1333  * if it fails return AF_INET6 socket.
1334  */
1335 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1336     int sock;
1337 
1338     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1339         if (errno == EPROTONOSUPPORT) {
1340             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1341                 JNU_ThrowByNameWithMessageAndLastError
1342                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1343                 return -1;
1344             }
1345         } else { // errno is not NOSUPPORT
1346             JNU_ThrowByNameWithMessageAndLastError
1347                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1348             return -1;
1349         }
1350     }
1351 
1352     return sock;
1353 }
1354 
1355 /*
1356  * Enumerates and returns all IPv4 interfaces on AIX.
1357  */
1358 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1359     struct ifconf ifc;
1360     struct ifreq *ifreqP;
1361     char *buf = NULL;
1362     unsigned i;
1363 
1364     // call SIOCGSIZIFCONF to get the size of SIOCGIFCONF buffer
1365     if (ioctl(sock, SIOCGSIZIFCONF, &amp;(ifc.ifc_len)) &lt; 0) {
1366         JNU_ThrowByNameWithMessageAndLastError
1367             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGSIZIFCONF) failed&quot;);
1368         return ifs;
1369     }
1370 
1371     // call CSIOCGIFCONF instead of SIOCGIFCONF where interface
1372     // records will always have sizeof(struct ifreq) length.
1373     // Be aware that only IPv4 data is complete this way.
1374     CHECKED_MALLOC3(buf, char *, ifc.ifc_len);
1375     ifc.ifc_buf = buf;
1376     if (ioctl(sock, CSIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1377         JNU_ThrowByNameWithMessageAndLastError
1378             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(CSIOCGIFCONF) failed&quot;);
1379         free(buf);
1380         return ifs;
1381     }
1382 
1383     // iterate through each interface
1384     ifreqP = ifc.ifc_req;
1385     for (i = 0; i &lt; ifc.ifc_len / sizeof(struct ifreq); i++, ifreqP++) {
1386         struct sockaddr addr, broadaddr, *broadaddrP = NULL;
1387         short prefix = 0;
1388 
1389         // ignore non IPv4 addresses
1390         if (ifreqP-&gt;ifr_addr.sa_family != AF_INET) {
1391             continue;
1392         }
1393 
1394         // save socket address
1395         memcpy(&amp;addr, &amp;(ifreqP-&gt;ifr_addr), sizeof(struct sockaddr));
1396 
1397         // determine broadcast address, if applicable
1398         if ((ioctl(sock, SIOCGIFFLAGS, ifreqP) == 0) &amp;&amp;
1399             ifreqP-&gt;ifr_flags &amp; IFF_BROADCAST) {
1400 
1401             // restore socket address to ifreqP
1402             memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1403 
1404             if (ioctl(sock, SIOCGIFBRDADDR, ifreqP) == 0) {
1405                 memcpy(&amp;broadaddr, &amp;(ifreqP-&gt;ifr_broadaddr),
1406                        sizeof(struct sockaddr));
1407                 broadaddrP = &amp;broadaddr;
1408             }
1409         }
1410 
1411         // restore socket address to ifreqP
1412         memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1413 
1414         // determine netmask
1415         if (ioctl(sock, SIOCGIFNETMASK, ifreqP) == 0) {
1416             prefix = translateIPv4AddressToPrefix(
1417                          (struct sockaddr_in *)&amp;(ifreqP-&gt;ifr_addr));
1418         }
1419 
1420         // add interface to the list
1421         ifs = addif(env, sock, ifreqP-&gt;ifr_name, ifs,
1422                     &amp;addr, broadaddrP, AF_INET, prefix);
1423 
1424         // in case of exception, free interface list and buffer and return NULL
1425         if ((*env)-&gt;ExceptionOccurred(env)) {
1426             free(buf);
1427             freeif(ifs);
1428             return NULL;
1429         }
1430     }
1431 
1432     // free buffer
1433     free(buf);
1434     return ifs;
1435 }
1436 
1437 /*
1438  * Enumerates and returns all IPv6 interfaces on AIX.
1439  */
1440 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
1441     struct ifconf ifc;
1442     struct ifreq *ifreqP;
1443     char *buf, *cp, *cplimit;
1444 
1445     // call SIOCGSIZIFCONF to get size for SIOCGIFCONF buffer
1446     if (ioctl(sock, SIOCGSIZIFCONF, &amp;(ifc.ifc_len)) &lt; 0) {
1447         JNU_ThrowByNameWithMessageAndLastError
1448             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGSIZIFCONF) failed&quot;);
1449         return ifs;
1450     }
1451 
1452     // call SIOCGIFCONF to enumerate the interfaces
1453     CHECKED_MALLOC3(buf, char *, ifc.ifc_len);
1454     ifc.ifc_buf = buf;
1455     if (ioctl(sock, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1456         JNU_ThrowByNameWithMessageAndLastError
1457             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFCONF) failed&quot;);
1458         free(buf);
1459         return ifs;
1460     }
1461 
1462     // iterate through each interface
1463     ifreqP = ifc.ifc_req;
1464     cp = (char *)ifc.ifc_req;
1465     cplimit = cp + ifc.ifc_len;
1466 
1467     for (; cp &lt; cplimit;
1468          cp += (sizeof(ifreqP-&gt;ifr_name) +
1469                 MAX((ifreqP-&gt;ifr_addr).sa_len, sizeof(ifreqP-&gt;ifr_addr))))
1470     {
1471         ifreqP = (struct ifreq *)cp;
1472         short prefix = 0;
1473 
1474         // ignore non IPv6 addresses
1475         if (ifreqP-&gt;ifr_addr.sa_family != AF_INET6) {
1476             continue;
1477         }
1478 
1479         // determine netmask
1480         struct in6_ifreq if6;
1481         memset((char *)&amp;if6, 0, sizeof(if6));
1482         strncpy(if6.ifr_name, ifreqP-&gt;ifr_name, sizeof(if6.ifr_name) - 1);
1483         memcpy(&amp;(if6.ifr_Addr), &amp;(ifreqP-&gt;ifr_addr),
1484                sizeof(struct sockaddr_in6));
1485         if (ioctl(sock, SIOCGIFNETMASK6, (char *)&amp;if6) &gt;= 0) {
1486             prefix = translateIPv6AddressToPrefix(&amp;(if6.ifr_Addr));
1487         }
1488 
1489         // set scope ID to interface index
1490         ((struct sockaddr_in6 *)&amp;(ifreqP-&gt;ifr_addr))-&gt;sin6_scope_id =
1491             getIndex(sock, ifreqP-&gt;ifr_name);
1492 
1493         // add interface to the list
1494         ifs = addif(env, sock, ifreqP-&gt;ifr_name, ifs,
1495                     (struct sockaddr *)&amp;(ifreqP-&gt;ifr_addr),
1496                     NULL, AF_INET6, prefix);
1497 
1498         // if an exception occurred then free the list
1499         if ((*env)-&gt;ExceptionOccurred(env)) {
1500             free(buf);
1501             freeif(ifs);
1502             return NULL;
1503         }
1504     }
1505 
1506     // free buffer
1507     free(buf);
1508     return ifs;
1509 }
1510 
1511 /*
1512  * Try to get the interface index.
1513  */
1514 static int getIndex(int sock, const char *name) {
1515     int index = if_nametoindex(name);
1516     return (index == 0) ? -1 : index;
1517 }
1518 
1519 /*
1520  * Gets the Hardware address (usually MAC address) for the named interface.
1521  * On return puts the data in buf, and returns the length, in byte, of the
1522  * MAC address. Returns -1 if there is no hardware address on that interface.
1523  */
1524 static int getMacAddress
1525   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
1526    unsigned char *buf)
1527 {
1528     int size;
1529     struct kinfo_ndd *nddp;
1530     void *end;
1531 
1532     size = getkerninfo(KINFO_NDD, 0, 0, 0);
1533     if (size == 0) {
1534         return -1;
1535     }
1536 
1537     if (size &lt; 0) {
1538         perror(&quot;getkerninfo 1&quot;);
1539         return -1;
1540     }
1541 
1542     nddp = (struct kinfo_ndd *)malloc(size);
1543 
1544     if (!nddp) {
1545         JNU_ThrowOutOfMemoryError(env,
1546             &quot;Network interface getMacAddress native buffer allocation failed&quot;);
1547         return -1;
1548     }
1549 
1550     if (getkerninfo(KINFO_NDD, nddp, &amp;size, 0) &lt; 0) {
1551         perror(&quot;getkerninfo 2&quot;);
1552         free(nddp);
1553         return -1;
1554     }
1555 
1556     end = (void *)nddp + size;
1557     while ((void *)nddp &lt; end) {
1558         if (!strcmp(nddp-&gt;ndd_alias, ifname) ||
1559                  !strcmp(nddp-&gt;ndd_name, ifname)) {
1560             bcopy(nddp-&gt;ndd_addr, buf, 6);
1561             free(nddp);
1562             return 6;
1563         } else {
1564             nddp++;
1565         }
1566     }
1567 
1568     free(nddp);
1569     return -1;
1570 }
1571 
1572 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
1573     struct ifreq if2;
1574     memset((char *)&amp;if2, 0, sizeof(if2));
1575     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1576 
1577     if (ioctl(sock, SIOCGIFMTU, (char *)&amp;if2) &lt; 0) {
1578         JNU_ThrowByNameWithMessageAndLastError
1579             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFMTU) failed&quot;);
1580         return -1;
1581     }
1582 
1583     return if2.ifr_mtu;
1584 }
1585 
1586 static int getFlags(int sock, const char *ifname, int *flags) {
1587     struct ifreq if2;
1588     memset((char *)&amp;if2, 0, sizeof(if2));
1589     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1590 
1591     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1592         return -1;
1593     }
1594 
1595     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1596         *flags = (if2.ifr_flags &amp; 0xffff);
1597     } else {
1598         *flags = if2.ifr_flags;
1599     }
1600     return 0;
1601 }
1602 
1603 #endif /* _AIX */
1604 
1605 /** Solaris **/
1606 #if defined(__solaris__)
1607 
1608 /*
1609  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1610  * if it fails return AF_INET6 socket.
1611  */
1612 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1613     int sock, alreadyV6 = 0;
1614     struct lifreq if2;
1615 
1616     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1617         if (errno == EPROTONOSUPPORT) {
1618             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1619                 JNU_ThrowByNameWithMessageAndLastError
1620                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1621                 return -1;
1622             }
1623             alreadyV6 = 1;
1624         } else { // errno is not NOSUPPORT
1625             JNU_ThrowByNameWithMessageAndLastError
1626                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1627             return -1;
1628         }
1629     }
1630 
1631     // Solaris requires that we have an IPv6 socket to query an  interface
1632     // without an IPv4 address - check it here. POSIX 1 require the kernel to
1633     // return ENOTTY if the call is inappropriate for a device e.g. the NETMASK
1634     // for a device having IPv6 only address but not all devices follow the
1635     // standard so fall back on any error. It&#39;s not an ecologically friendly
1636     // gesture but more reliable.
1637     if (!alreadyV6) {
1638         memset((char *)&amp;if2, 0, sizeof(if2));
1639         strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);
1640         if (ioctl(sock, SIOCGLIFNETMASK, (char *)&amp;if2) &lt; 0) {
1641             close(sock);
1642             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1643                 JNU_ThrowByNameWithMessageAndLastError
1644                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1645                 return -1;
1646             }
1647         }
1648     }
1649 
1650     return sock;
1651 }
1652 
1653 /*
1654  * Enumerates and returns all IPv4 interfaces on Solaris.
1655  */
1656 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1657     struct lifconf ifc;
1658     struct lifreq *ifreqP;
1659     struct lifnum numifs;
1660     char *buf = NULL;
1661     unsigned i;
1662 
1663     // call SIOCGLIFNUM to get the interface count
1664     numifs.lifn_family = AF_INET;
1665     numifs.lifn_flags = 0;
1666     if (ioctl(sock, SIOCGLIFNUM, (char *)&amp;numifs) &lt; 0) {
1667         JNU_ThrowByNameWithMessageAndLastError
1668             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFNUM) failed&quot;);
1669         return ifs;
1670     }
1671 
1672     // call SIOCGLIFCONF to enumerate the interfaces
1673     ifc.lifc_len = numifs.lifn_count * sizeof(struct lifreq);
1674     CHECKED_MALLOC3(buf, char *, ifc.lifc_len);
1675     ifc.lifc_buf = buf;
1676     ifc.lifc_family = AF_INET;
1677     ifc.lifc_flags = 0;
1678     if (ioctl(sock, SIOCGLIFCONF, (char *)&amp;ifc) &lt; 0) {
1679         JNU_ThrowByNameWithMessageAndLastError
1680             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFCONF) failed&quot;);
1681         free(buf);
1682         return ifs;
1683     }
1684 
1685     // iterate through each interface
1686     ifreqP = ifc.lifc_req;
1687     for (i = 0; i &lt; numifs.lifn_count; i++, ifreqP++) {
1688         struct sockaddr addr, *broadaddrP = NULL;
1689 
1690         // ignore non IPv4 addresses
1691         if (ifreqP-&gt;lifr_addr.ss_family != AF_INET) {
1692             continue;
1693         }
1694 
1695         // save socket address
1696         memcpy(&amp;addr, &amp;(ifreqP-&gt;lifr_addr), sizeof(struct sockaddr));
1697 
1698         // determine broadcast address, if applicable
1699         if ((ioctl(sock, SIOCGLIFFLAGS, ifreqP) == 0) &amp;&amp;
1700             ifreqP-&gt;lifr_flags &amp; IFF_BROADCAST) {
1701 
1702             // restore socket address to ifreqP
1703             memcpy(&amp;(ifreqP-&gt;lifr_addr), &amp;addr, sizeof(struct sockaddr));
1704 
1705             // query broadcast address and set pointer to it
1706             if (ioctl(sock, SIOCGLIFBRDADDR, ifreqP) == 0) {
1707                 broadaddrP = (struct sockaddr *)&amp;(ifreqP-&gt;lifr_broadaddr);
1708             }
1709         }
1710 
1711         // add to the list
1712         ifs = addif(env, sock, ifreqP-&gt;lifr_name, ifs,
1713                     &amp;addr, broadaddrP, AF_INET, (short)ifreqP-&gt;lifr_addrlen);
1714 
1715         // if an exception occurred we return immediately
1716         if ((*env)-&gt;ExceptionOccurred(env)) {
1717             free(buf);
1718             return ifs;
1719         }
1720    }
1721 
1722     // free buffer
1723     free(buf);
1724     return ifs;
1725 }
1726 
1727 /*
1728  * Enumerates and returns all IPv6 interfaces on Solaris.
1729  */
1730 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
1731     struct lifconf ifc;
1732     struct lifreq *ifreqP;
1733     struct lifnum numifs;
1734     char *buf = NULL;
1735     unsigned i;
1736 
1737     // call SIOCGLIFNUM to get the interface count
1738     numifs.lifn_family = AF_INET6;
1739     numifs.lifn_flags = 0;
1740     if (ioctl(sock, SIOCGLIFNUM, (char *)&amp;numifs) &lt; 0) {
1741         JNU_ThrowByNameWithMessageAndLastError
1742             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFNUM) failed&quot;);
1743         return ifs;
1744     }
1745 
1746     // call SIOCGLIFCONF to enumerate the interfaces
1747     ifc.lifc_len = numifs.lifn_count * sizeof(struct lifreq);
1748     CHECKED_MALLOC3(buf, char *, ifc.lifc_len);
1749     ifc.lifc_buf = buf;
1750     ifc.lifc_family = AF_INET6;
1751     ifc.lifc_flags = 0;
1752     if (ioctl(sock, SIOCGLIFCONF, (char *)&amp;ifc) &lt; 0) {
1753         JNU_ThrowByNameWithMessageAndLastError
1754             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFCONF) failed&quot;);
1755         free(buf);
1756         return ifs;
1757     }
1758 
1759     // iterate through each interface
1760     ifreqP = ifc.lifc_req;
1761     for (i = 0; i &lt; numifs.lifn_count; i++, ifreqP++) {
1762 
1763         // ignore non IPv6 addresses
1764         if (ifreqP-&gt;lifr_addr.ss_family != AF_INET6) {
1765             continue;
1766         }
1767 
1768         // set scope ID to interface index
1769         ((struct sockaddr_in6 *)&amp;(ifreqP-&gt;lifr_addr))-&gt;sin6_scope_id =
1770             getIndex(sock, ifreqP-&gt;lifr_name);
1771 
1772         // add to the list
1773         ifs = addif(env, sock, ifreqP-&gt;lifr_name, ifs,
1774                     (struct sockaddr *)&amp;(ifreqP-&gt;lifr_addr),
1775                     NULL, AF_INET6, (short)ifreqP-&gt;lifr_addrlen);
1776 
1777         // if an exception occurred we return immediately
1778         if ((*env)-&gt;ExceptionOccurred(env)) {
1779             free(buf);
1780             return ifs;
1781         }
1782     }
1783 
1784     // free buffer
1785     free(buf);
1786     return ifs;
1787 }
1788 
1789 /*
1790  * Try to get the interface index.
1791  * (Not supported on Solaris 2.6 or 7)
1792  */
1793 static int getIndex(int sock, const char *name) {
1794     struct lifreq if2;
1795     memset((char *)&amp;if2, 0, sizeof(if2));
1796     strncpy(if2.lifr_name, name, sizeof(if2.lifr_name) - 1);
1797 
1798     if (ioctl(sock, SIOCGLIFINDEX, (char *)&amp;if2) &lt; 0) {
1799         return -1;
1800     }
1801 
1802     return if2.lifr_index;
1803 }
1804 
1805 /*
1806  * Solaris specific DLPI code to get hardware address from a device.
1807  * Unfortunately, at least up to Solaris X, you have to have special
1808  * privileges (i.e. be root).
1809  */
1810 static int getMacFromDevice
1811   (JNIEnv *env, const char *ifname, unsigned char *retbuf)
1812 {
1813     char style1dev[MAXPATHLEN];
1814     int fd;
1815     dl_phys_addr_req_t dlpareq;
1816     dl_phys_addr_ack_t *dlpaack;
1817     struct strbuf msg;
1818     char buf[128];
1819     int flags = 0;
1820 
1821     // Device is in /dev.  e.g.: /dev/bge0
1822     strcpy(style1dev, DEV_PREFIX);
1823     strcat(style1dev, ifname);
1824     if ((fd = open(style1dev, O_RDWR)) &lt; 0) {
1825         // Can&#39;t open it. We probably are missing the privilege.
1826         // We&#39;ll have to try something else
1827         return 0;
1828     }
1829 
1830     dlpareq.dl_primitive = DL_PHYS_ADDR_REQ;
1831     dlpareq.dl_addr_type = DL_CURR_PHYS_ADDR;
1832 
1833     msg.buf = (char *)&amp;dlpareq;
1834     msg.len = DL_PHYS_ADDR_REQ_SIZE;
1835 
1836     if (putmsg(fd, &amp;msg, NULL, 0) &lt; 0) {
1837         JNU_ThrowByNameWithMessageAndLastError
1838             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;putmsg() failed&quot;);
1839         return -1;
1840     }
1841 
1842     dlpaack = (dl_phys_addr_ack_t *)buf;
1843 
1844     msg.buf = (char *)buf;
1845     msg.len = 0;
1846     msg.maxlen = sizeof (buf);
1847     if (getmsg(fd, &amp;msg, NULL, &amp;flags) &lt; 0) {
1848         JNU_ThrowByNameWithMessageAndLastError
1849             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getmsg() failed&quot;);
1850         return -1;
1851     }
1852 
1853     if (msg.len &lt; DL_PHYS_ADDR_ACK_SIZE || dlpaack-&gt;dl_primitive != DL_PHYS_ADDR_ACK) {
1854         JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,
1855                         &quot;Couldn&#39;t obtain phys addr\n&quot;);
1856         return -1;
1857     }
1858 
1859     memcpy(retbuf, &amp;buf[dlpaack-&gt;dl_addr_offset], dlpaack-&gt;dl_addr_length);
1860     return dlpaack-&gt;dl_addr_length;
1861 }
1862 
1863 /*
1864  * Gets the Hardware address (usually MAC address) for the named interface.
1865  * On return puts the data in buf, and returns the length, in byte, of the
1866  * MAC address. Returns -1 if there is no hardware address on that interface.
1867  */
1868 static int getMacAddress
1869   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
1870    unsigned char *buf)
1871 {
1872     struct lifreq if2;
1873     int len, i, sock;
1874 
1875     if ((sock = openSocketWithFallback(env, ifname)) &lt; 0) {
1876         return -1;
1877     }
1878 
1879     // First, try the new (S11) SIOCGLIFHWADDR ioctl(). If that fails
1880     // try the old way.
1881     memset((char *)&amp;if2, 0, sizeof(if2));
1882     strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);
1883 
1884     if (ioctl(sock, SIOCGLIFHWADDR, &amp;if2) != -1) {
1885         struct sockaddr_dl *sp;
1886         sp = (struct sockaddr_dl *)&amp;if2.lifr_addr;
1887         memcpy(buf, &amp;sp-&gt;sdl_data[0], sp-&gt;sdl_alen);
1888         close(sock);
1889         return sp-&gt;sdl_alen;
1890     }
1891 
1892     // On Solaris we have to use DLPI, but it will only work if we have
1893     // privileged access (i.e. root). If that fails, we try a lookup
1894     // in the ARP table, which requires an IPv4 address.
1895     if (((len = getMacFromDevice(env, ifname, buf)) == 0) &amp;&amp; (addr != NULL)) {
1896         struct arpreq arpreq;
1897         struct sockaddr_in *sin;
1898         struct sockaddr_in ipAddr;
1899 
1900         len = 6; //???
1901 
1902         sin = (struct sockaddr_in *)&amp;arpreq.arp_pa;
1903         memset((char *)&amp;arpreq, 0, sizeof(struct arpreq));
1904         ipAddr.sin_port = 0;
1905         ipAddr.sin_family = AF_INET;
1906         memcpy(&amp;ipAddr.sin_addr, addr, sizeof(struct in_addr));
1907         memcpy(&amp;arpreq.arp_pa, &amp;ipAddr, sizeof(struct sockaddr_in));
1908         arpreq.arp_flags= ATF_PUBL;
1909 
1910         if (ioctl(sock, SIOCGARP, &amp;arpreq) &lt; 0) {
1911             close(sock);
1912             return -1;
1913         }
1914 
1915         memcpy(buf, &amp;arpreq.arp_ha.sa_data[0], len);
1916     }
1917     close(sock);
1918 
1919     // all bytes to 0 means no hardware address
1920     for (i = 0; i &lt; len; i++) {
1921         if (buf[i] != 0)
1922             return len;
1923     }
1924 
1925     return -1;
1926 }
1927 
1928 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
1929     struct lifreq if2;
1930     memset((char *)&amp;if2, 0, sizeof(if2));
1931     strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);
1932 
1933     if (ioctl(sock, SIOCGLIFMTU, (char *)&amp;if2) &lt; 0) {
1934         JNU_ThrowByNameWithMessageAndLastError
1935             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFMTU) failed&quot;);
1936         return -1;
1937     }
1938 
1939     return if2.lifr_mtu;
1940 }
1941 
1942 static int getFlags(int sock, const char *ifname, int *flags) {
1943     struct lifreq if2;
1944     memset((char *)&amp;if2, 0, sizeof(if2));
1945     strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);
1946 
1947     if (ioctl(sock, SIOCGLIFFLAGS, (char *)&amp;if2) &lt; 0) {
1948         return -1;
1949     }
1950 
1951     *flags = if2.lifr_flags;
1952     return 0;
1953 }
1954 
1955 #endif /* __solaris__ */
1956 
1957 /** BSD **/
1958 #if defined(_ALLBSD_SOURCE)
1959 
1960 /*
1961  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1962  * if it fails return AF_INET6 socket.
1963  */
1964 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1965     int sock;
1966 
1967     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1968         if (errno == EPROTONOSUPPORT) {
1969             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1970                 JNU_ThrowByNameWithMessageAndLastError
1971                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1972                 return -1;
1973             }
1974         } else { // errno is not NOSUPPORT
1975             JNU_ThrowByNameWithMessageAndLastError
1976                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1977             return -1;
1978         }
1979     }
1980 
1981     return sock;
1982 }
1983 
1984 /*
1985  * Enumerates and returns all IPv4 interfaces on BSD.
1986  */
1987 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1988     struct ifaddrs *ifa, *origifa;
1989 
1990     if (getifaddrs(&amp;origifa) != 0) {
1991         JNU_ThrowByNameWithMessageAndLastError
1992             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getifaddrs() failed&quot;);
1993         return ifs;
1994     }
1995 
1996     for (ifa = origifa; ifa != NULL; ifa = ifa-&gt;ifa_next) {
1997         struct sockaddr *broadaddrP = NULL;
1998 
1999         // ignore non IPv4 addresses
2000         if (ifa-&gt;ifa_addr == NULL || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET)
2001             continue;
2002 
2003         // set ifa_broadaddr, if there is one
2004         if ((ifa-&gt;ifa_flags &amp; IFF_POINTOPOINT) == 0 &amp;&amp;
2005             ifa-&gt;ifa_flags &amp; IFF_BROADCAST) {
2006             broadaddrP = ifa-&gt;ifa_dstaddr;
2007         }
2008 
2009         // add interface to the list
2010         ifs = addif(env, sock, ifa-&gt;ifa_name, ifs, ifa-&gt;ifa_addr,
2011                     broadaddrP, AF_INET,
2012                     translateIPv4AddressToPrefix((struct sockaddr_in *)
2013                                                  ifa-&gt;ifa_netmask));
2014 
2015         // if an exception occurred then free the list
2016         if ((*env)-&gt;ExceptionOccurred(env)) {
2017             freeifaddrs(origifa);
2018             freeif(ifs);
2019             return NULL;
2020         }
2021     }
2022 
2023     // free ifaddrs buffer
2024     freeifaddrs(origifa);
2025     return ifs;
2026 }
2027 
2028 /*
2029  * Enumerates and returns all IPv6 interfaces on BSD.
2030  */
2031 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
2032     struct ifaddrs *ifa, *origifa;
2033 
2034     if (getifaddrs(&amp;origifa) != 0) {
2035         JNU_ThrowByNameWithMessageAndLastError
2036             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getifaddrs() failed&quot;);
2037         return ifs;
2038     }
2039 
2040     for (ifa = origifa; ifa != NULL; ifa = ifa-&gt;ifa_next) {
2041         // ignore non IPv6 addresses
2042         if (ifa-&gt;ifa_addr == NULL || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6)
2043             continue;
2044 
2045         // set scope ID to interface index
2046         ((struct sockaddr_in6 *)ifa-&gt;ifa_addr)-&gt;sin6_scope_id =
2047             getIndex(sock, ifa-&gt;ifa_name);
2048 
2049         // add interface to the list
2050         ifs = addif(env, sock, ifa-&gt;ifa_name, ifs, ifa-&gt;ifa_addr, NULL,
2051                     AF_INET6,
2052                     translateIPv6AddressToPrefix((struct sockaddr_in6 *)
2053                                                  ifa-&gt;ifa_netmask));
2054 
2055         // if an exception occurred then free the list
2056         if ((*env)-&gt;ExceptionOccurred(env)) {
2057             freeifaddrs(origifa);
2058             freeif(ifs);
2059             return NULL;
2060         }
2061     }
2062 
2063     // free ifaddrs buffer
2064     freeifaddrs(origifa);
2065     return ifs;
2066 }
2067 
2068 /*
2069  * Try to get the interface index.
2070  */
2071 static int getIndex(int sock, const char *name) {
2072 #if !defined(__FreeBSD__)
2073     int index = if_nametoindex(name);
2074     return (index == 0) ? -1 : index;
2075 #else
2076     struct ifreq if2;
2077     memset((char *)&amp;if2, 0, sizeof(if2));
2078     strncpy(if2.ifr_name, name, sizeof(if2.ifr_name) - 1);
2079 
2080     if (ioctl(sock, SIOCGIFINDEX, (char *)&amp;if2) &lt; 0) {
2081         return -1;
2082     }
2083 
2084     return if2.ifr_index;
2085 #endif
2086 }
2087 
2088 /*
2089  * Gets the Hardware address (usually MAC address) for the named interface.
2090  * On return puts the data in buf, and returns the length, in byte, of the
2091  * MAC address. Returns -1 if there is no hardware address on that interface.
2092  */
2093 static int getMacAddress
2094   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
2095    unsigned char *buf)
2096 {
2097     struct ifaddrs *ifa0, *ifa;
2098     struct sockaddr *saddr;
2099     int i;
2100 
2101     // grab the interface list
2102     if (!getifaddrs(&amp;ifa0)) {
2103         // cycle through the interfaces
2104         for (i = 0, ifa = ifa0; ifa != NULL; ifa = ifa-&gt;ifa_next, i++) {
2105             saddr = ifa-&gt;ifa_addr;
2106             if (saddr != NULL) {
2107                 // link layer contains the MAC address
2108                 if (saddr-&gt;sa_family == AF_LINK &amp;&amp; !strcmp(ifname, ifa-&gt;ifa_name)) {
2109                     struct sockaddr_dl *sadl = (struct sockaddr_dl *) saddr;
2110                     // check the address has the correct length
2111                     if (sadl-&gt;sdl_alen == ETHER_ADDR_LEN) {
2112                         memcpy(buf, (sadl-&gt;sdl_data + sadl-&gt;sdl_nlen), ETHER_ADDR_LEN);
2113                         freeifaddrs(ifa0);
2114                         return ETHER_ADDR_LEN;
2115                     }
2116                 }
2117             }
2118         }
2119         freeifaddrs(ifa0);
2120     }
2121 
2122     return -1;
2123 }
2124 
2125 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
2126     struct ifreq if2;
2127     memset((char *)&amp;if2, 0, sizeof(if2));
2128     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
2129 
2130     if (ioctl(sock, SIOCGIFMTU, (char *)&amp;if2) &lt; 0) {
2131         JNU_ThrowByNameWithMessageAndLastError
2132             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFMTU) failed&quot;);
2133         return -1;
2134     }
2135 
2136     return if2.ifr_mtu;
2137 }
2138 
2139 static int getFlags(int sock, const char *ifname, int *flags) {
2140     struct ifreq if2;
2141     memset((char *)&amp;if2, 0, sizeof(if2));
2142     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
2143 
2144     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
2145         return -1;
2146     }
2147 
2148     if (sizeof(if2.ifr_flags) == sizeof(short)) {
2149         *flags = (if2.ifr_flags &amp; 0xffff);
2150     } else {
2151         *flags = if2.ifr_flags;
2152     }
2153     return 0;
2154 }
2155 #endif /* _ALLBSD_SOURCE */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/unix/native/libnio/ch/InheritedChannel.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;
 27 #include &lt;sys/types.h&gt;
 28 #include &lt;sys/socket.h&gt;
 29 #include &lt;unistd.h&gt;
 30 #include &lt;fcntl.h&gt;
 31 
 32 #include &quot;jni.h&quot;
 33 
 34 #include &quot;jni.h&quot;
 35 #include &quot;jni_util.h&quot;
 36 #include &quot;net_util.h&quot;
 37 
 38 #include &quot;sun_nio_ch_InheritedChannel.h&quot;
 39 
 40 static int matchFamily(SOCKETADDRESS *sa) {
 41     return (sa-&gt;sa.sa_family == (ipv6_available() ? AF_INET6 : AF_INET));
 42 }
 43 
 44 JNIEXPORT void JNICALL
 45 Java_sun_nio_ch_InheritedChannel_initIDs(JNIEnv *env, jclass cla)
 46 {
 47     /* Initialize InetAddress IDs before later use of NET_XXX functions */
 48     initInetAddressIDs(env);
 49 }
 50 
 51 JNIEXPORT jobject JNICALL
 52 Java_sun_nio_ch_InheritedChannel_peerAddress0(JNIEnv *env, jclass cla, jint fd)
 53 {
 54     SOCKETADDRESS sa;
 55     socklen_t len = sizeof(SOCKETADDRESS);
 56     jobject remote_ia = NULL;
 57     jint remote_port;
 58 
 59     if (getpeername(fd, &amp;sa.sa, &amp;len) == 0) {
 60         if (matchFamily(&amp;sa)) {
 61             remote_ia = NET_SockaddrToInetAddress(env, &amp;sa, (int *)&amp;remote_port);
 62         }
 63     }
 64 
 65     return remote_ia;
 66 }
 67 
 68 JNIEXPORT jint JNICALL
 69 Java_sun_nio_ch_InheritedChannel_peerPort0(JNIEnv *env, jclass cla, jint fd)
 70 {
 71     SOCKETADDRESS sa;
 72     socklen_t len = sizeof(SOCKETADDRESS);
 73     jint remote_port = -1;
 74 
 75     if (getpeername(fd, &amp;sa.sa, &amp;len) == 0) {
 76         if (matchFamily(&amp;sa)) {
 77             NET_SockaddrToInetAddress(env, &amp;sa, (int *)&amp;remote_port);
 78         }
 79     }
 80 
 81     return remote_port;
 82 }
 83 
 84 JNIEXPORT jint JNICALL
 85 Java_sun_nio_ch_InheritedChannel_addressFamily(JNIEnv *env, jclass cla, jint fd)
 86 {
 87     SOCKETADDRESS addr;
 88     socklen_t addrlen = sizeof(addr);
 89 
 90     if (getsockname(fd, (struct sockaddr *)&amp;addr, &amp;addrlen) &lt; 0) {
 91         return sun_nio_ch_InheritedChannel_AF_UNKNOWN;
 92     }
 93     if (addr.sa.sa_family == AF_INET) {
 94         return sun_nio_ch_InheritedChannel_AF_INET;
 95     }
 96     if (addr.sa.sa_family == AF_INET6) {
 97         return sun_nio_ch_InheritedChannel_AF_INET6;
 98     }
 99     if (addr.sa.sa_family == AF_UNIX) {
100         return sun_nio_ch_InheritedChannel_AF_UNIX;
101     }
102     return sun_nio_ch_InheritedChannel_AF_UNKNOWN;
103 }
104 
105 JNIEXPORT jboolean JNICALL
106 Java_sun_nio_ch_InheritedChannel_isConnected(JNIEnv *env, jclass cla, jint fd)
107 {
108     SOCKETADDRESS addr;
109     socklen_t addrlen = sizeof(addr);
110 
111     if (getpeername(fd, (struct sockaddr *)&amp;addr, &amp;addrlen) &lt; 0) {
112         return JNI_FALSE;
113     }
114     return JNI_TRUE;
115 }
116 
117 JNIEXPORT jint JNICALL
118 Java_sun_nio_ch_InheritedChannel_soType0(JNIEnv *env, jclass cla, jint fd)
119 {
120     int sotype;
121     socklen_t arglen = sizeof(sotype);
122     if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype, &amp;arglen) == 0) {
123         if (sotype == SOCK_STREAM)
124             return sun_nio_ch_InheritedChannel_SOCK_STREAM;
125         if (sotype == SOCK_DGRAM)
126             return sun_nio_ch_InheritedChannel_SOCK_DGRAM;
127     }
128     return sun_nio_ch_InheritedChannel_UNKNOWN;
129 }
130 
131 JNIEXPORT jint JNICALL
132 Java_sun_nio_ch_InheritedChannel_dup(JNIEnv *env, jclass cla, jint fd)
133 {
134    int newfd = dup(fd);
135    if (newfd &lt; 0) {
136         JNU_ThrowIOExceptionWithLastError(env, &quot;dup failed&quot;);
137    }
138    return (jint)newfd;
139 }
140 
141 JNIEXPORT void JNICALL
142 Java_sun_nio_ch_InheritedChannel_dup2(JNIEnv *env, jclass cla, jint fd, jint fd2)
143 {
144    if (dup2(fd, fd2) &lt; 0) {
145         JNU_ThrowIOExceptionWithLastError(env, &quot;dup2 failed&quot;);
146    }
147 }
148 
149 JNIEXPORT jint JNICALL
150 Java_sun_nio_ch_InheritedChannel_open0(JNIEnv *env, jclass cla, jstring path, jint oflag)
151 {
152     const char *str;
153     int oflag_actual;
154 
155     /* convert to OS specific value */
156     switch (oflag) {
157         case sun_nio_ch_InheritedChannel_O_RDWR :
158             oflag_actual = O_RDWR;
159             break;
160         case sun_nio_ch_InheritedChannel_O_RDONLY :
161             oflag_actual = O_RDONLY;
162             break;
163         case sun_nio_ch_InheritedChannel_O_WRONLY :
164             oflag_actual = O_WRONLY;
165             break;
166         default :
167             JNU_ThrowInternalError(env, &quot;Unrecognized file mode&quot;);
168             return -1;
169     }
170 
171     str = JNU_GetStringPlatformChars(env, path, NULL);
172     if (str == NULL) {
173         return (jint)-1;
174     } else {
175         int fd = open(str, oflag_actual);
176         if (fd &lt; 0) {
177             JNU_ThrowIOExceptionWithLastError(env, str);
178         }
179         JNU_ReleaseStringPlatformChars(env, path, str);
180         return (jint)fd;
181     }
182 }
183 
184 JNIEXPORT void JNICALL
185 Java_sun_nio_ch_InheritedChannel_close0(JNIEnv *env, jclass cla, jint fd)
186 {
187     if (close(fd) &lt; 0) {
188         JNU_ThrowIOExceptionWithLastError(env, &quot;close failed&quot;);
189     }
190 }
    </pre>
  </body>
</html>
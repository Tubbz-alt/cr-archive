<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../ch/nio_util.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../windows/classes/java/io/WinNTFileSystem.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 126 
 127 static jfieldID attrs_f_frsize;
 128 static jfieldID attrs_f_blocks;
 129 static jfieldID attrs_f_bfree;
 130 static jfieldID attrs_f_bavail;
 131 
 132 static jfieldID entry_name;
 133 static jfieldID entry_dir;
 134 static jfieldID entry_fstype;
 135 static jfieldID entry_options;
 136 static jfieldID entry_dev;
 137 
 138 /**
 139  * System calls that may not be available at run time.
 140  */
 141 typedef int openat64_func(int, const char *, int, ...);
 142 typedef int fstatat64_func(int, const char *, struct stat64 *, int);
 143 typedef int unlinkat_func(int, const char*, int);
 144 typedef int renameat_func(int, const char*, int, const char*);
 145 typedef int futimesat_func(int, const char *, const struct timeval *);


 146 typedef DIR* fdopendir_func(int);
 147 
 148 static openat64_func* my_openat64_func = NULL;
 149 static fstatat64_func* my_fstatat64_func = NULL;
 150 static unlinkat_func* my_unlinkat_func = NULL;
 151 static renameat_func* my_renameat_func = NULL;
 152 static futimesat_func* my_futimesat_func = NULL;


 153 static fdopendir_func* my_fdopendir_func = NULL;
 154 
 155 /**
 156  * fstatat missing from glibc on Linux.
 157  */
 158 #if defined(__linux__) &amp;&amp; (defined(__i386) || defined(__arm__))
 159 #define FSTATAT64_SYSCALL_AVAILABLE
 160 static int fstatat64_wrapper(int dfd, const char *path,
 161                              struct stat64 *statbuf, int flag)
 162 {
 163     #ifndef __NR_fstatat64
 164     #define __NR_fstatat64  300
 165     #endif
 166     return syscall(__NR_fstatat64, dfd, path, statbuf, flag);
 167 }
 168 #endif
 169 
 170 #if defined(__linux__) &amp;&amp; defined(_LP64) &amp;&amp; defined(__NR_newfstatat)
 171 #define FSTATAT64_SYSCALL_AVAILABLE
 172 static int fstatat64_wrapper(int dfd, const char *path,
</pre>
<hr />
<pre>
 252     CHECK_NULL_RETURN(entry_dir, 0);
 253     entry_fstype = (*env)-&gt;GetFieldID(env, clazz, &quot;fstype&quot;, &quot;[B&quot;);
 254     CHECK_NULL_RETURN(entry_fstype, 0);
 255     entry_options = (*env)-&gt;GetFieldID(env, clazz, &quot;opts&quot;, &quot;[B&quot;);
 256     CHECK_NULL_RETURN(entry_options, 0);
 257     entry_dev = (*env)-&gt;GetFieldID(env, clazz, &quot;dev&quot;, &quot;J&quot;);
 258     CHECK_NULL_RETURN(entry_dev, 0);
 259 
 260     /* system calls that might not be available at run time */
 261 
 262 #if (defined(__solaris__) &amp;&amp; defined(_LP64)) || defined(_ALLBSD_SOURCE)
 263     /* Solaris 64-bit does not have openat64/fstatat64 */
 264     my_openat64_func = (openat64_func*)dlsym(RTLD_DEFAULT, &quot;openat&quot;);
 265     my_fstatat64_func = (fstatat64_func*)dlsym(RTLD_DEFAULT, &quot;fstatat&quot;);
 266 #else
 267     my_openat64_func = (openat64_func*) dlsym(RTLD_DEFAULT, &quot;openat64&quot;);
 268     my_fstatat64_func = (fstatat64_func*) dlsym(RTLD_DEFAULT, &quot;fstatat64&quot;);
 269 #endif
 270     my_unlinkat_func = (unlinkat_func*) dlsym(RTLD_DEFAULT, &quot;unlinkat&quot;);
 271     my_renameat_func = (renameat_func*) dlsym(RTLD_DEFAULT, &quot;renameat&quot;);

 272     my_futimesat_func = (futimesat_func*) dlsym(RTLD_DEFAULT, &quot;futimesat&quot;);



 273 #if defined(_AIX)
 274     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, &quot;fdopendir64&quot;);
 275 #else
 276     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, &quot;fdopendir&quot;);
 277 #endif
 278 
 279 #if defined(FSTATAT64_SYSCALL_AVAILABLE)
 280     /* fstatat64 missing from glibc */
 281     if (my_fstatat64_func == NULL)
 282         my_fstatat64_func = (fstatat64_func*)&amp;fstatat64_wrapper;
 283 #endif
 284 
<span class="line-modified"> 285     /* supports futimes or futimesat */</span>
 286 
 287 #ifdef _ALLBSD_SOURCE
 288     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;

 289 #else
 290     if (my_futimesat_func != NULL)
 291         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;


 292 #endif


 293 
 294     /* supports openat, etc. */
 295 
 296     if (my_openat64_func != NULL &amp;&amp;  my_fstatat64_func != NULL &amp;&amp;
 297         my_unlinkat_func != NULL &amp;&amp; my_renameat_func != NULL &amp;&amp;
 298         my_futimesat_func != NULL &amp;&amp; my_fdopendir_func != NULL)
 299     {
 300         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_OPENAT;
 301     }
 302 
 303     /* supports file birthtime */
 304 
 305 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 306     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;
 307 #endif
 308 
 309     return capabilities;
 310 }
 311 
 312 JNIEXPORT jbyteArray JNICALL
</pre>
<hr />
<pre>
 373     }
 374 
 375     return ptr_to_jlong(fp);
 376 }
 377 
 378 JNIEXPORT void JNICALL
 379 Java_sun_nio_fs_UnixNativeDispatcher_fclose(JNIEnv* env, jclass this, jlong stream)
 380 {
 381     FILE* fp = jlong_to_ptr(stream);
 382 
 383     /* NOTE: fclose() wrapper is only used with read-only streams.
 384      * If it ever is used with write streams, it might be better to add
 385      * RESTARTABLE(fflush(fp)) before closing, to make sure the stream
 386      * is completely written even if fclose() failed.
 387      */
 388     if (fclose(fp) == EOF &amp;&amp; errno != EINTR) {
 389         throwUnixException(env, errno);
 390     }
 391 }
 392 













































 393 JNIEXPORT jint JNICALL
 394 Java_sun_nio_fs_UnixNativeDispatcher_open0(JNIEnv* env, jclass this,
 395     jlong pathAddress, jint oflags, jint mode)
 396 {
 397     jint fd;
 398     const char* path = (const char*)jlong_to_ptr(pathAddress);
 399 
 400     RESTARTABLE(open64(path, (int)oflags, (mode_t)mode), fd);
 401     if (fd == -1) {
 402         throwUnixException(env, errno);
 403     }
 404     return fd;
 405 }
 406 
 407 JNIEXPORT jint JNICALL
 408 Java_sun_nio_fs_UnixNativeDispatcher_openat0(JNIEnv* env, jclass this, jint dfd,
 409     jlong pathAddress, jint oflags, jint mode)
 410 {
 411     jint fd;
 412     const char* path = (const char*)jlong_to_ptr(pathAddress);
</pre>
<hr />
<pre>
 658     }
 659 }
 660 
 661 JNIEXPORT void JNICALL
 662 Java_sun_nio_fs_UnixNativeDispatcher_futimes(JNIEnv* env, jclass this, jint filedes,
 663     jlong accessTime, jlong modificationTime)
 664 {
 665     struct timeval times[2];
 666     int err = 0;
 667 
 668     times[0].tv_sec = accessTime / 1000000;
 669     times[0].tv_usec = accessTime % 1000000;
 670 
 671     times[1].tv_sec = modificationTime / 1000000;
 672     times[1].tv_usec = modificationTime % 1000000;
 673 
 674 #ifdef _ALLBSD_SOURCE
 675     RESTARTABLE(futimes(filedes, &amp;times[0]), err);
 676 #else
 677     if (my_futimesat_func == NULL) {
<span class="line-modified"> 678         JNU_ThrowInternalError(env, &quot;my_ftimesat_func is NULL&quot;);</span>
 679         return;
 680     }
 681     RESTARTABLE((*my_futimesat_func)(filedes, NULL, &amp;times[0]), err);
 682 #endif
 683     if (err == -1) {
 684         throwUnixException(env, errno);
 685     }
 686 }
 687 



















































 688 JNIEXPORT jlong JNICALL
 689 Java_sun_nio_fs_UnixNativeDispatcher_opendir0(JNIEnv* env, jclass this,
 690     jlong pathAddress)
 691 {
 692     DIR* dir;
 693     const char* path = (const char*)jlong_to_ptr(pathAddress);
 694 
 695     /* EINTR not listed as a possible error */
 696     dir = opendir(path);
 697     if (dir == NULL) {
 698         throwUnixException(env, errno);
 699     }
 700     return ptr_to_jlong(dir);
 701 }
 702 
 703 JNIEXPORT jlong JNICALL
 704 Java_sun_nio_fs_UnixNativeDispatcher_fdopendir(JNIEnv* env, jclass this, int dfd) {
 705     DIR* dir;
 706 
 707     if (my_fdopendir_func == NULL) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 126 
 127 static jfieldID attrs_f_frsize;
 128 static jfieldID attrs_f_blocks;
 129 static jfieldID attrs_f_bfree;
 130 static jfieldID attrs_f_bavail;
 131 
 132 static jfieldID entry_name;
 133 static jfieldID entry_dir;
 134 static jfieldID entry_fstype;
 135 static jfieldID entry_options;
 136 static jfieldID entry_dev;
 137 
 138 /**
 139  * System calls that may not be available at run time.
 140  */
 141 typedef int openat64_func(int, const char *, int, ...);
 142 typedef int fstatat64_func(int, const char *, struct stat64 *, int);
 143 typedef int unlinkat_func(int, const char*, int);
 144 typedef int renameat_func(int, const char*, int, const char*);
 145 typedef int futimesat_func(int, const char *, const struct timeval *);
<span class="line-added"> 146 typedef int futimens_func(int, const struct timespec *);</span>
<span class="line-added"> 147 typedef int lutimes_func(const char *, const struct timeval *);</span>
 148 typedef DIR* fdopendir_func(int);
 149 
 150 static openat64_func* my_openat64_func = NULL;
 151 static fstatat64_func* my_fstatat64_func = NULL;
 152 static unlinkat_func* my_unlinkat_func = NULL;
 153 static renameat_func* my_renameat_func = NULL;
 154 static futimesat_func* my_futimesat_func = NULL;
<span class="line-added"> 155 static futimens_func* my_futimens_func = NULL;</span>
<span class="line-added"> 156 static lutimes_func* my_lutimes_func = NULL;</span>
 157 static fdopendir_func* my_fdopendir_func = NULL;
 158 
 159 /**
 160  * fstatat missing from glibc on Linux.
 161  */
 162 #if defined(__linux__) &amp;&amp; (defined(__i386) || defined(__arm__))
 163 #define FSTATAT64_SYSCALL_AVAILABLE
 164 static int fstatat64_wrapper(int dfd, const char *path,
 165                              struct stat64 *statbuf, int flag)
 166 {
 167     #ifndef __NR_fstatat64
 168     #define __NR_fstatat64  300
 169     #endif
 170     return syscall(__NR_fstatat64, dfd, path, statbuf, flag);
 171 }
 172 #endif
 173 
 174 #if defined(__linux__) &amp;&amp; defined(_LP64) &amp;&amp; defined(__NR_newfstatat)
 175 #define FSTATAT64_SYSCALL_AVAILABLE
 176 static int fstatat64_wrapper(int dfd, const char *path,
</pre>
<hr />
<pre>
 256     CHECK_NULL_RETURN(entry_dir, 0);
 257     entry_fstype = (*env)-&gt;GetFieldID(env, clazz, &quot;fstype&quot;, &quot;[B&quot;);
 258     CHECK_NULL_RETURN(entry_fstype, 0);
 259     entry_options = (*env)-&gt;GetFieldID(env, clazz, &quot;opts&quot;, &quot;[B&quot;);
 260     CHECK_NULL_RETURN(entry_options, 0);
 261     entry_dev = (*env)-&gt;GetFieldID(env, clazz, &quot;dev&quot;, &quot;J&quot;);
 262     CHECK_NULL_RETURN(entry_dev, 0);
 263 
 264     /* system calls that might not be available at run time */
 265 
 266 #if (defined(__solaris__) &amp;&amp; defined(_LP64)) || defined(_ALLBSD_SOURCE)
 267     /* Solaris 64-bit does not have openat64/fstatat64 */
 268     my_openat64_func = (openat64_func*)dlsym(RTLD_DEFAULT, &quot;openat&quot;);
 269     my_fstatat64_func = (fstatat64_func*)dlsym(RTLD_DEFAULT, &quot;fstatat&quot;);
 270 #else
 271     my_openat64_func = (openat64_func*) dlsym(RTLD_DEFAULT, &quot;openat64&quot;);
 272     my_fstatat64_func = (fstatat64_func*) dlsym(RTLD_DEFAULT, &quot;fstatat64&quot;);
 273 #endif
 274     my_unlinkat_func = (unlinkat_func*) dlsym(RTLD_DEFAULT, &quot;unlinkat&quot;);
 275     my_renameat_func = (renameat_func*) dlsym(RTLD_DEFAULT, &quot;renameat&quot;);
<span class="line-added"> 276 #ifndef _ALLBSD_SOURCE</span>
 277     my_futimesat_func = (futimesat_func*) dlsym(RTLD_DEFAULT, &quot;futimesat&quot;);
<span class="line-added"> 278     my_lutimes_func = (lutimes_func*) dlsym(RTLD_DEFAULT, &quot;lutimes&quot;);</span>
<span class="line-added"> 279 #endif</span>
<span class="line-added"> 280     my_futimens_func = (futimens_func*) dlsym(RTLD_DEFAULT, &quot;futimens&quot;);</span>
 281 #if defined(_AIX)
 282     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, &quot;fdopendir64&quot;);
 283 #else
 284     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, &quot;fdopendir&quot;);
 285 #endif
 286 
 287 #if defined(FSTATAT64_SYSCALL_AVAILABLE)
 288     /* fstatat64 missing from glibc */
 289     if (my_fstatat64_func == NULL)
 290         my_fstatat64_func = (fstatat64_func*)&amp;fstatat64_wrapper;
 291 #endif
 292 
<span class="line-modified"> 293     /* supports futimes or futimesat, futimens, and/or lutimes */</span>
 294 
 295 #ifdef _ALLBSD_SOURCE
 296     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;
<span class="line-added"> 297     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_LUTIMES;</span>
 298 #else
 299     if (my_futimesat_func != NULL)
 300         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;
<span class="line-added"> 301     if (my_lutimes_func != NULL)</span>
<span class="line-added"> 302         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_LUTIMES;</span>
 303 #endif
<span class="line-added"> 304     if (my_futimens_func != NULL)</span>
<span class="line-added"> 305         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMENS;</span>
 306 
 307     /* supports openat, etc. */
 308 
 309     if (my_openat64_func != NULL &amp;&amp;  my_fstatat64_func != NULL &amp;&amp;
 310         my_unlinkat_func != NULL &amp;&amp; my_renameat_func != NULL &amp;&amp;
 311         my_futimesat_func != NULL &amp;&amp; my_fdopendir_func != NULL)
 312     {
 313         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_OPENAT;
 314     }
 315 
 316     /* supports file birthtime */
 317 
 318 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 319     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;
 320 #endif
 321 
 322     return capabilities;
 323 }
 324 
 325 JNIEXPORT jbyteArray JNICALL
</pre>
<hr />
<pre>
 386     }
 387 
 388     return ptr_to_jlong(fp);
 389 }
 390 
 391 JNIEXPORT void JNICALL
 392 Java_sun_nio_fs_UnixNativeDispatcher_fclose(JNIEnv* env, jclass this, jlong stream)
 393 {
 394     FILE* fp = jlong_to_ptr(stream);
 395 
 396     /* NOTE: fclose() wrapper is only used with read-only streams.
 397      * If it ever is used with write streams, it might be better to add
 398      * RESTARTABLE(fflush(fp)) before closing, to make sure the stream
 399      * is completely written even if fclose() failed.
 400      */
 401     if (fclose(fp) == EOF &amp;&amp; errno != EINTR) {
 402         throwUnixException(env, errno);
 403     }
 404 }
 405 
<span class="line-added"> 406 JNIEXPORT void JNICALL</span>
<span class="line-added"> 407 Java_sun_nio_fs_UnixNativeDispatcher_rewind(JNIEnv* env, jclass this, jlong stream)</span>
<span class="line-added"> 408 {</span>
<span class="line-added"> 409     FILE* fp = jlong_to_ptr(stream);</span>
<span class="line-added"> 410     int saved_errno;</span>
<span class="line-added"> 411 </span>
<span class="line-added"> 412     errno = 0;</span>
<span class="line-added"> 413     rewind(fp);</span>
<span class="line-added"> 414     saved_errno = errno;</span>
<span class="line-added"> 415     if (ferror(fp)) {</span>
<span class="line-added"> 416         throwUnixException(env, saved_errno);</span>
<span class="line-added"> 417     }</span>
<span class="line-added"> 418 }</span>
<span class="line-added"> 419 </span>
<span class="line-added"> 420 /**</span>
<span class="line-added"> 421  * This function returns line length without NUL terminator or -1 on EOF.</span>
<span class="line-added"> 422  */</span>
<span class="line-added"> 423 JNIEXPORT jint JNICALL</span>
<span class="line-added"> 424 Java_sun_nio_fs_UnixNativeDispatcher_getlinelen(JNIEnv* env, jclass this, jlong stream)</span>
<span class="line-added"> 425 {</span>
<span class="line-added"> 426     FILE* fp = jlong_to_ptr(stream);</span>
<span class="line-added"> 427     size_t lineSize = 0;</span>
<span class="line-added"> 428     char * lineBuffer = NULL;</span>
<span class="line-added"> 429     int saved_errno;</span>
<span class="line-added"> 430 </span>
<span class="line-added"> 431     ssize_t res = getline(&amp;lineBuffer, &amp;lineSize, fp);</span>
<span class="line-added"> 432     saved_errno = errno;</span>
<span class="line-added"> 433 </span>
<span class="line-added"> 434     /* Should free lineBuffer no matter result, according to man page */</span>
<span class="line-added"> 435     if (lineBuffer != NULL)</span>
<span class="line-added"> 436         free(lineBuffer);</span>
<span class="line-added"> 437 </span>
<span class="line-added"> 438     if (feof(fp))</span>
<span class="line-added"> 439         return -1;</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441     /* On successfull return res &gt;= 0, otherwise res is -1 */</span>
<span class="line-added"> 442     if (res == -1)</span>
<span class="line-added"> 443         throwUnixException(env, saved_errno);</span>
<span class="line-added"> 444 </span>
<span class="line-added"> 445     if (res &gt; INT_MAX)</span>
<span class="line-added"> 446         throwUnixException(env, EOVERFLOW);</span>
<span class="line-added"> 447 </span>
<span class="line-added"> 448     return (jint)res;</span>
<span class="line-added"> 449 }</span>
<span class="line-added"> 450 </span>
 451 JNIEXPORT jint JNICALL
 452 Java_sun_nio_fs_UnixNativeDispatcher_open0(JNIEnv* env, jclass this,
 453     jlong pathAddress, jint oflags, jint mode)
 454 {
 455     jint fd;
 456     const char* path = (const char*)jlong_to_ptr(pathAddress);
 457 
 458     RESTARTABLE(open64(path, (int)oflags, (mode_t)mode), fd);
 459     if (fd == -1) {
 460         throwUnixException(env, errno);
 461     }
 462     return fd;
 463 }
 464 
 465 JNIEXPORT jint JNICALL
 466 Java_sun_nio_fs_UnixNativeDispatcher_openat0(JNIEnv* env, jclass this, jint dfd,
 467     jlong pathAddress, jint oflags, jint mode)
 468 {
 469     jint fd;
 470     const char* path = (const char*)jlong_to_ptr(pathAddress);
</pre>
<hr />
<pre>
 716     }
 717 }
 718 
 719 JNIEXPORT void JNICALL
 720 Java_sun_nio_fs_UnixNativeDispatcher_futimes(JNIEnv* env, jclass this, jint filedes,
 721     jlong accessTime, jlong modificationTime)
 722 {
 723     struct timeval times[2];
 724     int err = 0;
 725 
 726     times[0].tv_sec = accessTime / 1000000;
 727     times[0].tv_usec = accessTime % 1000000;
 728 
 729     times[1].tv_sec = modificationTime / 1000000;
 730     times[1].tv_usec = modificationTime % 1000000;
 731 
 732 #ifdef _ALLBSD_SOURCE
 733     RESTARTABLE(futimes(filedes, &amp;times[0]), err);
 734 #else
 735     if (my_futimesat_func == NULL) {
<span class="line-modified"> 736         JNU_ThrowInternalError(env, &quot;my_futimesat_func is NULL&quot;);</span>
 737         return;
 738     }
 739     RESTARTABLE((*my_futimesat_func)(filedes, NULL, &amp;times[0]), err);
 740 #endif
 741     if (err == -1) {
 742         throwUnixException(env, errno);
 743     }
 744 }
 745 
<span class="line-added"> 746 JNIEXPORT void JNICALL</span>
<span class="line-added"> 747 Java_sun_nio_fs_UnixNativeDispatcher_futimens(JNIEnv* env, jclass this, jint filedes,</span>
<span class="line-added"> 748     jlong accessTime, jlong modificationTime)</span>
<span class="line-added"> 749 {</span>
<span class="line-added"> 750     struct timespec times[2];</span>
<span class="line-added"> 751     int err = 0;</span>
<span class="line-added"> 752 </span>
<span class="line-added"> 753     times[0].tv_sec = accessTime / 1000000000;</span>
<span class="line-added"> 754     times[0].tv_nsec = accessTime % 1000000000;</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756     times[1].tv_sec = modificationTime / 1000000000;</span>
<span class="line-added"> 757     times[1].tv_nsec = modificationTime % 1000000000;</span>
<span class="line-added"> 758 </span>
<span class="line-added"> 759     if (my_futimens_func == NULL) {</span>
<span class="line-added"> 760         JNU_ThrowInternalError(env, &quot;my_futimens_func is NULL&quot;);</span>
<span class="line-added"> 761         return;</span>
<span class="line-added"> 762     }</span>
<span class="line-added"> 763     RESTARTABLE((*my_futimens_func)(filedes, &amp;times[0]), err);</span>
<span class="line-added"> 764     if (err == -1) {</span>
<span class="line-added"> 765         throwUnixException(env, errno);</span>
<span class="line-added"> 766     }</span>
<span class="line-added"> 767 }</span>
<span class="line-added"> 768 </span>
<span class="line-added"> 769 JNIEXPORT void JNICALL</span>
<span class="line-added"> 770 Java_sun_nio_fs_UnixNativeDispatcher_lutimes0(JNIEnv* env, jclass this,</span>
<span class="line-added"> 771     jlong pathAddress, jlong accessTime, jlong modificationTime)</span>
<span class="line-added"> 772 {</span>
<span class="line-added"> 773     int err;</span>
<span class="line-added"> 774     struct timeval times[2];</span>
<span class="line-added"> 775     const char* path = (const char*)jlong_to_ptr(pathAddress);</span>
<span class="line-added"> 776 </span>
<span class="line-added"> 777     times[0].tv_sec = accessTime / 1000000;</span>
<span class="line-added"> 778     times[0].tv_usec = accessTime % 1000000;</span>
<span class="line-added"> 779 </span>
<span class="line-added"> 780     times[1].tv_sec = modificationTime / 1000000;</span>
<span class="line-added"> 781     times[1].tv_usec = modificationTime % 1000000;</span>
<span class="line-added"> 782 </span>
<span class="line-added"> 783 #ifdef _ALLBSD_SOURCE</span>
<span class="line-added"> 784     RESTARTABLE(lutimes(path, &amp;times[0]), err);</span>
<span class="line-added"> 785 #else</span>
<span class="line-added"> 786     if (my_lutimes_func == NULL) {</span>
<span class="line-added"> 787         JNU_ThrowInternalError(env, &quot;my_lutimes_func is NULL&quot;);</span>
<span class="line-added"> 788         return;</span>
<span class="line-added"> 789     }</span>
<span class="line-added"> 790     RESTARTABLE((*my_lutimes_func)(path, &amp;times[0]), err);</span>
<span class="line-added"> 791 #endif</span>
<span class="line-added"> 792     if (err == -1) {</span>
<span class="line-added"> 793         throwUnixException(env, errno);</span>
<span class="line-added"> 794     }</span>
<span class="line-added"> 795 }</span>
<span class="line-added"> 796 </span>
 797 JNIEXPORT jlong JNICALL
 798 Java_sun_nio_fs_UnixNativeDispatcher_opendir0(JNIEnv* env, jclass this,
 799     jlong pathAddress)
 800 {
 801     DIR* dir;
 802     const char* path = (const char*)jlong_to_ptr(pathAddress);
 803 
 804     /* EINTR not listed as a possible error */
 805     dir = opendir(path);
 806     if (dir == NULL) {
 807         throwUnixException(env, errno);
 808     }
 809     return ptr_to_jlong(dir);
 810 }
 811 
 812 JNIEXPORT jlong JNICALL
 813 Java_sun_nio_fs_UnixNativeDispatcher_fdopendir(JNIEnv* env, jclass this, int dfd) {
 814     DIR* dir;
 815 
 816     if (my_fdopendir_func == NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="../ch/nio_util.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../windows/classes/java/io/WinNTFileSystem.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
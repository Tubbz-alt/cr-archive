<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libnio/ch/Net.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="InheritedChannel.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="nio_util.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libnio/ch/Net.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 25 
 26 #include &lt;poll.h&gt;
 27 #include &lt;sys/types.h&gt;
 28 #include &lt;sys/socket.h&gt;
 29 #include &lt;string.h&gt;
 30 #include &lt;netinet/in.h&gt;
 31 #include &lt;netinet/tcp.h&gt;
 32 #include &lt;limits.h&gt;
 33 
 34 #include &quot;jni.h&quot;
 35 #include &quot;jni_util.h&quot;
 36 #include &quot;jvm.h&quot;
 37 #include &quot;jlong.h&quot;
 38 #include &quot;sun_nio_ch_Net.h&quot;
 39 #include &quot;net_util.h&quot;
 40 #include &quot;net_util_md.h&quot;
 41 #include &quot;nio_util.h&quot;
 42 #include &quot;nio.h&quot;
 43 
 44 #ifdef _AIX

 45 #include &lt;sys/utsname.h&gt;
 46 #endif
 47 
 48 /**
 49  * IP_MULTICAST_ALL supported since 2.6.31 but may not be available at
 50  * build time.
 51  */
 52 #ifdef __linux__
 53   #ifndef IP_MULTICAST_ALL
 54     #define IP_MULTICAST_ALL    49
 55   #endif
 56 #endif
 57 
 58 /**
 59  * IPV6_ADD_MEMBERSHIP/IPV6_DROP_MEMBERSHIP may not be defined on OSX and AIX
 60  */
 61 #if defined(__APPLE__) || defined(_AIX)
 62   #ifndef IPV6_ADD_MEMBERSHIP
 63     #define IPV6_ADD_MEMBERSHIP     IPV6_JOIN_GROUP
 64     #define IPV6_DROP_MEMBERSHIP    IPV6_LEAVE_GROUP
 65   #endif
 66 #endif
 67 
<span class="line-removed"> 68 #if defined(_AIX)</span>
<span class="line-removed"> 69   #ifndef IP_BLOCK_SOURCE</span>
<span class="line-removed"> 70     #define IP_BLOCK_SOURCE                 58   /* Block data from a given source to a given group */</span>
<span class="line-removed"> 71     #define IP_UNBLOCK_SOURCE               59   /* Unblock data from a given source to a given group */</span>
<span class="line-removed"> 72     #define IP_ADD_SOURCE_MEMBERSHIP        60   /* Join a source-specific group */</span>
<span class="line-removed"> 73     #define IP_DROP_SOURCE_MEMBERSHIP       61   /* Leave a source-specific group */</span>
<span class="line-removed"> 74   #endif</span>
<span class="line-removed"> 75 </span>
<span class="line-removed"> 76   #ifndef MCAST_BLOCK_SOURCE</span>
<span class="line-removed"> 77     #define MCAST_BLOCK_SOURCE              64</span>
<span class="line-removed"> 78     #define MCAST_UNBLOCK_SOURCE            65</span>
<span class="line-removed"> 79     #define MCAST_JOIN_SOURCE_GROUP         66</span>
<span class="line-removed"> 80     #define MCAST_LEAVE_SOURCE_GROUP        67</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82     /* This means we&#39;re on AIX 5.3 and &#39;group_source_req&#39; and &#39;ip_mreq_source&#39; aren&#39;t defined as well */</span>
<span class="line-removed"> 83     struct group_source_req {</span>
<span class="line-removed"> 84         uint32_t gsr_interface;</span>
<span class="line-removed"> 85         struct sockaddr_storage gsr_group;</span>
<span class="line-removed"> 86         struct sockaddr_storage gsr_source;</span>
<span class="line-removed"> 87     };</span>
<span class="line-removed"> 88     struct ip_mreq_source {</span>
<span class="line-removed"> 89         struct in_addr  imr_multiaddr;  /* IP multicast address of group */</span>
<span class="line-removed"> 90         struct in_addr  imr_sourceaddr; /* IP address of source */</span>
<span class="line-removed"> 91         struct in_addr  imr_interface;  /* local IP address of interface */</span>
<span class="line-removed"> 92     };</span>
<span class="line-removed"> 93   #endif</span>
<span class="line-removed"> 94 #endif /* _AIX */</span>
<span class="line-removed"> 95 </span>
 96 #define COPY_INET6_ADDRESS(env, source, target) \
 97     (*env)-&gt;GetByteArrayRegion(env, source, 0, 16, target)
 98 
 99 /*
100  * Copy IPv6 group, interface index, and IPv6 source address
101  * into group_source_req structure.
102  */
103 static void initGroupSourceReq(JNIEnv* env, jbyteArray group, jint index,
104                                jbyteArray source, struct group_source_req *req)
105 {
106     struct sockaddr_in6* sin6;
107 
108     req-&gt;gsr_interface = (uint32_t)index;
109 
110     sin6 = (struct sockaddr_in6 *)&amp;(req-&gt;gsr_group);
111     sin6-&gt;sin6_family = AF_INET6;
112     COPY_INET6_ADDRESS(env, group, (jbyte *)&amp;(sin6-&gt;sin6_addr));
113 
114     sin6 = (struct sockaddr_in6 *)&amp;(req-&gt;gsr_source);
115     sin6-&gt;sin6_family = AF_INET6;
</pre>
<hr />
<pre>
129         struct utsname uts;
130         memset(&amp;uts, 0, sizeof(uts));
131         strcpy(uts.sysname, &quot;?&quot;);
132         const int utsRes = uname(&amp;uts);
133         int major = -1;
134         int minor = -1;
135         major = atoi(uts.version);
136         minor = atoi(uts.release);
137         if (strcmp(uts.sysname, &quot;AIX&quot;) == 0) {
138             if (major &lt; 6 || (major == 6 &amp;&amp; minor &lt; 1)) {// unsupported on aix &lt; 6.1
139                 result = JNI_FALSE;
140             }
141         }
142         alreadyChecked = JNI_TRUE;
143     }
144     return result;
145 }
146 
147 #endif  /* _AIX */
148 



149 JNIEXPORT void JNICALL
150 Java_sun_nio_ch_Net_initIDs(JNIEnv *env, jclass clazz)
151 {










152      initInetAddressIDs(env);
153 }
154 
155 JNIEXPORT jboolean JNICALL
156 Java_sun_nio_ch_Net_isIPv6Available0(JNIEnv* env, jclass cl)
157 {
158     return (ipv6_available()) ? JNI_TRUE : JNI_FALSE;
159 }
160 
161 JNIEXPORT jboolean JNICALL
162 Java_sun_nio_ch_Net_isReusePortAvailable0(JNIEnv* env, jclass c1)
163 {
164     return (reuseport_available()) ? JNI_TRUE : JNI_FALSE;
165 }
166 
167 JNIEXPORT jint JNICALL
168 Java_sun_nio_ch_Net_isExclusiveBindAvailable(JNIEnv *env, jclass clazz) {
169     return -1;
170 }
171 
172 JNIEXPORT jboolean JNICALL
<span class="line-modified">173 Java_sun_nio_ch_Net_canIPv6SocketJoinIPv4Group0(JNIEnv* env, jclass cl)</span>
174 {
<span class="line-modified">175 #if defined(__APPLE__) || defined(_AIX)</span>
<span class="line-modified">176     /* for now IPv6 sockets cannot join IPv4 multicast groups */</span>
<span class="line-modified">177     return JNI_FALSE;</span>
178 #else










179     return JNI_TRUE;



180 #endif
181 }
182 
183 JNIEXPORT jboolean JNICALL
184 Java_sun_nio_ch_Net_canJoin6WithIPv4Group0(JNIEnv* env, jclass cl)
185 {
<span class="line-modified">186 #ifdef __solaris__</span>

187     return JNI_TRUE;
188 #else

189     return JNI_FALSE;
190 #endif
191 }
192 







193 JNIEXPORT jint JNICALL
194 Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,
195                             jboolean stream, jboolean reuse, jboolean ignored)
196 {
197     int fd;
198     int type = (stream ? SOCK_STREAM : SOCK_DGRAM);
199     int domain = (ipv6_available() &amp;&amp; preferIPv6) ? AF_INET6 : AF_INET;
200 
201     fd = socket(domain, type, 0);
202     if (fd &lt; 0) {
203         return handleSocketError(env, errno);
204     }
205 
<span class="line-modified">206     /* Disable IPV6_V6ONLY to ensure dual-socket support */</span>
<span class="line-modified">207     if (domain == AF_INET6) {</span>


208         int arg = 0;
209         if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&amp;arg,
210                        sizeof(int)) &lt; 0) {
211             JNU_ThrowByNameWithLastError(env,
212                                          JNU_JAVANETPKG &quot;SocketException&quot;,
213                                          &quot;Unable to set IPV6_V6ONLY&quot;);
214             close(fd);
215             return -1;
216         }
217     }
218 
219     if (reuse) {
220         int arg = 1;
221         if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&amp;arg,
222                        sizeof(arg)) &lt; 0) {
223             JNU_ThrowByNameWithLastError(env,
224                                          JNU_JAVANETPKG &quot;SocketException&quot;,
225                                          &quot;Unable to set SO_REUSEADDR&quot;);
226             close(fd);
227             return -1;
</pre>
<hr />
<pre>
291     SOCKETADDRESS sa;
292     int sa_len = 0;
293     int rv;
294 
295     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
296         return IOS_THROWN;
297     }
298 
299     rv = connect(fdval(env, fdo), &amp;sa.sa, sa_len);
300     if (rv != 0) {
301         if (errno == EINPROGRESS) {
302             return IOS_UNAVAILABLE;
303         } else if (errno == EINTR) {
304             return IOS_INTERRUPTED;
305         }
306         return handleSocketError(env, errno);
307     }
308     return 1;
309 }
310 













































311 JNIEXPORT jint JNICALL
312 Java_sun_nio_ch_Net_localPort(JNIEnv *env, jclass clazz, jobject fdo)
313 {
314     SOCKETADDRESS sa;
315     socklen_t sa_len = sizeof(SOCKETADDRESS);
316     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {
317 #ifdef _ALLBSD_SOURCE
318         /*
319          * XXXBSD:
320          * ECONNRESET is specific to the BSDs. We can not return an error,
321          * as the calling Java code with raise a java.lang.Error given the expectation
322          * that getsockname() will never fail. According to the Single UNIX Specification,
323          * it shouldn&#39;t fail. As such, we just fill in generic Linux-compatible values.
324          */
325         if (errno == ECONNRESET) {
326             bzero(&amp;sa.sa4, sizeof(sa));
327             sa.sa4.sin_len = sizeof(struct sockaddr_in);
328             sa.sa4.sin_family = AF_INET;
329             sa.sa4.sin_port = htonl(0);
330             sa.sa4.sin_addr.s_addr = INADDR_ANY;
</pre>
<hr />
<pre>
356          * it shouldn&#39;t fail. As such, we just fill in generic Linux-compatible values.
357          */
358         if (errno == ECONNRESET) {
359             bzero(&amp;sa.sa4, sizeof(sa));
360             sa.sa4.sin_len  = sizeof(struct sockaddr_in);
361             sa.sa4.sin_family = AF_INET;
362             sa.sa4.sin_port = htonl(0);
363             sa.sa4.sin_addr.s_addr = INADDR_ANY;
364         } else {
365             handleSocketError(env, errno);
366             return NULL;
367         }
368 #else /* _ALLBSD_SOURCE */
369         handleSocketError(env, errno);
370         return NULL;
371 #endif /* _ALLBSD_SOURCE */
372     }
373     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
374 }
375 



























376 JNIEXPORT jint JNICALL
377 Java_sun_nio_ch_Net_getIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
378                                   jboolean mayNeedConversion, jint level, jint opt)
379 {
380     int result;
381     struct linger linger;
382     u_char carg;
383     void *arg;
384     socklen_t arglen;
385     int n;
386 
387     /* Option value is an int except for a few specific cases */
388 
389     arg = (void *)&amp;result;
390     arglen = sizeof(result);
391 
392     if (level == IPPROTO_IP &amp;&amp;
393         (opt == IP_MULTICAST_TTL || opt == IP_MULTICAST_LOOP)) {
394         arg = (void*)&amp;carg;
395         arglen = sizeof(carg);
</pre>
<hr />
<pre>
453         arglen = sizeof(linger);
454         if (arg &gt;= 0) {
455             linger.l_onoff = 1;
456             linger.l_linger = arg;
457         } else {
458             linger.l_onoff = 0;
459             linger.l_linger = 0;
460         }
461     }
462 
463     if (mayNeedConversion) {
464         n = NET_SetSockOpt(fdval(env, fdo), level, opt, parg, arglen);
465     } else {
466         n = setsockopt(fdval(env, fdo), level, opt, parg, arglen);
467     }
468     if (n &lt; 0) {
469         JNU_ThrowByNameWithLastError(env,
470                                      JNU_JAVANETPKG &quot;SocketException&quot;,
471                                      &quot;sun.nio.ch.Net.setIntOption&quot;);
472     }
<span class="line-removed">473 #ifdef __linux__</span>
<span class="line-removed">474     if (level == IPPROTO_IPV6 &amp;&amp; opt == IPV6_TCLASS &amp;&amp; isIPv6) {</span>
<span class="line-removed">475         // set the V4 option also</span>
<span class="line-removed">476         setsockopt(fdval(env, fdo), IPPROTO_IP, IP_TOS, parg, arglen);</span>
<span class="line-removed">477     }</span>
<span class="line-removed">478 #endif</span>
479 }
480 
481 JNIEXPORT jint JNICALL
482 Java_sun_nio_ch_Net_joinOrDrop4(JNIEnv *env, jobject this, jboolean join, jobject fdo,
483                                 jint group, jint interf, jint source)
484 {
485     struct ip_mreq mreq;
486     struct ip_mreq_source mreq_source;
487     int opt, n, optlen;
488     void* optval;
489 
490     if (source == 0) {
491         mreq.imr_multiaddr.s_addr = htonl(group);
492         mreq.imr_interface.s_addr = htonl(interf);
493         opt = (join) ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;
494         optval = (void*)&amp;mreq;
495         optlen = sizeof(mreq);
496     } else {
497 
498 #ifdef _AIX
499         /* check AIX for support of source filtering */
500         if (isSourceFilterSupported() != JNI_TRUE){
501             return IOS_UNAVAILABLE;
502         }
503 #endif
504 
505         mreq_source.imr_multiaddr.s_addr = htonl(group);
506         mreq_source.imr_sourceaddr.s_addr = htonl(source);
507         mreq_source.imr_interface.s_addr = htonl(interf);
508         opt = (join) ? IP_ADD_SOURCE_MEMBERSHIP : IP_DROP_SOURCE_MEMBERSHIP;
509         optval = (void*)&amp;mreq_source;
510         optlen = sizeof(mreq_source);
511     }
512 
513     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt, optval, optlen);







514     if (n &lt; 0) {
515         if (join &amp;&amp; (errno == ENOPROTOOPT || errno == EOPNOTSUPP))
516             return IOS_UNAVAILABLE;
517         handleSocketError(env, errno);
518     }
519     return 0;
520 }
521 
522 JNIEXPORT jint JNICALL
523 Java_sun_nio_ch_Net_blockOrUnblock4(JNIEnv *env, jobject this, jboolean block, jobject fdo,
524                                     jint group, jint interf, jint source)
525 {
526 #ifdef __APPLE__
527     /* no IPv4 exclude-mode filtering for now */
528     return IOS_UNAVAILABLE;
529 #else
530     struct ip_mreq_source mreq_source;
531     int n;
532     int opt = (block) ? IP_BLOCK_SOURCE : IP_UNBLOCK_SOURCE;
533 
</pre>
<hr />
<pre>
564 
565     if (source == NULL) {
566         COPY_INET6_ADDRESS(env, group, (jbyte*)&amp;(mreq6.ipv6mr_multiaddr));
567         mreq6.ipv6mr_interface = (int)index;
568         opt = (join) ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP;
569         optval = (void*)&amp;mreq6;
570         optlen = sizeof(mreq6);
571     } else {
572 #ifdef __APPLE__
573         /* no IPv6 include-mode filtering for now */
574         return IOS_UNAVAILABLE;
575 #else
576         initGroupSourceReq(env, group, index, source, &amp;req);
577         opt = (join) ? MCAST_JOIN_SOURCE_GROUP : MCAST_LEAVE_SOURCE_GROUP;
578         optval = (void*)&amp;req;
579         optlen = sizeof(req);
580 #endif
581     }
582 
583     n = setsockopt(fdval(env,fdo), IPPROTO_IPV6, opt, optval, optlen);







584     if (n &lt; 0) {
585         if (join &amp;&amp; (errno == ENOPROTOOPT || errno == EOPNOTSUPP))
586             return IOS_UNAVAILABLE;
587         handleSocketError(env, errno);
588     }
589     return 0;
590 }
591 
592 JNIEXPORT jint JNICALL
593 Java_sun_nio_ch_Net_blockOrUnblock6(JNIEnv *env, jobject this, jboolean block, jobject fdo,
594                                     jbyteArray group, jint index, jbyteArray source)
595 {
596 #ifdef __APPLE__
597     /* no IPv6 exclude-mode filtering for now */
598     return IOS_UNAVAILABLE;
599 #else
600     struct group_source_req req;
601     int n;
602     int opt = (block) ? MCAST_BLOCK_SOURCE : MCAST_UNBLOCK_SOURCE;
603 
</pre>
<hr />
<pre>
702     pfd.fd = fdval(env, fdo);
703     pfd.events = events;
704     if (timeout &lt; -1) {
705         timeout = -1;
706     } else if (timeout &gt; INT_MAX) {
707         timeout = INT_MAX;
708     }
709     rv = poll(&amp;pfd, 1, (int)timeout);
710 
711     if (rv &gt;= 0) {
712         return pfd.revents;
713     } else if (errno == EINTR) {
714         // interrupted, no events to return
715         return 0;
716     } else {
717         handleSocketError(env, errno);
718         return IOS_THROWN;
719     }
720 }
721 
<span class="line-modified">722 JNIEXPORT jint JNICALL</span>
723 Java_sun_nio_ch_Net_pollConnect(JNIEnv *env, jobject this, jobject fdo, jlong timeout)
724 {
725     jint fd = fdval(env, fdo);
726     struct pollfd poller;
727     int result;
728 
729     poller.fd = fd;
730     poller.events = POLLOUT;
731     poller.revents = 0;
732     if (timeout &lt; -1) {
733         timeout = -1;
734     } else if (timeout &gt; INT_MAX) {
735         timeout = INT_MAX;
736     }
737 
738     result = poll(&amp;poller, 1, (int)timeout);
739 
740     if (result &gt; 0) {
741         int error = 0;
742         socklen_t n = sizeof(int);
743         errno = 0;
744         result = getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;n);
745         if (result &lt; 0) {
<span class="line-modified">746             return handleSocketError(env, errno);</span>

747         } else if (error) {
<span class="line-modified">748             return handleSocketError(env, error);</span>

749         } else if ((poller.revents &amp; POLLHUP) != 0) {
<span class="line-modified">750             return handleSocketError(env, ENOTCONN);</span>

751         }
752         // connected
<span class="line-modified">753         return 1;</span>
<span class="line-modified">754     } else if (result == 0) {</span>
<span class="line-modified">755         return 0;</span>
756     } else {
<span class="line-modified">757         if (errno == EINTR) {</span>
<span class="line-modified">758             return IOS_INTERRUPTED;</span>
<span class="line-removed">759         } else {</span>
<span class="line-removed">760             JNU_ThrowIOExceptionWithLastError(env, &quot;poll failed&quot;);</span>
<span class="line-removed">761             return IOS_THROWN;</span>
<span class="line-removed">762         }</span>
763     }
764 }
765 
766 JNIEXPORT jshort JNICALL
767 Java_sun_nio_ch_Net_pollinValue(JNIEnv *env, jclass this)
768 {
769     return (jshort)POLLIN;
770 }
771 
772 JNIEXPORT jshort JNICALL
773 Java_sun_nio_ch_Net_polloutValue(JNIEnv *env, jclass this)
774 {
775     return (jshort)POLLOUT;
776 }
777 
778 JNIEXPORT jshort JNICALL
779 Java_sun_nio_ch_Net_pollerrValue(JNIEnv *env, jclass this)
780 {
781     return (jshort)POLLERR;
782 }
</pre>
<hr />
<pre>
813     char *xn;
814     switch (errorValue) {
815         case EINPROGRESS:       /* Non-blocking connect */
816             return 0;
817 #ifdef EPROTO
818         case EPROTO:
819             xn = JNU_JAVANETPKG &quot;ProtocolException&quot;;
820             break;
821 #endif
822         case ECONNREFUSED:
823         case ETIMEDOUT:
824         case ENOTCONN:
825             xn = JNU_JAVANETPKG &quot;ConnectException&quot;;
826             break;
827 
828         case EHOSTUNREACH:
829             xn = JNU_JAVANETPKG &quot;NoRouteToHostException&quot;;
830             break;
831         case EADDRINUSE:  /* Fall through */
832         case EADDRNOTAVAIL:

833             xn = JNU_JAVANETPKG &quot;BindException&quot;;
834             break;
835         default:
836             xn = JNU_JAVANETPKG &quot;SocketException&quot;;
837             break;
838     }
839     errno = errorValue;
840     JNU_ThrowByNameWithLastError(env, xn, &quot;NioSocketError&quot;);
841     return IOS_THROWN;
842 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 25 
 26 #include &lt;poll.h&gt;
 27 #include &lt;sys/types.h&gt;
 28 #include &lt;sys/socket.h&gt;
 29 #include &lt;string.h&gt;
 30 #include &lt;netinet/in.h&gt;
 31 #include &lt;netinet/tcp.h&gt;
 32 #include &lt;limits.h&gt;
 33 
 34 #include &quot;jni.h&quot;
 35 #include &quot;jni_util.h&quot;
 36 #include &quot;jvm.h&quot;
 37 #include &quot;jlong.h&quot;
 38 #include &quot;sun_nio_ch_Net.h&quot;
 39 #include &quot;net_util.h&quot;
 40 #include &quot;net_util_md.h&quot;
 41 #include &quot;nio_util.h&quot;
 42 #include &quot;nio.h&quot;
 43 
 44 #ifdef _AIX
<span class="line-added"> 45 #include &lt;stdlib.h&gt;</span>
 46 #include &lt;sys/utsname.h&gt;
 47 #endif
 48 
 49 /**
 50  * IP_MULTICAST_ALL supported since 2.6.31 but may not be available at
 51  * build time.
 52  */
 53 #ifdef __linux__
 54   #ifndef IP_MULTICAST_ALL
 55     #define IP_MULTICAST_ALL    49
 56   #endif
 57 #endif
 58 
 59 /**
 60  * IPV6_ADD_MEMBERSHIP/IPV6_DROP_MEMBERSHIP may not be defined on OSX and AIX
 61  */
 62 #if defined(__APPLE__) || defined(_AIX)
 63   #ifndef IPV6_ADD_MEMBERSHIP
 64     #define IPV6_ADD_MEMBERSHIP     IPV6_JOIN_GROUP
 65     #define IPV6_DROP_MEMBERSHIP    IPV6_LEAVE_GROUP
 66   #endif
 67 #endif
 68 




























 69 #define COPY_INET6_ADDRESS(env, source, target) \
 70     (*env)-&gt;GetByteArrayRegion(env, source, 0, 16, target)
 71 
 72 /*
 73  * Copy IPv6 group, interface index, and IPv6 source address
 74  * into group_source_req structure.
 75  */
 76 static void initGroupSourceReq(JNIEnv* env, jbyteArray group, jint index,
 77                                jbyteArray source, struct group_source_req *req)
 78 {
 79     struct sockaddr_in6* sin6;
 80 
 81     req-&gt;gsr_interface = (uint32_t)index;
 82 
 83     sin6 = (struct sockaddr_in6 *)&amp;(req-&gt;gsr_group);
 84     sin6-&gt;sin6_family = AF_INET6;
 85     COPY_INET6_ADDRESS(env, group, (jbyte *)&amp;(sin6-&gt;sin6_addr));
 86 
 87     sin6 = (struct sockaddr_in6 *)&amp;(req-&gt;gsr_source);
 88     sin6-&gt;sin6_family = AF_INET6;
</pre>
<hr />
<pre>
102         struct utsname uts;
103         memset(&amp;uts, 0, sizeof(uts));
104         strcpy(uts.sysname, &quot;?&quot;);
105         const int utsRes = uname(&amp;uts);
106         int major = -1;
107         int minor = -1;
108         major = atoi(uts.version);
109         minor = atoi(uts.release);
110         if (strcmp(uts.sysname, &quot;AIX&quot;) == 0) {
111             if (major &lt; 6 || (major == 6 &amp;&amp; minor &lt; 1)) {// unsupported on aix &lt; 6.1
112                 result = JNI_FALSE;
113             }
114         }
115         alreadyChecked = JNI_TRUE;
116     }
117     return result;
118 }
119 
120 #endif  /* _AIX */
121 
<span class="line-added">122 static jclass isa_class;        /* java.net.InetSocketAddress */</span>
<span class="line-added">123 static jmethodID isa_ctorID;    /* InetSocketAddress(InetAddress, int) */</span>
<span class="line-added">124 </span>
125 JNIEXPORT void JNICALL
126 Java_sun_nio_ch_Net_initIDs(JNIEnv *env, jclass clazz)
127 {
<span class="line-added">128      jclass cls = (*env)-&gt;FindClass(env, &quot;java/net/InetSocketAddress&quot;);</span>
<span class="line-added">129      CHECK_NULL(cls);</span>
<span class="line-added">130      isa_class = (*env)-&gt;NewGlobalRef(env, cls);</span>
<span class="line-added">131      if (isa_class == NULL) {</span>
<span class="line-added">132          JNU_ThrowOutOfMemoryError(env, NULL);</span>
<span class="line-added">133          return;</span>
<span class="line-added">134      }</span>
<span class="line-added">135      isa_ctorID = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;(Ljava/net/InetAddress;I)V&quot;);</span>
<span class="line-added">136      CHECK_NULL(isa_ctorID);</span>
<span class="line-added">137 </span>
138      initInetAddressIDs(env);
139 }
140 
141 JNIEXPORT jboolean JNICALL
142 Java_sun_nio_ch_Net_isIPv6Available0(JNIEnv* env, jclass cl)
143 {
144     return (ipv6_available()) ? JNI_TRUE : JNI_FALSE;
145 }
146 
147 JNIEXPORT jboolean JNICALL
148 Java_sun_nio_ch_Net_isReusePortAvailable0(JNIEnv* env, jclass c1)
149 {
150     return (reuseport_available()) ? JNI_TRUE : JNI_FALSE;
151 }
152 
153 JNIEXPORT jint JNICALL
154 Java_sun_nio_ch_Net_isExclusiveBindAvailable(JNIEnv *env, jclass clazz) {
155     return -1;
156 }
157 
158 JNIEXPORT jboolean JNICALL
<span class="line-modified">159 Java_sun_nio_ch_Net_shouldSetBothIPv4AndIPv6Options0(JNIEnv* env, jclass cl)</span>
160 {
<span class="line-modified">161 #if defined(__linux__)</span>
<span class="line-modified">162     /* Set both IPv4 and IPv6 socket options when setting multicast options */</span>
<span class="line-modified">163     return JNI_TRUE;</span>
164 #else
<span class="line-added">165     /* Do not set both IPv4 and IPv6 socket options when setting multicast options */</span>
<span class="line-added">166     return JNI_FALSE;</span>
<span class="line-added">167 #endif</span>
<span class="line-added">168 }</span>
<span class="line-added">169 </span>
<span class="line-added">170 JNIEXPORT jboolean JNICALL</span>
<span class="line-added">171 Java_sun_nio_ch_Net_canIPv6SocketJoinIPv4Group0(JNIEnv* env, jclass cl)</span>
<span class="line-added">172 {</span>
<span class="line-added">173 #if defined(__linux__) || defined(__APPLE__) || defined(__solaris__)</span>
<span class="line-added">174     /* IPv6 sockets can join IPv4 multicast groups */</span>
175     return JNI_TRUE;
<span class="line-added">176 #else</span>
<span class="line-added">177     /* IPv6 sockets cannot join IPv4 multicast groups */</span>
<span class="line-added">178     return JNI_FALSE;</span>
179 #endif
180 }
181 
182 JNIEXPORT jboolean JNICALL
183 Java_sun_nio_ch_Net_canJoin6WithIPv4Group0(JNIEnv* env, jclass cl)
184 {
<span class="line-modified">185 #if defined(__APPLE__) || defined(__solaris__)</span>
<span class="line-added">186     /* IPV6_ADD_MEMBERSHIP can be used to join IPv4 multicast groups */</span>
187     return JNI_TRUE;
188 #else
<span class="line-added">189     /* IPV6_ADD_MEMBERSHIP cannot be used to join IPv4 multicast groups */</span>
190     return JNI_FALSE;
191 #endif
192 }
193 
<span class="line-added">194 JNIEXPORT jboolean JNICALL</span>
<span class="line-added">195 Java_sun_nio_ch_Net_canUseIPv6OptionsWithIPv4LocalAddress0(JNIEnv* env, jclass cl)</span>
<span class="line-added">196 {</span>
<span class="line-added">197     /* IPV6_XXX socket options can be used on IPv6 sockets bound to IPv4 address */</span>
<span class="line-added">198     return JNI_TRUE;</span>
<span class="line-added">199 }</span>
<span class="line-added">200 </span>
201 JNIEXPORT jint JNICALL
202 Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,
203                             jboolean stream, jboolean reuse, jboolean ignored)
204 {
205     int fd;
206     int type = (stream ? SOCK_STREAM : SOCK_DGRAM);
207     int domain = (ipv6_available() &amp;&amp; preferIPv6) ? AF_INET6 : AF_INET;
208 
209     fd = socket(domain, type, 0);
210     if (fd &lt; 0) {
211         return handleSocketError(env, errno);
212     }
213 
<span class="line-modified">214     /*</span>
<span class="line-modified">215      * If IPv4 is available, disable IPV6_V6ONLY to ensure dual-socket support.</span>
<span class="line-added">216      */</span>
<span class="line-added">217     if (domain == AF_INET6 &amp;&amp; ipv4_available()) {</span>
218         int arg = 0;
219         if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&amp;arg,
220                        sizeof(int)) &lt; 0) {
221             JNU_ThrowByNameWithLastError(env,
222                                          JNU_JAVANETPKG &quot;SocketException&quot;,
223                                          &quot;Unable to set IPV6_V6ONLY&quot;);
224             close(fd);
225             return -1;
226         }
227     }
228 
229     if (reuse) {
230         int arg = 1;
231         if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&amp;arg,
232                        sizeof(arg)) &lt; 0) {
233             JNU_ThrowByNameWithLastError(env,
234                                          JNU_JAVANETPKG &quot;SocketException&quot;,
235                                          &quot;Unable to set SO_REUSEADDR&quot;);
236             close(fd);
237             return -1;
</pre>
<hr />
<pre>
301     SOCKETADDRESS sa;
302     int sa_len = 0;
303     int rv;
304 
305     if (NET_InetAddressToSockaddr(env, iao, port, &amp;sa, &amp;sa_len, preferIPv6) != 0) {
306         return IOS_THROWN;
307     }
308 
309     rv = connect(fdval(env, fdo), &amp;sa.sa, sa_len);
310     if (rv != 0) {
311         if (errno == EINPROGRESS) {
312             return IOS_UNAVAILABLE;
313         } else if (errno == EINTR) {
314             return IOS_INTERRUPTED;
315         }
316         return handleSocketError(env, errno);
317     }
318     return 1;
319 }
320 
<span class="line-added">321 JNIEXPORT jint JNICALL</span>
<span class="line-added">322 Java_sun_nio_ch_Net_accept(JNIEnv *env, jclass clazz, jobject fdo, jobject newfdo,</span>
<span class="line-added">323                            jobjectArray isaa)</span>
<span class="line-added">324 {</span>
<span class="line-added">325     jint fd = fdval(env, fdo);</span>
<span class="line-added">326     jint newfd;</span>
<span class="line-added">327     SOCKETADDRESS sa;</span>
<span class="line-added">328     socklen_t sa_len = sizeof(SOCKETADDRESS);</span>
<span class="line-added">329     jobject remote_ia;</span>
<span class="line-added">330     jint remote_port = 0;</span>
<span class="line-added">331     jobject isa;</span>
<span class="line-added">332 </span>
<span class="line-added">333     /* accept connection but ignore ECONNABORTED */</span>
<span class="line-added">334     for (;;) {</span>
<span class="line-added">335         newfd = accept(fd, &amp;sa.sa, &amp;sa_len);</span>
<span class="line-added">336         if (newfd &gt;= 0) {</span>
<span class="line-added">337             break;</span>
<span class="line-added">338         }</span>
<span class="line-added">339         if (errno != ECONNABORTED) {</span>
<span class="line-added">340             break;</span>
<span class="line-added">341         }</span>
<span class="line-added">342         /* ECONNABORTED =&gt; restart accept */</span>
<span class="line-added">343     }</span>
<span class="line-added">344 </span>
<span class="line-added">345     if (newfd &lt; 0) {</span>
<span class="line-added">346         if (errno == EAGAIN || errno == EWOULDBLOCK)</span>
<span class="line-added">347             return IOS_UNAVAILABLE;</span>
<span class="line-added">348         if (errno == EINTR)</span>
<span class="line-added">349             return IOS_INTERRUPTED;</span>
<span class="line-added">350         JNU_ThrowIOExceptionWithLastError(env, &quot;Accept failed&quot;);</span>
<span class="line-added">351         return IOS_THROWN;</span>
<span class="line-added">352     }</span>
<span class="line-added">353 </span>
<span class="line-added">354     setfdval(env, newfdo, newfd);</span>
<span class="line-added">355 </span>
<span class="line-added">356     remote_ia = NET_SockaddrToInetAddress(env, &amp;sa, (int *)&amp;remote_port);</span>
<span class="line-added">357     CHECK_NULL_RETURN(remote_ia, IOS_THROWN);</span>
<span class="line-added">358 </span>
<span class="line-added">359     isa = (*env)-&gt;NewObject(env, isa_class, isa_ctorID, remote_ia, remote_port);</span>
<span class="line-added">360     CHECK_NULL_RETURN(isa, IOS_THROWN);</span>
<span class="line-added">361     (*env)-&gt;SetObjectArrayElement(env, isaa, 0, isa);</span>
<span class="line-added">362 </span>
<span class="line-added">363     return 1;</span>
<span class="line-added">364 }</span>
<span class="line-added">365 </span>
366 JNIEXPORT jint JNICALL
367 Java_sun_nio_ch_Net_localPort(JNIEnv *env, jclass clazz, jobject fdo)
368 {
369     SOCKETADDRESS sa;
370     socklen_t sa_len = sizeof(SOCKETADDRESS);
371     if (getsockname(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {
372 #ifdef _ALLBSD_SOURCE
373         /*
374          * XXXBSD:
375          * ECONNRESET is specific to the BSDs. We can not return an error,
376          * as the calling Java code with raise a java.lang.Error given the expectation
377          * that getsockname() will never fail. According to the Single UNIX Specification,
378          * it shouldn&#39;t fail. As such, we just fill in generic Linux-compatible values.
379          */
380         if (errno == ECONNRESET) {
381             bzero(&amp;sa.sa4, sizeof(sa));
382             sa.sa4.sin_len = sizeof(struct sockaddr_in);
383             sa.sa4.sin_family = AF_INET;
384             sa.sa4.sin_port = htonl(0);
385             sa.sa4.sin_addr.s_addr = INADDR_ANY;
</pre>
<hr />
<pre>
411          * it shouldn&#39;t fail. As such, we just fill in generic Linux-compatible values.
412          */
413         if (errno == ECONNRESET) {
414             bzero(&amp;sa.sa4, sizeof(sa));
415             sa.sa4.sin_len  = sizeof(struct sockaddr_in);
416             sa.sa4.sin_family = AF_INET;
417             sa.sa4.sin_port = htonl(0);
418             sa.sa4.sin_addr.s_addr = INADDR_ANY;
419         } else {
420             handleSocketError(env, errno);
421             return NULL;
422         }
423 #else /* _ALLBSD_SOURCE */
424         handleSocketError(env, errno);
425         return NULL;
426 #endif /* _ALLBSD_SOURCE */
427     }
428     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);
429 }
430 
<span class="line-added">431 JNIEXPORT jint JNICALL</span>
<span class="line-added">432 Java_sun_nio_ch_Net_remotePort(JNIEnv *env, jclass clazz, jobject fdo)</span>
<span class="line-added">433 {</span>
<span class="line-added">434     SOCKETADDRESS sa;</span>
<span class="line-added">435     socklen_t sa_len = sizeof(sa);</span>
<span class="line-added">436 </span>
<span class="line-added">437     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
<span class="line-added">438         handleSocketError(env, errno);</span>
<span class="line-added">439         return IOS_THROWN;</span>
<span class="line-added">440     }</span>
<span class="line-added">441     return NET_GetPortFromSockaddr(&amp;sa);</span>
<span class="line-added">442 }</span>
<span class="line-added">443 </span>
<span class="line-added">444 JNIEXPORT jobject JNICALL</span>
<span class="line-added">445 Java_sun_nio_ch_Net_remoteInetAddress(JNIEnv *env, jclass clazz, jobject fdo)</span>
<span class="line-added">446 {</span>
<span class="line-added">447     SOCKETADDRESS sa;</span>
<span class="line-added">448     socklen_t sa_len = sizeof(sa);</span>
<span class="line-added">449     int port;</span>
<span class="line-added">450 </span>
<span class="line-added">451     if (getpeername(fdval(env, fdo), &amp;sa.sa, &amp;sa_len) &lt; 0) {</span>
<span class="line-added">452         handleSocketError(env, errno);</span>
<span class="line-added">453         return NULL;</span>
<span class="line-added">454     }</span>
<span class="line-added">455     return NET_SockaddrToInetAddress(env, &amp;sa, &amp;port);</span>
<span class="line-added">456 }</span>
<span class="line-added">457 </span>
458 JNIEXPORT jint JNICALL
459 Java_sun_nio_ch_Net_getIntOption0(JNIEnv *env, jclass clazz, jobject fdo,
460                                   jboolean mayNeedConversion, jint level, jint opt)
461 {
462     int result;
463     struct linger linger;
464     u_char carg;
465     void *arg;
466     socklen_t arglen;
467     int n;
468 
469     /* Option value is an int except for a few specific cases */
470 
471     arg = (void *)&amp;result;
472     arglen = sizeof(result);
473 
474     if (level == IPPROTO_IP &amp;&amp;
475         (opt == IP_MULTICAST_TTL || opt == IP_MULTICAST_LOOP)) {
476         arg = (void*)&amp;carg;
477         arglen = sizeof(carg);
</pre>
<hr />
<pre>
535         arglen = sizeof(linger);
536         if (arg &gt;= 0) {
537             linger.l_onoff = 1;
538             linger.l_linger = arg;
539         } else {
540             linger.l_onoff = 0;
541             linger.l_linger = 0;
542         }
543     }
544 
545     if (mayNeedConversion) {
546         n = NET_SetSockOpt(fdval(env, fdo), level, opt, parg, arglen);
547     } else {
548         n = setsockopt(fdval(env, fdo), level, opt, parg, arglen);
549     }
550     if (n &lt; 0) {
551         JNU_ThrowByNameWithLastError(env,
552                                      JNU_JAVANETPKG &quot;SocketException&quot;,
553                                      &quot;sun.nio.ch.Net.setIntOption&quot;);
554     }






555 }
556 
557 JNIEXPORT jint JNICALL
558 Java_sun_nio_ch_Net_joinOrDrop4(JNIEnv *env, jobject this, jboolean join, jobject fdo,
559                                 jint group, jint interf, jint source)
560 {
561     struct ip_mreq mreq;
562     struct ip_mreq_source mreq_source;
563     int opt, n, optlen;
564     void* optval;
565 
566     if (source == 0) {
567         mreq.imr_multiaddr.s_addr = htonl(group);
568         mreq.imr_interface.s_addr = htonl(interf);
569         opt = (join) ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP;
570         optval = (void*)&amp;mreq;
571         optlen = sizeof(mreq);
572     } else {
573 
574 #ifdef _AIX
575         /* check AIX for support of source filtering */
576         if (isSourceFilterSupported() != JNI_TRUE){
577             return IOS_UNAVAILABLE;
578         }
579 #endif
580 
581         mreq_source.imr_multiaddr.s_addr = htonl(group);
582         mreq_source.imr_sourceaddr.s_addr = htonl(source);
583         mreq_source.imr_interface.s_addr = htonl(interf);
584         opt = (join) ? IP_ADD_SOURCE_MEMBERSHIP : IP_DROP_SOURCE_MEMBERSHIP;
585         optval = (void*)&amp;mreq_source;
586         optlen = sizeof(mreq_source);
587     }
588 
589     n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt, optval, optlen);
<span class="line-added">590 #ifdef __APPLE__</span>
<span class="line-added">591     // workaround macOS bug where IP_ADD_MEMBERSHIP fails intermittently</span>
<span class="line-added">592     if (n &lt; 0 &amp;&amp; errno == ENOMEM) {</span>
<span class="line-added">593         n = setsockopt(fdval(env,fdo), IPPROTO_IP, opt, optval, optlen);</span>
<span class="line-added">594     }</span>
<span class="line-added">595 #endif</span>
<span class="line-added">596 </span>
597     if (n &lt; 0) {
598         if (join &amp;&amp; (errno == ENOPROTOOPT || errno == EOPNOTSUPP))
599             return IOS_UNAVAILABLE;
600         handleSocketError(env, errno);
601     }
602     return 0;
603 }
604 
605 JNIEXPORT jint JNICALL
606 Java_sun_nio_ch_Net_blockOrUnblock4(JNIEnv *env, jobject this, jboolean block, jobject fdo,
607                                     jint group, jint interf, jint source)
608 {
609 #ifdef __APPLE__
610     /* no IPv4 exclude-mode filtering for now */
611     return IOS_UNAVAILABLE;
612 #else
613     struct ip_mreq_source mreq_source;
614     int n;
615     int opt = (block) ? IP_BLOCK_SOURCE : IP_UNBLOCK_SOURCE;
616 
</pre>
<hr />
<pre>
647 
648     if (source == NULL) {
649         COPY_INET6_ADDRESS(env, group, (jbyte*)&amp;(mreq6.ipv6mr_multiaddr));
650         mreq6.ipv6mr_interface = (int)index;
651         opt = (join) ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP;
652         optval = (void*)&amp;mreq6;
653         optlen = sizeof(mreq6);
654     } else {
655 #ifdef __APPLE__
656         /* no IPv6 include-mode filtering for now */
657         return IOS_UNAVAILABLE;
658 #else
659         initGroupSourceReq(env, group, index, source, &amp;req);
660         opt = (join) ? MCAST_JOIN_SOURCE_GROUP : MCAST_LEAVE_SOURCE_GROUP;
661         optval = (void*)&amp;req;
662         optlen = sizeof(req);
663 #endif
664     }
665 
666     n = setsockopt(fdval(env,fdo), IPPROTO_IPV6, opt, optval, optlen);
<span class="line-added">667 #ifdef __APPLE__</span>
<span class="line-added">668     // workaround macOS bug where IPV6_ADD_MEMBERSHIP fails intermittently</span>
<span class="line-added">669     if (n &lt; 0 &amp;&amp; errno == ENOMEM) {</span>
<span class="line-added">670         n = setsockopt(fdval(env,fdo), IPPROTO_IPV6, opt, optval, optlen);</span>
<span class="line-added">671     }</span>
<span class="line-added">672 #endif</span>
<span class="line-added">673 </span>
674     if (n &lt; 0) {
675         if (join &amp;&amp; (errno == ENOPROTOOPT || errno == EOPNOTSUPP))
676             return IOS_UNAVAILABLE;
677         handleSocketError(env, errno);
678     }
679     return 0;
680 }
681 
682 JNIEXPORT jint JNICALL
683 Java_sun_nio_ch_Net_blockOrUnblock6(JNIEnv *env, jobject this, jboolean block, jobject fdo,
684                                     jbyteArray group, jint index, jbyteArray source)
685 {
686 #ifdef __APPLE__
687     /* no IPv6 exclude-mode filtering for now */
688     return IOS_UNAVAILABLE;
689 #else
690     struct group_source_req req;
691     int n;
692     int opt = (block) ? MCAST_BLOCK_SOURCE : MCAST_UNBLOCK_SOURCE;
693 
</pre>
<hr />
<pre>
792     pfd.fd = fdval(env, fdo);
793     pfd.events = events;
794     if (timeout &lt; -1) {
795         timeout = -1;
796     } else if (timeout &gt; INT_MAX) {
797         timeout = INT_MAX;
798     }
799     rv = poll(&amp;pfd, 1, (int)timeout);
800 
801     if (rv &gt;= 0) {
802         return pfd.revents;
803     } else if (errno == EINTR) {
804         // interrupted, no events to return
805         return 0;
806     } else {
807         handleSocketError(env, errno);
808         return IOS_THROWN;
809     }
810 }
811 
<span class="line-modified">812 JNIEXPORT jboolean JNICALL</span>
813 Java_sun_nio_ch_Net_pollConnect(JNIEnv *env, jobject this, jobject fdo, jlong timeout)
814 {
815     jint fd = fdval(env, fdo);
816     struct pollfd poller;
817     int result;
818 
819     poller.fd = fd;
820     poller.events = POLLOUT;
821     poller.revents = 0;
822     if (timeout &lt; -1) {
823         timeout = -1;
824     } else if (timeout &gt; INT_MAX) {
825         timeout = INT_MAX;
826     }
827 
828     result = poll(&amp;poller, 1, (int)timeout);
829 
830     if (result &gt; 0) {
831         int error = 0;
832         socklen_t n = sizeof(int);
833         errno = 0;
834         result = getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;n);
835         if (result &lt; 0) {
<span class="line-modified">836             handleSocketError(env, errno);</span>
<span class="line-added">837             return JNI_FALSE;</span>
838         } else if (error) {
<span class="line-modified">839             handleSocketError(env, error);</span>
<span class="line-added">840             return JNI_FALSE;</span>
841         } else if ((poller.revents &amp; POLLHUP) != 0) {
<span class="line-modified">842             handleSocketError(env, ENOTCONN);</span>
<span class="line-added">843             return JNI_FALSE;</span>
844         }
845         // connected
<span class="line-modified">846         return JNI_TRUE;</span>
<span class="line-modified">847     } else if (result == 0 || errno == EINTR) {</span>
<span class="line-modified">848         return JNI_FALSE;</span>
849     } else {
<span class="line-modified">850         JNU_ThrowIOExceptionWithLastError(env, &quot;poll failed&quot;);</span>
<span class="line-modified">851         return JNI_FALSE;</span>




852     }
853 }
854 
855 JNIEXPORT jshort JNICALL
856 Java_sun_nio_ch_Net_pollinValue(JNIEnv *env, jclass this)
857 {
858     return (jshort)POLLIN;
859 }
860 
861 JNIEXPORT jshort JNICALL
862 Java_sun_nio_ch_Net_polloutValue(JNIEnv *env, jclass this)
863 {
864     return (jshort)POLLOUT;
865 }
866 
867 JNIEXPORT jshort JNICALL
868 Java_sun_nio_ch_Net_pollerrValue(JNIEnv *env, jclass this)
869 {
870     return (jshort)POLLERR;
871 }
</pre>
<hr />
<pre>
902     char *xn;
903     switch (errorValue) {
904         case EINPROGRESS:       /* Non-blocking connect */
905             return 0;
906 #ifdef EPROTO
907         case EPROTO:
908             xn = JNU_JAVANETPKG &quot;ProtocolException&quot;;
909             break;
910 #endif
911         case ECONNREFUSED:
912         case ETIMEDOUT:
913         case ENOTCONN:
914             xn = JNU_JAVANETPKG &quot;ConnectException&quot;;
915             break;
916 
917         case EHOSTUNREACH:
918             xn = JNU_JAVANETPKG &quot;NoRouteToHostException&quot;;
919             break;
920         case EADDRINUSE:  /* Fall through */
921         case EADDRNOTAVAIL:
<span class="line-added">922         case EACCES:</span>
923             xn = JNU_JAVANETPKG &quot;BindException&quot;;
924             break;
925         default:
926             xn = JNU_JAVANETPKG &quot;SocketException&quot;;
927             break;
928     }
929     errno = errorValue;
930     JNU_ThrowByNameWithLastError(env, xn, &quot;NioSocketError&quot;);
931     return IOS_THROWN;
932 }
</pre>
</td>
</tr>
</table>
<center><a href="InheritedChannel.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="nio_util.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
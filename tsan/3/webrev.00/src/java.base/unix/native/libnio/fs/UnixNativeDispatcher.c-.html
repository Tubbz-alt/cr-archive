<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;stdio.h&gt;
  27 #include &lt;stdlib.h&gt;
  28 #include &lt;limits.h&gt;
  29 #include &lt;fcntl.h&gt;
  30 #include &lt;dirent.h&gt;
  31 #include &lt;unistd.h&gt;
  32 #include &lt;errno.h&gt;
  33 #include &lt;dlfcn.h&gt;
  34 #include &lt;sys/types.h&gt;
  35 #include &lt;sys/stat.h&gt;
  36 #ifdef MACOSX
  37 #include &lt;sys/param.h&gt;
  38 #include &lt;sys/mount.h&gt;
  39 #else
  40 #include &lt;sys/statvfs.h&gt;
  41 #endif
  42 #include &lt;sys/time.h&gt;
  43 
  44 /* For POSIX-compliant getpwuid_r, getgrgid_r on Solaris */
  45 #if defined(__solaris__)
  46 #define _POSIX_PTHREAD_SEMANTICS
  47 #endif
  48 #include &lt;pwd.h&gt;
  49 #include &lt;grp.h&gt;
  50 
  51 #ifdef __solaris__
  52 #include &lt;strings.h&gt;
  53 #endif
  54 
  55 #ifdef __linux__
  56 #include &lt;sys/syscall.h&gt;
  57 #endif
  58 
  59 #if defined(__linux__) || defined(_AIX)
  60 #include &lt;string.h&gt;
  61 #endif
  62 
  63 #ifdef _ALLBSD_SOURCE
  64 #include &lt;string.h&gt;
  65 
  66 #define stat64 stat
  67 #ifndef MACOSX
  68 #define statvfs64 statvfs
  69 #endif
  70 
  71 #define open64 open
  72 #define fstat64 fstat
  73 #define lstat64 lstat
  74 #define readdir64 readdir
  75 #endif
  76 
  77 #include &quot;jni.h&quot;
  78 #include &quot;jni_util.h&quot;
  79 #include &quot;jlong.h&quot;
  80 
  81 #include &quot;sun_nio_fs_UnixNativeDispatcher.h&quot;
  82 
  83 #if defined(_AIX)
  84   #define DIR DIR64
  85   #define dirent dirent64
  86   #define opendir opendir64
  87   #define readdir readdir64
  88   #define closedir closedir64
  89 #endif
  90 
  91 /**
  92  * Size of password or group entry when not available via sysconf
  93  */
  94 #define ENT_BUF_SIZE   1024
  95 
  96 #define RESTARTABLE(_cmd, _result) do { \
  97   do { \
  98     _result = _cmd; \
  99   } while((_result == -1) &amp;&amp; (errno == EINTR)); \
 100 } while(0)
 101 
 102 #define RESTARTABLE_RETURN_PTR(_cmd, _result) do { \
 103   do { \
 104     _result = _cmd; \
 105   } while((_result == NULL) &amp;&amp; (errno == EINTR)); \
 106 } while(0)
 107 
 108 static jfieldID attrs_st_mode;
 109 static jfieldID attrs_st_ino;
 110 static jfieldID attrs_st_dev;
 111 static jfieldID attrs_st_rdev;
 112 static jfieldID attrs_st_nlink;
 113 static jfieldID attrs_st_uid;
 114 static jfieldID attrs_st_gid;
 115 static jfieldID attrs_st_size;
 116 static jfieldID attrs_st_atime_sec;
 117 static jfieldID attrs_st_atime_nsec;
 118 static jfieldID attrs_st_mtime_sec;
 119 static jfieldID attrs_st_mtime_nsec;
 120 static jfieldID attrs_st_ctime_sec;
 121 static jfieldID attrs_st_ctime_nsec;
 122 
 123 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 124 static jfieldID attrs_st_birthtime_sec;
 125 #endif
 126 
 127 static jfieldID attrs_f_frsize;
 128 static jfieldID attrs_f_blocks;
 129 static jfieldID attrs_f_bfree;
 130 static jfieldID attrs_f_bavail;
 131 
 132 static jfieldID entry_name;
 133 static jfieldID entry_dir;
 134 static jfieldID entry_fstype;
 135 static jfieldID entry_options;
 136 static jfieldID entry_dev;
 137 
 138 /**
 139  * System calls that may not be available at run time.
 140  */
 141 typedef int openat64_func(int, const char *, int, ...);
 142 typedef int fstatat64_func(int, const char *, struct stat64 *, int);
 143 typedef int unlinkat_func(int, const char*, int);
 144 typedef int renameat_func(int, const char*, int, const char*);
 145 typedef int futimesat_func(int, const char *, const struct timeval *);
 146 typedef DIR* fdopendir_func(int);
 147 
 148 static openat64_func* my_openat64_func = NULL;
 149 static fstatat64_func* my_fstatat64_func = NULL;
 150 static unlinkat_func* my_unlinkat_func = NULL;
 151 static renameat_func* my_renameat_func = NULL;
 152 static futimesat_func* my_futimesat_func = NULL;
 153 static fdopendir_func* my_fdopendir_func = NULL;
 154 
 155 /**
 156  * fstatat missing from glibc on Linux.
 157  */
 158 #if defined(__linux__) &amp;&amp; (defined(__i386) || defined(__arm__))
 159 #define FSTATAT64_SYSCALL_AVAILABLE
 160 static int fstatat64_wrapper(int dfd, const char *path,
 161                              struct stat64 *statbuf, int flag)
 162 {
 163     #ifndef __NR_fstatat64
 164     #define __NR_fstatat64  300
 165     #endif
 166     return syscall(__NR_fstatat64, dfd, path, statbuf, flag);
 167 }
 168 #endif
 169 
 170 #if defined(__linux__) &amp;&amp; defined(_LP64) &amp;&amp; defined(__NR_newfstatat)
 171 #define FSTATAT64_SYSCALL_AVAILABLE
 172 static int fstatat64_wrapper(int dfd, const char *path,
 173                              struct stat64 *statbuf, int flag)
 174 {
 175     return syscall(__NR_newfstatat, dfd, path, statbuf, flag);
 176 }
 177 #endif
 178 
 179 /**
 180  * Call this to throw an internal UnixException when a system/library
 181  * call fails
 182  */
 183 static void throwUnixException(JNIEnv* env, int errnum) {
 184     jobject x = JNU_NewObjectByName(env, &quot;sun/nio/fs/UnixException&quot;,
 185         &quot;(I)V&quot;, errnum);
 186     if (x != NULL) {
 187         (*env)-&gt;Throw(env, x);
 188     }
 189 }
 190 
 191 /**
 192  * Initialization
 193  */
 194 JNIEXPORT jint JNICALL
 195 Java_sun_nio_fs_UnixNativeDispatcher_init(JNIEnv* env, jclass this)
 196 {
 197     jint capabilities = 0;
 198     jclass clazz;
 199 
 200     clazz = (*env)-&gt;FindClass(env, &quot;sun/nio/fs/UnixFileAttributes&quot;);
 201     CHECK_NULL_RETURN(clazz, 0);
 202     attrs_st_mode = (*env)-&gt;GetFieldID(env, clazz, &quot;st_mode&quot;, &quot;I&quot;);
 203     CHECK_NULL_RETURN(attrs_st_mode, 0);
 204     attrs_st_ino = (*env)-&gt;GetFieldID(env, clazz, &quot;st_ino&quot;, &quot;J&quot;);
 205     CHECK_NULL_RETURN(attrs_st_ino, 0);
 206     attrs_st_dev = (*env)-&gt;GetFieldID(env, clazz, &quot;st_dev&quot;, &quot;J&quot;);
 207     CHECK_NULL_RETURN(attrs_st_dev, 0);
 208     attrs_st_rdev = (*env)-&gt;GetFieldID(env, clazz, &quot;st_rdev&quot;, &quot;J&quot;);
 209     CHECK_NULL_RETURN(attrs_st_rdev, 0);
 210     attrs_st_nlink = (*env)-&gt;GetFieldID(env, clazz, &quot;st_nlink&quot;, &quot;I&quot;);
 211     CHECK_NULL_RETURN(attrs_st_nlink, 0);
 212     attrs_st_uid = (*env)-&gt;GetFieldID(env, clazz, &quot;st_uid&quot;, &quot;I&quot;);
 213     CHECK_NULL_RETURN(attrs_st_uid, 0);
 214     attrs_st_gid = (*env)-&gt;GetFieldID(env, clazz, &quot;st_gid&quot;, &quot;I&quot;);
 215     CHECK_NULL_RETURN(attrs_st_gid, 0);
 216     attrs_st_size = (*env)-&gt;GetFieldID(env, clazz, &quot;st_size&quot;, &quot;J&quot;);
 217     CHECK_NULL_RETURN(attrs_st_size, 0);
 218     attrs_st_atime_sec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_atime_sec&quot;, &quot;J&quot;);
 219     CHECK_NULL_RETURN(attrs_st_atime_sec, 0);
 220     attrs_st_atime_nsec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_atime_nsec&quot;, &quot;J&quot;);
 221     CHECK_NULL_RETURN(attrs_st_atime_nsec, 0);
 222     attrs_st_mtime_sec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_mtime_sec&quot;, &quot;J&quot;);
 223     CHECK_NULL_RETURN(attrs_st_mtime_sec, 0);
 224     attrs_st_mtime_nsec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_mtime_nsec&quot;, &quot;J&quot;);
 225     CHECK_NULL_RETURN(attrs_st_mtime_nsec, 0);
 226     attrs_st_ctime_sec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_ctime_sec&quot;, &quot;J&quot;);
 227     CHECK_NULL_RETURN(attrs_st_ctime_sec, 0);
 228     attrs_st_ctime_nsec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_ctime_nsec&quot;, &quot;J&quot;);
 229     CHECK_NULL_RETURN(attrs_st_ctime_nsec, 0);
 230 
 231 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 232     attrs_st_birthtime_sec = (*env)-&gt;GetFieldID(env, clazz, &quot;st_birthtime_sec&quot;, &quot;J&quot;);
 233     CHECK_NULL_RETURN(attrs_st_birthtime_sec, 0);
 234 #endif
 235 
 236     clazz = (*env)-&gt;FindClass(env, &quot;sun/nio/fs/UnixFileStoreAttributes&quot;);
 237     CHECK_NULL_RETURN(clazz, 0);
 238     attrs_f_frsize = (*env)-&gt;GetFieldID(env, clazz, &quot;f_frsize&quot;, &quot;J&quot;);
 239     CHECK_NULL_RETURN(attrs_f_frsize, 0);
 240     attrs_f_blocks = (*env)-&gt;GetFieldID(env, clazz, &quot;f_blocks&quot;, &quot;J&quot;);
 241     CHECK_NULL_RETURN(attrs_f_blocks, 0);
 242     attrs_f_bfree = (*env)-&gt;GetFieldID(env, clazz, &quot;f_bfree&quot;, &quot;J&quot;);
 243     CHECK_NULL_RETURN(attrs_f_bfree, 0);
 244     attrs_f_bavail = (*env)-&gt;GetFieldID(env, clazz, &quot;f_bavail&quot;, &quot;J&quot;);
 245     CHECK_NULL_RETURN(attrs_f_bavail, 0);
 246 
 247     clazz = (*env)-&gt;FindClass(env, &quot;sun/nio/fs/UnixMountEntry&quot;);
 248     CHECK_NULL_RETURN(clazz, 0);
 249     entry_name = (*env)-&gt;GetFieldID(env, clazz, &quot;name&quot;, &quot;[B&quot;);
 250     CHECK_NULL_RETURN(entry_name, 0);
 251     entry_dir = (*env)-&gt;GetFieldID(env, clazz, &quot;dir&quot;, &quot;[B&quot;);
 252     CHECK_NULL_RETURN(entry_dir, 0);
 253     entry_fstype = (*env)-&gt;GetFieldID(env, clazz, &quot;fstype&quot;, &quot;[B&quot;);
 254     CHECK_NULL_RETURN(entry_fstype, 0);
 255     entry_options = (*env)-&gt;GetFieldID(env, clazz, &quot;opts&quot;, &quot;[B&quot;);
 256     CHECK_NULL_RETURN(entry_options, 0);
 257     entry_dev = (*env)-&gt;GetFieldID(env, clazz, &quot;dev&quot;, &quot;J&quot;);
 258     CHECK_NULL_RETURN(entry_dev, 0);
 259 
 260     /* system calls that might not be available at run time */
 261 
 262 #if (defined(__solaris__) &amp;&amp; defined(_LP64)) || defined(_ALLBSD_SOURCE)
 263     /* Solaris 64-bit does not have openat64/fstatat64 */
 264     my_openat64_func = (openat64_func*)dlsym(RTLD_DEFAULT, &quot;openat&quot;);
 265     my_fstatat64_func = (fstatat64_func*)dlsym(RTLD_DEFAULT, &quot;fstatat&quot;);
 266 #else
 267     my_openat64_func = (openat64_func*) dlsym(RTLD_DEFAULT, &quot;openat64&quot;);
 268     my_fstatat64_func = (fstatat64_func*) dlsym(RTLD_DEFAULT, &quot;fstatat64&quot;);
 269 #endif
 270     my_unlinkat_func = (unlinkat_func*) dlsym(RTLD_DEFAULT, &quot;unlinkat&quot;);
 271     my_renameat_func = (renameat_func*) dlsym(RTLD_DEFAULT, &quot;renameat&quot;);
 272     my_futimesat_func = (futimesat_func*) dlsym(RTLD_DEFAULT, &quot;futimesat&quot;);
 273 #if defined(_AIX)
 274     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, &quot;fdopendir64&quot;);
 275 #else
 276     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, &quot;fdopendir&quot;);
 277 #endif
 278 
 279 #if defined(FSTATAT64_SYSCALL_AVAILABLE)
 280     /* fstatat64 missing from glibc */
 281     if (my_fstatat64_func == NULL)
 282         my_fstatat64_func = (fstatat64_func*)&amp;fstatat64_wrapper;
 283 #endif
 284 
 285     /* supports futimes or futimesat */
 286 
 287 #ifdef _ALLBSD_SOURCE
 288     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;
 289 #else
 290     if (my_futimesat_func != NULL)
 291         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;
 292 #endif
 293 
 294     /* supports openat, etc. */
 295 
 296     if (my_openat64_func != NULL &amp;&amp;  my_fstatat64_func != NULL &amp;&amp;
 297         my_unlinkat_func != NULL &amp;&amp; my_renameat_func != NULL &amp;&amp;
 298         my_futimesat_func != NULL &amp;&amp; my_fdopendir_func != NULL)
 299     {
 300         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_OPENAT;
 301     }
 302 
 303     /* supports file birthtime */
 304 
 305 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 306     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;
 307 #endif
 308 
 309     return capabilities;
 310 }
 311 
 312 JNIEXPORT jbyteArray JNICALL
 313 Java_sun_nio_fs_UnixNativeDispatcher_getcwd(JNIEnv* env, jclass this) {
 314     jbyteArray result = NULL;
 315     char buf[PATH_MAX+1];
 316 
 317     /* EINTR not listed as a possible error */
 318     char* cwd = getcwd(buf, sizeof(buf));
 319     if (cwd == NULL) {
 320         throwUnixException(env, errno);
 321     } else {
 322         jsize len = (jsize)strlen(buf);
 323         result = (*env)-&gt;NewByteArray(env, len);
 324         if (result != NULL) {
 325             (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)buf);
 326         }
 327     }
 328     return result;
 329 }
 330 
 331 JNIEXPORT jbyteArray
 332 Java_sun_nio_fs_UnixNativeDispatcher_strerror(JNIEnv* env, jclass this, jint error)
 333 {
 334     char tmpbuf[1024];
 335     jsize len;
 336     jbyteArray bytes;
 337 
 338     getErrorString((int)errno, tmpbuf, sizeof(tmpbuf));
 339     len = strlen(tmpbuf);
 340     bytes = (*env)-&gt;NewByteArray(env, len);
 341     if (bytes != NULL) {
 342         (*env)-&gt;SetByteArrayRegion(env, bytes, 0, len, (jbyte*)tmpbuf);
 343     }
 344     return bytes;
 345 }
 346 
 347 JNIEXPORT jint
 348 Java_sun_nio_fs_UnixNativeDispatcher_dup(JNIEnv* env, jclass this, jint fd) {
 349 
 350     int res = -1;
 351 
 352     RESTARTABLE(dup((int)fd), res);
 353     if (res == -1) {
 354         throwUnixException(env, errno);
 355     }
 356     return (jint)res;
 357 }
 358 
 359 JNIEXPORT jlong JNICALL
 360 Java_sun_nio_fs_UnixNativeDispatcher_fopen0(JNIEnv* env, jclass this,
 361     jlong pathAddress, jlong modeAddress)
 362 {
 363     FILE* fp = NULL;
 364     const char* path = (const char*)jlong_to_ptr(pathAddress);
 365     const char* mode = (const char*)jlong_to_ptr(modeAddress);
 366 
 367     do {
 368         fp = fopen(path, mode);
 369     } while (fp == NULL &amp;&amp; errno == EINTR);
 370 
 371     if (fp == NULL) {
 372         throwUnixException(env, errno);
 373     }
 374 
 375     return ptr_to_jlong(fp);
 376 }
 377 
 378 JNIEXPORT void JNICALL
 379 Java_sun_nio_fs_UnixNativeDispatcher_fclose(JNIEnv* env, jclass this, jlong stream)
 380 {
 381     FILE* fp = jlong_to_ptr(stream);
 382 
 383     /* NOTE: fclose() wrapper is only used with read-only streams.
 384      * If it ever is used with write streams, it might be better to add
 385      * RESTARTABLE(fflush(fp)) before closing, to make sure the stream
 386      * is completely written even if fclose() failed.
 387      */
 388     if (fclose(fp) == EOF &amp;&amp; errno != EINTR) {
 389         throwUnixException(env, errno);
 390     }
 391 }
 392 
 393 JNIEXPORT jint JNICALL
 394 Java_sun_nio_fs_UnixNativeDispatcher_open0(JNIEnv* env, jclass this,
 395     jlong pathAddress, jint oflags, jint mode)
 396 {
 397     jint fd;
 398     const char* path = (const char*)jlong_to_ptr(pathAddress);
 399 
 400     RESTARTABLE(open64(path, (int)oflags, (mode_t)mode), fd);
 401     if (fd == -1) {
 402         throwUnixException(env, errno);
 403     }
 404     return fd;
 405 }
 406 
 407 JNIEXPORT jint JNICALL
 408 Java_sun_nio_fs_UnixNativeDispatcher_openat0(JNIEnv* env, jclass this, jint dfd,
 409     jlong pathAddress, jint oflags, jint mode)
 410 {
 411     jint fd;
 412     const char* path = (const char*)jlong_to_ptr(pathAddress);
 413 
 414     if (my_openat64_func == NULL) {
 415         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 416         return -1;
 417     }
 418 
 419     RESTARTABLE((*my_openat64_func)(dfd, path, (int)oflags, (mode_t)mode), fd);
 420     if (fd == -1) {
 421         throwUnixException(env, errno);
 422     }
 423     return fd;
 424 }
 425 
 426 JNIEXPORT void JNICALL
 427 Java_sun_nio_fs_UnixNativeDispatcher_close0(JNIEnv* env, jclass this, jint fd) {
 428     int res;
 429 
 430 #if defined(_AIX)
 431     /* AIX allows close to be restarted after EINTR */
 432     RESTARTABLE(close((int)fd), res);
 433 #else
 434     res = close((int)fd);
 435 #endif
 436     if (res == -1 &amp;&amp; errno != EINTR) {
 437         throwUnixException(env, errno);
 438     }
 439 }
 440 
 441 JNIEXPORT jint JNICALL
 442 Java_sun_nio_fs_UnixNativeDispatcher_read(JNIEnv* env, jclass this, jint fd,
 443     jlong address, jint nbytes)
 444 {
 445     ssize_t n;
 446     void* bufp = jlong_to_ptr(address);
 447     RESTARTABLE(read((int)fd, bufp, (size_t)nbytes), n);
 448     if (n == -1) {
 449         throwUnixException(env, errno);
 450     }
 451     return (jint)n;
 452 }
 453 
 454 JNIEXPORT jint JNICALL
 455 Java_sun_nio_fs_UnixNativeDispatcher_write(JNIEnv* env, jclass this, jint fd,
 456     jlong address, jint nbytes)
 457 {
 458     ssize_t n;
 459     void* bufp = jlong_to_ptr(address);
 460     RESTARTABLE(write((int)fd, bufp, (size_t)nbytes), n);
 461     if (n == -1) {
 462         throwUnixException(env, errno);
 463     }
 464     return (jint)n;
 465 }
 466 
 467 /**
 468  * Copy stat64 members into sun.nio.fs.UnixFileAttributes
 469  */
 470 static void prepAttributes(JNIEnv* env, struct stat64* buf, jobject attrs) {
 471     (*env)-&gt;SetIntField(env, attrs, attrs_st_mode, (jint)buf-&gt;st_mode);
 472     (*env)-&gt;SetLongField(env, attrs, attrs_st_ino, (jlong)buf-&gt;st_ino);
 473     (*env)-&gt;SetLongField(env, attrs, attrs_st_dev, (jlong)buf-&gt;st_dev);
 474     (*env)-&gt;SetLongField(env, attrs, attrs_st_rdev, (jlong)buf-&gt;st_rdev);
 475     (*env)-&gt;SetIntField(env, attrs, attrs_st_nlink, (jint)buf-&gt;st_nlink);
 476     (*env)-&gt;SetIntField(env, attrs, attrs_st_uid, (jint)buf-&gt;st_uid);
 477     (*env)-&gt;SetIntField(env, attrs, attrs_st_gid, (jint)buf-&gt;st_gid);
 478     (*env)-&gt;SetLongField(env, attrs, attrs_st_size, (jlong)buf-&gt;st_size);
 479     (*env)-&gt;SetLongField(env, attrs, attrs_st_atime_sec, (jlong)buf-&gt;st_atime);
 480     (*env)-&gt;SetLongField(env, attrs, attrs_st_mtime_sec, (jlong)buf-&gt;st_mtime);
 481     (*env)-&gt;SetLongField(env, attrs, attrs_st_ctime_sec, (jlong)buf-&gt;st_ctime);
 482 
 483 #ifdef _DARWIN_FEATURE_64_BIT_INODE
 484     (*env)-&gt;SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf-&gt;st_birthtime);
 485 #endif
 486 
 487 #ifndef MACOSX
 488     (*env)-&gt;SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf-&gt;st_atim.tv_nsec);
 489     (*env)-&gt;SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf-&gt;st_mtim.tv_nsec);
 490     (*env)-&gt;SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf-&gt;st_ctim.tv_nsec);
 491 #else
 492     (*env)-&gt;SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf-&gt;st_atimespec.tv_nsec);
 493     (*env)-&gt;SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf-&gt;st_mtimespec.tv_nsec);
 494     (*env)-&gt;SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf-&gt;st_ctimespec.tv_nsec);
 495 #endif
 496 }
 497 
 498 JNIEXPORT void JNICALL
 499 Java_sun_nio_fs_UnixNativeDispatcher_stat0(JNIEnv* env, jclass this,
 500     jlong pathAddress, jobject attrs)
 501 {
 502     int err;
 503     struct stat64 buf;
 504     const char* path = (const char*)jlong_to_ptr(pathAddress);
 505 
 506     RESTARTABLE(stat64(path, &amp;buf), err);
 507     if (err == -1) {
 508         throwUnixException(env, errno);
 509     } else {
 510         prepAttributes(env, &amp;buf, attrs);
 511     }
 512 }
 513 
 514 JNIEXPORT jint JNICALL
 515 Java_sun_nio_fs_UnixNativeDispatcher_stat1(JNIEnv* env, jclass this, jlong pathAddress) {
 516     int err;
 517     struct stat64 buf;
 518     const char* path = (const char*)jlong_to_ptr(pathAddress);
 519 
 520     RESTARTABLE(stat64(path, &amp;buf), err);
 521     if (err == -1) {
 522         return 0;
 523     } else {
 524         return (jint)buf.st_mode;
 525     }
 526 }
 527 
 528 JNIEXPORT void JNICALL
 529 Java_sun_nio_fs_UnixNativeDispatcher_lstat0(JNIEnv* env, jclass this,
 530     jlong pathAddress, jobject attrs)
 531 {
 532     int err;
 533     struct stat64 buf;
 534     const char* path = (const char*)jlong_to_ptr(pathAddress);
 535 
 536     RESTARTABLE(lstat64(path, &amp;buf), err);
 537     if (err == -1) {
 538         throwUnixException(env, errno);
 539     } else {
 540         prepAttributes(env, &amp;buf, attrs);
 541     }
 542 }
 543 
 544 JNIEXPORT void JNICALL
 545 Java_sun_nio_fs_UnixNativeDispatcher_fstat(JNIEnv* env, jclass this, jint fd,
 546     jobject attrs)
 547 {
 548     int err;
 549     struct stat64 buf;
 550 
 551     RESTARTABLE(fstat64((int)fd, &amp;buf), err);
 552     if (err == -1) {
 553         throwUnixException(env, errno);
 554     } else {
 555         prepAttributes(env, &amp;buf, attrs);
 556     }
 557 }
 558 
 559 JNIEXPORT void JNICALL
 560 Java_sun_nio_fs_UnixNativeDispatcher_fstatat0(JNIEnv* env, jclass this, jint dfd,
 561     jlong pathAddress, jint flag, jobject attrs)
 562 {
 563     int err;
 564     struct stat64 buf;
 565     const char* path = (const char*)jlong_to_ptr(pathAddress);
 566 
 567     if (my_fstatat64_func == NULL) {
 568         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 569         return;
 570     }
 571     RESTARTABLE((*my_fstatat64_func)((int)dfd, path, &amp;buf, (int)flag), err);
 572     if (err == -1) {
 573         throwUnixException(env, errno);
 574     } else {
 575         prepAttributes(env, &amp;buf, attrs);
 576     }
 577 }
 578 
 579 JNIEXPORT void JNICALL
 580 Java_sun_nio_fs_UnixNativeDispatcher_chmod0(JNIEnv* env, jclass this,
 581     jlong pathAddress, jint mode)
 582 {
 583     int err;
 584     const char* path = (const char*)jlong_to_ptr(pathAddress);
 585 
 586     RESTARTABLE(chmod(path, (mode_t)mode), err);
 587     if (err == -1) {
 588         throwUnixException(env, errno);
 589     }
 590 }
 591 
 592 JNIEXPORT void JNICALL
 593 Java_sun_nio_fs_UnixNativeDispatcher_fchmod(JNIEnv* env, jclass this, jint filedes,
 594     jint mode)
 595 {
 596     int err;
 597 
 598     RESTARTABLE(fchmod((int)filedes, (mode_t)mode), err);
 599     if (err == -1) {
 600         throwUnixException(env, errno);
 601     }
 602 }
 603 
 604 
 605 JNIEXPORT void JNICALL
 606 Java_sun_nio_fs_UnixNativeDispatcher_chown0(JNIEnv* env, jclass this,
 607     jlong pathAddress, jint uid, jint gid)
 608 {
 609     int err;
 610     const char* path = (const char*)jlong_to_ptr(pathAddress);
 611 
 612     RESTARTABLE(chown(path, (uid_t)uid, (gid_t)gid), err);
 613     if (err == -1) {
 614         throwUnixException(env, errno);
 615     }
 616 }
 617 
 618 JNIEXPORT void JNICALL
 619 Java_sun_nio_fs_UnixNativeDispatcher_lchown0(JNIEnv* env, jclass this, jlong pathAddress, jint uid, jint gid)
 620 {
 621     int err;
 622     const char* path = (const char*)jlong_to_ptr(pathAddress);
 623 
 624     RESTARTABLE(lchown(path, (uid_t)uid, (gid_t)gid), err);
 625     if (err == -1) {
 626         throwUnixException(env, errno);
 627     }
 628 }
 629 
 630 JNIEXPORT void JNICALL
 631 Java_sun_nio_fs_UnixNativeDispatcher_fchown(JNIEnv* env, jclass this, jint filedes, jint uid, jint gid)
 632 {
 633     int err;
 634 
 635     RESTARTABLE(fchown(filedes, (uid_t)uid, (gid_t)gid), err);
 636     if (err == -1) {
 637         throwUnixException(env, errno);
 638     }
 639 }
 640 
 641 JNIEXPORT void JNICALL
 642 Java_sun_nio_fs_UnixNativeDispatcher_utimes0(JNIEnv* env, jclass this,
 643     jlong pathAddress, jlong accessTime, jlong modificationTime)
 644 {
 645     int err;
 646     struct timeval times[2];
 647     const char* path = (const char*)jlong_to_ptr(pathAddress);
 648 
 649     times[0].tv_sec = accessTime / 1000000;
 650     times[0].tv_usec = accessTime % 1000000;
 651 
 652     times[1].tv_sec = modificationTime / 1000000;
 653     times[1].tv_usec = modificationTime % 1000000;
 654 
 655     RESTARTABLE(utimes(path, &amp;times[0]), err);
 656     if (err == -1) {
 657         throwUnixException(env, errno);
 658     }
 659 }
 660 
 661 JNIEXPORT void JNICALL
 662 Java_sun_nio_fs_UnixNativeDispatcher_futimes(JNIEnv* env, jclass this, jint filedes,
 663     jlong accessTime, jlong modificationTime)
 664 {
 665     struct timeval times[2];
 666     int err = 0;
 667 
 668     times[0].tv_sec = accessTime / 1000000;
 669     times[0].tv_usec = accessTime % 1000000;
 670 
 671     times[1].tv_sec = modificationTime / 1000000;
 672     times[1].tv_usec = modificationTime % 1000000;
 673 
 674 #ifdef _ALLBSD_SOURCE
 675     RESTARTABLE(futimes(filedes, &amp;times[0]), err);
 676 #else
 677     if (my_futimesat_func == NULL) {
 678         JNU_ThrowInternalError(env, &quot;my_ftimesat_func is NULL&quot;);
 679         return;
 680     }
 681     RESTARTABLE((*my_futimesat_func)(filedes, NULL, &amp;times[0]), err);
 682 #endif
 683     if (err == -1) {
 684         throwUnixException(env, errno);
 685     }
 686 }
 687 
 688 JNIEXPORT jlong JNICALL
 689 Java_sun_nio_fs_UnixNativeDispatcher_opendir0(JNIEnv* env, jclass this,
 690     jlong pathAddress)
 691 {
 692     DIR* dir;
 693     const char* path = (const char*)jlong_to_ptr(pathAddress);
 694 
 695     /* EINTR not listed as a possible error */
 696     dir = opendir(path);
 697     if (dir == NULL) {
 698         throwUnixException(env, errno);
 699     }
 700     return ptr_to_jlong(dir);
 701 }
 702 
 703 JNIEXPORT jlong JNICALL
 704 Java_sun_nio_fs_UnixNativeDispatcher_fdopendir(JNIEnv* env, jclass this, int dfd) {
 705     DIR* dir;
 706 
 707     if (my_fdopendir_func == NULL) {
 708         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 709         return (jlong)-1;
 710     }
 711 
 712     /* EINTR not listed as a possible error */
 713     dir = (*my_fdopendir_func)((int)dfd);
 714     if (dir == NULL) {
 715         throwUnixException(env, errno);
 716     }
 717     return ptr_to_jlong(dir);
 718 }
 719 
 720 JNIEXPORT void JNICALL
 721 Java_sun_nio_fs_UnixNativeDispatcher_closedir(JNIEnv* env, jclass this, jlong dir) {
 722     DIR* dirp = jlong_to_ptr(dir);
 723 
 724     if (closedir(dirp) == -1 &amp;&amp; errno != EINTR) {
 725         throwUnixException(env, errno);
 726     }
 727 }
 728 
 729 JNIEXPORT jbyteArray JNICALL
 730 Java_sun_nio_fs_UnixNativeDispatcher_readdir(JNIEnv* env, jclass this, jlong value) {
 731     DIR* dirp = jlong_to_ptr(value);
 732     struct dirent* ptr;
 733 
 734     errno = 0;
 735     ptr = readdir(dirp);
 736     if (ptr == NULL) {
 737         if (errno != 0) {
 738             throwUnixException(env, errno);
 739         }
 740         return NULL;
 741     } else {
 742         jsize len = strlen(ptr-&gt;d_name);
 743         jbyteArray bytes = (*env)-&gt;NewByteArray(env, len);
 744         if (bytes != NULL) {
 745             (*env)-&gt;SetByteArrayRegion(env, bytes, 0, len, (jbyte*)(ptr-&gt;d_name));
 746         }
 747         return bytes;
 748     }
 749 }
 750 
 751 JNIEXPORT void JNICALL
 752 Java_sun_nio_fs_UnixNativeDispatcher_mkdir0(JNIEnv* env, jclass this,
 753     jlong pathAddress, jint mode)
 754 {
 755     const char* path = (const char*)jlong_to_ptr(pathAddress);
 756 
 757     /* EINTR not listed as a possible error */
 758     if (mkdir(path, (mode_t)mode) == -1) {
 759         throwUnixException(env, errno);
 760     }
 761 }
 762 
 763 JNIEXPORT void JNICALL
 764 Java_sun_nio_fs_UnixNativeDispatcher_rmdir0(JNIEnv* env, jclass this,
 765     jlong pathAddress)
 766 {
 767     const char* path = (const char*)jlong_to_ptr(pathAddress);
 768 
 769     /* EINTR not listed as a possible error */
 770     if (rmdir(path) == -1) {
 771         throwUnixException(env, errno);
 772     }
 773 }
 774 
 775 JNIEXPORT void JNICALL
 776 Java_sun_nio_fs_UnixNativeDispatcher_link0(JNIEnv* env, jclass this,
 777     jlong existingAddress, jlong newAddress)
 778 {
 779     int err;
 780     const char* existing = (const char*)jlong_to_ptr(existingAddress);
 781     const char* newname = (const char*)jlong_to_ptr(newAddress);
 782 
 783     RESTARTABLE(link(existing, newname), err);
 784     if (err == -1) {
 785         throwUnixException(env, errno);
 786     }
 787 }
 788 
 789 
 790 JNIEXPORT void JNICALL
 791 Java_sun_nio_fs_UnixNativeDispatcher_unlink0(JNIEnv* env, jclass this,
 792     jlong pathAddress)
 793 {
 794     const char* path = (const char*)jlong_to_ptr(pathAddress);
 795 
 796     /* EINTR not listed as a possible error */
 797     if (unlink(path) == -1) {
 798         throwUnixException(env, errno);
 799     }
 800 }
 801 
 802 JNIEXPORT void JNICALL
 803 Java_sun_nio_fs_UnixNativeDispatcher_unlinkat0(JNIEnv* env, jclass this, jint dfd,
 804                                                jlong pathAddress, jint flags)
 805 {
 806     const char* path = (const char*)jlong_to_ptr(pathAddress);
 807 
 808     if (my_unlinkat_func == NULL) {
 809         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 810         return;
 811     }
 812 
 813     /* EINTR not listed as a possible error */
 814     if ((*my_unlinkat_func)((int)dfd, path, (int)flags) == -1) {
 815         throwUnixException(env, errno);
 816     }
 817 }
 818 
 819 JNIEXPORT void JNICALL
 820 Java_sun_nio_fs_UnixNativeDispatcher_rename0(JNIEnv* env, jclass this,
 821     jlong fromAddress, jlong toAddress)
 822 {
 823     const char* from = (const char*)jlong_to_ptr(fromAddress);
 824     const char* to = (const char*)jlong_to_ptr(toAddress);
 825 
 826     /* EINTR not listed as a possible error */
 827     if (rename(from, to) == -1) {
 828         throwUnixException(env, errno);
 829     }
 830 }
 831 
 832 JNIEXPORT void JNICALL
 833 Java_sun_nio_fs_UnixNativeDispatcher_renameat0(JNIEnv* env, jclass this,
 834     jint fromfd, jlong fromAddress, jint tofd, jlong toAddress)
 835 {
 836     const char* from = (const char*)jlong_to_ptr(fromAddress);
 837     const char* to = (const char*)jlong_to_ptr(toAddress);
 838 
 839     if (my_renameat_func == NULL) {
 840         JNU_ThrowInternalError(env, &quot;should not reach here&quot;);
 841         return;
 842     }
 843 
 844     /* EINTR not listed as a possible error */
 845     if ((*my_renameat_func)((int)fromfd, from, (int)tofd, to) == -1) {
 846         throwUnixException(env, errno);
 847     }
 848 }
 849 
 850 JNIEXPORT void JNICALL
 851 Java_sun_nio_fs_UnixNativeDispatcher_symlink0(JNIEnv* env, jclass this,
 852     jlong targetAddress, jlong linkAddress)
 853 {
 854     const char* target = (const char*)jlong_to_ptr(targetAddress);
 855     const char* link = (const char*)jlong_to_ptr(linkAddress);
 856 
 857     /* EINTR not listed as a possible error */
 858     if (symlink(target, link) == -1) {
 859         throwUnixException(env, errno);
 860     }
 861 }
 862 
 863 JNIEXPORT jbyteArray JNICALL
 864 Java_sun_nio_fs_UnixNativeDispatcher_readlink0(JNIEnv* env, jclass this,
 865     jlong pathAddress)
 866 {
 867     jbyteArray result = NULL;
 868     char target[PATH_MAX+1];
 869     const char* path = (const char*)jlong_to_ptr(pathAddress);
 870 
 871     /* EINTR not listed as a possible error */
 872     int n = readlink(path, target, sizeof(target));
 873     if (n == -1) {
 874         throwUnixException(env, errno);
 875     } else {
 876         jsize len;
 877         if (n == sizeof(target)) {
 878             /* Traditionally readlink(2) should not return more than */
 879             /* PATH_MAX bytes (no terminating null byte is appended). */
 880             throwUnixException(env, ENAMETOOLONG);
 881             return NULL;
 882         }
 883         target[n] = &#39;\0&#39;;
 884         len = (jsize)strlen(target);
 885         result = (*env)-&gt;NewByteArray(env, len);
 886         if (result != NULL) {
 887             (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)target);
 888         }
 889     }
 890     return result;
 891 }
 892 
 893 JNIEXPORT jbyteArray JNICALL
 894 Java_sun_nio_fs_UnixNativeDispatcher_realpath0(JNIEnv* env, jclass this,
 895     jlong pathAddress)
 896 {
 897     jbyteArray result = NULL;
 898     char resolved[PATH_MAX+1];
 899     const char* path = (const char*)jlong_to_ptr(pathAddress);
 900 
 901     /* EINTR not listed as a possible error */
 902     if (realpath(path, resolved) == NULL) {
 903         throwUnixException(env, errno);
 904     } else {
 905         jsize len = (jsize)strlen(resolved);
 906         result = (*env)-&gt;NewByteArray(env, len);
 907         if (result != NULL) {
 908             (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)resolved);
 909         }
 910     }
 911     return result;
 912 }
 913 
 914 JNIEXPORT void JNICALL
 915 Java_sun_nio_fs_UnixNativeDispatcher_access0(JNIEnv* env, jclass this,
 916     jlong pathAddress, jint amode)
 917 {
 918     int err;
 919     const char* path = (const char*)jlong_to_ptr(pathAddress);
 920 
 921     RESTARTABLE(access(path, (int)amode), err);
 922     if (err == -1) {
 923         throwUnixException(env, errno);
 924     }
 925 }
 926 
 927 JNIEXPORT jboolean JNICALL
 928 Java_sun_nio_fs_UnixNativeDispatcher_exists0(JNIEnv* env, jclass this, jlong pathAddress) {
 929     int err;
 930     const char* path = (const char*)jlong_to_ptr(pathAddress);
 931     RESTARTABLE(access(path, F_OK), err);
 932     return (err == 0) ? JNI_TRUE : JNI_FALSE;
 933 }
 934 
 935 JNIEXPORT void JNICALL
 936 Java_sun_nio_fs_UnixNativeDispatcher_statvfs0(JNIEnv* env, jclass this,
 937     jlong pathAddress, jobject attrs)
 938 {
 939     int err;
 940 #ifdef MACOSX
 941     struct statfs buf;
 942 #else
 943     struct statvfs64 buf;
 944 #endif
 945     const char* path = (const char*)jlong_to_ptr(pathAddress);
 946 
 947 #ifdef MACOSX
 948     RESTARTABLE(statfs(path, &amp;buf), err);
 949 #else
 950     RESTARTABLE(statvfs64(path, &amp;buf), err);
 951 #endif
 952     if (err == -1) {
 953         throwUnixException(env, errno);
 954     } else {
 955 #ifdef _AIX
 956         /* AIX returns ULONG_MAX in buf.f_blocks for the /proc file system. */
 957         /* This is too big for a Java signed long and fools various tests.  */
 958         if (buf.f_blocks == ULONG_MAX) {
 959             buf.f_blocks = 0;
 960         }
 961         /* The number of free or available blocks can never exceed the total number of blocks */
 962         if (buf.f_blocks == 0) {
 963             buf.f_bfree = 0;
 964             buf.f_bavail = 0;
 965         }
 966 #endif
 967 #ifdef MACOSX
 968         (*env)-&gt;SetLongField(env, attrs, attrs_f_frsize, long_to_jlong(buf.f_bsize));
 969 #else
 970         (*env)-&gt;SetLongField(env, attrs, attrs_f_frsize, long_to_jlong(buf.f_frsize));
 971 #endif
 972         (*env)-&gt;SetLongField(env, attrs, attrs_f_blocks, long_to_jlong(buf.f_blocks));
 973         (*env)-&gt;SetLongField(env, attrs, attrs_f_bfree,  long_to_jlong(buf.f_bfree));
 974         (*env)-&gt;SetLongField(env, attrs, attrs_f_bavail, long_to_jlong(buf.f_bavail));
 975     }
 976 }
 977 
 978 JNIEXPORT jlong JNICALL
 979 Java_sun_nio_fs_UnixNativeDispatcher_pathconf0(JNIEnv* env, jclass this,
 980     jlong pathAddress, jint name)
 981 {
 982     long err;
 983     const char* path = (const char*)jlong_to_ptr(pathAddress);
 984 
 985     err = pathconf(path, (int)name);
 986     if (err == -1) {
 987         throwUnixException(env, errno);
 988     }
 989     return (jlong)err;
 990 }
 991 
 992 JNIEXPORT jlong JNICALL
 993 Java_sun_nio_fs_UnixNativeDispatcher_fpathconf(JNIEnv* env, jclass this,
 994     jint fd, jint name)
 995 {
 996     long err;
 997 
 998     err = fpathconf((int)fd, (int)name);
 999     if (err == -1) {
1000         throwUnixException(env, errno);
1001     }
1002     return (jlong)err;
1003 }
1004 
1005 JNIEXPORT void JNICALL
1006 Java_sun_nio_fs_UnixNativeDispatcher_mknod0(JNIEnv* env, jclass this,
1007     jlong pathAddress, jint mode, jlong dev)
1008 {
1009     int err;
1010     const char* path = (const char*)jlong_to_ptr(pathAddress);
1011 
1012     RESTARTABLE(mknod(path, (mode_t)mode, (dev_t)dev), err);
1013     if (err == -1) {
1014         throwUnixException(env, errno);
1015     }
1016 }
1017 
1018 JNIEXPORT jbyteArray JNICALL
1019 Java_sun_nio_fs_UnixNativeDispatcher_getpwuid(JNIEnv* env, jclass this, jint uid)
1020 {
1021     jbyteArray result = NULL;
1022     int buflen;
1023     char* pwbuf;
1024 
1025     /* allocate buffer for password record */
1026     buflen = (int)sysconf(_SC_GETPW_R_SIZE_MAX);
1027     if (buflen == -1)
1028         buflen = ENT_BUF_SIZE;
1029     pwbuf = (char*)malloc(buflen);
1030     if (pwbuf == NULL) {
1031         JNU_ThrowOutOfMemoryError(env, &quot;native heap&quot;);
1032     } else {
1033         struct passwd pwent;
1034         struct passwd* p = NULL;
1035         int res = 0;
1036 
1037         errno = 0;
1038         RESTARTABLE(getpwuid_r((uid_t)uid, &amp;pwent, pwbuf, (size_t)buflen, &amp;p), res);
1039 
1040         if (res != 0 || p == NULL || p-&gt;pw_name == NULL || *(p-&gt;pw_name) == &#39;\0&#39;) {
1041             /* not found or error */
1042             if (errno == 0)
1043                 errno = ENOENT;
1044             throwUnixException(env, errno);
1045         } else {
1046             jsize len = strlen(p-&gt;pw_name);
1047             result = (*env)-&gt;NewByteArray(env, len);
1048             if (result != NULL) {
1049                 (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)(p-&gt;pw_name));
1050             }
1051         }
1052         free(pwbuf);
1053     }
1054 
1055     return result;
1056 }
1057 
1058 
1059 JNIEXPORT jbyteArray JNICALL
1060 Java_sun_nio_fs_UnixNativeDispatcher_getgrgid(JNIEnv* env, jclass this, jint gid)
1061 {
1062     jbyteArray result = NULL;
1063     int buflen;
1064     int retry;
1065 
1066     /* initial size of buffer for group record */
1067     buflen = (int)sysconf(_SC_GETGR_R_SIZE_MAX);
1068     if (buflen == -1)
1069         buflen = ENT_BUF_SIZE;
1070 
1071     do {
1072         struct group grent;
1073         struct group* g = NULL;
1074         int res = 0;
1075 
1076         char* grbuf = (char*)malloc(buflen);
1077         if (grbuf == NULL) {
1078             JNU_ThrowOutOfMemoryError(env, &quot;native heap&quot;);
1079             return NULL;
1080         }
1081 
1082         errno = 0;
1083         RESTARTABLE(getgrgid_r((gid_t)gid, &amp;grent, grbuf, (size_t)buflen, &amp;g), res);
1084 
1085         retry = 0;
1086         if (res != 0 || g == NULL || g-&gt;gr_name == NULL || *(g-&gt;gr_name) == &#39;\0&#39;) {
1087             /* not found or error */
1088             if (errno == ERANGE) {
1089                 /* insufficient buffer size so need larger buffer */
1090                 buflen += ENT_BUF_SIZE;
1091                 retry = 1;
1092             } else {
1093                 if (errno == 0)
1094                     errno = ENOENT;
1095                 throwUnixException(env, errno);
1096             }
1097         } else {
1098             jsize len = strlen(g-&gt;gr_name);
1099             result = (*env)-&gt;NewByteArray(env, len);
1100             if (result != NULL) {
1101                 (*env)-&gt;SetByteArrayRegion(env, result, 0, len, (jbyte*)(g-&gt;gr_name));
1102             }
1103         }
1104 
1105         free(grbuf);
1106 
1107     } while (retry);
1108 
1109     return result;
1110 }
1111 
1112 JNIEXPORT jint JNICALL
1113 Java_sun_nio_fs_UnixNativeDispatcher_getpwnam0(JNIEnv* env, jclass this,
1114     jlong nameAddress)
1115 {
1116     jint uid = -1;
1117     int buflen;
1118     char* pwbuf;
1119 
1120     /* allocate buffer for password record */
1121     buflen = (int)sysconf(_SC_GETPW_R_SIZE_MAX);
1122     if (buflen == -1)
1123         buflen = ENT_BUF_SIZE;
1124     pwbuf = (char*)malloc(buflen);
1125     if (pwbuf == NULL) {
1126         JNU_ThrowOutOfMemoryError(env, &quot;native heap&quot;);
1127     } else {
1128         struct passwd pwent;
1129         struct passwd* p = NULL;
1130         int res = 0;
1131         const char* name = (const char*)jlong_to_ptr(nameAddress);
1132 
1133         errno = 0;
1134         RESTARTABLE(getpwnam_r(name, &amp;pwent, pwbuf, (size_t)buflen, &amp;p), res);
1135 
1136         if (res != 0 || p == NULL || p-&gt;pw_name == NULL || *(p-&gt;pw_name) == &#39;\0&#39;) {
1137             /* not found or error */
1138             if (errno != 0 &amp;&amp; errno != ENOENT &amp;&amp; errno != ESRCH)
1139                 throwUnixException(env, errno);
1140         } else {
1141             uid = p-&gt;pw_uid;
1142         }
1143         free(pwbuf);
1144     }
1145 
1146     return uid;
1147 }
1148 
1149 JNIEXPORT jint JNICALL
1150 Java_sun_nio_fs_UnixNativeDispatcher_getgrnam0(JNIEnv* env, jclass this,
1151     jlong nameAddress)
1152 {
1153     jint gid = -1;
1154     int buflen, retry;
1155 
1156     /* initial size of buffer for group record */
1157     buflen = (int)sysconf(_SC_GETGR_R_SIZE_MAX);
1158     if (buflen == -1)
1159         buflen = ENT_BUF_SIZE;
1160 
1161     do {
1162         struct group grent;
1163         struct group* g = NULL;
1164         int res = 0;
1165         char *grbuf;
1166         const char* name = (const char*)jlong_to_ptr(nameAddress);
1167 
1168         grbuf = (char*)malloc(buflen);
1169         if (grbuf == NULL) {
1170             JNU_ThrowOutOfMemoryError(env, &quot;native heap&quot;);
1171             return -1;
1172         }
1173 
1174         errno = 0;
1175         RESTARTABLE(getgrnam_r(name, &amp;grent, grbuf, (size_t)buflen, &amp;g), res);
1176 
1177         retry = 0;
1178         if (res != 0 || g == NULL || g-&gt;gr_name == NULL || *(g-&gt;gr_name) == &#39;\0&#39;) {
1179             /* not found or error */
1180             if (errno != 0 &amp;&amp; errno != ENOENT &amp;&amp; errno != ESRCH) {
1181                 if (errno == ERANGE) {
1182                     /* insufficient buffer size so need larger buffer */
1183                     buflen += ENT_BUF_SIZE;
1184                     retry = 1;
1185                 } else {
1186                     throwUnixException(env, errno);
1187                 }
1188             }
1189         } else {
1190             gid = g-&gt;gr_gid;
1191         }
1192 
1193         free(grbuf);
1194 
1195     } while (retry);
1196 
1197     return gid;
1198 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libjli/java_md_solinux.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="java_md_common.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../libnet/DefaultProxySelector.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libjli/java_md_solinux.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
171 static jboolean
172 JvmExists(const char *path) {
173     char tmp[PATH_MAX + 1];
174     struct stat statbuf;
175     JLI_Snprintf(tmp, PATH_MAX, &quot;%s/%s&quot;, path, JVM_DLL);
176     if (stat(tmp, &amp;statbuf) == 0) {
177         return JNI_TRUE;
178     }
179     return JNI_FALSE;
180 }
181 /*
182  * contains a lib/{server,client}/libjvm.so ?
183  */
184 static jboolean
185 ContainsLibJVM(const char *env) {
186     /* the usual suspects */
187     char clientPattern[] = &quot;lib/client&quot;;
188     char serverPattern[] = &quot;lib/server&quot;;
189     char *envpath;
190     char *path;

191     jboolean clientPatternFound;
192     jboolean serverPatternFound;
193 
194     /* fastest path */
195     if (env == NULL) {
196         return JNI_FALSE;
197     }
198 
199     /* to optimize for time, test if any of our usual suspects are present. */
200     clientPatternFound = JLI_StrStr(env, clientPattern) != NULL;
201     serverPatternFound = JLI_StrStr(env, serverPattern) != NULL;
202     if (clientPatternFound == JNI_FALSE &amp;&amp; serverPatternFound == JNI_FALSE) {
203         return JNI_FALSE;
204     }
205 
206     /*
207      * we have a suspicious path component, check if it contains a libjvm.so
208      */
209     envpath = JLI_StringDup(env);
<span class="line-modified">210     for (path = JLI_StrTok(envpath, &quot;:&quot;); path != NULL; path = JLI_StrTok(NULL, &quot;:&quot;)) {</span>
211         if (clientPatternFound &amp;&amp; JLI_StrStr(path, clientPattern) != NULL) {
212             if (JvmExists(path)) {
213                 JLI_MemFree(envpath);
214                 return JNI_TRUE;
215             }
216         }
217         if (serverPatternFound &amp;&amp; JLI_StrStr(path, serverPattern)  != NULL) {
218             if (JvmExists(path)) {
219                 JLI_MemFree(envpath);
220                 return JNI_TRUE;
221             }
222         }
223     }
224     JLI_MemFree(envpath);
225     return JNI_FALSE;
226 }
227 
228 /*
229  * Test whether the environment variable needs to be set, see flowchart.
230  */
</pre>
<hr />
<pre>
718 
719         if (ret &gt;= (int) sizeof(splashPath)) {
720             JLI_ReportErrorMessage(JRE_ERROR11);
721             return NULL;
722         }
723         if (ret &lt; 0) {
724             JLI_ReportErrorMessage(JRE_ERROR13);
725             return NULL;
726         }
727         hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);
728         JLI_TraceLauncher(&quot;Info: loaded %s\n&quot;, splashPath);
729     }
730     if (hSplashLib) {
731         void* sym = dlsym(hSplashLib, name);
732         return sym;
733     } else {
734         return NULL;
735     }
736 }
737 
<span class="line-removed">738 void SplashFreeLibrary() {</span>
<span class="line-removed">739     if (hSplashLib) {</span>
<span class="line-removed">740         dlclose(hSplashLib);</span>
<span class="line-removed">741         hSplashLib = NULL;</span>
<span class="line-removed">742     }</span>
<span class="line-removed">743 }</span>
<span class="line-removed">744 </span>
745 /*
746  * Signature adapter for pthread_create() or thr_create().
747  */
748 static void* ThreadJavaMain(void* args) {
749     return (void*)(intptr_t)JavaMain(args);
750 }
751 
752 /*
753  * Block current thread and continue execution in a new thread.
754  */
755 int
756 CallJavaMainInNewThread(jlong stack_size, void* args) {
757     int rslt;
758 #ifndef __solaris__
759     pthread_t tid;
760     pthread_attr_t attr;
761     pthread_attr_init(&amp;attr);
762     pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
763 
764     if (stack_size &gt; 0) {
</pre>
<hr />
<pre>
782 
783     pthread_attr_destroy(&amp;attr);
784 #else /* __solaris__ */
785     thread_t tid;
786     long flags = 0;
787     if (thr_create(NULL, stack_size, ThreadJavaMain, args, flags, &amp;tid) == 0) {
788         void* tmp;
789         thr_join(tid, NULL, &amp;tmp);
790         rslt = (int)(intptr_t)tmp;
791     } else {
792         /* See above. Continue in current thread if thr_create() failed */
793         rslt = JavaMain(args);
794     }
795 #endif /* !__solaris__ */
796     return rslt;
797 }
798 
799 /* Coarse estimation of number of digits assuming the worst case is a 64-bit pid. */
800 #define MAX_PID_STR_SZ   20
801 
<span class="line-removed">802 void SetJavaLauncherPlatformProps() {</span>
<span class="line-removed">803    /* Linux only */</span>
<span class="line-removed">804 #ifdef __linux__</span>
<span class="line-removed">805     const char *substr = &quot;-Dsun.java.launcher.pid=&quot;;</span>
<span class="line-removed">806     char *pid_prop_str = (char *)JLI_MemAlloc(JLI_StrLen(substr) + MAX_PID_STR_SZ + 1);</span>
<span class="line-removed">807     sprintf(pid_prop_str, &quot;%s%d&quot;, substr, getpid());</span>
<span class="line-removed">808     AddOption(pid_prop_str, NULL);</span>
<span class="line-removed">809 #endif /* __linux__ */</span>
<span class="line-removed">810 }</span>
<span class="line-removed">811 </span>
812 int
813 JVMInit(InvocationFunctions* ifn, jlong threadStackSize,
814         int argc, char **argv,
815         int mode, char *what, int ret)
816 {
817     ShowSplashScreen();
818     return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);
819 }
820 
821 void
822 PostJVMInit(JNIEnv *env, jclass mainClass, JavaVM *vm)
823 {
824     // stubbed out for windows and *nixes.
825 }
826 
827 void
828 RegisterThread()
829 {
830     // stubbed out for windows and *nixes.
831 }
</pre>
</td>
<td>
<hr />
<pre>
171 static jboolean
172 JvmExists(const char *path) {
173     char tmp[PATH_MAX + 1];
174     struct stat statbuf;
175     JLI_Snprintf(tmp, PATH_MAX, &quot;%s/%s&quot;, path, JVM_DLL);
176     if (stat(tmp, &amp;statbuf) == 0) {
177         return JNI_TRUE;
178     }
179     return JNI_FALSE;
180 }
181 /*
182  * contains a lib/{server,client}/libjvm.so ?
183  */
184 static jboolean
185 ContainsLibJVM(const char *env) {
186     /* the usual suspects */
187     char clientPattern[] = &quot;lib/client&quot;;
188     char serverPattern[] = &quot;lib/server&quot;;
189     char *envpath;
190     char *path;
<span class="line-added">191     char* save_ptr = NULL;</span>
192     jboolean clientPatternFound;
193     jboolean serverPatternFound;
194 
195     /* fastest path */
196     if (env == NULL) {
197         return JNI_FALSE;
198     }
199 
200     /* to optimize for time, test if any of our usual suspects are present. */
201     clientPatternFound = JLI_StrStr(env, clientPattern) != NULL;
202     serverPatternFound = JLI_StrStr(env, serverPattern) != NULL;
203     if (clientPatternFound == JNI_FALSE &amp;&amp; serverPatternFound == JNI_FALSE) {
204         return JNI_FALSE;
205     }
206 
207     /*
208      * we have a suspicious path component, check if it contains a libjvm.so
209      */
210     envpath = JLI_StringDup(env);
<span class="line-modified">211     for (path = strtok_r(envpath, &quot;:&quot;, &amp;save_ptr); path != NULL; path = strtok_r(NULL, &quot;:&quot;, &amp;save_ptr)) {</span>
212         if (clientPatternFound &amp;&amp; JLI_StrStr(path, clientPattern) != NULL) {
213             if (JvmExists(path)) {
214                 JLI_MemFree(envpath);
215                 return JNI_TRUE;
216             }
217         }
218         if (serverPatternFound &amp;&amp; JLI_StrStr(path, serverPattern)  != NULL) {
219             if (JvmExists(path)) {
220                 JLI_MemFree(envpath);
221                 return JNI_TRUE;
222             }
223         }
224     }
225     JLI_MemFree(envpath);
226     return JNI_FALSE;
227 }
228 
229 /*
230  * Test whether the environment variable needs to be set, see flowchart.
231  */
</pre>
<hr />
<pre>
719 
720         if (ret &gt;= (int) sizeof(splashPath)) {
721             JLI_ReportErrorMessage(JRE_ERROR11);
722             return NULL;
723         }
724         if (ret &lt; 0) {
725             JLI_ReportErrorMessage(JRE_ERROR13);
726             return NULL;
727         }
728         hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);
729         JLI_TraceLauncher(&quot;Info: loaded %s\n&quot;, splashPath);
730     }
731     if (hSplashLib) {
732         void* sym = dlsym(hSplashLib, name);
733         return sym;
734     } else {
735         return NULL;
736     }
737 }
738 







739 /*
740  * Signature adapter for pthread_create() or thr_create().
741  */
742 static void* ThreadJavaMain(void* args) {
743     return (void*)(intptr_t)JavaMain(args);
744 }
745 
746 /*
747  * Block current thread and continue execution in a new thread.
748  */
749 int
750 CallJavaMainInNewThread(jlong stack_size, void* args) {
751     int rslt;
752 #ifndef __solaris__
753     pthread_t tid;
754     pthread_attr_t attr;
755     pthread_attr_init(&amp;attr);
756     pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);
757 
758     if (stack_size &gt; 0) {
</pre>
<hr />
<pre>
776 
777     pthread_attr_destroy(&amp;attr);
778 #else /* __solaris__ */
779     thread_t tid;
780     long flags = 0;
781     if (thr_create(NULL, stack_size, ThreadJavaMain, args, flags, &amp;tid) == 0) {
782         void* tmp;
783         thr_join(tid, NULL, &amp;tmp);
784         rslt = (int)(intptr_t)tmp;
785     } else {
786         /* See above. Continue in current thread if thr_create() failed */
787         rslt = JavaMain(args);
788     }
789 #endif /* !__solaris__ */
790     return rslt;
791 }
792 
793 /* Coarse estimation of number of digits assuming the worst case is a 64-bit pid. */
794 #define MAX_PID_STR_SZ   20
795 










796 int
797 JVMInit(InvocationFunctions* ifn, jlong threadStackSize,
798         int argc, char **argv,
799         int mode, char *what, int ret)
800 {
801     ShowSplashScreen();
802     return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);
803 }
804 
805 void
806 PostJVMInit(JNIEnv *env, jclass mainClass, JavaVM *vm)
807 {
808     // stubbed out for windows and *nixes.
809 }
810 
811 void
812 RegisterThread()
813 {
814     // stubbed out for windows and *nixes.
815 }
</pre>
</td>
</tr>
</table>
<center><a href="java_md_common.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../libnet/DefaultProxySelector.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
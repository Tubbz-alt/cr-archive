<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/unix/native/libjava/canonicalize_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="UnixFileSystem_md.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="childproc.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libjava/canonicalize_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
  #include &lt;limits.h&gt;
  #if !defined(_ALLBSD_SOURCE)
  #include &lt;alloca.h&gt;
  #endif
  
<span class="line-added">+ #include &quot;jdk_util.h&quot;</span>
  
  /* Note: The comments in this file use the terminology
           defined in the java.io.File class */
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,65 ***</span>
  /* Convert a pathname to canonical form.  The input path is assumed to contain
     no duplicate slashes.  On Solaris we can use realpath() to do most of the
     work, though once that&#39;s done we still must collapse any remaining &quot;.&quot; and
     &quot;..&quot; names by hand. */
  
<span class="line-modified">! int</span>
<span class="line-modified">! canonicalize(char *original, char *resolved, int len)</span>
  {
      if (len &lt; PATH_MAX) {
          errno = EINVAL;
          return -1;
      }
  
<span class="line-modified">!     if (strlen(original) &gt; PATH_MAX) {</span>
          errno = ENAMETOOLONG;
          return -1;
      }
  
      /* First try realpath() on the entire path */
<span class="line-modified">!     if (realpath(original, resolved)) {</span>
          /* That worked, so return it */
<span class="line-modified">!         collapse(resolved);</span>
          return 0;
<span class="line-modified">!     }</span>
<span class="line-removed">-     else {</span>
          /* Something&#39;s bogus in the original path, so remove names from the end
             until either some subpath works or we run out of names */
          char *p, *end, *r = NULL;
          char path[PATH_MAX + 1];
  
<span class="line-modified">!         strncpy(path, original, sizeof(path));</span>
<span class="line-modified">!         if (path[PATH_MAX] != &#39;\0&#39;) {</span>
<span class="line-modified">!             errno = ENAMETOOLONG;</span>
<span class="line-modified">!             return -1;</span>
<span class="line-removed">-         }</span>
          end = path + strlen(path);
  
          for (p = end; p &gt; path;) {
  
              /* Skip last element */
              while ((--p &gt; path) &amp;&amp; (*p != &#39;/&#39;));
              if (p == path) break;
  
              /* Try realpath() on this subpath */
              *p = &#39;\0&#39;;
<span class="line-modified">!             r = realpath(path, resolved);</span>
              *p = (p == end) ? &#39;\0&#39; : &#39;/&#39;;
  
              if (r != NULL) {
                  /* The subpath has a canonical path */
                  break;
<span class="line-modified">!             }</span>
<span class="line-removed">-             else if (errno == ENOENT || errno == ENOTDIR || errno == EACCES) {</span>
                  /* If the lookup of a particular subpath fails because the file
                     does not exist, because it is of the wrong type, or because
                     access is denied, then remove its last name and try again.
                     Other I/O problems cause an error return. */
                  continue;
<span class="line-modified">!             }</span>
<span class="line-removed">-             else {</span>
                  return -1;
              }
          }
  
          if (r != NULL) {
<span class="line-new-header">--- 185,61 ---</span>
  /* Convert a pathname to canonical form.  The input path is assumed to contain
     no duplicate slashes.  On Solaris we can use realpath() to do most of the
     work, though once that&#39;s done we still must collapse any remaining &quot;.&quot; and
     &quot;..&quot; names by hand. */
  
<span class="line-modified">! JNIEXPORT int</span>
<span class="line-modified">! JDK_Canonicalize(const char *orig, char *out, int len)</span>
  {
      if (len &lt; PATH_MAX) {
          errno = EINVAL;
          return -1;
      }
  
<span class="line-modified">!     if (strlen(orig) &gt; PATH_MAX) {</span>
          errno = ENAMETOOLONG;
          return -1;
      }
  
      /* First try realpath() on the entire path */
<span class="line-modified">!     if (realpath(orig, out)) {</span>
          /* That worked, so return it */
<span class="line-modified">!         collapse(out);</span>
          return 0;
<span class="line-modified">!     } else {</span>
          /* Something&#39;s bogus in the original path, so remove names from the end
             until either some subpath works or we run out of names */
          char *p, *end, *r = NULL;
          char path[PATH_MAX + 1];
  
<span class="line-modified">!         // strlen(orig) &lt;= PATH_MAX, see above</span>
<span class="line-modified">!         strncpy(path, orig, PATH_MAX);</span>
<span class="line-modified">!         // append null for == case</span>
<span class="line-modified">!         path[PATH_MAX] = &#39;\0&#39;;</span>
          end = path + strlen(path);
  
          for (p = end; p &gt; path;) {
  
              /* Skip last element */
              while ((--p &gt; path) &amp;&amp; (*p != &#39;/&#39;));
              if (p == path) break;
  
              /* Try realpath() on this subpath */
              *p = &#39;\0&#39;;
<span class="line-modified">!             r = realpath(path, out);</span>
              *p = (p == end) ? &#39;\0&#39; : &#39;/&#39;;
  
              if (r != NULL) {
                  /* The subpath has a canonical path */
                  break;
<span class="line-modified">!             } else if (errno == ENOENT || errno == ENOTDIR || errno == EACCES) {</span>
                  /* If the lookup of a particular subpath fails because the file
                     does not exist, because it is of the wrong type, or because
                     access is denied, then remove its last name and try again.
                     Other I/O problems cause an error return. */
                  continue;
<span class="line-modified">!             } else {</span>
                  return -1;
              }
          }
  
          if (r != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,15 ***</span>
                  p++;
              }
              strcpy(r + rn, p);
              collapse(r);
              return 0;
<span class="line-modified">!         }</span>
<span class="line-removed">-         else {</span>
              /* Nothing resolved, so just return the original path */
<span class="line-modified">!             strcpy(resolved, path);</span>
<span class="line-modified">!             collapse(resolved);</span>
              return 0;
          }
      }
<span class="line-removed">- </span>
  }
<span class="line-new-header">--- 255,13 ---</span>
                  p++;
              }
              strcpy(r + rn, p);
              collapse(r);
              return 0;
<span class="line-modified">!         } else {</span>
              /* Nothing resolved, so just return the original path */
<span class="line-modified">!             strcpy(out, path);</span>
<span class="line-modified">!             collapse(out);</span>
              return 0;
          }
      }
  }
</pre>
<center><a href="UnixFileSystem_md.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="childproc.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
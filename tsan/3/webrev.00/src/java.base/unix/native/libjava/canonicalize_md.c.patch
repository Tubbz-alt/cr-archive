diff a/src/java.base/unix/native/libjava/canonicalize_md.c b/src/java.base/unix/native/libjava/canonicalize_md.c
--- a/src/java.base/unix/native/libjava/canonicalize_md.c
+++ b/src/java.base/unix/native/libjava/canonicalize_md.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -35,10 +35,11 @@
 #include <limits.h>
 #if !defined(_ALLBSD_SOURCE)
 #include <alloca.h>
 #endif
 
+#include "jdk_util.h"
 
 /* Note: The comments in this file use the terminology
          defined in the java.io.File class */
 
 
@@ -184,65 +185,61 @@
 /* Convert a pathname to canonical form.  The input path is assumed to contain
    no duplicate slashes.  On Solaris we can use realpath() to do most of the
    work, though once that's done we still must collapse any remaining "." and
    ".." names by hand. */
 
-int
-canonicalize(char *original, char *resolved, int len)
+JNIEXPORT int
+JDK_Canonicalize(const char *orig, char *out, int len)
 {
     if (len < PATH_MAX) {
         errno = EINVAL;
         return -1;
     }
 
-    if (strlen(original) > PATH_MAX) {
+    if (strlen(orig) > PATH_MAX) {
         errno = ENAMETOOLONG;
         return -1;
     }
 
     /* First try realpath() on the entire path */
-    if (realpath(original, resolved)) {
+    if (realpath(orig, out)) {
         /* That worked, so return it */
-        collapse(resolved);
+        collapse(out);
         return 0;
-    }
-    else {
+    } else {
         /* Something's bogus in the original path, so remove names from the end
            until either some subpath works or we run out of names */
         char *p, *end, *r = NULL;
         char path[PATH_MAX + 1];
 
-        strncpy(path, original, sizeof(path));
-        if (path[PATH_MAX] != '\0') {
-            errno = ENAMETOOLONG;
-            return -1;
-        }
+        // strlen(orig) <= PATH_MAX, see above
+        strncpy(path, orig, PATH_MAX);
+        // append null for == case
+        path[PATH_MAX] = '\0';
         end = path + strlen(path);
 
         for (p = end; p > path;) {
 
             /* Skip last element */
             while ((--p > path) && (*p != '/'));
             if (p == path) break;
 
             /* Try realpath() on this subpath */
             *p = '\0';
-            r = realpath(path, resolved);
+            r = realpath(path, out);
             *p = (p == end) ? '\0' : '/';
 
             if (r != NULL) {
                 /* The subpath has a canonical path */
                 break;
-            }
-            else if (errno == ENOENT || errno == ENOTDIR || errno == EACCES) {
+            } else if (errno == ENOENT || errno == ENOTDIR || errno == EACCES) {
                 /* If the lookup of a particular subpath fails because the file
                    does not exist, because it is of the wrong type, or because
                    access is denied, then remove its last name and try again.
                    Other I/O problems cause an error return. */
                 continue;
-            }
-            else {
+            } else {
                 return -1;
             }
         }
 
         if (r != NULL) {
@@ -258,15 +255,13 @@
                 p++;
             }
             strcpy(r + rn, p);
             collapse(r);
             return 0;
-        }
-        else {
+        } else {
             /* Nothing resolved, so just return the original path */
-            strcpy(resolved, path);
-            collapse(resolved);
+            strcpy(out, path);
+            collapse(out);
             return 0;
         }
     }
-
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libjava/TimeZone_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ProcessImpl_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="UnixFileSystem_md.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libjava/TimeZone_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 25 
 26 #include &lt;stdlib.h&gt;
 27 #include &lt;stdio.h&gt;
 28 #include &lt;strings.h&gt;
 29 #include &lt;time.h&gt;
 30 #include &lt;limits.h&gt;
 31 #include &lt;errno.h&gt;
 32 #include &lt;stddef.h&gt;
 33 #include &lt;sys/stat.h&gt;
 34 #include &lt;sys/types.h&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;dirent.h&gt;
 37 #include &lt;unistd.h&gt;
 38 #if defined(__solaris__)
 39 #include &lt;libscf.h&gt;
 40 #endif
 41 
 42 #include &quot;jvm.h&quot;
 43 #include &quot;TimeZone_md.h&quot;
 44 


 45 #define SKIP_SPACE(p)   while (*p == &#39; &#39; || *p == &#39;\t&#39;) p++;
 46 
 47 #define RESTARTABLE(_cmd, _result) do { \
 48   do { \
 49     _result = _cmd; \
 50   } while((_result == -1) &amp;&amp; (errno == EINTR)); \
 51 } while(0)
 52 
 53 #if !defined(__solaris__) || defined(__sparcv9) || defined(amd64)
 54 #define fileopen        fopen
 55 #define filegets        fgets
 56 #define fileclose       fclose
 57 #endif
 58 
 59 #if defined(_ALLBSD_SOURCE)
 60 #define stat64 stat
 61 #define lstat64 lstat
 62 #define fstat64 fstat
 63 #endif
 64 
 65 #if defined(__linux__) || defined(_ALLBSD_SOURCE)
 66 static const char *ETC_TIMEZONE_FILE = &quot;/etc/timezone&quot;;
 67 static const char *ZONEINFO_DIR = &quot;/usr/share/zoneinfo&quot;;
 68 static const char *DEFAULT_ZONEINFO_FILE = &quot;/etc/localtime&quot;;
 69 #else
 70 static const char *SYS_INIT_FILE = &quot;/etc/default/init&quot;;
 71 static const char *ZONEINFO_DIR = &quot;/usr/share/lib/zoneinfo&quot;;
 72 static const char *DEFAULT_ZONEINFO_FILE = &quot;/usr/share/lib/zoneinfo/localtime&quot;;
 73 #endif /* defined(__linux__) || defined(_ALLBSD_SOURCE) */
 74 


 75 #if defined(_AIX)
 76 static const char *ETC_ENVIRONMENT_FILE = &quot;/etc/environment&quot;;
 77 #endif
 78 
 79 #if defined(__linux__) || defined(MACOSX) || defined(__solaris__)
 80 
 81 /*
 82  * Returns a pointer to the zone ID portion of the given zoneinfo file
 83  * name, or NULL if the given string doesn&#39;t contain &quot;zoneinfo/&quot;.
 84  */
 85 static char *
 86 getZoneName(char *str)
 87 {
 88     static const char *zidir = &quot;zoneinfo/&quot;;
 89 
 90     char *pos = strstr((const char *)str, zidir);
 91     if (pos == NULL) {
 92         return NULL;
 93     }
 94     return pos + strlen(zidir);
</pre>
<hr />
<pre>
104     char *path;
105 
106     path = (char *) malloc(strlen(dir) + strlen(name) + 2);
107     if (path == NULL) {
108         return NULL;
109     }
110     return strcat(strcat(strcpy(path, dir), &quot;/&quot;), name);
111 }
112 
113 /*
114  * Scans the specified directory and its subdirectories to find a
115  * zoneinfo file which has the same content as /etc/localtime on Linux
116  * or /usr/share/lib/zoneinfo/localtime on Solaris given in &#39;buf&#39;.
117  * If file is symbolic link, then the contents it points to are in buf.
118  * Returns a zone ID if found, otherwise, NULL is returned.
119  */
120 static char *
121 findZoneinfoFile(char *buf, size_t size, const char *dir)
122 {
123     DIR *dirp = NULL;
<span class="line-removed">124     struct stat64 statbuf;</span>
125     struct dirent *dp = NULL;
126     char *pathname = NULL;
<span class="line-removed">127     int fd = -1;</span>
<span class="line-removed">128     char *dbuf = NULL;</span>
129     char *tz = NULL;
130     int res;
131 
















132     dirp = opendir(dir);
133     if (dirp == NULL) {
134         return NULL;
135     }
136 
137     while ((dp = readdir(dirp)) != NULL) {
138         /*
139          * Skip &#39;.&#39; and &#39;..&#39; (and possibly other .* files)
140          */
141         if (dp-&gt;d_name[0] == &#39;.&#39;) {
142             continue;
143         }
144 
145         /*
146          * Skip &quot;ROC&quot;, &quot;posixrules&quot;, and &quot;localtime&quot;.
147          */
148         if ((strcmp(dp-&gt;d_name, &quot;ROC&quot;) == 0)
149             || (strcmp(dp-&gt;d_name, &quot;posixrules&quot;) == 0)
150 #if defined(__solaris__)
151             /*
152              * Skip the &quot;src&quot; and &quot;tab&quot; directories on Solaris.
153              */
154             || (strcmp(dp-&gt;d_name, &quot;src&quot;) == 0)
155             || (strcmp(dp-&gt;d_name, &quot;tab&quot;) == 0)
156 #endif
157             || (strcmp(dp-&gt;d_name, &quot;localtime&quot;) == 0)) {
158             continue;
159         }
160 
161         pathname = getPathName(dir, dp-&gt;d_name);
162         if (pathname == NULL) {
163             break;
164         }
<span class="line-removed">165         RESTARTABLE(stat64(pathname, &amp;statbuf), res);</span>
<span class="line-removed">166         if (res == -1) {</span>
<span class="line-removed">167             break;</span>
<span class="line-removed">168         }</span>
169 
<span class="line-modified">170         if (S_ISDIR(statbuf.st_mode)) {</span>
<span class="line-removed">171             tz = findZoneinfoFile(buf, size, pathname);</span>
<span class="line-removed">172             if (tz != NULL) {</span>
<span class="line-removed">173                 break;</span>
<span class="line-removed">174             }</span>
<span class="line-removed">175         } else if (S_ISREG(statbuf.st_mode) &amp;&amp; (size_t)statbuf.st_size == size) {</span>
<span class="line-removed">176             dbuf = (char *) malloc(size);</span>
<span class="line-removed">177             if (dbuf == NULL) {</span>
<span class="line-removed">178                 break;</span>
<span class="line-removed">179             }</span>
<span class="line-removed">180             RESTARTABLE(open(pathname, O_RDONLY), fd);</span>
<span class="line-removed">181             if (fd == -1) {</span>
<span class="line-removed">182                 break;</span>
<span class="line-removed">183             }</span>
<span class="line-removed">184             RESTARTABLE(read(fd, dbuf, size), res);</span>
<span class="line-removed">185             if (res != (ssize_t) size) {</span>
<span class="line-removed">186                 break;</span>
<span class="line-removed">187             }</span>
<span class="line-removed">188             if (memcmp(buf, dbuf, size) == 0) {</span>
<span class="line-removed">189                 tz = getZoneName(pathname);</span>
<span class="line-removed">190                 if (tz != NULL) {</span>
<span class="line-removed">191                     tz = strdup(tz);</span>
<span class="line-removed">192                 }</span>
<span class="line-removed">193                 break;</span>
<span class="line-removed">194             }</span>
<span class="line-removed">195             free((void *) dbuf);</span>
<span class="line-removed">196             dbuf = NULL;</span>
<span class="line-removed">197             (void) close(fd);</span>
<span class="line-removed">198             fd = -1;</span>
<span class="line-removed">199         }</span>
200         free((void *) pathname);
201         pathname = NULL;



202     }
203 
204     if (dirp != NULL) {
205         (void) closedir(dirp);
206     }
<span class="line-modified">207     if (pathname != NULL) {</span>
<span class="line-modified">208         free((void *) pathname);</span>
<span class="line-modified">209     }</span>
<span class="line-modified">210     if (fd != -1) {</span>
<span class="line-modified">211         (void) close(fd);</span>
















212     }
<span class="line-modified">213     if (dbuf != NULL) {</span>






















214         free((void *) dbuf);

215     }
<span class="line-modified">216     return tz;</span>
217 }
218 
219 #if defined(__linux__) || defined(MACOSX)
220 
221 /*
222  * Performs Linux specific mapping and returns a zone ID
223  * if found. Otherwise, NULL is returned.
224  */
225 static char *
226 getPlatformTimeZoneID()
227 {
228     struct stat64 statbuf;
229     char *tz = NULL;
230     FILE *fp;
231     int fd;
232     char *buf;
233     size_t size;
234     int res;
235 
236 #if defined(__linux__)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 25 
 26 #include &lt;stdlib.h&gt;
 27 #include &lt;stdio.h&gt;
 28 #include &lt;strings.h&gt;
 29 #include &lt;time.h&gt;
 30 #include &lt;limits.h&gt;
 31 #include &lt;errno.h&gt;
 32 #include &lt;stddef.h&gt;
 33 #include &lt;sys/stat.h&gt;
 34 #include &lt;sys/types.h&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;dirent.h&gt;
 37 #include &lt;unistd.h&gt;
 38 #if defined(__solaris__)
 39 #include &lt;libscf.h&gt;
 40 #endif
 41 
 42 #include &quot;jvm.h&quot;
 43 #include &quot;TimeZone_md.h&quot;
 44 
<span class="line-added"> 45 static char *isFileIdentical(char* buf, size_t size, char *pathname);</span>
<span class="line-added"> 46 </span>
 47 #define SKIP_SPACE(p)   while (*p == &#39; &#39; || *p == &#39;\t&#39;) p++;
 48 
 49 #define RESTARTABLE(_cmd, _result) do { \
 50   do { \
 51     _result = _cmd; \
 52   } while((_result == -1) &amp;&amp; (errno == EINTR)); \
 53 } while(0)
 54 
 55 #if !defined(__solaris__) || defined(__sparcv9) || defined(amd64)
 56 #define fileopen        fopen
 57 #define filegets        fgets
 58 #define fileclose       fclose
 59 #endif
 60 
 61 #if defined(_ALLBSD_SOURCE)
 62 #define stat64 stat
 63 #define lstat64 lstat
 64 #define fstat64 fstat
 65 #endif
 66 
 67 #if defined(__linux__) || defined(_ALLBSD_SOURCE)
 68 static const char *ETC_TIMEZONE_FILE = &quot;/etc/timezone&quot;;
 69 static const char *ZONEINFO_DIR = &quot;/usr/share/zoneinfo&quot;;
 70 static const char *DEFAULT_ZONEINFO_FILE = &quot;/etc/localtime&quot;;
 71 #else
 72 static const char *SYS_INIT_FILE = &quot;/etc/default/init&quot;;
 73 static const char *ZONEINFO_DIR = &quot;/usr/share/lib/zoneinfo&quot;;
 74 static const char *DEFAULT_ZONEINFO_FILE = &quot;/usr/share/lib/zoneinfo/localtime&quot;;
 75 #endif /* defined(__linux__) || defined(_ALLBSD_SOURCE) */
 76 
<span class="line-added"> 77 static const char popularZones[][4] = {&quot;UTC&quot;, &quot;GMT&quot;};</span>
<span class="line-added"> 78 </span>
 79 #if defined(_AIX)
 80 static const char *ETC_ENVIRONMENT_FILE = &quot;/etc/environment&quot;;
 81 #endif
 82 
 83 #if defined(__linux__) || defined(MACOSX) || defined(__solaris__)
 84 
 85 /*
 86  * Returns a pointer to the zone ID portion of the given zoneinfo file
 87  * name, or NULL if the given string doesn&#39;t contain &quot;zoneinfo/&quot;.
 88  */
 89 static char *
 90 getZoneName(char *str)
 91 {
 92     static const char *zidir = &quot;zoneinfo/&quot;;
 93 
 94     char *pos = strstr((const char *)str, zidir);
 95     if (pos == NULL) {
 96         return NULL;
 97     }
 98     return pos + strlen(zidir);
</pre>
<hr />
<pre>
108     char *path;
109 
110     path = (char *) malloc(strlen(dir) + strlen(name) + 2);
111     if (path == NULL) {
112         return NULL;
113     }
114     return strcat(strcat(strcpy(path, dir), &quot;/&quot;), name);
115 }
116 
117 /*
118  * Scans the specified directory and its subdirectories to find a
119  * zoneinfo file which has the same content as /etc/localtime on Linux
120  * or /usr/share/lib/zoneinfo/localtime on Solaris given in &#39;buf&#39;.
121  * If file is symbolic link, then the contents it points to are in buf.
122  * Returns a zone ID if found, otherwise, NULL is returned.
123  */
124 static char *
125 findZoneinfoFile(char *buf, size_t size, const char *dir)
126 {
127     DIR *dirp = NULL;

128     struct dirent *dp = NULL;
129     char *pathname = NULL;


130     char *tz = NULL;
131     int res;
132 
<span class="line-added">133     if (strcmp(dir, ZONEINFO_DIR) == 0) {</span>
<span class="line-added">134         /* fast path for 1st iteration */</span>
<span class="line-added">135         for (unsigned int i = 0; i &lt; sizeof (popularZones) / sizeof (popularZones[0]); i++) {</span>
<span class="line-added">136             pathname = getPathName(dir, popularZones[i]);</span>
<span class="line-added">137             if (pathname == NULL) {</span>
<span class="line-added">138                 continue;</span>
<span class="line-added">139             }</span>
<span class="line-added">140             tz = isFileIdentical(buf, size, pathname);</span>
<span class="line-added">141             free((void *) pathname);</span>
<span class="line-added">142             pathname = NULL;</span>
<span class="line-added">143             if (tz != NULL) {</span>
<span class="line-added">144                 return tz;</span>
<span class="line-added">145             }</span>
<span class="line-added">146         }</span>
<span class="line-added">147     }</span>
<span class="line-added">148 </span>
149     dirp = opendir(dir);
150     if (dirp == NULL) {
151         return NULL;
152     }
153 
154     while ((dp = readdir(dirp)) != NULL) {
155         /*
156          * Skip &#39;.&#39; and &#39;..&#39; (and possibly other .* files)
157          */
158         if (dp-&gt;d_name[0] == &#39;.&#39;) {
159             continue;
160         }
161 
162         /*
163          * Skip &quot;ROC&quot;, &quot;posixrules&quot;, and &quot;localtime&quot;.
164          */
165         if ((strcmp(dp-&gt;d_name, &quot;ROC&quot;) == 0)
166             || (strcmp(dp-&gt;d_name, &quot;posixrules&quot;) == 0)
167 #if defined(__solaris__)
168             /*
169              * Skip the &quot;src&quot; and &quot;tab&quot; directories on Solaris.
170              */
171             || (strcmp(dp-&gt;d_name, &quot;src&quot;) == 0)
172             || (strcmp(dp-&gt;d_name, &quot;tab&quot;) == 0)
173 #endif
174             || (strcmp(dp-&gt;d_name, &quot;localtime&quot;) == 0)) {
175             continue;
176         }
177 
178         pathname = getPathName(dir, dp-&gt;d_name);
179         if (pathname == NULL) {
180             break;
181         }




182 
<span class="line-modified">183         tz = isFileIdentical(buf, size, pathname);</span>





























184         free((void *) pathname);
185         pathname = NULL;
<span class="line-added">186         if (tz != NULL) {</span>
<span class="line-added">187            break;</span>
<span class="line-added">188         }</span>
189     }
190 
191     if (dirp != NULL) {
192         (void) closedir(dirp);
193     }
<span class="line-modified">194     return tz;</span>
<span class="line-modified">195 }</span>
<span class="line-modified">196 </span>
<span class="line-modified">197 /*</span>
<span class="line-modified">198  * Checks if the file pointed to by pathname matches</span>
<span class="line-added">199  * the data contents in buf.</span>
<span class="line-added">200  * Returns a representation of the timezone file name</span>
<span class="line-added">201  * if file match is found, otherwise NULL.</span>
<span class="line-added">202  */</span>
<span class="line-added">203 static char *</span>
<span class="line-added">204 isFileIdentical(char *buf, size_t size, char *pathname)</span>
<span class="line-added">205 {</span>
<span class="line-added">206     char *possibleMatch = NULL;</span>
<span class="line-added">207     struct stat64 statbuf;</span>
<span class="line-added">208     char *dbuf = NULL;</span>
<span class="line-added">209     int fd = -1;</span>
<span class="line-added">210     int res;</span>
<span class="line-added">211 </span>
<span class="line-added">212     RESTARTABLE(stat64(pathname, &amp;statbuf), res);</span>
<span class="line-added">213     if (res == -1) {</span>
<span class="line-added">214         return NULL;</span>
215     }
<span class="line-modified">216 </span>
<span class="line-added">217     if (S_ISDIR(statbuf.st_mode)) {</span>
<span class="line-added">218         possibleMatch  = findZoneinfoFile(buf, size, pathname);</span>
<span class="line-added">219     } else if (S_ISREG(statbuf.st_mode) &amp;&amp; (size_t)statbuf.st_size == size) {</span>
<span class="line-added">220         dbuf = (char *) malloc(size);</span>
<span class="line-added">221         if (dbuf == NULL) {</span>
<span class="line-added">222             return NULL;</span>
<span class="line-added">223         }</span>
<span class="line-added">224         RESTARTABLE(open(pathname, O_RDONLY), fd);</span>
<span class="line-added">225         if (fd == -1) {</span>
<span class="line-added">226             goto freedata;</span>
<span class="line-added">227         }</span>
<span class="line-added">228         RESTARTABLE(read(fd, dbuf, size), res);</span>
<span class="line-added">229         if (res != (ssize_t) size) {</span>
<span class="line-added">230             goto freedata;</span>
<span class="line-added">231         }</span>
<span class="line-added">232         if (memcmp(buf, dbuf, size) == 0) {</span>
<span class="line-added">233             possibleMatch = getZoneName(pathname);</span>
<span class="line-added">234             if (possibleMatch != NULL) {</span>
<span class="line-added">235                 possibleMatch = strdup(possibleMatch);</span>
<span class="line-added">236             }</span>
<span class="line-added">237         }</span>
<span class="line-added">238         freedata:</span>
239         free((void *) dbuf);
<span class="line-added">240         (void) close(fd);</span>
241     }
<span class="line-modified">242     return possibleMatch;</span>
243 }
244 
245 #if defined(__linux__) || defined(MACOSX)
246 
247 /*
248  * Performs Linux specific mapping and returns a zone ID
249  * if found. Otherwise, NULL is returned.
250  */
251 static char *
252 getPlatformTimeZoneID()
253 {
254     struct stat64 statbuf;
255     char *tz = NULL;
256     FILE *fp;
257     int fd;
258     char *buf;
259     size_t size;
260     int res;
261 
262 #if defined(__linux__)
</pre>
</td>
</tr>
</table>
<center><a href="ProcessImpl_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="UnixFileSystem_md.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
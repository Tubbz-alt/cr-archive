<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libjava/UnixFileSystem_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="TimeZone_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="canonicalize_md.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libjava/UnixFileSystem_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 28 #include &lt;sys/types.h&gt;
 29 #include &lt;sys/time.h&gt;
 30 #include &lt;sys/stat.h&gt;
 31 #ifdef MACOSX
 32 #include &lt;sys/param.h&gt;
 33 #include &lt;sys/mount.h&gt;
 34 #else
 35 #include &lt;sys/statvfs.h&gt;
 36 #endif
 37 #include &lt;string.h&gt;
 38 #include &lt;stdlib.h&gt;
 39 #include &lt;dlfcn.h&gt;
 40 #include &lt;limits.h&gt;
 41 #include &lt;errno.h&gt;
 42 #include &lt;fcntl.h&gt;
 43 #include &lt;dirent.h&gt;
 44 
 45 #include &quot;jni.h&quot;
 46 #include &quot;jni_util.h&quot;
 47 #include &quot;jlong.h&quot;

 48 #include &quot;io_util.h&quot;
 49 #include &quot;io_util_md.h&quot;
 50 #include &quot;java_io_FileSystem.h&quot;
 51 #include &quot;java_io_UnixFileSystem.h&quot;
 52 
 53 #if defined(_AIX)
 54   #if !defined(NAME_MAX)
 55     #define NAME_MAX MAXNAMLEN
 56   #endif
 57   #define DIR DIR64
 58   #define dirent dirent64
 59   #define opendir opendir64
 60   #define readdir readdir64
 61   #define closedir closedir64
 62   #define stat stat64
 63 #endif
 64 
 65 #if defined(__solaris__) &amp;&amp; !defined(NAME_MAX)
 66   #define NAME_MAX MAXNAMLEN
 67 #endif
</pre>
<hr />
<pre>
 74 #endif
 75 
 76 /* -- Field IDs -- */
 77 
 78 static struct {
 79     jfieldID path;
 80 } ids;
 81 
 82 
 83 JNIEXPORT void JNICALL
 84 Java_java_io_UnixFileSystem_initIDs(JNIEnv *env, jclass cls)
 85 {
 86     jclass fileClass = (*env)-&gt;FindClass(env, &quot;java/io/File&quot;);
 87     if (!fileClass) return;
 88     ids.path = (*env)-&gt;GetFieldID(env, fileClass,
 89                                   &quot;path&quot;, &quot;Ljava/lang/String;&quot;);
 90 }
 91 
 92 /* -- Path operations -- */
 93 
<span class="line-removed"> 94 extern int canonicalize(char *path, const char *out, int len);</span>
<span class="line-removed"> 95 </span>
 96 JNIEXPORT jstring JNICALL
 97 Java_java_io_UnixFileSystem_canonicalize0(JNIEnv *env, jobject this,
 98                                           jstring pathname)
 99 {
100     jstring rv = NULL;
101 
102     WITH_PLATFORM_STRING(env, pathname, path) {
103         char canonicalPath[PATH_MAX];
<span class="line-modified">104         if (canonicalize((char *)path,</span>
105                          canonicalPath, PATH_MAX) &lt; 0) {
106             JNU_ThrowIOExceptionWithLastError(env, &quot;Bad pathname&quot;);
107         } else {
108 #ifdef MACOSX
109             rv = newStringPlatform(env, canonicalPath);
110 #else
111             rv = JNU_NewStringPlatform(env, canonicalPath);
112 #endif
113         }
114     } END_PLATFORM_STRING(env, path);
115     return rv;
116 }
117 
118 
119 /* -- Attribute accessors -- */
120 
121 
122 static jboolean
123 statMode(const char *path, int *mode)
124 {
</pre>
<hr />
<pre>
151 
152 JNIEXPORT jboolean JNICALL
153 Java_java_io_UnixFileSystem_checkAccess(JNIEnv *env, jobject this,
154                                         jobject file, jint a)
155 {
156     jboolean rv = JNI_FALSE;
157     int mode = 0;
158     switch (a) {
159     case java_io_FileSystem_ACCESS_READ:
160         mode = R_OK;
161         break;
162     case java_io_FileSystem_ACCESS_WRITE:
163         mode = W_OK;
164         break;
165     case java_io_FileSystem_ACCESS_EXECUTE:
166         mode = X_OK;
167         break;
168     default: assert(0);
169     }
170     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
<span class="line-modified">171         if (access(path, mode) == 0) {</span>


172             rv = JNI_TRUE;
173         }
174     } END_PLATFORM_STRING(env, path);
175     return rv;
176 }
177 
178 
179 JNIEXPORT jboolean JNICALL
180 Java_java_io_UnixFileSystem_setPermission(JNIEnv *env, jobject this,
181                                           jobject file,
182                                           jint access,
183                                           jboolean enable,
184                                           jboolean owneronly)
185 {
186     jboolean rv = JNI_FALSE;
187 
188     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
189         int amode = 0;
190         int mode;

191         switch (access) {
192         case java_io_FileSystem_ACCESS_READ:
193             if (owneronly)
194                 amode = S_IRUSR;
195             else
196                 amode = S_IRUSR | S_IRGRP | S_IROTH;
197             break;
198         case java_io_FileSystem_ACCESS_WRITE:
199             if (owneronly)
200                 amode = S_IWUSR;
201             else
202                 amode = S_IWUSR | S_IWGRP | S_IWOTH;
203             break;
204         case java_io_FileSystem_ACCESS_EXECUTE:
205             if (owneronly)
206                 amode = S_IXUSR;
207             else
208                 amode = S_IXUSR | S_IXGRP | S_IXOTH;
209             break;
210         default:
211             assert(0);
212         }
213         if (statMode(path, &amp;mode)) {
214             if (enable)
215                 mode |= amode;
216             else
217                 mode &amp;= ~amode;
<span class="line-modified">218             if (chmod(path, mode) &gt;= 0) {</span>

219                 rv = JNI_TRUE;
220             }
221         }
222     } END_PLATFORM_STRING(env, path);
223     return rv;
224 }
225 
226 JNIEXPORT jlong JNICALL
227 Java_java_io_UnixFileSystem_getLastModifiedTime(JNIEnv *env, jobject this,
228                                                 jobject file)
229 {
230     jlong rv = 0;
231 
232     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
233         struct stat64 sb;
234         if (stat64(path, &amp;sb) == 0) {
235 #if defined(_AIX)
236             rv =  (jlong)sb.st_mtime * 1000;
237             rv += (jlong)sb.st_mtime_n / 1000000;
238 #elif defined(MACOSX)
</pre>
<hr />
<pre>
263     return rv;
264 }
265 
266 
267 /* -- File operations -- */
268 
269 
270 JNIEXPORT jboolean JNICALL
271 Java_java_io_UnixFileSystem_createFileExclusively(JNIEnv *env, jclass cls,
272                                                   jstring pathname)
273 {
274     jboolean rv = JNI_FALSE;
275 
276     WITH_PLATFORM_STRING(env, pathname, path) {
277         FD fd;
278         /* The root directory always exists */
279         if (strcmp (path, &quot;/&quot;)) {
280             fd = handleOpen(path, O_RDWR | O_CREAT | O_EXCL, 0666);
281             if (fd &lt; 0) {
282                 if (errno != EEXIST)
<span class="line-modified">283                     JNU_ThrowIOExceptionWithLastError(env, path);</span>
284             } else {
285                 if (close(fd) == -1)
<span class="line-modified">286                     JNU_ThrowIOExceptionWithLastError(env, path);</span>
287                 rv = JNI_TRUE;
288             }
289         }
290     } END_PLATFORM_STRING(env, path);
291     return rv;
292 }
293 
294 
295 JNIEXPORT jboolean JNICALL
296 Java_java_io_UnixFileSystem_delete0(JNIEnv *env, jobject this,
297                                     jobject file)
298 {
299     jboolean rv = JNI_FALSE;
300 
301     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
302         if (remove(path) == 0) {
303             rv = JNI_TRUE;
304         }
305     } END_PLATFORM_STRING(env, path);
306     return rv;
</pre>
<hr />
<pre>
338             continue;
339         if (len == maxlen) {
340             old = rv;
341             rv = (*env)-&gt;NewObjectArray(env, maxlen &lt;&lt;= 1, str_class, NULL);
342             if (rv == NULL) goto error;
343             if (JNU_CopyObjectArray(env, rv, old, len) &lt; 0) goto error;
344             (*env)-&gt;DeleteLocalRef(env, old);
345         }
346 #ifdef MACOSX
347         name = newStringPlatform(env, ptr-&gt;d_name);
348 #else
349         name = JNU_NewStringPlatform(env, ptr-&gt;d_name);
350 #endif
351         if (name == NULL) goto error;
352         (*env)-&gt;SetObjectArrayElement(env, rv, len++, name);
353         (*env)-&gt;DeleteLocalRef(env, name);
354     }
355     closedir(dir);
356 
357     /* Copy the final results into an appropriately-sized array */
<span class="line-modified">358     old = rv;</span>
<span class="line-modified">359     rv = (*env)-&gt;NewObjectArray(env, len, str_class, NULL);</span>
<span class="line-modified">360     if (rv == NULL) {</span>
<span class="line-modified">361         return NULL;</span>
<span class="line-modified">362     }</span>
<span class="line-modified">363     if (JNU_CopyObjectArray(env, rv, old, len) &lt; 0) {</span>
<span class="line-modified">364         return NULL;</span>


365     }
366     return rv;
367 
368  error:
369     closedir(dir);
370     return NULL;
371 }
372 
373 
374 JNIEXPORT jboolean JNICALL
375 Java_java_io_UnixFileSystem_createDirectory(JNIEnv *env, jobject this,
376                                             jobject file)
377 {
378     jboolean rv = JNI_FALSE;
379 
380     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
381         if (mkdir(path, 0777) == 0) {
382             rv = JNI_TRUE;
383         }
384     } END_PLATFORM_STRING(env, path);
</pre>
<hr />
<pre>
429             tv[1].tv_sec = time / 1000;
430             tv[1].tv_usec = (time % 1000) * 1000;
431 
432             if (utimes(path, tv) == 0)
433                 rv = JNI_TRUE;
434         }
435     } END_PLATFORM_STRING(env, path);
436 
437     return rv;
438 }
439 
440 
441 JNIEXPORT jboolean JNICALL
442 Java_java_io_UnixFileSystem_setReadOnly(JNIEnv *env, jobject this,
443                                         jobject file)
444 {
445     jboolean rv = JNI_FALSE;
446 
447     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
448         int mode;

449         if (statMode(path, &amp;mode)) {
<span class="line-modified">450             if (chmod(path, mode &amp; ~(S_IWUSR | S_IWGRP | S_IWOTH)) &gt;= 0) {</span>

451                 rv = JNI_TRUE;
452             }
453         }
454     } END_PLATFORM_STRING(env, path);
455     return rv;
456 }
457 
458 JNIEXPORT jlong JNICALL
459 Java_java_io_UnixFileSystem_getSpace(JNIEnv *env, jobject this,
460                                      jobject file, jint t)
461 {
462     jlong rv = 0L;
463 
464     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
465 #ifdef MACOSX
466         struct statfs fsstat;
467 #else
468         struct statvfs64 fsstat;

469 #endif
470         memset(&amp;fsstat, 0, sizeof(fsstat));
471 #ifdef MACOSX
472         if (statfs(path, &amp;fsstat) == 0) {
473             switch(t) {
474                 case java_io_FileSystem_SPACE_TOTAL:
475                     rv = jlong_mul(long_to_jlong(fsstat.f_bsize),
476                                    long_to_jlong(fsstat.f_blocks));
477                     break;
478                 case java_io_FileSystem_SPACE_FREE:
479                     rv = jlong_mul(long_to_jlong(fsstat.f_bsize),
480                                    long_to_jlong(fsstat.f_bfree));
481                     break;
482                 case java_io_FileSystem_SPACE_USABLE:
483                     rv = jlong_mul(long_to_jlong(fsstat.f_bsize),
484                                    long_to_jlong(fsstat.f_bavail));
485                     break;
486                 default:
487                     assert(0);
488             }
489         }
490 #else
<span class="line-modified">491         if (statvfs64(path, &amp;fsstat) == 0) {</span>

492             switch(t) {
493             case java_io_FileSystem_SPACE_TOTAL:
494                 rv = jlong_mul(long_to_jlong(fsstat.f_frsize),
495                                long_to_jlong(fsstat.f_blocks));
496                 break;
497             case java_io_FileSystem_SPACE_FREE:
498                 rv = jlong_mul(long_to_jlong(fsstat.f_frsize),
499                                long_to_jlong(fsstat.f_bfree));
500                 break;
501             case java_io_FileSystem_SPACE_USABLE:
502                 rv = jlong_mul(long_to_jlong(fsstat.f_frsize),
503                                long_to_jlong(fsstat.f_bavail));
504                 break;
505             default:
506                 assert(0);
507             }
508         }
509 #endif
510     } END_PLATFORM_STRING(env, path);
511     return rv;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 28 #include &lt;sys/types.h&gt;
 29 #include &lt;sys/time.h&gt;
 30 #include &lt;sys/stat.h&gt;
 31 #ifdef MACOSX
 32 #include &lt;sys/param.h&gt;
 33 #include &lt;sys/mount.h&gt;
 34 #else
 35 #include &lt;sys/statvfs.h&gt;
 36 #endif
 37 #include &lt;string.h&gt;
 38 #include &lt;stdlib.h&gt;
 39 #include &lt;dlfcn.h&gt;
 40 #include &lt;limits.h&gt;
 41 #include &lt;errno.h&gt;
 42 #include &lt;fcntl.h&gt;
 43 #include &lt;dirent.h&gt;
 44 
 45 #include &quot;jni.h&quot;
 46 #include &quot;jni_util.h&quot;
 47 #include &quot;jlong.h&quot;
<span class="line-added"> 48 #include &quot;jdk_util.h&quot;</span>
 49 #include &quot;io_util.h&quot;
 50 #include &quot;io_util_md.h&quot;
 51 #include &quot;java_io_FileSystem.h&quot;
 52 #include &quot;java_io_UnixFileSystem.h&quot;
 53 
 54 #if defined(_AIX)
 55   #if !defined(NAME_MAX)
 56     #define NAME_MAX MAXNAMLEN
 57   #endif
 58   #define DIR DIR64
 59   #define dirent dirent64
 60   #define opendir opendir64
 61   #define readdir readdir64
 62   #define closedir closedir64
 63   #define stat stat64
 64 #endif
 65 
 66 #if defined(__solaris__) &amp;&amp; !defined(NAME_MAX)
 67   #define NAME_MAX MAXNAMLEN
 68 #endif
</pre>
<hr />
<pre>
 75 #endif
 76 
 77 /* -- Field IDs -- */
 78 
 79 static struct {
 80     jfieldID path;
 81 } ids;
 82 
 83 
 84 JNIEXPORT void JNICALL
 85 Java_java_io_UnixFileSystem_initIDs(JNIEnv *env, jclass cls)
 86 {
 87     jclass fileClass = (*env)-&gt;FindClass(env, &quot;java/io/File&quot;);
 88     if (!fileClass) return;
 89     ids.path = (*env)-&gt;GetFieldID(env, fileClass,
 90                                   &quot;path&quot;, &quot;Ljava/lang/String;&quot;);
 91 }
 92 
 93 /* -- Path operations -- */
 94 


 95 JNIEXPORT jstring JNICALL
 96 Java_java_io_UnixFileSystem_canonicalize0(JNIEnv *env, jobject this,
 97                                           jstring pathname)
 98 {
 99     jstring rv = NULL;
100 
101     WITH_PLATFORM_STRING(env, pathname, path) {
102         char canonicalPath[PATH_MAX];
<span class="line-modified">103         if (JDK_Canonicalize((char *)path,</span>
104                          canonicalPath, PATH_MAX) &lt; 0) {
105             JNU_ThrowIOExceptionWithLastError(env, &quot;Bad pathname&quot;);
106         } else {
107 #ifdef MACOSX
108             rv = newStringPlatform(env, canonicalPath);
109 #else
110             rv = JNU_NewStringPlatform(env, canonicalPath);
111 #endif
112         }
113     } END_PLATFORM_STRING(env, path);
114     return rv;
115 }
116 
117 
118 /* -- Attribute accessors -- */
119 
120 
121 static jboolean
122 statMode(const char *path, int *mode)
123 {
</pre>
<hr />
<pre>
150 
151 JNIEXPORT jboolean JNICALL
152 Java_java_io_UnixFileSystem_checkAccess(JNIEnv *env, jobject this,
153                                         jobject file, jint a)
154 {
155     jboolean rv = JNI_FALSE;
156     int mode = 0;
157     switch (a) {
158     case java_io_FileSystem_ACCESS_READ:
159         mode = R_OK;
160         break;
161     case java_io_FileSystem_ACCESS_WRITE:
162         mode = W_OK;
163         break;
164     case java_io_FileSystem_ACCESS_EXECUTE:
165         mode = X_OK;
166         break;
167     default: assert(0);
168     }
169     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
<span class="line-modified">170         int res;</span>
<span class="line-added">171         RESTARTABLE(access(path, mode), res);</span>
<span class="line-added">172         if (res == 0) {</span>
173             rv = JNI_TRUE;
174         }
175     } END_PLATFORM_STRING(env, path);
176     return rv;
177 }
178 
179 
180 JNIEXPORT jboolean JNICALL
181 Java_java_io_UnixFileSystem_setPermission(JNIEnv *env, jobject this,
182                                           jobject file,
183                                           jint access,
184                                           jboolean enable,
185                                           jboolean owneronly)
186 {
187     jboolean rv = JNI_FALSE;
188 
189     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
190         int amode = 0;
191         int mode;
<span class="line-added">192         int res;</span>
193         switch (access) {
194         case java_io_FileSystem_ACCESS_READ:
195             if (owneronly)
196                 amode = S_IRUSR;
197             else
198                 amode = S_IRUSR | S_IRGRP | S_IROTH;
199             break;
200         case java_io_FileSystem_ACCESS_WRITE:
201             if (owneronly)
202                 amode = S_IWUSR;
203             else
204                 amode = S_IWUSR | S_IWGRP | S_IWOTH;
205             break;
206         case java_io_FileSystem_ACCESS_EXECUTE:
207             if (owneronly)
208                 amode = S_IXUSR;
209             else
210                 amode = S_IXUSR | S_IXGRP | S_IXOTH;
211             break;
212         default:
213             assert(0);
214         }
215         if (statMode(path, &amp;mode)) {
216             if (enable)
217                 mode |= amode;
218             else
219                 mode &amp;= ~amode;
<span class="line-modified">220             RESTARTABLE(chmod(path, mode), res);</span>
<span class="line-added">221             if (res == 0) {</span>
222                 rv = JNI_TRUE;
223             }
224         }
225     } END_PLATFORM_STRING(env, path);
226     return rv;
227 }
228 
229 JNIEXPORT jlong JNICALL
230 Java_java_io_UnixFileSystem_getLastModifiedTime(JNIEnv *env, jobject this,
231                                                 jobject file)
232 {
233     jlong rv = 0;
234 
235     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
236         struct stat64 sb;
237         if (stat64(path, &amp;sb) == 0) {
238 #if defined(_AIX)
239             rv =  (jlong)sb.st_mtime * 1000;
240             rv += (jlong)sb.st_mtime_n / 1000000;
241 #elif defined(MACOSX)
</pre>
<hr />
<pre>
266     return rv;
267 }
268 
269 
270 /* -- File operations -- */
271 
272 
273 JNIEXPORT jboolean JNICALL
274 Java_java_io_UnixFileSystem_createFileExclusively(JNIEnv *env, jclass cls,
275                                                   jstring pathname)
276 {
277     jboolean rv = JNI_FALSE;
278 
279     WITH_PLATFORM_STRING(env, pathname, path) {
280         FD fd;
281         /* The root directory always exists */
282         if (strcmp (path, &quot;/&quot;)) {
283             fd = handleOpen(path, O_RDWR | O_CREAT | O_EXCL, 0666);
284             if (fd &lt; 0) {
285                 if (errno != EEXIST)
<span class="line-modified">286                     JNU_ThrowIOExceptionWithLastError(env, &quot;Could not open file&quot;);</span>
287             } else {
288                 if (close(fd) == -1)
<span class="line-modified">289                     JNU_ThrowIOExceptionWithLastError(env, &quot;Could not close file&quot;);</span>
290                 rv = JNI_TRUE;
291             }
292         }
293     } END_PLATFORM_STRING(env, path);
294     return rv;
295 }
296 
297 
298 JNIEXPORT jboolean JNICALL
299 Java_java_io_UnixFileSystem_delete0(JNIEnv *env, jobject this,
300                                     jobject file)
301 {
302     jboolean rv = JNI_FALSE;
303 
304     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
305         if (remove(path) == 0) {
306             rv = JNI_TRUE;
307         }
308     } END_PLATFORM_STRING(env, path);
309     return rv;
</pre>
<hr />
<pre>
341             continue;
342         if (len == maxlen) {
343             old = rv;
344             rv = (*env)-&gt;NewObjectArray(env, maxlen &lt;&lt;= 1, str_class, NULL);
345             if (rv == NULL) goto error;
346             if (JNU_CopyObjectArray(env, rv, old, len) &lt; 0) goto error;
347             (*env)-&gt;DeleteLocalRef(env, old);
348         }
349 #ifdef MACOSX
350         name = newStringPlatform(env, ptr-&gt;d_name);
351 #else
352         name = JNU_NewStringPlatform(env, ptr-&gt;d_name);
353 #endif
354         if (name == NULL) goto error;
355         (*env)-&gt;SetObjectArrayElement(env, rv, len++, name);
356         (*env)-&gt;DeleteLocalRef(env, name);
357     }
358     closedir(dir);
359 
360     /* Copy the final results into an appropriately-sized array */
<span class="line-modified">361     if (len &lt; maxlen) {</span>
<span class="line-modified">362         old = rv;</span>
<span class="line-modified">363         rv = (*env)-&gt;NewObjectArray(env, len, str_class, NULL);</span>
<span class="line-modified">364         if (rv == NULL) {</span>
<span class="line-modified">365             return NULL;</span>
<span class="line-modified">366         }</span>
<span class="line-modified">367         if (JNU_CopyObjectArray(env, rv, old, len) &lt; 0) {</span>
<span class="line-added">368             return NULL;</span>
<span class="line-added">369         }</span>
370     }
371     return rv;
372 
373  error:
374     closedir(dir);
375     return NULL;
376 }
377 
378 
379 JNIEXPORT jboolean JNICALL
380 Java_java_io_UnixFileSystem_createDirectory(JNIEnv *env, jobject this,
381                                             jobject file)
382 {
383     jboolean rv = JNI_FALSE;
384 
385     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
386         if (mkdir(path, 0777) == 0) {
387             rv = JNI_TRUE;
388         }
389     } END_PLATFORM_STRING(env, path);
</pre>
<hr />
<pre>
434             tv[1].tv_sec = time / 1000;
435             tv[1].tv_usec = (time % 1000) * 1000;
436 
437             if (utimes(path, tv) == 0)
438                 rv = JNI_TRUE;
439         }
440     } END_PLATFORM_STRING(env, path);
441 
442     return rv;
443 }
444 
445 
446 JNIEXPORT jboolean JNICALL
447 Java_java_io_UnixFileSystem_setReadOnly(JNIEnv *env, jobject this,
448                                         jobject file)
449 {
450     jboolean rv = JNI_FALSE;
451 
452     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
453         int mode;
<span class="line-added">454         int res;</span>
455         if (statMode(path, &amp;mode)) {
<span class="line-modified">456             RESTARTABLE(chmod(path, mode &amp; ~(S_IWUSR | S_IWGRP | S_IWOTH)), res);</span>
<span class="line-added">457             if (res == 0) {</span>
458                 rv = JNI_TRUE;
459             }
460         }
461     } END_PLATFORM_STRING(env, path);
462     return rv;
463 }
464 
465 JNIEXPORT jlong JNICALL
466 Java_java_io_UnixFileSystem_getSpace(JNIEnv *env, jobject this,
467                                      jobject file, jint t)
468 {
469     jlong rv = 0L;
470 
471     WITH_FIELD_PLATFORM_STRING(env, file, ids.path, path) {
472 #ifdef MACOSX
473         struct statfs fsstat;
474 #else
475         struct statvfs64 fsstat;
<span class="line-added">476         int res;</span>
477 #endif
478         memset(&amp;fsstat, 0, sizeof(fsstat));
479 #ifdef MACOSX
480         if (statfs(path, &amp;fsstat) == 0) {
481             switch(t) {
482                 case java_io_FileSystem_SPACE_TOTAL:
483                     rv = jlong_mul(long_to_jlong(fsstat.f_bsize),
484                                    long_to_jlong(fsstat.f_blocks));
485                     break;
486                 case java_io_FileSystem_SPACE_FREE:
487                     rv = jlong_mul(long_to_jlong(fsstat.f_bsize),
488                                    long_to_jlong(fsstat.f_bfree));
489                     break;
490                 case java_io_FileSystem_SPACE_USABLE:
491                     rv = jlong_mul(long_to_jlong(fsstat.f_bsize),
492                                    long_to_jlong(fsstat.f_bavail));
493                     break;
494                 default:
495                     assert(0);
496             }
497         }
498 #else
<span class="line-modified">499         RESTARTABLE(statvfs64(path, &amp;fsstat), res);</span>
<span class="line-added">500         if (res == 0) {</span>
501             switch(t) {
502             case java_io_FileSystem_SPACE_TOTAL:
503                 rv = jlong_mul(long_to_jlong(fsstat.f_frsize),
504                                long_to_jlong(fsstat.f_blocks));
505                 break;
506             case java_io_FileSystem_SPACE_FREE:
507                 rv = jlong_mul(long_to_jlong(fsstat.f_frsize),
508                                long_to_jlong(fsstat.f_bfree));
509                 break;
510             case java_io_FileSystem_SPACE_USABLE:
511                 rv = jlong_mul(long_to_jlong(fsstat.f_frsize),
512                                long_to_jlong(fsstat.f_bavail));
513                 break;
514             default:
515                 assert(0);
516             }
517         }
518 #endif
519     } END_PLATFORM_STRING(env, path);
520     return rv;
</pre>
</td>
</tr>
</table>
<center><a href="TimeZone_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="canonicalize_md.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libjava/childproc.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="canonicalize_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="childproc.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libjava/childproc.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;dirent.h&gt;
 27 #include &lt;errno.h&gt;
 28 #include &lt;fcntl.h&gt;

 29 #include &lt;stdlib.h&gt;
 30 #include &lt;string.h&gt;
 31 #include &lt;unistd.h&gt;
 32 #include &lt;limits.h&gt;
 33 
 34 #include &quot;childproc.h&quot;
 35 

 36 
 37 ssize_t
 38 restartableWrite(int fd, const void *buf, size_t count)
 39 {
 40     ssize_t result;
 41     RESTARTABLE(write(fd, buf, count), result);
 42     return result;
 43 }
 44 
 45 int
 46 restartableDup2(int fd_from, int fd_to)
 47 {
 48     int err;
 49     RESTARTABLE(dup2(fd_from, fd_to), err);
 50     return err;
 51 }
 52 
 53 int
 54 closeSafely(int fd)
 55 {
</pre>
<hr />
<pre>
296                 break; /* Try other directories in PATH */
297             default:
298                 return;
299             }
300         }
301         if (sticky_errno != 0)
302             errno = sticky_errno;
303     }
304 }
305 
306 /**
307  * Child process after a successful fork().
308  * This function must not return, and must be prepared for either all
309  * of its address space to be shared with its parent, or to be a copy.
310  * It must not modify global variables such as &quot;environ&quot;.
311  */
312 int
313 childProcess(void *arg)
314 {
315     const ChildStuff* p = (const ChildStuff*) arg;








316 
317     /* Close the parent sides of the pipes.
318        Closing pipe fds here is redundant, since closeDescriptors()
319        would do it anyways, but a little paranoia is a good thing. */
320     if ((closeSafely(p-&gt;in[1])   == -1) ||
321         (closeSafely(p-&gt;out[0])  == -1) ||
322         (closeSafely(p-&gt;err[0])  == -1) ||
323         (closeSafely(p-&gt;childenv[0])  == -1) ||
324         (closeSafely(p-&gt;childenv[1])  == -1) ||
325         (closeSafely(p-&gt;fail[0]) == -1))
326         goto WhyCantJohnnyExec;
327 
328     /* Give the child sides of the pipes the right fileno&#39;s. */
329     /* Note: it is possible for in[0] == 0 */
330     if ((moveDescriptor(p-&gt;in[0] != -1 ?  p-&gt;in[0] : p-&gt;fds[0],
331                         STDIN_FILENO) == -1) ||
332         (moveDescriptor(p-&gt;out[1]!= -1 ? p-&gt;out[1] : p-&gt;fds[1],
333                         STDOUT_FILENO) == -1))
334         goto WhyCantJohnnyExec;
335 
336     if (p-&gt;redirectErrorStream) {
337         if ((closeSafely(p-&gt;err[1]) == -1) ||
338             (restartableDup2(STDOUT_FILENO, STDERR_FILENO) == -1))
339             goto WhyCantJohnnyExec;
340     } else {
341         if (moveDescriptor(p-&gt;err[1] != -1 ? p-&gt;err[1] : p-&gt;fds[2],
342                            STDERR_FILENO) == -1)
343             goto WhyCantJohnnyExec;
344     }
345 
<span class="line-modified">346     if (moveDescriptor(p-&gt;fail[1], FAIL_FILENO) == -1)</span>
347         goto WhyCantJohnnyExec;
348 



349     /* close everything */
350     if (closeDescriptors() == 0) { /* failed,  close the old way */
351         int max_fd = (int)sysconf(_SC_OPEN_MAX);
352         int fd;
353         for (fd = FAIL_FILENO + 1; fd &lt; max_fd; fd++)
354             if (close(fd) == -1 &amp;&amp; errno != EBADF)
355                 goto WhyCantJohnnyExec;
356     }
357 
358     /* change to the new working directory */
359     if (p-&gt;pdir != NULL &amp;&amp; chdir(p-&gt;pdir) &lt; 0)
360         goto WhyCantJohnnyExec;
361 
362     if (fcntl(FAIL_FILENO, F_SETFD, FD_CLOEXEC) == -1)
363         goto WhyCantJohnnyExec;
364 
365     JDK_execvpe(p-&gt;mode, p-&gt;argv[0], p-&gt;argv, p-&gt;envv);
366 
367  WhyCantJohnnyExec:
368     /* We used to go to an awful lot of trouble to predict whether the
369      * child would fail, but there is no reliable way to predict the
370      * success of an operation without *trying* it, and there&#39;s no way
371      * to try a chdir or exec in the parent.  Instead, all we need is a
372      * way to communicate any failure back to the parent.  Easy; we just
373      * send the errno back to the parent over a pipe in case of failure.
374      * The tricky thing is, how do we communicate the *success* of exec?
375      * We use FD_CLOEXEC together with the fact that a read() on a pipe
376      * yields EOF when the write ends (we have two of them!) are closed.
377      */
378     {
379         int errnum = errno;
<span class="line-modified">380         restartableWrite(FAIL_FILENO, &amp;errnum, sizeof(errnum));</span>
381     }
<span class="line-modified">382     close(FAIL_FILENO);</span>
383     _exit(-1);
384     return 0;  /* Suppress warning &quot;no return value from function&quot; */
385 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;dirent.h&gt;
 27 #include &lt;errno.h&gt;
 28 #include &lt;fcntl.h&gt;
<span class="line-added"> 29 #include &lt;stdio.h&gt;</span>
 30 #include &lt;stdlib.h&gt;
 31 #include &lt;string.h&gt;
 32 #include &lt;unistd.h&gt;
 33 #include &lt;limits.h&gt;
 34 
 35 #include &quot;childproc.h&quot;
 36 
<span class="line-added"> 37 const char * const *parentPathv;</span>
 38 
 39 ssize_t
 40 restartableWrite(int fd, const void *buf, size_t count)
 41 {
 42     ssize_t result;
 43     RESTARTABLE(write(fd, buf, count), result);
 44     return result;
 45 }
 46 
 47 int
 48 restartableDup2(int fd_from, int fd_to)
 49 {
 50     int err;
 51     RESTARTABLE(dup2(fd_from, fd_to), err);
 52     return err;
 53 }
 54 
 55 int
 56 closeSafely(int fd)
 57 {
</pre>
<hr />
<pre>
298                 break; /* Try other directories in PATH */
299             default:
300                 return;
301             }
302         }
303         if (sticky_errno != 0)
304             errno = sticky_errno;
305     }
306 }
307 
308 /**
309  * Child process after a successful fork().
310  * This function must not return, and must be prepared for either all
311  * of its address space to be shared with its parent, or to be a copy.
312  * It must not modify global variables such as &quot;environ&quot;.
313  */
314 int
315 childProcess(void *arg)
316 {
317     const ChildStuff* p = (const ChildStuff*) arg;
<span class="line-added">318     int fail_pipe_fd = p-&gt;fail[1];</span>
<span class="line-added">319 </span>
<span class="line-added">320     if (p-&gt;sendAlivePing) {</span>
<span class="line-added">321         /* Child shall signal aliveness to parent at the very first</span>
<span class="line-added">322          * moment. */</span>
<span class="line-added">323         int code = CHILD_IS_ALIVE;</span>
<span class="line-added">324         restartableWrite(fail_pipe_fd, &amp;code, sizeof(code));</span>
<span class="line-added">325     }</span>
326 
327     /* Close the parent sides of the pipes.
328        Closing pipe fds here is redundant, since closeDescriptors()
329        would do it anyways, but a little paranoia is a good thing. */
330     if ((closeSafely(p-&gt;in[1])   == -1) ||
331         (closeSafely(p-&gt;out[0])  == -1) ||
332         (closeSafely(p-&gt;err[0])  == -1) ||
333         (closeSafely(p-&gt;childenv[0])  == -1) ||
334         (closeSafely(p-&gt;childenv[1])  == -1) ||
335         (closeSafely(p-&gt;fail[0]) == -1))
336         goto WhyCantJohnnyExec;
337 
338     /* Give the child sides of the pipes the right fileno&#39;s. */
339     /* Note: it is possible for in[0] == 0 */
340     if ((moveDescriptor(p-&gt;in[0] != -1 ?  p-&gt;in[0] : p-&gt;fds[0],
341                         STDIN_FILENO) == -1) ||
342         (moveDescriptor(p-&gt;out[1]!= -1 ? p-&gt;out[1] : p-&gt;fds[1],
343                         STDOUT_FILENO) == -1))
344         goto WhyCantJohnnyExec;
345 
346     if (p-&gt;redirectErrorStream) {
347         if ((closeSafely(p-&gt;err[1]) == -1) ||
348             (restartableDup2(STDOUT_FILENO, STDERR_FILENO) == -1))
349             goto WhyCantJohnnyExec;
350     } else {
351         if (moveDescriptor(p-&gt;err[1] != -1 ? p-&gt;err[1] : p-&gt;fds[2],
352                            STDERR_FILENO) == -1)
353             goto WhyCantJohnnyExec;
354     }
355 
<span class="line-modified">356     if (moveDescriptor(fail_pipe_fd, FAIL_FILENO) == -1)</span>
357         goto WhyCantJohnnyExec;
358 
<span class="line-added">359     /* We moved the fail pipe fd */</span>
<span class="line-added">360     fail_pipe_fd = FAIL_FILENO;</span>
<span class="line-added">361 </span>
362     /* close everything */
363     if (closeDescriptors() == 0) { /* failed,  close the old way */
364         int max_fd = (int)sysconf(_SC_OPEN_MAX);
365         int fd;
366         for (fd = FAIL_FILENO + 1; fd &lt; max_fd; fd++)
367             if (close(fd) == -1 &amp;&amp; errno != EBADF)
368                 goto WhyCantJohnnyExec;
369     }
370 
371     /* change to the new working directory */
372     if (p-&gt;pdir != NULL &amp;&amp; chdir(p-&gt;pdir) &lt; 0)
373         goto WhyCantJohnnyExec;
374 
375     if (fcntl(FAIL_FILENO, F_SETFD, FD_CLOEXEC) == -1)
376         goto WhyCantJohnnyExec;
377 
378     JDK_execvpe(p-&gt;mode, p-&gt;argv[0], p-&gt;argv, p-&gt;envv);
379 
380  WhyCantJohnnyExec:
381     /* We used to go to an awful lot of trouble to predict whether the
382      * child would fail, but there is no reliable way to predict the
383      * success of an operation without *trying* it, and there&#39;s no way
384      * to try a chdir or exec in the parent.  Instead, all we need is a
385      * way to communicate any failure back to the parent.  Easy; we just
386      * send the errno back to the parent over a pipe in case of failure.
387      * The tricky thing is, how do we communicate the *success* of exec?
388      * We use FD_CLOEXEC together with the fact that a read() on a pipe
389      * yields EOF when the write ends (we have two of them!) are closed.
390      */
391     {
392         int errnum = errno;
<span class="line-modified">393         restartableWrite(fail_pipe_fd, &amp;errnum, sizeof(errnum));</span>
394     }
<span class="line-modified">395     close(fail_pipe_fd);</span>
396     _exit(-1);
397     return 0;  /* Suppress warning &quot;no return value from function&quot; */
398 }
</pre>
</td>
</tr>
</table>
<center><a href="canonicalize_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="childproc.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/unix/classes/sun/nio/ch/SourceChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketDispatcher.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="UnixAsynchronousServerSocketChannelImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/classes/sun/nio/ch/SourceChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 58,12 ***</span>
      // -- The following fields are protected by stateLock
  
      // Channel state
      private static final int ST_INUSE = 0;
      private static final int ST_CLOSING = 1;
<span class="line-modified">!     private static final int ST_KILLPENDING = 2;</span>
<span class="line-removed">-     private static final int ST_KILLED = 3;</span>
      private int state;
  
      // ID of native thread doing read, for signalling
      private long thread;
  
<span class="line-new-header">--- 58,11 ---</span>
      // -- The following fields are protected by stateLock
  
      // Channel state
      private static final int ST_INUSE = 0;
      private static final int ST_CLOSING = 1;
<span class="line-modified">!     private static final int ST_CLOSED = 2;</span>
      private int state;
  
      // ID of native thread doing read, for signalling
      private long thread;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,82 ***</span>
          this.fd = fd;
          this.fdVal = IOUtil.fdVal(fd);
      }
  
      /**
<span class="line-modified">!      * Invoked by implCloseChannel to close the channel.</span>
       */
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">!         assert !isOpen();</span>
  
<span class="line-modified">!         boolean interrupted = false;</span>
<span class="line-modified">!         boolean blocking;</span>
  
<span class="line-modified">!         // set state to ST_CLOSING</span>
          synchronized (stateLock) {
              assert state &lt; ST_CLOSING;
              state = ST_CLOSING;
<span class="line-modified">!             blocking = isBlocking();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // wait for any outstanding read to complete</span>
<span class="line-removed">-         if (blocking) {</span>
<span class="line-removed">-             synchronized (stateLock) {</span>
<span class="line-removed">-                 assert state == ST_CLOSING;</span>
                  long th = thread;
                  if (th != 0) {
                      nd.preClose(fd);
                      NativeThread.signal(th);
<span class="line-removed">- </span>
<span class="line-removed">-                     // wait for read operation to end</span>
<span class="line-removed">-                     while (thread != 0) {</span>
<span class="line-removed">-                         try {</span>
<span class="line-removed">-                             stateLock.wait();</span>
<span class="line-removed">-                         } catch (InterruptedException e) {</span>
<span class="line-removed">-                             interrupted = true;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
                  }
              }
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             // non-blocking mode: wait for read to complete</span>
<span class="line-removed">-             readLock.lock();</span>
<span class="line-removed">-             readLock.unlock();</span>
          }
  
<span class="line-modified">!         // set state to ST_KILLPENDING</span>
          synchronized (stateLock) {
<span class="line-modified">!             assert state == ST_CLOSING;</span>
<span class="line-modified">!             state = ST_KILLPENDING;</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         // close socket if not registered with Selector</span>
<span class="line-removed">-         if (!isRegistered())</span>
<span class="line-removed">-             kill();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // restore interrupt status</span>
<span class="line-removed">-         if (interrupted)</span>
<span class="line-removed">-             Thread.currentThread().interrupt();</span>
      }
  
      @Override
<span class="line-modified">!     public void kill() throws IOException {</span>
          synchronized (stateLock) {
<span class="line-modified">!             assert thread == 0;</span>
<span class="line-modified">!             if (state == ST_KILLPENDING) {</span>
<span class="line-modified">!                 state = ST_KILLED;</span>
<span class="line-removed">-                 nd.close(fd);</span>
              }
          }
      }
  
      @Override
      protected void implConfigureBlocking(boolean block) throws IOException {
          readLock.lock();
          try {
              synchronized (stateLock) {
                  IOUtil.configureBlocking(fd, block);
              }
          } finally {
              readLock.unlock();
          }
<span class="line-new-header">--- 82,106 ---</span>
          this.fd = fd;
          this.fdVal = IOUtil.fdVal(fd);
      }
  
      /**
<span class="line-modified">!      * Closes the read end of the pipe if there are no read operation in</span>
<span class="line-added">+      * progress and the channel is not registered with a Selector.</span>
       */
<span class="line-modified">!     private boolean tryClose() throws IOException {</span>
<span class="line-modified">!         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-modified">!         if (thread == 0 &amp;&amp; !isRegistered()) {</span>
<span class="line-added">+             state = ST_CLOSED;</span>
<span class="line-added">+             nd.close(fd);</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Invokes tryClose to attempt to close the read end of the pipe.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void tryFinishClose() {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             tryClose();</span>
<span class="line-added">+         } catch (IOException ignore) { }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Closes this channel when configured in blocking mode.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If there is a read operation in progress then the read-end of the pipe</span>
<span class="line-added">+      * is pre-closed and the reader is signalled, in which case the final close</span>
<span class="line-added">+      * is deferred until the reader aborts.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void implCloseBlockingMode() throws IOException {</span>
          synchronized (stateLock) {
              assert state &lt; ST_CLOSING;
              state = ST_CLOSING;
<span class="line-modified">!             if (!tryClose()) {</span>
                  long th = thread;
                  if (th != 0) {
                      nd.preClose(fd);
                      NativeThread.signal(th);
                  }
              }
          }
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added">+      * until the channel is flushed from all Selectors.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void implCloseNonBlockingMode() throws IOException {</span>
          synchronized (stateLock) {
<span class="line-modified">!             assert state &lt; ST_CLOSING;</span>
<span class="line-modified">!             state = ST_CLOSING;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // wait for any read operation to complete before trying to close</span>
<span class="line-added">+         readLock.lock();</span>
<span class="line-added">+         readLock.unlock();</span>
<span class="line-added">+         synchronized (stateLock) {</span>
<span class="line-added">+             if (state == ST_CLOSING) {</span>
<span class="line-added">+                 tryClose();</span>
<span class="line-added">+             }</span>
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-added">+         assert !isOpen();</span>
<span class="line-added">+         if (isBlocking()) {</span>
<span class="line-added">+             implCloseBlockingMode();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             implCloseNonBlockingMode();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
      @Override
<span class="line-modified">!     public void kill() {</span>
          synchronized (stateLock) {
<span class="line-modified">!             assert !isOpen();</span>
<span class="line-modified">!             if (state == ST_CLOSING) {</span>
<span class="line-modified">!                 tryFinishClose();</span>
              }
          }
      }
  
      @Override
      protected void implConfigureBlocking(boolean block) throws IOException {
          readLock.lock();
          try {
              synchronized (stateLock) {
<span class="line-added">+                 if (!isOpen())</span>
<span class="line-added">+                     throw new ClosedChannelException();</span>
                  IOUtil.configureBlocking(fd, block);
              }
          } finally {
              readLock.unlock();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,13 ***</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  thread = 0;
<span class="line-removed">-                 // notify any thread waiting in implCloseSelectableChannel</span>
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     stateLock.notifyAll();</span>
                  }
              }
              // remove hook for Thread.interrupt
              end(completed);
          }
<span class="line-new-header">--- 253,12 ---</span>
          throws AsynchronousCloseException
      {
          if (blocking) {
              synchronized (stateLock) {
                  thread = 0;
                  if (state == ST_CLOSING) {
<span class="line-modified">!                     tryFinishClose();</span>
                  }
              }
              // remove hook for Thread.interrupt
              end(completed);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,13 ***</span>
          try {
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginRead(blocking);
<span class="line-modified">!                 do {</span>
<span class="line-modified">!                     n = IOUtil.read(fd, dst, -1, nd);</span>
<span class="line-modified">!                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
<span class="line-new-header">--- 272,17 ---</span>
          try {
              boolean blocking = isBlocking();
              int n = 0;
              try {
                  beginRead(blocking);
<span class="line-modified">!                 n = IOUtil.read(fd, dst, -1, nd);</span>
<span class="line-modified">!                 if (blocking) {</span>
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLIN);</span>
<span class="line-added">+                         n = IOUtil.read(fd, dst, -1, nd);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,13 ***</span>
          try {
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginRead(blocking);
<span class="line-modified">!                 do {</span>
<span class="line-modified">!                     n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-modified">!                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
<span class="line-new-header">--- 299,17 ---</span>
          try {
              boolean blocking = isBlocking();
              long n = 0;
              try {
                  beginRead(blocking);
<span class="line-modified">!                 n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-modified">!                 if (blocking) {</span>
<span class="line-modified">!                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">+                         park(Net.POLLIN);</span>
<span class="line-added">+                         n = IOUtil.read(fd, dsts, offset, length, nd);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              } finally {
                  endRead(blocking, n &gt; 0);
                  assert IOStatus.check(n);
              }
              return IOStatus.normalize(n);
</pre>
<center><a href="SocketDispatcher.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="UnixAsynchronousServerSocketChannelImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
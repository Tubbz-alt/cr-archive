<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/classes/sun/nio/ch/InheritedChannel.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="FileDispatcherImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SinkChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/classes/sun/nio/ch/InheritedChannel.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package sun.nio.ch;
 27 
 28 import java.lang.reflect.Constructor;
 29 import java.io.FileDescriptor;
 30 import java.io.IOException;
 31 import java.net.InetAddress;
 32 import java.net.InetSocketAddress;
 33 import java.nio.channels.Channel;
 34 import java.nio.channels.SocketChannel;
 35 import java.nio.channels.ServerSocketChannel;
 36 import java.nio.channels.DatagramChannel;
 37 import java.nio.channels.spi.SelectorProvider;
 38 
 39 class InheritedChannel {
 40 
 41     // the &quot;types&quot; of socket returned by soType0
 42     private static final int UNKNOWN            = -1;
 43     private static final int SOCK_STREAM        = 1;
 44     private static final int SOCK_DGRAM         = 2;
 45 






 46     // oflag values when opening a file
 47     private static final int O_RDONLY           = 0;
 48     private static final int O_WRONLY           = 1;
 49     private static final int O_RDWR             = 2;
 50 
 51     /*
 52      * In order to &quot;detach&quot; the standard streams we dup them to /dev/null.
 53      * In order to reduce the possibility of an error at close time we
 54      * open /dev/null early - that way we know we won&#39;t run out of file
 55      * descriptors at close time. This makes the close operation a
 56      * simple dup2 operation for each of the standard streams.
 57      */
 58     private static int devnull = -1;
 59 
 60     private static void detachIOStreams() {
 61         try {
 62             dup2(devnull, 0);
 63             dup2(devnull, 1);
 64             dup2(devnull, 2);
 65         } catch (IOException ioe) {
</pre>
<hr />
<pre>
 72      * Override the implCloseSelectableChannel for each channel type - this
 73      * allows us to &quot;detach&quot; the standard streams after closing and ensures
 74      * that the underlying socket really closes.
 75      */
 76     public static class InheritedSocketChannelImpl extends SocketChannelImpl {
 77 
 78         InheritedSocketChannelImpl(SelectorProvider sp,
 79                                    FileDescriptor fd,
 80                                    InetSocketAddress remote)
 81             throws IOException
 82         {
 83             super(sp, fd, remote);
 84         }
 85 
 86         protected void implCloseSelectableChannel() throws IOException {
 87             super.implCloseSelectableChannel();
 88             detachIOStreams();
 89         }
 90     }
 91 














 92     public static class InheritedServerSocketChannelImpl extends
 93         ServerSocketChannelImpl {
 94 
 95         InheritedServerSocketChannelImpl(SelectorProvider sp,
 96                                          FileDescriptor fd)
 97             throws IOException
 98         {
 99             super(sp, fd, true);
100         }
101 
102         protected void implCloseSelectableChannel() throws IOException {
103             super.implCloseSelectableChannel();
104             detachIOStreams();
105         }
106 
107     }
108 
109     public static class InheritedDatagramChannelImpl extends
110         DatagramChannelImpl {
111 
</pre>
<hr />
<pre>
143     private static Channel createChannel() throws IOException {
144 
145         // dup the file descriptor - we do this so that for two reasons :-
146         // 1. Avoids any timing issues with FileDescriptor.in being closed
147         //    or redirected while we create the channel.
148         // 2. Allows streams based on file descriptor 0 to co-exist with
149         //    the channel (closing one doesn&#39;t impact the other)
150 
151         int fdVal = dup(0);
152 
153         // Examine the file descriptor - if it&#39;s not a socket then we don&#39;t
154         // create a channel so we release the file descriptor.
155 
156         int st;
157         st = soType0(fdVal);
158         if (st != SOCK_STREAM &amp;&amp; st != SOCK_DGRAM) {
159             close0(fdVal);
160             return null;
161         }
162 
<span class="line-removed">163 </span>
164         // Next we create a FileDescriptor for the dup&#39;ed file descriptor
165         // Have to use reflection and also make assumption on how FD
166         // is implemented.
167 
168         Class&lt;?&gt; paramTypes[] = { int.class };
169         Constructor&lt;?&gt; ctr = Reflect.lookupConstructor(&quot;java.io.FileDescriptor&quot;,
170                                                        paramTypes);
171         Object args[] = { Integer.valueOf(fdVal) };
172         FileDescriptor fd = (FileDescriptor)Reflect.invoke(ctr, args);
173 
174 
175         // Now create the channel. If the socket is a streams socket then
176         // we see if tthere is a peer (ie: connected). If so, then we
177         // create a SocketChannel, otherwise a ServerSocketChannel.
178         // If the socket is a datagram socket then create a DatagramChannel
179 
180         SelectorProvider provider = SelectorProvider.provider();
181         assert provider instanceof sun.nio.ch.SelectorProviderImpl;
182 
183         Channel c;
184         if (st == SOCK_STREAM) {











185             InetAddress ia = peerAddress0(fdVal);
186             if (ia == null) {
187                c = new InheritedServerSocketChannelImpl(provider, fd);
188             } else {
189                int port = peerPort0(fdVal);
190                assert port &gt; 0;
191                InetSocketAddress isa = new InetSocketAddress(ia, port);
192                c = new InheritedSocketChannelImpl(provider, fd, isa);
193             }
194         } else {
195             c = new InheritedDatagramChannelImpl(provider, fd);
196         }
197         return c;
198     }
199 
200     private static boolean haveChannel = false;
201     private static Channel channel = null;
202 
203     /*
204      * Returns a Channel representing the inherited channel if the
</pre>
<hr />
<pre>
215             haveChannel = true;
216         }
217 
218         // if there is a channel then do the security check before
219         // returning it.
220         if (channel != null) {
221             checkAccess(channel);
222         }
223         return channel;
224     }
225 
226 
227     // -- Native methods --
228 
229     private static native void initIDs();
230     private static native int dup(int fd) throws IOException;
231     private static native void dup2(int fd, int fd2) throws IOException;
232     private static native int open0(String path, int oflag) throws IOException;
233     private static native void close0(int fd) throws IOException;
234     private static native int soType0(int fd);

235     private static native InetAddress peerAddress0(int fd);
236     private static native int peerPort0(int fd);
237 



238     static {
239         IOUtil.load();
240         initIDs();
241     }
242 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package sun.nio.ch;
 27 
 28 import java.lang.reflect.Constructor;
 29 import java.io.FileDescriptor;
 30 import java.io.IOException;
 31 import java.net.InetAddress;
 32 import java.net.InetSocketAddress;
 33 import java.nio.channels.Channel;
 34 import java.nio.channels.SocketChannel;
 35 import java.nio.channels.ServerSocketChannel;
 36 import java.nio.channels.DatagramChannel;
 37 import java.nio.channels.spi.SelectorProvider;
 38 
 39 class InheritedChannel {
 40 
 41     // the &quot;types&quot; of socket returned by soType0
 42     private static final int UNKNOWN            = -1;
 43     private static final int SOCK_STREAM        = 1;
 44     private static final int SOCK_DGRAM         = 2;
 45 
<span class="line-added"> 46     // socket address type</span>
<span class="line-added"> 47     private static final int AF_UNKNOWN         = -1;</span>
<span class="line-added"> 48     private static final int AF_INET            = 1;</span>
<span class="line-added"> 49     private static final int AF_INET6           = 2;</span>
<span class="line-added"> 50     private static final int AF_UNIX            = 3;</span>
<span class="line-added"> 51 </span>
 52     // oflag values when opening a file
 53     private static final int O_RDONLY           = 0;
 54     private static final int O_WRONLY           = 1;
 55     private static final int O_RDWR             = 2;
 56 
 57     /*
 58      * In order to &quot;detach&quot; the standard streams we dup them to /dev/null.
 59      * In order to reduce the possibility of an error at close time we
 60      * open /dev/null early - that way we know we won&#39;t run out of file
 61      * descriptors at close time. This makes the close operation a
 62      * simple dup2 operation for each of the standard streams.
 63      */
 64     private static int devnull = -1;
 65 
 66     private static void detachIOStreams() {
 67         try {
 68             dup2(devnull, 0);
 69             dup2(devnull, 1);
 70             dup2(devnull, 2);
 71         } catch (IOException ioe) {
</pre>
<hr />
<pre>
 78      * Override the implCloseSelectableChannel for each channel type - this
 79      * allows us to &quot;detach&quot; the standard streams after closing and ensures
 80      * that the underlying socket really closes.
 81      */
 82     public static class InheritedSocketChannelImpl extends SocketChannelImpl {
 83 
 84         InheritedSocketChannelImpl(SelectorProvider sp,
 85                                    FileDescriptor fd,
 86                                    InetSocketAddress remote)
 87             throws IOException
 88         {
 89             super(sp, fd, remote);
 90         }
 91 
 92         protected void implCloseSelectableChannel() throws IOException {
 93             super.implCloseSelectableChannel();
 94             detachIOStreams();
 95         }
 96     }
 97 
<span class="line-added"> 98     public static class InheritedUnixChannelImpl extends UnixDomainSocketChannelImpl {</span>
<span class="line-added"> 99 </span>
<span class="line-added">100         InheritedUnixChannelImpl(FileDescriptor fd)</span>
<span class="line-added">101             throws IOException</span>
<span class="line-added">102         {</span>
<span class="line-added">103             super(fd);</span>
<span class="line-added">104         }</span>
<span class="line-added">105 </span>
<span class="line-added">106         protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-added">107             super.implCloseChannel();</span>
<span class="line-added">108             detachIOStreams();</span>
<span class="line-added">109         }</span>
<span class="line-added">110     }</span>
<span class="line-added">111 </span>
112     public static class InheritedServerSocketChannelImpl extends
113         ServerSocketChannelImpl {
114 
115         InheritedServerSocketChannelImpl(SelectorProvider sp,
116                                          FileDescriptor fd)
117             throws IOException
118         {
119             super(sp, fd, true);
120         }
121 
122         protected void implCloseSelectableChannel() throws IOException {
123             super.implCloseSelectableChannel();
124             detachIOStreams();
125         }
126 
127     }
128 
129     public static class InheritedDatagramChannelImpl extends
130         DatagramChannelImpl {
131 
</pre>
<hr />
<pre>
163     private static Channel createChannel() throws IOException {
164 
165         // dup the file descriptor - we do this so that for two reasons :-
166         // 1. Avoids any timing issues with FileDescriptor.in being closed
167         //    or redirected while we create the channel.
168         // 2. Allows streams based on file descriptor 0 to co-exist with
169         //    the channel (closing one doesn&#39;t impact the other)
170 
171         int fdVal = dup(0);
172 
173         // Examine the file descriptor - if it&#39;s not a socket then we don&#39;t
174         // create a channel so we release the file descriptor.
175 
176         int st;
177         st = soType0(fdVal);
178         if (st != SOCK_STREAM &amp;&amp; st != SOCK_DGRAM) {
179             close0(fdVal);
180             return null;
181         }
182 

183         // Next we create a FileDescriptor for the dup&#39;ed file descriptor
184         // Have to use reflection and also make assumption on how FD
185         // is implemented.
186 
187         Class&lt;?&gt; paramTypes[] = { int.class };
188         Constructor&lt;?&gt; ctr = Reflect.lookupConstructor(&quot;java.io.FileDescriptor&quot;,
189                                                        paramTypes);
190         Object args[] = { Integer.valueOf(fdVal) };
191         FileDescriptor fd = (FileDescriptor)Reflect.invoke(ctr, args);
192 
193 
194         // Now create the channel. If the socket is a streams socket then
195         // we see if tthere is a peer (ie: connected). If so, then we
196         // create a SocketChannel, otherwise a ServerSocketChannel.
197         // If the socket is a datagram socket then create a DatagramChannel
198 
199         SelectorProvider provider = SelectorProvider.provider();
200         assert provider instanceof sun.nio.ch.SelectorProviderImpl;
201 
202         Channel c;
203         if (st == SOCK_STREAM) {
<span class="line-added">204             int family = addressFamily(fdVal);</span>
<span class="line-added">205             if (family == AF_UNKNOWN)</span>
<span class="line-added">206                 return null;</span>
<span class="line-added">207             if (family == AF_UNIX) {</span>
<span class="line-added">208                 if (isConnected(fdVal)) {</span>
<span class="line-added">209                     return new InheritedUnixChannelImpl(fd);</span>
<span class="line-added">210                 } else {</span>
<span class="line-added">211                     // listener. unsupported.</span>
<span class="line-added">212                     return null;</span>
<span class="line-added">213                 }</span>
<span class="line-added">214             }</span>
215             InetAddress ia = peerAddress0(fdVal);
216             if (ia == null) {
217                c = new InheritedServerSocketChannelImpl(provider, fd);
218             } else {
219                int port = peerPort0(fdVal);
220                assert port &gt; 0;
221                InetSocketAddress isa = new InetSocketAddress(ia, port);
222                c = new InheritedSocketChannelImpl(provider, fd, isa);
223             }
224         } else {
225             c = new InheritedDatagramChannelImpl(provider, fd);
226         }
227         return c;
228     }
229 
230     private static boolean haveChannel = false;
231     private static Channel channel = null;
232 
233     /*
234      * Returns a Channel representing the inherited channel if the
</pre>
<hr />
<pre>
245             haveChannel = true;
246         }
247 
248         // if there is a channel then do the security check before
249         // returning it.
250         if (channel != null) {
251             checkAccess(channel);
252         }
253         return channel;
254     }
255 
256 
257     // -- Native methods --
258 
259     private static native void initIDs();
260     private static native int dup(int fd) throws IOException;
261     private static native void dup2(int fd, int fd2) throws IOException;
262     private static native int open0(String path, int oflag) throws IOException;
263     private static native void close0(int fd) throws IOException;
264     private static native int soType0(int fd);
<span class="line-added">265     private static native int addressFamily(int fd);</span>
266     private static native InetAddress peerAddress0(int fd);
267     private static native int peerPort0(int fd);
268 
<span class="line-added">269     // return true if socket is connected to a peer</span>
<span class="line-added">270     private static native boolean isConnected(int fd);</span>
<span class="line-added">271 </span>
272     static {
273         IOUtil.load();
274         initIDs();
275     }
276 }
</pre>
</td>
</tr>
</table>
<center><a href="FileDispatcherImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SinkChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
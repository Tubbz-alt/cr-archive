<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/classes/sun/nio/ch/SinkChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InheritedChannel.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketDispatcher.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/classes/sun/nio/ch/SinkChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 43 {
 44     // Used to make native read and write calls
 45     private static final NativeDispatcher nd = new FileDispatcherImpl();
 46 
 47     // The file descriptor associated with this channel
 48     private final FileDescriptor fd;
 49     private final int fdVal;
 50 
 51     // Lock held by current writing thread
 52     private final ReentrantLock writeLock = new ReentrantLock();
 53 
 54     // Lock held by any thread that modifies the state fields declared below
 55     // DO NOT invoke a blocking I/O operation while holding this lock!
 56     private final Object stateLock = new Object();
 57 
 58     // -- The following fields are protected by stateLock
 59 
 60     // Channel state
 61     private static final int ST_INUSE = 0;
 62     private static final int ST_CLOSING = 1;
<span class="line-modified"> 63     private static final int ST_KILLPENDING = 2;</span>
<span class="line-removed"> 64     private static final int ST_KILLED = 3;</span>
 65     private int state;
 66 
 67     // ID of native thread doing write, for signalling
 68     private long thread;
 69 
 70     // -- End of fields protected by stateLock
 71 
 72 
 73     public FileDescriptor getFD() {
 74         return fd;
 75     }
 76 
 77     public int getFDVal() {
 78         return fdVal;
 79     }
 80 
 81     SinkChannelImpl(SelectorProvider sp, FileDescriptor fd) {
 82         super(sp);
 83         this.fd = fd;
 84         this.fdVal = IOUtil.fdVal(fd);
 85     }
 86 
 87     /**
<span class="line-modified"> 88      * Invoked by implCloseChannel to close the channel.</span>

 89      */
<span class="line-modified"> 90     @Override</span>
<span class="line-modified"> 91     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified"> 92         assert !isOpen();</span>







 93 
<span class="line-modified"> 94         boolean interrupted = false;</span>
<span class="line-modified"> 95         boolean blocking;</span>








 96 
<span class="line-modified"> 97         // set state to ST_CLOSING</span>







 98         synchronized (stateLock) {
 99             assert state &lt; ST_CLOSING;
100             state = ST_CLOSING;
<span class="line-modified">101             blocking = isBlocking();</span>
<span class="line-removed">102         }</span>
<span class="line-removed">103 </span>
<span class="line-removed">104         // wait for any outstanding write to complete</span>
<span class="line-removed">105         if (blocking) {</span>
<span class="line-removed">106             synchronized (stateLock) {</span>
<span class="line-removed">107                 assert state == ST_CLOSING;</span>
108                 long th = thread;
109                 if (th != 0) {
110                     nd.preClose(fd);
111                     NativeThread.signal(th);
<span class="line-removed">112 </span>
<span class="line-removed">113                     // wait for write operation to end</span>
<span class="line-removed">114                     while (thread != 0) {</span>
<span class="line-removed">115                         try {</span>
<span class="line-removed">116                             stateLock.wait();</span>
<span class="line-removed">117                         } catch (InterruptedException e) {</span>
<span class="line-removed">118                             interrupted = true;</span>
<span class="line-removed">119                         }</span>
<span class="line-removed">120                     }</span>
121                 }
122             }
<span class="line-removed">123         } else {</span>
<span class="line-removed">124             // non-blocking mode: wait for write to complete</span>
<span class="line-removed">125             writeLock.lock();</span>
<span class="line-removed">126             writeLock.unlock();</span>
127         }

128 
<span class="line-modified">129         // set state to ST_KILLPENDING</span>






130         synchronized (stateLock) {
<span class="line-modified">131             assert state == ST_CLOSING;</span>
<span class="line-modified">132             state = ST_KILLPENDING;</span>
133         }









134 
<span class="line-modified">135         // close socket if not registered with Selector</span>
<span class="line-modified">136         if (!isRegistered())</span>
<span class="line-modified">137             kill();</span>
<span class="line-modified">138 </span>
<span class="line-modified">139         // restore interrupt status</span>
<span class="line-modified">140         if (interrupted)</span>
<span class="line-modified">141             Thread.currentThread().interrupt();</span>




142     }
143 
144     @Override
<span class="line-modified">145     public void kill() throws IOException {</span>
146         synchronized (stateLock) {
<span class="line-modified">147             assert thread == 0;</span>
<span class="line-modified">148             if (state == ST_KILLPENDING) {</span>
<span class="line-removed">149                 state = ST_KILLED;</span>
<span class="line-removed">150                 nd.close(fd);</span>
151             }
152         }
153     }
154 
155     @Override
156     protected void implConfigureBlocking(boolean block) throws IOException {
157         writeLock.lock();
158         try {
159             synchronized (stateLock) {


160                 IOUtil.configureBlocking(fd, block);
161             }
162         } finally {
163             writeLock.unlock();
164         }
165     }
166 
167     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
168         int intOps = ski.nioInterestOps();
169         int oldOps = ski.nioReadyOps();
170         int newOps = initialOps;
171 
172         if ((ops &amp; Net.POLLNVAL) != 0)
173             throw new Error(&quot;POLLNVAL detected&quot;);
174 
175         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
176             newOps = intOps;
177             ski.nioReadyOps(newOps);
178             return (newOps &amp; ~oldOps) != 0;
179         }
</pre>
<hr />
<pre>
215         synchronized (stateLock) {
216             if (!isOpen())
217                 throw new ClosedChannelException();
218             if (blocking)
219                 thread = NativeThread.current();
220         }
221     }
222 
223     /**
224      * Marks the end of a write operation that may have blocked.
225      *
226      * @throws AsynchronousCloseException if the channel was closed due to this
227      * thread being interrupted on a blocking write operation.
228      */
229     private void endWrite(boolean blocking, boolean completed)
230         throws AsynchronousCloseException
231     {
232         if (blocking) {
233             synchronized (stateLock) {
234                 thread = 0;
<span class="line-removed">235                 // notify any thread waiting in implCloseSelectableChannel</span>
236                 if (state == ST_CLOSING) {
<span class="line-modified">237                     stateLock.notifyAll();</span>
238                 }
239             }
240             // remove hook for Thread.interrupt
241             end(completed);
242         }
243     }
244 
245     @Override
246     public int write(ByteBuffer src) throws IOException {
247         Objects.requireNonNull(src);
248 
249         writeLock.lock();
250         try {
251             boolean blocking = isBlocking();
252             int n = 0;
253             try {
254                 beginWrite(blocking);
<span class="line-modified">255                 do {</span>
<span class="line-modified">256                     n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-modified">257                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>




258             } finally {
259                 endWrite(blocking, n &gt; 0);
260                 assert IOStatus.check(n);
261             }
262             return IOStatus.normalize(n);
263         } finally {
264             writeLock.unlock();
265         }
266     }
267 
268     @Override
269     public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {
270         Objects.checkFromIndexSize(offset, length, srcs.length);
271 
272         writeLock.lock();
273         try {
274             boolean blocking = isBlocking();
275             long n = 0;
276             try {
277                 beginWrite(blocking);
<span class="line-modified">278                 do {</span>
<span class="line-modified">279                     n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-modified">280                 } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span>




281             } finally {
282                 endWrite(blocking, n &gt; 0);
283                 assert IOStatus.check(n);
284             }
285             return IOStatus.normalize(n);
286         } finally {
287             writeLock.unlock();
288         }
289     }
290 
291     @Override
292     public long write(ByteBuffer[] srcs) throws IOException {
293         return write(srcs, 0, srcs.length);
294     }
295 }
</pre>
</td>
<td>
<hr />
<pre>
 43 {
 44     // Used to make native read and write calls
 45     private static final NativeDispatcher nd = new FileDispatcherImpl();
 46 
 47     // The file descriptor associated with this channel
 48     private final FileDescriptor fd;
 49     private final int fdVal;
 50 
 51     // Lock held by current writing thread
 52     private final ReentrantLock writeLock = new ReentrantLock();
 53 
 54     // Lock held by any thread that modifies the state fields declared below
 55     // DO NOT invoke a blocking I/O operation while holding this lock!
 56     private final Object stateLock = new Object();
 57 
 58     // -- The following fields are protected by stateLock
 59 
 60     // Channel state
 61     private static final int ST_INUSE = 0;
 62     private static final int ST_CLOSING = 1;
<span class="line-modified"> 63     private static final int ST_CLOSED = 2;</span>

 64     private int state;
 65 
 66     // ID of native thread doing write, for signalling
 67     private long thread;
 68 
 69     // -- End of fields protected by stateLock
 70 
 71 
 72     public FileDescriptor getFD() {
 73         return fd;
 74     }
 75 
 76     public int getFDVal() {
 77         return fdVal;
 78     }
 79 
 80     SinkChannelImpl(SelectorProvider sp, FileDescriptor fd) {
 81         super(sp);
 82         this.fd = fd;
 83         this.fdVal = IOUtil.fdVal(fd);
 84     }
 85 
 86     /**
<span class="line-modified"> 87      * Closes the write end of the pipe if there are no write operation in</span>
<span class="line-added"> 88      * progress and the channel is not registered with a Selector.</span>
 89      */
<span class="line-modified"> 90     private boolean tryClose() throws IOException {</span>
<span class="line-modified"> 91         assert Thread.holdsLock(stateLock) &amp;&amp; state == ST_CLOSING;</span>
<span class="line-modified"> 92         if (thread == 0 &amp;&amp; !isRegistered()) {</span>
<span class="line-added"> 93             state = ST_CLOSED;</span>
<span class="line-added"> 94             nd.close(fd);</span>
<span class="line-added"> 95             return true;</span>
<span class="line-added"> 96         } else {</span>
<span class="line-added"> 97             return false;</span>
<span class="line-added"> 98         }</span>
<span class="line-added"> 99     }</span>
100 
<span class="line-modified">101     /**</span>
<span class="line-modified">102      * Invokes tryClose to attempt to close the write end of the pipe.</span>
<span class="line-added">103      *</span>
<span class="line-added">104      * This method is used for deferred closing by I/O and Selector operations.</span>
<span class="line-added">105      */</span>
<span class="line-added">106     private void tryFinishClose() {</span>
<span class="line-added">107         try {</span>
<span class="line-added">108             tryClose();</span>
<span class="line-added">109         } catch (IOException ignore) { }</span>
<span class="line-added">110     }</span>
111 
<span class="line-modified">112     /**</span>
<span class="line-added">113      * Closes this channel when configured in blocking mode.</span>
<span class="line-added">114      *</span>
<span class="line-added">115      * If there is a write operation in progress then the write-end of the pipe</span>
<span class="line-added">116      * is pre-closed and the writer is signalled, in which case the final close</span>
<span class="line-added">117      * is deferred until the writer aborts.</span>
<span class="line-added">118      */</span>
<span class="line-added">119     private void implCloseBlockingMode() throws IOException {</span>
120         synchronized (stateLock) {
121             assert state &lt; ST_CLOSING;
122             state = ST_CLOSING;
<span class="line-modified">123             if (!tryClose()) {</span>






124                 long th = thread;
125                 if (th != 0) {
126                     nd.preClose(fd);
127                     NativeThread.signal(th);









128                 }
129             }




130         }
<span class="line-added">131     }</span>
132 
<span class="line-modified">133     /**</span>
<span class="line-added">134      * Closes this channel when configured in non-blocking mode.</span>
<span class="line-added">135      *</span>
<span class="line-added">136      * If the channel is registered with a Selector then the close is deferred</span>
<span class="line-added">137      * until the channel is flushed from all Selectors.</span>
<span class="line-added">138      */</span>
<span class="line-added">139     private void implCloseNonBlockingMode() throws IOException {</span>
140         synchronized (stateLock) {
<span class="line-modified">141             assert state &lt; ST_CLOSING;</span>
<span class="line-modified">142             state = ST_CLOSING;</span>
143         }
<span class="line-added">144         // wait for any write operation to complete before trying to close</span>
<span class="line-added">145         writeLock.lock();</span>
<span class="line-added">146         writeLock.unlock();</span>
<span class="line-added">147         synchronized (stateLock) {</span>
<span class="line-added">148             if (state == ST_CLOSING) {</span>
<span class="line-added">149                 tryClose();</span>
<span class="line-added">150             }</span>
<span class="line-added">151         }</span>
<span class="line-added">152     }</span>
153 
<span class="line-modified">154     /**</span>
<span class="line-modified">155      * Invoked by implCloseChannel to close the channel.</span>
<span class="line-modified">156      */</span>
<span class="line-modified">157     @Override</span>
<span class="line-modified">158     protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-modified">159         assert !isOpen();</span>
<span class="line-modified">160         if (isBlocking()) {</span>
<span class="line-added">161             implCloseBlockingMode();</span>
<span class="line-added">162         } else {</span>
<span class="line-added">163             implCloseNonBlockingMode();</span>
<span class="line-added">164         }</span>
165     }
166 
167     @Override
<span class="line-modified">168     public void kill() {</span>
169         synchronized (stateLock) {
<span class="line-modified">170             if (state == ST_CLOSING) {</span>
<span class="line-modified">171                 tryFinishClose();</span>


172             }
173         }
174     }
175 
176     @Override
177     protected void implConfigureBlocking(boolean block) throws IOException {
178         writeLock.lock();
179         try {
180             synchronized (stateLock) {
<span class="line-added">181                 if (!isOpen())</span>
<span class="line-added">182                     throw new ClosedChannelException();</span>
183                 IOUtil.configureBlocking(fd, block);
184             }
185         } finally {
186             writeLock.unlock();
187         }
188     }
189 
190     public boolean translateReadyOps(int ops, int initialOps, SelectionKeyImpl ski) {
191         int intOps = ski.nioInterestOps();
192         int oldOps = ski.nioReadyOps();
193         int newOps = initialOps;
194 
195         if ((ops &amp; Net.POLLNVAL) != 0)
196             throw new Error(&quot;POLLNVAL detected&quot;);
197 
198         if ((ops &amp; (Net.POLLERR | Net.POLLHUP)) != 0) {
199             newOps = intOps;
200             ski.nioReadyOps(newOps);
201             return (newOps &amp; ~oldOps) != 0;
202         }
</pre>
<hr />
<pre>
238         synchronized (stateLock) {
239             if (!isOpen())
240                 throw new ClosedChannelException();
241             if (blocking)
242                 thread = NativeThread.current();
243         }
244     }
245 
246     /**
247      * Marks the end of a write operation that may have blocked.
248      *
249      * @throws AsynchronousCloseException if the channel was closed due to this
250      * thread being interrupted on a blocking write operation.
251      */
252     private void endWrite(boolean blocking, boolean completed)
253         throws AsynchronousCloseException
254     {
255         if (blocking) {
256             synchronized (stateLock) {
257                 thread = 0;

258                 if (state == ST_CLOSING) {
<span class="line-modified">259                     tryFinishClose();</span>
260                 }
261             }
262             // remove hook for Thread.interrupt
263             end(completed);
264         }
265     }
266 
267     @Override
268     public int write(ByteBuffer src) throws IOException {
269         Objects.requireNonNull(src);
270 
271         writeLock.lock();
272         try {
273             boolean blocking = isBlocking();
274             int n = 0;
275             try {
276                 beginWrite(blocking);
<span class="line-modified">277                 n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-modified">278                 if (blocking) {</span>
<span class="line-modified">279                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">280                         park(Net.POLLOUT);</span>
<span class="line-added">281                         n = IOUtil.write(fd, src, -1, nd);</span>
<span class="line-added">282                     }</span>
<span class="line-added">283                 }</span>
284             } finally {
285                 endWrite(blocking, n &gt; 0);
286                 assert IOStatus.check(n);
287             }
288             return IOStatus.normalize(n);
289         } finally {
290             writeLock.unlock();
291         }
292     }
293 
294     @Override
295     public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {
296         Objects.checkFromIndexSize(offset, length, srcs.length);
297 
298         writeLock.lock();
299         try {
300             boolean blocking = isBlocking();
301             long n = 0;
302             try {
303                 beginWrite(blocking);
<span class="line-modified">304                 n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-modified">305                 if (blocking) {</span>
<span class="line-modified">306                     while (IOStatus.okayToRetry(n) &amp;&amp; isOpen()) {</span>
<span class="line-added">307                         park(Net.POLLOUT);</span>
<span class="line-added">308                         n = IOUtil.write(fd, srcs, offset, length, nd);</span>
<span class="line-added">309                     }</span>
<span class="line-added">310                 }</span>
311             } finally {
312                 endWrite(blocking, n &gt; 0);
313                 assert IOStatus.check(n);
314             }
315             return IOStatus.normalize(n);
316         } finally {
317             writeLock.unlock();
318         }
319     }
320 
321     @Override
322     public long write(ByteBuffer[] srcs) throws IOException {
323         return write(srcs, 0, srcs.length);
324     }
325 }
</pre>
</td>
</tr>
</table>
<center><a href="InheritedChannel.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SocketDispatcher.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
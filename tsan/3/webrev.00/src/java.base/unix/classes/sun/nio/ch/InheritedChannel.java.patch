diff a/src/java.base/unix/classes/sun/nio/ch/InheritedChannel.java b/src/java.base/unix/classes/sun/nio/ch/InheritedChannel.java
--- a/src/java.base/unix/classes/sun/nio/ch/InheritedChannel.java
+++ b/src/java.base/unix/classes/sun/nio/ch/InheritedChannel.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,10 +41,16 @@
     // the "types" of socket returned by soType0
     private static final int UNKNOWN            = -1;
     private static final int SOCK_STREAM        = 1;
     private static final int SOCK_DGRAM         = 2;
 
+    // socket address type
+    private static final int AF_UNKNOWN         = -1;
+    private static final int AF_INET            = 1;
+    private static final int AF_INET6           = 2;
+    private static final int AF_UNIX            = 3;
+
     // oflag values when opening a file
     private static final int O_RDONLY           = 0;
     private static final int O_WRONLY           = 1;
     private static final int O_RDWR             = 2;
 
@@ -87,10 +93,24 @@
             super.implCloseSelectableChannel();
             detachIOStreams();
         }
     }
 
+    public static class InheritedUnixChannelImpl extends UnixDomainSocketChannelImpl {
+
+        InheritedUnixChannelImpl(FileDescriptor fd)
+            throws IOException
+        {
+            super(fd);
+        }
+
+        protected void implCloseSelectableChannel() throws IOException {
+            super.implCloseChannel();
+            detachIOStreams();
+        }
+    }
+
     public static class InheritedServerSocketChannelImpl extends
         ServerSocketChannelImpl {
 
         InheritedServerSocketChannelImpl(SelectorProvider sp,
                                          FileDescriptor fd)
@@ -158,11 +178,10 @@
         if (st != SOCK_STREAM && st != SOCK_DGRAM) {
             close0(fdVal);
             return null;
         }
 
-
         // Next we create a FileDescriptor for the dup'ed file descriptor
         // Have to use reflection and also make assumption on how FD
         // is implemented.
 
         Class<?> paramTypes[] = { int.class };
@@ -180,10 +199,21 @@
         SelectorProvider provider = SelectorProvider.provider();
         assert provider instanceof sun.nio.ch.SelectorProviderImpl;
 
         Channel c;
         if (st == SOCK_STREAM) {
+            int family = addressFamily(fdVal);
+            if (family == AF_UNKNOWN)
+                return null;
+            if (family == AF_UNIX) {
+                if (isConnected(fdVal)) {
+                    return new InheritedUnixChannelImpl(fd);
+                } else {
+                    // listener. unsupported.
+                    return null;
+                }
+            }
             InetAddress ia = peerAddress0(fdVal);
             if (ia == null) {
                c = new InheritedServerSocketChannelImpl(provider, fd);
             } else {
                int port = peerPort0(fdVal);
@@ -230,13 +260,17 @@
     private static native int dup(int fd) throws IOException;
     private static native void dup2(int fd, int fd2) throws IOException;
     private static native int open0(String path, int oflag) throws IOException;
     private static native void close0(int fd) throws IOException;
     private static native int soType0(int fd);
+    private static native int addressFamily(int fd);
     private static native InetAddress peerAddress0(int fd);
     private static native int peerPort0(int fd);
 
+    // return true if socket is connected to a peer
+    private static native boolean isConnected(int fd);
+
     static {
         IOUtil.load();
         initIDs();
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/classes/sun/nio/ch/UnixAsynchronousSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnixAsynchronousServerSocketChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../fs/UnixCopyFile.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/classes/sun/nio/ch/UnixAsynchronousSocketChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.nio.channels.*;
 29 import java.nio.ByteBuffer;
 30 import java.net.*;
 31 import java.util.concurrent.*;
 32 import java.io.IOException;
 33 import java.io.FileDescriptor;


 34 import sun.net.NetHooks;
 35 import sun.net.util.SocketExceptions;
 36 import sun.security.action.GetPropertyAction;
 37 
 38 /**
 39  * Unix implementation of AsynchronousSocketChannel
 40  */
 41 
 42 class UnixAsynchronousSocketChannelImpl
 43     extends AsynchronousSocketChannelImpl implements Port.PollableChannel
 44 {
 45     private static final NativeDispatcher nd = new SocketDispatcher();
 46     private static enum OpType { CONNECT, READ, WRITE };
 47 
 48     private static final boolean disableSynchronousRead;
 49     static {
 50         String propValue = GetPropertyAction.privilegedGetProperty(
 51             &quot;sun.nio.ch.disableSynchronousRead&quot;, &quot;false&quot;);
 52         disableSynchronousRead = propValue.isEmpty() ?
 53             true : Boolean.parseBoolean(propValue);
</pre>
<hr />
<pre>
398                 // spurious wakeup, is this possible?
399                 synchronized (updateLock) {
400                     readPending = true;
401                 }
402                 return;
403             }
404 
405             // allow objects to be GC&#39;ed.
406             this.readBuffer = null;
407             this.readBuffers = null;
408             this.readAttachment = null;
409             this.readHandler = null;
410 
411             // allow another read to be initiated
412             enableReading();
413 
414         } catch (Throwable x) {
415             enableReading();
416             if (x instanceof ClosedChannelException)
417                 x = new AsynchronousCloseException();


418             exc = x;
419         } finally {
420             // restart poll in case of concurrent write
421             if (!(exc instanceof AsynchronousCloseException))
422                 lockAndUpdateEvents();
423             end();
424         }
425 
426         // cancel the associated timer
427         if (timeout != null)
428             timeout.cancel(false);
429 
430         // create result
431         Number result = (exc != null) ? null : (scattering) ?
432             (Number)Long.valueOf(n) : (Number)Integer.valueOf(n);
433 
434         // invoke handler or set result
435         if (handler == null) {
436             future.setResult(result, exc);
437         } else {
</pre>
<hr />
<pre>
529                         result = new PendingFuture&lt;V,A&gt;(this, OpType.READ);
530                         this.readFuture = (PendingFuture&lt;Number,Object&gt;)result;
531                         this.readAttachment = null;
532                     } else {
533                         this.readHandler = (CompletionHandler&lt;Number,Object&gt;)handler;
534                         this.readAttachment = attachment;
535                         this.readFuture = null;
536                     }
537                     if (timeout &gt; 0L) {
538                         this.readTimer = port.schedule(readTimeoutTask, timeout, unit);
539                     }
540                     this.readPending = true;
541                     updateEvents();
542                 }
543                 pending = true;
544                 return result;
545             }
546         } catch (Throwable x) {
547             if (x instanceof ClosedChannelException)
548                 x = new AsynchronousCloseException();


549             exc = x;
550         } finally {
551             if (!pending)
552                 enableReading();
553             end();
554         }
555 
556         Number result = (exc != null) ? null : (isScatteringRead) ?
557             (Number)Long.valueOf(n) : (Number)Integer.valueOf(n);
558 
559         // read completed immediately
560         if (handler != null) {
561             if (invokeDirect) {
562                 Invoker.invokeDirect(myGroupAndInvokeCount, handler, attachment, (V)result, exc);
563             } else {
564                 Invoker.invokeIndirectly(this, handler, attachment, (V)result, exc);
565             }
566             return null;
567         } else {
568             return CompletedFuture.withResult((V)result, exc);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.nio.channels.*;
 29 import java.nio.ByteBuffer;
 30 import java.net.*;
 31 import java.util.concurrent.*;
 32 import java.io.IOException;
 33 import java.io.FileDescriptor;
<span class="line-added"> 34 </span>
<span class="line-added"> 35 import sun.net.ConnectionResetException;</span>
 36 import sun.net.NetHooks;
 37 import sun.net.util.SocketExceptions;
 38 import sun.security.action.GetPropertyAction;
 39 
 40 /**
 41  * Unix implementation of AsynchronousSocketChannel
 42  */
 43 
 44 class UnixAsynchronousSocketChannelImpl
 45     extends AsynchronousSocketChannelImpl implements Port.PollableChannel
 46 {
 47     private static final NativeDispatcher nd = new SocketDispatcher();
 48     private static enum OpType { CONNECT, READ, WRITE };
 49 
 50     private static final boolean disableSynchronousRead;
 51     static {
 52         String propValue = GetPropertyAction.privilegedGetProperty(
 53             &quot;sun.nio.ch.disableSynchronousRead&quot;, &quot;false&quot;);
 54         disableSynchronousRead = propValue.isEmpty() ?
 55             true : Boolean.parseBoolean(propValue);
</pre>
<hr />
<pre>
400                 // spurious wakeup, is this possible?
401                 synchronized (updateLock) {
402                     readPending = true;
403                 }
404                 return;
405             }
406 
407             // allow objects to be GC&#39;ed.
408             this.readBuffer = null;
409             this.readBuffers = null;
410             this.readAttachment = null;
411             this.readHandler = null;
412 
413             // allow another read to be initiated
414             enableReading();
415 
416         } catch (Throwable x) {
417             enableReading();
418             if (x instanceof ClosedChannelException)
419                 x = new AsynchronousCloseException();
<span class="line-added">420             if (x instanceof ConnectionResetException)</span>
<span class="line-added">421                 x = new IOException(x.getMessage());</span>
422             exc = x;
423         } finally {
424             // restart poll in case of concurrent write
425             if (!(exc instanceof AsynchronousCloseException))
426                 lockAndUpdateEvents();
427             end();
428         }
429 
430         // cancel the associated timer
431         if (timeout != null)
432             timeout.cancel(false);
433 
434         // create result
435         Number result = (exc != null) ? null : (scattering) ?
436             (Number)Long.valueOf(n) : (Number)Integer.valueOf(n);
437 
438         // invoke handler or set result
439         if (handler == null) {
440             future.setResult(result, exc);
441         } else {
</pre>
<hr />
<pre>
533                         result = new PendingFuture&lt;V,A&gt;(this, OpType.READ);
534                         this.readFuture = (PendingFuture&lt;Number,Object&gt;)result;
535                         this.readAttachment = null;
536                     } else {
537                         this.readHandler = (CompletionHandler&lt;Number,Object&gt;)handler;
538                         this.readAttachment = attachment;
539                         this.readFuture = null;
540                     }
541                     if (timeout &gt; 0L) {
542                         this.readTimer = port.schedule(readTimeoutTask, timeout, unit);
543                     }
544                     this.readPending = true;
545                     updateEvents();
546                 }
547                 pending = true;
548                 return result;
549             }
550         } catch (Throwable x) {
551             if (x instanceof ClosedChannelException)
552                 x = new AsynchronousCloseException();
<span class="line-added">553             if (x instanceof ConnectionResetException)</span>
<span class="line-added">554                 x = new IOException(x.getMessage());</span>
555             exc = x;
556         } finally {
557             if (!pending)
558                 enableReading();
559             end();
560         }
561 
562         Number result = (exc != null) ? null : (isScatteringRead) ?
563             (Number)Long.valueOf(n) : (Number)Integer.valueOf(n);
564 
565         // read completed immediately
566         if (handler != null) {
567             if (invokeDirect) {
568                 Invoker.invokeDirect(myGroupAndInvokeCount, handler, attachment, (V)result, exc);
569             } else {
570                 Invoker.invokeIndirectly(this, handler, attachment, (V)result, exc);
571             }
572             return null;
573         } else {
574             return CompletedFuture.withResult((V)result, exc);
</pre>
</td>
</tr>
</table>
<center><a href="UnixAsynchronousServerSocketChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../fs/UnixCopyFile.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/unix/classes/sun/nio/fs/UnixFileStore.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.fs;
 27 
 28 import sun.nio.cs.UTF_8;
 29 
 30 import jdk.internal.util.StaticProperty;
 31 
 32 import java.nio.file.*;
 33 import java.nio.file.attribute.*;
 34 import java.nio.channels.*;
 35 import java.util.*;
 36 import java.io.IOException;
 37 import java.security.AccessController;
 38 import java.security.PrivilegedAction;
 39 
 40 /**
 41  * Base implementation of FileStore for Unix/like implementations.
 42  */
 43 
 44 abstract class UnixFileStore
 45     extends FileStore
 46 {
 47     // original path of file that identified file system
 48     private final UnixPath file;
 49 
 50     // device ID
 51     private final long dev;
 52 
 53     // entry in the mount tab
 54     private final UnixMountEntry entry;
 55 
 56     // return the device ID where the given file resides
 57     private static long devFor(UnixPath file) throws IOException {
 58         try {
 59             return UnixFileAttributes.get(file, true).dev();
 60         } catch (UnixException x) {
 61             x.rethrowAsIOException(file);
 62             return 0L;  // keep compiler happy
 63         }
 64     }
 65 
 66     UnixFileStore(UnixPath file) throws IOException {
 67         this.file = file;
 68         this.dev = devFor(file);
 69         this.entry = findMountEntry();
 70     }
 71 
 72     UnixFileStore(UnixFileSystem fs, UnixMountEntry entry) throws IOException {
 73         this.file = new UnixPath(fs, entry.dir());
 74         this.dev = (entry.dev() == 0L) ? devFor(this.file) : entry.dev();
 75         this.entry = entry;
 76     }
 77 
 78     /**
 79      * Find the mount entry for the file store
 80      */
 81     abstract UnixMountEntry findMountEntry() throws IOException;
 82 
 83     UnixPath file() {
 84         return file;
 85     }
 86 
 87     long dev() {
 88         return dev;
 89     }
 90 
 91     UnixMountEntry entry() {
 92         return entry;
 93     }
 94 
 95     @Override
 96     public String name() {
 97         return entry.name();
 98     }
 99 
100     @Override
101     public String type() {
102         return entry.fstype();
103     }
104 
105     @Override
106     public boolean isReadOnly() {
107         return entry.isReadOnly();
108     }
109 
110     // uses statvfs to read the file system information
111     private UnixFileStoreAttributes readAttributes() throws IOException {
112         try {
113             return UnixFileStoreAttributes.get(file);
114         } catch (UnixException x) {
115             x.rethrowAsIOException(file);
116             return null;    // keep compile happy
117         }
118     }
119 
120     @Override
121     public long getTotalSpace() throws IOException {
122         UnixFileStoreAttributes attrs = readAttributes();
123         try {
124             return Math.multiplyExact(attrs.blockSize(), attrs.totalBlocks());
125         } catch (ArithmeticException ignore) {
126             return Long.MAX_VALUE;
127         }
128     }
129 
130     @Override
131     public long getUsableSpace() throws IOException {
132         UnixFileStoreAttributes attrs = readAttributes();
133         try {
134             return Math.multiplyExact(attrs.blockSize(), attrs.availableBlocks());
135         } catch (ArithmeticException ignore) {
136             return Long.MAX_VALUE;
137         }
138     }
139 
140     @Override
141     public long getUnallocatedSpace() throws IOException {
142         UnixFileStoreAttributes attrs = readAttributes();
143         try {
144             return Math.multiplyExact(attrs.blockSize(), attrs.freeBlocks());
145         } catch (ArithmeticException ignore) {
146             return Long.MAX_VALUE;
147         }
148     }
149 
150     @Override
151     public long getBlockSize() throws IOException {
152        UnixFileStoreAttributes attrs = readAttributes();
153        return attrs.blockSize();
154     }
155 
156     @Override
157     public &lt;V extends FileStoreAttributeView&gt; V getFileStoreAttributeView(Class&lt;V&gt; view)
158     {
159         if (view == null)
160             throw new NullPointerException();
161         return (V) null;
162     }
163 
164     @Override
165     public Object getAttribute(String attribute) throws IOException {
166         if (attribute.equals(&quot;totalSpace&quot;))
167             return getTotalSpace();
168         if (attribute.equals(&quot;usableSpace&quot;))
169             return getUsableSpace();
170         if (attribute.equals(&quot;unallocatedSpace&quot;))
171             return getUnallocatedSpace();
172         throw new UnsupportedOperationException(&quot;&#39;&quot; + attribute + &quot;&#39; not recognized&quot;);
173     }
174 
175     @Override
176     public boolean supportsFileAttributeView(Class&lt;? extends FileAttributeView&gt; type) {
177         if (type == null)
178             throw new NullPointerException();
179         if (type == BasicFileAttributeView.class)
180             return true;
181         if (type == PosixFileAttributeView.class ||
182             type == FileOwnerAttributeView.class)
183         {
184             // lookup fstypes.properties
185             FeatureStatus status = checkIfFeaturePresent(&quot;posix&quot;);
186             // assume supported if UNKNOWN
187             return (status != FeatureStatus.NOT_PRESENT);
188         }
189         return false;
190     }
191 
192     @Override
193     public boolean supportsFileAttributeView(String name) {
194         if (name.equals(&quot;basic&quot;) || name.equals(&quot;unix&quot;))
195             return true;
196         if (name.equals(&quot;posix&quot;))
197             return supportsFileAttributeView(PosixFileAttributeView.class);
198         if (name.equals(&quot;owner&quot;))
199             return supportsFileAttributeView(FileOwnerAttributeView.class);
200         return false;
201     }
202 
203     @Override
204     public boolean equals(Object ob) {
205         if (ob == this)
206             return true;
207         if (!(ob instanceof UnixFileStore))
208             return false;
209         UnixFileStore other = (UnixFileStore)ob;
210         return (this.dev == other.dev) &amp;&amp;
211                Arrays.equals(this.entry.dir(), other.entry.dir()) &amp;&amp;
212                this.entry.name().equals(other.entry.name());
213     }
214 
215     @Override
216     public int hashCode() {
217         return (int)(dev ^ (dev &gt;&gt;&gt; 32)) ^ Arrays.hashCode(entry.dir());
218     }
219 
220     @Override
221     public String toString() {
222         StringBuilder sb = new StringBuilder(Util.toString(entry.dir()));
223         sb.append(&quot; (&quot;);
224         sb.append(entry.name());
225         sb.append(&quot;)&quot;);
226         return sb.toString();
227     }
228 
229     // -- fstypes.properties --
230 
231     private static final Object loadLock = new Object();
232     private static volatile Properties props;
233 
234     enum FeatureStatus {
235         PRESENT,
236         NOT_PRESENT,
237         UNKNOWN;
238     }
239 
240     /**
241      * Returns status to indicate if file system supports a given feature
242      */
243     FeatureStatus checkIfFeaturePresent(String feature) {
244         if (props == null) {
245             synchronized (loadLock) {
246                 if (props == null) {
247                     props = AccessController.doPrivileged(
248                         new PrivilegedAction&lt;&gt;() {
249                             @Override
250                             public Properties run() {
251                                 return loadProperties();
252                             }});
253                 }
254             }
255         }
256 
257         String value = props.getProperty(type());
258         if (value != null) {
259             String[] values = value.split(&quot;\\s&quot;);
260             for (String s: values) {
261                 s = s.trim().toLowerCase();
262                 if (s.equals(feature)) {
263                     return FeatureStatus.PRESENT;
264                 }
265                 if (s.startsWith(&quot;no&quot;)) {
266                     s = s.substring(2);
267                     if (s.equals(feature)) {
268                         return FeatureStatus.NOT_PRESENT;
269                     }
270                 }
271             }
272         }
273         return FeatureStatus.UNKNOWN;
274     }
275 
276     private static Properties loadProperties() {
277         Properties result = new Properties();
278         String fstypes = StaticProperty.javaHome() + &quot;/lib/fstypes.properties&quot;;
279         Path file = Path.of(fstypes);
280         try {
281             try (ReadableByteChannel rbc = Files.newByteChannel(file)) {
282                 result.load(Channels.newReader(rbc, UTF_8.INSTANCE));
283             }
284         } catch (IOException x) {
285         }
286         return result;
287     }
288 }
    </pre>
  </body>
</html>
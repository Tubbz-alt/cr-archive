<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/classes/sun/nio/fs/UnixNativeDispatcher.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnixFileStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../native/libjava/ProcessImpl_md.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/classes/sun/nio/fs/UnixNativeDispatcher.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.fs;
 27 
<span class="line-removed"> 28 import java.security.AccessController;</span>
<span class="line-removed"> 29 import java.security.PrivilegedAction;</span>
<span class="line-removed"> 30 </span>
 31 /**
 32  * Unix system and library calls.
 33  */
 34 
 35 class UnixNativeDispatcher {
 36     protected UnixNativeDispatcher() { }
 37 
 38     // returns a NativeBuffer containing the given path
<span class="line-modified"> 39     private static NativeBuffer copyToNativeBuffer(UnixPath path) {</span>
 40         byte[] cstr = path.getByteArrayForSysCalls();
 41         int size = cstr.length + 1;
 42         NativeBuffer buffer = NativeBuffers.getNativeBufferFromCache(size);
 43         if (buffer == null) {
 44             buffer = NativeBuffers.allocNativeBuffer(size);
 45         } else {
 46             // buffer already contains the path
 47             if (buffer.owner() == path)
 48                 return buffer;
 49         }
 50         NativeBuffers.copyCStringToNativeBuffer(cstr, buffer);
 51         buffer.setOwner(path);
 52         return buffer;
 53     }
 54 
 55     /**
 56      * char *getcwd(char *buf, size_t size);
 57      */
 58     static native byte[] getcwd();
 59 
</pre>
<hr />
<pre>
104      * FILE* fopen(const char *filename, const char* mode);
105      */
106     static long fopen(UnixPath filename, String mode) throws UnixException {
107         NativeBuffer pathBuffer = copyToNativeBuffer(filename);
108         NativeBuffer modeBuffer = NativeBuffers.asNativeBuffer(Util.toBytes(mode));
109         try {
110             return fopen0(pathBuffer.address(), modeBuffer.address());
111         } finally {
112             modeBuffer.release();
113             pathBuffer.release();
114         }
115     }
116     private static native long fopen0(long pathAddress, long modeAddress)
117         throws UnixException;
118 
119     /**
120      * fclose(FILE* stream)
121      */
122     static native void fclose(long stream) throws UnixException;
123 










124     /**
125      * link(const char* existing, const char* new)
126      */
127     static void link(UnixPath existing, UnixPath newfile) throws UnixException {
128         NativeBuffer existingBuffer = copyToNativeBuffer(existing);
129         NativeBuffer newBuffer = copyToNativeBuffer(newfile);
130         try {
131             link0(existingBuffer.address(), newBuffer.address());
132         } finally {
133             newBuffer.release();
134             existingBuffer.release();
135         }
136     }
137     private static native void link0(long existingAddress, long newAddress)
138         throws UnixException;
139 
140     /**
141      * unlink(const char* path)
142      */
143     static void unlink(UnixPath path) throws UnixException {
</pre>
<hr />
<pre>
384     /**
385      * chmod(const char* path, mode_t mode)
386      */
387     static void chmod(UnixPath path, int mode) throws UnixException {
388         NativeBuffer buffer = copyToNativeBuffer(path);
389         try {
390             chmod0(buffer.address(), mode);
391         } finally {
392             buffer.release();
393         }
394     }
395     private static native void chmod0(long pathAddress, int mode)
396         throws UnixException;
397 
398     /**
399      * fchmod(int fildes, mode_t mode)
400      */
401     static native void fchmod(int fd, int mode) throws UnixException;
402 
403     /**
<span class="line-modified">404      * utimes(conar char* path, const struct timeval times[2])</span>
405      */
406     static void utimes(UnixPath path, long times0, long times1)
407         throws UnixException
408     {
409         NativeBuffer buffer = copyToNativeBuffer(path);
410         try {
411             utimes0(buffer.address(), times0, times1);
412         } finally {
413             buffer.release();
414         }
415     }
416     private static native void utimes0(long pathAddress, long times0, long times1)
417         throws UnixException;
418 
419     /**
<span class="line-modified">420      * futimes(int fildes,, const struct timeval times[2])</span>
421      */
422     static native void futimes(int fd, long times0, long times1) throws UnixException;
423 





















424     /**
425      * DIR *opendir(const char* dirname)
426      */
427     static long opendir(UnixPath path) throws UnixException {
428         NativeBuffer buffer = copyToNativeBuffer(path);
429         try {
430             return opendir0(buffer.address());
431         } finally {
432             buffer.release();
433         }
434     }
435     private static native long opendir0(long pathAddress) throws UnixException;
436 
437     /**
438      * DIR* fdopendir(int filedes)
439      */
440     static native long fdopendir(int dfd) throws UnixException;
441 
442 
443     /**
</pre>
<hr />
<pre>
561         } finally {
562             buffer.release();
563         }
564     }
565     private static native long pathconf0(long pathAddress, int name)
566         throws UnixException;
567 
568     /**
569      * long fpathconf(int fildes, int name);
570      */
571     static native long fpathconf(int filedes, int name) throws UnixException;
572 
573     /**
574      * char* strerror(int errnum)
575      */
576     static native byte[] strerror(int errnum);
577 
578     /**
579      * Capabilities
580      */
<span class="line-modified">581     private static final int SUPPORTS_OPENAT        = 1 &lt;&lt; 1;    // syscalls</span>
582     private static final int SUPPORTS_FUTIMES       = 1 &lt;&lt; 2;
<span class="line-modified">583     private static final int SUPPORTS_BIRTHTIME     = 1 &lt;&lt; 16;   // other features</span>


584     private static final int capabilities;
585 
586     /**
587      * Supports openat and other *at calls.
588      */
589     static boolean openatSupported() {
590         return (capabilities &amp; SUPPORTS_OPENAT) != 0;
591     }
592 
593     /**
594      * Supports futimes or futimesat
595      */
596     static boolean futimesSupported() {
597         return (capabilities &amp; SUPPORTS_FUTIMES) != 0;
598     }
599 














600     /**
601      * Supports file birth (creation) time attribute
602      */
603     static boolean birthtimeSupported() {
604         return (capabilities &amp; SUPPORTS_BIRTHTIME) != 0;
605     }
606 
607     private static native int init();
608     static {
<span class="line-modified">609         AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed">610             public Void run() {</span>
<span class="line-removed">611                 System.loadLibrary(&quot;nio&quot;);</span>
<span class="line-removed">612                 return null;</span>
<span class="line-removed">613         }});</span>
614         capabilities = init();
615     }
616 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.fs;
 27 



 28 /**
 29  * Unix system and library calls.
 30  */
 31 
 32 class UnixNativeDispatcher {
 33     protected UnixNativeDispatcher() { }
 34 
 35     // returns a NativeBuffer containing the given path
<span class="line-modified"> 36     static NativeBuffer copyToNativeBuffer(UnixPath path) {</span>
 37         byte[] cstr = path.getByteArrayForSysCalls();
 38         int size = cstr.length + 1;
 39         NativeBuffer buffer = NativeBuffers.getNativeBufferFromCache(size);
 40         if (buffer == null) {
 41             buffer = NativeBuffers.allocNativeBuffer(size);
 42         } else {
 43             // buffer already contains the path
 44             if (buffer.owner() == path)
 45                 return buffer;
 46         }
 47         NativeBuffers.copyCStringToNativeBuffer(cstr, buffer);
 48         buffer.setOwner(path);
 49         return buffer;
 50     }
 51 
 52     /**
 53      * char *getcwd(char *buf, size_t size);
 54      */
 55     static native byte[] getcwd();
 56 
</pre>
<hr />
<pre>
101      * FILE* fopen(const char *filename, const char* mode);
102      */
103     static long fopen(UnixPath filename, String mode) throws UnixException {
104         NativeBuffer pathBuffer = copyToNativeBuffer(filename);
105         NativeBuffer modeBuffer = NativeBuffers.asNativeBuffer(Util.toBytes(mode));
106         try {
107             return fopen0(pathBuffer.address(), modeBuffer.address());
108         } finally {
109             modeBuffer.release();
110             pathBuffer.release();
111         }
112     }
113     private static native long fopen0(long pathAddress, long modeAddress)
114         throws UnixException;
115 
116     /**
117      * fclose(FILE* stream)
118      */
119     static native void fclose(long stream) throws UnixException;
120 
<span class="line-added">121     /**</span>
<span class="line-added">122      * void rewind(FILE* stream);</span>
<span class="line-added">123      */</span>
<span class="line-added">124     static native void rewind(long stream) throws UnixException;</span>
<span class="line-added">125 </span>
<span class="line-added">126     /**</span>
<span class="line-added">127      * ssize_t getline(char **lineptr, size_t *n, FILE *stream);</span>
<span class="line-added">128      */</span>
<span class="line-added">129     static native int getlinelen(long stream) throws UnixException;</span>
<span class="line-added">130 </span>
131     /**
132      * link(const char* existing, const char* new)
133      */
134     static void link(UnixPath existing, UnixPath newfile) throws UnixException {
135         NativeBuffer existingBuffer = copyToNativeBuffer(existing);
136         NativeBuffer newBuffer = copyToNativeBuffer(newfile);
137         try {
138             link0(existingBuffer.address(), newBuffer.address());
139         } finally {
140             newBuffer.release();
141             existingBuffer.release();
142         }
143     }
144     private static native void link0(long existingAddress, long newAddress)
145         throws UnixException;
146 
147     /**
148      * unlink(const char* path)
149      */
150     static void unlink(UnixPath path) throws UnixException {
</pre>
<hr />
<pre>
391     /**
392      * chmod(const char* path, mode_t mode)
393      */
394     static void chmod(UnixPath path, int mode) throws UnixException {
395         NativeBuffer buffer = copyToNativeBuffer(path);
396         try {
397             chmod0(buffer.address(), mode);
398         } finally {
399             buffer.release();
400         }
401     }
402     private static native void chmod0(long pathAddress, int mode)
403         throws UnixException;
404 
405     /**
406      * fchmod(int fildes, mode_t mode)
407      */
408     static native void fchmod(int fd, int mode) throws UnixException;
409 
410     /**
<span class="line-modified">411      * utimes(const char* path, const struct timeval times[2])</span>
412      */
413     static void utimes(UnixPath path, long times0, long times1)
414         throws UnixException
415     {
416         NativeBuffer buffer = copyToNativeBuffer(path);
417         try {
418             utimes0(buffer.address(), times0, times1);
419         } finally {
420             buffer.release();
421         }
422     }
423     private static native void utimes0(long pathAddress, long times0, long times1)
424         throws UnixException;
425 
426     /**
<span class="line-modified">427      * futimes(int fildes, const struct timeval times[2])</span>
428      */
429     static native void futimes(int fd, long times0, long times1) throws UnixException;
430 
<span class="line-added">431     /**</span>
<span class="line-added">432      * futimens(int fildes, const struct timespec times[2])</span>
<span class="line-added">433      */</span>
<span class="line-added">434     static native void futimens(int fd, long times0, long times1) throws UnixException;</span>
<span class="line-added">435 </span>
<span class="line-added">436     /**</span>
<span class="line-added">437      * lutimes(const char* path, const struct timeval times[2])</span>
<span class="line-added">438      */</span>
<span class="line-added">439     static void lutimes(UnixPath path, long times0, long times1)</span>
<span class="line-added">440         throws UnixException</span>
<span class="line-added">441     {</span>
<span class="line-added">442         NativeBuffer buffer = copyToNativeBuffer(path);</span>
<span class="line-added">443         try {</span>
<span class="line-added">444             lutimes0(buffer.address(), times0, times1);</span>
<span class="line-added">445         } finally {</span>
<span class="line-added">446             buffer.release();</span>
<span class="line-added">447         }</span>
<span class="line-added">448     }</span>
<span class="line-added">449     private static native void lutimes0(long pathAddress, long times0, long times1)</span>
<span class="line-added">450         throws UnixException;</span>
<span class="line-added">451 </span>
452     /**
453      * DIR *opendir(const char* dirname)
454      */
455     static long opendir(UnixPath path) throws UnixException {
456         NativeBuffer buffer = copyToNativeBuffer(path);
457         try {
458             return opendir0(buffer.address());
459         } finally {
460             buffer.release();
461         }
462     }
463     private static native long opendir0(long pathAddress) throws UnixException;
464 
465     /**
466      * DIR* fdopendir(int filedes)
467      */
468     static native long fdopendir(int dfd) throws UnixException;
469 
470 
471     /**
</pre>
<hr />
<pre>
589         } finally {
590             buffer.release();
591         }
592     }
593     private static native long pathconf0(long pathAddress, int name)
594         throws UnixException;
595 
596     /**
597      * long fpathconf(int fildes, int name);
598      */
599     static native long fpathconf(int filedes, int name) throws UnixException;
600 
601     /**
602      * char* strerror(int errnum)
603      */
604     static native byte[] strerror(int errnum);
605 
606     /**
607      * Capabilities
608      */
<span class="line-modified">609     private static final int SUPPORTS_OPENAT        = 1 &lt;&lt; 1;  // syscalls</span>
610     private static final int SUPPORTS_FUTIMES       = 1 &lt;&lt; 2;
<span class="line-modified">611     private static final int SUPPORTS_FUTIMENS      = 1 &lt;&lt; 4;</span>
<span class="line-added">612     private static final int SUPPORTS_LUTIMES       = 1 &lt;&lt; 8;</span>
<span class="line-added">613     private static final int SUPPORTS_BIRTHTIME     = 1 &lt;&lt; 16; // other features</span>
614     private static final int capabilities;
615 
616     /**
617      * Supports openat and other *at calls.
618      */
619     static boolean openatSupported() {
620         return (capabilities &amp; SUPPORTS_OPENAT) != 0;
621     }
622 
623     /**
624      * Supports futimes or futimesat
625      */
626     static boolean futimesSupported() {
627         return (capabilities &amp; SUPPORTS_FUTIMES) != 0;
628     }
629 
<span class="line-added">630     /**</span>
<span class="line-added">631      * Supports futimens</span>
<span class="line-added">632      */</span>
<span class="line-added">633     static boolean futimensSupported() {</span>
<span class="line-added">634         return (capabilities &amp; SUPPORTS_FUTIMENS) != 0;</span>
<span class="line-added">635     }</span>
<span class="line-added">636 </span>
<span class="line-added">637     /**</span>
<span class="line-added">638      * Supports lutimes</span>
<span class="line-added">639      */</span>
<span class="line-added">640     static boolean lutimesSupported() {</span>
<span class="line-added">641         return (capabilities &amp; SUPPORTS_LUTIMES) != 0;</span>
<span class="line-added">642     }</span>
<span class="line-added">643 </span>
644     /**
645      * Supports file birth (creation) time attribute
646      */
647     static boolean birthtimeSupported() {
648         return (capabilities &amp; SUPPORTS_BIRTHTIME) != 0;
649     }
650 
651     private static native int init();
652     static {
<span class="line-modified">653         jdk.internal.loader.BootLoader.loadLibrary(&quot;nio&quot;);</span>




654         capabilities = init();
655     }
656 }
</pre>
</td>
</tr>
</table>
<center><a href="UnixFileStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../native/libjava/ProcessImpl_md.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
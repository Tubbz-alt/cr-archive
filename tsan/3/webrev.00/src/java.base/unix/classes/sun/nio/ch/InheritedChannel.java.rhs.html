<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/unix/classes/sun/nio/ch/InheritedChannel.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.nio.ch;
 27 
 28 import java.lang.reflect.Constructor;
 29 import java.io.FileDescriptor;
 30 import java.io.IOException;
 31 import java.net.InetAddress;
 32 import java.net.InetSocketAddress;
 33 import java.nio.channels.Channel;
 34 import java.nio.channels.SocketChannel;
 35 import java.nio.channels.ServerSocketChannel;
 36 import java.nio.channels.DatagramChannel;
 37 import java.nio.channels.spi.SelectorProvider;
 38 
 39 class InheritedChannel {
 40 
 41     // the &quot;types&quot; of socket returned by soType0
 42     private static final int UNKNOWN            = -1;
 43     private static final int SOCK_STREAM        = 1;
 44     private static final int SOCK_DGRAM         = 2;
 45 
<a name="2" id="anc2"></a><span class="line-added"> 46     // socket address type</span>
<span class="line-added"> 47     private static final int AF_UNKNOWN         = -1;</span>
<span class="line-added"> 48     private static final int AF_INET            = 1;</span>
<span class="line-added"> 49     private static final int AF_INET6           = 2;</span>
<span class="line-added"> 50     private static final int AF_UNIX            = 3;</span>
<span class="line-added"> 51 </span>
 52     // oflag values when opening a file
 53     private static final int O_RDONLY           = 0;
 54     private static final int O_WRONLY           = 1;
 55     private static final int O_RDWR             = 2;
 56 
 57     /*
 58      * In order to &quot;detach&quot; the standard streams we dup them to /dev/null.
 59      * In order to reduce the possibility of an error at close time we
 60      * open /dev/null early - that way we know we won&#39;t run out of file
 61      * descriptors at close time. This makes the close operation a
 62      * simple dup2 operation for each of the standard streams.
 63      */
 64     private static int devnull = -1;
 65 
 66     private static void detachIOStreams() {
 67         try {
 68             dup2(devnull, 0);
 69             dup2(devnull, 1);
 70             dup2(devnull, 2);
 71         } catch (IOException ioe) {
 72             // this shouldn&#39;t happen
 73             throw new InternalError(ioe);
 74         }
 75     }
 76 
 77     /*
 78      * Override the implCloseSelectableChannel for each channel type - this
 79      * allows us to &quot;detach&quot; the standard streams after closing and ensures
 80      * that the underlying socket really closes.
 81      */
 82     public static class InheritedSocketChannelImpl extends SocketChannelImpl {
 83 
 84         InheritedSocketChannelImpl(SelectorProvider sp,
 85                                    FileDescriptor fd,
 86                                    InetSocketAddress remote)
 87             throws IOException
 88         {
 89             super(sp, fd, remote);
 90         }
 91 
 92         protected void implCloseSelectableChannel() throws IOException {
 93             super.implCloseSelectableChannel();
 94             detachIOStreams();
 95         }
 96     }
 97 
<a name="3" id="anc3"></a><span class="line-added"> 98     public static class InheritedUnixChannelImpl extends UnixDomainSocketChannelImpl {</span>
<span class="line-added"> 99 </span>
<span class="line-added">100         InheritedUnixChannelImpl(FileDescriptor fd)</span>
<span class="line-added">101             throws IOException</span>
<span class="line-added">102         {</span>
<span class="line-added">103             super(fd);</span>
<span class="line-added">104         }</span>
<span class="line-added">105 </span>
<span class="line-added">106         protected void implCloseSelectableChannel() throws IOException {</span>
<span class="line-added">107             super.implCloseChannel();</span>
<span class="line-added">108             detachIOStreams();</span>
<span class="line-added">109         }</span>
<span class="line-added">110     }</span>
<span class="line-added">111 </span>
112     public static class InheritedServerSocketChannelImpl extends
113         ServerSocketChannelImpl {
114 
115         InheritedServerSocketChannelImpl(SelectorProvider sp,
116                                          FileDescriptor fd)
117             throws IOException
118         {
119             super(sp, fd, true);
120         }
121 
122         protected void implCloseSelectableChannel() throws IOException {
123             super.implCloseSelectableChannel();
124             detachIOStreams();
125         }
126 
127     }
128 
129     public static class InheritedDatagramChannelImpl extends
130         DatagramChannelImpl {
131 
132         InheritedDatagramChannelImpl(SelectorProvider sp,
133                                      FileDescriptor fd)
134             throws IOException
135         {
136             super(sp, fd);
137         }
138 
139         protected void implCloseSelectableChannel() throws IOException {
140             super.implCloseSelectableChannel();
141             detachIOStreams();
142         }
143     }
144 
145     /*
146      * If there&#39;s a SecurityManager then check for the appropriate
147      * RuntimePermission.
148      */
149     private static void checkAccess(Channel c) {
150         SecurityManager sm = System.getSecurityManager();
151         if (sm != null) {
152             sm.checkPermission(
153                 new RuntimePermission(&quot;inheritedChannel&quot;)
154             );
155         }
156     }
157 
158 
159     /*
160      * If standard inherited channel is connected to a socket then return a Channel
161      * of the appropriate type based standard input.
162      */
163     private static Channel createChannel() throws IOException {
164 
165         // dup the file descriptor - we do this so that for two reasons :-
166         // 1. Avoids any timing issues with FileDescriptor.in being closed
167         //    or redirected while we create the channel.
168         // 2. Allows streams based on file descriptor 0 to co-exist with
169         //    the channel (closing one doesn&#39;t impact the other)
170 
171         int fdVal = dup(0);
172 
173         // Examine the file descriptor - if it&#39;s not a socket then we don&#39;t
174         // create a channel so we release the file descriptor.
175 
176         int st;
177         st = soType0(fdVal);
178         if (st != SOCK_STREAM &amp;&amp; st != SOCK_DGRAM) {
179             close0(fdVal);
180             return null;
181         }
182 
<a name="4" id="anc4"></a>
183         // Next we create a FileDescriptor for the dup&#39;ed file descriptor
184         // Have to use reflection and also make assumption on how FD
185         // is implemented.
186 
187         Class&lt;?&gt; paramTypes[] = { int.class };
188         Constructor&lt;?&gt; ctr = Reflect.lookupConstructor(&quot;java.io.FileDescriptor&quot;,
189                                                        paramTypes);
190         Object args[] = { Integer.valueOf(fdVal) };
191         FileDescriptor fd = (FileDescriptor)Reflect.invoke(ctr, args);
192 
193 
194         // Now create the channel. If the socket is a streams socket then
195         // we see if tthere is a peer (ie: connected). If so, then we
196         // create a SocketChannel, otherwise a ServerSocketChannel.
197         // If the socket is a datagram socket then create a DatagramChannel
198 
199         SelectorProvider provider = SelectorProvider.provider();
200         assert provider instanceof sun.nio.ch.SelectorProviderImpl;
201 
202         Channel c;
203         if (st == SOCK_STREAM) {
<a name="5" id="anc5"></a><span class="line-added">204             int family = addressFamily(fdVal);</span>
<span class="line-added">205             if (family == AF_UNKNOWN)</span>
<span class="line-added">206                 return null;</span>
<span class="line-added">207             if (family == AF_UNIX) {</span>
<span class="line-added">208                 if (isConnected(fdVal)) {</span>
<span class="line-added">209                     return new InheritedUnixChannelImpl(fd);</span>
<span class="line-added">210                 } else {</span>
<span class="line-added">211                     // listener. unsupported.</span>
<span class="line-added">212                     return null;</span>
<span class="line-added">213                 }</span>
<span class="line-added">214             }</span>
215             InetAddress ia = peerAddress0(fdVal);
216             if (ia == null) {
217                c = new InheritedServerSocketChannelImpl(provider, fd);
218             } else {
219                int port = peerPort0(fdVal);
220                assert port &gt; 0;
221                InetSocketAddress isa = new InetSocketAddress(ia, port);
222                c = new InheritedSocketChannelImpl(provider, fd, isa);
223             }
224         } else {
225             c = new InheritedDatagramChannelImpl(provider, fd);
226         }
227         return c;
228     }
229 
230     private static boolean haveChannel = false;
231     private static Channel channel = null;
232 
233     /*
234      * Returns a Channel representing the inherited channel if the
235      * inherited channel is a stream connected to a network socket.
236      */
237     public static synchronized Channel getChannel() throws IOException {
238         if (devnull &lt; 0) {
239             devnull = open0(&quot;/dev/null&quot;, O_RDWR);
240         }
241 
242         // If we don&#39;t have the channel try to create it
243         if (!haveChannel) {
244             channel = createChannel();
245             haveChannel = true;
246         }
247 
248         // if there is a channel then do the security check before
249         // returning it.
250         if (channel != null) {
251             checkAccess(channel);
252         }
253         return channel;
254     }
255 
256 
257     // -- Native methods --
258 
259     private static native void initIDs();
260     private static native int dup(int fd) throws IOException;
261     private static native void dup2(int fd, int fd2) throws IOException;
262     private static native int open0(String path, int oflag) throws IOException;
263     private static native void close0(int fd) throws IOException;
264     private static native int soType0(int fd);
<a name="6" id="anc6"></a><span class="line-added">265     private static native int addressFamily(int fd);</span>
266     private static native InetAddress peerAddress0(int fd);
267     private static native int peerPort0(int fd);
268 
<a name="7" id="anc7"></a><span class="line-added">269     // return true if socket is connected to a peer</span>
<span class="line-added">270     private static native boolean isConnected(int fd);</span>
<span class="line-added">271 </span>
272     static {
273         IOUtil.load();
274         initIDs();
275     }
276 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
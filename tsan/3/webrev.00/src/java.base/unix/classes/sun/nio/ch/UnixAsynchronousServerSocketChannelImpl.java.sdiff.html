<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/classes/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SourceChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="UnixAsynchronousSocketChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/classes/sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
124         return port;
125     }
126 
127     /**
128      * Invoked by event handling thread when listener socket is polled
129      */
130     @Override
131     public void onEvent(int events, boolean mayInvokeDirect) {
132         synchronized (updateLock) {
133             if (!acceptPending)
134                 return;  // may have been grabbed by asynchronous close
135             acceptPending = false;
136         }
137 
138         // attempt to accept connection
139         FileDescriptor newfd = new FileDescriptor();
140         InetSocketAddress[] isaa = new InetSocketAddress[1];
141         Throwable exc = null;
142         try {
143             begin();
<span class="line-modified">144             int n = accept(this.fd, newfd, isaa);</span>
145 
146             // spurious wakeup, is this possible?
147             if (n == IOStatus.UNAVAILABLE) {
148                 synchronized (updateLock) {
149                     acceptPending = true;
150                 }
151                 port.startPoll(fdVal, Net.POLLIN);
152                 return;
153             }
154 
155         } catch (Throwable x) {
156             if (x instanceof ClosedChannelException)
157                 x = new AsynchronousCloseException();
158             exc = x;
159         } finally {
160             end();
161         }
162 
163         // Connection accepted so finish it when not holding locks.
164         AsynchronousSocketChannel child = null;
</pre>
<hr />
<pre>
204                                                    final InetSocketAddress remote,
205                                                    AccessControlContext acc)
206         throws IOException, SecurityException
207     {
208         AsynchronousSocketChannel ch = null;
209         try {
210             ch = new UnixAsynchronousSocketChannelImpl(port, newfd, remote);
211         } catch (IOException x) {
212             nd.close(newfd);
213             throw x;
214         }
215 
216         // permission check must always be in initiator&#39;s context
217         try {
218             if (acc != null) {
219                 AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
220                     public Void run() {
221                         SecurityManager sm = System.getSecurityManager();
222                         if (sm != null) {
223                             sm.checkAccept(remote.getAddress().getHostAddress(),
<span class="line-modified">224                                            remote.getPort());</span>
225                         }
226                         return null;
227                     }
228                 }, acc);
229             } else {
230                 SecurityManager sm = System.getSecurityManager();
231                 if (sm != null) {
232                     sm.checkAccept(remote.getAddress().getHostAddress(),
<span class="line-modified">233                                    remote.getPort());</span>
234                 }
235             }
236         } catch (SecurityException x) {
237             try {
238                 ch.close();
239             } catch (Throwable suppressed) {
240                 x.addSuppressed(suppressed);
241             }
242             throw x;
243         }
244         return ch;
245     }
246 
247     @Override
248     Future&lt;AsynchronousSocketChannel&gt; implAccept(Object att,
249         CompletionHandler&lt;AsynchronousSocketChannel,Object&gt; handler)
250     {
251         // complete immediately if channel is closed
252         if (!isOpen()) {
253             Throwable e = new ClosedChannelException();
</pre>
<hr />
<pre>
260         }
261         if (localAddress == null)
262             throw new NotYetBoundException();
263 
264         // cancel was invoked with pending accept so connection may have been
265         // dropped.
266         if (isAcceptKilled())
267             throw new RuntimeException(&quot;Accept not allowed due cancellation&quot;);
268 
269         // check and set flag to prevent concurrent accepting
270         if (!accepting.compareAndSet(false, true))
271             throw new AcceptPendingException();
272 
273         // attempt accept
274         FileDescriptor newfd = new FileDescriptor();
275         InetSocketAddress[] isaa = new InetSocketAddress[1];
276         Throwable exc = null;
277         try {
278             begin();
279 
<span class="line-modified">280             int n = accept(this.fd, newfd, isaa);</span>
281             if (n == IOStatus.UNAVAILABLE) {
282 
283                 // need calling context when there is security manager as
284                 // permission check may be done in a different thread without
285                 // any application call frames on the stack
286                 PendingFuture&lt;AsynchronousSocketChannel,Object&gt; result = null;
287                 synchronized (updateLock) {
288                     if (handler == null) {
289                         this.acceptHandler = null;
290                         result = new PendingFuture&lt;&gt;(this);
291                         this.acceptFuture = result;
292                     } else {
293                         this.acceptHandler = handler;
294                         this.acceptAttachment = att;
295                     }
296                     this.acceptAcc = (System.getSecurityManager() == null) ?
<span class="line-modified">297                         null : AccessController.getContext();</span>
298                     this.acceptPending = true;
299                 }
300 
301                 // register for connections
302                 port.startPoll(fdVal, Net.POLLIN);
303                 return result;
304             }
305         } catch (Throwable x) {
306             // accept failed
307             if (x instanceof ClosedChannelException)
308                 x = new AsynchronousCloseException();
309             exc = x;
310         } finally {
311             end();
312         }
313 
314         AsynchronousSocketChannel child = null;
315         if (exc == null) {
316             // connection accepted immediately
317             try {
318                 child = finishAccept(newfd, isaa[0], null);
319             } catch (Throwable x) {
320                 exc = x;
321             }
322         }
323 
324         // re-enable accepting before invoking handler
325         enableAccept();
326 
327         if (handler == null) {
328             return CompletedFuture.withResult(child, exc);
329         } else {
330             Invoker.invokeIndirectly(this, handler, att, child, exc);
331             return null;
332         }
333     }
<span class="line-removed">334 </span>
<span class="line-removed">335     /**</span>
<span class="line-removed">336      * Accept a connection on a socket.</span>
<span class="line-removed">337      *</span>
<span class="line-removed">338      * @implNote Wrap native call to allow instrumentation.</span>
<span class="line-removed">339      */</span>
<span class="line-removed">340     private int accept(FileDescriptor ssfd, FileDescriptor newfd,</span>
<span class="line-removed">341                        InetSocketAddress[] isaa)</span>
<span class="line-removed">342         throws IOException</span>
<span class="line-removed">343     {</span>
<span class="line-removed">344         return accept0(ssfd, newfd, isaa);</span>
<span class="line-removed">345     }</span>
<span class="line-removed">346 </span>
<span class="line-removed">347     // -- Native methods --</span>
<span class="line-removed">348 </span>
<span class="line-removed">349     private static native void initIDs();</span>
<span class="line-removed">350 </span>
<span class="line-removed">351     // Accepts a new connection, setting the given file descriptor to refer to</span>
<span class="line-removed">352     // the new socket and setting isaa[0] to the socket&#39;s remote address.</span>
<span class="line-removed">353     // Returns 1 on success, or IOStatus.UNAVAILABLE.</span>
<span class="line-removed">354     //</span>
<span class="line-removed">355     private native int accept0(FileDescriptor ssfd, FileDescriptor newfd,</span>
<span class="line-removed">356                                InetSocketAddress[] isaa)</span>
<span class="line-removed">357         throws IOException;</span>
<span class="line-removed">358 </span>
<span class="line-removed">359     static {</span>
<span class="line-removed">360         IOUtil.load();</span>
<span class="line-removed">361         initIDs();</span>
<span class="line-removed">362     }</span>
363 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
124         return port;
125     }
126 
127     /**
128      * Invoked by event handling thread when listener socket is polled
129      */
130     @Override
131     public void onEvent(int events, boolean mayInvokeDirect) {
132         synchronized (updateLock) {
133             if (!acceptPending)
134                 return;  // may have been grabbed by asynchronous close
135             acceptPending = false;
136         }
137 
138         // attempt to accept connection
139         FileDescriptor newfd = new FileDescriptor();
140         InetSocketAddress[] isaa = new InetSocketAddress[1];
141         Throwable exc = null;
142         try {
143             begin();
<span class="line-modified">144             int n = Net.accept(this.fd, newfd, isaa);</span>
145 
146             // spurious wakeup, is this possible?
147             if (n == IOStatus.UNAVAILABLE) {
148                 synchronized (updateLock) {
149                     acceptPending = true;
150                 }
151                 port.startPoll(fdVal, Net.POLLIN);
152                 return;
153             }
154 
155         } catch (Throwable x) {
156             if (x instanceof ClosedChannelException)
157                 x = new AsynchronousCloseException();
158             exc = x;
159         } finally {
160             end();
161         }
162 
163         // Connection accepted so finish it when not holding locks.
164         AsynchronousSocketChannel child = null;
</pre>
<hr />
<pre>
204                                                    final InetSocketAddress remote,
205                                                    AccessControlContext acc)
206         throws IOException, SecurityException
207     {
208         AsynchronousSocketChannel ch = null;
209         try {
210             ch = new UnixAsynchronousSocketChannelImpl(port, newfd, remote);
211         } catch (IOException x) {
212             nd.close(newfd);
213             throw x;
214         }
215 
216         // permission check must always be in initiator&#39;s context
217         try {
218             if (acc != null) {
219                 AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
220                     public Void run() {
221                         SecurityManager sm = System.getSecurityManager();
222                         if (sm != null) {
223                             sm.checkAccept(remote.getAddress().getHostAddress(),
<span class="line-modified">224                                     remote.getPort());</span>
225                         }
226                         return null;
227                     }
228                 }, acc);
229             } else {
230                 SecurityManager sm = System.getSecurityManager();
231                 if (sm != null) {
232                     sm.checkAccept(remote.getAddress().getHostAddress(),
<span class="line-modified">233                             remote.getPort());</span>
234                 }
235             }
236         } catch (SecurityException x) {
237             try {
238                 ch.close();
239             } catch (Throwable suppressed) {
240                 x.addSuppressed(suppressed);
241             }
242             throw x;
243         }
244         return ch;
245     }
246 
247     @Override
248     Future&lt;AsynchronousSocketChannel&gt; implAccept(Object att,
249         CompletionHandler&lt;AsynchronousSocketChannel,Object&gt; handler)
250     {
251         // complete immediately if channel is closed
252         if (!isOpen()) {
253             Throwable e = new ClosedChannelException();
</pre>
<hr />
<pre>
260         }
261         if (localAddress == null)
262             throw new NotYetBoundException();
263 
264         // cancel was invoked with pending accept so connection may have been
265         // dropped.
266         if (isAcceptKilled())
267             throw new RuntimeException(&quot;Accept not allowed due cancellation&quot;);
268 
269         // check and set flag to prevent concurrent accepting
270         if (!accepting.compareAndSet(false, true))
271             throw new AcceptPendingException();
272 
273         // attempt accept
274         FileDescriptor newfd = new FileDescriptor();
275         InetSocketAddress[] isaa = new InetSocketAddress[1];
276         Throwable exc = null;
277         try {
278             begin();
279 
<span class="line-modified">280             int n = Net.accept(this.fd, newfd, isaa);</span>
281             if (n == IOStatus.UNAVAILABLE) {
282 
283                 // need calling context when there is security manager as
284                 // permission check may be done in a different thread without
285                 // any application call frames on the stack
286                 PendingFuture&lt;AsynchronousSocketChannel,Object&gt; result = null;
287                 synchronized (updateLock) {
288                     if (handler == null) {
289                         this.acceptHandler = null;
290                         result = new PendingFuture&lt;&gt;(this);
291                         this.acceptFuture = result;
292                     } else {
293                         this.acceptHandler = handler;
294                         this.acceptAttachment = att;
295                     }
296                     this.acceptAcc = (System.getSecurityManager() == null) ?
<span class="line-modified">297                             null : AccessController.getContext();</span>
298                     this.acceptPending = true;
299                 }
300 
301                 // register for connections
302                 port.startPoll(fdVal, Net.POLLIN);
303                 return result;
304             }
305         } catch (Throwable x) {
306             // accept failed
307             if (x instanceof ClosedChannelException)
308                 x = new AsynchronousCloseException();
309             exc = x;
310         } finally {
311             end();
312         }
313 
314         AsynchronousSocketChannel child = null;
315         if (exc == null) {
316             // connection accepted immediately
317             try {
318                 child = finishAccept(newfd, isaa[0], null);
319             } catch (Throwable x) {
320                 exc = x;
321             }
322         }
323 
324         // re-enable accepting before invoking handler
325         enableAccept();
326 
327         if (handler == null) {
328             return CompletedFuture.withResult(child, exc);
329         } else {
330             Invoker.invokeIndirectly(this, handler, att, child, exc);
331             return null;
332         }
333     }





























334 }
</pre>
</td>
</tr>
</table>
<center><a href="SourceChannelImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="UnixAsynchronousSocketChannelImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
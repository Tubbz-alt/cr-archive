<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/classes/java/io/UnixFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../solaris/native/libnet/solaris_close.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../lang/ClassLoaderHelper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/classes/java/io/UnixFileSystem.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 class UnixFileSystem extends FileSystem {
 35 
 36     private final char slash;
 37     private final char colon;
 38     private final String javaHome;
 39     private final String userDir;
 40 
 41     public UnixFileSystem() {
 42         Properties props = GetPropertyAction.privilegedGetProperties();
 43         slash = props.getProperty(&quot;file.separator&quot;).charAt(0);
 44         colon = props.getProperty(&quot;path.separator&quot;).charAt(0);
 45         javaHome = StaticProperty.javaHome();
 46         userDir = StaticProperty.userDir();
 47         cache = useCanonCaches ? new ExpiringCache() : null;
 48         javaHomePrefixCache = useCanonPrefixCache ? new ExpiringCache() : null;
 49     }
 50 
 51 
 52     /* -- Normalization and construction -- */
 53 

 54     public char getSeparator() {
 55         return slash;
 56     }
 57 

 58     public char getPathSeparator() {
 59         return colon;
 60     }
 61 
 62     /* A normal Unix pathname contains no duplicate slashes and does not end
 63        with a slash.  It may be the empty string. */
 64 
 65     /* Normalize the given pathname, whose length is len, starting at the given
 66        offset; everything before this offset is already normal. */
 67     private String normalize(String pathname, int len, int off) {
 68         if (len == 0) return pathname;
 69         int n = len;
 70         while ((n &gt; 0) &amp;&amp; (pathname.charAt(n - 1) == &#39;/&#39;)) n--;
 71         if (n == 0) return &quot;/&quot;;
 72         StringBuilder sb = new StringBuilder(pathname.length());
 73         if (off &gt; 0) sb.append(pathname, 0, off);
 74         char prevChar = 0;
 75         for (int i = off; i &lt; n; i++) {
 76             char c = pathname.charAt(i);
 77             if ((prevChar == &#39;/&#39;) &amp;&amp; (c == &#39;/&#39;)) continue;
 78             sb.append(c);
 79             prevChar = c;
 80         }
 81         return sb.toString();
 82     }
 83 
 84     /* Check that the given pathname is normal.  If not, invoke the real
 85        normalizer on the part of the pathname that requires normalization.
 86        This way we iterate through the whole pathname string only once. */

 87     public String normalize(String pathname) {
 88         int n = pathname.length();
 89         char prevChar = 0;
 90         for (int i = 0; i &lt; n; i++) {
 91             char c = pathname.charAt(i);
 92             if ((prevChar == &#39;/&#39;) &amp;&amp; (c == &#39;/&#39;))
 93                 return normalize(pathname, n, i - 1);
 94             prevChar = c;
 95         }
 96         if (prevChar == &#39;/&#39;) return normalize(pathname, n, n - 1);
 97         return pathname;
 98     }
 99 

100     public int prefixLength(String pathname) {
101         if (pathname.isEmpty()) return 0;
102         return (pathname.charAt(0) == &#39;/&#39;) ? 1 : 0;
103     }
104 

105     public String resolve(String parent, String child) {
106         if (child.isEmpty()) return parent;
107         if (child.charAt(0) == &#39;/&#39;) {
108             if (parent.equals(&quot;/&quot;)) return child;
109             return parent + child;
110         }
111         if (parent.equals(&quot;/&quot;)) return parent + child;
112         return parent + &#39;/&#39; + child;
113     }
114 

115     public String getDefaultParent() {
116         return &quot;/&quot;;
117     }
118 

119     public String fromURIPath(String path) {
120         String p = path;
121         if (p.endsWith(&quot;/&quot;) &amp;&amp; (p.length() &gt; 1)) {
122             // &quot;/foo/&quot; --&gt; &quot;/foo&quot;, but &quot;/&quot; --&gt; &quot;/&quot;
123             p = p.substring(0, p.length() - 1);
124         }
125         return p;
126     }
127 
128 
129     /* -- Path operations -- */
130 

131     public boolean isAbsolute(File f) {
132         return (f.getPrefixLength() != 0);
133     }
134 

135     public String resolve(File f) {
136         if (isAbsolute(f)) return f.getPath();
137         SecurityManager sm = System.getSecurityManager();
138         if (sm != null) {
139             sm.checkPropertyAccess(&quot;user.dir&quot;);
140         }
141         return resolve(userDir, f.getPath());
142     }
143 
144     // Caches for canonicalization results to improve startup performance.
145     // The first cache handles repeated canonicalizations of the same path
146     // name. The prefix cache handles repeated canonicalizations within the
147     // same directory, and must not create results differing from the true
148     // canonicalization algorithm in canonicalize_md.c. For this reason the
149     // prefix cache is conservative and is not used for complex path names.
150     private final ExpiringCache cache;
151     // On Unix symlinks can jump anywhere in the file system, so we only
152     // treat prefixes in java.home as trusted and cacheable in the
153     // canonicalization algorithm
154     private final ExpiringCache javaHomePrefixCache;
155 

156     public String canonicalize(String path) throws IOException {
157         if (!useCanonCaches) {
158             return canonicalize0(path);
159         } else {
160             String res = cache.get(path);
161             if (res == null) {
162                 String dir = null;
163                 String resDir;
164                 if (useCanonPrefixCache) {
165                     // Note that this can cause symlinks that should
166                     // be resolved to a destination directory to be
167                     // resolved to the directory they&#39;re contained in
168                     dir = parentOrNull(path);
169                     if (dir != null) {
170                         resDir = javaHomePrefixCache.get(dir);
171                         if (resDir != null) {
172                             // Hit only in prefix cache; full path is canonical
173                             String filename = path.substring(1 + dir.length());
174                             res = resDir + slash + filename;
175                             cache.put(dir + slash + filename, res);
</pre>
<hr />
<pre>
229                     idx &gt;= last - 1 ||
230                     path.charAt(idx - 1) == sep) {
231                     // Punt on pathnames containing adjacent slashes
232                     // toward the end
233                     return null;
234                 }
235                 return path.substring(0, idx);
236             } else {
237                 ++nonDotCount;
238                 adjacentDots = 0;
239             }
240             --idx;
241         }
242         return null;
243     }
244 
245     /* -- Attribute accessors -- */
246 
247     public native int getBooleanAttributes0(File f);
248 

249     public int getBooleanAttributes(File f) {
250         int rv = getBooleanAttributes0(f);
251         String name = f.getName();
252         boolean hidden = !name.isEmpty() &amp;&amp; name.charAt(0) == &#39;.&#39;;
253         return rv | (hidden ? BA_HIDDEN : 0);
254     }
255 

256     public native boolean checkAccess(File f, int access);


257     public native long getLastModifiedTime(File f);


258     public native long getLength(File f);


259     public native boolean setPermission(File f, int access, boolean enable, boolean owneronly);
260 
261     /* -- File operations -- */
262 

263     public native boolean createFileExclusively(String path)
264         throws IOException;


265     public boolean delete(File f) {
266         // Keep canonicalization caches in sync after file deletion
267         // and renaming operations. Could be more clever than this
268         // (i.e., only remove/update affected entries) but probably
269         // not worth it since these entries expire after 30 seconds
270         // anyway.
271         if (useCanonCaches) {
272             cache.clear();
273         }
274         if (useCanonPrefixCache) {
275             javaHomePrefixCache.clear();
276         }
277         return delete0(f);
278     }
279     private native boolean delete0(File f);


280     public native String[] list(File f);


281     public native boolean createDirectory(File f);


282     public boolean rename(File f1, File f2) {
283         // Keep canonicalization caches in sync after file deletion
284         // and renaming operations. Could be more clever than this
285         // (i.e., only remove/update affected entries) but probably
286         // not worth it since these entries expire after 30 seconds
287         // anyway.
288         if (useCanonCaches) {
289             cache.clear();
290         }
291         if (useCanonPrefixCache) {
292             javaHomePrefixCache.clear();
293         }
294         return rename0(f1, f2);
295     }
296     private native boolean rename0(File f1, File f2);


297     public native boolean setLastModifiedTime(File f, long time);
<span class="line-removed">298     public native boolean setReadOnly(File f);</span>
299 


300 
301     /* -- Filesystem interface -- */
302 

303     public File[] listRoots() {
304         try {
305             SecurityManager security = System.getSecurityManager();
306             if (security != null) {
307                 security.checkRead(&quot;/&quot;);
308             }
309             return new File[] { new File(&quot;/&quot;) };
310         } catch (SecurityException x) {
311             return new File[0];
312         }
313     }
314 
315     /* -- Disk usage -- */


316     public native long getSpace(File f, int t);
317 
318     /* -- Basic infrastructure -- */
319 
320     private native long getNameMax0(String path);
321 

322     public int getNameMax(String path) {
323         long nameMax = getNameMax0(path);
324         if (nameMax &gt; Integer.MAX_VALUE) {
325             nameMax = Integer.MAX_VALUE;
326         }
327         return (int)nameMax;
328     }
329 

330     public int compare(File f1, File f2) {
331         return f1.getPath().compareTo(f2.getPath());
332     }
333 

334     public int hashCode(File f) {
335         return f.getPath().hashCode() ^ 1234321;
336     }
337 
338 
339     private static native void initIDs();
340 
341     static {
342         initIDs();
343     }
<span class="line-removed">344 </span>
345 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 class UnixFileSystem extends FileSystem {
 35 
 36     private final char slash;
 37     private final char colon;
 38     private final String javaHome;
 39     private final String userDir;
 40 
 41     public UnixFileSystem() {
 42         Properties props = GetPropertyAction.privilegedGetProperties();
 43         slash = props.getProperty(&quot;file.separator&quot;).charAt(0);
 44         colon = props.getProperty(&quot;path.separator&quot;).charAt(0);
 45         javaHome = StaticProperty.javaHome();
 46         userDir = StaticProperty.userDir();
 47         cache = useCanonCaches ? new ExpiringCache() : null;
 48         javaHomePrefixCache = useCanonPrefixCache ? new ExpiringCache() : null;
 49     }
 50 
 51 
 52     /* -- Normalization and construction -- */
 53 
<span class="line-added"> 54     @Override</span>
 55     public char getSeparator() {
 56         return slash;
 57     }
 58 
<span class="line-added"> 59     @Override</span>
 60     public char getPathSeparator() {
 61         return colon;
 62     }
 63 
 64     /* A normal Unix pathname contains no duplicate slashes and does not end
 65        with a slash.  It may be the empty string. */
 66 
 67     /* Normalize the given pathname, whose length is len, starting at the given
 68        offset; everything before this offset is already normal. */
 69     private String normalize(String pathname, int len, int off) {
 70         if (len == 0) return pathname;
 71         int n = len;
 72         while ((n &gt; 0) &amp;&amp; (pathname.charAt(n - 1) == &#39;/&#39;)) n--;
 73         if (n == 0) return &quot;/&quot;;
 74         StringBuilder sb = new StringBuilder(pathname.length());
 75         if (off &gt; 0) sb.append(pathname, 0, off);
 76         char prevChar = 0;
 77         for (int i = off; i &lt; n; i++) {
 78             char c = pathname.charAt(i);
 79             if ((prevChar == &#39;/&#39;) &amp;&amp; (c == &#39;/&#39;)) continue;
 80             sb.append(c);
 81             prevChar = c;
 82         }
 83         return sb.toString();
 84     }
 85 
 86     /* Check that the given pathname is normal.  If not, invoke the real
 87        normalizer on the part of the pathname that requires normalization.
 88        This way we iterate through the whole pathname string only once. */
<span class="line-added"> 89     @Override</span>
 90     public String normalize(String pathname) {
 91         int n = pathname.length();
 92         char prevChar = 0;
 93         for (int i = 0; i &lt; n; i++) {
 94             char c = pathname.charAt(i);
 95             if ((prevChar == &#39;/&#39;) &amp;&amp; (c == &#39;/&#39;))
 96                 return normalize(pathname, n, i - 1);
 97             prevChar = c;
 98         }
 99         if (prevChar == &#39;/&#39;) return normalize(pathname, n, n - 1);
100         return pathname;
101     }
102 
<span class="line-added">103     @Override</span>
104     public int prefixLength(String pathname) {
105         if (pathname.isEmpty()) return 0;
106         return (pathname.charAt(0) == &#39;/&#39;) ? 1 : 0;
107     }
108 
<span class="line-added">109     @Override</span>
110     public String resolve(String parent, String child) {
111         if (child.isEmpty()) return parent;
112         if (child.charAt(0) == &#39;/&#39;) {
113             if (parent.equals(&quot;/&quot;)) return child;
114             return parent + child;
115         }
116         if (parent.equals(&quot;/&quot;)) return parent + child;
117         return parent + &#39;/&#39; + child;
118     }
119 
<span class="line-added">120     @Override</span>
121     public String getDefaultParent() {
122         return &quot;/&quot;;
123     }
124 
<span class="line-added">125     @Override</span>
126     public String fromURIPath(String path) {
127         String p = path;
128         if (p.endsWith(&quot;/&quot;) &amp;&amp; (p.length() &gt; 1)) {
129             // &quot;/foo/&quot; --&gt; &quot;/foo&quot;, but &quot;/&quot; --&gt; &quot;/&quot;
130             p = p.substring(0, p.length() - 1);
131         }
132         return p;
133     }
134 
135 
136     /* -- Path operations -- */
137 
<span class="line-added">138     @Override</span>
139     public boolean isAbsolute(File f) {
140         return (f.getPrefixLength() != 0);
141     }
142 
<span class="line-added">143     @Override</span>
144     public String resolve(File f) {
145         if (isAbsolute(f)) return f.getPath();
146         SecurityManager sm = System.getSecurityManager();
147         if (sm != null) {
148             sm.checkPropertyAccess(&quot;user.dir&quot;);
149         }
150         return resolve(userDir, f.getPath());
151     }
152 
153     // Caches for canonicalization results to improve startup performance.
154     // The first cache handles repeated canonicalizations of the same path
155     // name. The prefix cache handles repeated canonicalizations within the
156     // same directory, and must not create results differing from the true
157     // canonicalization algorithm in canonicalize_md.c. For this reason the
158     // prefix cache is conservative and is not used for complex path names.
159     private final ExpiringCache cache;
160     // On Unix symlinks can jump anywhere in the file system, so we only
161     // treat prefixes in java.home as trusted and cacheable in the
162     // canonicalization algorithm
163     private final ExpiringCache javaHomePrefixCache;
164 
<span class="line-added">165     @Override</span>
166     public String canonicalize(String path) throws IOException {
167         if (!useCanonCaches) {
168             return canonicalize0(path);
169         } else {
170             String res = cache.get(path);
171             if (res == null) {
172                 String dir = null;
173                 String resDir;
174                 if (useCanonPrefixCache) {
175                     // Note that this can cause symlinks that should
176                     // be resolved to a destination directory to be
177                     // resolved to the directory they&#39;re contained in
178                     dir = parentOrNull(path);
179                     if (dir != null) {
180                         resDir = javaHomePrefixCache.get(dir);
181                         if (resDir != null) {
182                             // Hit only in prefix cache; full path is canonical
183                             String filename = path.substring(1 + dir.length());
184                             res = resDir + slash + filename;
185                             cache.put(dir + slash + filename, res);
</pre>
<hr />
<pre>
239                     idx &gt;= last - 1 ||
240                     path.charAt(idx - 1) == sep) {
241                     // Punt on pathnames containing adjacent slashes
242                     // toward the end
243                     return null;
244                 }
245                 return path.substring(0, idx);
246             } else {
247                 ++nonDotCount;
248                 adjacentDots = 0;
249             }
250             --idx;
251         }
252         return null;
253     }
254 
255     /* -- Attribute accessors -- */
256 
257     public native int getBooleanAttributes0(File f);
258 
<span class="line-added">259     @Override</span>
260     public int getBooleanAttributes(File f) {
261         int rv = getBooleanAttributes0(f);
262         String name = f.getName();
263         boolean hidden = !name.isEmpty() &amp;&amp; name.charAt(0) == &#39;.&#39;;
264         return rv | (hidden ? BA_HIDDEN : 0);
265     }
266 
<span class="line-added">267     @Override</span>
268     public native boolean checkAccess(File f, int access);
<span class="line-added">269 </span>
<span class="line-added">270     @Override</span>
271     public native long getLastModifiedTime(File f);
<span class="line-added">272 </span>
<span class="line-added">273     @Override</span>
274     public native long getLength(File f);
<span class="line-added">275 </span>
<span class="line-added">276     @Override</span>
277     public native boolean setPermission(File f, int access, boolean enable, boolean owneronly);
278 
279     /* -- File operations -- */
280 
<span class="line-added">281     @Override</span>
282     public native boolean createFileExclusively(String path)
283         throws IOException;
<span class="line-added">284 </span>
<span class="line-added">285     @Override</span>
286     public boolean delete(File f) {
287         // Keep canonicalization caches in sync after file deletion
288         // and renaming operations. Could be more clever than this
289         // (i.e., only remove/update affected entries) but probably
290         // not worth it since these entries expire after 30 seconds
291         // anyway.
292         if (useCanonCaches) {
293             cache.clear();
294         }
295         if (useCanonPrefixCache) {
296             javaHomePrefixCache.clear();
297         }
298         return delete0(f);
299     }
300     private native boolean delete0(File f);
<span class="line-added">301 </span>
<span class="line-added">302     @Override</span>
303     public native String[] list(File f);
<span class="line-added">304 </span>
<span class="line-added">305     @Override</span>
306     public native boolean createDirectory(File f);
<span class="line-added">307 </span>
<span class="line-added">308     @Override</span>
309     public boolean rename(File f1, File f2) {
310         // Keep canonicalization caches in sync after file deletion
311         // and renaming operations. Could be more clever than this
312         // (i.e., only remove/update affected entries) but probably
313         // not worth it since these entries expire after 30 seconds
314         // anyway.
315         if (useCanonCaches) {
316             cache.clear();
317         }
318         if (useCanonPrefixCache) {
319             javaHomePrefixCache.clear();
320         }
321         return rename0(f1, f2);
322     }
323     private native boolean rename0(File f1, File f2);
<span class="line-added">324 </span>
<span class="line-added">325     @Override</span>
326     public native boolean setLastModifiedTime(File f, long time);

327 
<span class="line-added">328     @Override</span>
<span class="line-added">329     public native boolean setReadOnly(File f);</span>
330 
331     /* -- Filesystem interface -- */
332 
<span class="line-added">333     @Override</span>
334     public File[] listRoots() {
335         try {
336             SecurityManager security = System.getSecurityManager();
337             if (security != null) {
338                 security.checkRead(&quot;/&quot;);
339             }
340             return new File[] { new File(&quot;/&quot;) };
341         } catch (SecurityException x) {
342             return new File[0];
343         }
344     }
345 
346     /* -- Disk usage -- */
<span class="line-added">347 </span>
<span class="line-added">348     @Override</span>
349     public native long getSpace(File f, int t);
350 
351     /* -- Basic infrastructure -- */
352 
353     private native long getNameMax0(String path);
354 
<span class="line-added">355     @Override</span>
356     public int getNameMax(String path) {
357         long nameMax = getNameMax0(path);
358         if (nameMax &gt; Integer.MAX_VALUE) {
359             nameMax = Integer.MAX_VALUE;
360         }
361         return (int)nameMax;
362     }
363 
<span class="line-added">364     @Override</span>
365     public int compare(File f1, File f2) {
366         return f1.getPath().compareTo(f2.getPath());
367     }
368 
<span class="line-added">369     @Override</span>
370     public int hashCode(File f) {
371         return f.getPath().hashCode() ^ 1234321;
372     }
373 
374 
375     private static native void initIDs();
376 
377     static {
378         initIDs();
379     }

380 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../solaris/native/libnet/solaris_close.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../lang/ClassLoaderHelper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
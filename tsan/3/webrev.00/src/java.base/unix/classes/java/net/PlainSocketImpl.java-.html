<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/unix/classes/java/net/PlainSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
 26 
 27 import java.io.IOException;
 28 import java.io.FileDescriptor;
 29 import java.util.Set;
 30 import java.util.HashSet;
 31 import sun.net.ext.ExtendedSocketOptions;
 32 
 33 /*
 34  * On Unix systems we simply delegate to native methods.
 35  *
 36  * @author Chris Hegarty
 37  */
 38 
 39 class PlainSocketImpl extends AbstractPlainSocketImpl
 40 {
 41     static {
 42         initProto();
 43     }
 44 
 45     /**
 46      * Constructs an empty instance.
 47      */
 48     PlainSocketImpl() { }
 49 
 50     /**
 51      * Constructs an instance with the given file descriptor.
 52      */
 53     PlainSocketImpl(FileDescriptor fd) {
 54         this.fd = fd;
 55     }
 56 
 57     static final ExtendedSocketOptions extendedOptions =
 58             ExtendedSocketOptions.getInstance();
 59 
 60     protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
 61         if (isClosedOrPending()) {
 62             throw new SocketException(&quot;Socket closed&quot;);
 63         }
 64         if (supportedOptions().contains(name)) {
 65             if (extendedOptions.isOptionSupported(name)) {
 66                 extendedOptions.setOption(fd, name, value);
 67             } else {
 68                 super.setOption(name, value);
 69             }
 70         } else {
 71             throw new UnsupportedOperationException(&quot;unsupported option&quot;);
 72         }
 73     }
 74 
 75     @SuppressWarnings(&quot;unchecked&quot;)
 76     protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
 77         if (isClosedOrPending()) {
 78             throw new SocketException(&quot;Socket closed&quot;);
 79         }
 80         if (supportedOptions().contains(name)) {
 81             if (extendedOptions.isOptionSupported(name)) {
 82                 return (T) extendedOptions.getOption(fd, name);
 83             } else {
 84                 return super.getOption(name);
 85             }
 86         } else {
 87             throw new UnsupportedOperationException(&quot;unsupported option&quot;);
 88         }
 89     }
 90 
 91     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
 92         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;(super.supportedOptions());
 93         if (getServerSocket() != null) {
 94             options.addAll(ExtendedSocketOptions.serverSocketOptions());
 95         } else {
 96             options.addAll(ExtendedSocketOptions.clientSocketOptions());
 97         }
 98         return options;
 99     }
100 
101     protected void socketSetOption(int opt, boolean b, Object val) throws SocketException {
102         if (opt == SocketOptions.SO_REUSEPORT &amp;&amp;
103             !supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {
104             throw new UnsupportedOperationException(&quot;unsupported option&quot;);
105         }
106         try {
107             socketSetOption0(opt, b, val);
108         } catch (SocketException se) {
109             if (socket == null || !socket.isConnected())
110                 throw se;
111         }
112     }
113 
114     native void socketCreate(boolean isServer) throws IOException;
115 
116     native void socketConnect(InetAddress address, int port, int timeout)
117         throws IOException;
118 
119     native void socketBind(InetAddress address, int port)
120         throws IOException;
121 
122     native void socketListen(int count) throws IOException;
123 
124     native void socketAccept(SocketImpl s) throws IOException;
125 
126     native int socketAvailable() throws IOException;
127 
128     native void socketClose0(boolean useDeferredClose) throws IOException;
129 
130     native void socketShutdown(int howto) throws IOException;
131 
132     static native void initProto();
133 
134     native void socketSetOption0(int cmd, boolean on, Object value)
135         throws SocketException;
136 
137     native int socketGetOption(int opt, Object iaContainerObj) throws SocketException;
138 
139     native void socketSendUrgentData(int data) throws IOException;
140 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/macosx/classes/apple/security/KeychainStore.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package apple.security;
  27 
  28 import java.io.*;
  29 import java.security.*;
  30 import java.security.cert.*;
  31 import java.security.cert.Certificate;
  32 import java.security.spec.*;
  33 import java.util.*;
  34 
  35 import javax.crypto.*;
  36 import javax.crypto.spec.*;
  37 import javax.security.auth.x500.*;
  38 
  39 import sun.security.pkcs.*;
  40 import sun.security.pkcs.EncryptedPrivateKeyInfo;
  41 import sun.security.util.*;
  42 import sun.security.x509.*;
  43 
  44 /**
  45  * This class provides the keystore implementation referred to as &quot;KeychainStore&quot;.
  46  * It uses the current user&#39;s keychain as its backing storage, and does NOT support
  47  * a file-based implementation.
  48  */
  49 
  50 public final class KeychainStore extends KeyStoreSpi {
  51 
  52     // Private keys and their supporting certificate chains
  53     // If a key came from the keychain it has a SecKeyRef and one or more
  54     // SecCertificateRef.  When we delete the key we have to delete all of the corresponding
  55     // native objects.
  56     class KeyEntry {
  57         Date date; // the creation date of this entry
  58         byte[] protectedPrivKey;
  59         char[] password;
  60         long keyRef;  // SecKeyRef for this key
  61         Certificate chain[];
  62         long chainRefs[];  // SecCertificateRefs for this key&#39;s chain.
  63     };
  64 
  65     // Trusted certificates
  66     class TrustedCertEntry {
  67         Date date; // the creation date of this entry
  68 
  69         Certificate cert;
  70         long certRef;  // SecCertificateRef for this key
  71     };
  72 
  73     /**
  74      * Entries that have been deleted.  When something calls engineStore we&#39;ll
  75      * remove them from the keychain.
  76      */
  77     private Hashtable&lt;String, Object&gt; deletedEntries = new Hashtable&lt;&gt;();
  78 
  79     /**
  80      * Entries that have been added.  When something calls engineStore we&#39;ll
  81      * add them to the keychain.
  82      */
  83     private Hashtable&lt;String, Object&gt; addedEntries = new Hashtable&lt;&gt;();
  84 
  85     /**
  86      * Private keys and certificates are stored in a hashtable.
  87      * Hash entries are keyed by alias names.
  88      */
  89     private Hashtable&lt;String, Object&gt; entries = new Hashtable&lt;&gt;();
  90 
  91     /**
<a name="2" id="anc2"></a><span class="line-modified">  92      * Algorithm identifiers and corresponding OIDs for the contents of the</span>
<span class="line-added">  93      * PKCS12 bag we get from the Keychain.</span>
  94      */
<a name="3" id="anc3"></a><span class="line-modified">  95     private static ObjectIdentifier PKCS8ShroudedKeyBag_OID =</span>
<span class="line-modified">  96             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.10.1.2&quot;);</span>
<span class="line-modified">  97     private static ObjectIdentifier pbeWithSHAAnd3KeyTripleDESCBC_OID =</span>
<span class="line-modified">  98             ObjectIdentifier.of(&quot;1.2.840.113549.1.12.1.3&quot;);</span>
  99 
 100     /**
 101      * Constnats used in PBE decryption.
 102      */
 103     private static final int iterationCount = 1024;
 104     private static final int SALT_LEN = 20;
 105 
 106     private static final Debug debug = Debug.getInstance(&quot;keystore&quot;);
 107 
<a name="4" id="anc4"></a>















 108     private static void permissionCheck() {
 109         SecurityManager sec = System.getSecurityManager();
 110 
 111         if (sec != null) {
 112             sec.checkPermission(new RuntimePermission(&quot;useKeychainStore&quot;));
 113         }
 114     }
 115 
 116 
 117     /**
 118      * Verify the Apple provider in the constructor.
 119      *
 120      * @exception SecurityException if fails to verify
 121      * its own integrity
 122      */
 123     public KeychainStore() { }
 124 
 125     /**
 126         * Returns the key associated with the given alias, using the given
 127      * password to recover it.
 128      *
 129      * @param alias the alias name
 130      * @param password the password for recovering the key. This password is
 131      *        used internally as the key is exported in a PKCS12 format.
 132      *
 133      * @return the requested key, or null if the given alias does not exist
 134      * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
 135      *
 136      * @exception NoSuchAlgorithmException if the algorithm for recovering the
 137      * key cannot be found
 138      * @exception UnrecoverableKeyException if the key cannot be recovered
 139      * (e.g., the given password is wrong).
 140      */
 141     public Key engineGetKey(String alias, char[] password)
 142         throws NoSuchAlgorithmException, UnrecoverableKeyException
 143     {
 144         permissionCheck();
 145 
 146         // An empty password is rejected by MacOS API, no private key data
 147         // is exported. If no password is passed (as is the case when
 148         // this implementation is used as browser keystore in various
 149         // deployment scenarios like Webstart, JFX and applets), create
 150         // a dummy password so MacOS API is happy.
 151         if (password == null || password.length == 0) {
 152             // Must not be a char array with only a 0, as this is an empty
 153             // string.
 154             if (random == null) {
 155                 random = new SecureRandom();
 156             }
 157             password = Long.toString(random.nextLong()).toCharArray();
 158         }
 159 
 160         Object entry = entries.get(alias.toLowerCase());
 161 
 162         if (entry == null || !(entry instanceof KeyEntry)) {
 163             return null;
 164         }
 165 
 166         // This call gives us a PKCS12 bag, with the key inside it.
 167         byte[] exportedKeyInfo = _getEncodedKeyData(((KeyEntry)entry).keyRef, password);
 168         if (exportedKeyInfo == null) {
 169             return null;
 170         }
 171 
 172         PrivateKey returnValue = null;
 173 
 174         try {
 175             byte[] pkcs8KeyData = fetchPrivateKeyFromBag(exportedKeyInfo);
 176             byte[] encryptedKey;
 177             AlgorithmParameters algParams;
 178             ObjectIdentifier algOid;
 179             try {
 180                 // get the encrypted private key
 181                 EncryptedPrivateKeyInfo encrInfo = new EncryptedPrivateKeyInfo(pkcs8KeyData);
 182                 encryptedKey = encrInfo.getEncryptedData();
 183 
 184                 // parse Algorithm parameters
 185                 DerValue val = new DerValue(encrInfo.getAlgorithm().encode());
 186                 DerInputStream in = val.toDerInputStream();
 187                 algOid = in.getOID();
 188                 algParams = parseAlgParameters(in);
 189 
 190             } catch (IOException ioe) {
 191                 UnrecoverableKeyException uke =
 192                 new UnrecoverableKeyException(&quot;Private key not stored as &quot;
 193                                               + &quot;PKCS#8 EncryptedPrivateKeyInfo: &quot; + ioe);
 194                 uke.initCause(ioe);
 195                 throw uke;
 196             }
 197 
 198             // Use JCE to decrypt the data using the supplied password.
 199             SecretKey skey = getPBEKey(password);
 200             Cipher cipher = Cipher.getInstance(algOid.toString());
 201             cipher.init(Cipher.DECRYPT_MODE, skey, algParams);
 202             byte[] decryptedPrivateKey = cipher.doFinal(encryptedKey);
 203             PKCS8EncodedKeySpec kspec = new PKCS8EncodedKeySpec(decryptedPrivateKey);
 204 
 205              // Parse the key algorithm and then use a JCA key factory to create the private key.
 206             DerValue val = new DerValue(decryptedPrivateKey);
 207             DerInputStream in = val.toDerInputStream();
 208 
 209             // Ignore this -- version should be 0.
 210             int i = in.getInteger();
 211 
 212             // Get the Algorithm ID next
 213             DerValue[] value = in.getSequence(2);
 214             AlgorithmId algId = new AlgorithmId(value[0].getOID());
 215             String algName = algId.getName();
 216 
 217             // Get a key factory for this algorithm.  It&#39;s likely to be &#39;RSA&#39;.
 218             KeyFactory kfac = KeyFactory.getInstance(algName);
 219             returnValue = kfac.generatePrivate(kspec);
 220         } catch (Exception e) {
 221             UnrecoverableKeyException uke =
 222             new UnrecoverableKeyException(&quot;Get Key failed: &quot; +
 223                                           e.getMessage());
 224             uke.initCause(e);
 225             throw uke;
 226         }
 227 
 228         return returnValue;
 229     }
 230 
 231     private native byte[] _getEncodedKeyData(long secKeyRef, char[] password);
 232 
 233     /**
 234      * Returns the certificate chain associated with the given alias.
 235      *
 236      * @param alias the alias name
 237      *
 238      * @return the certificate chain (ordered with the user&#39;s certificate first
 239                                       * and the root certificate authority last), or null if the given alias
 240      * does not exist or does not contain a certificate chain (i.e., the given
 241                                                                * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
 242                                                                * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
 243      */
 244     public Certificate[] engineGetCertificateChain(String alias) {
 245         permissionCheck();
 246 
 247         Object entry = entries.get(alias.toLowerCase());
 248 
 249         if (entry != null &amp;&amp; entry instanceof KeyEntry) {
 250             if (((KeyEntry)entry).chain == null) {
 251                 return null;
 252             } else {
 253                 return ((KeyEntry)entry).chain.clone();
 254             }
 255         } else {
 256             return null;
 257         }
 258     }
 259 
 260     /**
 261      * Returns the certificate associated with the given alias.
 262      *
 263      * &lt;p&gt;If the given alias name identifies a
 264      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
 265      * entry is returned. If the given alias name identifies a
 266      * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
 267      * entry is returned, or null if that entry does not have a certificate
 268      * chain.
 269      *
 270      * @param alias the alias name
 271      *
 272      * @return the certificate, or null if the given alias does not exist or
 273      * does not contain a certificate.
 274      */
 275     public Certificate engineGetCertificate(String alias) {
 276         permissionCheck();
 277 
 278         Object entry = entries.get(alias.toLowerCase());
 279 
 280         if (entry != null) {
 281             if (entry instanceof TrustedCertEntry) {
 282                 return ((TrustedCertEntry)entry).cert;
 283             } else {
 284                 KeyEntry ke = (KeyEntry)entry;
 285                 if (ke.chain == null || ke.chain.length == 0) {
 286                     return null;
 287                 }
 288                 return ke.chain[0];
 289             }
 290         } else {
 291             return null;
 292         }
 293     }
 294 
 295     /**
 296         * Returns the creation date of the entry identified by the given alias.
 297      *
 298      * @param alias the alias name
 299      *
 300      * @return the creation date of this entry, or null if the given alias does
 301      * not exist
 302      */
 303     public Date engineGetCreationDate(String alias) {
 304         permissionCheck();
 305 
 306         Object entry = entries.get(alias.toLowerCase());
 307 
 308         if (entry != null) {
 309             if (entry instanceof TrustedCertEntry) {
 310                 return new Date(((TrustedCertEntry)entry).date.getTime());
 311             } else {
 312                 return new Date(((KeyEntry)entry).date.getTime());
 313             }
 314         } else {
 315             return null;
 316         }
 317     }
 318 
 319     /**
 320         * Assigns the given key to the given alias, protecting it with the given
 321      * password.
 322      *
 323      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
 324      * it must be accompanied by a certificate chain certifying the
 325      * corresponding public key.
 326      *
 327      * &lt;p&gt;If the given alias already exists, the keystore information
 328      * associated with it is overridden by the given key (and possibly
 329                                                           * certificate chain).
 330      *
 331      * @param alias the alias name
 332      * @param key the key to be associated with the alias
 333      * @param password the password to protect the key
 334      * @param chain the certificate chain for the corresponding public
 335      * key (only required if the given key is of type
 336             * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 337      *
 338      * @exception KeyStoreException if the given key cannot be protected, or
 339      * this operation fails for some other reason
 340      */
 341     public void engineSetKeyEntry(String alias, Key key, char[] password,
 342                                   Certificate[] chain)
 343         throws KeyStoreException
 344     {
 345         permissionCheck();
 346 
 347         synchronized(entries) {
 348             try {
 349                 KeyEntry entry = new KeyEntry();
 350                 entry.date = new Date();
 351 
 352                 if (key instanceof PrivateKey) {
 353                     if ((key.getFormat().equals(&quot;PKCS#8&quot;)) ||
 354                         (key.getFormat().equals(&quot;PKCS8&quot;))) {
 355                         entry.protectedPrivKey = encryptPrivateKey(key.getEncoded(), password);
 356                         entry.password = password.clone();
 357                     } else {
 358                         throw new KeyStoreException(&quot;Private key is not encoded as PKCS#8&quot;);
 359                     }
 360                 } else {
 361                     throw new KeyStoreException(&quot;Key is not a PrivateKey&quot;);
 362                 }
 363 
 364                 // clone the chain
 365                 if (chain != null) {
 366                     if ((chain.length &gt; 1) &amp;&amp; !validateChain(chain)) {
 367                         throw new KeyStoreException(&quot;Certificate chain does not validate&quot;);
 368                     }
 369 
 370                     entry.chain = chain.clone();
 371                     entry.chainRefs = new long[entry.chain.length];
 372                 }
 373 
 374                 String lowerAlias = alias.toLowerCase();
 375                 if (entries.get(lowerAlias) != null) {
 376                     deletedEntries.put(lowerAlias, entries.get(lowerAlias));
 377                 }
 378 
 379                 entries.put(lowerAlias, entry);
 380                 addedEntries.put(lowerAlias, entry);
 381             } catch (Exception nsae) {
 382                 KeyStoreException ke = new KeyStoreException(&quot;Key protection algorithm not found: &quot; + nsae);
 383                 ke.initCause(nsae);
 384                 throw ke;
 385             }
 386         }
 387     }
 388 
 389     /**
 390         * Assigns the given key (that has already been protected) to the given
 391      * alias.
 392      *
 393      * &lt;p&gt;If the protected key is of type
 394      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
 395      * certificate chain certifying the corresponding public key. If the
 396      * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
 397      * &lt;code&gt;key&lt;/code&gt; must be encoded as an
 398      * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
 399      *
 400      * &lt;p&gt;If the given alias already exists, the keystore information
 401      * associated with it is overridden by the given key (and possibly
 402                                                           * certificate chain).
 403      *
 404      * @param alias the alias name
 405      * @param key the key (in protected format) to be associated with the alias
 406      * @param chain the certificate chain for the corresponding public
 407      * key (only useful if the protected key is of type
 408             * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 409      *
 410      * @exception KeyStoreException if this operation fails.
 411      */
 412     public void engineSetKeyEntry(String alias, byte[] key,
 413                                   Certificate[] chain)
 414         throws KeyStoreException
 415     {
 416         permissionCheck();
 417 
 418         synchronized(entries) {
 419             // key must be encoded as EncryptedPrivateKeyInfo as defined in
 420             // PKCS#8
 421             KeyEntry entry = new KeyEntry();
 422             try {
 423                 EncryptedPrivateKeyInfo privateKey = new EncryptedPrivateKeyInfo(key);
 424                 entry.protectedPrivKey = privateKey.getEncoded();
 425             } catch (IOException ioe) {
 426                 throw new KeyStoreException(&quot;key is not encoded as &quot;
 427                                             + &quot;EncryptedPrivateKeyInfo&quot;);
 428             }
 429 
 430             entry.date = new Date();
 431 
 432             if ((chain != null) &amp;&amp;
 433                 (chain.length != 0)) {
 434                 entry.chain = chain.clone();
 435                 entry.chainRefs = new long[entry.chain.length];
 436             }
 437 
 438             String lowerAlias = alias.toLowerCase();
 439             if (entries.get(lowerAlias) != null) {
 440                 deletedEntries.put(lowerAlias, entries.get(alias));
 441             }
 442             entries.put(lowerAlias, entry);
 443             addedEntries.put(lowerAlias, entry);
 444         }
 445     }
 446 
 447     /**
 448         * Assigns the given certificate to the given alias.
 449      *
 450      * &lt;p&gt;If the given alias already exists in this keystore and identifies a
 451      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
 452      * overridden by the given certificate.
 453      *
 454      * @param alias the alias name
 455      * @param cert the certificate
 456      *
 457      * @exception KeyStoreException if the given alias already exists and does
 458      * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation
 459      * fails for some other reason.
 460      */
 461     public void engineSetCertificateEntry(String alias, Certificate cert)
 462         throws KeyStoreException
 463     {
 464         permissionCheck();
 465 
 466         synchronized(entries) {
 467 
 468             Object entry = entries.get(alias.toLowerCase());
 469             if ((entry != null) &amp;&amp; (entry instanceof KeyEntry)) {
 470                 throw new KeyStoreException
 471                 (&quot;Cannot overwrite key entry with certificate&quot;);
 472             }
 473 
 474             // This will be slow, but necessary.  Enumerate the values and then see if the cert matches the one in the trusted cert entry.
 475             // Security framework doesn&#39;t support the same certificate twice in a keychain.
 476             Collection&lt;Object&gt; allValues = entries.values();
 477 
 478             for (Object value : allValues) {
 479                 if (value instanceof TrustedCertEntry) {
 480                     TrustedCertEntry tce = (TrustedCertEntry)value;
 481                     if (tce.cert.equals(cert)) {
 482                         throw new KeyStoreException(&quot;Keychain does not support mulitple copies of same certificate.&quot;);
 483                     }
 484                 }
 485             }
 486 
 487             TrustedCertEntry trustedCertEntry = new TrustedCertEntry();
 488             trustedCertEntry.cert = cert;
 489             trustedCertEntry.date = new Date();
 490             String lowerAlias = alias.toLowerCase();
 491             if (entries.get(lowerAlias) != null) {
 492                 deletedEntries.put(lowerAlias, entries.get(lowerAlias));
 493             }
 494             entries.put(lowerAlias, trustedCertEntry);
 495             addedEntries.put(lowerAlias, trustedCertEntry);
 496         }
 497     }
 498 
 499     /**
 500         * Deletes the entry identified by the given alias from this keystore.
 501      *
 502      * @param alias the alias name
 503      *
 504      * @exception KeyStoreException if the entry cannot be removed.
 505      */
 506     public void engineDeleteEntry(String alias)
 507         throws KeyStoreException
 508     {
 509         permissionCheck();
 510 
 511         synchronized(entries) {
 512             Object entry = entries.remove(alias.toLowerCase());
 513             deletedEntries.put(alias.toLowerCase(), entry);
 514         }
 515     }
 516 
 517     /**
 518         * Lists all the alias names of this keystore.
 519      *
 520      * @return enumeration of the alias names
 521      */
 522     public Enumeration&lt;String&gt; engineAliases() {
 523         permissionCheck();
 524         return entries.keys();
 525     }
 526 
 527     /**
 528         * Checks if the given alias exists in this keystore.
 529      *
 530      * @param alias the alias name
 531      *
 532      * @return true if the alias exists, false otherwise
 533      */
 534     public boolean engineContainsAlias(String alias) {
 535         permissionCheck();
 536         return entries.containsKey(alias.toLowerCase());
 537     }
 538 
 539     /**
 540         * Retrieves the number of entries in this keystore.
 541      *
 542      * @return the number of entries in this keystore
 543      */
 544     public int engineSize() {
 545         permissionCheck();
 546         return entries.size();
 547     }
 548 
 549     /**
 550         * Returns true if the entry identified by the given alias is a
 551      * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
 552      *
 553      * @return true if the entry identified by the given alias is a
 554      * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
 555      */
 556     public boolean engineIsKeyEntry(String alias) {
 557         permissionCheck();
 558         Object entry = entries.get(alias.toLowerCase());
 559         if ((entry != null) &amp;&amp; (entry instanceof KeyEntry)) {
 560             return true;
 561         } else {
 562             return false;
 563         }
 564     }
 565 
 566     /**
 567         * Returns true if the entry identified by the given alias is a
 568      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
 569      *
 570      * @return true if the entry identified by the given alias is a
 571      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
 572      */
 573     public boolean engineIsCertificateEntry(String alias) {
 574         permissionCheck();
 575         Object entry = entries.get(alias.toLowerCase());
 576         if ((entry != null) &amp;&amp; (entry instanceof TrustedCertEntry)) {
 577             return true;
 578         } else {
 579             return false;
 580         }
 581     }
 582 
 583     /**
 584         * Returns the (alias) name of the first keystore entry whose certificate
 585      * matches the given certificate.
 586      *
 587      * &lt;p&gt;This method attempts to match the given certificate with each
 588      * keystore entry. If the entry being considered
 589      * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
 590      * compared to that entry&#39;s certificate. If the entry being considered is
 591      * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
 592      * element of that entry&#39;s certificate chain (if a chain exists).
 593      *
 594      * @param cert the certificate to match with.
 595      *
 596      * @return the (alias) name of the first entry with matching certificate,
 597      * or null if no such entry exists in this keystore.
 598      */
 599     public String engineGetCertificateAlias(Certificate cert) {
 600         permissionCheck();
 601         Certificate certElem;
 602 
 603         for (Enumeration&lt;String&gt; e = entries.keys(); e.hasMoreElements(); ) {
 604             String alias = e.nextElement();
 605             Object entry = entries.get(alias);
 606             if (entry instanceof TrustedCertEntry) {
 607                 certElem = ((TrustedCertEntry)entry).cert;
 608             } else {
 609                 KeyEntry ke = (KeyEntry)entry;
 610                 if (ke.chain == null || ke.chain.length == 0) {
 611                     continue;
 612                 }
 613                 certElem = ke.chain[0];
 614             }
 615             if (certElem.equals(cert)) {
 616                 return alias;
 617             }
 618         }
 619         return null;
 620     }
 621 
 622     /**
 623         * Stores this keystore to the given output stream, and protects its
 624      * integrity with the given password.
 625      *
 626      * @param stream Ignored. the output stream to which this keystore is written.
 627      * @param password the password to generate the keystore integrity check
 628      *
 629      * @exception IOException if there was an I/O problem with data
 630      * @exception NoSuchAlgorithmException if the appropriate data integrity
 631      * algorithm could not be found
 632      * @exception CertificateException if any of the certificates included in
 633      * the keystore data could not be stored
 634      */
 635     public void engineStore(OutputStream stream, char[] password)
 636         throws IOException, NoSuchAlgorithmException, CertificateException
 637     {
 638         permissionCheck();
 639 
 640         // Delete items that do have a keychain item ref.
 641         for (Enumeration&lt;String&gt; e = deletedEntries.keys(); e.hasMoreElements(); ) {
 642             String alias = e.nextElement();
 643             Object entry = deletedEntries.get(alias);
 644             if (entry instanceof TrustedCertEntry) {
 645                 if (((TrustedCertEntry)entry).certRef != 0) {
 646                     _removeItemFromKeychain(((TrustedCertEntry)entry).certRef);
 647                     _releaseKeychainItemRef(((TrustedCertEntry)entry).certRef);
 648                 }
 649             } else {
 650                 Certificate certElem;
 651                 KeyEntry keyEntry = (KeyEntry)entry;
 652 
 653                 if (keyEntry.chain != null) {
 654                     for (int i = 0; i &lt; keyEntry.chain.length; i++) {
 655                         if (keyEntry.chainRefs[i] != 0) {
 656                             _removeItemFromKeychain(keyEntry.chainRefs[i]);
 657                             _releaseKeychainItemRef(keyEntry.chainRefs[i]);
 658                         }
 659                     }
 660 
 661                     if (keyEntry.keyRef != 0) {
 662                         _removeItemFromKeychain(keyEntry.keyRef);
 663                         _releaseKeychainItemRef(keyEntry.keyRef);
 664                     }
 665                 }
 666             }
 667         }
 668 
 669         // Add all of the certs or keys in the added entries.
 670         // No need to check for 0 refs, as they are in the added list.
 671         for (Enumeration&lt;String&gt; e = addedEntries.keys(); e.hasMoreElements(); ) {
 672             String alias = e.nextElement();
 673             Object entry = addedEntries.get(alias);
 674             if (entry instanceof TrustedCertEntry) {
 675                 TrustedCertEntry tce = (TrustedCertEntry)entry;
 676                 Certificate certElem;
 677                 certElem = tce.cert;
 678                 tce.certRef = addCertificateToKeychain(alias, certElem);
 679             } else {
 680                 KeyEntry keyEntry = (KeyEntry)entry;
 681 
 682                 if (keyEntry.chain != null) {
 683                     for (int i = 0; i &lt; keyEntry.chain.length; i++) {
 684                         keyEntry.chainRefs[i] = addCertificateToKeychain(alias, keyEntry.chain[i]);
 685                     }
 686 
 687                     keyEntry.keyRef = _addItemToKeychain(alias, false, keyEntry.protectedPrivKey, keyEntry.password);
 688                 }
 689             }
 690         }
 691 
 692         // Clear the added and deletedEntries hashtables here, now that we&#39;re done with the updates.
 693         // For the deleted entries, we freed up the native references above.
 694         deletedEntries.clear();
 695         addedEntries.clear();
 696     }
 697 
 698     private long addCertificateToKeychain(String alias, Certificate cert) {
 699         byte[] certblob = null;
 700         long returnValue = 0;
 701 
 702         try {
 703             certblob = cert.getEncoded();
 704             returnValue = _addItemToKeychain(alias, true, certblob, null);
 705         } catch (Exception e) {
 706             e.printStackTrace();
 707         }
 708 
 709         return returnValue;
 710     }
 711 
 712     private native long _addItemToKeychain(String alias, boolean isCertificate, byte[] datablob, char[] password);
 713     private native int _removeItemFromKeychain(long certRef);
 714     private native void _releaseKeychainItemRef(long keychainItemRef);
 715 
 716     /**
 717       * Loads the keystore from the Keychain.
 718      *
 719      * @param stream Ignored - here for API compatibility.
 720      * @param password Ignored - if user needs to unlock keychain Security
 721      * framework will post any dialogs.
 722      *
 723      * @exception IOException if there is an I/O or format problem with the
 724      * keystore data
 725      * @exception NoSuchAlgorithmException if the algorithm used to check
 726      * the integrity of the keystore cannot be found
 727      * @exception CertificateException if any of the certificates in the
 728      * keystore could not be loaded
 729      */
 730     public void engineLoad(InputStream stream, char[] password)
 731         throws IOException, NoSuchAlgorithmException, CertificateException
 732     {
 733         permissionCheck();
 734 
 735         // Release any stray keychain references before clearing out the entries.
 736         synchronized(entries) {
 737             for (Enumeration&lt;String&gt; e = entries.keys(); e.hasMoreElements(); ) {
 738                 String alias = e.nextElement();
 739                 Object entry = entries.get(alias);
 740                 if (entry instanceof TrustedCertEntry) {
 741                     if (((TrustedCertEntry)entry).certRef != 0) {
 742                         _releaseKeychainItemRef(((TrustedCertEntry)entry).certRef);
 743                     }
 744                 } else {
 745                     KeyEntry keyEntry = (KeyEntry)entry;
 746 
 747                     if (keyEntry.chain != null) {
 748                         for (int i = 0; i &lt; keyEntry.chain.length; i++) {
 749                             if (keyEntry.chainRefs[i] != 0) {
 750                                 _releaseKeychainItemRef(keyEntry.chainRefs[i]);
 751                             }
 752                         }
 753 
 754                         if (keyEntry.keyRef != 0) {
 755                             _releaseKeychainItemRef(keyEntry.keyRef);
 756                         }
 757                     }
 758                 }
 759             }
 760 
 761             entries.clear();
 762             _scanKeychain();
 763             if (debug != null) {
 764                 debug.println(&quot;KeychainStore load entry count: &quot; +
 765                         entries.size());
 766             }
 767         }
 768     }
 769 
 770     private native void _scanKeychain();
 771 
 772     /**
 773      * Callback method from _scanKeychain.  If a trusted certificate is found, this method will be called.
 774      */
 775     private void createTrustedCertEntry(String alias, long keychainItemRef, long creationDate, byte[] derStream) {
 776         TrustedCertEntry tce = new TrustedCertEntry();
 777 
 778         try {
 779             CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 780             InputStream input = new ByteArrayInputStream(derStream);
 781             X509Certificate cert = (X509Certificate) cf.generateCertificate(input);
 782             input.close();
 783             tce.cert = cert;
 784             tce.certRef = keychainItemRef;
 785 
 786             // Make a creation date.
 787             if (creationDate != 0)
 788                 tce.date = new Date(creationDate);
 789             else
 790                 tce.date = new Date();
 791 
 792             int uniqueVal = 1;
 793             String originalAlias = alias;
 794 
 795             while (entries.containsKey(alias.toLowerCase())) {
 796                 alias = originalAlias + &quot; &quot; + uniqueVal;
 797                 uniqueVal++;
 798             }
 799 
 800             entries.put(alias.toLowerCase(), tce);
 801         } catch (Exception e) {
 802             // The certificate will be skipped.
 803             System.err.println(&quot;KeychainStore Ignored Exception: &quot; + e);
 804         }
 805     }
 806 
 807     /**
 808      * Callback method from _scanKeychain.  If an identity is found, this method will be called to create Java certificate
 809      * and private key objects from the keychain data.
 810      */
 811     private void createKeyEntry(String alias, long creationDate, long secKeyRef, long[] secCertificateRefs, byte[][] rawCertData)
 812         throws IOException, NoSuchAlgorithmException, UnrecoverableKeyException {
 813         KeyEntry ke = new KeyEntry();
 814 
 815         // First, store off the private key information.  This is the easy part.
 816         ke.protectedPrivKey = null;
 817         ke.keyRef = secKeyRef;
 818 
 819         // Make a creation date.
 820         if (creationDate != 0)
 821             ke.date = new Date(creationDate);
 822         else
 823             ke.date = new Date();
 824 
 825         // Next, create X.509 Certificate objects from the raw data.  This is complicated
 826         // because a certificate&#39;s public key may be too long for Java&#39;s default encryption strength.
 827         List&lt;CertKeychainItemPair&gt; createdCerts = new ArrayList&lt;&gt;();
 828 
 829         try {
 830             CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
 831 
 832             for (int i = 0; i &lt; rawCertData.length; i++) {
 833                 try {
 834                     InputStream input = new ByteArrayInputStream(rawCertData[i]);
 835                     X509Certificate cert = (X509Certificate) cf.generateCertificate(input);
 836                     input.close();
 837 
 838                     // We successfully created the certificate, so track it and its corresponding SecCertificateRef.
 839                     createdCerts.add(new CertKeychainItemPair(secCertificateRefs[i], cert));
 840                 } catch (CertificateException e) {
 841                     // The certificate will be skipped.
 842                     System.err.println(&quot;KeychainStore Ignored Exception: &quot; + e);
 843                 }
 844             }
 845         } catch (CertificateException e) {
 846             e.printStackTrace();
 847         } catch (IOException ioe) {
 848             ioe.printStackTrace();  // How would this happen?
 849         }
 850 
 851         // We have our certificates in the List, so now extract them into an array of
 852         // Certificates and SecCertificateRefs.
 853         CertKeychainItemPair[] objArray = createdCerts.toArray(new CertKeychainItemPair[0]);
 854         Certificate[] certArray = new Certificate[objArray.length];
 855         long[] certRefArray = new long[objArray.length];
 856 
 857         for (int i = 0; i &lt; objArray.length; i++) {
 858             CertKeychainItemPair addedItem = objArray[i];
 859             certArray[i] = addedItem.mCert;
 860             certRefArray[i] = addedItem.mCertificateRef;
 861         }
 862 
 863         ke.chain = certArray;
 864         ke.chainRefs = certRefArray;
 865 
 866         // If we don&#39;t have already have an item with this item&#39;s alias
 867         // create a new one for it.
 868         int uniqueVal = 1;
 869         String originalAlias = alias;
 870 
 871         while (entries.containsKey(alias.toLowerCase())) {
 872             alias = originalAlias + &quot; &quot; + uniqueVal;
 873             uniqueVal++;
 874         }
 875 
 876         entries.put(alias.toLowerCase(), ke);
 877     }
 878 
 879     private class CertKeychainItemPair {
 880         long mCertificateRef;
 881         Certificate mCert;
 882 
 883         CertKeychainItemPair(long inCertRef, Certificate cert) {
 884             mCertificateRef = inCertRef;
 885             mCert = cert;
 886         }
 887     }
 888 
 889     /*
 890      * Validate Certificate Chain
 891      */
 892     private boolean validateChain(Certificate[] certChain)
 893     {
 894         for (int i = 0; i &lt; certChain.length-1; i++) {
 895             X500Principal issuerDN =
 896             ((X509Certificate)certChain[i]).getIssuerX500Principal();
 897             X500Principal subjectDN =
 898                 ((X509Certificate)certChain[i+1]).getSubjectX500Principal();
 899             if (!(issuerDN.equals(subjectDN)))
 900                 return false;
 901         }
 902         return true;
 903     }
 904 
 905     private byte[] fetchPrivateKeyFromBag(byte[] privateKeyInfo) throws IOException, NoSuchAlgorithmException, CertificateException
 906     {
 907         byte[] returnValue = null;
 908         DerValue val = new DerValue(new ByteArrayInputStream(privateKeyInfo));
 909         DerInputStream s = val.toDerInputStream();
 910         int version = s.getInteger();
 911 
 912         if (version != 3) {
 913             throw new IOException(&quot;PKCS12 keystore not in version 3 format&quot;);
 914         }
 915 
 916         /*
 917             * Read the authSafe.
 918          */
 919         byte[] authSafeData;
 920         ContentInfo authSafe = new ContentInfo(s);
 921         ObjectIdentifier contentType = authSafe.getContentType();
 922 
 923         if (contentType.equals(ContentInfo.DATA_OID)) {
 924             authSafeData = authSafe.getData();
 925         } else /* signed data */ {
 926             throw new IOException(&quot;public key protected PKCS12 not supported&quot;);
 927         }
 928 
 929         DerInputStream as = new DerInputStream(authSafeData);
 930         DerValue[] safeContentsArray = as.getSequence(2);
 931         int count = safeContentsArray.length;
 932 
 933         /*
 934          * Spin over the ContentInfos.
 935          */
 936         for (int i = 0; i &lt; count; i++) {
 937             byte[] safeContentsData;
 938             ContentInfo safeContents;
 939             DerInputStream sci;
 940             byte[] eAlgId = null;
 941 
 942             sci = new DerInputStream(safeContentsArray[i].toByteArray());
 943             safeContents = new ContentInfo(sci);
 944             contentType = safeContents.getContentType();
 945             safeContentsData = null;
 946 
 947             if (contentType.equals(ContentInfo.DATA_OID)) {
 948                 safeContentsData = safeContents.getData();
 949             } else if (contentType.equals(ContentInfo.ENCRYPTED_DATA_OID)) {
 950                 // The password was used to export the private key from the keychain.
 951                 // The Keychain won&#39;t export the key with encrypted data, so we don&#39;t need
 952                 // to worry about it.
 953                 continue;
 954             } else {
 955                 throw new IOException(&quot;public key protected PKCS12&quot; +
 956                                       &quot; not supported&quot;);
 957             }
 958             DerInputStream sc = new DerInputStream(safeContentsData);
 959             returnValue = extractKeyData(sc);
 960         }
 961 
 962         return returnValue;
 963     }
 964 
 965     private byte[] extractKeyData(DerInputStream stream)
 966         throws IOException, NoSuchAlgorithmException, CertificateException
 967     {
 968         byte[] returnValue = null;
 969         DerValue[] safeBags = stream.getSequence(2);
 970         int count = safeBags.length;
 971 
 972         /*
 973          * Spin over the SafeBags.
 974          */
 975         for (int i = 0; i &lt; count; i++) {
 976             ObjectIdentifier bagId;
 977             DerInputStream sbi;
 978             DerValue bagValue;
 979             Object bagItem = null;
 980 
 981             sbi = safeBags[i].toDerInputStream();
 982             bagId = sbi.getOID();
 983             bagValue = sbi.getDerValue();
 984             if (!bagValue.isContextSpecific((byte)0)) {
 985                 throw new IOException(&quot;unsupported PKCS12 bag value type &quot;
 986                                       + bagValue.tag);
 987             }
 988             bagValue = bagValue.data.getDerValue();
 989             if (bagId.equals(PKCS8ShroudedKeyBag_OID)) {
 990                 // got what we were looking for.  Return it.
 991                 returnValue = bagValue.toByteArray();
 992             } else {
 993                 // log error message for &quot;unsupported PKCS12 bag type&quot;
 994                 System.out.println(&quot;Unsupported bag type &#39;&quot; + bagId + &quot;&#39;&quot;);
 995             }
 996         }
 997 
 998         return returnValue;
 999     }
1000 
1001     /*
1002         * Generate PBE Algorithm Parameters
1003      */
1004     private AlgorithmParameters getAlgorithmParameters(String algorithm)
1005         throws IOException
1006     {
1007         AlgorithmParameters algParams = null;
1008 
1009         // create PBE parameters from salt and iteration count
1010         PBEParameterSpec paramSpec =
1011             new PBEParameterSpec(getSalt(), iterationCount);
1012         try {
1013             algParams = AlgorithmParameters.getInstance(algorithm);
1014             algParams.init(paramSpec);
1015         } catch (Exception e) {
1016             IOException ioe =
1017             new IOException(&quot;getAlgorithmParameters failed: &quot; +
1018                             e.getMessage());
1019             ioe.initCause(e);
1020             throw ioe;
1021         }
1022         return algParams;
1023     }
1024 
1025     // the source of randomness
1026     private SecureRandom random;
1027 
1028     /*
1029      * Generate random salt
1030      */
1031     private byte[] getSalt()
1032     {
1033         // Generate a random salt.
1034         byte[] salt = new byte[SALT_LEN];
1035         if (random == null) {
1036             random = new SecureRandom();
1037         }
<a name="5" id="anc5"></a><span class="line-modified">1038         random.nextBytes(salt);</span>
1039         return salt;
1040     }
1041 
1042     /*
1043      * parse Algorithm Parameters
1044      */
1045     private AlgorithmParameters parseAlgParameters(DerInputStream in)
1046         throws IOException
1047     {
1048         AlgorithmParameters algParams = null;
1049         try {
1050             DerValue params;
1051             if (in.available() == 0) {
1052                 params = null;
1053             } else {
1054                 params = in.getDerValue();
1055                 if (params.tag == DerValue.tag_Null) {
1056                     params = null;
1057                 }
1058             }
1059             if (params != null) {
1060                 algParams = AlgorithmParameters.getInstance(&quot;PBE&quot;);
1061                 algParams.init(params.toByteArray());
1062             }
1063         } catch (Exception e) {
1064             IOException ioe =
1065             new IOException(&quot;parseAlgParameters failed: &quot; +
1066                             e.getMessage());
1067             ioe.initCause(e);
1068             throw ioe;
1069         }
1070         return algParams;
1071     }
1072 
1073     /*
1074      * Generate PBE key
1075      */
1076     private SecretKey getPBEKey(char[] password) throws IOException
1077     {
1078         SecretKey skey = null;
1079 
1080         try {
1081             PBEKeySpec keySpec = new PBEKeySpec(password);
1082             SecretKeyFactory skFac = SecretKeyFactory.getInstance(&quot;PBE&quot;);
1083             skey = skFac.generateSecret(keySpec);
1084         } catch (Exception e) {
1085             IOException ioe = new IOException(&quot;getSecretKey failed: &quot; +
1086                                               e.getMessage());
1087             ioe.initCause(e);
1088             throw ioe;
1089         }
1090         return skey;
1091     }
1092 
1093     /*
1094      * Encrypt private key using Password-based encryption (PBE)
1095      * as defined in PKCS#5.
1096      *
1097      * NOTE: Currently pbeWithSHAAnd3-KeyTripleDES-CBC algorithmID is
1098      *       used to derive the key and IV.
1099      *
1100      * @return encrypted private key encoded as EncryptedPrivateKeyInfo
1101      */
1102     private byte[] encryptPrivateKey(byte[] data, char[] password)
1103         throws IOException, NoSuchAlgorithmException, UnrecoverableKeyException
1104     {
1105         byte[] key = null;
1106 
1107         try {
1108             // create AlgorithmParameters
1109             AlgorithmParameters algParams =
1110             getAlgorithmParameters(&quot;PBEWithSHA1AndDESede&quot;);
1111 
1112             // Use JCE
1113             SecretKey skey = getPBEKey(password);
1114             Cipher cipher = Cipher.getInstance(&quot;PBEWithSHA1AndDESede&quot;);
1115             cipher.init(Cipher.ENCRYPT_MODE, skey, algParams);
1116             byte[] encryptedKey = cipher.doFinal(data);
1117 
1118             // wrap encrypted private key in EncryptedPrivateKeyInfo
1119             // as defined in PKCS#8
1120             AlgorithmId algid =
1121                 new AlgorithmId(pbeWithSHAAnd3KeyTripleDESCBC_OID, algParams);
1122             EncryptedPrivateKeyInfo encrInfo =
1123                 new EncryptedPrivateKeyInfo(algid, encryptedKey);
1124             key = encrInfo.getEncoded();
1125         } catch (Exception e) {
1126             UnrecoverableKeyException uke =
1127             new UnrecoverableKeyException(&quot;Encrypt Private Key failed: &quot;
1128                                           + e.getMessage());
1129             uke.initCause(e);
1130             throw uke;
1131         }
1132 
1133         return key;
1134     }
1135 
1136 
1137 }
1138 
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
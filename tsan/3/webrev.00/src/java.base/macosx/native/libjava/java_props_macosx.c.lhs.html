<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/macosx/native/libjava/java_props_macosx.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;sys/socket.h&gt;
 27 #include &lt;netinet/in.h&gt;
 28 #include &lt;arpa/inet.h&gt;
 29 #include &lt;objc/objc-runtime.h&gt;
 30 
<a name="2" id="anc2"></a><span class="line-removed"> 31 #include &lt;Security/AuthSession.h&gt;</span>
 32 #include &lt;CoreFoundation/CoreFoundation.h&gt;
 33 #include &lt;SystemConfiguration/SystemConfiguration.h&gt;
 34 #include &lt;Foundation/Foundation.h&gt;
 35 
 36 #include &quot;java_props_macosx.h&quot;
 37 
 38 char *getPosixLocale(int cat) {
 39     char *lc = setlocale(cat, NULL);
 40     if ((lc == NULL) || (strcmp(lc, &quot;C&quot;) == 0)) {
 41         lc = getenv(&quot;LANG&quot;);
 42     }
 43     if (lc == NULL) return NULL;
 44     return strdup(lc);
 45 }
 46 
 47 #define LOCALEIDLENGTH  128
 48 #ifndef kCFCoreFoundationVersionNumber10_11_Max
 49 #define kCFCoreFoundationVersionNumber10_11_Max 1299
 50 #endif
 51 char *getMacOSXLocale(int cat) {
 52     const char* retVal = NULL;
 53     char languageString[LOCALEIDLENGTH];
 54     char localeString[LOCALEIDLENGTH];
 55 
 56     // Since macOS 10.12, there is no separate language selection for
 57     // &quot;format&quot; locale, e.g., date format. Use the preferred language
 58     // for all LC_* categories.
 59     if (kCFCoreFoundationVersionNumber &gt;
 60         kCFCoreFoundationVersionNumber10_11_Max) {
 61         cat = LC_MESSAGES;
 62     }
 63 
 64     switch (cat) {
 65     case LC_MESSAGES:
 66         {
 67             // get preferred language code
 68             CFArrayRef languages = CFLocaleCopyPreferredLanguages();
 69             if (languages == NULL) {
 70                 return NULL;
 71             }
 72             if (CFArrayGetCount(languages) &lt;= 0) {
 73                 CFRelease(languages);
 74                 return NULL;
 75             }
 76 
 77             CFStringRef primaryLanguage = (CFStringRef)CFArrayGetValueAtIndex(languages, 0);
 78             if (primaryLanguage == NULL) {
 79                 CFRelease(languages);
 80                 return NULL;
 81             }
 82             if (CFStringGetCString(primaryLanguage, languageString,
 83                                    LOCALEIDLENGTH, CFStringGetSystemEncoding()) == false) {
 84                 CFRelease(languages);
 85                 return NULL;
 86             }
 87             CFRelease(languages);
 88 
 89             // Explicitly supply region, if there is none
 90             char *hyphenPos = strchr(languageString, &#39;-&#39;);
 91             int langStrLen = strlen(languageString);
 92 
 93             if (hyphenPos == NULL || // languageString contains ISO639 only, e.g., &quot;en&quot;
 94                 languageString + langStrLen - hyphenPos == 5) { // ISO639-ScriptCode, e.g., &quot;en-Latn&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 95                 CFStringGetCString(CFLocaleGetIdentifier(CFLocaleCopyCurrent()),</span>
<span class="line-modified"> 96                                localeString, LOCALEIDLENGTH, CFStringGetSystemEncoding());</span>
<span class="line-modified"> 97                 char *underscorePos = strrchr(localeString, &#39;_&#39;);</span>
<span class="line-modified"> 98                 char *region = NULL;</span>
<span class="line-modified"> 99 </span>
<span class="line-modified">100                 if (underscorePos != NULL) {</span>
<span class="line-modified">101                     region = underscorePos + 1;</span>
<span class="line-modified">102                 }</span>
<span class="line-modified">103 </span>
<span class="line-modified">104                 if (region != NULL) {</span>
<span class="line-modified">105                     strcat(languageString, &quot;-&quot;);</span>
<span class="line-modified">106                     strcat(languageString, region);</span>




107                 }
108             }
109 
110             retVal = languageString;
111         }
112         break;
113 
114     default:
115         {
<a name="4" id="anc4"></a><span class="line-modified">116             if (!CFStringGetCString(CFLocaleGetIdentifier(CFLocaleCopyCurrent()),</span>
<span class="line-modified">117                                     localeString, LOCALEIDLENGTH, CFStringGetSystemEncoding())) {</span>









118                 return NULL;
119             }
<a name="5" id="anc5"></a><span class="line-removed">120 </span>
<span class="line-removed">121             retVal = localeString;</span>
122         }
123         break;
124     }
125 
126     if (retVal != NULL) {
127         // convertToPOSIXLocale() does not expect any variant codes, so ignore
128         // &#39;@&#39; and anything following, if present.
129         char* rmAt = strchr(retVal, &#39;@&#39;);
130         if (rmAt != NULL) {
131             *rmAt = &#39;\0&#39;;
132         }
133         return strdup(convertToPOSIXLocale(retVal));
134     }
135 
136     return NULL;
137 }
138 
139 /* Language IDs use the language designators and (optional) region
140  * and script designators of BCP 47.  So possible formats are:
141  *
142  * &quot;en&quot;         (language designator only)
143  * &quot;haw&quot;        (3-letter lanuage designator)
144  * &quot;en-GB&quot;      (language with alpha-2 region designator)
145  * &quot;es-419&quot;     (language with 3-digit UN M.49 area code)
146  * &quot;zh-Hans&quot;    (language with ISO 15924 script designator)
147  * &quot;zh-Hans-US&quot;  (language with ISO 15924 script designator and region)
148  * &quot;zh-Hans-419&quot; (language with ISO 15924 script designator and UN M.49)
149  *
150  * convert these tags into POSIX conforming locale string, i.e.,
151  * lang{_region}{@script}. e.g., for &quot;zh-Hans-US&quot; into &quot;zh_US@Hans&quot;
152  */
153 const char * convertToPOSIXLocale(const char* src) {
154     char* scriptRegion = strchr(src, &#39;-&#39;);
155     if (scriptRegion != NULL) {
156         int length = strlen(scriptRegion);
157         char* region = strchr(scriptRegion + 1, &#39;-&#39;);
158         char* atMark = NULL;
159 
160         if (region == NULL) {
161             // CFLocaleGetIdentifier() returns &#39;_&#39; before region
162             region = strchr(scriptRegion + 1, &#39;_&#39;);
163         }
164 
165         *scriptRegion = &#39;_&#39;;
166         if (length &gt; 5) {
167             // Region and script both exist.
168             char tmpScript[4];
169             int regionLength = length - 6;
170             atMark = scriptRegion + 1 + regionLength;
171             memcpy(tmpScript, scriptRegion + 1, 4);
172             memmove(scriptRegion + 1, region + 1, regionLength);
173             memcpy(atMark + 1, tmpScript, 4);
174         } else if (length == 5) {
175             // script only
176             atMark = scriptRegion;
177         }
178 
179         if (atMark != NULL) {
180             *atMark = &#39;@&#39;;
181 
182             // assert script code
183             assert(isalpha(atMark[1]) &amp;&amp;
184                    isalpha(atMark[2]) &amp;&amp;
185                    isalpha(atMark[3]) &amp;&amp;
186                    isalpha(atMark[4]));
187         }
188 
189         assert(((length == 3 || length == 8) &amp;&amp;
190             // &#39;_&#39; followed by a 2 character region designator
191                 isalpha(scriptRegion[1]) &amp;&amp;
192                 isalpha(scriptRegion[2])) ||
193                 ((length == 4 || length == 9) &amp;&amp;
194             // &#39;_&#39; followed by a 3-digit UN M.49 area code
195                 isdigit(scriptRegion[1]) &amp;&amp;
196                 isdigit(scriptRegion[2]) &amp;&amp;
197                 isdigit(scriptRegion[3])) ||
198             // &#39;@&#39; followed by a 4 character script code (already validated above)
199                 (length == 5));
200     }
201 
202     return src;
203 }
204 
205 char *setupMacOSXLocale(int cat) {
206     char * ret = getMacOSXLocale(cat);
207 
208     if (ret == NULL) {
209         return getPosixLocale(cat);
210     } else {
211         return ret;
212     }
213 }
214 
<a name="6" id="anc6"></a><span class="line-removed">215 int isInAquaSession() {</span>
<span class="line-removed">216     // environment variable to bypass the aqua session check</span>
<span class="line-removed">217     char *ev = getenv(&quot;AWT_FORCE_HEADFUL&quot;);</span>
<span class="line-removed">218     if (ev &amp;&amp; (strncasecmp(ev, &quot;true&quot;, 4) == 0)) {</span>
<span class="line-removed">219         // if &quot;true&quot; then tell the caller we&#39;re in an Aqua session without actually checking</span>
<span class="line-removed">220         return 1;</span>
<span class="line-removed">221     }</span>
<span class="line-removed">222     // Is the WindowServer available?</span>
<span class="line-removed">223     SecuritySessionId session_id;</span>
<span class="line-removed">224     SessionAttributeBits session_info;</span>
<span class="line-removed">225     OSStatus status = SessionGetInfo(callerSecuritySession, &amp;session_id, &amp;session_info);</span>
<span class="line-removed">226     if (status == noErr) {</span>
<span class="line-removed">227         if (session_info &amp; sessionHasGraphicAccess) {</span>
<span class="line-removed">228             return 1;</span>
<span class="line-removed">229         }</span>
<span class="line-removed">230     }</span>
<span class="line-removed">231     return 0;</span>
<span class="line-removed">232 }</span>
<span class="line-removed">233 </span>
234 // 10.9 SDK does not include the NSOperatingSystemVersion struct.
235 // For now, create our own
236 typedef struct {
237         NSInteger majorVersion;
238         NSInteger minorVersion;
239         NSInteger patchVersion;
240 } OSVerStruct;
241 
242 void setOSNameAndVersion(java_props_t *sprops) {
243     // Hardcode os_name, and fill in os_version
244     sprops-&gt;os_name = strdup(&quot;Mac OS X&quot;);
245 
246     char* osVersionCStr = NULL;
247     // Mac OS 10.9 includes the [NSProcessInfo operatingSystemVersion] function,
248     // but it&#39;s not in the 10.9 SDK.  So, call it via objc_msgSend_stret.
249     if ([[NSProcessInfo processInfo] respondsToSelector:@selector(operatingSystemVersion)]) {
250         OSVerStruct (*procInfoFn)(id rec, SEL sel) = (OSVerStruct(*)(id, SEL))objc_msgSend_stret;
251         OSVerStruct osVer = procInfoFn([NSProcessInfo processInfo],
252                                        @selector(operatingSystemVersion));
253         NSString *nsVerStr;
254         if (osVer.patchVersion == 0) { // Omit trailing &quot;.0&quot;
255             nsVerStr = [NSString stringWithFormat:@&quot;%ld.%ld&quot;,
256                     (long)osVer.majorVersion, (long)osVer.minorVersion];
257         } else {
258             nsVerStr = [NSString stringWithFormat:@&quot;%ld.%ld.%ld&quot;,
259                     (long)osVer.majorVersion, (long)osVer.minorVersion, (long)osVer.patchVersion];
260         }
261         // Copy out the char*
262         osVersionCStr = strdup([nsVerStr UTF8String]);
263     }
264     // Fallback if running on pre-10.9 Mac OS
265     if (osVersionCStr == NULL) {
266         NSDictionary *version = [NSDictionary dictionaryWithContentsOfFile :
267                                  @&quot;/System/Library/CoreServices/SystemVersion.plist&quot;];
268         if (version != NULL) {
269             NSString *nsVerStr = [version objectForKey : @&quot;ProductVersion&quot;];
270             if (nsVerStr != NULL) {
271                 osVersionCStr = strdup([nsVerStr UTF8String]);
272             }
273         }
274     }
275     if (osVersionCStr == NULL) {
276         osVersionCStr = strdup(&quot;Unknown&quot;);
277     }
278     sprops-&gt;os_version = osVersionCStr;
279 }
280 
281 
282 static Boolean getProxyInfoForProtocol(CFDictionaryRef inDict, CFStringRef inEnabledKey,
283                                        CFStringRef inHostKey, CFStringRef inPortKey,
284                                        CFStringRef *outProxyHost, int *ioProxyPort) {
285     /* See if the proxy is enabled. */
286     CFNumberRef cf_enabled = CFDictionaryGetValue(inDict, inEnabledKey);
287     if (cf_enabled == NULL) {
288         return false;
289     }
290 
291     int isEnabled = false;
292     if (!CFNumberGetValue(cf_enabled, kCFNumberIntType, &amp;isEnabled)) {
293         return isEnabled;
294     }
295 
296     if (!isEnabled) return false;
297     *outProxyHost = CFDictionaryGetValue(inDict, inHostKey);
298 
299     // If cf_host is null, that means the checkbox is set,
300     //   but no host was entered. We&#39;ll treat that as NOT ENABLED.
301     // If cf_port is null or cf_port isn&#39;t a number, that means
302     //   no port number was entered. Treat this as ENABLED with the
303     //   protocol&#39;s default port.
304     if (*outProxyHost == NULL) {
305         return false;
306     }
307 
308     if (CFStringGetLength(*outProxyHost) == 0) {
309         return false;
310     }
311 
312     int newPort = 0;
313     CFNumberRef cf_port = NULL;
314     if ((cf_port = CFDictionaryGetValue(inDict, inPortKey)) != NULL &amp;&amp;
315         CFNumberGetValue(cf_port, kCFNumberIntType, &amp;newPort) &amp;&amp;
316         newPort &gt; 0) {
317         *ioProxyPort = newPort;
318     } else {
319         // bad port or no port - leave *ioProxyPort unchanged
320     }
321 
322     return true;
323 }
324 
325 static char *createUTF8CString(const CFStringRef theString) {
326     if (theString == NULL) return NULL;
327 
328     const CFIndex stringLength = CFStringGetLength(theString);
329     const CFIndex bufSize = CFStringGetMaximumSizeForEncoding(stringLength, kCFStringEncodingUTF8) + 1;
330     char *returnVal = (char *)malloc(bufSize);
331 
332     if (CFStringGetCString(theString, returnVal, bufSize, kCFStringEncodingUTF8)) {
333         return returnVal;
334     }
335 
336     free(returnVal);
337     return NULL;
338 }
339 
340 // Return TRUE if str is a syntactically valid IP address.
341 // Using inet_pton() instead of inet_aton() for IPv6 support.
342 // len is only a hint; cstr must still be nul-terminated
343 static int looksLikeIPAddress(char *cstr, size_t len) {
344     if (len == 0  ||  (len == 1 &amp;&amp; cstr[0] == &#39;.&#39;)) return FALSE;
345 
346     char dst[16]; // big enough for INET6
347     return (1 == inet_pton(AF_INET, cstr, dst)  ||
348             1 == inet_pton(AF_INET6, cstr, dst));
349 }
350 
351 
352 
353 // Convert Mac OS X proxy exception entry to Java syntax.
354 // See Radar #3441134 for details.
355 // Returns NULL if this exception should be ignored by Java.
356 // May generate a string with multiple exceptions separated by &#39;|&#39;.
357 static char * createConvertedException(CFStringRef cf_original) {
358     // This is done with char* instead of CFString because inet_pton()
359     // needs a C string.
360     char *c_exception = createUTF8CString(cf_original);
361     if (!c_exception) return NULL;
362 
363     int c_len = strlen(c_exception);
364 
365     // 1. sanitize exception prefix
366     if (c_len &gt;= 1  &amp;&amp;  0 == strncmp(c_exception, &quot;.&quot;, 1)) {
367         memmove(c_exception, c_exception+1, c_len);
368         c_len -= 1;
369     } else if (c_len &gt;= 2  &amp;&amp;  0 == strncmp(c_exception, &quot;*.&quot;, 2)) {
370         memmove(c_exception, c_exception+2, c_len-1);
371         c_len -= 2;
372     }
373 
374     // 2. pre-reject other exception wildcards
375     if (strchr(c_exception, &#39;*&#39;)) {
376         free(c_exception);
377         return NULL;
378     }
379 
380     // 3. no IP wildcarding
381     if (looksLikeIPAddress(c_exception, c_len)) {
382         return c_exception;
383     }
384 
385     // 4. allow domain suffixes
386     // c_exception is now &quot;str\0&quot; - change to &quot;str|*.str\0&quot;
387     c_exception = reallocf(c_exception, c_len+3+c_len+1);
388     if (!c_exception) return NULL;
389 
390     strncpy(c_exception+c_len, &quot;|*.&quot;, 3);
391     strncpy(c_exception+c_len+3, c_exception, c_len);
392     c_exception[c_len+3+c_len] = &#39;\0&#39;;
393     return c_exception;
394 }
395 
396 /*
397  * Method for fetching the user.home path and storing it in the property list.
398  * For signed .apps running in the Mac App Sandbox, user.home is set to the
399  * app&#39;s sandbox container.
400  */
401 void setUserHome(java_props_t *sprops) {
402     if (sprops == NULL) { return; }
403     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
404     sprops-&gt;user_home = createUTF8CString((CFStringRef)NSHomeDirectory());
405     [pool drain];
406 }
407 
408 /*
409  * Method for fetching proxy info and storing it in the property list.
410  */
411 void setProxyProperties(java_props_t *sProps) {
412     if (sProps == NULL) return;
413 
414     char buf[16];    /* Used for %d of an int - 16 is plenty */
415     CFStringRef
416     cf_httpHost = NULL,
417     cf_httpsHost = NULL,
418     cf_ftpHost = NULL,
419     cf_socksHost = NULL;
420     int
421     httpPort = 80, // Default proxy port values
422     httpsPort = 443,
423     ftpPort = 21,
424     socksPort = 1080;
425 
426     CFDictionaryRef dict = SCDynamicStoreCopyProxies(NULL);
427     if (dict == NULL) return;
428 
429     /* Read the proxy exceptions list */
430     CFArrayRef cf_list = CFDictionaryGetValue(dict, kSCPropNetProxiesExceptionsList);
431 
432     CFMutableStringRef cf_exceptionList = NULL;
433     if (cf_list != NULL) {
434         CFIndex len = CFArrayGetCount(cf_list), idx;
435 
436         cf_exceptionList = CFStringCreateMutable(NULL, 0);
437         for (idx = (CFIndex)0; idx &lt; len; idx++) {
438             CFStringRef cf_ehost;
439             if ((cf_ehost = CFArrayGetValueAtIndex(cf_list, idx))) {
440                 /* Convert this exception from Mac OS X syntax to Java syntax.
441                  See Radar #3441134 for details. This may generate a string
442                  with multiple Java exceptions separated by &#39;|&#39;. */
443                 char *c_exception = createConvertedException(cf_ehost);
444                 if (c_exception) {
445                     /* Append the host to the list of exclusions. */
446                     if (CFStringGetLength(cf_exceptionList) &gt; 0) {
447                         CFStringAppendCString(cf_exceptionList, &quot;|&quot;, kCFStringEncodingMacRoman);
448                     }
449                     CFStringAppendCString(cf_exceptionList, c_exception, kCFStringEncodingMacRoman);
450                     free(c_exception);
451                 }
452             }
453         }
454     }
455 
456     if (cf_exceptionList != NULL) {
457         if (CFStringGetLength(cf_exceptionList) &gt; 0) {
458             sProps-&gt;exceptionList = createUTF8CString(cf_exceptionList);
459         }
460         CFRelease(cf_exceptionList);
461     }
462 
463 #define CHECK_PROXY(protocol, PROTOCOL)                                     \
464     sProps-&gt;protocol##ProxyEnabled =                                        \
465     getProxyInfoForProtocol(dict, kSCPropNetProxies##PROTOCOL##Enable,      \
466     kSCPropNetProxies##PROTOCOL##Proxy,         \
467     kSCPropNetProxies##PROTOCOL##Port,          \
468     &amp;cf_##protocol##Host, &amp;protocol##Port);     \
469     if (sProps-&gt;protocol##ProxyEnabled) {                                   \
470         sProps-&gt;protocol##Host = createUTF8CString(cf_##protocol##Host);    \
471         snprintf(buf, sizeof(buf), &quot;%d&quot;, protocol##Port);                   \
472         sProps-&gt;protocol##Port = malloc(strlen(buf) + 1);                   \
473         strcpy(sProps-&gt;protocol##Port, buf);                                \
474     }
475 
476     CHECK_PROXY(http, HTTP);
477     CHECK_PROXY(https, HTTPS);
478     CHECK_PROXY(ftp, FTP);
479     CHECK_PROXY(socks, SOCKS);
480 
481 #undef CHECK_PROXY
482 
483     CFRelease(dict);
484 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
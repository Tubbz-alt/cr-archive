<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/String.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StrictMath.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringBuffer.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/String.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -34,10 +34,11 @@</span>
  import java.nio.charset.Charset;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Comparator;
  import java.util.Formatter;
<span class="udiff-line-added">+ import java.util.List;</span>
  import java.util.Locale;
  import java.util.Objects;
  import java.util.Optional;
  import java.util.Spliterator;
  import java.util.StringJoiner;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73,11 +74,11 @@</span>
   * Here are some more examples of how strings can be used:
   * &lt;blockquote&gt;&lt;pre&gt;
   *     System.out.println(&quot;abc&quot;);
   *     String cde = &quot;cde&quot;;
   *     System.out.println(&quot;abc&quot; + cde);
<span class="udiff-line-modified-removed">-  *     String c = &quot;abc&quot;.substring(2,3);</span>
<span class="udiff-line-modified-added">+  *     String c = &quot;abc&quot;.substring(2, 3);</span>
   *     String d = cde.substring(1, 2);
   * &lt;/pre&gt;&lt;/blockquote&gt;
   * &lt;p&gt;
   * The class {@code String} includes methods for examining
   * individual characters of the sequence, for comparing strings, for
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162,11 +163,18 @@</span>
      private final byte coder;
  
      /** Cache the hash code for the string */
      private int hash; // Default to 0
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Cache if the hash has been calculated as actually being zero, enabling</span>
<span class="udiff-line-added">+      * us to avoid recalculating this.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private boolean hashIsZero; // Default to false;</span>
<span class="udiff-line-added">+ </span>
      /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = -6849794470754667710L;
  
      /**
       * If String compaction is disabled, the bytes in {@code value} are
       * always encoded in UTF16.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -215,10 +223,11 @@</span>
       *
       * A String instance is written into an ObjectOutputStream according to
       * &lt;a href=&quot;{@docRoot}/../specs/serialization/protocol.html#stream-elements&quot;&gt;
       * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private static final ObjectStreamField[] serialPersistentFields =
          new ObjectStreamField[0];
  
      /**
       * Initializes a newly created {@code String} object so that it represents
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -691,11 +700,11 @@</span>
       * value is returned.
       *
       * @param      index   the index of the {@code char} value.
       * @return     the {@code char} value at the specified index of this string.
       *             The first {@code char} value is at index {@code 0}.
<span class="udiff-line-modified-removed">-      * @exception  IndexOutOfBoundsException  if the {@code index}</span>
<span class="udiff-line-modified-added">+      * @throws     IndexOutOfBoundsException  if the {@code index}</span>
       *             argument is negative or not less than the length of this
       *             string.
       */
      public char charAt(int index) {
          if (isLatin1()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -720,11 +729,11 @@</span>
       * the {@code char} value at the given index is returned.
       *
       * @param      index the index to the {@code char} values
       * @return     the code point value of the character at the
       *             {@code index}
<span class="udiff-line-modified-removed">-      * @exception  IndexOutOfBoundsException  if the {@code index}</span>
<span class="udiff-line-modified-added">+      * @throws     IndexOutOfBoundsException  if the {@code index}</span>
       *             argument is negative or not less than the length of this
       *             string.
       * @since      1.5
       */
      public int codePointAt(int index) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -752,11 +761,11 @@</span>
       * 1} is an unpaired low-surrogate or a high-surrogate, the
       * surrogate value is returned.
       *
       * @param     index the index following the code point that should be returned
       * @return    the Unicode code point value before the given index.
<span class="udiff-line-modified-removed">-      * @exception IndexOutOfBoundsException if the {@code index}</span>
<span class="udiff-line-modified-added">+      * @throws    IndexOutOfBoundsException if the {@code index}</span>
       *            argument is less than 1 or greater than the length
       *            of this string.
       * @since     1.5
       */
      public int codePointBefore(int index) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -783,11 +792,11 @@</span>
       * the text range.
       * @param endIndex the index after the last {@code char} of
       * the text range.
       * @return the number of Unicode code points in the specified text
       * range
<span class="udiff-line-modified-removed">-      * @exception IndexOutOfBoundsException if the</span>
<span class="udiff-line-modified-added">+      * @throws    IndexOutOfBoundsException if the</span>
       * {@code beginIndex} is negative, or {@code endIndex}
       * is larger than the length of this {@code String}, or
       * {@code beginIndex} is larger than {@code endIndex}.
       * @since  1.5
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -810,11 +819,11 @@</span>
       * {@code codePointOffset} count as one code point each.
       *
       * @param index the index to be offset
       * @param codePointOffset the offset in code points
       * @return the index within this {@code String}
<span class="udiff-line-modified-removed">-      * @exception IndexOutOfBoundsException if {@code index}</span>
<span class="udiff-line-modified-added">+      * @throws    IndexOutOfBoundsException if {@code index}</span>
       *   is negative or larger then the length of this
       *   {@code String}, or if {@code codePointOffset} is positive
       *   and the substring starting with {@code index} has fewer
       *   than {@code codePointOffset} code points,
       *   or if {@code codePointOffset} is negative and the substring
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -847,11 +856,11 @@</span>
       *                        to copy.
       * @param      srcEnd     index after the last character in the string
       *                        to copy.
       * @param      dst        the destination array.
       * @param      dstBegin   the start offset in the destination array.
<span class="udiff-line-modified-removed">-      * @exception IndexOutOfBoundsException If any of the following</span>
<span class="udiff-line-modified-added">+      * @throws    IndexOutOfBoundsException If any of the following</span>
       *            is true:
       *            &lt;ul&gt;&lt;li&gt;{@code srcBegin} is negative.
       *            &lt;li&gt;{@code srcBegin} is greater than {@code srcEnd}
       *            &lt;li&gt;{@code srcEnd} is greater than the length of this
       *                string
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1012,13 +1021,12 @@</span>
          if (this == anObject) {
              return true;
          }
          if (anObject instanceof String) {
              String aString = (String)anObject;
<span class="udiff-line-modified-removed">-             if (coder() == aString.coder()) {</span>
<span class="udiff-line-modified-removed">-                 return isLatin1() ? StringLatin1.equals(value, aString.value)</span>
<span class="udiff-line-removed">-                                   : StringUTF16.equals(value, aString.value);</span>
<span class="udiff-line-modified-added">+             if (!COMPACT_STRINGS || this.coder == aString.coder) {</span>
<span class="udiff-line-modified-added">+                 return StringLatin1.equals(value, aString.value);</span>
              }
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1049,19 +1057,20 @@</span>
          if (len != sb.length()) {
              return false;
          }
          byte v1[] = value;
          byte v2[] = sb.getValue();
<span class="udiff-line-modified-removed">-         if (coder() == sb.getCoder()) {</span>
<span class="udiff-line-modified-added">+         byte coder = coder();</span>
<span class="udiff-line-added">+         if (coder == sb.getCoder()) {</span>
              int n = v1.length;
              for (int i = 0; i &lt; n; i++) {
                  if (v1[i] != v2[i]) {
                      return false;
                  }
              }
          } else {
<span class="udiff-line-modified-removed">-             if (!isLatin1()) {  // utf16 str and latin1 abs can never be &quot;equal&quot;</span>
<span class="udiff-line-modified-added">+             if (coder != LATIN1) {  // utf16 str and latin1 abs can never be &quot;equal&quot;</span>
                  return false;
              }
              return StringUTF16.contentEquals(v1, v2, len);
          }
          return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1201,16 +1210,17 @@</span>
       *          lexicographically greater than the string argument.
       */
      public int compareTo(String anotherString) {
          byte v1[] = value;
          byte v2[] = anotherString.value;
<span class="udiff-line-modified-removed">-         if (coder() == anotherString.coder()) {</span>
<span class="udiff-line-modified-removed">-             return isLatin1() ? StringLatin1.compareTo(v1, v2)</span>
<span class="udiff-line-modified-removed">-                               : StringUTF16.compareTo(v1, v2);</span>
<span class="udiff-line-modified-added">+         byte coder = coder();</span>
<span class="udiff-line-modified-added">+         if (coder == anotherString.coder()) {</span>
<span class="udiff-line-modified-added">+             return coder == LATIN1 ? StringLatin1.compareTo(v1, v2)</span>
<span class="udiff-line-added">+                                    : StringUTF16.compareTo(v1, v2);</span>
          }
<span class="udiff-line-modified-removed">-         return isLatin1() ? StringLatin1.compareToUTF16(v1, v2)</span>
<span class="udiff-line-modified-removed">-                           : StringUTF16.compareToLatin1(v1, v2);</span>
<span class="udiff-line-modified-added">+         return coder == LATIN1 ? StringLatin1.compareToUTF16(v1, v2)</span>
<span class="udiff-line-modified-added">+                                : StringUTF16.compareToLatin1(v1, v2);</span>
       }
  
      /**
       * A Comparator that orders {@code String} objects as by
       * {@code compareToIgnoreCase}. This comparator is serializable.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1225,24 +1235,27 @@</span>
      public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER
                                           = new CaseInsensitiveComparator();
      private static class CaseInsensitiveComparator
              implements Comparator&lt;String&gt;, java.io.Serializable {
          // use serialVersionUID from JDK 1.2.2 for interoperability
<span class="udiff-line-added">+         @java.io.Serial</span>
          private static final long serialVersionUID = 8575799808933029326L;
  
          public int compare(String s1, String s2) {
              byte v1[] = s1.value;
              byte v2[] = s2.value;
<span class="udiff-line-modified-removed">-             if (s1.coder() == s2.coder()) {</span>
<span class="udiff-line-modified-removed">-                 return s1.isLatin1() ? StringLatin1.compareToCI(v1, v2)</span>
<span class="udiff-line-modified-removed">-                                      : StringUTF16.compareToCI(v1, v2);</span>
<span class="udiff-line-modified-added">+             byte coder = s1.coder();</span>
<span class="udiff-line-modified-added">+             if (coder == s2.coder()) {</span>
<span class="udiff-line-modified-added">+                 return coder == LATIN1 ? StringLatin1.compareToCI(v1, v2)</span>
<span class="udiff-line-added">+                                        : StringUTF16.compareToCI(v1, v2);</span>
              }
<span class="udiff-line-modified-removed">-             return s1.isLatin1() ? StringLatin1.compareToCI_UTF16(v1, v2)</span>
<span class="udiff-line-modified-removed">-                                  : StringUTF16.compareToCI_Latin1(v1, v2);</span>
<span class="udiff-line-modified-added">+             return coder == LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)</span>
<span class="udiff-line-modified-added">+                                    : StringUTF16.compareToCI_Latin1(v1, v2);</span>
          }
  
          /** Replaces the de-serialized object. */
<span class="udiff-line-added">+         @java.io.Serial</span>
          private Object readResolve() { return CASE_INSENSITIVE_ORDER; }
      }
  
      /**
       * Compares two strings lexicographically, ignoring case
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1309,11 +1322,12 @@</span>
          if ((ooffset &lt; 0) || (toffset &lt; 0) ||
               (toffset &gt; (long)length() - len) ||
               (ooffset &gt; (long)other.length() - len)) {
              return false;
          }
<span class="udiff-line-modified-removed">-         if (coder() == other.coder()) {</span>
<span class="udiff-line-modified-added">+         byte coder = coder();</span>
<span class="udiff-line-added">+         if (coder == other.coder()) {</span>
              if (!isLatin1() &amp;&amp; (len &gt; 0)) {
                  toffset = toffset &lt;&lt; 1;
                  ooffset = ooffset &lt;&lt; 1;
                  len = len &lt;&lt; 1;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1321,11 +1335,11 @@</span>
                  if (tv[toffset++] != ov[ooffset++]) {
                      return false;
                  }
              }
          } else {
<span class="udiff-line-modified-removed">-             if (coder() == LATIN1) {</span>
<span class="udiff-line-modified-added">+             if (coder == LATIN1) {</span>
                  while (len-- &gt; 0) {
                      if (StringLatin1.getChar(tv, toffset++) !=
                          StringUTF16.getChar(ov, ooffset++)) {
                          return false;
                      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1403,16 +1417,17 @@</span>
                  || (ooffset &gt; (long)other.length() - len)) {
              return false;
          }
          byte tv[] = value;
          byte ov[] = other.value;
<span class="udiff-line-modified-removed">-         if (coder() == other.coder()) {</span>
<span class="udiff-line-modified-removed">-             return isLatin1()</span>
<span class="udiff-line-modified-added">+         byte coder = coder();</span>
<span class="udiff-line-modified-added">+         if (coder == other.coder()) {</span>
<span class="udiff-line-added">+             return coder == LATIN1</span>
                ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)
                : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);
          }
<span class="udiff-line-modified-removed">-         return isLatin1()</span>
<span class="udiff-line-modified-added">+         return coder == LATIN1</span>
                ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)
                : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1439,19 +1454,20 @@</span>
          }
          byte ta[] = value;
          byte pa[] = prefix.value;
          int po = 0;
          int pc = pa.length;
<span class="udiff-line-modified-removed">-         if (coder() == prefix.coder()) {</span>
<span class="udiff-line-modified-removed">-             int to = isLatin1() ? toffset : toffset &lt;&lt; 1;</span>
<span class="udiff-line-modified-added">+         byte coder = coder();</span>
<span class="udiff-line-modified-added">+         if (coder == prefix.coder()) {</span>
<span class="udiff-line-added">+             int to = (coder == LATIN1) ? toffset : toffset &lt;&lt; 1;</span>
              while (po &lt; pc) {
                  if (ta[to++] != pa[po++]) {
                      return false;
                  }
              }
          } else {
<span class="udiff-line-modified-removed">-             if (isLatin1()) {  // &amp;&amp; pcoder == UTF16</span>
<span class="udiff-line-modified-added">+             if (coder == LATIN1) {  // &amp;&amp; pcoder == UTF16</span>
                  return false;
              }
              // coder == UTF16 &amp;&amp; pcoder == LATIN1)
              while (po &lt; pc) {
                  if (StringUTF16.getChar(ta, toffset++) != (pa[po++] &amp; 0xff)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1506,14 +1522,27 @@</span>
       * (The hash value of the empty string is zero.)
       *
       * @return  a hash code value for this object.
       */
      public int hashCode() {
<span class="udiff-line-added">+         // The hash or hashIsZero fields are subject to a benign data race,</span>
<span class="udiff-line-added">+         // making it crucial to ensure that any observable result of the</span>
<span class="udiff-line-added">+         // calculation in this method stays correct under any possible read of</span>
<span class="udiff-line-added">+         // these fields. Necessary restrictions to allow this to be correct</span>
<span class="udiff-line-added">+         // without explicit memory fences or similar concurrency primitives is</span>
<span class="udiff-line-added">+         // that we can ever only write to one of these two fields for a given</span>
<span class="udiff-line-added">+         // String instance, and that the computation is idempotent and derived</span>
<span class="udiff-line-added">+         // from immutable state</span>
          int h = hash;
<span class="udiff-line-modified-removed">-         if (h == 0 &amp;&amp; value.length &gt; 0) {</span>
<span class="udiff-line-modified-removed">-             hash = h = isLatin1() ? StringLatin1.hashCode(value)</span>
<span class="udiff-line-modified-removed">-                                   : StringUTF16.hashCode(value);</span>
<span class="udiff-line-modified-added">+         if (h == 0 &amp;&amp; !hashIsZero) {</span>
<span class="udiff-line-modified-added">+             h = isLatin1() ? StringLatin1.hashCode(value)</span>
<span class="udiff-line-modified-added">+                            : StringUTF16.hashCode(value);</span>
<span class="udiff-line-added">+             if (h == 0) {</span>
<span class="udiff-line-added">+                 hashIsZero = true;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 hash = h;</span>
<span class="udiff-line-added">+             }</span>
          }
          return h;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1667,15 +1696,16 @@</span>
       * @param   str   the substring to search for.
       * @return  the index of the first occurrence of the specified substring,
       *          or {@code -1} if there is no such occurrence.
       */
      public int indexOf(String str) {
<span class="udiff-line-modified-removed">-         if (coder() == str.coder()) {</span>
<span class="udiff-line-modified-added">+         byte coder = coder();</span>
<span class="udiff-line-added">+         if (coder == str.coder()) {</span>
              return isLatin1() ? StringLatin1.indexOf(value, str.value)
                                : StringUTF16.indexOf(value, str.value);
          }
<span class="udiff-line-modified-removed">-         if (coder() == LATIN1) {  // str.coder == UTF16</span>
<span class="udiff-line-modified-added">+         if (coder == LATIN1) {  // str.coder == UTF16</span>
              return -1;
          }
          return StringUTF16.indexOfLatin1(value, str.value);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1835,27 +1865,16 @@</span>
       * &quot;emptiness&quot;.substring(9) returns &quot;&quot; (an empty string)
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @param      beginIndex   the beginning index, inclusive.
       * @return     the specified substring.
<span class="udiff-line-modified-removed">-      * @exception  IndexOutOfBoundsException  if</span>
<span class="udiff-line-modified-added">+      * @throws     IndexOutOfBoundsException  if</span>
       *             {@code beginIndex} is negative or larger than the
       *             length of this {@code String} object.
       */
      public String substring(int beginIndex) {
<span class="udiff-line-modified-removed">-         if (beginIndex &lt; 0) {</span>
<span class="udiff-line-removed">-             throw new StringIndexOutOfBoundsException(beginIndex);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         int subLen = length() - beginIndex;</span>
<span class="udiff-line-removed">-         if (subLen &lt; 0) {</span>
<span class="udiff-line-removed">-             throw new StringIndexOutOfBoundsException(subLen);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (beginIndex == 0) {</span>
<span class="udiff-line-removed">-             return this;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)</span>
<span class="udiff-line-removed">-                           : StringUTF16.newString(value, beginIndex, subLen);</span>
<span class="udiff-line-modified-added">+         return substring(beginIndex, length());</span>
      }
  
      /**
       * Returns a string that is a substring of this string. The
       * substring begins at the specified {@code beginIndex} and
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1869,11 +1888,11 @@</span>
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
       * @param      beginIndex   the beginning index, inclusive.
       * @param      endIndex     the ending index, exclusive.
       * @return     the specified substring.
<span class="udiff-line-modified-removed">-      * @exception  IndexOutOfBoundsException  if the</span>
<span class="udiff-line-modified-added">+      * @throws     IndexOutOfBoundsException  if the</span>
       *             {@code beginIndex} is negative, or
       *             {@code endIndex} is larger than the length of
       *             this {@code String} object, or
       *             {@code beginIndex} is larger than
       *             {@code endIndex}.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1944,24 +1963,11 @@</span>
       */
      public String concat(String str) {
          if (str.isEmpty()) {
              return this;
          }
<span class="udiff-line-modified-removed">-         if (coder() == str.coder()) {</span>
<span class="udiff-line-removed">-             byte[] val = this.value;</span>
<span class="udiff-line-removed">-             byte[] oval = str.value;</span>
<span class="udiff-line-removed">-             int len = val.length + oval.length;</span>
<span class="udiff-line-removed">-             byte[] buf = Arrays.copyOf(val, len);</span>
<span class="udiff-line-removed">-             System.arraycopy(oval, 0, buf, val.length, oval.length);</span>
<span class="udiff-line-removed">-             return new String(buf, coder);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         int len = length();</span>
<span class="udiff-line-removed">-         int olen = str.length();</span>
<span class="udiff-line-removed">-         byte[] buf = StringUTF16.newBytesFor(len + olen);</span>
<span class="udiff-line-removed">-         getBytes(buf, 0, UTF16);</span>
<span class="udiff-line-removed">-         str.getBytes(buf, len, UTF16);</span>
<span class="udiff-line-removed">-         return new String(buf, UTF16);</span>
<span class="udiff-line-modified-added">+         return StringConcatHelper.simpleConcat(this, str);</span>
      }
  
      /**
       * Returns a string resulting from replacing all occurrences of
       * {@code oldChar} in this string with {@code newChar}.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2146,31 +2152,52 @@</span>
       * @param  replacement The replacement sequence of char values
       * @return  The resulting string
       * @since 1.5
       */
      public String replace(CharSequence target, CharSequence replacement) {
<span class="udiff-line-modified-removed">-         String tgtStr = target.toString();</span>
<span class="udiff-line-modified-added">+         String trgtStr = target.toString();</span>
          String replStr = replacement.toString();
<span class="udiff-line-removed">-         int j = indexOf(tgtStr);</span>
<span class="udiff-line-removed">-         if (j &lt; 0) {</span>
<span class="udiff-line-removed">-             return this;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         int tgtLen = tgtStr.length();</span>
<span class="udiff-line-removed">-         int tgtLen1 = Math.max(tgtLen, 1);</span>
          int thisLen = length();
<span class="udiff-line-added">+         int trgtLen = trgtStr.length();</span>
<span class="udiff-line-added">+         int replLen = replStr.length();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (trgtLen &gt; 0) {</span>
<span class="udiff-line-added">+             if (trgtLen == 1 &amp;&amp; replLen == 1) {</span>
<span class="udiff-line-added">+                 return replace(trgtStr.charAt(0), replStr.charAt(0));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             boolean thisIsLatin1 = this.isLatin1();</span>
<span class="udiff-line-added">+             boolean trgtIsLatin1 = trgtStr.isLatin1();</span>
<span class="udiff-line-added">+             boolean replIsLatin1 = replStr.isLatin1();</span>
<span class="udiff-line-added">+             String ret = (thisIsLatin1 &amp;&amp; trgtIsLatin1 &amp;&amp; replIsLatin1)</span>
<span class="udiff-line-added">+                     ? StringLatin1.replace(value, thisLen,</span>
<span class="udiff-line-added">+                                            trgtStr.value, trgtLen,</span>
<span class="udiff-line-added">+                                            replStr.value, replLen)</span>
<span class="udiff-line-added">+                     : StringUTF16.replace(value, thisLen, thisIsLatin1,</span>
<span class="udiff-line-added">+                                           trgtStr.value, trgtLen, trgtIsLatin1,</span>
<span class="udiff-line-added">+                                           replStr.value, replLen, replIsLatin1);</span>
<span class="udiff-line-added">+             if (ret != null) {</span>
<span class="udiff-line-added">+                 return ret;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return this;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         } else { // trgtLen == 0</span>
<span class="udiff-line-added">+             int resultLen;</span>
<span class="udiff-line-added">+             try {</span>
<span class="udiff-line-added">+                 resultLen = Math.addExact(thisLen, Math.multiplyExact(</span>
<span class="udiff-line-added">+                         Math.addExact(thisLen, 1), replLen));</span>
<span class="udiff-line-added">+             } catch (ArithmeticException ignored) {</span>
<span class="udiff-line-added">+                 throw new OutOfMemoryError();</span>
<span class="udiff-line-added">+             }</span>
  
<span class="udiff-line-modified-removed">-         int newLenHint = thisLen - tgtLen + replStr.length();</span>
<span class="udiff-line-modified-removed">-         if (newLenHint &lt; 0) {</span>
<span class="udiff-line-modified-removed">-             throw new OutOfMemoryError();</span>
<span class="udiff-line-modified-added">+             StringBuilder sb = new StringBuilder(resultLen);</span>
<span class="udiff-line-modified-added">+             sb.append(replStr);</span>
<span class="udiff-line-modified-added">+             for (int i = 0; i &lt; thisLen; ++i) {</span>
<span class="udiff-line-added">+                 sb.append(charAt(i)).append(replStr);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return sb.toString();</span>
          }
<span class="udiff-line-removed">-         StringBuilder sb = new StringBuilder(newLenHint);</span>
<span class="udiff-line-removed">-         int i = 0;</span>
<span class="udiff-line-removed">-         do {</span>
<span class="udiff-line-removed">-             sb.append(this, i, j).append(replStr);</span>
<span class="udiff-line-removed">-             i = j + tgtLen;</span>
<span class="udiff-line-removed">-         } while (j &lt; thisLen &amp;&amp; (j = indexOf(tgtStr, j + tgtLen1)) &gt; 0);</span>
<span class="udiff-line-removed">-         return sb.append(this, i, thisLen).toString();</span>
      }
  
      /**
       * Splits this string around matches of the given
       * &lt;a href=&quot;../util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt;.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2655,25 +2682,25 @@</span>
          return ret == null ? this : ret;
      }
  
      /**
       * Returns a string whose value is this string, with all leading
<span class="udiff-line-modified-removed">-      * and trailing {@link Character#isWhitespace(int) white space}</span>
<span class="udiff-line-modified-added">+      * and trailing {@linkplain Character#isWhitespace(int) white space}</span>
       * removed.
       * &lt;p&gt;
       * If this {@code String} object represents an empty string,
       * or if all code points in this string are
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space}, then an empty string</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space}, then an empty string</span>
       * is returned.
       * &lt;p&gt;
       * Otherwise, returns a substring of this string beginning with the first
<span class="udiff-line-modified-removed">-      * code point that is not a {@link Character#isWhitespace(int) white space}</span>
<span class="udiff-line-modified-added">+      * code point that is not a {@linkplain Character#isWhitespace(int) white space}</span>
       * up to and including the last code point that is not a
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space}.</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space}.</span>
       * &lt;p&gt;
       * This method may be used to strip
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space} from</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space} from</span>
       * the beginning and end of a string.
       *
       * @return  a string whose value is this string, with all leading
       *          and trailing white space removed
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2687,23 +2714,23 @@</span>
          return ret == null ? this : ret;
      }
  
      /**
       * Returns a string whose value is this string, with all leading
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space} removed.</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space} removed.</span>
       * &lt;p&gt;
       * If this {@code String} object represents an empty string,
       * or if all code points in this string are
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space}, then an empty string</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space}, then an empty string</span>
       * is returned.
       * &lt;p&gt;
       * Otherwise, returns a substring of this string beginning with the first
<span class="udiff-line-modified-removed">-      * code point that is not a {@link Character#isWhitespace(int) white space}</span>
<span class="udiff-line-modified-added">+      * code point that is not a {@linkplain Character#isWhitespace(int) white space}</span>
       * up to and including the last code point of this string.
       * &lt;p&gt;
       * This method may be used to trim
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space} from</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space} from</span>
       * the beginning of a string.
       *
       * @return  a string whose value is this string, with all leading white
       *          space removed
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2717,23 +2744,23 @@</span>
          return ret == null ? this : ret;
      }
  
      /**
       * Returns a string whose value is this string, with all trailing
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space} removed.</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space} removed.</span>
       * &lt;p&gt;
       * If this {@code String} object represents an empty string,
       * or if all characters in this string are
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space}, then an empty string</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space}, then an empty string</span>
       * is returned.
       * &lt;p&gt;
       * Otherwise, returns a substring of this string beginning with the first
       * code point of this string up to and including the last code point
<span class="udiff-line-modified-removed">-      * that is not a {@link Character#isWhitespace(int) white space}.</span>
<span class="udiff-line-modified-added">+      * that is not a {@linkplain Character#isWhitespace(int) white space}.</span>
       * &lt;p&gt;
       * This method may be used to trim
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space} from</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space} from</span>
       * the end of a string.
       *
       * @return  a string whose value is this string, with all trailing white
       *          space removed
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2747,30 +2774,25 @@</span>
          return ret == null ? this : ret;
      }
  
      /**
       * Returns {@code true} if the string is empty or contains only
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space} codepoints,</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space} codepoints,</span>
       * otherwise {@code false}.
       *
       * @return {@code true} if the string is empty or contains only
<span class="udiff-line-modified-removed">-      *         {@link Character#isWhitespace(int) white space} codepoints,</span>
<span class="udiff-line-modified-added">+      *         {@linkplain Character#isWhitespace(int) white space} codepoints,</span>
       *         otherwise {@code false}
       *
       * @see Character#isWhitespace(int)
       *
       * @since 11
       */
      public boolean isBlank() {
          return indexOfNonWhitespace() == length();
      }
  
<span class="udiff-line-removed">-     private Stream&lt;String&gt; lines(int maxLeading, int maxTrailing) {</span>
<span class="udiff-line-removed">-         return isLatin1() ? StringLatin1.lines(value, maxLeading, maxTrailing)</span>
<span class="udiff-line-removed">-                           : StringUTF16.lines(value, maxLeading, maxTrailing);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * Returns a stream of lines extracted from this string,
       * separated by line terminators.
       * &lt;p&gt;
       * A &lt;i&gt;line terminator&lt;/i&gt; is one of the following:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2798,11 +2820,11 @@</span>
       * @return  the stream of lines extracted from this string
       *
       * @since 11
       */
      public Stream&lt;String&gt; lines() {
<span class="udiff-line-modified-removed">-         return lines(0, 0);</span>
<span class="udiff-line-modified-added">+         return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);</span>
      }
  
      /**
       * Adjusts the indentation of each line of this string based on the value of
       * {@code n}, and normalizes line termination characters.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2814,23 +2836,23 @@</span>
       * &lt;p&gt;
       * If {@code n &gt; 0} then {@code n} spaces (U+0020) are inserted at the
       * beginning of each line.
       * &lt;p&gt;
       * If {@code n &lt; 0} then up to {@code n}
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space characters} are removed</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space characters} are removed</span>
       * from the beginning of each line. If a given line does not contain
       * sufficient white space then all leading
<span class="udiff-line-modified-removed">-      * {@link Character#isWhitespace(int) white space characters} are removed.</span>
<span class="udiff-line-modified-added">+      * {@linkplain Character#isWhitespace(int) white space characters} are removed.</span>
       * Each white space character is treated as a single character. In
       * particular, the tab character {@code &quot;\t&quot;} (U+0009) is considered a
       * single character; it is not expanded.
       * &lt;p&gt;
       * If {@code n == 0} then the line remains unchanged. However, line
       * terminators are still normalized.
       *
       * @param n  number of leading
<span class="udiff-line-modified-removed">-      *           {@link Character#isWhitespace(int) white space characters}</span>
<span class="udiff-line-modified-added">+      *           {@linkplain Character#isWhitespace(int) white space characters}</span>
       *           to add or remove
       *
       * @return string with indentation adjusted and line endings normalized
       *
       * @see String#lines()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2838,16 +2860,14 @@</span>
       * @see Character#isWhitespace(int)
       *
       * @since 12
       */
      public String indent(int n) {
<span class="udiff-line-modified-removed">-         return isEmpty() ? &quot;&quot; :  indent(n, false);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     private String indent(int n, boolean removeBlanks) {</span>
<span class="udiff-line-removed">-         Stream&lt;String&gt; stream = removeBlanks ? lines(Integer.MAX_VALUE, Integer.MAX_VALUE)</span>
<span class="udiff-line-removed">-                                              : lines();</span>
<span class="udiff-line-modified-added">+         if (isEmpty()) {</span>
<span class="udiff-line-modified-added">+             return &quot;&quot;;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         Stream&lt;String&gt; stream = lines();</span>
          if (n &gt; 0) {
              final String spaces = &quot; &quot;.repeat(n);
              stream = stream.map(s -&gt; spaces + s);
          } else if (n == Integer.MIN_VALUE) {
              stream = stream.map(s -&gt; s.stripLeading());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2865,10 +2885,304 @@</span>
      private int lastIndexOfNonWhitespace() {
          return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)
                            : StringUTF16.lastIndexOfNonWhitespace(value);
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * {@preview Associated with text blocks, a preview feature of</span>
<span class="udiff-line-added">+      *           the Java language.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      *           This method is associated with &lt;i&gt;text blocks&lt;/i&gt;, a preview</span>
<span class="udiff-line-added">+      *           feature of the Java language. Programs can only use this</span>
<span class="udiff-line-added">+      *           method when preview features are enabled. Preview features</span>
<span class="udiff-line-added">+      *           may be removed in a future release, or upgraded to permanent</span>
<span class="udiff-line-added">+      *           features of the Java language.}</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Returns a string whose value is this string, with incidental</span>
<span class="udiff-line-added">+      * {@linkplain Character#isWhitespace(int) white space} removed from</span>
<span class="udiff-line-added">+      * the beginning and end of every line.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * Incidental {@linkplain Character#isWhitespace(int) white space}</span>
<span class="udiff-line-added">+      * is often present in a text block to align the content with the opening</span>
<span class="udiff-line-added">+      * delimiter. For example, in the following code, dots represent incidental</span>
<span class="udiff-line-added">+      * {@linkplain Character#isWhitespace(int) white space}:</span>
<span class="udiff-line-added">+      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="udiff-line-added">+      * String html = &quot;&quot;&quot;</span>
<span class="udiff-line-added">+      * ..............&amp;lt;html&amp;gt;</span>
<span class="udiff-line-added">+      * ..............    &amp;lt;body&amp;gt;</span>
<span class="udiff-line-added">+      * ..............        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;</span>
<span class="udiff-line-added">+      * ..............    &amp;lt;/body&amp;gt;</span>
<span class="udiff-line-added">+      * ..............&amp;lt;/html&amp;gt;</span>
<span class="udiff-line-added">+      * ..............&quot;&quot;&quot;;</span>
<span class="udiff-line-added">+      * &lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="udiff-line-added">+      * This method treats the incidental</span>
<span class="udiff-line-added">+      * {@linkplain Character#isWhitespace(int) white space} as indentation to be</span>
<span class="udiff-line-added">+      * stripped, producing a string that preserves the relative indentation of</span>
<span class="udiff-line-added">+      * the content. Using | to visualize the start of each line of the string:</span>
<span class="udiff-line-added">+      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="udiff-line-added">+      * |&amp;lt;html&amp;gt;</span>
<span class="udiff-line-added">+      * |    &amp;lt;body&amp;gt;</span>
<span class="udiff-line-added">+      * |        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;</span>
<span class="udiff-line-added">+      * |    &amp;lt;/body&amp;gt;</span>
<span class="udiff-line-added">+      * |&amp;lt;/html&amp;gt;</span>
<span class="udiff-line-added">+      * &lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="udiff-line-added">+      * First, the individual lines of this string are extracted as if by using</span>
<span class="udiff-line-added">+      * {@link String#lines()}.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * Then, the &lt;i&gt;minimum indentation&lt;/i&gt; (min) is determined as follows.</span>
<span class="udiff-line-added">+      * For each non-blank line (as defined by {@link String#isBlank()}), the</span>
<span class="udiff-line-added">+      * leading {@linkplain Character#isWhitespace(int) white space} characters are</span>
<span class="udiff-line-added">+      * counted. The leading {@linkplain Character#isWhitespace(int) white space}</span>
<span class="udiff-line-added">+      * characters on the last line are also counted even if</span>
<span class="udiff-line-added">+      * {@linkplain String#isBlank() blank}. The &lt;i&gt;min&lt;/i&gt; value is the smallest</span>
<span class="udiff-line-added">+      * of these counts.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * For each {@linkplain String#isBlank() non-blank} line, &lt;i&gt;min&lt;/i&gt; leading</span>
<span class="udiff-line-added">+      * {@linkplain Character#isWhitespace(int) white space} characters are removed,</span>
<span class="udiff-line-added">+      * and any trailing {@linkplain Character#isWhitespace(int) white space}</span>
<span class="udiff-line-added">+      * characters are removed. {@linkplain String#isBlank() Blank} lines are</span>
<span class="udiff-line-added">+      * replaced with the empty string.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * Finally, the lines are joined into a new string, using the LF character</span>
<span class="udiff-line-added">+      * {@code &quot;\n&quot;} (U+000A) to separate lines.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @apiNote</span>
<span class="udiff-line-added">+      * This method&#39;s primary purpose is to shift a block of lines as far as</span>
<span class="udiff-line-added">+      * possible to the left, while preserving relative indentation. Lines</span>
<span class="udiff-line-added">+      * that were indented the least will thus have no leading</span>
<span class="udiff-line-added">+      * {@linkplain Character#isWhitespace(int) white space}.</span>
<span class="udiff-line-added">+      * The line count of the result will be the same as line count of this</span>
<span class="udiff-line-added">+      * string.</span>
<span class="udiff-line-added">+      * If this string ends with a line terminator then the result will end</span>
<span class="udiff-line-added">+      * with a line terminator.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @implNote</span>
<span class="udiff-line-added">+      * This method treats all {@linkplain Character#isWhitespace(int) white space}</span>
<span class="udiff-line-added">+      * characters as having equal width. As long as the indentation on every</span>
<span class="udiff-line-added">+      * line is consistently composed of the same character sequences, then the</span>
<span class="udiff-line-added">+      * result will be as described above.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @return string with incidental indentation removed and line</span>
<span class="udiff-line-added">+      *         terminators normalized</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @see String#lines()</span>
<span class="udiff-line-added">+      * @see String#isBlank()</span>
<span class="udiff-line-added">+      * @see String#indent(int)</span>
<span class="udiff-line-added">+      * @see Character#isWhitespace(int)</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @since 13</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.TEXT_BLOCKS,</span>
<span class="udiff-line-added">+                                  essentialAPI=true)</span>
<span class="udiff-line-added">+     public String stripIndent() {</span>
<span class="udiff-line-added">+         int length = length();</span>
<span class="udiff-line-added">+         if (length == 0) {</span>
<span class="udiff-line-added">+             return &quot;&quot;;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         char lastChar = charAt(length - 1);</span>
<span class="udiff-line-added">+         boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;</span>
<span class="udiff-line-added">+         List&lt;String&gt; lines = lines().collect(Collectors.toList());</span>
<span class="udiff-line-added">+         final int outdent = optOut ? 0 : outdent(lines);</span>
<span class="udiff-line-added">+         return lines.stream()</span>
<span class="udiff-line-added">+             .map(line -&gt; {</span>
<span class="udiff-line-added">+                 int firstNonWhitespace = line.indexOfNonWhitespace();</span>
<span class="udiff-line-added">+                 int lastNonWhitespace = line.lastIndexOfNonWhitespace();</span>
<span class="udiff-line-added">+                 int incidentalWhitespace = Math.min(outdent, firstNonWhitespace);</span>
<span class="udiff-line-added">+                 return firstNonWhitespace &gt; lastNonWhitespace</span>
<span class="udiff-line-added">+                     ? &quot;&quot; : line.substring(incidentalWhitespace, lastNonWhitespace);</span>
<span class="udiff-line-added">+             })</span>
<span class="udiff-line-added">+             .collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, optOut ? &quot;\n&quot; : &quot;&quot;));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static int outdent(List&lt;String&gt; lines) {</span>
<span class="udiff-line-added">+         // Note: outdent is guaranteed to be zero or positive number.</span>
<span class="udiff-line-added">+         // If there isn&#39;t a non-blank line then the last must be blank</span>
<span class="udiff-line-added">+         int outdent = Integer.MAX_VALUE;</span>
<span class="udiff-line-added">+         for (String line : lines) {</span>
<span class="udiff-line-added">+             int leadingWhitespace = line.indexOfNonWhitespace();</span>
<span class="udiff-line-added">+             if (leadingWhitespace != line.length()) {</span>
<span class="udiff-line-added">+                 outdent = Integer.min(outdent, leadingWhitespace);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         String lastLine = lines.get(lines.size() - 1);</span>
<span class="udiff-line-added">+         if (lastLine.isBlank()) {</span>
<span class="udiff-line-added">+             outdent = Integer.min(outdent, lastLine.length());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return outdent;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * {@preview Associated with text blocks, a preview feature of</span>
<span class="udiff-line-added">+      *           the Java language.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      *           This method is associated with &lt;i&gt;text blocks&lt;/i&gt;, a preview</span>
<span class="udiff-line-added">+      *           feature of the Java language. Programs can only use this</span>
<span class="udiff-line-added">+      *           method when preview features are enabled. Preview features</span>
<span class="udiff-line-added">+      *           may be removed in a future release, or upgraded to permanent</span>
<span class="udiff-line-added">+      *           features of the Java language.}</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Returns a string whose value is this string, with escape sequences</span>
<span class="udiff-line-added">+      * translated as if in a string literal.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * Escape sequences are translated as follows;</span>
<span class="udiff-line-added">+      * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="udiff-line-added">+      *   &lt;caption style=&quot;display:none&quot;&gt;Translation&lt;/caption&gt;</span>
<span class="udiff-line-added">+      *   &lt;thead&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;col&quot;&gt;Escape&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;col&quot;&gt;Name&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;col&quot;&gt;Translation&lt;/th&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;/thead&gt;</span>
<span class="udiff-line-added">+      *   &lt;tbody&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cb}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;backspace&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;{@code U+0008}&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Ct}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;horizontal tab&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;{@code U+0009}&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cn}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;line feed&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;{@code U+000A}&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cf}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;form feed&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;{@code U+000C}&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cr}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;carriage return&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;{@code U+000D}&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cs}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;space&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;{@code U+0020}&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C&quot;}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;double quote&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;{@code U+0022}&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C&#39;}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;single quote&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;{@code U+0027}&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C\u005C}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;backslash&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;{@code U+005C}&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C0 - \u005C377}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;octal escape&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;code point equivalents&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;tr&gt;</span>
<span class="udiff-line-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C&lt;line-terminator&gt;}&lt;/th&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;continuation&lt;/td&gt;</span>
<span class="udiff-line-added">+      *     &lt;td&gt;discard&lt;/td&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tr&gt;</span>
<span class="udiff-line-added">+      *   &lt;/tbody&gt;</span>
<span class="udiff-line-added">+      * &lt;/table&gt;</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @implNote</span>
<span class="udiff-line-added">+      * This method does &lt;em&gt;not&lt;/em&gt; translate Unicode escapes such as &quot;{@code \u005cu2022}&quot;.</span>
<span class="udiff-line-added">+      * Unicode escapes are translated by the Java compiler when reading input characters and</span>
<span class="udiff-line-added">+      * are not part of the string literal specification.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @throws IllegalArgumentException when an escape sequence is malformed.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @return String with escape sequences translated.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @jls 3.10.7 Escape Sequences</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @since 13</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.TEXT_BLOCKS,</span>
<span class="udiff-line-added">+                                  essentialAPI=true)</span>
<span class="udiff-line-added">+     public String translateEscapes() {</span>
<span class="udiff-line-added">+         if (isEmpty()) {</span>
<span class="udiff-line-added">+             return &quot;&quot;;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         char[] chars = toCharArray();</span>
<span class="udiff-line-added">+         int length = chars.length;</span>
<span class="udiff-line-added">+         int from = 0;</span>
<span class="udiff-line-added">+         int to = 0;</span>
<span class="udiff-line-added">+         while (from &lt; length) {</span>
<span class="udiff-line-added">+             char ch = chars[from++];</span>
<span class="udiff-line-added">+             if (ch == &#39;\\&#39;) {</span>
<span class="udiff-line-added">+                 ch = from &lt; length ? chars[from++] : &#39;\0&#39;;</span>
<span class="udiff-line-added">+                 switch (ch) {</span>
<span class="udiff-line-added">+                 case &#39;b&#39;:</span>
<span class="udiff-line-added">+                     ch = &#39;\b&#39;;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case &#39;f&#39;:</span>
<span class="udiff-line-added">+                     ch = &#39;\f&#39;;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case &#39;n&#39;:</span>
<span class="udiff-line-added">+                     ch = &#39;\n&#39;;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case &#39;r&#39;:</span>
<span class="udiff-line-added">+                     ch = &#39;\r&#39;;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case &#39;s&#39;:</span>
<span class="udiff-line-added">+                     ch = &#39; &#39;;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case &#39;t&#39;:</span>
<span class="udiff-line-added">+                     ch = &#39;\t&#39;;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case &#39;\&#39;&#39;:</span>
<span class="udiff-line-added">+                 case &#39;\&quot;&#39;:</span>
<span class="udiff-line-added">+                 case &#39;\\&#39;:</span>
<span class="udiff-line-added">+                     // as is</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:</span>
<span class="udiff-line-added">+                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:</span>
<span class="udiff-line-added">+                     int limit = Integer.min(from + (ch &lt;= &#39;3&#39; ? 2 : 1), length);</span>
<span class="udiff-line-added">+                     int code = ch - &#39;0&#39;;</span>
<span class="udiff-line-added">+                     while (from &lt; limit) {</span>
<span class="udiff-line-added">+                         ch = chars[from];</span>
<span class="udiff-line-added">+                         if (ch &lt; &#39;0&#39; || &#39;7&#39; &lt; ch) {</span>
<span class="udiff-line-added">+                             break;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         from++;</span>
<span class="udiff-line-added">+                         code = (code &lt;&lt; 3) | (ch - &#39;0&#39;);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     ch = (char)code;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case &#39;\n&#39;:</span>
<span class="udiff-line-added">+                     continue;</span>
<span class="udiff-line-added">+                 case &#39;\r&#39;:</span>
<span class="udiff-line-added">+                     if (from &lt; length &amp;&amp; chars[from] == &#39;\n&#39;) {</span>
<span class="udiff-line-added">+                         from++;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     continue;</span>
<span class="udiff-line-added">+                 default: {</span>
<span class="udiff-line-added">+                     String msg = String.format(</span>
<span class="udiff-line-added">+                         &quot;Invalid escape sequence: \\%c \\\\u%04X&quot;,</span>
<span class="udiff-line-added">+                         ch, (int)ch);</span>
<span class="udiff-line-added">+                     throw new IllegalArgumentException(msg);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             chars[to++] = ch;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return new String(chars, 0, to);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * This method allows the application of a function to {@code this}
       * string. The function should expect a single String argument
       * and produce an {@code R} result.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3027,10 +3341,42 @@</span>
       */
      public static String format(Locale l, String format, Object... args) {
          return new Formatter(l).format(format, args).toString();
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * {@preview Associated with text blocks, a preview feature of</span>
<span class="udiff-line-added">+      *           the Java language.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      *           This method is associated with &lt;i&gt;text blocks&lt;/i&gt;, a preview</span>
<span class="udiff-line-added">+      *           feature of the Java language. Programs can only use this</span>
<span class="udiff-line-added">+      *           method when preview features are enabled. Preview features</span>
<span class="udiff-line-added">+      *           may be removed in a future release, or upgraded to permanent</span>
<span class="udiff-line-added">+      *           features of the Java language.}</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Formats using this string as the format string, and the supplied</span>
<span class="udiff-line-added">+      * arguments.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @implSpec This method is equivalent to {@code String.format(this, args)}.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param  args</span>
<span class="udiff-line-added">+      *         Arguments referenced by the format specifiers in this string.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @return  A formatted string</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @see  java.lang.String#format(String,Object...)</span>
<span class="udiff-line-added">+      * @see  java.util.Formatter</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @since 13</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.TEXT_BLOCKS,</span>
<span class="udiff-line-added">+                                  essentialAPI=true)</span>
<span class="udiff-line-added">+     public String formatted(Object... args) {</span>
<span class="udiff-line-added">+         return new Formatter().format(this, args).toString();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Returns the string representation of the {@code Object} argument.
       *
       * @param   obj   an {@code Object}.
       * @return  if the argument is {@code null}, then a string equal to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3069,11 +3415,11 @@</span>
       * @param   data     the character array.
       * @param   offset   initial offset of the subarray.
       * @param   count    length of the subarray.
       * @return  a {@code String} that contains the characters of the
       *          specified subarray of the character array.
<span class="udiff-line-modified-removed">-      * @exception IndexOutOfBoundsException if {@code offset} is</span>
<span class="udiff-line-modified-added">+      * @throws    IndexOutOfBoundsException if {@code offset} is</span>
       *          negative, or {@code count} is negative, or
       *          {@code offset+count} is larger than
       *          {@code data.length}.
       */
      public static String valueOf(char data[], int offset, int count) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3086,11 +3432,11 @@</span>
       * @param   data     the character array.
       * @param   offset   initial offset of the subarray.
       * @param   count    length of the subarray.
       * @return  a {@code String} that contains the characters of the
       *          specified subarray of the character array.
<span class="udiff-line-modified-removed">-      * @exception IndexOutOfBoundsException if {@code offset} is</span>
<span class="udiff-line-modified-added">+      * @throws    IndexOutOfBoundsException if {@code offset} is</span>
       *          negative, or {@code count} is negative, or
       *          {@code offset+count} is larger than
       *          {@code data.length}.
       */
      public static String copyValueOf(char data[], int offset, int count) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3351,11 +3697,11 @@</span>
  
      byte[] value() {
          return value;
      }
  
<span class="udiff-line-modified-removed">-     private boolean isLatin1() {</span>
<span class="udiff-line-modified-added">+     boolean isLatin1() {</span>
          return COMPACT_STRINGS &amp;&amp; coder == LATIN1;
      }
  
      @Native static final byte LATIN1 = 0;
      @Native static final byte UTF16  = 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3365,22 +3711,22 @@</span>
       * negative or greater than or equal to {@code length}.
       */
      static void checkIndex(int index, int length) {
          if (index &lt; 0 || index &gt;= length) {
              throw new StringIndexOutOfBoundsException(&quot;index &quot; + index +
<span class="udiff-line-modified-removed">-                                                       &quot;,length &quot; + length);</span>
<span class="udiff-line-modified-added">+                                                       &quot;, length &quot; + length);</span>
          }
      }
  
      /*
       * StringIndexOutOfBoundsException  if {@code offset}
       * is negative or greater than {@code length}.
       */
      static void checkOffset(int offset, int length) {
          if (offset &lt; 0 || offset &gt; length) {
              throw new StringIndexOutOfBoundsException(&quot;offset &quot; + offset +
<span class="udiff-line-modified-removed">-                                                       &quot;,length &quot; + length);</span>
<span class="udiff-line-modified-added">+                                                       &quot;, length &quot; + length);</span>
          }
      }
  
      /*
       * Check {@code offset}, {@code count} against {@code 0} and {@code length}
</pre>
<center><a href="StrictMath.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringBuffer.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
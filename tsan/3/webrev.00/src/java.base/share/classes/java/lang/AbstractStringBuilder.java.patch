diff a/src/java.base/share/classes/java/lang/AbstractStringBuilder.java b/src/java.base/share/classes/java/lang/AbstractStringBuilder.java
--- a/src/java.base/share/classes/java/lang/AbstractStringBuilder.java
+++ b/src/java.base/share/classes/java/lang/AbstractStringBuilder.java
@@ -24,10 +24,11 @@
  */
 
 package java.lang;
 
 import jdk.internal.math.FloatingDecimal;
+
 import java.util.Arrays;
 import java.util.Spliterator;
 import java.util.stream.IntStream;
 import java.util.stream.StreamSupport;
 
@@ -90,23 +91,61 @@
             coder = UTF16;
         }
     }
 
     /**
-     * Creates an AbstractStringBuilder with the specified coder and with
-     * the initial capacity equal to the smaller of (length + addition)
-     * and Integer.MAX_VALUE.
+     * Constructs an AbstractStringBuilder that contains the same characters
+     * as the specified {@code String}. The initial capacity of
+     * the string builder is {@code 16} plus the length of the
+     * {@code String} argument.
+     *
+     * @param      str   the string to copy.
+     */
+    AbstractStringBuilder(String str) {
+        int length = str.length();
+        int capacity = (length < Integer.MAX_VALUE - 16)
+                ? length + 16 : Integer.MAX_VALUE;
+        final byte initCoder = str.coder();
+        coder = initCoder;
+        value = (initCoder == LATIN1)
+                ? new byte[capacity] : StringUTF16.newBytesFor(capacity);
+        append(str);
+    }
+
+    /**
+     * Constructs an AbstractStringBuilder that contains the same characters
+     * as the specified {@code CharSequence}. The initial capacity of
+     * the string builder is {@code 16} plus the length of the
+     * {@code CharSequence} argument.
+     *
+     * @param      seq   the sequence to copy.
      */
-    AbstractStringBuilder(byte coder, int length, int addition) {
+    AbstractStringBuilder(CharSequence seq) {
+        int length = seq.length();
         if (length < 0) {
             throw new NegativeArraySizeException("Negative length: " + length);
         }
-        this.coder = coder;
-        int capacity = (length < Integer.MAX_VALUE - addition)
-                ? length + addition : Integer.MAX_VALUE;
-        value = (coder == LATIN1)
+        int capacity = (length < Integer.MAX_VALUE - 16)
+                ? length + 16 : Integer.MAX_VALUE;
+
+        final byte initCoder;
+        if (COMPACT_STRINGS) {
+            if (seq instanceof AbstractStringBuilder) {
+                initCoder = ((AbstractStringBuilder)seq).getCoder();
+            } else if (seq instanceof String) {
+                initCoder = ((String)seq).coder();
+            } else {
+                initCoder = LATIN1;
+            }
+        } else {
+            initCoder = UTF16;
+        }
+
+        coder = initCoder;
+        value = (initCoder == LATIN1)
                 ? new byte[capacity] : StringUTF16.newBytesFor(capacity);
+        append(seq);
     }
 
     /**
      * Compares the objects of two AbstractStringBuilder implementations lexicographically.
      *
@@ -140,13 +179,13 @@
     public int length() {
         return count;
     }
 
     /**
-     * Returns the current capacity. The capacity is the amount of storage
-     * available for newly inserted characters, beyond which an allocation
-     * will occur.
+     * Returns the current capacity. The capacity is the number of characters
+     * that can be stored (including already written characters), beyond which
+     * an allocation will occur.
      *
      * @return  the current capacity
      */
     public int capacity() {
         return value.length >> coder;
@@ -645,14 +684,19 @@
             s = "null";
         }
         checkRange(start, end, s.length());
         int len = end - start;
         ensureCapacityInternal(count + len);
-        appendChars(s, start, end);
+        if (s instanceof String) {
+            appendChars((String)s, start, end);
+        } else {
+            appendChars(s, start, end);
+        }
         return this;
     }
 
+
     /**
      * Appends the string representation of the {@code char} array
      * argument to this sequence.
      * <p>
      * The characters of the array argument are appended, in order, to
@@ -1703,10 +1747,39 @@
             StringUTF16.putCharsSB(this.value, count, s, off, end);
         }
         this.count = count + end - off;
     }
 
+    private final void appendChars(String s, int off, int end) {
+        if (isLatin1()) {
+            if (s.isLatin1()) {
+                System.arraycopy(s.value(), off, this.value, this.count, end - off);
+            } else {
+                // We might need to inflate, but do it as late as possible since
+                // the range of characters we're copying might all be latin1
+                byte[] val = this.value;
+                for (int i = off, j = count; i < end; i++) {
+                    char c = s.charAt(i);
+                    if (StringLatin1.canEncode(c)) {
+                        val[j++] = (byte) c;
+                    } else {
+                        count = j;
+                        inflate();
+                        System.arraycopy(s.value(), i << UTF16, this.value, j << UTF16, (end - i) << UTF16);
+                        count += end - i;
+                        return;
+                    }
+                }
+            }
+        } else if (s.isLatin1()) {
+            StringUTF16.putCharsSB(this.value, this.count, s, off, end);
+        } else { // both UTF16
+            System.arraycopy(s.value(), off << UTF16, this.value, this.count << UTF16, (end - off) << UTF16);
+        }
+        count += end - off;
+    }
+
     private final void appendChars(CharSequence s, int off, int end) {
         if (isLatin1()) {
             byte[] val = this.value;
             for (int i = off, j = count; i < end; i++) {
                 char c = s.charAt(i);

diff a/src/java.base/share/classes/java/text/Normalizer.java b/src/java.base/share/classes/java/text/Normalizer.java
--- a/src/java.base/share/classes/java/text/Normalizer.java
+++ b/src/java.base/share/classes/java/text/Normalizer.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -35,17 +35,17 @@
  *******************************************************************************
  */
 
 package java.text;
 
-import sun.text.normalizer.NormalizerBase;
+import jdk.internal.icu.text.NormalizerBase;
 
 /**
- * This class provides the method <code>normalize</code> which transforms Unicode
+ * This class provides the method {@code normalize} which transforms Unicode
  * text into an equivalent composed or decomposed form, allowing for easier
  * sorting and searching of text.
- * The <code>normalize</code> method supports the standard normalization forms
+ * The {@code normalize} method supports the standard normalization forms
  * described in
  * <a href="http://www.unicode.org/unicode/reports/tr15/tr15-23.html">
  * Unicode Standard Annex #15 &mdash; Unicode Normalization Forms</a>.
  * <p>
  * Characters with accents or other adornments can be encoded in
@@ -86,16 +86,16 @@
  * with existing character sets that already provided it.  The Unicode standard
  * identifies such characters by giving them "compatibility" decompositions
  * into the corresponding semantic characters.  When sorting and searching, you
  * will often want to use these mappings.
  * <p>
- * The <code>normalize</code> method helps solve these problems by transforming
+ * The {@code normalize} method helps solve these problems by transforming
  * text into the canonical composed and decomposed forms as shown in the first
  * example above. In addition, you can have it perform compatibility
  * decompositions so that you can treat compatibility characters the same as
  * their equivalents.
- * Finally, the <code>normalize</code> method rearranges accents into the
+ * Finally, the {@code normalize} method rearranges accents into the
  * proper canonical order, so that you do not have to worry about accent
  * rearrangement on your own.
  * <p>
  * The W3C generally recommends to exchange texts in NFC.
  * Note also that most legacy character encodings use only precomposed forms and
@@ -150,11 +150,11 @@
      *                   {@link java.text.Normalizer.Form#NFC},
      *                   {@link java.text.Normalizer.Form#NFD},
      *                   {@link java.text.Normalizer.Form#NFKC},
      *                   {@link java.text.Normalizer.Form#NFKD}
      * @return The normalized String
-     * @throws NullPointerException If <code>src</code> or <code>form</code>
+     * @throws NullPointerException If {@code src} or {@code form}
      * is null.
      */
     public static String normalize(CharSequence src, Form form) {
         return NormalizerBase.normalize(src.toString(), form);
     }
@@ -167,11 +167,11 @@
      *                   {@link java.text.Normalizer.Form#NFD},
      *                   {@link java.text.Normalizer.Form#NFKC},
      *                   {@link java.text.Normalizer.Form#NFKD}
      * @return true if the sequence of char values is normalized;
      * false otherwise.
-     * @throws NullPointerException If <code>src</code> or <code>form</code>
+     * @throws NullPointerException If {@code src} or {@code form}
      * is null.
      */
     public static boolean isNormalized(CharSequence src, Form form) {
         return NormalizerBase.isNormalized(src.toString(), form);
     }

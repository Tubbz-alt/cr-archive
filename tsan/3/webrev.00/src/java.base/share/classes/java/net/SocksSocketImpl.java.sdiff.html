<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/SocksSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketTimeoutException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StandardSocketOptions.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/SocksSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;

 26 import java.io.IOException;
 27 import java.io.InputStream;
 28 import java.io.OutputStream;
 29 import java.io.BufferedOutputStream;

 30 import java.security.AccessController;

 31 
 32 import jdk.internal.util.StaticProperty;
 33 import sun.net.SocksProxy;
 34 import sun.net.spi.DefaultProxySelector;
 35 import sun.net.www.ParseUtil;
 36 
 37 /**
 38  * SOCKS (V4 &amp; V5) TCP socket implementation (RFC 1928).
<span class="line-removed"> 39  * This is a subclass of PlainSocketImpl.</span>
<span class="line-removed"> 40  * Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.</span>
 41  */
 42 
<span class="line-modified"> 43 class SocksSocketImpl extends PlainSocketImpl implements SocksConsts {</span>
 44     private String server = null;
 45     private int serverPort = DEFAULT_PORT;
 46     private InetSocketAddress external_address;
 47     private boolean useV4 = false;
 48     private Socket cmdsock = null;
 49     private InputStream cmdIn = null;
 50     private OutputStream cmdOut = null;
 51 
<span class="line-modified"> 52     SocksSocketImpl() {</span>
<span class="line-modified"> 53         // Nothing needed</span>
 54     }
 55 
<span class="line-modified"> 56     SocksSocketImpl(Proxy proxy) {</span>

 57         SocketAddress a = proxy.address();
 58         if (a instanceof InetSocketAddress) {
 59             InetSocketAddress ad = (InetSocketAddress) a;
 60             // Use getHostString() to avoid reverse lookups
 61             server = ad.getHostString();
 62             serverPort = ad.getPort();
 63         }
 64         useV4 = useV4(proxy);
 65     }
 66 
 67     private static boolean useV4(Proxy proxy) {
 68         if (proxy instanceof SocksProxy
 69             &amp;&amp; ((SocksProxy)proxy).protocolVersion() == 4) {
 70             return true;
 71         }
 72         return DefaultProxySelector.socksProxyVersion() == 4;
 73     }
 74 
 75     private synchronized void privilegedConnect(final String host,
 76                                               final int port,
 77                                               final int timeout)
<span class="line-modified"> 78          throws IOException</span>
 79     {
 80         try {
 81             AccessController.doPrivileged(
 82                 new java.security.PrivilegedExceptionAction&lt;&gt;() {
 83                     public Void run() throws IOException {
 84                               superConnectServer(host, port, timeout);
 85                               cmdIn = getInputStream();
 86                               cmdOut = getOutputStream();
 87                               return null;
 88                           }
 89                       });
 90         } catch (java.security.PrivilegedActionException pae) {
 91             throw (IOException) pae.getException();
 92         }
 93     }
 94 
 95     private void superConnectServer(String host, int port,
 96                                     int timeout) throws IOException {
<span class="line-modified"> 97         super.connect(new InetSocketAddress(host, port), timeout);</span>
 98     }
 99 
100     private static int remainingMillis(long deadlineMillis) throws IOException {
101         if (deadlineMillis == 0L)
102             return 0;
103 
104         final long remaining = deadlineMillis - System.currentTimeMillis();
105         if (remaining &gt; 0)
106             return (int) remaining;
107 
108         throw new SocketTimeoutException();
109     }
110 
111     private int readSocksReply(InputStream in, byte[] data, long deadlineMillis) throws IOException {
112         int len = data.length;
113         int received = 0;
<span class="line-modified">114         while (received &lt; len) {</span>
<span class="line-modified">115             int count;</span>
<span class="line-modified">116             try {</span>
<span class="line-modified">117                 count = ((SocketInputStream)in).read(data, received, len - received, remainingMillis(deadlineMillis));</span>
<span class="line-modified">118             } catch (SocketTimeoutException e) {</span>
<span class="line-modified">119                 throw new SocketTimeoutException(&quot;Connect timed out&quot;);</span>








120             }
<span class="line-modified">121             if (count &lt; 0)</span>
<span class="line-modified">122                 throw new SocketException(&quot;Malformed reply from SOCKS server&quot;);</span>
<span class="line-removed">123             received += count;</span>
124         }
125         return received;
126     }
127 
128     private boolean authenticate(byte method, InputStream in,
129                                  BufferedOutputStream out,
130                                  long deadlineMillis) throws IOException {
131         // No Authentication required. We&#39;re done then!
132         if (method == NO_AUTH)
133             return true;
134         /*
135          * User/Password authentication. Try, in that order :
136          * - The application provided Authenticator, if any
137          * - the user.name &amp; no password (backward compatibility behavior).
138          */
139         if (method == USER_PASSW) {
140             String userName;
141             String password = null;
142             final InetAddress addr = InetAddress.getByName(server);
143             PasswordAuthentication pw =
144                 java.security.AccessController.doPrivileged(
145                     new java.security.PrivilegedAction&lt;&gt;() {
146                         public PasswordAuthentication run() {
147                                 return Authenticator.requestPasswordAuthentication(
148                                        server, addr, serverPort, &quot;SOCKS5&quot;, &quot;SOCKS authentication&quot;, null);
149                             }
150                         });
151             if (pw != null) {
152                 userName = pw.getUserName();
153                 password = new String(pw.getPassword());
154             } else {
155                 userName = StaticProperty.userName();
156             }
157             if (userName == null)
158                 return false;
159             out.write(1);
160             out.write(userName.length());
<span class="line-modified">161             try {</span>
<span class="line-removed">162                 out.write(userName.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">163             } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">164                 assert false;</span>
<span class="line-removed">165             }</span>
166             if (password != null) {
167                 out.write(password.length());
<span class="line-modified">168                 try {</span>
<span class="line-removed">169                     out.write(password.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">170                 } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">171                     assert false;</span>
<span class="line-removed">172                 }</span>
173             } else
174                 out.write(0);
175             out.flush();
176             byte[] data = new byte[2];
177             int i = readSocksReply(in, data, deadlineMillis);
178             if (i != 2 || data[1] != 0) {
179                 /* RFC 1929 specifies that the connection MUST be closed if
180                    authentication fails */
181                 out.close();
182                 in.close();
183                 return false;
184             }
185             /* Authentication succeeded */
186             return true;
187         }
188         return false;
189     }
190 
191     private void connectV4(InputStream in, OutputStream out,
192                            InetSocketAddress endpoint,
193                            long deadlineMillis) throws IOException {
194         if (!(endpoint.getAddress() instanceof Inet4Address)) {
195             throw new SocketException(&quot;SOCKS V4 requires IPv4 only addresses&quot;);
196         }
197         out.write(PROTO_VERS4);
198         out.write(CONNECT);
199         out.write((endpoint.getPort() &gt;&gt; 8) &amp; 0xff);
200         out.write((endpoint.getPort() &gt;&gt; 0) &amp; 0xff);
201         out.write(endpoint.getAddress().getAddress());
202         String userName = getUserName();
<span class="line-modified">203         try {</span>
<span class="line-removed">204             out.write(userName.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">205         } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">206             assert false;</span>
<span class="line-removed">207         }</span>
208         out.write(0);
209         out.flush();
210         byte[] data = new byte[8];
211         int n = readSocksReply(in, data, deadlineMillis);
212         if (n != 8)
213             throw new SocketException(&quot;Reply from SOCKS server has bad length: &quot; + n);
214         if (data[0] != 0 &amp;&amp; data[0] != 4)
215             throw new SocketException(&quot;Reply from SOCKS server has bad version&quot;);
216         SocketException ex = null;
217         switch (data[1]) {
218         case 90:
219             // Success!
220             external_address = endpoint;
221             break;
222         case 91:
223             ex = new SocketException(&quot;SOCKS request rejected&quot;);
224             break;
225         case 92:
226             ex = new SocketException(&quot;SOCKS server couldn&#39;t reach destination&quot;);
227             break;
228         case 93:
229             ex = new SocketException(&quot;SOCKS authentication failed&quot;);
230             break;
231         default:
232             ex = new SocketException(&quot;Reply from SOCKS server contains bad status&quot;);
233             break;
234         }
235         if (ex != null) {
236             in.close();
237             out.close();
238             throw ex;
239         }
240     }
241 










242     /**
243      * Connects the Socks Socket to the specified endpoint. It will first
244      * connect to the SOCKS proxy and negotiate the access. If the proxy
245      * grants the connections, then the connect is successful and all
246      * further traffic will go to the &quot;real&quot; endpoint.
247      *
248      * @param   endpoint        the {@code SocketAddress} to connect to.
249      * @param   timeout         the timeout value in milliseconds
250      * @throws  IOException     if the connection can&#39;t be established.
251      * @throws  SecurityException if there is a security manager and it
252      *                          doesn&#39;t allow the connection
253      * @throws  IllegalArgumentException if endpoint is null or a
254      *          SocketAddress subclass not supported by this socket
255      */
256     @Override
257     protected void connect(SocketAddress endpoint, int timeout) throws IOException {
258         final long deadlineMillis;
259 
260         if (timeout == 0) {
261             deadlineMillis = 0L;
</pre>
<hr />
<pre>
273                 security.checkConnect(epoint.getHostName(),
274                                       epoint.getPort());
275             else
276                 security.checkConnect(epoint.getAddress().getHostAddress(),
277                                       epoint.getPort());
278         }
279         if (server == null) {
280             // This is the general case
281             // server is not null only when the socket was created with a
282             // specified proxy in which case it does bypass the ProxySelector
283             ProxySelector sel = java.security.AccessController.doPrivileged(
284                 new java.security.PrivilegedAction&lt;&gt;() {
285                     public ProxySelector run() {
286                             return ProxySelector.getDefault();
287                         }
288                     });
289             if (sel == null) {
290                 /*
291                  * No default proxySelector --&gt; direct connection
292                  */
<span class="line-modified">293                 super.connect(epoint, remainingMillis(deadlineMillis));</span>
294                 return;
295             }
296             URI uri;
297             // Use getHostString() to avoid reverse lookups
298             String host = epoint.getHostString();
299             // IPv6 literal?
300             if (epoint.getAddress() instanceof Inet6Address &amp;&amp;
301                 (!host.startsWith(&quot;[&quot;)) &amp;&amp; (host.indexOf(&#39;:&#39;) &gt;= 0)) {
302                 host = &quot;[&quot; + host + &quot;]&quot;;
303             }
304             try {
305                 uri = new URI(&quot;socket://&quot; + ParseUtil.encodePath(host) + &quot;:&quot;+ epoint.getPort());
306             } catch (URISyntaxException e) {
307                 // This shouldn&#39;t happen
308                 assert false : e;
309                 uri = null;
310             }
311             Proxy p = null;
312             IOException savedExc = null;
<span class="line-modified">313             java.util.Iterator&lt;Proxy&gt; iProxy = null;</span>
<span class="line-modified">314             iProxy = sel.select(uri).iterator();</span>




315             if (iProxy == null || !(iProxy.hasNext())) {
<span class="line-modified">316                 super.connect(epoint, remainingMillis(deadlineMillis));</span>
317                 return;
318             }
319             while (iProxy.hasNext()) {
320                 p = iProxy.next();
321                 if (p == null || p.type() != Proxy.Type.SOCKS) {
<span class="line-modified">322                     super.connect(epoint, remainingMillis(deadlineMillis));</span>
323                     return;
324                 }
325 
326                 if (!(p.address() instanceof InetSocketAddress))
327                     throw new SocketException(&quot;Unknown address type for proxy: &quot; + p);
328                 // Use getHostString() to avoid reverse lookups
329                 server = ((InetSocketAddress) p.address()).getHostString();
330                 serverPort = ((InetSocketAddress) p.address()).getPort();
331                 useV4 = useV4(p);
332 
333                 // Connects to the SOCKS server
334                 try {
335                     privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
336                     // Worked, let&#39;s get outta here
337                     break;
338                 } catch (IOException e) {
339                     // Ooops, let&#39;s notify the ProxySelector
340                     sel.connectFailed(uri,p.address(),e);
341                     server = null;
342                     serverPort = -1;
</pre>
<hr />
<pre>
388             // Let&#39;s try V4 before we give up
389             // SOCKS Protocol version 4 doesn&#39;t know how to deal with
390             // DOMAIN type of addresses (unresolved addresses here)
391             if (epoint.isUnresolved())
392                 throw new UnknownHostException(epoint.toString());
393             connectV4(in, out, epoint, deadlineMillis);
394             return;
395         }
396         if (((int)data[1]) == NO_METHODS)
397             throw new SocketException(&quot;SOCKS : No acceptable methods&quot;);
398         if (!authenticate(data[1], in, out, deadlineMillis)) {
399             throw new SocketException(&quot;SOCKS : authentication failed&quot;);
400         }
401         out.write(PROTO_VERS);
402         out.write(CONNECT);
403         out.write(0);
404         /* Test for IPV4/IPV6/Unresolved */
405         if (epoint.isUnresolved()) {
406             out.write(DOMAIN_NAME);
407             out.write(epoint.getHostName().length());
<span class="line-modified">408             try {</span>
<span class="line-removed">409                 out.write(epoint.getHostName().getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="line-removed">410             } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="line-removed">411                 assert false;</span>
<span class="line-removed">412             }</span>
413             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
414             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
415         } else if (epoint.getAddress() instanceof Inet6Address) {
416             out.write(IPV6);
417             out.write(epoint.getAddress().getAddress());
418             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
419             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
420         } else {
421             out.write(IPV4);
422             out.write(epoint.getAddress().getAddress());
423             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
424             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
425         }
426         out.flush();
427         data = new byte[4];
428         i = readSocksReply(in, data, deadlineMillis);
429         if (i != 4)
430             throw new SocketException(&quot;Reply from SOCKS server has bad length&quot;);
431         SocketException ex = null;
432         int len;
</pre>
<hr />
<pre>
492             ex = new SocketException(&quot;SOCKS: Connection refused&quot;);
493             break;
494         case TTL_EXPIRED:
495             ex =  new SocketException(&quot;SOCKS: TTL expired&quot;);
496             break;
497         case CMD_NOT_SUPPORTED:
498             ex = new SocketException(&quot;SOCKS: Command not supported&quot;);
499             break;
500         case ADDR_TYPE_NOT_SUP:
501             ex = new SocketException(&quot;SOCKS: address type not supported&quot;);
502             break;
503         }
504         if (ex != null) {
505             in.close();
506             out.close();
507             throw ex;
508         }
509         external_address = epoint;
510     }
511 




512 




513 
514     /**
515      * Returns the value of this socket&#39;s {@code address} field.
516      *
517      * @return  the value of this socket&#39;s {@code address} field.
518      * @see     java.net.SocketImpl#address
519      */
520     @Override
521     protected InetAddress getInetAddress() {
522         if (external_address != null)
523             return external_address.getAddress();
524         else
<span class="line-modified">525             return super.getInetAddress();</span>
526     }
527 
528     /**
529      * Returns the value of this socket&#39;s {@code port} field.
530      *
531      * @return  the value of this socket&#39;s {@code port} field.
532      * @see     java.net.SocketImpl#port
533      */
534     @Override
535     protected int getPort() {
536         if (external_address != null)
537             return external_address.getPort();
538         else
<span class="line-modified">539             return super.getPort();</span>
540     }
541 
542     @Override
543     protected void close() throws IOException {
544         if (cmdsock != null)
545             cmdsock.close();
546         cmdsock = null;
<span class="line-modified">547         super.close();</span>
548     }
549 
550     private String getUserName() {
551         return StaticProperty.userName();
552     }





553 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
<span class="line-added"> 26 </span>
 27 import java.io.IOException;
 28 import java.io.InputStream;
 29 import java.io.OutputStream;
 30 import java.io.BufferedOutputStream;
<span class="line-added"> 31 import java.nio.charset.StandardCharsets;</span>
 32 import java.security.AccessController;
<span class="line-added"> 33 import java.util.Iterator;</span>
 34 
 35 import jdk.internal.util.StaticProperty;
 36 import sun.net.SocksProxy;
 37 import sun.net.spi.DefaultProxySelector;
 38 import sun.net.www.ParseUtil;
 39 
 40 /**
 41  * SOCKS (V4 &amp; V5) TCP socket implementation (RFC 1928).


 42  */
 43 
<span class="line-modified"> 44 class SocksSocketImpl extends DelegatingSocketImpl implements SocksConsts {</span>
 45     private String server = null;
 46     private int serverPort = DEFAULT_PORT;
 47     private InetSocketAddress external_address;
 48     private boolean useV4 = false;
 49     private Socket cmdsock = null;
 50     private InputStream cmdIn = null;
 51     private OutputStream cmdOut = null;
 52 
<span class="line-modified"> 53     SocksSocketImpl(SocketImpl delegate) {</span>
<span class="line-modified"> 54         super(delegate);</span>
 55     }
 56 
<span class="line-modified"> 57     SocksSocketImpl(Proxy proxy, SocketImpl delegate) {</span>
<span class="line-added"> 58         super(delegate);</span>
 59         SocketAddress a = proxy.address();
 60         if (a instanceof InetSocketAddress) {
 61             InetSocketAddress ad = (InetSocketAddress) a;
 62             // Use getHostString() to avoid reverse lookups
 63             server = ad.getHostString();
 64             serverPort = ad.getPort();
 65         }
 66         useV4 = useV4(proxy);
 67     }
 68 
 69     private static boolean useV4(Proxy proxy) {
 70         if (proxy instanceof SocksProxy
 71             &amp;&amp; ((SocksProxy)proxy).protocolVersion() == 4) {
 72             return true;
 73         }
 74         return DefaultProxySelector.socksProxyVersion() == 4;
 75     }
 76 
 77     private synchronized void privilegedConnect(final String host,
 78                                               final int port,
 79                                               final int timeout)
<span class="line-modified"> 80         throws IOException</span>
 81     {
 82         try {
 83             AccessController.doPrivileged(
 84                 new java.security.PrivilegedExceptionAction&lt;&gt;() {
 85                     public Void run() throws IOException {
 86                               superConnectServer(host, port, timeout);
 87                               cmdIn = getInputStream();
 88                               cmdOut = getOutputStream();
 89                               return null;
 90                           }
 91                       });
 92         } catch (java.security.PrivilegedActionException pae) {
 93             throw (IOException) pae.getException();
 94         }
 95     }
 96 
 97     private void superConnectServer(String host, int port,
 98                                     int timeout) throws IOException {
<span class="line-modified"> 99         delegate.connect(new InetSocketAddress(host, port), timeout);</span>
100     }
101 
102     private static int remainingMillis(long deadlineMillis) throws IOException {
103         if (deadlineMillis == 0L)
104             return 0;
105 
106         final long remaining = deadlineMillis - System.currentTimeMillis();
107         if (remaining &gt; 0)
108             return (int) remaining;
109 
110         throw new SocketTimeoutException();
111     }
112 
113     private int readSocksReply(InputStream in, byte[] data, long deadlineMillis) throws IOException {
114         int len = data.length;
115         int received = 0;
<span class="line-modified">116         int originalTimeout = (int) getOption(SocketOptions.SO_TIMEOUT);</span>
<span class="line-modified">117         try {</span>
<span class="line-modified">118             while (received &lt; len) {</span>
<span class="line-modified">119                 int count;</span>
<span class="line-modified">120                 int remaining = remainingMillis(deadlineMillis);</span>
<span class="line-modified">121                 setOption(SocketOptions.SO_TIMEOUT, remaining);</span>
<span class="line-added">122                 try {</span>
<span class="line-added">123                     count = in.read(data, received, len - received);</span>
<span class="line-added">124                 } catch (SocketTimeoutException e) {</span>
<span class="line-added">125                     throw new SocketTimeoutException(&quot;Connect timed out&quot;);</span>
<span class="line-added">126                 }</span>
<span class="line-added">127                 if (count &lt; 0)</span>
<span class="line-added">128                     throw new SocketException(&quot;Malformed reply from SOCKS server&quot;);</span>
<span class="line-added">129                 received += count;</span>
130             }
<span class="line-modified">131         } finally {</span>
<span class="line-modified">132             setOption(SocketOptions.SO_TIMEOUT, originalTimeout);</span>

133         }
134         return received;
135     }
136 
137     private boolean authenticate(byte method, InputStream in,
138                                  BufferedOutputStream out,
139                                  long deadlineMillis) throws IOException {
140         // No Authentication required. We&#39;re done then!
141         if (method == NO_AUTH)
142             return true;
143         /*
144          * User/Password authentication. Try, in that order :
145          * - The application provided Authenticator, if any
146          * - the user.name &amp; no password (backward compatibility behavior).
147          */
148         if (method == USER_PASSW) {
149             String userName;
150             String password = null;
151             final InetAddress addr = InetAddress.getByName(server);
152             PasswordAuthentication pw =
153                 java.security.AccessController.doPrivileged(
154                     new java.security.PrivilegedAction&lt;&gt;() {
155                         public PasswordAuthentication run() {
156                                 return Authenticator.requestPasswordAuthentication(
157                                        server, addr, serverPort, &quot;SOCKS5&quot;, &quot;SOCKS authentication&quot;, null);
158                             }
159                         });
160             if (pw != null) {
161                 userName = pw.getUserName();
162                 password = new String(pw.getPassword());
163             } else {
164                 userName = StaticProperty.userName();
165             }
166             if (userName == null)
167                 return false;
168             out.write(1);
169             out.write(userName.length());
<span class="line-modified">170             out.write(userName.getBytes(StandardCharsets.ISO_8859_1));</span>




171             if (password != null) {
172                 out.write(password.length());
<span class="line-modified">173                 out.write(password.getBytes(StandardCharsets.ISO_8859_1));</span>




174             } else
175                 out.write(0);
176             out.flush();
177             byte[] data = new byte[2];
178             int i = readSocksReply(in, data, deadlineMillis);
179             if (i != 2 || data[1] != 0) {
180                 /* RFC 1929 specifies that the connection MUST be closed if
181                    authentication fails */
182                 out.close();
183                 in.close();
184                 return false;
185             }
186             /* Authentication succeeded */
187             return true;
188         }
189         return false;
190     }
191 
192     private void connectV4(InputStream in, OutputStream out,
193                            InetSocketAddress endpoint,
194                            long deadlineMillis) throws IOException {
195         if (!(endpoint.getAddress() instanceof Inet4Address)) {
196             throw new SocketException(&quot;SOCKS V4 requires IPv4 only addresses&quot;);
197         }
198         out.write(PROTO_VERS4);
199         out.write(CONNECT);
200         out.write((endpoint.getPort() &gt;&gt; 8) &amp; 0xff);
201         out.write((endpoint.getPort() &gt;&gt; 0) &amp; 0xff);
202         out.write(endpoint.getAddress().getAddress());
203         String userName = getUserName();
<span class="line-modified">204         out.write(userName.getBytes(StandardCharsets.ISO_8859_1));</span>




205         out.write(0);
206         out.flush();
207         byte[] data = new byte[8];
208         int n = readSocksReply(in, data, deadlineMillis);
209         if (n != 8)
210             throw new SocketException(&quot;Reply from SOCKS server has bad length: &quot; + n);
211         if (data[0] != 0 &amp;&amp; data[0] != 4)
212             throw new SocketException(&quot;Reply from SOCKS server has bad version&quot;);
213         SocketException ex = null;
214         switch (data[1]) {
215         case 90:
216             // Success!
217             external_address = endpoint;
218             break;
219         case 91:
220             ex = new SocketException(&quot;SOCKS request rejected&quot;);
221             break;
222         case 92:
223             ex = new SocketException(&quot;SOCKS server couldn&#39;t reach destination&quot;);
224             break;
225         case 93:
226             ex = new SocketException(&quot;SOCKS authentication failed&quot;);
227             break;
228         default:
229             ex = new SocketException(&quot;Reply from SOCKS server contains bad status&quot;);
230             break;
231         }
232         if (ex != null) {
233             in.close();
234             out.close();
235             throw ex;
236         }
237     }
238 
<span class="line-added">239     @Override</span>
<span class="line-added">240     protected void connect(String host, int port) throws IOException {</span>
<span class="line-added">241         connect(new InetSocketAddress(host, port), 0);</span>
<span class="line-added">242     }</span>
<span class="line-added">243 </span>
<span class="line-added">244     @Override</span>
<span class="line-added">245     protected void connect(InetAddress address, int port) throws IOException {</span>
<span class="line-added">246         connect(new InetSocketAddress(address, port), 0);</span>
<span class="line-added">247     }</span>
<span class="line-added">248 </span>
249     /**
250      * Connects the Socks Socket to the specified endpoint. It will first
251      * connect to the SOCKS proxy and negotiate the access. If the proxy
252      * grants the connections, then the connect is successful and all
253      * further traffic will go to the &quot;real&quot; endpoint.
254      *
255      * @param   endpoint        the {@code SocketAddress} to connect to.
256      * @param   timeout         the timeout value in milliseconds
257      * @throws  IOException     if the connection can&#39;t be established.
258      * @throws  SecurityException if there is a security manager and it
259      *                          doesn&#39;t allow the connection
260      * @throws  IllegalArgumentException if endpoint is null or a
261      *          SocketAddress subclass not supported by this socket
262      */
263     @Override
264     protected void connect(SocketAddress endpoint, int timeout) throws IOException {
265         final long deadlineMillis;
266 
267         if (timeout == 0) {
268             deadlineMillis = 0L;
</pre>
<hr />
<pre>
280                 security.checkConnect(epoint.getHostName(),
281                                       epoint.getPort());
282             else
283                 security.checkConnect(epoint.getAddress().getHostAddress(),
284                                       epoint.getPort());
285         }
286         if (server == null) {
287             // This is the general case
288             // server is not null only when the socket was created with a
289             // specified proxy in which case it does bypass the ProxySelector
290             ProxySelector sel = java.security.AccessController.doPrivileged(
291                 new java.security.PrivilegedAction&lt;&gt;() {
292                     public ProxySelector run() {
293                             return ProxySelector.getDefault();
294                         }
295                     });
296             if (sel == null) {
297                 /*
298                  * No default proxySelector --&gt; direct connection
299                  */
<span class="line-modified">300                 delegate.connect(epoint, remainingMillis(deadlineMillis));</span>
301                 return;
302             }
303             URI uri;
304             // Use getHostString() to avoid reverse lookups
305             String host = epoint.getHostString();
306             // IPv6 literal?
307             if (epoint.getAddress() instanceof Inet6Address &amp;&amp;
308                 (!host.startsWith(&quot;[&quot;)) &amp;&amp; (host.indexOf(&#39;:&#39;) &gt;= 0)) {
309                 host = &quot;[&quot; + host + &quot;]&quot;;
310             }
311             try {
312                 uri = new URI(&quot;socket://&quot; + ParseUtil.encodePath(host) + &quot;:&quot;+ epoint.getPort());
313             } catch (URISyntaxException e) {
314                 // This shouldn&#39;t happen
315                 assert false : e;
316                 uri = null;
317             }
318             Proxy p = null;
319             IOException savedExc = null;
<span class="line-modified">320             final Iterator&lt;Proxy&gt; iProxy;</span>
<span class="line-modified">321             try {</span>
<span class="line-added">322                 iProxy = sel.select(uri).iterator();</span>
<span class="line-added">323             } catch (IllegalArgumentException iae) {</span>
<span class="line-added">324                 throw new IOException(&quot;Failed to select a proxy&quot;, iae);</span>
<span class="line-added">325             }</span>
326             if (iProxy == null || !(iProxy.hasNext())) {
<span class="line-modified">327                 delegate.connect(epoint, remainingMillis(deadlineMillis));</span>
328                 return;
329             }
330             while (iProxy.hasNext()) {
331                 p = iProxy.next();
332                 if (p == null || p.type() != Proxy.Type.SOCKS) {
<span class="line-modified">333                     delegate.connect(epoint, remainingMillis(deadlineMillis));</span>
334                     return;
335                 }
336 
337                 if (!(p.address() instanceof InetSocketAddress))
338                     throw new SocketException(&quot;Unknown address type for proxy: &quot; + p);
339                 // Use getHostString() to avoid reverse lookups
340                 server = ((InetSocketAddress) p.address()).getHostString();
341                 serverPort = ((InetSocketAddress) p.address()).getPort();
342                 useV4 = useV4(p);
343 
344                 // Connects to the SOCKS server
345                 try {
346                     privilegedConnect(server, serverPort, remainingMillis(deadlineMillis));
347                     // Worked, let&#39;s get outta here
348                     break;
349                 } catch (IOException e) {
350                     // Ooops, let&#39;s notify the ProxySelector
351                     sel.connectFailed(uri,p.address(),e);
352                     server = null;
353                     serverPort = -1;
</pre>
<hr />
<pre>
399             // Let&#39;s try V4 before we give up
400             // SOCKS Protocol version 4 doesn&#39;t know how to deal with
401             // DOMAIN type of addresses (unresolved addresses here)
402             if (epoint.isUnresolved())
403                 throw new UnknownHostException(epoint.toString());
404             connectV4(in, out, epoint, deadlineMillis);
405             return;
406         }
407         if (((int)data[1]) == NO_METHODS)
408             throw new SocketException(&quot;SOCKS : No acceptable methods&quot;);
409         if (!authenticate(data[1], in, out, deadlineMillis)) {
410             throw new SocketException(&quot;SOCKS : authentication failed&quot;);
411         }
412         out.write(PROTO_VERS);
413         out.write(CONNECT);
414         out.write(0);
415         /* Test for IPV4/IPV6/Unresolved */
416         if (epoint.isUnresolved()) {
417             out.write(DOMAIN_NAME);
418             out.write(epoint.getHostName().length());
<span class="line-modified">419             out.write(epoint.getHostName().getBytes(StandardCharsets.ISO_8859_1));</span>




420             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
421             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
422         } else if (epoint.getAddress() instanceof Inet6Address) {
423             out.write(IPV6);
424             out.write(epoint.getAddress().getAddress());
425             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
426             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
427         } else {
428             out.write(IPV4);
429             out.write(epoint.getAddress().getAddress());
430             out.write((epoint.getPort() &gt;&gt; 8) &amp; 0xff);
431             out.write((epoint.getPort() &gt;&gt; 0) &amp; 0xff);
432         }
433         out.flush();
434         data = new byte[4];
435         i = readSocksReply(in, data, deadlineMillis);
436         if (i != 4)
437             throw new SocketException(&quot;Reply from SOCKS server has bad length&quot;);
438         SocketException ex = null;
439         int len;
</pre>
<hr />
<pre>
499             ex = new SocketException(&quot;SOCKS: Connection refused&quot;);
500             break;
501         case TTL_EXPIRED:
502             ex =  new SocketException(&quot;SOCKS: TTL expired&quot;);
503             break;
504         case CMD_NOT_SUPPORTED:
505             ex = new SocketException(&quot;SOCKS: Command not supported&quot;);
506             break;
507         case ADDR_TYPE_NOT_SUP:
508             ex = new SocketException(&quot;SOCKS: address type not supported&quot;);
509             break;
510         }
511         if (ex != null) {
512             in.close();
513             out.close();
514             throw ex;
515         }
516         external_address = epoint;
517     }
518 
<span class="line-added">519     @Override</span>
<span class="line-added">520     protected void listen(int backlog) {</span>
<span class="line-added">521         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">522     }</span>
523 
<span class="line-added">524     @Override</span>
<span class="line-added">525     protected void accept(SocketImpl s) {</span>
<span class="line-added">526         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">527     }</span>
528 
529     /**
530      * Returns the value of this socket&#39;s {@code address} field.
531      *
532      * @return  the value of this socket&#39;s {@code address} field.
533      * @see     java.net.SocketImpl#address
534      */
535     @Override
536     protected InetAddress getInetAddress() {
537         if (external_address != null)
538             return external_address.getAddress();
539         else
<span class="line-modified">540             return delegate.getInetAddress();</span>
541     }
542 
543     /**
544      * Returns the value of this socket&#39;s {@code port} field.
545      *
546      * @return  the value of this socket&#39;s {@code port} field.
547      * @see     java.net.SocketImpl#port
548      */
549     @Override
550     protected int getPort() {
551         if (external_address != null)
552             return external_address.getPort();
553         else
<span class="line-modified">554             return delegate.getPort();</span>
555     }
556 
557     @Override
558     protected void close() throws IOException {
559         if (cmdsock != null)
560             cmdsock.close();
561         cmdsock = null;
<span class="line-modified">562         delegate.close();</span>
563     }
564 
565     private String getUserName() {
566         return StaticProperty.userName();
567     }
<span class="line-added">568 </span>
<span class="line-added">569     @Override</span>
<span class="line-added">570     void reset() {</span>
<span class="line-added">571         throw new InternalError(&quot;should not get here&quot;);</span>
<span class="line-added">572     }</span>
573 }
</pre>
</td>
</tr>
</table>
<center><a href="SocketTimeoutException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StandardSocketOptions.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
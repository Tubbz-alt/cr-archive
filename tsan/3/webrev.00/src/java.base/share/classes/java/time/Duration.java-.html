<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/time/Duration.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file:
  31  *
  32  * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  33  *
  34  * All rights reserved.
  35  *
  36  * Redistribution and use in source and binary forms, with or without
  37  * modification, are permitted provided that the following conditions are met:
  38  *
  39  *  * Redistributions of source code must retain the above copyright notice,
  40  *    this list of conditions and the following disclaimer.
  41  *
  42  *  * Redistributions in binary form must reproduce the above copyright notice,
  43  *    this list of conditions and the following disclaimer in the documentation
  44  *    and/or other materials provided with the distribution.
  45  *
  46  *  * Neither the name of JSR-310 nor the names of its contributors
  47  *    may be used to endorse or promote products derived from this software
  48  *    without specific prior written permission.
  49  *
  50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  61  */
  62 package java.time;
  63 
  64 import static java.time.LocalTime.MINUTES_PER_HOUR;
  65 import static java.time.LocalTime.NANOS_PER_MILLI;
  66 import static java.time.LocalTime.NANOS_PER_SECOND;
  67 import static java.time.LocalTime.SECONDS_PER_DAY;
  68 import static java.time.LocalTime.SECONDS_PER_HOUR;
  69 import static java.time.LocalTime.SECONDS_PER_MINUTE;
  70 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  71 import static java.time.temporal.ChronoUnit.DAYS;
  72 import static java.time.temporal.ChronoUnit.NANOS;
  73 import static java.time.temporal.ChronoUnit.SECONDS;
  74 
  75 import java.io.DataInput;
  76 import java.io.DataOutput;
  77 import java.io.IOException;
  78 import java.io.InvalidObjectException;
  79 import java.io.ObjectInputStream;
  80 import java.io.Serializable;
  81 import java.math.BigDecimal;
  82 import java.math.BigInteger;
  83 import java.math.RoundingMode;
  84 import java.time.format.DateTimeParseException;
  85 import java.time.temporal.ChronoField;
  86 import java.time.temporal.ChronoUnit;
  87 import java.time.temporal.Temporal;
  88 import java.time.temporal.TemporalAmount;
  89 import java.time.temporal.TemporalUnit;
  90 import java.time.temporal.UnsupportedTemporalTypeException;
  91 import java.util.List;
  92 import java.util.Objects;
  93 import java.util.regex.Matcher;
  94 import java.util.regex.Pattern;
  95 
  96 /**
  97  * A time-based amount of time, such as &#39;34.5 seconds&#39;.
  98  * &lt;p&gt;
  99  * This class models a quantity or amount of time in terms of seconds and nanoseconds.
 100  * It can be accessed using other duration-based units, such as minutes and hours.
 101  * In addition, the {@link ChronoUnit#DAYS DAYS} unit can be used and is treated as
 102  * exactly equal to 24 hours, thus ignoring daylight savings effects.
 103  * See {@link Period} for the date-based equivalent to this class.
 104  * &lt;p&gt;
 105  * A physical duration could be of infinite length.
 106  * For practicality, the duration is stored with constraints similar to {@link Instant}.
 107  * The duration uses nanosecond resolution with a maximum value of the seconds that can
 108  * be held in a {@code long}. This is greater than the current estimated age of the universe.
 109  * &lt;p&gt;
 110  * The range of a duration requires the storage of a number larger than a {@code long}.
 111  * To achieve this, the class stores a {@code long} representing seconds and an {@code int}
 112  * representing nanosecond-of-second, which will always be between 0 and 999,999,999.
 113  * The model is of a directed duration, meaning that the duration may be negative.
 114  * &lt;p&gt;
 115  * The duration is measured in &quot;seconds&quot;, but these are not necessarily identical to
 116  * the scientific &quot;SI second&quot; definition based on atomic clocks.
 117  * This difference only impacts durations measured near a leap-second and should not affect
 118  * most applications.
 119  * See {@link Instant} for a discussion as to the meaning of the second and time-scales.
 120  *
 121  * &lt;p&gt;
 122  * This is a &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
 123  * class; use of identity-sensitive operations (including reference equality
 124  * ({@code ==}), identity hash code, or synchronization) on instances of
 125  * {@code Duration} may have unpredictable results and should be avoided.
 126  * The {@code equals} method should be used for comparisons.
 127  *
 128  * @implSpec
 129  * This class is immutable and thread-safe.
 130  *
 131  * @since 1.8
 132  */
 133 public final class Duration
 134         implements TemporalAmount, Comparable&lt;Duration&gt;, Serializable {
 135 
 136     /**
 137      * Constant for a duration of zero.
 138      */
 139     public static final Duration ZERO = new Duration(0, 0);
 140     /**
 141      * Serialization version.
 142      */
 143     private static final long serialVersionUID = 3078945930695997490L;
 144     /**
 145      * Constant for nanos per second.
 146      */
 147     private static final BigInteger BI_NANOS_PER_SECOND = BigInteger.valueOf(NANOS_PER_SECOND);
 148     /**
 149      * The pattern for parsing.
 150      */
 151     private static class Lazy {
 152         static final Pattern PATTERN =
 153             Pattern.compile(&quot;([-+]?)P(?:([-+]?[0-9]+)D)?&quot; +
 154                     &quot;(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?&quot;,
 155                     Pattern.CASE_INSENSITIVE);
 156     }
 157 
 158     /**
 159      * The number of seconds in the duration.
 160      */
 161     private final long seconds;
 162     /**
 163      * The number of nanoseconds in the duration, expressed as a fraction of the
 164      * number of seconds. This is always positive, and never exceeds 999,999,999.
 165      */
 166     private final int nanos;
 167 
 168     //-----------------------------------------------------------------------
 169     /**
 170      * Obtains a {@code Duration} representing a number of standard 24 hour days.
 171      * &lt;p&gt;
 172      * The seconds are calculated based on the standard definition of a day,
 173      * where each day is 86400 seconds which implies a 24 hour day.
 174      * The nanosecond in second field is set to zero.
 175      *
 176      * @param days  the number of days, positive or negative
 177      * @return a {@code Duration}, not null
 178      * @throws ArithmeticException if the input days exceeds the capacity of {@code Duration}
 179      */
 180     public static Duration ofDays(long days) {
 181         return create(Math.multiplyExact(days, SECONDS_PER_DAY), 0);
 182     }
 183 
 184     /**
 185      * Obtains a {@code Duration} representing a number of standard hours.
 186      * &lt;p&gt;
 187      * The seconds are calculated based on the standard definition of an hour,
 188      * where each hour is 3600 seconds.
 189      * The nanosecond in second field is set to zero.
 190      *
 191      * @param hours  the number of hours, positive or negative
 192      * @return a {@code Duration}, not null
 193      * @throws ArithmeticException if the input hours exceeds the capacity of {@code Duration}
 194      */
 195     public static Duration ofHours(long hours) {
 196         return create(Math.multiplyExact(hours, SECONDS_PER_HOUR), 0);
 197     }
 198 
 199     /**
 200      * Obtains a {@code Duration} representing a number of standard minutes.
 201      * &lt;p&gt;
 202      * The seconds are calculated based on the standard definition of a minute,
 203      * where each minute is 60 seconds.
 204      * The nanosecond in second field is set to zero.
 205      *
 206      * @param minutes  the number of minutes, positive or negative
 207      * @return a {@code Duration}, not null
 208      * @throws ArithmeticException if the input minutes exceeds the capacity of {@code Duration}
 209      */
 210     public static Duration ofMinutes(long minutes) {
 211         return create(Math.multiplyExact(minutes, SECONDS_PER_MINUTE), 0);
 212     }
 213 
 214     //-----------------------------------------------------------------------
 215     /**
 216      * Obtains a {@code Duration} representing a number of seconds.
 217      * &lt;p&gt;
 218      * The nanosecond in second field is set to zero.
 219      *
 220      * @param seconds  the number of seconds, positive or negative
 221      * @return a {@code Duration}, not null
 222      */
 223     public static Duration ofSeconds(long seconds) {
 224         return create(seconds, 0);
 225     }
 226 
 227     /**
 228      * Obtains a {@code Duration} representing a number of seconds and an
 229      * adjustment in nanoseconds.
 230      * &lt;p&gt;
 231      * This method allows an arbitrary number of nanoseconds to be passed in.
 232      * The factory will alter the values of the second and nanosecond in order
 233      * to ensure that the stored nanosecond is in the range 0 to 999,999,999.
 234      * For example, the following will result in exactly the same duration:
 235      * &lt;pre&gt;
 236      *  Duration.ofSeconds(3, 1);
 237      *  Duration.ofSeconds(4, -999_999_999);
 238      *  Duration.ofSeconds(2, 1000_000_001);
 239      * &lt;/pre&gt;
 240      *
 241      * @param seconds  the number of seconds, positive or negative
 242      * @param nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative
 243      * @return a {@code Duration}, not null
 244      * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@code Duration}
 245      */
 246     public static Duration ofSeconds(long seconds, long nanoAdjustment) {
 247         long secs = Math.addExact(seconds, Math.floorDiv(nanoAdjustment, NANOS_PER_SECOND));
 248         int nos = (int) Math.floorMod(nanoAdjustment, NANOS_PER_SECOND);
 249         return create(secs, nos);
 250     }
 251 
 252     //-----------------------------------------------------------------------
 253     /**
 254      * Obtains a {@code Duration} representing a number of milliseconds.
 255      * &lt;p&gt;
 256      * The seconds and nanoseconds are extracted from the specified milliseconds.
 257      *
 258      * @param millis  the number of milliseconds, positive or negative
 259      * @return a {@code Duration}, not null
 260      */
 261     public static Duration ofMillis(long millis) {
 262         long secs = millis / 1000;
 263         int mos = (int) (millis % 1000);
 264         if (mos &lt; 0) {
 265             mos += 1000;
 266             secs--;
 267         }
 268         return create(secs, mos * 1000_000);
 269     }
 270 
 271     //-----------------------------------------------------------------------
 272     /**
 273      * Obtains a {@code Duration} representing a number of nanoseconds.
 274      * &lt;p&gt;
 275      * The seconds and nanoseconds are extracted from the specified nanoseconds.
 276      *
 277      * @param nanos  the number of nanoseconds, positive or negative
 278      * @return a {@code Duration}, not null
 279      */
 280     public static Duration ofNanos(long nanos) {
 281         long secs = nanos / NANOS_PER_SECOND;
 282         int nos = (int) (nanos % NANOS_PER_SECOND);
 283         if (nos &lt; 0) {
 284             nos += NANOS_PER_SECOND;
 285             secs--;
 286         }
 287         return create(secs, nos);
 288     }
 289 
 290     //-----------------------------------------------------------------------
 291     /**
 292      * Obtains a {@code Duration} representing an amount in the specified unit.
 293      * &lt;p&gt;
 294      * The parameters represent the two parts of a phrase like &#39;6 Hours&#39;. For example:
 295      * &lt;pre&gt;
 296      *  Duration.of(3, SECONDS);
 297      *  Duration.of(465, HOURS);
 298      * &lt;/pre&gt;
 299      * Only a subset of units are accepted by this method.
 300      * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
 301      * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
 302      *
 303      * @param amount  the amount of the duration, measured in terms of the unit, positive or negative
 304      * @param unit  the unit that the duration is measured in, must have an exact duration, not null
 305      * @return a {@code Duration}, not null
 306      * @throws DateTimeException if the period unit has an estimated duration
 307      * @throws ArithmeticException if a numeric overflow occurs
 308      */
 309     public static Duration of(long amount, TemporalUnit unit) {
 310         return ZERO.plus(amount, unit);
 311     }
 312 
 313     //-----------------------------------------------------------------------
 314     /**
 315      * Obtains an instance of {@code Duration} from a temporal amount.
 316      * &lt;p&gt;
 317      * This obtains a duration based on the specified amount.
 318      * A {@code TemporalAmount} represents an  amount of time, which may be
 319      * date-based or time-based, which this factory extracts to a duration.
 320      * &lt;p&gt;
 321      * The conversion loops around the set of units from the amount and uses
 322      * the {@linkplain TemporalUnit#getDuration() duration} of the unit to
 323      * calculate the total {@code Duration}.
 324      * Only a subset of units are accepted by this method. The unit must either
 325      * have an {@linkplain TemporalUnit#isDurationEstimated() exact duration}
 326      * or be {@link ChronoUnit#DAYS} which is treated as 24 hours.
 327      * If any other units are found then an exception is thrown.
 328      *
 329      * @param amount  the temporal amount to convert, not null
 330      * @return the equivalent duration, not null
 331      * @throws DateTimeException if unable to convert to a {@code Duration}
 332      * @throws ArithmeticException if numeric overflow occurs
 333      */
 334     public static Duration from(TemporalAmount amount) {
 335         Objects.requireNonNull(amount, &quot;amount&quot;);
 336         Duration duration = ZERO;
 337         for (TemporalUnit unit : amount.getUnits()) {
 338             duration = duration.plus(amount.get(unit), unit);
 339         }
 340         return duration;
 341     }
 342 
 343     //-----------------------------------------------------------------------
 344     /**
 345      * Obtains a {@code Duration} from a text string such as {@code PnDTnHnMn.nS}.
 346      * &lt;p&gt;
 347      * This will parse a textual representation of a duration, including the
 348      * string produced by {@code toString()}. The formats accepted are based
 349      * on the ISO-8601 duration format {@code PnDTnHnMn.nS} with days
 350      * considered to be exactly 24 hours.
 351      * &lt;p&gt;
 352      * The string starts with an optional sign, denoted by the ASCII negative
 353      * or positive symbol. If negative, the whole period is negated.
 354      * The ASCII letter &quot;P&quot; is next in upper or lower case.
 355      * There are then four sections, each consisting of a number and a suffix.
 356      * The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for
 357      * days, hours, minutes and seconds, accepted in upper or lower case.
 358      * The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before
 359      * the first occurrence, if any, of an hour, minute or second section.
 360      * At least one of the four sections must be present, and if &quot;T&quot; is present
 361      * there must be at least one section after the &quot;T&quot;.
 362      * The number part of each section must consist of one or more ASCII digits.
 363      * The number may be prefixed by the ASCII negative or positive symbol.
 364      * The number of days, hours and minutes must parse to a {@code long}.
 365      * The number of seconds must parse to a {@code long} with optional fraction.
 366      * The decimal point may be either a dot or a comma.
 367      * The fractional part may have from zero to 9 digits.
 368      * &lt;p&gt;
 369      * The leading plus/minus sign, and negative values for other units are
 370      * not part of the ISO-8601 standard.
 371      * &lt;p&gt;
 372      * Examples:
 373      * &lt;pre&gt;
 374      *    &quot;PT20.345S&quot; -- parses as &quot;20.345 seconds&quot;
 375      *    &quot;PT15M&quot;     -- parses as &quot;15 minutes&quot; (where a minute is 60 seconds)
 376      *    &quot;PT10H&quot;     -- parses as &quot;10 hours&quot; (where an hour is 3600 seconds)
 377      *    &quot;P2D&quot;       -- parses as &quot;2 days&quot; (where a day is 24 hours or 86400 seconds)
 378      *    &quot;P2DT3H4M&quot;  -- parses as &quot;2 days, 3 hours and 4 minutes&quot;
 379      *    &quot;PT-6H3M&quot;    -- parses as &quot;-6 hours and +3 minutes&quot;
 380      *    &quot;-PT6H3M&quot;    -- parses as &quot;-6 hours and -3 minutes&quot;
 381      *    &quot;-PT-6H+3M&quot;  -- parses as &quot;+6 hours and -3 minutes&quot;
 382      * &lt;/pre&gt;
 383      *
 384      * @param text  the text to parse, not null
 385      * @return the parsed duration, not null
 386      * @throws DateTimeParseException if the text cannot be parsed to a duration
 387      */
 388     public static Duration parse(CharSequence text) {
 389         Objects.requireNonNull(text, &quot;text&quot;);
 390         Matcher matcher = Lazy.PATTERN.matcher(text);
 391         if (matcher.matches()) {
 392             // check for letter T but no time sections
 393             if (!charMatch(text, matcher.start(3), matcher.end(3), &#39;T&#39;)) {
 394                 boolean negate = charMatch(text, matcher.start(1), matcher.end(1), &#39;-&#39;);
 395 
 396                 int dayStart = matcher.start(2), dayEnd = matcher.end(2);
 397                 int hourStart = matcher.start(4), hourEnd = matcher.end(4);
 398                 int minuteStart = matcher.start(5), minuteEnd = matcher.end(5);
 399                 int secondStart = matcher.start(6), secondEnd = matcher.end(6);
 400                 int fractionStart = matcher.start(7), fractionEnd = matcher.end(7);
 401 
 402                 if (dayStart &gt;= 0 || hourStart &gt;= 0 || minuteStart &gt;= 0 || secondStart &gt;= 0) {
 403                     long daysAsSecs = parseNumber(text, dayStart, dayEnd, SECONDS_PER_DAY, &quot;days&quot;);
 404                     long hoursAsSecs = parseNumber(text, hourStart, hourEnd, SECONDS_PER_HOUR, &quot;hours&quot;);
 405                     long minsAsSecs = parseNumber(text, minuteStart, minuteEnd, SECONDS_PER_MINUTE, &quot;minutes&quot;);
 406                     long seconds = parseNumber(text, secondStart, secondEnd, 1, &quot;seconds&quot;);
 407                     boolean negativeSecs = secondStart &gt;= 0 &amp;&amp; text.charAt(secondStart) == &#39;-&#39;;
 408                     int nanos = parseFraction(text, fractionStart, fractionEnd, negativeSecs ? -1 : 1);
 409                     try {
 410                         return create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
 411                     } catch (ArithmeticException ex) {
 412                         throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: overflow&quot;, text, 0).initCause(ex);
 413                     }
 414                 }
 415             }
 416         }
 417         throw new DateTimeParseException(&quot;Text cannot be parsed to a Duration&quot;, text, 0);
 418     }
 419 
 420     private static boolean charMatch(CharSequence text, int start, int end, char c) {
 421         return (start &gt;= 0 &amp;&amp; end == start + 1 &amp;&amp; text.charAt(start) == c);
 422     }
 423 
 424     private static long parseNumber(CharSequence text, int start, int end, int multiplier, String errorText) {
 425         // regex limits to [-+]?[0-9]+
 426         if (start &lt; 0 || end &lt; 0) {
 427             return 0;
 428         }
 429         try {
 430             long val = Long.parseLong(text, start, end, 10);
 431             return Math.multiplyExact(val, multiplier);
 432         } catch (NumberFormatException | ArithmeticException ex) {
 433             throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: &quot; + errorText, text, 0).initCause(ex);
 434         }
 435     }
 436 
 437     private static int parseFraction(CharSequence text, int start, int end, int negate) {
 438         // regex limits to [0-9]{0,9}
 439         if (start &lt; 0 || end &lt; 0 || end - start == 0) {
 440             return 0;
 441         }
 442         try {
 443             int fraction = Integer.parseInt(text, start, end, 10);
 444 
 445             // for number strings smaller than 9 digits, interpret as if there
 446             // were trailing zeros
 447             for (int i = end - start; i &lt; 9; i++) {
 448                 fraction *= 10;
 449             }
 450             return fraction * negate;
 451         } catch (NumberFormatException | ArithmeticException ex) {
 452             throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: fraction&quot;, text, 0).initCause(ex);
 453         }
 454     }
 455 
 456     private static Duration create(boolean negate, long daysAsSecs, long hoursAsSecs, long minsAsSecs, long secs, int nanos) {
 457         long seconds = Math.addExact(daysAsSecs, Math.addExact(hoursAsSecs, Math.addExact(minsAsSecs, secs)));
 458         if (negate) {
 459             return ofSeconds(seconds, nanos).negated();
 460         }
 461         return ofSeconds(seconds, nanos);
 462     }
 463 
 464     //-----------------------------------------------------------------------
 465     /**
 466      * Obtains a {@code Duration} representing the duration between two temporal objects.
 467      * &lt;p&gt;
 468      * This calculates the duration between two temporal objects. If the objects
 469      * are of different types, then the duration is calculated based on the type
 470      * of the first object. For example, if the first argument is a {@code LocalTime}
 471      * then the second argument is converted to a {@code LocalTime}.
 472      * &lt;p&gt;
 473      * The specified temporal objects must support the {@link ChronoUnit#SECONDS SECONDS} unit.
 474      * For full accuracy, either the {@link ChronoUnit#NANOS NANOS} unit or the
 475      * {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} field should be supported.
 476      * &lt;p&gt;
 477      * The result of this method can be a negative period if the end is before the start.
 478      * To guarantee to obtain a positive duration call {@link #abs()} on the result.
 479      *
 480      * @param startInclusive  the start instant, inclusive, not null
 481      * @param endExclusive  the end instant, exclusive, not null
 482      * @return a {@code Duration}, not null
 483      * @throws DateTimeException if the seconds between the temporals cannot be obtained
 484      * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}
 485      */
 486     public static Duration between(Temporal startInclusive, Temporal endExclusive) {
 487         try {
 488             return ofNanos(startInclusive.until(endExclusive, NANOS));
 489         } catch (DateTimeException | ArithmeticException ex) {
 490             long secs = startInclusive.until(endExclusive, SECONDS);
 491             long nanos;
 492             try {
 493                 nanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);
 494                 if (secs &gt; 0 &amp;&amp; nanos &lt; 0) {
 495                     secs++;
 496                 } else if (secs &lt; 0 &amp;&amp; nanos &gt; 0) {
 497                     secs--;
 498                 }
 499             } catch (DateTimeException ex2) {
 500                 nanos = 0;
 501             }
 502             return ofSeconds(secs, nanos);
 503         }
 504     }
 505 
 506     //-----------------------------------------------------------------------
 507     /**
 508      * Obtains an instance of {@code Duration} using seconds and nanoseconds.
 509      *
 510      * @param seconds  the length of the duration in seconds, positive or negative
 511      * @param nanoAdjustment  the nanosecond adjustment within the second, from 0 to 999,999,999
 512      */
 513     private static Duration create(long seconds, int nanoAdjustment) {
 514         if ((seconds | nanoAdjustment) == 0) {
 515             return ZERO;
 516         }
 517         return new Duration(seconds, nanoAdjustment);
 518     }
 519 
 520     /**
 521      * Constructs an instance of {@code Duration} using seconds and nanoseconds.
 522      *
 523      * @param seconds  the length of the duration in seconds, positive or negative
 524      * @param nanos  the nanoseconds within the second, from 0 to 999,999,999
 525      */
 526     private Duration(long seconds, int nanos) {
 527         super();
 528         this.seconds = seconds;
 529         this.nanos = nanos;
 530     }
 531 
 532     //-----------------------------------------------------------------------
 533     /**
 534      * Gets the value of the requested unit.
 535      * &lt;p&gt;
 536      * This returns a value for each of the two supported units,
 537      * {@link ChronoUnit#SECONDS SECONDS} and {@link ChronoUnit#NANOS NANOS}.
 538      * All other units throw an exception.
 539      *
 540      * @param unit the {@code TemporalUnit} for which to return the value
 541      * @return the long value of the unit
 542      * @throws DateTimeException if the unit is not supported
 543      * @throws UnsupportedTemporalTypeException if the unit is not supported
 544      */
 545     @Override
 546     public long get(TemporalUnit unit) {
 547         if (unit == SECONDS) {
 548             return seconds;
 549         } else if (unit == NANOS) {
 550             return nanos;
 551         } else {
 552             throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);
 553         }
 554     }
 555 
 556     /**
 557      * Gets the set of units supported by this duration.
 558      * &lt;p&gt;
 559      * The supported units are {@link ChronoUnit#SECONDS SECONDS},
 560      * and {@link ChronoUnit#NANOS NANOS}.
 561      * They are returned in the order seconds, nanos.
 562      * &lt;p&gt;
 563      * This set can be used in conjunction with {@link #get(TemporalUnit)}
 564      * to access the entire state of the duration.
 565      *
 566      * @return a list containing the seconds and nanos units, not null
 567      */
 568     @Override
 569     public List&lt;TemporalUnit&gt; getUnits() {
 570         return DurationUnits.UNITS;
 571     }
 572 
 573     /**
 574      * Private class to delay initialization of this list until needed.
 575      * The circular dependency between Duration and ChronoUnit prevents
 576      * the simple initialization in Duration.
 577      */
 578     private static class DurationUnits {
 579         static final List&lt;TemporalUnit&gt; UNITS = List.of(SECONDS, NANOS);
 580     }
 581 
 582     //-----------------------------------------------------------------------
 583     /**
 584      * Checks if this duration is zero length.
 585      * &lt;p&gt;
 586      * A {@code Duration} represents a directed distance between two points on
 587      * the time-line and can therefore be positive, zero or negative.
 588      * This method checks whether the length is zero.
 589      *
 590      * @return true if this duration has a total length equal to zero
 591      */
 592     public boolean isZero() {
 593         return (seconds | nanos) == 0;
 594     }
 595 
 596     /**
 597      * Checks if this duration is negative, excluding zero.
 598      * &lt;p&gt;
 599      * A {@code Duration} represents a directed distance between two points on
 600      * the time-line and can therefore be positive, zero or negative.
 601      * This method checks whether the length is less than zero.
 602      *
 603      * @return true if this duration has a total length less than zero
 604      */
 605     public boolean isNegative() {
 606         return seconds &lt; 0;
 607     }
 608 
 609     //-----------------------------------------------------------------------
 610     /**
 611      * Gets the number of seconds in this duration.
 612      * &lt;p&gt;
 613      * The length of the duration is stored using two fields - seconds and nanoseconds.
 614      * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
 615      * the length in seconds.
 616      * The total duration is defined by calling this method and {@link #getNano()}.
 617      * &lt;p&gt;
 618      * A {@code Duration} represents a directed distance between two points on the time-line.
 619      * A negative duration is expressed by the negative sign of the seconds part.
 620      * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
 621      *
 622      * @return the whole seconds part of the length of the duration, positive or negative
 623      */
 624     public long getSeconds() {
 625         return seconds;
 626     }
 627 
 628     /**
 629      * Gets the number of nanoseconds within the second in this duration.
 630      * &lt;p&gt;
 631      * The length of the duration is stored using two fields - seconds and nanoseconds.
 632      * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
 633      * the length in seconds.
 634      * The total duration is defined by calling this method and {@link #getSeconds()}.
 635      * &lt;p&gt;
 636      * A {@code Duration} represents a directed distance between two points on the time-line.
 637      * A negative duration is expressed by the negative sign of the seconds part.
 638      * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
 639      *
 640      * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
 641      */
 642     public int getNano() {
 643         return nanos;
 644     }
 645 
 646     //-----------------------------------------------------------------------
 647     /**
 648      * Returns a copy of this duration with the specified amount of seconds.
 649      * &lt;p&gt;
 650      * This returns a duration with the specified seconds, retaining the
 651      * nano-of-second part of this duration.
 652      * &lt;p&gt;
 653      * This instance is immutable and unaffected by this method call.
 654      *
 655      * @param seconds  the seconds to represent, may be negative
 656      * @return a {@code Duration} based on this period with the requested seconds, not null
 657      */
 658     public Duration withSeconds(long seconds) {
 659         return create(seconds, nanos);
 660     }
 661 
 662     /**
 663      * Returns a copy of this duration with the specified nano-of-second.
 664      * &lt;p&gt;
 665      * This returns a duration with the specified nano-of-second, retaining the
 666      * seconds part of this duration.
 667      * &lt;p&gt;
 668      * This instance is immutable and unaffected by this method call.
 669      *
 670      * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
 671      * @return a {@code Duration} based on this period with the requested nano-of-second, not null
 672      * @throws DateTimeException if the nano-of-second is invalid
 673      */
 674     public Duration withNanos(int nanoOfSecond) {
 675         NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
 676         return create(seconds, nanoOfSecond);
 677     }
 678 
 679     //-----------------------------------------------------------------------
 680     /**
 681      * Returns a copy of this duration with the specified duration added.
 682      * &lt;p&gt;
 683      * This instance is immutable and unaffected by this method call.
 684      *
 685      * @param duration  the duration to add, positive or negative, not null
 686      * @return a {@code Duration} based on this duration with the specified duration added, not null
 687      * @throws ArithmeticException if numeric overflow occurs
 688      */
 689     public Duration plus(Duration duration) {
 690         return plus(duration.getSeconds(), duration.getNano());
 691      }
 692 
 693     /**
 694      * Returns a copy of this duration with the specified duration added.
 695      * &lt;p&gt;
 696      * The duration amount is measured in terms of the specified unit.
 697      * Only a subset of units are accepted by this method.
 698      * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
 699      * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
 700      * &lt;p&gt;
 701      * This instance is immutable and unaffected by this method call.
 702      *
 703      * @param amountToAdd  the amount to add, measured in terms of the unit, positive or negative
 704      * @param unit  the unit that the amount is measured in, must have an exact duration, not null
 705      * @return a {@code Duration} based on this duration with the specified duration added, not null
 706      * @throws UnsupportedTemporalTypeException if the unit is not supported
 707      * @throws ArithmeticException if numeric overflow occurs
 708      */
 709     public Duration plus(long amountToAdd, TemporalUnit unit) {
 710         Objects.requireNonNull(unit, &quot;unit&quot;);
 711         if (unit == DAYS) {
 712             return plus(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY), 0);
 713         }
 714         if (unit.isDurationEstimated()) {
 715             throw new UnsupportedTemporalTypeException(&quot;Unit must not have an estimated duration&quot;);
 716         }
 717         if (amountToAdd == 0) {
 718             return this;
 719         }
 720         if (unit instanceof ChronoUnit) {
 721             switch ((ChronoUnit) unit) {
 722                 case NANOS: return plusNanos(amountToAdd);
 723                 case MICROS: return plusSeconds((amountToAdd / (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);
 724                 case MILLIS: return plusMillis(amountToAdd);
 725                 case SECONDS: return plusSeconds(amountToAdd);
 726             }
 727             return plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));
 728         }
 729         Duration duration = unit.getDuration().multipliedBy(amountToAdd);
 730         return plusSeconds(duration.getSeconds()).plusNanos(duration.getNano());
 731     }
 732 
 733     //-----------------------------------------------------------------------
 734     /**
 735      * Returns a copy of this duration with the specified duration in standard 24 hour days added.
 736      * &lt;p&gt;
 737      * The number of days is multiplied by 86400 to obtain the number of seconds to add.
 738      * This is based on the standard definition of a day as 24 hours.
 739      * &lt;p&gt;
 740      * This instance is immutable and unaffected by this method call.
 741      *
 742      * @param daysToAdd  the days to add, positive or negative
 743      * @return a {@code Duration} based on this duration with the specified days added, not null
 744      * @throws ArithmeticException if numeric overflow occurs
 745      */
 746     public Duration plusDays(long daysToAdd) {
 747         return plus(Math.multiplyExact(daysToAdd, SECONDS_PER_DAY), 0);
 748     }
 749 
 750     /**
 751      * Returns a copy of this duration with the specified duration in hours added.
 752      * &lt;p&gt;
 753      * This instance is immutable and unaffected by this method call.
 754      *
 755      * @param hoursToAdd  the hours to add, positive or negative
 756      * @return a {@code Duration} based on this duration with the specified hours added, not null
 757      * @throws ArithmeticException if numeric overflow occurs
 758      */
 759     public Duration plusHours(long hoursToAdd) {
 760         return plus(Math.multiplyExact(hoursToAdd, SECONDS_PER_HOUR), 0);
 761     }
 762 
 763     /**
 764      * Returns a copy of this duration with the specified duration in minutes added.
 765      * &lt;p&gt;
 766      * This instance is immutable and unaffected by this method call.
 767      *
 768      * @param minutesToAdd  the minutes to add, positive or negative
 769      * @return a {@code Duration} based on this duration with the specified minutes added, not null
 770      * @throws ArithmeticException if numeric overflow occurs
 771      */
 772     public Duration plusMinutes(long minutesToAdd) {
 773         return plus(Math.multiplyExact(minutesToAdd, SECONDS_PER_MINUTE), 0);
 774     }
 775 
 776     /**
 777      * Returns a copy of this duration with the specified duration in seconds added.
 778      * &lt;p&gt;
 779      * This instance is immutable and unaffected by this method call.
 780      *
 781      * @param secondsToAdd  the seconds to add, positive or negative
 782      * @return a {@code Duration} based on this duration with the specified seconds added, not null
 783      * @throws ArithmeticException if numeric overflow occurs
 784      */
 785     public Duration plusSeconds(long secondsToAdd) {
 786         return plus(secondsToAdd, 0);
 787     }
 788 
 789     /**
 790      * Returns a copy of this duration with the specified duration in milliseconds added.
 791      * &lt;p&gt;
 792      * This instance is immutable and unaffected by this method call.
 793      *
 794      * @param millisToAdd  the milliseconds to add, positive or negative
 795      * @return a {@code Duration} based on this duration with the specified milliseconds added, not null
 796      * @throws ArithmeticException if numeric overflow occurs
 797      */
 798     public Duration plusMillis(long millisToAdd) {
 799         return plus(millisToAdd / 1000, (millisToAdd % 1000) * 1000_000);
 800     }
 801 
 802     /**
 803      * Returns a copy of this duration with the specified duration in nanoseconds added.
 804      * &lt;p&gt;
 805      * This instance is immutable and unaffected by this method call.
 806      *
 807      * @param nanosToAdd  the nanoseconds to add, positive or negative
 808      * @return a {@code Duration} based on this duration with the specified nanoseconds added, not null
 809      * @throws ArithmeticException if numeric overflow occurs
 810      */
 811     public Duration plusNanos(long nanosToAdd) {
 812         return plus(0, nanosToAdd);
 813     }
 814 
 815     /**
 816      * Returns a copy of this duration with the specified duration added.
 817      * &lt;p&gt;
 818      * This instance is immutable and unaffected by this method call.
 819      *
 820      * @param secondsToAdd  the seconds to add, positive or negative
 821      * @param nanosToAdd  the nanos to add, positive or negative
 822      * @return a {@code Duration} based on this duration with the specified seconds added, not null
 823      * @throws ArithmeticException if numeric overflow occurs
 824      */
 825     private Duration plus(long secondsToAdd, long nanosToAdd) {
 826         if ((secondsToAdd | nanosToAdd) == 0) {
 827             return this;
 828         }
 829         long epochSec = Math.addExact(seconds, secondsToAdd);
 830         epochSec = Math.addExact(epochSec, nanosToAdd / NANOS_PER_SECOND);
 831         nanosToAdd = nanosToAdd % NANOS_PER_SECOND;
 832         long nanoAdjustment = nanos + nanosToAdd;  // safe int+NANOS_PER_SECOND
 833         return ofSeconds(epochSec, nanoAdjustment);
 834     }
 835 
 836     //-----------------------------------------------------------------------
 837     /**
 838      * Returns a copy of this duration with the specified duration subtracted.
 839      * &lt;p&gt;
 840      * This instance is immutable and unaffected by this method call.
 841      *
 842      * @param duration  the duration to subtract, positive or negative, not null
 843      * @return a {@code Duration} based on this duration with the specified duration subtracted, not null
 844      * @throws ArithmeticException if numeric overflow occurs
 845      */
 846     public Duration minus(Duration duration) {
 847         long secsToSubtract = duration.getSeconds();
 848         int nanosToSubtract = duration.getNano();
 849         if (secsToSubtract == Long.MIN_VALUE) {
 850             return plus(Long.MAX_VALUE, -nanosToSubtract).plus(1, 0);
 851         }
 852         return plus(-secsToSubtract, -nanosToSubtract);
 853      }
 854 
 855     /**
 856      * Returns a copy of this duration with the specified duration subtracted.
 857      * &lt;p&gt;
 858      * The duration amount is measured in terms of the specified unit.
 859      * Only a subset of units are accepted by this method.
 860      * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
 861      * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
 862      * &lt;p&gt;
 863      * This instance is immutable and unaffected by this method call.
 864      *
 865      * @param amountToSubtract  the amount to subtract, measured in terms of the unit, positive or negative
 866      * @param unit  the unit that the amount is measured in, must have an exact duration, not null
 867      * @return a {@code Duration} based on this duration with the specified duration subtracted, not null
 868      * @throws ArithmeticException if numeric overflow occurs
 869      */
 870     public Duration minus(long amountToSubtract, TemporalUnit unit) {
 871         return (amountToSubtract == Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));
 872     }
 873 
 874     //-----------------------------------------------------------------------
 875     /**
 876      * Returns a copy of this duration with the specified duration in standard 24 hour days subtracted.
 877      * &lt;p&gt;
 878      * The number of days is multiplied by 86400 to obtain the number of seconds to subtract.
 879      * This is based on the standard definition of a day as 24 hours.
 880      * &lt;p&gt;
 881      * This instance is immutable and unaffected by this method call.
 882      *
 883      * @param daysToSubtract  the days to subtract, positive or negative
 884      * @return a {@code Duration} based on this duration with the specified days subtracted, not null
 885      * @throws ArithmeticException if numeric overflow occurs
 886      */
 887     public Duration minusDays(long daysToSubtract) {
 888         return (daysToSubtract == Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));
 889     }
 890 
 891     /**
 892      * Returns a copy of this duration with the specified duration in hours subtracted.
 893      * &lt;p&gt;
 894      * The number of hours is multiplied by 3600 to obtain the number of seconds to subtract.
 895      * &lt;p&gt;
 896      * This instance is immutable and unaffected by this method call.
 897      *
 898      * @param hoursToSubtract  the hours to subtract, positive or negative
 899      * @return a {@code Duration} based on this duration with the specified hours subtracted, not null
 900      * @throws ArithmeticException if numeric overflow occurs
 901      */
 902     public Duration minusHours(long hoursToSubtract) {
 903         return (hoursToSubtract == Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hoursToSubtract));
 904     }
 905 
 906     /**
 907      * Returns a copy of this duration with the specified duration in minutes subtracted.
 908      * &lt;p&gt;
 909      * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.
 910      * &lt;p&gt;
 911      * This instance is immutable and unaffected by this method call.
 912      *
 913      * @param minutesToSubtract  the minutes to subtract, positive or negative
 914      * @return a {@code Duration} based on this duration with the specified minutes subtracted, not null
 915      * @throws ArithmeticException if numeric overflow occurs
 916      */
 917     public Duration minusMinutes(long minutesToSubtract) {
 918         return (minutesToSubtract == Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutesToSubtract));
 919     }
 920 
 921     /**
 922      * Returns a copy of this duration with the specified duration in seconds subtracted.
 923      * &lt;p&gt;
 924      * This instance is immutable and unaffected by this method call.
 925      *
 926      * @param secondsToSubtract  the seconds to subtract, positive or negative
 927      * @return a {@code Duration} based on this duration with the specified seconds subtracted, not null
 928      * @throws ArithmeticException if numeric overflow occurs
 929      */
 930     public Duration minusSeconds(long secondsToSubtract) {
 931         return (secondsToSubtract == Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-secondsToSubtract));
 932     }
 933 
 934     /**
 935      * Returns a copy of this duration with the specified duration in milliseconds subtracted.
 936      * &lt;p&gt;
 937      * This instance is immutable and unaffected by this method call.
 938      *
 939      * @param millisToSubtract  the milliseconds to subtract, positive or negative
 940      * @return a {@code Duration} based on this duration with the specified milliseconds subtracted, not null
 941      * @throws ArithmeticException if numeric overflow occurs
 942      */
 943     public Duration minusMillis(long millisToSubtract) {
 944         return (millisToSubtract == Long.MIN_VALUE ? plusMillis(Long.MAX_VALUE).plusMillis(1) : plusMillis(-millisToSubtract));
 945     }
 946 
 947     /**
 948      * Returns a copy of this duration with the specified duration in nanoseconds subtracted.
 949      * &lt;p&gt;
 950      * This instance is immutable and unaffected by this method call.
 951      *
 952      * @param nanosToSubtract  the nanoseconds to subtract, positive or negative
 953      * @return a {@code Duration} based on this duration with the specified nanoseconds subtracted, not null
 954      * @throws ArithmeticException if numeric overflow occurs
 955      */
 956     public Duration minusNanos(long nanosToSubtract) {
 957         return (nanosToSubtract == Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanosToSubtract));
 958     }
 959 
 960     //-----------------------------------------------------------------------
 961     /**
 962      * Returns a copy of this duration multiplied by the scalar.
 963      * &lt;p&gt;
 964      * This instance is immutable and unaffected by this method call.
 965      *
 966      * @param multiplicand  the value to multiply the duration by, positive or negative
 967      * @return a {@code Duration} based on this duration multiplied by the specified scalar, not null
 968      * @throws ArithmeticException if numeric overflow occurs
 969      */
 970     public Duration multipliedBy(long multiplicand) {
 971         if (multiplicand == 0) {
 972             return ZERO;
 973         }
 974         if (multiplicand == 1) {
 975             return this;
 976         }
 977         return create(toBigDecimalSeconds().multiply(BigDecimal.valueOf(multiplicand)));
 978      }
 979 
 980     /**
 981      * Returns a copy of this duration divided by the specified value.
 982      * &lt;p&gt;
 983      * This instance is immutable and unaffected by this method call.
 984      *
 985      * @param divisor  the value to divide the duration by, positive or negative, not zero
 986      * @return a {@code Duration} based on this duration divided by the specified divisor, not null
 987      * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs
 988      */
 989     public Duration dividedBy(long divisor) {
 990         if (divisor == 0) {
 991             throw new ArithmeticException(&quot;Cannot divide by zero&quot;);
 992         }
 993         if (divisor == 1) {
 994             return this;
 995         }
 996         return create(toBigDecimalSeconds().divide(BigDecimal.valueOf(divisor), RoundingMode.DOWN));
 997      }
 998 
 999     /**
1000      * Returns number of whole times a specified Duration occurs within this Duration.
1001      * &lt;p&gt;
1002      * This instance is immutable and unaffected by this method call.
1003      *
1004      * @param divisor the value to divide the duration by, positive or negative, not null
1005      * @return number of whole times, rounded toward zero, a specified
1006      *         {@code Duration} occurs within this Duration, may be negative
1007      * @throws ArithmeticException if the divisor is zero, or if numeric overflow occurs
1008      * @since 9
1009      */
1010     public long dividedBy(Duration divisor) {
1011         Objects.requireNonNull(divisor, &quot;divisor&quot;);
1012         BigDecimal dividendBigD = toBigDecimalSeconds();
1013         BigDecimal divisorBigD = divisor.toBigDecimalSeconds();
1014         return dividendBigD.divideToIntegralValue(divisorBigD).longValueExact();
1015     }
1016 
1017     /**
1018      * Converts this duration to the total length in seconds and
1019      * fractional nanoseconds expressed as a {@code BigDecimal}.
1020      *
1021      * @return the total length of the duration in seconds, with a scale of 9, not null
1022      */
1023     private BigDecimal toBigDecimalSeconds() {
1024         return BigDecimal.valueOf(seconds).add(BigDecimal.valueOf(nanos, 9));
1025     }
1026 
1027     /**
1028      * Creates an instance of {@code Duration} from a number of seconds.
1029      *
1030      * @param seconds  the number of seconds, up to scale 9, positive or negative
1031      * @return a {@code Duration}, not null
1032      * @throws ArithmeticException if numeric overflow occurs
1033      */
1034     private static Duration create(BigDecimal seconds) {
1035         BigInteger nanos = seconds.movePointRight(9).toBigIntegerExact();
1036         BigInteger[] divRem = nanos.divideAndRemainder(BI_NANOS_PER_SECOND);
1037         if (divRem[0].bitLength() &gt; 63) {
1038             throw new ArithmeticException(&quot;Exceeds capacity of Duration: &quot; + nanos);
1039         }
1040         return ofSeconds(divRem[0].longValue(), divRem[1].intValue());
1041     }
1042 
1043     //-----------------------------------------------------------------------
1044     /**
1045      * Returns a copy of this duration with the length negated.
1046      * &lt;p&gt;
1047      * This method swaps the sign of the total length of this duration.
1048      * For example, {@code PT1.3S} will be returned as {@code PT-1.3S}.
1049      * &lt;p&gt;
1050      * This instance is immutable and unaffected by this method call.
1051      *
1052      * @return a {@code Duration} based on this duration with the amount negated, not null
1053      * @throws ArithmeticException if numeric overflow occurs
1054      */
1055     public Duration negated() {
1056         return multipliedBy(-1);
1057     }
1058 
1059     /**
1060      * Returns a copy of this duration with a positive length.
1061      * &lt;p&gt;
1062      * This method returns a positive duration by effectively removing the sign from any negative total length.
1063      * For example, {@code PT-1.3S} will be returned as {@code PT1.3S}.
1064      * &lt;p&gt;
1065      * This instance is immutable and unaffected by this method call.
1066      *
1067      * @return a {@code Duration} based on this duration with an absolute length, not null
1068      * @throws ArithmeticException if numeric overflow occurs
1069      */
1070     public Duration abs() {
1071         return isNegative() ? negated() : this;
1072     }
1073 
1074     //-------------------------------------------------------------------------
1075     /**
1076      * Adds this duration to the specified temporal object.
1077      * &lt;p&gt;
1078      * This returns a temporal object of the same observable type as the input
1079      * with this duration added.
1080      * &lt;p&gt;
1081      * In most cases, it is clearer to reverse the calling pattern by using
1082      * {@link Temporal#plus(TemporalAmount)}.
1083      * &lt;pre&gt;
1084      *   // these two lines are equivalent, but the second approach is recommended
1085      *   dateTime = thisDuration.addTo(dateTime);
1086      *   dateTime = dateTime.plus(thisDuration);
1087      * &lt;/pre&gt;
1088      * &lt;p&gt;
1089      * The calculation will add the seconds, then nanos.
1090      * Only non-zero amounts will be added.
1091      * &lt;p&gt;
1092      * This instance is immutable and unaffected by this method call.
1093      *
1094      * @param temporal  the temporal object to adjust, not null
1095      * @return an object of the same type with the adjustment made, not null
1096      * @throws DateTimeException if unable to add
1097      * @throws ArithmeticException if numeric overflow occurs
1098      */
1099     @Override
1100     public Temporal addTo(Temporal temporal) {
1101         if (seconds != 0) {
1102             temporal = temporal.plus(seconds, SECONDS);
1103         }
1104         if (nanos != 0) {
1105             temporal = temporal.plus(nanos, NANOS);
1106         }
1107         return temporal;
1108     }
1109 
1110     /**
1111      * Subtracts this duration from the specified temporal object.
1112      * &lt;p&gt;
1113      * This returns a temporal object of the same observable type as the input
1114      * with this duration subtracted.
1115      * &lt;p&gt;
1116      * In most cases, it is clearer to reverse the calling pattern by using
1117      * {@link Temporal#minus(TemporalAmount)}.
1118      * &lt;pre&gt;
1119      *   // these two lines are equivalent, but the second approach is recommended
1120      *   dateTime = thisDuration.subtractFrom(dateTime);
1121      *   dateTime = dateTime.minus(thisDuration);
1122      * &lt;/pre&gt;
1123      * &lt;p&gt;
1124      * The calculation will subtract the seconds, then nanos.
1125      * Only non-zero amounts will be added.
1126      * &lt;p&gt;
1127      * This instance is immutable and unaffected by this method call.
1128      *
1129      * @param temporal  the temporal object to adjust, not null
1130      * @return an object of the same type with the adjustment made, not null
1131      * @throws DateTimeException if unable to subtract
1132      * @throws ArithmeticException if numeric overflow occurs
1133      */
1134     @Override
1135     public Temporal subtractFrom(Temporal temporal) {
1136         if (seconds != 0) {
1137             temporal = temporal.minus(seconds, SECONDS);
1138         }
1139         if (nanos != 0) {
1140             temporal = temporal.minus(nanos, NANOS);
1141         }
1142         return temporal;
1143     }
1144 
1145     //-----------------------------------------------------------------------
1146     /**
1147      * Gets the number of days in this duration.
1148      * &lt;p&gt;
1149      * This returns the total number of days in the duration by dividing the
1150      * number of seconds by 86400.
1151      * This is based on the standard definition of a day as 24 hours.
1152      * &lt;p&gt;
1153      * This instance is immutable and unaffected by this method call.
1154      *
1155      * @return the number of days in the duration, may be negative
1156      */
1157     public long toDays() {
1158         return seconds / SECONDS_PER_DAY;
1159     }
1160 
1161     /**
1162      * Gets the number of hours in this duration.
1163      * &lt;p&gt;
1164      * This returns the total number of hours in the duration by dividing the
1165      * number of seconds by 3600.
1166      * &lt;p&gt;
1167      * This instance is immutable and unaffected by this method call.
1168      *
1169      * @return the number of hours in the duration, may be negative
1170      */
1171     public long toHours() {
1172         return seconds / SECONDS_PER_HOUR;
1173     }
1174 
1175     /**
1176      * Gets the number of minutes in this duration.
1177      * &lt;p&gt;
1178      * This returns the total number of minutes in the duration by dividing the
1179      * number of seconds by 60.
1180      * &lt;p&gt;
1181      * This instance is immutable and unaffected by this method call.
1182      *
1183      * @return the number of minutes in the duration, may be negative
1184      */
1185     public long toMinutes() {
1186         return seconds / SECONDS_PER_MINUTE;
1187     }
1188 
1189     /**
1190      * Gets the number of seconds in this duration.
1191      * &lt;p&gt;
1192      * This returns the total number of whole seconds in the duration.
1193      * &lt;p&gt;
1194      * This instance is immutable and unaffected by this method call.
1195      *
1196      * @return the whole seconds part of the length of the duration, positive or negative
1197      * @since 9
1198      */
1199     public long toSeconds() {
1200         return seconds;
1201     }
1202 
1203     /**
1204      * Converts this duration to the total length in milliseconds.
1205      * &lt;p&gt;
1206      * If this duration is too large to fit in a {@code long} milliseconds, then an
1207      * exception is thrown.
1208      * &lt;p&gt;
1209      * If this duration has greater than millisecond precision, then the conversion
1210      * will drop any excess precision information as though the amount in nanoseconds
1211      * was subject to integer division by one million.
1212      *
1213      * @return the total length of the duration in milliseconds
1214      * @throws ArithmeticException if numeric overflow occurs
1215      */
1216     public long toMillis() {
1217         long tempSeconds = seconds;
1218         long tempNanos = nanos;
1219         if (tempSeconds &lt; 0) {
1220             // change the seconds and nano value to
1221             // handle Long.MIN_VALUE case
1222             tempSeconds = tempSeconds + 1;
1223             tempNanos = tempNanos - NANOS_PER_SECOND;
1224         }
1225         long millis = Math.multiplyExact(tempSeconds, 1000);
1226         millis = Math.addExact(millis, tempNanos / NANOS_PER_MILLI);
1227         return millis;
1228     }
1229 
1230     /**
1231      * Converts this duration to the total length in nanoseconds expressed as a {@code long}.
1232      * &lt;p&gt;
1233      * If this duration is too large to fit in a {@code long} nanoseconds, then an
1234      * exception is thrown.
1235      *
1236      * @return the total length of the duration in nanoseconds
1237      * @throws ArithmeticException if numeric overflow occurs
1238      */
1239     public long toNanos() {
1240         long tempSeconds = seconds;
1241         long tempNanos = nanos;
1242         if (tempSeconds &lt; 0) {
1243             // change the seconds and nano value to
1244             // handle Long.MIN_VALUE case
1245             tempSeconds = tempSeconds + 1;
1246             tempNanos = tempNanos - NANOS_PER_SECOND;
1247         }
1248         long totalNanos = Math.multiplyExact(tempSeconds, NANOS_PER_SECOND);
1249         totalNanos = Math.addExact(totalNanos, tempNanos);
1250         return totalNanos;
1251     }
1252 
1253     /**
1254      * Extracts the number of days in the duration.
1255      * &lt;p&gt;
1256      * This returns the total number of days in the duration by dividing the
1257      * number of seconds by 86400.
1258      * This is based on the standard definition of a day as 24 hours.
1259      * &lt;p&gt;
1260      * This instance is immutable and unaffected by this method call.
1261      *
1262      * @return the number of days in the duration, may be negative
1263      * @since 9
1264      */
1265     public long toDaysPart(){
1266         return seconds / SECONDS_PER_DAY;
1267     }
1268 
1269     /**
1270      * Extracts the number of hours part in the duration.
1271      * &lt;p&gt;
1272      * This returns the number of remaining hours when dividing {@link #toHours}
1273      * by hours in a day.
1274      * This is based on the standard definition of a day as 24 hours.
1275      * &lt;p&gt;
1276      * This instance is immutable and unaffected by this method call.
1277      *
1278      * @return the number of hours part in the duration, may be negative
1279      * @since 9
1280      */
1281     public int toHoursPart(){
1282         return (int) (toHours() % 24);
1283     }
1284 
1285     /**
1286      * Extracts the number of minutes part in the duration.
1287      * &lt;p&gt;
1288      * This returns the number of remaining minutes when dividing {@link #toMinutes}
1289      * by minutes in an hour.
1290      * This is based on the standard definition of an hour as 60 minutes.
1291      * &lt;p&gt;
1292      * This instance is immutable and unaffected by this method call.
1293      *
1294      * @return the number of minutes parts in the duration, may be negative
1295      * @since 9
1296      */
1297     public int toMinutesPart(){
1298         return (int) (toMinutes() % MINUTES_PER_HOUR);
1299     }
1300 
1301     /**
1302      * Extracts the number of seconds part in the duration.
1303      * &lt;p&gt;
1304      * This returns the remaining seconds when dividing {@link #toSeconds}
1305      * by seconds in a minute.
1306      * This is based on the standard definition of a minute as 60 seconds.
1307      * &lt;p&gt;
1308      * This instance is immutable and unaffected by this method call.
1309      *
1310      * @return the number of seconds parts in the duration, may be negative
1311      * @since 9
1312      */
1313     public int toSecondsPart(){
1314         return (int) (seconds % SECONDS_PER_MINUTE);
1315     }
1316 
1317     /**
1318      * Extracts the number of milliseconds part of the duration.
1319      * &lt;p&gt;
1320      * This returns the milliseconds part by dividing the number of nanoseconds by 1,000,000.
1321      * The length of the duration is stored using two fields - seconds and nanoseconds.
1322      * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
1323      * the length in seconds.
1324      * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
1325      * &lt;p&gt;
1326      * This instance is immutable and unaffected by this method call.
1327      *
1328      * @return the number of milliseconds part of the duration.
1329      * @since 9
1330      */
1331     public int toMillisPart(){
1332         return nanos / 1000_000;
1333     }
1334 
1335     /**
1336      * Get the nanoseconds part within seconds of the duration.
1337      * &lt;p&gt;
1338      * The length of the duration is stored using two fields - seconds and nanoseconds.
1339      * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
1340      * the length in seconds.
1341      * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
1342      * &lt;p&gt;
1343      * This instance is immutable and unaffected by this method call.
1344      *
1345      * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
1346      * @since 9
1347      */
1348     public int toNanosPart(){
1349         return nanos;
1350     }
1351 
1352 
1353     //-----------------------------------------------------------------------
1354     /**
1355      * Returns a copy of this {@code Duration} truncated to the specified unit.
1356      * &lt;p&gt;
1357      * Truncating the duration returns a copy of the original with conceptual fields
1358      * smaller than the specified unit set to zero.
1359      * For example, truncating with the {@link ChronoUnit#MINUTES MINUTES} unit will
1360      * round down towards zero to the nearest minute, setting the seconds and
1361      * nanoseconds to zero.
1362      * &lt;p&gt;
1363      * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
1364      * that divides into the length of a standard day without remainder.
1365      * This includes all
1366      * {@linkplain ChronoUnit#isTimeBased() time-based units on {@code ChronoUnit}}
1367      * and {@link ChronoUnit#DAYS DAYS}. Other ChronoUnits throw an exception.
1368      * &lt;p&gt;
1369      * This instance is immutable and unaffected by this method call.
1370      *
1371      * @param unit the unit to truncate to, not null
1372      * @return a {@code Duration} based on this duration with the time truncated, not null
1373      * @throws DateTimeException if the unit is invalid for truncation
1374      * @throws UnsupportedTemporalTypeException if the unit is not supported
1375      * @since 9
1376      */
1377     public Duration truncatedTo(TemporalUnit unit) {
1378         Objects.requireNonNull(unit, &quot;unit&quot;);
1379         if (unit == ChronoUnit.SECONDS &amp;&amp; (seconds &gt;= 0 || nanos == 0)) {
1380             return new Duration(seconds, 0);
1381         } else if (unit == ChronoUnit.NANOS) {
1382             return this;
1383         }
1384         Duration unitDur = unit.getDuration();
1385         if (unitDur.getSeconds() &gt; LocalTime.SECONDS_PER_DAY) {
1386             throw new UnsupportedTemporalTypeException(&quot;Unit is too large to be used for truncation&quot;);
1387         }
1388         long dur = unitDur.toNanos();
1389         if ((LocalTime.NANOS_PER_DAY % dur) != 0) {
1390             throw new UnsupportedTemporalTypeException(&quot;Unit must divide into a standard day without remainder&quot;);
1391         }
1392         long nod = (seconds % LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + nanos;
1393         long result = (nod / dur) * dur;
1394         return plusNanos(result - nod);
1395     }
1396 
1397     //-----------------------------------------------------------------------
1398     /**
1399      * Compares this duration to the specified {@code Duration}.
1400      * &lt;p&gt;
1401      * The comparison is based on the total length of the durations.
1402      * It is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
1403      *
1404      * @param otherDuration the other duration to compare to, not null
1405      * @return the comparator value, negative if less, positive if greater
1406      */
1407     @Override
1408     public int compareTo(Duration otherDuration) {
1409         int cmp = Long.compare(seconds, otherDuration.seconds);
1410         if (cmp != 0) {
1411             return cmp;
1412         }
1413         return nanos - otherDuration.nanos;
1414     }
1415 
1416     //-----------------------------------------------------------------------
1417     /**
1418      * Checks if this duration is equal to the specified {@code Duration}.
1419      * &lt;p&gt;
1420      * The comparison is based on the total length of the durations.
1421      *
1422      * @param otherDuration the other duration, null returns false
1423      * @return true if the other duration is equal to this one
1424      */
1425     @Override
1426     public boolean equals(Object otherDuration) {
1427         if (this == otherDuration) {
1428             return true;
1429         }
1430         if (otherDuration instanceof Duration) {
1431             Duration other = (Duration) otherDuration;
1432             return this.seconds == other.seconds &amp;&amp;
1433                    this.nanos == other.nanos;
1434         }
1435         return false;
1436     }
1437 
1438     /**
1439      * A hash code for this duration.
1440      *
1441      * @return a suitable hash code
1442      */
1443     @Override
1444     public int hashCode() {
1445         return ((int) (seconds ^ (seconds &gt;&gt;&gt; 32))) + (51 * nanos);
1446     }
1447 
1448     //-----------------------------------------------------------------------
1449     /**
1450      * A string representation of this duration using ISO-8601 seconds
1451      * based representation, such as {@code PT8H6M12.345S}.
1452      * &lt;p&gt;
1453      * The format of the returned string will be {@code PTnHnMnS}, where n is
1454      * the relevant hours, minutes or seconds part of the duration.
1455      * Any fractional seconds are placed after a decimal point in the seconds section.
1456      * If a section has a zero value, it is omitted.
1457      * The hours, minutes and seconds will all have the same sign.
1458      * &lt;p&gt;
1459      * Examples:
1460      * &lt;pre&gt;
1461      *    &quot;20.345 seconds&quot;                 -- &quot;PT20.345S
1462      *    &quot;15 minutes&quot; (15 * 60 seconds)   -- &quot;PT15M&quot;
1463      *    &quot;10 hours&quot; (10 * 3600 seconds)   -- &quot;PT10H&quot;
1464      *    &quot;2 days&quot; (2 * 86400 seconds)     -- &quot;PT48H&quot;
1465      * &lt;/pre&gt;
1466      * Note that multiples of 24 hours are not output as days to avoid confusion
1467      * with {@code Period}.
1468      *
1469      * @return an ISO-8601 representation of this duration, not null
1470      */
1471     @Override
1472     public String toString() {
1473         if (this == ZERO) {
1474             return &quot;PT0S&quot;;
1475         }
1476         long effectiveTotalSecs = seconds;
1477         if (seconds &lt; 0 &amp;&amp; nanos &gt; 0) {
1478             effectiveTotalSecs++;
1479         }
1480         long hours = effectiveTotalSecs / SECONDS_PER_HOUR;
1481         int minutes = (int) ((effectiveTotalSecs % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE);
1482         int secs = (int) (effectiveTotalSecs % SECONDS_PER_MINUTE);
1483         StringBuilder buf = new StringBuilder(24);
1484         buf.append(&quot;PT&quot;);
1485         if (hours != 0) {
1486             buf.append(hours).append(&#39;H&#39;);
1487         }
1488         if (minutes != 0) {
1489             buf.append(minutes).append(&#39;M&#39;);
1490         }
1491         if (secs == 0 &amp;&amp; nanos == 0 &amp;&amp; buf.length() &gt; 2) {
1492             return buf.toString();
1493         }
1494         if (seconds &lt; 0 &amp;&amp; nanos &gt; 0) {
1495             if (secs == 0) {
1496                 buf.append(&quot;-0&quot;);
1497             } else {
1498                 buf.append(secs);
1499             }
1500         } else {
1501             buf.append(secs);
1502         }
1503         if (nanos &gt; 0) {
1504             int pos = buf.length();
1505             if (seconds &lt; 0) {
1506                 buf.append(2 * NANOS_PER_SECOND - nanos);
1507             } else {
1508                 buf.append(nanos + NANOS_PER_SECOND);
1509             }
1510             while (buf.charAt(buf.length() - 1) == &#39;0&#39;) {
1511                 buf.setLength(buf.length() - 1);
1512             }
1513             buf.setCharAt(pos, &#39;.&#39;);
1514         }
1515         buf.append(&#39;S&#39;);
1516         return buf.toString();
1517     }
1518 
1519     //-----------------------------------------------------------------------
1520     /**
1521      * Writes the object using a
1522      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
1523      * @serialData
1524      * &lt;pre&gt;
1525      *  out.writeByte(1);  // identifies a Duration
1526      *  out.writeLong(seconds);
1527      *  out.writeInt(nanos);
1528      * &lt;/pre&gt;
1529      *
1530      * @return the instance of {@code Ser}, not null
1531      */
1532     private Object writeReplace() {
1533         return new Ser(Ser.DURATION_TYPE, this);
1534     }
1535 
1536     /**
1537      * Defend against malicious streams.
1538      *
1539      * @param s the stream to read
1540      * @throws InvalidObjectException always
1541      */
1542     private void readObject(ObjectInputStream s) throws InvalidObjectException {
1543         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
1544     }
1545 
1546     void writeExternal(DataOutput out) throws IOException {
1547         out.writeLong(seconds);
1548         out.writeInt(nanos);
1549     }
1550 
1551     static Duration readExternal(DataInput in) throws IOException {
1552         long seconds = in.readLong();
1553         int nanos = in.readInt();
1554         return Duration.ofSeconds(seconds, nanos);
1555     }
1556 
1557 }
    </pre>
  </body>
</html>
diff a/src/java.base/share/classes/java/lang/invoke/VarHandle.java b/src/java.base/share/classes/java/lang/invoke/VarHandle.java
--- a/src/java.base/share/classes/java/lang/invoke/VarHandle.java
+++ b/src/java.base/share/classes/java/lang/invoke/VarHandle.java
@@ -232,11 +232,11 @@
  * are phrased in terms of the lack of "reorderings" -- observable ordering
  * effects that might otherwise occur if the fence was not present.  More
  * precise phrasing of the specification of access mode methods and memory fence
  * methods may accompany future updates of the Java Language Specification.
  *
- * <h1>Compiling invocation of access mode methods</h1>
+ * <h2>Compiling invocation of access mode methods</h2>
  * A Java method call expression naming an access mode method can invoke a
  * VarHandle from Java source code.  From the viewpoint of source code, these
  * methods can take any arguments and their polymorphic result (if expressed)
  * can be cast to any return type.  Formally this is accomplished by giving the
  * access mode methods variable arity {@code Object} arguments and
@@ -264,11 +264,11 @@
  * descriptor of {@code java.lang.Void}.  The ambiguity with the type
  * {@code Void} is harmless, since there are no references of type {@code Void}
  * except the null reference.
  *
  *
- * <h1><a id="invoke">Performing invocation of access mode methods</a></h1>
+ * <h2><a id="invoke">Performing invocation of access mode methods</a></h2>
  * The first time an {@code invokevirtual} instruction is executed it is linked
  * by symbolically resolving the names in the instruction and verifying that
  * the method call is statically legal.  This also holds for calls to access mode
  * methods.  In this case, the symbolic type descriptor emitted by the compiler
  * is checked for correct syntax, and names it contains are resolved.  Thus, an
@@ -327,11 +327,11 @@
  * R r = (R) mh.invoke(p1, p2, ..., pN)
  * }</pre>
  * Where, in this case, the method handle is bound to the VarHandle instance.
  *
  *
- * <h1>Invocation checking</h1>
+ * <h2>Invocation checking</h2>
  * In typical programs, VarHandle access mode type matching will usually
  * succeed.  But if a match fails, the JVM will throw a
  * {@link WrongMethodTypeException}.
  * <p>
  * Thus, an access mode type mismatch which might show up as a linkage error
@@ -362,11 +362,11 @@
  * Thus, VarHandles to non-public variables, or to variables in non-public
  * classes, should generally be kept secret.  They should not be passed to
  * untrusted code unless their use from the untrusted code would be harmless.
  *
  *
- * <h1>VarHandle creation</h1>
+ * <h2>VarHandle creation</h2>
  * Java code can create a VarHandle that directly accesses any field that is
  * accessible to that code.  This is done via a reflective, capability-based
  * API called {@link java.lang.invoke.MethodHandles.Lookup
  * MethodHandles.Lookup}.
  * For example, a VarHandle for a non-static field can be obtained
@@ -381,11 +381,11 @@
  * turn be a subclass (or package sibling) of the protected member's defining
  * class.  If a VarHandle refers to a protected non-static field of a declaring
  * class outside the current package, the receiver argument will be narrowed to
  * the type of the accessing class.
  *
- * <h1>Interoperation between VarHandles and the Core Reflection API</h1>
+ * <h2>Interoperation between VarHandles and the Core Reflection API</h2>
  * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup
  * Lookup} API, any field represented by a Core Reflection API object
  * can be converted to a behaviorally equivalent VarHandle.
  * For example, a reflective {@link java.lang.reflect.Field Field} can
  * be converted to a VarHandle using
@@ -426,11 +426,11 @@
  * {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
  * API is also able to return a method handle to call an access mode method for
  * any specified access mode type and is equivalent in behaviour to
  * {@link java.lang.invoke.MethodHandles#varHandleInvoker}.
  *
- * <h1>Interoperation between VarHandles and Java generics</h1>
+ * <h2>Interoperation between VarHandles and Java generics</h2>
  * A VarHandle can be obtained for a variable, such as a field, which is
  * declared with Java generic types.  As with the Core Reflection API, the
  * VarHandle's variable type will be constructed from the erasure of the
  * source-level type.  When a VarHandle access mode method is invoked, the
  * types
@@ -2116,11 +2116,11 @@
     public static void storeStoreFence() {
         UNSAFE.storeStoreFence();
     }
 
     /**
-     * A <a href="package-summary.html#nominal">nominal descriptor</a> for a
+     * A <a href="{@docRoot}/java.base/java/lang/constant/package-summary.html#nominal">nominal descriptor</a> for a
      * {@link VarHandle} constant.
      *
      * @since 12
      */
     public static final class VarHandleDesc extends DynamicConstantDesc<VarHandle> {

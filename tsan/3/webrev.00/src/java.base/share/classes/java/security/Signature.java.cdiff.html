<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/security/Signature.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SecurityPermission.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SignatureException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/Signature.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,10 ***</span>
<span class="line-new-header">--- 38,12 ---</span>
  
  import javax.crypto.Cipher;
  import javax.crypto.IllegalBlockSizeException;
  import javax.crypto.BadPaddingException;
  import javax.crypto.NoSuchPaddingException;
<span class="line-added">+ import jdk.internal.access.JavaSecuritySignatureAccess;</span>
<span class="line-added">+ import jdk.internal.access.SharedSecrets;</span>
  
  import sun.security.util.Debug;
  import sun.security.jca.*;
  import sun.security.jca.GetInstance.Instance;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,10 ***</span>
<span class="line-new-header">--- 118,38 ---</span>
   *
   */
  
  public abstract class Signature extends SignatureSpi {
  
<span class="line-added">+     static {</span>
<span class="line-added">+         SharedSecrets.setJavaSecuritySignatureAccess(</span>
<span class="line-added">+             new JavaSecuritySignatureAccess() {</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public void initVerify(Signature s, PublicKey publicKey,</span>
<span class="line-added">+                         AlgorithmParameterSpec params)</span>
<span class="line-added">+                         throws InvalidKeyException,</span>
<span class="line-added">+                         InvalidAlgorithmParameterException {</span>
<span class="line-added">+                     s.initVerify(publicKey, params);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public void initVerify(Signature s,</span>
<span class="line-added">+                         java.security.cert.Certificate certificate,</span>
<span class="line-added">+                         AlgorithmParameterSpec params)</span>
<span class="line-added">+                         throws InvalidKeyException,</span>
<span class="line-added">+                         InvalidAlgorithmParameterException {</span>
<span class="line-added">+                     s.initVerify(certificate, params);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public void initSign(Signature s, PrivateKey privateKey,</span>
<span class="line-added">+                         AlgorithmParameterSpec params, SecureRandom random)</span>
<span class="line-added">+                         throws InvalidKeyException,</span>
<span class="line-added">+                         InvalidAlgorithmParameterException {</span>
<span class="line-added">+                     s.initSign(privateKey, params, random);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+         });</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private static final Debug debug =
                          Debug.getInstance(&quot;jca&quot;, &quot;Signature&quot;);
  
      private static final Debug pdebug =
                          Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,11 ***</span>
       * of this call.
       *
       * @param publicKey the public key of the identity whose signature is
       * going to be verified.
       *
<span class="line-modified">!      * @exception InvalidKeyException if the key is invalid.</span>
       */
      public final void initVerify(PublicKey publicKey)
              throws InvalidKeyException {
          engineInitVerify(publicKey);
          state = VERIFY;
<span class="line-new-header">--- 496,11 ---</span>
       * of this call.
       *
       * @param publicKey the public key of the identity whose signature is
       * going to be verified.
       *
<span class="line-modified">!      * @throws    InvalidKeyException if the key is invalid.</span>
       */
      public final void initVerify(PublicKey publicKey)
              throws InvalidKeyException {
          engineInitVerify(publicKey);
          state = VERIFY;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 479,10 ***</span>
<span class="line-new-header">--- 509,57 ---</span>
              pdebug.println(&quot;Signature.&quot; + algorithm +
                  &quot; verification algorithm from: &quot; + getProviderName());
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Initialize this object for verification. If this method is called</span>
<span class="line-added">+      * again with different arguments, it negates the effect</span>
<span class="line-added">+      * of this call.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param publicKey the public key of the identity whose signature is</span>
<span class="line-added">+      * going to be verified.</span>
<span class="line-added">+      * @param params the parameters used for verifying this signature.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws    InvalidKeyException if the key is invalid.</span>
<span class="line-added">+      * @throws    InvalidAlgorithmParameterException if the params is invalid.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     final void initVerify(PublicKey publicKey, AlgorithmParameterSpec params)</span>
<span class="line-added">+             throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added">+         engineInitVerify(publicKey, params);</span>
<span class="line-added">+         state = VERIFY;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!skipDebug &amp;&amp; pdebug != null) {</span>
<span class="line-added">+             pdebug.println(&quot;Signature.&quot; + algorithm +</span>
<span class="line-added">+                 &quot; verification algorithm from: &quot; + getProviderName());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static PublicKey getPublicKeyFromCert(Certificate cert)</span>
<span class="line-added">+             throws InvalidKeyException {</span>
<span class="line-added">+         // If the certificate is of type X509Certificate,</span>
<span class="line-added">+         // we should check whether it has a Key Usage</span>
<span class="line-added">+         // extension marked as critical.</span>
<span class="line-added">+         //if (cert instanceof java.security.cert.X509Certificate) {</span>
<span class="line-added">+         if (cert instanceof X509Certificate) {</span>
<span class="line-added">+             // Check whether the cert has a key usage extension</span>
<span class="line-added">+             // marked as a critical extension.</span>
<span class="line-added">+             // The OID for KeyUsage extension is 2.5.29.15.</span>
<span class="line-added">+             X509Certificate c = (X509Certificate)cert;</span>
<span class="line-added">+             Set&lt;String&gt; critSet = c.getCriticalExtensionOIDs();</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (critSet != null &amp;&amp; !critSet.isEmpty()</span>
<span class="line-added">+                 &amp;&amp; critSet.contains(&quot;2.5.29.15&quot;)) {</span>
<span class="line-added">+                 boolean[] keyUsageInfo = c.getKeyUsage();</span>
<span class="line-added">+                 // keyUsageInfo[0] is for digitalSignature.</span>
<span class="line-added">+                 if ((keyUsageInfo != null) &amp;&amp; (keyUsageInfo[0] == false))</span>
<span class="line-added">+                     throw new InvalidKeyException(&quot;Wrong key usage&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return cert.getPublicKey();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Initializes this object for verification, using the public key from
       * the given certificate.
       * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
       * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 492,38 ***</span>
       * {@code InvalidKeyException} is thrown.
       *
       * @param certificate the certificate of the identity whose signature is
       * going to be verified.
       *
<span class="line-modified">!      * @exception InvalidKeyException  if the public key in the certificate</span>
       * is not encoded properly or does not include required  parameter
       * information or cannot be used for digital signature purposes.
       * @since 1.3
       */
      public final void initVerify(Certificate certificate)
              throws InvalidKeyException {
<span class="line-modified">!         // If the certificate is of type X509Certificate,</span>
<span class="line-modified">!         // we should check whether it has a Key Usage</span>
<span class="line-removed">-         // extension marked as critical.</span>
<span class="line-removed">-         if (certificate instanceof java.security.cert.X509Certificate) {</span>
<span class="line-removed">-             // Check whether the cert has a key usage extension</span>
<span class="line-removed">-             // marked as a critical extension.</span>
<span class="line-removed">-             // The OID for KeyUsage extension is 2.5.29.15.</span>
<span class="line-removed">-             X509Certificate cert = (X509Certificate)certificate;</span>
<span class="line-removed">-             Set&lt;String&gt; critSet = cert.getCriticalExtensionOIDs();</span>
  
<span class="line-modified">!             if (critSet != null &amp;&amp; !critSet.isEmpty()</span>
<span class="line-modified">!                 &amp;&amp; critSet.contains(&quot;2.5.29.15&quot;)) {</span>
<span class="line-modified">!                 boolean[] keyUsageInfo = cert.getKeyUsage();</span>
<span class="line-removed">-                 // keyUsageInfo[0] is for digitalSignature.</span>
<span class="line-removed">-                 if ((keyUsageInfo != null) &amp;&amp; (keyUsageInfo[0] == false))</span>
<span class="line-removed">-                     throw new InvalidKeyException(&quot;Wrong key usage&quot;);</span>
<span class="line-removed">-             }</span>
          }
  
<span class="line-modified">!         PublicKey publicKey = certificate.getPublicKey();</span>
<span class="line-modified">!         engineInitVerify(publicKey);</span>
          state = VERIFY;
  
          if (!skipDebug &amp;&amp; pdebug != null) {
              pdebug.println(&quot;Signature.&quot; + algorithm +
                  &quot; verification algorithm from: &quot; + getProviderName());
<span class="line-new-header">--- 569,51 ---</span>
       * {@code InvalidKeyException} is thrown.
       *
       * @param certificate the certificate of the identity whose signature is
       * going to be verified.
       *
<span class="line-modified">!      * @throws    InvalidKeyException  if the public key in the certificate</span>
       * is not encoded properly or does not include required  parameter
       * information or cannot be used for digital signature purposes.
       * @since 1.3
       */
      public final void initVerify(Certificate certificate)
              throws InvalidKeyException {
<span class="line-modified">!         engineInitVerify(getPublicKeyFromCert(certificate));</span>
<span class="line-modified">!         state = VERIFY;</span>
  
<span class="line-modified">!         if (!skipDebug &amp;&amp; pdebug != null) {</span>
<span class="line-modified">!             pdebug.println(&quot;Signature.&quot; + algorithm +</span>
<span class="line-modified">!                 &quot; verification algorithm from: &quot; + getProviderName());</span>
          }
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Initializes this object for verification, using the public key from</span>
<span class="line-added">+      * the given certificate.</span>
<span class="line-added">+      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;</span>
<span class="line-added">+      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;</span>
<span class="line-added">+      * extension field implies that the public key in</span>
<span class="line-added">+      * the certificate and its corresponding private key are not</span>
<span class="line-added">+      * supposed to be used for digital signatures, an</span>
<span class="line-added">+      * {@code InvalidKeyException} is thrown.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param certificate the certificate of the identity whose signature is</span>
<span class="line-added">+      * going to be verified.</span>
<span class="line-added">+      * @param params the parameters used for verifying this signature.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws    InvalidKeyException  if the public key in the certificate</span>
<span class="line-added">+      * is not encoded properly or does not include required  parameter</span>
<span class="line-added">+      * information or cannot be used for digital signature purposes.</span>
<span class="line-added">+      * @throws    InvalidAlgorithmParameterException if the params is invalid.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @since 13</span>
<span class="line-added">+      */</span>
<span class="line-added">+     final void initVerify(Certificate certificate,</span>
<span class="line-added">+             AlgorithmParameterSpec params)</span>
<span class="line-added">+             throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added">+         engineInitVerify(getPublicKeyFromCert(certificate), params);</span>
          state = VERIFY;
  
          if (!skipDebug &amp;&amp; pdebug != null) {
              pdebug.println(&quot;Signature.&quot; + algorithm +
                  &quot; verification algorithm from: &quot; + getProviderName());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,11 ***</span>
       * of this call.
       *
       * @param privateKey the private key of the identity whose signature
       * is going to be generated.
       *
<span class="line-modified">!      * @exception InvalidKeyException if the key is invalid.</span>
       */
      public final void initSign(PrivateKey privateKey)
              throws InvalidKeyException {
          engineInitSign(privateKey);
          state = SIGN;
<span class="line-new-header">--- 626,11 ---</span>
       * of this call.
       *
       * @param privateKey the private key of the identity whose signature
       * is going to be generated.
       *
<span class="line-modified">!      * @throws    InvalidKeyException if the key is invalid.</span>
       */
      public final void initSign(PrivateKey privateKey)
              throws InvalidKeyException {
          engineInitSign(privateKey);
          state = SIGN;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,11 ***</span>
       * @param privateKey the private key of the identity whose signature
       * is going to be generated.
       *
       * @param random the source of randomness for this signature.
       *
<span class="line-modified">!      * @exception InvalidKeyException if the key is invalid.</span>
       */
      public final void initSign(PrivateKey privateKey, SecureRandom random)
              throws InvalidKeyException {
          engineInitSign(privateKey, random);
          state = SIGN;
<span class="line-new-header">--- 649,11 ---</span>
       * @param privateKey the private key of the identity whose signature
       * is going to be generated.
       *
       * @param random the source of randomness for this signature.
       *
<span class="line-modified">!      * @throws    InvalidKeyException if the key is invalid.</span>
       */
      public final void initSign(PrivateKey privateKey, SecureRandom random)
              throws InvalidKeyException {
          engineInitSign(privateKey, random);
          state = SIGN;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 572,10 ***</span>
<span class="line-new-header">--- 662,35 ---</span>
              pdebug.println(&quot;Signature.&quot; + algorithm +
                  &quot; signing algorithm from: &quot; + getProviderName());
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Initialize this object for signing. If this method is called</span>
<span class="line-added">+      * again with different arguments, it negates the effect</span>
<span class="line-added">+      * of this call.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param privateKey the private key of the identity whose signature</span>
<span class="line-added">+      * is going to be generated.</span>
<span class="line-added">+      * @param params the parameters used for generating signature.</span>
<span class="line-added">+      * @param random the source of randomness for this signature.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws    InvalidKeyException if the key is invalid.</span>
<span class="line-added">+      * @throws    InvalidAlgorithmParameterException if the params is invalid</span>
<span class="line-added">+      */</span>
<span class="line-added">+     final void initSign(PrivateKey privateKey,</span>
<span class="line-added">+             AlgorithmParameterSpec params, SecureRandom random)</span>
<span class="line-added">+             throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added">+         engineInitSign(privateKey, params, random);</span>
<span class="line-added">+         state = SIGN;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!skipDebug &amp;&amp; pdebug != null) {</span>
<span class="line-added">+             pdebug.println(&quot;Signature.&quot; + algorithm +</span>
<span class="line-added">+                 &quot; signing algorithm from: &quot; + getProviderName());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns the signature bytes of all the data updated.
       * The format of the signature depends on the underlying
       * signature scheme.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 586,11 ***</span>
       * signer, if desired, via new calls to {@code update} and
       * {@code sign}.
       *
       * @return the signature bytes of the signing operation&#39;s result.
       *
<span class="line-modified">!      * @exception SignatureException if this signature object is not</span>
       * initialized properly or if this signature algorithm is unable to
       * process the input data provided.
       */
      public final byte[] sign() throws SignatureException {
          if (state == SIGN) {
<span class="line-new-header">--- 701,11 ---</span>
       * signer, if desired, via new calls to {@code update} and
       * {@code sign}.
       *
       * @return the signature bytes of the signing operation&#39;s result.
       *
<span class="line-modified">!      * @throws    SignatureException if this signature object is not</span>
       * initialized properly or if this signature algorithm is unable to
       * process the input data provided.
       */
      public final byte[] sign() throws SignatureException {
          if (state == SIGN) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 619,15 ***</span>
       * @param len number of bytes within {@code outbuf} allotted for the
       * signature.
       *
       * @return the number of bytes placed into {@code outbuf}.
       *
<span class="line-modified">!      * @exception SignatureException if this signature object is not</span>
       *     initialized properly, if this signature algorithm is unable to
       *     process the input data provided, or if {@code len} is less
       *     than the actual signature length.
<span class="line-modified">!      * @exception IllegalArgumentException if {@code outbuf} is {@code null},</span>
       *     or {@code offset} or {@code len} is less than 0, or the sum of
       *     {@code offset} and {@code len} is greater than the length of
       *     {@code outbuf}.
       *
       * @since 1.2
<span class="line-new-header">--- 734,15 ---</span>
       * @param len number of bytes within {@code outbuf} allotted for the
       * signature.
       *
       * @return the number of bytes placed into {@code outbuf}.
       *
<span class="line-modified">!      * @throws    SignatureException if this signature object is not</span>
       *     initialized properly, if this signature algorithm is unable to
       *     process the input data provided, or if {@code len} is less
       *     than the actual signature length.
<span class="line-modified">!      * @throws    IllegalArgumentException if {@code outbuf} is {@code null},</span>
       *     or {@code offset} or {@code len} is less than 0, or the sum of
       *     {@code offset} and {@code len} is greater than the length of
       *     {@code outbuf}.
       *
       * @since 1.2
</pre>
<hr />
<pre>
<span class="line-old-header">*** 662,11 ***</span>
       *
       * @param signature the signature bytes to be verified.
       *
       * @return true if the signature was verified, false if not.
       *
<span class="line-modified">!      * @exception SignatureException if this signature object is not</span>
       * initialized properly, the passed-in signature is improperly
       * encoded or of the wrong type, if this signature algorithm is unable to
       * process the input data provided, etc.
       */
      public final boolean verify(byte[] signature) throws SignatureException {
<span class="line-new-header">--- 777,11 ---</span>
       *
       * @param signature the signature bytes to be verified.
       *
       * @return true if the signature was verified, false if not.
       *
<span class="line-modified">!      * @throws    SignatureException if this signature object is not</span>
       * initialized properly, the passed-in signature is improperly
       * encoded or of the wrong type, if this signature algorithm is unable to
       * process the input data provided, etc.
       */
      public final boolean verify(byte[] signature) throws SignatureException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 692,15 ***</span>
       * @param offset the offset to start from in the array of bytes.
       * @param length the number of bytes to use, starting at offset.
       *
       * @return true if the signature was verified, false if not.
       *
<span class="line-modified">!      * @exception SignatureException if this signature object is not</span>
       * initialized properly, the passed-in signature is improperly
       * encoded or of the wrong type, if this signature algorithm is unable to
       * process the input data provided, etc.
<span class="line-modified">!      * @exception IllegalArgumentException if the {@code signature}</span>
       * byte array is {@code null}, or the {@code offset} or {@code length}
       * is less than 0, or the sum of the {@code offset} and
       * {@code length} is greater than the length of the
       * {@code signature} byte array.
       * @since 1.4
<span class="line-new-header">--- 807,15 ---</span>
       * @param offset the offset to start from in the array of bytes.
       * @param length the number of bytes to use, starting at offset.
       *
       * @return true if the signature was verified, false if not.
       *
<span class="line-modified">!      * @throws    SignatureException if this signature object is not</span>
       * initialized properly, the passed-in signature is improperly
       * encoded or of the wrong type, if this signature algorithm is unable to
       * process the input data provided, etc.
<span class="line-modified">!      * @throws    IllegalArgumentException if the {@code signature}</span>
       * byte array is {@code null}, or the {@code offset} or {@code length}
       * is less than 0, or the sum of the {@code offset} and
       * {@code length} is greater than the length of the
       * {@code signature} byte array.
       * @since 1.4
</pre>
<hr />
<pre>
<span class="line-old-header">*** 729,11 ***</span>
      /**
       * Updates the data to be signed or verified by a byte.
       *
       * @param b the byte to use for the update.
       *
<span class="line-modified">!      * @exception SignatureException if this signature object is not</span>
       * initialized properly.
       */
      public final void update(byte b) throws SignatureException {
          if (state == VERIFY || state == SIGN) {
              engineUpdate(b);
<span class="line-new-header">--- 844,11 ---</span>
      /**
       * Updates the data to be signed or verified by a byte.
       *
       * @param b the byte to use for the update.
       *
<span class="line-modified">!      * @throws    SignatureException if this signature object is not</span>
       * initialized properly.
       */
      public final void update(byte b) throws SignatureException {
          if (state == VERIFY || state == SIGN) {
              engineUpdate(b);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 747,11 ***</span>
       * Updates the data to be signed or verified, using the specified
       * array of bytes.
       *
       * @param data the byte array to use for the update.
       *
<span class="line-modified">!      * @exception SignatureException if this signature object is not</span>
       * initialized properly.
       */
      public final void update(byte[] data) throws SignatureException {
          update(data, 0, data.length);
      }
<span class="line-new-header">--- 862,11 ---</span>
       * Updates the data to be signed or verified, using the specified
       * array of bytes.
       *
       * @param data the byte array to use for the update.
       *
<span class="line-modified">!      * @throws    SignatureException if this signature object is not</span>
       * initialized properly.
       */
      public final void update(byte[] data) throws SignatureException {
          update(data, 0, data.length);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,13 ***</span>
       *
       * @param data the array of bytes.
       * @param off the offset to start from in the array of bytes.
       * @param len the number of bytes to use, starting at offset.
       *
<span class="line-modified">!      * @exception SignatureException if this signature object is not</span>
       *     initialized properly.
<span class="line-modified">!      * @exception IllegalArgumentException if {@code data} is {@code null},</span>
       *     or {@code off} or {@code len} is less than 0, or the sum of
       *     {@code off} and {@code len} is greater than the length of
       *     {@code data}.
       */
      public final void update(byte[] data, int off, int len)
<span class="line-new-header">--- 877,13 ---</span>
       *
       * @param data the array of bytes.
       * @param off the offset to start from in the array of bytes.
       * @param len the number of bytes to use, starting at offset.
       *
<span class="line-modified">!      * @throws    SignatureException if this signature object is not</span>
       *     initialized properly.
<span class="line-modified">!      * @throws    IllegalArgumentException if {@code data} is {@code null},</span>
       *     or {@code off} or {@code len} is less than 0, or the sum of
       *     {@code off} and {@code len} is greater than the length of
       *     {@code data}.
       */
      public final void update(byte[] data, int off, int len)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 798,11 ***</span>
       * Upon return, the buffer&#39;s position will be equal to its limit;
       * its limit will not have changed.
       *
       * @param data the ByteBuffer
       *
<span class="line-modified">!      * @exception SignatureException if this signature object is not</span>
       * initialized properly.
       * @since 1.5
       */
      public final void update(ByteBuffer data) throws SignatureException {
          if ((state != SIGN) &amp;&amp; (state != VERIFY)) {
<span class="line-new-header">--- 913,11 ---</span>
       * Upon return, the buffer&#39;s position will be equal to its limit;
       * its limit will not have changed.
       *
       * @param data the ByteBuffer
       *
<span class="line-modified">!      * @throws    SignatureException if this signature object is not</span>
       * initialized properly.
       * @since 1.5
       */
      public final void update(ByteBuffer data) throws SignatureException {
          if ((state != SIGN) &amp;&amp; (state != VERIFY)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 859,11 ***</span>
       * at this time.
       *
       * @param param the string identifier of the parameter.
       * @param value the parameter value.
       *
<span class="line-modified">!      * @exception InvalidParameterException if {@code param} is an</span>
       * invalid parameter for this signature algorithm engine,
       * the parameter is already set
       * and cannot be set again, a security exception occurs, and so on.
       *
       * @see #getParameter
<span class="line-new-header">--- 974,11 ---</span>
       * at this time.
       *
       * @param param the string identifier of the parameter.
       * @param value the parameter value.
       *
<span class="line-modified">!      * @throws    InvalidParameterException if {@code param} is an</span>
       * invalid parameter for this signature algorithm engine,
       * the parameter is already set
       * and cannot be set again, a security exception occurs, and so on.
       *
       * @see #getParameter
</pre>
<hr />
<pre>
<span class="line-old-header">*** 881,11 ***</span>
      /**
       * Initializes this signature engine with the specified parameter set.
       *
       * @param params the parameters
       *
<span class="line-modified">!      * @exception InvalidAlgorithmParameterException if the given parameters</span>
       * are inappropriate for this signature engine
       *
       * @see #getParameters
       */
      public final void setParameter(AlgorithmParameterSpec params)
<span class="line-new-header">--- 996,11 ---</span>
      /**
       * Initializes this signature engine with the specified parameter set.
       *
       * @param params the parameters
       *
<span class="line-modified">!      * @throws    InvalidAlgorithmParameterException if the given parameters</span>
       * are inappropriate for this signature engine
       *
       * @see #getParameters
       */
      public final void setParameter(AlgorithmParameterSpec params)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 926,11 ***</span>
       * @param param the string name of the parameter.
       *
       * @return the object that represents the parameter value, or {@code null} if
       * there is none.
       *
<span class="line-modified">!      * @exception InvalidParameterException if {@code param} is an invalid</span>
       * parameter for this engine, or another exception occurs while
       * trying to get this parameter.
       *
       * @see #setParameter(String, Object)
       *
<span class="line-new-header">--- 1041,11 ---</span>
       * @param param the string name of the parameter.
       *
       * @return the object that represents the parameter value, or {@code null} if
       * there is none.
       *
<span class="line-modified">!      * @throws    InvalidParameterException if {@code param} is an invalid</span>
       * parameter for this engine, or another exception occurs while
       * trying to get this parameter.
       *
       * @see #setParameter(String, Object)
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 945,11 ***</span>
      /**
       * Returns a clone if the implementation is cloneable.
       *
       * @return a clone if the implementation is cloneable.
       *
<span class="line-modified">!      * @exception CloneNotSupportedException if this is called</span>
       * on an implementation that does not support {@code Cloneable}.
       */
      public Object clone() throws CloneNotSupportedException {
          if (this instanceof Cloneable) {
              return super.clone();
<span class="line-new-header">--- 1060,11 ---</span>
      /**
       * Returns a clone if the implementation is cloneable.
       *
       * @return a clone if the implementation is cloneable.
       *
<span class="line-modified">!      * @throws    CloneNotSupportedException if this is called</span>
       * on an implementation that does not support {@code Cloneable}.
       */
      public Object clone() throws CloneNotSupportedException {
          if (this instanceof Cloneable) {
              return super.clone();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1009,11 ***</span>
          /**
           * Returns a clone if the delegate is cloneable.
           *
           * @return a clone if the delegate is cloneable.
           *
<span class="line-modified">!          * @exception CloneNotSupportedException if this is called on a</span>
           * delegate that does not support {@code Cloneable}.
           */
          public Object clone() throws CloneNotSupportedException {
              chooseFirstProvider();
              if (sigSpi instanceof Cloneable) {
<span class="line-new-header">--- 1124,11 ---</span>
          /**
           * Returns a clone if the delegate is cloneable.
           *
           * @return a clone if the delegate is cloneable.
           *
<span class="line-modified">!          * @throws    CloneNotSupportedException if this is called on a</span>
           * delegate that does not support {@code Cloneable}.
           */
          public Object clone() throws CloneNotSupportedException {
              chooseFirstProvider();
              if (sigSpi instanceof Cloneable) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1108,15 ***</span>
                  }
                  throw e;
              }
          }
  
<span class="line-modified">!         private void chooseProvider(int type, Key key, SecureRandom random)</span>
<span class="line-modified">!                 throws InvalidKeyException {</span>
              synchronized (lock) {
                  if (sigSpi != null) {
<span class="line-removed">-                     init(sigSpi, type, key, random);</span>
                      return;
                  }
                  Exception lastException = null;
                  while ((firstService != null) || serviceIterator.hasNext()) {
                      Service s;
<span class="line-new-header">--- 1223,17 ---</span>
                  }
                  throw e;
              }
          }
  
<span class="line-modified">!         // Used by engineSetParameter/engineInitSign/engineInitVerify() to</span>
<span class="line-modified">!         // find the right provider with the supplied key, parameters, random source</span>
<span class="line-added">+         private void chooseProvider(int type, Key key,</span>
<span class="line-added">+                 AlgorithmParameterSpec params, SecureRandom random)</span>
<span class="line-added">+                 throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
              synchronized (lock) {
                  if (sigSpi != null) {
                      return;
                  }
                  Exception lastException = null;
                  while ((firstService != null) || serviceIterator.hasNext()) {
                      Service s;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1125,20 ***</span>
                          firstService = null;
                      } else {
                          s = serviceIterator.next();
                      }
                      // if provider says it does not support this key, ignore it
<span class="line-modified">!                     if (s.supportsParameter(key) == false) {</span>
                          continue;
                      }
                      // if instance is not a SignatureSpi, ignore it
                      if (isSpi(s) == false) {
                          continue;
                      }
                      try {
                          SignatureSpi spi = newInstance(s);
<span class="line-modified">!                         init(spi, type, key, random);</span>
                          provider = s.getProvider();
                          sigSpi = spi;
                          firstService = null;
                          serviceIterator = null;
                          return;
<span class="line-new-header">--- 1242,20 ---</span>
                          firstService = null;
                      } else {
                          s = serviceIterator.next();
                      }
                      // if provider says it does not support this key, ignore it
<span class="line-modified">!                     if (key != null &amp;&amp; s.supportsParameter(key) == false) {</span>
                          continue;
                      }
                      // if instance is not a SignatureSpi, ignore it
                      if (isSpi(s) == false) {
                          continue;
                      }
                      try {
                          SignatureSpi spi = newInstance(s);
<span class="line-modified">!                         tryOperation(spi, type, key, params, random);</span>
                          provider = s.getProvider();
                          sigSpi = spi;
                          firstService = null;
                          serviceIterator = null;
                          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1156,62 ***</span>
                      throw (InvalidKeyException)lastException;
                  }
                  if (lastException instanceof RuntimeException) {
                      throw (RuntimeException)lastException;
                  }
                  String k = (key != null) ? key.getClass().getName() : &quot;(null)&quot;;
                  throw new InvalidKeyException
                      (&quot;No installed provider supports this key: &quot;
                      + k, lastException);
              }
          }
  
<span class="line-modified">!         private static final int I_PUB     = 1;</span>
<span class="line-modified">!         private static final int I_PRIV    = 2;</span>
<span class="line-modified">!         private static final int I_PRIV_SR = 3;</span>
  
<span class="line-modified">!         private void init(SignatureSpi spi, int type, Key  key,</span>
<span class="line-modified">!                 SecureRandom random) throws InvalidKeyException {</span>
              switch (type) {
              case I_PUB:
                  spi.engineInitVerify((PublicKey)key);
                  break;
              case I_PRIV:
                  spi.engineInitSign((PrivateKey)key);
                  break;
              case I_PRIV_SR:
                  spi.engineInitSign((PrivateKey)key, random);
                  break;
              default:
                  throw new AssertionError(&quot;Internal error: &quot; + type);
              }
          }
  
          protected void engineInitVerify(PublicKey publicKey)
                  throws InvalidKeyException {
              if (sigSpi != null) {
                  sigSpi.engineInitVerify(publicKey);
              } else {
<span class="line-modified">!                 chooseProvider(I_PUB, publicKey, null);</span>
              }
          }
  
          protected void engineInitSign(PrivateKey privateKey)
                  throws InvalidKeyException {
              if (sigSpi != null) {
                  sigSpi.engineInitSign(privateKey);
              } else {
<span class="line-modified">!                 chooseProvider(I_PRIV, privateKey, null);</span>
              }
          }
  
          protected void engineInitSign(PrivateKey privateKey, SecureRandom sr)
                  throws InvalidKeyException {
              if (sigSpi != null) {
                  sigSpi.engineInitSign(privateKey, sr);
              } else {
<span class="line-modified">!                 chooseProvider(I_PRIV_SR, privateKey, sr);</span>
              }
          }
  
          protected void engineUpdate(byte b) throws SignatureException {
              chooseFirstProvider();
<span class="line-new-header">--- 1273,114 ---</span>
                      throw (InvalidKeyException)lastException;
                  }
                  if (lastException instanceof RuntimeException) {
                      throw (RuntimeException)lastException;
                  }
<span class="line-added">+                 if (lastException instanceof InvalidAlgorithmParameterException) {</span>
<span class="line-added">+                     throw (InvalidAlgorithmParameterException)lastException;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
                  String k = (key != null) ? key.getClass().getName() : &quot;(null)&quot;;
                  throw new InvalidKeyException
                      (&quot;No installed provider supports this key: &quot;
                      + k, lastException);
              }
          }
  
<span class="line-modified">!         private static final int I_PUB           = 1;</span>
<span class="line-modified">!         private static final int I_PRIV          = 2;</span>
<span class="line-modified">!         private static final int I_PRIV_SR       = 3;</span>
<span class="line-added">+         private static final int I_PUB_PARAM     = 4;</span>
<span class="line-added">+         private static final int I_PRIV_PARAM_SR = 5;</span>
<span class="line-added">+         private static final int S_PARAM         = 6;</span>
  
<span class="line-modified">!         private void tryOperation(SignatureSpi spi, int type, Key  key,</span>
<span class="line-modified">!                 AlgorithmParameterSpec params, SecureRandom random)</span>
<span class="line-added">+                 throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
              switch (type) {
              case I_PUB:
                  spi.engineInitVerify((PublicKey)key);
                  break;
<span class="line-added">+             case I_PUB_PARAM:</span>
<span class="line-added">+                 spi.engineInitVerify((PublicKey)key, params);</span>
<span class="line-added">+                 break;</span>
              case I_PRIV:
                  spi.engineInitSign((PrivateKey)key);
                  break;
              case I_PRIV_SR:
                  spi.engineInitSign((PrivateKey)key, random);
                  break;
<span class="line-added">+             case I_PRIV_PARAM_SR:</span>
<span class="line-added">+                 spi.engineInitSign((PrivateKey)key, params, random);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case S_PARAM:</span>
<span class="line-added">+                 spi.engineSetParameter(params);</span>
<span class="line-added">+                 break;</span>
              default:
                  throw new AssertionError(&quot;Internal error: &quot; + type);
              }
          }
  
          protected void engineInitVerify(PublicKey publicKey)
                  throws InvalidKeyException {
              if (sigSpi != null) {
                  sigSpi.engineInitVerify(publicKey);
              } else {
<span class="line-modified">!                 try {</span>
<span class="line-added">+                     chooseProvider(I_PUB, publicKey, null, null);</span>
<span class="line-added">+                 } catch (InvalidAlgorithmParameterException iape) {</span>
<span class="line-added">+                     // should not happen, re-throw as IKE just in case</span>
<span class="line-added">+                     throw new InvalidKeyException(iape);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         void engineInitVerify(PublicKey publicKey,</span>
<span class="line-added">+                 AlgorithmParameterSpec params)</span>
<span class="line-added">+                 throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added">+             if (sigSpi != null) {</span>
<span class="line-added">+                 sigSpi.engineInitVerify(publicKey, params);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 chooseProvider(I_PUB_PARAM, publicKey, params, null);</span>
              }
          }
  
          protected void engineInitSign(PrivateKey privateKey)
                  throws InvalidKeyException {
              if (sigSpi != null) {
                  sigSpi.engineInitSign(privateKey);
              } else {
<span class="line-modified">!                 try {</span>
<span class="line-added">+                     chooseProvider(I_PRIV, privateKey, null, null);</span>
<span class="line-added">+                 } catch (InvalidAlgorithmParameterException iape) {</span>
<span class="line-added">+                     // should not happen, re-throw as IKE just in case</span>
<span class="line-added">+                     throw new InvalidKeyException(iape);</span>
<span class="line-added">+                 }</span>
              }
          }
  
          protected void engineInitSign(PrivateKey privateKey, SecureRandom sr)
                  throws InvalidKeyException {
              if (sigSpi != null) {
                  sigSpi.engineInitSign(privateKey, sr);
              } else {
<span class="line-modified">!                 try {</span>
<span class="line-added">+                     chooseProvider(I_PRIV_SR, privateKey, null, sr);</span>
<span class="line-added">+                 } catch (InvalidAlgorithmParameterException iape) {</span>
<span class="line-added">+                     // should not happen, re-throw as IKE just in case</span>
<span class="line-added">+                     throw new InvalidKeyException(iape);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         void engineInitSign(PrivateKey privateKey,</span>
<span class="line-added">+                 AlgorithmParameterSpec params, SecureRandom sr)</span>
<span class="line-added">+                 throws InvalidKeyException, InvalidAlgorithmParameterException {</span>
<span class="line-added">+             if (sigSpi != null) {</span>
<span class="line-added">+                 sigSpi.engineInitSign(privateKey, params, sr);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 chooseProvider(I_PRIV_PARAM_SR, privateKey, params, sr);</span>
              }
          }
  
          protected void engineUpdate(byte b) throws SignatureException {
              chooseFirstProvider();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1258,12 ***</span>
              sigSpi.engineSetParameter(param, value);
          }
  
          protected void engineSetParameter(AlgorithmParameterSpec params)
                  throws InvalidAlgorithmParameterException {
<span class="line-modified">!             chooseFirstProvider();</span>
<span class="line-modified">!             sigSpi.engineSetParameter(params);</span>
          }
  
          protected Object engineGetParameter(String param)
                  throws InvalidParameterException {
              chooseFirstProvider();
<span class="line-new-header">--- 1427,20 ---</span>
              sigSpi.engineSetParameter(param, value);
          }
  
          protected void engineSetParameter(AlgorithmParameterSpec params)
                  throws InvalidAlgorithmParameterException {
<span class="line-modified">!             if (sigSpi != null) {</span>
<span class="line-modified">!                 sigSpi.engineSetParameter(params);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     chooseProvider(S_PARAM, null, params, null);</span>
<span class="line-added">+                 } catch (InvalidKeyException ike) {</span>
<span class="line-added">+                     // should never happen, rethrow just in case</span>
<span class="line-added">+                     throw new InvalidAlgorithmParameterException(ike);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          }
  
          protected Object engineGetParameter(String param)
                  throws InvalidParameterException {
              chooseFirstProvider();
</pre>
<center><a href="SecurityPermission.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SignatureException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/Vector.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="UnknownFormatFlagsException.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="concurrent/ArrayBlockingQueue.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Vector.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,10 +30,12 @@</span>
  import java.io.StreamCorruptedException;
  import java.util.function.Consumer;
  import java.util.function.Predicate;
  import java.util.function.UnaryOperator;
  
<span class="udiff-line-added">+ import jdk.internal.util.ArraysSupport;</span>
<span class="udiff-line-added">+ </span>
  /**
   * The {@code Vector} class implements a growable array of
   * objects. Like an array, it contains components that can be
   * accessed using an integer index. However, the size of a
   * {@code Vector} can grow or shrink as needed to accommodate
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98,10 +100,11 @@</span>
       *
       * &lt;p&gt;Any array elements following the last element in the Vector are null.
       *
       * @serial
       */
<span class="udiff-line-added">+     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
      protected Object[] elementData;
  
      /**
       * The number of valid components in this {@code Vector} object.
       * Components {@code elementData[0]} through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120,10 +123,11 @@</span>
       * @serial
       */
      protected int capacityIncrement;
  
      /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = -2767605614048989439L;
  
      /**
       * Constructs an empty vector with the specified initial capacity and
       * capacity increment.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -239,65 +243,30 @@</span>
              if (minCapacity &gt; elementData.length)
                  grow(minCapacity);
          }
      }
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * The maximum size of array to allocate (unless necessary).</span>
<span class="udiff-line-removed">-      * Some VMs reserve some header words in an array.</span>
<span class="udiff-line-removed">-      * Attempts to allocate larger arrays may result in</span>
<span class="udiff-line-removed">-      * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
<span class="udiff-line-removed">- </span>
      /**
       * Increases the capacity to ensure that it can hold at least the
       * number of elements specified by the minimum capacity argument.
       *
       * @param minCapacity the desired minimum capacity
       * @throws OutOfMemoryError if minCapacity is less than zero
       */
      private Object[] grow(int minCapacity) {
<span class="udiff-line-modified-removed">-         return elementData = Arrays.copyOf(elementData,</span>
<span class="udiff-line-modified-removed">-                                            newCapacity(minCapacity));</span>
<span class="udiff-line-modified-added">+         int oldCapacity = elementData.length;</span>
<span class="udiff-line-modified-added">+         int newCapacity = ArraysSupport.newLength(oldCapacity,</span>
<span class="udiff-line-added">+                 minCapacity - oldCapacity, /* minimum growth */</span>
<span class="udiff-line-added">+                 capacityIncrement &gt; 0 ? capacityIncrement : oldCapacity</span>
<span class="udiff-line-added">+                                            /* preferred growth */);</span>
<span class="udiff-line-added">+         return elementData = Arrays.copyOf(elementData, newCapacity);</span>
      }
  
      private Object[] grow() {
          return grow(elementCount + 1);
      }
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Returns a capacity at least as large as the given minimum capacity.</span>
<span class="udiff-line-removed">-      * Will not return a capacity greater than MAX_ARRAY_SIZE unless</span>
<span class="udiff-line-removed">-      * the given minimum capacity is greater than MAX_ARRAY_SIZE.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param minCapacity the desired minimum capacity</span>
<span class="udiff-line-removed">-      * @throws OutOfMemoryError if minCapacity is less than zero</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private int newCapacity(int minCapacity) {</span>
<span class="udiff-line-removed">-         // overflow-conscious code</span>
<span class="udiff-line-removed">-         int oldCapacity = elementData.length;</span>
<span class="udiff-line-removed">-         int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span>
<span class="udiff-line-removed">-                                          capacityIncrement : oldCapacity);</span>
<span class="udiff-line-removed">-         if (newCapacity - minCapacity &lt;= 0) {</span>
<span class="udiff-line-removed">-             if (minCapacity &lt; 0) // overflow</span>
<span class="udiff-line-removed">-                 throw new OutOfMemoryError();</span>
<span class="udiff-line-removed">-             return minCapacity;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)</span>
<span class="udiff-line-removed">-             ? newCapacity</span>
<span class="udiff-line-removed">-             : hugeCapacity(minCapacity);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private static int hugeCapacity(int minCapacity) {</span>
<span class="udiff-line-removed">-         if (minCapacity &lt; 0) // overflow</span>
<span class="udiff-line-removed">-             throw new OutOfMemoryError();</span>
<span class="udiff-line-removed">-         return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span>
<span class="udiff-line-removed">-             Integer.MAX_VALUE :</span>
<span class="udiff-line-removed">-             MAX_ARRAY_SIZE;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * Sets the size of this vector. If the new size is greater than the
       * current size, new {@code null} items are added to the end of
       * the vector. If the new size is less than the current size, all
       * components at index {@code newSize} and greater are discarded.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1180,10 +1149,11 @@</span>
       * @param in the stream
       * @throws java.io.IOException if an I/O error occurs
       * @throws ClassNotFoundException if the stream contains data
       *         of a non-existing class
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream in)
              throws IOException, ClassNotFoundException {
          ObjectInputStream.GetField gfields = in.readFields();
          int count = gfields.get(&quot;elementCount&quot;, 0);
          Object[] data = (Object[])gfields.get(&quot;elementData&quot;, null);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1201,10 +1171,11 @@</span>
       * of the serialized data.
       *
       * @param s the stream
       * @throws java.io.IOException if an I/O error occurs
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void writeObject(java.io.ObjectOutputStream s)
              throws java.io.IOException {
          final java.io.ObjectOutputStream.PutField fields = s.putFields();
          final Object[] data;
          synchronized (this) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1400,10 +1371,11 @@</span>
          final int size = elementCount;
          for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++)
              es[i] = operator.apply(elementAt(es, i));
          if (modCount != expectedModCount)
              throw new ConcurrentModificationException();
<span class="udiff-line-added">+         // TODO(8203662): remove increment of modCount from ...</span>
          modCount++;
      }
  
      @SuppressWarnings(&quot;unchecked&quot;)
      @Override
</pre>
<center><a href="UnknownFormatFlagsException.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="concurrent/ArrayBlockingQueue.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
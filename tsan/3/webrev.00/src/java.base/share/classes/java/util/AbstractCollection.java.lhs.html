<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/AbstractCollection.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util;
 27 
<a name="2" id="anc2"></a>

 28 /**
 29  * This class provides a skeletal implementation of the {@code Collection}
 30  * interface, to minimize the effort required to implement this interface. &lt;p&gt;
 31  *
 32  * To implement an unmodifiable collection, the programmer needs only to
 33  * extend this class and provide implementations for the {@code iterator} and
 34  * {@code size} methods.  (The iterator returned by the {@code iterator}
 35  * method must implement {@code hasNext} and {@code next}.)&lt;p&gt;
 36  *
 37  * To implement a modifiable collection, the programmer must additionally
 38  * override this class&#39;s {@code add} method (which otherwise throws an
 39  * {@code UnsupportedOperationException}), and the iterator returned by the
 40  * {@code iterator} method must additionally implement its {@code remove}
 41  * method.&lt;p&gt;
 42  *
 43  * The programmer should generally provide a void (no argument) and
 44  * {@code Collection} constructor, as per the recommendation in the
 45  * {@code Collection} interface specification.&lt;p&gt;
 46  *
 47  * The documentation for each non-abstract method in this class describes its
 48  * implementation in detail.  Each of these methods may be overridden if
 49  * the collection being implemented admits a more efficient implementation.&lt;p&gt;
 50  *
 51  * This class is a member of the
 52  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 53  * Java Collections Framework&lt;/a&gt;.
 54  *
 55  * @author  Josh Bloch
 56  * @author  Neal Gafter
 57  * @see Collection
 58  * @since 1.2
 59  */
 60 
 61 public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {
 62     /**
 63      * Sole constructor.  (For invocation by subclass constructors, typically
 64      * implicit.)
 65      */
 66     protected AbstractCollection() {
 67     }
 68 
 69     // Query Operations
 70 
 71     /**
 72      * Returns an iterator over the elements contained in this collection.
 73      *
 74      * @return an iterator over the elements contained in this collection
 75      */
 76     public abstract Iterator&lt;E&gt; iterator();
 77 
 78     public abstract int size();
 79 
 80     /**
 81      * {@inheritDoc}
 82      *
 83      * @implSpec
 84      * This implementation returns {@code size() == 0}.
 85      */
 86     public boolean isEmpty() {
 87         return size() == 0;
 88     }
 89 
 90     /**
 91      * {@inheritDoc}
 92      *
 93      * @implSpec
 94      * This implementation iterates over the elements in the collection,
 95      * checking each element in turn for equality with the specified element.
 96      *
 97      * @throws ClassCastException   {@inheritDoc}
 98      * @throws NullPointerException {@inheritDoc}
 99      */
100     public boolean contains(Object o) {
101         Iterator&lt;E&gt; it = iterator();
102         if (o==null) {
103             while (it.hasNext())
104                 if (it.next()==null)
105                     return true;
106         } else {
107             while (it.hasNext())
108                 if (o.equals(it.next()))
109                     return true;
110         }
111         return false;
112     }
113 
114     /**
115      * {@inheritDoc}
116      *
117      * @implSpec
118      * This implementation returns an array containing all the elements
119      * returned by this collection&#39;s iterator, in the same order, stored in
120      * consecutive elements of the array, starting with index {@code 0}.
121      * The length of the returned array is equal to the number of elements
122      * returned by the iterator, even if the size of this collection changes
123      * during iteration, as might happen if the collection permits
124      * concurrent modification during iteration.  The {@code size} method is
125      * called only as an optimization hint; the correct result is returned
126      * even if the iterator returns a different number of elements.
127      *
128      * &lt;p&gt;This method is equivalent to:
129      *
130      *  &lt;pre&gt; {@code
131      * List&lt;E&gt; list = new ArrayList&lt;E&gt;(size());
132      * for (E e : this)
133      *     list.add(e);
134      * return list.toArray();
135      * }&lt;/pre&gt;
136      */
137     public Object[] toArray() {
138         // Estimate size of array; be prepared to see more or fewer elements
139         Object[] r = new Object[size()];
140         Iterator&lt;E&gt; it = iterator();
141         for (int i = 0; i &lt; r.length; i++) {
142             if (! it.hasNext()) // fewer elements than expected
143                 return Arrays.copyOf(r, i);
144             r[i] = it.next();
145         }
146         return it.hasNext() ? finishToArray(r, it) : r;
147     }
148 
149     /**
150      * {@inheritDoc}
151      *
152      * @implSpec
153      * This implementation returns an array containing all the elements
154      * returned by this collection&#39;s iterator in the same order, stored in
155      * consecutive elements of the array, starting with index {@code 0}.
156      * If the number of elements returned by the iterator is too large to
157      * fit into the specified array, then the elements are returned in a
158      * newly allocated array with length equal to the number of elements
159      * returned by the iterator, even if the size of this collection
160      * changes during iteration, as might happen if the collection permits
161      * concurrent modification during iteration.  The {@code size} method is
162      * called only as an optimization hint; the correct result is returned
163      * even if the iterator returns a different number of elements.
164      *
165      * &lt;p&gt;This method is equivalent to:
166      *
167      *  &lt;pre&gt; {@code
168      * List&lt;E&gt; list = new ArrayList&lt;E&gt;(size());
169      * for (E e : this)
170      *     list.add(e);
171      * return list.toArray(a);
172      * }&lt;/pre&gt;
173      *
174      * @throws ArrayStoreException  {@inheritDoc}
175      * @throws NullPointerException {@inheritDoc}
176      */
177     @SuppressWarnings(&quot;unchecked&quot;)
178     public &lt;T&gt; T[] toArray(T[] a) {
179         // Estimate size of array; be prepared to see more or fewer elements
180         int size = size();
181         T[] r = a.length &gt;= size ? a :
182                   (T[])java.lang.reflect.Array
183                   .newInstance(a.getClass().getComponentType(), size);
184         Iterator&lt;E&gt; it = iterator();
185 
186         for (int i = 0; i &lt; r.length; i++) {
187             if (! it.hasNext()) { // fewer elements than expected
188                 if (a == r) {
189                     r[i] = null; // null-terminate
190                 } else if (a.length &lt; i) {
191                     return Arrays.copyOf(r, i);
192                 } else {
193                     System.arraycopy(r, 0, a, 0, i);
194                     if (a.length &gt; i) {
195                         a[i] = null;
196                     }
197                 }
198                 return a;
199             }
200             r[i] = (T)it.next();
201         }
202         // more elements than expected
203         return it.hasNext() ? finishToArray(r, it) : r;
204     }
205 
<a name="3" id="anc3"></a><span class="line-removed">206     /**</span>
<span class="line-removed">207      * The maximum size of array to allocate.</span>
<span class="line-removed">208      * Some VMs reserve some header words in an array.</span>
<span class="line-removed">209      * Attempts to allocate larger arrays may result in</span>
<span class="line-removed">210      * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="line-removed">211      */</span>
<span class="line-removed">212     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
<span class="line-removed">213 </span>
214     /**
215      * Reallocates the array being used within toArray when the iterator
216      * returned more elements than expected, and finishes filling it from
217      * the iterator.
218      *
219      * @param r the array, replete with previously stored elements
220      * @param it the in-progress iterator over this collection
221      * @return array containing the elements in the given array, plus any
222      *         further elements returned by the iterator, trimmed to size
223      */
224     @SuppressWarnings(&quot;unchecked&quot;)
225     private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) {
<a name="4" id="anc4"></a><span class="line-modified">226         int i = r.length;</span>

227         while (it.hasNext()) {
<a name="5" id="anc5"></a><span class="line-modified">228             int cap = r.length;</span>
<span class="line-modified">229             if (i == cap) {</span>
<span class="line-modified">230                 int newCap = cap + (cap &gt;&gt; 1) + 1;</span>
<span class="line-modified">231                 // overflow-conscious code</span>
<span class="line-modified">232                 if (newCap - MAX_ARRAY_SIZE &gt; 0)</span>
<span class="line-removed">233                     newCap = hugeCapacity(cap + 1);</span>
<span class="line-removed">234                 r = Arrays.copyOf(r, newCap);</span>
235             }
236             r[i++] = (T)it.next();
237         }
238         // trim if overallocated
<a name="6" id="anc6"></a><span class="line-modified">239         return (i == r.length) ? r : Arrays.copyOf(r, i);</span>
<span class="line-removed">240     }</span>
<span class="line-removed">241 </span>
<span class="line-removed">242     private static int hugeCapacity(int minCapacity) {</span>
<span class="line-removed">243         if (minCapacity &lt; 0) // overflow</span>
<span class="line-removed">244             throw new OutOfMemoryError</span>
<span class="line-removed">245                 (&quot;Required array size too large&quot;);</span>
<span class="line-removed">246         return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span>
<span class="line-removed">247             Integer.MAX_VALUE :</span>
<span class="line-removed">248             MAX_ARRAY_SIZE;</span>
249     }
250 
251     // Modification Operations
252 
253     /**
254      * {@inheritDoc}
255      *
256      * @implSpec
257      * This implementation always throws an
258      * {@code UnsupportedOperationException}.
259      *
260      * @throws UnsupportedOperationException {@inheritDoc}
261      * @throws ClassCastException            {@inheritDoc}
262      * @throws NullPointerException          {@inheritDoc}
263      * @throws IllegalArgumentException      {@inheritDoc}
264      * @throws IllegalStateException         {@inheritDoc}
265      */
266     public boolean add(E e) {
267         throw new UnsupportedOperationException();
268     }
269 
270     /**
271      * {@inheritDoc}
272      *
273      * @implSpec
274      * This implementation iterates over the collection looking for the
275      * specified element.  If it finds the element, it removes the element
276      * from the collection using the iterator&#39;s remove method.
277      *
278      * &lt;p&gt;Note that this implementation throws an
279      * {@code UnsupportedOperationException} if the iterator returned by this
280      * collection&#39;s iterator method does not implement the {@code remove}
281      * method and this collection contains the specified object.
282      *
283      * @throws UnsupportedOperationException {@inheritDoc}
284      * @throws ClassCastException            {@inheritDoc}
285      * @throws NullPointerException          {@inheritDoc}
286      */
287     public boolean remove(Object o) {
288         Iterator&lt;E&gt; it = iterator();
289         if (o==null) {
290             while (it.hasNext()) {
291                 if (it.next()==null) {
292                     it.remove();
293                     return true;
294                 }
295             }
296         } else {
297             while (it.hasNext()) {
298                 if (o.equals(it.next())) {
299                     it.remove();
300                     return true;
301                 }
302             }
303         }
304         return false;
305     }
306 
307 
308     // Bulk Operations
309 
310     /**
311      * {@inheritDoc}
312      *
313      * @implSpec
314      * This implementation iterates over the specified collection,
315      * checking each element returned by the iterator in turn to see
316      * if it&#39;s contained in this collection.  If all elements are so
317      * contained {@code true} is returned, otherwise {@code false}.
318      *
319      * @throws ClassCastException            {@inheritDoc}
320      * @throws NullPointerException          {@inheritDoc}
321      * @see #contains(Object)
322      */
323     public boolean containsAll(Collection&lt;?&gt; c) {
324         for (Object e : c)
325             if (!contains(e))
326                 return false;
327         return true;
328     }
329 
330     /**
331      * {@inheritDoc}
332      *
333      * @implSpec
334      * This implementation iterates over the specified collection, and adds
335      * each object returned by the iterator to this collection, in turn.
336      *
337      * &lt;p&gt;Note that this implementation will throw an
338      * {@code UnsupportedOperationException} unless {@code add} is
339      * overridden (assuming the specified collection is non-empty).
340      *
341      * @throws UnsupportedOperationException {@inheritDoc}
342      * @throws ClassCastException            {@inheritDoc}
343      * @throws NullPointerException          {@inheritDoc}
344      * @throws IllegalArgumentException      {@inheritDoc}
345      * @throws IllegalStateException         {@inheritDoc}
346      *
347      * @see #add(Object)
348      */
349     public boolean addAll(Collection&lt;? extends E&gt; c) {
350         boolean modified = false;
351         for (E e : c)
352             if (add(e))
353                 modified = true;
354         return modified;
355     }
356 
357     /**
358      * {@inheritDoc}
359      *
360      * @implSpec
361      * This implementation iterates over this collection, checking each
362      * element returned by the iterator in turn to see if it&#39;s contained
363      * in the specified collection.  If it&#39;s so contained, it&#39;s removed from
364      * this collection with the iterator&#39;s {@code remove} method.
365      *
366      * &lt;p&gt;Note that this implementation will throw an
367      * {@code UnsupportedOperationException} if the iterator returned by the
368      * {@code iterator} method does not implement the {@code remove} method
369      * and this collection contains one or more elements in common with the
370      * specified collection.
371      *
372      * @throws UnsupportedOperationException {@inheritDoc}
373      * @throws ClassCastException            {@inheritDoc}
374      * @throws NullPointerException          {@inheritDoc}
375      *
376      * @see #remove(Object)
377      * @see #contains(Object)
378      */
379     public boolean removeAll(Collection&lt;?&gt; c) {
380         Objects.requireNonNull(c);
381         boolean modified = false;
382         Iterator&lt;?&gt; it = iterator();
383         while (it.hasNext()) {
384             if (c.contains(it.next())) {
385                 it.remove();
386                 modified = true;
387             }
388         }
389         return modified;
390     }
391 
392     /**
393      * {@inheritDoc}
394      *
395      * @implSpec
396      * This implementation iterates over this collection, checking each
397      * element returned by the iterator in turn to see if it&#39;s contained
398      * in the specified collection.  If it&#39;s not so contained, it&#39;s removed
399      * from this collection with the iterator&#39;s {@code remove} method.
400      *
401      * &lt;p&gt;Note that this implementation will throw an
402      * {@code UnsupportedOperationException} if the iterator returned by the
403      * {@code iterator} method does not implement the {@code remove} method
404      * and this collection contains one or more elements not present in the
405      * specified collection.
406      *
407      * @throws UnsupportedOperationException {@inheritDoc}
408      * @throws ClassCastException            {@inheritDoc}
409      * @throws NullPointerException          {@inheritDoc}
410      *
411      * @see #remove(Object)
412      * @see #contains(Object)
413      */
414     public boolean retainAll(Collection&lt;?&gt; c) {
415         Objects.requireNonNull(c);
416         boolean modified = false;
417         Iterator&lt;E&gt; it = iterator();
418         while (it.hasNext()) {
419             if (!c.contains(it.next())) {
420                 it.remove();
421                 modified = true;
422             }
423         }
424         return modified;
425     }
426 
427     /**
428      * {@inheritDoc}
429      *
430      * @implSpec
431      * This implementation iterates over this collection, removing each
432      * element using the {@code Iterator.remove} operation.  Most
433      * implementations will probably choose to override this method for
434      * efficiency.
435      *
436      * &lt;p&gt;Note that this implementation will throw an
437      * {@code UnsupportedOperationException} if the iterator returned by this
438      * collection&#39;s {@code iterator} method does not implement the
439      * {@code remove} method and this collection is non-empty.
440      *
441      * @throws UnsupportedOperationException {@inheritDoc}
442      */
443     public void clear() {
444         Iterator&lt;E&gt; it = iterator();
445         while (it.hasNext()) {
446             it.next();
447             it.remove();
448         }
449     }
450 
451 
452     //  String conversion
453 
454     /**
455      * Returns a string representation of this collection.  The string
456      * representation consists of a list of the collection&#39;s elements in the
457      * order they are returned by its iterator, enclosed in square brackets
458      * ({@code &quot;[]&quot;}).  Adjacent elements are separated by the characters
459      * {@code &quot;, &quot;} (comma and space).  Elements are converted to strings as
460      * by {@link String#valueOf(Object)}.
461      *
462      * @return a string representation of this collection
463      */
464     public String toString() {
465         Iterator&lt;E&gt; it = iterator();
466         if (! it.hasNext())
467             return &quot;[]&quot;;
468 
469         StringBuilder sb = new StringBuilder();
470         sb.append(&#39;[&#39;);
471         for (;;) {
472             E e = it.next();
473             sb.append(e == this ? &quot;(this Collection)&quot; : e);
474             if (! it.hasNext())
475                 return sb.append(&#39;]&#39;).toString();
476             sb.append(&#39;,&#39;).append(&#39; &#39;);
477         }
478     }
479 
480 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
diff a/src/java.base/share/classes/java/net/InetAddress.java b/src/java.base/share/classes/java/net/InetAddress.java
--- a/src/java.base/share/classes/java/net/InetAddress.java
+++ b/src/java.base/share/classes/java/net/InetAddress.java
@@ -29,11 +29,10 @@
 import java.util.ArrayList;
 import java.util.Objects;
 import java.util.Scanner;
 import java.security.AccessController;
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.ObjectStreamException;
 import java.io.ObjectStreamField;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
@@ -43,16 +42,18 @@
 import java.lang.annotation.Native;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ConcurrentSkipListSet;
 import java.util.concurrent.atomic.AtomicLong;
+import java.util.Arrays;
 
 import jdk.internal.access.JavaNetInetAddressAccess;
 import jdk.internal.access.SharedSecrets;
 import sun.security.action.*;
 import sun.net.InetAddressCachePolicy;
 import sun.net.util.IPAddressUtil;
+import sun.nio.cs.UTF_8;
 
 /**
  * This class represents an Internet Protocol (IP) address.
  *
  * <p> An IP address is either a 32-bit or 128-bit unsigned number
@@ -69,11 +70,11 @@
  * InetAddress consists of an IP address and possibly its
  * corresponding host name (depending on whether it is constructed
  * with a host name or whether it has already done reverse host name
  * resolution).
  *
- * <h3> Address types </h3>
+ * <h2> Address types </h2>
  *
  * <table class="striped" style="margin-left:2em">
  *   <caption style="display:none">Description of unicast and multicast address types</caption>
  *   <thead>
  *   <tr><th scope="col">Address Type</th><th scope="col">Description</th></tr>
@@ -103,22 +104,22 @@
  *         to different nodes). A packet sent to a multicast address is
  *         delivered to all interfaces identified by that address.</td></tr>
  * </tbody>
  * </table>
  *
- * <h4> IP address scope </h4>
+ * <h3> IP address scope </h3>
  *
  * <p> <i>Link-local</i> addresses are designed to be used for addressing
  * on a single link for purposes such as auto-address configuration,
  * neighbor discovery, or when no routers are present.
  *
  * <p> <i>Site-local</i> addresses are designed to be used for addressing
  * inside of a site without the need for a global prefix.
  *
  * <p> <i>Global</i> addresses are unique across the internet.
  *
- * <h4> Textual representation of IP addresses </h4>
+ * <h3> Textual representation of IP addresses </h3>
  *
  * The textual representation of an IP address is address family specific.
  *
  * <p>
  *
@@ -128,11 +129,11 @@
  * HREF="Inet6Address.html#format">Inet6Address#format</A>.
  *
  * <P>There is a <a href="doc-files/net-properties.html#Ipv4IPv6">couple of
  * System Properties</a> affecting how IPv4 and IPv6 addresses are used.</P>
  *
- * <h4> Host Name Resolution </h4>
+ * <h3> Host Name Resolution </h3>
  *
  * Host name-to-IP address <i>resolution</i> is accomplished through
  * the use of a combination of local machine configuration information
  * and network naming services such as the Domain Name System (DNS)
  * and Network Information Service(NIS). The particular naming
@@ -143,11 +144,11 @@
  * the host associated with the IP address is returned.
  *
  * <p> The InetAddress class provides methods to resolve host names to
  * their IP addresses and vice versa.
  *
- * <h4> InetAddress Caching </h4>
+ * <h3> InetAddress Caching </h3>
  *
  * The InetAddress class has a cache to store successful as well as
  * unsuccessful host name resolutions.
  *
  * <p> By default, when a security manager is installed, in order to
@@ -193,12 +194,11 @@
  * @see     java.net.InetAddress#getAllByName(java.lang.String)
  * @see     java.net.InetAddress#getByName(java.lang.String)
  * @see     java.net.InetAddress#getLocalHost()
  * @since 1.0
  */
-public
-class InetAddress implements java.io.Serializable {
+public class InetAddress implements java.io.Serializable {
 
     @Native static final int PREFER_IPV4_VALUE = 0;
     @Native static final int PREFER_IPV6_VALUE = 1;
     @Native static final int PREFER_SYSTEM_VALUE = 2;
 
@@ -287,27 +287,27 @@
     InetAddressHolder holder() {
         return holder;
     }
 
     /* Used to store the name service provider */
-    private static transient NameService nameService = null;
+    private static transient NameService nameService;
 
     /**
      * Used to store the best available hostname.
      * Lazily initialized via a data race; safe because Strings are immutable.
      */
     private transient String canonicalHostName = null;
 
     /** use serialVersionUID from JDK 1.0.2 for interoperability */
+    @java.io.Serial
     private static final long serialVersionUID = 3286316764910316507L;
 
     /*
      * Load net library into runtime, and perform initializations.
      */
     static {
-        String str = java.security.AccessController.doPrivileged(
-                new GetPropertyAction("java.net.preferIPv6Addresses"));
+        String str = GetPropertyAction.privilegedGetProperty("java.net.preferIPv6Addresses");
         if (str == null) {
             preferIPv6Address = PREFER_IPV4_VALUE;
         } else if (str.equalsIgnoreCase("true")) {
             preferIPv6Address = PREFER_IPV6_VALUE;
         } else if (str.equalsIgnoreCase("false")) {
@@ -315,29 +315,31 @@
         } else if (str.equalsIgnoreCase("system")) {
             preferIPv6Address = PREFER_SYSTEM_VALUE;
         } else {
             preferIPv6Address = PREFER_IPV4_VALUE;
         }
-        AccessController.doPrivileged(
-            new java.security.PrivilegedAction<>() {
-                public Void run() {
-                    System.loadLibrary("net");
-                    return null;
-                }
-            });
+        jdk.internal.loader.BootLoader.loadLibrary("net");
         SharedSecrets.setJavaNetInetAddressAccess(
                 new JavaNetInetAddressAccess() {
                     public String getOriginalHostName(InetAddress ia) {
                         return ia.holder.getOriginalHostName();
                     }
 
                     public InetAddress getByName(String hostName,
                                                  InetAddress hostAddress)
-                            throws UnknownHostException
+                        throws UnknownHostException
                     {
                         return InetAddress.getByName(hostName, hostAddress);
                     }
+
+                    public int addressValue(Inet4Address inet4Address) {
+                        return inet4Address.addressValue();
+                    }
+
+                    public byte[] addressBytes(Inet6Address inet6Address) {
+                        return inet6Address.addressBytes();
+                    }
                 }
         );
         init();
     }
 
@@ -357,10 +359,11 @@
      * @return the alternate object to the de-serialized object.
      *
      * @throws ObjectStreamException if a new object replacing this
      * object could not be created
      */
+    @java.io.Serial
     private Object readResolve() throws ObjectStreamException {
         // will replace the deserialized 'this' object
         return new Inet4Address(holder().getHostName(), holder().getAddress());
     }
 
@@ -987,33 +990,34 @@
         @Override
         public String getHostByAddr(byte[] addr) throws UnknownHostException {
             String hostEntry;
             String host = null;
 
-            String addrString = addrToString(addr);
-            try (Scanner hostsFileScanner = new Scanner(new File(hostsFile), "UTF-8")) {
+            try (Scanner hostsFileScanner = new Scanner(new File(hostsFile),
+                                                        UTF_8.INSTANCE))
+            {
                 while (hostsFileScanner.hasNextLine()) {
                     hostEntry = hostsFileScanner.nextLine();
                     if (!hostEntry.startsWith("#")) {
                         hostEntry = removeComments(hostEntry);
-                        if (hostEntry.contains(addrString)) {
-                            host = extractHost(hostEntry, addrString);
-                            if (host != null) {
-                                break;
-                            }
+                        String[] mapping = hostEntry.split("\\s+");
+                        if (mapping.length >= 2 &&
+                            Arrays.equals(addr, createAddressByteArray(mapping[0]))) {
+                            host = mapping[1];
+                            break;
                         }
                     }
                 }
-            } catch (FileNotFoundException e) {
+            } catch (IOException e) {
                 throw new UnknownHostException("Unable to resolve address "
-                        + addrString + " as hosts file " + hostsFile
+                        + Arrays.toString(addr) + " as hosts file " + hostsFile
                         + " not found ");
             }
 
             if ((host == null) || (host.isEmpty()) || (host.equals(" "))) {
                 throw new UnknownHostException("Requested address "
-                        + addrString
+                        + Arrays.toString(addr)
                         + " resolves to an invalid entry in hosts file "
                         + hostsFile);
             }
             return host;
         }
@@ -1037,11 +1041,13 @@
             InetAddress[] res = null;
             byte addr[] = new byte[4];
             ArrayList<InetAddress> inetAddresses = null;
 
             // lookup the file and create a list InetAddress for the specified host
-            try (Scanner hostsFileScanner = new Scanner(new File(hostsFile), "UTF-8")) {
+            try (Scanner hostsFileScanner = new Scanner(new File(hostsFile),
+                                                        UTF_8.INSTANCE))
+            {
                 while (hostsFileScanner.hasNextLine()) {
                     hostEntry = hostsFileScanner.nextLine();
                     if (!hostEntry.startsWith("#")) {
                         hostEntry = removeComments(hostEntry);
                         if (hostEntry.contains(host)) {
@@ -1056,11 +1062,11 @@
                                 }
                             }
                         }
                     }
                 }
-            } catch (FileNotFoundException e) {
+            } catch (IOException e) {
                 throw new UnknownHostException("Unable to resolve host " + host
                         + " as hosts file " + hostsFile + " not found ");
             }
 
             if (inetAddresses != null) {
@@ -1105,26 +1111,10 @@
                     }
                 }
             }
             return hostAddr;
         }
-
-        /**
-         * IP Address to host mapping
-         * use first host alias in list
-         */
-        private String extractHost(String hostEntry, String addrString) {
-            String[] mapping = hostEntry.split("\\s+");
-            String host = null;
-
-            if (mapping.length >= 2) {
-                if (mapping[0].equalsIgnoreCase(addrString)) {
-                    host = mapping[1];
-                }
-            }
-            return host;
-        }
     }
 
     static final InetAddressImpl  impl;
 
     static {
@@ -1180,11 +1170,11 @@
      * must be 16 bytes long
      *
      * @param host the specified host
      * @param addr the raw IP address in network byte order
      * @return  an InetAddress object created from the raw IP address.
-     * @exception  UnknownHostException  if IP address is of illegal length
+     * @throws     UnknownHostException  if IP address is of illegal length
      * @since 1.4
      */
     public static InetAddress getByAddress(String host, byte[] addr)
         throws UnknownHostException {
         if (host != null && !host.isEmpty() && host.charAt(0) == '[') {
@@ -1235,14 +1225,14 @@
      * {@code checkConnect} method is called with the hostname and {@code -1}
      * as its arguments to determine if the operation is allowed.
      *
      * @param      host   the specified host, or {@code null}.
      * @return     an IP address for the given host name.
-     * @exception  UnknownHostException  if no IP address for the
+     * @throws     UnknownHostException  if no IP address for the
      *               {@code host} could be found, or if a scope_id was specified
      *               for a global IPv6 address.
-     * @exception  SecurityException if a security manager exists
+     * @throws     SecurityException if a security manager exists
      *             and its checkConnect method doesn't allow the operation
      */
     public static InetAddress getByName(String host)
         throws UnknownHostException {
         return InetAddress.getAllByName(host)[0];
@@ -1283,14 +1273,14 @@
      * as its arguments to determine if the operation is allowed.
      *
      * @param      host   the name of the host, or {@code null}.
      * @return     an array of all the IP addresses for a given host name.
      *
-     * @exception  UnknownHostException  if no IP address for the
+     * @throws     UnknownHostException  if no IP address for the
      *               {@code host} could be found, or if a scope_id was specified
      *               for a global IPv6 address.
-     * @exception  SecurityException  if a security manager exists and its
+     * @throws     SecurityException  if a security manager exists and its
      *               {@code checkConnect} method doesn't allow the operation.
      *
      * @see SecurityManager#checkConnect
      */
     public static InetAddress[] getAllByName(String host)
@@ -1561,11 +1551,11 @@
      * <p> IPv4 address byte array must be 4 bytes long and IPv6 byte array
      * must be 16 bytes long
      *
      * @param addr the raw IP address in network byte order
      * @return  an InetAddress object created from the raw IP address.
-     * @exception  UnknownHostException  if IP address is of illegal length
+     * @throws     UnknownHostException  if IP address is of illegal length
      * @since 1.4
      */
     public static InetAddress getByAddress(byte[] addr)
         throws UnknownHostException {
         return getByAddress(null, addr);
@@ -1599,11 +1589,11 @@
      * If the operation is not allowed, an InetAddress representing
      * the loopback address is returned.
      *
      * @return     the address of the local host.
      *
-     * @exception  UnknownHostException  if the local host name could not
+     * @throws     UnknownHostException  if the local host name could not
      *             be resolved into an address.
      *
      * @see SecurityManager#checkConnect
      * @see java.net.InetAddress#getByName(java.lang.String)
      */
@@ -1708,10 +1698,11 @@
         }
 
         return (InetAddressImpl) impl;
     }
 
+    @java.io.Serial
     private void readObjectNoData () {
         if (getClass().getClassLoader() != null) {
             throw new SecurityException ("invalid address type");
         }
     }
@@ -1719,10 +1710,11 @@
     private static final jdk.internal.misc.Unsafe UNSAFE
             = jdk.internal.misc.Unsafe.getUnsafe();
     private static final long FIELDS_OFFSET
             = UNSAFE.objectFieldOffset(InetAddress.class, "holder");
 
+    @java.io.Serial
     private void readObject (ObjectInputStream s) throws
                          IOException, ClassNotFoundException {
         if (getClass().getClassLoader() != null) {
             throw new SecurityException ("invalid address type");
         }
@@ -1742,16 +1734,18 @@
     /**
      * @serialField hostName String
      * @serialField address int
      * @serialField family int
      */
+    @java.io.Serial
     private static final ObjectStreamField[] serialPersistentFields = {
         new ObjectStreamField("hostName", String.class),
         new ObjectStreamField("address", int.class),
         new ObjectStreamField("family", int.class),
     };
 
+    @java.io.Serial
     private void writeObject (ObjectOutputStream s) throws
                         IOException {
         if (getClass().getClassLoader() != null) {
             throw new SecurityException ("invalid address type");
         }

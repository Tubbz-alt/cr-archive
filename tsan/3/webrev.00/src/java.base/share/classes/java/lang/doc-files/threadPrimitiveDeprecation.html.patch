diff a/src/java.base/share/classes/java/lang/doc-files/threadPrimitiveDeprecation.html b/src/java.base/share/classes/java/lang/doc-files/threadPrimitiveDeprecation.html
--- a/src/java.base/share/classes/java/lang/doc-files/threadPrimitiveDeprecation.html
+++ b/src/java.base/share/classes/java/lang/doc-files/threadPrimitiveDeprecation.html
@@ -1,8 +1,8 @@
 <!doctype html>
 <!--
- Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 
  This code is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License version 2 only, as
  published by the Free Software Foundation.  Oracle designates this
@@ -27,13 +27,13 @@
 <head>
   <title>Java Thread Primitive Deprecation</title>
   <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
 </head>
 <body>
-<h2>Java Thread Primitive Deprecation</h2>
+<h1>Java Thread Primitive Deprecation</h1>
 <hr>
-<h3>Why is <code>Thread.stop</code> deprecated?</h3>
+<h2>Why is <code>Thread.stop</code> deprecated?</h2>
 <p>Because it is inherently unsafe. Stopping a thread causes it to
 unlock all the monitors that it has locked. (The monitors are
 unlocked as the <code>ThreadDeath</code> exception propagates up
 the stack.) If any of the objects previously protected by these
 monitors were in an inconsistent state, other threads may now view
@@ -44,12 +44,12 @@
 <code>ThreadDeath</code> kills threads silently; thus, the user has
 no warning that his program may be corrupted. The corruption can
 manifest itself at any time after the actual damage occurs, even
 hours or days in the future.</p>
 <hr>
-<h3>Couldn't I just catch the <code>ThreadDeath</code> exception
-and fix the damaged object?</h3>
+<h2>Couldn't I just catch the <code>ThreadDeath</code> exception
+and fix the damaged object?</h2>
 <p>In theory, perhaps, but it would <em>vastly</em> complicate the
 task of writing correct multithreaded code. The task would be
 nearly insurmountable for two reasons:</p>
 <ol>
 <li>A thread can throw a <code>ThreadDeath</code> exception
@@ -60,11 +60,11 @@
 <code>finally</code> clause). Cleanup would have to be repeated till
 it succeeded. The code to ensure this would be quite complex.</li>
 </ol>
 In sum, it just isn't practical.
 <hr>
-<h3>What should I use instead of <code>Thread.stop</code>?</h3>
+<h2>What should I use instead of <code>Thread.stop</code>?</h2>
 <p>Most uses of <code>stop</code> should be replaced by code that
 simply modifies some variable to indicate that the target thread
 should stop running. The target thread should check this variable
 regularly, and return from its run method in an orderly fashion if
 the variable indicates that it is to stop running. To ensure prompt
@@ -115,12 +115,12 @@
             repaint();
         }
     }
 </pre>
 <hr>
-<h3>How do I stop a thread that waits for long periods (e.g., for
-input)?</h3>
+<h2>How do I stop a thread that waits for long periods (e.g., for
+input)?</h2>
 <p>That's what the <code>Thread.interrupt</code> method is for. The
 same "state based" signaling mechanism shown above can be used, but
 the state change (<code>blinker = null</code>, in the previous
 example) can be followed by a call to
 <code>Thread.interrupt</code>, to interrupt the wait:</p>
@@ -143,12 +143,12 @@
     Thread.currentThread().interrupt();
 </pre>
 This ensures that the Thread will reraise the
 <code>InterruptedException</code> as soon as it is able.
 <hr>
-<h3>What if a thread doesn't respond to
-<code>Thread.interrupt</code>?</h3>
+<h2>What if a thread doesn't respond to
+<code>Thread.interrupt</code>?</h2>
 <p>In some cases, you can use application specific tricks. For
 example, if a thread is waiting on a known socket, you can close
 the socket to cause the thread to return immediately.
 Unfortunately, there really isn't any technique that works in
 general. <em>It should be noted that in all situations where a
@@ -156,22 +156,22 @@
 wouldn't respond to <code>Thread.stop</code> either.</em> Such
 cases include deliberate denial-of-service attacks, and I/O
 operations for which thread.stop and thread.interrupt do not work
 properly.</p>
 <hr>
-<h3>Why are <code>Thread.suspend</code> and
-<code>Thread.resume</code> deprecated?</h3>
+<h2>Why are <code>Thread.suspend</code> and
+<code>Thread.resume</code> deprecated?</h2>
 <p><code>Thread.suspend</code> is inherently deadlock-prone. If the
 target thread holds a lock on the monitor protecting a critical
 system resource when it is suspended, no thread can access this
 resource until the target thread is resumed. If the thread that
 would resume the target thread attempts to lock this monitor prior
 to calling <code>resume</code>, deadlock results. Such deadlocks
 typically manifest themselves as "frozen" processes.</p>
 <hr>
-<h3>What should I use instead of <code>Thread.suspend</code> and
-<code>Thread.resume</code>?</h3>
+<h2>What should I use instead of <code>Thread.suspend</code> and
+<code>Thread.resume</code>?</h2>
 <p>As with <code>Thread.stop</code>, the prudent approach is to
 have the "target thread" poll a variable indicating the desired
 state of the thread (active or suspended). When the desired state
 is suspended, the thread waits using <code>Object.wait</code>. When
 the thread is resumed, the target thread is notified using
@@ -281,12 +281,12 @@
             repaint();
         }
     }
 </pre>
 <hr size="3" noshade="noshade" />
-<h3>Can I combine the two techniques to produce a thread that may
-be safely "stopped" or "suspended"?</h3>
+<h2>Can I combine the two techniques to produce a thread that may
+be safely "stopped" or "suspended"?</h2>
 Yes, it's reasonably straightforward. The one subtlety is that the
 target thread may already be suspended at the time that another
 thread tries to stop it. If the <code>stop</code> method merely sets
 the state variable (<code>blinker</code>) to null, the target thread
 will remain suspended (waiting on the monitor), rather than exiting

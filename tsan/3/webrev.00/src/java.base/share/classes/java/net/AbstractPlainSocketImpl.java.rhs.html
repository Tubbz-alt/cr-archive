<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/AbstractPlainSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.OutputStream;
 32 
<a name="2" id="anc2"></a><span class="line-added"> 33 import java.security.AccessController;</span>
<span class="line-added"> 34 import java.security.PrivilegedActionException;</span>
<span class="line-added"> 35 import java.security.PrivilegedExceptionAction;</span>
 36 import java.util.Collections;
 37 import java.util.HashSet;
<a name="3" id="anc3"></a><span class="line-added"> 38 import java.util.Objects;</span>
 39 import java.util.Set;
 40 
 41 import sun.net.ConnectionResetException;
 42 import sun.net.NetHooks;
<a name="4" id="anc4"></a><span class="line-added"> 43 import sun.net.PlatformSocketImpl;</span>
 44 import sun.net.ResourceManager;
<a name="5" id="anc5"></a><span class="line-added"> 45 import sun.net.ext.ExtendedSocketOptions;</span>
<span class="line-added"> 46 import sun.net.util.IPAddressUtil;</span>
 47 import sun.net.util.SocketExceptions;
 48 
 49 /**
 50  * Default Socket Implementation. This implementation does
 51  * not implement any security checks.
 52  * Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.
 53  *
 54  * @author  Steven B. Byrne
 55  */
<a name="6" id="anc6"></a><span class="line-modified"> 56 abstract class AbstractPlainSocketImpl extends SocketImpl implements PlatformSocketImpl {</span>
 57     /* instance variable for SO_TIMEOUT */
 58     int timeout;   // timeout in millisec
 59     // traffic class
 60     private int trafficClass;
 61 
 62     private boolean shut_rd = false;
 63     private boolean shut_wr = false;
 64 
 65     private SocketInputStream socketInputStream = null;
 66     private SocketOutputStream socketOutputStream = null;
 67 
 68     /* number of threads using the FileDescriptor */
 69     protected int fdUseCount = 0;
 70 
 71     /* lock when increment/decrementing fdUseCount */
 72     protected final Object fdLock = new Object();
 73 
 74     /* indicates a close is pending on the file descriptor */
 75     protected boolean closePending = false;
 76 
 77     /* indicates connection reset state */
 78     private volatile boolean connectionReset;
 79 
<a name="7" id="anc7"></a><span class="line-added"> 80     /* indicates whether impl is bound  */</span>
<span class="line-added"> 81     boolean isBound;</span>
<span class="line-added"> 82 </span>
<span class="line-added"> 83     /* indicates whether impl is connected  */</span>
<span class="line-added"> 84     volatile boolean isConnected;</span>
<span class="line-added"> 85 </span>
 86    /* whether this Socket is a stream (TCP) socket or not (UDP)
 87     */
 88     protected boolean stream;
 89 
<a name="8" id="anc8"></a><span class="line-added"> 90     /* whether this is a server or not */</span>
<span class="line-added"> 91     final boolean isServer;</span>
<span class="line-added"> 92 </span>
 93     /**
 94      * Load net library into runtime.
 95      */
 96     static {
<a name="9" id="anc9"></a><span class="line-modified"> 97         jdk.internal.loader.BootLoader.loadLibrary(&quot;net&quot;);</span>






 98     }
 99 
100     private static volatile boolean checkedReusePort;
101     private static volatile boolean isReusePortAvailable;
102 
103     /**
104      * Tells whether SO_REUSEPORT is supported.
105      */
106     static boolean isReusePortAvailable() {
107         if (!checkedReusePort) {
108             isReusePortAvailable = isReusePortAvailable0();
109             checkedReusePort = true;
110         }
111         return isReusePortAvailable;
112     }
113 
<a name="10" id="anc10"></a><span class="line-modified">114     AbstractPlainSocketImpl(boolean isServer) {</span>
<span class="line-modified">115         this.isServer = isServer;</span>
















116     }
117 
118     /**
119      * Creates a socket with a boolean that specifies whether this
120      * is a stream socket (true) or an unconnected UDP socket (false).
121      */
122     protected synchronized void create(boolean stream) throws IOException {
123         this.stream = stream;
124         if (!stream) {
125             ResourceManager.beforeUdpCreate();
126             // only create the fd after we know we will be able to create the socket
127             fd = new FileDescriptor();
128             try {
129                 socketCreate(false);
<a name="11" id="anc11"></a><span class="line-modified">130                 SocketCleanable.register(fd, false);</span>
131             } catch (IOException ioe) {
132                 ResourceManager.afterUdpClose();
133                 fd = null;
134                 throw ioe;
135             }
136         } else {
137             fd = new FileDescriptor();
138             socketCreate(true);
<a name="12" id="anc12"></a><span class="line-modified">139             SocketCleanable.register(fd, true);</span>
140         }
<a name="13" id="anc13"></a>



141     }
142 
143     /**
144      * Creates a socket and connects it to the specified port on
145      * the specified host.
146      * @param host the specified host
147      * @param port the specified port
148      */
149     protected void connect(String host, int port)
150         throws UnknownHostException, IOException
151     {
152         boolean connected = false;
153         try {
154             InetAddress address = InetAddress.getByName(host);
<a name="14" id="anc14"></a><span class="line-modified">155             // recording this.address as supplied by caller before calling connect</span>
156             this.address = address;
<a name="15" id="anc15"></a><span class="line-added">157             this.port = port;</span>
<span class="line-added">158             if (address.isLinkLocalAddress()) {</span>
<span class="line-added">159                 address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">160             }</span>
161 
162             connectToAddress(address, port, timeout);
163             connected = true;
164         } finally {
165             if (!connected) {
166                 try {
167                     close();
168                 } catch (IOException ioe) {
169                     /* Do nothing. If connect threw an exception then
170                        it will be passed up the call stack */
171                 }
172             }
<a name="16" id="anc16"></a><span class="line-added">173             isConnected = connected;</span>
174         }
175     }
176 
177     /**
178      * Creates a socket and connects it to the specified address on
179      * the specified port.
180      * @param address the address
181      * @param port the specified port
182      */
183     protected void connect(InetAddress address, int port) throws IOException {
<a name="17" id="anc17"></a><span class="line-modified">184         // recording this.address as supplied by caller before calling connect</span>
185         this.address = address;
<a name="18" id="anc18"></a><span class="line-added">186         this.port = port;</span>
<span class="line-added">187         if (address.isLinkLocalAddress()) {</span>
<span class="line-added">188             address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">189         }</span>
190 
191         try {
192             connectToAddress(address, port, timeout);
<a name="19" id="anc19"></a><span class="line-added">193             isConnected = true;</span>
194             return;
195         } catch (IOException e) {
196             // everything failed
197             close();
198             throw e;
199         }
200     }
201 
202     /**
203      * Creates a socket and connects it to the specified address on
204      * the specified port.
205      * @param address the address
206      * @param timeout the timeout value in milliseconds, or zero for no timeout.
207      * @throws IOException if connection fails
208      * @throws  IllegalArgumentException if address is null or is a
209      *          SocketAddress subclass not supported by this socket
210      * @since 1.4
211      */
212     protected void connect(SocketAddress address, int timeout)
213             throws IOException {
214         boolean connected = false;
215         try {
216             if (address == null || !(address instanceof InetSocketAddress))
217                 throw new IllegalArgumentException(&quot;unsupported address type&quot;);
218             InetSocketAddress addr = (InetSocketAddress) address;
219             if (addr.isUnresolved())
220                 throw new UnknownHostException(addr.getHostName());
<a name="20" id="anc20"></a><span class="line-added">221             // recording this.address as supplied by caller before calling connect</span>
<span class="line-added">222             InetAddress ia = addr.getAddress();</span>
<span class="line-added">223             this.address = ia;</span>
224             this.port = addr.getPort();
<a name="21" id="anc21"></a><span class="line-modified">225             if (ia.isLinkLocalAddress()) {</span>
<span class="line-modified">226                 ia = IPAddressUtil.toScopedAddress(ia);</span>
<span class="line-modified">227             }</span>
<span class="line-added">228             connectToAddress(ia, port, timeout);</span>
229             connected = true;
230         } finally {
231             if (!connected) {
232                 try {
233                     close();
234                 } catch (IOException ioe) {
235                     /* Do nothing. If connect threw an exception then
236                        it will be passed up the call stack */
237                 }
238             }
<a name="22" id="anc22"></a><span class="line-added">239             isConnected = connected;</span>
240         }
241     }
242 
243     private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {
244         if (address.isAnyLocalAddress()) {
245             doConnect(InetAddress.getLocalHost(), port, timeout);
246         } else {
247             doConnect(address, port, timeout);
248         }
249     }
250 
251     public void setOption(int opt, Object val) throws SocketException {
252         if (isClosedOrPending()) {
253             throw new SocketException(&quot;Socket Closed&quot;);
254         }
255         boolean on = true;
256         switch (opt) {
257             /* check type safety b4 going native.  These should never
258              * fail, since only java.Socket* has access to
259              * PlainSocketImpl.setOption().
260              */
261         case SO_LINGER:
262             if (val == null || (!(val instanceof Integer) &amp;&amp; !(val instanceof Boolean)))
263                 throw new SocketException(&quot;Bad parameter for option&quot;);
264             if (val instanceof Boolean) {
265                 /* true only if disabling - enabling should be Integer */
266                 on = false;
267             }
268             break;
269         case SO_TIMEOUT:
270             if (val == null || (!(val instanceof Integer)))
271                 throw new SocketException(&quot;Bad parameter for SO_TIMEOUT&quot;);
272             int tmp = ((Integer) val).intValue();
273             if (tmp &lt; 0)
274                 throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);
275             timeout = tmp;
276             break;
277         case IP_TOS:
278              if (val == null || !(val instanceof Integer)) {
279                  throw new SocketException(&quot;bad argument for IP_TOS&quot;);
280              }
281              trafficClass = ((Integer)val).intValue();
282              break;
283         case SO_BINDADDR:
284             throw new SocketException(&quot;Cannot re-bind socket&quot;);
285         case TCP_NODELAY:
286             if (val == null || !(val instanceof Boolean))
287                 throw new SocketException(&quot;bad parameter for TCP_NODELAY&quot;);
288             on = ((Boolean)val).booleanValue();
289             break;
290         case SO_SNDBUF:
291         case SO_RCVBUF:
292             if (val == null || !(val instanceof Integer) ||
293                 !(((Integer)val).intValue() &gt; 0)) {
294                 throw new SocketException(&quot;bad parameter for SO_SNDBUF &quot; +
295                                           &quot;or SO_RCVBUF&quot;);
296             }
297             break;
298         case SO_KEEPALIVE:
299             if (val == null || !(val instanceof Boolean))
300                 throw new SocketException(&quot;bad parameter for SO_KEEPALIVE&quot;);
301             on = ((Boolean)val).booleanValue();
302             break;
303         case SO_OOBINLINE:
304             if (val == null || !(val instanceof Boolean))
305                 throw new SocketException(&quot;bad parameter for SO_OOBINLINE&quot;);
306             on = ((Boolean)val).booleanValue();
307             break;
308         case SO_REUSEADDR:
309             if (val == null || !(val instanceof Boolean))
310                 throw new SocketException(&quot;bad parameter for SO_REUSEADDR&quot;);
311             on = ((Boolean)val).booleanValue();
312             break;
313         case SO_REUSEPORT:
314             if (val == null || !(val instanceof Boolean))
315                 throw new SocketException(&quot;bad parameter for SO_REUSEPORT&quot;);
316             if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT))
317                 throw new UnsupportedOperationException(&quot;unsupported option&quot;);
318             on = ((Boolean)val).booleanValue();
319             break;
320         default:
321             throw new SocketException(&quot;unrecognized TCP option: &quot; + opt);
322         }
323         socketSetOption(opt, on, val);
324     }
325     public Object getOption(int opt) throws SocketException {
326         if (isClosedOrPending()) {
327             throw new SocketException(&quot;Socket Closed&quot;);
328         }
329         if (opt == SO_TIMEOUT) {
330             return timeout;
331         }
332         int ret = 0;
333         /*
334          * The native socketGetOption() knows about 3 options.
335          * The 32 bit value it returns will be interpreted according
336          * to what we&#39;re asking.  A return of -1 means it understands
337          * the option but its turned off.  It will raise a SocketException
338          * if &quot;opt&quot; isn&#39;t one it understands.
339          */
340 
341         switch (opt) {
342         case TCP_NODELAY:
343             ret = socketGetOption(opt, null);
344             return Boolean.valueOf(ret != -1);
345         case SO_OOBINLINE:
346             ret = socketGetOption(opt, null);
347             return Boolean.valueOf(ret != -1);
348         case SO_LINGER:
349             ret = socketGetOption(opt, null);
350             return (ret == -1) ? Boolean.FALSE: (Object)(ret);
351         case SO_REUSEADDR:
352             ret = socketGetOption(opt, null);
353             return Boolean.valueOf(ret != -1);
354         case SO_BINDADDR:
355             InetAddressContainer in = new InetAddressContainer();
356             ret = socketGetOption(opt, in);
357             return in.addr;
358         case SO_SNDBUF:
359         case SO_RCVBUF:
360             ret = socketGetOption(opt, null);
361             return ret;
362         case IP_TOS:
363             try {
364                 ret = socketGetOption(opt, null);
365                 if (ret == -1) { // ipv6 tos
366                     return trafficClass;
367                 } else {
368                     return ret;
369                 }
370             } catch (SocketException se) {
371                     // TODO - should make better effort to read TOS or TCLASS
372                     return trafficClass; // ipv6 tos
373             }
374         case SO_KEEPALIVE:
375             ret = socketGetOption(opt, null);
376             return Boolean.valueOf(ret != -1);
377         case SO_REUSEPORT:
378             if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {
379                 throw new UnsupportedOperationException(&quot;unsupported option&quot;);
380             }
381             ret = socketGetOption(opt, null);
382             return Boolean.valueOf(ret != -1);
383         // should never get here
384         default:
385             return null;
386         }
387     }
388 
<a name="23" id="anc23"></a><span class="line-added">389     static final ExtendedSocketOptions extendedOptions =</span>
<span class="line-added">390             ExtendedSocketOptions.getInstance();</span>
<span class="line-added">391 </span>
<span class="line-added">392     private static final Set&lt;SocketOption&lt;?&gt;&gt; clientSocketOptions = clientSocketOptions();</span>
<span class="line-added">393     private static final Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions = serverSocketOptions();</span>
<span class="line-added">394 </span>
<span class="line-added">395     private static Set&lt;SocketOption&lt;?&gt;&gt; clientSocketOptions() {</span>
<span class="line-added">396         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();</span>
<span class="line-added">397         options.add(StandardSocketOptions.SO_KEEPALIVE);</span>
<span class="line-added">398         options.add(StandardSocketOptions.SO_SNDBUF);</span>
<span class="line-added">399         options.add(StandardSocketOptions.SO_RCVBUF);</span>
<span class="line-added">400         options.add(StandardSocketOptions.SO_REUSEADDR);</span>
<span class="line-added">401         options.add(StandardSocketOptions.SO_LINGER);</span>
<span class="line-added">402         options.add(StandardSocketOptions.IP_TOS);</span>
<span class="line-added">403         options.add(StandardSocketOptions.TCP_NODELAY);</span>
<span class="line-added">404         if (isReusePortAvailable())</span>
<span class="line-added">405             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-added">406         options.addAll(ExtendedSocketOptions.clientSocketOptions());</span>
<span class="line-added">407         return Collections.unmodifiableSet(options);</span>
<span class="line-added">408     }</span>
<span class="line-added">409 </span>
<span class="line-added">410     private static Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions() {</span>
<span class="line-added">411         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();</span>
<span class="line-added">412         options.add(StandardSocketOptions.SO_RCVBUF);</span>
<span class="line-added">413         options.add(StandardSocketOptions.SO_REUSEADDR);</span>
<span class="line-added">414         options.add(StandardSocketOptions.IP_TOS);</span>
<span class="line-added">415         if (isReusePortAvailable())</span>
<span class="line-added">416             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-added">417         options.addAll(ExtendedSocketOptions.serverSocketOptions());</span>
<span class="line-added">418         return Collections.unmodifiableSet(options);</span>
<span class="line-added">419     }</span>
<span class="line-added">420 </span>
<span class="line-added">421     @Override</span>
<span class="line-added">422     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">423         if (isServer)</span>
<span class="line-added">424             return serverSocketOptions;</span>
<span class="line-added">425         else</span>
<span class="line-added">426             return clientSocketOptions;</span>
<span class="line-added">427     }</span>
<span class="line-added">428 </span>
<span class="line-added">429     @Override</span>
<span class="line-added">430     protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-added">431         Objects.requireNonNull(name);</span>
<span class="line-added">432         if (!supportedOptions().contains(name))</span>
<span class="line-added">433             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">434 </span>
<span class="line-added">435         if (!name.type().isInstance(value))</span>
<span class="line-added">436             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
<span class="line-added">437 </span>
<span class="line-added">438         if (isClosedOrPending())</span>
<span class="line-added">439             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">440 </span>
<span class="line-added">441         if (name == StandardSocketOptions.SO_KEEPALIVE) {</span>
<span class="line-added">442             setOption(SocketOptions.SO_KEEPALIVE, value);</span>
<span class="line-added">443         } else if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">444             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">445                 throw new IllegalArgumentException(&quot;Invalid send buffer size:&quot; + value);</span>
<span class="line-added">446             setOption(SocketOptions.SO_SNDBUF, value);</span>
<span class="line-added">447         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">448             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">449                 throw new IllegalArgumentException(&quot;Invalid recv buffer size:&quot; + value);</span>
<span class="line-added">450             setOption(SocketOptions.SO_RCVBUF, value);</span>
<span class="line-added">451         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">452             setOption(SocketOptions.SO_REUSEADDR, value);</span>
<span class="line-added">453         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">454             setOption(SocketOptions.SO_REUSEPORT, value);</span>
<span class="line-added">455         } else if (name == StandardSocketOptions.SO_LINGER ) {</span>
<span class="line-added">456             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">457                 setOption(SocketOptions.SO_LINGER, false);</span>
<span class="line-added">458             else</span>
<span class="line-added">459                 setOption(SocketOptions.SO_LINGER, value);</span>
<span class="line-added">460         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">461             int i = ((Integer)value).intValue();</span>
<span class="line-added">462             if (i &lt; 0 || i &gt; 255)</span>
<span class="line-added">463                 throw new IllegalArgumentException(&quot;Invalid IP_TOS value: &quot; + value);</span>
<span class="line-added">464             setOption(SocketOptions.IP_TOS, value);</span>
<span class="line-added">465         } else if (name == StandardSocketOptions.TCP_NODELAY) {</span>
<span class="line-added">466             setOption(SocketOptions.TCP_NODELAY, value);</span>
<span class="line-added">467         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">468             extendedOptions.setOption(fd, name, value);</span>
<span class="line-added">469         } else {</span>
<span class="line-added">470             throw new AssertionError(&quot;unknown option: &quot; + name);</span>
<span class="line-added">471         }</span>
<span class="line-added">472     }</span>
<span class="line-added">473 </span>
<span class="line-added">474     @Override</span>
<span class="line-added">475     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">476     protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">477         Objects.requireNonNull(name);</span>
<span class="line-added">478         if (!supportedOptions().contains(name))</span>
<span class="line-added">479             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">480 </span>
<span class="line-added">481         if (isClosedOrPending())</span>
<span class="line-added">482             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">483 </span>
<span class="line-added">484         if (name == StandardSocketOptions.SO_KEEPALIVE) {</span>
<span class="line-added">485             return (T)getOption(SocketOptions.SO_KEEPALIVE);</span>
<span class="line-added">486         } else if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">487             return (T)getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-added">488         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">489             return (T)getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-added">490         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">491             return (T)getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-added">492         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">493             return (T)getOption(SocketOptions.SO_REUSEPORT);</span>
<span class="line-added">494         } else if (name == StandardSocketOptions.SO_LINGER) {</span>
<span class="line-added">495             Object value = getOption(SocketOptions.SO_LINGER);</span>
<span class="line-added">496             if (value instanceof Boolean) {</span>
<span class="line-added">497                 assert ((Boolean)value).booleanValue() == false;</span>
<span class="line-added">498                 value = -1;</span>
<span class="line-added">499             }</span>
<span class="line-added">500             return (T)value;</span>
<span class="line-added">501         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">502             return (T)getOption(SocketOptions.IP_TOS);</span>
<span class="line-added">503         } else if (name == StandardSocketOptions.TCP_NODELAY) {</span>
<span class="line-added">504             return (T)getOption(SocketOptions.TCP_NODELAY);</span>
<span class="line-added">505         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">506             return (T) extendedOptions.getOption(fd, name);</span>
<span class="line-added">507         } else {</span>
<span class="line-added">508             throw new AssertionError(&quot;unknown option: &quot; + name);</span>
<span class="line-added">509         }</span>
<span class="line-added">510     }</span>
<span class="line-added">511 </span>
512     /**
513      * The workhorse of the connection operation.  Tries several times to
514      * establish a connection to the given &lt;host, port&gt;.  If unsuccessful,
515      * throws an IOException indicating what went wrong.
516      */
517 
518     synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
519         synchronized (fdLock) {
<a name="24" id="anc24"></a><span class="line-modified">520             if (!closePending &amp;&amp; !isBound) {</span>
521                 NetHooks.beforeTcpConnect(fd, address, port);
522             }
523         }
524         try {
525             acquireFD();
526             try {
527                 socketConnect(address, port, timeout);
528                 /* socket may have been closed during poll/select */
529                 synchronized (fdLock) {
530                     if (closePending) {
531                         throw new SocketException (&quot;Socket closed&quot;);
532                     }
533                 }
<a name="25" id="anc25"></a>







534             } finally {
535                 releaseFD();
536             }
537         } catch (IOException e) {
538             close();
539             throw SocketExceptions.of(e, new InetSocketAddress(address, port));
540         }
541     }
542 
543     /**
544      * Binds the socket to the specified address of the specified local port.
545      * @param address the address
546      * @param lport the port
547      */
548     protected synchronized void bind(InetAddress address, int lport)
549         throws IOException
550     {
551        synchronized (fdLock) {
<a name="26" id="anc26"></a><span class="line-modified">552             if (!closePending &amp;&amp; !isBound) {</span>
553                 NetHooks.beforeTcpBind(fd, address, lport);
554             }
555         }
<a name="27" id="anc27"></a><span class="line-added">556         if (address.isLinkLocalAddress()) {</span>
<span class="line-added">557             address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">558         }</span>
559         socketBind(address, lport);
<a name="28" id="anc28"></a><span class="line-modified">560         isBound = true;</span>



561     }
562 
563     /**
564      * Listens, for a specified amount of time, for connections.
565      * @param count the amount of time to listen for connections
566      */
567     protected synchronized void listen(int count) throws IOException {
568         socketListen(count);
569     }
570 
571     /**
572      * Accepts connections.
<a name="29" id="anc29"></a><span class="line-modified">573      * @param si the socket impl</span>
574      */
<a name="30" id="anc30"></a><span class="line-modified">575     protected void accept(SocketImpl si) throws IOException {</span>
<span class="line-added">576         si.fd = new FileDescriptor();</span>
577         acquireFD();
578         try {
<a name="31" id="anc31"></a><span class="line-modified">579             socketAccept(si);</span>
580         } finally {
581             releaseFD();
582         }
<a name="32" id="anc32"></a><span class="line-added">583         SocketCleanable.register(si.fd, true);</span>
584     }
585 
586     /**
587      * Gets an InputStream for this socket.
588      */
589     protected synchronized InputStream getInputStream() throws IOException {
590         synchronized (fdLock) {
591             if (isClosedOrPending())
592                 throw new IOException(&quot;Socket Closed&quot;);
593             if (shut_rd)
594                 throw new IOException(&quot;Socket input is shutdown&quot;);
<a name="33" id="anc33"></a><span class="line-modified">595             if (socketInputStream == null) {</span>
<span class="line-modified">596                 PrivilegedExceptionAction&lt;SocketInputStream&gt; pa = () -&gt; new SocketInputStream(this);</span>
<span class="line-added">597                 try {</span>
<span class="line-added">598                     socketInputStream = AccessController.doPrivileged(pa);</span>
<span class="line-added">599                 } catch (PrivilegedActionException e) {</span>
<span class="line-added">600                     throw (IOException) e.getCause();</span>
<span class="line-added">601                 }</span>
<span class="line-added">602             }</span>
603         }
604         return socketInputStream;
605     }
606 
607     void setInputStream(SocketInputStream in) {
608         socketInputStream = in;
609     }
610 
611     /**
612      * Gets an OutputStream for this socket.
613      */
614     protected synchronized OutputStream getOutputStream() throws IOException {
615         synchronized (fdLock) {
616             if (isClosedOrPending())
617                 throw new IOException(&quot;Socket Closed&quot;);
618             if (shut_wr)
619                 throw new IOException(&quot;Socket output is shutdown&quot;);
<a name="34" id="anc34"></a><span class="line-modified">620             if (socketOutputStream == null) {</span>
<span class="line-modified">621                 PrivilegedExceptionAction&lt;SocketOutputStream&gt; pa = () -&gt; new SocketOutputStream(this);</span>
<span class="line-added">622                 try {</span>
<span class="line-added">623                     socketOutputStream = AccessController.doPrivileged(pa);</span>
<span class="line-added">624                 } catch (PrivilegedActionException e) {</span>
<span class="line-added">625                     throw (IOException) e.getCause();</span>
<span class="line-added">626                 }</span>
<span class="line-added">627             }</span>
628         }
629         return socketOutputStream;
630     }
631 
632     void setFileDescriptor(FileDescriptor fd) {
633         this.fd = fd;
634     }
635 
636     void setAddress(InetAddress address) {
637         this.address = address;
638     }
639 
640     void setPort(int port) {
641         this.port = port;
642     }
643 
644     void setLocalPort(int localport) {
645         this.localport = localport;
646     }
647 
648     /**
649      * Returns the number of bytes that can be read without blocking.
650      */
651     protected synchronized int available() throws IOException {
652         if (isClosedOrPending()) {
653             throw new IOException(&quot;Stream closed.&quot;);
654         }
655 
656         /*
657          * If connection has been reset or shut down for input, then return 0
658          * to indicate there are no buffered bytes.
659          */
660         if (isConnectionReset() || shut_rd) {
661             return 0;
662         }
663 
664         /*
665          * If no bytes available and we were previously notified
666          * of a connection reset then we move to the reset state.
667          *
668          * If are notified of a connection reset then check
669          * again if there are bytes buffered on the socket.
670          */
671         int n = 0;
672         try {
673             n = socketAvailable();
674         } catch (ConnectionResetException exc1) {
675             setConnectionReset();
676         }
677         return n;
678     }
679 
680     /**
681      * Closes the socket.
682      */
683     protected void close() throws IOException {
684         synchronized(fdLock) {
685             if (fd != null) {
<a name="35" id="anc35"></a>


686                 if (fdUseCount == 0) {
687                     if (closePending) {
688                         return;
689                     }
690                     closePending = true;
691                     /*
692                      * We close the FileDescriptor in two-steps - first the
693                      * &quot;pre-close&quot; which closes the socket but doesn&#39;t
694                      * release the underlying file descriptor. This operation
695                      * may be lengthy due to untransmitted data and a long
696                      * linger interval. Once the pre-close is done we do the
697                      * actual socket to release the fd.
698                      */
699                     try {
700                         socketPreClose();
701                     } finally {
702                         socketClose();
703                     }
704                     fd = null;
705                     return;
706                 } else {
707                     /*
708                      * If a thread has acquired the fd and a close
709                      * isn&#39;t pending then use a deferred close.
710                      * Also decrement fdUseCount to signal the last
711                      * thread that releases the fd to close it.
712                      */
713                     if (!closePending) {
714                         closePending = true;
715                         fdUseCount--;
716                         socketPreClose();
717                     }
718                 }
719             }
720         }
721     }
722 
<a name="36" id="anc36"></a><span class="line-modified">723     void reset() {</span>
<span class="line-modified">724         throw new InternalError(&quot;should not get here&quot;);</span>




725     }
726 
<a name="37" id="anc37"></a>
727     /**
728      * Shutdown read-half of the socket connection;
729      */
730     protected void shutdownInput() throws IOException {
731       if (fd != null) {
732           socketShutdown(SHUT_RD);
733           if (socketInputStream != null) {
734               socketInputStream.setEOF(true);
735           }
736           shut_rd = true;
737       }
738     }
739 
740     /**
741      * Shutdown write-half of the socket connection;
742      */
743     protected void shutdownOutput() throws IOException {
744       if (fd != null) {
745           socketShutdown(SHUT_WR);
746           shut_wr = true;
747       }
748     }
749 
750     protected boolean supportsUrgentData () {
751         return true;
752     }
753 
754     protected void sendUrgentData (int data) throws IOException {
755         if (fd == null) {
756             throw new IOException(&quot;Socket Closed&quot;);
757         }
758         socketSendUrgentData (data);
759     }
760 
761     /*
762      * &quot;Acquires&quot; and returns the FileDescriptor for this impl
763      *
764      * A corresponding releaseFD is required to &quot;release&quot; the
765      * FileDescriptor.
766      */
767     FileDescriptor acquireFD() {
768         synchronized (fdLock) {
769             fdUseCount++;
770             return fd;
771         }
772     }
773 
774     /*
775      * &quot;Release&quot; the FileDescriptor for this impl.
776      *
777      * If the use count goes to -1 then the socket is closed.
778      */
779     void releaseFD() {
780         synchronized (fdLock) {
781             fdUseCount--;
782             if (fdUseCount == -1) {
783                 if (fd != null) {
784                     try {
785                         socketClose();
786                     } catch (IOException e) {
787                     } finally {
788                         fd = null;
789                     }
790                 }
791             }
792         }
793     }
794 
795     boolean isConnectionReset() {
796         return connectionReset;
797     }
798 
799     void setConnectionReset() {
800         connectionReset = true;
801     }
802 
803     /*
804      * Return true if already closed or close is pending
805      */
806     public boolean isClosedOrPending() {
807         /*
808          * Lock on fdLock to ensure that we wait if a
809          * close is in progress.
810          */
811         synchronized (fdLock) {
812             if (closePending || (fd == null)) {
813                 return true;
814             } else {
815                 return false;
816             }
817         }
818     }
819 
820     /*
821      * Return the current value of SO_TIMEOUT
822      */
823     public int getTimeout() {
824         return timeout;
825     }
826 
827     /*
828      * &quot;Pre-close&quot; a socket by dup&#39;ing the file descriptor - this enables
829      * the socket to be closed without releasing the file descriptor.
830      */
831     private void socketPreClose() throws IOException {
832         socketClose0(true);
833     }
834 
835     /*
836      * Close the socket (and release the file descriptor).
837      */
838     protected void socketClose() throws IOException {
839         SocketCleanable.unregister(fd);
<a name="38" id="anc38"></a><span class="line-modified">840         try {</span>
<span class="line-added">841             socketClose0(false);</span>
<span class="line-added">842         } finally {</span>
<span class="line-added">843             if (!stream) {</span>
<span class="line-added">844                 ResourceManager.afterUdpClose();</span>
<span class="line-added">845             }</span>
<span class="line-added">846         }</span>
847     }
848 
<a name="39" id="anc39"></a><span class="line-modified">849     abstract void socketCreate(boolean stream) throws IOException;</span>
850     abstract void socketConnect(InetAddress address, int port, int timeout)
851         throws IOException;
852     abstract void socketBind(InetAddress address, int port)
853         throws IOException;
854     abstract void socketListen(int count)
855         throws IOException;
856     abstract void socketAccept(SocketImpl s)
857         throws IOException;
858     abstract int socketAvailable()
859         throws IOException;
860     abstract void socketClose0(boolean useDeferredClose)
861         throws IOException;
862     abstract void socketShutdown(int howto)
863         throws IOException;
864     abstract void socketSetOption(int cmd, boolean on, Object value)
865         throws SocketException;
866     abstract int socketGetOption(int opt, Object iaContainerObj) throws SocketException;
867     abstract void socketSendUrgentData(int data)
868         throws IOException;
869 
870     public static final int SHUT_RD = 0;
871     public static final int SHUT_WR = 1;
872 
873     private static native boolean isReusePortAvailable0();
874 }
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
@@ -39,10 +39,11 @@
 import sun.invoke.util.ValueConversions;
 import sun.invoke.util.VerifyType;
 import sun.invoke.util.Wrapper;
 
 import java.lang.reflect.Array;
+import java.nio.ByteOrder;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -57,11 +58,12 @@
 
 /**
  * Trusted implementation code for MethodHandle.
  * @author jrose
  */
-/*non-public*/ abstract class MethodHandleImpl {
+/*non-public*/
+abstract class MethodHandleImpl {
 
     /// Factory methods to create method handles:
 
     static MethodHandle makeArrayElementAccessor(Class<?> arrayClass, ArrayAccess access) {
         if (arrayClass == Object[].class) {
@@ -681,24 +683,22 @@
         LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);
         return SimpleMethodHandle.make(srcType, form);
     }
 
     @Hidden
-    static
-    MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {
+    static MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {
         if (testResult) {
             return target;
         } else {
             return fallback;
         }
     }
 
     // Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.
     @Hidden
     @jdk.internal.HotSpotIntrinsicCandidate
-    static
-    boolean profileBoolean(boolean result, int[] counters) {
+    static boolean profileBoolean(boolean result, int[] counters) {
         // Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.
         int idx = result ? 1 : 0;
         try {
             counters[idx] = Math.addExact(counters[idx], 1);
         } catch (ArithmeticException e) {
@@ -709,17 +709,15 @@
     }
 
     // Intrinsified by C2. Returns true if obj is a compile-time constant.
     @Hidden
     @jdk.internal.HotSpotIntrinsicCandidate
-    static
-    boolean isCompileConstant(Object obj) {
+    static boolean isCompileConstant(Object obj) {
         return false;
     }
 
-    static
-    MethodHandle makeGuardWithTest(MethodHandle test,
+    static MethodHandle makeGuardWithTest(MethodHandle test,
                                    MethodHandle target,
                                    MethodHandle fallback) {
         MethodType type = target.type();
         assert(test.type().equals(type.changeReturnType(boolean.class)) && fallback.type().equals(type));
         MethodType basicType = type.basicType();
@@ -742,12 +740,11 @@
         assert(mh.type() == type);
         return mh;
     }
 
 
-    static
-    MethodHandle profile(MethodHandle target) {
+    static MethodHandle profile(MethodHandle target) {
         if (DONT_INLINE_THRESHOLD >= 0) {
             return makeBlockInliningWrapper(target);
         } else {
             return target;
         }
@@ -755,12 +752,11 @@
 
     /**
      * Block inlining during JIT-compilation of a target method handle if it hasn't been invoked enough times.
      * Corresponding LambdaForm has @DontInline when compiled into bytecode.
      */
-    static
-    MethodHandle makeBlockInliningWrapper(MethodHandle target) {
+    static MethodHandle makeBlockInliningWrapper(MethodHandle target) {
         LambdaForm lform;
         if (DONT_INLINE_THRESHOLD > 0) {
             lform = Makers.PRODUCE_BLOCK_INLINING_FORM.apply(target);
         } else {
             lform = Makers.PRODUCE_REINVOKER_FORM.apply(target);
@@ -893,12 +889,11 @@
                 throw newInternalError(ex);
             }
         }
     }
 
-    static
-    LambdaForm makeGuardWithTestForm(MethodType basicType) {
+    static LambdaForm makeGuardWithTestForm(MethodType basicType) {
         LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWT);
         if (lform != null)  return lform;
         final int THIS_MH      = 0;  // the BMH_LLL
         final int ARG_BASE     = 1;  // start of incoming arguments
         final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
@@ -1024,12 +1019,11 @@
         lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);
 
         return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWC, lform);
     }
 
-    static
-    MethodHandle makeGuardWithCatch(MethodHandle target,
+    static MethodHandle makeGuardWithCatch(MethodHandle target,
                                     Class<? extends Throwable> exType,
                                     MethodHandle catcher) {
         MethodType type = target.type();
         LambdaForm form = makeGuardWithCatchForm(type.basicType());
 
@@ -1076,12 +1070,11 @@
         System.arraycopy(elems, 0, newArray, 0, nElems);
         System.arraycopy(array, 0, newArray, nElems, nArray);
         return newArray;
     }
 
-    static
-    MethodHandle throwException(MethodType type) {
+    static MethodHandle throwException(MethodType type) {
         assert(Throwable.class.isAssignableFrom(type.parameterType(0)));
         int arity = type.parameterCount();
         if (arity > 1) {
             MethodHandle mh = throwException(type.dropParameterTypes(1, arity));
             mh = MethodHandles.dropArguments(mh, 1, Arrays.copyOfRange(type.parameterArray(), 1, arity));
@@ -1135,22 +1128,20 @@
      * as hostClass.
      * This is an expensive no-op unless the method which is called
      * is sensitive to its caller.  A small number of system methods
      * are in this category, including Class.forName and Method.invoke.
      */
-    static
-    MethodHandle bindCaller(MethodHandle mh, Class<?> hostClass) {
+    static MethodHandle bindCaller(MethodHandle mh, Class<?> hostClass) {
         return BindCaller.bindCaller(mh, hostClass);
     }
 
     // Put the whole mess into its own nested class.
     // That way we can lazily load the code and set up the constants.
     private static class BindCaller {
         private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
 
-        static
-        MethodHandle bindCaller(MethodHandle mh, Class<?> hostClass) {
+        static MethodHandle bindCaller(MethodHandle mh, Class<?> hostClass) {
             // Code in the boot layer should now be careful while creating method handles or
             // functional interface instances created from method references to @CallerSensitive  methods,
             // it needs to be ensured the handles or interface instances are kept safe and are not passed
             // from the boot layer to untrusted code.
             if (hostClass == null
@@ -1663,11 +1654,12 @@
         Class<?> elemType = arrayType.getComponentType();
         assert(elemType.isPrimitive());
         return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));
     }
 
-    /*non-public*/ static void assertSame(Object mh1, Object mh2) {
+    /*non-public*/
+    static void assertSame(Object mh1, Object mh2) {
         if (mh1 != mh2) {
             String msg = String.format("mh1 != mh2: mh1 = %s (form: %s); mh2 = %s (form: %s)",
                     mh1, ((MethodHandle)mh1).form,
                     mh2, ((MethodHandle)mh2).form);
             throw newInternalError(msg);
@@ -1797,10 +1789,48 @@
                 return GenerateJLIClassesHelper
                         .generateInvokersHolderClassBytes(className,
                                 invokerMethodTypes, callSiteMethodTypes);
             }
 
+            @Override
+            public VarHandle memoryAddressViewVarHandle(Class<?> carrier, long alignmentMask,
+                                                        ByteOrder order, long offset, long[] strides) {
+                return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order, offset, strides);
+            }
+
+            @Override
+            public Class<?> memoryAddressCarrier(VarHandle handle) {
+                return checkMemAccessHandle(handle).carrier();
+            }
+
+            @Override
+            public long memoryAddressAlignmentMask(VarHandle handle) {
+                return checkMemAccessHandle(handle).alignmentMask;
+            }
+
+            @Override
+            public ByteOrder memoryAddressByteOrder(VarHandle handle) {
+                return checkMemAccessHandle(handle).be ?
+                        ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
+            }
+
+            @Override
+            public long memoryAddressOffset(VarHandle handle) {
+                return checkMemAccessHandle(handle).offset;
+            }
+
+            @Override
+            public long[] memoryAddressStrides(VarHandle handle) {
+                return checkMemAccessHandle(handle).strides();
+            }
+
+            private VarHandleMemoryAddressBase checkMemAccessHandle(VarHandle handle) {
+                if (!(handle instanceof VarHandleMemoryAddressBase)) {
+                    throw new IllegalArgumentException("Not a memory access varhandle: " + handle);
+                }
+                return (VarHandleMemoryAddressBase) handle;
+            }
         });
     }
 
     /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
     private static MethodHandle unboxResultHandle(Class<?> returnType) {

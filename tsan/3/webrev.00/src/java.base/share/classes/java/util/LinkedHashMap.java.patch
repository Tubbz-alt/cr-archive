diff a/src/java.base/share/classes/java/util/LinkedHashMap.java b/src/java.base/share/classes/java/util/LinkedHashMap.java
--- a/src/java.base/share/classes/java/util/LinkedHashMap.java
+++ b/src/java.base/share/classes/java/util/LinkedHashMap.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -194,10 +194,11 @@
         Entry(int hash, K key, V value, Node<K,V> next) {
             super(hash, key, value, next);
         }
     }
 
+    @java.io.Serial
     private static final long serialVersionUID = 3801124242820219131L;
 
     /**
      * The head (eldest) of the doubly linked list.
      */
@@ -534,10 +535,30 @@
             keySet = ks;
         }
         return ks;
     }
 
+    @Override
+    final <T> T[] keysToArray(T[] a) {
+        Object[] r = a;
+        int idx = 0;
+        for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after) {
+            r[idx++] = e.key;
+        }
+        return a;
+    }
+
+    @Override
+    final <T> T[] valuesToArray(T[] a) {
+        Object[] r = a;
+        int idx = 0;
+        for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after) {
+            r[idx++] = e.value;
+        }
+        return a;
+    }
+
     final class LinkedKeySet extends AbstractSet<K> {
         public final int size()                 { return size; }
         public final void clear()               { LinkedHashMap.this.clear(); }
         public final Iterator<K> iterator() {
             return new LinkedKeyIterator();
@@ -549,10 +570,19 @@
         public final Spliterator<K> spliterator()  {
             return Spliterators.spliterator(this, Spliterator.SIZED |
                                             Spliterator.ORDERED |
                                             Spliterator.DISTINCT);
         }
+
+        public Object[] toArray() {
+            return keysToArray(new Object[size]);
+        }
+
+        public <T> T[] toArray(T[] a) {
+            return keysToArray(prepareArray(a));
+        }
+
         public final void forEach(Consumer<? super K> action) {
             if (action == null)
                 throw new NullPointerException();
             int mc = modCount;
             for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)
@@ -598,10 +628,19 @@
         public final boolean contains(Object o) { return containsValue(o); }
         public final Spliterator<V> spliterator() {
             return Spliterators.spliterator(this, Spliterator.SIZED |
                                             Spliterator.ORDERED);
         }
+
+        public Object[] toArray() {
+            return valuesToArray(new Object[size]);
+        }
+
+        public <T> T[] toArray(T[] a) {
+            return valuesToArray(prepareArray(a));
+        }
+
         public final void forEach(Consumer<? super V> action) {
             if (action == null)
                 throw new NullPointerException();
             int mc = modCount;
             for (LinkedHashMap.Entry<K,V> e = head; e != null; e = e.after)

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/VarHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="VarForm.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/VarHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -232,11 +232,11 @@</span>
   * are phrased in terms of the lack of &quot;reorderings&quot; -- observable ordering
   * effects that might otherwise occur if the fence was not present.  More
   * precise phrasing of the specification of access mode methods and memory fence
   * methods may accompany future updates of the Java Language Specification.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Compiling invocation of access mode methods&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Compiling invocation of access mode methods&lt;/h2&gt;</span>
   * A Java method call expression naming an access mode method can invoke a
   * VarHandle from Java source code.  From the viewpoint of source code, these
   * methods can take any arguments and their polymorphic result (if expressed)
   * can be cast to any return type.  Formally this is accomplished by giving the
   * access mode methods variable arity {@code Object} arguments and
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -264,11 +264,11 @@</span>
   * descriptor of {@code java.lang.Void}.  The ambiguity with the type
   * {@code Void} is harmless, since there are no references of type {@code Void}
   * except the null reference.
   *
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;&lt;a id=&quot;invoke&quot;&gt;Performing invocation of access mode methods&lt;/a&gt;&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;&lt;a id=&quot;invoke&quot;&gt;Performing invocation of access mode methods&lt;/a&gt;&lt;/h2&gt;</span>
   * The first time an {@code invokevirtual} instruction is executed it is linked
   * by symbolically resolving the names in the instruction and verifying that
   * the method call is statically legal.  This also holds for calls to access mode
   * methods.  In this case, the symbolic type descriptor emitted by the compiler
   * is checked for correct syntax, and names it contains are resolved.  Thus, an
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -327,11 +327,11 @@</span>
   * R r = (R) mh.invoke(p1, p2, ..., pN)
   * }&lt;/pre&gt;
   * Where, in this case, the method handle is bound to the VarHandle instance.
   *
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Invocation checking&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Invocation checking&lt;/h2&gt;</span>
   * In typical programs, VarHandle access mode type matching will usually
   * succeed.  But if a match fails, the JVM will throw a
   * {@link WrongMethodTypeException}.
   * &lt;p&gt;
   * Thus, an access mode type mismatch which might show up as a linkage error
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -362,11 +362,11 @@</span>
   * Thus, VarHandles to non-public variables, or to variables in non-public
   * classes, should generally be kept secret.  They should not be passed to
   * untrusted code unless their use from the untrusted code would be harmless.
   *
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;VarHandle creation&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;VarHandle creation&lt;/h2&gt;</span>
   * Java code can create a VarHandle that directly accesses any field that is
   * accessible to that code.  This is done via a reflective, capability-based
   * API called {@link java.lang.invoke.MethodHandles.Lookup
   * MethodHandles.Lookup}.
   * For example, a VarHandle for a non-static field can be obtained
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -381,11 +381,11 @@</span>
   * turn be a subclass (or package sibling) of the protected member&#39;s defining
   * class.  If a VarHandle refers to a protected non-static field of a declaring
   * class outside the current package, the receiver argument will be narrowed to
   * the type of the accessing class.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Interoperation between VarHandles and the Core Reflection API&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Interoperation between VarHandles and the Core Reflection API&lt;/h2&gt;</span>
   * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup
   * Lookup} API, any field represented by a Core Reflection API object
   * can be converted to a behaviorally equivalent VarHandle.
   * For example, a reflective {@link java.lang.reflect.Field Field} can
   * be converted to a VarHandle using
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -426,11 +426,11 @@</span>
   * {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
   * API is also able to return a method handle to call an access mode method for
   * any specified access mode type and is equivalent in behaviour to
   * {@link java.lang.invoke.MethodHandles#varHandleInvoker}.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Interoperation between VarHandles and Java generics&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Interoperation between VarHandles and Java generics&lt;/h2&gt;</span>
   * A VarHandle can be obtained for a variable, such as a field, which is
   * declared with Java generic types.  As with the Core Reflection API, the
   * VarHandle&#39;s variable type will be constructed from the erasure of the
   * source-level type.  When a VarHandle access mode method is invoked, the
   * types
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2116,11 +2116,11 @@</span>
      public static void storeStoreFence() {
          UNSAFE.storeStoreFence();
      }
  
      /**
<span class="udiff-line-modified-removed">-      * A &lt;a href=&quot;package-summary.html#nominal&quot;&gt;nominal descriptor&lt;/a&gt; for a</span>
<span class="udiff-line-modified-added">+      * A &lt;a href=&quot;{@docRoot}/java.base/java/lang/constant/package-summary.html#nominal&quot;&gt;nominal descriptor&lt;/a&gt; for a</span>
       * {@link VarHandle} constant.
       *
       * @since 12
       */
      public static final class VarHandleDesc extends DynamicConstantDesc&lt;VarHandle&gt; {
</pre>
<center><a href="VarForm.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarHandles.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
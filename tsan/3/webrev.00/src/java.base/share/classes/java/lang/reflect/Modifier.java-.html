<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/reflect/Modifier.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.reflect;
 27 
 28 import java.security.AccessController;
 29 import java.util.StringJoiner;
 30 import jdk.internal.reflect.LangReflectAccess;
 31 import jdk.internal.reflect.ReflectionFactory;
 32 
 33 /**
 34  * The Modifier class provides {@code static} methods and
 35  * constants to decode class and member access modifiers.  The sets of
 36  * modifiers are represented as integers with distinct bit positions
 37  * representing different modifiers.  The values for the constants
 38  * representing the modifiers are taken from the tables in sections 4.1, 4.4, 4.5, and 4.7 of
 39  * &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
 40  *
 41  * @see Class#getModifiers()
 42  * @see Member#getModifiers()
 43  *
 44  * @author Nakul Saraiya
 45  * @author Kenneth Russell
 46  * @since 1.1
 47  */
 48 public class Modifier {
 49 
 50     /*
 51      * Bootstrapping protocol between java.lang and java.lang.reflect
 52      *  packages
 53      */
 54     static {
 55         ReflectionFactory factory = AccessController.doPrivileged(
 56                 new ReflectionFactory.GetReflectionFactoryAction());
 57         factory.setLangReflectAccess(new java.lang.reflect.ReflectAccess());
 58     }
 59 
 60     /**
 61      * Return {@code true} if the integer argument includes the
 62      * {@code public} modifier, {@code false} otherwise.
 63      *
 64      * @param   mod a set of modifiers
 65      * @return {@code true} if {@code mod} includes the
 66      * {@code public} modifier; {@code false} otherwise.
 67      */
 68     public static boolean isPublic(int mod) {
 69         return (mod &amp; PUBLIC) != 0;
 70     }
 71 
 72     /**
 73      * Return {@code true} if the integer argument includes the
 74      * {@code private} modifier, {@code false} otherwise.
 75      *
 76      * @param   mod a set of modifiers
 77      * @return {@code true} if {@code mod} includes the
 78      * {@code private} modifier; {@code false} otherwise.
 79      */
 80     public static boolean isPrivate(int mod) {
 81         return (mod &amp; PRIVATE) != 0;
 82     }
 83 
 84     /**
 85      * Return {@code true} if the integer argument includes the
 86      * {@code protected} modifier, {@code false} otherwise.
 87      *
 88      * @param   mod a set of modifiers
 89      * @return {@code true} if {@code mod} includes the
 90      * {@code protected} modifier; {@code false} otherwise.
 91      */
 92     public static boolean isProtected(int mod) {
 93         return (mod &amp; PROTECTED) != 0;
 94     }
 95 
 96     /**
 97      * Return {@code true} if the integer argument includes the
 98      * {@code static} modifier, {@code false} otherwise.
 99      *
100      * @param   mod a set of modifiers
101      * @return {@code true} if {@code mod} includes the
102      * {@code static} modifier; {@code false} otherwise.
103      */
104     public static boolean isStatic(int mod) {
105         return (mod &amp; STATIC) != 0;
106     }
107 
108     /**
109      * Return {@code true} if the integer argument includes the
110      * {@code final} modifier, {@code false} otherwise.
111      *
112      * @param   mod a set of modifiers
113      * @return {@code true} if {@code mod} includes the
114      * {@code final} modifier; {@code false} otherwise.
115      */
116     public static boolean isFinal(int mod) {
117         return (mod &amp; FINAL) != 0;
118     }
119 
120     /**
121      * Return {@code true} if the integer argument includes the
122      * {@code synchronized} modifier, {@code false} otherwise.
123      *
124      * @param   mod a set of modifiers
125      * @return {@code true} if {@code mod} includes the
126      * {@code synchronized} modifier; {@code false} otherwise.
127      */
128     public static boolean isSynchronized(int mod) {
129         return (mod &amp; SYNCHRONIZED) != 0;
130     }
131 
132     /**
133      * Return {@code true} if the integer argument includes the
134      * {@code volatile} modifier, {@code false} otherwise.
135      *
136      * @param   mod a set of modifiers
137      * @return {@code true} if {@code mod} includes the
138      * {@code volatile} modifier; {@code false} otherwise.
139      */
140     public static boolean isVolatile(int mod) {
141         return (mod &amp; VOLATILE) != 0;
142     }
143 
144     /**
145      * Return {@code true} if the integer argument includes the
146      * {@code transient} modifier, {@code false} otherwise.
147      *
148      * @param   mod a set of modifiers
149      * @return {@code true} if {@code mod} includes the
150      * {@code transient} modifier; {@code false} otherwise.
151      */
152     public static boolean isTransient(int mod) {
153         return (mod &amp; TRANSIENT) != 0;
154     }
155 
156     /**
157      * Return {@code true} if the integer argument includes the
158      * {@code native} modifier, {@code false} otherwise.
159      *
160      * @param   mod a set of modifiers
161      * @return {@code true} if {@code mod} includes the
162      * {@code native} modifier; {@code false} otherwise.
163      */
164     public static boolean isNative(int mod) {
165         return (mod &amp; NATIVE) != 0;
166     }
167 
168     /**
169      * Return {@code true} if the integer argument includes the
170      * {@code interface} modifier, {@code false} otherwise.
171      *
172      * @param   mod a set of modifiers
173      * @return {@code true} if {@code mod} includes the
174      * {@code interface} modifier; {@code false} otherwise.
175      */
176     public static boolean isInterface(int mod) {
177         return (mod &amp; INTERFACE) != 0;
178     }
179 
180     /**
181      * Return {@code true} if the integer argument includes the
182      * {@code abstract} modifier, {@code false} otherwise.
183      *
184      * @param   mod a set of modifiers
185      * @return {@code true} if {@code mod} includes the
186      * {@code abstract} modifier; {@code false} otherwise.
187      */
188     public static boolean isAbstract(int mod) {
189         return (mod &amp; ABSTRACT) != 0;
190     }
191 
192     /**
193      * Return {@code true} if the integer argument includes the
194      * {@code strictfp} modifier, {@code false} otherwise.
195      *
196      * @param   mod a set of modifiers
197      * @return {@code true} if {@code mod} includes the
198      * {@code strictfp} modifier; {@code false} otherwise.
199      */
200     public static boolean isStrict(int mod) {
201         return (mod &amp; STRICT) != 0;
202     }
203 
204     /**
205      * Return a string describing the access modifier flags in
206      * the specified modifier. For example:
207      * &lt;blockquote&gt;&lt;pre&gt;
208      *    public final synchronized strictfp
209      * &lt;/pre&gt;&lt;/blockquote&gt;
210      * The modifier names are returned in an order consistent with the
211      * suggested modifier orderings given in sections 8.1.1, 8.3.1, 8.4.3, 8.8.3, and 9.1.1 of
212      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
213      * The full modifier ordering used by this method is:
214      * &lt;blockquote&gt; {@code
215      * public protected private abstract static final transient
216      * volatile synchronized native strictfp
217      * interface } &lt;/blockquote&gt;
218      * The {@code interface} modifier discussed in this class is
219      * not a true modifier in the Java language and it appears after
220      * all other modifiers listed by this method.  This method may
221      * return a string of modifiers that are not valid modifiers of a
222      * Java entity; in other words, no checking is done on the
223      * possible validity of the combination of modifiers represented
224      * by the input.
225      *
226      * Note that to perform such checking for a known kind of entity,
227      * such as a constructor or method, first AND the argument of
228      * {@code toString} with the appropriate mask from a method like
229      * {@link #constructorModifiers} or {@link #methodModifiers}.
230      *
231      * @param   mod a set of modifiers
232      * @return  a string representation of the set of modifiers
233      * represented by {@code mod}
234      */
235     public static String toString(int mod) {
236         StringJoiner sj = new StringJoiner(&quot; &quot;);
237 
238         if ((mod &amp; PUBLIC) != 0)        sj.add(&quot;public&quot;);
239         if ((mod &amp; PROTECTED) != 0)     sj.add(&quot;protected&quot;);
240         if ((mod &amp; PRIVATE) != 0)       sj.add(&quot;private&quot;);
241 
242         /* Canonical order */
243         if ((mod &amp; ABSTRACT) != 0)      sj.add(&quot;abstract&quot;);
244         if ((mod &amp; STATIC) != 0)        sj.add(&quot;static&quot;);
245         if ((mod &amp; FINAL) != 0)         sj.add(&quot;final&quot;);
246         if ((mod &amp; TRANSIENT) != 0)     sj.add(&quot;transient&quot;);
247         if ((mod &amp; VOLATILE) != 0)      sj.add(&quot;volatile&quot;);
248         if ((mod &amp; SYNCHRONIZED) != 0)  sj.add(&quot;synchronized&quot;);
249         if ((mod &amp; NATIVE) != 0)        sj.add(&quot;native&quot;);
250         if ((mod &amp; STRICT) != 0)        sj.add(&quot;strictfp&quot;);
251         if ((mod &amp; INTERFACE) != 0)     sj.add(&quot;interface&quot;);
252 
253         return sj.toString();
254     }
255 
256     /*
257      * Access modifier flag constants from tables 4.1, 4.4, 4.5, and 4.7 of
258      * &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
259      */
260 
261     /**
262      * The {@code int} value representing the {@code public}
263      * modifier.
264      */
265     public static final int PUBLIC           = 0x00000001;
266 
267     /**
268      * The {@code int} value representing the {@code private}
269      * modifier.
270      */
271     public static final int PRIVATE          = 0x00000002;
272 
273     /**
274      * The {@code int} value representing the {@code protected}
275      * modifier.
276      */
277     public static final int PROTECTED        = 0x00000004;
278 
279     /**
280      * The {@code int} value representing the {@code static}
281      * modifier.
282      */
283     public static final int STATIC           = 0x00000008;
284 
285     /**
286      * The {@code int} value representing the {@code final}
287      * modifier.
288      */
289     public static final int FINAL            = 0x00000010;
290 
291     /**
292      * The {@code int} value representing the {@code synchronized}
293      * modifier.
294      */
295     public static final int SYNCHRONIZED     = 0x00000020;
296 
297     /**
298      * The {@code int} value representing the {@code volatile}
299      * modifier.
300      */
301     public static final int VOLATILE         = 0x00000040;
302 
303     /**
304      * The {@code int} value representing the {@code transient}
305      * modifier.
306      */
307     public static final int TRANSIENT        = 0x00000080;
308 
309     /**
310      * The {@code int} value representing the {@code native}
311      * modifier.
312      */
313     public static final int NATIVE           = 0x00000100;
314 
315     /**
316      * The {@code int} value representing the {@code interface}
317      * modifier.
318      */
319     public static final int INTERFACE        = 0x00000200;
320 
321     /**
322      * The {@code int} value representing the {@code abstract}
323      * modifier.
324      */
325     public static final int ABSTRACT         = 0x00000400;
326 
327     /**
328      * The {@code int} value representing the {@code strictfp}
329      * modifier.
330      */
331     public static final int STRICT           = 0x00000800;
332 
333     // Bits not (yet) exposed in the public API either because they
334     // have different meanings for fields and methods and there is no
335     // way to distinguish between the two in this class, or because
336     // they are not Java programming language keywords
337     static final int BRIDGE    = 0x00000040;
338     static final int VARARGS   = 0x00000080;
339     static final int SYNTHETIC = 0x00001000;
340     static final int ANNOTATION  = 0x00002000;
341     static final int ENUM      = 0x00004000;
342     static final int MANDATED  = 0x00008000;
343     static boolean isSynthetic(int mod) {
344       return (mod &amp; SYNTHETIC) != 0;
345     }
346 
347     static boolean isMandated(int mod) {
348       return (mod &amp; MANDATED) != 0;
349     }
350 
351     // Note on the FOO_MODIFIERS fields and fooModifiers() methods:
352     // the sets of modifiers are not guaranteed to be constants
353     // across time and Java SE releases. Therefore, it would not be
354     // appropriate to expose an external interface to this information
355     // that would allow the values to be treated as Java-level
356     // constants since the values could be constant folded and updates
357     // to the sets of modifiers missed. Thus, the fooModifiers()
358     // methods return an unchanging values for a given release, but a
359     // value that can potentially change over time.
360 
361     /**
362      * The Java source modifiers that can be applied to a class.
363      * @jls 8.1.1 Class Modifiers
364      */
365     private static final int CLASS_MODIFIERS =
366         Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
367         Modifier.ABSTRACT       | Modifier.STATIC       | Modifier.FINAL   |
368         Modifier.STRICT;
369 
370     /**
371      * The Java source modifiers that can be applied to an interface.
372      * @jls 9.1.1 Interface Modifiers
373      */
374     private static final int INTERFACE_MODIFIERS =
375         Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
376         Modifier.ABSTRACT       | Modifier.STATIC       | Modifier.STRICT;
377 
378 
379     /**
380      * The Java source modifiers that can be applied to a constructor.
381      * @jls 8.8.3 Constructor Modifiers
382      */
383     private static final int CONSTRUCTOR_MODIFIERS =
384         Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE;
385 
386     /**
387      * The Java source modifiers that can be applied to a method.
388      * @jls8.4.3  Method Modifiers
389      */
390     private static final int METHOD_MODIFIERS =
391         Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
392         Modifier.ABSTRACT       | Modifier.STATIC       | Modifier.FINAL   |
393         Modifier.SYNCHRONIZED   | Modifier.NATIVE       | Modifier.STRICT;
394 
395     /**
396      * The Java source modifiers that can be applied to a field.
397      * @jls 8.3.1  Field Modifiers
398      */
399     private static final int FIELD_MODIFIERS =
400         Modifier.PUBLIC         | Modifier.PROTECTED    | Modifier.PRIVATE |
401         Modifier.STATIC         | Modifier.FINAL        | Modifier.TRANSIENT |
402         Modifier.VOLATILE;
403 
404     /**
405      * The Java source modifiers that can be applied to a method or constructor parameter.
406      * @jls 8.4.1 Formal Parameters
407      */
408     private static final int PARAMETER_MODIFIERS =
409         Modifier.FINAL;
410 
411     /**
412      *
413      */
414     static final int ACCESS_MODIFIERS =
415         Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;
416 
417     /**
418      * Return an {@code int} value OR-ing together the source language
419      * modifiers that can be applied to a class.
420      * @return an {@code int} value OR-ing together the source language
421      * modifiers that can be applied to a class.
422      *
423      * @jls 8.1.1 Class Modifiers
424      * @since 1.7
425      */
426     public static int classModifiers() {
427         return CLASS_MODIFIERS;
428     }
429 
430     /**
431      * Return an {@code int} value OR-ing together the source language
432      * modifiers that can be applied to an interface.
433      * @return an {@code int} value OR-ing together the source language
434      * modifiers that can be applied to an interface.
435      *
436      * @jls 9.1.1 Interface Modifiers
437      * @since 1.7
438      */
439     public static int interfaceModifiers() {
440         return INTERFACE_MODIFIERS;
441     }
442 
443     /**
444      * Return an {@code int} value OR-ing together the source language
445      * modifiers that can be applied to a constructor.
446      * @return an {@code int} value OR-ing together the source language
447      * modifiers that can be applied to a constructor.
448      *
449      * @jls 8.8.3 Constructor Modifiers
450      * @since 1.7
451      */
452     public static int constructorModifiers() {
453         return CONSTRUCTOR_MODIFIERS;
454     }
455 
456     /**
457      * Return an {@code int} value OR-ing together the source language
458      * modifiers that can be applied to a method.
459      * @return an {@code int} value OR-ing together the source language
460      * modifiers that can be applied to a method.
461      *
462      * @jls 8.4.3 Method Modifiers
463      * @since 1.7
464      */
465     public static int methodModifiers() {
466         return METHOD_MODIFIERS;
467     }
468 
469     /**
470      * Return an {@code int} value OR-ing together the source language
471      * modifiers that can be applied to a field.
472      * @return an {@code int} value OR-ing together the source language
473      * modifiers that can be applied to a field.
474      *
475      * @jls 8.3.1 Field Modifiers
476      * @since 1.7
477      */
478     public static int fieldModifiers() {
479         return FIELD_MODIFIERS;
480     }
481 
482     /**
483      * Return an {@code int} value OR-ing together the source language
484      * modifiers that can be applied to a parameter.
485      * @return an {@code int} value OR-ing together the source language
486      * modifiers that can be applied to a parameter.
487      *
488      * @jls 8.4.1 Formal Parameters
489      * @since 1.8
490      */
491     public static int parameterModifiers() {
492         return PARAMETER_MODIFIERS;
493     }
494 }
    </pre>
  </body>
</html>
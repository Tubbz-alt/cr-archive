<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/time/Instant.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file:
  31  *
  32  * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  33  *
  34  * All rights reserved.
  35  *
  36  * Redistribution and use in source and binary forms, with or without
  37  * modification, are permitted provided that the following conditions are met:
  38  *
  39  *  * Redistributions of source code must retain the above copyright notice,
  40  *    this list of conditions and the following disclaimer.
  41  *
  42  *  * Redistributions in binary form must reproduce the above copyright notice,
  43  *    this list of conditions and the following disclaimer in the documentation
  44  *    and/or other materials provided with the distribution.
  45  *
  46  *  * Neither the name of JSR-310 nor the names of its contributors
  47  *    may be used to endorse or promote products derived from this software
  48  *    without specific prior written permission.
  49  *
  50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  61  */
  62 package java.time;
  63 
  64 import static java.time.LocalTime.NANOS_PER_SECOND;
  65 import static java.time.LocalTime.SECONDS_PER_DAY;
  66 import static java.time.LocalTime.SECONDS_PER_HOUR;
  67 import static java.time.LocalTime.SECONDS_PER_MINUTE;
  68 import static java.time.temporal.ChronoField.INSTANT_SECONDS;
  69 import static java.time.temporal.ChronoField.MICRO_OF_SECOND;
  70 import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
  71 import static java.time.temporal.ChronoField.NANO_OF_SECOND;
  72 import static java.time.temporal.ChronoUnit.DAYS;
  73 import static java.time.temporal.ChronoUnit.NANOS;
  74 
  75 import java.io.DataInput;
  76 import java.io.DataOutput;
  77 import java.io.IOException;
  78 import java.io.InvalidObjectException;
  79 import java.io.ObjectInputStream;
  80 import java.io.Serializable;
  81 import java.time.format.DateTimeFormatter;
  82 import java.time.format.DateTimeParseException;
  83 import java.time.temporal.ChronoField;
  84 import java.time.temporal.ChronoUnit;
  85 import java.time.temporal.Temporal;
  86 import java.time.temporal.TemporalAccessor;
  87 import java.time.temporal.TemporalAdjuster;
  88 import java.time.temporal.TemporalAmount;
  89 import java.time.temporal.TemporalField;
  90 import java.time.temporal.TemporalQueries;
  91 import java.time.temporal.TemporalQuery;
  92 import java.time.temporal.TemporalUnit;
  93 import java.time.temporal.UnsupportedTemporalTypeException;
  94 import java.time.temporal.ValueRange;
  95 import java.util.Objects;
  96 
  97 /**
  98  * An instantaneous point on the time-line.
  99  * &lt;p&gt;
 100  * This class models a single instantaneous point on the time-line.
 101  * This might be used to record event time-stamps in the application.
 102  * &lt;p&gt;
 103  * The range of an instant requires the storage of a number larger than a {@code long}.
 104  * To achieve this, the class stores a {@code long} representing epoch-seconds and an
 105  * {@code int} representing nanosecond-of-second, which will always be between 0 and 999,999,999.
 106  * The epoch-seconds are measured from the standard Java epoch of {@code 1970-01-01T00:00:00Z}
 107  * where instants after the epoch have positive values, and earlier instants have negative values.
 108  * For both the epoch-second and nanosecond parts, a larger value is always later on the time-line
 109  * than a smaller value.
 110  *
<a name="2" id="anc2"></a><span class="line-modified"> 111  * &lt;h3&gt;Time-scale&lt;/h3&gt;</span>
 112  * &lt;p&gt;
 113  * The length of the solar day is the standard way that humans measure time.
 114  * This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,
 115  * forming a 86400 second day.
 116  * &lt;p&gt;
 117  * Modern timekeeping is based on atomic clocks which precisely define an SI second
 118  * relative to the transitions of a Caesium atom. The length of an SI second was defined
 119  * to be very close to the 86400th fraction of a day.
 120  * &lt;p&gt;
 121  * Unfortunately, as the Earth rotates the length of the day varies.
 122  * In addition, over time the average length of the day is getting longer as the Earth slows.
 123  * As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.
 124  * The actual length of any given day and the amount by which the Earth is slowing
 125  * are not predictable and can only be determined by measurement.
 126  * The UT1 time-scale captures the accurate length of day, but is only available some
 127  * time after the day has completed.
 128  * &lt;p&gt;
 129  * The UTC time-scale is a standard approach to bundle up all the additional fractions
 130  * of a second from UT1 into whole seconds, known as &lt;i&gt;leap-seconds&lt;/i&gt;.
 131  * A leap-second may be added or removed depending on the Earth&#39;s rotational changes.
 132  * As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where
 133  * necessary in order to keep the day aligned with the Sun.
 134  * &lt;p&gt;
 135  * The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.
 136  * Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and
 137  * alterations to the length of the notional second. As of 2012, discussions are underway
 138  * to change the definition of UTC again, with the potential to remove leap seconds or
 139  * introduce other changes.
 140  * &lt;p&gt;
 141  * Given the complexity of accurate timekeeping described above, this Java API defines
 142  * its own time-scale, the &lt;i&gt;Java Time-Scale&lt;/i&gt;.
 143  * &lt;p&gt;
 144  * The Java Time-Scale divides each calendar day into exactly 86400
 145  * subdivisions, known as seconds.  These seconds may differ from the
 146  * SI second.  It closely matches the de facto international civil time
 147  * scale, the definition of which changes from time to time.
 148  * &lt;p&gt;
 149  * The Java Time-Scale has slightly different definitions for different
 150  * segments of the time-line, each based on the consensus international
 151  * time scale that is used as the basis for civil time. Whenever the
 152  * internationally-agreed time scale is modified or replaced, a new
 153  * segment of the Java Time-Scale must be defined for it.  Each segment
 154  * must meet these requirements:
 155  * &lt;ul&gt;
 156  * &lt;li&gt;the Java Time-Scale shall closely match the underlying international
 157  *  civil time scale;&lt;/li&gt;
 158  * &lt;li&gt;the Java Time-Scale shall exactly match the international civil
 159  *  time scale at noon each day;&lt;/li&gt;
 160  * &lt;li&gt;the Java Time-Scale shall have a precisely-defined relationship to
 161  *  the international civil time scale.&lt;/li&gt;
 162  * &lt;/ul&gt;
 163  * There are currently, as of 2013, two segments in the Java time-scale.
 164  * &lt;p&gt;
 165  * For the segment from 1972-11-03 (exact boundary discussed below) until
 166  * further notice, the consensus international time scale is UTC (with
 167  * leap seconds).  In this segment, the Java Time-Scale is identical to
 168  * &lt;a href=&quot;http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/&quot;&gt;UTC-SLS&lt;/a&gt;.
 169  * This is identical to UTC on days that do not have a leap second.
 170  * On days that do have a leap second, the leap second is spread equally
 171  * over the last 1000 seconds of the day, maintaining the appearance of
 172  * exactly 86400 seconds per day.
 173  * &lt;p&gt;
 174  * For the segment prior to 1972-11-03, extending back arbitrarily far,
 175  * the consensus international time scale is defined to be UT1, applied
 176  * proleptically, which is equivalent to the (mean) solar time on the
 177  * prime meridian (Greenwich). In this segment, the Java Time-Scale is
 178  * identical to the consensus international time scale. The exact
 179  * boundary between the two segments is the instant where UT1 = UTC
 180  * between 1972-11-03T00:00 and 1972-11-04T12:00.
 181  * &lt;p&gt;
 182  * Implementations of the Java time-scale using the JSR-310 API are not
 183  * required to provide any clock that is sub-second accurate, or that
 184  * progresses monotonically or smoothly. Implementations are therefore
 185  * not required to actually perform the UTC-SLS slew or to otherwise be
 186  * aware of leap seconds. JSR-310 does, however, require that
 187  * implementations must document the approach they use when defining a
 188  * clock representing the current instant.
 189  * See {@link Clock} for details on the available clocks.
 190  * &lt;p&gt;
 191  * The Java time-scale is used for all date-time classes.
 192  * This includes {@code Instant}, {@code LocalDate}, {@code LocalTime}, {@code OffsetDateTime},
 193  * {@code ZonedDateTime} and {@code Duration}.
 194  *
 195  * &lt;p&gt;
 196  * This is a &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
 197  * class; use of identity-sensitive operations (including reference equality
 198  * ({@code ==}), identity hash code, or synchronization) on instances of
 199  * {@code Instant} may have unpredictable results and should be avoided.
 200  * The {@code equals} method should be used for comparisons.
 201  *
 202  * @implSpec
 203  * This class is immutable and thread-safe.
 204  *
 205  * @since 1.8
 206  */
 207 public final class Instant
 208         implements Temporal, TemporalAdjuster, Comparable&lt;Instant&gt;, Serializable {
 209 
 210     /**
 211      * Constant for the 1970-01-01T00:00:00Z epoch instant.
 212      */
 213     public static final Instant EPOCH = new Instant(0, 0);
 214     /**
 215      * The minimum supported epoch second.
 216      */
 217     private static final long MIN_SECOND = -31557014167219200L;
 218     /**
 219      * The maximum supported epoch second.
 220      */
 221     private static final long MAX_SECOND = 31556889864403199L;
 222     /**
 223      * The minimum supported {@code Instant}, &#39;-1000000000-01-01T00:00Z&#39;.
 224      * This could be used by an application as a &quot;far past&quot; instant.
 225      * &lt;p&gt;
 226      * This is one year earlier than the minimum {@code LocalDateTime}.
 227      * This provides sufficient values to handle the range of {@code ZoneOffset}
 228      * which affect the instant in addition to the local date-time.
 229      * The value is also chosen such that the value of the year fits in
 230      * an {@code int}.
 231      */
 232     public static final Instant MIN = Instant.ofEpochSecond(MIN_SECOND, 0);
 233     /**
 234      * The maximum supported {@code Instant}, &#39;1000000000-12-31T23:59:59.999999999Z&#39;.
 235      * This could be used by an application as a &quot;far future&quot; instant.
 236      * &lt;p&gt;
 237      * This is one year later than the maximum {@code LocalDateTime}.
 238      * This provides sufficient values to handle the range of {@code ZoneOffset}
 239      * which affect the instant in addition to the local date-time.
 240      * The value is also chosen such that the value of the year fits in
 241      * an {@code int}.
 242      */
 243     public static final Instant MAX = Instant.ofEpochSecond(MAX_SECOND, 999_999_999);
 244 
 245     /**
 246      * Serialization version.
 247      */
<a name="3" id="anc3"></a>
 248     private static final long serialVersionUID = -665713676816604388L;
 249 
 250     /**
 251      * The number of seconds from the epoch of 1970-01-01T00:00:00Z.
 252      */
 253     private final long seconds;
 254     /**
 255      * The number of nanoseconds, later along the time-line, from the seconds field.
 256      * This is always positive, and never exceeds 999,999,999.
 257      */
 258     private final int nanos;
 259 
 260     //-----------------------------------------------------------------------
 261     /**
 262      * Obtains the current instant from the system clock.
 263      * &lt;p&gt;
 264      * This will query the {@link Clock#systemUTC() system UTC clock} to
 265      * obtain the current instant.
 266      * &lt;p&gt;
 267      * Using this method will prevent the ability to use an alternate time-source for
 268      * testing because the clock is effectively hard-coded.
 269      *
 270      * @return the current instant using the system clock, not null
 271      */
 272     public static Instant now() {
 273         return Clock.systemUTC().instant();
 274     }
 275 
 276     /**
 277      * Obtains the current instant from the specified clock.
 278      * &lt;p&gt;
 279      * This will query the specified clock to obtain the current time.
 280      * &lt;p&gt;
 281      * Using this method allows the use of an alternate clock for testing.
 282      * The alternate clock may be introduced using {@link Clock dependency injection}.
 283      *
 284      * @param clock  the clock to use, not null
 285      * @return the current instant, not null
 286      */
 287     public static Instant now(Clock clock) {
 288         Objects.requireNonNull(clock, &quot;clock&quot;);
 289         return clock.instant();
 290     }
 291 
 292     //-----------------------------------------------------------------------
 293     /**
 294      * Obtains an instance of {@code Instant} using seconds from the
 295      * epoch of 1970-01-01T00:00:00Z.
 296      * &lt;p&gt;
 297      * The nanosecond field is set to zero.
 298      *
 299      * @param epochSecond  the number of seconds from 1970-01-01T00:00:00Z
 300      * @return an instant, not null
 301      * @throws DateTimeException if the instant exceeds the maximum or minimum instant
 302      */
 303     public static Instant ofEpochSecond(long epochSecond) {
 304         return create(epochSecond, 0);
 305     }
 306 
 307     /**
 308      * Obtains an instance of {@code Instant} using seconds from the
 309      * epoch of 1970-01-01T00:00:00Z and nanosecond fraction of second.
 310      * &lt;p&gt;
 311      * This method allows an arbitrary number of nanoseconds to be passed in.
 312      * The factory will alter the values of the second and nanosecond in order
 313      * to ensure that the stored nanosecond is in the range 0 to 999,999,999.
 314      * For example, the following will result in exactly the same instant:
 315      * &lt;pre&gt;
 316      *  Instant.ofEpochSecond(3, 1);
 317      *  Instant.ofEpochSecond(4, -999_999_999);
 318      *  Instant.ofEpochSecond(2, 1000_000_001);
 319      * &lt;/pre&gt;
 320      *
 321      * @param epochSecond  the number of seconds from 1970-01-01T00:00:00Z
 322      * @param nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative
 323      * @return an instant, not null
 324      * @throws DateTimeException if the instant exceeds the maximum or minimum instant
 325      * @throws ArithmeticException if numeric overflow occurs
 326      */
 327     public static Instant ofEpochSecond(long epochSecond, long nanoAdjustment) {
 328         long secs = Math.addExact(epochSecond, Math.floorDiv(nanoAdjustment, NANOS_PER_SECOND));
 329         int nos = (int)Math.floorMod(nanoAdjustment, NANOS_PER_SECOND);
 330         return create(secs, nos);
 331     }
 332 
 333     /**
 334      * Obtains an instance of {@code Instant} using milliseconds from the
 335      * epoch of 1970-01-01T00:00:00Z.
 336      * &lt;p&gt;
 337      * The seconds and nanoseconds are extracted from the specified milliseconds.
 338      *
 339      * @param epochMilli  the number of milliseconds from 1970-01-01T00:00:00Z
 340      * @return an instant, not null
 341      * @throws DateTimeException if the instant exceeds the maximum or minimum instant
 342      */
 343     public static Instant ofEpochMilli(long epochMilli) {
 344         long secs = Math.floorDiv(epochMilli, 1000);
 345         int mos = Math.floorMod(epochMilli, 1000);
 346         return create(secs, mos * 1000_000);
 347     }
 348 
 349     //-----------------------------------------------------------------------
 350     /**
 351      * Obtains an instance of {@code Instant} from a temporal object.
 352      * &lt;p&gt;
 353      * This obtains an instant based on the specified temporal.
 354      * A {@code TemporalAccessor} represents an arbitrary set of date and time information,
 355      * which this factory converts to an instance of {@code Instant}.
 356      * &lt;p&gt;
 357      * The conversion extracts the {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}
 358      * and {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} fields.
 359      * &lt;p&gt;
 360      * This method matches the signature of the functional interface {@link TemporalQuery}
 361      * allowing it to be used as a query via method reference, {@code Instant::from}.
 362      *
 363      * @param temporal  the temporal object to convert, not null
 364      * @return the instant, not null
 365      * @throws DateTimeException if unable to convert to an {@code Instant}
 366      */
 367     public static Instant from(TemporalAccessor temporal) {
 368         if (temporal instanceof Instant) {
 369             return (Instant) temporal;
 370         }
 371         Objects.requireNonNull(temporal, &quot;temporal&quot;);
 372         try {
 373             long instantSecs = temporal.getLong(INSTANT_SECONDS);
 374             int nanoOfSecond = temporal.get(NANO_OF_SECOND);
 375             return Instant.ofEpochSecond(instantSecs, nanoOfSecond);
 376         } catch (DateTimeException ex) {
 377             throw new DateTimeException(&quot;Unable to obtain Instant from TemporalAccessor: &quot; +
 378                     temporal + &quot; of type &quot; + temporal.getClass().getName(), ex);
 379         }
 380     }
 381 
 382     //-----------------------------------------------------------------------
 383     /**
 384      * Obtains an instance of {@code Instant} from a text string such as
 385      * {@code 2007-12-03T10:15:30.00Z}.
 386      * &lt;p&gt;
 387      * The string must represent a valid instant in UTC and is parsed using
 388      * {@link DateTimeFormatter#ISO_INSTANT}.
 389      *
 390      * @param text  the text to parse, not null
 391      * @return the parsed instant, not null
 392      * @throws DateTimeParseException if the text cannot be parsed
 393      */
 394     public static Instant parse(final CharSequence text) {
 395         return DateTimeFormatter.ISO_INSTANT.parse(text, Instant::from);
 396     }
 397 
 398     //-----------------------------------------------------------------------
 399     /**
 400      * Obtains an instance of {@code Instant} using seconds and nanoseconds.
 401      *
 402      * @param seconds  the length of the duration in seconds
 403      * @param nanoOfSecond  the nano-of-second, from 0 to 999,999,999
 404      * @throws DateTimeException if the instant exceeds the maximum or minimum instant
 405      */
 406     private static Instant create(long seconds, int nanoOfSecond) {
 407         if ((seconds | nanoOfSecond) == 0) {
 408             return EPOCH;
 409         }
 410         if (seconds &lt; MIN_SECOND || seconds &gt; MAX_SECOND) {
 411             throw new DateTimeException(&quot;Instant exceeds minimum or maximum instant&quot;);
 412         }
 413         return new Instant(seconds, nanoOfSecond);
 414     }
 415 
 416     /**
 417      * Constructs an instance of {@code Instant} using seconds from the epoch of
 418      * 1970-01-01T00:00:00Z and nanosecond fraction of second.
 419      *
 420      * @param epochSecond  the number of seconds from 1970-01-01T00:00:00Z
 421      * @param nanos  the nanoseconds within the second, must be positive
 422      */
 423     private Instant(long epochSecond, int nanos) {
 424         super();
 425         this.seconds = epochSecond;
 426         this.nanos = nanos;
 427     }
 428 
 429     //-----------------------------------------------------------------------
 430     /**
 431      * Checks if the specified field is supported.
 432      * &lt;p&gt;
 433      * This checks if this instant can be queried for the specified field.
 434      * If false, then calling the {@link #range(TemporalField) range},
 435      * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
 436      * methods will throw an exception.
 437      * &lt;p&gt;
 438      * If the field is a {@link ChronoField} then the query is implemented here.
 439      * The supported fields are:
 440      * &lt;ul&gt;
 441      * &lt;li&gt;{@code NANO_OF_SECOND}
 442      * &lt;li&gt;{@code MICRO_OF_SECOND}
 443      * &lt;li&gt;{@code MILLI_OF_SECOND}
 444      * &lt;li&gt;{@code INSTANT_SECONDS}
 445      * &lt;/ul&gt;
 446      * All other {@code ChronoField} instances will return false.
 447      * &lt;p&gt;
 448      * If the field is not a {@code ChronoField}, then the result of this method
 449      * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
 450      * passing {@code this} as the argument.
 451      * Whether the field is supported is determined by the field.
 452      *
 453      * @param field  the field to check, null returns false
 454      * @return true if the field is supported on this instant, false if not
 455      */
 456     @Override
 457     public boolean isSupported(TemporalField field) {
 458         if (field instanceof ChronoField) {
 459             return field == INSTANT_SECONDS || field == NANO_OF_SECOND || field == MICRO_OF_SECOND || field == MILLI_OF_SECOND;
 460         }
 461         return field != null &amp;&amp; field.isSupportedBy(this);
 462     }
 463 
 464     /**
 465      * Checks if the specified unit is supported.
 466      * &lt;p&gt;
 467      * This checks if the specified unit can be added to, or subtracted from, this date-time.
 468      * If false, then calling the {@link #plus(long, TemporalUnit)} and
 469      * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
 470      * &lt;p&gt;
 471      * If the unit is a {@link ChronoUnit} then the query is implemented here.
 472      * The supported units are:
 473      * &lt;ul&gt;
 474      * &lt;li&gt;{@code NANOS}
 475      * &lt;li&gt;{@code MICROS}
 476      * &lt;li&gt;{@code MILLIS}
 477      * &lt;li&gt;{@code SECONDS}
 478      * &lt;li&gt;{@code MINUTES}
 479      * &lt;li&gt;{@code HOURS}
 480      * &lt;li&gt;{@code HALF_DAYS}
 481      * &lt;li&gt;{@code DAYS}
 482      * &lt;/ul&gt;
 483      * All other {@code ChronoUnit} instances will return false.
 484      * &lt;p&gt;
 485      * If the unit is not a {@code ChronoUnit}, then the result of this method
 486      * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}
 487      * passing {@code this} as the argument.
 488      * Whether the unit is supported is determined by the unit.
 489      *
 490      * @param unit  the unit to check, null returns false
 491      * @return true if the unit can be added/subtracted, false if not
 492      */
 493     @Override
 494     public boolean isSupported(TemporalUnit unit) {
 495         if (unit instanceof ChronoUnit) {
 496             return unit.isTimeBased() || unit == DAYS;
 497         }
 498         return unit != null &amp;&amp; unit.isSupportedBy(this);
 499     }
 500 
 501     //-----------------------------------------------------------------------
 502     /**
 503      * Gets the range of valid values for the specified field.
 504      * &lt;p&gt;
 505      * The range object expresses the minimum and maximum valid values for a field.
 506      * This instant is used to enhance the accuracy of the returned range.
 507      * If it is not possible to return the range, because the field is not supported
 508      * or for some other reason, an exception is thrown.
 509      * &lt;p&gt;
 510      * If the field is a {@link ChronoField} then the query is implemented here.
 511      * The {@link #isSupported(TemporalField) supported fields} will return
 512      * appropriate range instances.
 513      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 514      * &lt;p&gt;
 515      * If the field is not a {@code ChronoField}, then the result of this method
 516      * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
 517      * passing {@code this} as the argument.
 518      * Whether the range can be obtained is determined by the field.
 519      *
 520      * @param field  the field to query the range for, not null
 521      * @return the range of valid values for the field, not null
 522      * @throws DateTimeException if the range for the field cannot be obtained
 523      * @throws UnsupportedTemporalTypeException if the field is not supported
 524      */
 525     @Override  // override for Javadoc
 526     public ValueRange range(TemporalField field) {
 527         return Temporal.super.range(field);
 528     }
 529 
 530     /**
 531      * Gets the value of the specified field from this instant as an {@code int}.
 532      * &lt;p&gt;
 533      * This queries this instant for the value of the specified field.
 534      * The returned value will always be within the valid range of values for the field.
 535      * If it is not possible to return the value, because the field is not supported
 536      * or for some other reason, an exception is thrown.
 537      * &lt;p&gt;
 538      * If the field is a {@link ChronoField} then the query is implemented here.
 539      * The {@link #isSupported(TemporalField) supported fields} will return valid
 540      * values based on this date-time, except {@code INSTANT_SECONDS} which is too
 541      * large to fit in an {@code int} and throws a {@code DateTimeException}.
 542      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 543      * &lt;p&gt;
 544      * If the field is not a {@code ChronoField}, then the result of this method
 545      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
 546      * passing {@code this} as the argument. Whether the value can be obtained,
 547      * and what the value represents, is determined by the field.
 548      *
 549      * @param field  the field to get, not null
 550      * @return the value for the field
 551      * @throws DateTimeException if a value for the field cannot be obtained or
 552      *         the value is outside the range of valid values for the field
 553      * @throws UnsupportedTemporalTypeException if the field is not supported or
 554      *         the range of values exceeds an {@code int}
 555      * @throws ArithmeticException if numeric overflow occurs
 556      */
 557     @Override  // override for Javadoc and performance
 558     public int get(TemporalField field) {
 559         if (field instanceof ChronoField) {
 560             switch ((ChronoField) field) {
 561                 case NANO_OF_SECOND: return nanos;
 562                 case MICRO_OF_SECOND: return nanos / 1000;
 563                 case MILLI_OF_SECOND: return nanos / 1000_000;
 564             }
 565             throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);
 566         }
 567         return range(field).checkValidIntValue(field.getFrom(this), field);
 568     }
 569 
 570     /**
 571      * Gets the value of the specified field from this instant as a {@code long}.
 572      * &lt;p&gt;
 573      * This queries this instant for the value of the specified field.
 574      * If it is not possible to return the value, because the field is not supported
 575      * or for some other reason, an exception is thrown.
 576      * &lt;p&gt;
 577      * If the field is a {@link ChronoField} then the query is implemented here.
 578      * The {@link #isSupported(TemporalField) supported fields} will return valid
 579      * values based on this date-time.
 580      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 581      * &lt;p&gt;
 582      * If the field is not a {@code ChronoField}, then the result of this method
 583      * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
 584      * passing {@code this} as the argument. Whether the value can be obtained,
 585      * and what the value represents, is determined by the field.
 586      *
 587      * @param field  the field to get, not null
 588      * @return the value for the field
 589      * @throws DateTimeException if a value for the field cannot be obtained
 590      * @throws UnsupportedTemporalTypeException if the field is not supported
 591      * @throws ArithmeticException if numeric overflow occurs
 592      */
 593     @Override
 594     public long getLong(TemporalField field) {
 595         if (field instanceof ChronoField) {
 596             switch ((ChronoField) field) {
 597                 case NANO_OF_SECOND: return nanos;
 598                 case MICRO_OF_SECOND: return nanos / 1000;
 599                 case MILLI_OF_SECOND: return nanos / 1000_000;
 600                 case INSTANT_SECONDS: return seconds;
 601             }
 602             throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);
 603         }
 604         return field.getFrom(this);
 605     }
 606 
 607     //-----------------------------------------------------------------------
 608     /**
 609      * Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.
 610      * &lt;p&gt;
 611      * The epoch second count is a simple incrementing count of seconds where
 612      * second 0 is 1970-01-01T00:00:00Z.
 613      * The nanosecond part is returned by {@link #getNano}.
 614      *
 615      * @return the seconds from the epoch of 1970-01-01T00:00:00Z
 616      */
 617     public long getEpochSecond() {
 618         return seconds;
 619     }
 620 
 621     /**
 622      * Gets the number of nanoseconds, later along the time-line, from the start
 623      * of the second.
 624      * &lt;p&gt;
 625      * The nanosecond-of-second value measures the total number of nanoseconds from
 626      * the second returned by {@link #getEpochSecond}.
 627      *
 628      * @return the nanoseconds within the second, always positive, never exceeds 999,999,999
 629      */
 630     public int getNano() {
 631         return nanos;
 632     }
 633 
 634     //-------------------------------------------------------------------------
 635     /**
 636      * Returns an adjusted copy of this instant.
 637      * &lt;p&gt;
 638      * This returns an {@code Instant}, based on this one, with the instant adjusted.
 639      * The adjustment takes place using the specified adjuster strategy object.
 640      * Read the documentation of the adjuster to understand what adjustment will be made.
 641      * &lt;p&gt;
 642      * The result of this method is obtained by invoking the
 643      * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
 644      * specified adjuster passing {@code this} as the argument.
 645      * &lt;p&gt;
 646      * This instance is immutable and unaffected by this method call.
 647      *
 648      * @param adjuster the adjuster to use, not null
 649      * @return an {@code Instant} based on {@code this} with the adjustment made, not null
 650      * @throws DateTimeException if the adjustment cannot be made
 651      * @throws ArithmeticException if numeric overflow occurs
 652      */
 653     @Override
 654     public Instant with(TemporalAdjuster adjuster) {
 655         return (Instant) adjuster.adjustInto(this);
 656     }
 657 
 658     /**
 659      * Returns a copy of this instant with the specified field set to a new value.
 660      * &lt;p&gt;
 661      * This returns an {@code Instant}, based on this one, with the value
 662      * for the specified field changed.
 663      * If it is not possible to set the value, because the field is not supported or for
 664      * some other reason, an exception is thrown.
 665      * &lt;p&gt;
 666      * If the field is a {@link ChronoField} then the adjustment is implemented here.
 667      * The supported fields behave as follows:
 668      * &lt;ul&gt;
 669      * &lt;li&gt;{@code NANO_OF_SECOND} -
 670      *  Returns an {@code Instant} with the specified nano-of-second.
 671      *  The epoch-second will be unchanged.
 672      * &lt;li&gt;{@code MICRO_OF_SECOND} -
 673      *  Returns an {@code Instant} with the nano-of-second replaced by the specified
 674      *  micro-of-second multiplied by 1,000. The epoch-second will be unchanged.
 675      * &lt;li&gt;{@code MILLI_OF_SECOND} -
 676      *  Returns an {@code Instant} with the nano-of-second replaced by the specified
 677      *  milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.
 678      * &lt;li&gt;{@code INSTANT_SECONDS} -
 679      *  Returns an {@code Instant} with the specified epoch-second.
 680      *  The nano-of-second will be unchanged.
 681      * &lt;/ul&gt;
 682      * &lt;p&gt;
 683      * In all cases, if the new value is outside the valid range of values for the field
 684      * then a {@code DateTimeException} will be thrown.
 685      * &lt;p&gt;
 686      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
 687      * &lt;p&gt;
 688      * If the field is not a {@code ChronoField}, then the result of this method
 689      * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}
 690      * passing {@code this} as the argument. In this case, the field determines
 691      * whether and how to adjust the instant.
 692      * &lt;p&gt;
 693      * This instance is immutable and unaffected by this method call.
 694      *
 695      * @param field  the field to set in the result, not null
 696      * @param newValue  the new value of the field in the result
 697      * @return an {@code Instant} based on {@code this} with the specified field set, not null
 698      * @throws DateTimeException if the field cannot be set
 699      * @throws UnsupportedTemporalTypeException if the field is not supported
 700      * @throws ArithmeticException if numeric overflow occurs
 701      */
 702     @Override
 703     public Instant with(TemporalField field, long newValue) {
 704         if (field instanceof ChronoField) {
 705             ChronoField f = (ChronoField) field;
 706             f.checkValidValue(newValue);
 707             switch (f) {
 708                 case MILLI_OF_SECOND: {
 709                     int nval = (int) newValue * 1000_000;
 710                     return (nval != nanos ? create(seconds, nval) : this);
 711                 }
 712                 case MICRO_OF_SECOND: {
 713                     int nval = (int) newValue * 1000;
 714                     return (nval != nanos ? create(seconds, nval) : this);
 715                 }
 716                 case NANO_OF_SECOND: return (newValue != nanos ? create(seconds, (int) newValue) : this);
 717                 case INSTANT_SECONDS: return (newValue != seconds ? create(newValue, nanos) : this);
 718             }
 719             throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);
 720         }
 721         return field.adjustInto(this, newValue);
 722     }
 723 
 724     //-----------------------------------------------------------------------
 725     /**
 726      * Returns a copy of this {@code Instant} truncated to the specified unit.
 727      * &lt;p&gt;
 728      * Truncating the instant returns a copy of the original with fields
 729      * smaller than the specified unit set to zero.
 730      * The fields are calculated on the basis of using a UTC offset as seen
 731      * in {@code toString}.
 732      * For example, truncating with the {@link ChronoUnit#MINUTES MINUTES} unit will
 733      * round down to the nearest minute, setting the seconds and nanoseconds to zero.
 734      * &lt;p&gt;
 735      * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
 736      * that divides into the length of a standard day without remainder.
 737      * This includes all supplied time units on {@link ChronoUnit} and
 738      * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.
 739      * &lt;p&gt;
 740      * This instance is immutable and unaffected by this method call.
 741      *
 742      * @param unit  the unit to truncate to, not null
 743      * @return an {@code Instant} based on this instant with the time truncated, not null
 744      * @throws DateTimeException if the unit is invalid for truncation
 745      * @throws UnsupportedTemporalTypeException if the unit is not supported
 746      */
 747     public Instant truncatedTo(TemporalUnit unit) {
 748         if (unit == ChronoUnit.NANOS) {
 749             return this;
 750         }
 751         Duration unitDur = unit.getDuration();
 752         if (unitDur.getSeconds() &gt; LocalTime.SECONDS_PER_DAY) {
 753             throw new UnsupportedTemporalTypeException(&quot;Unit is too large to be used for truncation&quot;);
 754         }
 755         long dur = unitDur.toNanos();
 756         if ((LocalTime.NANOS_PER_DAY % dur) != 0) {
 757             throw new UnsupportedTemporalTypeException(&quot;Unit must divide into a standard day without remainder&quot;);
 758         }
 759         long nod = (seconds % LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + nanos;
 760         long result = Math.floorDiv(nod, dur) * dur;
 761         return plusNanos(result - nod);
 762     }
 763 
 764     //-----------------------------------------------------------------------
 765     /**
 766      * Returns a copy of this instant with the specified amount added.
 767      * &lt;p&gt;
 768      * This returns an {@code Instant}, based on this one, with the specified amount added.
 769      * The amount is typically {@link Duration} but may be any other type implementing
 770      * the {@link TemporalAmount} interface.
 771      * &lt;p&gt;
 772      * The calculation is delegated to the amount object by calling
 773      * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
 774      * to implement the addition in any way it wishes, however it typically
 775      * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
 776      * of the amount implementation to determine if it can be successfully added.
 777      * &lt;p&gt;
 778      * This instance is immutable and unaffected by this method call.
 779      *
 780      * @param amountToAdd  the amount to add, not null
 781      * @return an {@code Instant} based on this instant with the addition made, not null
 782      * @throws DateTimeException if the addition cannot be made
 783      * @throws ArithmeticException if numeric overflow occurs
 784      */
 785     @Override
 786     public Instant plus(TemporalAmount amountToAdd) {
 787         return (Instant) amountToAdd.addTo(this);
 788     }
 789 
 790     /**
 791      * Returns a copy of this instant with the specified amount added.
 792      * &lt;p&gt;
 793      * This returns an {@code Instant}, based on this one, with the amount
 794      * in terms of the unit added. If it is not possible to add the amount, because the
 795      * unit is not supported or for some other reason, an exception is thrown.
 796      * &lt;p&gt;
 797      * If the field is a {@link ChronoUnit} then the addition is implemented here.
 798      * The supported fields behave as follows:
 799      * &lt;ul&gt;
 800      * &lt;li&gt;{@code NANOS} -
 801      *  Returns an {@code Instant} with the specified number of nanoseconds added.
 802      *  This is equivalent to {@link #plusNanos(long)}.
 803      * &lt;li&gt;{@code MICROS} -
 804      *  Returns an {@code Instant} with the specified number of microseconds added.
 805      *  This is equivalent to {@link #plusNanos(long)} with the amount
 806      *  multiplied by 1,000.
 807      * &lt;li&gt;{@code MILLIS} -
 808      *  Returns an {@code Instant} with the specified number of milliseconds added.
 809      *  This is equivalent to {@link #plusNanos(long)} with the amount
 810      *  multiplied by 1,000,000.
 811      * &lt;li&gt;{@code SECONDS} -
 812      *  Returns an {@code Instant} with the specified number of seconds added.
 813      *  This is equivalent to {@link #plusSeconds(long)}.
 814      * &lt;li&gt;{@code MINUTES} -
 815      *  Returns an {@code Instant} with the specified number of minutes added.
 816      *  This is equivalent to {@link #plusSeconds(long)} with the amount
 817      *  multiplied by 60.
 818      * &lt;li&gt;{@code HOURS} -
 819      *  Returns an {@code Instant} with the specified number of hours added.
 820      *  This is equivalent to {@link #plusSeconds(long)} with the amount
 821      *  multiplied by 3,600.
 822      * &lt;li&gt;{@code HALF_DAYS} -
 823      *  Returns an {@code Instant} with the specified number of half-days added.
 824      *  This is equivalent to {@link #plusSeconds(long)} with the amount
 825      *  multiplied by 43,200 (12 hours).
 826      * &lt;li&gt;{@code DAYS} -
 827      *  Returns an {@code Instant} with the specified number of days added.
 828      *  This is equivalent to {@link #plusSeconds(long)} with the amount
 829      *  multiplied by 86,400 (24 hours).
 830      * &lt;/ul&gt;
 831      * &lt;p&gt;
 832      * All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.
 833      * &lt;p&gt;
 834      * If the field is not a {@code ChronoUnit}, then the result of this method
 835      * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}
 836      * passing {@code this} as the argument. In this case, the unit determines
 837      * whether and how to perform the addition.
 838      * &lt;p&gt;
 839      * This instance is immutable and unaffected by this method call.
 840      *
 841      * @param amountToAdd  the amount of the unit to add to the result, may be negative
 842      * @param unit  the unit of the amount to add, not null
 843      * @return an {@code Instant} based on this instant with the specified amount added, not null
 844      * @throws DateTimeException if the addition cannot be made
 845      * @throws UnsupportedTemporalTypeException if the unit is not supported
 846      * @throws ArithmeticException if numeric overflow occurs
 847      */
 848     @Override
 849     public Instant plus(long amountToAdd, TemporalUnit unit) {
 850         if (unit instanceof ChronoUnit) {
 851             switch ((ChronoUnit) unit) {
 852                 case NANOS: return plusNanos(amountToAdd);
 853                 case MICROS: return plus(amountToAdd / 1000_000, (amountToAdd % 1000_000) * 1000);
 854                 case MILLIS: return plusMillis(amountToAdd);
 855                 case SECONDS: return plusSeconds(amountToAdd);
 856                 case MINUTES: return plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_MINUTE));
 857                 case HOURS: return plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_HOUR));
 858                 case HALF_DAYS: return plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY / 2));
 859                 case DAYS: return plusSeconds(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY));
 860             }
 861             throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);
 862         }
 863         return unit.addTo(this, amountToAdd);
 864     }
 865 
 866     //-----------------------------------------------------------------------
 867     /**
 868      * Returns a copy of this instant with the specified duration in seconds added.
 869      * &lt;p&gt;
 870      * This instance is immutable and unaffected by this method call.
 871      *
 872      * @param secondsToAdd  the seconds to add, positive or negative
 873      * @return an {@code Instant} based on this instant with the specified seconds added, not null
 874      * @throws DateTimeException if the result exceeds the maximum or minimum instant
 875      * @throws ArithmeticException if numeric overflow occurs
 876      */
 877     public Instant plusSeconds(long secondsToAdd) {
 878         return plus(secondsToAdd, 0);
 879     }
 880 
 881     /**
 882      * Returns a copy of this instant with the specified duration in milliseconds added.
 883      * &lt;p&gt;
 884      * This instance is immutable and unaffected by this method call.
 885      *
 886      * @param millisToAdd  the milliseconds to add, positive or negative
 887      * @return an {@code Instant} based on this instant with the specified milliseconds added, not null
 888      * @throws DateTimeException if the result exceeds the maximum or minimum instant
 889      * @throws ArithmeticException if numeric overflow occurs
 890      */
 891     public Instant plusMillis(long millisToAdd) {
 892         return plus(millisToAdd / 1000, (millisToAdd % 1000) * 1000_000);
 893     }
 894 
 895     /**
 896      * Returns a copy of this instant with the specified duration in nanoseconds added.
 897      * &lt;p&gt;
 898      * This instance is immutable and unaffected by this method call.
 899      *
 900      * @param nanosToAdd  the nanoseconds to add, positive or negative
 901      * @return an {@code Instant} based on this instant with the specified nanoseconds added, not null
 902      * @throws DateTimeException if the result exceeds the maximum or minimum instant
 903      * @throws ArithmeticException if numeric overflow occurs
 904      */
 905     public Instant plusNanos(long nanosToAdd) {
 906         return plus(0, nanosToAdd);
 907     }
 908 
 909     /**
 910      * Returns a copy of this instant with the specified duration added.
 911      * &lt;p&gt;
 912      * This instance is immutable and unaffected by this method call.
 913      *
 914      * @param secondsToAdd  the seconds to add, positive or negative
 915      * @param nanosToAdd  the nanos to add, positive or negative
 916      * @return an {@code Instant} based on this instant with the specified seconds added, not null
 917      * @throws DateTimeException if the result exceeds the maximum or minimum instant
 918      * @throws ArithmeticException if numeric overflow occurs
 919      */
 920     private Instant plus(long secondsToAdd, long nanosToAdd) {
 921         if ((secondsToAdd | nanosToAdd) == 0) {
 922             return this;
 923         }
 924         long epochSec = Math.addExact(seconds, secondsToAdd);
 925         epochSec = Math.addExact(epochSec, nanosToAdd / NANOS_PER_SECOND);
 926         nanosToAdd = nanosToAdd % NANOS_PER_SECOND;
 927         long nanoAdjustment = nanos + nanosToAdd;  // safe int+NANOS_PER_SECOND
 928         return ofEpochSecond(epochSec, nanoAdjustment);
 929     }
 930 
 931     //-----------------------------------------------------------------------
 932     /**
 933      * Returns a copy of this instant with the specified amount subtracted.
 934      * &lt;p&gt;
 935      * This returns an {@code Instant}, based on this one, with the specified amount subtracted.
 936      * The amount is typically {@link Duration} but may be any other type implementing
 937      * the {@link TemporalAmount} interface.
 938      * &lt;p&gt;
 939      * The calculation is delegated to the amount object by calling
 940      * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
 941      * to implement the subtraction in any way it wishes, however it typically
 942      * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
 943      * of the amount implementation to determine if it can be successfully subtracted.
 944      * &lt;p&gt;
 945      * This instance is immutable and unaffected by this method call.
 946      *
 947      * @param amountToSubtract  the amount to subtract, not null
 948      * @return an {@code Instant} based on this instant with the subtraction made, not null
 949      * @throws DateTimeException if the subtraction cannot be made
 950      * @throws ArithmeticException if numeric overflow occurs
 951      */
 952     @Override
 953     public Instant minus(TemporalAmount amountToSubtract) {
 954         return (Instant) amountToSubtract.subtractFrom(this);
 955     }
 956 
 957     /**
 958      * Returns a copy of this instant with the specified amount subtracted.
 959      * &lt;p&gt;
 960      * This returns an {@code Instant}, based on this one, with the amount
 961      * in terms of the unit subtracted. If it is not possible to subtract the amount,
 962      * because the unit is not supported or for some other reason, an exception is thrown.
 963      * &lt;p&gt;
 964      * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
 965      * See that method for a full description of how addition, and thus subtraction, works.
 966      * &lt;p&gt;
 967      * This instance is immutable and unaffected by this method call.
 968      *
 969      * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
 970      * @param unit  the unit of the amount to subtract, not null
 971      * @return an {@code Instant} based on this instant with the specified amount subtracted, not null
 972      * @throws DateTimeException if the subtraction cannot be made
 973      * @throws UnsupportedTemporalTypeException if the unit is not supported
 974      * @throws ArithmeticException if numeric overflow occurs
 975      */
 976     @Override
 977     public Instant minus(long amountToSubtract, TemporalUnit unit) {
 978         return (amountToSubtract == Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));
 979     }
 980 
 981     //-----------------------------------------------------------------------
 982     /**
 983      * Returns a copy of this instant with the specified duration in seconds subtracted.
 984      * &lt;p&gt;
 985      * This instance is immutable and unaffected by this method call.
 986      *
 987      * @param secondsToSubtract  the seconds to subtract, positive or negative
 988      * @return an {@code Instant} based on this instant with the specified seconds subtracted, not null
 989      * @throws DateTimeException if the result exceeds the maximum or minimum instant
 990      * @throws ArithmeticException if numeric overflow occurs
 991      */
 992     public Instant minusSeconds(long secondsToSubtract) {
 993         if (secondsToSubtract == Long.MIN_VALUE) {
 994             return plusSeconds(Long.MAX_VALUE).plusSeconds(1);
 995         }
 996         return plusSeconds(-secondsToSubtract);
 997     }
 998 
 999     /**
1000      * Returns a copy of this instant with the specified duration in milliseconds subtracted.
1001      * &lt;p&gt;
1002      * This instance is immutable and unaffected by this method call.
1003      *
1004      * @param millisToSubtract  the milliseconds to subtract, positive or negative
1005      * @return an {@code Instant} based on this instant with the specified milliseconds subtracted, not null
1006      * @throws DateTimeException if the result exceeds the maximum or minimum instant
1007      * @throws ArithmeticException if numeric overflow occurs
1008      */
1009     public Instant minusMillis(long millisToSubtract) {
1010         if (millisToSubtract == Long.MIN_VALUE) {
1011             return plusMillis(Long.MAX_VALUE).plusMillis(1);
1012         }
1013         return plusMillis(-millisToSubtract);
1014     }
1015 
1016     /**
1017      * Returns a copy of this instant with the specified duration in nanoseconds subtracted.
1018      * &lt;p&gt;
1019      * This instance is immutable and unaffected by this method call.
1020      *
1021      * @param nanosToSubtract  the nanoseconds to subtract, positive or negative
1022      * @return an {@code Instant} based on this instant with the specified nanoseconds subtracted, not null
1023      * @throws DateTimeException if the result exceeds the maximum or minimum instant
1024      * @throws ArithmeticException if numeric overflow occurs
1025      */
1026     public Instant minusNanos(long nanosToSubtract) {
1027         if (nanosToSubtract == Long.MIN_VALUE) {
1028             return plusNanos(Long.MAX_VALUE).plusNanos(1);
1029         }
1030         return plusNanos(-nanosToSubtract);
1031     }
1032 
1033     //-------------------------------------------------------------------------
1034     /**
1035      * Queries this instant using the specified query.
1036      * &lt;p&gt;
1037      * This queries this instant using the specified query strategy object.
1038      * The {@code TemporalQuery} object defines the logic to be used to
1039      * obtain the result. Read the documentation of the query to understand
1040      * what the result of this method will be.
1041      * &lt;p&gt;
1042      * The result of this method is obtained by invoking the
1043      * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
1044      * specified query passing {@code this} as the argument.
1045      *
1046      * @param &lt;R&gt; the type of the result
1047      * @param query  the query to invoke, not null
1048      * @return the query result, null may be returned (defined by the query)
1049      * @throws DateTimeException if unable to query (defined by the query)
1050      * @throws ArithmeticException if numeric overflow occurs (defined by the query)
1051      */
1052     @SuppressWarnings(&quot;unchecked&quot;)
1053     @Override
1054     public &lt;R&gt; R query(TemporalQuery&lt;R&gt; query) {
1055         if (query == TemporalQueries.precision()) {
1056             return (R) NANOS;
1057         }
1058         // inline TemporalAccessor.super.query(query) as an optimization
1059         if (query == TemporalQueries.chronology() || query == TemporalQueries.zoneId() ||
1060                 query == TemporalQueries.zone() || query == TemporalQueries.offset() ||
1061                 query == TemporalQueries.localDate() || query == TemporalQueries.localTime()) {
1062             return null;
1063         }
1064         return query.queryFrom(this);
1065     }
1066 
1067     /**
1068      * Adjusts the specified temporal object to have this instant.
1069      * &lt;p&gt;
1070      * This returns a temporal object of the same observable type as the input
1071      * with the instant changed to be the same as this.
1072      * &lt;p&gt;
1073      * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
1074      * twice, passing {@link ChronoField#INSTANT_SECONDS} and
1075      * {@link ChronoField#NANO_OF_SECOND} as the fields.
1076      * &lt;p&gt;
1077      * In most cases, it is clearer to reverse the calling pattern by using
1078      * {@link Temporal#with(TemporalAdjuster)}:
1079      * &lt;pre&gt;
1080      *   // these two lines are equivalent, but the second approach is recommended
1081      *   temporal = thisInstant.adjustInto(temporal);
1082      *   temporal = temporal.with(thisInstant);
1083      * &lt;/pre&gt;
1084      * &lt;p&gt;
1085      * This instance is immutable and unaffected by this method call.
1086      *
1087      * @param temporal  the target object to be adjusted, not null
1088      * @return the adjusted object, not null
1089      * @throws DateTimeException if unable to make the adjustment
1090      * @throws ArithmeticException if numeric overflow occurs
1091      */
1092     @Override
1093     public Temporal adjustInto(Temporal temporal) {
1094         return temporal.with(INSTANT_SECONDS, seconds).with(NANO_OF_SECOND, nanos);
1095     }
1096 
1097     /**
1098      * Calculates the amount of time until another instant in terms of the specified unit.
1099      * &lt;p&gt;
1100      * This calculates the amount of time between two {@code Instant}
1101      * objects in terms of a single {@code TemporalUnit}.
1102      * The start and end points are {@code this} and the specified instant.
1103      * The result will be negative if the end is before the start.
1104      * The calculation returns a whole number, representing the number of
1105      * complete units between the two instants.
1106      * The {@code Temporal} passed to this method is converted to a
1107      * {@code Instant} using {@link #from(TemporalAccessor)}.
1108      * For example, the amount in seconds between two dates can be calculated
1109      * using {@code startInstant.until(endInstant, SECONDS)}.
1110      * &lt;p&gt;
1111      * There are two equivalent ways of using this method.
1112      * The first is to invoke this method.
1113      * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
1114      * &lt;pre&gt;
1115      *   // these two lines are equivalent
1116      *   amount = start.until(end, SECONDS);
1117      *   amount = SECONDS.between(start, end);
1118      * &lt;/pre&gt;
1119      * The choice should be made based on which makes the code more readable.
1120      * &lt;p&gt;
1121      * The calculation is implemented in this method for {@link ChronoUnit}.
1122      * The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},
1123      * {@code MINUTES}, {@code HOURS}, {@code HALF_DAYS} and {@code DAYS}
1124      * are supported. Other {@code ChronoUnit} values will throw an exception.
1125      * &lt;p&gt;
1126      * If the unit is not a {@code ChronoUnit}, then the result of this method
1127      * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}
1128      * passing {@code this} as the first argument and the converted input temporal
1129      * as the second argument.
1130      * &lt;p&gt;
1131      * This instance is immutable and unaffected by this method call.
1132      *
1133      * @param endExclusive  the end date, exclusive, which is converted to an {@code Instant}, not null
1134      * @param unit  the unit to measure the amount in, not null
1135      * @return the amount of time between this instant and the end instant
1136      * @throws DateTimeException if the amount cannot be calculated, or the end
1137      *  temporal cannot be converted to an {@code Instant}
1138      * @throws UnsupportedTemporalTypeException if the unit is not supported
1139      * @throws ArithmeticException if numeric overflow occurs
1140      */
1141     @Override
1142     public long until(Temporal endExclusive, TemporalUnit unit) {
1143         Instant end = Instant.from(endExclusive);
1144         if (unit instanceof ChronoUnit) {
1145             ChronoUnit f = (ChronoUnit) unit;
1146             switch (f) {
1147                 case NANOS: return nanosUntil(end);
1148                 case MICROS: return nanosUntil(end) / 1000;
1149                 case MILLIS: return Math.subtractExact(end.toEpochMilli(), toEpochMilli());
1150                 case SECONDS: return secondsUntil(end);
1151                 case MINUTES: return secondsUntil(end) / SECONDS_PER_MINUTE;
1152                 case HOURS: return secondsUntil(end) / SECONDS_PER_HOUR;
1153                 case HALF_DAYS: return secondsUntil(end) / (12 * SECONDS_PER_HOUR);
1154                 case DAYS: return secondsUntil(end) / (SECONDS_PER_DAY);
1155             }
1156             throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);
1157         }
1158         return unit.between(this, end);
1159     }
1160 
1161     private long nanosUntil(Instant end) {
1162         long secsDiff = Math.subtractExact(end.seconds, seconds);
1163         long totalNanos = Math.multiplyExact(secsDiff, NANOS_PER_SECOND);
1164         return Math.addExact(totalNanos, end.nanos - nanos);
1165     }
1166 
1167     private long secondsUntil(Instant end) {
1168         long secsDiff = Math.subtractExact(end.seconds, seconds);
1169         long nanosDiff = end.nanos - nanos;
1170         if (secsDiff &gt; 0 &amp;&amp; nanosDiff &lt; 0) {
1171             secsDiff--;
1172         } else if (secsDiff &lt; 0 &amp;&amp; nanosDiff &gt; 0) {
1173             secsDiff++;
1174         }
1175         return secsDiff;
1176     }
1177 
1178     //-----------------------------------------------------------------------
1179     /**
1180      * Combines this instant with an offset to create an {@code OffsetDateTime}.
1181      * &lt;p&gt;
1182      * This returns an {@code OffsetDateTime} formed from this instant at the
1183      * specified offset from UTC/Greenwich. An exception will be thrown if the
1184      * instant is too large to fit into an offset date-time.
1185      * &lt;p&gt;
1186      * This method is equivalent to
1187      * {@link OffsetDateTime#ofInstant(Instant, ZoneId) OffsetDateTime.ofInstant(this, offset)}.
1188      *
1189      * @param offset  the offset to combine with, not null
1190      * @return the offset date-time formed from this instant and the specified offset, not null
1191      * @throws DateTimeException if the result exceeds the supported range
1192      */
1193     public OffsetDateTime atOffset(ZoneOffset offset) {
1194         return OffsetDateTime.ofInstant(this, offset);
1195     }
1196 
1197     /**
1198      * Combines this instant with a time-zone to create a {@code ZonedDateTime}.
1199      * &lt;p&gt;
1200      * This returns an {@code ZonedDateTime} formed from this instant at the
1201      * specified time-zone. An exception will be thrown if the instant is too
1202      * large to fit into a zoned date-time.
1203      * &lt;p&gt;
1204      * This method is equivalent to
1205      * {@link ZonedDateTime#ofInstant(Instant, ZoneId) ZonedDateTime.ofInstant(this, zone)}.
1206      *
1207      * @param zone  the zone to combine with, not null
1208      * @return the zoned date-time formed from this instant and the specified zone, not null
1209      * @throws DateTimeException if the result exceeds the supported range
1210      */
1211     public ZonedDateTime atZone(ZoneId zone) {
1212         return ZonedDateTime.ofInstant(this, zone);
1213     }
1214 
1215     //-----------------------------------------------------------------------
1216     /**
1217      * Converts this instant to the number of milliseconds from the epoch
1218      * of 1970-01-01T00:00:00Z.
1219      * &lt;p&gt;
1220      * If this instant represents a point on the time-line too far in the future
1221      * or past to fit in a {@code long} milliseconds, then an exception is thrown.
1222      * &lt;p&gt;
1223      * If this instant has greater than millisecond precision, then the conversion
1224      * will drop any excess precision information as though the amount in nanoseconds
1225      * was subject to integer division by one million.
1226      *
1227      * @return the number of milliseconds since the epoch of 1970-01-01T00:00:00Z
1228      * @throws ArithmeticException if numeric overflow occurs
1229      */
1230     public long toEpochMilli() {
1231         if (seconds &lt; 0 &amp;&amp; nanos &gt; 0) {
1232             long millis = Math.multiplyExact(seconds+1, 1000);
1233             long adjustment = nanos / 1000_000 - 1000;
1234             return Math.addExact(millis, adjustment);
1235         } else {
1236             long millis = Math.multiplyExact(seconds, 1000);
1237             return Math.addExact(millis, nanos / 1000_000);
1238         }
1239     }
1240 
1241     //-----------------------------------------------------------------------
1242     /**
1243      * Compares this instant to the specified instant.
1244      * &lt;p&gt;
1245      * The comparison is based on the time-line position of the instants.
1246      * It is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
1247      *
1248      * @param otherInstant  the other instant to compare to, not null
1249      * @return the comparator value, negative if less, positive if greater
1250      * @throws NullPointerException if otherInstant is null
1251      */
1252     @Override
1253     public int compareTo(Instant otherInstant) {
1254         int cmp = Long.compare(seconds, otherInstant.seconds);
1255         if (cmp != 0) {
1256             return cmp;
1257         }
1258         return nanos - otherInstant.nanos;
1259     }
1260 
1261     /**
1262      * Checks if this instant is after the specified instant.
1263      * &lt;p&gt;
1264      * The comparison is based on the time-line position of the instants.
1265      *
1266      * @param otherInstant  the other instant to compare to, not null
1267      * @return true if this instant is after the specified instant
1268      * @throws NullPointerException if otherInstant is null
1269      */
1270     public boolean isAfter(Instant otherInstant) {
1271         return compareTo(otherInstant) &gt; 0;
1272     }
1273 
1274     /**
1275      * Checks if this instant is before the specified instant.
1276      * &lt;p&gt;
1277      * The comparison is based on the time-line position of the instants.
1278      *
1279      * @param otherInstant  the other instant to compare to, not null
1280      * @return true if this instant is before the specified instant
1281      * @throws NullPointerException if otherInstant is null
1282      */
1283     public boolean isBefore(Instant otherInstant) {
1284         return compareTo(otherInstant) &lt; 0;
1285     }
1286 
1287     //-----------------------------------------------------------------------
1288     /**
1289      * Checks if this instant is equal to the specified instant.
1290      * &lt;p&gt;
1291      * The comparison is based on the time-line position of the instants.
1292      *
1293      * @param otherInstant  the other instant, null returns false
1294      * @return true if the other instant is equal to this one
1295      */
1296     @Override
1297     public boolean equals(Object otherInstant) {
1298         if (this == otherInstant) {
1299             return true;
1300         }
1301         if (otherInstant instanceof Instant) {
1302             Instant other = (Instant) otherInstant;
1303             return this.seconds == other.seconds &amp;&amp;
1304                    this.nanos == other.nanos;
1305         }
1306         return false;
1307     }
1308 
1309     /**
1310      * Returns a hash code for this instant.
1311      *
1312      * @return a suitable hash code
1313      */
1314     @Override
1315     public int hashCode() {
1316         return ((int) (seconds ^ (seconds &gt;&gt;&gt; 32))) + 51 * nanos;
1317     }
1318 
1319     //-----------------------------------------------------------------------
1320     /**
1321      * A string representation of this instant using ISO-8601 representation.
1322      * &lt;p&gt;
1323      * The format used is the same as {@link DateTimeFormatter#ISO_INSTANT}.
1324      *
1325      * @return an ISO-8601 representation of this instant, not null
1326      */
1327     @Override
1328     public String toString() {
1329         return DateTimeFormatter.ISO_INSTANT.format(this);
1330     }
1331 
1332     // -----------------------------------------------------------------------
1333     /**
1334      * Writes the object using a
1335      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
1336      * @serialData
1337      * &lt;pre&gt;
1338      *  out.writeByte(2);  // identifies an Instant
1339      *  out.writeLong(seconds);
1340      *  out.writeInt(nanos);
1341      * &lt;/pre&gt;
1342      *
1343      * @return the instance of {@code Ser}, not null
1344      */
<a name="4" id="anc4"></a>
1345     private Object writeReplace() {
1346         return new Ser(Ser.INSTANT_TYPE, this);
1347     }
1348 
1349     /**
1350      * Defend against malicious streams.
1351      *
1352      * @param s the stream to read
1353      * @throws InvalidObjectException always
1354      */
<a name="5" id="anc5"></a>
1355     private void readObject(ObjectInputStream s) throws InvalidObjectException {
1356         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
1357     }
1358 
1359     void writeExternal(DataOutput out) throws IOException {
1360         out.writeLong(seconds);
1361         out.writeInt(nanos);
1362     }
1363 
1364     static Instant readExternal(DataInput in) throws IOException {
1365         long seconds = in.readLong();
1366         int nanos = in.readInt();
1367         return Instant.ofEpochSecond(seconds, nanos);
1368     }
1369 
1370 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleInfo.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleStatics.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -150,12 +150,11 @@</span>
      // private constructors, or interfaces with multiple but related
      // entry points, must be covered by hand-written or automatically
      // generated adapter classes.
      //
      @CallerSensitive
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     &lt;T&gt; T asInterfaceInstance(final Class&lt;T&gt; intfc, final MethodHandle target) {</span>
<span class="udiff-line-modified-added">+     public static &lt;T&gt; T asInterfaceInstance(final Class&lt;T&gt; intfc, final MethodHandle target) {</span>
          if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))
              throw newIllegalArgumentException(&quot;not a public interface&quot;, intfc.getName());
          final MethodHandle mh;
          if (System.getSecurityManager() != null) {
              final Class&lt;?&gt; caller = Reflection.getCallerClass();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -233,12 +232,11 @@</span>
      /**
       * Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
       * @param x any reference
       * @return true if the reference is not null and points to an object produced by {@code asInterfaceInstance}
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     boolean isWrapperInstance(Object x) {</span>
<span class="udiff-line-modified-added">+     public static boolean isWrapperInstance(Object x) {</span>
          return x instanceof WrapperInstance;
      }
  
      private static WrapperInstance asWrapperInstance(Object x) {
          try {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -256,12 +254,11 @@</span>
       * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
       * @param x any reference
       * @return a method handle implementing the unique method
       * @throws IllegalArgumentException if the reference x is not to a wrapper instance
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle wrapperInstanceTarget(Object x) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle wrapperInstanceTarget(Object x) {</span>
          return asWrapperInstance(x).getWrapperInstanceTarget();
      }
  
      /**
       * Recovers the unique single-method interface type for which this wrapper instance was created.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -269,17 +266,15 @@</span>
       * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
       * @param x any reference
       * @return the single-method interface type for which the wrapper was created
       * @throws IllegalArgumentException if the reference x is not to a wrapper instance
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     Class&lt;?&gt; wrapperInstanceType(Object x) {</span>
<span class="udiff-line-modified-added">+     public static Class&lt;?&gt; wrapperInstanceType(Object x) {</span>
          return asWrapperInstance(x).getWrapperInstanceType();
      }
  
<span class="udiff-line-modified-removed">-     private static</span>
<span class="udiff-line-removed">-     boolean isObjectMethod(Method m) {</span>
<span class="udiff-line-modified-added">+     private static boolean isObjectMethod(Method m) {</span>
          switch (m.getName()) {
          case &quot;toString&quot;:
              return (m.getReturnType() == String.class
                      &amp;&amp; m.getParameterTypes().length == 0);
          case &quot;hashCode&quot;:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,12 +286,11 @@</span>
                      &amp;&amp; m.getParameterTypes()[0] == Object.class);
          }
          return false;
      }
  
<span class="udiff-line-modified-removed">-     private static</span>
<span class="udiff-line-removed">-     Object callObjectMethod(Object self, Method m, Object[] args) {</span>
<span class="udiff-line-modified-added">+     private static Object callObjectMethod(Object self, Method m, Object[] args) {</span>
          assert(isObjectMethod(m)) : m;
          switch (m.getName()) {
          case &quot;toString&quot;:
              return self.getClass().getName() + &quot;@&quot; + Integer.toHexString(self.hashCode());
          case &quot;hashCode&quot;:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -305,12 +299,11 @@</span>
              return (self == args[0]);
          }
          return null;
      }
  
<span class="udiff-line-modified-removed">-     private static</span>
<span class="udiff-line-removed">-     Method[] getSingleNameMethods(Class&lt;?&gt; intfc) {</span>
<span class="udiff-line-modified-added">+     private static Method[] getSingleNameMethods(Class&lt;?&gt; intfc) {</span>
          ArrayList&lt;Method&gt; methods = new ArrayList&lt;&gt;();
          String uniqueName = null;
          for (Method m : intfc.getMethods()) {
              if (isObjectMethod(m))  continue;
              if (!Modifier.isAbstract(m.getModifiers()))  continue;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -323,28 +316,25 @@</span>
          }
          if (uniqueName == null)  return null;
          return methods.toArray(new Method[methods.size()]);
      }
  
<span class="udiff-line-modified-removed">-     private static</span>
<span class="udiff-line-removed">-     boolean isDefaultMethod(Method m) {</span>
<span class="udiff-line-modified-added">+     private static boolean isDefaultMethod(Method m) {</span>
          return !Modifier.isAbstract(m.getModifiers());
      }
  
<span class="udiff-line-modified-removed">-     private static</span>
<span class="udiff-line-removed">-     boolean hasDefaultMethods(Class&lt;?&gt; intfc) {</span>
<span class="udiff-line-modified-added">+     private static boolean hasDefaultMethods(Class&lt;?&gt; intfc) {</span>
          for (Method m : intfc.getMethods()) {
              if (!isObjectMethod(m) &amp;&amp;
                  !Modifier.isAbstract(m.getModifiers())) {
                  return true;
              }
          }
          return false;
      }
  
<span class="udiff-line-modified-removed">-     private static</span>
<span class="udiff-line-removed">-     Object callDefaultMethod(ConcurrentHashMap&lt;Method, MethodHandle&gt; defaultMethodMap,</span>
<span class="udiff-line-modified-added">+     private static Object callDefaultMethod(ConcurrentHashMap&lt;Method, MethodHandle&gt; defaultMethodMap,</span>
                               Object self, Class&lt;?&gt; intfc, Method m, Object[] args) throws Throwable {
          assert(isDefaultMethod(m) &amp;&amp; !isObjectMethod(m)) : m;
  
          // Lazily compute the associated method handle from the method
          MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -&gt; {
</pre>
<center><a href="MethodHandleInfo.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleStatics.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
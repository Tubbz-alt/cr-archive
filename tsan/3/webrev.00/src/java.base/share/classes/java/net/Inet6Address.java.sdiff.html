<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/Inet6Address.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Inet4Address.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Inet6AddressImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/Inet6Address.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;
 29 import java.io.InvalidObjectException;
 30 import java.io.ObjectInputStream;
 31 import java.io.ObjectOutputStream;
 32 import java.io.ObjectStreamField;
 33 import java.util.Enumeration;
 34 import java.util.Arrays;
 35 
 36 /**
 37  * This class represents an Internet Protocol version 6 (IPv6) address.
 38  * Defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;
 39  * &lt;i&gt;RFC&amp;nbsp;2373: IP Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;.
 40  *
<span class="line-modified"> 41  * &lt;h3&gt; &lt;a id=&quot;format&quot;&gt;Textual representation of IP addresses&lt;/a&gt; &lt;/h3&gt;</span>
 42  *
 43  * Textual representation of IPv6 address used as input to methods
 44  * takes one of the following forms:
 45  *
 46  * &lt;ol&gt;
 47  *   &lt;li&gt;&lt;p&gt; &lt;a id=&quot;lform&quot;&gt;The preferred form&lt;/a&gt; is x:x:x:x:x:x:x:x,
 48  *   where the &#39;x&#39;s are
 49  *   the hexadecimal values of the eight 16-bit pieces of the
 50  *   address. This is the full form.  For example,
 51  *
 52  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
 53  *   &lt;li&gt;{@code 1080:0:0:0:8:800:200C:417A}&lt;/li&gt;
 54  *   &lt;/ul&gt;&lt;/blockquote&gt;
 55  *
 56  *   &lt;p&gt; Note that it is not necessary to write the leading zeros in
 57  *   an individual field. However, there must be at least one numeral
 58  *   in every field, except as described below.&lt;/li&gt;
 59  *
 60  *   &lt;li&gt;&lt;p&gt; Due to some methods of allocating certain styles of IPv6
 61  *   addresses, it will be common for addresses to contain long
</pre>
<hr />
<pre>
 99  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
100  *   &lt;li&gt;{@code ::FFFF:d}&lt;/li&gt;
101  *   &lt;/ul&gt;&lt;/blockquote&gt;
102  *
103  *   &lt;p&gt; is valid, however it is an unconventional representation of
104  *   the IPv4-compatible IPv6 address,
105  *
106  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
107  *   &lt;li&gt;{@code ::255.255.0.d}&lt;/li&gt;
108  *   &lt;/ul&gt;&lt;/blockquote&gt;
109  *
110  *   &lt;p&gt; while &quot;::d&quot; corresponds to the general IPv6 address
111  *   &quot;0:0:0:0:0:0:0:d&quot;.&lt;/li&gt;
112  * &lt;/ol&gt;
113  *
114  * &lt;p&gt; For methods that return a textual representation as output
115  * value, the full form is used. Inet6Address will return the full
116  * form because it is unambiguous when used in combination with other
117  * textual data.
118  *
<span class="line-modified">119  * &lt;h4&gt; Special IPv6 address &lt;/h4&gt;</span>
120  *
121  * &lt;blockquote&gt;
122  * &lt;table class=&quot;borderless&quot;&gt;
123  * &lt;caption style=&quot;display:none&quot;&gt;Description of IPv4-mapped address&lt;/caption&gt;
124  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; padding-right:2px&quot;&gt;&lt;i&gt;IPv4-mapped address&lt;/i&gt;&lt;/th&gt;
125  *         &lt;td&gt;Of the form ::ffff:w.x.y.z, this IPv6 address is used to
126  *         represent an IPv4 address. It allows the native program to
127  *         use the same address data structure and also the same
128  *         socket when communicating with both IPv4 and IPv6 nodes.
129  *
130  *         &lt;p&gt;In InetAddress and Inet6Address, it is used for internal
131  *         representation; it has no functional role. Java will never
132  *         return an IPv4-mapped address.  These classes can take an
133  *         IPv4-mapped address as input, both in byte array and text
134  *         representation. However, it will be converted into an IPv4
135  *         address.&lt;/td&gt;&lt;/tr&gt;
136  * &lt;/table&gt;&lt;/blockquote&gt;
137  *
<span class="line-modified">138  * &lt;h4&gt;&lt;a id=&quot;scoped&quot;&gt;Textual representation of IPv6 scoped addresses&lt;/a&gt;&lt;/h4&gt;</span>
139  *
140  * &lt;p&gt; The textual representation of IPv6 addresses as described above can be
141  * extended to specify IPv6 scoped addresses. This extension to the basic
142  * addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].
143  *
144  * &lt;p&gt; Because link-local and site-local addresses are non-global, it is possible
145  * that different hosts may have the same destination address and may be
146  * reachable through different interfaces on the same originating system. In
147  * this case, the originating system is said to be connected to multiple zones
148  * of the same scope. In order to disambiguate which is the intended destination
149  * zone, it is possible to append a zone identifier (or &lt;i&gt;scope_id&lt;/i&gt;) to an
150  * IPv6 address.
151  *
152  * &lt;p&gt; The general format for specifying the &lt;i&gt;scope_id&lt;/i&gt; is the following:
153  *
154  * &lt;blockquote&gt;&lt;i&gt;IPv6-address&lt;/i&gt;%&lt;i&gt;scope_id&lt;/i&gt;&lt;/blockquote&gt;
155  * &lt;p&gt; The IPv6-address is a literal IPv6 address as described above.
156  * The &lt;i&gt;scope_id&lt;/i&gt; refers to an interface on the local system, and it can be
157  * specified in two ways.
158  * &lt;ol&gt;&lt;li&gt;&lt;i&gt;As a numeric identifier.&lt;/i&gt; This must be a positive integer
159  * that identifies the particular interface and scope as understood by the
160  * system. Usually, the numeric values can be determined through administration
161  * tools on the system. Each interface may have multiple values, one for each
162  * scope. If the scope is unspecified, then the default value used is zero.&lt;/li&gt;
163  * &lt;li&gt;&lt;i&gt;As a string.&lt;/i&gt; This must be the exact string that is returned by
164  * {@link java.net.NetworkInterface#getName()} for the particular interface in
165  * question. When an Inet6Address is created in this way, the numeric scope-id
166  * is determined at the time the object is created by querying the relevant
167  * NetworkInterface.&lt;/li&gt;&lt;/ol&gt;
168  *
169  * &lt;p&gt; Note also, that the numeric &lt;i&gt;scope_id&lt;/i&gt; can be retrieved from
170  * Inet6Address instances returned from the NetworkInterface class. This can be
171  * used to find out the current scope ids configured on the system.
172  * @since 1.4
173  */
174 
175 public final
176 class Inet6Address extends InetAddress {
177     static final int INADDRSZ = 16;
178 
<span class="line-removed">179     /*</span>
<span class="line-removed">180      * cached scope_id - for link-local address use only.</span>
<span class="line-removed">181      */</span>
<span class="line-removed">182     private transient int cached_scope_id;  // 0</span>
<span class="line-removed">183 </span>
184     private class Inet6AddressHolder {
185 
186         private Inet6AddressHolder() {
187             ipaddress = new byte[INADDRSZ];
188         }
189 
190         private Inet6AddressHolder(
191             byte[] ipaddress, int scope_id, boolean scope_id_set,
192             NetworkInterface ifname, boolean scope_ifname_set)
193         {
194             this.ipaddress = ipaddress;
195             this.scope_id = scope_id;
196             this.scope_id_set = scope_id_set;
197             this.scope_ifname_set = scope_ifname_set;
198             this.scope_ifname = ifname;
199         }
200 
201         /**
202          * Holds a 128-bit (16 bytes) IPv6 address.
203          */
</pre>
<hr />
<pre>
351         }
352 
353         boolean isMCLinkLocal() {
354             return ((ipaddress[0] &amp; 0xff) == 0xff
355                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x02);
356         }
357 
358         boolean isMCSiteLocal() {
359             return ((ipaddress[0] &amp; 0xff) == 0xff
360                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x05);
361         }
362 
363         boolean isMCOrgLocal() {
364             return ((ipaddress[0] &amp; 0xff) == 0xff
365                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x08);
366         }
367     }
368 
369     private final transient Inet6AddressHolder holder6;
370 

371     private static final long serialVersionUID = 6880410070516793377L;
372 
373     // Perform native initialization
374     static { init(); }
375 
376     Inet6Address() {
377         super();
378         holder.init(null, IPv6);
379         holder6 = new Inet6AddressHolder();
380     }
381 
382     /* checking of value for scope_id should be done by caller
383      * scope_id must be &gt;= 0, or -1 to indicate not being set
384      */
385     Inet6Address(String hostName, byte addr[], int scope_id) {
386         holder.init(hostName, IPv6);
387         holder6 = new Inet6AddressHolder();
388         holder6.init(addr, scope_id);
389     }
390 
</pre>
<hr />
<pre>
550             en = NetworkInterface.getNetworkInterfaces();
551         } catch (SocketException e) {
552             throw new UnknownHostException (&quot;could not enumerate local network interfaces&quot;);
553         }
554         while (en.hasMoreElements()) {
555             NetworkInterface ifc = en.nextElement();
556             if (ifc.getName().equals (ifname)) {
557                 return deriveNumericScope(holder6.ipaddress, ifc);
558             }
559         }
560         throw new UnknownHostException (&quot;No matching address found for interface : &quot; +ifname);
561     }
562 
563     /**
564      * @serialField ipaddress byte[]
565      * @serialField scope_id int
566      * @serialField scope_id_set boolean
567      * @serialField scope_ifname_set boolean
568      * @serialField ifname String
569      */
<span class="line-modified">570 </span>
571     private static final ObjectStreamField[] serialPersistentFields = {
572          new ObjectStreamField(&quot;ipaddress&quot;, byte[].class),
573          new ObjectStreamField(&quot;scope_id&quot;, int.class),
574          new ObjectStreamField(&quot;scope_id_set&quot;, boolean.class),
575          new ObjectStreamField(&quot;scope_ifname_set&quot;, boolean.class),
576          new ObjectStreamField(&quot;ifname&quot;, String.class)
577     };
578 
579     private static final jdk.internal.misc.Unsafe UNSAFE
580             = jdk.internal.misc.Unsafe.getUnsafe();
581     private static final long FIELDS_OFFSET = UNSAFE.objectFieldOffset(
582                 Inet6Address.class, &quot;holder6&quot;);
583 
584     /**
585      * restore the state of this object from stream
586      * including the scope information, only if the
587      * scoped interface name is valid on this system
588      */

589     private void readObject(ObjectInputStream s)
590         throws IOException, ClassNotFoundException {
591         NetworkInterface scope_ifname = null;
592 
593         if (getClass().getClassLoader() != null) {
594             throw new SecurityException (&quot;invalid address type&quot;);
595         }
596 
597         ObjectInputStream.GetField gf = s.readFields();
598         byte[] ipaddress = (byte[])gf.get(&quot;ipaddress&quot;, new byte[0]);
599         int scope_id = gf.get(&quot;scope_id&quot;, -1);
600         boolean scope_id_set = gf.get(&quot;scope_id_set&quot;, false);
601         boolean scope_ifname_set = gf.get(&quot;scope_ifname_set&quot;, false);
602         String ifname = (String)gf.get(&quot;ifname&quot;, null);
603 
604         if (ifname != null &amp;&amp; !ifname.isEmpty()) {
605             try {
606                 scope_ifname = NetworkInterface.getByName(ifname);
607                 if (scope_ifname == null) {
608                     /* the interface does not exist on this system, so we clear
</pre>
<hr />
<pre>
632             throw new InvalidObjectException(&quot;invalid address length: &quot;+
633                                              ipaddress.length);
634         }
635 
636         if (holder.getFamily() != IPv6) {
637             throw new InvalidObjectException(&quot;invalid address family type&quot;);
638         }
639 
640         Inet6AddressHolder h = new Inet6AddressHolder(
641             ipaddress, scope_id, scope_id_set, scope_ifname, scope_ifname_set
642         );
643 
644         UNSAFE.putReference(this, FIELDS_OFFSET, h);
645     }
646 
647     /**
648      * default behavior is overridden in order to write the
649      * scope_ifname field as a String, rather than a NetworkInterface
650      * which is not serializable
651      */

652     private synchronized void writeObject(ObjectOutputStream s)
653         throws IOException
654     {
655             String ifname = null;
656 
657         if (holder6.scope_ifname != null) {
658             ifname = holder6.scope_ifname.getName();
659             holder6.scope_ifname_set = true;
660         }
661         ObjectOutputStream.PutField pfields = s.putFields();
662         pfields.put(&quot;ipaddress&quot;, holder6.ipaddress);
663         pfields.put(&quot;scope_id&quot;, holder6.scope_id);
664         pfields.put(&quot;scope_id_set&quot;, holder6.scope_id_set);
665         pfields.put(&quot;scope_ifname_set&quot;, holder6.scope_ifname_set);
666         pfields.put(&quot;ifname&quot;, ifname);
667         s.writeFields();
668     }
669 
670     /**
671      * Utility routine to check if the InetAddress is an IP multicast
</pre>
<hr />
<pre>
778      * @return a {@code boolean} indicating if the address has is a multicast
779      *         address of site-local scope, false if it is not  of site-local
780      *         scope or it is not a multicast address
781      */
782     @Override
783     public boolean isMCSiteLocal() {
784         return holder6.isMCSiteLocal();
785     }
786 
787     /**
788      * Utility routine to check if the multicast address has organization scope.
789      *
790      * @return a {@code boolean} indicating if the address has is a multicast
791      *         address of organization-local scope, false if it is not of
792      *         organization-local scope or it is not a multicast address
793      */
794     @Override
795     public boolean isMCOrgLocal() {
796         return holder6.isMCOrgLocal();
797     }

798     /**
799      * Returns the raw IP address of this {@code InetAddress} object. The result
800      * is in network byte order: the highest order byte of the address is in
801      * {@code getAddress()[0]}.
802      *
803      * @return  the raw IP address of this object.
804      */
805     @Override
806     public byte[] getAddress() {
807         return holder6.ipaddress.clone();
808     }
809 







810     /**
811      * Returns the numeric scopeId, if this instance is associated with
812      * an interface. If no scoped_id is set, the returned value is zero.
813      *
814      * @return the scopeId, or zero if not set.
815      *
816      * @since 1.5
817      */
818      public int getScopeId() {
<span class="line-modified">819         return holder6.scope_id;</span>
820      }
821 
822     /**
823      * Returns the scoped interface, if this instance was created with
824      * a scoped interface.
825      *
826      * @return the scoped interface, or null if not set.
827      * @since 1.5
828      */
829      public NetworkInterface getScopedInterface() {
<span class="line-modified">830         return holder6.scope_ifname;</span>
831      }
832 
833     /**
834      * Returns the IP address string in textual presentation. If the instance
835      * was created specifying a scope identifier then the scope id is appended
836      * to the IP address preceded by a &quot;%&quot; (per-cent) character. This can be
837      * either a numeric value or a string, depending on which was used to create
838      * the instance.
839      *
840      * @return  the raw IP address in a string format.
841      */
842     @Override
843     public String getHostAddress() {
844         return holder6.getHostAddress();
845     }
846 
847     /**
848      * Returns a hashcode for this IP address.
849      *
850      * @return  a hash code value for this IP address.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.IOException;
 29 import java.io.InvalidObjectException;
 30 import java.io.ObjectInputStream;
 31 import java.io.ObjectOutputStream;
 32 import java.io.ObjectStreamField;
 33 import java.util.Enumeration;
 34 import java.util.Arrays;
 35 
 36 /**
 37  * This class represents an Internet Protocol version 6 (IPv6) address.
 38  * Defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;
 39  * &lt;i&gt;RFC&amp;nbsp;2373: IP Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt;.
 40  *
<span class="line-modified"> 41  * &lt;h2&gt; &lt;a id=&quot;format&quot;&gt;Textual representation of IP addresses&lt;/a&gt; &lt;/h2&gt;</span>
 42  *
 43  * Textual representation of IPv6 address used as input to methods
 44  * takes one of the following forms:
 45  *
 46  * &lt;ol&gt;
 47  *   &lt;li&gt;&lt;p&gt; &lt;a id=&quot;lform&quot;&gt;The preferred form&lt;/a&gt; is x:x:x:x:x:x:x:x,
 48  *   where the &#39;x&#39;s are
 49  *   the hexadecimal values of the eight 16-bit pieces of the
 50  *   address. This is the full form.  For example,
 51  *
 52  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
 53  *   &lt;li&gt;{@code 1080:0:0:0:8:800:200C:417A}&lt;/li&gt;
 54  *   &lt;/ul&gt;&lt;/blockquote&gt;
 55  *
 56  *   &lt;p&gt; Note that it is not necessary to write the leading zeros in
 57  *   an individual field. However, there must be at least one numeral
 58  *   in every field, except as described below.&lt;/li&gt;
 59  *
 60  *   &lt;li&gt;&lt;p&gt; Due to some methods of allocating certain styles of IPv6
 61  *   addresses, it will be common for addresses to contain long
</pre>
<hr />
<pre>
 99  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
100  *   &lt;li&gt;{@code ::FFFF:d}&lt;/li&gt;
101  *   &lt;/ul&gt;&lt;/blockquote&gt;
102  *
103  *   &lt;p&gt; is valid, however it is an unconventional representation of
104  *   the IPv4-compatible IPv6 address,
105  *
106  *   &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
107  *   &lt;li&gt;{@code ::255.255.0.d}&lt;/li&gt;
108  *   &lt;/ul&gt;&lt;/blockquote&gt;
109  *
110  *   &lt;p&gt; while &quot;::d&quot; corresponds to the general IPv6 address
111  *   &quot;0:0:0:0:0:0:0:d&quot;.&lt;/li&gt;
112  * &lt;/ol&gt;
113  *
114  * &lt;p&gt; For methods that return a textual representation as output
115  * value, the full form is used. Inet6Address will return the full
116  * form because it is unambiguous when used in combination with other
117  * textual data.
118  *
<span class="line-modified">119  * &lt;h3&gt; Special IPv6 address &lt;/h3&gt;</span>
120  *
121  * &lt;blockquote&gt;
122  * &lt;table class=&quot;borderless&quot;&gt;
123  * &lt;caption style=&quot;display:none&quot;&gt;Description of IPv4-mapped address&lt;/caption&gt;
124  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; padding-right:2px&quot;&gt;&lt;i&gt;IPv4-mapped address&lt;/i&gt;&lt;/th&gt;
125  *         &lt;td&gt;Of the form ::ffff:w.x.y.z, this IPv6 address is used to
126  *         represent an IPv4 address. It allows the native program to
127  *         use the same address data structure and also the same
128  *         socket when communicating with both IPv4 and IPv6 nodes.
129  *
130  *         &lt;p&gt;In InetAddress and Inet6Address, it is used for internal
131  *         representation; it has no functional role. Java will never
132  *         return an IPv4-mapped address.  These classes can take an
133  *         IPv4-mapped address as input, both in byte array and text
134  *         representation. However, it will be converted into an IPv4
135  *         address.&lt;/td&gt;&lt;/tr&gt;
136  * &lt;/table&gt;&lt;/blockquote&gt;
137  *
<span class="line-modified">138  * &lt;h3&gt;&lt;a id=&quot;scoped&quot;&gt;Textual representation of IPv6 scoped addresses&lt;/a&gt;&lt;/h3&gt;</span>
139  *
140  * &lt;p&gt; The textual representation of IPv6 addresses as described above can be
141  * extended to specify IPv6 scoped addresses. This extension to the basic
142  * addressing architecture is described in [draft-ietf-ipngwg-scoping-arch-04.txt].
143  *
144  * &lt;p&gt; Because link-local and site-local addresses are non-global, it is possible
145  * that different hosts may have the same destination address and may be
146  * reachable through different interfaces on the same originating system. In
147  * this case, the originating system is said to be connected to multiple zones
148  * of the same scope. In order to disambiguate which is the intended destination
149  * zone, it is possible to append a zone identifier (or &lt;i&gt;scope_id&lt;/i&gt;) to an
150  * IPv6 address.
151  *
152  * &lt;p&gt; The general format for specifying the &lt;i&gt;scope_id&lt;/i&gt; is the following:
153  *
154  * &lt;blockquote&gt;&lt;i&gt;IPv6-address&lt;/i&gt;%&lt;i&gt;scope_id&lt;/i&gt;&lt;/blockquote&gt;
155  * &lt;p&gt; The IPv6-address is a literal IPv6 address as described above.
156  * The &lt;i&gt;scope_id&lt;/i&gt; refers to an interface on the local system, and it can be
157  * specified in two ways.
158  * &lt;ol&gt;&lt;li&gt;&lt;i&gt;As a numeric identifier.&lt;/i&gt; This must be a positive integer
159  * that identifies the particular interface and scope as understood by the
160  * system. Usually, the numeric values can be determined through administration
161  * tools on the system. Each interface may have multiple values, one for each
162  * scope. If the scope is unspecified, then the default value used is zero.&lt;/li&gt;
163  * &lt;li&gt;&lt;i&gt;As a string.&lt;/i&gt; This must be the exact string that is returned by
164  * {@link java.net.NetworkInterface#getName()} for the particular interface in
165  * question. When an Inet6Address is created in this way, the numeric scope-id
166  * is determined at the time the object is created by querying the relevant
167  * NetworkInterface.&lt;/li&gt;&lt;/ol&gt;
168  *
169  * &lt;p&gt; Note also, that the numeric &lt;i&gt;scope_id&lt;/i&gt; can be retrieved from
170  * Inet6Address instances returned from the NetworkInterface class. This can be
171  * used to find out the current scope ids configured on the system.
172  * @since 1.4
173  */
174 
175 public final
176 class Inet6Address extends InetAddress {
177     static final int INADDRSZ = 16;
178 





179     private class Inet6AddressHolder {
180 
181         private Inet6AddressHolder() {
182             ipaddress = new byte[INADDRSZ];
183         }
184 
185         private Inet6AddressHolder(
186             byte[] ipaddress, int scope_id, boolean scope_id_set,
187             NetworkInterface ifname, boolean scope_ifname_set)
188         {
189             this.ipaddress = ipaddress;
190             this.scope_id = scope_id;
191             this.scope_id_set = scope_id_set;
192             this.scope_ifname_set = scope_ifname_set;
193             this.scope_ifname = ifname;
194         }
195 
196         /**
197          * Holds a 128-bit (16 bytes) IPv6 address.
198          */
</pre>
<hr />
<pre>
346         }
347 
348         boolean isMCLinkLocal() {
349             return ((ipaddress[0] &amp; 0xff) == 0xff
350                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x02);
351         }
352 
353         boolean isMCSiteLocal() {
354             return ((ipaddress[0] &amp; 0xff) == 0xff
355                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x05);
356         }
357 
358         boolean isMCOrgLocal() {
359             return ((ipaddress[0] &amp; 0xff) == 0xff
360                     &amp;&amp; (ipaddress[1] &amp; 0x0f) == 0x08);
361         }
362     }
363 
364     private final transient Inet6AddressHolder holder6;
365 
<span class="line-added">366     @java.io.Serial</span>
367     private static final long serialVersionUID = 6880410070516793377L;
368 
369     // Perform native initialization
370     static { init(); }
371 
372     Inet6Address() {
373         super();
374         holder.init(null, IPv6);
375         holder6 = new Inet6AddressHolder();
376     }
377 
378     /* checking of value for scope_id should be done by caller
379      * scope_id must be &gt;= 0, or -1 to indicate not being set
380      */
381     Inet6Address(String hostName, byte addr[], int scope_id) {
382         holder.init(hostName, IPv6);
383         holder6 = new Inet6AddressHolder();
384         holder6.init(addr, scope_id);
385     }
386 
</pre>
<hr />
<pre>
546             en = NetworkInterface.getNetworkInterfaces();
547         } catch (SocketException e) {
548             throw new UnknownHostException (&quot;could not enumerate local network interfaces&quot;);
549         }
550         while (en.hasMoreElements()) {
551             NetworkInterface ifc = en.nextElement();
552             if (ifc.getName().equals (ifname)) {
553                 return deriveNumericScope(holder6.ipaddress, ifc);
554             }
555         }
556         throw new UnknownHostException (&quot;No matching address found for interface : &quot; +ifname);
557     }
558 
559     /**
560      * @serialField ipaddress byte[]
561      * @serialField scope_id int
562      * @serialField scope_id_set boolean
563      * @serialField scope_ifname_set boolean
564      * @serialField ifname String
565      */
<span class="line-modified">566     @java.io.Serial</span>
567     private static final ObjectStreamField[] serialPersistentFields = {
568          new ObjectStreamField(&quot;ipaddress&quot;, byte[].class),
569          new ObjectStreamField(&quot;scope_id&quot;, int.class),
570          new ObjectStreamField(&quot;scope_id_set&quot;, boolean.class),
571          new ObjectStreamField(&quot;scope_ifname_set&quot;, boolean.class),
572          new ObjectStreamField(&quot;ifname&quot;, String.class)
573     };
574 
575     private static final jdk.internal.misc.Unsafe UNSAFE
576             = jdk.internal.misc.Unsafe.getUnsafe();
577     private static final long FIELDS_OFFSET = UNSAFE.objectFieldOffset(
578                 Inet6Address.class, &quot;holder6&quot;);
579 
580     /**
581      * restore the state of this object from stream
582      * including the scope information, only if the
583      * scoped interface name is valid on this system
584      */
<span class="line-added">585     @java.io.Serial</span>
586     private void readObject(ObjectInputStream s)
587         throws IOException, ClassNotFoundException {
588         NetworkInterface scope_ifname = null;
589 
590         if (getClass().getClassLoader() != null) {
591             throw new SecurityException (&quot;invalid address type&quot;);
592         }
593 
594         ObjectInputStream.GetField gf = s.readFields();
595         byte[] ipaddress = (byte[])gf.get(&quot;ipaddress&quot;, new byte[0]);
596         int scope_id = gf.get(&quot;scope_id&quot;, -1);
597         boolean scope_id_set = gf.get(&quot;scope_id_set&quot;, false);
598         boolean scope_ifname_set = gf.get(&quot;scope_ifname_set&quot;, false);
599         String ifname = (String)gf.get(&quot;ifname&quot;, null);
600 
601         if (ifname != null &amp;&amp; !ifname.isEmpty()) {
602             try {
603                 scope_ifname = NetworkInterface.getByName(ifname);
604                 if (scope_ifname == null) {
605                     /* the interface does not exist on this system, so we clear
</pre>
<hr />
<pre>
629             throw new InvalidObjectException(&quot;invalid address length: &quot;+
630                                              ipaddress.length);
631         }
632 
633         if (holder.getFamily() != IPv6) {
634             throw new InvalidObjectException(&quot;invalid address family type&quot;);
635         }
636 
637         Inet6AddressHolder h = new Inet6AddressHolder(
638             ipaddress, scope_id, scope_id_set, scope_ifname, scope_ifname_set
639         );
640 
641         UNSAFE.putReference(this, FIELDS_OFFSET, h);
642     }
643 
644     /**
645      * default behavior is overridden in order to write the
646      * scope_ifname field as a String, rather than a NetworkInterface
647      * which is not serializable
648      */
<span class="line-added">649     @java.io.Serial</span>
650     private synchronized void writeObject(ObjectOutputStream s)
651         throws IOException
652     {
653             String ifname = null;
654 
655         if (holder6.scope_ifname != null) {
656             ifname = holder6.scope_ifname.getName();
657             holder6.scope_ifname_set = true;
658         }
659         ObjectOutputStream.PutField pfields = s.putFields();
660         pfields.put(&quot;ipaddress&quot;, holder6.ipaddress);
661         pfields.put(&quot;scope_id&quot;, holder6.scope_id);
662         pfields.put(&quot;scope_id_set&quot;, holder6.scope_id_set);
663         pfields.put(&quot;scope_ifname_set&quot;, holder6.scope_ifname_set);
664         pfields.put(&quot;ifname&quot;, ifname);
665         s.writeFields();
666     }
667 
668     /**
669      * Utility routine to check if the InetAddress is an IP multicast
</pre>
<hr />
<pre>
776      * @return a {@code boolean} indicating if the address has is a multicast
777      *         address of site-local scope, false if it is not  of site-local
778      *         scope or it is not a multicast address
779      */
780     @Override
781     public boolean isMCSiteLocal() {
782         return holder6.isMCSiteLocal();
783     }
784 
785     /**
786      * Utility routine to check if the multicast address has organization scope.
787      *
788      * @return a {@code boolean} indicating if the address has is a multicast
789      *         address of organization-local scope, false if it is not of
790      *         organization-local scope or it is not a multicast address
791      */
792     @Override
793     public boolean isMCOrgLocal() {
794         return holder6.isMCOrgLocal();
795     }
<span class="line-added">796 </span>
797     /**
798      * Returns the raw IP address of this {@code InetAddress} object. The result
799      * is in network byte order: the highest order byte of the address is in
800      * {@code getAddress()[0]}.
801      *
802      * @return  the raw IP address of this object.
803      */
804     @Override
805     public byte[] getAddress() {
806         return holder6.ipaddress.clone();
807     }
808 
<span class="line-added">809     /**</span>
<span class="line-added">810      * Returns a reference to the byte[] with the IPv6 address.</span>
<span class="line-added">811      */</span>
<span class="line-added">812     byte[] addressBytes() {</span>
<span class="line-added">813         return holder6.ipaddress;</span>
<span class="line-added">814     }</span>
<span class="line-added">815 </span>
816     /**
817      * Returns the numeric scopeId, if this instance is associated with
818      * an interface. If no scoped_id is set, the returned value is zero.
819      *
820      * @return the scopeId, or zero if not set.
821      *
822      * @since 1.5
823      */
824      public int getScopeId() {
<span class="line-modified">825          return holder6.scope_id;</span>
826      }
827 
828     /**
829      * Returns the scoped interface, if this instance was created with
830      * a scoped interface.
831      *
832      * @return the scoped interface, or null if not set.
833      * @since 1.5
834      */
835      public NetworkInterface getScopedInterface() {
<span class="line-modified">836          return holder6.scope_ifname;</span>
837      }
838 
839     /**
840      * Returns the IP address string in textual presentation. If the instance
841      * was created specifying a scope identifier then the scope id is appended
842      * to the IP address preceded by a &quot;%&quot; (per-cent) character. This can be
843      * either a numeric value or a string, depending on which was used to create
844      * the instance.
845      *
846      * @return  the raw IP address in a string format.
847      */
848     @Override
849     public String getHostAddress() {
850         return holder6.getHostAddress();
851     }
852 
853     /**
854      * Returns a hashcode for this IP address.
855      *
856      * @return  a hash code value for this IP address.
</pre>
</td>
</tr>
</table>
<center><a href="Inet4Address.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Inet6AddressImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Process.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 
 28 import java.io.*;
 29 import java.lang.ProcessBuilder.Redirect;
 30 import java.util.concurrent.CompletableFuture;
 31 import java.util.concurrent.ForkJoinPool;
 32 import java.util.concurrent.TimeUnit;
 33 import java.util.stream.Stream;
 34 
 35 /**
 36  * {@code Process} provides control of native processes started by
 37  * ProcessBuilder.start and Runtime.exec.
 38  * The class provides methods for performing input from the process, performing
 39  * output to the process, waiting for the process to complete,
 40  * checking the exit status of the process, and destroying (killing)
 41  * the process.
 42  * The {@link ProcessBuilder#start()} and
 43  * {@link Runtime#exec(String[],String[],File) Runtime.exec}
 44  * methods create a native process and return an instance of a
 45  * subclass of {@code Process} that can be used to control the process
 46  * and obtain information about it.
 47  *
 48  * &lt;p&gt;The methods that create processes may not work well for special
 49  * processes on certain native platforms, such as native windowing
 50  * processes, daemon processes, Win16/DOS processes on Microsoft
 51  * Windows, or shell scripts.
 52  *
 53  * &lt;p&gt;By default, the created process does not have its own terminal
 54  * or console.  All its standard I/O (i.e. stdin, stdout, stderr)
 55  * operations will be redirected to the parent process, where they can
 56  * be accessed via the streams obtained using the methods
 57  * {@link #getOutputStream()},
 58  * {@link #getInputStream()}, and
 59  * {@link #getErrorStream()}.
 60  * The parent process uses these streams to feed input to and get output
 61  * from the process.  Because some native platforms only provide
 62  * limited buffer size for standard input and output streams, failure
 63  * to promptly write the input stream or read the output stream of
 64  * the process may cause the process to block, or even deadlock.
 65  *
 66  * &lt;p&gt;Where desired, &lt;a href=&quot;ProcessBuilder.html#redirect-input&quot;&gt;
 67  * process I/O can also be redirected&lt;/a&gt;
 68  * using methods of the {@link ProcessBuilder} class.
 69  *
 70  * &lt;p&gt;The process is not killed when there are no more references to
 71  * the {@code Process} object, but rather the process
 72  * continues executing asynchronously.
 73  *
 74  * &lt;p&gt;There is no requirement that the process represented by a {@code
 75  * Process} object execute asynchronously or concurrently with respect
 76  * to the Java process that owns the {@code Process} object.
 77  *
 78  * &lt;p&gt;As of 1.5, {@link ProcessBuilder#start()} is the preferred way
 79  * to create a {@code Process}.
 80  *
 81  * &lt;p&gt;Subclasses of Process should override the {@link #onExit()} and
 82  * {@link #toHandle()} methods to provide a fully functional Process including the
 83  * {@linkplain #pid() process id},
 84  * {@linkplain #info() information about the process},
 85  * {@linkplain #children() direct children}, and
 86  * {@linkplain #descendants() direct children plus descendants of those children} of the process.
 87  * Delegating to the underlying Process or ProcessHandle is typically
 88  * easiest and most efficient.
 89  *
 90  * @since   1.0
 91  */
 92 public abstract class Process {
 93     /**
 94      * Default constructor for Process.
 95      */
 96     public Process() {}
 97 
 98     /**
 99      * Returns the output stream connected to the normal input of the
100      * process.  Output to the stream is piped into the standard
101      * input of the process represented by this {@code Process} object.
102      *
103      * &lt;p&gt;If the standard input of the process has been redirected using
104      * {@link ProcessBuilder#redirectInput(Redirect)
105      * ProcessBuilder.redirectInput}
106      * then this method will return a
107      * &lt;a href=&quot;ProcessBuilder.html#redirect-input&quot;&gt;null output stream&lt;/a&gt;.
108      *
109      * &lt;p&gt;Implementation note: It is a good idea for the returned
110      * output stream to be buffered.
111      *
112      * @return the output stream connected to the normal input of the
113      *         process
114      */
115     public abstract OutputStream getOutputStream();
116 
117     /**
118      * Returns the input stream connected to the normal output of the
119      * process.  The stream obtains data piped from the standard
120      * output of the process represented by this {@code Process} object.
121      *
122      * &lt;p&gt;If the standard output of the process has been redirected using
123      * {@link ProcessBuilder#redirectOutput(Redirect)
124      * ProcessBuilder.redirectOutput}
125      * then this method will return a
126      * &lt;a href=&quot;ProcessBuilder.html#redirect-output&quot;&gt;null input stream&lt;/a&gt;.
127      *
128      * &lt;p&gt;Otherwise, if the standard error of the process has been
129      * redirected using
130      * {@link ProcessBuilder#redirectErrorStream(boolean)
131      * ProcessBuilder.redirectErrorStream}
132      * then the input stream returned by this method will receive the
133      * merged standard output and the standard error of the process.
134      *
135      * &lt;p&gt;Implementation note: It is a good idea for the returned
136      * input stream to be buffered.
137      *
138      * @return the input stream connected to the normal output of the
139      *         process
140      */
141     public abstract InputStream getInputStream();
142 
143     /**
144      * Returns the input stream connected to the error output of the
145      * process.  The stream obtains data piped from the error output
146      * of the process represented by this {@code Process} object.
147      *
148      * &lt;p&gt;If the standard error of the process has been redirected using
149      * {@link ProcessBuilder#redirectError(Redirect)
150      * ProcessBuilder.redirectError} or
151      * {@link ProcessBuilder#redirectErrorStream(boolean)
152      * ProcessBuilder.redirectErrorStream}
153      * then this method will return a
154      * &lt;a href=&quot;ProcessBuilder.html#redirect-output&quot;&gt;null input stream&lt;/a&gt;.
155      *
156      * &lt;p&gt;Implementation note: It is a good idea for the returned
157      * input stream to be buffered.
158      *
159      * @return the input stream connected to the error output of
160      *         the process
161      */
162     public abstract InputStream getErrorStream();
163 
164     /**
165      * Causes the current thread to wait, if necessary, until the
166      * process represented by this {@code Process} object has
167      * terminated.  This method returns immediately if the process
168      * has already terminated.  If the process has not yet
169      * terminated, the calling thread will be blocked until the
170      * process exits.
171      *
172      * @return the exit value of the process represented by this
173      *         {@code Process} object.  By convention, the value
174      *         {@code 0} indicates normal termination.
175      * @throws InterruptedException if the current thread is
176      *         {@linkplain Thread#interrupt() interrupted} by another
177      *         thread while it is waiting, then the wait is ended and
178      *         an {@link InterruptedException} is thrown.
179      */
180     public abstract int waitFor() throws InterruptedException;
181 
182     /**
183      * Causes the current thread to wait, if necessary, until the
184      * process represented by this {@code Process} object has
185      * terminated, or the specified waiting time elapses.
186      *
187      * &lt;p&gt;If the process has already terminated then this method returns
188      * immediately with the value {@code true}.  If the process has not
189      * terminated and the timeout value is less than, or equal to, zero, then
190      * this method returns immediately with the value {@code false}.
191      *
192      * &lt;p&gt;The default implementation of this methods polls the {@code exitValue}
193      * to check if the process has terminated. Concrete implementations of this
194      * class are strongly encouraged to override this method with a more
195      * efficient implementation.
196      *
197      * @param timeout the maximum time to wait
198      * @param unit the time unit of the {@code timeout} argument
199      * @return {@code true} if the process has exited and {@code false} if
200      *         the waiting time elapsed before the process has exited.
201      * @throws InterruptedException if the current thread is interrupted
202      *         while waiting.
203      * @throws NullPointerException if unit is null
204      * @since 1.8
205      */
206     public boolean waitFor(long timeout, TimeUnit unit)
207         throws InterruptedException
208     {
<a name="2" id="anc2"></a><span class="line-modified">209         long remainingNanos = unit.toNanos(timeout); // throw NPE before other conditions</span>
<span class="line-modified">210         if (hasExited())</span>
<span class="line-added">211             return true;</span>
<span class="line-added">212         if (timeout &lt;= 0)</span>
<span class="line-added">213             return false;</span>
214 
<a name="3" id="anc3"></a><span class="line-added">215         long deadline = System.nanoTime() + remainingNanos;</span>
216         do {
<a name="4" id="anc4"></a><span class="line-modified">217             Thread.sleep(Math.min(TimeUnit.NANOSECONDS.toMillis(remainingNanos) + 1, 100));</span>
<span class="line-modified">218             if (hasExited())</span>
219                 return true;
<a name="5" id="anc5"></a><span class="line-modified">220             remainingNanos = deadline - System.nanoTime();</span>
<span class="line-modified">221         } while (remainingNanos &gt; 0);</span>
<span class="line-modified">222 </span>




223         return false;
224     }
225 
226     /**
227      * Returns the exit value for the process.
228      *
229      * @return the exit value of the process represented by this
230      *         {@code Process} object.  By convention, the value
231      *         {@code 0} indicates normal termination.
232      * @throws IllegalThreadStateException if the process represented
233      *         by this {@code Process} object has not yet terminated
234      */
235     public abstract int exitValue();
236 
237     /**
238      * Kills the process.
239      * Whether the process represented by this {@code Process} object is
240      * {@linkplain #supportsNormalTermination normally terminated} or not is
241      * implementation dependent.
242      * Forcible process destruction is defined as the immediate termination of a
243      * process, whereas normal termination allows the process to shut down cleanly.
244      * If the process is not alive, no action is taken.
245      * &lt;p&gt;
246      * The {@link java.util.concurrent.CompletableFuture} from {@link #onExit} is
247      * {@linkplain java.util.concurrent.CompletableFuture#complete completed}
248      * when the process has terminated.
249      */
250     public abstract void destroy();
251 
252     /**
253      * Kills the process forcibly. The process represented by this
254      * {@code Process} object is forcibly terminated.
255      * Forcible process destruction is defined as the immediate termination of a
256      * process, whereas normal termination allows the process to shut down cleanly.
257      * If the process is not alive, no action is taken.
258      * &lt;p&gt;
259      * The {@link java.util.concurrent.CompletableFuture} from {@link #onExit} is
260      * {@linkplain java.util.concurrent.CompletableFuture#complete completed}
261      * when the process has terminated.
262      * &lt;p&gt;
263      * Invoking this method on {@code Process} objects returned by
264      * {@link ProcessBuilder#start} and {@link Runtime#exec} forcibly terminate
265      * the process.
266      *
267      * @implSpec
268      * The default implementation of this method invokes {@link #destroy}
269      * and so may not forcibly terminate the process.
270      * @implNote
271      * Concrete implementations of this class are strongly encouraged to override
272      * this method with a compliant implementation.
273      * @apiNote
274      * The process may not terminate immediately.
275      * i.e. {@code isAlive()} may return true for a brief period
276      * after {@code destroyForcibly()} is called. This method
277      * may be chained to {@code waitFor()} if needed.
278      *
279      * @return the {@code Process} object representing the
280      *         process forcibly destroyed
281      * @since 1.8
282      */
283     public Process destroyForcibly() {
284         destroy();
285         return this;
286     }
287 
288     /**
289      * Returns {@code true} if the implementation of {@link #destroy} is to
290      * normally terminate the process,
291      * Returns {@code false} if the implementation of {@code destroy}
292      * forcibly and immediately terminates the process.
293      * &lt;p&gt;
294      * Invoking this method on {@code Process} objects returned by
295      * {@link ProcessBuilder#start} and {@link Runtime#exec} return
296      * {@code true} or {@code false} depending on the platform implementation.
297      *
298      * @implSpec
299      * This implementation throws an instance of
300      * {@link java.lang.UnsupportedOperationException} and performs no other action.
301      *
302      * @return {@code true} if the implementation of {@link #destroy} is to
303      *         normally terminate the process;
304      *         otherwise, {@link #destroy} forcibly terminates the process
305      * @throws UnsupportedOperationException if the Process implementation
306      *         does not support this operation
307      * @since 9
308      */
309     public boolean supportsNormalTermination() {
310         throw new UnsupportedOperationException(this.getClass()
311                 + &quot;.supportsNormalTermination() not supported&quot; );
312     }
313 
314     /**
315      * Tests whether the process represented by this {@code Process} is
316      * alive.
317      *
318      * @return {@code true} if the process represented by this
319      *         {@code Process} object has not yet terminated.
320      * @since 1.8
321      */
322     public boolean isAlive() {
<a name="6" id="anc6"></a><span class="line-added">323         return !hasExited();</span>
<span class="line-added">324     }</span>
<span class="line-added">325 </span>
<span class="line-added">326     /**</span>
<span class="line-added">327      * This is called from the default implementation of</span>
<span class="line-added">328      * {@code waitFor(long, TimeUnit)}, which is specified to poll</span>
<span class="line-added">329      * {@code exitValue()}.</span>
<span class="line-added">330      */</span>
<span class="line-added">331     private boolean hasExited() {</span>
332         try {
333             exitValue();
<a name="7" id="anc7"></a>

334             return true;
<a name="8" id="anc8"></a><span class="line-added">335         } catch (IllegalThreadStateException e) {</span>
<span class="line-added">336             return false;</span>
337         }
338     }
339 
340     /**
341      * Returns the native process ID of the process.
342      * The native process ID is an identification number that the operating
343      * system assigns to the process.
344      *
345      * @implSpec
346      * The implementation of this method returns the process id as:
347      * {@link #toHandle toHandle().pid()}.
348      *
349      * @return the native process id of the process
350      * @throws UnsupportedOperationException if the Process implementation
351      *         does not support this operation
352      * @since 9
353      */
354     public long pid() {
355         return toHandle().pid();
356     }
357 
358     /**
359      * Returns a {@code CompletableFuture&lt;Process&gt;} for the termination of the Process.
360      * The {@link java.util.concurrent.CompletableFuture} provides the ability
361      * to trigger dependent functions or actions that may be run synchronously
362      * or asynchronously upon process termination.
363      * When the process has terminated the CompletableFuture is
364      * {@link java.util.concurrent.CompletableFuture#complete completed} regardless
365      * of the exit status of the process.
366      * &lt;p&gt;
367      * Calling {@code onExit().get()} waits for the process to terminate and returns
368      * the Process. The future can be used to check if the process is
369      * {@linkplain java.util.concurrent.CompletableFuture#isDone done} or to
370      * {@linkplain java.util.concurrent.CompletableFuture#get() wait} for it to terminate.
371      * {@linkplain java.util.concurrent.CompletableFuture#cancel(boolean) Cancelling}
372      * the CompletableFuture does not affect the Process.
373      * &lt;p&gt;
374      * Processes returned from {@link ProcessBuilder#start} override the
375      * default implementation to provide an efficient mechanism to wait
376      * for process exit.
377      *
378      * @apiNote
379      * Using {@link #onExit() onExit} is an alternative to
380      * {@link #waitFor() waitFor} that enables both additional concurrency
381      * and convenient access to the result of the Process.
382      * Lambda expressions can be used to evaluate the result of the Process
383      * execution.
384      * If there is other processing to be done before the value is used
385      * then {@linkplain #onExit onExit} is a convenient mechanism to
386      * free the current thread and block only if and when the value is needed.
387      * &lt;br&gt;
388      * For example, launching a process to compare two files and get a boolean if they are identical:
389      * &lt;pre&gt; {@code   Process p = new ProcessBuilder(&quot;cmp&quot;, &quot;f1&quot;, &quot;f2&quot;).start();
390      *    Future&lt;Boolean&gt; identical = p.onExit().thenApply(p1 -&gt; p1.exitValue() == 0);
391      *    ...
392      *    if (identical.get()) { ... }
393      * }&lt;/pre&gt;
394      *
395      * @implSpec
396      * This implementation executes {@link #waitFor()} in a separate thread
397      * repeatedly until it returns successfully. If the execution of
398      * {@code waitFor} is interrupted, the thread&#39;s interrupt status is preserved.
399      * &lt;p&gt;
400      * When {@link #waitFor()} returns successfully the CompletableFuture is
401      * {@linkplain java.util.concurrent.CompletableFuture#complete completed} regardless
402      * of the exit status of the process.
403      *
404      * This implementation may consume a lot of memory for thread stacks if a
405      * large number of processes are waited for concurrently.
406      * &lt;p&gt;
407      * External implementations should override this method and provide
408      * a more efficient implementation. For example, to delegate to the underlying
409      * process, it can do the following:
410      * &lt;pre&gt;{@code
411      *    public CompletableFuture&lt;Process&gt; onExit() {
412      *       return delegate.onExit().thenApply(p -&gt; this);
413      *    }
414      * }&lt;/pre&gt;
415      * @apiNote
416      * The process may be observed to have terminated with {@link #isAlive}
417      * before the ComputableFuture is completed and dependent actions are invoked.
418      *
419      * @return a new {@code CompletableFuture&lt;Process&gt;} for the Process
420      *
421      * @since 9
422      */
423     public CompletableFuture&lt;Process&gt; onExit() {
424         return CompletableFuture.supplyAsync(this::waitForInternal);
425     }
426 
427     /**
428      * Wait for the process to exit by calling {@code waitFor}.
429      * If the thread is interrupted, remember the interrupted state to
430      * be restored before returning. Use ForkJoinPool.ManagedBlocker
431      * so that the number of workers in case ForkJoinPool is used is
432      * compensated when the thread blocks in waitFor().
433      *
434      * @return the Process
435      */
436     private Process waitForInternal() {
437         boolean interrupted = false;
438         while (true) {
439             try {
440                 ForkJoinPool.managedBlock(new ForkJoinPool.ManagedBlocker() {
441                     @Override
442                     public boolean block() throws InterruptedException {
443                         waitFor();
444                         return true;
445                     }
446 
447                     @Override
448                     public boolean isReleasable() {
449                         return !isAlive();
450                     }
451                 });
452                 break;
453             } catch (InterruptedException x) {
454                 interrupted = true;
455             }
456         }
457         if (interrupted) {
458             Thread.currentThread().interrupt();
459         }
460         return this;
461     }
462 
463     /**
464      * Returns a ProcessHandle for the Process.
465      *
466      * {@code Process} objects returned by {@link ProcessBuilder#start} and
467      * {@link Runtime#exec} implement {@code toHandle} as the equivalent of
468      * {@link ProcessHandle#of(long) ProcessHandle.of(pid)} including the
469      * check for a SecurityManager and {@code RuntimePermission(&quot;manageProcess&quot;)}.
470      *
471      * @implSpec
472      * This implementation throws an instance of
473      * {@link java.lang.UnsupportedOperationException} and performs no other action.
474      * Subclasses should override this method to provide a ProcessHandle for the
475      * process.  The methods {@link #pid}, {@link #info}, {@link #children},
476      * and {@link #descendants}, unless overridden, operate on the ProcessHandle.
477      *
478      * @return Returns a ProcessHandle for the Process
479      * @throws UnsupportedOperationException if the Process implementation
480      *         does not support this operation
481      * @throws SecurityException if a security manager has been installed and
482      *         it denies RuntimePermission(&quot;manageProcess&quot;)
483      * @since 9
484      */
485     public ProcessHandle toHandle() {
486         throw new UnsupportedOperationException(this.getClass()
487                 + &quot;.toHandle() not supported&quot;);
488     }
489 
490     /**
491      * Returns a snapshot of information about the process.
492      *
493      * &lt;p&gt; A {@link ProcessHandle.Info} instance has accessor methods
494      * that return information about the process if it is available.
495      *
496      * @implSpec
497      * This implementation returns information about the process as:
498      * {@link #toHandle toHandle().info()}.
499      *
500      * @return a snapshot of information about the process, always non-null
501      * @throws UnsupportedOperationException if the Process implementation
502      *         does not support this operation
503      * @since 9
504      */
505     public ProcessHandle.Info info() {
506         return toHandle().info();
507     }
508 
509     /**
510      * Returns a snapshot of the direct children of the process.
511      * The parent of a direct child process is the process.
512      * Typically, a process that is {@linkplain #isAlive not alive} has no children.
513      * &lt;p&gt;
514      * &lt;em&gt;Note that processes are created and terminate asynchronously.
515      * There is no guarantee that a process is {@linkplain #isAlive alive}.
516      * &lt;/em&gt;
517      *
518      * @implSpec
519      * This implementation returns the direct children as:
520      * {@link #toHandle toHandle().children()}.
521      *
522      * @return a sequential Stream of ProcessHandles for processes that are
523      *         direct children of the process
524      * @throws UnsupportedOperationException if the Process implementation
525      *         does not support this operation
526      * @throws SecurityException if a security manager has been installed and
527      *         it denies RuntimePermission(&quot;manageProcess&quot;)
528      * @since 9
529      */
530     public Stream&lt;ProcessHandle&gt; children() {
531         return toHandle().children();
532     }
533 
534     /**
535      * Returns a snapshot of the descendants of the process.
536      * The descendants of a process are the children of the process
537      * plus the descendants of those children, recursively.
538      * Typically, a process that is {@linkplain #isAlive not alive} has no children.
539      * &lt;p&gt;
540      * &lt;em&gt;Note that processes are created and terminate asynchronously.
541      * There is no guarantee that a process is {@linkplain #isAlive alive}.
542      * &lt;/em&gt;
543      *
544      * @implSpec
545      * This implementation returns all children as:
546      * {@link #toHandle toHandle().descendants()}.
547      *
548      * @return a sequential Stream of ProcessHandles for processes that
549      *         are descendants of the process
550      * @throws UnsupportedOperationException if the Process implementation
551      *         does not support this operation
552      * @throws SecurityException if a security manager has been installed and
553      *         it denies RuntimePermission(&quot;manageProcess&quot;)
554      * @since 9
555      */
556     public Stream&lt;ProcessHandle&gt; descendants() {
557         return toHandle().descendants();
558     }
559 
560     /**
561      * An input stream for a subprocess pipe that skips by reading bytes
562      * instead of seeking, the underlying pipe does not support seek.
563      */
564     static class PipeInputStream extends FileInputStream {
565 
566         PipeInputStream(FileDescriptor fd) {
567             super(fd);
568         }
569 
570         @Override
571         public long skip(long n) throws IOException {
572             long remaining = n;
573             int nr;
574 
575             if (n &lt;= 0) {
576                 return 0;
577             }
578 
579             int size = (int)Math.min(2048, remaining);
580             byte[] skipBuffer = new byte[size];
581             while (remaining &gt; 0) {
582                 nr = read(skipBuffer, 0, (int)Math.min(size, remaining));
583                 if (nr &lt; 0) {
584                     break;
585                 }
586                 remaining -= nr;
587             }
588 
589             return n - remaining;
590         }
591     }
592 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
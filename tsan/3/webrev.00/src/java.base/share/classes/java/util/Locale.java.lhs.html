<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/Locale.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
  28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
  29  *
  30  * The original version of this source code and documentation
  31  * is copyrighted and owned by Taligent, Inc., a wholly-owned
  32  * subsidiary of IBM. These materials are provided under terms
  33  * of a License Agreement between Taligent and Sun. This technology
  34  * is protected by multiple US and International patents.
  35  *
  36  * This notice and attribution to Taligent may not be removed.
  37  * Taligent is a registered trademark of Taligent, Inc.
  38  *
  39  */
  40 
  41 package java.util;
  42 
  43 import java.io.IOException;
  44 import java.io.ObjectInputStream;
  45 import java.io.ObjectOutputStream;
  46 import java.io.ObjectStreamField;
  47 import java.io.Serializable;
  48 import java.text.MessageFormat;
  49 import java.util.concurrent.ConcurrentHashMap;
  50 import java.util.spi.LocaleNameProvider;
  51 import java.util.stream.Collectors;
  52 
  53 import sun.security.action.GetPropertyAction;
  54 import sun.util.locale.BaseLocale;
  55 import sun.util.locale.InternalLocaleBuilder;
  56 import sun.util.locale.LanguageTag;
  57 import sun.util.locale.LocaleExtensions;
  58 import sun.util.locale.LocaleMatcher;
  59 import sun.util.locale.LocaleObjectCache;
  60 import sun.util.locale.LocaleSyntaxException;
  61 import sun.util.locale.LocaleUtils;
  62 import sun.util.locale.ParseStatus;
  63 import sun.util.locale.provider.LocaleProviderAdapter;
  64 import sun.util.locale.provider.LocaleResources;
  65 import sun.util.locale.provider.LocaleServiceProviderPool;
  66 import sun.util.locale.provider.TimeZoneNameUtility;
  67 
  68 /**
<a name="2" id="anc2"></a><span class="line-modified">  69  * A &lt;code&gt;Locale&lt;/code&gt; object represents a specific geographical, political,</span>
<span class="line-modified">  70  * or cultural region. An operation that requires a &lt;code&gt;Locale&lt;/code&gt; to perform</span>
<span class="line-modified">  71  * its task is called &lt;em&gt;locale-sensitive&lt;/em&gt; and uses the &lt;code&gt;Locale&lt;/code&gt;</span>
  72  * to tailor information for the user. For example, displaying a number
  73  * is a locale-sensitive operation&amp;mdash; the number should be formatted
  74  * according to the customs and conventions of the user&#39;s native country,
  75  * region, or culture.
  76  *
  77  * &lt;p&gt; The {@code Locale} class implements IETF BCP 47 which is composed of
  78  * &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 &quot;Matching of Language
  79  * Tags&quot;&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646 &quot;Tags
  80  * for Identifying Languages&quot;&lt;/a&gt; with support for the LDML (UTS#35, &quot;Unicode
  81  * Locale Data Markup Language&quot;) BCP 47-compatible extensions for locale data
  82  * exchange.
  83  *
<a name="3" id="anc3"></a><span class="line-modified">  84  * &lt;p&gt; A &lt;code&gt;Locale&lt;/code&gt; object logically consists of the fields</span>
  85  * described below.
  86  *
  87  * &lt;dl&gt;
  88  *   &lt;dt&gt;&lt;a id=&quot;def_language&quot;&gt;&lt;b&gt;language&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
  89  *
  90  *   &lt;dd&gt;ISO 639 alpha-2 or alpha-3 language code, or registered
  91  *   language subtags up to 8 alpha letters (for future enhancements).
  92  *   When a language has both an alpha-2 code and an alpha-3 code, the
  93  *   alpha-2 code must be used.  You can find a full list of valid
  94  *   language codes in the IANA Language Subtag Registry (search for
  95  *   &quot;Type: language&quot;).  The language field is case insensitive, but
<a name="4" id="anc4"></a><span class="line-modified">  96  *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to lower case.&lt;/dd&gt;</span>
  97  *
  98  *   &lt;dd&gt;Well-formed language values have the form
  99  *   &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;.  Note that this is not the full
 100  *   BCP47 language production, since it excludes extlang.  They are
 101  *   not needed since modern three-letter language codes replace
 102  *   them.&lt;/dd&gt;
 103  *
 104  *   &lt;dd&gt;Example: &quot;en&quot; (English), &quot;ja&quot; (Japanese), &quot;kok&quot; (Konkani)&lt;/dd&gt;
 105  *
 106  *   &lt;dt&gt;&lt;a id=&quot;def_script&quot;&gt;&lt;b&gt;script&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 107  *
 108  *   &lt;dd&gt;ISO 15924 alpha-4 script code.  You can find a full list of
 109  *   valid script codes in the IANA Language Subtag Registry (search
 110  *   for &quot;Type: script&quot;).  The script field is case insensitive, but
<a name="5" id="anc5"></a><span class="line-modified"> 111  *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to title case (the first</span>
 112  *   letter is upper case and the rest of the letters are lower
 113  *   case).&lt;/dd&gt;
 114  *
 115  *   &lt;dd&gt;Well-formed script values have the form
 116  *   &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;&lt;/dd&gt;
 117  *
 118  *   &lt;dd&gt;Example: &quot;Latn&quot; (Latin), &quot;Cyrl&quot; (Cyrillic)&lt;/dd&gt;
 119  *
 120  *   &lt;dt&gt;&lt;a id=&quot;def_region&quot;&gt;&lt;b&gt;country (region)&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 121  *
 122  *   &lt;dd&gt;ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.
 123  *   You can find a full list of valid country and region codes in the
 124  *   IANA Language Subtag Registry (search for &quot;Type: region&quot;).  The
 125  *   country (region) field is case insensitive, but
<a name="6" id="anc6"></a><span class="line-modified"> 126  *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to upper case.&lt;/dd&gt;</span>
 127  *
 128  *   &lt;dd&gt;Well-formed country/region values have
 129  *   the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;&lt;/dd&gt;
 130  *
 131  *   &lt;dd&gt;Example: &quot;US&quot; (United States), &quot;FR&quot; (France), &quot;029&quot;
 132  *   (Caribbean)&lt;/dd&gt;
 133  *
 134  *   &lt;dt&gt;&lt;a id=&quot;def_variant&quot;&gt;&lt;b&gt;variant&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 135  *
 136  *   &lt;dd&gt;Any arbitrary value used to indicate a variation of a
<a name="7" id="anc7"></a><span class="line-modified"> 137  *   &lt;code&gt;Locale&lt;/code&gt;.  Where there are two or more variant values</span>
 138  *   each indicating its own semantics, these values should be ordered
 139  *   by importance, with most important first, separated by
 140  *   underscore(&#39;_&#39;).  The variant field is case sensitive.&lt;/dd&gt;
 141  *
 142  *   &lt;dd&gt;Note: IETF BCP 47 places syntactic restrictions on variant
 143  *   subtags.  Also BCP 47 subtags are strictly used to indicate
 144  *   additional variations that define a language or its dialects that
 145  *   are not covered by any combinations of language, script and
 146  *   region subtags.  You can find a full list of valid variant codes
 147  *   in the IANA Language Subtag Registry (search for &quot;Type: variant&quot;).
 148  *
<a name="8" id="anc8"></a><span class="line-modified"> 149  *   &lt;p&gt;However, the variant field in &lt;code&gt;Locale&lt;/code&gt; has</span>
 150  *   historically been used for any kind of variation, not just
 151  *   language variations.  For example, some supported variants
 152  *   available in Java SE Runtime Environments indicate alternative
 153  *   cultural behaviors such as calendar type or number script.  In
 154  *   BCP 47 this kind of information, which does not identify the
 155  *   language, is supported by extension subtags or private use
 156  *   subtags.&lt;/dd&gt;
 157  *
 158  *   &lt;dd&gt;Well-formed variant values have the form &lt;code&gt;SUBTAG
 159  *   ((&#39;_&#39;|&#39;-&#39;) SUBTAG)*&lt;/code&gt; where &lt;code&gt;SUBTAG =
 160  *   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt;. (Note: BCP 47 only
 161  *   uses hyphen (&#39;-&#39;) as a delimiter, this is more lenient).&lt;/dd&gt;
 162  *
 163  *   &lt;dd&gt;Example: &quot;polyton&quot; (Polytonic Greek), &quot;POSIX&quot;&lt;/dd&gt;
 164  *
 165  *   &lt;dt&gt;&lt;a id=&quot;def_extensions&quot;&gt;&lt;b&gt;extensions&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
 166  *
 167  *   &lt;dd&gt;A map from single character keys to string values, indicating
 168  *   extensions apart from language identification.  The extensions in
<a name="9" id="anc9"></a><span class="line-modified"> 169  *   &lt;code&gt;Locale&lt;/code&gt; implement the semantics and syntax of BCP 47</span>
 170  *   extension subtags and private use subtags. The extensions are
<a name="10" id="anc10"></a><span class="line-modified"> 171  *   case insensitive, but &lt;code&gt;Locale&lt;/code&gt; canonicalizes all</span>
 172  *   extension keys and values to lower case. Note that extensions
 173  *   cannot have empty values.&lt;/dd&gt;
 174  *
 175  *   &lt;dd&gt;Well-formed keys are single characters from the set
<a name="11" id="anc11"></a><span class="line-modified"> 176  *   &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;.  Well-formed values have the form</span>
<span class="line-modified"> 177  *   &lt;code&gt;SUBTAG (&#39;-&#39; SUBTAG)*&lt;/code&gt; where for the key &#39;x&#39;</span>
 178  *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys
 179  *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, &#39;x&#39; allows
 180  *   single-character subtags).&lt;/dd&gt;
 181  *
 182  *   &lt;dd&gt;Example: key=&quot;u&quot;/value=&quot;ca-japanese&quot; (Japanese Calendar),
 183  *   key=&quot;x&quot;/value=&quot;java-1-7&quot;&lt;/dd&gt;
 184  * &lt;/dl&gt;
 185  *
 186  * &lt;b&gt;Note:&lt;/b&gt; Although BCP 47 requires field values to be registered
<a name="12" id="anc12"></a><span class="line-modified"> 187  * in the IANA Language Subtag Registry, the &lt;code&gt;Locale&lt;/code&gt; class</span>
<span class="line-modified"> 188  * does not provide any validation features.  The &lt;code&gt;Builder&lt;/code&gt;</span>
 189  * only checks if an individual field satisfies the syntactic
 190  * requirement (is well-formed), but does not validate the value
 191  * itself.  See {@link Builder} for details.
 192  *
<a name="13" id="anc13"></a><span class="line-modified"> 193  * &lt;h3&gt;&lt;a id=&quot;def_locale_extension&quot;&gt;Unicode locale/language extension&lt;/a&gt;&lt;/h3&gt;</span>
 194  *
 195  * &lt;p&gt;UTS#35, &quot;Unicode Locale Data Markup Language&quot; defines optional
 196  * attributes and keywords to override or refine the default behavior
 197  * associated with a locale.  A keyword is represented by a pair of
 198  * key and type.  For example, &quot;nu-thai&quot; indicates that Thai local
 199  * digits (value:&quot;thai&quot;) should be used for formatting numbers
 200  * (key:&quot;nu&quot;).
 201  *
 202  * &lt;p&gt;The keywords are mapped to a BCP 47 extension value using the
 203  * extension key &#39;u&#39; ({@link #UNICODE_LOCALE_EXTENSION}).  The above
 204  * example, &quot;nu-thai&quot;, becomes the extension &quot;u-nu-thai&quot;.
 205  *
<a name="14" id="anc14"></a><span class="line-modified"> 206  * &lt;p&gt;Thus, when a &lt;code&gt;Locale&lt;/code&gt; object contains Unicode locale</span>
 207  * attributes and keywords,
<a name="15" id="anc15"></a><span class="line-modified"> 208  * &lt;code&gt;getExtension(UNICODE_LOCALE_EXTENSION)&lt;/code&gt; will return a</span>
 209  * String representing this information, for example, &quot;nu-thai&quot;.  The
<a name="16" id="anc16"></a><span class="line-modified"> 210  * &lt;code&gt;Locale&lt;/code&gt; class also provides {@link</span>
 211  * #getUnicodeLocaleAttributes}, {@link #getUnicodeLocaleKeys}, and
 212  * {@link #getUnicodeLocaleType} which allow you to access Unicode
 213  * locale attributes and key/type pairs directly.  When represented as
 214  * a string, the Unicode Locale Extension lists attributes
 215  * alphabetically, followed by key/type sequences with keys listed
 216  * alphabetically (the order of subtags comprising a key&#39;s type is
 217  * fixed when the type is defined)
 218  *
 219  * &lt;p&gt;A well-formed locale key has the form
 220  * &lt;code&gt;[0-9a-zA-Z]{2}&lt;/code&gt;.  A well-formed locale type has the
 221  * form &lt;code&gt;&quot;&quot; | [0-9a-zA-Z]{3,8} (&#39;-&#39; [0-9a-zA-Z]{3,8})*&lt;/code&gt; (it
 222  * can be empty, or a series of subtags 3-8 alphanums in length).  A
 223  * well-formed locale attribute has the form
 224  * &lt;code&gt;[0-9a-zA-Z]{3,8}&lt;/code&gt; (it is a single subtag with the same
 225  * form as a locale type subtag).
 226  *
 227  * &lt;p&gt;The Unicode locale extension specifies optional behavior in
 228  * locale-sensitive services.  Although the LDML specification defines
 229  * various keys and values, actual locale-sensitive service
 230  * implementations in a Java Runtime Environment might not support any
 231  * particular Unicode locale attributes or key/type pairs.
 232  *
<a name="17" id="anc17"></a><span class="line-modified"> 233  * &lt;h4&gt;Creating a Locale&lt;/h4&gt;</span>
 234  *
<a name="18" id="anc18"></a><span class="line-modified"> 235  * &lt;p&gt;There are several different ways to create a &lt;code&gt;Locale&lt;/code&gt;</span>
 236  * object.
 237  *
<a name="19" id="anc19"></a><span class="line-modified"> 238  * &lt;h5&gt;Builder&lt;/h5&gt;</span>
 239  *
<a name="20" id="anc20"></a><span class="line-modified"> 240  * &lt;p&gt;Using {@link Builder} you can construct a &lt;code&gt;Locale&lt;/code&gt; object</span>
 241  * that conforms to BCP 47 syntax.
 242  *
<a name="21" id="anc21"></a><span class="line-modified"> 243  * &lt;h5&gt;Constructors&lt;/h5&gt;</span>
 244  *
<a name="22" id="anc22"></a><span class="line-modified"> 245  * &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides three constructors:</span>
 246  * &lt;blockquote&gt;
 247  * &lt;pre&gt;
 248  *     {@link #Locale(String language)}
 249  *     {@link #Locale(String language, String country)}
 250  *     {@link #Locale(String language, String country, String variant)}
 251  * &lt;/pre&gt;
 252  * &lt;/blockquote&gt;
<a name="23" id="anc23"></a><span class="line-modified"> 253  * These constructors allow you to create a &lt;code&gt;Locale&lt;/code&gt; object</span>
 254  * with language, country and variant, but you cannot specify
 255  * script or extensions.
 256  *
<a name="24" id="anc24"></a><span class="line-modified"> 257  * &lt;h5&gt;Factory Methods&lt;/h5&gt;</span>
 258  *
<a name="25" id="anc25"></a><span class="line-modified"> 259  * &lt;p&gt;The method {@link #forLanguageTag} creates a &lt;code&gt;Locale&lt;/code&gt;</span>
 260  * object for a well-formed BCP 47 language tag.
 261  *
<a name="26" id="anc26"></a><span class="line-modified"> 262  * &lt;h5&gt;Locale Constants&lt;/h5&gt;</span>
 263  *
<a name="27" id="anc27"></a><span class="line-modified"> 264  * &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides a number of convenient constants</span>
<span class="line-modified"> 265  * that you can use to create &lt;code&gt;Locale&lt;/code&gt; objects for commonly used</span>
<span class="line-modified"> 266  * locales. For example, the following creates a &lt;code&gt;Locale&lt;/code&gt; object</span>
 267  * for the United States:
 268  * &lt;blockquote&gt;
 269  * &lt;pre&gt;
 270  *     Locale.US
 271  * &lt;/pre&gt;
 272  * &lt;/blockquote&gt;
 273  *
<a name="28" id="anc28"></a><span class="line-modified"> 274  * &lt;h4&gt;&lt;a id=&quot;LocaleMatching&quot;&gt;Locale Matching&lt;/a&gt;&lt;/h4&gt;</span>
 275  *
 276  * &lt;p&gt;If an application or a system is internationalized and provides localized
 277  * resources for multiple locales, it sometimes needs to find one or more
 278  * locales (or language tags) which meet each user&#39;s specific preferences. Note
 279  * that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this
 280  * locale matching documentation.
 281  *
 282  * &lt;p&gt;In order to do matching a user&#39;s preferred locales to a set of language
 283  * tags, &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of
 284  * Language Tags&lt;/a&gt; defines two mechanisms: filtering and lookup.
 285  * &lt;em&gt;Filtering&lt;/em&gt; is used to get all matching locales, whereas
 286  * &lt;em&gt;lookup&lt;/em&gt; is to choose the best matching locale.
 287  * Matching is done case-insensitively. These matching mechanisms are described
 288  * in the following sections.
 289  *
 290  * &lt;p&gt;A user&#39;s preference is called a &lt;em&gt;Language Priority List&lt;/em&gt; and is
 291  * expressed as a list of language ranges. There are syntactically two types of
 292  * language ranges: basic and extended. See
 293  * {@link Locale.LanguageRange Locale.LanguageRange} for details.
 294  *
<a name="29" id="anc29"></a><span class="line-modified"> 295  * &lt;h5&gt;Filtering&lt;/h5&gt;</span>
 296  *
 297  * &lt;p&gt;The filtering operation returns all matching language tags. It is defined
 298  * in RFC 4647 as follows:
 299  * &quot;In filtering, each language range represents the least specific language
 300  * tag (that is, the language tag with fewest number of subtags) that is an
 301  * acceptable match. All of the language tags in the matching set of tags will
 302  * have an equal or greater number of subtags than the language range. Every
 303  * non-wildcard subtag in the language range will appear in every one of the
 304  * matching language tags.&quot;
 305  *
 306  * &lt;p&gt;There are two types of filtering: filtering for basic language ranges
 307  * (called &quot;basic filtering&quot;) and filtering for extended language ranges
 308  * (called &quot;extended filtering&quot;). They may return different results by what
 309  * kind of language ranges are included in the given Language Priority List.
 310  * {@link Locale.FilteringMode} is a parameter to specify how filtering should
 311  * be done.
 312  *
<a name="30" id="anc30"></a><span class="line-modified"> 313  * &lt;h5&gt;Lookup&lt;/h5&gt;</span>
 314  *
 315  * &lt;p&gt;The lookup operation returns the best matching language tags. It is
 316  * defined in RFC 4647 as follows:
 317  * &quot;By contrast with filtering, each language range represents the most
 318  * specific tag that is an acceptable match.  The first matching tag found,
 319  * according to the user&#39;s priority, is considered the closest match and is the
 320  * item returned.&quot;
 321  *
 322  * &lt;p&gt;For example, if a Language Priority List consists of two language ranges,
 323  * {@code &quot;zh-Hant-TW&quot;} and {@code &quot;en-US&quot;}, in prioritized order, lookup
 324  * method progressively searches the language tags below in order to find the
 325  * best matching language tag.
 326  * &lt;blockquote&gt;
 327  * &lt;pre&gt;
 328  *    1. zh-Hant-TW
 329  *    2. zh-Hant
 330  *    3. zh
 331  *    4. en-US
 332  *    5. en
 333  * &lt;/pre&gt;
 334  * &lt;/blockquote&gt;
 335  * If there is a language tag which matches completely to a language range
 336  * above, the language tag is returned.
 337  *
 338  * &lt;p&gt;{@code &quot;*&quot;} is the special language range, and it is ignored in lookup.
 339  *
 340  * &lt;p&gt;If multiple language tags match as a result of the subtag {@code &#39;*&#39;}
 341  * included in a language range, the first matching language tag returned by
 342  * an {@link Iterator} over a {@link Collection} of language tags is treated as
 343  * the best matching one.
 344  *
<a name="31" id="anc31"></a><span class="line-modified"> 345  * &lt;h4&gt;Use of Locale&lt;/h4&gt;</span>
 346  *
<a name="32" id="anc32"></a><span class="line-modified"> 347  * &lt;p&gt;Once you&#39;ve created a &lt;code&gt;Locale&lt;/code&gt; you can query it for information</span>
<span class="line-modified"> 348  * about itself. Use &lt;code&gt;getCountry&lt;/code&gt; to get the country (or region)</span>
<span class="line-modified"> 349  * code and &lt;code&gt;getLanguage&lt;/code&gt; to get the language code.</span>
<span class="line-modified"> 350  * You can use &lt;code&gt;getDisplayCountry&lt;/code&gt; to get the</span>
 351  * name of the country suitable for displaying to the user. Similarly,
<a name="33" id="anc33"></a><span class="line-modified"> 352  * you can use &lt;code&gt;getDisplayLanguage&lt;/code&gt; to get the name of</span>
 353  * the language suitable for displaying to the user. Interestingly,
<a name="34" id="anc34"></a><span class="line-modified"> 354  * the &lt;code&gt;getDisplayXXX&lt;/code&gt; methods are themselves locale-sensitive</span>
 355  * and have two versions: one that uses the default
 356  * {@link Locale.Category#DISPLAY DISPLAY} locale and one
 357  * that uses the locale specified as an argument.
 358  *
 359  * &lt;p&gt;The Java Platform provides a number of classes that perform locale-sensitive
<a name="35" id="anc35"></a><span class="line-modified"> 360  * operations. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class formats</span>
 361  * numbers, currency, and percentages in a locale-sensitive manner. Classes
<a name="36" id="anc36"></a><span class="line-modified"> 362  * such as &lt;code&gt;NumberFormat&lt;/code&gt; have several convenience methods</span>
 363  * for creating a default object of that type. For example, the
<a name="37" id="anc37"></a><span class="line-modified"> 364  * &lt;code&gt;NumberFormat&lt;/code&gt; class provides these three convenience methods</span>
<span class="line-modified"> 365  * for creating a default &lt;code&gt;NumberFormat&lt;/code&gt; object:</span>
 366  * &lt;blockquote&gt;
 367  * &lt;pre&gt;
 368  *     NumberFormat.getInstance()
 369  *     NumberFormat.getCurrencyInstance()
 370  *     NumberFormat.getPercentInstance()
 371  * &lt;/pre&gt;
 372  * &lt;/blockquote&gt;
 373  * Each of these methods has two variants; one with an explicit locale
 374  * and one without; the latter uses the default
 375  * {@link Locale.Category#FORMAT FORMAT} locale:
 376  * &lt;blockquote&gt;
 377  * &lt;pre&gt;
 378  *     NumberFormat.getInstance(myLocale)
 379  *     NumberFormat.getCurrencyInstance(myLocale)
 380  *     NumberFormat.getPercentInstance(myLocale)
 381  * &lt;/pre&gt;
 382  * &lt;/blockquote&gt;
<a name="38" id="anc38"></a><span class="line-modified"> 383  * A &lt;code&gt;Locale&lt;/code&gt; is the mechanism for identifying the kind of object</span>
<span class="line-modified"> 384  * (&lt;code&gt;NumberFormat&lt;/code&gt;) that you would like to get. The locale is</span>
 385  * &lt;STRONG&gt;just&lt;/STRONG&gt; a mechanism for identifying objects,
 386  * &lt;STRONG&gt;not&lt;/STRONG&gt; a container for the objects themselves.
 387  *
<a name="39" id="anc39"></a><span class="line-modified"> 388  * &lt;h4&gt;Compatibility&lt;/h4&gt;</span>
 389  *
 390  * &lt;p&gt;In order to maintain compatibility with existing usage, Locale&#39;s
 391  * constructors retain their behavior prior to the Java Runtime
 392  * Environment version 1.7.  The same is largely true for the
<a name="40" id="anc40"></a><span class="line-modified"> 393  * &lt;code&gt;toString&lt;/code&gt; method. Thus Locale objects can continue to</span>
 394  * be used as they were. In particular, clients who parse the output
 395  * of toString into language, country, and variant fields can continue
 396  * to do so (although this is strongly discouraged), although the
 397  * variant field will have additional information in it if script or
 398  * extensions are present.
 399  *
 400  * &lt;p&gt;In addition, BCP 47 imposes syntax restrictions that are not
 401  * imposed by Locale&#39;s constructors. This means that conversions
 402  * between some Locales and BCP 47 language tags cannot be made without
<a name="41" id="anc41"></a><span class="line-modified"> 403  * losing information. Thus &lt;code&gt;toLanguageTag&lt;/code&gt; cannot</span>
 404  * represent the state of locales whose language, country, or variant
 405  * do not conform to BCP 47.
 406  *
 407  * &lt;p&gt;Because of these issues, it is recommended that clients migrate
 408  * away from constructing non-conforming locales and use the
<a name="42" id="anc42"></a><span class="line-modified"> 409  * &lt;code&gt;forLanguageTag&lt;/code&gt; and &lt;code&gt;Locale.Builder&lt;/code&gt; APIs instead.</span>
 410  * Clients desiring a string representation of the complete locale can
<a name="43" id="anc43"></a><span class="line-modified"> 411  * then always rely on &lt;code&gt;toLanguageTag&lt;/code&gt; for this purpose.</span>
 412  *
<a name="44" id="anc44"></a><span class="line-modified"> 413  * &lt;h5&gt;&lt;a id=&quot;special_cases_constructor&quot;&gt;Special cases&lt;/a&gt;&lt;/h5&gt;</span>
 414  *
 415  * &lt;p&gt;For compatibility reasons, two
 416  * non-conforming locales are treated as special cases.  These are
 417  * &lt;b&gt;{@code ja_JP_JP}&lt;/b&gt; and &lt;b&gt;{@code th_TH_TH}&lt;/b&gt;. These are ill-formed
 418  * in BCP 47 since the variants are too short. To ease migration to BCP 47,
 419  * these are treated specially during construction.  These two cases (and only
 420  * these) cause a constructor to generate an extension, all other values behave
 421  * exactly as they did prior to Java 7.
 422  *
 423  * &lt;p&gt;Java has used {@code ja_JP_JP} to represent Japanese as used in
 424  * Japan together with the Japanese Imperial calendar. This is now
 425  * representable using a Unicode locale extension, by specifying the
 426  * Unicode locale key {@code ca} (for &quot;calendar&quot;) and type
 427  * {@code japanese}. When the Locale constructor is called with the
 428  * arguments &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;, the extension &quot;u-ca-japanese&quot; is
 429  * automatically added.
 430  *
 431  * &lt;p&gt;Java has used {@code th_TH_TH} to represent Thai as used in
 432  * Thailand together with Thai digits. This is also now representable using
 433  * a Unicode locale extension, by specifying the Unicode locale key
 434  * {@code nu} (for &quot;number&quot;) and value {@code thai}. When the Locale
 435  * constructor is called with the arguments &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;, the
 436  * extension &quot;u-nu-thai&quot; is automatically added.
 437  *
<a name="45" id="anc45"></a><span class="line-modified"> 438  * &lt;h5&gt;Serialization&lt;/h5&gt;</span>
 439  *
 440  * &lt;p&gt;During serialization, writeObject writes all fields to the output
 441  * stream, including extensions.
 442  *
 443  * &lt;p&gt;During deserialization, readResolve adds extensions as described
 444  * in &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;, only
 445  * for the two cases th_TH_TH and ja_JP_JP.
 446  *
<a name="46" id="anc46"></a><span class="line-modified"> 447  * &lt;h5&gt;Legacy language codes&lt;/h5&gt;</span>
 448  *
 449  * &lt;p&gt;Locale&#39;s constructor has always converted three language codes to
 450  * their earlier, obsoleted forms: {@code he} maps to {@code iw},
 451  * {@code yi} maps to {@code ji}, and {@code id} maps to
 452  * {@code in}.  This continues to be the case, in order to not break
 453  * backwards compatibility.
 454  *
 455  * &lt;p&gt;The APIs added in 1.7 map between the old and new language codes,
 456  * maintaining the old codes internal to Locale (so that
<a name="47" id="anc47"></a><span class="line-modified"> 457  * &lt;code&gt;getLanguage&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; reflect the old</span>
 458  * code), but using the new codes in the BCP 47 language tag APIs (so
<a name="48" id="anc48"></a><span class="line-modified"> 459  * that &lt;code&gt;toLanguageTag&lt;/code&gt; reflects the new one). This</span>
 460  * preserves the equivalence between Locales no matter which code or
 461  * API is used to construct them. Java&#39;s default resource bundle
 462  * lookup mechanism also implements this mapping, so that resources
 463  * can be named using either convention, see {@link ResourceBundle.Control}.
 464  *
<a name="49" id="anc49"></a><span class="line-modified"> 465  * &lt;h5&gt;Three-letter language/country(region) codes&lt;/h5&gt;</span>
 466  *
 467  * &lt;p&gt;The Locale constructors have always specified that the language
 468  * and the country param be two characters in length, although in
 469  * practice they have accepted any length.  The specification has now
 470  * been relaxed to allow language codes of two to eight characters and
 471  * country (region) codes of two to three characters, and in
 472  * particular, three-letter language codes and three-digit region
 473  * codes as specified in the IANA Language Subtag Registry.  For
 474  * compatibility, the implementation still does not impose a length
 475  * constraint.
 476  *
 477  * @see Builder
 478  * @see ResourceBundle
 479  * @see java.text.Format
 480  * @see java.text.NumberFormat
 481  * @see java.text.Collator
 482  * @author Mark Davis
 483  * @since 1.1
 484  */
 485 public final class Locale implements Cloneable, Serializable {
 486 
<a name="50" id="anc50"></a><span class="line-removed"> 487     private static final  Cache LOCALECACHE = new Cache();</span>
<span class="line-removed"> 488 </span>
 489     /** Useful constant for language.
 490      */
<a name="51" id="anc51"></a><span class="line-modified"> 491     public static final Locale ENGLISH = createConstant(&quot;en&quot;, &quot;&quot;);</span>
 492 
 493     /** Useful constant for language.
 494      */
<a name="52" id="anc52"></a><span class="line-modified"> 495     public static final Locale FRENCH = createConstant(&quot;fr&quot;, &quot;&quot;);</span>
 496 
 497     /** Useful constant for language.
 498      */
<a name="53" id="anc53"></a><span class="line-modified"> 499     public static final Locale GERMAN = createConstant(&quot;de&quot;, &quot;&quot;);</span>
 500 
 501     /** Useful constant for language.
 502      */
<a name="54" id="anc54"></a><span class="line-modified"> 503     public static final Locale ITALIAN = createConstant(&quot;it&quot;, &quot;&quot;);</span>
 504 
 505     /** Useful constant for language.
 506      */
<a name="55" id="anc55"></a><span class="line-modified"> 507     public static final Locale JAPANESE = createConstant(&quot;ja&quot;, &quot;&quot;);</span>
 508 
 509     /** Useful constant for language.
 510      */
<a name="56" id="anc56"></a><span class="line-modified"> 511     public static final Locale KOREAN = createConstant(&quot;ko&quot;, &quot;&quot;);</span>
 512 
 513     /** Useful constant for language.
 514      */
<a name="57" id="anc57"></a><span class="line-modified"> 515     public static final Locale CHINESE = createConstant(&quot;zh&quot;, &quot;&quot;);</span>
 516 
 517     /** Useful constant for language.
 518      */
<a name="58" id="anc58"></a><span class="line-modified"> 519     public static final Locale SIMPLIFIED_CHINESE = createConstant(&quot;zh&quot;, &quot;CN&quot;);</span>
 520 
 521     /** Useful constant for language.
 522      */
<a name="59" id="anc59"></a><span class="line-modified"> 523     public static final Locale TRADITIONAL_CHINESE = createConstant(&quot;zh&quot;, &quot;TW&quot;);</span>
 524 
 525     /** Useful constant for country.
 526      */
<a name="60" id="anc60"></a><span class="line-modified"> 527     public static final Locale FRANCE = createConstant(&quot;fr&quot;, &quot;FR&quot;);</span>
 528 
 529     /** Useful constant for country.
 530      */
<a name="61" id="anc61"></a><span class="line-modified"> 531     public static final Locale GERMANY = createConstant(&quot;de&quot;, &quot;DE&quot;);</span>
 532 
 533     /** Useful constant for country.
 534      */
<a name="62" id="anc62"></a><span class="line-modified"> 535     public static final Locale ITALY = createConstant(&quot;it&quot;, &quot;IT&quot;);</span>
 536 
 537     /** Useful constant for country.
 538      */
<a name="63" id="anc63"></a><span class="line-modified"> 539     public static final Locale JAPAN = createConstant(&quot;ja&quot;, &quot;JP&quot;);</span>
 540 
 541     /** Useful constant for country.
 542      */
<a name="64" id="anc64"></a><span class="line-modified"> 543     public static final Locale KOREA = createConstant(&quot;ko&quot;, &quot;KR&quot;);</span>
 544 
 545     /** Useful constant for country.
 546      */
<a name="65" id="anc65"></a><span class="line-modified"> 547     public static final Locale CHINA = SIMPLIFIED_CHINESE;</span>
 548 
 549     /** Useful constant for country.
 550      */
<a name="66" id="anc66"></a><span class="line-modified"> 551     public static final Locale PRC = SIMPLIFIED_CHINESE;</span>
 552 
 553     /** Useful constant for country.
 554      */
<a name="67" id="anc67"></a><span class="line-modified"> 555     public static final Locale TAIWAN = TRADITIONAL_CHINESE;</span>
 556 
 557     /** Useful constant for country.
 558      */
<a name="68" id="anc68"></a><span class="line-modified"> 559     public static final Locale UK = createConstant(&quot;en&quot;, &quot;GB&quot;);</span>


































 560 
 561     /** Useful constant for country.
 562      */
<a name="69" id="anc69"></a><span class="line-modified"> 563     public static final Locale US = createConstant(&quot;en&quot;, &quot;US&quot;);</span>
 564 
 565     /** Useful constant for country.
 566      */
<a name="70" id="anc70"></a><span class="line-modified"> 567     public static final Locale CANADA = createConstant(&quot;en&quot;, &quot;CA&quot;);</span>
 568 
 569     /** Useful constant for country.
 570      */
<a name="71" id="anc71"></a><span class="line-modified"> 571     public static final Locale CANADA_FRENCH = createConstant(&quot;fr&quot;, &quot;CA&quot;);</span>
 572 
 573     /**
<a name="72" id="anc72"></a><span class="line-modified"> 574      * Useful constant for the root locale.  The root locale is the locale whose</span>
<span class="line-modified"> 575      * language, country, and variant are empty (&quot;&quot;) strings.  This is regarded</span>
<span class="line-removed"> 576      * as the base locale of all locales, and is used as the language/country</span>
<span class="line-removed"> 577      * neutral locale for the locale sensitive operations.</span>
<span class="line-removed"> 578      *</span>
<span class="line-removed"> 579      * @since 1.6</span>
 580      */
<a name="73" id="anc73"></a><span class="line-modified"> 581     public static final Locale ROOT = createConstant(&quot;&quot;, &quot;&quot;);</span>





 582 
 583     /**
 584      * The key for the private use extension (&#39;x&#39;).
 585      *
 586      * @see #getExtension(char)
 587      * @see Builder#setExtension(char, String)
 588      * @since 1.7
 589      */
 590     public static final char PRIVATE_USE_EXTENSION = &#39;x&#39;;
 591 
 592     /**
 593      * The key for Unicode locale extension (&#39;u&#39;).
 594      *
 595      * @see #getExtension(char)
 596      * @see Builder#setExtension(char, String)
 597      * @since 1.7
 598      */
 599     public static final char UNICODE_LOCALE_EXTENSION = &#39;u&#39;;
 600 
 601     /** serialization ID
 602      */
<a name="74" id="anc74"></a>
 603     static final long serialVersionUID = 9149081749638150636L;
 604 
 605     /**
 606      * Enum for specifying the type defined in ISO 3166. This enum is used to
 607      * retrieve the two-letter ISO3166-1 alpha-2, three-letter ISO3166-1
 608      * alpha-3, four-letter ISO3166-3 country codes.
 609      *
 610      * @see #getISOCountries(Locale.IsoCountryCode)
 611      * @since 9
 612      */
 613     public static enum IsoCountryCode {
 614         /**
 615          * PART1_ALPHA2 is used to represent the ISO3166-1 alpha-2 two letter
 616          * country codes.
 617          */
 618         PART1_ALPHA2 {
 619             @Override
 620             Set&lt;String&gt; createCountryCodeSet() {
 621                 return Set.of(Locale.getISOCountries());
 622             }
 623         },
 624 
 625         /**
 626          *
 627          * PART1_ALPHA3 is used to represent the ISO3166-1 alpha-3 three letter
 628          * country codes.
 629          */
 630         PART1_ALPHA3 {
 631             @Override
 632             Set&lt;String&gt; createCountryCodeSet() {
 633                 return LocaleISOData.computeISO3166_1Alpha3Countries();
 634             }
 635         },
 636 
 637         /**
 638          * PART3 is used to represent the ISO3166-3 four letter country codes.
 639          */
 640         PART3 {
 641             @Override
 642             Set&lt;String&gt; createCountryCodeSet() {
 643                 return Set.of(LocaleISOData.ISO3166_3);
 644             }
 645         };
 646 
 647         /**
 648          * Concrete implementation of this method attempts to compute value
 649          * for iso3166CodesMap for each IsoCountryCode type key.
 650          */
 651         abstract Set&lt;String&gt; createCountryCodeSet();
 652 
 653         /**
 654          * Map to hold country codes for each ISO3166 part.
 655          */
 656         private static Map&lt;IsoCountryCode, Set&lt;String&gt;&gt; iso3166CodesMap = new ConcurrentHashMap&lt;&gt;();
 657 
 658         /**
 659          * This method is called from Locale class to retrieve country code set
 660          * for getISOCountries(type)
 661          */
 662         static Set&lt;String&gt; retrieveISOCountryCodes(IsoCountryCode type) {
 663             return iso3166CodesMap.computeIfAbsent(type, IsoCountryCode::createCountryCodeSet);
 664         }
 665     }
 666 
 667     /**
 668      * Display types for retrieving localized names from the name providers.
 669      */
 670     private static final int DISPLAY_LANGUAGE  = 0;
 671     private static final int DISPLAY_COUNTRY   = 1;
 672     private static final int DISPLAY_VARIANT   = 2;
 673     private static final int DISPLAY_SCRIPT    = 3;
 674     private static final int DISPLAY_UEXT_KEY  = 4;
 675     private static final int DISPLAY_UEXT_TYPE = 5;
 676 
 677     /**
 678      * Private constructor used by getInstance method
 679      */
 680     private Locale(BaseLocale baseLocale, LocaleExtensions extensions) {
 681         this.baseLocale = baseLocale;
 682         this.localeExtensions = extensions;
 683     }
 684 
 685     /**
 686      * Construct a locale from language, country and variant.
 687      * This constructor normalizes the language value to lowercase and
 688      * the country value to uppercase.
 689      * &lt;p&gt;
 690      * &lt;b&gt;Note:&lt;/b&gt;
 691      * &lt;ul&gt;
 692      * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
 693      * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
 694      * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
 695      * API on Locale will return only the OLD codes.
 696      * &lt;li&gt;For backward compatibility reasons, this constructor does not make
 697      * any syntactic checks on the input.
 698      * &lt;li&gt;The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially,
 699      * see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.
 700      * &lt;/ul&gt;
 701      *
 702      * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<a name="75" id="anc75"></a><span class="line-modified"> 703      * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</span>
 704      * valid language values.
 705      * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<a name="76" id="anc76"></a><span class="line-modified"> 706      * See the &lt;code&gt;Locale&lt;/code&gt; class description about valid country values.</span>
<span class="line-modified"> 707      * @param variant Any arbitrary value used to indicate a variation of a &lt;code&gt;Locale&lt;/code&gt;.</span>
<span class="line-modified"> 708      * See the &lt;code&gt;Locale&lt;/code&gt; class description for the details.</span>
<span class="line-modified"> 709      * @exception NullPointerException thrown if any argument is null.</span>
 710      */
 711     public Locale(String language, String country, String variant) {
<a name="77" id="anc77"></a><span class="line-modified"> 712         if (language== null || country == null || variant == null) {</span>
 713             throw new NullPointerException();
 714         }
 715         baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), &quot;&quot;, country, variant);
 716         localeExtensions = getCompatibilityExtensions(language, &quot;&quot;, country, variant);
 717     }
 718 
 719     /**
 720      * Construct a locale from language and country.
 721      * This constructor normalizes the language value to lowercase and
 722      * the country value to uppercase.
 723      * &lt;p&gt;
 724      * &lt;b&gt;Note:&lt;/b&gt;
 725      * &lt;ul&gt;
 726      * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
 727      * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
 728      * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
 729      * API on Locale will return only the OLD codes.
 730      * &lt;li&gt;For backward compatibility reasons, this constructor does not make
 731      * any syntactic checks on the input.
 732      * &lt;/ul&gt;
 733      *
 734      * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<a name="78" id="anc78"></a><span class="line-modified"> 735      * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</span>
 736      * valid language values.
 737      * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<a name="79" id="anc79"></a><span class="line-modified"> 738      * See the &lt;code&gt;Locale&lt;/code&gt; class description about valid country values.</span>
<span class="line-modified"> 739      * @exception NullPointerException thrown if either argument is null.</span>
 740      */
 741     public Locale(String language, String country) {
 742         this(language, country, &quot;&quot;);
 743     }
 744 
 745     /**
 746      * Construct a locale from a language code.
 747      * This constructor normalizes the language value to lowercase.
 748      * &lt;p&gt;
 749      * &lt;b&gt;Note:&lt;/b&gt;
 750      * &lt;ul&gt;
 751      * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
 752      * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
 753      * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
 754      * API on Locale will return only the OLD codes.
 755      * &lt;li&gt;For backward compatibility reasons, this constructor does not make
 756      * any syntactic checks on the input.
 757      * &lt;/ul&gt;
 758      *
 759      * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<a name="80" id="anc80"></a><span class="line-modified"> 760      * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</span>
 761      * valid language values.
<a name="81" id="anc81"></a><span class="line-modified"> 762      * @exception NullPointerException thrown if argument is null.</span>
 763      * @since 1.4
 764      */
 765     public Locale(String language) {
 766         this(language, &quot;&quot;, &quot;&quot;);
 767     }
 768 
 769     /**
<a name="82" id="anc82"></a><span class="line-modified"> 770      * This method must be called only for creating the Locale.*</span>
<span class="line-modified"> 771      * constants due to making shortcuts.</span>
<span class="line-modified"> 772      */</span>
<span class="line-removed"> 773     private static Locale createConstant(String lang, String country) {</span>
<span class="line-removed"> 774         BaseLocale base = BaseLocale.createInstance(lang, country);</span>
<span class="line-removed"> 775         return getInstance(base, null);</span>
<span class="line-removed"> 776     }</span>
<span class="line-removed"> 777 </span>
<span class="line-removed"> 778     /**</span>
<span class="line-removed"> 779      * Returns a &lt;code&gt;Locale&lt;/code&gt; constructed from the given</span>
<span class="line-removed"> 780      * &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;country&lt;/code&gt; and</span>
<span class="line-removed"> 781      * &lt;code&gt;variant&lt;/code&gt;. If the same &lt;code&gt;Locale&lt;/code&gt; instance</span>
 782      * is available in the cache, then that instance is
<a name="83" id="anc83"></a><span class="line-modified"> 783      * returned. Otherwise, a new &lt;code&gt;Locale&lt;/code&gt; instance is</span>
 784      * created and cached.
 785      *
 786      * @param language lowercase 2 to 8 language code.
 787      * @param country uppercase two-letter ISO-3166 code and numeric-3 UN M.49 area code.
 788      * @param variant vendor and browser specific code. See class description.
<a name="84" id="anc84"></a><span class="line-modified"> 789      * @return the &lt;code&gt;Locale&lt;/code&gt; instance requested</span>
<span class="line-modified"> 790      * @exception NullPointerException if any argument is null.</span>
 791      */
 792     static Locale getInstance(String language, String country, String variant) {
 793         return getInstance(language, &quot;&quot;, country, variant, null);
 794     }
 795 
 796     static Locale getInstance(String language, String script, String country,
 797                                       String variant, LocaleExtensions extensions) {
 798         if (language== null || script == null || country == null || variant == null) {
 799             throw new NullPointerException();
 800         }
 801 
 802         if (extensions == null) {
 803             extensions = getCompatibilityExtensions(language, script, country, variant);
 804         }
 805 
<a name="85" id="anc85"></a><span class="line-modified"> 806         BaseLocale baseloc = BaseLocale.getInstance(language, script, country, variant);</span>
 807         return getInstance(baseloc, extensions);
 808     }
 809 
 810     static Locale getInstance(BaseLocale baseloc, LocaleExtensions extensions) {
 811         if (extensions == null) {
<a name="86" id="anc86"></a><span class="line-modified"> 812             return LOCALECACHE.get(baseloc);</span>




 813         } else {
 814             LocaleKey key = new LocaleKey(baseloc, extensions);
<a name="87" id="anc87"></a><span class="line-modified"> 815             return LOCALECACHE.get(key);</span>
 816         }
 817     }
 818 
 819     private static class Cache extends LocaleObjectCache&lt;Object, Locale&gt; {
<a name="88" id="anc88"></a>


 820         private Cache() {
 821         }
 822 
 823         @Override
 824         protected Locale createObject(Object key) {
 825             if (key instanceof BaseLocale) {
 826                 return new Locale((BaseLocale)key, null);
 827             } else {
 828                 LocaleKey lk = (LocaleKey)key;
 829                 return new Locale(lk.base, lk.exts);
 830             }
 831         }
 832     }
 833 
 834     private static final class LocaleKey {
 835         private final BaseLocale base;
 836         private final LocaleExtensions exts;
 837         private final int hash;
 838 
 839         private LocaleKey(BaseLocale baseLocale, LocaleExtensions extensions) {
 840             base = baseLocale;
 841             exts = extensions;
 842 
 843             // Calculate the hash value here because it&#39;s always used.
 844             int h = base.hashCode();
 845             if (exts != null) {
 846                 h ^= exts.hashCode();
 847             }
 848             hash = h;
 849         }
 850 
 851         @Override
 852         public boolean equals(Object obj) {
 853             if (this == obj) {
 854                 return true;
 855             }
 856             if (!(obj instanceof LocaleKey)) {
 857                 return false;
 858             }
 859             LocaleKey other = (LocaleKey)obj;
 860             if (hash != other.hash || !base.equals(other.base)) {
 861                 return false;
 862             }
 863             if (exts == null) {
 864                 return other.exts == null;
 865             }
 866             return exts.equals(other.exts);
 867         }
 868 
 869         @Override
 870         public int hashCode() {
 871             return hash;
 872         }
 873     }
 874 
 875     /**
 876      * Gets the current value of the default locale for this instance
 877      * of the Java Virtual Machine.
 878      * &lt;p&gt;
 879      * The Java Virtual Machine sets the default locale during startup
 880      * based on the host environment. It is used by many locale-sensitive
 881      * methods if no locale is explicitly specified.
 882      * It can be changed using the
 883      * {@link #setDefault(java.util.Locale) setDefault} method.
 884      *
 885      * @return the default locale for this instance of the Java Virtual Machine
 886      */
 887     public static Locale getDefault() {
 888         // do not synchronize this method - see 4071298
 889         return defaultLocale;
 890     }
 891 
 892     /**
 893      * Gets the current value of the default locale for the specified Category
 894      * for this instance of the Java Virtual Machine.
 895      * &lt;p&gt;
 896      * The Java Virtual Machine sets the default locale during startup based
 897      * on the host environment. It is used by many locale-sensitive methods
 898      * if no locale is explicitly specified. It can be changed using the
 899      * setDefault(Locale.Category, Locale) method.
 900      *
<a name="89" id="anc89"></a><span class="line-modified"> 901      * @param category - the specified category to get the default locale</span>
 902      * @throws NullPointerException if category is null
 903      * @return the default locale for the specified Category for this instance
 904      *     of the Java Virtual Machine
 905      * @see #setDefault(Locale.Category, Locale)
 906      * @since 1.7
 907      */
 908     public static Locale getDefault(Locale.Category category) {
 909         // do not synchronize this method - see 4071298
 910         switch (category) {
 911         case DISPLAY:
 912             if (defaultDisplayLocale == null) {
 913                 synchronized(Locale.class) {
 914                     if (defaultDisplayLocale == null) {
 915                         defaultDisplayLocale = initDefault(category);
 916                     }
 917                 }
 918             }
 919             return defaultDisplayLocale;
 920         case FORMAT:
 921             if (defaultFormatLocale == null) {
 922                 synchronized(Locale.class) {
 923                     if (defaultFormatLocale == null) {
 924                         defaultFormatLocale = initDefault(category);
 925                     }
 926                 }
 927             }
 928             return defaultFormatLocale;
 929         default:
 930             assert false: &quot;Unknown Category&quot;;
 931         }
 932         return getDefault();
 933     }
 934 
 935     private static Locale initDefault() {
 936         String language, region, script, country, variant;
 937         Properties props = GetPropertyAction.privilegedGetProperties();
 938         language = props.getProperty(&quot;user.language&quot;, &quot;en&quot;);
 939         // for compatibility, check for old user.region property
 940         region = props.getProperty(&quot;user.region&quot;);
 941         if (region != null) {
 942             // region can be of form country, country_variant, or _variant
 943             int i = region.indexOf(&#39;_&#39;);
 944             if (i &gt;= 0) {
 945                 country = region.substring(0, i);
 946                 variant = region.substring(i + 1);
 947             } else {
 948                 country = region;
 949                 variant = &quot;&quot;;
 950             }
 951             script = &quot;&quot;;
 952         } else {
 953             script = props.getProperty(&quot;user.script&quot;, &quot;&quot;);
 954             country = props.getProperty(&quot;user.country&quot;, &quot;&quot;);
 955             variant = props.getProperty(&quot;user.variant&quot;, &quot;&quot;);
 956         }
 957 
 958         return getInstance(language, script, country, variant,
 959                 getDefaultExtensions(props.getProperty(&quot;user.extensions&quot;, &quot;&quot;))
 960                     .orElse(null));
 961     }
 962 
 963     private static Locale initDefault(Locale.Category category) {
 964         Properties props = GetPropertyAction.privilegedGetProperties();
 965 
 966         return getInstance(
 967             props.getProperty(category.languageKey,
 968                     defaultLocale.getLanguage()),
 969             props.getProperty(category.scriptKey,
 970                     defaultLocale.getScript()),
 971             props.getProperty(category.countryKey,
 972                     defaultLocale.getCountry()),
 973             props.getProperty(category.variantKey,
 974                     defaultLocale.getVariant()),
 975             getDefaultExtensions(props.getProperty(category.extensionsKey, &quot;&quot;))
 976                 .orElse(defaultLocale.getLocaleExtensions()));
 977     }
 978 
 979     private static Optional&lt;LocaleExtensions&gt; getDefaultExtensions(String extensionsProp) {
<a name="90" id="anc90"></a><span class="line-modified"> 980         LocaleExtensions exts = null;</span>


 981 
<a name="91" id="anc91"></a>
 982         try {
 983             exts = new InternalLocaleBuilder()
 984                 .setExtensions(extensionsProp)
 985                 .getLocaleExtensions();
 986         } catch (LocaleSyntaxException e) {
 987             // just ignore this incorrect property
 988         }
 989 
 990         return Optional.ofNullable(exts);
 991     }
 992 
 993     /**
 994      * Sets the default locale for this instance of the Java Virtual Machine.
 995      * This does not affect the host locale.
 996      * &lt;p&gt;
<a name="92" id="anc92"></a><span class="line-modified"> 997      * If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;</span>
<span class="line-modified"> 998      * method is called with a &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt;</span>
 999      * permission before the default locale is changed.
1000      * &lt;p&gt;
1001      * The Java Virtual Machine sets the default locale during startup
1002      * based on the host environment. It is used by many locale-sensitive
1003      * methods if no locale is explicitly specified.
1004      * &lt;p&gt;
1005      * Since changing the default locale may affect many different areas
1006      * of functionality, this method should only be used if the caller
1007      * is prepared to reinitialize locale-sensitive code running
1008      * within the same Java Virtual Machine.
1009      * &lt;p&gt;
1010      * By setting the default locale with this method, all of the default
1011      * locales for each Category are also set to the specified default locale.
1012      *
1013      * @throws SecurityException
1014      *        if a security manager exists and its
<a name="93" id="anc93"></a><span class="line-modified">1015      *        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow the operation.</span>
<span class="line-modified">1016      * @throws NullPointerException if &lt;code&gt;newLocale&lt;/code&gt; is null</span>
1017      * @param newLocale the new default locale
1018      * @see SecurityManager#checkPermission
1019      * @see java.util.PropertyPermission
1020      */
1021     public static synchronized void setDefault(Locale newLocale) {
1022         setDefault(Category.DISPLAY, newLocale);
1023         setDefault(Category.FORMAT, newLocale);
1024         defaultLocale = newLocale;
1025     }
1026 
1027     /**
1028      * Sets the default locale for the specified Category for this instance
1029      * of the Java Virtual Machine. This does not affect the host locale.
1030      * &lt;p&gt;
1031      * If there is a security manager, its checkPermission method is called
1032      * with a PropertyPermission(&quot;user.language&quot;, &quot;write&quot;) permission before
1033      * the default locale is changed.
1034      * &lt;p&gt;
1035      * The Java Virtual Machine sets the default locale during startup based
1036      * on the host environment. It is used by many locale-sensitive methods
1037      * if no locale is explicitly specified.
1038      * &lt;p&gt;
1039      * Since changing the default locale may affect many different areas of
1040      * functionality, this method should only be used if the caller is
1041      * prepared to reinitialize locale-sensitive code running within the
1042      * same Java Virtual Machine.
1043      *
<a name="94" id="anc94"></a><span class="line-modified">1044      * @param category - the specified category to set the default locale</span>
<span class="line-modified">1045      * @param newLocale - the new default locale</span>
1046      * @throws SecurityException if a security manager exists and its
1047      *     checkPermission method doesn&#39;t allow the operation.
1048      * @throws NullPointerException if category and/or newLocale is null
1049      * @see SecurityManager#checkPermission(java.security.Permission)
1050      * @see PropertyPermission
1051      * @see #getDefault(Locale.Category)
1052      * @since 1.7
1053      */
1054     public static synchronized void setDefault(Locale.Category category,
1055         Locale newLocale) {
1056         if (category == null)
1057             throw new NullPointerException(&quot;Category cannot be NULL&quot;);
1058         if (newLocale == null)
1059             throw new NullPointerException(&quot;Can&#39;t set default locale to NULL&quot;);
1060 
1061         SecurityManager sm = System.getSecurityManager();
1062         if (sm != null) sm.checkPermission(new PropertyPermission
1063                         (&quot;user.language&quot;, &quot;write&quot;));
1064         switch (category) {
1065         case DISPLAY:
1066             defaultDisplayLocale = newLocale;
1067             break;
1068         case FORMAT:
1069             defaultFormatLocale = newLocale;
1070             break;
1071         default:
1072             assert false: &quot;Unknown Category&quot;;
1073         }
1074     }
1075 
1076     /**
1077      * Returns an array of all installed locales.
1078      * The returned array represents the union of locales supported
1079      * by the Java runtime environment and by installed
1080      * {@link java.util.spi.LocaleServiceProvider LocaleServiceProvider}
<a name="95" id="anc95"></a><span class="line-modified">1081      * implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;</span>
1082      * instance equal to {@link java.util.Locale#US Locale.US}.
1083      *
1084      * @return An array of installed locales.
1085      */
1086     public static Locale[] getAvailableLocales() {
1087         return LocaleServiceProviderPool.getAllAvailableLocales();
1088     }
1089 
1090     /**
1091      * Returns a list of all 2-letter country codes defined in ISO 3166.
1092      * Can be used to create Locales.
1093      * This method is equivalent to {@link #getISOCountries(Locale.IsoCountryCode type)}
1094      * with {@code type}  {@link IsoCountryCode#PART1_ALPHA2}.
1095      * &lt;p&gt;
<a name="96" id="anc96"></a><span class="line-modified">1096      * &lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;Locale&lt;/code&gt; class also supports other codes for</span>
1097      * country (region), such as 3-letter numeric UN M.49 area codes.
1098      * Therefore, the list returned by this method does not contain ALL valid
1099      * codes that can be used to create Locales.
1100      * &lt;p&gt;
1101      * Note that this method does not return obsolete 2-letter country codes.
1102      * ISO3166-3 codes which designate country codes for those obsolete codes,
1103      * can be retrieved from {@link #getISOCountries(Locale.IsoCountryCode type)} with
1104      * {@code type}  {@link IsoCountryCode#PART3}.
1105      * @return An array of ISO 3166 two-letter country codes.
1106      */
1107     public static String[] getISOCountries() {
1108         if (isoCountries == null) {
1109             isoCountries = getISO2Table(LocaleISOData.isoCountryTable);
1110         }
1111         String[] result = new String[isoCountries.length];
1112         System.arraycopy(isoCountries, 0, result, 0, isoCountries.length);
1113         return result;
1114     }
1115 
1116     /**
1117      * Returns a {@code Set} of ISO3166 country codes for the specified type.
1118      *
1119      * @param type {@link Locale.IsoCountryCode} specified ISO code type.
1120      * @see java.util.Locale.IsoCountryCode
1121      * @throws NullPointerException if type is null
1122      * @return a {@code Set} of ISO country codes for the specified type.
1123      * @since 9
1124      */
1125     public static Set&lt;String&gt; getISOCountries(IsoCountryCode type) {
1126         Objects.requireNonNull(type);
1127         return IsoCountryCode.retrieveISOCountryCodes(type);
1128     }
1129 
1130     /**
1131      * Returns a list of all 2-letter language codes defined in ISO 639.
1132      * Can be used to create Locales.
1133      * &lt;p&gt;
1134      * &lt;b&gt;Note:&lt;/b&gt;
1135      * &lt;ul&gt;
1136      * &lt;li&gt;ISO 639 is not a stable standard&amp;mdash; some languages&#39; codes have changed.
1137      * The list this function returns includes both the new and the old codes for the
1138      * languages whose codes have changed.
<a name="97" id="anc97"></a><span class="line-modified">1139      * &lt;li&gt;The &lt;code&gt;Locale&lt;/code&gt; class also supports language codes up to</span>
1140      * 8 characters in length.  Therefore, the list returned by this method does
1141      * not contain ALL valid codes that can be used to create Locales.
1142      * &lt;/ul&gt;
1143      *
1144      * @return An array of ISO 639 two-letter language codes.
1145      */
1146     public static String[] getISOLanguages() {
1147         if (isoLanguages == null) {
1148             isoLanguages = getISO2Table(LocaleISOData.isoLanguageTable);
1149         }
1150         String[] result = new String[isoLanguages.length];
1151         System.arraycopy(isoLanguages, 0, result, 0, isoLanguages.length);
1152         return result;
1153     }
1154 
1155     private static String[] getISO2Table(String table) {
1156         int len = table.length() / 5;
1157         String[] isoTable = new String[len];
1158         for (int i = 0, j = 0; i &lt; len; i++, j += 5) {
1159             isoTable[i] = table.substring(j, j + 2);
1160         }
1161         return isoTable;
1162     }
1163 
1164     /**
1165      * Returns the language code of this Locale.
1166      *
1167      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; ISO 639 is not a stable standard&amp;mdash; some languages&#39; codes have changed.
1168      * Locale&#39;s constructor recognizes both the new and the old codes for the languages
1169      * whose codes have changed, but this function always returns the old code.  If you
1170      * want to check for a specific language whose code has changed, don&#39;t do
1171      * &lt;pre&gt;
1172      * if (locale.getLanguage().equals(&quot;he&quot;)) // BAD!
1173      *    ...
1174      * &lt;/pre&gt;
1175      * Instead, do
1176      * &lt;pre&gt;
1177      * if (locale.getLanguage().equals(new Locale(&quot;he&quot;).getLanguage()))
1178      *    ...
1179      * &lt;/pre&gt;
1180      * @return The language code, or the empty string if none is defined.
1181      * @see #getDisplayLanguage
1182      */
1183     public String getLanguage() {
1184         return baseLocale.getLanguage();
1185     }
1186 
1187     /**
1188      * Returns the script for this locale, which should
1189      * either be the empty string or an ISO 15924 4-letter script
1190      * code. The first letter is uppercase and the rest are
1191      * lowercase, for example, &#39;Latn&#39;, &#39;Cyrl&#39;.
1192      *
1193      * @return The script code, or the empty string if none is defined.
1194      * @see #getDisplayScript
1195      * @since 1.7
1196      */
1197     public String getScript() {
1198         return baseLocale.getScript();
1199     }
1200 
1201     /**
1202      * Returns the country/region code for this locale, which should
1203      * either be the empty string, an uppercase ISO 3166 2-letter code,
1204      * or a UN M.49 3-digit code.
1205      *
1206      * @return The country/region code, or the empty string if none is defined.
1207      * @see #getDisplayCountry
1208      */
1209     public String getCountry() {
1210         return baseLocale.getRegion();
1211     }
1212 
1213     /**
1214      * Returns the variant code for this locale.
1215      *
1216      * @return The variant code, or the empty string if none is defined.
1217      * @see #getDisplayVariant
1218      */
1219     public String getVariant() {
1220         return baseLocale.getVariant();
1221     }
1222 
1223     /**
1224      * Returns {@code true} if this {@code Locale} has any &lt;a href=&quot;#def_extensions&quot;&gt;
1225      * extensions&lt;/a&gt;.
1226      *
1227      * @return {@code true} if this {@code Locale} has any extensions
1228      * @since 1.8
1229      */
1230     public boolean hasExtensions() {
1231         return localeExtensions != null;
1232     }
1233 
1234     /**
1235      * Returns a copy of this {@code Locale} with no &lt;a href=&quot;#def_extensions&quot;&gt;
1236      * extensions&lt;/a&gt;. If this {@code Locale} has no extensions, this {@code Locale}
1237      * is returned.
1238      *
1239      * @return a copy of this {@code Locale} with no extensions, or {@code this}
1240      *         if {@code this} has no extensions
1241      * @since 1.8
1242      */
1243     public Locale stripExtensions() {
1244         return hasExtensions() ? Locale.getInstance(baseLocale, null) : this;
1245     }
1246 
1247     /**
1248      * Returns the extension (or private use) value associated with
1249      * the specified key, or null if there is no extension
1250      * associated with the key. To be well-formed, the key must be one
<a name="98" id="anc98"></a><span class="line-modified">1251      * of &lt;code&gt;[0-9A-Za-z]&lt;/code&gt;. Keys are case-insensitive, so</span>
1252      * for example &#39;z&#39; and &#39;Z&#39; represent the same extension.
1253      *
1254      * @param key the extension key
1255      * @return The extension, or null if this locale defines no
1256      * extension for the specified key.
1257      * @throws IllegalArgumentException if key is not well-formed
1258      * @see #PRIVATE_USE_EXTENSION
1259      * @see #UNICODE_LOCALE_EXTENSION
1260      * @since 1.7
1261      */
1262     public String getExtension(char key) {
1263         if (!LocaleExtensions.isValidKey(key)) {
1264             throw new IllegalArgumentException(&quot;Ill-formed extension key: &quot; + key);
1265         }
1266         return hasExtensions() ? localeExtensions.getExtensionValue(key) : null;
1267     }
1268 
1269     /**
1270      * Returns the set of extension keys associated with this locale, or the
1271      * empty set if it has no extensions. The returned set is unmodifiable.
1272      * The keys will all be lower-case.
1273      *
1274      * @return The set of extension keys, or the empty set if this locale has
1275      * no extensions.
1276      * @since 1.7
1277      */
1278     public Set&lt;Character&gt; getExtensionKeys() {
1279         if (!hasExtensions()) {
1280             return Collections.emptySet();
1281         }
1282         return localeExtensions.getKeys();
1283     }
1284 
1285     /**
1286      * Returns the set of unicode locale attributes associated with
1287      * this locale, or the empty set if it has no attributes. The
1288      * returned set is unmodifiable.
1289      *
1290      * @return The set of attributes.
1291      * @since 1.7
1292      */
1293     public Set&lt;String&gt; getUnicodeLocaleAttributes() {
1294         if (!hasExtensions()) {
1295             return Collections.emptySet();
1296         }
1297         return localeExtensions.getUnicodeLocaleAttributes();
1298     }
1299 
1300     /**
1301      * Returns the Unicode locale type associated with the specified Unicode locale key
1302      * for this locale. Returns the empty string for keys that are defined with no type.
1303      * Returns null if the key is not defined. Keys are case-insensitive. The key must
1304      * be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is
1305      * thrown.
1306      *
1307      * @param key the Unicode locale key
1308      * @return The Unicode locale type associated with the key, or null if the
1309      * locale does not define the key.
1310      * @throws IllegalArgumentException if the key is not well-formed
<a name="99" id="anc99"></a><span class="line-modified">1311      * @throws NullPointerException if &lt;code&gt;key&lt;/code&gt; is null</span>
1312      * @since 1.7
1313      */
1314     public String getUnicodeLocaleType(String key) {
1315         if (!isUnicodeExtensionKey(key)) {
1316             throw new IllegalArgumentException(&quot;Ill-formed Unicode locale key: &quot; + key);
1317         }
1318         return hasExtensions() ? localeExtensions.getUnicodeLocaleType(key) : null;
1319     }
1320 
1321     /**
1322      * Returns the set of Unicode locale keys defined by this locale, or the empty set if
1323      * this locale has none.  The returned set is immutable.  Keys are all lower case.
1324      *
1325      * @return The set of Unicode locale keys, or the empty set if this locale has
1326      * no Unicode locale keywords.
1327      * @since 1.7
1328      */
1329     public Set&lt;String&gt; getUnicodeLocaleKeys() {
1330         if (localeExtensions == null) {
1331             return Collections.emptySet();
1332         }
1333         return localeExtensions.getUnicodeLocaleKeys();
1334     }
1335 
1336     /**
1337      * Package locale method returning the Locale&#39;s BaseLocale,
1338      * used by ResourceBundle
1339      * @return base locale of this Locale
1340      */
1341     BaseLocale getBaseLocale() {
1342         return baseLocale;
1343     }
1344 
1345     /**
1346      * Package private method returning the Locale&#39;s LocaleExtensions,
1347      * used by ResourceBundle.
1348      * @return locale extensions of this Locale,
1349      *         or {@code null} if no extensions are defined
1350      */
1351      LocaleExtensions getLocaleExtensions() {
1352          return localeExtensions;
1353      }
1354 
1355     /**
<a name="100" id="anc100"></a><span class="line-modified">1356      * Returns a string representation of this &lt;code&gt;Locale&lt;/code&gt;</span>
1357      * object, consisting of language, country, variant, script,
1358      * and extensions as below:
1359      * &lt;blockquote&gt;
1360      * language + &quot;_&quot; + country + &quot;_&quot; + (variant + &quot;_#&quot; | &quot;#&quot;) + script + &quot;_&quot; + extensions
1361      * &lt;/blockquote&gt;
1362      *
1363      * Language is always lower case, country is always upper case, script is always title
1364      * case, and extensions are always lower case.  Extensions and private use subtags
1365      * will be in canonical order as explained in {@link #toLanguageTag}.
1366      *
1367      * &lt;p&gt;When the locale has neither script nor extensions, the result is the same as in
1368      * Java 6 and prior.
1369      *
1370      * &lt;p&gt;If both the language and country fields are missing, this function will return
1371      * the empty string, even if the variant, script, or extensions field is present (you
1372      * can&#39;t have a locale with just a variant, the variant must accompany a well-formed
1373      * language or country code).
1374      *
1375      * &lt;p&gt;If script or extensions are present and variant is missing, no underscore is
1376      * added before the &quot;#&quot;.
1377      *
1378      * &lt;p&gt;This behavior is designed to support debugging and to be compatible with
<a name="101" id="anc101"></a><span class="line-modified">1379      * previous uses of &lt;code&gt;toString&lt;/code&gt; that expected language, country, and variant</span>
1380      * fields only.  To represent a Locale as a String for interchange purposes, use
1381      * {@link #toLanguageTag}.
1382      *
1383      * &lt;p&gt;Examples: &lt;ul&gt;
1384      * &lt;li&gt;{@code en}&lt;/li&gt;
1385      * &lt;li&gt;{@code de_DE}&lt;/li&gt;
1386      * &lt;li&gt;{@code _GB}&lt;/li&gt;
1387      * &lt;li&gt;{@code en_US_WIN}&lt;/li&gt;
1388      * &lt;li&gt;{@code de__POSIX}&lt;/li&gt;
1389      * &lt;li&gt;{@code zh_CN_#Hans}&lt;/li&gt;
1390      * &lt;li&gt;{@code zh_TW_#Hant_x-java}&lt;/li&gt;
1391      * &lt;li&gt;{@code th_TH_TH_#u-nu-thai}&lt;/li&gt;&lt;/ul&gt;
1392      *
1393      * @return A string representation of the Locale, for debugging.
1394      * @see #getDisplayName
1395      * @see #toLanguageTag
1396      */
1397     @Override
1398     public final String toString() {
1399         boolean l = !baseLocale.getLanguage().isEmpty();
1400         boolean s = !baseLocale.getScript().isEmpty();
1401         boolean r = !baseLocale.getRegion().isEmpty();
1402         boolean v = !baseLocale.getVariant().isEmpty();
1403         boolean e = localeExtensions != null &amp;&amp; !localeExtensions.getID().isEmpty();
1404 
1405         StringBuilder result = new StringBuilder(baseLocale.getLanguage());
1406         if (r || (l &amp;&amp; (v || s || e))) {
1407             result.append(&#39;_&#39;)
1408                 .append(baseLocale.getRegion()); // This may just append &#39;_&#39;
1409         }
1410         if (v &amp;&amp; (l || r)) {
1411             result.append(&#39;_&#39;)
1412                 .append(baseLocale.getVariant());
1413         }
1414 
1415         if (s &amp;&amp; (l || r)) {
1416             result.append(&quot;_#&quot;)
1417                 .append(baseLocale.getScript());
1418         }
1419 
1420         if (e &amp;&amp; (l || r)) {
1421             result.append(&#39;_&#39;);
1422             if (!s) {
1423                 result.append(&#39;#&#39;);
1424             }
1425             result.append(localeExtensions.getID());
1426         }
1427 
1428         return result.toString();
1429     }
1430 
1431     /**
1432      * Returns a well-formed IETF BCP 47 language tag representing
1433      * this locale.
1434      *
<a name="102" id="anc102"></a><span class="line-modified">1435      * &lt;p&gt;If this &lt;code&gt;Locale&lt;/code&gt; has a language, country, or</span>
1436      * variant that does not satisfy the IETF BCP 47 language tag
1437      * syntax requirements, this method handles these fields as
1438      * described below:
1439      *
1440      * &lt;p&gt;&lt;b&gt;Language:&lt;/b&gt; If language is empty, or not &lt;a
1441      * href=&quot;#def_language&quot; &gt;well-formed&lt;/a&gt; (for example &quot;a&quot; or
1442      * &quot;e2&quot;), it will be emitted as &quot;und&quot; (Undetermined).
1443      *
1444      * &lt;p&gt;&lt;b&gt;Country:&lt;/b&gt; If country is not &lt;a
1445      * href=&quot;#def_region&quot;&gt;well-formed&lt;/a&gt; (for example &quot;12&quot; or &quot;USA&quot;),
1446      * it will be omitted.
1447      *
1448      * &lt;p&gt;&lt;b&gt;Variant:&lt;/b&gt; If variant &lt;b&gt;is&lt;/b&gt; &lt;a
1449      * href=&quot;#def_variant&quot;&gt;well-formed&lt;/a&gt;, each sub-segment
1450      * (delimited by &#39;-&#39; or &#39;_&#39;) is emitted as a subtag.  Otherwise:
1451      * &lt;ul&gt;
1452      *
1453      * &lt;li&gt;if all sub-segments match &lt;code&gt;[0-9a-zA-Z]{1,8}&lt;/code&gt;
1454      * (for example &quot;WIN&quot; or &quot;Oracle_JDK_Standard_Edition&quot;), the first
1455      * ill-formed sub-segment and all following will be appended to
1456      * the private use subtag.  The first appended subtag will be
1457      * &quot;lvariant&quot;, followed by the sub-segments in order, separated by
1458      * hyphen. For example, &quot;x-lvariant-WIN&quot;,
1459      * &quot;Oracle-x-lvariant-JDK-Standard-Edition&quot;.
1460      *
1461      * &lt;li&gt;if any sub-segment does not match
1462      * &lt;code&gt;[0-9a-zA-Z]{1,8}&lt;/code&gt;, the variant will be truncated
1463      * and the problematic sub-segment and all following sub-segments
1464      * will be omitted.  If the remainder is non-empty, it will be
1465      * emitted as a private use subtag as above (even if the remainder
1466      * turns out to be well-formed).  For example,
1467      * &quot;Solaris_isjustthecoolestthing&quot; is emitted as
1468      * &quot;x-lvariant-Solaris&quot;, not as &quot;solaris&quot;.&lt;/li&gt;&lt;/ul&gt;
1469      *
1470      * &lt;p&gt;&lt;b&gt;Special Conversions:&lt;/b&gt; Java supports some old locale
1471      * representations, including deprecated ISO language codes,
1472      * for compatibility. This method performs the following
1473      * conversions:
1474      * &lt;ul&gt;
1475      *
1476      * &lt;li&gt;Deprecated ISO language codes &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot; are
1477      * converted to &quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;, respectively.
1478      *
1479      * &lt;li&gt;A locale with language &quot;no&quot;, country &quot;NO&quot;, and variant
1480      * &quot;NY&quot;, representing Norwegian Nynorsk (Norway), is converted
1481      * to a language tag &quot;nn-NO&quot;.&lt;/li&gt;&lt;/ul&gt;
1482      *
1483      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; Although the language tag created by this
1484      * method is well-formed (satisfies the syntax requirements
1485      * defined by the IETF BCP 47 specification), it is not
1486      * necessarily a valid BCP 47 language tag.  For example,
1487      * &lt;pre&gt;
1488      *   new Locale(&quot;xx&quot;, &quot;YY&quot;).toLanguageTag();&lt;/pre&gt;
1489      *
1490      * will return &quot;xx-YY&quot;, but the language subtag &quot;xx&quot; and the
1491      * region subtag &quot;YY&quot; are invalid because they are not registered
1492      * in the IANA Language Subtag Registry.
1493      *
1494      * @return a BCP47 language tag representing the locale
1495      * @see #forLanguageTag(String)
1496      * @since 1.7
1497      */
1498     public String toLanguageTag() {
1499         if (languageTag != null) {
1500             return languageTag;
1501         }
1502 
1503         LanguageTag tag = LanguageTag.parseLocale(baseLocale, localeExtensions);
1504         StringBuilder buf = new StringBuilder();
1505 
1506         String subtag = tag.getLanguage();
1507         if (!subtag.isEmpty()) {
1508             buf.append(LanguageTag.canonicalizeLanguage(subtag));
1509         }
1510 
1511         subtag = tag.getScript();
1512         if (!subtag.isEmpty()) {
1513             buf.append(LanguageTag.SEP);
1514             buf.append(LanguageTag.canonicalizeScript(subtag));
1515         }
1516 
1517         subtag = tag.getRegion();
1518         if (!subtag.isEmpty()) {
1519             buf.append(LanguageTag.SEP);
1520             buf.append(LanguageTag.canonicalizeRegion(subtag));
1521         }
1522 
1523         List&lt;String&gt;subtags = tag.getVariants();
1524         for (String s : subtags) {
1525             buf.append(LanguageTag.SEP);
1526             // preserve casing
1527             buf.append(s);
1528         }
1529 
1530         subtags = tag.getExtensions();
1531         for (String s : subtags) {
1532             buf.append(LanguageTag.SEP);
1533             buf.append(LanguageTag.canonicalizeExtension(s));
1534         }
1535 
1536         subtag = tag.getPrivateuse();
1537         if (!subtag.isEmpty()) {
1538             if (buf.length() &gt; 0) {
1539                 buf.append(LanguageTag.SEP);
1540             }
1541             buf.append(LanguageTag.PRIVATEUSE).append(LanguageTag.SEP);
1542             // preserve casing
1543             buf.append(subtag);
1544         }
1545 
1546         String langTag = buf.toString();
1547         synchronized (this) {
1548             if (languageTag == null) {
1549                 languageTag = langTag;
1550             }
1551         }
1552         return languageTag;
1553     }
1554 
1555     /**
1556      * Returns a locale for the specified IETF BCP 47 language tag string.
1557      *
1558      * &lt;p&gt;If the specified language tag contains any ill-formed subtags,
1559      * the first such subtag and all following subtags are ignored.  Compare
1560      * to {@link Locale.Builder#setLanguageTag} which throws an exception
1561      * in this case.
1562      *
1563      * &lt;p&gt;The following &lt;b&gt;conversions&lt;/b&gt; are performed:&lt;ul&gt;
1564      *
1565      * &lt;li&gt;The language code &quot;und&quot; is mapped to language &quot;&quot;.
1566      *
1567      * &lt;li&gt;The language codes &quot;he&quot;, &quot;yi&quot;, and &quot;id&quot; are mapped to &quot;iw&quot;,
1568      * &quot;ji&quot;, and &quot;in&quot; respectively. (This is the same canonicalization
1569      * that&#39;s done in Locale&#39;s constructors.)
1570      *
1571      * &lt;li&gt;The portion of a private use subtag prefixed by &quot;lvariant&quot;,
1572      * if any, is removed and appended to the variant field in the
1573      * result locale (without case normalization).  If it is then
1574      * empty, the private use subtag is discarded:
1575      *
1576      * &lt;pre&gt;
1577      *     Locale loc;
1578      *     loc = Locale.forLanguageTag(&quot;en-US-x-lvariant-POSIX&quot;);
1579      *     loc.getVariant(); // returns &quot;POSIX&quot;
1580      *     loc.getExtension(&#39;x&#39;); // returns null
1581      *
1582      *     loc = Locale.forLanguageTag(&quot;de-POSIX-x-URP-lvariant-Abc-Def&quot;);
1583      *     loc.getVariant(); // returns &quot;POSIX_Abc_Def&quot;
1584      *     loc.getExtension(&#39;x&#39;); // returns &quot;urp&quot;
1585      * &lt;/pre&gt;
1586      *
1587      * &lt;li&gt;When the languageTag argument contains an extlang subtag,
1588      * the first such subtag is used as the language, and the primary
1589      * language subtag and other extlang subtags are ignored:
1590      *
1591      * &lt;pre&gt;
1592      *     Locale.forLanguageTag(&quot;ar-aao&quot;).getLanguage(); // returns &quot;aao&quot;
1593      *     Locale.forLanguageTag(&quot;en-abc-def-us&quot;).toString(); // returns &quot;abc_US&quot;
1594      * &lt;/pre&gt;
1595      *
1596      * &lt;li&gt;Case is normalized except for variant tags, which are left
1597      * unchanged.  Language is normalized to lower case, script to
1598      * title case, country to upper case, and extensions to lower
1599      * case.
1600      *
1601      * &lt;li&gt;If, after processing, the locale would exactly match either
1602      * ja_JP_JP or th_TH_TH with no extensions, the appropriate
1603      * extensions are added as though the constructor had been called:
1604      *
1605      * &lt;pre&gt;
1606      *    Locale.forLanguageTag(&quot;ja-JP-x-lvariant-JP&quot;).toLanguageTag();
1607      *    // returns &quot;ja-JP-u-ca-japanese-x-lvariant-JP&quot;
1608      *    Locale.forLanguageTag(&quot;th-TH-x-lvariant-TH&quot;).toLanguageTag();
1609      *    // returns &quot;th-TH-u-nu-thai-x-lvariant-TH&quot;
1610      * &lt;/pre&gt;&lt;/ul&gt;
1611      *
1612      * &lt;p&gt;This implements the &#39;Language-Tag&#39; production of BCP47, and
1613      * so supports grandfathered (regular and irregular) as well as
1614      * private use language tags.  Stand alone private use tags are
1615      * represented as empty language and extension &#39;x-whatever&#39;,
1616      * and grandfathered tags are converted to their canonical replacements
1617      * where they exist.
1618      *
1619      * &lt;p&gt;Grandfathered tags with canonical replacements are as follows:
1620      *
1621      * &lt;table class=&quot;striped&quot;&gt;
1622      * &lt;caption style=&quot;display:none&quot;&gt;Grandfathered tags with canonical replacements&lt;/caption&gt;
1623      * &lt;thead style=&quot;text-align:center&quot;&gt;
1624      * &lt;tr&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;grandfathered tag&lt;/th&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;modern replacement&lt;/th&gt;&lt;/tr&gt;
1625      * &lt;/thead&gt;
1626      * &lt;tbody style=&quot;text-align:center&quot;&gt;
1627      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;art-lojban&lt;/th&gt;&lt;td&gt;jbo&lt;/td&gt;&lt;/tr&gt;
1628      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-ami&lt;/th&gt;&lt;td&gt;ami&lt;/td&gt;&lt;/tr&gt;
1629      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-bnn&lt;/th&gt;&lt;td&gt;bnn&lt;/td&gt;&lt;/tr&gt;
1630      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-hak&lt;/th&gt;&lt;td&gt;hak&lt;/td&gt;&lt;/tr&gt;
1631      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-klingon&lt;/th&gt;&lt;td&gt;tlh&lt;/td&gt;&lt;/tr&gt;
1632      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-lux&lt;/th&gt;&lt;td&gt;lb&lt;/td&gt;&lt;/tr&gt;
1633      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-navajo&lt;/th&gt;&lt;td&gt;nv&lt;/td&gt;&lt;/tr&gt;
1634      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-pwn&lt;/th&gt;&lt;td&gt;pwn&lt;/td&gt;&lt;/tr&gt;
1635      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-tao&lt;/th&gt;&lt;td&gt;tao&lt;/td&gt;&lt;/tr&gt;
1636      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-tay&lt;/th&gt;&lt;td&gt;tay&lt;/td&gt;&lt;/tr&gt;
1637      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-tsu&lt;/th&gt;&lt;td&gt;tsu&lt;/td&gt;&lt;/tr&gt;
1638      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;no-bok&lt;/th&gt;&lt;td&gt;nb&lt;/td&gt;&lt;/tr&gt;
1639      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;no-nyn&lt;/th&gt;&lt;td&gt;nn&lt;/td&gt;&lt;/tr&gt;
1640      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;sgn-BE-FR&lt;/th&gt;&lt;td&gt;sfb&lt;/td&gt;&lt;/tr&gt;
1641      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;sgn-BE-NL&lt;/th&gt;&lt;td&gt;vgt&lt;/td&gt;&lt;/tr&gt;
1642      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;sgn-CH-DE&lt;/th&gt;&lt;td&gt;sgg&lt;/td&gt;&lt;/tr&gt;
1643      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-guoyu&lt;/th&gt;&lt;td&gt;cmn&lt;/td&gt;&lt;/tr&gt;
1644      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-hakka&lt;/th&gt;&lt;td&gt;hak&lt;/td&gt;&lt;/tr&gt;
1645      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-min-nan&lt;/th&gt;&lt;td&gt;nan&lt;/td&gt;&lt;/tr&gt;
1646      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-xiang&lt;/th&gt;&lt;td&gt;hsn&lt;/td&gt;&lt;/tr&gt;
1647      * &lt;/tbody&gt;
1648      * &lt;/table&gt;
1649      *
1650      * &lt;p&gt;Grandfathered tags with no modern replacement will be
1651      * converted as follows:
1652      *
1653      * &lt;table class=&quot;striped&quot;&gt;
1654      * &lt;caption style=&quot;display:none&quot;&gt;Grandfathered tags with no modern replacement&lt;/caption&gt;
1655      * &lt;thead style=&quot;text-align:center&quot;&gt;
1656      * &lt;tr&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;grandfathered tag&lt;/th&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;converts to&lt;/th&gt;&lt;/tr&gt;
1657      * &lt;/thead&gt;
1658      * &lt;tbody style=&quot;text-align:center&quot;&gt;
1659      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;cel-gaulish&lt;/th&gt;&lt;td&gt;xtg-x-cel-gaulish&lt;/td&gt;&lt;/tr&gt;
1660      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;en-GB-oed&lt;/th&gt;&lt;td&gt;en-GB-x-oed&lt;/td&gt;&lt;/tr&gt;
1661      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-default&lt;/th&gt;&lt;td&gt;en-x-i-default&lt;/td&gt;&lt;/tr&gt;
1662      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-enochian&lt;/th&gt;&lt;td&gt;und-x-i-enochian&lt;/td&gt;&lt;/tr&gt;
1663      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-mingo&lt;/th&gt;&lt;td&gt;see-x-i-mingo&lt;/td&gt;&lt;/tr&gt;
1664      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-min&lt;/th&gt;&lt;td&gt;nan-x-zh-min&lt;/td&gt;&lt;/tr&gt;
1665      * &lt;/tbody&gt;
1666      * &lt;/table&gt;
1667      *
1668      * &lt;p&gt;For a list of all grandfathered tags, see the
1669      * IANA Language Subtag Registry (search for &quot;Type: grandfathered&quot;).
1670      *
<a name="103" id="anc103"></a><span class="line-modified">1671      * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: there is no guarantee that &lt;code&gt;toLanguageTag&lt;/code&gt;</span>
<span class="line-modified">1672      * and &lt;code&gt;forLanguageTag&lt;/code&gt; will round-trip.</span>
1673      *
1674      * @param languageTag the language tag
1675      * @return The locale that best represents the language tag.
<a name="104" id="anc104"></a><span class="line-modified">1676      * @throws NullPointerException if &lt;code&gt;languageTag&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1677      * @see #toLanguageTag()
1678      * @see java.util.Locale.Builder#setLanguageTag(String)
1679      * @since 1.7
1680      */
1681     public static Locale forLanguageTag(String languageTag) {
1682         LanguageTag tag = LanguageTag.parse(languageTag, null);
1683         InternalLocaleBuilder bldr = new InternalLocaleBuilder();
1684         bldr.setLanguageTag(tag);
1685         BaseLocale base = bldr.getBaseLocale();
1686         LocaleExtensions exts = bldr.getLocaleExtensions();
1687         if (exts == null &amp;&amp; !base.getVariant().isEmpty()) {
1688             exts = getCompatibilityExtensions(base.getLanguage(), base.getScript(),
1689                                               base.getRegion(), base.getVariant());
1690         }
1691         return getInstance(base, exts);
1692     }
1693 
1694     /**
1695      * Returns a three-letter abbreviation of this locale&#39;s language.
1696      * If the language matches an ISO 639-1 two-letter code, the
1697      * corresponding ISO 639-2/T three-letter lowercase code is
1698      * returned.  The ISO 639-2 language codes can be found on-line,
1699      * see &quot;Codes for the Representation of Names of Languages Part 2:
1700      * Alpha-3 Code&quot;.  If the locale specifies a three-letter
1701      * language, the language is returned as is.  If the locale does
1702      * not specify a language the empty string is returned.
1703      *
1704      * @return A three-letter abbreviation of this locale&#39;s language.
<a name="105" id="anc105"></a><span class="line-modified">1705      * @exception MissingResourceException Throws MissingResourceException if</span>
1706      * three-letter language abbreviation is not available for this locale.
1707      */
1708     public String getISO3Language() throws MissingResourceException {
1709         String lang = baseLocale.getLanguage();
1710         if (lang.length() == 3) {
1711             return lang;
1712         }
1713 
1714         String language3 = getISO3Code(lang, LocaleISOData.isoLanguageTable);
1715         if (language3 == null) {
1716             throw new MissingResourceException(&quot;Couldn&#39;t find 3-letter language code for &quot;
1717                     + lang, &quot;FormatData_&quot; + toString(), &quot;ShortLanguage&quot;);
1718         }
1719         return language3;
1720     }
1721 
1722     /**
1723      * Returns a three-letter abbreviation for this locale&#39;s country.
1724      * If the country matches an ISO 3166-1 alpha-2 code, the
1725      * corresponding ISO 3166-1 alpha-3 uppercase code is returned.
1726      * If the locale doesn&#39;t specify a country, this will be the empty
1727      * string.
1728      *
1729      * &lt;p&gt;The ISO 3166-1 codes can be found on-line.
1730      *
1731      * @return A three-letter abbreviation of this locale&#39;s country.
<a name="106" id="anc106"></a><span class="line-modified">1732      * @exception MissingResourceException Throws MissingResourceException if the</span>
1733      * three-letter country abbreviation is not available for this locale.
1734      */
1735     public String getISO3Country() throws MissingResourceException {
1736         String country3 = getISO3Code(baseLocale.getRegion(), LocaleISOData.isoCountryTable);
1737         if (country3 == null) {
1738             throw new MissingResourceException(&quot;Couldn&#39;t find 3-letter country code for &quot;
1739                     + baseLocale.getRegion(), &quot;FormatData_&quot; + toString(), &quot;ShortCountry&quot;);
1740         }
1741         return country3;
1742     }
1743 
1744     private static String getISO3Code(String iso2Code, String table) {
1745         int codeLength = iso2Code.length();
1746         if (codeLength == 0) {
1747             return &quot;&quot;;
1748         }
1749 
1750         int tableLength = table.length();
1751         int index = tableLength;
1752         if (codeLength == 2) {
1753             char c1 = iso2Code.charAt(0);
1754             char c2 = iso2Code.charAt(1);
1755             for (index = 0; index &lt; tableLength; index += 5) {
1756                 if (table.charAt(index) == c1
1757                     &amp;&amp; table.charAt(index + 1) == c2) {
1758                     break;
1759                 }
1760             }
1761         }
1762         return index &lt; tableLength ? table.substring(index + 2, index + 5) : null;
1763     }
1764 
1765     /**
1766      * Returns a name for the locale&#39;s language that is appropriate for display to the
1767      * user.
1768      * If possible, the name returned will be localized for the default
1769      * {@link Locale.Category#DISPLAY DISPLAY} locale.
1770      * For example, if the locale is fr_FR and the default
1771      * {@link Locale.Category#DISPLAY DISPLAY} locale
1772      * is en_US, getDisplayLanguage() will return &quot;French&quot;; if the locale is en_US and
1773      * the default {@link Locale.Category#DISPLAY DISPLAY} locale is fr_FR,
1774      * getDisplayLanguage() will return &quot;anglais&quot;.
1775      * If the name returned cannot be localized for the default
1776      * {@link Locale.Category#DISPLAY DISPLAY} locale,
1777      * (say, we don&#39;t have a Japanese name for Croatian),
1778      * this function falls back on the English name, and uses the ISO code as a last-resort
1779      * value.  If the locale doesn&#39;t specify a language, this function returns the empty string.
1780      *
1781      * @return The name of the display language.
1782      */
1783     public final String getDisplayLanguage() {
1784         return getDisplayLanguage(getDefault(Category.DISPLAY));
1785     }
1786 
1787     /**
1788      * Returns a name for the locale&#39;s language that is appropriate for display to the
1789      * user.
1790      * If possible, the name returned will be localized according to inLocale.
1791      * For example, if the locale is fr_FR and inLocale
1792      * is en_US, getDisplayLanguage() will return &quot;French&quot;; if the locale is en_US and
1793      * inLocale is fr_FR, getDisplayLanguage() will return &quot;anglais&quot;.
1794      * If the name returned cannot be localized according to inLocale,
1795      * (say, we don&#39;t have a Japanese name for Croatian),
1796      * this function falls back on the English name, and finally
1797      * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a language,
1798      * this function returns the empty string.
1799      *
1800      * @param inLocale The locale for which to retrieve the display language.
1801      * @return The name of the display language appropriate to the given locale.
<a name="107" id="anc107"></a><span class="line-modified">1802      * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1803      */
1804     public String getDisplayLanguage(Locale inLocale) {
1805         return getDisplayString(baseLocale.getLanguage(), null, inLocale, DISPLAY_LANGUAGE);
1806     }
1807 
1808     /**
1809      * Returns a name for the locale&#39;s script that is appropriate for display to
1810      * the user. If possible, the name will be localized for the default
1811      * {@link Locale.Category#DISPLAY DISPLAY} locale.  Returns
1812      * the empty string if this locale doesn&#39;t specify a script code.
1813      *
1814      * @return the display name of the script code for the current default
1815      *     {@link Locale.Category#DISPLAY DISPLAY} locale
1816      * @since 1.7
1817      */
1818     public String getDisplayScript() {
1819         return getDisplayScript(getDefault(Category.DISPLAY));
1820     }
1821 
1822     /**
1823      * Returns a name for the locale&#39;s script that is appropriate
1824      * for display to the user. If possible, the name will be
1825      * localized for the given locale. Returns the empty string if
1826      * this locale doesn&#39;t specify a script code.
1827      *
1828      * @param inLocale The locale for which to retrieve the display script.
1829      * @return the display name of the script code for the current default
1830      * {@link Locale.Category#DISPLAY DISPLAY} locale
<a name="108" id="anc108"></a><span class="line-modified">1831      * @throws NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1832      * @since 1.7
1833      */
1834     public String getDisplayScript(Locale inLocale) {
1835         return getDisplayString(baseLocale.getScript(), null, inLocale, DISPLAY_SCRIPT);
1836     }
1837 
1838     /**
1839      * Returns a name for the locale&#39;s country that is appropriate for display to the
1840      * user.
1841      * If possible, the name returned will be localized for the default
1842      * {@link Locale.Category#DISPLAY DISPLAY} locale.
1843      * For example, if the locale is fr_FR and the default
1844      * {@link Locale.Category#DISPLAY DISPLAY} locale
1845      * is en_US, getDisplayCountry() will return &quot;France&quot;; if the locale is en_US and
1846      * the default {@link Locale.Category#DISPLAY DISPLAY} locale is fr_FR,
1847      * getDisplayCountry() will return &quot;Etats-Unis&quot;.
1848      * If the name returned cannot be localized for the default
1849      * {@link Locale.Category#DISPLAY DISPLAY} locale,
1850      * (say, we don&#39;t have a Japanese name for Croatia),
1851      * this function falls back on the English name, and uses the ISO code as a last-resort
1852      * value.  If the locale doesn&#39;t specify a country, this function returns the empty string.
1853      *
1854      * @return The name of the country appropriate to the locale.
1855      */
1856     public final String getDisplayCountry() {
1857         return getDisplayCountry(getDefault(Category.DISPLAY));
1858     }
1859 
1860     /**
1861      * Returns a name for the locale&#39;s country that is appropriate for display to the
1862      * user.
1863      * If possible, the name returned will be localized according to inLocale.
1864      * For example, if the locale is fr_FR and inLocale
1865      * is en_US, getDisplayCountry() will return &quot;France&quot;; if the locale is en_US and
1866      * inLocale is fr_FR, getDisplayCountry() will return &quot;Etats-Unis&quot;.
1867      * If the name returned cannot be localized according to inLocale.
1868      * (say, we don&#39;t have a Japanese name for Croatia),
1869      * this function falls back on the English name, and finally
1870      * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a country,
1871      * this function returns the empty string.
1872      *
1873      * @param inLocale The locale for which to retrieve the display country.
1874      * @return The name of the country appropriate to the given locale.
<a name="109" id="anc109"></a><span class="line-modified">1875      * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1876      */
1877     public String getDisplayCountry(Locale inLocale) {
1878         return getDisplayString(baseLocale.getRegion(), null, inLocale, DISPLAY_COUNTRY);
1879     }
1880 
1881     private String getDisplayString(String code, String cat, Locale inLocale, int type) {
1882         Objects.requireNonNull(inLocale);
1883         Objects.requireNonNull(code);
1884 
1885         if (code.isEmpty()) {
1886             return &quot;&quot;;
1887         }
1888 
1889         LocaleServiceProviderPool pool =
1890             LocaleServiceProviderPool.getPool(LocaleNameProvider.class);
1891         String rbKey = (type == DISPLAY_VARIANT ? &quot;%%&quot;+code : code);
1892         String result = pool.getLocalizedObject(
1893                                 LocaleNameGetter.INSTANCE,
1894                                 inLocale, rbKey, type, code, cat);
1895         return result != null ? result : code;
1896     }
1897 
1898     /**
1899      * Returns a name for the locale&#39;s variant code that is appropriate for display to the
1900      * user.  If possible, the name will be localized for the default
1901      * {@link Locale.Category#DISPLAY DISPLAY} locale.  If the locale
1902      * doesn&#39;t specify a variant code, this function returns the empty string.
1903      *
1904      * @return The name of the display variant code appropriate to the locale.
1905      */
1906     public final String getDisplayVariant() {
1907         return getDisplayVariant(getDefault(Category.DISPLAY));
1908     }
1909 
1910     /**
1911      * Returns a name for the locale&#39;s variant code that is appropriate for display to the
1912      * user.  If possible, the name will be localized for inLocale.  If the locale
1913      * doesn&#39;t specify a variant code, this function returns the empty string.
1914      *
1915      * @param inLocale The locale for which to retrieve the display variant code.
1916      * @return The name of the display variant code appropriate to the given locale.
<a name="110" id="anc110"></a><span class="line-modified">1917      * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1918      */
1919     public String getDisplayVariant(Locale inLocale) {
1920         if (baseLocale.getVariant().isEmpty())
1921             return &quot;&quot;;
1922 
1923         LocaleResources lr = LocaleProviderAdapter
1924             .getResourceBundleBased()
1925             .getLocaleResources(inLocale);
1926 
1927         String names[] = getDisplayVariantArray(inLocale);
1928 
1929         // Get the localized patterns for formatting a list, and use
1930         // them to format the list.
1931         return formatList(names,
1932                           lr.getLocaleName(&quot;ListCompositionPattern&quot;));
1933     }
1934 
1935     /**
1936      * Returns a name for the locale that is appropriate for display to the
1937      * user. This will be the values returned by getDisplayLanguage(),
1938      * getDisplayScript(), getDisplayCountry(), getDisplayVariant() and
1939      * optional &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;
1940      * assembled into a single string. The non-empty values are used in order, with
1941      * the second and subsequent names in parentheses.  For example:
1942      * &lt;blockquote&gt;
1943      * language (script, country, variant(, extension)*)&lt;br&gt;
1944      * language (country(, extension)*)&lt;br&gt;
1945      * language (variant(, extension)*)&lt;br&gt;
1946      * script (country(, extension)*)&lt;br&gt;
1947      * country (extension)*&lt;br&gt;
1948      * &lt;/blockquote&gt;
1949      * depending on which fields are specified in the locale. The field
1950      * separator in the above parentheses, denoted as a comma character, may
1951      * be localized depending on the locale. If the language, script, country,
1952      * and variant fields are all empty, this function returns the empty string.
1953      *
1954      * @return The name of the locale appropriate to display.
1955      */
1956     public final String getDisplayName() {
1957         return getDisplayName(getDefault(Category.DISPLAY));
1958     }
1959 
1960     /**
1961      * Returns a name for the locale that is appropriate for display
1962      * to the user.  This will be the values returned by
1963      * getDisplayLanguage(), getDisplayScript(),getDisplayCountry()
1964      * getDisplayVariant(), and optional &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;
1965      * Unicode extensions&lt;/a&gt; assembled into a single string. The non-empty
1966      * values are used in order, with the second and subsequent names in
1967      * parentheses.  For example:
1968      * &lt;blockquote&gt;
1969      * language (script, country, variant(, extension)*)&lt;br&gt;
1970      * language (country(, extension)*)&lt;br&gt;
1971      * language (variant(, extension)*)&lt;br&gt;
1972      * script (country(, extension)*)&lt;br&gt;
1973      * country (extension)*&lt;br&gt;
1974      * &lt;/blockquote&gt;
1975      * depending on which fields are specified in the locale. The field
1976      * separator in the above parentheses, denoted as a comma character, may
1977      * be localized depending on the locale. If the language, script, country,
1978      * and variant fields are all empty, this function returns the empty string.
1979      *
1980      * @param inLocale The locale for which to retrieve the display name.
1981      * @return The name of the locale appropriate to display.
<a name="111" id="anc111"></a><span class="line-modified">1982      * @throws NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1983      */
1984     public String getDisplayName(Locale inLocale) {
1985         LocaleResources lr =  LocaleProviderAdapter
1986             .getResourceBundleBased()
1987             .getLocaleResources(inLocale);
1988 
1989         String languageName = getDisplayLanguage(inLocale);
1990         String scriptName = getDisplayScript(inLocale);
1991         String countryName = getDisplayCountry(inLocale);
1992         String[] variantNames = getDisplayVariantArray(inLocale);
1993 
1994         // Get the localized patterns for formatting a display name.
1995         String displayNamePattern = lr.getLocaleName(&quot;DisplayNamePattern&quot;);
1996         String listCompositionPattern = lr.getLocaleName(&quot;ListCompositionPattern&quot;);
1997 
1998         // The display name consists of a main name, followed by qualifiers.
1999         // Typically, the format is &quot;MainName (Qualifier, Qualifier)&quot; but this
2000         // depends on what pattern is stored in the display locale.
2001         String   mainName;
2002         String[] qualifierNames;
2003 
2004         // The main name is the language, or if there is no language, the script,
2005         // then if no script, the country. If there is no language/script/country
2006         // (an anomalous situation) then the display name is simply the variant&#39;s
2007         // display name.
2008         if (languageName.isEmpty() &amp;&amp; scriptName.isEmpty() &amp;&amp; countryName.isEmpty()) {
2009             if (variantNames.length == 0) {
2010                 return &quot;&quot;;
2011             } else {
2012                 return formatList(variantNames, listCompositionPattern);
2013             }
2014         }
2015         ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(4);
2016         if (!languageName.isEmpty()) {
2017             names.add(languageName);
2018         }
2019         if (!scriptName.isEmpty()) {
2020             names.add(scriptName);
2021         }
2022         if (!countryName.isEmpty()) {
2023             names.add(countryName);
2024         }
2025         if (variantNames.length != 0) {
2026             names.addAll(Arrays.asList(variantNames));
2027         }
2028 
2029         // add Unicode extensions
2030         if (localeExtensions != null) {
2031             localeExtensions.getUnicodeLocaleAttributes().stream()
2032                 .map(key -&gt; getDisplayString(key, null, inLocale, DISPLAY_UEXT_KEY))
2033                 .forEach(names::add);
2034             localeExtensions.getUnicodeLocaleKeys().stream()
2035                 .map(key -&gt; getDisplayKeyTypeExtensionString(key, lr, inLocale))
2036                 .forEach(names::add);
2037         }
2038 
2039         // The first one in the main name
2040         mainName = names.get(0);
2041 
2042         // Others are qualifiers
2043         int numNames = names.size();
2044         qualifierNames = (numNames &gt; 1) ?
2045                 names.subList(1, numNames).toArray(new String[numNames - 1]) : new String[0];
2046 
2047         // Create an array whose first element is the number of remaining
2048         // elements.  This serves as a selector into a ChoiceFormat pattern from
2049         // the resource.  The second and third elements are the main name and
2050         // the qualifier; if there are no qualifiers, the third element is
2051         // unused by the format pattern.
2052         Object[] displayNames = {
2053             qualifierNames.length != 0 ? 2 : 1,
2054             mainName,
2055             // We could also just call formatList() and have it handle the empty
2056             // list case, but this is more efficient, and we want it to be
2057             // efficient since all the language-only locales will not have any
2058             // qualifiers.
2059             qualifierNames.length != 0 ? formatList(qualifierNames, listCompositionPattern) : null
2060         };
2061 
2062         if (displayNamePattern != null) {
2063             return new MessageFormat(displayNamePattern).format(displayNames);
2064         }
2065         else {
2066             // If we cannot get the message format pattern, then we use a simple
2067             // hard-coded pattern.  This should not occur in practice unless the
2068             // installation is missing some core files (FormatData etc.).
2069             StringBuilder result = new StringBuilder();
2070             result.append((String)displayNames[1]);
2071             if (displayNames.length &gt; 2) {
2072                 result.append(&quot; (&quot;);
2073                 result.append((String)displayNames[2]);
2074                 result.append(&#39;)&#39;);
2075             }
2076             return result.toString();
2077         }
2078     }
2079 
2080     /**
2081      * Overrides Cloneable.
2082      */
2083     @Override
2084     public Object clone()
2085     {
2086         try {
2087             Locale that = (Locale)super.clone();
2088             return that;
2089         } catch (CloneNotSupportedException e) {
2090             throw new InternalError(e);
2091         }
2092     }
2093 
2094     /**
2095      * Override hashCode.
2096      * Since Locales are often used in hashtables, caches the value
2097      * for speed.
2098      */
2099     @Override
2100     public int hashCode() {
2101         int hc = hashCodeValue;
2102         if (hc == 0) {
2103             hc = baseLocale.hashCode();
2104             if (localeExtensions != null) {
2105                 hc ^= localeExtensions.hashCode();
2106             }
2107             hashCodeValue = hc;
2108         }
2109         return hc;
2110     }
2111 
2112     // Overrides
2113 
2114     /**
2115      * Returns true if this Locale is equal to another object.  A Locale is
2116      * deemed equal to another Locale with identical language, script, country,
2117      * variant and extensions, and unequal to all other objects.
2118      *
2119      * @return true if this Locale is equal to the specified object.
2120      */
2121     @Override
2122     public boolean equals(Object obj) {
2123         if (this == obj)                      // quick check
2124             return true;
2125         if (!(obj instanceof Locale))
2126             return false;
2127         BaseLocale otherBase = ((Locale)obj).baseLocale;
2128         if (!baseLocale.equals(otherBase)) {
2129             return false;
2130         }
2131         if (localeExtensions == null) {
2132             return ((Locale)obj).localeExtensions == null;
2133         }
2134         return localeExtensions.equals(((Locale)obj).localeExtensions);
2135     }
2136 
2137     // ================= privates =====================================
2138 
2139     private transient BaseLocale baseLocale;
2140     private transient LocaleExtensions localeExtensions;
2141 
2142     /**
2143      * Calculated hashcode
2144      */
2145     private transient volatile int hashCodeValue;
2146 
2147     private static volatile Locale defaultLocale = initDefault();
2148     private static volatile Locale defaultDisplayLocale;
2149     private static volatile Locale defaultFormatLocale;
2150 
2151     private transient volatile String languageTag;
2152 
2153     /**
2154      * Return an array of the display names of the variant.
2155      * @param bundle the ResourceBundle to use to get the display names
2156      * @return an array of display names, possible of zero length.
2157      */
2158     private String[] getDisplayVariantArray(Locale inLocale) {
2159         // Split the variant name into tokens separated by &#39;_&#39;.
2160         StringTokenizer tokenizer = new StringTokenizer(baseLocale.getVariant(), &quot;_&quot;);
2161         String[] names = new String[tokenizer.countTokens()];
2162 
2163         // For each variant token, lookup the display name.  If
2164         // not found, use the variant name itself.
2165         for (int i=0; i&lt;names.length; ++i) {
2166             names[i] = getDisplayString(tokenizer.nextToken(), null,
2167                                 inLocale, DISPLAY_VARIANT);
2168         }
2169 
2170         return names;
2171     }
2172 
2173     private String getDisplayKeyTypeExtensionString(String key, LocaleResources lr, Locale inLocale) {
2174         String type = localeExtensions.getUnicodeLocaleType(key);
2175         String ret = getDisplayString(type, key, inLocale, DISPLAY_UEXT_TYPE);
2176 
2177         if (ret == null || ret.equals(type)) {
2178             // no localization for this type. try combining key/type separately
2179             String displayType = type;
2180             switch (key) {
2181             case &quot;cu&quot;:
2182                 displayType = lr.getCurrencyName(type.toLowerCase(Locale.ROOT));
2183                 break;
2184             case &quot;rg&quot;:
2185                 if (type != null &amp;&amp;
2186                     // UN M.49 code should not be allowed here
2187                     type.matches(&quot;^[a-zA-Z]{2}[zZ]{4}$&quot;)) {
2188                         displayType = lr.getLocaleName(type.substring(0, 2).toUpperCase(Locale.ROOT));
2189                 }
2190                 break;
2191             case &quot;tz&quot;:
2192                 displayType = TimeZoneNameUtility.convertLDMLShortID(type)
2193                     .map(id -&gt; TimeZoneNameUtility.retrieveGenericDisplayName(id, TimeZone.LONG, inLocale))
2194                     .orElse(type);
2195                 break;
2196             }
2197             ret = MessageFormat.format(lr.getLocaleName(&quot;ListKeyTypePattern&quot;),
2198                 getDisplayString(key, null, inLocale, DISPLAY_UEXT_KEY),
2199                 Optional.ofNullable(displayType).orElse(type));
2200         }
2201 
2202         return ret;
2203     }
2204 
2205     /**
2206      * Format a list using given pattern strings.
2207      * If either of the patterns is null, then a the list is
2208      * formatted by concatenation with the delimiter &#39;,&#39;.
2209      * @param stringList the list of strings to be formatted.
2210      * and formatting them into a list.
2211      * @param pattern should take 2 arguments for reduction
2212      * @return a string representing the list.
2213      */
2214     private static String formatList(String[] stringList, String pattern) {
2215         // If we have no list patterns, compose the list in a simple,
2216         // non-localized way.
2217         if (pattern == null) {
2218             return Arrays.stream(stringList).collect(Collectors.joining(&quot;,&quot;));
2219         }
2220 
2221         switch (stringList.length) {
2222             case 0:
2223                 return &quot;&quot;;
2224             case 1:
2225                 return stringList[0];
2226             default:
2227                 return Arrays.stream(stringList).reduce(&quot;&quot;,
2228                     (s1, s2) -&gt; {
2229                         if (s1.isEmpty()) {
2230                             return s2;
2231                         }
2232                         if (s2.isEmpty()) {
2233                             return s1;
2234                         }
2235                         return MessageFormat.format(pattern, s1, s2);
2236                     });
2237         }
2238     }
2239 
2240     // Duplicate of sun.util.locale.UnicodeLocaleExtension.isKey in order to
2241     // avoid its class loading.
2242     private static boolean isUnicodeExtensionKey(String s) {
2243         // 2alphanum
2244         return (s.length() == 2) &amp;&amp; LocaleUtils.isAlphaNumericString(s);
2245     }
2246 
2247     /**
2248      * @serialField language    String
2249      *      language subtag in lower case.
2250      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getLanguage()&quot;&gt;getLanguage()&lt;/a&gt;)
2251      * @serialField country     String
2252      *      country subtag in upper case.
2253      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getCountry()&quot;&gt;getCountry()&lt;/a&gt;)
2254      * @serialField variant     String
2255      *      variant subtags separated by LOWLINE characters.
2256      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getVariant()&quot;&gt;getVariant()&lt;/a&gt;)
2257      * @serialField hashcode    int
2258      *      deprecated, for forward compatibility only
2259      * @serialField script      String
2260      *      script subtag in title case
2261      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getScript()&quot;&gt;getScript()&lt;/a&gt;)
2262      * @serialField extensions  String
2263      *      canonical representation of extensions, that is,
2264      *      BCP47 extensions in alphabetical order followed by
2265      *      BCP47 private use subtags, all in lower case letters
2266      *      separated by HYPHEN-MINUS characters.
2267      *      (See &lt;a href=&quot;java.base/java/util/Locale.html#getExtensionKeys()&quot;&gt;getExtensionKeys()&lt;/a&gt;,
2268      *      &lt;a href=&quot;java.base/java/util/Locale.html#getExtension(char)&quot;&gt;getExtension(char)&lt;/a&gt;)
2269      */
<a name="112" id="anc112"></a>
2270     private static final ObjectStreamField[] serialPersistentFields = {
2271         new ObjectStreamField(&quot;language&quot;, String.class),
2272         new ObjectStreamField(&quot;country&quot;, String.class),
2273         new ObjectStreamField(&quot;variant&quot;, String.class),
2274         new ObjectStreamField(&quot;hashcode&quot;, int.class),
2275         new ObjectStreamField(&quot;script&quot;, String.class),
2276         new ObjectStreamField(&quot;extensions&quot;, String.class),
2277     };
2278 
2279     /**
<a name="113" id="anc113"></a><span class="line-modified">2280      * Serializes this &lt;code&gt;Locale&lt;/code&gt; to the specified &lt;code&gt;ObjectOutputStream&lt;/code&gt;.</span>
<span class="line-modified">2281      * @param out the &lt;code&gt;ObjectOutputStream&lt;/code&gt; to write</span>
2282      * @throws IOException
2283      * @since 1.7
2284      */
<a name="114" id="anc114"></a>
2285     private void writeObject(ObjectOutputStream out) throws IOException {
2286         ObjectOutputStream.PutField fields = out.putFields();
2287         fields.put(&quot;language&quot;, baseLocale.getLanguage());
2288         fields.put(&quot;script&quot;, baseLocale.getScript());
2289         fields.put(&quot;country&quot;, baseLocale.getRegion());
2290         fields.put(&quot;variant&quot;, baseLocale.getVariant());
2291         fields.put(&quot;extensions&quot;, localeExtensions == null ? &quot;&quot; : localeExtensions.getID());
2292         fields.put(&quot;hashcode&quot;, -1); // place holder just for backward support
2293         out.writeFields();
2294     }
2295 
2296     /**
<a name="115" id="anc115"></a><span class="line-modified">2297      * Deserializes this &lt;code&gt;Locale&lt;/code&gt;.</span>
<span class="line-modified">2298      * @param in the &lt;code&gt;ObjectInputStream&lt;/code&gt; to read</span>
2299      * @throws IOException
2300      * @throws ClassNotFoundException
2301      * @throws IllformedLocaleException
2302      * @since 1.7
2303      */
<a name="116" id="anc116"></a>
2304     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
2305         ObjectInputStream.GetField fields = in.readFields();
2306         String language = (String)fields.get(&quot;language&quot;, &quot;&quot;);
2307         String script = (String)fields.get(&quot;script&quot;, &quot;&quot;);
2308         String country = (String)fields.get(&quot;country&quot;, &quot;&quot;);
2309         String variant = (String)fields.get(&quot;variant&quot;, &quot;&quot;);
2310         String extStr = (String)fields.get(&quot;extensions&quot;, &quot;&quot;);
<a name="117" id="anc117"></a>
2311         baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), script, country, variant);
2312         if (!extStr.isEmpty()) {
2313             try {
2314                 InternalLocaleBuilder bldr = new InternalLocaleBuilder();
2315                 bldr.setExtensions(extStr);
2316                 localeExtensions = bldr.getLocaleExtensions();
2317             } catch (LocaleSyntaxException e) {
2318                 throw new IllformedLocaleException(e.getMessage());
2319             }
2320         } else {
2321             localeExtensions = null;
2322         }
2323     }
2324 
2325     /**
<a name="118" id="anc118"></a><span class="line-modified">2326      * Returns a cached &lt;code&gt;Locale&lt;/code&gt; instance equivalent to</span>
<span class="line-modified">2327      * the deserialized &lt;code&gt;Locale&lt;/code&gt;. When serialized</span>
2328      * language, country and variant fields read from the object data stream
2329      * are exactly &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot; or &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot; and script/extensions
<a name="119" id="anc119"></a><span class="line-modified">2330      * fields are empty, this method supplies &lt;code&gt;UNICODE_LOCALE_EXTENSION&lt;/code&gt;</span>
2331      * &quot;ca&quot;/&quot;japanese&quot; (calendar type is &quot;japanese&quot;) or &quot;nu&quot;/&quot;thai&quot; (number script
2332      * type is &quot;thai&quot;). See &lt;a href=&quot;Locale.html#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;
2333      * for more information.
2334      *
<a name="120" id="anc120"></a><span class="line-modified">2335      * @return an instance of &lt;code&gt;Locale&lt;/code&gt; equivalent to</span>
<span class="line-modified">2336      * the deserialized &lt;code&gt;Locale&lt;/code&gt;.</span>
2337      * @throws java.io.ObjectStreamException
2338      */
<a name="121" id="anc121"></a>
2339     private Object readResolve() throws java.io.ObjectStreamException {
2340         return getInstance(baseLocale.getLanguage(), baseLocale.getScript(),
2341                 baseLocale.getRegion(), baseLocale.getVariant(), localeExtensions);
2342     }
2343 
2344     private static volatile String[] isoLanguages;
2345 
2346     private static volatile String[] isoCountries;
2347 
2348     private static String convertOldISOCodes(String language) {
2349         // we accept both the old and the new ISO codes for the languages whose ISO
2350         // codes have changed, but we always store the OLD code, for backward compatibility
2351         language = LocaleUtils.toLowerString(language).intern();
2352         if (language == &quot;he&quot;) {
2353             return &quot;iw&quot;;
2354         } else if (language == &quot;yi&quot;) {
2355             return &quot;ji&quot;;
2356         } else if (language == &quot;id&quot;) {
2357             return &quot;in&quot;;
2358         } else {
2359             return language;
2360         }
2361     }
2362 
2363     private static LocaleExtensions getCompatibilityExtensions(String language,
2364                                                                String script,
2365                                                                String country,
2366                                                                String variant) {
2367         LocaleExtensions extensions = null;
2368         // Special cases for backward compatibility support
2369         if (LocaleUtils.caseIgnoreMatch(language, &quot;ja&quot;)
2370                 &amp;&amp; script.isEmpty()
2371                 &amp;&amp; LocaleUtils.caseIgnoreMatch(country, &quot;jp&quot;)
2372                 &amp;&amp; &quot;JP&quot;.equals(variant)) {
2373             // ja_JP_JP -&gt; u-ca-japanese (calendar = japanese)
2374             extensions = LocaleExtensions.CALENDAR_JAPANESE;
2375         } else if (LocaleUtils.caseIgnoreMatch(language, &quot;th&quot;)
2376                 &amp;&amp; script.isEmpty()
2377                 &amp;&amp; LocaleUtils.caseIgnoreMatch(country, &quot;th&quot;)
2378                 &amp;&amp; &quot;TH&quot;.equals(variant)) {
2379             // th_TH_TH -&gt; u-nu-thai (numbersystem = thai)
2380             extensions = LocaleExtensions.NUMBER_THAI;
2381         }
2382         return extensions;
2383     }
2384 
2385     /**
2386      * Obtains a localized locale names from a LocaleNameProvider
2387      * implementation.
2388      */
2389     private static class LocaleNameGetter
2390         implements LocaleServiceProviderPool.LocalizedObjectGetter&lt;LocaleNameProvider, String&gt; {
2391         private static final LocaleNameGetter INSTANCE = new LocaleNameGetter();
2392 
2393         @Override
2394         public String getObject(LocaleNameProvider localeNameProvider,
2395                                 Locale locale,
2396                                 String key,
2397                                 Object... params) {
2398             assert params.length == 3;
2399             int type = (Integer)params[0];
2400             String code = (String)params[1];
2401             String cat = (String)params[2];
2402 
2403             switch(type) {
2404             case DISPLAY_LANGUAGE:
2405                 return localeNameProvider.getDisplayLanguage(code, locale);
2406             case DISPLAY_COUNTRY:
2407                 return localeNameProvider.getDisplayCountry(code, locale);
2408             case DISPLAY_VARIANT:
2409                 return localeNameProvider.getDisplayVariant(code, locale);
2410             case DISPLAY_SCRIPT:
2411                 return localeNameProvider.getDisplayScript(code, locale);
2412             case DISPLAY_UEXT_KEY:
2413                 return localeNameProvider.getDisplayUnicodeExtensionKey(code, locale);
2414             case DISPLAY_UEXT_TYPE:
2415                 return localeNameProvider.getDisplayUnicodeExtensionType(code, cat, locale);
2416             default:
2417                 assert false; // shouldn&#39;t happen
2418             }
2419 
2420             return null;
2421         }
2422     }
2423 
2424     /**
2425      * Enum for locale categories.  These locale categories are used to get/set
2426      * the default locale for the specific functionality represented by the
2427      * category.
2428      *
2429      * @see #getDefault(Locale.Category)
2430      * @see #setDefault(Locale.Category, Locale)
2431      * @since 1.7
2432      */
2433     public enum Category {
2434 
2435         /**
2436          * Category used to represent the default locale for
2437          * displaying user interfaces.
2438          */
2439         DISPLAY(&quot;user.language.display&quot;,
2440                 &quot;user.script.display&quot;,
2441                 &quot;user.country.display&quot;,
2442                 &quot;user.variant.display&quot;,
2443                 &quot;user.extensions.display&quot;),
2444 
2445         /**
2446          * Category used to represent the default locale for
2447          * formatting dates, numbers, and/or currencies.
2448          */
2449         FORMAT(&quot;user.language.format&quot;,
2450                &quot;user.script.format&quot;,
2451                &quot;user.country.format&quot;,
2452                &quot;user.variant.format&quot;,
2453                &quot;user.extensions.format&quot;);
2454 
2455         Category(String languageKey, String scriptKey, String countryKey,
2456                 String variantKey, String extensionsKey) {
2457             this.languageKey = languageKey;
2458             this.scriptKey = scriptKey;
2459             this.countryKey = countryKey;
2460             this.variantKey = variantKey;
2461             this.extensionsKey = extensionsKey;
2462         }
2463 
2464         final String languageKey;
2465         final String scriptKey;
2466         final String countryKey;
2467         final String variantKey;
2468         final String extensionsKey;
2469     }
2470 
2471     /**
<a name="122" id="anc122"></a><span class="line-modified">2472      * &lt;code&gt;Builder&lt;/code&gt; is used to build instances of &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">2473      * from values configured by the setters.  Unlike the &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">2474      * constructors, the &lt;code&gt;Builder&lt;/code&gt; checks if a value configured by a</span>
<span class="line-modified">2475      * setter satisfies the syntax requirements defined by the &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">2476      * class.  A &lt;code&gt;Locale&lt;/code&gt; object created by a &lt;code&gt;Builder&lt;/code&gt; is</span>
2477      * well-formed and can be transformed to a well-formed IETF BCP 47 language tag
2478      * without losing information.
2479      *
<a name="123" id="anc123"></a><span class="line-modified">2480      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;Locale&lt;/code&gt; class does not provide any</span>
2481      * syntactic restrictions on variant, while BCP 47 requires each variant
2482      * subtag to be 5 to 8 alphanumerics or a single numeric followed by 3
<a name="124" id="anc124"></a><span class="line-modified">2483      * alphanumerics.  The method &lt;code&gt;setVariant&lt;/code&gt; throws</span>
<span class="line-modified">2484      * &lt;code&gt;IllformedLocaleException&lt;/code&gt; for a variant that does not satisfy</span>
2485      * this restriction. If it is necessary to support such a variant, use a
<a name="125" id="anc125"></a><span class="line-modified">2486      * Locale constructor.  However, keep in mind that a &lt;code&gt;Locale&lt;/code&gt;</span>
2487      * object created this way might lose the variant information when
2488      * transformed to a BCP 47 language tag.
2489      *
<a name="126" id="anc126"></a><span class="line-modified">2490      * &lt;p&gt;The following example shows how to create a &lt;code&gt;Locale&lt;/code&gt; object</span>
<span class="line-modified">2491      * with the &lt;code&gt;Builder&lt;/code&gt;.</span>
2492      * &lt;blockquote&gt;
2493      * &lt;pre&gt;
2494      *     Locale aLocale = new Builder().setLanguage(&quot;sr&quot;).setScript(&quot;Latn&quot;).setRegion(&quot;RS&quot;).build();
2495      * &lt;/pre&gt;
2496      * &lt;/blockquote&gt;
2497      *
<a name="127" id="anc127"></a><span class="line-modified">2498      * &lt;p&gt;Builders can be reused; &lt;code&gt;clear()&lt;/code&gt; resets all</span>
2499      * fields to their default values.
2500      *
2501      * @see Locale#forLanguageTag
2502      * @since 1.7
2503      */
2504     public static final class Builder {
2505         private final InternalLocaleBuilder localeBuilder;
2506 
2507         /**
2508          * Constructs an empty Builder. The default value of all
2509          * fields, extensions, and private use information is the
2510          * empty string.
2511          */
2512         public Builder() {
2513             localeBuilder = new InternalLocaleBuilder();
2514         }
2515 
2516         /**
<a name="128" id="anc128"></a><span class="line-modified">2517          * Resets the &lt;code&gt;Builder&lt;/code&gt; to match the provided</span>
<span class="line-modified">2518          * &lt;code&gt;locale&lt;/code&gt;.  Existing state is discarded.</span>
2519          *
2520          * &lt;p&gt;All fields of the locale must be well-formed, see {@link Locale}.
2521          *
2522          * &lt;p&gt;Locales with any ill-formed fields cause
<a name="129" id="anc129"></a><span class="line-modified">2523          * &lt;code&gt;IllformedLocaleException&lt;/code&gt; to be thrown, except for the</span>
2524          * following three cases which are accepted for compatibility
2525          * reasons:&lt;ul&gt;
2526          * &lt;li&gt;Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) is treated as &quot;ja-JP-u-ca-japanese&quot;
2527          * &lt;li&gt;Locale(&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) is treated as &quot;th-TH-u-nu-thai&quot;
2528          * &lt;li&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;) is treated as &quot;nn-NO&quot;&lt;/ul&gt;
2529          *
2530          * @param locale the locale
2531          * @return This builder.
<a name="130" id="anc130"></a><span class="line-modified">2532          * @throws IllformedLocaleException if &lt;code&gt;locale&lt;/code&gt; has</span>
2533          * any ill-formed fields.
<a name="131" id="anc131"></a><span class="line-modified">2534          * @throws NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null.</span>
2535          */
2536         public Builder setLocale(Locale locale) {
2537             try {
2538                 localeBuilder.setLocale(locale.baseLocale, locale.localeExtensions);
2539             } catch (LocaleSyntaxException e) {
2540                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2541             }
2542             return this;
2543         }
2544 
2545         /**
2546          * Resets the Builder to match the provided IETF BCP 47
2547          * language tag.  Discards the existing state.  Null and the
2548          * empty string cause the builder to be reset, like {@link
2549          * #clear}.  Grandfathered tags (see {@link
2550          * Locale#forLanguageTag}) are converted to their canonical
2551          * form before being processed.  Otherwise, the language tag
2552          * must be well-formed (see {@link Locale}) or an exception is
<a name="132" id="anc132"></a><span class="line-modified">2553          * thrown (unlike &lt;code&gt;Locale.forLanguageTag&lt;/code&gt;, which</span>
2554          * just discards ill-formed and following portions of the
2555          * tag).
2556          *
2557          * @param languageTag the language tag
2558          * @return This builder.
<a name="133" id="anc133"></a><span class="line-modified">2559          * @throws IllformedLocaleException if &lt;code&gt;languageTag&lt;/code&gt; is ill-formed</span>
2560          * @see Locale#forLanguageTag(String)
2561          */
2562         public Builder setLanguageTag(String languageTag) {
2563             ParseStatus sts = new ParseStatus();
2564             LanguageTag tag = LanguageTag.parse(languageTag, sts);
2565             if (sts.isError()) {
2566                 throw new IllformedLocaleException(sts.getErrorMessage(), sts.getErrorIndex());
2567             }
2568             localeBuilder.setLanguageTag(tag);
2569             return this;
2570         }
2571 
2572         /**
<a name="134" id="anc134"></a><span class="line-modified">2573          * Sets the language.  If &lt;code&gt;language&lt;/code&gt; is the empty string or</span>
<span class="line-modified">2574          * null, the language in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise,</span>
2575          * the language must be &lt;a href=&quot;./Locale.html#def_language&quot;&gt;well-formed&lt;/a&gt;
2576          * or an exception is thrown.
2577          *
2578          * &lt;p&gt;The typical language value is a two or three-letter language
2579          * code as defined in ISO639.
2580          *
2581          * @param language the language
2582          * @return This builder.
<a name="135" id="anc135"></a><span class="line-modified">2583          * @throws IllformedLocaleException if &lt;code&gt;language&lt;/code&gt; is ill-formed</span>
2584          */
2585         public Builder setLanguage(String language) {
2586             try {
2587                 localeBuilder.setLanguage(language);
2588             } catch (LocaleSyntaxException e) {
2589                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2590             }
2591             return this;
2592         }
2593 
2594         /**
<a name="136" id="anc136"></a><span class="line-modified">2595          * Sets the script. If &lt;code&gt;script&lt;/code&gt; is null or the empty string,</span>
<span class="line-modified">2596          * the script in this &lt;code&gt;Builder&lt;/code&gt; is removed.</span>
2597          * Otherwise, the script must be &lt;a href=&quot;./Locale.html#def_script&quot;&gt;well-formed&lt;/a&gt; or an
2598          * exception is thrown.
2599          *
2600          * &lt;p&gt;The typical script value is a four-letter script code as defined by ISO 15924.
2601          *
2602          * @param script the script
2603          * @return This builder.
<a name="137" id="anc137"></a><span class="line-modified">2604          * @throws IllformedLocaleException if &lt;code&gt;script&lt;/code&gt; is ill-formed</span>
2605          */
2606         public Builder setScript(String script) {
2607             try {
2608                 localeBuilder.setScript(script);
2609             } catch (LocaleSyntaxException e) {
2610                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2611             }
2612             return this;
2613         }
2614 
2615         /**
2616          * Sets the region.  If region is null or the empty string, the region
<a name="138" id="anc138"></a><span class="line-modified">2617          * in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise,</span>
2618          * the region must be &lt;a href=&quot;./Locale.html#def_region&quot;&gt;well-formed&lt;/a&gt; or an
2619          * exception is thrown.
2620          *
2621          * &lt;p&gt;The typical region value is a two-letter ISO 3166 code or a
2622          * three-digit UN M.49 area code.
2623          *
<a name="139" id="anc139"></a><span class="line-modified">2624          * &lt;p&gt;The country value in the &lt;code&gt;Locale&lt;/code&gt; created by the</span>
<span class="line-modified">2625          * &lt;code&gt;Builder&lt;/code&gt; is always normalized to upper case.</span>
2626          *
2627          * @param region the region
2628          * @return This builder.
<a name="140" id="anc140"></a><span class="line-modified">2629          * @throws IllformedLocaleException if &lt;code&gt;region&lt;/code&gt; is ill-formed</span>
2630          */
2631         public Builder setRegion(String region) {
2632             try {
2633                 localeBuilder.setRegion(region);
2634             } catch (LocaleSyntaxException e) {
2635                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2636             }
2637             return this;
2638         }
2639 
2640         /**
2641          * Sets the variant.  If variant is null or the empty string, the
<a name="141" id="anc141"></a><span class="line-modified">2642          * variant in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise, it</span>
2643          * must consist of one or more &lt;a href=&quot;./Locale.html#def_variant&quot;&gt;well-formed&lt;/a&gt;
2644          * subtags, or an exception is thrown.
2645          *
<a name="142" id="anc142"></a><span class="line-modified">2646          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method checks if &lt;code&gt;variant&lt;/code&gt;</span>
2647          * satisfies the IETF BCP 47 variant subtag&#39;s syntax requirements,
2648          * and normalizes the value to lowercase letters.  However,
<a name="143" id="anc143"></a><span class="line-modified">2649          * the &lt;code&gt;Locale&lt;/code&gt; class does not impose any syntactic</span>
2650          * restriction on variant, and the variant value in
<a name="144" id="anc144"></a><span class="line-modified">2651          * &lt;code&gt;Locale&lt;/code&gt; is case sensitive.  To set such a variant,</span>
2652          * use a Locale constructor.
2653          *
2654          * @param variant the variant
2655          * @return This builder.
<a name="145" id="anc145"></a><span class="line-modified">2656          * @throws IllformedLocaleException if &lt;code&gt;variant&lt;/code&gt; is ill-formed</span>
2657          */
2658         public Builder setVariant(String variant) {
2659             try {
2660                 localeBuilder.setVariant(variant);
2661             } catch (LocaleSyntaxException e) {
2662                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2663             }
2664             return this;
2665         }
2666 
2667         /**
2668          * Sets the extension for the given key. If the value is null or the
2669          * empty string, the extension is removed.  Otherwise, the extension
2670          * must be &lt;a href=&quot;./Locale.html#def_extensions&quot;&gt;well-formed&lt;/a&gt; or an exception
2671          * is thrown.
2672          *
2673          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The key {@link Locale#UNICODE_LOCALE_EXTENSION
2674          * UNICODE_LOCALE_EXTENSION} (&#39;u&#39;) is used for the Unicode locale extension.
2675          * Setting a value for this key replaces any existing Unicode locale key/type
2676          * pairs with those defined in the extension.
2677          *
2678          * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The key {@link Locale#PRIVATE_USE_EXTENSION
2679          * PRIVATE_USE_EXTENSION} (&#39;x&#39;) is used for the private use code. To be
2680          * well-formed, the value for this key needs only to have subtags of one to
2681          * eight alphanumeric characters, not two to eight as in the general case.
2682          *
2683          * @param key the extension key
2684          * @param value the extension value
2685          * @return This builder.
<a name="146" id="anc146"></a><span class="line-modified">2686          * @throws IllformedLocaleException if &lt;code&gt;key&lt;/code&gt; is illegal</span>
<span class="line-modified">2687          * or &lt;code&gt;value&lt;/code&gt; is ill-formed</span>
2688          * @see #setUnicodeLocaleKeyword(String, String)
2689          */
2690         public Builder setExtension(char key, String value) {
2691             try {
2692                 localeBuilder.setExtension(key, value);
2693             } catch (LocaleSyntaxException e) {
2694                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2695             }
2696             return this;
2697         }
2698 
2699         /**
2700          * Sets the Unicode locale keyword type for the given key.  If the type
2701          * is null, the Unicode keyword is removed.  Otherwise, the key must be
2702          * non-null and both key and type must be &lt;a
2703          * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
2704          * is thrown.
2705          *
2706          * &lt;p&gt;Keys and types are converted to lower case.
2707          *
2708          * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;:Setting the &#39;u&#39; extension via {@link #setExtension}
2709          * replaces all Unicode locale keywords with those defined in the
2710          * extension.
2711          *
2712          * @param key the Unicode locale key
2713          * @param type the Unicode locale type
2714          * @return This builder.
<a name="147" id="anc147"></a><span class="line-modified">2715          * @throws IllformedLocaleException if &lt;code&gt;key&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;</span>
2716          * is ill-formed
<a name="148" id="anc148"></a><span class="line-modified">2717          * @throws NullPointerException if &lt;code&gt;key&lt;/code&gt; is null</span>
2718          * @see #setExtension(char, String)
2719          */
2720         public Builder setUnicodeLocaleKeyword(String key, String type) {
2721             try {
2722                 localeBuilder.setUnicodeLocaleKeyword(key, type);
2723             } catch (LocaleSyntaxException e) {
2724                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2725             }
2726             return this;
2727         }
2728 
2729         /**
2730          * Adds a unicode locale attribute, if not already present, otherwise
2731          * has no effect.  The attribute must not be null and must be &lt;a
2732          * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
2733          * is thrown.
2734          *
2735          * @param attribute the attribute
2736          * @return This builder.
<a name="149" id="anc149"></a><span class="line-modified">2737          * @throws NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null</span>
<span class="line-modified">2738          * @throws IllformedLocaleException if &lt;code&gt;attribute&lt;/code&gt; is ill-formed</span>
2739          * @see #setExtension(char, String)
2740          */
2741         public Builder addUnicodeLocaleAttribute(String attribute) {
2742             try {
2743                 localeBuilder.addUnicodeLocaleAttribute(attribute);
2744             } catch (LocaleSyntaxException e) {
2745                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2746             }
2747             return this;
2748         }
2749 
2750         /**
2751          * Removes a unicode locale attribute, if present, otherwise has no
2752          * effect.  The attribute must not be null and must be &lt;a
2753          * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
2754          * is thrown.
2755          *
2756          * &lt;p&gt;Attribute comparison for removal is case-insensitive.
2757          *
2758          * @param attribute the attribute
2759          * @return This builder.
<a name="150" id="anc150"></a><span class="line-modified">2760          * @throws NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null</span>
<span class="line-modified">2761          * @throws IllformedLocaleException if &lt;code&gt;attribute&lt;/code&gt; is ill-formed</span>
2762          * @see #setExtension(char, String)
2763          */
2764         public Builder removeUnicodeLocaleAttribute(String attribute) {
2765             Objects.requireNonNull(attribute);
2766             try {
2767                 localeBuilder.removeUnicodeLocaleAttribute(attribute);
2768             } catch (LocaleSyntaxException e) {
2769                 throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
2770             }
2771             return this;
2772         }
2773 
2774         /**
2775          * Resets the builder to its initial, empty state.
2776          *
2777          * @return This builder.
2778          */
2779         public Builder clear() {
2780             localeBuilder.clear();
2781             return this;
2782         }
2783 
2784         /**
2785          * Resets the extensions to their initial, empty state.
2786          * Language, script, region and variant are unchanged.
2787          *
2788          * @return This builder.
2789          * @see #setExtension(char, String)
2790          */
2791         public Builder clearExtensions() {
2792             localeBuilder.clearExtensions();
2793             return this;
2794         }
2795 
2796         /**
<a name="151" id="anc151"></a><span class="line-modified">2797          * Returns an instance of &lt;code&gt;Locale&lt;/code&gt; created from the fields set</span>
2798          * on this builder.
2799          *
2800          * &lt;p&gt;This applies the conversions listed in {@link Locale#forLanguageTag}
2801          * when constructing a Locale. (Grandfathered tags are handled in
2802          * {@link #setLanguageTag}.)
2803          *
2804          * @return A Locale.
2805          */
2806         public Locale build() {
2807             BaseLocale baseloc = localeBuilder.getBaseLocale();
2808             LocaleExtensions extensions = localeBuilder.getLocaleExtensions();
2809             if (extensions == null &amp;&amp; !baseloc.getVariant().isEmpty()) {
2810                 extensions = getCompatibilityExtensions(baseloc.getLanguage(), baseloc.getScript(),
2811                         baseloc.getRegion(), baseloc.getVariant());
2812             }
2813             return Locale.getInstance(baseloc, extensions);
2814         }
2815     }
2816 
2817     /**
2818      * This enum provides constants to select a filtering mode for locale
2819      * matching. Refer to &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647
2820      * Matching of Language Tags&lt;/a&gt; for details.
2821      *
2822      * &lt;p&gt;As an example, think of two Language Priority Lists each of which
2823      * includes only one language range and a set of following language tags:
2824      *
2825      * &lt;pre&gt;
2826      *    de (German)
2827      *    de-DE (German, Germany)
2828      *    de-Deva (German, in Devanagari script)
2829      *    de-Deva-DE (German, in Devanagari script, Germany)
2830      *    de-DE-1996 (German, Germany, orthography of 1996)
2831      *    de-Latn-DE (German, in Latin script, Germany)
2832      *    de-Latn-DE-1996 (German, in Latin script, Germany, orthography of 1996)
2833      * &lt;/pre&gt;
2834      *
2835      * The filtering method will behave as follows:
2836      *
2837      * &lt;table class=&quot;striped&quot;&gt;
2838      * &lt;caption&gt;Filtering method behavior&lt;/caption&gt;
2839      * &lt;thead&gt;
2840      * &lt;tr&gt;
2841      * &lt;th scope=&quot;col&quot;&gt;Filtering Mode&lt;/th&gt;
2842      * &lt;th scope=&quot;col&quot;&gt;Language Priority List: {@code &quot;de-DE&quot;}&lt;/th&gt;
2843      * &lt;th scope=&quot;col&quot;&gt;Language Priority List: {@code &quot;de-*-DE&quot;}&lt;/th&gt;
2844      * &lt;/tr&gt;
2845      * &lt;/thead&gt;
2846      * &lt;tbody&gt;
2847      * &lt;tr&gt;
2848      * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;
2849      * {@link FilteringMode#AUTOSELECT_FILTERING AUTOSELECT_FILTERING}
2850      * &lt;/th&gt;
2851      * &lt;td style=&quot;vertical-align:top&quot;&gt;
2852      * Performs &lt;em&gt;basic&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;} and
2853      * {@code &quot;de-DE-1996&quot;}.
2854      * &lt;/td&gt;
2855      * &lt;td style=&quot;vertical-align:top&quot;&gt;
2856      * Performs &lt;em&gt;extended&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;},
2857      * {@code &quot;de-Deva-DE&quot;}, {@code &quot;de-DE-1996&quot;}, {@code &quot;de-Latn-DE&quot;}, and
2858      * {@code &quot;de-Latn-DE-1996&quot;}.
2859      * &lt;/td&gt;
2860      * &lt;/tr&gt;
2861      * &lt;tr&gt;
2862      * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;
2863      * {@link FilteringMode#EXTENDED_FILTERING EXTENDED_FILTERING}
2864      * &lt;/th&gt;
2865      * &lt;td style=&quot;vertical-align:top&quot;&gt;
2866      * Performs &lt;em&gt;extended&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;},
2867      * {@code &quot;de-Deva-DE&quot;}, {@code &quot;de-DE-1996&quot;}, {@code &quot;de-Latn-DE&quot;}, and
2868      * {@code &quot;de-Latn-DE-1996&quot;}.
2869      * &lt;/td&gt;
2870      * &lt;td style=&quot;vertical-align:top&quot;&gt;Same as above.&lt;/td&gt;
2871      * &lt;/tr&gt;
2872      * &lt;tr&gt;
2873      * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;
2874      * {@link FilteringMode#IGNORE_EXTENDED_RANGES IGNORE_EXTENDED_RANGES}
2875      * &lt;/th&gt;
2876      * &lt;td style=&quot;vertical-align:top&quot;&gt;
2877      * Performs &lt;em&gt;basic&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;} and
2878      * {@code &quot;de-DE-1996&quot;}.
2879      * &lt;/td&gt;
2880      * &lt;td style=&quot;vertical-align:top&quot;&gt;
2881      * Performs &lt;em&gt;basic&lt;/em&gt; filtering and returns {@code null} because
2882      * nothing matches.
2883      * &lt;/td&gt;
2884      * &lt;/tr&gt;
2885      * &lt;tr&gt;
2886      * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;
2887      * {@link FilteringMode#MAP_EXTENDED_RANGES MAP_EXTENDED_RANGES}
2888      * &lt;/th&gt;
2889      * &lt;td style=&quot;vertical-align:top&quot;&gt;Same as above.&lt;/td&gt;
2890      * &lt;td style=&quot;vertical-align:top&quot;&gt;
2891      * Performs &lt;em&gt;basic&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;} and
2892      * {@code &quot;de-DE-1996&quot;} because {@code &quot;de-*-DE&quot;} is mapped to
2893      * {@code &quot;de-DE&quot;}.
2894      * &lt;/td&gt;
2895      * &lt;/tr&gt;
2896      * &lt;tr&gt;
2897      * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;
2898      * {@link FilteringMode#REJECT_EXTENDED_RANGES REJECT_EXTENDED_RANGES}
2899      * &lt;/th&gt;
2900      * &lt;td style=&quot;vertical-align:top&quot;&gt;Same as above.&lt;/td&gt;
2901      * &lt;td style=&quot;vertical-align:top&quot;&gt;
2902      * Throws {@link IllegalArgumentException} because {@code &quot;de-*-DE&quot;} is
2903      * not a valid basic language range.
2904      * &lt;/td&gt;
2905      * &lt;/tr&gt;
2906      * &lt;/tbody&gt;
2907      * &lt;/table&gt;
2908      *
2909      * @see #filter(List, Collection, FilteringMode)
2910      * @see #filterTags(List, Collection, FilteringMode)
2911      *
2912      * @since 1.8
2913      */
2914     public static enum FilteringMode {
2915         /**
2916          * Specifies automatic filtering mode based on the given Language
2917          * Priority List consisting of language ranges. If all of the ranges
2918          * are basic, basic filtering is selected. Otherwise, extended
2919          * filtering is selected.
2920          */
2921         AUTOSELECT_FILTERING,
2922 
2923         /**
2924          * Specifies extended filtering.
2925          */
2926         EXTENDED_FILTERING,
2927 
2928         /**
2929          * Specifies basic filtering: Note that any extended language ranges
2930          * included in the given Language Priority List are ignored.
2931          */
2932         IGNORE_EXTENDED_RANGES,
2933 
2934         /**
2935          * Specifies basic filtering: If any extended language ranges are
2936          * included in the given Language Priority List, they are mapped to the
2937          * basic language range. Specifically, a language range starting with a
2938          * subtag {@code &quot;*&quot;} is treated as a language range {@code &quot;*&quot;}. For
2939          * example, {@code &quot;*-US&quot;} is treated as {@code &quot;*&quot;}. If {@code &quot;*&quot;} is
2940          * not the first subtag, {@code &quot;*&quot;} and extra {@code &quot;-&quot;} are removed.
2941          * For example, {@code &quot;ja-*-JP&quot;} is mapped to {@code &quot;ja-JP&quot;}.
2942          */
2943         MAP_EXTENDED_RANGES,
2944 
2945         /**
2946          * Specifies basic filtering: If any extended language ranges are
2947          * included in the given Language Priority List, the list is rejected
2948          * and the filtering method throws {@link IllegalArgumentException}.
2949          */
2950         REJECT_EXTENDED_RANGES
2951     };
2952 
2953     /**
2954      * This class expresses a &lt;em&gt;Language Range&lt;/em&gt; defined in
2955      * &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of
2956      * Language Tags&lt;/a&gt;. A language range is an identifier which is used to
2957      * select language tag(s) meeting specific requirements by using the
2958      * mechanisms described in &lt;a href=&quot;Locale.html#LocaleMatching&quot;&gt;Locale
2959      * Matching&lt;/a&gt;. A list which represents a user&#39;s preferences and consists
2960      * of language ranges is called a &lt;em&gt;Language Priority List&lt;/em&gt;.
2961      *
2962      * &lt;p&gt;There are two types of language ranges: basic and extended. In RFC
2963      * 4647, the syntax of language ranges is expressed in
2964      * &lt;a href=&quot;http://tools.ietf.org/html/rfc4234&quot;&gt;ABNF&lt;/a&gt; as follows:
2965      * &lt;blockquote&gt;
2966      * &lt;pre&gt;
2967      *     basic-language-range    = (1*8ALPHA *(&quot;-&quot; 1*8alphanum)) / &quot;*&quot;
2968      *     extended-language-range = (1*8ALPHA / &quot;*&quot;)
2969      *                               *(&quot;-&quot; (1*8alphanum / &quot;*&quot;))
2970      *     alphanum                = ALPHA / DIGIT
2971      * &lt;/pre&gt;
2972      * &lt;/blockquote&gt;
2973      * For example, {@code &quot;en&quot;} (English), {@code &quot;ja-JP&quot;} (Japanese, Japan),
2974      * {@code &quot;*&quot;} (special language range which matches any language tag) are
2975      * basic language ranges, whereas {@code &quot;*-CH&quot;} (any languages,
2976      * Switzerland), {@code &quot;es-*&quot;} (Spanish, any regions), and
2977      * {@code &quot;zh-Hant-*&quot;} (Traditional Chinese, any regions) are extended
2978      * language ranges.
2979      *
2980      * @see #filter
2981      * @see #filterTags
2982      * @see #lookup
2983      * @see #lookupTag
2984      *
2985      * @since 1.8
2986      */
2987     public static final class LanguageRange {
2988 
2989        /**
2990         * A constant holding the maximum value of weight, 1.0, which indicates
2991         * that the language range is a good fit for the user.
2992         */
2993         public static final double MAX_WEIGHT = 1.0;
2994 
2995        /**
2996         * A constant holding the minimum value of weight, 0.0, which indicates
2997         * that the language range is not a good fit for the user.
2998         */
2999         public static final double MIN_WEIGHT = 0.0;
3000 
3001         private final String range;
3002         private final double weight;
3003 
3004         private volatile int hash;
3005 
3006         /**
3007          * Constructs a {@code LanguageRange} using the given {@code range}.
3008          * Note that no validation is done against the IANA Language Subtag
3009          * Registry at time of construction.
3010          *
3011          * &lt;p&gt;This is equivalent to {@code LanguageRange(range, MAX_WEIGHT)}.
3012          *
3013          * @param range a language range
3014          * @throws NullPointerException if the given {@code range} is
3015          *     {@code null}
3016          * @throws IllegalArgumentException if the given {@code range} does not
3017          * comply with the syntax of the language range mentioned in RFC 4647
3018          */
3019         public LanguageRange(String range) {
3020             this(range, MAX_WEIGHT);
3021         }
3022 
3023         /**
3024          * Constructs a {@code LanguageRange} using the given {@code range} and
3025          * {@code weight}. Note that no validation is done against the IANA
3026          * Language Subtag Registry at time of construction.
3027          *
3028          * @param range  a language range
3029          * @param weight a weight value between {@code MIN_WEIGHT} and
3030          *     {@code MAX_WEIGHT}
3031          * @throws NullPointerException if the given {@code range} is
3032          *     {@code null}
3033          * @throws IllegalArgumentException if the given {@code range} does not
3034          * comply with the syntax of the language range mentioned in RFC 4647
3035          * or if the given {@code weight} is less than {@code MIN_WEIGHT}
3036          * or greater than {@code MAX_WEIGHT}
3037          */
3038         public LanguageRange(String range, double weight) {
3039             if (range == null) {
3040                 throw new NullPointerException();
3041             }
3042             if (weight &lt; MIN_WEIGHT || weight &gt; MAX_WEIGHT) {
3043                 throw new IllegalArgumentException(&quot;weight=&quot; + weight);
3044             }
3045 
3046             range = range.toLowerCase(Locale.ROOT);
3047 
3048             // Do syntax check.
3049             boolean isIllFormed = false;
3050             String[] subtags = range.split(&quot;-&quot;);
3051             if (isSubtagIllFormed(subtags[0], true)
3052                 || range.endsWith(&quot;-&quot;)) {
3053                 isIllFormed = true;
3054             } else {
3055                 for (int i = 1; i &lt; subtags.length; i++) {
3056                     if (isSubtagIllFormed(subtags[i], false)) {
3057                         isIllFormed = true;
3058                         break;
3059                     }
3060                 }
3061             }
3062             if (isIllFormed) {
3063                 throw new IllegalArgumentException(&quot;range=&quot; + range);
3064             }
3065 
3066             this.range = range;
3067             this.weight = weight;
3068         }
3069 
3070         private static boolean isSubtagIllFormed(String subtag,
3071                                                  boolean isFirstSubtag) {
3072             if (subtag.isEmpty() || subtag.length() &gt; 8) {
3073                 return true;
3074             } else if (subtag.equals(&quot;*&quot;)) {
3075                 return false;
3076             }
3077             char[] charArray = subtag.toCharArray();
3078             if (isFirstSubtag) { // ALPHA
3079                 for (char c : charArray) {
3080                     if (c &lt; &#39;a&#39; || c &gt; &#39;z&#39;) {
3081                         return true;
3082                     }
3083                 }
3084             } else { // ALPHA / DIGIT
3085                 for (char c : charArray) {
3086                     if (c &lt; &#39;0&#39; || (c &gt; &#39;9&#39; &amp;&amp; c &lt; &#39;a&#39;) || c &gt; &#39;z&#39;) {
3087                         return true;
3088                     }
3089                 }
3090             }
3091             return false;
3092         }
3093 
3094         /**
3095          * Returns the language range of this {@code LanguageRange}.
3096          *
3097          * @return the language range.
3098          */
3099         public String getRange() {
3100             return range;
3101         }
3102 
3103         /**
3104          * Returns the weight of this {@code LanguageRange}.
3105          *
3106          * @return the weight value.
3107          */
3108         public double getWeight() {
3109             return weight;
3110         }
3111 
3112         /**
3113          * Parses the given {@code ranges} to generate a Language Priority List.
3114          *
3115          * &lt;p&gt;This method performs a syntactic check for each language range in
3116          * the given {@code ranges} but doesn&#39;t do validation using the IANA
3117          * Language Subtag Registry.
3118          *
3119          * &lt;p&gt;The {@code ranges} to be given can take one of the following
3120          * forms:
3121          *
3122          * &lt;pre&gt;
3123          *   &quot;Accept-Language: ja,en;q=0.4&quot;  (weighted list with Accept-Language prefix)
3124          *   &quot;ja,en;q=0.4&quot;                   (weighted list)
3125          *   &quot;ja,en&quot;                         (prioritized list)
3126          * &lt;/pre&gt;
3127          *
3128          * In a weighted list, each language range is given a weight value.
3129          * The weight value is identical to the &quot;quality value&quot; in
3130          * &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, and it
3131          * expresses how much the user prefers  the language. A weight value is
3132          * specified after a corresponding language range followed by
3133          * {@code &quot;;q=&quot;}, and the default weight value is {@code MAX_WEIGHT}
3134          * when it is omitted.
3135          *
3136          * &lt;p&gt;Unlike a weighted list, language ranges in a prioritized list
3137          * are sorted in the descending order based on its priority. The first
3138          * language range has the highest priority and meets the user&#39;s
3139          * preference most.
3140          *
3141          * &lt;p&gt;In either case, language ranges are sorted in descending order in
3142          * the Language Priority List based on priority or weight. If a
3143          * language range appears in the given {@code ranges} more than once,
3144          * only the first one is included on the Language Priority List.
3145          *
3146          * &lt;p&gt;The returned list consists of language ranges from the given
3147          * {@code ranges} and their equivalents found in the IANA Language
3148          * Subtag Registry. For example, if the given {@code ranges} is
3149          * {@code &quot;Accept-Language: iw,en-us;q=0.7,en;q=0.3&quot;}, the elements in
3150          * the list to be returned are:
3151          *
3152          * &lt;pre&gt;
3153          *  &lt;b&gt;Range&lt;/b&gt;                                   &lt;b&gt;Weight&lt;/b&gt;
3154          *    &quot;iw&quot; (older tag for Hebrew)             1.0
3155          *    &quot;he&quot; (new preferred code for Hebrew)    1.0
3156          *    &quot;en-us&quot; (English, United States)        0.7
3157          *    &quot;en&quot; (English)                          0.3
3158          * &lt;/pre&gt;
3159          *
3160          * Two language ranges, {@code &quot;iw&quot;} and {@code &quot;he&quot;}, have the same
3161          * highest priority in the list. By adding {@code &quot;he&quot;} to the user&#39;s
3162          * Language Priority List, locale-matching method can find Hebrew as a
3163          * matching locale (or language tag) even if the application or system
3164          * offers only {@code &quot;he&quot;} as a supported locale (or language tag).
3165          *
3166          * @param ranges a list of comma-separated language ranges or a list of
3167          *     language ranges in the form of the &quot;Accept-Language&quot; header
3168          *     defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC
3169          *     2616&lt;/a&gt;
3170          * @return a Language Priority List consisting of language ranges
3171          *     included in the given {@code ranges} and their equivalent
3172          *     language ranges if available. The list is modifiable.
3173          * @throws NullPointerException if {@code ranges} is null
3174          * @throws IllegalArgumentException if a language range or a weight
3175          *     found in the given {@code ranges} is ill-formed
3176          */
3177         public static List&lt;LanguageRange&gt; parse(String ranges) {
3178             return LocaleMatcher.parse(ranges);
3179         }
3180 
3181         /**
3182          * Parses the given {@code ranges} to generate a Language Priority
3183          * List, and then customizes the list using the given {@code map}.
3184          * This method is equivalent to
3185          * {@code mapEquivalents(parse(ranges), map)}.
3186          *
3187          * @param ranges a list of comma-separated language ranges or a list
3188          *     of language ranges in the form of the &quot;Accept-Language&quot; header
3189          *     defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC
3190          *     2616&lt;/a&gt;
3191          * @param map a map containing information to customize language ranges
3192          * @return a Language Priority List with customization. The list is
3193          *     modifiable.
3194          * @throws NullPointerException if {@code ranges} is null
3195          * @throws IllegalArgumentException if a language range or a weight
3196          *     found in the given {@code ranges} is ill-formed
3197          * @see #parse(String)
3198          * @see #mapEquivalents
3199          */
3200         public static List&lt;LanguageRange&gt; parse(String ranges,
3201                                                 Map&lt;String, List&lt;String&gt;&gt; map) {
3202             return mapEquivalents(parse(ranges), map);
3203         }
3204 
3205         /**
3206          * Generates a new customized Language Priority List using the given
3207          * {@code priorityList} and {@code map}. If the given {@code map} is
3208          * empty, this method returns a copy of the given {@code priorityList}.
3209          *
3210          * &lt;p&gt;In the map, a key represents a language range whereas a value is
3211          * a list of equivalents of it. {@code &#39;*&#39;} cannot be used in the map.
3212          * Each equivalent language range has the same weight value as its
3213          * original language range.
3214          *
3215          * &lt;pre&gt;
3216          *  An example of map:
3217          *    &lt;b&gt;Key&lt;/b&gt;                            &lt;b&gt;Value&lt;/b&gt;
3218          *      &quot;zh&quot; (Chinese)                 &quot;zh&quot;,
3219          *                                     &quot;zh-Hans&quot;(Simplified Chinese)
3220          *      &quot;zh-HK&quot; (Chinese, Hong Kong)   &quot;zh-HK&quot;
3221          *      &quot;zh-TW&quot; (Chinese, Taiwan)      &quot;zh-TW&quot;
3222          * &lt;/pre&gt;
3223          *
3224          * The customization is performed after modification using the IANA
3225          * Language Subtag Registry.
3226          *
3227          * &lt;p&gt;For example, if a user&#39;s Language Priority List consists of five
3228          * language ranges ({@code &quot;zh&quot;}, {@code &quot;zh-CN&quot;}, {@code &quot;en&quot;},
3229          * {@code &quot;zh-TW&quot;}, and {@code &quot;zh-HK&quot;}), the newly generated Language
3230          * Priority List which is customized using the above map example will
3231          * consists of {@code &quot;zh&quot;}, {@code &quot;zh-Hans&quot;}, {@code &quot;zh-CN&quot;},
3232          * {@code &quot;zh-Hans-CN&quot;}, {@code &quot;en&quot;}, {@code &quot;zh-TW&quot;}, and
3233          * {@code &quot;zh-HK&quot;}.
3234          *
3235          * &lt;p&gt;{@code &quot;zh-HK&quot;} and {@code &quot;zh-TW&quot;} aren&#39;t converted to
3236          * {@code &quot;zh-Hans-HK&quot;} nor {@code &quot;zh-Hans-TW&quot;} even if they are
3237          * included in the Language Priority List. In this example, mapping
3238          * is used to clearly distinguish Simplified Chinese and Traditional
3239          * Chinese.
3240          *
3241          * &lt;p&gt;If the {@code &quot;zh&quot;}-to-{@code &quot;zh&quot;} mapping isn&#39;t included in the
3242          * map, a simple replacement will be performed and the customized list
3243          * won&#39;t include {@code &quot;zh&quot;} and {@code &quot;zh-CN&quot;}.
3244          *
3245          * @param priorityList user&#39;s Language Priority List
3246          * @param map a map containing information to customize language ranges
3247          * @return a new Language Priority List with customization. The list is
3248          *     modifiable.
3249          * @throws NullPointerException if {@code priorityList} is {@code null}
3250          * @see #parse(String, Map)
3251          */
3252         public static List&lt;LanguageRange&gt; mapEquivalents(
3253                                               List&lt;LanguageRange&gt;priorityList,
3254                                               Map&lt;String, List&lt;String&gt;&gt; map) {
3255             return LocaleMatcher.mapEquivalents(priorityList, map);
3256         }
3257 
3258         /**
3259          * Returns a hash code value for the object.
3260          *
3261          * @return  a hash code value for this object.
3262          */
3263         @Override
3264         public int hashCode() {
3265             int h = hash;
3266             if (h == 0) {
3267                 h = 17;
3268                 h = 37*h + range.hashCode();
3269                 long bitsWeight = Double.doubleToLongBits(weight);
3270                 h = 37*h + (int)(bitsWeight ^ (bitsWeight &gt;&gt;&gt; 32));
3271                 if (h != 0) {
3272                     hash = h;
3273                 }
3274             }
3275             return h;
3276         }
3277 
3278         /**
3279          * Compares this object to the specified object. The result is true if
3280          * and only if the argument is not {@code null} and is a
3281          * {@code LanguageRange} object that contains the same {@code range}
3282          * and {@code weight} values as this object.
3283          *
3284          * @param obj the object to compare with
3285          * @return  {@code true} if this object&#39;s {@code range} and
3286          *     {@code weight} are the same as the {@code obj}&#39;s; {@code false}
3287          *     otherwise.
3288          */
3289         @Override
3290         public boolean equals(Object obj) {
3291             if (this == obj) {
3292                 return true;
3293             }
3294             if (!(obj instanceof LanguageRange)) {
3295                 return false;
3296             }
3297             LanguageRange other = (LanguageRange)obj;
3298             return hash == other.hash
3299                    &amp;&amp; range.equals(other.range)
3300                    &amp;&amp; weight == other.weight;
3301         }
3302 
3303         /**
3304          * Returns an informative string representation of this {@code LanguageRange}
3305          * object, consisting of language range and weight if the range is
3306          * weighted and the weight is less than the max weight.
3307          *
3308          * @return a string representation of this {@code LanguageRange} object.
3309          */
3310         @Override
3311         public String toString() {
3312             return (weight == MAX_WEIGHT) ? range : range + &quot;;q=&quot; + weight;
3313         }
3314     }
3315 
3316     /**
3317      * Returns a list of matching {@code Locale} instances using the filtering
3318      * mechanism defined in RFC 4647.
3319      *
3320      * This filter operation on the given {@code locales} ensures that only
3321      * unique matching locale(s) are returned.
3322      *
3323      * @param priorityList user&#39;s Language Priority List in which each language
3324      *     tag is sorted in descending order based on priority or weight
3325      * @param locales {@code Locale} instances used for matching
3326      * @param mode filtering mode
3327      * @return a list of {@code Locale} instances for matching language tags
3328      *     sorted in descending order based on priority or weight, or an empty
3329      *     list if nothing matches. The list is modifiable.
3330      * @throws NullPointerException if {@code priorityList} or {@code locales}
3331      *     is {@code null}
3332      * @throws IllegalArgumentException if one or more extended language ranges
3333      *     are included in the given list when
3334      *     {@link FilteringMode#REJECT_EXTENDED_RANGES} is specified
3335      *
3336      * @since 1.8
3337      */
3338     public static List&lt;Locale&gt; filter(List&lt;LanguageRange&gt; priorityList,
3339                                       Collection&lt;Locale&gt; locales,
3340                                       FilteringMode mode) {
3341         return LocaleMatcher.filter(priorityList, locales, mode);
3342     }
3343 
3344     /**
3345      * Returns a list of matching {@code Locale} instances using the filtering
3346      * mechanism defined in RFC 4647. This is equivalent to
3347      * {@link #filter(List, Collection, FilteringMode)} when {@code mode} is
3348      * {@link FilteringMode#AUTOSELECT_FILTERING}.
3349      *
3350      * This filter operation on the given {@code locales} ensures that only
3351      * unique matching locale(s) are returned.
3352      *
3353      * @param priorityList user&#39;s Language Priority List in which each language
3354      *     tag is sorted in descending order based on priority or weight
3355      * @param locales {@code Locale} instances used for matching
3356      * @return a list of {@code Locale} instances for matching language tags
3357      *     sorted in descending order based on priority or weight, or an empty
3358      *     list if nothing matches. The list is modifiable.
3359      * @throws NullPointerException if {@code priorityList} or {@code locales}
3360      *     is {@code null}
3361      *
3362      * @since 1.8
3363      */
3364     public static List&lt;Locale&gt; filter(List&lt;LanguageRange&gt; priorityList,
3365                                       Collection&lt;Locale&gt; locales) {
3366         return filter(priorityList, locales, FilteringMode.AUTOSELECT_FILTERING);
3367     }
3368 
3369     /**
3370      * Returns a list of matching languages tags using the basic filtering
3371      * mechanism defined in RFC 4647.
3372      *
3373      * This filter operation on the given {@code tags} ensures that only
3374      * unique matching tag(s) are returned with preserved case. In case of
3375      * duplicate matching tags with the case difference, the first matching
3376      * tag with preserved case is returned.
3377      * For example, &quot;de-ch&quot; is returned out of the duplicate matching tags
3378      * &quot;de-ch&quot; and &quot;de-CH&quot;, if &quot;de-ch&quot; is checked first for matching in the
3379      * given {@code tags}. Note that if the given {@code tags} is an unordered
3380      * {@code Collection}, the returned matching tag out of duplicate tags is
3381      * subject to change, depending on the implementation of the
3382      * {@code Collection}.
3383      *
3384      * @param priorityList user&#39;s Language Priority List in which each language
3385      *     tag is sorted in descending order based on priority or weight
3386      * @param tags language tags
3387      * @param mode filtering mode
3388      * @return a list of matching language tags sorted in descending order
3389      *     based on priority or weight, or an empty list if nothing matches.
3390      *     The list is modifiable.
3391      * @throws NullPointerException if {@code priorityList} or {@code tags} is
3392      *     {@code null}
3393      * @throws IllegalArgumentException if one or more extended language ranges
3394      *     are included in the given list when
3395      *     {@link FilteringMode#REJECT_EXTENDED_RANGES} is specified
3396      *
3397      * @since 1.8
3398      */
3399     public static List&lt;String&gt; filterTags(List&lt;LanguageRange&gt; priorityList,
3400                                           Collection&lt;String&gt; tags,
3401                                           FilteringMode mode) {
3402         return LocaleMatcher.filterTags(priorityList, tags, mode);
3403     }
3404 
3405     /**
3406      * Returns a list of matching languages tags using the basic filtering
3407      * mechanism defined in RFC 4647. This is equivalent to
3408      * {@link #filterTags(List, Collection, FilteringMode)} when {@code mode}
3409      * is {@link FilteringMode#AUTOSELECT_FILTERING}.
3410      *
3411      * This filter operation on the given {@code tags} ensures that only
3412      * unique matching tag(s) are returned with preserved case. In case of
3413      * duplicate matching tags with the case difference, the first matching
3414      * tag with preserved case is returned.
3415      * For example, &quot;de-ch&quot; is returned out of the duplicate matching tags
3416      * &quot;de-ch&quot; and &quot;de-CH&quot;, if &quot;de-ch&quot; is checked first for matching in the
3417      * given {@code tags}. Note that if the given {@code tags} is an unordered
3418      * {@code Collection}, the returned matching tag out of duplicate tags is
3419      * subject to change, depending on the implementation of the
3420      * {@code Collection}.
3421      *
3422      * @param priorityList user&#39;s Language Priority List in which each language
3423      *     tag is sorted in descending order based on priority or weight
3424      * @param tags language tags
3425      * @return a list of matching language tags sorted in descending order
3426      *     based on priority or weight, or an empty list if nothing matches.
3427      *     The list is modifiable.
3428      * @throws NullPointerException if {@code priorityList} or {@code tags} is
3429      *     {@code null}
3430      *
3431      * @since 1.8
3432      */
3433     public static List&lt;String&gt; filterTags(List&lt;LanguageRange&gt; priorityList,
3434                                           Collection&lt;String&gt; tags) {
3435         return filterTags(priorityList, tags, FilteringMode.AUTOSELECT_FILTERING);
3436     }
3437 
3438     /**
3439      * Returns a {@code Locale} instance for the best-matching language
3440      * tag using the lookup mechanism defined in RFC 4647.
3441      *
3442      * @param priorityList user&#39;s Language Priority List in which each language
3443      *     tag is sorted in descending order based on priority or weight
3444      * @param locales {@code Locale} instances used for matching
<a name="152" id="anc152"></a><span class="line-modified">3445      * @return the best matching &lt;code&gt;Locale&lt;/code&gt; instance chosen based on</span>
3446      *     priority or weight, or {@code null} if nothing matches.
3447      * @throws NullPointerException if {@code priorityList} or {@code tags} is
3448      *     {@code null}
3449      *
3450      * @since 1.8
3451      */
3452     public static Locale lookup(List&lt;LanguageRange&gt; priorityList,
3453                                 Collection&lt;Locale&gt; locales) {
3454         return LocaleMatcher.lookup(priorityList, locales);
3455     }
3456 
3457     /**
3458      * Returns the best-matching language tag using the lookup mechanism
3459      * defined in RFC 4647.
3460      *
3461      * This lookup operation on the given {@code tags} ensures that the
3462      * first matching tag with preserved case is returned.
3463      *
3464      * @param priorityList user&#39;s Language Priority List in which each language
3465      *     tag is sorted in descending order based on priority or weight
3466      * @param tags language tangs used for matching
3467      * @return the best matching language tag chosen based on priority or
3468      *     weight, or {@code null} if nothing matches.
3469      * @throws NullPointerException if {@code priorityList} or {@code tags} is
3470      *     {@code null}
3471      *
3472      * @since 1.8
3473      */
3474     public static String lookupTag(List&lt;LanguageRange&gt; priorityList,
3475                                    Collection&lt;String&gt; tags) {
3476         return LocaleMatcher.lookupTag(priorityList, tags);
3477     }
3478 
3479 }
<a name="153" id="anc153"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="153" type="hidden" />
</body>
</html>
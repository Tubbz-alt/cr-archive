<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/io/BufferedInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../com/sun/security/ntlm/NTLMException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BufferedOutputStream.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/BufferedInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,45 ***</span>
   */
  
  package java.io;
  
  import jdk.internal.misc.Unsafe;
  
  /**
<span class="line-modified">!  * A &lt;code&gt;BufferedInputStream&lt;/code&gt; adds</span>
   * functionality to another input stream-namely,
   * the ability to buffer the input and to
<span class="line-modified">!  * support the &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;</span>
<span class="line-modified">!  * methods. When  the &lt;code&gt;BufferedInputStream&lt;/code&gt;</span>
   * is created, an internal buffer array is
   * created. As bytes  from the stream are read
   * or skipped, the internal buffer is refilled
   * as necessary  from the contained input stream,
<span class="line-modified">!  * many bytes at a time. The &lt;code&gt;mark&lt;/code&gt;</span>
   * operation  remembers a point in the input
<span class="line-modified">!  * stream and the &lt;code&gt;reset&lt;/code&gt; operation</span>
   * causes all the  bytes read since the most
<span class="line-modified">!  * recent &lt;code&gt;mark&lt;/code&gt; operation to be</span>
   * reread before new bytes are  taken from
   * the contained input stream.
   *
   * @author  Arthur van Hoff
   * @since   1.0
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class BufferedInputStream extends FilterInputStream {</span>
  
      private static int DEFAULT_BUFFER_SIZE = 8192;
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * The maximum size of array to allocate.</span>
<span class="line-removed">-      * Some VMs reserve some header words in an array.</span>
<span class="line-removed">-      * Attempts to allocate larger arrays may result in</span>
<span class="line-removed">-      * OutOfMemoryError: Requested array size exceeds VM limit</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;</span>
<span class="line-removed">- </span>
      /**
       * As this class is used early during bootstrap, it&#39;s motivated to use
       * Unsafe.compareAndSetObject instead of AtomicReferenceFieldUpdater
       * (or VarHandles) to reduce dependencies and improve startup time.
       */
<span class="line-new-header">--- 24,37 ---</span>
   */
  
  package java.io;
  
  import jdk.internal.misc.Unsafe;
<span class="line-added">+ import jdk.internal.util.ArraysSupport;</span>
  
  /**
<span class="line-modified">!  * A {@code BufferedInputStream} adds</span>
   * functionality to another input stream-namely,
   * the ability to buffer the input and to
<span class="line-modified">!  * support the {@code mark} and {@code reset}</span>
<span class="line-modified">!  * methods. When  the {@code BufferedInputStream}</span>
   * is created, an internal buffer array is
   * created. As bytes  from the stream are read
   * or skipped, the internal buffer is refilled
   * as necessary  from the contained input stream,
<span class="line-modified">!  * many bytes at a time. The {@code mark}</span>
   * operation  remembers a point in the input
<span class="line-modified">!  * stream and the {@code reset} operation</span>
   * causes all the  bytes read since the most
<span class="line-modified">!  * recent {@code mark} operation to be</span>
   * reread before new bytes are  taken from
   * the contained input stream.
   *
   * @author  Arthur van Hoff
   * @since   1.0
   */
<span class="line-modified">! public class BufferedInputStream extends FilterInputStream {</span>
  
      private static int DEFAULT_BUFFER_SIZE = 8192;
  
      /**
       * As this class is used early during bootstrap, it&#39;s motivated to use
       * Unsafe.compareAndSetObject instead of AtomicReferenceFieldUpdater
       * (or VarHandles) to reduce dependencies and improve startup time.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,71 ***</span>
  
      /**
       * The index one greater than the index of the last valid byte in
       * the buffer.
       * This value is always
<span class="line-modified">!      * in the range &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;buf.length&lt;/code&gt;;</span>
<span class="line-modified">!      * elements &lt;code&gt;buf[0]&lt;/code&gt;  through &lt;code&gt;buf[count-1]</span>
<span class="line-modified">!      * &lt;/code&gt;contain buffered input data obtained</span>
       * from the underlying  input stream.
       */
      protected int count;
  
      /**
       * The current position in the buffer. This is the index of the next
<span class="line-modified">!      * character to be read from the &lt;code&gt;buf&lt;/code&gt; array.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This value is always in the range &lt;code&gt;0&lt;/code&gt;</span>
<span class="line-modified">!      * through &lt;code&gt;count&lt;/code&gt;. If it is less</span>
<span class="line-modified">!      * than &lt;code&gt;count&lt;/code&gt;, then  &lt;code&gt;buf[pos]&lt;/code&gt;</span>
       * is the next byte to be supplied as input;
<span class="line-modified">!      * if it is equal to &lt;code&gt;count&lt;/code&gt;, then</span>
<span class="line-modified">!      * the  next &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;</span>
       * operation will require more bytes to be
       * read from the contained  input stream.
       *
       * @see     java.io.BufferedInputStream#buf
       */
      protected int pos;
  
      /**
<span class="line-modified">!      * The value of the &lt;code&gt;pos&lt;/code&gt; field at the time the last</span>
<span class="line-modified">!      * &lt;code&gt;mark&lt;/code&gt; method was called.</span>
       * &lt;p&gt;
       * This value is always
<span class="line-modified">!      * in the range &lt;code&gt;-1&lt;/code&gt; through &lt;code&gt;pos&lt;/code&gt;.</span>
       * If there is no marked position in  the input
<span class="line-modified">!      * stream, this field is &lt;code&gt;-1&lt;/code&gt;. If</span>
       * there is a marked position in the input
<span class="line-modified">!      * stream,  then &lt;code&gt;buf[markpos]&lt;/code&gt;</span>
       * is the first byte to be supplied as input
<span class="line-modified">!      * after a &lt;code&gt;reset&lt;/code&gt; operation. If</span>
<span class="line-modified">!      * &lt;code&gt;markpos&lt;/code&gt; is not &lt;code&gt;-1&lt;/code&gt;,</span>
<span class="line-modified">!      * then all bytes from positions &lt;code&gt;buf[markpos]&lt;/code&gt;</span>
<span class="line-modified">!      * through  &lt;code&gt;buf[pos-1]&lt;/code&gt; must remain</span>
       * in the buffer array (though they may be
       * moved to  another place in the buffer array,
       * with suitable adjustments to the values
<span class="line-modified">!      * of &lt;code&gt;count&lt;/code&gt;,  &lt;code&gt;pos&lt;/code&gt;,</span>
<span class="line-modified">!      * and &lt;code&gt;markpos&lt;/code&gt;); they may not</span>
       * be discarded unless and until the difference
<span class="line-modified">!      * between &lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;markpos&lt;/code&gt;</span>
<span class="line-modified">!      * exceeds &lt;code&gt;marklimit&lt;/code&gt;.</span>
       *
       * @see     java.io.BufferedInputStream#mark(int)
       * @see     java.io.BufferedInputStream#pos
       */
      protected int markpos = -1;
  
      /**
       * The maximum read ahead allowed after a call to the
<span class="line-modified">!      * &lt;code&gt;mark&lt;/code&gt; method before subsequent calls to the</span>
<span class="line-modified">!      * &lt;code&gt;reset&lt;/code&gt; method fail.</span>
<span class="line-modified">!      * Whenever the difference between &lt;code&gt;pos&lt;/code&gt;</span>
<span class="line-modified">!      * and &lt;code&gt;markpos&lt;/code&gt; exceeds &lt;code&gt;marklimit&lt;/code&gt;,</span>
       * then the  mark may be dropped by setting
<span class="line-modified">!      * &lt;code&gt;markpos&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt;.</span>
       *
       * @see     java.io.BufferedInputStream#mark(int)
       * @see     java.io.BufferedInputStream#reset()
       */
      protected int marklimit;
<span class="line-new-header">--- 78,71 ---</span>
  
      /**
       * The index one greater than the index of the last valid byte in
       * the buffer.
       * This value is always
<span class="line-modified">!      * in the range {@code 0} through {@code buf.length};</span>
<span class="line-modified">!      * elements {@code buf[0]} through {@code buf[count-1]}</span>
<span class="line-modified">!      * contain buffered input data obtained</span>
       * from the underlying  input stream.
       */
      protected int count;
  
      /**
       * The current position in the buffer. This is the index of the next
<span class="line-modified">!      * character to be read from the {@code buf} array.</span>
       * &lt;p&gt;
<span class="line-modified">!      * This value is always in the range {@code 0}</span>
<span class="line-modified">!      * through {@code count}. If it is less</span>
<span class="line-modified">!      * than {@code count}, then  {@code buf[pos]}</span>
       * is the next byte to be supplied as input;
<span class="line-modified">!      * if it is equal to {@code count}, then</span>
<span class="line-modified">!      * the  next {@code read} or {@code skip}</span>
       * operation will require more bytes to be
       * read from the contained  input stream.
       *
       * @see     java.io.BufferedInputStream#buf
       */
      protected int pos;
  
      /**
<span class="line-modified">!      * The value of the {@code pos} field at the time the last</span>
<span class="line-modified">!      * {@code mark} method was called.</span>
       * &lt;p&gt;
       * This value is always
<span class="line-modified">!      * in the range {@code -1} through {@code pos}.</span>
       * If there is no marked position in  the input
<span class="line-modified">!      * stream, this field is {@code -1}. If</span>
       * there is a marked position in the input
<span class="line-modified">!      * stream,  then {@code buf[markpos]}</span>
       * is the first byte to be supplied as input
<span class="line-modified">!      * after a {@code reset} operation. If</span>
<span class="line-modified">!      * {@code markpos} is not {@code -1},</span>
<span class="line-modified">!      * then all bytes from positions {@code buf[markpos]}</span>
<span class="line-modified">!      * through  {@code buf[pos-1]} must remain</span>
       * in the buffer array (though they may be
       * moved to  another place in the buffer array,
       * with suitable adjustments to the values
<span class="line-modified">!      * of {@code count},  {@code pos},</span>
<span class="line-modified">!      * and {@code markpos}); they may not</span>
       * be discarded unless and until the difference
<span class="line-modified">!      * between {@code pos} and {@code markpos}</span>
<span class="line-modified">!      * exceeds {@code marklimit}.</span>
       *
       * @see     java.io.BufferedInputStream#mark(int)
       * @see     java.io.BufferedInputStream#pos
       */
      protected int markpos = -1;
  
      /**
       * The maximum read ahead allowed after a call to the
<span class="line-modified">!      * {@code mark} method before subsequent calls to the</span>
<span class="line-modified">!      * {@code reset} method fail.</span>
<span class="line-modified">!      * Whenever the difference between {@code pos}</span>
<span class="line-modified">!      * and {@code markpos} exceeds {@code marklimit},</span>
       * then the  mark may be dropped by setting
<span class="line-modified">!      * {@code markpos} to {@code -1}.</span>
       *
       * @see     java.io.BufferedInputStream#mark(int)
       * @see     java.io.BufferedInputStream#reset()
       */
      protected int marklimit;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,32 ***</span>
              throw new IOException(&quot;Stream closed&quot;);
          return buffer;
      }
  
      /**
<span class="line-modified">!      * Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt;</span>
       * and saves its  argument, the input stream
<span class="line-modified">!      * &lt;code&gt;in&lt;/code&gt;, for later use. An internal</span>
<span class="line-modified">!      * buffer array is created and  stored in &lt;code&gt;buf&lt;/code&gt;.</span>
       *
       * @param   in   the underlying input stream.
       */
      public BufferedInputStream(InputStream in) {
          this(in, DEFAULT_BUFFER_SIZE);
      }
  
      /**
<span class="line-modified">!      * Creates a &lt;code&gt;BufferedInputStream&lt;/code&gt;</span>
       * with the specified buffer size,
       * and saves its  argument, the input stream
<span class="line-modified">!      * &lt;code&gt;in&lt;/code&gt;, for later use.  An internal</span>
<span class="line-modified">!      * buffer array of length  &lt;code&gt;size&lt;/code&gt;</span>
<span class="line-modified">!      * is created and stored in &lt;code&gt;buf&lt;/code&gt;.</span>
       *
       * @param   in     the underlying input stream.
       * @param   size   the buffer size.
<span class="line-modified">!      * @exception IllegalArgumentException if {@code size &lt;= 0}.</span>
       */
      public BufferedInputStream(InputStream in, int size) {
          super(in);
          if (size &lt;= 0) {
              throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
<span class="line-new-header">--- 168,32 ---</span>
              throw new IOException(&quot;Stream closed&quot;);
          return buffer;
      }
  
      /**
<span class="line-modified">!      * Creates a {@code BufferedInputStream}</span>
       * and saves its  argument, the input stream
<span class="line-modified">!      * {@code in}, for later use. An internal</span>
<span class="line-modified">!      * buffer array is created and  stored in {@code buf}.</span>
       *
       * @param   in   the underlying input stream.
       */
      public BufferedInputStream(InputStream in) {
          this(in, DEFAULT_BUFFER_SIZE);
      }
  
      /**
<span class="line-modified">!      * Creates a {@code BufferedInputStream}</span>
       * with the specified buffer size,
       * and saves its  argument, the input stream
<span class="line-modified">!      * {@code in}, for later use.  An internal</span>
<span class="line-modified">!      * buffer array of length  {@code size}</span>
<span class="line-modified">!      * is created and stored in {@code buf}.</span>
       *
       * @param   in     the underlying input stream.
       * @param   size   the buffer size.
<span class="line-modified">!      * @throws  IllegalArgumentException if {@code size &lt;= 0}.</span>
       */
      public BufferedInputStream(InputStream in, int size) {
          super(in);
          if (size &lt;= 0) {
              throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,24 ***</span>
       */
      private void fill() throws IOException {
          byte[] buffer = getBufIfOpen();
          if (markpos &lt; 0)
              pos = 0;            /* no mark: throw away the buffer */
<span class="line-modified">!         else if (pos &gt;= buffer.length)  /* no room left in buffer */</span>
              if (markpos &gt; 0) {  /* can throw away early part of the buffer */
                  int sz = pos - markpos;
                  System.arraycopy(buffer, markpos, buffer, 0, sz);
                  pos = sz;
                  markpos = 0;
              } else if (buffer.length &gt;= marklimit) {
                  markpos = -1;   /* buffer got too big, invalidate mark */
                  pos = 0;        /* drop buffer contents */
<span class="line-removed">-             } else if (buffer.length &gt;= MAX_BUFFER_SIZE) {</span>
<span class="line-removed">-                 throw new OutOfMemoryError(&quot;Required array size too large&quot;);</span>
              } else {            /* grow buffer */
<span class="line-modified">!                 int nsz = (pos &lt;= MAX_BUFFER_SIZE - pos) ?</span>
<span class="line-modified">!                         pos * 2 : MAX_BUFFER_SIZE;</span>
                  if (nsz &gt; marklimit)
                      nsz = marklimit;
                  byte[] nbuf = new byte[nsz];
                  System.arraycopy(buffer, 0, nbuf, 0, pos);
                  if (!U.compareAndSetReference(this, BUF_OFFSET, buffer, nbuf)) {
<span class="line-new-header">--- 210,23 ---</span>
       */
      private void fill() throws IOException {
          byte[] buffer = getBufIfOpen();
          if (markpos &lt; 0)
              pos = 0;            /* no mark: throw away the buffer */
<span class="line-modified">!         else if (pos &gt;= buffer.length) { /* no room left in buffer */</span>
              if (markpos &gt; 0) {  /* can throw away early part of the buffer */
                  int sz = pos - markpos;
                  System.arraycopy(buffer, markpos, buffer, 0, sz);
                  pos = sz;
                  markpos = 0;
              } else if (buffer.length &gt;= marklimit) {
                  markpos = -1;   /* buffer got too big, invalidate mark */
                  pos = 0;        /* drop buffer contents */
              } else {            /* grow buffer */
<span class="line-modified">!                 int nsz = ArraysSupport.newLength(pos,</span>
<span class="line-modified">!                         1,  /* minimum growth */</span>
<span class="line-added">+                         pos /* preferred growth */);</span>
                  if (nsz &gt; marklimit)
                      nsz = marklimit;
                  byte[] nbuf = new byte[nsz];
                  System.arraycopy(buffer, 0, nbuf, 0, pos);
                  if (!U.compareAndSetReference(this, BUF_OFFSET, buffer, nbuf)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,24 ***</span>
                      // assert buf == null;
                      throw new IOException(&quot;Stream closed&quot;);
                  }
                  buffer = nbuf;
              }
          count = pos;
          int n = getInIfOpen().read(buffer, pos, buffer.length - pos);
          if (n &gt; 0)
              count = n + pos;
      }
  
      /**
       * See
<span class="line-modified">!      * the general contract of the &lt;code&gt;read&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;InputStream&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @return     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the</span>
       *             stream is reached.
<span class="line-modified">!      * @exception  IOException  if this input stream has been closed by</span>
       *                          invoking its {@link #close()} method,
       *                          or an I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public synchronized int read() throws IOException {
<span class="line-new-header">--- 237,25 ---</span>
                      // assert buf == null;
                      throw new IOException(&quot;Stream closed&quot;);
                  }
                  buffer = nbuf;
              }
<span class="line-added">+         }</span>
          count = pos;
          int n = getInIfOpen().read(buffer, pos, buffer.length - pos);
          if (n &gt; 0)
              count = n + pos;
      }
  
      /**
       * See
<span class="line-modified">!      * the general contract of the {@code read}</span>
<span class="line-modified">!      * method of {@code InputStream}.</span>
       *
<span class="line-modified">!      * @return     the next byte of data, or {@code -1} if the end of the</span>
       *             stream is reached.
<span class="line-modified">!      * @throws     IOException  if this input stream has been closed by</span>
       *                          invoking its {@link #close()} method,
       *                          or an I/O error occurs.
       * @see        java.io.FilterInputStream#in
       */
      public synchronized int read() throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,36 ***</span>
       *
       * &lt;p&gt; This method implements the general contract of the corresponding
       * &lt;code&gt;{@link InputStream#read(byte[], int, int) read}&lt;/code&gt; method of
       * the &lt;code&gt;{@link InputStream}&lt;/code&gt; class.  As an additional
       * convenience, it attempts to read as many bytes as possible by repeatedly
<span class="line-modified">!      * invoking the &lt;code&gt;read&lt;/code&gt; method of the underlying stream.  This</span>
<span class="line-modified">!      * iterated &lt;code&gt;read&lt;/code&gt; continues until one of the following</span>
       * conditions becomes true: &lt;ul&gt;
       *
       *   &lt;li&gt; The specified number of bytes have been read,
       *
<span class="line-modified">!      *   &lt;li&gt; The &lt;code&gt;read&lt;/code&gt; method of the underlying stream returns</span>
<span class="line-modified">!      *   &lt;code&gt;-1&lt;/code&gt;, indicating end-of-file, or</span>
       *
<span class="line-modified">!      *   &lt;li&gt; The &lt;code&gt;available&lt;/code&gt; method of the underlying stream</span>
       *   returns zero, indicating that further input requests would block.
       *
<span class="line-modified">!      * &lt;/ul&gt; If the first &lt;code&gt;read&lt;/code&gt; on the underlying stream returns</span>
<span class="line-modified">!      * &lt;code&gt;-1&lt;/code&gt; to indicate end-of-file then this method returns</span>
<span class="line-modified">!      * &lt;code&gt;-1&lt;/code&gt;.  Otherwise this method returns the number of bytes</span>
       * actually read.
       *
       * &lt;p&gt; Subclasses of this class are encouraged, but not required, to
       * attempt to read as many bytes as possible in the same fashion.
       *
       * @param      b     destination buffer.
       * @param      off   offset at which to start storing bytes.
       * @param      len   maximum number of bytes to read.
<span class="line-modified">!      * @return     the number of bytes read, or &lt;code&gt;-1&lt;/code&gt; if the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @exception  IOException  if this input stream has been closed by</span>
       *                          invoking its {@link #close()} method,
       *                          or an I/O error occurs.
       */
      public synchronized int read(byte b[], int off, int len)
          throws IOException
<span class="line-new-header">--- 297,36 ---</span>
       *
       * &lt;p&gt; This method implements the general contract of the corresponding
       * &lt;code&gt;{@link InputStream#read(byte[], int, int) read}&lt;/code&gt; method of
       * the &lt;code&gt;{@link InputStream}&lt;/code&gt; class.  As an additional
       * convenience, it attempts to read as many bytes as possible by repeatedly
<span class="line-modified">!      * invoking the {@code read} method of the underlying stream.  This</span>
<span class="line-modified">!      * iterated {@code read} continues until one of the following</span>
       * conditions becomes true: &lt;ul&gt;
       *
       *   &lt;li&gt; The specified number of bytes have been read,
       *
<span class="line-modified">!      *   &lt;li&gt; The {@code read} method of the underlying stream returns</span>
<span class="line-modified">!      *   {@code -1}, indicating end-of-file, or</span>
       *
<span class="line-modified">!      *   &lt;li&gt; The {@code available} method of the underlying stream</span>
       *   returns zero, indicating that further input requests would block.
       *
<span class="line-modified">!      * &lt;/ul&gt; If the first {@code read} on the underlying stream returns</span>
<span class="line-modified">!      * {@code -1} to indicate end-of-file then this method returns</span>
<span class="line-modified">!      * {@code -1}.  Otherwise this method returns the number of bytes</span>
       * actually read.
       *
       * &lt;p&gt; Subclasses of this class are encouraged, but not required, to
       * attempt to read as many bytes as possible in the same fashion.
       *
       * @param      b     destination buffer.
       * @param      off   offset at which to start storing bytes.
       * @param      len   maximum number of bytes to read.
<span class="line-modified">!      * @return     the number of bytes read, or {@code -1} if the end of</span>
       *             the stream has been reached.
<span class="line-modified">!      * @throws     IOException  if this input stream has been closed by</span>
       *                          invoking its {@link #close()} method,
       *                          or an I/O error occurs.
       */
      public synchronized int read(byte b[], int off, int len)
          throws IOException
</pre>
<hr />
<pre>
<span class="line-old-header">*** 360,12 ***</span>
                  return n;
          }
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;skip&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;InputStream&lt;/code&gt;.</span>
       *
       * @throws IOException  if this input stream has been closed by
       *                      invoking its {@link #close()} method,
       *                      {@code in.skip(n)} throws an IOException,
       *                      or an I/O error occurs.
<span class="line-new-header">--- 352,12 ---</span>
                  return n;
          }
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code skip}</span>
<span class="line-modified">!      * method of {@code InputStream}.</span>
       *
       * @throws IOException  if this input stream has been closed by
       *                      invoking its {@link #close()} method,
       *                      {@code in.skip(n)} throws an IOException,
       *                      or an I/O error occurs.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 405,11 ***</span>
       * the buffer (&lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt;) and the result of calling the
       * {@link java.io.FilterInputStream#in in}.available().
       *
       * @return     an estimate of the number of bytes that can be read (or skipped
       *             over) from this input stream without blocking.
<span class="line-modified">!      * @exception  IOException  if this input stream has been closed by</span>
       *                          invoking its {@link #close()} method,
       *                          or an I/O error occurs.
       */
      public synchronized int available() throws IOException {
          int n = count - pos;
<span class="line-new-header">--- 397,11 ---</span>
       * the buffer (&lt;code&gt;count&amp;nbsp;- pos&lt;/code&gt;) and the result of calling the
       * {@link java.io.FilterInputStream#in in}.available().
       *
       * @return     an estimate of the number of bytes that can be read (or skipped
       *             over) from this input stream without blocking.
<span class="line-modified">!      * @throws     IOException  if this input stream has been closed by</span>
       *                          invoking its {@link #close()} method,
       *                          or an I/O error occurs.
       */
      public synchronized int available() throws IOException {
          int n = count - pos;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 418,12 ***</span>
                      ? Integer.MAX_VALUE
                      : n + avail;
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;mark&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;InputStream&lt;/code&gt;.</span>
       *
       * @param   readlimit   the maximum limit of bytes that can be read before
       *                      the mark position becomes invalid.
       * @see     java.io.BufferedInputStream#reset()
       */
<span class="line-new-header">--- 410,12 ---</span>
                      ? Integer.MAX_VALUE
                      : n + avail;
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code mark}</span>
<span class="line-modified">!      * method of {@code InputStream}.</span>
       *
       * @param   readlimit   the maximum limit of bytes that can be read before
       *                      the mark position becomes invalid.
       * @see     java.io.BufferedInputStream#reset()
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 431,20 ***</span>
          marklimit = readlimit;
          markpos = pos;
      }
  
      /**
<span class="line-modified">!      * See the general contract of the &lt;code&gt;reset&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;InputStream&lt;/code&gt;.</span>
       * &lt;p&gt;
<span class="line-modified">!      * If &lt;code&gt;markpos&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;</span>
       * (no mark has been set or the mark has been
<span class="line-modified">!      * invalidated), an &lt;code&gt;IOException&lt;/code&gt;</span>
<span class="line-modified">!      * is thrown. Otherwise, &lt;code&gt;pos&lt;/code&gt; is</span>
<span class="line-modified">!      * set equal to &lt;code&gt;markpos&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @exception  IOException  if this stream has not been marked or,</span>
       *                  if the mark has been invalidated, or the stream
       *                  has been closed by invoking its {@link #close()}
       *                  method, or an I/O error occurs.
       * @see        java.io.BufferedInputStream#mark(int)
       */
<span class="line-new-header">--- 423,20 ---</span>
          marklimit = readlimit;
          markpos = pos;
      }
  
      /**
<span class="line-modified">!      * See the general contract of the {@code reset}</span>
<span class="line-modified">!      * method of {@code InputStream}.</span>
       * &lt;p&gt;
<span class="line-modified">!      * If {@code markpos} is {@code -1}</span>
       * (no mark has been set or the mark has been
<span class="line-modified">!      * invalidated), an {@code IOException}</span>
<span class="line-modified">!      * is thrown. Otherwise, {@code pos} is</span>
<span class="line-modified">!      * set equal to {@code markpos}.</span>
       *
<span class="line-modified">!      * @throws     IOException  if this stream has not been marked or,</span>
       *                  if the mark has been invalidated, or the stream
       *                  has been closed by invoking its {@link #close()}
       *                  method, or an I/O error occurs.
       * @see        java.io.BufferedInputStream#mark(int)
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 454,17 ***</span>
              throw new IOException(&quot;Resetting to invalid mark&quot;);
          pos = markpos;
      }
  
      /**
<span class="line-modified">!      * Tests if this input stream supports the &lt;code&gt;mark&lt;/code&gt;</span>
<span class="line-modified">!      * and &lt;code&gt;reset&lt;/code&gt; methods. The &lt;code&gt;markSupported&lt;/code&gt;</span>
<span class="line-modified">!      * method of &lt;code&gt;BufferedInputStream&lt;/code&gt; returns</span>
<span class="line-modified">!      * &lt;code&gt;true&lt;/code&gt;.</span>
       *
<span class="line-modified">!      * @return  a &lt;code&gt;boolean&lt;/code&gt; indicating if this stream type supports</span>
<span class="line-modified">!      *          the &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt; methods.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.InputStream#reset()
       */
      public boolean markSupported() {
          return true;
<span class="line-new-header">--- 446,17 ---</span>
              throw new IOException(&quot;Resetting to invalid mark&quot;);
          pos = markpos;
      }
  
      /**
<span class="line-modified">!      * Tests if this input stream supports the {@code mark}</span>
<span class="line-modified">!      * and {@code reset} methods. The {@code markSupported}</span>
<span class="line-modified">!      * method of {@code BufferedInputStream} returns</span>
<span class="line-modified">!      * {@code true}.</span>
       *
<span class="line-modified">!      * @return  a {@code boolean} indicating if this stream type supports</span>
<span class="line-modified">!      *          the {@code mark} and {@code reset} methods.</span>
       * @see     java.io.InputStream#mark(int)
       * @see     java.io.InputStream#reset()
       */
      public boolean markSupported() {
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 475,11 ***</span>
       * associated with the stream.
       * Once the stream has been closed, further read(), available(), reset(),
       * or skip() invocations will throw an IOException.
       * Closing a previously closed stream has no effect.
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
       */
      public void close() throws IOException {
          byte[] buffer;
          while ( (buffer = buf) != null) {
              if (U.compareAndSetReference(this, BUF_OFFSET, buffer, null)) {
<span class="line-new-header">--- 467,11 ---</span>
       * associated with the stream.
       * Once the stream has been closed, further read(), available(), reset(),
       * or skip() invocations will throw an IOException.
       * Closing a previously closed stream has no effect.
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
       */
      public void close() throws IOException {
          byte[] buffer;
          while ( (buffer = buf) != null) {
              if (U.compareAndSetReference(this, BUF_OFFSET, buffer, null)) {
</pre>
<center><a href="../../com/sun/security/ntlm/NTLMException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BufferedOutputStream.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Byte.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang;
 27 
 28 import jdk.internal.HotSpotIntrinsicCandidate;
 29 import jdk.internal.misc.VM;
 30 
 31 /**
 32  *
 33  * The {@code Byte} class wraps a value of primitive type {@code byte}
 34  * in an object.  An object of type {@code Byte} contains a single
 35  * field whose type is {@code byte}.
 36  *
 37  * &lt;p&gt;In addition, this class provides several methods for converting
 38  * a {@code byte} to a {@code String} and a {@code String} to a {@code
 39  * byte}, as well as other constants and methods useful when dealing
 40  * with a {@code byte}.
 41  *
 42  * @author  Nakul Saraiya
 43  * @author  Joseph D. Darcy
 44  * @see     java.lang.Number
 45  * @since   1.1
 46  */
 47 public final class Byte extends Number implements Comparable&lt;Byte&gt; {
 48 
 49     /**
 50      * A constant holding the minimum value a {@code byte} can
 51      * have, -2&lt;sup&gt;7&lt;/sup&gt;.
 52      */
 53     public static final byte   MIN_VALUE = -128;
 54 
 55     /**
 56      * A constant holding the maximum value a {@code byte} can
 57      * have, 2&lt;sup&gt;7&lt;/sup&gt;-1.
 58      */
 59     public static final byte   MAX_VALUE = 127;
 60 
 61     /**
 62      * The {@code Class} instance representing the primitive type
 63      * {@code byte}.
 64      */
 65     @SuppressWarnings(&quot;unchecked&quot;)
 66     public static final Class&lt;Byte&gt;     TYPE = (Class&lt;Byte&gt;) Class.getPrimitiveClass(&quot;byte&quot;);
 67 
 68     /**
 69      * Returns a new {@code String} object representing the
 70      * specified {@code byte}. The radix is assumed to be 10.
 71      *
 72      * @param b the {@code byte} to be converted
 73      * @return the string representation of the specified {@code byte}
 74      * @see java.lang.Integer#toString(int)
 75      */
 76     public static String toString(byte b) {
 77         return Integer.toString((int)b, 10);
 78     }
 79 
 80     private static class ByteCache {
 81         private ByteCache() {}
 82 
 83         static final Byte[] cache;
 84         static Byte[] archivedCache;
 85 
 86         static {
 87             final int size = -(-128) + 127 + 1;
 88 
 89             // Load and use the archived cache if it exists
 90             VM.initializeFromArchive(ByteCache.class);
 91             if (archivedCache == null || archivedCache.length != size) {
 92                 Byte[] c = new Byte[size];
 93                 byte value = (byte)-128;
 94                 for(int i = 0; i &lt; size; i++) {
 95                     c[i] = new Byte(value++);
 96                 }
 97                 archivedCache = c;
 98             }
 99             cache = archivedCache;
100         }
101     }
102 
103     /**
104      * Returns a {@code Byte} instance representing the specified
105      * {@code byte} value.
106      * If a new {@code Byte} instance is not required, this method
107      * should generally be used in preference to the constructor
108      * {@link #Byte(byte)}, as this method is likely to yield
109      * significantly better space and time performance since
110      * all byte values are cached.
111      *
112      * @param  b a byte value.
113      * @return a {@code Byte} instance representing {@code b}.
114      * @since  1.5
115      */
116     @HotSpotIntrinsicCandidate
117     public static Byte valueOf(byte b) {
118         final int offset = 128;
119         return ByteCache.cache[(int)b + offset];
120     }
121 
122     /**
123      * Parses the string argument as a signed {@code byte} in the
124      * radix specified by the second argument. The characters in the
125      * string must all be digits, of the specified radix (as
126      * determined by whether {@link java.lang.Character#digit(char,
127      * int)} returns a nonnegative value) except that the first
128      * character may be an ASCII minus sign {@code &#39;-&#39;}
129      * ({@code &#39;\u005Cu002D&#39;}) to indicate a negative value or an
130      * ASCII plus sign {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}) to
131      * indicate a positive value.  The resulting {@code byte} value is
132      * returned.
133      *
134      * &lt;p&gt;An exception of type {@code NumberFormatException} is
135      * thrown if any of the following situations occurs:
136      * &lt;ul&gt;
137      * &lt;li&gt; The first argument is {@code null} or is a string of
138      * length zero.
139      *
140      * &lt;li&gt; The radix is either smaller than {@link
141      * java.lang.Character#MIN_RADIX} or larger than {@link
142      * java.lang.Character#MAX_RADIX}.
143      *
144      * &lt;li&gt; Any character of the string is not a digit of the
145      * specified radix, except that the first character may be a minus
146      * sign {@code &#39;-&#39;} ({@code &#39;\u005Cu002D&#39;}) or plus sign
147      * {@code &#39;+&#39;} ({@code &#39;\u005Cu002B&#39;}) provided that the
148      * string is longer than length 1.
149      *
150      * &lt;li&gt; The value represented by the string is not a value of type
151      * {@code byte}.
152      * &lt;/ul&gt;
153      *
154      * @param s         the {@code String} containing the
155      *                  {@code byte}
156      *                  representation to be parsed
157      * @param radix     the radix to be used while parsing {@code s}
158      * @return          the {@code byte} value represented by the string
159      *                   argument in the specified radix
160      * @throws          NumberFormatException If the string does
161      *                  not contain a parsable {@code byte}.
162      */
163     public static byte parseByte(String s, int radix)
164         throws NumberFormatException {
165         int i = Integer.parseInt(s, radix);
166         if (i &lt; MIN_VALUE || i &gt; MAX_VALUE)
167             throw new NumberFormatException(
168                 &quot;Value out of range. Value:\&quot;&quot; + s + &quot;\&quot; Radix:&quot; + radix);
169         return (byte)i;
170     }
171 
172     /**
173      * Parses the string argument as a signed decimal {@code
174      * byte}. The characters in the string must all be decimal digits,
175      * except that the first character may be an ASCII minus sign
176      * {@code &#39;-&#39;} ({@code &#39;\u005Cu002D&#39;}) to indicate a negative
177      * value or an ASCII plus sign {@code &#39;+&#39;}
178      * ({@code &#39;\u005Cu002B&#39;}) to indicate a positive value. The
179      * resulting {@code byte} value is returned, exactly as if the
180      * argument and the radix 10 were given as arguments to the {@link
181      * #parseByte(java.lang.String, int)} method.
182      *
183      * @param s         a {@code String} containing the
184      *                  {@code byte} representation to be parsed
185      * @return          the {@code byte} value represented by the
186      *                  argument in decimal
187      * @throws          NumberFormatException if the string does not
188      *                  contain a parsable {@code byte}.
189      */
190     public static byte parseByte(String s) throws NumberFormatException {
191         return parseByte(s, 10);
192     }
193 
194     /**
195      * Returns a {@code Byte} object holding the value
196      * extracted from the specified {@code String} when parsed
197      * with the radix given by the second argument. The first argument
198      * is interpreted as representing a signed {@code byte} in
199      * the radix specified by the second argument, exactly as if the
200      * argument were given to the {@link #parseByte(java.lang.String,
201      * int)} method. The result is a {@code Byte} object that
202      * represents the {@code byte} value specified by the string.
203      *
204      * &lt;p&gt; In other words, this method returns a {@code Byte} object
205      * equal to the value of:
206      *
207      * &lt;blockquote&gt;
208      * {@code new Byte(Byte.parseByte(s, radix))}
209      * &lt;/blockquote&gt;
210      *
211      * @param s         the string to be parsed
212      * @param radix     the radix to be used in interpreting {@code s}
213      * @return          a {@code Byte} object holding the value
214      *                  represented by the string argument in the
215      *                  specified radix.
216      * @throws          NumberFormatException If the {@code String} does
217      *                  not contain a parsable {@code byte}.
218      */
219     public static Byte valueOf(String s, int radix)
220         throws NumberFormatException {
221         return valueOf(parseByte(s, radix));
222     }
223 
224     /**
225      * Returns a {@code Byte} object holding the value
226      * given by the specified {@code String}. The argument is
227      * interpreted as representing a signed decimal {@code byte},
228      * exactly as if the argument were given to the {@link
229      * #parseByte(java.lang.String)} method. The result is a
230      * {@code Byte} object that represents the {@code byte}
231      * value specified by the string.
232      *
233      * &lt;p&gt; In other words, this method returns a {@code Byte} object
234      * equal to the value of:
235      *
236      * &lt;blockquote&gt;
237      * {@code new Byte(Byte.parseByte(s))}
238      * &lt;/blockquote&gt;
239      *
240      * @param s         the string to be parsed
241      * @return          a {@code Byte} object holding the value
242      *                  represented by the string argument
243      * @throws          NumberFormatException If the {@code String} does
244      *                  not contain a parsable {@code byte}.
245      */
246     public static Byte valueOf(String s) throws NumberFormatException {
247         return valueOf(s, 10);
248     }
249 
250     /**
251      * Decodes a {@code String} into a {@code Byte}.
252      * Accepts decimal, hexadecimal, and octal numbers given by
253      * the following grammar:
254      *
255      * &lt;blockquote&gt;
256      * &lt;dl&gt;
257      * &lt;dt&gt;&lt;i&gt;DecodableString:&lt;/i&gt;
258      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; DecimalNumeral&lt;/i&gt;
259      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code 0x} &lt;i&gt;HexDigits&lt;/i&gt;
260      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code 0X} &lt;i&gt;HexDigits&lt;/i&gt;
261      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code #} &lt;i&gt;HexDigits&lt;/i&gt;
262      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code 0} &lt;i&gt;OctalDigits&lt;/i&gt;
263      *
264      * &lt;dt&gt;&lt;i&gt;Sign:&lt;/i&gt;
265      * &lt;dd&gt;{@code -}
266      * &lt;dd&gt;{@code +}
267      * &lt;/dl&gt;
268      * &lt;/blockquote&gt;
269      *
270      * &lt;i&gt;DecimalNumeral&lt;/i&gt;, &lt;i&gt;HexDigits&lt;/i&gt;, and &lt;i&gt;OctalDigits&lt;/i&gt;
271      * are as defined in section 3.10.1 of
272      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
273      * except that underscores are not accepted between digits.
274      *
275      * &lt;p&gt;The sequence of characters following an optional
276      * sign and/or radix specifier (&quot;{@code 0x}&quot;, &quot;{@code 0X}&quot;,
277      * &quot;{@code #}&quot;, or leading zero) is parsed as by the {@code
278      * Byte.parseByte} method with the indicated radix (10, 16, or 8).
279      * This sequence of characters must represent a positive value or
280      * a {@link NumberFormatException} will be thrown.  The result is
281      * negated if first character of the specified {@code String} is
282      * the minus sign.  No whitespace characters are permitted in the
283      * {@code String}.
284      *
285      * @param     nm the {@code String} to decode.
286      * @return   a {@code Byte} object holding the {@code byte}
287      *          value represented by {@code nm}
288      * @throws  NumberFormatException  if the {@code String} does not
289      *            contain a parsable {@code byte}.
290      * @see java.lang.Byte#parseByte(java.lang.String, int)
291      */
292     public static Byte decode(String nm) throws NumberFormatException {
293         int i = Integer.decode(nm);
294         if (i &lt; MIN_VALUE || i &gt; MAX_VALUE)
295             throw new NumberFormatException(
296                     &quot;Value &quot; + i + &quot; out of range from input &quot; + nm);
297         return valueOf((byte)i);
298     }
299 
300     /**
301      * The value of the {@code Byte}.
302      *
303      * @serial
304      */
305     private final byte value;
306 
307     /**
308      * Constructs a newly allocated {@code Byte} object that
309      * represents the specified {@code byte} value.
310      *
311      * @param value     the value to be represented by the
312      *                  {@code Byte}.
313      *
314      * @deprecated
315      * It is rarely appropriate to use this constructor. The static factory
316      * {@link #valueOf(byte)} is generally a better choice, as it is
317      * likely to yield significantly better space and time performance.
318      */
319     @Deprecated(since=&quot;9&quot;)
320     public Byte(byte value) {
321         this.value = value;
322     }
323 
324     /**
325      * Constructs a newly allocated {@code Byte} object that
326      * represents the {@code byte} value indicated by the
327      * {@code String} parameter. The string is converted to a
328      * {@code byte} value in exactly the manner used by the
329      * {@code parseByte} method for radix 10.
330      *
331      * @param s         the {@code String} to be converted to a
332      *                  {@code Byte}
333      * @throws          NumberFormatException if the {@code String}
334      *                  does not contain a parsable {@code byte}.
335      *
336      * @deprecated
337      * It is rarely appropriate to use this constructor.
338      * Use {@link #parseByte(String)} to convert a string to a
339      * {@code byte} primitive, or use {@link #valueOf(String)}
340      * to convert a string to a {@code Byte} object.
341      */
342     @Deprecated(since=&quot;9&quot;)
343     public Byte(String s) throws NumberFormatException {
344         this.value = parseByte(s, 10);
345     }
346 
347     /**
348      * Returns the value of this {@code Byte} as a
349      * {@code byte}.
350      */
351     @HotSpotIntrinsicCandidate
352     public byte byteValue() {
353         return value;
354     }
355 
356     /**
357      * Returns the value of this {@code Byte} as a {@code short} after
358      * a widening primitive conversion.
<a name="2" id="anc2"></a><span class="line-modified">359      * @jls 5.1.2 Widening Primitive Conversions</span>
360      */
361     public short shortValue() {
362         return (short)value;
363     }
364 
365     /**
366      * Returns the value of this {@code Byte} as an {@code int} after
367      * a widening primitive conversion.
<a name="3" id="anc3"></a><span class="line-modified">368      * @jls 5.1.2 Widening Primitive Conversions</span>
369      */
370     public int intValue() {
371         return (int)value;
372     }
373 
374     /**
375      * Returns the value of this {@code Byte} as a {@code long} after
376      * a widening primitive conversion.
<a name="4" id="anc4"></a><span class="line-modified">377      * @jls 5.1.2 Widening Primitive Conversions</span>
378      */
379     public long longValue() {
380         return (long)value;
381     }
382 
383     /**
384      * Returns the value of this {@code Byte} as a {@code float} after
385      * a widening primitive conversion.
<a name="5" id="anc5"></a><span class="line-modified">386      * @jls 5.1.2 Widening Primitive Conversions</span>
387      */
388     public float floatValue() {
389         return (float)value;
390     }
391 
392     /**
393      * Returns the value of this {@code Byte} as a {@code double}
394      * after a widening primitive conversion.
<a name="6" id="anc6"></a><span class="line-modified">395      * @jls 5.1.2 Widening Primitive Conversions</span>
396      */
397     public double doubleValue() {
398         return (double)value;
399     }
400 
401     /**
402      * Returns a {@code String} object representing this
403      * {@code Byte}&#39;s value.  The value is converted to signed
404      * decimal representation and returned as a string, exactly as if
405      * the {@code byte} value were given as an argument to the
406      * {@link java.lang.Byte#toString(byte)} method.
407      *
408      * @return  a string representation of the value of this object in
409      *          base&amp;nbsp;10.
410      */
411     public String toString() {
412         return Integer.toString((int)value);
413     }
414 
415     /**
416      * Returns a hash code for this {@code Byte}; equal to the result
417      * of invoking {@code intValue()}.
418      *
419      * @return a hash code value for this {@code Byte}
420      */
421     @Override
422     public int hashCode() {
423         return Byte.hashCode(value);
424     }
425 
426     /**
427      * Returns a hash code for a {@code byte} value; compatible with
428      * {@code Byte.hashCode()}.
429      *
430      * @param value the value to hash
431      * @return a hash code value for a {@code byte} value.
432      * @since 1.8
433      */
434     public static int hashCode(byte value) {
435         return (int)value;
436     }
437 
438     /**
439      * Compares this object to the specified object.  The result is
440      * {@code true} if and only if the argument is not
441      * {@code null} and is a {@code Byte} object that
442      * contains the same {@code byte} value as this object.
443      *
444      * @param obj       the object to compare with
445      * @return          {@code true} if the objects are the same;
446      *                  {@code false} otherwise.
447      */
448     public boolean equals(Object obj) {
449         if (obj instanceof Byte) {
450             return value == ((Byte)obj).byteValue();
451         }
452         return false;
453     }
454 
455     /**
456      * Compares two {@code Byte} objects numerically.
457      *
458      * @param   anotherByte   the {@code Byte} to be compared.
459      * @return  the value {@code 0} if this {@code Byte} is
460      *          equal to the argument {@code Byte}; a value less than
461      *          {@code 0} if this {@code Byte} is numerically less
462      *          than the argument {@code Byte}; and a value greater than
463      *           {@code 0} if this {@code Byte} is numerically
464      *           greater than the argument {@code Byte} (signed
465      *           comparison).
466      * @since   1.2
467      */
468     public int compareTo(Byte anotherByte) {
469         return compare(this.value, anotherByte.value);
470     }
471 
472     /**
473      * Compares two {@code byte} values numerically.
474      * The value returned is identical to what would be returned by:
475      * &lt;pre&gt;
476      *    Byte.valueOf(x).compareTo(Byte.valueOf(y))
477      * &lt;/pre&gt;
478      *
479      * @param  x the first {@code byte} to compare
480      * @param  y the second {@code byte} to compare
481      * @return the value {@code 0} if {@code x == y};
482      *         a value less than {@code 0} if {@code x &lt; y}; and
483      *         a value greater than {@code 0} if {@code x &gt; y}
484      * @since 1.7
485      */
486     public static int compare(byte x, byte y) {
487         return x - y;
488     }
489 
490     /**
491      * Compares two {@code byte} values numerically treating the values
492      * as unsigned.
493      *
494      * @param  x the first {@code byte} to compare
495      * @param  y the second {@code byte} to compare
496      * @return the value {@code 0} if {@code x == y}; a value less
497      *         than {@code 0} if {@code x &lt; y} as unsigned values; and
498      *         a value greater than {@code 0} if {@code x &gt; y} as
499      *         unsigned values
500      * @since 9
501      */
502     public static int compareUnsigned(byte x, byte y) {
503         return Byte.toUnsignedInt(x) - Byte.toUnsignedInt(y);
504     }
505 
506     /**
507      * Converts the argument to an {@code int} by an unsigned
508      * conversion.  In an unsigned conversion to an {@code int}, the
509      * high-order 24 bits of the {@code int} are zero and the
510      * low-order 8 bits are equal to the bits of the {@code byte} argument.
511      *
512      * Consequently, zero and positive {@code byte} values are mapped
513      * to a numerically equal {@code int} value and negative {@code
514      * byte} values are mapped to an {@code int} value equal to the
515      * input plus 2&lt;sup&gt;8&lt;/sup&gt;.
516      *
517      * @param  x the value to convert to an unsigned {@code int}
518      * @return the argument converted to {@code int} by an unsigned
519      *         conversion
520      * @since 1.8
521      */
522     public static int toUnsignedInt(byte x) {
523         return ((int) x) &amp; 0xff;
524     }
525 
526     /**
527      * Converts the argument to a {@code long} by an unsigned
528      * conversion.  In an unsigned conversion to a {@code long}, the
529      * high-order 56 bits of the {@code long} are zero and the
530      * low-order 8 bits are equal to the bits of the {@code byte} argument.
531      *
532      * Consequently, zero and positive {@code byte} values are mapped
533      * to a numerically equal {@code long} value and negative {@code
534      * byte} values are mapped to a {@code long} value equal to the
535      * input plus 2&lt;sup&gt;8&lt;/sup&gt;.
536      *
537      * @param  x the value to convert to an unsigned {@code long}
538      * @return the argument converted to {@code long} by an unsigned
539      *         conversion
540      * @since 1.8
541      */
542     public static long toUnsignedLong(byte x) {
543         return ((long) x) &amp; 0xffL;
544     }
545 
546 
547     /**
548      * The number of bits used to represent a {@code byte} value in two&#39;s
549      * complement binary form.
550      *
551      * @since 1.5
552      */
553     public static final int SIZE = 8;
554 
555     /**
556      * The number of bytes used to represent a {@code byte} value in two&#39;s
557      * complement binary form.
558      *
559      * @since 1.8
560      */
561     public static final int BYTES = SIZE / Byte.SIZE;
562 
563     /** use serialVersionUID from JDK 1.1. for interoperability */
<a name="7" id="anc7"></a>
564     private static final long serialVersionUID = -7183698231559129828L;
565 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
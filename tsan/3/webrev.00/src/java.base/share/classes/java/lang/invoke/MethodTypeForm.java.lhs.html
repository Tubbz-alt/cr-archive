<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/MethodTypeForm.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
<a name="2" id="anc2"></a><span class="line-removed"> 28 import jdk.internal.vm.annotation.Stable;</span>
 29 import sun.invoke.util.Wrapper;
 30 
 31 import java.lang.ref.SoftReference;
 32 
 33 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
 34 
 35 /**
 36  * Shared information for a group of method types, which differ
 37  * only by reference types, and therefore share a common erasure
 38  * and wrapping.
 39  * &lt;p&gt;
 40  * For an empirical discussion of the structure of method types,
 41  * see &lt;a href=&quot;http://groups.google.com/group/jvm-languages/browse_thread/thread/ac9308ae74da9b7e/&quot;&gt;
 42  * the thread &quot;Avoiding Boxing&quot; on jvm-languages&lt;/a&gt;.
 43  * There are approximately 2000 distinct erased method types in the JDK.
 44  * There are a little over 10 times that number of unerased types.
 45  * No more than half of these are likely to be loaded at once.
 46  * @author John Rose
 47  */
 48 final class MethodTypeForm {
<a name="3" id="anc3"></a><span class="line-modified"> 49     final int[] argToSlotTable, slotToArgTable;</span>
<span class="line-modified"> 50     final long argCounts;               // packed slot &amp; value counts</span>
<span class="line-removed"> 51     final long primCounts;              // packed prim &amp; double counts</span>
 52     final MethodType erasedType;        // the canonical erasure
 53     final MethodType basicType;         // the canonical erasure, with primitives simplified
 54 
 55     // Cached adapter information:
<a name="4" id="anc4"></a><span class="line-modified"> 56     @Stable final SoftReference&lt;MethodHandle&gt;[] methodHandles;</span>

 57     // Indexes into methodHandles:
 58     static final int
 59             MH_BASIC_INV      =  0,  // cached instance of MH.invokeBasic
 60             MH_NF_INV         =  1,  // cached helper for LF.NamedFunction
 61             MH_UNINIT_CS      =  2,  // uninitialized call site
 62             MH_LIMIT          =  3;
 63 
 64     // Cached lambda form information, for basic types only:
<a name="5" id="anc5"></a><span class="line-modified"> 65     final @Stable SoftReference&lt;LambdaForm&gt;[] lambdaForms;</span>

 66     // Indexes into lambdaForms:
 67     static final int
 68             LF_INVVIRTUAL              =  0,  // DMH invokeVirtual
 69             LF_INVSTATIC               =  1,
 70             LF_INVSPECIAL              =  2,
 71             LF_NEWINVSPECIAL           =  3,
 72             LF_INVINTERFACE            =  4,
 73             LF_INVSTATIC_INIT          =  5,  // DMH invokeStatic with &lt;clinit&gt; barrier
 74             LF_INTERPRET               =  6,  // LF interpreter
 75             LF_REBIND                  =  7,  // BoundMethodHandle
 76             LF_DELEGATE                =  8,  // DelegatingMethodHandle
 77             LF_DELEGATE_BLOCK_INLINING =  9,  // Counting DelegatingMethodHandle w/ @DontInline
 78             LF_EX_LINKER               = 10,  // invokeExact_MT (for invokehandle)
 79             LF_EX_INVOKER              = 11,  // MHs.invokeExact
 80             LF_GEN_LINKER              = 12,  // generic invoke_MT (for invokehandle)
 81             LF_GEN_INVOKER             = 13,  // generic MHs.invoke
 82             LF_CS_LINKER               = 14,  // linkToCallSite_CS
 83             LF_MH_LINKER               = 15,  // linkToCallSite_MH
 84             LF_GWC                     = 16,  // guardWithCatch (catchException)
 85             LF_GWT                     = 17,  // guardWithTest
 86             LF_TF                      = 18,  // tryFinally
 87             LF_LOOP                    = 19,  // loop
 88             LF_INVSPECIAL_IFC          = 20,  // DMH invokeSpecial of (private) interface method
 89             LF_LIMIT                   = 21;
 90 
 91     /** Return the type corresponding uniquely (1-1) to this MT-form.
 92      *  It might have any primitive returns or arguments, but will have no references except Object.
 93      */
 94     public MethodType erasedType() {
 95         return erasedType;
 96     }
 97 
 98     /** Return the basic type derived from the erased type of this MT-form.
 99      *  A basic type is erased (all references Object) and also has all primitive
100      *  types (except int, long, float, double, void) normalized to int.
101      *  Such basic types correspond to low-level JVM calling sequences.
102      */
103     public MethodType basicType() {
104         return basicType;
105     }
106 
<a name="6" id="anc6"></a><span class="line-removed">107     private boolean assertIsBasicType() {</span>
<span class="line-removed">108         // primitives must be flattened also</span>
<span class="line-removed">109         assert(erasedType == basicType)</span>
<span class="line-removed">110                 : &quot;erasedType: &quot; + erasedType + &quot; != basicType: &quot; + basicType;</span>
<span class="line-removed">111         return true;</span>
<span class="line-removed">112     }</span>
<span class="line-removed">113 </span>
114     public MethodHandle cachedMethodHandle(int which) {
<a name="7" id="anc7"></a><span class="line-removed">115         assert(assertIsBasicType());</span>
116         SoftReference&lt;MethodHandle&gt; entry = methodHandles[which];
117         return (entry != null) ? entry.get() : null;
118     }
119 
120     public synchronized MethodHandle setCachedMethodHandle(int which, MethodHandle mh) {
121         // Simulate a CAS, to avoid racy duplication of results.
122         SoftReference&lt;MethodHandle&gt; entry = methodHandles[which];
123         if (entry != null) {
124             MethodHandle prev = entry.get();
125             if (prev != null) {
126                 return prev;
127             }
128         }
129         methodHandles[which] = new SoftReference&lt;&gt;(mh);
130         return mh;
131     }
132 
133     public LambdaForm cachedLambdaForm(int which) {
<a name="8" id="anc8"></a><span class="line-removed">134         assert(assertIsBasicType());</span>
135         SoftReference&lt;LambdaForm&gt; entry = lambdaForms[which];
136         return (entry != null) ? entry.get() : null;
137     }
138 
139     public synchronized LambdaForm setCachedLambdaForm(int which, LambdaForm form) {
140         // Simulate a CAS, to avoid racy duplication of results.
141         SoftReference&lt;LambdaForm&gt; entry = lambdaForms[which];
142         if (entry != null) {
143             LambdaForm prev = entry.get();
144             if (prev != null) {
145                 return prev;
146             }
147         }
148         lambdaForms[which] = new SoftReference&lt;&gt;(form);
149         return form;
150     }
151 
152     /**
153      * Build an MTF for a given type, which must have all references erased to Object.
154      * This MTF will stand for that type and all un-erased variations.
155      * Eagerly compute some basic properties of the type, common to all variations.
156      */
157     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
158     protected MethodTypeForm(MethodType erasedType) {
159         this.erasedType = erasedType;
160 
161         Class&lt;?&gt;[] ptypes = erasedType.ptypes();
<a name="9" id="anc9"></a><span class="line-modified">162         int ptypeCount = ptypes.length;</span>
<span class="line-removed">163         int pslotCount = ptypeCount;            // temp. estimate</span>
<span class="line-removed">164         int rtypeCount = 1;                     // temp. estimate</span>
<span class="line-removed">165         int rslotCount = 1;                     // temp. estimate</span>
<span class="line-removed">166 </span>
<span class="line-removed">167         int[] argToSlotTab = null, slotToArgTab = null;</span>
168 
169         // Walk the argument types, looking for primitives.
<a name="10" id="anc10"></a><span class="line-modified">170         int pac = 0, lac = 0, prc = 0, lrc = 0;</span>
<span class="line-modified">171         Class&lt;?&gt;[] epts = ptypes;</span>
<span class="line-modified">172         Class&lt;?&gt;[] bpts = epts;</span>
<span class="line-modified">173         for (int i = 0; i &lt; epts.length; i++) {</span>
<span class="line-modified">174             Class&lt;?&gt; pt = epts[i];</span>
<span class="line-modified">175             if (pt != Object.class) {</span>
<span class="line-modified">176                 ++pac;</span>
<span class="line-modified">177                 Wrapper w = Wrapper.forPrimitiveType(pt);</span>
<span class="line-modified">178                 if (w.isDoubleWord())  ++lac;</span>
<span class="line-modified">179                 if (w.isSubwordOrInt() &amp;&amp; pt != int.class) {</span>
<span class="line-modified">180                     if (bpts == epts)</span>
<span class="line-modified">181                         bpts = bpts.clone();</span>
<span class="line-modified">182                     bpts[i] = int.class;</span>
183                 }
184             }
185         }
<a name="11" id="anc11"></a><span class="line-modified">186         pslotCount += lac;                  // #slots = #args + #longs</span>
<span class="line-modified">187         Class&lt;?&gt; rt = erasedType.returnType();</span>
<span class="line-modified">188         Class&lt;?&gt; bt = rt;</span>
<span class="line-modified">189         if (rt != Object.class) {</span>
<span class="line-modified">190             ++prc;          // even void.class counts as a prim here</span>
<span class="line-modified">191             Wrapper w = Wrapper.forPrimitiveType(rt);</span>
<span class="line-modified">192             if (w.isDoubleWord())  ++lrc;</span>
<span class="line-modified">193             if (w.isSubwordOrInt() &amp;&amp; rt != int.class)</span>
<span class="line-removed">194                 bt = int.class;</span>
<span class="line-removed">195             // adjust #slots, #args</span>
<span class="line-removed">196             if (rt == void.class)</span>
<span class="line-removed">197                 rtypeCount = rslotCount = 0;</span>
<span class="line-removed">198             else</span>
<span class="line-removed">199                 rslotCount += lrc;</span>
200         }
<a name="12" id="anc12"></a><span class="line-modified">201         if (epts == bpts &amp;&amp; bt == rt) {</span>

202             this.basicType = erasedType;
<a name="13" id="anc13"></a>






203         } else {
<a name="14" id="anc14"></a><span class="line-modified">204             this.basicType = MethodType.makeImpl(bt, bpts, true);</span>
205             // fill in rest of data from the basic type:
206             MethodTypeForm that = this.basicType.form();
207             assert(this != that);
<a name="15" id="anc15"></a><span class="line-modified">208             this.primCounts = that.primCounts;</span>
<span class="line-modified">209             this.argCounts = that.argCounts;</span>
<span class="line-modified">210             this.argToSlotTable = that.argToSlotTable;</span>
<span class="line-removed">211             this.slotToArgTable = that.slotToArgTable;</span>
212             this.methodHandles = null;
213             this.lambdaForms = null;
<a name="16" id="anc16"></a><span class="line-removed">214             return;</span>
215         }
<a name="17" id="anc17"></a><span class="line-removed">216         if (lac != 0) {</span>
<span class="line-removed">217             int slot = ptypeCount + lac;</span>
<span class="line-removed">218             slotToArgTab = new int[slot+1];</span>
<span class="line-removed">219             argToSlotTab = new int[1+ptypeCount];</span>
<span class="line-removed">220             argToSlotTab[0] = slot;  // argument &quot;-1&quot; is past end of slots</span>
<span class="line-removed">221             for (int i = 0; i &lt; epts.length; i++) {</span>
<span class="line-removed">222                 Class&lt;?&gt; pt = epts[i];</span>
<span class="line-removed">223                 Wrapper w = Wrapper.forBasicType(pt);</span>
<span class="line-removed">224                 if (w.isDoubleWord())  --slot;</span>
<span class="line-removed">225                 --slot;</span>
<span class="line-removed">226                 slotToArgTab[slot] = i+1; // &quot;+1&quot; see argSlotToParameter note</span>
<span class="line-removed">227                 argToSlotTab[1+i]  = slot;</span>
<span class="line-removed">228             }</span>
<span class="line-removed">229             assert(slot == 0);  // filled the table</span>
<span class="line-removed">230         } else if (pac != 0) {</span>
<span class="line-removed">231             // have primitives but no long primitives; share slot counts with generic</span>
<span class="line-removed">232             assert(ptypeCount == pslotCount);</span>
<span class="line-removed">233             MethodTypeForm that = MethodType.genericMethodType(ptypeCount).form();</span>
<span class="line-removed">234             assert(this != that);</span>
<span class="line-removed">235             slotToArgTab = that.slotToArgTable;</span>
<span class="line-removed">236             argToSlotTab = that.argToSlotTable;</span>
<span class="line-removed">237         } else {</span>
<span class="line-removed">238             int slot = ptypeCount; // first arg is deepest in stack</span>
<span class="line-removed">239             slotToArgTab = new int[slot+1];</span>
<span class="line-removed">240             argToSlotTab = new int[1+ptypeCount];</span>
<span class="line-removed">241             argToSlotTab[0] = slot;  // argument &quot;-1&quot; is past end of slots</span>
<span class="line-removed">242             for (int i = 0; i &lt; ptypeCount; i++) {</span>
<span class="line-removed">243                 --slot;</span>
<span class="line-removed">244                 slotToArgTab[slot] = i+1; // &quot;+1&quot; see argSlotToParameter note</span>
<span class="line-removed">245                 argToSlotTab[1+i]  = slot;</span>
<span class="line-removed">246             }</span>
<span class="line-removed">247         }</span>
<span class="line-removed">248         this.primCounts = pack(lrc, prc, lac, pac);</span>
<span class="line-removed">249         this.argCounts = pack(rslotCount, rtypeCount, pslotCount, ptypeCount);</span>
<span class="line-removed">250         this.argToSlotTable = argToSlotTab;</span>
<span class="line-removed">251         this.slotToArgTable = slotToArgTab;</span>
<span class="line-removed">252 </span>
<span class="line-removed">253         if (pslotCount &gt;= 256)  throw newIllegalArgumentException(&quot;too many arguments&quot;);</span>
<span class="line-removed">254 </span>
<span class="line-removed">255         // Initialize caches, but only for basic types</span>
<span class="line-removed">256         assert(basicType == erasedType);</span>
<span class="line-removed">257         this.lambdaForms   = new SoftReference[LF_LIMIT];</span>
<span class="line-removed">258         this.methodHandles = new SoftReference[MH_LIMIT];</span>
<span class="line-removed">259     }</span>
<span class="line-removed">260 </span>
<span class="line-removed">261     private static long pack(int a, int b, int c, int d) {</span>
<span class="line-removed">262         assert(((a|b|c|d) &amp; ~0xFFFF) == 0);</span>
<span class="line-removed">263         long hw = ((a &lt;&lt; 16) | b), lw = ((c &lt;&lt; 16) | d);</span>
<span class="line-removed">264         return (hw &lt;&lt; 32) | lw;</span>
<span class="line-removed">265     }</span>
<span class="line-removed">266     private static char unpack(long packed, int word) { // word==0 =&gt; return a, ==3 =&gt; return d</span>
<span class="line-removed">267         assert(word &lt;= 3);</span>
<span class="line-removed">268         return (char)(packed &gt;&gt; ((3-word) * 16));</span>
269     }
270 
<a name="18" id="anc18"></a><span class="line-modified">271     public int parameterCount() {                      // # outgoing values</span>
<span class="line-modified">272         return unpack(argCounts, 3);</span>
<span class="line-removed">273     }</span>
<span class="line-removed">274     public int parameterSlotCount() {                  // # outgoing interpreter slots</span>
<span class="line-removed">275         return unpack(argCounts, 2);</span>
<span class="line-removed">276     }</span>
<span class="line-removed">277     public int returnCount() {                         // = 0 (V), or 1</span>
<span class="line-removed">278         return unpack(argCounts, 1);</span>
<span class="line-removed">279     }</span>
<span class="line-removed">280     public int returnSlotCount() {                     // = 0 (V), 2 (J/D), or 1</span>
<span class="line-removed">281         return unpack(argCounts, 0);</span>
282     }
<a name="19" id="anc19"></a><span class="line-modified">283     public int primitiveParameterCount() {</span>
<span class="line-modified">284         return unpack(primCounts, 3);</span>
<span class="line-removed">285     }</span>
<span class="line-removed">286     public int longPrimitiveParameterCount() {</span>
<span class="line-removed">287         return unpack(primCounts, 2);</span>
<span class="line-removed">288     }</span>
<span class="line-removed">289     public int primitiveReturnCount() {                // = 0 (obj), or 1</span>
<span class="line-removed">290         return unpack(primCounts, 1);</span>
<span class="line-removed">291     }</span>
<span class="line-removed">292     public int longPrimitiveReturnCount() {            // = 1 (J/D), or 0</span>
<span class="line-removed">293         return unpack(primCounts, 0);</span>
294     }
295     public boolean hasPrimitives() {
<a name="20" id="anc20"></a><span class="line-modified">296         return primCounts != 0;</span>
<span class="line-removed">297     }</span>
<span class="line-removed">298     public boolean hasNonVoidPrimitives() {</span>
<span class="line-removed">299         if (primCounts == 0)  return false;</span>
<span class="line-removed">300         if (primitiveParameterCount() != 0)  return true;</span>
<span class="line-removed">301         return (primitiveReturnCount() != 0 &amp;&amp; returnCount() != 0);</span>
<span class="line-removed">302     }</span>
<span class="line-removed">303     public boolean hasLongPrimitives() {</span>
<span class="line-removed">304         return (longPrimitiveParameterCount() | longPrimitiveReturnCount()) != 0;</span>
<span class="line-removed">305     }</span>
<span class="line-removed">306     public int parameterToArgSlot(int i) {</span>
<span class="line-removed">307         return argToSlotTable[1+i];</span>
<span class="line-removed">308     }</span>
<span class="line-removed">309     public int argSlotToParameter(int argSlot) {</span>
<span class="line-removed">310         // Note:  Empty slots are represented by zero in this table.</span>
<span class="line-removed">311         // Valid arguments slots contain incremented entries, so as to be non-zero.</span>
<span class="line-removed">312         // We return -1 the caller to mean an empty slot.</span>
<span class="line-removed">313         return slotToArgTable[argSlot] - 1;</span>
314     }
315 
316     static MethodTypeForm findForm(MethodType mt) {
317         MethodType erased = canonicalize(mt, ERASE, ERASE);
318         if (erased == null) {
319             // It is already erased.  Make a new MethodTypeForm.
320             return new MethodTypeForm(mt);
321         } else {
322             // Share the MethodTypeForm with the erased version.
323             return erased.form();
324         }
325     }
326 
327     /** Codes for {@link #canonicalize(java.lang.Class, int)}.
328      * ERASE means change every reference to {@code Object}.
329      * WRAP means convert primitives (including {@code void} to their
330      * corresponding wrapper types.  UNWRAP means the reverse of WRAP.
331      * INTS means convert all non-void primitive types to int or long,
332      * according to size.  LONGS means convert all non-void primitives
333      * to long, regardless of size.  RAW_RETURN means convert a type
334      * (assumed to be a return type) to int if it is smaller than an int,
335      * or if it is void.
336      */
<a name="21" id="anc21"></a><span class="line-modified">337     public static final int NO_CHANGE = 0, ERASE = 1, WRAP = 2, UNWRAP = 3, INTS = 4, LONGS = 5, RAW_RETURN = 6;</span>
338 
339     /** Canonicalize the types in the given method type.
340      * If any types change, intern the new type, and return it.
341      * Otherwise return null.
342      */
343     public static MethodType canonicalize(MethodType mt, int howRet, int howArgs) {
344         Class&lt;?&gt;[] ptypes = mt.ptypes();
<a name="22" id="anc22"></a><span class="line-modified">345         Class&lt;?&gt;[] ptc = MethodTypeForm.canonicalizeAll(ptypes, howArgs);</span>
346         Class&lt;?&gt; rtype = mt.returnType();
<a name="23" id="anc23"></a><span class="line-modified">347         Class&lt;?&gt; rtc = MethodTypeForm.canonicalize(rtype, howRet);</span>
<span class="line-modified">348         if (ptc == null &amp;&amp; rtc == null) {</span>
349             // It is already canonical.
350             return null;
351         }
352         // Find the erased version of the method type:
<a name="24" id="anc24"></a><span class="line-modified">353         if (rtc == null)  rtc = rtype;</span>
<span class="line-modified">354         if (ptc == null)  ptc = ptypes;</span>
<span class="line-modified">355         return MethodType.makeImpl(rtc, ptc, true);</span>
356     }
357 
358     /** Canonicalize the given return or param type.
359      *  Return null if the type is already canonicalized.
360      */
361     static Class&lt;?&gt; canonicalize(Class&lt;?&gt; t, int how) {
362         Class&lt;?&gt; ct;
363         if (t == Object.class) {
364             // no change, ever
365         } else if (!t.isPrimitive()) {
366             switch (how) {
367                 case UNWRAP:
368                     ct = Wrapper.asPrimitiveType(t);
369                     if (ct != t)  return ct;
370                     break;
371                 case RAW_RETURN:
372                 case ERASE:
373                     return Object.class;
374             }
375         } else if (t == void.class) {
376             // no change, usually
377             switch (how) {
378                 case RAW_RETURN:
379                     return int.class;
380                 case WRAP:
381                     return Void.class;
382             }
383         } else {
384             // non-void primitive
385             switch (how) {
386                 case WRAP:
387                     return Wrapper.asWrapperType(t);
388                 case INTS:
389                     if (t == int.class || t == long.class)
390                         return null;  // no change
391                     if (t == double.class)
392                         return long.class;
393                     return int.class;
394                 case LONGS:
395                     if (t == long.class)
396                         return null;  // no change
397                     return long.class;
398                 case RAW_RETURN:
399                     if (t == int.class || t == long.class ||
400                         t == float.class || t == double.class)
401                         return null;  // no change
402                     // everything else returns as an int
403                     return int.class;
404             }
405         }
406         // no change; return null to signify
407         return null;
408     }
409 
410     /** Canonicalize each param type in the given array.
411      *  Return null if all types are already canonicalized.
412      */
413     static Class&lt;?&gt;[] canonicalizeAll(Class&lt;?&gt;[] ts, int how) {
414         Class&lt;?&gt;[] cs = null;
415         for (int imax = ts.length, i = 0; i &lt; imax; i++) {
416             Class&lt;?&gt; c = canonicalize(ts[i], how);
<a name="25" id="anc25"></a><span class="line-modified">417             if (c == void.class)</span>
<span class="line-modified">418                 c = null;  // a Void parameter was unwrapped to void; ignore</span>
<span class="line-removed">419             if (c != null) {</span>
420                 if (cs == null)
421                     cs = ts.clone();
422                 cs[i] = c;
423             }
424         }
425         return cs;
426     }
427 
428     @Override
429     public String toString() {
430         return &quot;Form&quot;+erasedType;
431     }
432 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
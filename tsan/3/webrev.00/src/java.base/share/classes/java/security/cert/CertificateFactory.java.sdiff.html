<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/cert/CertificateFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CertificateExpiredException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateFactorySpi.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/cert/CertificateFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
330      * certificate is provided in Base64 encoding, it must be bounded at
331      * the beginning by -----BEGIN CERTIFICATE-----, and must be bounded at
332      * the end by -----END CERTIFICATE-----.
333      *
334      * &lt;p&gt;Note that if the given input stream does not support
335      * {@link java.io.InputStream#mark(int) mark} and
336      * {@link java.io.InputStream#reset() reset}, this method will
337      * consume the entire input stream. Otherwise, each call to this
338      * method consumes one certificate and the read position of the
339      * input stream is positioned to the next available byte after
340      * the inherent end-of-certificate marker. If the data in the input stream
341      * does not contain an inherent end-of-certificate marker (other
342      * than EOF) and there is trailing data after the certificate is parsed, a
343      * {@code CertificateException} is thrown.
344      *
345      * @param inStream an input stream with the certificate data.
346      *
347      * @return a certificate object initialized with the data
348      * from the input stream.
349      *
<span class="line-modified">350      * @exception CertificateException on parsing errors.</span>
351      */
352     public final Certificate generateCertificate(InputStream inStream)
353         throws CertificateException
354     {
355         return certFacSpi.engineGenerateCertificate(inStream);
356     }
357 
358     /**
359      * Returns an iteration of the {@code CertPath} encodings supported
360      * by this certificate factory, with the default encoding first. See
361      * the CertPath Encodings section in the &lt;a href=
362      * &quot;{@docRoot}/../specs/security/standard-names.html#certpath-encodings&quot;&gt;
363      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
364      * for information about standard encoding names and their formats.
365      * &lt;p&gt;
366      * Attempts to modify the returned {@code Iterator} via its
367      * {@code remove} method result in an
368      * {@code UnsupportedOperationException}.
369      *
370      * @return an {@code Iterator} over the names of the supported
371      *         {@code CertPath} encodings (as {@code String}s)
372      * @since 1.4
373      */
374     public final Iterator&lt;String&gt; getCertPathEncodings() {
375         return(certFacSpi.engineGetCertPathEncodings());
376     }
377 
378     /**
379      * Generates a {@code CertPath} object and initializes it with
380      * the data read from the {@code InputStream} inStream. The data
381      * is assumed to be in the default encoding. The name of the default
382      * encoding is the first element of the {@code Iterator} returned by
383      * the {@link #getCertPathEncodings getCertPathEncodings} method.
384      *
385      * @param inStream an {@code InputStream} containing the data
386      * @return a {@code CertPath} initialized with the data from the
387      *   {@code InputStream}
<span class="line-modified">388      * @exception CertificateException if an exception occurs while decoding</span>
389      * @since 1.4
390      */
391     public final CertPath generateCertPath(InputStream inStream)
392         throws CertificateException
393     {
394         return(certFacSpi.engineGenerateCertPath(inStream));
395     }
396 
397     /**
398      * Generates a {@code CertPath} object and initializes it with
399      * the data read from the {@code InputStream} inStream. The data
400      * is assumed to be in the specified encoding. See
401      * the CertPath Encodings section in the &lt;a href=
402      * &quot;{@docRoot}/../specs/security/standard-names.html#certpath-encodings&quot;&gt;
403      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
404      * for information about standard encoding names and their formats.
405      *
406      * @param inStream an {@code InputStream} containing the data
407      * @param encoding the encoding used for the data
408      * @return a {@code CertPath} initialized with the data from the
409      *   {@code InputStream}
<span class="line-modified">410      * @exception CertificateException if an exception occurs while decoding or</span>
411      *   the encoding requested is not supported
412      * @since 1.4
413      */
414     public final CertPath generateCertPath(InputStream inStream,
415         String encoding) throws CertificateException
416     {
417         return(certFacSpi.engineGenerateCertPath(inStream, encoding));
418     }
419 
420     /**
421      * Generates a {@code CertPath} object and initializes it with
422      * a {@code List} of {@code Certificate}s.
423      * &lt;p&gt;
424      * The certificates supplied must be of a type supported by the
425      * {@code CertificateFactory}. They will be copied out of the supplied
426      * {@code List} object.
427      *
428      * @param certificates a {@code List} of {@code Certificate}s
429      * @return a {@code CertPath} initialized with the supplied list of
430      *   certificates
<span class="line-modified">431      * @exception CertificateException if an exception occurs</span>
432      * @since 1.4
433      */
434     public final CertPath
435         generateCertPath(List&lt;? extends Certificate&gt; certificates)
436         throws CertificateException
437     {
438         return(certFacSpi.engineGenerateCertPath(certificates));
439     }
440 
441     /**
442      * Returns a (possibly empty) collection view of the certificates read
443      * from the given input stream {@code inStream}.
444      *
445      * &lt;p&gt;In order to take advantage of the specialized certificate format
446      * supported by this certificate factory, each element in
447      * the returned collection view can be typecast to the corresponding
448      * certificate class. For example, if this certificate
449      * factory implements X.509 certificates, the elements in the returned
450      * collection can be typecast to the {@code X509Certificate} class.
451      *
</pre>
<hr />
<pre>
454      * in the formats described for
455      * {@link #generateCertificate(java.io.InputStream) generateCertificate}.
456      * In addition, {@code inStream} may contain a PKCS#7 certificate
457      * chain. This is a PKCS#7 &lt;i&gt;SignedData&lt;/i&gt; object, with the only
458      * significant field being &lt;i&gt;certificates&lt;/i&gt;. In particular, the
459      * signature and the contents are ignored. This format allows multiple
460      * certificates to be downloaded at once. If no certificates are present,
461      * an empty collection is returned.
462      *
463      * &lt;p&gt;Note that if the given input stream does not support
464      * {@link java.io.InputStream#mark(int) mark} and
465      * {@link java.io.InputStream#reset() reset}, this method will
466      * consume the entire input stream.
467      *
468      * @param inStream the input stream with the certificates.
469      *
470      * @return a (possibly empty) collection view of
471      * java.security.cert.Certificate objects
472      * initialized with the data from the input stream.
473      *
<span class="line-modified">474      * @exception CertificateException on parsing errors.</span>
475      */
476     public final Collection&lt;? extends Certificate&gt; generateCertificates
477             (InputStream inStream) throws CertificateException {
478         return certFacSpi.engineGenerateCertificates(inStream);
479     }
480 
481     /**
482      * Generates a certificate revocation list (CRL) object and initializes it
483      * with the data read from the input stream {@code inStream}.
484      *
485      * &lt;p&gt;In order to take advantage of the specialized CRL format
486      * supported by this certificate factory,
487      * the returned CRL object can be typecast to the corresponding
488      * CRL class. For example, if this certificate
489      * factory implements X.509 CRLs, the returned CRL object
490      * can be typecast to the {@code X509CRL} class.
491      *
492      * &lt;p&gt;Note that if the given input stream does not support
493      * {@link java.io.InputStream#mark(int) mark} and
494      * {@link java.io.InputStream#reset() reset}, this method will
495      * consume the entire input stream. Otherwise, each call to this
496      * method consumes one CRL and the read position of the input stream
497      * is positioned to the next available byte after the inherent
498      * end-of-CRL marker. If the data in the
499      * input stream does not contain an inherent end-of-CRL marker (other
500      * than EOF) and there is trailing data after the CRL is parsed, a
501      * {@code CRLException} is thrown.
502      *
503      * @param inStream an input stream with the CRL data.
504      *
505      * @return a CRL object initialized with the data
506      * from the input stream.
507      *
<span class="line-modified">508      * @exception CRLException on parsing errors.</span>
509      */
510     public final CRL generateCRL(InputStream inStream)
511         throws CRLException
512     {
513         return certFacSpi.engineGenerateCRL(inStream);
514     }
515 
516     /**
517      * Returns a (possibly empty) collection view of the CRLs read
518      * from the given input stream {@code inStream}.
519      *
520      * &lt;p&gt;In order to take advantage of the specialized CRL format
521      * supported by this certificate factory, each element in
522      * the returned collection view can be typecast to the corresponding
523      * CRL class. For example, if this certificate
524      * factory implements X.509 CRLs, the elements in the returned
525      * collection can be typecast to the {@code X509CRL} class.
526      *
527      * &lt;p&gt;In the case of a certificate factory for X.509 CRLs,
528      * {@code inStream} may contain a sequence of DER-encoded CRLs.
529      * In addition, {@code inStream} may contain a PKCS#7 CRL
530      * set. This is a PKCS#7 &lt;i&gt;SignedData&lt;/i&gt; object, with the only
531      * significant field being &lt;i&gt;crls&lt;/i&gt;. In particular, the
532      * signature and the contents are ignored. This format allows multiple
533      * CRLs to be downloaded at once. If no CRLs are present,
534      * an empty collection is returned.
535      *
536      * &lt;p&gt;Note that if the given input stream does not support
537      * {@link java.io.InputStream#mark(int) mark} and
538      * {@link java.io.InputStream#reset() reset}, this method will
539      * consume the entire input stream.
540      *
541      * @param inStream the input stream with the CRLs.
542      *
543      * @return a (possibly empty) collection view of
544      * java.security.cert.CRL objects initialized with the data from the input
545      * stream.
546      *
<span class="line-modified">547      * @exception CRLException on parsing errors.</span>
548      */
549     public final Collection&lt;? extends CRL&gt; generateCRLs(InputStream inStream)
550             throws CRLException {
551         return certFacSpi.engineGenerateCRLs(inStream);
552     }
553 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
330      * certificate is provided in Base64 encoding, it must be bounded at
331      * the beginning by -----BEGIN CERTIFICATE-----, and must be bounded at
332      * the end by -----END CERTIFICATE-----.
333      *
334      * &lt;p&gt;Note that if the given input stream does not support
335      * {@link java.io.InputStream#mark(int) mark} and
336      * {@link java.io.InputStream#reset() reset}, this method will
337      * consume the entire input stream. Otherwise, each call to this
338      * method consumes one certificate and the read position of the
339      * input stream is positioned to the next available byte after
340      * the inherent end-of-certificate marker. If the data in the input stream
341      * does not contain an inherent end-of-certificate marker (other
342      * than EOF) and there is trailing data after the certificate is parsed, a
343      * {@code CertificateException} is thrown.
344      *
345      * @param inStream an input stream with the certificate data.
346      *
347      * @return a certificate object initialized with the data
348      * from the input stream.
349      *
<span class="line-modified">350      * @throws    CertificateException on parsing errors.</span>
351      */
352     public final Certificate generateCertificate(InputStream inStream)
353         throws CertificateException
354     {
355         return certFacSpi.engineGenerateCertificate(inStream);
356     }
357 
358     /**
359      * Returns an iteration of the {@code CertPath} encodings supported
360      * by this certificate factory, with the default encoding first. See
361      * the CertPath Encodings section in the &lt;a href=
362      * &quot;{@docRoot}/../specs/security/standard-names.html#certpath-encodings&quot;&gt;
363      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
364      * for information about standard encoding names and their formats.
365      * &lt;p&gt;
366      * Attempts to modify the returned {@code Iterator} via its
367      * {@code remove} method result in an
368      * {@code UnsupportedOperationException}.
369      *
370      * @return an {@code Iterator} over the names of the supported
371      *         {@code CertPath} encodings (as {@code String}s)
372      * @since 1.4
373      */
374     public final Iterator&lt;String&gt; getCertPathEncodings() {
375         return(certFacSpi.engineGetCertPathEncodings());
376     }
377 
378     /**
379      * Generates a {@code CertPath} object and initializes it with
380      * the data read from the {@code InputStream} inStream. The data
381      * is assumed to be in the default encoding. The name of the default
382      * encoding is the first element of the {@code Iterator} returned by
383      * the {@link #getCertPathEncodings getCertPathEncodings} method.
384      *
385      * @param inStream an {@code InputStream} containing the data
386      * @return a {@code CertPath} initialized with the data from the
387      *   {@code InputStream}
<span class="line-modified">388      * @throws    CertificateException if an exception occurs while decoding</span>
389      * @since 1.4
390      */
391     public final CertPath generateCertPath(InputStream inStream)
392         throws CertificateException
393     {
394         return(certFacSpi.engineGenerateCertPath(inStream));
395     }
396 
397     /**
398      * Generates a {@code CertPath} object and initializes it with
399      * the data read from the {@code InputStream} inStream. The data
400      * is assumed to be in the specified encoding. See
401      * the CertPath Encodings section in the &lt;a href=
402      * &quot;{@docRoot}/../specs/security/standard-names.html#certpath-encodings&quot;&gt;
403      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
404      * for information about standard encoding names and their formats.
405      *
406      * @param inStream an {@code InputStream} containing the data
407      * @param encoding the encoding used for the data
408      * @return a {@code CertPath} initialized with the data from the
409      *   {@code InputStream}
<span class="line-modified">410      * @throws    CertificateException if an exception occurs while decoding or</span>
411      *   the encoding requested is not supported
412      * @since 1.4
413      */
414     public final CertPath generateCertPath(InputStream inStream,
415         String encoding) throws CertificateException
416     {
417         return(certFacSpi.engineGenerateCertPath(inStream, encoding));
418     }
419 
420     /**
421      * Generates a {@code CertPath} object and initializes it with
422      * a {@code List} of {@code Certificate}s.
423      * &lt;p&gt;
424      * The certificates supplied must be of a type supported by the
425      * {@code CertificateFactory}. They will be copied out of the supplied
426      * {@code List} object.
427      *
428      * @param certificates a {@code List} of {@code Certificate}s
429      * @return a {@code CertPath} initialized with the supplied list of
430      *   certificates
<span class="line-modified">431      * @throws    CertificateException if an exception occurs</span>
432      * @since 1.4
433      */
434     public final CertPath
435         generateCertPath(List&lt;? extends Certificate&gt; certificates)
436         throws CertificateException
437     {
438         return(certFacSpi.engineGenerateCertPath(certificates));
439     }
440 
441     /**
442      * Returns a (possibly empty) collection view of the certificates read
443      * from the given input stream {@code inStream}.
444      *
445      * &lt;p&gt;In order to take advantage of the specialized certificate format
446      * supported by this certificate factory, each element in
447      * the returned collection view can be typecast to the corresponding
448      * certificate class. For example, if this certificate
449      * factory implements X.509 certificates, the elements in the returned
450      * collection can be typecast to the {@code X509Certificate} class.
451      *
</pre>
<hr />
<pre>
454      * in the formats described for
455      * {@link #generateCertificate(java.io.InputStream) generateCertificate}.
456      * In addition, {@code inStream} may contain a PKCS#7 certificate
457      * chain. This is a PKCS#7 &lt;i&gt;SignedData&lt;/i&gt; object, with the only
458      * significant field being &lt;i&gt;certificates&lt;/i&gt;. In particular, the
459      * signature and the contents are ignored. This format allows multiple
460      * certificates to be downloaded at once. If no certificates are present,
461      * an empty collection is returned.
462      *
463      * &lt;p&gt;Note that if the given input stream does not support
464      * {@link java.io.InputStream#mark(int) mark} and
465      * {@link java.io.InputStream#reset() reset}, this method will
466      * consume the entire input stream.
467      *
468      * @param inStream the input stream with the certificates.
469      *
470      * @return a (possibly empty) collection view of
471      * java.security.cert.Certificate objects
472      * initialized with the data from the input stream.
473      *
<span class="line-modified">474      * @throws    CertificateException on parsing errors.</span>
475      */
476     public final Collection&lt;? extends Certificate&gt; generateCertificates
477             (InputStream inStream) throws CertificateException {
478         return certFacSpi.engineGenerateCertificates(inStream);
479     }
480 
481     /**
482      * Generates a certificate revocation list (CRL) object and initializes it
483      * with the data read from the input stream {@code inStream}.
484      *
485      * &lt;p&gt;In order to take advantage of the specialized CRL format
486      * supported by this certificate factory,
487      * the returned CRL object can be typecast to the corresponding
488      * CRL class. For example, if this certificate
489      * factory implements X.509 CRLs, the returned CRL object
490      * can be typecast to the {@code X509CRL} class.
491      *
492      * &lt;p&gt;Note that if the given input stream does not support
493      * {@link java.io.InputStream#mark(int) mark} and
494      * {@link java.io.InputStream#reset() reset}, this method will
495      * consume the entire input stream. Otherwise, each call to this
496      * method consumes one CRL and the read position of the input stream
497      * is positioned to the next available byte after the inherent
498      * end-of-CRL marker. If the data in the
499      * input stream does not contain an inherent end-of-CRL marker (other
500      * than EOF) and there is trailing data after the CRL is parsed, a
501      * {@code CRLException} is thrown.
502      *
503      * @param inStream an input stream with the CRL data.
504      *
505      * @return a CRL object initialized with the data
506      * from the input stream.
507      *
<span class="line-modified">508      * @throws    CRLException on parsing errors.</span>
509      */
510     public final CRL generateCRL(InputStream inStream)
511         throws CRLException
512     {
513         return certFacSpi.engineGenerateCRL(inStream);
514     }
515 
516     /**
517      * Returns a (possibly empty) collection view of the CRLs read
518      * from the given input stream {@code inStream}.
519      *
520      * &lt;p&gt;In order to take advantage of the specialized CRL format
521      * supported by this certificate factory, each element in
522      * the returned collection view can be typecast to the corresponding
523      * CRL class. For example, if this certificate
524      * factory implements X.509 CRLs, the elements in the returned
525      * collection can be typecast to the {@code X509CRL} class.
526      *
527      * &lt;p&gt;In the case of a certificate factory for X.509 CRLs,
528      * {@code inStream} may contain a sequence of DER-encoded CRLs.
529      * In addition, {@code inStream} may contain a PKCS#7 CRL
530      * set. This is a PKCS#7 &lt;i&gt;SignedData&lt;/i&gt; object, with the only
531      * significant field being &lt;i&gt;crls&lt;/i&gt;. In particular, the
532      * signature and the contents are ignored. This format allows multiple
533      * CRLs to be downloaded at once. If no CRLs are present,
534      * an empty collection is returned.
535      *
536      * &lt;p&gt;Note that if the given input stream does not support
537      * {@link java.io.InputStream#mark(int) mark} and
538      * {@link java.io.InputStream#reset() reset}, this method will
539      * consume the entire input stream.
540      *
541      * @param inStream the input stream with the CRLs.
542      *
543      * @return a (possibly empty) collection view of
544      * java.security.cert.CRL objects initialized with the data from the input
545      * stream.
546      *
<span class="line-modified">547      * @throws    CRLException on parsing errors.</span>
548      */
549     public final Collection&lt;? extends CRL&gt; generateCRLs(InputStream inStream)
550             throws CRLException {
551         return certFacSpi.engineGenerateCRLs(inStream);
552     }
553 }
</pre>
</td>
</tr>
</table>
<center><a href="CertificateExpiredException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateFactorySpi.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
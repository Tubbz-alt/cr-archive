<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleStatics.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodType.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90,21 +90,22 @@</span>
      //// Method handle creation from ordinary methods.
  
      /**
       * Returns a {@link Lookup lookup object} with
       * full capabilities to emulate all supported bytecode behaviors of the caller.
<span class="udiff-line-modified-removed">-      * These capabilities include &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt; to the caller.</span>
<span class="udiff-line-modified-added">+      * These capabilities include {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} to the caller.</span>
       * Factory methods on the lookup object can create
       * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handles&lt;/a&gt;
       * for any member that the caller has access to via bytecodes,
       * including protected and private fields and methods.
       * This lookup object is a &lt;em&gt;capability&lt;/em&gt; which may be delegated to trusted agents.
       * Do not store it in place where untrusted code can access it.
       * &lt;p&gt;
       * This method is caller sensitive, which means that it may return different
       * values to different callers.
<span class="udiff-line-modified-removed">-      * @return a lookup object for the caller of this method, with private access</span>
<span class="udiff-line-modified-added">+      * @return a lookup object for the caller of this method, with</span>
<span class="udiff-line-added">+      * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access}</span>
       */
      @CallerSensitive
      @ForceInline // to ensure Reflection.getCallerClass optimization
      public static Lookup lookup() {
          return new Lookup(Reflection.getCallerClass());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123,27 +124,27 @@</span>
          return new Lookup(caller);
      }
  
      /**
       * Returns a {@link Lookup lookup object} which is trusted minimally.
<span class="udiff-line-modified-removed">-      * The lookup has the {@code PUBLIC} and {@code UNCONDITIONAL} modes.</span>
<span class="udiff-line-modified-added">+      * The lookup has the {@code UNCONDITIONAL} mode.</span>
       * It can only be used to create method handles to public members of
       * public classes in packages that are exported unconditionally.
       * &lt;p&gt;
       * As a matter of pure convention, the {@linkplain Lookup#lookupClass() lookup class}
       * of this lookup object will be {@link java.lang.Object}.
       *
       * @apiNote The use of Object is conventional, and because the lookup modes are
       * limited, there is no special access provided to the internals of Object, its package
<span class="udiff-line-modified-removed">-      * or its module. Consequently, the lookup context of this lookup object will be the</span>
<span class="udiff-line-modified-removed">-      * bootstrap class loader, which means it cannot find user classes.</span>
<span class="udiff-line-modified-added">+      * or its module.  This public lookup object or other lookup object with</span>
<span class="udiff-line-modified-added">+      * {@code UNCONDITIONAL} mode assumes readability. Consequently, the lookup class</span>
<span class="udiff-line-added">+      * is not used to determine the lookup context.</span>
       *
       * &lt;p style=&quot;font-size:smaller;&quot;&gt;
       * &lt;em&gt;Discussion:&lt;/em&gt;
       * The lookup class can be changed to any other class {@code C} using an expression of the form
       * {@link Lookup#in publicLookup().in(C.class)}.
<span class="udiff-line-removed">-      * but may change the lookup context by virtue of changing the class loader.</span>
       * A public lookup object is always subject to
       * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;security manager checks&lt;/a&gt;.
       * Also, it cannot access
       * &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive methods&lt;/a&gt;.
       * @return a lookup object which is trusted minimally
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -154,68 +155,113 @@</span>
      public static Lookup publicLookup() {
          return Lookup.PUBLIC_LOOKUP;
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Returns a {@link Lookup lookup object} with full capabilities to emulate all</span>
<span class="udiff-line-modified-removed">-      * supported bytecode behaviors, including &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;</span>
<span class="udiff-line-modified-removed">-      * private access&lt;/a&gt;, on a target class.</span>
<span class="udiff-line-modified-removed">-      * This method checks that a caller, specified as a {@code Lookup} object, is allowed to</span>
<span class="udiff-line-modified-removed">-      * do &lt;em&gt;deep reflection&lt;/em&gt; on the target class. If {@code m1} is the module containing</span>
<span class="udiff-line-modified-removed">-      * the {@link Lookup#lookupClass() lookup class}, and {@code m2} is the module containing</span>
<span class="udiff-line-modified-removed">-      * the target class, then this check ensures that</span>
<span class="udiff-line-modified-added">+      * Returns a {@link Lookup lookup} object on a target class to emulate all supported</span>
<span class="udiff-line-modified-added">+      * bytecode behaviors, including &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.</span>
<span class="udiff-line-modified-added">+      * The returned lookup object can provide access to classes in modules and packages,</span>
<span class="udiff-line-modified-added">+      * and members of those classes, outside the normal rules of Java access control,</span>
<span class="udiff-line-modified-added">+      * instead conforming to the more permissive rules for modular &lt;em&gt;deep reflection&lt;/em&gt;.</span>
<span class="udiff-line-modified-added">+      * &lt;p&gt;</span>
<span class="udiff-line-modified-added">+      * A caller, specified as a {@code Lookup} object, in module {@code M1} is</span>
<span class="udiff-line-added">+      * allowed to do deep reflection on module {@code M2} and package of the target class</span>
<span class="udiff-line-added">+      * if and only if all of the following conditions are {@code true}:</span>
       * &lt;ul&gt;
<span class="udiff-line-modified-removed">-      *     &lt;li&gt;{@code m1} {@link Module#canRead reads} {@code m2}.&lt;/li&gt;</span>
<span class="udiff-line-modified-removed">-      *     &lt;li&gt;{@code m2} {@link Module#isOpen(String,Module) opens} the package containing</span>
<span class="udiff-line-modified-removed">-      *     the target class to at least {@code m1}.&lt;/li&gt;</span>
<span class="udiff-line-modified-removed">-      *     &lt;li&gt;The lookup has the {@link Lookup#MODULE MODULE} lookup mode.&lt;/li&gt;</span>
<span class="udiff-line-modified-added">+      * &lt;li&gt;If there is a security manager, its {@code checkPermission} method is</span>
<span class="udiff-line-modified-added">+      * called to check {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} and</span>
<span class="udiff-line-modified-added">+      * that must return normally.</span>
<span class="udiff-line-modified-added">+      * &lt;li&gt;The caller lookup object must have {@linkplain Lookup#hasFullPrivilegeAccess()</span>
<span class="udiff-line-added">+      * full privilege access}.  Specifically:</span>
<span class="udiff-line-added">+      *   &lt;ul&gt;</span>
<span class="udiff-line-added">+      *     &lt;li&gt;The caller lookup object must have the {@link Lookup#MODULE MODULE} lookup mode.</span>
<span class="udiff-line-added">+      *         (This is because otherwise there would be no way to ensure the original lookup</span>
<span class="udiff-line-added">+      *         creator was a member of any particular module, and so any subsequent checks</span>
<span class="udiff-line-added">+      *         for readability and qualified exports would become ineffective.)</span>
<span class="udiff-line-added">+      *     &lt;li&gt;The caller lookup object must have {@link Lookup#PRIVATE PRIVATE} access.</span>
<span class="udiff-line-added">+      *         (This is because an application intending to share intra-module access</span>
<span class="udiff-line-added">+      *         using {@link Lookup#MODULE MODULE} alone will inadvertently also share</span>
<span class="udiff-line-added">+      *         deep reflection to its own module.)</span>
<span class="udiff-line-added">+      *   &lt;/ul&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;The target class must be a proper class, not a primitive or array class.</span>
<span class="udiff-line-added">+      * (Thus, {@code M2} is well-defined.)</span>
<span class="udiff-line-added">+      * &lt;li&gt;If the caller module {@code M1} differs from</span>
<span class="udiff-line-added">+      * the target module {@code M2} then both of the following must be true:</span>
<span class="udiff-line-added">+      *   &lt;ul&gt;</span>
<span class="udiff-line-added">+      *     &lt;li&gt;{@code M1} {@link Module#canRead reads} {@code M2}.&lt;/li&gt;</span>
<span class="udiff-line-added">+      *     &lt;li&gt;{@code M2} {@link Module#isOpen(String,Module) opens} the package</span>
<span class="udiff-line-added">+      *         containing the target class to at least {@code M1}.&lt;/li&gt;</span>
<span class="udiff-line-added">+      *   &lt;/ul&gt;</span>
       * &lt;/ul&gt;
       * &lt;p&gt;
<span class="udiff-line-modified-removed">-      * If there is a security manager, its {@code checkPermission} method is called to</span>
<span class="udiff-line-modified-removed">-      * check {@code ReflectPermission(&quot;suppressAccessChecks&quot;)}.</span>
<span class="udiff-line-modified-removed">-      * @apiNote The {@code MODULE} lookup mode serves to authenticate that the lookup object</span>
<span class="udiff-line-modified-removed">-      * was created by code in the caller module (or derived from a lookup object originally</span>
<span class="udiff-line-modified-removed">-      * created by the caller). A lookup object with the {@code MODULE} lookup mode can be</span>
<span class="udiff-line-modified-removed">-      * shared with trusted parties without giving away {@code PRIVATE} and {@code PACKAGE}</span>
<span class="udiff-line-modified-removed">-      * access to the caller.</span>
<span class="udiff-line-modified-added">+      * If any of the above checks is violated, this method fails with an</span>
<span class="udiff-line-modified-added">+      * exception.</span>
<span class="udiff-line-modified-added">+      * &lt;p&gt;</span>
<span class="udiff-line-modified-added">+      * Otherwise, if {@code M1} and {@code M2} are the same module, this method</span>
<span class="udiff-line-modified-added">+      * returns a {@code Lookup} on {@code targetClass} with</span>
<span class="udiff-line-modified-added">+      * {@linkplain Lookup#hasFullPrivilegeAccess() full privilege access} and</span>
<span class="udiff-line-modified-added">+      * {@code null} previous lookup class.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * Otherwise, {@code M1} and {@code M2} are two different modules.  This method</span>
<span class="udiff-line-added">+      * returns a {@code Lookup} on {@code targetClass} that records</span>
<span class="udiff-line-added">+      * the lookup class of the caller as the new previous lookup class and</span>
<span class="udiff-line-added">+      * drops {@code MODULE} access from the full privilege access.</span>
<span class="udiff-line-added">+      *</span>
       * @param targetClass the target class
<span class="udiff-line-modified-removed">-      * @param lookup the caller lookup object</span>
<span class="udiff-line-modified-added">+      * @param caller the caller lookup object</span>
       * @return a lookup object for the target class, with private access
<span class="udiff-line-modified-removed">-      * @throws IllegalArgumentException if {@code targetClass} is a primitve type or array class</span>
<span class="udiff-line-modified-added">+      * @throws IllegalArgumentException if {@code targetClass} is a primitive type or void or array class</span>
       * @throws NullPointerException if {@code targetClass} or {@code caller} is {@code null}
<span class="udiff-line-removed">-      * @throws IllegalAccessException if the access check specified above fails</span>
       * @throws SecurityException if denied by the security manager
<span class="udiff-line-added">+      * @throws IllegalAccessException if any of the other access checks specified above fails</span>
       * @since 9
       * @spec JPMS
       * @see Lookup#dropLookupMode
<span class="udiff-line-added">+      * @see &lt;a href=&quot;MethodHandles.Lookup.html#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
       */
<span class="udiff-line-modified-removed">-     public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup lookup) throws IllegalAccessException {</span>
<span class="udiff-line-modified-added">+     public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup caller) throws IllegalAccessException {</span>
          SecurityManager sm = System.getSecurityManager();
          if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
          if (targetClass.isPrimitive())
              throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
          if (targetClass.isArray())
              throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
<span class="udiff-line-modified-removed">-         Module targetModule = targetClass.getModule();</span>
<span class="udiff-line-modified-removed">-         Module callerModule = lookup.lookupClass().getModule();</span>
<span class="udiff-line-modified-removed">-         if (!callerModule.canRead(targetModule))</span>
<span class="udiff-line-modified-removed">-             throw new IllegalAccessException(callerModule + &quot; does not read &quot; + targetModule);</span>
<span class="udiff-line-modified-removed">-         if (targetModule.isNamed()) {</span>
<span class="udiff-line-modified-removed">-             String pn = targetClass.getPackageName();</span>
<span class="udiff-line-modified-removed">-             assert !pn.isEmpty() : &quot;unnamed package cannot be in named module&quot;;</span>
<span class="udiff-line-modified-removed">-             if (!targetModule.isOpen(pn, callerModule))</span>
<span class="udiff-line-modified-removed">-                 throw new IllegalAccessException(targetModule + &quot; does not open &quot; + pn + &quot; to &quot; + callerModule);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         if ((lookup.lookupModes() &amp; Lookup.MODULE) == 0)</span>
<span class="udiff-line-modified-removed">-             throw new IllegalAccessException(&quot;lookup does not have MODULE lookup mode&quot;);</span>
<span class="udiff-line-modified-added">+         // Ensure that we can reason accurately about private and module access.</span>
<span class="udiff-line-modified-added">+         if (!caller.hasFullPrivilegeAccess())</span>
<span class="udiff-line-modified-added">+             throw new IllegalAccessException(&quot;caller does not have PRIVATE and MODULE lookup mode&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         // previous lookup class is never set if it has MODULE access</span>
<span class="udiff-line-modified-added">+         assert caller.previousLookupClass() == null;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         Class&lt;?&gt; callerClass = caller.lookupClass();</span>
<span class="udiff-line-modified-added">+         Module callerModule = callerClass.getModule();  // M1</span>
<span class="udiff-line-modified-added">+         Module targetModule = targetClass.getModule();  // M2</span>
<span class="udiff-line-modified-added">+         Class&lt;?&gt; newPreviousClass = null;</span>
<span class="udiff-line-modified-added">+         int newModes = Lookup.FULL_POWER_MODES;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (targetModule != callerModule) {</span>
<span class="udiff-line-added">+             if (!callerModule.canRead(targetModule))</span>
<span class="udiff-line-added">+                 throw new IllegalAccessException(callerModule + &quot; does not read &quot; + targetModule);</span>
<span class="udiff-line-added">+             if (targetModule.isNamed()) {</span>
<span class="udiff-line-added">+                 String pn = targetClass.getPackageName();</span>
<span class="udiff-line-added">+                 assert !pn.isEmpty() : &quot;unnamed package cannot be in named module&quot;;</span>
<span class="udiff-line-added">+                 if (!targetModule.isOpen(pn, callerModule))</span>
<span class="udiff-line-added">+                     throw new IllegalAccessException(targetModule + &quot; does not open &quot; + pn + &quot; to &quot; + callerModule);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // M2 != M1, set previous lookup class to M1 and drop MODULE access</span>
<span class="udiff-line-added">+             newPreviousClass = callerClass;</span>
<span class="udiff-line-added">+             newModes &amp;= ~Lookup.MODULE;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          if (!callerModule.isNamed() &amp;&amp; targetModule.isNamed()) {
              IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();
              if (logger != null) {
<span class="udiff-line-modified-removed">-                 logger.logIfOpenedForIllegalAccess(lookup, targetClass);</span>
<span class="udiff-line-modified-added">+                 logger.logIfOpenedForIllegalAccess(caller, targetClass);</span>
              }
          }
<span class="udiff-line-modified-removed">-         return new Lookup(targetClass);</span>
<span class="udiff-line-modified-added">+         return Lookup.newLookup(targetClass, newPreviousClass, newModes);</span>
      }
  
      /**
       * Performs an unchecked &quot;crack&quot; of a
       * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -230,18 +276,17 @@</span>
       * is called with a {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} permission.
       * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
       * @param target a direct method handle to crack into symbolic reference components
       * @param expected a class object representing the desired result type {@code T}
       * @return a reference to the method, constructor, or field object
<span class="udiff-line-modified-removed">-      * @exception SecurityException if the caller is not privileged to call {@code setAccessible}</span>
<span class="udiff-line-modified-removed">-      * @exception NullPointerException if either argument is {@code null}</span>
<span class="udiff-line-modified-removed">-      * @exception IllegalArgumentException if the target is not a direct method handle</span>
<span class="udiff-line-modified-removed">-      * @exception ClassCastException if the member is not of the expected type</span>
<span class="udiff-line-modified-added">+      * @throws    SecurityException if the caller is not privileged to call {@code setAccessible}</span>
<span class="udiff-line-modified-added">+      * @throws    NullPointerException if either argument is {@code null}</span>
<span class="udiff-line-modified-added">+      * @throws    IllegalArgumentException if the target is not a direct method handle</span>
<span class="udiff-line-modified-added">+      * @throws    ClassCastException if the member is not of the expected type</span>
       * @since 1.8
       */
<span class="udiff-line-modified-removed">-     public static &lt;T extends Member&gt; T</span>
<span class="udiff-line-removed">-     reflectAs(Class&lt;T&gt; expected, MethodHandle target) {</span>
<span class="udiff-line-modified-added">+     public static &lt;T extends Member&gt; T reflectAs(Class&lt;T&gt; expected, MethodHandle target) {</span>
          SecurityManager smgr = System.getSecurityManager();
          if (smgr != null)  smgr.checkPermission(ACCESS_PERMISSION);
          Lookup lookup = Lookup.IMPL_LOOKUP;  // use maximally privileged lookup
          return lookup.revealDirect(target).reflectAs(expected, lookup);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -266,16 +311,17 @@</span>
       * The lookup class (or its delegates) may then use factory methods
       * on the {@code Lookup} object to create method handles for access-checked members.
       * This includes all methods, constructors, and fields which are allowed to the lookup class,
       * even private ones.
       *
<span class="udiff-line-modified-removed">-      * &lt;h1&gt;&lt;a id=&quot;lookups&quot;&gt;&lt;/a&gt;Lookup Factory Methods&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+      * &lt;h2&gt;&lt;a id=&quot;lookups&quot;&gt;&lt;/a&gt;Lookup Factory Methods&lt;/h2&gt;</span>
       * The factory methods on a {@code Lookup} object correspond to all major
       * use cases for methods, constructors, and fields.
       * Each method handle created by a factory method is the functional
       * equivalent of a particular &lt;em&gt;bytecode behavior&lt;/em&gt;.
<span class="udiff-line-modified-removed">-      * (Bytecode behaviors are described in section 5.4.3.5 of the Java Virtual Machine Specification.)</span>
<span class="udiff-line-modified-added">+      * (Bytecode behaviors are described in section {@jvms 5.4.3.5} of</span>
<span class="udiff-line-added">+      * the Java Virtual Machine Specification.)</span>
       * Here is a summary of the correspondence between these factory methods and
       * the behavior of the resulting method handles:
       * &lt;table class=&quot;striped&quot;&gt;
       * &lt;caption style=&quot;display:none&quot;&gt;lookup method behaviors&lt;/caption&gt;
       * &lt;thead&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -290,11 +336,11 @@</span>
       *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findGetter lookup.findGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
       *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (T) this.f;}&lt;/td&gt;
       * &lt;/tr&gt;
       * &lt;tr&gt;
       *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticGetter lookup.findStaticGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
<span class="udiff-line-modified-removed">-      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (T) C.f;}&lt;/td&gt;</span>
<span class="udiff-line-modified-added">+      *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (FT) C.f;}&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSetter lookup.findSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
       *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code this.f = x;}&lt;/td&gt;
       * &lt;/tr&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -333,12 +379,12 @@</span>
       * &lt;tr&gt;
       *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectConstructor lookup.unreflectConstructor(aConstructor)}&lt;/th&gt;
       *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code (C) aConstructor.newInstance(arg*);}&lt;/td&gt;
       * &lt;/tr&gt;
       * &lt;tr&gt;
<span class="udiff-line-modified-removed">-      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/th&gt;</span>
<span class="udiff-line-modified-removed">-      *     &lt;td&gt;({@code static})?&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) aMethod.invoke(thisOrNull, arg*);}&lt;/td&gt;</span>
<span class="udiff-line-modified-added">+      *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectSpecial lookup.unreflectSpecial(aMethod,this.class)}&lt;/th&gt;</span>
<span class="udiff-line-modified-added">+      *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) super.m(arg*);}&lt;/td&gt;</span>
       * &lt;/tr&gt;
       * &lt;tr&gt;
       *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findClass lookup.findClass(&quot;C&quot;)}&lt;/th&gt;
       *     &lt;td&gt;{@code class C { ... }}&lt;/td&gt;&lt;td&gt;{@code C.class;}&lt;/td&gt;
       * &lt;/tr&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -359,11 +405,11 @@</span>
       * The name {@code arg} stands for all the other method handle arguments.
       * In the code examples for the Core Reflection API, the name {@code thisOrNull}
       * stands for a null reference if the accessed method or field is static,
       * and {@code this} otherwise.
       * The names {@code aMethod}, {@code aField}, and {@code aConstructor} stand
<span class="udiff-line-modified-removed">-      * for reflective objects corresponding to the given members.</span>
<span class="udiff-line-modified-added">+      * for reflective objects corresponding to the given members declared in type {@code C}.</span>
       * &lt;p&gt;
       * The bytecode behavior for a {@code findClass} operation is a load of a constant class,
       * as if by {@code ldc CONSTANT_Class}.
       * The behavior is represented, not as a method handle, but directly as a {@code Class} constant.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -393,11 +439,11 @@</span>
       * the method handle creation may fail with an
       * {@code IllegalArgumentException}, due to the method handle type having
       * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters.&lt;/a&gt;
       * &lt;/ul&gt;
       *
<span class="udiff-line-modified-removed">-      * &lt;h1&gt;&lt;a id=&quot;access&quot;&gt;&lt;/a&gt;Access checking&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+      * &lt;h2&gt;&lt;a id=&quot;access&quot;&gt;&lt;/a&gt;Access checking&lt;/h2&gt;</span>
       * Access checks are applied in the factory methods of {@code Lookup},
       * when a method handle is created.
       * This is a key difference from the Core Reflection API, since
       * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
       * performs access checking against every caller, on every call.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -420,10 +466,14 @@</span>
       * A lookup can fail, because
       * the containing class is not accessible to the lookup class, or
       * because the desired class member is missing, or because the
       * desired class member is not accessible to the lookup class, or
       * because the lookup object is not trusted enough to access the member.
<span class="udiff-line-added">+      * In the case of a field setter function on a {@code final} field,</span>
<span class="udiff-line-added">+      * finality enforcement is treated as a kind of access control,</span>
<span class="udiff-line-added">+      * and the lookup will fail, except in special cases of</span>
<span class="udiff-line-added">+      * {@link Lookup#unreflectSetter Lookup.unreflectSetter}.</span>
       * In any of these cases, a {@code ReflectiveOperationException} will be
       * thrown from the attempted lookup.  The exact class will be one of
       * the following:
       * &lt;ul&gt;
       * &lt;li&gt;NoSuchMethodException &amp;mdash; if a method is requested but does not exist
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -451,11 +501,12 @@</span>
       * independently of any {@code Lookup} object.
       * &lt;p&gt;
       * If the desired member is {@code protected}, the usual JVM rules apply,
       * including the requirement that the lookup class must either be in the
       * same package as the desired member, or must inherit that member.
<span class="udiff-line-modified-removed">-      * (See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.)</span>
<span class="udiff-line-modified-added">+      * (See the Java Virtual Machine Specification, sections {@jvms</span>
<span class="udiff-line-added">+      * 4.9.2}, {@jvms 5.4.3.5}, and {@jvms 6.4}.)</span>
       * In addition, if the desired member is a non-static field or method
       * in a different package, the resulting method handle may only be applied
       * to objects of the lookup class or one of its subclasses.
       * This requirement is enforced by narrowing the type of the leading
       * {@code this} parameter from {@code C}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -464,21 +515,22 @@</span>
       * &lt;p&gt;
       * The JVM imposes a similar requirement on {@code invokespecial} instruction,
       * that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
       * the current class.  Again, this requirement is enforced by narrowing the
       * type of the leading parameter to the resulting method handle.
<span class="udiff-line-modified-removed">-      * (See the Java Virtual Machine Specification, section 4.10.1.9.)</span>
<span class="udiff-line-modified-added">+      * (See the Java Virtual Machine Specification, section {@jmvs 4.10.1.9}.)</span>
       * &lt;p&gt;
       * The JVM represents constructors and static initializer blocks as internal methods
       * with special names ({@code &quot;&lt;init&gt;&quot;} and {@code &quot;&lt;clinit&gt;&quot;}).
       * The internal syntax of invocation instructions allows them to refer to such internal
       * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
       * A lookup of such an internal method will produce a {@code NoSuchMethodException}.
       * &lt;p&gt;
       * If the relationship between nested types is expressed directly through the
       * {@code NestHost} and {@code NestMembers} attributes
<span class="udiff-line-modified-removed">-      * (see the Java Virtual Machine Specification, sections 4.7.28 and 4.7.29),</span>
<span class="udiff-line-modified-added">+      * (see the Java Virtual Machine Specification, sections {@jvms</span>
<span class="udiff-line-added">+      * 4.7.28} and {@jvms 4.7.29}),</span>
       * then the associated {@code Lookup} object provides direct access to
       * the lookup class and all of its nestmates
       * (see {@link java.lang.Class#getNestHost Class.getNestHost}).
       * Otherwise, access between nested classes is obtained by the Java compiler creating
       * a wrapper method to access a private method of another class in the same nest.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -504,34 +556,552 @@</span>
       * Also, the {@link Lookup#in Lookup.in} method may produce a lookup object
       * with fewer access modes than the original lookup object.
       *
       * &lt;p style=&quot;font-size:smaller;&quot;&gt;
       * &lt;a id=&quot;privacc&quot;&gt;&lt;/a&gt;
<span class="udiff-line-modified-removed">-      * &lt;em&gt;Discussion of private access:&lt;/em&gt;</span>
<span class="udiff-line-modified-added">+      * &lt;em&gt;Discussion of private and module access:&lt;/em&gt;</span>
       * We say that a lookup has &lt;em&gt;private access&lt;/em&gt;
       * if its {@linkplain #lookupModes lookup modes}
       * include the possibility of accessing {@code private} members
       * (which includes the private members of nestmates).
       * As documented in the relevant methods elsewhere,
       * only lookups with private access possess the following capabilities:
       * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
       * &lt;li&gt;access private fields, methods, and constructors of the lookup class and its nestmates
<span class="udiff-line-removed">-      * &lt;li&gt;create method handles which invoke &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt; methods,</span>
<span class="udiff-line-removed">-      *     such as {@code Class.forName}</span>
       * &lt;li&gt;create method handles which {@link Lookup#findSpecial emulate invokespecial} instructions
       * &lt;li&gt;avoid &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;package access checks&lt;/a&gt;
       *     for classes accessible to the lookup class
       * &lt;li&gt;create {@link Lookup#in delegated lookup objects} which have private access to other classes
       *     within the same package member
       * &lt;/ul&gt;
       * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<span class="udiff-line-added">+      * Similarly, a lookup with module access ensures that the original lookup creator was</span>
<span class="udiff-line-added">+      * a member in the same module as the lookup class.</span>
<span class="udiff-line-added">+      * &lt;p style=&quot;font-size:smaller;&quot;&gt;</span>
<span class="udiff-line-added">+      * Private and module access are independently determined modes; a lookup may have</span>
<span class="udiff-line-added">+      * either or both or neither.  A lookup which possesses both access modes is said to</span>
<span class="udiff-line-added">+      * possess {@linkplain #hasFullPrivilegeAccess() full privilege access}.  Such a lookup has</span>
<span class="udiff-line-added">+      * the following additional capability:</span>
<span class="udiff-line-added">+      * &lt;ul style=&quot;font-size:smaller;&quot;&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;create method handles which invoke &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt; methods,</span>
<span class="udiff-line-added">+      *     such as {@code Class.forName}</span>
<span class="udiff-line-added">+      * &lt;/ul&gt;</span>
<span class="udiff-line-added">+      * &lt;p style=&quot;font-size:smaller;&quot;&gt;</span>
       * Each of these permissions is a consequence of the fact that a lookup object
       * with private access can be securely traced back to an originating class,
       * whose &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; and Java language access permissions
       * can be reliably determined and emulated by method handles.
       *
<span class="udiff-line-modified-removed">-      * &lt;h1&gt;&lt;a id=&quot;secmgr&quot;&gt;&lt;/a&gt;Security manager interactions&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+      * &lt;h2&gt;&lt;a id=&quot;cross-module-lookup&quot;&gt;&lt;/a&gt;Cross-module lookups&lt;/h2&gt;</span>
<span class="udiff-line-added">+      * When a lookup class in one module {@code M1} accesses a class in another module</span>
<span class="udiff-line-added">+      * {@code M2}, extra access checking is performed beyond the access mode bits.</span>
<span class="udiff-line-added">+      * A {@code Lookup} with {@link #PUBLIC} mode and a lookup class in {@code M1}</span>
<span class="udiff-line-added">+      * can access public types in {@code M2} when {@code M2} is readable to {@code M1}</span>
<span class="udiff-line-added">+      * and when the type is in a package of {@code M2} that is exported to</span>
<span class="udiff-line-added">+      * at least {@code M1}.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * A {@code Lookup} on {@code C} can also &lt;em&gt;teleport&lt;/em&gt; to a target class</span>
<span class="udiff-line-added">+      * via {@link #in(Class) Lookup.in} and {@link MethodHandles#privateLookupIn(Class, Lookup)</span>
<span class="udiff-line-added">+      * MethodHandles.privateLookupIn} methods.</span>
<span class="udiff-line-added">+      * Teleporting across modules will always record the original lookup class as</span>
<span class="udiff-line-added">+      * the &lt;em&gt;{@linkplain #previousLookupClass() previous lookup class}&lt;/em&gt;</span>
<span class="udiff-line-added">+      * and drops {@link Lookup#MODULE MODULE} access.</span>
<span class="udiff-line-added">+      * If the target class is in the same module as the lookup class {@code C},</span>
<span class="udiff-line-added">+      * then the target class becomes the new lookup class</span>
<span class="udiff-line-added">+      * and there is no change to the previous lookup class.</span>
<span class="udiff-line-added">+      * If the target class is in a different module from {@code M1} ({@code C}&#39;s module),</span>
<span class="udiff-line-added">+      * {@code C} becomes the new previous lookup class</span>
<span class="udiff-line-added">+      * and the target class becomes the new lookup class.</span>
<span class="udiff-line-added">+      * In that case, if there was already a previous lookup class in {@code M0},</span>
<span class="udiff-line-added">+      * and it differs from {@code M1} and {@code M2}, then the resulting lookup</span>
<span class="udiff-line-added">+      * drops all privileges.</span>
<span class="udiff-line-added">+      * For example,</span>
<span class="udiff-line-added">+      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="udiff-line-added">+      * {@code</span>
<span class="udiff-line-added">+      * Lookup lookup = MethodHandles.lookup();   // in class C</span>
<span class="udiff-line-added">+      * Lookup lookup2 = lookup.in(D.class);</span>
<span class="udiff-line-added">+      * MethodHandle mh = lookup2.findStatic(E.class, &quot;m&quot;, MT);</span>
<span class="udiff-line-added">+      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * The {@link #lookup()} factory method produces a {@code Lookup} object</span>
<span class="udiff-line-added">+      * with {@code null} previous lookup class.</span>
<span class="udiff-line-added">+      * {@link Lookup#in lookup.in(D.class)} transforms the {@code lookup} on class {@code C}</span>
<span class="udiff-line-added">+      * to class {@code D} without elevation of privileges.</span>
<span class="udiff-line-added">+      * If {@code C} and {@code D} are in the same module,</span>
<span class="udiff-line-added">+      * {@code lookup2} records {@code D} as the new lookup class and keeps the</span>
<span class="udiff-line-added">+      * same previous lookup class as the original {@code lookup}, or</span>
<span class="udiff-line-added">+      * {@code null} if not present.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * When a {@code Lookup} teleports from a class</span>
<span class="udiff-line-added">+      * in one nest to another nest, {@code PRIVATE} access is dropped.</span>
<span class="udiff-line-added">+      * When a {@code Lookup} teleports from a class in one package to</span>
<span class="udiff-line-added">+      * another package, {@code PACKAGE} access is dropped.</span>
<span class="udiff-line-added">+      * When a {@code Lookup} teleports from a class in one module to another module,</span>
<span class="udiff-line-added">+      * {@code MODULE} access is dropped.</span>
<span class="udiff-line-added">+      * Teleporting across modules drops the ability to access non-exported classes</span>
<span class="udiff-line-added">+      * in both the module of the new lookup class and the module of the old lookup class</span>
<span class="udiff-line-added">+      * and the resulting {@code Lookup} remains only {@code PUBLIC} access.</span>
<span class="udiff-line-added">+      * A {@code Lookup} can teleport back and forth to a class in the module of</span>
<span class="udiff-line-added">+      * the lookup class and the module of the previous class lookup.</span>
<span class="udiff-line-added">+      * Teleporting across modules can only decrease access but cannot increase it.</span>
<span class="udiff-line-added">+      * Teleporting to some third module drops all accesses.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * In the above example, if {@code C} and {@code D} are in different modules,</span>
<span class="udiff-line-added">+      * {@code lookup2} records {@code D} as its lookup class and</span>
<span class="udiff-line-added">+      * {@code C} as its previous lookup class and {@code lookup2} has only</span>
<span class="udiff-line-added">+      * {@code PUBLIC} access. {@code lookup2} can teleport to other class in</span>
<span class="udiff-line-added">+      * {@code C}&#39;s module and {@code D}&#39;s module.</span>
<span class="udiff-line-added">+      * If class {@code E} is in a third module, {@code lookup2.in(E.class)} creates</span>
<span class="udiff-line-added">+      * a {@code Lookup} on {@code E} with no access and {@code lookup2}&#39;s lookup</span>
<span class="udiff-line-added">+      * class {@code D} is recorded as its previous lookup class.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * Teleporting across modules restricts access to the public types that</span>
<span class="udiff-line-added">+      * both the lookup class and the previous lookup class can equally access</span>
<span class="udiff-line-added">+      * (see below).</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * {@link MethodHandles#privateLookupIn(Class, Lookup) MethodHandles.privateLookupIn(T.class, lookup)}</span>
<span class="udiff-line-added">+      * can be used to teleport a {@code lookup} from class {@code C} to class {@code T}</span>
<span class="udiff-line-added">+      * and create a new {@code Lookup} with &lt;a href=&quot;#privacc&quot;&gt;private access&lt;/a&gt;</span>
<span class="udiff-line-added">+      * if the lookup class is allowed to do &lt;em&gt;deep reflection&lt;/em&gt; on {@code T}.</span>
<span class="udiff-line-added">+      * The {@code lookup} must have {@link #MODULE} and {@link #PRIVATE} access</span>
<span class="udiff-line-added">+      * to call {@code privateLookupIn}.</span>
<span class="udiff-line-added">+      * A {@code lookup} on {@code C} in module {@code M1} is allowed to do deep reflection</span>
<span class="udiff-line-added">+      * on all classes in {@code M1}.  If {@code T} is in {@code M1}, {@code privateLookupIn}</span>
<span class="udiff-line-added">+      * produces a new {@code Lookup} on {@code T} with full capabilities.</span>
<span class="udiff-line-added">+      * A {@code lookup} on {@code C} is also allowed</span>
<span class="udiff-line-added">+      * to do deep reflection on {@code T} in another module {@code M2} if</span>
<span class="udiff-line-added">+      * {@code M1} reads {@code M2} and {@code M2} {@link Module#isOpen(String,Module) opens}</span>
<span class="udiff-line-added">+      * the package containing {@code T} to at least {@code M1}.</span>
<span class="udiff-line-added">+      * {@code T} becomes the new lookup class and {@code C} becomes the new previous</span>
<span class="udiff-line-added">+      * lookup class and {@code MODULE} access is dropped from the resulting {@code Lookup}.</span>
<span class="udiff-line-added">+      * The resulting {@code Lookup} can be used to do member lookup or teleport</span>
<span class="udiff-line-added">+      * to another lookup class by calling {@link #in Lookup::in}.  But</span>
<span class="udiff-line-added">+      * it cannot be used to obtain another private {@code Lookup} by calling</span>
<span class="udiff-line-added">+      * {@link MethodHandles#privateLookupIn(Class, Lookup) privateLookupIn}</span>
<span class="udiff-line-added">+      * because it has no {@code MODULE} access.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;h2&gt;&lt;a id=&quot;module-access-check&quot;&gt;&lt;/a&gt;Cross-module access checks&lt;/h2&gt;</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * A {@code Lookup} with {@link #PUBLIC} or with {@link #UNCONDITIONAL} mode</span>
<span class="udiff-line-added">+      * allows cross-module access. The access checking is performed with respect</span>
<span class="udiff-line-added">+      * to both the lookup class and the previous lookup class if present.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * A {@code Lookup} with {@link #UNCONDITIONAL} mode can access public type</span>
<span class="udiff-line-added">+      * in all modules when the type is in a package that is {@linkplain Module#isExported(String)</span>
<span class="udiff-line-added">+      * exported unconditionally}.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * If a {@code Lookup} on {@code LC} in {@code M1} has no previous lookup class,</span>
<span class="udiff-line-added">+      * the lookup with {@link #PUBLIC} mode can access all public types in modules</span>
<span class="udiff-line-added">+      * that are readable to {@code M1} and the type is in a package that is exported</span>
<span class="udiff-line-added">+      * at least to {@code M1}.</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * If a {@code Lookup} on {@code LC} in {@code M1} has a previous lookup class</span>
<span class="udiff-line-added">+      * {@code PLC} on {@code M0}, the lookup with {@link #PUBLIC} mode can access</span>
<span class="udiff-line-added">+      * the intersection of all public types that are accessible to {@code M1}</span>
<span class="udiff-line-added">+      * with all public types that are accessible to {@code M0}. {@code M0}</span>
<span class="udiff-line-added">+      * reads {@code M1} and hence the set of accessible types includes:</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="udiff-line-added">+      * &lt;caption style=&quot;display:none&quot;&gt;</span>
<span class="udiff-line-added">+      * Public types in the following packages are accessible to the</span>
<span class="udiff-line-added">+      * lookup class and the previous lookup class.</span>
<span class="udiff-line-added">+      * &lt;/caption&gt;</span>
<span class="udiff-line-added">+      * &lt;thead&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;col&quot;&gt;Equally accessible types to {@code M0} and {@code M1}&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;/thead&gt;</span>
<span class="udiff-line-added">+      * &lt;tbody&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from {@code M1}&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from {@code M0} if {@code M1} reads {@code M0}&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;unconditional-exported packages from a third module {@code M2}</span>
<span class="udiff-line-added">+      * if both {@code M0} and {@code M1} read {@code M2}&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from {@code M1} to {@code M0}&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from {@code M0} to {@code M1}</span>
<span class="udiff-line-added">+      * if {@code M1} reads {@code M0}&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;qualified-exported packages from a third module {@code M2} to</span>
<span class="udiff-line-added">+      * both {@code M0} and {@code M1} if both {@code M0} and {@code M1} read {@code M2}&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;/tbody&gt;</span>
<span class="udiff-line-added">+      * &lt;/table&gt;</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;h2&gt;&lt;a id=&quot;access-modes&quot;&gt;&lt;/a&gt;Access modes&lt;/h2&gt;</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * The table below shows the access modes of a {@code Lookup} produced by</span>
<span class="udiff-line-added">+      * any of the following factory or transformation methods:</span>
<span class="udiff-line-added">+      * &lt;ul&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;{@link #lookup() MethodHandles.lookup()}&lt;/li&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;{@link #publicLookup() MethodHandles.publicLookup()}&lt;/li&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;{@link #privateLookupIn(Class, Lookup) MethodHandles.privateLookupIn}&lt;/li&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;{@link Lookup#in}&lt;/li&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;{@link Lookup#dropLookupMode(int)}&lt;/li&gt;</span>
<span class="udiff-line-added">+      * &lt;/ul&gt;</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="udiff-line-added">+      * &lt;caption style=&quot;display:none&quot;&gt;</span>
<span class="udiff-line-added">+      * Access mode summary</span>
<span class="udiff-line-added">+      * &lt;/caption&gt;</span>
<span class="udiff-line-added">+      * &lt;thead&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;col&quot;&gt;Lookup object&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;th style=&quot;text-align:center&quot;&gt;protected&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;th style=&quot;text-align:center&quot;&gt;private&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;th style=&quot;text-align:center&quot;&gt;package&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;th style=&quot;text-align:center&quot;&gt;module&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;th style=&quot;text-align:center&quot;&gt;public&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;/thead&gt;</span>
<span class="udiff-line-added">+      * &lt;tbody&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL = MethodHandles.lookup()} in {@code C}&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(C1)} same package&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(C1)} same module&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;th scope=&quot;row&quot; style=&quot;text-align:left&quot;&gt;{@code CL.in(D)} different module&lt;/th&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code CL.in(D).in(C)} hop back to module&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1 = privateLookupIn(C1,CL)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1a = privateLookupIn(C,PRI1)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1.in(C1)} same package&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1.in(C1)} different package&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1.in(D)} different module&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1.dropLookupMode(PROTECTED)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1.dropLookupMode(PRIVATE)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1.dropLookupMode(PACKAGE)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1.dropLookupMode(MODULE)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI1.dropLookupMode(PUBLIC)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2 = privateLookupIn(D,CL)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code privateLookupIn(D,PRI1)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRO&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code privateLookupIn(C,PRI2)} fails&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;IAE&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2.in(D2)} same package&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2.in(D2)} different package&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2.in(C1)} hop back to module&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2.in(E)} hop to third module&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2.dropLookupMode(PROTECTED)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2.dropLookupMode(PRIVATE)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2.dropLookupMode(PACKAGE)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2.dropLookupMode(MODULE)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;2R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PRI2.dropLookupMode(PUBLIC)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code CL.dropLookupMode(PROTECTED)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PRI&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code CL.dropLookupMode(PRIVATE)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;PAC&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code CL.dropLookupMode(PACKAGE)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;MOD&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code CL.dropLookupMode(MODULE)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;1R&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code CL.dropLookupMode(PUBLIC)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PUB = publicLookup()}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PUB.in(D)} different module&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PUB.in(D).in(E)} third module&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;U&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code PUB.dropLookupMode(UNCONDITIONAL)}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code privateLookupIn(C1,PUB)} fails&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;IAE&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;tr&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;{@code ANY.in(X)}, for inaccessible {@code X}&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td&gt;&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;td style=&quot;text-align:center&quot;&gt;none&lt;/td&gt;</span>
<span class="udiff-line-added">+      * &lt;/tr&gt;</span>
<span class="udiff-line-added">+      * &lt;/tbody&gt;</span>
<span class="udiff-line-added">+      * &lt;/table&gt;</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * Notes:</span>
<span class="udiff-line-added">+      * &lt;ul&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;Class {@code C} and class {@code C1} are in module {@code M1},</span>
<span class="udiff-line-added">+      *     but {@code D} and {@code D2} are in module {@code M2}, and {@code E}</span>
<span class="udiff-line-added">+      *     is in module {@code M3}. {@code X} stands for class which is inaccessible</span>
<span class="udiff-line-added">+      *     to the lookup. {@code ANY} stands for any of the example lookups.&lt;/li&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;{@code PRO} indicates {@link #PROTECTED} bit set,</span>
<span class="udiff-line-added">+      *     {@code PRI} indicates {@link #PRIVATE} bit set,</span>
<span class="udiff-line-added">+      *     {@code PAC} indicates {@link #PACKAGE} bit set,</span>
<span class="udiff-line-added">+      *     {@code MOD} indicates {@link #MODULE} bit set,</span>
<span class="udiff-line-added">+      *     {@code 1R} and {@code 2R} indicate {@link #PUBLIC} bit set,</span>
<span class="udiff-line-added">+      *     {@code U} indicates {@link #UNCONDITIONAL} bit set,</span>
<span class="udiff-line-added">+      *     {@code IAE} indicates {@code IllegalAccessException} thrown.&lt;/li&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;Public access comes in three kinds:</span>
<span class="udiff-line-added">+      * &lt;ul&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;unconditional ({@code U}): the lookup assumes readability.</span>
<span class="udiff-line-added">+      *     The lookup has {@code null} previous lookup class.</span>
<span class="udiff-line-added">+      * &lt;li&gt;one-module-reads ({@code 1R}): the module access checking is</span>
<span class="udiff-line-added">+      *     performed with respect to the lookup class.  The lookup has {@code null}</span>
<span class="udiff-line-added">+      *     previous lookup class.</span>
<span class="udiff-line-added">+      * &lt;li&gt;two-module-reads ({@code 2R}): the module access checking is</span>
<span class="udiff-line-added">+      *     performed with respect to the lookup class and the previous lookup class.</span>
<span class="udiff-line-added">+      *     The lookup has a non-null previous lookup class which is in a</span>
<span class="udiff-line-added">+      *     different module from the current lookup class.</span>
<span class="udiff-line-added">+      * &lt;/ul&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;Any attempt to reach a third module loses all access.&lt;/li&gt;</span>
<span class="udiff-line-added">+      * &lt;li&gt;If a target class {@code X} is not accessible to {@code Lookup::in}</span>
<span class="udiff-line-added">+      * all access modes are dropped.&lt;/li&gt;</span>
<span class="udiff-line-added">+      * &lt;/ul&gt;</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;h2&gt;&lt;a id=&quot;secmgr&quot;&gt;&lt;/a&gt;Security manager interactions&lt;/h2&gt;</span>
       * Although bytecode instructions can only refer to classes in
       * a related class loader, this API can search for methods in any
       * class, as long as a reference to its {@code Class} object is
       * available.  Such cross-loader references are also possible with the
       * Core Reflection API, and are impossible to bytecode instructions
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -554,11 +1124,11 @@</span>
       * member is actually defined.
       * (If a class or other type is being accessed,
       * the {@code refc} and {@code defc} values are the class itself.)
       * The value {@code lookc} is defined as &lt;em&gt;not present&lt;/em&gt;
       * if the current lookup object does not have
<span class="udiff-line-modified-removed">-      * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.</span>
<span class="udiff-line-modified-added">+      * {@linkplain #hasFullPrivilegeAccess() full privilege access}.</span>
       * The calls are made according to the following rules:
       * &lt;ul&gt;
       * &lt;li&gt;&lt;b&gt;Step 1:&lt;/b&gt;
       *     If {@code lookc} is not present, or if its class loader is not
       *     the same as or an ancestor of the class loader of {@code refc},
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -585,12 +1155,18 @@</span>
       * &lt;/ul&gt;
       * Security checks are performed after other access checks have passed.
       * Therefore, the above rules presuppose a member or class that is public,
       * or else that is being accessed from a lookup class that has
       * rights to access the member or class.
<span class="udiff-line-added">+      * &lt;p&gt;</span>
<span class="udiff-line-added">+      * If a security manager is present and the current lookup object does not have</span>
<span class="udiff-line-added">+      * {@linkplain #hasFullPrivilegeAccess() full privilege access}, then</span>
<span class="udiff-line-added">+      * {@link #defineClass(byte[]) defineClass}</span>
<span class="udiff-line-added">+      * calls {@link SecurityManager#checkPermission smgr.checkPermission}</span>
<span class="udiff-line-added">+      * with {@code RuntimePermission(&quot;defineClass&quot;)}.</span>
       *
<span class="udiff-line-modified-removed">-      * &lt;h1&gt;&lt;a id=&quot;callsens&quot;&gt;&lt;/a&gt;Caller sensitive methods&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+      * &lt;h2&gt;&lt;a id=&quot;callsens&quot;&gt;&lt;/a&gt;Caller sensitive methods&lt;/h2&gt;</span>
       * A small number of Java methods have a special property called caller sensitivity.
       * A &lt;em&gt;caller-sensitive&lt;/em&gt; method can behave differently depending on the
       * identity of its immediate caller.
       * &lt;p&gt;
       * If a method handle for a caller-sensitive method is requested,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -604,12 +1180,12 @@</span>
       * different lookup classes may give rise to
       * differently behaving method handles.
       * &lt;p&gt;
       * In cases where the lookup object is
       * {@link MethodHandles#publicLookup() publicLookup()},
<span class="udiff-line-modified-removed">-      * or some other lookup object without</span>
<span class="udiff-line-modified-removed">-      * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;,</span>
<span class="udiff-line-modified-added">+      * or some other lookup object without the</span>
<span class="udiff-line-modified-added">+      * {@linkplain #hasFullPrivilegeAccess() full privilege access},</span>
       * the lookup class is disregarded.
       * In such cases, no caller-sensitive method handle can be created,
       * access is forbidden, and the lookup fails with an
       * {@code IllegalAccessException}.
       * &lt;p style=&quot;font-size:smaller;&quot;&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -639,10 +1215,13 @@</span>
      public static final
      class Lookup {
          /** The class on behalf of whom the lookup is being performed. */
          private final Class&lt;?&gt; lookupClass;
  
<span class="udiff-line-added">+         /** previous lookup class */</span>
<span class="udiff-line-added">+         private final Class&lt;?&gt; prevLookupClass;</span>
<span class="udiff-line-added">+ </span>
          /** The allowed sorts of members which may be looked up (PUBLIC, etc.). */
          private final int allowedModes;
  
          static {
              Reflection.registerFieldsToFilter(Lookup.class, Set.of(&quot;lookupClass&quot;, &quot;allowedModes&quot;));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,10 +1229,14 @@</span>
  
          /** A single-bit mask representing {@code public} access,
           *  which may contribute to the result of {@link #lookupModes lookupModes}.
           *  The value, {@code 0x01}, happens to be the same as the value of the
           *  {@code public} {@linkplain java.lang.reflect.Modifier#PUBLIC modifier bit}.
<span class="udiff-line-added">+          *  &lt;p&gt;</span>
<span class="udiff-line-added">+          *  A {@code Lookup} with this lookup mode performs cross-module access check</span>
<span class="udiff-line-added">+          *  with respect to the {@linkplain #lookupClass() lookup class} and</span>
<span class="udiff-line-added">+          *  {@linkplain #previousLookupClass() previous lookup class} if present.</span>
           */
          public static final int PUBLIC = Modifier.PUBLIC;
  
          /** A single-bit mask representing {@code private} access,
           *  which may contribute to the result of {@link #lookupModes lookupModes}.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -674,18 +1257,22 @@</span>
           *  The value is {@code 0x08}, which does not correspond meaningfully to
           *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
           */
          public static final int PACKAGE = Modifier.STATIC;
  
<span class="udiff-line-modified-removed">-         /** A single-bit mask representing {@code module} access (default access),</span>
<span class="udiff-line-modified-added">+         /** A single-bit mask representing {@code module} access,</span>
           *  which may contribute to the result of {@link #lookupModes lookupModes}.
           *  The value is {@code 0x10}, which does not correspond meaningfully to
           *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
           *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}
           *  with this lookup mode can access all public types in the module of the
           *  lookup class and public types in packages exported by other modules
           *  to the module of the lookup class.
<span class="udiff-line-added">+          *  &lt;p&gt;</span>
<span class="udiff-line-added">+          *  If this lookup mode is set, the {@linkplain #previousLookupClass()</span>
<span class="udiff-line-added">+          *  previous lookup class} is always {@code null}.</span>
<span class="udiff-line-added">+          *</span>
           *  @since 9
           *  @spec JPMS
           */
          public static final int MODULE = PACKAGE &lt;&lt; 1;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -693,45 +1280,87 @@</span>
           *  which may contribute to the result of {@link #lookupModes lookupModes}.
           *  The value is {@code 0x20}, which does not correspond meaningfully to
           *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
           *  A {@code Lookup} with this lookup mode assumes {@linkplain
           *  java.lang.Module#canRead(java.lang.Module) readability}.
<span class="udiff-line-modified-removed">-          *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}</span>
<span class="udiff-line-modified-removed">-          *  with this lookup mode can access all public members of public types</span>
<span class="udiff-line-removed">-          *  of all modules where the type is in a package that is {@link</span>
<span class="udiff-line-modified-added">+          *  This lookup mode can access all public members of public types</span>
<span class="udiff-line-modified-added">+          *  of all modules when the type is in a package that is {@link</span>
           *  java.lang.Module#isExported(String) exported unconditionally}.
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          *  &lt;p&gt;</span>
<span class="udiff-line-added">+          *  If this lookup mode is set, the {@linkplain #previousLookupClass()</span>
<span class="udiff-line-added">+          *  previous lookup class} is always {@code null}.</span>
<span class="udiff-line-added">+          *</span>
           *  @since 9
           *  @spec JPMS
           *  @see #publicLookup()
           */
          public static final int UNCONDITIONAL = PACKAGE &lt;&lt; 2;
  
          private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL);
          private static final int FULL_POWER_MODES = (ALL_MODES &amp; ~UNCONDITIONAL);
          private static final int TRUSTED   = -1;
  
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Adjust PUBLIC =&gt; PUBLIC|MODULE|UNCONDITIONAL</span>
<span class="udiff-line-added">+          * Adjust 0 =&gt; PACKAGE</span>
<span class="udiff-line-added">+          */</span>
          private static int fixmods(int mods) {
              mods &amp;= (ALL_MODES - PACKAGE - MODULE - UNCONDITIONAL);
<span class="udiff-line-modified-removed">-             return (mods != 0) ? mods : (PACKAGE | MODULE | UNCONDITIONAL);</span>
<span class="udiff-line-modified-added">+             if (Modifier.isPublic(mods))</span>
<span class="udiff-line-added">+                 mods |= UNCONDITIONAL;</span>
<span class="udiff-line-added">+             return (mods != 0) ? mods : PACKAGE;</span>
          }
  
          /** Tells which class is performing the lookup.  It is this class against
           *  which checks are performed for visibility and access permissions.
           *  &lt;p&gt;
<span class="udiff-line-added">+          *  If this lookup object has a {@linkplain #previousLookupClass() previous lookup class},</span>
<span class="udiff-line-added">+          *  access checks are performed against both the lookup class and the previous lookup class.</span>
<span class="udiff-line-added">+          *  &lt;p&gt;</span>
           *  The class implies a maximum level of access permission,
           *  but the permissions may be additionally limited by the bitmask
           *  {@link #lookupModes lookupModes}, which controls whether non-public members
           *  can be accessed.
           *  @return the lookup class, on behalf of which this lookup object finds members
<span class="udiff-line-added">+          *  @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
           */
          public Class&lt;?&gt; lookupClass() {
              return lookupClass;
          }
  
<span class="udiff-line-added">+         /** Reports a lookup class in another module that this lookup object</span>
<span class="udiff-line-added">+          * was previously teleported from, or {@code null}.</span>
<span class="udiff-line-added">+          * &lt;p&gt;</span>
<span class="udiff-line-added">+          * A {@code Lookup} object produced by the factory methods, such as the</span>
<span class="udiff-line-added">+          * {@link #lookup() lookup()} and {@link #publicLookup() publicLookup()} method,</span>
<span class="udiff-line-added">+          * has {@code null} previous lookup class.</span>
<span class="udiff-line-added">+          * A {@code Lookup} object has a non-null previous lookup class</span>
<span class="udiff-line-added">+          * when this lookup was teleported from an old lookup class</span>
<span class="udiff-line-added">+          * in one module to a new lookup class in another module.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @return the lookup class in another module that this lookup object was</span>
<span class="udiff-line-added">+          *         previously teleported from, or {@code null}</span>
<span class="udiff-line-added">+          * @since 14</span>
<span class="udiff-line-added">+          * @see #in(Class)</span>
<span class="udiff-line-added">+          * @see MethodHandles#privateLookupIn(Class, Lookup)</span>
<span class="udiff-line-added">+          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public Class&lt;?&gt; previousLookupClass() {</span>
<span class="udiff-line-added">+             return prevLookupClass;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          // This is just for calling out to MethodHandleImpl.
          private Class&lt;?&gt; lookupClassOrNull() {
<span class="udiff-line-modified-removed">-             return (allowedModes == TRUSTED) ? null : lookupClass;</span>
<span class="udiff-line-modified-added">+             if (allowedModes == TRUSTED) {</span>
<span class="udiff-line-added">+                 return null;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (allowedModes == UNCONDITIONAL) {</span>
<span class="udiff-line-added">+                 // use Object as the caller to pass to VM doing resolution</span>
<span class="udiff-line-added">+                 return Object.class;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return lookupClass;</span>
          }
  
          /** Tells which access-protection classes of members this lookup object can produce.
           *  The result is a bit-mask of the bits
           *  {@linkplain #PUBLIC PUBLIC (0x01)},
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -768,129 +1397,177 @@</span>
           * for method handle creation.
           * Must be called by from a method in this package,
           * which in turn is called by a method not in this package.
           */
          Lookup(Class&lt;?&gt; lookupClass) {
<span class="udiff-line-modified-removed">-             this(lookupClass, FULL_POWER_MODES);</span>
<span class="udiff-line-modified-added">+             this(lookupClass, null, FULL_POWER_MODES);</span>
              // make sure we haven&#39;t accidentally picked up a privileged class:
              checkUnprivilegedlookupClass(lookupClass);
          }
  
<span class="udiff-line-modified-removed">-         private Lookup(Class&lt;?&gt; lookupClass, int allowedModes) {</span>
<span class="udiff-line-modified-added">+         private Lookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {</span>
<span class="udiff-line-added">+             assert prevLookupClass == null || ((allowedModes &amp; MODULE) == 0</span>
<span class="udiff-line-added">+                     &amp;&amp; prevLookupClass.getModule() != lookupClass.getModule());</span>
<span class="udiff-line-added">+             assert !lookupClass.isArray() &amp;&amp; !lookupClass.isPrimitive();</span>
              this.lookupClass = lookupClass;
<span class="udiff-line-added">+             this.prevLookupClass = prevLookupClass;</span>
              this.allowedModes = allowedModes;
          }
  
<span class="udiff-line-added">+         private static Lookup newLookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {</span>
<span class="udiff-line-added">+             // make sure we haven&#39;t accidentally picked up a privileged class:</span>
<span class="udiff-line-added">+             checkUnprivilegedlookupClass(lookupClass);</span>
<span class="udiff-line-added">+             return new Lookup(lookupClass, prevLookupClass, allowedModes);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          /**
           * Creates a lookup on the specified new lookup class.
           * The resulting object will report the specified
           * class as its own {@link #lookupClass() lookupClass}.
<span class="udiff-line-added">+          *</span>
           * &lt;p&gt;
           * However, the resulting {@code Lookup} object is guaranteed
           * to have no more access capabilities than the original.
           * In particular, access capabilities can be lost as follows:&lt;ul&gt;
<span class="udiff-line-modified-removed">-          * &lt;li&gt;If the old lookup class is in a {@link Module#isNamed() named} module, and</span>
<span class="udiff-line-modified-removed">-          * the new lookup class is in a different module {@code M}, then no members, not</span>
<span class="udiff-line-removed">-          * even public members in {@code M}&#39;s exported packages, will be accessible.</span>
<span class="udiff-line-removed">-          * The exception to this is when this lookup is {@link #publicLookup()</span>
<span class="udiff-line-removed">-          * publicLookup}, in which case {@code PUBLIC} access is not lost.</span>
<span class="udiff-line-removed">-          * &lt;li&gt;If the old lookup class is in an unnamed module, and the new lookup class</span>
<span class="udiff-line-removed">-          * is a different module then {@link #MODULE MODULE} access is lost.</span>
<span class="udiff-line-removed">-          * &lt;li&gt;If the new lookup class differs from the old one then {@code UNCONDITIONAL} is lost.</span>
<span class="udiff-line-modified-added">+          * &lt;li&gt;If the new lookup class is in a different module from the old one,</span>
<span class="udiff-line-modified-added">+          * i.e. {@link #MODULE MODULE} access is lost.</span>
           * &lt;li&gt;If the new lookup class is in a different package
<span class="udiff-line-modified-removed">-          * than the old one, protected and default (package) members will not be accessible.</span>
<span class="udiff-line-modified-added">+          * than the old one, protected and default (package) members will not be accessible,</span>
<span class="udiff-line-added">+          * i.e. {@link #PROTECTED PROTECTED} and {@link #PACKAGE PACKAGE} access are lost.</span>
           * &lt;li&gt;If the new lookup class is not within the same package member
           * as the old one, private members will not be accessible, and protected members
<span class="udiff-line-modified-removed">-          * will not be accessible by virtue of inheritance.</span>
<span class="udiff-line-modified-added">+          * will not be accessible by virtue of inheritance,</span>
<span class="udiff-line-added">+          * i.e. {@link #PRIVATE PRIVATE} access is lost.</span>
           * (Protected members may continue to be accessible because of package sharing.)
<span class="udiff-line-modified-removed">-          * &lt;li&gt;If the new lookup class is not accessible to the old lookup class,</span>
<span class="udiff-line-modified-removed">-          * then no members, not even public members, will be accessible.</span>
<span class="udiff-line-modified-removed">-          * (In all other cases, public members will continue to be accessible.)</span>
<span class="udiff-line-modified-added">+          * &lt;li&gt;If the new lookup class is not</span>
<span class="udiff-line-modified-added">+          * {@linkplain #accessClass(Class) accessible} to this lookup,</span>
<span class="udiff-line-modified-added">+          * then no members, not even public members, will be accessible</span>
<span class="udiff-line-added">+          * i.e. all access modes are lost.</span>
<span class="udiff-line-added">+          * &lt;li&gt;If the new lookup class, the old lookup class and the previous lookup class</span>
<span class="udiff-line-added">+          * are all in different modules i.e. teleporting to a third module,</span>
<span class="udiff-line-added">+          * all access modes are lost.</span>
           * &lt;/ul&gt;
           * &lt;p&gt;
<span class="udiff-line-added">+          * The new previous lookup class is chosen as follows:</span>
<span class="udiff-line-added">+          * &lt;ul&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt;If the new lookup object has {@link #UNCONDITIONAL UNCONDITIONAL} bit,</span>
<span class="udiff-line-added">+          * the new previous lookup class is {@code null}.</span>
<span class="udiff-line-added">+          * &lt;li&gt;If the new lookup class is in the same module as the old lookup class,</span>
<span class="udiff-line-added">+          * the new previous lookup class is the old previous lookup class.</span>
<span class="udiff-line-added">+          * &lt;li&gt;If the new lookup class is in a different module from the old lookup class,</span>
<span class="udiff-line-added">+          * the new previous lookup class is the old lookup class.</span>
<span class="udiff-line-added">+          *&lt;/ul&gt;</span>
<span class="udiff-line-added">+          * &lt;p&gt;</span>
           * The resulting lookup&#39;s capabilities for loading classes
           * (used during {@link #findClass} invocations)
           * are determined by the lookup class&#39; loader,
           * which may change due to this operation.
<span class="udiff-line-modified-removed">-          *</span>
<span class="udiff-line-modified-added">+          * &lt;p&gt;</span>
           * @param requestedLookupClass the desired lookup class for the new lookup object
           * @return a lookup object which reports the desired lookup class, or the same object
           * if there is no change
<span class="udiff-line-added">+          * @throws IllegalArgumentException if {@code requestedLookupClass} is a primitive type or void or array class</span>
           * @throws NullPointerException if the argument is null
           *
           * @revised 9
           * @spec JPMS
<span class="udiff-line-added">+          * @see #accessClass(Class)</span>
<span class="udiff-line-added">+          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
           */
          public Lookup in(Class&lt;?&gt; requestedLookupClass) {
              Objects.requireNonNull(requestedLookupClass);
<span class="udiff-line-added">+             if (requestedLookupClass.isPrimitive())</span>
<span class="udiff-line-added">+                 throw new IllegalArgumentException(requestedLookupClass + &quot; is a primitive class&quot;);</span>
<span class="udiff-line-added">+             if (requestedLookupClass.isArray())</span>
<span class="udiff-line-added">+                 throw new IllegalArgumentException(requestedLookupClass + &quot; is an array class&quot;);</span>
<span class="udiff-line-added">+ </span>
              if (allowedModes == TRUSTED)  // IMPL_LOOKUP can make any lookup at all
<span class="udiff-line-modified-removed">-                 return new Lookup(requestedLookupClass, FULL_POWER_MODES);</span>
<span class="udiff-line-modified-added">+                 return new Lookup(requestedLookupClass, null, FULL_POWER_MODES);</span>
              if (requestedLookupClass == this.lookupClass)
                  return this;  // keep same capabilities
              int newModes = (allowedModes &amp; FULL_POWER_MODES);
<span class="udiff-line-modified-removed">-             if (!VerifyAccess.isSameModule(this.lookupClass, requestedLookupClass)) {</span>
<span class="udiff-line-modified-removed">-                 // Need to drop all access when teleporting from a named module to another</span>
<span class="udiff-line-modified-removed">-                 // module. The exception is publicLookup where PUBLIC is not lost.</span>
<span class="udiff-line-modified-removed">-                 if (this.lookupClass.getModule().isNamed()</span>
<span class="udiff-line-modified-removed">-                     &amp;&amp; (this.allowedModes &amp; UNCONDITIONAL) == 0)</span>
<span class="udiff-line-modified-added">+             Module fromModule = this.lookupClass.getModule();</span>
<span class="udiff-line-modified-added">+             Module targetModule = requestedLookupClass.getModule();</span>
<span class="udiff-line-modified-added">+             Class&lt;?&gt; plc = this.previousLookupClass();</span>
<span class="udiff-line-modified-added">+             if ((this.allowedModes &amp; UNCONDITIONAL) != 0) {</span>
<span class="udiff-line-modified-added">+                 assert plc == null;</span>
<span class="udiff-line-added">+                 newModes = UNCONDITIONAL;</span>
<span class="udiff-line-added">+             } else if (fromModule != targetModule) {</span>
<span class="udiff-line-added">+                 if (plc != null &amp;&amp; !VerifyAccess.isSameModule(plc, requestedLookupClass)) {</span>
<span class="udiff-line-added">+                     // allow hopping back and forth between fromModule and plc&#39;s module</span>
<span class="udiff-line-added">+                     // but not the third module</span>
                      newModes = 0;
<span class="udiff-line-modified-removed">-                 else</span>
<span class="udiff-line-modified-removed">-                     newModes &amp;= ~(MODULE|PACKAGE|PRIVATE|PROTECTED);</span>
<span class="udiff-line-modified-added">+                 }</span>
<span class="udiff-line-modified-added">+                 // drop MODULE access</span>
<span class="udiff-line-added">+                 newModes &amp;= ~(MODULE|PACKAGE|PRIVATE|PROTECTED);</span>
<span class="udiff-line-added">+                 // teleport from this lookup class</span>
<span class="udiff-line-added">+                 plc = this.lookupClass;</span>
              }
              if ((newModes &amp; PACKAGE) != 0
                  &amp;&amp; !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
                  newModes &amp;= ~(PACKAGE|PRIVATE|PROTECTED);
              }
              // Allow nestmate lookups to be created without special privilege:
              if ((newModes &amp; PRIVATE) != 0
                  &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {
                  newModes &amp;= ~(PRIVATE|PROTECTED);
              }
<span class="udiff-line-modified-removed">-             if ((newModes &amp; PUBLIC) != 0</span>
<span class="udiff-line-modified-removed">-                 &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, allowedModes)) {</span>
<span class="udiff-line-modified-added">+             if ((newModes &amp; (PUBLIC|UNCONDITIONAL)) != 0</span>
<span class="udiff-line-modified-added">+                 &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, this.prevLookupClass, allowedModes)) {</span>
                  // The requested class it not accessible from the lookup class.
                  // No permissions.
                  newModes = 0;
              }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-             checkUnprivilegedlookupClass(requestedLookupClass);</span>
<span class="udiff-line-removed">-             return new Lookup(requestedLookupClass, newModes);</span>
<span class="udiff-line-modified-added">+             return newLookup(requestedLookupClass, plc, newModes);</span>
          }
  
<span class="udiff-line-removed">- </span>
          /**
           * Creates a lookup on the same lookup class which this lookup object
           * finds members, but with a lookup mode that has lost the given lookup mode.
           * The lookup mode to drop is one of {@link #PUBLIC PUBLIC}, {@link #MODULE
           * MODULE}, {@link #PACKAGE PACKAGE}, {@link #PROTECTED PROTECTED} or {@link #PRIVATE PRIVATE}.
<span class="udiff-line-modified-removed">-          * {@link #PROTECTED PROTECTED} and {@link #UNCONDITIONAL UNCONDITIONAL} are always</span>
<span class="udiff-line-modified-removed">-          * dropped and so the resulting lookup mode will never have these access capabilities.</span>
<span class="udiff-line-modified-added">+          * {@link #PROTECTED PROTECTED} is always</span>
<span class="udiff-line-modified-added">+          * dropped and so the resulting lookup mode will never have this access capability.</span>
           * When dropping {@code PACKAGE} then the resulting lookup will not have {@code PACKAGE}
           * or {@code PRIVATE} access. When dropping {@code MODULE} then the resulting lookup will
           * not have {@code MODULE}, {@code PACKAGE}, or {@code PRIVATE} access. If {@code PUBLIC}
<span class="udiff-line-added">+          * is dropped then the resulting lookup has no access. If {@code UNCONDITIONAL}</span>
           * is dropped then the resulting lookup has no access.
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @apiNote</span>
<span class="udiff-line-added">+          * A lookup with {@code PACKAGE} but not {@code PRIVATE} mode can safely</span>
<span class="udiff-line-added">+          * delegate non-public access within the package of the lookup class without</span>
<span class="udiff-line-added">+          * conferring  &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.</span>
<span class="udiff-line-added">+          * A lookup with {@code MODULE} but not</span>
<span class="udiff-line-added">+          * {@code PACKAGE} mode can safely delegate {@code PUBLIC} access within</span>
<span class="udiff-line-added">+          * the module of the lookup class without conferring package access.</span>
<span class="udiff-line-added">+          * A lookup with a {@linkplain #previousLookupClass() previous lookup class}</span>
<span class="udiff-line-added">+          * (and {@code PUBLIC} but not {@code MODULE} mode) can safely delegate access</span>
<span class="udiff-line-added">+          * to public classes accessible to both the module of the lookup class</span>
<span class="udiff-line-added">+          * and the module of the previous lookup class.</span>
<span class="udiff-line-added">+          *</span>
           * @param modeToDrop the lookup mode to drop
           * @return a lookup object which lacks the indicated mode, or the same object if there is no change
           * @throws IllegalArgumentException if {@code modeToDrop} is not one of {@code PUBLIC},
           * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE} or {@code UNCONDITIONAL}
           * @see MethodHandles#privateLookupIn
           * @since 9
           */
          public Lookup dropLookupMode(int modeToDrop) {
              int oldModes = lookupModes();
<span class="udiff-line-modified-removed">-             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED | UNCONDITIONAL);</span>
<span class="udiff-line-modified-added">+             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED);</span>
              switch (modeToDrop) {
<span class="udiff-line-modified-removed">-                 case PUBLIC: newModes &amp;= ~(ALL_MODES); break;</span>
<span class="udiff-line-modified-added">+                 case PUBLIC: newModes &amp;= ~(FULL_POWER_MODES); break;</span>
                  case MODULE: newModes &amp;= ~(PACKAGE | PRIVATE); break;
                  case PACKAGE: newModes &amp;= ~(PRIVATE); break;
                  case PROTECTED:
                  case PRIVATE:
                  case UNCONDITIONAL: break;
                  default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);
              }
              if (newModes == oldModes) return this;  // return self if no change
<span class="udiff-line-modified-removed">-             return new Lookup(lookupClass(), newModes);</span>
<span class="udiff-line-modified-added">+             return newLookup(lookupClass(), previousLookupClass(), newModes);</span>
          }
  
          /**
           * Defines a class to the same class loader and in the same runtime package and
           * {@linkplain java.security.ProtectionDomain protection domain} as this lookup&#39;s
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -909,35 +1586,38 @@</span>
           *
           * &lt;p&gt; This method does not run the class initializer. The class initializer may
           * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
           * Specification&lt;/em&gt;. &lt;/p&gt;
           *
<span class="udiff-line-modified-removed">-          * &lt;p&gt; If there is a security manager, its {@code checkPermission} method is first called</span>
<span class="udiff-line-modified-removed">-          * to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;</span>
<span class="udiff-line-modified-added">+          * &lt;p&gt; If there is a security manager and this lookup does not have {@linkplain</span>
<span class="udiff-line-modified-added">+          * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method</span>
<span class="udiff-line-added">+          * is first called to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;</span>
           *
           * @param bytes the class bytes
           * @return the {@code Class} object for the class
           * @throws IllegalArgumentException the bytes are for a class in a different package
           * to the lookup class
           * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
           * @throws LinkageError if the class is malformed ({@code ClassFormatError}), cannot be
           * verified ({@code VerifyError}), is already defined, or another linkage error occurs
<span class="udiff-line-modified-removed">-          * @throws SecurityException if denied by the security manager</span>
<span class="udiff-line-modified-added">+          * @throws SecurityException if a security manager is present and it</span>
<span class="udiff-line-added">+          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
           * @throws NullPointerException if {@code bytes} is {@code null}
           * @since 9
           * @spec JPMS
           * @see Lookup#privateLookupIn
           * @see Lookup#dropLookupMode
           * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
           */
          public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {
<span class="udiff-line-modified-removed">-             SecurityManager sm = System.getSecurityManager();</span>
<span class="udiff-line-modified-removed">-             if (sm != null)</span>
<span class="udiff-line-modified-removed">-                 sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));</span>
<span class="udiff-line-modified-added">+             if (!hasFullPrivilegeAccess()) {</span>
<span class="udiff-line-modified-added">+                 SecurityManager sm = System.getSecurityManager();</span>
<span class="udiff-line-modified-added">+                 if (sm != null)</span>
<span class="udiff-line-added">+                     sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));</span>
<span class="udiff-line-added">+             }</span>
              if ((lookupModes() &amp; PACKAGE) == 0)
                  throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);
<span class="udiff-line-removed">-             assert (lookupModes() &amp; (MODULE|PUBLIC)) != 0;</span>
  
              // parse class bytes to get class name (in internal form)
              bytes = bytes.clone();
              String name;
              try {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -991,41 +1671,43 @@</span>
  
          // Make sure outer class is initialized first.
          static { IMPL_NAMES.getClass(); }
  
          /** Package-private version of lookup which is trusted. */
<span class="udiff-line-modified-removed">-         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, TRUSTED);</span>
<span class="udiff-line-modified-added">+         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);</span>
  
          /** Version of lookup which is trusted minimally.
           *  It can only be used to create method handles to publicly accessible
           *  members in packages that are exported unconditionally.
           */
<span class="udiff-line-modified-removed">-         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, (PUBLIC|UNCONDITIONAL));</span>
<span class="udiff-line-modified-added">+         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);</span>
  
          private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
              String name = lookupClass.getName();
              if (name.startsWith(&quot;java.lang.invoke.&quot;))
                  throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
          }
  
          /**
           * Displays the name of the class from which lookups are to be made.
<span class="udiff-line-added">+          * followed with &quot;/&quot; and the name of the {@linkplain #previousLookupClass()</span>
<span class="udiff-line-added">+          * previous lookup class} if present.</span>
           * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
           * If there are restrictions on the access permitted to this lookup,
           * this is indicated by adding a suffix to the class name, consisting
           * of a slash and a keyword.  The keyword represents the strongest
           * allowed access, and is chosen as follows:
           * &lt;ul&gt;
           * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
<span class="udiff-line-added">+          * &lt;li&gt;If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.</span>
           * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.
<span class="udiff-line-removed">-          * &lt;li&gt;If only public access and unconditional access are allowed, the suffix is &quot;/publicLookup&quot;.</span>
           * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
<span class="udiff-line-modified-removed">-          * &lt;li&gt;If only public, module and package access are allowed, the suffix is &quot;/package&quot;.</span>
<span class="udiff-line-modified-removed">-          * &lt;li&gt;If only public, module, package, and private access are allowed, the suffix is &quot;/private&quot;.</span>
<span class="udiff-line-modified-added">+          * &lt;li&gt;If public and package access are allowed, the suffix is &quot;/package&quot;.</span>
<span class="udiff-line-modified-added">+          * &lt;li&gt;If public, package, and private access are allowed, the suffix is &quot;/private&quot;.</span>
           * &lt;/ul&gt;
<span class="udiff-line-modified-removed">-          * If none of the above cases apply, it is the case that full</span>
<span class="udiff-line-modified-removed">-          * access (public, module, package, private, and protected) is allowed.</span>
<span class="udiff-line-modified-added">+          * If none of the above cases apply, it is the case that full access</span>
<span class="udiff-line-modified-added">+          * (public, module, package, private, and protected) is allowed.</span>
           * In this case, no suffix is added.
           * This is true only of an object obtained originally from
           * {@link java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}.
           * Objects created by {@link java.lang.invoke.MethodHandles.Lookup#in Lookup.in}
           * always have restricted access, and will display a suffix.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1041,24 +1723,29 @@</span>
           * @spec JPMS
           */
          @Override
          public String toString() {
              String cname = lookupClass.getName();
<span class="udiff-line-added">+             if (prevLookupClass != null)</span>
<span class="udiff-line-added">+                 cname += &quot;/&quot; + prevLookupClass.getName();</span>
              switch (allowedModes) {
              case 0:  // no privileges
                  return cname + &quot;/noaccess&quot;;
<span class="udiff-line-added">+             case UNCONDITIONAL:</span>
<span class="udiff-line-added">+                 return cname + &quot;/publicLookup&quot;;</span>
              case PUBLIC:
                  return cname + &quot;/public&quot;;
<span class="udiff-line-removed">-             case PUBLIC|UNCONDITIONAL:</span>
<span class="udiff-line-removed">-                 return cname  + &quot;/publicLookup&quot;;</span>
              case PUBLIC|MODULE:
                  return cname + &quot;/module&quot;;
<span class="udiff-line-added">+             case PUBLIC|PACKAGE:</span>
              case PUBLIC|MODULE|PACKAGE:
                  return cname + &quot;/package&quot;;
<span class="udiff-line-modified-removed">-             case FULL_POWER_MODES &amp; ~PROTECTED:</span>
<span class="udiff-line-modified-removed">-                 return cname + &quot;/private&quot;;</span>
<span class="udiff-line-modified-added">+             case FULL_POWER_MODES &amp; (~PROTECTED):</span>
<span class="udiff-line-modified-added">+             case FULL_POWER_MODES &amp; ~(PROTECTED|MODULE):</span>
<span class="udiff-line-added">+                     return cname + &quot;/private&quot;;</span>
              case FULL_POWER_MODES:
<span class="udiff-line-added">+             case FULL_POWER_MODES &amp; (~MODULE):</span>
                  return cname;
              case TRUSTED:
                  return &quot;/trusted&quot;;  // internal only; not exported
              default:  // Should not happen, but it&#39;s a bitfield...
                  cname = cname + &quot;/&quot; + Integer.toHexString(allowedModes);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1097,18 +1784,17 @@</span>
           * @throws NoSuchMethodException if the method does not exist
           * @throws IllegalAccessException if access checking fails,
           *                                or if the method is not {@code static},
           *                                or if the method&#39;s variable arity modifier bit
           *                                is set and {@code asVarargsCollector} fails
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           */
<span class="udiff-line-modified-removed">-         public</span>
<span class="udiff-line-removed">-         MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {</span>
<span class="udiff-line-modified-added">+         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {</span>
              MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<span class="udiff-line-modified-removed">-             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerClass(method));</span>
<span class="udiff-line-modified-added">+             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));</span>
          }
  
          /**
           * Produces a method handle for a virtual method.
           * The type of the method handle will be that of the method,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1182,11 +1868,11 @@</span>
           * @throws NoSuchMethodException if the method does not exist
           * @throws IllegalAccessException if access checking fails,
           *                                or if the method is {@code static},
           *                                or if the method&#39;s variable arity modifier bit
           *                                is set and {@code asVarargsCollector} fails
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           */
          public MethodHandle findVirtual(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
              if (refc == MethodHandle.class) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1196,11 +1882,11 @@</span>
                  MethodHandle mh = findVirtualForVH(name, type);
                  if (mh != null)  return mh;
              }
              byte refKind = (refc.isInterface() ? REF_invokeInterface : REF_invokeVirtual);
              MemberName method = resolveOrFail(refKind, refc, name, type);
<span class="udiff-line-modified-removed">-             return getDirectMethod(refKind, refc, method, findBoundCallerClass(method));</span>
<span class="udiff-line-modified-added">+             return getDirectMethod(refKind, refc, method, findBoundCallerLookup(method));</span>
          }
          private MethodHandle findVirtualForMH(String name, MethodType type) {
              // these names require special lookups because of the implicit MethodType argument
              if (&quot;invoke&quot;.equals(name))
                  return invoker(type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1256,11 +1942,11 @@</span>
           * @return the desired method handle
           * @throws NoSuchMethodException if the constructor does not exist
           * @throws IllegalAccessException if access checking fails
           *                                or if the method&#39;s variable arity modifier bit
           *                                is set and {@code asVarargsCollector} fails
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           */
          public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
              if (refc.isArray()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1270,53 +1956,104 @@</span>
              MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
              return getDirectConstructor(refc, ctor);
          }
  
          /**
<span class="udiff-line-modified-removed">-          * Looks up a class by name from the lookup context defined by this {@code Lookup} object. The static</span>
<span class="udiff-line-modified-removed">-          * initializer of the class is not run.</span>
<span class="udiff-line-modified-added">+          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,</span>
<span class="udiff-line-modified-added">+          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.</span>
<span class="udiff-line-added">+          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,</span>
<span class="udiff-line-added">+          * and then determines whether the class is accessible to this lookup object.</span>
           * &lt;p&gt;
<span class="udiff-line-modified-removed">-          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class}, its class</span>
<span class="udiff-line-modified-removed">-          * loader, and the {@linkplain #lookupModes() lookup modes}. In particular, the method first attempts to</span>
<span class="udiff-line-removed">-          * load the requested class, and then determines whether the class is accessible to this lookup object.</span>
<span class="udiff-line-modified-added">+          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},</span>
<span class="udiff-line-modified-added">+          * its class loader, and the {@linkplain #lookupModes() lookup modes}.</span>
           *
           * @param targetName the fully qualified name of the class to be looked up.
           * @return the requested class.
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-removed">-          *            &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
<span class="udiff-line-modified-added">+          * @throws SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
           * @throws LinkageError if the linkage fails
           * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
           * @throws IllegalAccessException if the class is not accessible, using the allowed access
           * modes.
<span class="udiff-line-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-removed">-          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
           * @since 9
<span class="udiff-line-added">+          * @jvms 5.4.3.1 Class and Interface Resolution</span>
           */
          public Class&lt;?&gt; findClass(String targetName) throws ClassNotFoundException, IllegalAccessException {
              Class&lt;?&gt; targetClass = Class.forName(targetName, false, lookupClass.getClassLoader());
              return accessClass(targetClass);
          }
  
          /**
<span class="udiff-line-modified-removed">-          * Determines if a class can be accessed from the lookup context defined by this {@code Lookup} object. The</span>
<span class="udiff-line-modified-removed">-          * static initializer of the class is not run.</span>
<span class="udiff-line-modified-added">+          * Determines if a class can be accessed from the lookup context defined by</span>
<span class="udiff-line-modified-added">+          * this {@code Lookup} object. The static initializer of the class is not run.</span>
           * &lt;p&gt;
<span class="udiff-line-modified-removed">-          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class} and the</span>
<span class="udiff-line-modified-removed">-          * {@linkplain #lookupModes() lookup modes}.</span>
<span class="udiff-line-modified-added">+          * If the {@code targetClass} is in the same module as the lookup class,</span>
<span class="udiff-line-modified-added">+          * the lookup class is {@code LC} in module {@code M1} and</span>
<span class="udiff-line-added">+          * the previous lookup class is in module {@code M0} or</span>
<span class="udiff-line-added">+          * {@code null} if not present,</span>
<span class="udiff-line-added">+          * {@code targetClass} is accessible if and only if one of the following is true:</span>
<span class="udiff-line-added">+          * &lt;ul&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt;If this lookup has {@link #PRIVATE} access, {@code targetClass} is</span>
<span class="udiff-line-added">+          *     {@code LC} or other class in the same nest of {@code LC}.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt;If this lookup has {@link #PACKAGE} access, {@code targetClass} is</span>
<span class="udiff-line-added">+          *     in the same runtime package of {@code LC}.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt;If this lookup has {@link #MODULE} access, {@code targetClass} is</span>
<span class="udiff-line-added">+          *     a public type in {@code M1}.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt;If this lookup has {@link #PUBLIC} access, {@code targetClass} is</span>
<span class="udiff-line-added">+          *     a public type in a package exported by {@code M1} to at least  {@code M0}</span>
<span class="udiff-line-added">+          *     if the previous lookup class is present; otherwise, {@code targetClass}</span>
<span class="udiff-line-added">+          *     is a public type in a package exported by {@code M1} unconditionally.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;/ul&gt;</span>
           *
<span class="udiff-line-modified-removed">-          * @param targetClass the class to be access-checked</span>
<span class="udiff-line-modified-added">+          * &lt;p&gt;</span>
<span class="udiff-line-added">+          * Otherwise, if this lookup has {@link #UNCONDITIONAL} access, this lookup</span>
<span class="udiff-line-added">+          * can access public types in all modules when the type is in a package</span>
<span class="udiff-line-added">+          * that is exported unconditionally.</span>
<span class="udiff-line-added">+          * &lt;p&gt;</span>
<span class="udiff-line-added">+          * Otherwise, the target class is in a different module from {@code lookupClass},</span>
<span class="udiff-line-added">+          * and if this lookup does not have {@code PUBLIC} access, {@code lookupClass}</span>
<span class="udiff-line-added">+          * is inaccessible.</span>
<span class="udiff-line-added">+          * &lt;p&gt;</span>
<span class="udiff-line-added">+          * Otherwise, if this lookup has no {@linkplain #previousLookupClass() previous lookup class},</span>
<span class="udiff-line-added">+          * {@code M1} is the module containing {@code lookupClass} and</span>
<span class="udiff-line-added">+          * {@code M2} is the module containing {@code targetClass},</span>
<span class="udiff-line-added">+          * then {@code targetClass} is accessible if and only if</span>
<span class="udiff-line-added">+          * &lt;ul&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt;{@code M1} reads {@code M2}, and</span>
<span class="udiff-line-added">+          * &lt;li&gt;{@code targetClass} is public and in a package exported by</span>
<span class="udiff-line-added">+          *     {@code M2} at least to {@code M1}.</span>
<span class="udiff-line-added">+          * &lt;/ul&gt;</span>
<span class="udiff-line-added">+          * &lt;p&gt;</span>
<span class="udiff-line-added">+          * Otherwise, if this lookup has a {@linkplain #previousLookupClass() previous lookup class},</span>
<span class="udiff-line-added">+          * {@code M1} and {@code M2} are as before, and {@code M0} is the module</span>
<span class="udiff-line-added">+          * containing the previous lookup class, then {@code targetClass} is accessible</span>
<span class="udiff-line-added">+          * if and only if one of the following is true:</span>
<span class="udiff-line-added">+          * &lt;ul&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt;{@code targetClass} is in {@code M0} and {@code M1}</span>
<span class="udiff-line-added">+          *     {@linkplain Module#reads reads} {@code M0} and the type is</span>
<span class="udiff-line-added">+          *     in a package that is exported to at least {@code M1}.</span>
<span class="udiff-line-added">+          * &lt;li&gt;{@code targetClass} is in {@code M1} and {@code M0}</span>
<span class="udiff-line-added">+          *     {@linkplain Module#reads reads} {@code M1} and the type is</span>
<span class="udiff-line-added">+          *     in a package that is exported to at least {@code M0}.</span>
<span class="udiff-line-added">+          * &lt;li&gt;{@code targetClass} is in a third module {@code M2} and both {@code M0}</span>
<span class="udiff-line-added">+          *     and {@code M1} reads {@code M2} and the type is in a package</span>
<span class="udiff-line-added">+          *     that is exported to at least both {@code M0} and {@code M2}.</span>
<span class="udiff-line-added">+          * &lt;/ul&gt;</span>
<span class="udiff-line-added">+          * &lt;p&gt;</span>
<span class="udiff-line-added">+          * Otherwise, {@code targetClass} is not accessible.</span>
           *
<span class="udiff-line-added">+          * @param targetClass the class to be access-checked</span>
           * @return the class that has been access-checked
<span class="udiff-line-modified-removed">-          *</span>
<span class="udiff-line-modified-removed">-          * @throws IllegalAccessException if the class is not accessible from the lookup class, using the allowed access</span>
<span class="udiff-line-modified-removed">-          * modes.</span>
<span class="udiff-line-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws IllegalAccessException if the class is not accessible from the lookup class</span>
<span class="udiff-line-modified-added">+          * and previous lookup class, if present, using the allowed access modes.</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @since 9
<span class="udiff-line-added">+          * @see &lt;a href=&quot;#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;</span>
           */
          public Class&lt;?&gt; accessClass(Class&lt;?&gt; targetClass) throws IllegalAccessException {
<span class="udiff-line-modified-removed">-             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, allowedModes)) {</span>
<span class="udiff-line-modified-added">+             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {</span>
                  throw new MemberName(targetClass).makeAccessException(&quot;access violation&quot;, this);
              }
              checkSecurityManager(targetClass, null);
              return targetClass;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1388,20 +2125,20 @@</span>
           * @throws NoSuchMethodException if the method does not exist
           * @throws IllegalAccessException if access checking fails,
           *                                or if the method is {@code static},
           *                                or if the method&#39;s variable arity modifier bit
           *                                is set and {@code asVarargsCollector} fails
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           */
          public MethodHandle findSpecial(Class&lt;?&gt; refc, String name, MethodType type,
                                          Class&lt;?&gt; specialCaller) throws NoSuchMethodException, IllegalAccessException {
              checkSpecialCaller(specialCaller, refc);
              Lookup specialLookup = this.in(specialCaller);
              MemberName method = specialLookup.resolveOrFail(REF_invokeSpecial, refc, name, type);
<span class="udiff-line-modified-removed">-             return specialLookup.getDirectMethod(REF_invokeSpecial, refc, method, findBoundCallerClass(method));</span>
<span class="udiff-line-modified-added">+             return specialLookup.getDirectMethod(REF_invokeSpecial, refc, method, findBoundCallerLookup(method));</span>
          }
  
          /**
           * Produces a method handle giving read access to a non-static field.
           * The type of the method handle will have a return type of the field&#39;s
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1413,11 +2150,11 @@</span>
           * @param name the field&#39;s name
           * @param type the field&#39;s type
           * @return a method handle which can load values from the field
           * @throws NoSuchFieldException if the field does not exist
           * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           * @see #findVarHandle(Class, String, Class)
           */
          public MethodHandle findGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1436,11 +2173,12 @@</span>
           * @param name the field&#39;s name
           * @param type the field&#39;s type
           * @return a method handle which can store values into the field
           * @throws NoSuchFieldException if the field does not exist
           * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          *                                or {@code final}</span>
<span class="udiff-line-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           * @see #findVarHandle(Class, String, Class)
           */
          public MethodHandle findSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1509,11 +2247,11 @@</span>
           * @param name the field&#39;s name
           * @param type the field&#39;s type, of type {@code T}
           * @return a VarHandle giving access to non-static fields.
           * @throws NoSuchFieldException if the field does not exist
           * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           * @since 9
           */
          public VarHandle findVarHandle(Class&lt;?&gt; recv, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1535,11 +2273,11 @@</span>
           * @param name the field&#39;s name
           * @param type the field&#39;s type
           * @return a method handle which can load values from the field
           * @throws NoSuchFieldException if the field does not exist
           * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           */
          public MethodHandle findStaticGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
              MemberName field = resolveOrFail(REF_getStatic, refc, name, type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1559,11 +2297,12 @@</span>
           * @param name the field&#39;s name
           * @param type the field&#39;s type
           * @return a method handle which can store values into the field
           * @throws NoSuchFieldException if the field does not exist
           * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          *                                or is {@code final}</span>
<span class="udiff-line-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           */
          public MethodHandle findStaticSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
              MemberName field = resolveOrFail(REF_putStatic, refc, name, type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1633,11 +2372,11 @@</span>
           * @param name the field&#39;s name
           * @param type the field&#39;s type, of type {@code T}
           * @return a VarHandle giving access to a static field
           * @throws NoSuchFieldException if the field does not exist
           * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           * @since 9
           */
          public VarHandle findStaticVarHandle(Class&lt;?&gt; decl, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1687,20 +2426,20 @@</span>
           * @return the desired method handle
           * @throws NoSuchMethodException if the method does not exist
           * @throws IllegalAccessException if access checking fails
           *                                or if the method&#39;s variable arity modifier bit
           *                                is set and {@code asVarargsCollector} fails
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if any argument is null
           * @see MethodHandle#bindTo
           * @see #findVirtual
           */
          public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
              Class&lt;? extends Object&gt; refc = receiver.getClass(); // may get NPE
              MemberName method = resolveOrFail(REF_invokeSpecial, refc, name, type);
<span class="udiff-line-modified-removed">-             MethodHandle mh = getDirectMethodNoRestrictInvokeSpecial(refc, method, findBoundCallerClass(method));</span>
<span class="udiff-line-modified-added">+             MethodHandle mh = getDirectMethodNoRestrictInvokeSpecial(refc, method, findBoundCallerLookup(method));</span>
              if (!mh.type().leadingReferenceParameter().isAssignableFrom(receiver.getClass())) {
                  throw new IllegalAccessException(&quot;The restricted defining class &quot; +
                                                   mh.type().leadingReferenceParameter().getName() +
                                                   &quot; is not assignable from receiver class &quot; +
                                                   receiver.getClass().getName());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1748,11 +2487,11 @@</span>
              if (refKind == REF_invokeSpecial)
                  refKind = REF_invokeVirtual;
              assert(method.isMethod());
              @SuppressWarnings(&quot;deprecation&quot;)
              Lookup lookup = m.isAccessible() ? IMPL_LOOKUP : this;
<span class="udiff-line-modified-removed">-             return lookup.getDirectMethodNoSecurityManager(refKind, method.getDeclaringClass(), method, findBoundCallerClass(method));</span>
<span class="udiff-line-modified-added">+             return lookup.getDirectMethodNoSecurityManager(refKind, method.getDeclaringClass(), method, findBoundCallerLookup(method));</span>
          }
          private MethodHandle unreflectForMH(Method m) {
              // these names require special lookups because they throw UnsupportedOperationException
              if (MemberName.isMethodHandleInvokeName(m.getName()))
                  return MethodHandleImpl.fakeMethodHandleInvoke(new MemberName(m));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1794,16 +2533,16 @@</span>
           *                                or if the method&#39;s variable arity modifier bit
           *                                is set and {@code asVarargsCollector} fails
           * @throws NullPointerException if any argument is null
           */
          public MethodHandle unreflectSpecial(Method m, Class&lt;?&gt; specialCaller) throws IllegalAccessException {
<span class="udiff-line-modified-removed">-             checkSpecialCaller(specialCaller, null);</span>
<span class="udiff-line-modified-added">+             checkSpecialCaller(specialCaller, m.getDeclaringClass());</span>
              Lookup specialLookup = this.in(specialCaller);
              MemberName method = new MemberName(m, true);
              assert(method.isMethod());
              // ignore m.isAccessible:  this is a new kind of access
<span class="udiff-line-modified-removed">-             return specialLookup.getDirectMethodNoSecurityManager(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerClass(method));</span>
<span class="udiff-line-modified-added">+             return specialLookup.getDirectMethodNoSecurityManager(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerLookup(method));</span>
          }
  
          /**
           * Produces a method handle for a reflected constructor.
           * The type of the method handle will be that of the constructor,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1838,14 +2577,14 @@</span>
  
          /**
           * Produces a method handle giving read access to a reflected field.
           * The type of the method handle will have a return type of the field&#39;s
           * value type.
<span class="udiff-line-modified-removed">-          * If the field is static, the method handle will take no arguments.</span>
<span class="udiff-line-modified-added">+          * If the field is {@code static}, the method handle will take no arguments.</span>
           * Otherwise, its single argument will be the instance containing
           * the field.
<span class="udiff-line-modified-removed">-          * If the field&#39;s {@code accessible} flag is not set,</span>
<span class="udiff-line-modified-added">+          * If the {@code Field} object&#39;s {@code accessible} flag is not set,</span>
           * access checking is performed immediately on behalf of the lookup class.
           * &lt;p&gt;
           * If the field is static, and
           * if the returned method handle is invoked, the field&#39;s class will
           * be initialized, if it has not already been initialized.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1855,42 +2594,55 @@</span>
           * @throws NullPointerException if the argument is null
           */
          public MethodHandle unreflectGetter(Field f) throws IllegalAccessException {
              return unreflectField(f, false);
          }
<span class="udiff-line-removed">-         private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {</span>
<span class="udiff-line-removed">-             MemberName field = new MemberName(f, isSetter);</span>
<span class="udiff-line-removed">-             assert(isSetter</span>
<span class="udiff-line-removed">-                     ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())</span>
<span class="udiff-line-removed">-                     : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));</span>
<span class="udiff-line-removed">-             @SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="udiff-line-removed">-             Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;</span>
<span class="udiff-line-removed">-             return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);</span>
<span class="udiff-line-removed">-         }</span>
  
          /**
           * Produces a method handle giving write access to a reflected field.
           * The type of the method handle will have a void return type.
<span class="udiff-line-modified-removed">-          * If the field is static, the method handle will take a single</span>
<span class="udiff-line-modified-added">+          * If the field is {@code static}, the method handle will take a single</span>
           * argument, of the field&#39;s value type, the value to be stored.
           * Otherwise, the two arguments will be the instance containing
           * the field, and the value to be stored.
<span class="udiff-line-modified-removed">-          * If the field&#39;s {@code accessible} flag is not set,</span>
<span class="udiff-line-modified-added">+          * If the {@code Field} object&#39;s {@code accessible} flag is not set,</span>
           * access checking is performed immediately on behalf of the lookup class.
           * &lt;p&gt;
<span class="udiff-line-modified-removed">-          * If the field is static, and</span>
<span class="udiff-line-modified-added">+          * If the field is {@code final}, write access will not be</span>
<span class="udiff-line-added">+          * allowed and access checking will fail, except under certain</span>
<span class="udiff-line-added">+          * narrow circumstances documented for {@link Field#set Field.set}.</span>
<span class="udiff-line-added">+          * A method handle is returned only if a corresponding call to</span>
<span class="udiff-line-added">+          * the {@code Field} object&#39;s {@code set} method could return</span>
<span class="udiff-line-added">+          * normally.  In particular, fields which are both {@code static}</span>
<span class="udiff-line-added">+          * and {@code final} may never be set.</span>
<span class="udiff-line-added">+          * &lt;p&gt;</span>
<span class="udiff-line-added">+          * If the field is {@code static}, and</span>
           * if the returned method handle is invoked, the field&#39;s class will
           * be initialized, if it has not already been initialized.
           * @param f the reflected field
           * @return a method handle which can store values into the reflected field
<span class="udiff-line-modified-removed">-          * @throws IllegalAccessException if access checking fails</span>
<span class="udiff-line-modified-added">+          * @throws IllegalAccessException if access checking fails,</span>
<span class="udiff-line-added">+          *         or if the field is {@code final} and write access</span>
<span class="udiff-line-added">+          *         is not enabled on the {@code Field} object</span>
           * @throws NullPointerException if the argument is null
           */
          public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
              return unreflectField(f, true);
          }
  
<span class="udiff-line-added">+         private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {</span>
<span class="udiff-line-added">+             MemberName field = new MemberName(f, isSetter);</span>
<span class="udiff-line-added">+             if (isSetter &amp;&amp; field.isStatic() &amp;&amp; field.isFinal())</span>
<span class="udiff-line-added">+                 throw field.makeAccessException(&quot;static final field has no write access&quot;, this);</span>
<span class="udiff-line-added">+             assert(isSetter</span>
<span class="udiff-line-added">+                     ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())</span>
<span class="udiff-line-added">+                     : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));</span>
<span class="udiff-line-added">+             @SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="udiff-line-added">+             Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;</span>
<span class="udiff-line-added">+             return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          /**
           * Produces a VarHandle giving access to a reflected field {@code f}
           * of type {@code T} declared in a class of type {@code R}.
           * The VarHandle&#39;s variable type is {@code T}.
           * If the field is non-static the VarHandle has one coordinate type,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1976,14 +2728,14 @@</span>
           * but was created by an unrelated lookup object.
           * This can happen if the method handle is &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt;
           * and was created by a lookup object for a different class.
           * @param target a direct method handle to crack into symbolic reference components
           * @return a symbolic reference which can be used to reconstruct this method handle from this lookup object
<span class="udiff-line-modified-removed">-          * @exception SecurityException if a security manager is present and it</span>
<span class="udiff-line-modified-added">+          * @throws    SecurityException if a security manager is present and it</span>
           *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws IllegalArgumentException if the target is not a direct method handle or if access checking fails
<span class="udiff-line-modified-removed">-          * @exception NullPointerException if the target is {@code null}</span>
<span class="udiff-line-modified-added">+          * @throws    NullPointerException if the target is {@code null}</span>
           * @see MethodHandleInfo
           * @since 1.8
           */
          public MethodHandleInfo revealDirect(MethodHandle target) {
              MemberName member = target.internalMemberName();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2009,11 +2761,11 @@</span>
              } catch (IllegalAccessException ex) {
                  throw new IllegalArgumentException(ex);
              }
              if (allowedModes != TRUSTED &amp;&amp; member.isCallerSensitive()) {
                  Class&lt;?&gt; callerClass = target.internalCallerClass();
<span class="udiff-line-modified-removed">-                 if (!hasPrivateAccess() || callerClass != lookupClass())</span>
<span class="udiff-line-modified-added">+                 if (!hasFullPrivilegeAccess() || callerClass != lookupClass())</span>
                      throw new IllegalArgumentException(&quot;method handle is caller sensitive: &quot;+callerClass);
              }
              // Produce the handle to the results.
              return new InfoFromMemberName(this, member, refKind);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2062,11 +2814,11 @@</span>
          }
  
          boolean isClassAccessible(Class&lt;?&gt; refc) {
              Objects.requireNonNull(refc);
              Class&lt;?&gt; caller = lookupClassOrNull();
<span class="udiff-line-modified-removed">-             return caller == null || VerifyAccess.isClassAccessible(refc, caller, allowedModes);</span>
<span class="udiff-line-modified-added">+             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);</span>
          }
  
          /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
          void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
              if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2074,47 +2826,63 @@</span>
          }
  
  
          /**
           * Find my trustable caller class if m is a caller sensitive method.
<span class="udiff-line-modified-removed">-          * If this lookup object has private access, then the caller class is the lookupClass.</span>
<span class="udiff-line-modified-added">+          * If this lookup object has full privilege access, then the caller class is the lookupClass.</span>
           * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
           */
<span class="udiff-line-modified-removed">-         Class&lt;?&gt; findBoundCallerClass(MemberName m) throws IllegalAccessException {</span>
<span class="udiff-line-modified-removed">-             Class&lt;?&gt; callerClass = null;</span>
<span class="udiff-line-modified-removed">-             if (MethodHandleNatives.isCallerSensitive(m)) {</span>
<span class="udiff-line-modified-removed">-                 // Only lookups with private access are allowed to resolve caller-sensitive methods</span>
<span class="udiff-line-removed">-                 if (hasPrivateAccess()) {</span>
<span class="udiff-line-removed">-                     callerClass = lookupClass;</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {</span>
<span class="udiff-line-modified-added">+             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {</span>
<span class="udiff-line-modified-added">+                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods</span>
<span class="udiff-line-modified-added">+                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);</span>
              }
<span class="udiff-line-modified-removed">-             return callerClass;</span>
<span class="udiff-line-modified-added">+             return this;</span>
          }
  
          /**
<span class="udiff-line-modified-removed">-          * Returns {@code true} if this lookup has {@code PRIVATE} access.</span>
<span class="udiff-line-modified-removed">-          * @return {@code true} if this lookup has {@code PRIVATE} access.</span>
<span class="udiff-line-modified-added">+          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.</span>
<span class="udiff-line-modified-added">+          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @deprecated This method was originally designed to test {@code PRIVATE} access</span>
<span class="udiff-line-added">+          * that implies full privilege access but {@code MODULE} access has since become</span>
<span class="udiff-line-added">+          * independent of {@code PRIVATE} access.  It is recommended to call</span>
<span class="udiff-line-added">+          * {@link #hasFullPrivilegeAccess()} instead.</span>
           * @since 9
           */
<span class="udiff-line-added">+         @Deprecated(since=&quot;14&quot;)</span>
          public boolean hasPrivateAccess() {
<span class="udiff-line-modified-removed">-             return (allowedModes &amp; PRIVATE) != 0;</span>
<span class="udiff-line-modified-added">+             return hasFullPrivilegeAccess();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Returns {@code true} if this lookup has &lt;em&gt;full privilege access&lt;/em&gt;,</span>
<span class="udiff-line-added">+          * i.e. {@code PRIVATE} and {@code MODULE} access.</span>
<span class="udiff-line-added">+          * A {@code Lookup} object must have full privilege access in order to</span>
<span class="udiff-line-added">+          * access all members that are allowed to the {@linkplain #lookupClass() lookup class}.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @return {@code true} if this lookup has full privilege access.</span>
<span class="udiff-line-added">+          * @since 14</span>
<span class="udiff-line-added">+          * @see &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private and module access&lt;/a&gt;</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public boolean hasFullPrivilegeAccess() {</span>
<span class="udiff-line-added">+             return (allowedModes &amp; (PRIVATE|MODULE)) == (PRIVATE|MODULE);</span>
          }
  
          /**
           * Perform necessary &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;.
           * Determines a trustable caller class to compare with refc, the symbolic reference class.
<span class="udiff-line-modified-removed">-          * If this lookup object has private access, then the caller class is the lookupClass.</span>
<span class="udiff-line-modified-added">+          * If this lookup object has full privilege access, then the caller class is the lookupClass.</span>
           */
          void checkSecurityManager(Class&lt;?&gt; refc, MemberName m) {
<span class="udiff-line-added">+             if (allowedModes == TRUSTED)  return;</span>
<span class="udiff-line-added">+ </span>
              SecurityManager smgr = System.getSecurityManager();
              if (smgr == null)  return;
<span class="udiff-line-removed">-             if (allowedModes == TRUSTED)  return;</span>
  
              // Step 1:
<span class="udiff-line-modified-removed">-             boolean fullPowerLookup = hasPrivateAccess();</span>
<span class="udiff-line-modified-added">+             boolean fullPowerLookup = hasFullPrivilegeAccess();</span>
              if (!fullPowerLookup ||
                  !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
                  ReflectUtil.checkPackageAccess(refc);
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2199,11 +2967,11 @@</span>
                      MethodHandleNatives.refKindIsSetter(refKind))
                  throw m.makeAccessException(&quot;unexpected set of a final field&quot;, this);
              int requestedModes = fixmods(mods);  // adjust 0 =&gt; PACKAGE
              if ((requestedModes &amp; allowedModes) != 0) {
                  if (VerifyAccess.isMemberAccessible(refc, m.getDeclaringClass(),
<span class="udiff-line-modified-removed">-                                                     mods, lookupClass(), allowedModes))</span>
<span class="udiff-line-modified-added">+                                                     mods, lookupClass(), previousLookupClass(), allowedModes))</span>
                      return;
              } else {
                  // Protected members can also be checked as if they were package-private.
                  if ((requestedModes &amp; PROTECTED) != 0 &amp;&amp; (allowedModes &amp; PACKAGE) != 0
                          &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), lookupClass()))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2218,13 +2986,14 @@</span>
              // check the class first:
              boolean classOK = (Modifier.isPublic(defc.getModifiers()) &amp;&amp;
                                 (defc == refc ||
                                  Modifier.isPublic(refc.getModifiers())));
              if (!classOK &amp;&amp; (allowedModes &amp; PACKAGE) != 0) {
<span class="udiff-line-modified-removed">-                 classOK = (VerifyAccess.isClassAccessible(defc, lookupClass(), FULL_POWER_MODES) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 // ignore previous lookup class to check if default package access</span>
<span class="udiff-line-added">+                 classOK = (VerifyAccess.isClassAccessible(defc, lookupClass(), null, FULL_POWER_MODES) &amp;&amp;</span>
                             (defc == refc ||
<span class="udiff-line-modified-removed">-                             VerifyAccess.isClassAccessible(refc, lookupClass(), FULL_POWER_MODES)));</span>
<span class="udiff-line-modified-added">+                             VerifyAccess.isClassAccessible(refc, lookupClass(), null, FULL_POWER_MODES)));</span>
              }
              if (!classOK)
                  return &quot;class is not public&quot;;
              if (Modifier.isPublic(mods))
                  return &quot;access to public member failed&quot;;  // (how?, module not readable?)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2236,11 +3005,11 @@</span>
          }
  
          private void checkSpecialCaller(Class&lt;?&gt; specialCaller, Class&lt;?&gt; refc) throws IllegalAccessException {
              int allowedModes = this.allowedModes;
              if (allowedModes == TRUSTED)  return;
<span class="udiff-line-modified-removed">-             if (!hasPrivateAccess()</span>
<span class="udiff-line-modified-added">+             if ((lookupModes() &amp; PRIVATE) == 0</span>
                  || (specialCaller != lookupClass()
                         // ensure non-abstract methods in superinterfaces can be special-invoked
                      &amp;&amp; !(refc != null &amp;&amp; refc.isInterface() &amp;&amp; refc.isAssignableFrom(specialCaller))))
                  throw new MemberName(specialCaller).
                      makeAccessException(&quot;no private access for invokespecial&quot;, this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2269,32 +3038,32 @@</span>
              assert(mh.viewAsTypeChecks(narrowType, true));
              return mh.copyWith(narrowType, mh.form);
          }
  
          /** Check access and get the requested method. */
<span class="udiff-line-modified-removed">-         private MethodHandle getDirectMethod(byte refKind, Class&lt;?&gt; refc, MemberName method, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</span>
<span class="udiff-line-modified-added">+         private MethodHandle getDirectMethod(byte refKind, Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {</span>
              final boolean doRestrict    = true;
              final boolean checkSecurity = true;
<span class="udiff-line-modified-removed">-             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, boundCallerClass);</span>
<span class="udiff-line-modified-added">+             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);</span>
          }
          /** Check access and get the requested method, for invokespecial with no restriction on the application of narrowing rules. */
<span class="udiff-line-modified-removed">-         private MethodHandle getDirectMethodNoRestrictInvokeSpecial(Class&lt;?&gt; refc, MemberName method, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</span>
<span class="udiff-line-modified-added">+         private MethodHandle getDirectMethodNoRestrictInvokeSpecial(Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {</span>
              final boolean doRestrict    = false;
              final boolean checkSecurity = true;
<span class="udiff-line-modified-removed">-             return getDirectMethodCommon(REF_invokeSpecial, refc, method, checkSecurity, doRestrict, boundCallerClass);</span>
<span class="udiff-line-modified-added">+             return getDirectMethodCommon(REF_invokeSpecial, refc, method, checkSecurity, doRestrict, callerLookup);</span>
          }
          /** Check access and get the requested method, eliding security manager checks. */
<span class="udiff-line-modified-removed">-         private MethodHandle getDirectMethodNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName method, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</span>
<span class="udiff-line-modified-added">+         private MethodHandle getDirectMethodNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {</span>
              final boolean doRestrict    = true;
              final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
<span class="udiff-line-modified-removed">-             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, boundCallerClass);</span>
<span class="udiff-line-modified-added">+             return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);</span>
          }
          /** Common code for all methods; do not call directly except from immediately above. */
          private MethodHandle getDirectMethodCommon(byte refKind, Class&lt;?&gt; refc, MemberName method,
                                                     boolean checkSecurity,
<span class="udiff-line-modified-removed">-                                                    boolean doRestrict, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+                                                    boolean doRestrict,</span>
<span class="udiff-line-modified-added">+                                                    Lookup boundCaller) throws IllegalAccessException {</span>
              checkMethod(refKind, refc, method);
              // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
              if (checkSecurity)
                  checkSecurityManager(refc, method);
              assert(!method.isMethodHandleInvoke());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2328,34 +3097,36 @@</span>
                  method = m2;
                  refc = refcAsSuper;
                  // redo basic checks
                  checkMethod(refKind, refc, method);
              }
<span class="udiff-line-removed">- </span>
              DirectMethodHandle dmh = DirectMethodHandle.make(refKind, refc, method, lookupClass());
              MethodHandle mh = dmh;
              // Optionally narrow the receiver argument to lookupClass using restrictReceiver.
              if ((doRestrict &amp;&amp; refKind == REF_invokeSpecial) ||
                      (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp; restrictProtectedReceiver(method))) {
                  mh = restrictReceiver(method, dmh, lookupClass());
              }
<span class="udiff-line-modified-removed">-             mh = maybeBindCaller(method, mh, boundCallerClass);</span>
<span class="udiff-line-modified-added">+             mh = maybeBindCaller(method, mh, boundCaller);</span>
              mh = mh.setVarargs(method);
              return mh;
          }
<span class="udiff-line-modified-removed">-         private MethodHandle maybeBindCaller(MemberName method, MethodHandle mh,</span>
<span class="udiff-line-removed">-                                              Class&lt;?&gt; boundCallerClass)</span>
<span class="udiff-line-modified-added">+         private MethodHandle maybeBindCaller(MemberName method, MethodHandle mh, Lookup boundCaller)</span>
                                               throws IllegalAccessException {
<span class="udiff-line-modified-removed">-             if (allowedModes == TRUSTED || !MethodHandleNatives.isCallerSensitive(method))</span>
<span class="udiff-line-modified-added">+             if (boundCaller.allowedModes == TRUSTED || !MethodHandleNatives.isCallerSensitive(method))</span>
                  return mh;
<span class="udiff-line-modified-removed">-             Class&lt;?&gt; hostClass = lookupClass;</span>
<span class="udiff-line-modified-removed">-             if (!hasPrivateAccess())  // caller must have private access</span>
<span class="udiff-line-modified-removed">-                 hostClass = boundCallerClass;  // boundCallerClass came from a security manager style stack walk</span>
<span class="udiff-line-modified-removed">-             MethodHandle cbmh = MethodHandleImpl.bindCaller(mh, hostClass);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             // boundCaller must have full privilege access.</span>
<span class="udiff-line-modified-added">+             // It should have been checked by findBoundCallerLookup. Safe to check this again.</span>
<span class="udiff-line-modified-added">+             if (!boundCaller.hasFullPrivilegeAccess())</span>
<span class="udiff-line-added">+                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             MethodHandle cbmh = MethodHandleImpl.bindCaller(mh, boundCaller.lookupClass);</span>
              // Note: caller will apply varargs after this step happens.
              return cbmh;
          }
<span class="udiff-line-added">+ </span>
          /** Check access and get the requested field. */
          private MethodHandle getDirectField(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
              final boolean checkSecurity = true;
              return getDirectFieldCommon(refKind, refc, field, checkSecurity);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2447,11 +3218,12 @@</span>
          }
  
          /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
           */
          /*non-public*/
<span class="udiff-line-modified-removed">-         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type) throws ReflectiveOperationException {</span>
<span class="udiff-line-modified-added">+         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)</span>
<span class="udiff-line-added">+                 throws ReflectiveOperationException {</span>
              if (!(type instanceof Class || type instanceof MethodType))
                  throw new InternalError(&quot;unresolved MemberName&quot;);
              MemberName member = new MemberName(refKind, defc, name, type);
              MethodHandle mh = LOOKASIDE_TABLE.get(member);
              if (mh != null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2483,12 +3255,11 @@</span>
                      LOOKASIDE_TABLE.put(key, (DirectMethodHandle) mh);
                  }
              }
              return mh;
          }
<span class="udiff-line-modified-removed">-         private</span>
<span class="udiff-line-removed">-         boolean canBeCached(byte refKind, Class&lt;?&gt; defc, MemberName member) {</span>
<span class="udiff-line-modified-added">+         private boolean canBeCached(byte refKind, Class&lt;?&gt; defc, MemberName member) {</span>
              if (refKind == REF_invokeSpecial) {
                  return false;
              }
              if (!Modifier.isPublic(defc.getModifiers()) ||
                      !Modifier.isPublic(member.getDeclaringClass().getModifiers()) ||
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2518,17 +3289,16 @@</span>
              } catch (SecurityException ex) {
                  return false;
              }
              return true;
          }
<span class="udiff-line-modified-removed">-         private</span>
<span class="udiff-line-removed">-         MethodHandle getDirectMethodForConstant(byte refKind, Class&lt;?&gt; defc, MemberName member)</span>
<span class="udiff-line-modified-added">+         private MethodHandle getDirectMethodForConstant(byte refKind, Class&lt;?&gt; defc, MemberName member)</span>
                  throws ReflectiveOperationException {
              if (MethodHandleNatives.refKindIsField(refKind)) {
                  return getDirectFieldNoSecurityManager(refKind, defc, member);
              } else if (MethodHandleNatives.refKindIsMethod(refKind)) {
<span class="udiff-line-modified-removed">-                 return getDirectMethodNoSecurityManager(refKind, defc, member, lookupClass);</span>
<span class="udiff-line-modified-added">+                 return getDirectMethodNoSecurityManager(refKind, defc, member, findBoundCallerLookup(member));</span>
              } else if (refKind == REF_newInvokeSpecial) {
                  return getDirectConstructorNoSecurityManager(defc, member);
              }
              // oops
              throw newIllegalArgumentException(&quot;bad MethodHandle constant #&quot;+member);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2552,12 +3322,11 @@</span>
       * @throws IllegalArgumentException if {@code arrayClass} is not an array type
       * @see java.lang.reflect.Array#newInstance(Class, int)
       * @jvms 6.5 {@code anewarray} Instruction
       * @since 9
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle arrayConstructor(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle arrayConstructor(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
          if (!arrayClass.isArray()) {
              throw newIllegalArgumentException(&quot;not an array class: &quot; + arrayClass.getName());
          }
          MethodHandle ani = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).
                  bindTo(arrayClass.getComponentType());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2578,12 +3347,11 @@</span>
       * @throws NullPointerException if the argument is {@code null}
       * @throws IllegalArgumentException if arrayClass is not an array type
       * @jvms 6.5 {@code arraylength} Instruction
       * @since 9
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle arrayLength(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle arrayLength(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
          return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.LENGTH);
      }
  
      /**
       * Produces a method handle giving read access to elements of an array,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2603,12 +3371,11 @@</span>
       * @return a method handle which can load values from the given array type
       * @throws NullPointerException if the argument is null
       * @throws  IllegalArgumentException if arrayClass is not an array type
       * @jvms 6.5 {@code aaload} Instruction
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle arrayElementGetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle arrayElementGetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
          return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.GET);
      }
  
      /**
       * Produces a method handle giving write access to elements of an array,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2628,12 +3395,11 @@</span>
       * @return a method handle which can store values into the array type
       * @throws NullPointerException if the argument is null
       * @throws IllegalArgumentException if arrayClass is not an array type
       * @jvms 6.5 {@code aastore} Instruction
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
          return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
      }
  
      /**
       * Produces a VarHandle giving access to elements of an array of type
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2693,12 +3459,11 @@</span>
       * @return a VarHandle giving access to elements of an array
       * @throws NullPointerException if the arrayClass is null
       * @throws IllegalArgumentException if arrayClass is not an array type
       * @since 9
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     VarHandle arrayElementVarHandle(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
<span class="udiff-line-modified-added">+     public static VarHandle arrayElementVarHandle(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {</span>
          return VarHandles.makeArrayElementHandle(arrayClass);
      }
  
      /**
       * Produces a VarHandle giving access to elements of a {@code byte[]} array
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2774,12 +3539,11 @@</span>
       * @throws IllegalArgumentException if viewArrayClass is not an array type
       * @throws UnsupportedOperationException if the component type of
       * viewArrayClass is not supported as a variable type
       * @since 9
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     VarHandle byteArrayViewVarHandle(Class&lt;?&gt; viewArrayClass,</span>
<span class="udiff-line-modified-added">+     public static VarHandle byteArrayViewVarHandle(Class&lt;?&gt; viewArrayClass,</span>
                                       ByteOrder byteOrder) throws IllegalArgumentException {
          Objects.requireNonNull(byteOrder);
          return VarHandles.byteArrayViewHandle(viewArrayClass,
                                                byteOrder == ByteOrder.BIG_ENDIAN);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2862,12 +3626,11 @@</span>
       * @throws IllegalArgumentException if viewArrayClass is not an array type
       * @throws UnsupportedOperationException if the component type of
       * viewArrayClass is not supported as a variable type
       * @since 9
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     VarHandle byteBufferViewVarHandle(Class&lt;?&gt; viewArrayClass,</span>
<span class="udiff-line-modified-added">+     public static VarHandle byteBufferViewVarHandle(Class&lt;?&gt; viewArrayClass,</span>
                                        ByteOrder byteOrder) throws IllegalArgumentException {
          Objects.requireNonNull(byteOrder);
          return VarHandles.makeByteBufferViewHandle(viewArrayClass,
                                                     byteOrder == ByteOrder.BIG_ENDIAN);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2919,12 +3682,11 @@</span>
       * @throws IllegalArgumentException if {@code leadingArgCount} is not in
       *                  the range from 0 to {@code type.parameterCount()} inclusive,
       *                  or if the resulting method handle&#39;s type would have
       *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {</span>
          if (leadingArgCount &lt; 0 || leadingArgCount &gt; type.parameterCount())
              throw newIllegalArgumentException(&quot;bad argument count&quot;, leadingArgCount);
          type = type.asSpreaderType(Object[].class, leadingArgCount, type.parameterCount() - leadingArgCount);
          return type.invokers().spreadInvoker(leadingArgCount);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2962,12 +3724,11 @@</span>
       * @param type the desired target type
       * @return a method handle suitable for invoking any method handle of the given type
       * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
       *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle exactInvoker(MethodType type) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle exactInvoker(MethodType type) {</span>
          return type.invokers().exactInvoker();
      }
  
      /**
       * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3001,12 +3762,11 @@</span>
       * @param type the desired target type
       * @return a method handle suitable for invoking any method handle convertible to the given type
       * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
       *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle invoker(MethodType type) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle invoker(MethodType type) {</span>
          return type.invokers().genericInvoker();
      }
  
      /**
       * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3020,12 +3780,11 @@</span>
       * @param type the desired target type
       * @return a method handle suitable for invoking an access mode method of
       *         any VarHandle whose access mode type is of the given type.
       * @since 9
       */
<span class="udiff-line-modified-removed">-     static public</span>
<span class="udiff-line-removed">-     MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {</span>
          return type.invokers().varHandleMethodExactInvoker(accessMode);
      }
  
      /**
       * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3049,17 +3808,16 @@</span>
       * @return a method handle suitable for invoking an access mode method of
       *         any VarHandle whose access mode type is convertible to the given
       *         type.
       * @since 9
       */
<span class="udiff-line-modified-removed">-     static public</span>
<span class="udiff-line-removed">-     MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type) {</span>
          return type.invokers().varHandleMethodInvoker(accessMode);
      }
  
<span class="udiff-line-modified-removed">-     static /*non-public*/</span>
<span class="udiff-line-modified-removed">-     MethodHandle basicInvoker(MethodType type) {</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-modified-added">+     static MethodHandle basicInvoker(MethodType type) {</span>
          return type.invokers().basicInvoker();
      }
  
       /// method handle modification (creation from other method handles)
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3105,12 +3863,11 @@</span>
       *           necessary return value conversions
       * @throws NullPointerException if either argument is null
       * @throws WrongMethodTypeException if the conversion cannot be made
       * @see MethodHandle#asType
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {</span>
          explicitCastArgumentsChecks(target, newType);
          // use the asTypeCache when possible:
          MethodType oldType = target.type();
          if (oldType == newType)  return target;
          if (oldType.explicitCastEquivalentToAsType(newType)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3185,12 +3942,11 @@</span>
       *                  the arity of the target, or if any index array element
       *                  not a valid index for a parameter of {@code newType},
       *                  or if two corresponding parameter types in
       *                  {@code target.type()} and {@code newType} are not identical,
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {</span>
          reorder = reorder.clone();  // get a private copy
          MethodType oldType = target.type();
          permuteArgumentChecks(reorder, newType, oldType);
          // first detect dropped arguments and handle them separately
          int[] originalReorder = reorder;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3345,12 +4101,11 @@</span>
       * @return a method handle of the given return type and no arguments, which always returns the given value
       * @throws NullPointerException if the {@code type} argument is null
       * @throws ClassCastException if the value cannot be converted to the required return type
       * @throws IllegalArgumentException if the given type is {@code void.class}
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle constant(Class&lt;?&gt; type, Object value) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle constant(Class&lt;?&gt; type, Object value) {</span>
          if (type.isPrimitive()) {
              if (type == void.class)
                  throw newIllegalArgumentException(&quot;void type&quot;);
              Wrapper w = Wrapper.forPrimitiveType(type);
              value = w.convert(value, type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3369,12 +4124,11 @@</span>
       * @param type the type of the sole parameter and return value of the desired method handle
       * @return a unary method handle which accepts and returns the given type
       * @throws NullPointerException if the argument is null
       * @throws IllegalArgumentException if the given type is {@code void.class}
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle identity(Class&lt;?&gt; type) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle identity(Class&lt;?&gt; type) {</span>
          Wrapper btw = (type.isPrimitive() ? Wrapper.forPrimitiveType(type) : Wrapper.OBJECT);
          int pos = btw.ordinal();
          MethodHandle ident = IDENTITY_MHS[pos];
          if (ident == null) {
              ident = setCachedMethodHandle(IDENTITY_MHS, pos, makeIdentity(btw.primitiveType()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3500,12 +4254,11 @@</span>
       *         is the length of the values array.
       * @throws ClassCastException if an argument does not match the corresponding bound parameter
       *         type.
       * @see MethodHandle#bindTo
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle insertArguments(MethodHandle target, int pos, Object... values) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle insertArguments(MethodHandle target, int pos, Object... values) {</span>
          int insCount = values.length;
          Class&lt;?&gt;[] ptypes = insertArgumentsChecks(target, insCount, pos);
          if (insCount == 0)  return target;
          BoundMethodHandle result = target.rebind();
          for (int i = 0; i &lt; insCount; i++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3576,31 +4329,29 @@</span>
       * This method is also equivalent to the following code:
       * &lt;blockquote&gt;&lt;pre&gt;
       * {@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}
       * &lt;/pre&gt;&lt;/blockquote&gt;
       * @param target the method handle to invoke after the arguments are dropped
<span class="udiff-line-removed">-      * @param valueTypes the type(s) of the argument(s) to drop</span>
       * @param pos position of first argument to drop (zero for the leftmost)
<span class="udiff-line-added">+      * @param valueTypes the type(s) of the argument(s) to drop</span>
       * @return a method handle which drops arguments of the given types,
       *         before calling the original method handle
       * @throws NullPointerException if the target is null,
       *                              or if the {@code valueTypes} list or any of its elements is null
       * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
       *                  or if {@code pos} is negative or greater than the arity of the target,
       *                  or if the new method handle&#39;s type would have too many parameters
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle dropArguments(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle dropArguments(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {</span>
          return dropArguments0(target, pos, copyTypes(valueTypes.toArray()));
      }
  
      private static List&lt;Class&lt;?&gt;&gt; copyTypes(Object[] array) {
          return Arrays.asList(Arrays.copyOf(array, array.length, Class[].class));
      }
  
<span class="udiff-line-modified-removed">-     private static</span>
<span class="udiff-line-removed">-     MethodHandle dropArguments0(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {</span>
<span class="udiff-line-modified-added">+     private static MethodHandle dropArguments0(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {</span>
          MethodType oldType = target.type();  // get NPE
          int dropped = dropArgumentChecks(oldType, pos, valueTypes);
          MethodType newType = oldType.insertParameterTypes(pos, valueTypes);
          if (dropped == 0)  return target;
          BoundMethodHandle result = target.rebind();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3658,23 +4409,22 @@</span>
       * This method is also equivalent to the following code:
       * &lt;blockquote&gt;&lt;pre&gt;
       * {@link #dropArguments(MethodHandle,int,List) dropArguments}{@code (target, pos, Arrays.asList(valueTypes))}
       * &lt;/pre&gt;&lt;/blockquote&gt;
       * @param target the method handle to invoke after the arguments are dropped
<span class="udiff-line-removed">-      * @param valueTypes the type(s) of the argument(s) to drop</span>
       * @param pos position of first argument to drop (zero for the leftmost)
<span class="udiff-line-added">+      * @param valueTypes the type(s) of the argument(s) to drop</span>
       * @return a method handle which drops arguments of the given types,
       *         before calling the original method handle
       * @throws NullPointerException if the target is null,
       *                              or if the {@code valueTypes} array or any of its elements is null
       * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
       *                  or if {@code pos} is negative or greater than the arity of the target,
       *                  or if the new method handle&#39;s type would have
       *                  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle dropArguments(MethodHandle target, int pos, Class&lt;?&gt;... valueTypes) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle dropArguments(MethodHandle target, int pos, Class&lt;?&gt;... valueTypes) {</span>
          return dropArguments0(target, pos, copyTypes(valueTypes));
      }
  
      // private version which allows caller some freedom with error handling
      private static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3776,12 +4526,11 @@</span>
       *         or if {@code pos} is negative or greater than the newTypes list size,
       *         or if {@code newTypes} does not contain the {@code target}&#39;s non-skipped parameter types at position
       *         {@code pos}.
       * @since 9
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos) {</span>
          Objects.requireNonNull(target);
          Objects.requireNonNull(newTypes);
          return dropArgumentsToMatch(target, skip, newTypes, pos, false);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3860,12 +4609,11 @@</span>
       *          does not match a corresponding argument type of target as described above,
       *          or if the {@code pos+filters.length} is greater than {@code target.type().parameterCount()},
       *          or if the resulting method handle&#39;s type would have
       *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) {</span>
          // In method types arguments start at index 0, while the LF
          // editor have the MH receiver at position 0 - adjust appropriately.
          final int MH_RECEIVER_OFFSET = 1;
          filterArgumentsCheckArity(target, pos, filters);
          MethodHandle adapter = target;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3919,12 +4667,12 @@</span>
  
          LambdaForm lform = result.editor().filterRepeatedArgumentForm(BasicType.basicType(newParamType), positions);
          return result.copyWithExtendL(newType, lform, filter);
      }
  
<span class="udiff-line-modified-removed">-     /*non-public*/ static</span>
<span class="udiff-line-modified-removed">-     MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle filter) {</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-modified-added">+     static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle filter) {</span>
          filterArgumentChecks(target, pos, filter);
          MethodType targetType = target.type();
          MethodType filterType = filter.type();
          BoundMethodHandle result = target.rebind();
          Class&lt;?&gt; newParamType = filterType.parameterType(0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4066,12 +4814,11 @@</span>
       *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
       * @see MethodHandles#foldArguments
       * @see MethodHandles#filterArguments
       * @see MethodHandles#filterReturnValue
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle collectArguments(MethodHandle target, int pos, MethodHandle filter) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle collectArguments(MethodHandle target, int pos, MethodHandle filter) {</span>
          MethodType newType = collectArgumentsChecks(target, pos, filter);
          MethodType collectorType = filter.type();
          BoundMethodHandle result = target.rebind();
          LambdaForm lform;
          if (collectorType.returnType().isArray() &amp;&amp; filter.intrinsicName() == Intrinsic.NEW_ARRAY) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4160,12 +4907,11 @@</span>
       * @return method handle which incorporates the specified return value filtering logic
       * @throws NullPointerException if either argument is null
       * @throws IllegalArgumentException if the argument list of {@code filter}
       *          does not match the return type of target as described above
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter) {</span>
          MethodType targetType = target.type();
          MethodType filterType = filter.type();
          filterReturnValueChecks(targetType, filterType);
          BoundMethodHandle result = target.rebind();
          BasicType rtype = BasicType.basicType(filterType.returnType());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4269,12 +5015,11 @@</span>
       *          the target, or if the initial {@code N} argument types
       *          of the target
       *          (skipping one matching the {@code combiner}&#39;s return type)
       *          are not identical with the argument types of {@code combiner}
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle foldArguments(MethodHandle target, MethodHandle combiner) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle foldArguments(MethodHandle target, MethodHandle combiner) {</span>
          return foldArguments(target, 0, combiner);
      }
  
      /**
       * Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4397,11 +5142,12 @@</span>
       *          (1) {@code combiner}&#39;s return type is not the same as the argument type at position
       *              {@code pos} of the target signature;
       *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature are
       *              not identical with the argument types of {@code combiner}.
       */
<span class="udiff-line-modified-removed">-     /*non-public*/ static MethodHandle filterArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     static MethodHandle filterArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {</span>
          return argumentsWithCombiner(true, target, position, combiner, argPositions);
      }
  
      /**
       * Adapts a target method handle by pre-processing some of its arguments, calling the target with the result of
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4419,11 +5165,12 @@</span>
       *              {@code pos} of the target signature;
       *          (2) the {@code N} argument types at positions {@code argPositions[1...N]} of the target signature
       *              (skipping {@code position} where the {@code combiner}&#39;s return will be folded in) are not identical
       *              with the argument types of {@code combiner}.
       */
<span class="udiff-line-modified-removed">-     /*non-public*/ static MethodHandle foldArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     static MethodHandle foldArgumentsWithCombiner(MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {</span>
          return argumentsWithCombiner(false, target, position, combiner, argPositions);
      }
  
      private static MethodHandle argumentsWithCombiner(boolean filter, MethodHandle target, int position, MethodHandle combiner, int ... argPositions) {
          MethodType targetType = target.type();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4506,12 +5253,11 @@</span>
       * @throws NullPointerException if any argument is null
       * @throws IllegalArgumentException if {@code test} does not return boolean,
       *          or if all three method types do not match (with the return
       *          type of {@code test} changed to match that of the target).
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle guardWithTest(MethodHandle test,</span>
<span class="udiff-line-modified-added">+     public static MethodHandle guardWithTest(MethodHandle test,</span>
                                 MethodHandle target,
                                 MethodHandle fallback) {
          MethodType gtype = test.type();
          MethodType ttype = target.type();
          MethodType ftype = fallback.type();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4579,12 +5325,11 @@</span>
       *          the given exception type, or if the method handle types do
       *          not match in their return types and their
       *          corresponding parameters
       * @see MethodHandles#tryFinally(MethodHandle, MethodHandle)
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle catchException(MethodHandle target,</span>
<span class="udiff-line-modified-added">+     public static MethodHandle catchException(MethodHandle target,</span>
                                  Class&lt;? extends Throwable&gt; exType,
                                  MethodHandle handler) {
          MethodType ttype = target.type();
          MethodType htype = handler.type();
          if (!Throwable.class.isAssignableFrom(exType))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4611,12 +5356,11 @@</span>
       * @param returnType the return type of the desired method handle
       * @param exType the parameter type of the desired method handle
       * @return method handle which can throw the given exceptions
       * @throws NullPointerException if either argument is null
       */
<span class="udiff-line-modified-removed">-     public static</span>
<span class="udiff-line-removed">-     MethodHandle throwException(Class&lt;?&gt; returnType, Class&lt;? extends Throwable&gt; exType) {</span>
<span class="udiff-line-modified-added">+     public static MethodHandle throwException(Class&lt;?&gt; returnType, Class&lt;? extends Throwable&gt; exType) {</span>
          if (!Throwable.class.isAssignableFrom(exType))
              throw new ClassCastException(exType.getName());
          return MethodHandleImpl.throwException(methodType(returnType, exType));
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4959,12 +5703,14 @@</span>
          final List&lt;Class&lt;?&gt;&gt; commonSuffix = buildCommonSuffix(init, step, pred, fini, commonPrefix.size());
          loopChecks1b(init, commonSuffix);
  
          // Step 1C: determine loop return type.
          // Step 1D: check other types.
<span class="udiff-line-modified-removed">-         final Class&lt;?&gt; loopReturnType = fini.stream().filter(Objects::nonNull).map(MethodHandle::type).</span>
<span class="udiff-line-modified-removed">-                 map(MethodType::returnType).findFirst().orElse(void.class);</span>
<span class="udiff-line-modified-added">+         // local variable required here; see JDK-8223553</span>
<span class="udiff-line-modified-added">+         Stream&lt;Class&lt;?&gt;&gt; cstream = fini.stream().filter(Objects::nonNull).map(MethodHandle::type)</span>
<span class="udiff-line-added">+                 .map(MethodType::returnType);</span>
<span class="udiff-line-added">+         final Class&lt;?&gt; loopReturnType = cstream.findFirst().orElse(void.class);</span>
          loopChecks1cd(pred, fini, loopReturnType);
  
          // Step 2: determine parameter lists.
          final List&lt;Class&lt;?&gt;&gt; commonParameterSequence = new ArrayList&lt;&gt;(commonPrefix);
          commonParameterSequence.addAll(commonSuffix);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5918,11 +6664,12 @@</span>
              }
          }
          return iterableType;  // help the caller a bit
      }
  
<span class="udiff-line-modified-removed">-     /*non-public*/ static MethodHandle swapArguments(MethodHandle mh, int i, int j) {</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     static MethodHandle swapArguments(MethodHandle mh, int i, int j) {</span>
          // there should be a better way to uncross my wires
          int arity = mh.type().parameterCount();
          int[] order = new int[arity];
          for (int k = 0; k &lt; arity; k++)  order[k] = k;
          order[i] = j; order[j] = i;
</pre>
<center><a href="MethodHandleStatics.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodType.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
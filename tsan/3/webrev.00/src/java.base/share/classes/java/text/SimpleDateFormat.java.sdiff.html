<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/SimpleDateFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="RuleBasedCollator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringCharacterIterator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/SimpleDateFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  41 import java.io.IOException;
  42 import java.io.InvalidObjectException;
  43 import java.io.ObjectInputStream;
  44 import static java.text.DateFormatSymbols.*;
  45 import java.util.Calendar;
  46 import java.util.Date;
  47 import java.util.GregorianCalendar;
  48 import java.util.Locale;
  49 import java.util.Map;
  50 import java.util.SimpleTimeZone;
  51 import java.util.SortedMap;
  52 import java.util.TimeZone;
  53 import java.util.concurrent.ConcurrentHashMap;
  54 import java.util.concurrent.ConcurrentMap;
  55 import sun.util.calendar.CalendarUtils;
  56 import sun.util.calendar.ZoneInfoFile;
  57 import sun.util.locale.provider.LocaleProviderAdapter;
  58 import sun.util.locale.provider.TimeZoneNameUtility;
  59 
  60 /**
<span class="line-modified">  61  * &lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and</span>
  62  * parsing dates in a locale-sensitive manner. It allows for formatting
  63  * (date &amp;rarr; text), parsing (text &amp;rarr; date), and normalization.
  64  *
  65  * &lt;p&gt;
<span class="line-modified">  66  * &lt;code&gt;SimpleDateFormat&lt;/code&gt; allows you to start by choosing</span>
  67  * any user-defined patterns for date-time formatting. However, you
  68  * are encouraged to create a date-time formatter with either
<span class="line-modified">  69  * &lt;code&gt;getTimeInstance&lt;/code&gt;, &lt;code&gt;getDateInstance&lt;/code&gt;, or</span>
<span class="line-modified">  70  * &lt;code&gt;getDateTimeInstance&lt;/code&gt; in &lt;code&gt;DateFormat&lt;/code&gt;. Each</span>
  71  * of these class methods can return a date/time formatter initialized
  72  * with a default format pattern. You may modify the format pattern
<span class="line-modified">  73  * using the &lt;code&gt;applyPattern&lt;/code&gt; methods as desired.</span>
  74  * For more information on using these methods, see
  75  * {@link DateFormat}.
  76  *
<span class="line-modified">  77  * &lt;h3&gt;Date and Time Patterns&lt;/h3&gt;</span>
  78  * &lt;p&gt;
  79  * Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt;
  80  * strings.
  81  * Within date and time pattern strings, unquoted letters from
<span class="line-modified">  82  * &lt;code&gt;&#39;A&#39;&lt;/code&gt; to &lt;code&gt;&#39;Z&#39;&lt;/code&gt; and from &lt;code&gt;&#39;a&#39;&lt;/code&gt; to</span>
<span class="line-modified">  83  * &lt;code&gt;&#39;z&#39;&lt;/code&gt; are interpreted as pattern letters representing the</span>
  84  * components of a date or time string.
<span class="line-modified">  85  * Text can be quoted using single quotes (&lt;code&gt;&#39;&lt;/code&gt;) to avoid</span>
  86  * interpretation.
<span class="line-modified">  87  * &lt;code&gt;&quot;&#39;&#39;&quot;&lt;/code&gt; represents a single quote.</span>
  88  * All other characters are not interpreted; they&#39;re simply copied into the
  89  * output string during formatting or matched against the input string
  90  * during parsing.
  91  * &lt;p&gt;
  92  * The following pattern letters are defined (all other characters from
<span class="line-modified">  93  * &lt;code&gt;&#39;A&#39;&lt;/code&gt; to &lt;code&gt;&#39;Z&#39;&lt;/code&gt; and from &lt;code&gt;&#39;a&#39;&lt;/code&gt; to</span>
<span class="line-modified">  94  * &lt;code&gt;&#39;z&#39;&lt;/code&gt; are reserved):</span>
  95  * &lt;blockquote&gt;
  96  * &lt;table class=&quot;striped&quot;&gt;
  97  * &lt;caption style=&quot;display:none&quot;&gt;Chart shows pattern letters, date/time component, presentation, and examples.&lt;/caption&gt;
  98  * &lt;thead&gt;
  99  *     &lt;tr&gt;
 100  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Letter
 101  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Date or Time Component
 102  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Presentation
 103  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Examples
 104  * &lt;/thead&gt;
 105  * &lt;tbody&gt;
 106  *     &lt;tr&gt;
<span class="line-modified"> 107  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;G&lt;/code&gt;</span>
 108  *         &lt;td&gt;Era designator
 109  *         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
<span class="line-modified"> 110  *         &lt;td&gt;&lt;code&gt;AD&lt;/code&gt;</span>
 111  *     &lt;tr&gt;
<span class="line-modified"> 112  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;y&lt;/code&gt;</span>
 113  *         &lt;td&gt;Year
 114  *         &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
<span class="line-modified"> 115  *         &lt;td&gt;&lt;code&gt;1996&lt;/code&gt;; &lt;code&gt;96&lt;/code&gt;</span>
 116  *     &lt;tr&gt;
<span class="line-modified"> 117  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;Y&lt;/code&gt;</span>
 118  *         &lt;td&gt;Week year
 119  *         &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
<span class="line-modified"> 120  *         &lt;td&gt;&lt;code&gt;2009&lt;/code&gt;; &lt;code&gt;09&lt;/code&gt;</span>
 121  *     &lt;tr&gt;
<span class="line-modified"> 122  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;M&lt;/code&gt;</span>
 123  *         &lt;td&gt;Month in year (context sensitive)
 124  *         &lt;td&gt;&lt;a href=&quot;#month&quot;&gt;Month&lt;/a&gt;
<span class="line-modified"> 125  *         &lt;td&gt;&lt;code&gt;July&lt;/code&gt;; &lt;code&gt;Jul&lt;/code&gt;; &lt;code&gt;07&lt;/code&gt;</span>
 126  *     &lt;tr&gt;
<span class="line-modified"> 127  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;L&lt;/code&gt;</span>
 128  *         &lt;td&gt;Month in year (standalone form)
 129  *         &lt;td&gt;&lt;a href=&quot;#month&quot;&gt;Month&lt;/a&gt;
<span class="line-modified"> 130  *         &lt;td&gt;&lt;code&gt;July&lt;/code&gt;; &lt;code&gt;Jul&lt;/code&gt;; &lt;code&gt;07&lt;/code&gt;</span>
 131  *     &lt;tr&gt;
<span class="line-modified"> 132  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;w&lt;/code&gt;</span>
 133  *         &lt;td&gt;Week in year
 134  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 135  *         &lt;td&gt;&lt;code&gt;27&lt;/code&gt;</span>
 136  *     &lt;tr&gt;
<span class="line-modified"> 137  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;W&lt;/code&gt;</span>
 138  *         &lt;td&gt;Week in month
 139  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 140  *         &lt;td&gt;&lt;code&gt;2&lt;/code&gt;</span>
 141  *     &lt;tr&gt;
<span class="line-modified"> 142  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;D&lt;/code&gt;</span>
 143  *         &lt;td&gt;Day in year
 144  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 145  *         &lt;td&gt;&lt;code&gt;189&lt;/code&gt;</span>
 146  *     &lt;tr&gt;
<span class="line-modified"> 147  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;d&lt;/code&gt;</span>
 148  *         &lt;td&gt;Day in month
 149  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 150  *         &lt;td&gt;&lt;code&gt;10&lt;/code&gt;</span>
 151  *     &lt;tr&gt;
<span class="line-modified"> 152  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;F&lt;/code&gt;</span>
 153  *         &lt;td&gt;Day of week in month
 154  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 155  *         &lt;td&gt;&lt;code&gt;2&lt;/code&gt;</span>
 156  *     &lt;tr&gt;
<span class="line-modified"> 157  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;E&lt;/code&gt;</span>
 158  *         &lt;td&gt;Day name in week
 159  *         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
<span class="line-modified"> 160  *         &lt;td&gt;&lt;code&gt;Tuesday&lt;/code&gt;; &lt;code&gt;Tue&lt;/code&gt;</span>
 161  *     &lt;tr&gt;
<span class="line-modified"> 162  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;u&lt;/code&gt;</span>
 163  *         &lt;td&gt;Day number of week (1 = Monday, ..., 7 = Sunday)
 164  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 165  *         &lt;td&gt;&lt;code&gt;1&lt;/code&gt;</span>
 166  *     &lt;tr&gt;
<span class="line-modified"> 167  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;a&lt;/code&gt;</span>
 168  *         &lt;td&gt;Am/pm marker
 169  *         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
<span class="line-modified"> 170  *         &lt;td&gt;&lt;code&gt;PM&lt;/code&gt;</span>
 171  *     &lt;tr&gt;
<span class="line-modified"> 172  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;H&lt;/code&gt;</span>
 173  *         &lt;td&gt;Hour in day (0-23)
 174  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 175  *         &lt;td&gt;&lt;code&gt;0&lt;/code&gt;</span>
 176  *     &lt;tr&gt;
<span class="line-modified"> 177  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;k&lt;/code&gt;</span>
 178  *         &lt;td&gt;Hour in day (1-24)
 179  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 180  *         &lt;td&gt;&lt;code&gt;24&lt;/code&gt;</span>
 181  *     &lt;tr&gt;
<span class="line-modified"> 182  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;K&lt;/code&gt;</span>
 183  *         &lt;td&gt;Hour in am/pm (0-11)
 184  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 185  *         &lt;td&gt;&lt;code&gt;0&lt;/code&gt;</span>
 186  *     &lt;tr&gt;
<span class="line-modified"> 187  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;h&lt;/code&gt;</span>
 188  *         &lt;td&gt;Hour in am/pm (1-12)
 189  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 190  *         &lt;td&gt;&lt;code&gt;12&lt;/code&gt;</span>
 191  *     &lt;tr&gt;
<span class="line-modified"> 192  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;m&lt;/code&gt;</span>
 193  *         &lt;td&gt;Minute in hour
 194  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 195  *         &lt;td&gt;&lt;code&gt;30&lt;/code&gt;</span>
 196  *     &lt;tr&gt;
<span class="line-modified"> 197  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;s&lt;/code&gt;</span>
 198  *         &lt;td&gt;Second in minute
 199  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 200  *         &lt;td&gt;&lt;code&gt;55&lt;/code&gt;</span>
 201  *     &lt;tr&gt;
<span class="line-modified"> 202  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;S&lt;/code&gt;</span>
 203  *         &lt;td&gt;Millisecond
 204  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 205  *         &lt;td&gt;&lt;code&gt;978&lt;/code&gt;</span>
 206  *     &lt;tr&gt;
<span class="line-modified"> 207  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;z&lt;/code&gt;</span>
 208  *         &lt;td&gt;Time zone
 209  *         &lt;td&gt;&lt;a href=&quot;#timezone&quot;&gt;General time zone&lt;/a&gt;
<span class="line-modified"> 210  *         &lt;td&gt;&lt;code&gt;Pacific Standard Time&lt;/code&gt;; &lt;code&gt;PST&lt;/code&gt;; &lt;code&gt;GMT-08:00&lt;/code&gt;</span>
 211  *     &lt;tr&gt;
<span class="line-modified"> 212  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;Z&lt;/code&gt;</span>
 213  *         &lt;td&gt;Time zone
 214  *         &lt;td&gt;&lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zone&lt;/a&gt;
<span class="line-modified"> 215  *         &lt;td&gt;&lt;code&gt;-0800&lt;/code&gt;</span>
 216  *     &lt;tr&gt;
<span class="line-modified"> 217  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;X&lt;/code&gt;</span>
 218  *         &lt;td&gt;Time zone
 219  *         &lt;td&gt;&lt;a href=&quot;#iso8601timezone&quot;&gt;ISO 8601 time zone&lt;/a&gt;
<span class="line-modified"> 220  *         &lt;td&gt;&lt;code&gt;-08&lt;/code&gt;; &lt;code&gt;-0800&lt;/code&gt;;  &lt;code&gt;-08:00&lt;/code&gt;</span>
 221  * &lt;/tbody&gt;
 222  * &lt;/table&gt;
 223  * &lt;/blockquote&gt;
 224  * Pattern letters are usually repeated, as their number determines the
 225  * exact presentation:
 226  * &lt;ul&gt;
 227  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;text&quot;&gt;Text:&lt;/a&gt;&lt;/strong&gt;
 228  *     For formatting, if the number of pattern letters is 4 or more,
 229  *     the full form is used; otherwise a short or abbreviated form
 230  *     is used if available.
 231  *     For parsing, both forms are accepted, independent of the number
 232  *     of pattern letters.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 233  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;number&quot;&gt;Number:&lt;/a&gt;&lt;/strong&gt;
 234  *     For formatting, the number of pattern letters is the minimum
 235  *     number of digits, and shorter numbers are zero-padded to this amount.
 236  *     For parsing, the number of pattern letters is ignored unless
 237  *     it&#39;s needed to separate two adjacent fields.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 238  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;year&quot;&gt;Year:&lt;/a&gt;&lt;/strong&gt;
 239  *     If the formatter&#39;s {@link #getCalendar() Calendar} is the Gregorian
 240  *     calendar, the following rules are applied.&lt;br&gt;
 241  *     &lt;ul&gt;
 242  *     &lt;li&gt;For formatting, if the number of pattern letters is 2, the year
 243  *         is truncated to 2 digits; otherwise it is interpreted as a
 244  *         &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.
 245  *     &lt;li&gt;For parsing, if the number of pattern letters is more than 2,
 246  *         the year is interpreted literally, regardless of the number of
 247  *         digits. So using the pattern &quot;MM/dd/yyyy&quot;, &quot;01/11/12&quot; parses to
 248  *         Jan 11, 12 A.D.
 249  *     &lt;li&gt;For parsing with the abbreviated year pattern (&quot;y&quot; or &quot;yy&quot;),
<span class="line-modified"> 250  *         &lt;code&gt;SimpleDateFormat&lt;/code&gt; must interpret the abbreviated year</span>
 251  *         relative to some century.  It does this by adjusting dates to be
<span class="line-modified"> 252  *         within 80 years before and 20 years after the time the &lt;code&gt;SimpleDateFormat&lt;/code&gt;</span>
 253  *         instance is created. For example, using a pattern of &quot;MM/dd/yy&quot; and a
<span class="line-modified"> 254  *         &lt;code&gt;SimpleDateFormat&lt;/code&gt; instance created on Jan 1, 1997,  the string</span>
 255  *         &quot;01/11/12&quot; would be interpreted as Jan 11, 2012 while the string &quot;05/04/64&quot;
 256  *         would be interpreted as May 4, 1964.
 257  *         During parsing, only strings consisting of exactly two digits, as defined by
 258  *         {@link Character#isDigit(char)}, will be parsed into the default century.
 259  *         Any other numeric string, such as a one digit string, a three or more digit
 260  *         string, or a two digit string that isn&#39;t all digits (for example, &quot;-1&quot;), is
 261  *         interpreted literally.  So &quot;01/02/3&quot; or &quot;01/02/003&quot; are parsed, using the
 262  *         same pattern, as Jan 2, 3 AD.  Likewise, &quot;01/02/-3&quot; is parsed as Jan 2, 4 BC.
 263  *     &lt;/ul&gt;
 264  *     Otherwise, calendar system specific forms are applied.
 265  *     For both formatting and parsing, if the number of pattern
 266  *     letters is 4 or more, a calendar specific {@linkplain
 267  *     Calendar#LONG long form} is used. Otherwise, a calendar
 268  *     specific {@linkplain Calendar#SHORT short or abbreviated form}
 269  *     is used.&lt;br&gt;
 270  *     &lt;br&gt;
 271  *     If week year {@code &#39;Y&#39;} is specified and the {@linkplain
 272  *     #getCalendar() calendar} doesn&#39;t support any &lt;a
 273  *     href=&quot;../util/GregorianCalendar.html#week_year&quot;&gt; week
 274  *     years&lt;/a&gt;, the calendar year ({@code &#39;y&#39;}) is used instead. The
</pre>
<hr />
<pre>
 286  *         sense that when it is used in the standalone pattern, for example,
 287  *         &quot;MMMM&quot;, it gives the standalone form of a month name and when it is
 288  *         used in the pattern containing other field(s), for example, &quot;d MMMM&quot;,
 289  *         it gives the format form of a month name. For example, January in the
 290  *         Catalan language is &quot;de gener&quot; in the format form while it is &quot;gener&quot;
 291  *         in the standalone form. In this case, &quot;MMMM&quot; will produce &quot;gener&quot; and
 292  *         the month part of the &quot;d MMMM&quot; will produce &quot;de gener&quot;. If a
 293  *         {@code DateFormatSymbols} has been set explicitly with constructor
 294  *         {@link #SimpleDateFormat(String,DateFormatSymbols)} or method {@link
 295  *         #setDateFormatSymbols(DateFormatSymbols)}, the month names given by
 296  *         the {@code DateFormatSymbols} are used.&lt;/li&gt;
 297  *     &lt;li&gt;Letter &lt;em&gt;L&lt;/em&gt; produces the standalone form of month names.&lt;/li&gt;
 298  *     &lt;/ul&gt;
 299  *     &lt;br&gt;&lt;/li&gt;
 300  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;timezone&quot;&gt;General time zone:&lt;/a&gt;&lt;/strong&gt;
 301  *     Time zones are interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; if they have
 302  *     names. For time zones representing a GMT offset value, the
 303  *     following syntax is used:
 304  *     &lt;pre&gt;
 305  *     &lt;a id=&quot;GMTOffsetTimeZone&quot;&gt;&lt;i&gt;GMTOffsetTimeZone:&lt;/i&gt;&lt;/a&gt;
<span class="line-modified"> 306  *             &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;</span>
 307  *     &lt;i&gt;Sign:&lt;/i&gt; one of
<span class="line-modified"> 308  *             &lt;code&gt;+ -&lt;/code&gt;</span>
 309  *     &lt;i&gt;Hours:&lt;/i&gt;
 310  *             &lt;i&gt;Digit&lt;/i&gt;
 311  *             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 312  *     &lt;i&gt;Minutes:&lt;/i&gt;
 313  *             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 314  *     &lt;i&gt;Digit:&lt;/i&gt; one of
<span class="line-modified"> 315  *             &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;</span>
 316  *     &lt;i&gt;Hours&lt;/i&gt; must be between 0 and 23, and &lt;i&gt;Minutes&lt;/i&gt; must be between
 317  *     00 and 59. The format is locale independent and digits must be taken
 318  *     from the Basic Latin block of the Unicode standard.
 319  *     &lt;p&gt;For parsing, &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt; are also
 320  *     accepted.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 321  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;rfc822timezone&quot;&gt;RFC 822 time zone:&lt;/a&gt;&lt;/strong&gt;
 322  *     For formatting, the RFC 822 4-digit time zone format is used:
 323  *
 324  *     &lt;pre&gt;
 325  *     &lt;i&gt;RFC822TimeZone:&lt;/i&gt;
 326  *             &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
 327  *     &lt;i&gt;TwoDigitHours:&lt;/i&gt;
 328  *             &lt;i&gt;Digit Digit&lt;/i&gt;&lt;/pre&gt;
 329  *     &lt;i&gt;TwoDigitHours&lt;/i&gt; must be between 00 and 23. Other definitions
 330  *     are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt;.
 331  *
 332  *     &lt;p&gt;For parsing, &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; are also
 333  *     accepted.
 334  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;iso8601timezone&quot;&gt;ISO 8601 Time zone:&lt;/a&gt;&lt;/strong&gt;
 335  *     The number of pattern letters designates the format for both formatting
</pre>
<hr />
<pre>
 347  *             {@code Z}
 348  *     &lt;i&gt;ThreeLetterISO8601TimeZone:&lt;/i&gt;
 349  *             &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; {@code :} &lt;i&gt;Minutes&lt;/i&gt;
 350  *             {@code Z}&lt;/pre&gt;
 351  *     Other definitions are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; or
 352  *     &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt;.
 353  *
 354  *     &lt;p&gt;For formatting, if the offset value from GMT is 0, {@code &quot;Z&quot;} is
 355  *     produced. If the number of pattern letters is 1, any fraction of an hour
 356  *     is ignored. For example, if the pattern is {@code &quot;X&quot;} and the time zone is
 357  *     {@code &quot;GMT+05:30&quot;}, {@code &quot;+05&quot;} is produced.
 358  *
 359  *     &lt;p&gt;For parsing, {@code &quot;Z&quot;} is parsed as the UTC time zone designator.
 360  *     &lt;a href=&quot;#timezone&quot;&gt;General time zones&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; accepted.
 361  *
 362  *     &lt;p&gt;If the number of pattern letters is 4 or more, {@link
 363  *     IllegalArgumentException} is thrown when constructing a {@code
 364  *     SimpleDateFormat} or {@linkplain #applyPattern(String) applying a
 365  *     pattern}.
 366  * &lt;/ul&gt;
<span class="line-modified"> 367  * &lt;code&gt;SimpleDateFormat&lt;/code&gt; also supports &lt;em&gt;localized date and time</span>
 368  * pattern&lt;/em&gt; strings. In these strings, the pattern letters described above
 369  * may be replaced with other, locale dependent, pattern letters.
<span class="line-modified"> 370  * &lt;code&gt;SimpleDateFormat&lt;/code&gt; does not deal with the localization of text</span>
 371  * other than the pattern letters; that&#39;s up to the client of the class.
 372  *
<span class="line-modified"> 373  * &lt;h4&gt;Examples&lt;/h4&gt;</span>
 374  *
 375  * The following examples show how date and time patterns are interpreted in
 376  * the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time
 377  * in the U.S. Pacific Time time zone.
 378  * &lt;blockquote&gt;
 379  * &lt;table class=&quot;striped&quot;&gt;
 380  * &lt;caption style=&quot;display:none&quot;&gt;Examples of date and time patterns interpreted in the U.S. locale&lt;/caption&gt;
 381  * &lt;thead&gt;
 382  *     &lt;tr&gt;
 383  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Date and Time Pattern
 384  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Result
 385  * &lt;/thead&gt;
 386  * &lt;tbody&gt;
 387  *     &lt;tr&gt;
<span class="line-modified"> 388  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;yyyy.MM.dd G &#39;at&#39; HH:mm:ss z&quot;&lt;/code&gt;</span>
<span class="line-modified"> 389  *         &lt;td&gt;&lt;code&gt;2001.07.04 AD at 12:08:56 PDT&lt;/code&gt;</span>
 390  *     &lt;tr&gt;
<span class="line-modified"> 391  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;EEE, MMM d, &#39;&#39;yy&quot;&lt;/code&gt;</span>
<span class="line-modified"> 392  *         &lt;td&gt;&lt;code&gt;Wed, Jul 4, &#39;01&lt;/code&gt;</span>
 393  *     &lt;tr&gt;
<span class="line-modified"> 394  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;h:mm a&quot;&lt;/code&gt;</span>
<span class="line-modified"> 395  *         &lt;td&gt;&lt;code&gt;12:08 PM&lt;/code&gt;</span>
 396  *     &lt;tr&gt;
<span class="line-modified"> 397  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;hh &#39;o&#39;&#39;clock&#39; a, zzzz&quot;&lt;/code&gt;</span>
<span class="line-modified"> 398  *         &lt;td&gt;&lt;code&gt;12 o&#39;clock PM, Pacific Daylight Time&lt;/code&gt;</span>
 399  *     &lt;tr&gt;
<span class="line-modified"> 400  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;K:mm a, z&quot;&lt;/code&gt;</span>
<span class="line-modified"> 401  *         &lt;td&gt;&lt;code&gt;0:08 PM, PDT&lt;/code&gt;</span>
 402  *     &lt;tr&gt;
<span class="line-modified"> 403  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;&lt;/code&gt;</span>
<span class="line-modified"> 404  *         &lt;td&gt;&lt;code&gt;02001.July.04 AD 12:08 PM&lt;/code&gt;</span>
 405  *     &lt;tr&gt;
<span class="line-modified"> 406  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;EEE, d MMM yyyy HH:mm:ss Z&quot;&lt;/code&gt;</span>
<span class="line-modified"> 407  *         &lt;td&gt;&lt;code&gt;Wed, 4 Jul 2001 12:08:56 -0700&lt;/code&gt;</span>
 408  *     &lt;tr&gt;
<span class="line-modified"> 409  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;yyMMddHHmmssZ&quot;&lt;/code&gt;</span>
<span class="line-modified"> 410  *         &lt;td&gt;&lt;code&gt;010704120856-0700&lt;/code&gt;</span>
 411  *     &lt;tr&gt;
<span class="line-modified"> 412  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;&lt;/code&gt;</span>
<span class="line-modified"> 413  *         &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-0700&lt;/code&gt;</span>
 414  *     &lt;tr&gt;
<span class="line-modified"> 415  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX&quot;&lt;/code&gt;</span>
<span class="line-modified"> 416  *         &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-07:00&lt;/code&gt;</span>
 417  *     &lt;tr&gt;
<span class="line-modified"> 418  *         &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&quot;YYYY-&#39;W&#39;ww-u&quot;&lt;/code&gt;</span>
<span class="line-modified"> 419  *         &lt;td&gt;&lt;code&gt;2001-W27-3&lt;/code&gt;</span>
 420  * &lt;/tbody&gt;
 421  * &lt;/table&gt;
 422  * &lt;/blockquote&gt;
 423  *
<span class="line-modified"> 424  * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;</span>
 425  *
 426  * &lt;p&gt;
 427  * Date formats are not synchronized.
 428  * It is recommended to create separate format instances for each thread.
 429  * If multiple threads access a format concurrently, it must be synchronized
 430  * externally.
 431  *
 432  * @see          &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/i18n/format/simpleDateFormat.html&quot;&gt;Java Tutorial&lt;/a&gt;
 433  * @see          java.util.Calendar
 434  * @see          java.util.TimeZone
 435  * @see          DateFormat
 436  * @see          DateFormatSymbols
 437  * @author       Mark Davis, Chen-Lieh Huang, Alan Liu
 438  * @since 1.1
 439  */
 440 public class SimpleDateFormat extends DateFormat {
 441 
 442     // the official serial version ID which says cryptically
 443     // which version we&#39;re compatible with

 444     static final long serialVersionUID = 4774881970558875024L;
 445 
 446     // the internal serial version which says which version was written
 447     // - 0 (default) for version up to JDK 1.1.3
 448     // - 1 for version from JDK 1.1.4, which includes a new field
 449     static final int currentSerialVersion = 1;
 450 
 451     /**
 452      * The version of the serialized data on the stream.  Possible values:
 453      * &lt;ul&gt;
 454      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream: JDK 1.1.3.  This version
<span class="line-modified"> 455      * has no &lt;code&gt;defaultCenturyStart&lt;/code&gt; on stream.</span>
 456      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt; JDK 1.1.4 or later.  This version adds
<span class="line-modified"> 457      * &lt;code&gt;defaultCenturyStart&lt;/code&gt;.</span>
 458      * &lt;/ul&gt;
 459      * When streaming out this class, the most recent format
<span class="line-modified"> 460      * and the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;</span>
 461      * is written.
 462      * @serial
 463      * @since 1.1.4
 464      */
 465     private int serialVersionOnStream = currentSerialVersion;
 466 
 467     /**
 468      * The pattern string of this formatter.  This is always a non-localized
 469      * pattern.  May not be null.  See class documentation for details.
 470      * @serial
 471      */
 472     private String pattern;
 473 
 474     /**
 475      * Saved numberFormat and pattern.
 476      * @see SimpleDateFormat#checkNegativeNumberExpression
 477      */
 478     private transient NumberFormat originalNumberFormat;
 479     private transient String originalNumberPattern;
 480 
</pre>
<hr />
<pre>
 505     private static final int TAG_QUOTE_ASCII_CHAR       = 100;
 506     private static final int TAG_QUOTE_CHARS            = 101;
 507 
 508     /**
 509      * Locale dependent digit zero.
 510      * @see #zeroPaddingNumber
 511      * @see java.text.DecimalFormatSymbols#getZeroDigit
 512      */
 513     private transient char zeroDigit;
 514 
 515     /**
 516      * The symbols used by this formatter for week names, month names,
 517      * etc.  May not be null.
 518      * @serial
 519      * @see java.text.DateFormatSymbols
 520      */
 521     private DateFormatSymbols formatData;
 522 
 523     /**
 524      * We map dates with two-digit years into the century starting at
<span class="line-modified"> 525      * &lt;code&gt;defaultCenturyStart&lt;/code&gt;, which may be any date.  May</span>
 526      * not be null.
 527      * @serial
 528      * @since 1.1.4
 529      */
 530     private Date defaultCenturyStart;
 531 
 532     private transient int defaultCenturyStartYear;
 533 
 534     private static final int MILLIS_PER_MINUTE = 60 * 1000;
 535 
 536     // For time zones that have no names, use strings GMT+minutes and
 537     // GMT-minutes. For instance, in France the time zone is GMT+60.
 538     private static final String GMT = &quot;GMT&quot;;
 539 
 540     /**
 541      * Cache NumberFormat instances with Locale key.
 542      */
 543     private static final ConcurrentMap&lt;Locale, NumberFormat&gt; cachedNumberFormatData
 544         = new ConcurrentHashMap&lt;&gt;(3);
 545 
 546     /**
 547      * The Locale used to instantiate this
<span class="line-modified"> 548      * &lt;code&gt;SimpleDateFormat&lt;/code&gt;. The value may be null if this object</span>
<span class="line-modified"> 549      * has been created by an older &lt;code&gt;SimpleDateFormat&lt;/code&gt; and</span>
 550      * deserialized.
 551      *
 552      * @serial
 553      * @since 1.6
 554      */
 555     private Locale locale;
 556 
 557     /**
<span class="line-modified"> 558      * Indicates whether this &lt;code&gt;SimpleDateFormat&lt;/code&gt; should use</span>
 559      * the DateFormatSymbols. If true, the format and parse methods
 560      * use the DateFormatSymbols values. If false, the format and
 561      * parse methods call Calendar.getDisplayName or
 562      * Calendar.getDisplayNames.
 563      */
 564     transient boolean useDateFormatSymbols;
 565 
 566     /**
<span class="line-modified"> 567      * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the default pattern and</span>
 568      * date format symbols for the default
 569      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 570      * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
 571      * For full coverage, use the factory methods in the {@link DateFormat}
 572      * class.
 573      */
 574     public SimpleDateFormat() {
 575         this(&quot;&quot;, Locale.getDefault(Locale.Category.FORMAT));
 576         applyPatternImpl(LocaleProviderAdapter.getResourceBundleBased().getLocaleResources(locale)
 577                          .getDateTimePattern(SHORT, SHORT, calendar));
 578     }
 579 
 580     /**
<span class="line-modified"> 581      * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and</span>
 582      * the default date format symbols for the default
 583      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 584      * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
 585      * For full coverage, use the factory methods in the {@link DateFormat}
 586      * class.
 587      * &lt;p&gt;This is equivalent to calling
 588      * {@link #SimpleDateFormat(String, Locale)
 589      *     SimpleDateFormat(pattern, Locale.getDefault(Locale.Category.FORMAT))}.
 590      *
 591      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 592      * @see java.util.Locale.Category#FORMAT
 593      * @param pattern the pattern describing the date and time format
<span class="line-modified"> 594      * @exception NullPointerException if the given pattern is null</span>
<span class="line-modified"> 595      * @exception IllegalArgumentException if the given pattern is invalid</span>
 596      */
 597     public SimpleDateFormat(String pattern)
 598     {
 599         this(pattern, Locale.getDefault(Locale.Category.FORMAT));
 600     }
 601 
 602     /**
<span class="line-modified"> 603      * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and</span>
 604      * the default date format symbols for the given locale.
 605      * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
 606      * For full coverage, use the factory methods in the {@link DateFormat}
 607      * class.
 608      *
 609      * @param pattern the pattern describing the date and time format
 610      * @param locale the locale whose date format symbols should be used
<span class="line-modified"> 611      * @exception NullPointerException if the given pattern or locale is null</span>
<span class="line-modified"> 612      * @exception IllegalArgumentException if the given pattern is invalid</span>
 613      */
 614     public SimpleDateFormat(String pattern, Locale locale)
 615     {
 616         if (pattern == null || locale == null) {
 617             throw new NullPointerException();
 618         }
 619 
 620         initializeCalendar(locale);
 621         this.pattern = pattern;
 622         this.formatData = DateFormatSymbols.getInstanceRef(locale);
 623         this.locale = locale;
 624         initialize(locale);
 625     }
 626 
 627     /**
<span class="line-modified"> 628      * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and</span>
 629      * date format symbols.
 630      *
 631      * @param pattern the pattern describing the date and time format
 632      * @param formatSymbols the date format symbols to be used for formatting
<span class="line-modified"> 633      * @exception NullPointerException if the given pattern or formatSymbols is null</span>
<span class="line-modified"> 634      * @exception IllegalArgumentException if the given pattern is invalid</span>
 635      */
 636     public SimpleDateFormat(String pattern, DateFormatSymbols formatSymbols)
 637     {
 638         if (pattern == null || formatSymbols == null) {
 639             throw new NullPointerException();
 640         }
 641 
 642         this.pattern = pattern;
 643         this.formatData = (DateFormatSymbols) formatSymbols.clone();
 644         this.locale = Locale.getDefault(Locale.Category.FORMAT);
 645         initializeCalendar(this.locale);
 646         initialize(this.locale);
 647         useDateFormatSymbols = true;
 648     }
 649 
 650     /* Initialize compiledPattern and numberFormat fields */
 651     private void initialize(Locale loc) {
 652         // Verify and compile the given pattern.
 653         compiledPattern = compile(pattern);
 654 
</pre>
<hr />
<pre>
 721      * &lt;blockquote&gt;
 722      *     char[0] = (Tag &lt;&lt; 8) | 255;
 723      *     char[1] = (char) (long_length &gt;&gt;&gt; 16);
 724      *     char[2] = (char) (long_length &amp; 0xffff);
 725      * &lt;/blockquote&gt;
 726      * &lt;p&gt;
 727      * If Tag is a pattern_char_index, its Length is the number of
 728      * pattern characters. For example, if the given pattern is
 729      * &quot;yyyy&quot;, Tag is 1 and Length is 4, followed by no data.
 730      * &lt;p&gt;
 731      * If Tag is TAG_QUOTE_CHARS, its Length is the number of char&#39;s
 732      * following the TagField. For example, if the given pattern is
 733      * &quot;&#39;o&#39;&#39;clock&#39;&quot;, Length is 7 followed by a char sequence of
 734      * &lt;code&gt;o&amp;nbs;&#39;&amp;nbs;c&amp;nbs;l&amp;nbs;o&amp;nbs;c&amp;nbs;k&lt;/code&gt;.
 735      * &lt;p&gt;
 736      * TAG_QUOTE_ASCII_CHAR is a special tag and has an ASCII
 737      * character in place of Length. For example, if the given pattern
 738      * is &quot;&#39;o&#39;&quot;, the TaggedData entry is
 739      * &lt;code&gt;((TAG_QUOTE_ASCII_CHAR&amp;nbs;&lt;&lt;&amp;nbs;8)&amp;nbs;|&amp;nbs;&#39;o&#39;)&lt;/code&gt;.
 740      *
<span class="line-modified"> 741      * @exception NullPointerException if the given pattern is null</span>
<span class="line-modified"> 742      * @exception IllegalArgumentException if the given pattern is invalid</span>
 743      */
 744     private char[] compile(String pattern) {
 745         int length = pattern.length();
 746         boolean inQuote = false;
 747         StringBuilder compiledCode = new StringBuilder(length * 2);
 748         StringBuilder tmpBuffer = null;
 749         int count = 0, tagcount = 0;
 750         int lastTag = -1, prevTag = -1;
 751 
 752         for (int i = 0; i &lt; length; i++) {
 753             char c = pattern.charAt(i);
 754 
 755             if (c == &#39;\&#39;&#39;) {
 756                 // &#39;&#39; is treated as a single quote regardless of being
 757                 // in a quoted section.
 758                 if ((i + 1) &lt; length) {
 759                     c = pattern.charAt(i + 1);
 760                     if (c == &#39;\&#39;&#39;) {
 761                         i++;
 762                         if (count != 0) {
</pre>
<hr />
<pre>
 898     private void initializeDefaultCentury() {
 899         calendar.setTimeInMillis(System.currentTimeMillis());
 900         calendar.add( Calendar.YEAR, -80 );
 901         parseAmbiguousDatesAsAfter(calendar.getTime());
 902     }
 903 
 904     /* Define one-century window into which to disambiguate dates using
 905      * two-digit years.
 906      */
 907     private void parseAmbiguousDatesAsAfter(Date startDate) {
 908         defaultCenturyStart = startDate;
 909         calendar.setTime(startDate);
 910         defaultCenturyStartYear = calendar.get(Calendar.YEAR);
 911     }
 912 
 913     /**
 914      * Sets the 100-year period 2-digit years will be interpreted as being in
 915      * to begin on the date the user specifies.
 916      *
 917      * @param startDate During parsing, two digit years will be placed in the range
<span class="line-modified"> 918      * &lt;code&gt;startDate&lt;/code&gt; to &lt;code&gt;startDate + 100 years&lt;/code&gt;.</span>
 919      * @see #get2DigitYearStart
 920      * @throws NullPointerException if {@code startDate} is {@code null}.
 921      * @since 1.2
 922      */
 923     public void set2DigitYearStart(Date startDate) {
 924         parseAmbiguousDatesAsAfter(new Date(startDate.getTime()));
 925     }
 926 
 927     /**
 928      * Returns the beginning date of the 100-year period 2-digit years are interpreted
 929      * as being within.
 930      *
 931      * @return the start of the 100-year period into which two digit years are
 932      * parsed
 933      * @see #set2DigitYearStart
 934      * @since 1.2
 935      */
 936     public Date get2DigitYearStart() {
 937         return (Date) defaultCenturyStart.clone();
 938     }
 939 
 940     /**
<span class="line-modified"> 941      * Formats the given &lt;code&gt;Date&lt;/code&gt; into a date/time string and appends</span>
<span class="line-modified"> 942      * the result to the given &lt;code&gt;StringBuffer&lt;/code&gt;.</span>
 943      *
 944      * @param date the date-time value to be formatted into a date-time string.
 945      * @param toAppendTo where the new date-time text is to be appended.
 946      * @param pos keeps track on the position of the field within
 947      * the returned string. For example, given a date-time text
 948      * {@code &quot;1996.07.10 AD at 15:08:56 PDT&quot;}, if the given {@code fieldPosition}
 949      * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of
 950      * {@code fieldPosition} will be set to 0 and 4, respectively.
 951      * Notice that if the same date-time field appears more than once in a
 952      * pattern, the {@code fieldPosition} will be set for the first occurrence
 953      * of that date-time field. For instance, formatting a {@code Date} to the
 954      * date-time string {@code &quot;1 PM PDT (Pacific Daylight Time)&quot;} using the
 955      * pattern {@code &quot;h a z (zzzz)&quot;} and the alignment field
 956      * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of
 957      * {@code fieldPosition} will be set to 5 and 8, respectively, for the
 958      * first occurrence of the timezone pattern character {@code &#39;z&#39;}.
 959      * @return the formatted date-time string.
<span class="line-modified"> 960      * @exception NullPointerException if any of the parameters is {@code null}.</span>
 961      */
 962     @Override
 963     public StringBuffer format(Date date, StringBuffer toAppendTo,
 964                                FieldPosition pos)
 965     {
 966         pos.beginIndex = pos.endIndex = 0;
 967         return format(date, toAppendTo, pos.getFieldDelegate());
 968     }
 969 
 970     // Called from Format after creating a FieldDelegate
 971     private StringBuffer format(Date date, StringBuffer toAppendTo,
 972                                 FieldDelegate delegate) {
 973         // Convert input date to time field list
 974         calendar.setTime(date);
 975 
 976         boolean useDateFormatSymbols = useDateFormatSymbols();
 977 
 978         for (int i = 0; i &lt; compiledPattern.length; ) {
 979             int tag = compiledPattern[i] &gt;&gt;&gt; 8;
 980             int count = compiledPattern[i++] &amp; 0xff;
</pre>
<hr />
<pre>
 985 
 986             switch (tag) {
 987             case TAG_QUOTE_ASCII_CHAR:
 988                 toAppendTo.append((char)count);
 989                 break;
 990 
 991             case TAG_QUOTE_CHARS:
 992                 toAppendTo.append(compiledPattern, i, count);
 993                 i += count;
 994                 break;
 995 
 996             default:
 997                 subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);
 998                 break;
 999             }
1000         }
1001         return toAppendTo;
1002     }
1003 
1004     /**
<span class="line-modified">1005      * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.</span>
<span class="line-modified">1006      * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;</span>
1007      * to build the resulting String, as well as to determine information
1008      * about the resulting String.
1009      * &lt;p&gt;
1010      * Each attribute key of the AttributedCharacterIterator will be of type
<span class="line-modified">1011      * &lt;code&gt;DateFormat.Field&lt;/code&gt;, with the corresponding attribute value</span>
1012      * being the same as the attribute key.
1013      *
<span class="line-modified">1014      * @exception NullPointerException if obj is null.</span>
<span class="line-modified">1015      * @exception IllegalArgumentException if the Format cannot format the</span>
1016      *            given object, or if the Format&#39;s pattern string is invalid.
1017      * @param obj The object to format
1018      * @return AttributedCharacterIterator describing the formatted value.
1019      * @since 1.4
1020      */
1021     @Override
1022     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
1023         StringBuffer sb = new StringBuffer();
1024         CharacterIteratorFieldDelegate delegate = new
1025                          CharacterIteratorFieldDelegate();
1026 
1027         if (obj instanceof Date) {
1028             format((Date)obj, sb, delegate);
1029         }
1030         else if (obj instanceof Number) {
1031             format(new Date(((Number)obj).longValue()), sb, delegate);
1032         }
1033         else if (obj == null) {
1034             throw new NullPointerException(
1035                    &quot;formatToCharacterIterator must be passed non-null object&quot;);
</pre>
<hr />
<pre>
1409                         buffer.append((char)(zeroDigit + value / 10));
1410                         buffer.append((char)(zeroDigit + value % 10));
1411                         return;
1412                     }
1413                     if (minDigits == 2 &amp;&amp; maxDigits == 2) {
1414                         zeroPaddingNumber(value % 100, 2, 2, buffer);
1415                         return;
1416                     }
1417                 }
1418             }
1419         } catch (Exception e) {
1420         }
1421 
1422         numberFormat.setMinimumIntegerDigits(minDigits);
1423         numberFormat.setMaximumIntegerDigits(maxDigits);
1424         numberFormat.format((long)value, buffer, DontCareFieldPosition.INSTANCE);
1425     }
1426 
1427 
1428     /**
<span class="line-modified">1429      * Parses text from a string to produce a &lt;code&gt;Date&lt;/code&gt;.</span>
1430      * &lt;p&gt;
1431      * The method attempts to parse text starting at the index given by
<span class="line-modified">1432      * &lt;code&gt;pos&lt;/code&gt;.</span>
<span class="line-modified">1433      * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated</span>
1434      * to the index after the last character used (parsing does not necessarily
1435      * use all characters up to the end of the string), and the parsed
<span class="line-modified">1436      * date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</span>
1437      * indicate the starting point for the next call to this method.
<span class="line-modified">1438      * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</span>
<span class="line-modified">1439      * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of</span>
1440      * the character where the error occurred, and null is returned.
1441      *
1442      * &lt;p&gt;This parsing operation uses the {@link DateFormat#calendar
1443      * calendar} to produce a {@code Date}. All of the {@code
1444      * calendar}&#39;s date-time fields are {@linkplain Calendar#clear()
1445      * cleared} before parsing, and the {@code calendar}&#39;s default
1446      * values of the date-time fields are used for any missing
1447      * date-time information. For example, the year value of the
1448      * parsed {@code Date} is 1970 with {@link GregorianCalendar} if
1449      * no year value is given from the parsing operation.  The {@code
1450      * TimeZone} value may be overwritten, depending on the given
1451      * pattern and the time zone value in {@code text}. Any {@code
1452      * TimeZone} value that has previously been set by a call to
1453      * {@link #setTimeZone(java.util.TimeZone) setTimeZone} may need
1454      * to be restored for further operations.
1455      *
<span class="line-modified">1456      * @param text  A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.</span>
<span class="line-modified">1457      * @param pos   A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error</span>
1458      *              index information as described above.
<span class="line-modified">1459      * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of</span>
1460      *         error, returns null.
<span class="line-modified">1461      * @exception NullPointerException if &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;pos&lt;/code&gt; is null.</span>
1462      */
1463     @Override
1464     public Date parse(String text, ParsePosition pos)
1465     {
1466         checkNegativeNumberExpression();
1467 
1468         int start = pos.index;
1469         int oldStart = start;
1470         int textLength = text.length();
1471 
1472         boolean[] ambiguousYear = {false};
1473 
1474         CalendarBuilder calb = new CalendarBuilder();
1475 
1476         for (int i = 0; i &lt; compiledPattern.length; ) {
1477             int tag = compiledPattern[i] &gt;&gt;&gt; 8;
1478             int count = compiledPattern[i++] &amp; 0xff;
1479             if (count == 255) {
1480                 count = compiledPattern[i++] &lt;&lt; 16;
1481                 count |= compiledPattern[i++];
</pre>
<hr />
<pre>
2258             }
2259         }
2260 
2261         // Parsing failed.
2262         origPos.errorIndex = pos.index;
2263         return -1;
2264     }
2265 
2266     /**
2267      * Returns true if the DateFormatSymbols has been set explicitly or locale
2268      * is null.
2269      */
2270     private boolean useDateFormatSymbols() {
2271         return useDateFormatSymbols || locale == null;
2272     }
2273 
2274     /**
2275      * Translates a pattern, mapping each character in the from string to the
2276      * corresponding character in the to string.
2277      *
<span class="line-modified">2278      * @exception IllegalArgumentException if the given pattern is invalid</span>
2279      */
2280     private String translatePattern(String pattern, String from, String to) {
2281         StringBuilder result = new StringBuilder();
2282         boolean inQuote = false;
2283         for (int i = 0; i &lt; pattern.length(); ++i) {
2284             char c = pattern.charAt(i);
2285             if (inQuote) {
2286                 if (c == &#39;\&#39;&#39;) {
2287                     inQuote = false;
2288                 }
2289             }
2290             else {
2291                 if (c == &#39;\&#39;&#39;) {
2292                     inQuote = true;
2293                 } else if ((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)) {
2294                     int ci = from.indexOf(c);
2295                     if (ci &gt;= 0) {
2296                         // patternChars is longer than localPatternChars due
2297                         // to serialization compatibility. The pattern letters
2298                         // unsupported by localPatternChars pass through.
</pre>
<hr />
<pre>
2321      */
2322     public String toPattern() {
2323         return pattern;
2324     }
2325 
2326     /**
2327      * Returns a localized pattern string describing this date format.
2328      *
2329      * @return a localized pattern string describing this date format.
2330      */
2331     public String toLocalizedPattern() {
2332         return translatePattern(pattern,
2333                                 DateFormatSymbols.patternChars,
2334                                 formatData.getLocalPatternChars());
2335     }
2336 
2337     /**
2338      * Applies the given pattern string to this date format.
2339      *
2340      * @param pattern the new date and time pattern for this date format
<span class="line-modified">2341      * @exception NullPointerException if the given pattern is null</span>
<span class="line-modified">2342      * @exception IllegalArgumentException if the given pattern is invalid</span>
2343      */
2344     public void applyPattern(String pattern)
2345     {
2346         applyPatternImpl(pattern);
2347     }
2348 
2349     private void applyPatternImpl(String pattern) {
2350         compiledPattern = compile(pattern);
2351         this.pattern = pattern;
2352     }
2353 
2354     /**
2355      * Applies the given localized pattern string to this date format.
2356      *
2357      * @param pattern a String to be mapped to the new date and time format
2358      *        pattern for this format
<span class="line-modified">2359      * @exception NullPointerException if the given pattern is null</span>
<span class="line-modified">2360      * @exception IllegalArgumentException if the given pattern is invalid</span>
2361      */
2362     public void applyLocalizedPattern(String pattern) {
2363          String p = translatePattern(pattern,
2364                                      formatData.getLocalPatternChars(),
2365                                      DateFormatSymbols.patternChars);
2366          compiledPattern = compile(p);
2367          this.pattern = p;
2368     }
2369 
2370     /**
2371      * Gets a copy of the date and time format symbols of this date format.
2372      *
2373      * @return the date and time format symbols of this date format
2374      * @see #setDateFormatSymbols
2375      */
2376     public DateFormatSymbols getDateFormatSymbols()
2377     {
2378         return (DateFormatSymbols)formatData.clone();
2379     }
2380 
2381     /**
2382      * Sets the date and time format symbols of this date format.
2383      *
2384      * @param newFormatSymbols the new date and time format symbols
<span class="line-modified">2385      * @exception NullPointerException if the given newFormatSymbols is null</span>
2386      * @see #getDateFormatSymbols
2387      */
2388     public void setDateFormatSymbols(DateFormatSymbols newFormatSymbols)
2389     {
2390         this.formatData = (DateFormatSymbols)newFormatSymbols.clone();
2391         useDateFormatSymbols = true;
2392     }
2393 
2394     /**
<span class="line-modified">2395      * Creates a copy of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;. This also</span>
2396      * clones the format&#39;s date format symbols.
2397      *
<span class="line-modified">2398      * @return a clone of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;</span>
2399      */
2400     @Override
2401     public Object clone() {
2402         SimpleDateFormat other = (SimpleDateFormat) super.clone();
2403         other.formatData = (DateFormatSymbols) formatData.clone();
2404         return other;
2405     }
2406 
2407     /**
<span class="line-modified">2408      * Returns the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object.</span>
2409      *
<span class="line-modified">2410      * @return the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object.</span>
2411      */
2412     @Override
2413     public int hashCode()
2414     {
2415         return pattern.hashCode();
2416         // just enough fields for a reasonable distribution
2417     }
2418 
2419     /**
<span class="line-modified">2420      * Compares the given object with this &lt;code&gt;SimpleDateFormat&lt;/code&gt; for</span>
2421      * equality.
2422      *
2423      * @return true if the given object is equal to this
<span class="line-modified">2424      * &lt;code&gt;SimpleDateFormat&lt;/code&gt;</span>
2425      */
2426     @Override
2427     public boolean equals(Object obj)
2428     {
2429         if (!super.equals(obj)) {
2430             return false; // super does class check
2431         }
2432         SimpleDateFormat that = (SimpleDateFormat) obj;
2433         return (pattern.equals(that.pattern)
2434                 &amp;&amp; formatData.equals(that.formatData));
2435     }
2436 
2437     private static final int[] REST_OF_STYLES = {
2438         Calendar.SHORT_STANDALONE, Calendar.LONG_FORMAT, Calendar.LONG_STANDALONE,
2439     };
2440     private Map&lt;String, Integer&gt; getDisplayNamesMap(int field, Locale locale) {
2441         Map&lt;String, Integer&gt; map = calendar.getDisplayNames(field, Calendar.SHORT_FORMAT, locale);
2442         // Get all SHORT and LONG styles (avoid NARROW styles).
2443         for (int style : REST_OF_STYLES) {
2444             Map&lt;String, Integer&gt; m = calendar.getDisplayNames(field, style, locale);
</pre>
<hr />
<pre>
2452     /**
2453      * Obtains display names map, taking the context into account. Currently only
2454      * the month name pattern &#39;M&#39; is context dependent.
2455      */
2456     private Map&lt;String, Integer&gt; getDisplayContextNamesMap(int field, Locale locale) {
2457         Map&lt;String, Integer&gt; map = calendar.getDisplayNames(field,
2458             forceStandaloneForm ? Calendar.SHORT_STANDALONE : Calendar.SHORT_FORMAT, locale);
2459         // Get the LONG style
2460         Map&lt;String, Integer&gt; m = calendar.getDisplayNames(field,
2461             forceStandaloneForm ? Calendar.LONG_STANDALONE : Calendar.LONG_FORMAT, locale);
2462         if (m != null) {
2463             map.putAll(m);
2464         }
2465         return map;
2466     }
2467 
2468     /**
2469      * After reading an object from the input stream, the format
2470      * pattern in the object is verified.
2471      *
<span class="line-modified">2472      * @exception InvalidObjectException if the pattern is invalid</span>
2473      */

2474     private void readObject(ObjectInputStream stream)
2475                          throws IOException, ClassNotFoundException {
2476         stream.defaultReadObject();
2477 
2478         try {
2479             compiledPattern = compile(pattern);
2480         } catch (Exception e) {
2481             throw new InvalidObjectException(&quot;invalid pattern&quot;);
2482         }
2483 
2484         if (serialVersionOnStream &lt; 1) {
2485             // didn&#39;t have defaultCenturyStart field
2486             initializeDefaultCentury();
2487         }
2488         else {
2489             // fill in dependent transient field
2490             parseAmbiguousDatesAsAfter(defaultCenturyStart);
2491         }
2492         serialVersionOnStream = currentSerialVersion;
2493 
</pre>
</td>
<td>
<hr />
<pre>
  41 import java.io.IOException;
  42 import java.io.InvalidObjectException;
  43 import java.io.ObjectInputStream;
  44 import static java.text.DateFormatSymbols.*;
  45 import java.util.Calendar;
  46 import java.util.Date;
  47 import java.util.GregorianCalendar;
  48 import java.util.Locale;
  49 import java.util.Map;
  50 import java.util.SimpleTimeZone;
  51 import java.util.SortedMap;
  52 import java.util.TimeZone;
  53 import java.util.concurrent.ConcurrentHashMap;
  54 import java.util.concurrent.ConcurrentMap;
  55 import sun.util.calendar.CalendarUtils;
  56 import sun.util.calendar.ZoneInfoFile;
  57 import sun.util.locale.provider.LocaleProviderAdapter;
  58 import sun.util.locale.provider.TimeZoneNameUtility;
  59 
  60 /**
<span class="line-modified">  61  * {@code SimpleDateFormat} is a concrete class for formatting and</span>
  62  * parsing dates in a locale-sensitive manner. It allows for formatting
  63  * (date &amp;rarr; text), parsing (text &amp;rarr; date), and normalization.
  64  *
  65  * &lt;p&gt;
<span class="line-modified">  66  * {@code SimpleDateFormat} allows you to start by choosing</span>
  67  * any user-defined patterns for date-time formatting. However, you
  68  * are encouraged to create a date-time formatter with either
<span class="line-modified">  69  * {@code getTimeInstance}, {@code getDateInstance}, or</span>
<span class="line-modified">  70  * {@code getDateTimeInstance} in {@code DateFormat}. Each</span>
  71  * of these class methods can return a date/time formatter initialized
  72  * with a default format pattern. You may modify the format pattern
<span class="line-modified">  73  * using the {@code applyPattern} methods as desired.</span>
  74  * For more information on using these methods, see
  75  * {@link DateFormat}.
  76  *
<span class="line-modified">  77  * &lt;h2&gt;Date and Time Patterns&lt;/h2&gt;</span>
  78  * &lt;p&gt;
  79  * Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt;
  80  * strings.
  81  * Within date and time pattern strings, unquoted letters from
<span class="line-modified">  82  * {@code &#39;A&#39;} to {@code &#39;Z&#39;} and from {@code &#39;a&#39;} to</span>
<span class="line-modified">  83  * {@code &#39;z&#39;} are interpreted as pattern letters representing the</span>
  84  * components of a date or time string.
<span class="line-modified">  85  * Text can be quoted using single quotes ({@code &#39;}) to avoid</span>
  86  * interpretation.
<span class="line-modified">  87  * {@code &quot;&#39;&#39;&quot;} represents a single quote.</span>
  88  * All other characters are not interpreted; they&#39;re simply copied into the
  89  * output string during formatting or matched against the input string
  90  * during parsing.
  91  * &lt;p&gt;
  92  * The following pattern letters are defined (all other characters from
<span class="line-modified">  93  * {@code &#39;A&#39;} to {@code &#39;Z&#39;} and from {@code &#39;a&#39;} to</span>
<span class="line-modified">  94  * {@code &#39;z&#39;} are reserved):</span>
  95  * &lt;blockquote&gt;
  96  * &lt;table class=&quot;striped&quot;&gt;
  97  * &lt;caption style=&quot;display:none&quot;&gt;Chart shows pattern letters, date/time component, presentation, and examples.&lt;/caption&gt;
  98  * &lt;thead&gt;
  99  *     &lt;tr&gt;
 100  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Letter
 101  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Date or Time Component
 102  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Presentation
 103  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Examples
 104  * &lt;/thead&gt;
 105  * &lt;tbody&gt;
 106  *     &lt;tr&gt;
<span class="line-modified"> 107  *         &lt;th scope=&quot;row&quot;&gt;{@code G}</span>
 108  *         &lt;td&gt;Era designator
 109  *         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
<span class="line-modified"> 110  *         &lt;td&gt;{@code AD}</span>
 111  *     &lt;tr&gt;
<span class="line-modified"> 112  *         &lt;th scope=&quot;row&quot;&gt;{@code y}</span>
 113  *         &lt;td&gt;Year
 114  *         &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
<span class="line-modified"> 115  *         &lt;td&gt;{@code 1996}; {@code 96}</span>
 116  *     &lt;tr&gt;
<span class="line-modified"> 117  *         &lt;th scope=&quot;row&quot;&gt;{@code Y}</span>
 118  *         &lt;td&gt;Week year
 119  *         &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
<span class="line-modified"> 120  *         &lt;td&gt;{@code 2009}; {@code 09}</span>
 121  *     &lt;tr&gt;
<span class="line-modified"> 122  *         &lt;th scope=&quot;row&quot;&gt;{@code M}</span>
 123  *         &lt;td&gt;Month in year (context sensitive)
 124  *         &lt;td&gt;&lt;a href=&quot;#month&quot;&gt;Month&lt;/a&gt;
<span class="line-modified"> 125  *         &lt;td&gt;{@code July}; {@code Jul}; {@code 07}</span>
 126  *     &lt;tr&gt;
<span class="line-modified"> 127  *         &lt;th scope=&quot;row&quot;&gt;{@code L}</span>
 128  *         &lt;td&gt;Month in year (standalone form)
 129  *         &lt;td&gt;&lt;a href=&quot;#month&quot;&gt;Month&lt;/a&gt;
<span class="line-modified"> 130  *         &lt;td&gt;{@code July}; {@code Jul}; {@code 07}</span>
 131  *     &lt;tr&gt;
<span class="line-modified"> 132  *         &lt;th scope=&quot;row&quot;&gt;{@code w}</span>
 133  *         &lt;td&gt;Week in year
 134  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 135  *         &lt;td&gt;{@code 27}</span>
 136  *     &lt;tr&gt;
<span class="line-modified"> 137  *         &lt;th scope=&quot;row&quot;&gt;{@code W}</span>
 138  *         &lt;td&gt;Week in month
 139  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 140  *         &lt;td&gt;{@code 2}</span>
 141  *     &lt;tr&gt;
<span class="line-modified"> 142  *         &lt;th scope=&quot;row&quot;&gt;{@code D}</span>
 143  *         &lt;td&gt;Day in year
 144  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 145  *         &lt;td&gt;{@code 189}</span>
 146  *     &lt;tr&gt;
<span class="line-modified"> 147  *         &lt;th scope=&quot;row&quot;&gt;{@code d}</span>
 148  *         &lt;td&gt;Day in month
 149  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 150  *         &lt;td&gt;{@code 10}</span>
 151  *     &lt;tr&gt;
<span class="line-modified"> 152  *         &lt;th scope=&quot;row&quot;&gt;{@code F}</span>
 153  *         &lt;td&gt;Day of week in month
 154  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 155  *         &lt;td&gt;{@code 2}</span>
 156  *     &lt;tr&gt;
<span class="line-modified"> 157  *         &lt;th scope=&quot;row&quot;&gt;{@code E}</span>
 158  *         &lt;td&gt;Day name in week
 159  *         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
<span class="line-modified"> 160  *         &lt;td&gt;{@code Tuesday}; {@code Tue}</span>
 161  *     &lt;tr&gt;
<span class="line-modified"> 162  *         &lt;th scope=&quot;row&quot;&gt;{@code u}</span>
 163  *         &lt;td&gt;Day number of week (1 = Monday, ..., 7 = Sunday)
 164  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 165  *         &lt;td&gt;{@code 1}</span>
 166  *     &lt;tr&gt;
<span class="line-modified"> 167  *         &lt;th scope=&quot;row&quot;&gt;{@code a}</span>
 168  *         &lt;td&gt;Am/pm marker
 169  *         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
<span class="line-modified"> 170  *         &lt;td&gt;{@code PM}</span>
 171  *     &lt;tr&gt;
<span class="line-modified"> 172  *         &lt;th scope=&quot;row&quot;&gt;{@code H}</span>
 173  *         &lt;td&gt;Hour in day (0-23)
 174  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 175  *         &lt;td&gt;{@code 0}</span>
 176  *     &lt;tr&gt;
<span class="line-modified"> 177  *         &lt;th scope=&quot;row&quot;&gt;{@code k}</span>
 178  *         &lt;td&gt;Hour in day (1-24)
 179  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 180  *         &lt;td&gt;{@code 24}</span>
 181  *     &lt;tr&gt;
<span class="line-modified"> 182  *         &lt;th scope=&quot;row&quot;&gt;{@code K}</span>
 183  *         &lt;td&gt;Hour in am/pm (0-11)
 184  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 185  *         &lt;td&gt;{@code 0}</span>
 186  *     &lt;tr&gt;
<span class="line-modified"> 187  *         &lt;th scope=&quot;row&quot;&gt;{@code h}</span>
 188  *         &lt;td&gt;Hour in am/pm (1-12)
 189  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 190  *         &lt;td&gt;{@code 12}</span>
 191  *     &lt;tr&gt;
<span class="line-modified"> 192  *         &lt;th scope=&quot;row&quot;&gt;{@code m}</span>
 193  *         &lt;td&gt;Minute in hour
 194  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 195  *         &lt;td&gt;{@code 30}</span>
 196  *     &lt;tr&gt;
<span class="line-modified"> 197  *         &lt;th scope=&quot;row&quot;&gt;{@code s}</span>
 198  *         &lt;td&gt;Second in minute
 199  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 200  *         &lt;td&gt;{@code 55}</span>
 201  *     &lt;tr&gt;
<span class="line-modified"> 202  *         &lt;th scope=&quot;row&quot;&gt;{@code S}</span>
 203  *         &lt;td&gt;Millisecond
 204  *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
<span class="line-modified"> 205  *         &lt;td&gt;{@code 978}</span>
 206  *     &lt;tr&gt;
<span class="line-modified"> 207  *         &lt;th scope=&quot;row&quot;&gt;{@code z}</span>
 208  *         &lt;td&gt;Time zone
 209  *         &lt;td&gt;&lt;a href=&quot;#timezone&quot;&gt;General time zone&lt;/a&gt;
<span class="line-modified"> 210  *         &lt;td&gt;{@code Pacific Standard Time}; {@code PST}; {@code GMT-08:00}</span>
 211  *     &lt;tr&gt;
<span class="line-modified"> 212  *         &lt;th scope=&quot;row&quot;&gt;{@code Z}</span>
 213  *         &lt;td&gt;Time zone
 214  *         &lt;td&gt;&lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zone&lt;/a&gt;
<span class="line-modified"> 215  *         &lt;td&gt;{@code -0800}</span>
 216  *     &lt;tr&gt;
<span class="line-modified"> 217  *         &lt;th scope=&quot;row&quot;&gt;{@code X}</span>
 218  *         &lt;td&gt;Time zone
 219  *         &lt;td&gt;&lt;a href=&quot;#iso8601timezone&quot;&gt;ISO 8601 time zone&lt;/a&gt;
<span class="line-modified"> 220  *         &lt;td&gt;{@code -08}; {@code -0800};  {@code -08:00}</span>
 221  * &lt;/tbody&gt;
 222  * &lt;/table&gt;
 223  * &lt;/blockquote&gt;
 224  * Pattern letters are usually repeated, as their number determines the
 225  * exact presentation:
 226  * &lt;ul&gt;
 227  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;text&quot;&gt;Text:&lt;/a&gt;&lt;/strong&gt;
 228  *     For formatting, if the number of pattern letters is 4 or more,
 229  *     the full form is used; otherwise a short or abbreviated form
 230  *     is used if available.
 231  *     For parsing, both forms are accepted, independent of the number
 232  *     of pattern letters.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 233  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;number&quot;&gt;Number:&lt;/a&gt;&lt;/strong&gt;
 234  *     For formatting, the number of pattern letters is the minimum
 235  *     number of digits, and shorter numbers are zero-padded to this amount.
 236  *     For parsing, the number of pattern letters is ignored unless
 237  *     it&#39;s needed to separate two adjacent fields.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 238  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;year&quot;&gt;Year:&lt;/a&gt;&lt;/strong&gt;
 239  *     If the formatter&#39;s {@link #getCalendar() Calendar} is the Gregorian
 240  *     calendar, the following rules are applied.&lt;br&gt;
 241  *     &lt;ul&gt;
 242  *     &lt;li&gt;For formatting, if the number of pattern letters is 2, the year
 243  *         is truncated to 2 digits; otherwise it is interpreted as a
 244  *         &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.
 245  *     &lt;li&gt;For parsing, if the number of pattern letters is more than 2,
 246  *         the year is interpreted literally, regardless of the number of
 247  *         digits. So using the pattern &quot;MM/dd/yyyy&quot;, &quot;01/11/12&quot; parses to
 248  *         Jan 11, 12 A.D.
 249  *     &lt;li&gt;For parsing with the abbreviated year pattern (&quot;y&quot; or &quot;yy&quot;),
<span class="line-modified"> 250  *         {@code SimpleDateFormat} must interpret the abbreviated year</span>
 251  *         relative to some century.  It does this by adjusting dates to be
<span class="line-modified"> 252  *         within 80 years before and 20 years after the time the {@code SimpleDateFormat}</span>
 253  *         instance is created. For example, using a pattern of &quot;MM/dd/yy&quot; and a
<span class="line-modified"> 254  *         {@code SimpleDateFormat} instance created on Jan 1, 1997,  the string</span>
 255  *         &quot;01/11/12&quot; would be interpreted as Jan 11, 2012 while the string &quot;05/04/64&quot;
 256  *         would be interpreted as May 4, 1964.
 257  *         During parsing, only strings consisting of exactly two digits, as defined by
 258  *         {@link Character#isDigit(char)}, will be parsed into the default century.
 259  *         Any other numeric string, such as a one digit string, a three or more digit
 260  *         string, or a two digit string that isn&#39;t all digits (for example, &quot;-1&quot;), is
 261  *         interpreted literally.  So &quot;01/02/3&quot; or &quot;01/02/003&quot; are parsed, using the
 262  *         same pattern, as Jan 2, 3 AD.  Likewise, &quot;01/02/-3&quot; is parsed as Jan 2, 4 BC.
 263  *     &lt;/ul&gt;
 264  *     Otherwise, calendar system specific forms are applied.
 265  *     For both formatting and parsing, if the number of pattern
 266  *     letters is 4 or more, a calendar specific {@linkplain
 267  *     Calendar#LONG long form} is used. Otherwise, a calendar
 268  *     specific {@linkplain Calendar#SHORT short or abbreviated form}
 269  *     is used.&lt;br&gt;
 270  *     &lt;br&gt;
 271  *     If week year {@code &#39;Y&#39;} is specified and the {@linkplain
 272  *     #getCalendar() calendar} doesn&#39;t support any &lt;a
 273  *     href=&quot;../util/GregorianCalendar.html#week_year&quot;&gt; week
 274  *     years&lt;/a&gt;, the calendar year ({@code &#39;y&#39;}) is used instead. The
</pre>
<hr />
<pre>
 286  *         sense that when it is used in the standalone pattern, for example,
 287  *         &quot;MMMM&quot;, it gives the standalone form of a month name and when it is
 288  *         used in the pattern containing other field(s), for example, &quot;d MMMM&quot;,
 289  *         it gives the format form of a month name. For example, January in the
 290  *         Catalan language is &quot;de gener&quot; in the format form while it is &quot;gener&quot;
 291  *         in the standalone form. In this case, &quot;MMMM&quot; will produce &quot;gener&quot; and
 292  *         the month part of the &quot;d MMMM&quot; will produce &quot;de gener&quot;. If a
 293  *         {@code DateFormatSymbols} has been set explicitly with constructor
 294  *         {@link #SimpleDateFormat(String,DateFormatSymbols)} or method {@link
 295  *         #setDateFormatSymbols(DateFormatSymbols)}, the month names given by
 296  *         the {@code DateFormatSymbols} are used.&lt;/li&gt;
 297  *     &lt;li&gt;Letter &lt;em&gt;L&lt;/em&gt; produces the standalone form of month names.&lt;/li&gt;
 298  *     &lt;/ul&gt;
 299  *     &lt;br&gt;&lt;/li&gt;
 300  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;timezone&quot;&gt;General time zone:&lt;/a&gt;&lt;/strong&gt;
 301  *     Time zones are interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; if they have
 302  *     names. For time zones representing a GMT offset value, the
 303  *     following syntax is used:
 304  *     &lt;pre&gt;
 305  *     &lt;a id=&quot;GMTOffsetTimeZone&quot;&gt;&lt;i&gt;GMTOffsetTimeZone:&lt;/i&gt;&lt;/a&gt;
<span class="line-modified"> 306  *             {@code GMT} &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; {@code :} &lt;i&gt;Minutes&lt;/i&gt;</span>
 307  *     &lt;i&gt;Sign:&lt;/i&gt; one of
<span class="line-modified"> 308  *             {@code + -}</span>
 309  *     &lt;i&gt;Hours:&lt;/i&gt;
 310  *             &lt;i&gt;Digit&lt;/i&gt;
 311  *             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 312  *     &lt;i&gt;Minutes:&lt;/i&gt;
 313  *             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 314  *     &lt;i&gt;Digit:&lt;/i&gt; one of
<span class="line-modified"> 315  *             {@code 0 1 2 3 4 5 6 7 8 9}&lt;/pre&gt;</span>
 316  *     &lt;i&gt;Hours&lt;/i&gt; must be between 0 and 23, and &lt;i&gt;Minutes&lt;/i&gt; must be between
 317  *     00 and 59. The format is locale independent and digits must be taken
 318  *     from the Basic Latin block of the Unicode standard.
 319  *     &lt;p&gt;For parsing, &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt; are also
 320  *     accepted.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 321  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;rfc822timezone&quot;&gt;RFC 822 time zone:&lt;/a&gt;&lt;/strong&gt;
 322  *     For formatting, the RFC 822 4-digit time zone format is used:
 323  *
 324  *     &lt;pre&gt;
 325  *     &lt;i&gt;RFC822TimeZone:&lt;/i&gt;
 326  *             &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
 327  *     &lt;i&gt;TwoDigitHours:&lt;/i&gt;
 328  *             &lt;i&gt;Digit Digit&lt;/i&gt;&lt;/pre&gt;
 329  *     &lt;i&gt;TwoDigitHours&lt;/i&gt; must be between 00 and 23. Other definitions
 330  *     are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt;.
 331  *
 332  *     &lt;p&gt;For parsing, &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; are also
 333  *     accepted.
 334  * &lt;li&gt;&lt;strong&gt;&lt;a id=&quot;iso8601timezone&quot;&gt;ISO 8601 Time zone:&lt;/a&gt;&lt;/strong&gt;
 335  *     The number of pattern letters designates the format for both formatting
</pre>
<hr />
<pre>
 347  *             {@code Z}
 348  *     &lt;i&gt;ThreeLetterISO8601TimeZone:&lt;/i&gt;
 349  *             &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; {@code :} &lt;i&gt;Minutes&lt;/i&gt;
 350  *             {@code Z}&lt;/pre&gt;
 351  *     Other definitions are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; or
 352  *     &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt;.
 353  *
 354  *     &lt;p&gt;For formatting, if the offset value from GMT is 0, {@code &quot;Z&quot;} is
 355  *     produced. If the number of pattern letters is 1, any fraction of an hour
 356  *     is ignored. For example, if the pattern is {@code &quot;X&quot;} and the time zone is
 357  *     {@code &quot;GMT+05:30&quot;}, {@code &quot;+05&quot;} is produced.
 358  *
 359  *     &lt;p&gt;For parsing, {@code &quot;Z&quot;} is parsed as the UTC time zone designator.
 360  *     &lt;a href=&quot;#timezone&quot;&gt;General time zones&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; accepted.
 361  *
 362  *     &lt;p&gt;If the number of pattern letters is 4 or more, {@link
 363  *     IllegalArgumentException} is thrown when constructing a {@code
 364  *     SimpleDateFormat} or {@linkplain #applyPattern(String) applying a
 365  *     pattern}.
 366  * &lt;/ul&gt;
<span class="line-modified"> 367  * {@code SimpleDateFormat} also supports &lt;em&gt;localized date and time</span>
 368  * pattern&lt;/em&gt; strings. In these strings, the pattern letters described above
 369  * may be replaced with other, locale dependent, pattern letters.
<span class="line-modified"> 370  * {@code SimpleDateFormat} does not deal with the localization of text</span>
 371  * other than the pattern letters; that&#39;s up to the client of the class.
 372  *
<span class="line-modified"> 373  * &lt;h3&gt;Examples&lt;/h3&gt;</span>
 374  *
 375  * The following examples show how date and time patterns are interpreted in
 376  * the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time
 377  * in the U.S. Pacific Time time zone.
 378  * &lt;blockquote&gt;
 379  * &lt;table class=&quot;striped&quot;&gt;
 380  * &lt;caption style=&quot;display:none&quot;&gt;Examples of date and time patterns interpreted in the U.S. locale&lt;/caption&gt;
 381  * &lt;thead&gt;
 382  *     &lt;tr&gt;
 383  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Date and Time Pattern
 384  *         &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Result
 385  * &lt;/thead&gt;
 386  * &lt;tbody&gt;
 387  *     &lt;tr&gt;
<span class="line-modified"> 388  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;yyyy.MM.dd G &#39;at&#39; HH:mm:ss z&quot;}</span>
<span class="line-modified"> 389  *         &lt;td&gt;{@code 2001.07.04 AD at 12:08:56 PDT}</span>
 390  *     &lt;tr&gt;
<span class="line-modified"> 391  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;EEE, MMM d, &#39;&#39;yy&quot;}</span>
<span class="line-modified"> 392  *         &lt;td&gt;{@code Wed, Jul 4, &#39;01}</span>
 393  *     &lt;tr&gt;
<span class="line-modified"> 394  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;h:mm a&quot;}</span>
<span class="line-modified"> 395  *         &lt;td&gt;{@code 12:08 PM}</span>
 396  *     &lt;tr&gt;
<span class="line-modified"> 397  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;hh &#39;o&#39;&#39;clock&#39; a, zzzz&quot;}</span>
<span class="line-modified"> 398  *         &lt;td&gt;{@code 12 o&#39;clock PM, Pacific Daylight Time}</span>
 399  *     &lt;tr&gt;
<span class="line-modified"> 400  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;K:mm a, z&quot;}</span>
<span class="line-modified"> 401  *         &lt;td&gt;{@code 0:08 PM, PDT}</span>
 402  *     &lt;tr&gt;
<span class="line-modified"> 403  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;}</span>
<span class="line-modified"> 404  *         &lt;td&gt;{@code 02001.July.04 AD 12:08 PM}</span>
 405  *     &lt;tr&gt;
<span class="line-modified"> 406  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;EEE, d MMM yyyy HH:mm:ss Z&quot;}</span>
<span class="line-modified"> 407  *         &lt;td&gt;{@code Wed, 4 Jul 2001 12:08:56 -0700}</span>
 408  *     &lt;tr&gt;
<span class="line-modified"> 409  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;yyMMddHHmmssZ&quot;}</span>
<span class="line-modified"> 410  *         &lt;td&gt;{@code 010704120856-0700}</span>
 411  *     &lt;tr&gt;
<span class="line-modified"> 412  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;}</span>
<span class="line-modified"> 413  *         &lt;td&gt;{@code 2001-07-04T12:08:56.235-0700}</span>
 414  *     &lt;tr&gt;
<span class="line-modified"> 415  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX&quot;}</span>
<span class="line-modified"> 416  *         &lt;td&gt;{@code 2001-07-04T12:08:56.235-07:00}</span>
 417  *     &lt;tr&gt;
<span class="line-modified"> 418  *         &lt;th scope=&quot;row&quot;&gt;{@code &quot;YYYY-&#39;W&#39;ww-u&quot;}</span>
<span class="line-modified"> 419  *         &lt;td&gt;{@code 2001-W27-3}</span>
 420  * &lt;/tbody&gt;
 421  * &lt;/table&gt;
 422  * &lt;/blockquote&gt;
 423  *
<span class="line-modified"> 424  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
 425  *
 426  * &lt;p&gt;
 427  * Date formats are not synchronized.
 428  * It is recommended to create separate format instances for each thread.
 429  * If multiple threads access a format concurrently, it must be synchronized
 430  * externally.
 431  *
 432  * @see          &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/i18n/format/simpleDateFormat.html&quot;&gt;Java Tutorial&lt;/a&gt;
 433  * @see          java.util.Calendar
 434  * @see          java.util.TimeZone
 435  * @see          DateFormat
 436  * @see          DateFormatSymbols
 437  * @author       Mark Davis, Chen-Lieh Huang, Alan Liu
 438  * @since 1.1
 439  */
 440 public class SimpleDateFormat extends DateFormat {
 441 
 442     // the official serial version ID which says cryptically
 443     // which version we&#39;re compatible with
<span class="line-added"> 444     @java.io.Serial</span>
 445     static final long serialVersionUID = 4774881970558875024L;
 446 
 447     // the internal serial version which says which version was written
 448     // - 0 (default) for version up to JDK 1.1.3
 449     // - 1 for version from JDK 1.1.4, which includes a new field
 450     static final int currentSerialVersion = 1;
 451 
 452     /**
 453      * The version of the serialized data on the stream.  Possible values:
 454      * &lt;ul&gt;
 455      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream: JDK 1.1.3.  This version
<span class="line-modified"> 456      * has no {@code defaultCenturyStart} on stream.</span>
 457      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt; JDK 1.1.4 or later.  This version adds
<span class="line-modified"> 458      * {@code defaultCenturyStart}.</span>
 459      * &lt;/ul&gt;
 460      * When streaming out this class, the most recent format
<span class="line-modified"> 461      * and the highest allowable {@code serialVersionOnStream}</span>
 462      * is written.
 463      * @serial
 464      * @since 1.1.4
 465      */
 466     private int serialVersionOnStream = currentSerialVersion;
 467 
 468     /**
 469      * The pattern string of this formatter.  This is always a non-localized
 470      * pattern.  May not be null.  See class documentation for details.
 471      * @serial
 472      */
 473     private String pattern;
 474 
 475     /**
 476      * Saved numberFormat and pattern.
 477      * @see SimpleDateFormat#checkNegativeNumberExpression
 478      */
 479     private transient NumberFormat originalNumberFormat;
 480     private transient String originalNumberPattern;
 481 
</pre>
<hr />
<pre>
 506     private static final int TAG_QUOTE_ASCII_CHAR       = 100;
 507     private static final int TAG_QUOTE_CHARS            = 101;
 508 
 509     /**
 510      * Locale dependent digit zero.
 511      * @see #zeroPaddingNumber
 512      * @see java.text.DecimalFormatSymbols#getZeroDigit
 513      */
 514     private transient char zeroDigit;
 515 
 516     /**
 517      * The symbols used by this formatter for week names, month names,
 518      * etc.  May not be null.
 519      * @serial
 520      * @see java.text.DateFormatSymbols
 521      */
 522     private DateFormatSymbols formatData;
 523 
 524     /**
 525      * We map dates with two-digit years into the century starting at
<span class="line-modified"> 526      * {@code defaultCenturyStart}, which may be any date.  May</span>
 527      * not be null.
 528      * @serial
 529      * @since 1.1.4
 530      */
 531     private Date defaultCenturyStart;
 532 
 533     private transient int defaultCenturyStartYear;
 534 
 535     private static final int MILLIS_PER_MINUTE = 60 * 1000;
 536 
 537     // For time zones that have no names, use strings GMT+minutes and
 538     // GMT-minutes. For instance, in France the time zone is GMT+60.
 539     private static final String GMT = &quot;GMT&quot;;
 540 
 541     /**
 542      * Cache NumberFormat instances with Locale key.
 543      */
 544     private static final ConcurrentMap&lt;Locale, NumberFormat&gt; cachedNumberFormatData
 545         = new ConcurrentHashMap&lt;&gt;(3);
 546 
 547     /**
 548      * The Locale used to instantiate this
<span class="line-modified"> 549      * {@code SimpleDateFormat}. The value may be null if this object</span>
<span class="line-modified"> 550      * has been created by an older {@code SimpleDateFormat} and</span>
 551      * deserialized.
 552      *
 553      * @serial
 554      * @since 1.6
 555      */
 556     private Locale locale;
 557 
 558     /**
<span class="line-modified"> 559      * Indicates whether this {@code SimpleDateFormat} should use</span>
 560      * the DateFormatSymbols. If true, the format and parse methods
 561      * use the DateFormatSymbols values. If false, the format and
 562      * parse methods call Calendar.getDisplayName or
 563      * Calendar.getDisplayNames.
 564      */
 565     transient boolean useDateFormatSymbols;
 566 
 567     /**
<span class="line-modified"> 568      * Constructs a {@code SimpleDateFormat} using the default pattern and</span>
 569      * date format symbols for the default
 570      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 571      * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
 572      * For full coverage, use the factory methods in the {@link DateFormat}
 573      * class.
 574      */
 575     public SimpleDateFormat() {
 576         this(&quot;&quot;, Locale.getDefault(Locale.Category.FORMAT));
 577         applyPatternImpl(LocaleProviderAdapter.getResourceBundleBased().getLocaleResources(locale)
 578                          .getDateTimePattern(SHORT, SHORT, calendar));
 579     }
 580 
 581     /**
<span class="line-modified"> 582      * Constructs a {@code SimpleDateFormat} using the given pattern and</span>
 583      * the default date format symbols for the default
 584      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
 585      * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
 586      * For full coverage, use the factory methods in the {@link DateFormat}
 587      * class.
 588      * &lt;p&gt;This is equivalent to calling
 589      * {@link #SimpleDateFormat(String, Locale)
 590      *     SimpleDateFormat(pattern, Locale.getDefault(Locale.Category.FORMAT))}.
 591      *
 592      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 593      * @see java.util.Locale.Category#FORMAT
 594      * @param pattern the pattern describing the date and time format
<span class="line-modified"> 595      * @throws    NullPointerException if the given pattern is null</span>
<span class="line-modified"> 596      * @throws    IllegalArgumentException if the given pattern is invalid</span>
 597      */
 598     public SimpleDateFormat(String pattern)
 599     {
 600         this(pattern, Locale.getDefault(Locale.Category.FORMAT));
 601     }
 602 
 603     /**
<span class="line-modified"> 604      * Constructs a {@code SimpleDateFormat} using the given pattern and</span>
 605      * the default date format symbols for the given locale.
 606      * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
 607      * For full coverage, use the factory methods in the {@link DateFormat}
 608      * class.
 609      *
 610      * @param pattern the pattern describing the date and time format
 611      * @param locale the locale whose date format symbols should be used
<span class="line-modified"> 612      * @throws    NullPointerException if the given pattern or locale is null</span>
<span class="line-modified"> 613      * @throws    IllegalArgumentException if the given pattern is invalid</span>
 614      */
 615     public SimpleDateFormat(String pattern, Locale locale)
 616     {
 617         if (pattern == null || locale == null) {
 618             throw new NullPointerException();
 619         }
 620 
 621         initializeCalendar(locale);
 622         this.pattern = pattern;
 623         this.formatData = DateFormatSymbols.getInstanceRef(locale);
 624         this.locale = locale;
 625         initialize(locale);
 626     }
 627 
 628     /**
<span class="line-modified"> 629      * Constructs a {@code SimpleDateFormat} using the given pattern and</span>
 630      * date format symbols.
 631      *
 632      * @param pattern the pattern describing the date and time format
 633      * @param formatSymbols the date format symbols to be used for formatting
<span class="line-modified"> 634      * @throws    NullPointerException if the given pattern or formatSymbols is null</span>
<span class="line-modified"> 635      * @throws    IllegalArgumentException if the given pattern is invalid</span>
 636      */
 637     public SimpleDateFormat(String pattern, DateFormatSymbols formatSymbols)
 638     {
 639         if (pattern == null || formatSymbols == null) {
 640             throw new NullPointerException();
 641         }
 642 
 643         this.pattern = pattern;
 644         this.formatData = (DateFormatSymbols) formatSymbols.clone();
 645         this.locale = Locale.getDefault(Locale.Category.FORMAT);
 646         initializeCalendar(this.locale);
 647         initialize(this.locale);
 648         useDateFormatSymbols = true;
 649     }
 650 
 651     /* Initialize compiledPattern and numberFormat fields */
 652     private void initialize(Locale loc) {
 653         // Verify and compile the given pattern.
 654         compiledPattern = compile(pattern);
 655 
</pre>
<hr />
<pre>
 722      * &lt;blockquote&gt;
 723      *     char[0] = (Tag &lt;&lt; 8) | 255;
 724      *     char[1] = (char) (long_length &gt;&gt;&gt; 16);
 725      *     char[2] = (char) (long_length &amp; 0xffff);
 726      * &lt;/blockquote&gt;
 727      * &lt;p&gt;
 728      * If Tag is a pattern_char_index, its Length is the number of
 729      * pattern characters. For example, if the given pattern is
 730      * &quot;yyyy&quot;, Tag is 1 and Length is 4, followed by no data.
 731      * &lt;p&gt;
 732      * If Tag is TAG_QUOTE_CHARS, its Length is the number of char&#39;s
 733      * following the TagField. For example, if the given pattern is
 734      * &quot;&#39;o&#39;&#39;clock&#39;&quot;, Length is 7 followed by a char sequence of
 735      * &lt;code&gt;o&amp;nbs;&#39;&amp;nbs;c&amp;nbs;l&amp;nbs;o&amp;nbs;c&amp;nbs;k&lt;/code&gt;.
 736      * &lt;p&gt;
 737      * TAG_QUOTE_ASCII_CHAR is a special tag and has an ASCII
 738      * character in place of Length. For example, if the given pattern
 739      * is &quot;&#39;o&#39;&quot;, the TaggedData entry is
 740      * &lt;code&gt;((TAG_QUOTE_ASCII_CHAR&amp;nbs;&lt;&lt;&amp;nbs;8)&amp;nbs;|&amp;nbs;&#39;o&#39;)&lt;/code&gt;.
 741      *
<span class="line-modified"> 742      * @throws    NullPointerException if the given pattern is null</span>
<span class="line-modified"> 743      * @throws    IllegalArgumentException if the given pattern is invalid</span>
 744      */
 745     private char[] compile(String pattern) {
 746         int length = pattern.length();
 747         boolean inQuote = false;
 748         StringBuilder compiledCode = new StringBuilder(length * 2);
 749         StringBuilder tmpBuffer = null;
 750         int count = 0, tagcount = 0;
 751         int lastTag = -1, prevTag = -1;
 752 
 753         for (int i = 0; i &lt; length; i++) {
 754             char c = pattern.charAt(i);
 755 
 756             if (c == &#39;\&#39;&#39;) {
 757                 // &#39;&#39; is treated as a single quote regardless of being
 758                 // in a quoted section.
 759                 if ((i + 1) &lt; length) {
 760                     c = pattern.charAt(i + 1);
 761                     if (c == &#39;\&#39;&#39;) {
 762                         i++;
 763                         if (count != 0) {
</pre>
<hr />
<pre>
 899     private void initializeDefaultCentury() {
 900         calendar.setTimeInMillis(System.currentTimeMillis());
 901         calendar.add( Calendar.YEAR, -80 );
 902         parseAmbiguousDatesAsAfter(calendar.getTime());
 903     }
 904 
 905     /* Define one-century window into which to disambiguate dates using
 906      * two-digit years.
 907      */
 908     private void parseAmbiguousDatesAsAfter(Date startDate) {
 909         defaultCenturyStart = startDate;
 910         calendar.setTime(startDate);
 911         defaultCenturyStartYear = calendar.get(Calendar.YEAR);
 912     }
 913 
 914     /**
 915      * Sets the 100-year period 2-digit years will be interpreted as being in
 916      * to begin on the date the user specifies.
 917      *
 918      * @param startDate During parsing, two digit years will be placed in the range
<span class="line-modified"> 919      * {@code startDate} to {@code startDate + 100 years}.</span>
 920      * @see #get2DigitYearStart
 921      * @throws NullPointerException if {@code startDate} is {@code null}.
 922      * @since 1.2
 923      */
 924     public void set2DigitYearStart(Date startDate) {
 925         parseAmbiguousDatesAsAfter(new Date(startDate.getTime()));
 926     }
 927 
 928     /**
 929      * Returns the beginning date of the 100-year period 2-digit years are interpreted
 930      * as being within.
 931      *
 932      * @return the start of the 100-year period into which two digit years are
 933      * parsed
 934      * @see #set2DigitYearStart
 935      * @since 1.2
 936      */
 937     public Date get2DigitYearStart() {
 938         return (Date) defaultCenturyStart.clone();
 939     }
 940 
 941     /**
<span class="line-modified"> 942      * Formats the given {@code Date} into a date/time string and appends</span>
<span class="line-modified"> 943      * the result to the given {@code StringBuffer}.</span>
 944      *
 945      * @param date the date-time value to be formatted into a date-time string.
 946      * @param toAppendTo where the new date-time text is to be appended.
 947      * @param pos keeps track on the position of the field within
 948      * the returned string. For example, given a date-time text
 949      * {@code &quot;1996.07.10 AD at 15:08:56 PDT&quot;}, if the given {@code fieldPosition}
 950      * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of
 951      * {@code fieldPosition} will be set to 0 and 4, respectively.
 952      * Notice that if the same date-time field appears more than once in a
 953      * pattern, the {@code fieldPosition} will be set for the first occurrence
 954      * of that date-time field. For instance, formatting a {@code Date} to the
 955      * date-time string {@code &quot;1 PM PDT (Pacific Daylight Time)&quot;} using the
 956      * pattern {@code &quot;h a z (zzzz)&quot;} and the alignment field
 957      * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of
 958      * {@code fieldPosition} will be set to 5 and 8, respectively, for the
 959      * first occurrence of the timezone pattern character {@code &#39;z&#39;}.
 960      * @return the formatted date-time string.
<span class="line-modified"> 961      * @throws    NullPointerException if any of the parameters is {@code null}.</span>
 962      */
 963     @Override
 964     public StringBuffer format(Date date, StringBuffer toAppendTo,
 965                                FieldPosition pos)
 966     {
 967         pos.beginIndex = pos.endIndex = 0;
 968         return format(date, toAppendTo, pos.getFieldDelegate());
 969     }
 970 
 971     // Called from Format after creating a FieldDelegate
 972     private StringBuffer format(Date date, StringBuffer toAppendTo,
 973                                 FieldDelegate delegate) {
 974         // Convert input date to time field list
 975         calendar.setTime(date);
 976 
 977         boolean useDateFormatSymbols = useDateFormatSymbols();
 978 
 979         for (int i = 0; i &lt; compiledPattern.length; ) {
 980             int tag = compiledPattern[i] &gt;&gt;&gt; 8;
 981             int count = compiledPattern[i++] &amp; 0xff;
</pre>
<hr />
<pre>
 986 
 987             switch (tag) {
 988             case TAG_QUOTE_ASCII_CHAR:
 989                 toAppendTo.append((char)count);
 990                 break;
 991 
 992             case TAG_QUOTE_CHARS:
 993                 toAppendTo.append(compiledPattern, i, count);
 994                 i += count;
 995                 break;
 996 
 997             default:
 998                 subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);
 999                 break;
1000             }
1001         }
1002         return toAppendTo;
1003     }
1004 
1005     /**
<span class="line-modified">1006      * Formats an Object producing an {@code AttributedCharacterIterator}.</span>
<span class="line-modified">1007      * You can use the returned {@code AttributedCharacterIterator}</span>
1008      * to build the resulting String, as well as to determine information
1009      * about the resulting String.
1010      * &lt;p&gt;
1011      * Each attribute key of the AttributedCharacterIterator will be of type
<span class="line-modified">1012      * {@code DateFormat.Field}, with the corresponding attribute value</span>
1013      * being the same as the attribute key.
1014      *
<span class="line-modified">1015      * @throws    NullPointerException if obj is null.</span>
<span class="line-modified">1016      * @throws    IllegalArgumentException if the Format cannot format the</span>
1017      *            given object, or if the Format&#39;s pattern string is invalid.
1018      * @param obj The object to format
1019      * @return AttributedCharacterIterator describing the formatted value.
1020      * @since 1.4
1021      */
1022     @Override
1023     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
1024         StringBuffer sb = new StringBuffer();
1025         CharacterIteratorFieldDelegate delegate = new
1026                          CharacterIteratorFieldDelegate();
1027 
1028         if (obj instanceof Date) {
1029             format((Date)obj, sb, delegate);
1030         }
1031         else if (obj instanceof Number) {
1032             format(new Date(((Number)obj).longValue()), sb, delegate);
1033         }
1034         else if (obj == null) {
1035             throw new NullPointerException(
1036                    &quot;formatToCharacterIterator must be passed non-null object&quot;);
</pre>
<hr />
<pre>
1410                         buffer.append((char)(zeroDigit + value / 10));
1411                         buffer.append((char)(zeroDigit + value % 10));
1412                         return;
1413                     }
1414                     if (minDigits == 2 &amp;&amp; maxDigits == 2) {
1415                         zeroPaddingNumber(value % 100, 2, 2, buffer);
1416                         return;
1417                     }
1418                 }
1419             }
1420         } catch (Exception e) {
1421         }
1422 
1423         numberFormat.setMinimumIntegerDigits(minDigits);
1424         numberFormat.setMaximumIntegerDigits(maxDigits);
1425         numberFormat.format((long)value, buffer, DontCareFieldPosition.INSTANCE);
1426     }
1427 
1428 
1429     /**
<span class="line-modified">1430      * Parses text from a string to produce a {@code Date}.</span>
1431      * &lt;p&gt;
1432      * The method attempts to parse text starting at the index given by
<span class="line-modified">1433      * {@code pos}.</span>
<span class="line-modified">1434      * If parsing succeeds, then the index of {@code pos} is updated</span>
1435      * to the index after the last character used (parsing does not necessarily
1436      * use all characters up to the end of the string), and the parsed
<span class="line-modified">1437      * date is returned. The updated {@code pos} can be used to</span>
1438      * indicate the starting point for the next call to this method.
<span class="line-modified">1439      * If an error occurs, then the index of {@code pos} is not</span>
<span class="line-modified">1440      * changed, the error index of {@code pos} is set to the index of</span>
1441      * the character where the error occurred, and null is returned.
1442      *
1443      * &lt;p&gt;This parsing operation uses the {@link DateFormat#calendar
1444      * calendar} to produce a {@code Date}. All of the {@code
1445      * calendar}&#39;s date-time fields are {@linkplain Calendar#clear()
1446      * cleared} before parsing, and the {@code calendar}&#39;s default
1447      * values of the date-time fields are used for any missing
1448      * date-time information. For example, the year value of the
1449      * parsed {@code Date} is 1970 with {@link GregorianCalendar} if
1450      * no year value is given from the parsing operation.  The {@code
1451      * TimeZone} value may be overwritten, depending on the given
1452      * pattern and the time zone value in {@code text}. Any {@code
1453      * TimeZone} value that has previously been set by a call to
1454      * {@link #setTimeZone(java.util.TimeZone) setTimeZone} may need
1455      * to be restored for further operations.
1456      *
<span class="line-modified">1457      * @param text  A {@code String}, part of which should be parsed.</span>
<span class="line-modified">1458      * @param pos   A {@code ParsePosition} object with index and error</span>
1459      *              index information as described above.
<span class="line-modified">1460      * @return A {@code Date} parsed from the string. In case of</span>
1461      *         error, returns null.
<span class="line-modified">1462      * @throws    NullPointerException if {@code text} or {@code pos} is null.</span>
1463      */
1464     @Override
1465     public Date parse(String text, ParsePosition pos)
1466     {
1467         checkNegativeNumberExpression();
1468 
1469         int start = pos.index;
1470         int oldStart = start;
1471         int textLength = text.length();
1472 
1473         boolean[] ambiguousYear = {false};
1474 
1475         CalendarBuilder calb = new CalendarBuilder();
1476 
1477         for (int i = 0; i &lt; compiledPattern.length; ) {
1478             int tag = compiledPattern[i] &gt;&gt;&gt; 8;
1479             int count = compiledPattern[i++] &amp; 0xff;
1480             if (count == 255) {
1481                 count = compiledPattern[i++] &lt;&lt; 16;
1482                 count |= compiledPattern[i++];
</pre>
<hr />
<pre>
2259             }
2260         }
2261 
2262         // Parsing failed.
2263         origPos.errorIndex = pos.index;
2264         return -1;
2265     }
2266 
2267     /**
2268      * Returns true if the DateFormatSymbols has been set explicitly or locale
2269      * is null.
2270      */
2271     private boolean useDateFormatSymbols() {
2272         return useDateFormatSymbols || locale == null;
2273     }
2274 
2275     /**
2276      * Translates a pattern, mapping each character in the from string to the
2277      * corresponding character in the to string.
2278      *
<span class="line-modified">2279      * @throws    IllegalArgumentException if the given pattern is invalid</span>
2280      */
2281     private String translatePattern(String pattern, String from, String to) {
2282         StringBuilder result = new StringBuilder();
2283         boolean inQuote = false;
2284         for (int i = 0; i &lt; pattern.length(); ++i) {
2285             char c = pattern.charAt(i);
2286             if (inQuote) {
2287                 if (c == &#39;\&#39;&#39;) {
2288                     inQuote = false;
2289                 }
2290             }
2291             else {
2292                 if (c == &#39;\&#39;&#39;) {
2293                     inQuote = true;
2294                 } else if ((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)) {
2295                     int ci = from.indexOf(c);
2296                     if (ci &gt;= 0) {
2297                         // patternChars is longer than localPatternChars due
2298                         // to serialization compatibility. The pattern letters
2299                         // unsupported by localPatternChars pass through.
</pre>
<hr />
<pre>
2322      */
2323     public String toPattern() {
2324         return pattern;
2325     }
2326 
2327     /**
2328      * Returns a localized pattern string describing this date format.
2329      *
2330      * @return a localized pattern string describing this date format.
2331      */
2332     public String toLocalizedPattern() {
2333         return translatePattern(pattern,
2334                                 DateFormatSymbols.patternChars,
2335                                 formatData.getLocalPatternChars());
2336     }
2337 
2338     /**
2339      * Applies the given pattern string to this date format.
2340      *
2341      * @param pattern the new date and time pattern for this date format
<span class="line-modified">2342      * @throws    NullPointerException if the given pattern is null</span>
<span class="line-modified">2343      * @throws    IllegalArgumentException if the given pattern is invalid</span>
2344      */
2345     public void applyPattern(String pattern)
2346     {
2347         applyPatternImpl(pattern);
2348     }
2349 
2350     private void applyPatternImpl(String pattern) {
2351         compiledPattern = compile(pattern);
2352         this.pattern = pattern;
2353     }
2354 
2355     /**
2356      * Applies the given localized pattern string to this date format.
2357      *
2358      * @param pattern a String to be mapped to the new date and time format
2359      *        pattern for this format
<span class="line-modified">2360      * @throws    NullPointerException if the given pattern is null</span>
<span class="line-modified">2361      * @throws    IllegalArgumentException if the given pattern is invalid</span>
2362      */
2363     public void applyLocalizedPattern(String pattern) {
2364          String p = translatePattern(pattern,
2365                                      formatData.getLocalPatternChars(),
2366                                      DateFormatSymbols.patternChars);
2367          compiledPattern = compile(p);
2368          this.pattern = p;
2369     }
2370 
2371     /**
2372      * Gets a copy of the date and time format symbols of this date format.
2373      *
2374      * @return the date and time format symbols of this date format
2375      * @see #setDateFormatSymbols
2376      */
2377     public DateFormatSymbols getDateFormatSymbols()
2378     {
2379         return (DateFormatSymbols)formatData.clone();
2380     }
2381 
2382     /**
2383      * Sets the date and time format symbols of this date format.
2384      *
2385      * @param newFormatSymbols the new date and time format symbols
<span class="line-modified">2386      * @throws    NullPointerException if the given newFormatSymbols is null</span>
2387      * @see #getDateFormatSymbols
2388      */
2389     public void setDateFormatSymbols(DateFormatSymbols newFormatSymbols)
2390     {
2391         this.formatData = (DateFormatSymbols)newFormatSymbols.clone();
2392         useDateFormatSymbols = true;
2393     }
2394 
2395     /**
<span class="line-modified">2396      * Creates a copy of this {@code SimpleDateFormat}. This also</span>
2397      * clones the format&#39;s date format symbols.
2398      *
<span class="line-modified">2399      * @return a clone of this {@code SimpleDateFormat}</span>
2400      */
2401     @Override
2402     public Object clone() {
2403         SimpleDateFormat other = (SimpleDateFormat) super.clone();
2404         other.formatData = (DateFormatSymbols) formatData.clone();
2405         return other;
2406     }
2407 
2408     /**
<span class="line-modified">2409      * Returns the hash code value for this {@code SimpleDateFormat} object.</span>
2410      *
<span class="line-modified">2411      * @return the hash code value for this {@code SimpleDateFormat} object.</span>
2412      */
2413     @Override
2414     public int hashCode()
2415     {
2416         return pattern.hashCode();
2417         // just enough fields for a reasonable distribution
2418     }
2419 
2420     /**
<span class="line-modified">2421      * Compares the given object with this {@code SimpleDateFormat} for</span>
2422      * equality.
2423      *
2424      * @return true if the given object is equal to this
<span class="line-modified">2425      * {@code SimpleDateFormat}</span>
2426      */
2427     @Override
2428     public boolean equals(Object obj)
2429     {
2430         if (!super.equals(obj)) {
2431             return false; // super does class check
2432         }
2433         SimpleDateFormat that = (SimpleDateFormat) obj;
2434         return (pattern.equals(that.pattern)
2435                 &amp;&amp; formatData.equals(that.formatData));
2436     }
2437 
2438     private static final int[] REST_OF_STYLES = {
2439         Calendar.SHORT_STANDALONE, Calendar.LONG_FORMAT, Calendar.LONG_STANDALONE,
2440     };
2441     private Map&lt;String, Integer&gt; getDisplayNamesMap(int field, Locale locale) {
2442         Map&lt;String, Integer&gt; map = calendar.getDisplayNames(field, Calendar.SHORT_FORMAT, locale);
2443         // Get all SHORT and LONG styles (avoid NARROW styles).
2444         for (int style : REST_OF_STYLES) {
2445             Map&lt;String, Integer&gt; m = calendar.getDisplayNames(field, style, locale);
</pre>
<hr />
<pre>
2453     /**
2454      * Obtains display names map, taking the context into account. Currently only
2455      * the month name pattern &#39;M&#39; is context dependent.
2456      */
2457     private Map&lt;String, Integer&gt; getDisplayContextNamesMap(int field, Locale locale) {
2458         Map&lt;String, Integer&gt; map = calendar.getDisplayNames(field,
2459             forceStandaloneForm ? Calendar.SHORT_STANDALONE : Calendar.SHORT_FORMAT, locale);
2460         // Get the LONG style
2461         Map&lt;String, Integer&gt; m = calendar.getDisplayNames(field,
2462             forceStandaloneForm ? Calendar.LONG_STANDALONE : Calendar.LONG_FORMAT, locale);
2463         if (m != null) {
2464             map.putAll(m);
2465         }
2466         return map;
2467     }
2468 
2469     /**
2470      * After reading an object from the input stream, the format
2471      * pattern in the object is verified.
2472      *
<span class="line-modified">2473      * @throws    InvalidObjectException if the pattern is invalid</span>
2474      */
<span class="line-added">2475     @java.io.Serial</span>
2476     private void readObject(ObjectInputStream stream)
2477                          throws IOException, ClassNotFoundException {
2478         stream.defaultReadObject();
2479 
2480         try {
2481             compiledPattern = compile(pattern);
2482         } catch (Exception e) {
2483             throw new InvalidObjectException(&quot;invalid pattern&quot;);
2484         }
2485 
2486         if (serialVersionOnStream &lt; 1) {
2487             // didn&#39;t have defaultCenturyStart field
2488             initializeDefaultCentury();
2489         }
2490         else {
2491             // fill in dependent transient field
2492             parseAmbiguousDatesAsAfter(defaultCenturyStart);
2493         }
2494         serialVersionOnStream = currentSerialVersion;
2495 
</pre>
</td>
</tr>
</table>
<center><a href="RuleBasedCollator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringCharacterIterator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/AbstractPlainDatagramSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../math/MathContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AbstractPlainSocketImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/AbstractPlainDatagramSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
 26 
 27 import java.io.FileDescriptor;
 28 import java.io.IOException;
 29 import java.util.Collections;
 30 import java.util.HashSet;

 31 import java.util.Set;
 32 
 33 import sun.net.ResourceManager;


 34 import sun.security.action.GetPropertyAction;
 35 
 36 /**
 37  * Abstract datagram and multicast socket implementation base class.
 38  * Note: This is not a public class, so that applets cannot call
 39  * into the implementation directly and hence cannot bypass the
 40  * security checks present in the DatagramSocket and MulticastSocket
 41  * classes.
 42  *
 43  * @author Pavani Diwanji
 44  */
 45 
 46 abstract class AbstractPlainDatagramSocketImpl extends DatagramSocketImpl
 47 {
 48     /* timeout value for receive() */
 49     int timeout = 0;
 50     boolean connected = false;
 51     private int trafficClass = 0;
 52     protected InetAddress connectedAddress = null;
 53     private int connectedPort = -1;

 54 
 55     private static final String os =
 56             GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
 57 
 58     /**
 59      * flag set if the native connect() call not to be used
 60      */
 61     private static final boolean connectDisabled = os.contains(&quot;OS X&quot;);
 62 
 63     /**
 64      * Load net library into runtime.
 65      */
 66     static {
<span class="line-modified"> 67         java.security.AccessController.doPrivileged(</span>
<span class="line-removed"> 68             new java.security.PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed"> 69                 public Void run() {</span>
<span class="line-removed"> 70                     System.loadLibrary(&quot;net&quot;);</span>
<span class="line-removed"> 71                     return null;</span>
<span class="line-removed"> 72                 }</span>
<span class="line-removed"> 73             });</span>
 74     }
 75 
 76     private static volatile boolean checkedReusePort;
 77     private static volatile boolean isReusePortAvailable;
 78 
 79     /**
 80      * Tells whether SO_REUSEPORT is supported.
 81      */
 82     static boolean isReusePortAvailable() {
 83         if (!checkedReusePort) {
 84             isReusePortAvailable = isReusePortAvailable0();
 85             checkedReusePort = true;
 86         }
 87         return isReusePortAvailable;
 88     }
 89 
<span class="line-modified"> 90     /**</span>
<span class="line-modified"> 91      * Returns a set of SocketOptions supported by this impl and by this impl&#39;s</span>
<span class="line-removed"> 92      * socket (Socket or ServerSocket)</span>
<span class="line-removed"> 93      *</span>
<span class="line-removed"> 94      * @return a Set of SocketOptions</span>
<span class="line-removed"> 95      */</span>
<span class="line-removed"> 96     @Override</span>
<span class="line-removed"> 97     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-removed"> 98         Set&lt;SocketOption&lt;?&gt;&gt; options;</span>
<span class="line-removed"> 99         if (isReusePortAvailable()) {</span>
<span class="line-removed">100             options = new HashSet&lt;&gt;();</span>
<span class="line-removed">101             options.addAll(super.supportedOptions());</span>
<span class="line-removed">102             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-removed">103             options = Collections.unmodifiableSet(options);</span>
<span class="line-removed">104         } else {</span>
<span class="line-removed">105             options = super.supportedOptions();</span>
<span class="line-removed">106         }</span>
<span class="line-removed">107         return options;</span>
108     }
109 
110     /**
111      * Creates a datagram socket
112      */
113     protected synchronized void create() throws SocketException {
114         ResourceManager.beforeUdpCreate();
115         fd = new FileDescriptor();
116         try {
117             datagramSocketCreate();
<span class="line-modified">118             SocketCleanable.register(fd);</span>
119         } catch (SocketException ioe) {
120             ResourceManager.afterUdpClose();
121             fd = null;
122             throw ioe;
123         }
124     }
125 
126     /**
127      * Binds a datagram socket to a local port.
128      */
129     protected synchronized void bind(int lport, InetAddress laddr)
130         throws SocketException {



131         bind0(lport, laddr);
132     }
133 
134     protected abstract void bind0(int lport, InetAddress laddr)
135         throws SocketException;
136 
137     /**
138      * Sends a datagram packet. The packet contains the data and the
139      * destination address to send the packet to.
140      * @param p the packet to be sent.
141      */
<span class="line-modified">142     protected abstract void send(DatagramPacket p) throws IOException;</span>












143 
144     /**
145      * Connects a datagram socket to a remote destination. This associates the remote
146      * address with the local socket so that datagrams may only be sent to this destination
147      * and received from this destination.
148      * @param address the remote InetAddress to connect to
149      * @param port the remote port number
150      */
151     protected void connect(InetAddress address, int port) throws SocketException {



152         connect0(address, port);
153         connectedAddress = address;
154         connectedPort = port;
155         connected = true;
156     }
157 
158     /**
159      * Disconnects a previously connected socket. Does nothing if the socket was
160      * not connected already.
161      */
162     protected void disconnect() {
163         disconnect0(connectedAddress.holder().getFamily());
164         connected = false;
165         connectedAddress = null;
166         connectedPort = -1;
167     }
168 
169     /**
170      * Peek at the packet to see who it is from.
171      * @param i the address to populate with the sender address
</pre>
<hr />
<pre>
383             case IP_MULTICAST_LOOP:
384             case SO_REUSEADDR:
385             case SO_BROADCAST:
386                 result = socketGetOption(optID);
387                 break;
388 
389             case SO_REUSEPORT:
390                 if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {
391                     throw new UnsupportedOperationException(&quot;unsupported option&quot;);
392                 }
393                 result = socketGetOption(optID);
394                 break;
395 
396             default:
397                 throw new SocketException(&quot;invalid option: &quot; + optID);
398         }
399 
400         return result;
401     }
402 
















































































































403     protected abstract void datagramSocketCreate() throws SocketException;
404     protected abstract void datagramSocketClose();
405     protected abstract void socketSetOption(int opt, Object val)
406         throws SocketException;
407     protected abstract Object socketGetOption(int opt) throws SocketException;
408 
409     protected abstract void connect0(InetAddress address, int port) throws SocketException;
410     protected abstract void disconnect0(int family);
411 
412     protected boolean nativeConnectDisabled() {
413         return connectDisabled;
414     }
415 
416     abstract int dataAvailable();
417     private static native boolean isReusePortAvailable0();
418 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.net;
 26 
 27 import java.io.FileDescriptor;
 28 import java.io.IOException;
 29 import java.util.Collections;
 30 import java.util.HashSet;
<span class="line-added"> 31 import java.util.Objects;</span>
 32 import java.util.Set;
 33 
 34 import sun.net.ResourceManager;
<span class="line-added"> 35 import sun.net.ext.ExtendedSocketOptions;</span>
<span class="line-added"> 36 import sun.net.util.IPAddressUtil;</span>
 37 import sun.security.action.GetPropertyAction;
 38 
 39 /**
 40  * Abstract datagram and multicast socket implementation base class.
 41  * Note: This is not a public class, so that applets cannot call
 42  * into the implementation directly and hence cannot bypass the
 43  * security checks present in the DatagramSocket and MulticastSocket
 44  * classes.
 45  *
 46  * @author Pavani Diwanji
 47  */
 48 
 49 abstract class AbstractPlainDatagramSocketImpl extends DatagramSocketImpl
 50 {
 51     /* timeout value for receive() */
 52     int timeout = 0;
 53     boolean connected = false;
 54     private int trafficClass = 0;
 55     protected InetAddress connectedAddress = null;
 56     private int connectedPort = -1;
<span class="line-added"> 57     private final boolean isMulticast;</span>
 58 
 59     private static final String os =
 60             GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
 61 
 62     /**
 63      * flag set if the native connect() call not to be used
 64      */
 65     private static final boolean connectDisabled = os.contains(&quot;OS X&quot;);
 66 
 67     /**
 68      * Load net library into runtime.
 69      */
 70     static {
<span class="line-modified"> 71         jdk.internal.loader.BootLoader.loadLibrary(&quot;net&quot;);</span>






 72     }
 73 
 74     private static volatile boolean checkedReusePort;
 75     private static volatile boolean isReusePortAvailable;
 76 
 77     /**
 78      * Tells whether SO_REUSEPORT is supported.
 79      */
 80     static boolean isReusePortAvailable() {
 81         if (!checkedReusePort) {
 82             isReusePortAvailable = isReusePortAvailable0();
 83             checkedReusePort = true;
 84         }
 85         return isReusePortAvailable;
 86     }
 87 
<span class="line-modified"> 88     AbstractPlainDatagramSocketImpl(boolean isMulticast) {</span>
<span class="line-modified"> 89         this.isMulticast = isMulticast;</span>
















 90     }
 91 
 92     /**
 93      * Creates a datagram socket
 94      */
 95     protected synchronized void create() throws SocketException {
 96         ResourceManager.beforeUdpCreate();
 97         fd = new FileDescriptor();
 98         try {
 99             datagramSocketCreate();
<span class="line-modified">100             SocketCleanable.register(fd, false);</span>
101         } catch (SocketException ioe) {
102             ResourceManager.afterUdpClose();
103             fd = null;
104             throw ioe;
105         }
106     }
107 
108     /**
109      * Binds a datagram socket to a local port.
110      */
111     protected synchronized void bind(int lport, InetAddress laddr)
112         throws SocketException {
<span class="line-added">113         if (laddr.isLinkLocalAddress()) {</span>
<span class="line-added">114             laddr = IPAddressUtil.toScopedAddress(laddr);</span>
<span class="line-added">115         }</span>
116         bind0(lport, laddr);
117     }
118 
119     protected abstract void bind0(int lport, InetAddress laddr)
120         throws SocketException;
121 
122     /**
123      * Sends a datagram packet. The packet contains the data and the
124      * destination address to send the packet to.
125      * @param p the packet to be sent.
126      */
<span class="line-modified">127     protected void send(DatagramPacket p) throws IOException {</span>
<span class="line-added">128         InetAddress orig = p.getAddress();</span>
<span class="line-added">129         if (orig.isLinkLocalAddress()) {</span>
<span class="line-added">130             InetAddress scoped = IPAddressUtil.toScopedAddress(orig);</span>
<span class="line-added">131             if (orig != scoped) {</span>
<span class="line-added">132                 p = new DatagramPacket(p.getData(), p.getOffset(),</span>
<span class="line-added">133                                        p.getLength(), scoped, p.getPort());</span>
<span class="line-added">134             }</span>
<span class="line-added">135         }</span>
<span class="line-added">136         send0(p);</span>
<span class="line-added">137     }</span>
<span class="line-added">138 </span>
<span class="line-added">139     protected abstract void send0(DatagramPacket p) throws IOException;</span>
140 
141     /**
142      * Connects a datagram socket to a remote destination. This associates the remote
143      * address with the local socket so that datagrams may only be sent to this destination
144      * and received from this destination.
145      * @param address the remote InetAddress to connect to
146      * @param port the remote port number
147      */
148     protected void connect(InetAddress address, int port) throws SocketException {
<span class="line-added">149         if (address.isLinkLocalAddress()) {</span>
<span class="line-added">150             address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">151         }</span>
152         connect0(address, port);
153         connectedAddress = address;
154         connectedPort = port;
155         connected = true;
156     }
157 
158     /**
159      * Disconnects a previously connected socket. Does nothing if the socket was
160      * not connected already.
161      */
162     protected void disconnect() {
163         disconnect0(connectedAddress.holder().getFamily());
164         connected = false;
165         connectedAddress = null;
166         connectedPort = -1;
167     }
168 
169     /**
170      * Peek at the packet to see who it is from.
171      * @param i the address to populate with the sender address
</pre>
<hr />
<pre>
383             case IP_MULTICAST_LOOP:
384             case SO_REUSEADDR:
385             case SO_BROADCAST:
386                 result = socketGetOption(optID);
387                 break;
388 
389             case SO_REUSEPORT:
390                 if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {
391                     throw new UnsupportedOperationException(&quot;unsupported option&quot;);
392                 }
393                 result = socketGetOption(optID);
394                 break;
395 
396             default:
397                 throw new SocketException(&quot;invalid option: &quot; + optID);
398         }
399 
400         return result;
401     }
402 
<span class="line-added">403     static final ExtendedSocketOptions extendedOptions =</span>
<span class="line-added">404             ExtendedSocketOptions.getInstance();</span>
<span class="line-added">405 </span>
<span class="line-added">406     private static final Set&lt;SocketOption&lt;?&gt;&gt; datagramSocketOptions = datagramSocketOptions();</span>
<span class="line-added">407 </span>
<span class="line-added">408     private static Set&lt;SocketOption&lt;?&gt;&gt; datagramSocketOptions() {</span>
<span class="line-added">409         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();</span>
<span class="line-added">410         options.add(StandardSocketOptions.SO_SNDBUF);</span>
<span class="line-added">411         options.add(StandardSocketOptions.SO_RCVBUF);</span>
<span class="line-added">412         options.add(StandardSocketOptions.SO_REUSEADDR);</span>
<span class="line-added">413         options.add(StandardSocketOptions.SO_BROADCAST);</span>
<span class="line-added">414         options.add(StandardSocketOptions.IP_TOS);</span>
<span class="line-added">415         options.add(StandardSocketOptions.IP_MULTICAST_IF);</span>
<span class="line-added">416         options.add(StandardSocketOptions.IP_MULTICAST_TTL);</span>
<span class="line-added">417         options.add(StandardSocketOptions.IP_MULTICAST_LOOP);</span>
<span class="line-added">418         if (isReusePortAvailable())</span>
<span class="line-added">419             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-added">420         options.addAll(ExtendedSocketOptions.datagramSocketOptions());</span>
<span class="line-added">421         return Collections.unmodifiableSet(options);</span>
<span class="line-added">422     }</span>
<span class="line-added">423 </span>
<span class="line-added">424     @Override</span>
<span class="line-added">425     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">426             return datagramSocketOptions;</span>
<span class="line-added">427     }</span>
<span class="line-added">428 </span>
<span class="line-added">429     @Override</span>
<span class="line-added">430     protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-added">431         Objects.requireNonNull(name);</span>
<span class="line-added">432         if (!supportedOptions().contains(name))</span>
<span class="line-added">433             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">434 </span>
<span class="line-added">435         if (!name.type().isInstance(value))</span>
<span class="line-added">436             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
<span class="line-added">437 </span>
<span class="line-added">438         if (isClosed())</span>
<span class="line-added">439             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">440 </span>
<span class="line-added">441         if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">442             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">443                 throw new IllegalArgumentException(&quot;Invalid send buffer size:&quot; + value);</span>
<span class="line-added">444             setOption(SocketOptions.SO_SNDBUF, value);</span>
<span class="line-added">445         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">446             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">447                 throw new IllegalArgumentException(&quot;Invalid recv buffer size:&quot; + value);</span>
<span class="line-added">448             setOption(SocketOptions.SO_RCVBUF, value);</span>
<span class="line-added">449         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">450             setOption(SocketOptions.SO_REUSEADDR, value);</span>
<span class="line-added">451         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">452             setOption(SocketOptions.SO_REUSEPORT, value);</span>
<span class="line-added">453         } else if (name == StandardSocketOptions.SO_BROADCAST) {</span>
<span class="line-added">454             setOption(SocketOptions.SO_BROADCAST, value);</span>
<span class="line-added">455         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">456             int i = ((Integer)value).intValue();</span>
<span class="line-added">457             if (i &lt; 0 || i &gt; 255)</span>
<span class="line-added">458                 throw new IllegalArgumentException(&quot;Invalid IP_TOS value: &quot; + value);</span>
<span class="line-added">459             setOption(SocketOptions.IP_TOS, value);</span>
<span class="line-added">460         } else if (name == StandardSocketOptions.IP_MULTICAST_IF ) {</span>
<span class="line-added">461             setOption(SocketOptions.IP_MULTICAST_IF2, value);</span>
<span class="line-added">462         } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {</span>
<span class="line-added">463             int i = ((Integer)value).intValue();</span>
<span class="line-added">464             if (i &lt; 0 || i &gt; 255)</span>
<span class="line-added">465                 throw new IllegalArgumentException(&quot;Invalid TTL/hop value: &quot; + value);</span>
<span class="line-added">466             setTimeToLive((Integer)value);</span>
<span class="line-added">467         } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {</span>
<span class="line-added">468             boolean enable = (boolean) value;</span>
<span class="line-added">469             // Legacy setOption expects true to mean &#39;disabled&#39;</span>
<span class="line-added">470             setOption(SocketOptions.IP_MULTICAST_LOOP, !enable);</span>
<span class="line-added">471         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">472             extendedOptions.setOption(fd, name, value);</span>
<span class="line-added">473         } else {</span>
<span class="line-added">474             throw new AssertionError(&quot;unknown option :&quot; + name);</span>
<span class="line-added">475         }</span>
<span class="line-added">476     }</span>
<span class="line-added">477 </span>
<span class="line-added">478     @Override</span>
<span class="line-added">479     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">480     protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">481         Objects.requireNonNull(name);</span>
<span class="line-added">482         if (!supportedOptions().contains(name))</span>
<span class="line-added">483             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">484 </span>
<span class="line-added">485         if (isClosed())</span>
<span class="line-added">486             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">487 </span>
<span class="line-added">488         if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">489             return (T) getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-added">490         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">491             return (T) getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-added">492         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">493             return (T) getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-added">494         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">495             return (T) getOption(SocketOptions.SO_REUSEPORT);</span>
<span class="line-added">496         } else if (name == StandardSocketOptions.SO_BROADCAST) {</span>
<span class="line-added">497             return (T) getOption(SocketOptions.SO_BROADCAST);</span>
<span class="line-added">498         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">499             return (T) getOption(SocketOptions.IP_TOS);</span>
<span class="line-added">500         } else if (name == StandardSocketOptions.IP_MULTICAST_IF) {</span>
<span class="line-added">501             return (T) getOption(SocketOptions.IP_MULTICAST_IF2);</span>
<span class="line-added">502         } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {</span>
<span class="line-added">503             return (T) ((Integer) getTimeToLive());</span>
<span class="line-added">504         } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {</span>
<span class="line-added">505             boolean disabled = (boolean) getOption(SocketOptions.IP_MULTICAST_LOOP);</span>
<span class="line-added">506             // Legacy getOption returns true when disabled</span>
<span class="line-added">507             return (T) Boolean.valueOf(!disabled);</span>
<span class="line-added">508         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">509             return (T) extendedOptions.getOption(fd, name);</span>
<span class="line-added">510         } else {</span>
<span class="line-added">511             throw new AssertionError(&quot;unknown option: &quot; + name);</span>
<span class="line-added">512         }</span>
<span class="line-added">513     }</span>
<span class="line-added">514 </span>
515     protected abstract void datagramSocketCreate() throws SocketException;
516     protected abstract void datagramSocketClose();
517     protected abstract void socketSetOption(int opt, Object val)
518         throws SocketException;
519     protected abstract Object socketGetOption(int opt) throws SocketException;
520 
521     protected abstract void connect0(InetAddress address, int port) throws SocketException;
522     protected abstract void disconnect0(int family);
523 
524     protected boolean nativeConnectDisabled() {
525         return connectDisabled;
526     }
527 
528     abstract int dataAvailable();
529     private static native boolean isReusePortAvailable0();
530 }
</pre>
</td>
</tr>
</table>
<center><a href="../math/MathContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AbstractPlainSocketImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
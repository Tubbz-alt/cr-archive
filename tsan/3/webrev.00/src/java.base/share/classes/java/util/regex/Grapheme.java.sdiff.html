<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/regex/Grapheme.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jar/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Matcher.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/regex/Grapheme.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.regex;
 27 


 28 final class Grapheme {
 29 
 30     /**
 31      * Determines if there is an extended  grapheme cluster boundary between two
 32      * continuing characters {@code cp1} and {@code cp2}.
 33      * &lt;p&gt;
 34      * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification
 35      * for the extended grapheme cluster boundary rules


 36      */
 37     static boolean isBoundary(int cp1, int cp2) {
 38         return rules[getType(cp1)][getType(cp2)];
 39     }
 40 

















































 41     // types
 42     private static final int OTHER = 0;
 43     private static final int CR = 1;
 44     private static final int LF = 2;
 45     private static final int CONTROL = 3;
 46     private static final int EXTEND = 4;
<span class="line-modified"> 47     private static final int RI = 5;</span>
<span class="line-modified"> 48     private static final int PREPEND = 6;</span>
<span class="line-modified"> 49     private static final int SPACINGMARK = 7;</span>
<span class="line-modified"> 50     private static final int L = 8;</span>
<span class="line-modified"> 51     private static final int V = 9;</span>
<span class="line-modified"> 52     private static final int T = 10;</span>
<span class="line-modified"> 53     private static final int LV = 11;</span>
<span class="line-modified"> 54     private static final int LVT = 12;</span>


 55 
 56     private static final int FIRST_TYPE = 0;
<span class="line-modified"> 57     private static final int LAST_TYPE = 12;</span>
 58 
 59     private static boolean[][] rules;
 60     static {
 61         rules = new boolean[LAST_TYPE + 1][LAST_TYPE + 1];
<span class="line-modified"> 62         // default, any + any</span>
 63         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
 64             for (int j = FIRST_TYPE; j &lt;= LAST_TYPE; j++)
 65                 rules[i][j] = true;
 66         // GB 6 L x (L | V | LV | VT)
 67         rules[L][L] = false;
 68         rules[L][V] = false;
 69         rules[L][LV] = false;
 70         rules[L][LVT] = false;
 71         // GB 7 (LV | V) x (V | T)
 72         rules[LV][V] = false;
 73         rules[LV][T] = false;
 74         rules[V][V] = false;
 75         rules[V][T] = false;
 76         // GB 8 (LVT | T) x T
 77         rules[LVT][T] = false;
 78         rules[T][T] = false;
<span class="line-modified"> 79         // GB 8a RI x RI</span>
<span class="line-removed"> 80         rules[RI][RI] = false;</span>
<span class="line-removed"> 81         // GB 9 x Extend</span>
 82         // GB 9a x Spacing Mark
 83         // GB 9b Prepend x
 84         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++) {
 85             rules[i][EXTEND] = false;

 86             rules[i][SPACINGMARK] = false;
 87             rules[PREPEND][i] = false;
 88         }
 89         // GB 4  (Control | CR | LF) +
 90         // GB 5  + (Control | CR | LF)
 91         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
 92             for (int j = CR; j &lt;= CONTROL; j++) {
 93                 rules[i][j] = true;
 94                 rules[j][i] = true;
 95             }
 96         // GB 3 CR x LF
 97         rules[CR][LF] = false;
<span class="line-modified"> 98         // GB 10 Any + Any  -&gt; default</span>


 99     }
100 
101     // Hangul syllables
102     private static final int SYLLABLE_BASE = 0xAC00;
103     private static final int LCOUNT = 19;
104     private static final int VCOUNT = 21;
105     private static final int TCOUNT = 28;
106     private static final int NCOUNT = VCOUNT * TCOUNT; // 588
107     private static final int SCOUNT = LCOUNT * NCOUNT; // 11172
108 
109     // #tr29: SpacingMark exceptions: The following (which have
110     // General_Category = Spacing_Mark and would otherwise be included)
111     // are specifically excluded
112     private static boolean isExcludedSpacingMark(int cp) {
113        return  cp == 0x102B || cp == 0x102C || cp == 0x1038 ||
114                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x1064 ||
115                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x106D ||
116                cp == 0x1083 ||
117                cp &gt;= 0x1087 &amp;&amp; cp &lt;= 0x108C ||
118                cp == 0x108F ||
119                cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
120                cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
121                cp == 0xAA7B || cp == 0xAA7D;
122     }
123 














124     @SuppressWarnings(&quot;fallthrough&quot;)
125     private static int getType(int cp) {




126         int type = Character.getType(cp);
127         switch(type) {
<span class="line-modified">128         case Character.CONTROL:</span>
<span class="line-removed">129             if (cp == 0x000D)</span>
<span class="line-removed">130                 return CR;</span>
<span class="line-removed">131             if (cp == 0x000A)</span>
<span class="line-removed">132                 return LF;</span>
<span class="line-removed">133             return CONTROL;</span>
<span class="line-removed">134          case Character.UNASSIGNED:</span>
135             // NOTE: #tr29 lists &quot;Unassigned and Default_Ignorable_Code_Point&quot; as Control
136             // but GraphemeBreakTest.txt lists u+0378/reserved-0378 as &quot;Other&quot;
137             // so type it as &quot;Other&quot; to make the test happy
<span class="line-modified">138              if (cp == 0x0378)</span>
<span class="line-modified">139                  return OTHER;</span>
140 

141         case Character.LINE_SEPARATOR:
142         case Character.PARAGRAPH_SEPARATOR:
143         case Character.SURROGATE:
144             return CONTROL;
145         case Character.FORMAT:
<span class="line-modified">146             if (cp == 0x200C || cp == 0x200D)</span>

147                 return EXTEND;






148             return CONTROL;
149         case Character.NON_SPACING_MARK:
150         case Character.ENCLOSING_MARK:
<span class="line-modified">151              // NOTE:</span>
<span class="line-modified">152              // #tr29 &quot;plus a few General_Category = Spacing_Mark needed for</span>
<span class="line-modified">153              // canonical equivalence.&quot;</span>
<span class="line-modified">154              // but for &quot;extended grapheme clusters&quot; support, there is no</span>
<span class="line-modified">155              // need actually to diff &quot;extend&quot; and &quot;spackmark&quot; given GB9, GB9a</span>
<span class="line-modified">156              return EXTEND;</span>
157         case  Character.COMBINING_SPACING_MARK:
158             if (isExcludedSpacingMark(cp))
159                 return OTHER;
160             // NOTE:
161             // 0x11720 and 0x11721 are mentioned in #tr29 as
162             // OTHER_LETTER but it appears their category has been updated to
163             // COMBING_SPACING_MARK already (verified in ver.8)
164             return SPACINGMARK;
165         case Character.OTHER_SYMBOL:
166             if (cp &gt;= 0x1F1E6 &amp;&amp; cp &lt;= 0x1F1FF)
167                 return RI;
168             return OTHER;
169         case Character.MODIFIER_LETTER:

170             // WARNING:
171             // not mentioned in #tr29 but listed in GraphemeBreakProperty.txt
<span class="line-modified">172             if (cp == 0xFF9E || cp == 0xFF9F)</span>

173                 return EXTEND;
174             return OTHER;
175         case Character.OTHER_LETTER:
176             if (cp == 0x0E33 || cp == 0x0EB3)
177                 return SPACINGMARK;
178             // hangul jamo
179             if (cp &gt;= 0x1100 &amp;&amp; cp &lt;= 0x11FF) {
180                 if (cp &lt;= 0x115F)
181                     return L;
182                 if (cp &lt;= 0x11A7)
183                     return V;
184                 return T;
185             }
186             // hangul syllables
187             int sindex = cp - SYLLABLE_BASE;
188             if (sindex &gt;= 0 &amp;&amp; sindex &lt; SCOUNT) {
189 
190                 if (sindex % TCOUNT == 0)
191                     return LV;
192                 return LVT;
193             }
194             //  hangul jamo_extended A
195             if (cp &gt;= 0xA960 &amp;&amp; cp &lt;= 0xA97C)
196                 return L;
197             //  hangul jamo_extended B
198             if (cp &gt;= 0xD7B0 &amp;&amp; cp &lt;= 0xD7C6)
199                 return V;
200             if (cp &gt;= 0xD7CB &amp;&amp; cp &lt;= 0xD7FB)
201                 return T;
















202         }
203         return OTHER;
204     }
205 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.regex;
 27 
<span class="line-added"> 28 import java.util.Objects;</span>
<span class="line-added"> 29 </span>
 30 final class Grapheme {
 31 
 32     /**
 33      * Determines if there is an extended  grapheme cluster boundary between two
 34      * continuing characters {@code cp1} and {@code cp2}.
 35      * &lt;p&gt;
 36      * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification
 37      * for the extended grapheme cluster boundary rules
<span class="line-added"> 38      * &lt;p&gt;</span>
<span class="line-added"> 39      * Note: this method does not take care of stateful breaking.</span>
 40      */
 41     static boolean isBoundary(int cp1, int cp2) {
 42         return rules[getType(cp1)][getType(cp2)];
 43     }
 44 
<span class="line-added"> 45     /**</span>
<span class="line-added"> 46      * Look for the next extended grapheme cluster boundary in a CharSequence. It assumes</span>
<span class="line-added"> 47      * the start of the char sequence is a boundary.</span>
<span class="line-added"> 48      * &lt;p&gt;</span>
<span class="line-added"> 49      * See Unicode Standard Annex #29 Unicode Text Segmentation for the specification</span>
<span class="line-added"> 50      * for the extended grapheme cluster boundary rules. The following implementation</span>
<span class="line-added"> 51      * is based on version 12.0 of the annex.</span>
<span class="line-added"> 52      * (http://www.unicode.org/reports/tr29/tr29-35.html)</span>
<span class="line-added"> 53      *</span>
<span class="line-added"> 54      * @param src the {@code CharSequence} to be scanned</span>
<span class="line-added"> 55      * @param off offset to start looking for the next boundary in the src</span>
<span class="line-added"> 56      * @param limit limit offset in the src (exclusive)</span>
<span class="line-added"> 57      * @return the next possible boundary</span>
<span class="line-added"> 58      */</span>
<span class="line-added"> 59     static int nextBoundary(CharSequence src, int off, int limit) {</span>
<span class="line-added"> 60         Objects.checkFromToIndex(off, limit, src.length());</span>
<span class="line-added"> 61 </span>
<span class="line-added"> 62         int ch0 = Character.codePointAt(src, 0);</span>
<span class="line-added"> 63         int ret = Character.charCount(ch0);</span>
<span class="line-added"> 64         int ch1;</span>
<span class="line-added"> 65         // indicates whether gb11 or gb12 is underway</span>
<span class="line-added"> 66         int t0 = getGraphemeType(ch0);</span>
<span class="line-added"> 67         int riCount = t0 == RI ? 1 : 0;</span>
<span class="line-added"> 68         boolean gb11 = t0 == EXTENDED_PICTOGRAPHIC;</span>
<span class="line-added"> 69         while (ret &lt; limit) {</span>
<span class="line-added"> 70             ch1 = Character.codePointAt(src, ret);</span>
<span class="line-added"> 71             int t1 = getGraphemeType(ch1);</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73             if (gb11 &amp;&amp; t0 == ZWJ &amp;&amp; t1 == EXTENDED_PICTOGRAPHIC) {</span>
<span class="line-added"> 74                 gb11 = false;</span>
<span class="line-added"> 75             } else if (riCount % 2 == 1 &amp;&amp; t0 == RI &amp;&amp; t1 == RI) {</span>
<span class="line-added"> 76                 // continue for gb12</span>
<span class="line-added"> 77             } else if (rules[t0][t1]) {</span>
<span class="line-added"> 78                 if (ret &gt; off) {</span>
<span class="line-added"> 79                     break;</span>
<span class="line-added"> 80                 } else {</span>
<span class="line-added"> 81                     gb11 = t1 == EXTENDED_PICTOGRAPHIC;</span>
<span class="line-added"> 82                     riCount = 0;</span>
<span class="line-added"> 83                 }</span>
<span class="line-added"> 84             }</span>
<span class="line-added"> 85 </span>
<span class="line-added"> 86             riCount += (t1 == RI) ? 1 : 0;</span>
<span class="line-added"> 87             t0 = t1;</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89             ret += Character.charCount(ch1);</span>
<span class="line-added"> 90         }</span>
<span class="line-added"> 91         return ret;</span>
<span class="line-added"> 92     }</span>
<span class="line-added"> 93 </span>
 94     // types
 95     private static final int OTHER = 0;
 96     private static final int CR = 1;
 97     private static final int LF = 2;
 98     private static final int CONTROL = 3;
 99     private static final int EXTEND = 4;
<span class="line-modified">100     private static final int ZWJ = 5;</span>
<span class="line-modified">101     private static final int RI = 6;</span>
<span class="line-modified">102     private static final int PREPEND = 7;</span>
<span class="line-modified">103     private static final int SPACINGMARK = 8;</span>
<span class="line-modified">104     private static final int L = 9;</span>
<span class="line-modified">105     private static final int V = 10;</span>
<span class="line-modified">106     private static final int T = 11;</span>
<span class="line-modified">107     private static final int LV = 12;</span>
<span class="line-added">108     private static final int LVT = 13;</span>
<span class="line-added">109     private static final int EXTENDED_PICTOGRAPHIC = 14;</span>
110 
111     private static final int FIRST_TYPE = 0;
<span class="line-modified">112     private static final int LAST_TYPE = 14;</span>
113 
114     private static boolean[][] rules;
115     static {
116         rules = new boolean[LAST_TYPE + 1][LAST_TYPE + 1];
<span class="line-modified">117         // GB 999 Any + Any  -&gt; default</span>
118         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
119             for (int j = FIRST_TYPE; j &lt;= LAST_TYPE; j++)
120                 rules[i][j] = true;
121         // GB 6 L x (L | V | LV | VT)
122         rules[L][L] = false;
123         rules[L][V] = false;
124         rules[L][LV] = false;
125         rules[L][LVT] = false;
126         // GB 7 (LV | V) x (V | T)
127         rules[LV][V] = false;
128         rules[LV][T] = false;
129         rules[V][V] = false;
130         rules[V][T] = false;
131         // GB 8 (LVT | T) x T
132         rules[LVT][T] = false;
133         rules[T][T] = false;
<span class="line-modified">134         // GB 9 x (Extend|ZWJ)</span>


135         // GB 9a x Spacing Mark
136         // GB 9b Prepend x
137         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++) {
138             rules[i][EXTEND] = false;
<span class="line-added">139             rules[i][ZWJ] = false;</span>
140             rules[i][SPACINGMARK] = false;
141             rules[PREPEND][i] = false;
142         }
143         // GB 4  (Control | CR | LF) +
144         // GB 5  + (Control | CR | LF)
145         for (int i = FIRST_TYPE; i &lt;= LAST_TYPE; i++)
146             for (int j = CR; j &lt;= CONTROL; j++) {
147                 rules[i][j] = true;
148                 rules[j][i] = true;
149             }
150         // GB 3 CR x LF
151         rules[CR][LF] = false;
<span class="line-modified">152         // GB 11 Exended_Pictographic x (Extend|ZWJ)</span>
<span class="line-added">153         rules[EXTENDED_PICTOGRAPHIC][EXTEND] = false;</span>
<span class="line-added">154         rules[EXTENDED_PICTOGRAPHIC][ZWJ] = false;</span>
155     }
156 
157     // Hangul syllables
158     private static final int SYLLABLE_BASE = 0xAC00;
159     private static final int LCOUNT = 19;
160     private static final int VCOUNT = 21;
161     private static final int TCOUNT = 28;
162     private static final int NCOUNT = VCOUNT * TCOUNT; // 588
163     private static final int SCOUNT = LCOUNT * NCOUNT; // 11172
164 
165     // #tr29: SpacingMark exceptions: The following (which have
166     // General_Category = Spacing_Mark and would otherwise be included)
167     // are specifically excluded
168     private static boolean isExcludedSpacingMark(int cp) {
169        return  cp == 0x102B || cp == 0x102C || cp == 0x1038 ||
170                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x1064 ||
171                cp &gt;= 0x1062 &amp;&amp; cp &lt;= 0x106D ||
172                cp == 0x1083 ||
173                cp &gt;= 0x1087 &amp;&amp; cp &lt;= 0x108C ||
174                cp == 0x108F ||
175                cp &gt;= 0x109A &amp;&amp; cp &lt;= 0x109C ||
176                cp == 0x1A61 || cp == 0x1A63 || cp == 0x1A64 ||
177                cp == 0xAA7B || cp == 0xAA7D;
178     }
179 
<span class="line-added">180     private static int getGraphemeType(int cp) {</span>
<span class="line-added">181         if (cp &lt; 0x007F) { // ASCII</span>
<span class="line-added">182             if (cp &lt; 32) { // Control characters</span>
<span class="line-added">183                 if (cp == 0x000D)</span>
<span class="line-added">184                     return CR;</span>
<span class="line-added">185                 if (cp == 0x000A)</span>
<span class="line-added">186                     return LF;</span>
<span class="line-added">187                 return CONTROL;</span>
<span class="line-added">188             }</span>
<span class="line-added">189             return OTHER;</span>
<span class="line-added">190         }</span>
<span class="line-added">191         return getType(cp);</span>
<span class="line-added">192     }</span>
<span class="line-added">193 </span>
194     @SuppressWarnings(&quot;fallthrough&quot;)
195     private static int getType(int cp) {
<span class="line-added">196         if (EmojiData.isExtendedPictographic(cp)) {</span>
<span class="line-added">197             return EXTENDED_PICTOGRAPHIC;</span>
<span class="line-added">198         }</span>
<span class="line-added">199 </span>
200         int type = Character.getType(cp);
201         switch(type) {
<span class="line-modified">202         case Character.UNASSIGNED:</span>






203             // NOTE: #tr29 lists &quot;Unassigned and Default_Ignorable_Code_Point&quot; as Control
204             // but GraphemeBreakTest.txt lists u+0378/reserved-0378 as &quot;Other&quot;
205             // so type it as &quot;Other&quot; to make the test happy
<span class="line-modified">206             if (cp == 0x0378)</span>
<span class="line-modified">207                 return OTHER;</span>
208 
<span class="line-added">209         case Character.CONTROL:</span>
210         case Character.LINE_SEPARATOR:
211         case Character.PARAGRAPH_SEPARATOR:
212         case Character.SURROGATE:
213             return CONTROL;
214         case Character.FORMAT:
<span class="line-modified">215             if (cp == 0x200C ||</span>
<span class="line-added">216                 cp &gt;= 0xE0020 &amp;&amp; cp &lt;= 0xE007F)</span>
217                 return EXTEND;
<span class="line-added">218             if (cp == 0x200D)</span>
<span class="line-added">219                 return ZWJ;</span>
<span class="line-added">220             if (cp &gt;= 0x0600 &amp;&amp; cp &lt;= 0x0605 ||</span>
<span class="line-added">221                 cp == 0x06DD || cp == 0x070F || cp == 0x08E2 ||</span>
<span class="line-added">222                 cp == 0x110BD || cp == 0x110CD)</span>
<span class="line-added">223                 return PREPEND;</span>
224             return CONTROL;
225         case Character.NON_SPACING_MARK:
226         case Character.ENCLOSING_MARK:
<span class="line-modified">227             // NOTE:</span>
<span class="line-modified">228             // #tr29 &quot;plus a few General_Category = Spacing_Mark needed for</span>
<span class="line-modified">229             // canonical equivalence.&quot;</span>
<span class="line-modified">230             // but for &quot;extended grapheme clusters&quot; support, there is no</span>
<span class="line-modified">231             // need actually to diff &quot;extend&quot; and &quot;spackmark&quot; given GB9, GB9a</span>
<span class="line-modified">232             return EXTEND;</span>
233         case  Character.COMBINING_SPACING_MARK:
234             if (isExcludedSpacingMark(cp))
235                 return OTHER;
236             // NOTE:
237             // 0x11720 and 0x11721 are mentioned in #tr29 as
238             // OTHER_LETTER but it appears their category has been updated to
239             // COMBING_SPACING_MARK already (verified in ver.8)
240             return SPACINGMARK;
241         case Character.OTHER_SYMBOL:
242             if (cp &gt;= 0x1F1E6 &amp;&amp; cp &lt;= 0x1F1FF)
243                 return RI;
244             return OTHER;
245         case Character.MODIFIER_LETTER:
<span class="line-added">246         case Character.MODIFIER_SYMBOL:</span>
247             // WARNING:
248             // not mentioned in #tr29 but listed in GraphemeBreakProperty.txt
<span class="line-modified">249             if (cp == 0xFF9E || cp == 0xFF9F ||</span>
<span class="line-added">250                 cp &gt;= 0x1F3FB &amp;&amp; cp &lt;= 0x1F3FF)</span>
251                 return EXTEND;
252             return OTHER;
253         case Character.OTHER_LETTER:
254             if (cp == 0x0E33 || cp == 0x0EB3)
255                 return SPACINGMARK;
256             // hangul jamo
257             if (cp &gt;= 0x1100 &amp;&amp; cp &lt;= 0x11FF) {
258                 if (cp &lt;= 0x115F)
259                     return L;
260                 if (cp &lt;= 0x11A7)
261                     return V;
262                 return T;
263             }
264             // hangul syllables
265             int sindex = cp - SYLLABLE_BASE;
266             if (sindex &gt;= 0 &amp;&amp; sindex &lt; SCOUNT) {
267 
268                 if (sindex % TCOUNT == 0)
269                     return LV;
270                 return LVT;
271             }
272             //  hangul jamo_extended A
273             if (cp &gt;= 0xA960 &amp;&amp; cp &lt;= 0xA97C)
274                 return L;
275             //  hangul jamo_extended B
276             if (cp &gt;= 0xD7B0 &amp;&amp; cp &lt;= 0xD7C6)
277                 return V;
278             if (cp &gt;= 0xD7CB &amp;&amp; cp &lt;= 0xD7FB)
279                 return T;
<span class="line-added">280 </span>
<span class="line-added">281             // Prepend</span>
<span class="line-added">282             switch (cp) {</span>
<span class="line-added">283                 case 0x0D4E:</span>
<span class="line-added">284                 case 0x111C2:</span>
<span class="line-added">285                 case 0x111C3:</span>
<span class="line-added">286                 case 0x11A3A:</span>
<span class="line-added">287                 case 0x11A84:</span>
<span class="line-added">288                 case 0x11A85:</span>
<span class="line-added">289                 case 0x11A86:</span>
<span class="line-added">290                 case 0x11A87:</span>
<span class="line-added">291                 case 0x11A88:</span>
<span class="line-added">292                 case 0x11A89:</span>
<span class="line-added">293                 case 0x11D46:</span>
<span class="line-added">294                     return PREPEND;</span>
<span class="line-added">295             }</span>
296         }
297         return OTHER;
298     }
299 }
</pre>
</td>
</tr>
</table>
<center><a href="../jar/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Matcher.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
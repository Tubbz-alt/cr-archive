<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/locks/StampedLock.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ReentrantReadWriteLock.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../package-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/StampedLock.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent.locks;
  37 
<span class="line-removed">  38 import java.lang.invoke.MethodHandles;</span>
<span class="line-removed">  39 import java.lang.invoke.VarHandle;</span>
  40 import java.util.concurrent.TimeUnit;

  41 import jdk.internal.vm.annotation.ReservedStackAccess;
  42 
  43 /**
  44  * A capability-based lock with three modes for controlling read/write
  45  * access.  The state of a StampedLock consists of a version and mode.
  46  * Lock acquisition methods return a stamp that represents and
  47  * controls access with respect to a lock state; &quot;try&quot; versions of
  48  * these methods may instead return the special value zero to
  49  * represent failure to acquire access. Lock release and conversion
  50  * methods require stamps as arguments, and fail if they do not match
  51  * the state of the lock. The three modes are:
  52  *
  53  * &lt;ul&gt;
  54  *
  55  *  &lt;li&gt;&lt;b&gt;Writing.&lt;/b&gt; Method {@link #writeLock} possibly blocks
  56  *   waiting for exclusive access, returning a stamp that can be used
  57  *   in method {@link #unlockWrite} to release the lock. Untimed and
  58  *   timed versions of {@code tryWriteLock} are also provided. When
  59  *   the lock is held in write mode, no read locks may be obtained,
  60  *   and all optimistic read validations will fail.
</pre>
<hr />
<pre>
 115  * &lt;p&gt;Like {@link java.util.concurrent.Semaphore Semaphore}, but unlike most
 116  * {@link Lock} implementations, StampedLocks have no notion of ownership.
 117  * Locks acquired in one thread can be released or converted in another.
 118  *
 119  * &lt;p&gt;The scheduling policy of StampedLock does not consistently
 120  * prefer readers over writers or vice versa.  All &quot;try&quot; methods are
 121  * best-effort and do not necessarily conform to any scheduling or
 122  * fairness policy. A zero return from any &quot;try&quot; method for acquiring
 123  * or converting locks does not carry any information about the state
 124  * of the lock; a subsequent invocation may succeed.
 125  *
 126  * &lt;p&gt;Because it supports coordinated usage across multiple lock
 127  * modes, this class does not directly implement the {@link Lock} or
 128  * {@link ReadWriteLock} interfaces. However, a StampedLock may be
 129  * viewed {@link #asReadLock()}, {@link #asWriteLock()}, or {@link
 130  * #asReadWriteLock()} in applications requiring only the associated
 131  * set of functionality.
 132  *
 133  * &lt;p&gt;&lt;b&gt;Memory Synchronization.&lt;/b&gt; Methods with the effect of
 134  * successfully locking in any mode have the same memory
<span class="line-modified"> 135  * synchronization effects as a &lt;em&gt;Lock&lt;/em&gt; action described in</span>
<span class="line-modified"> 136  * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se11/html/jls-17.html#jls-17.4&quot;&gt;</span>
<span class="line-removed"> 137  * Chapter 17 of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;&lt;/a&gt;.</span>
 138  * Methods successfully unlocking in write mode have the same memory
 139  * synchronization effects as an &lt;em&gt;Unlock&lt;/em&gt; action.  In optimistic
 140  * read usages, actions prior to the most recent write mode unlock action
 141  * are guaranteed to happen-before those following a tryOptimisticRead
 142  * only if a later validate returns true; otherwise there is no guarantee
 143  * that the reads between tryOptimisticRead and validate obtain a
 144  * consistent snapshot.
 145  *
 146  * &lt;p&gt;&lt;b&gt;Sample Usage.&lt;/b&gt; The following illustrates some usage idioms
 147  * in a class that maintains simple two-dimensional points. The sample
 148  * code illustrates some try/catch conventions even though they are
 149  * not strictly needed here because no exceptions can occur in their
 150  * bodies.
 151  *
 152  * &lt;pre&gt; {@code
 153  * class Point {
 154  *   private double x, y;
 155  *   private final StampedLock sl = new StampedLock();
 156  *
 157  *   // an exclusively locked method
</pre>
<hr />
<pre>
 220  *     try {
 221  *       while (x == 0.0 &amp;&amp; y == 0.0) {
 222  *         long ws = sl.tryConvertToWriteLock(stamp);
 223  *         if (ws != 0L) {
 224  *           stamp = ws;
 225  *           x = newX;
 226  *           y = newY;
 227  *           break;
 228  *         }
 229  *         else {
 230  *           sl.unlockRead(stamp);
 231  *           stamp = sl.writeLock();
 232  *         }
 233  *       }
 234  *     } finally {
 235  *       sl.unlock(stamp);
 236  *     }
 237  *   }
 238  * }}&lt;/pre&gt;
 239  *

 240  * @since 1.8
 241  * @author Doug Lea
 242  */
 243 public class StampedLock implements java.io.Serializable {
 244     /*
 245      * Algorithmic notes:
 246      *
 247      * The design employs elements of Sequence locks
 248      * (as used in linux kernels; see Lameter&#39;s
 249      * http://www.lameter.com/gelato2005.pdf
 250      * and elsewhere; see
 251      * Boehm&#39;s http://www.hpl.hp.com/techreports/2012/HPL-2012-68.html)
 252      * and Ordered RW locks (see Shirako et al
 253      * http://dl.acm.org/citation.cfm?id=2312015)
 254      *
 255      * Conceptually, the primary state of the lock includes a sequence
 256      * number that is odd when write-locked and even otherwise.
 257      * However, this is offset by a reader count that is non-zero when
 258      * read-locked.  The read count is ignored when validating
 259      * &quot;optimistic&quot; seqlock-reader-style stamps.  Because we must use
 260      * a small finite number of bits (currently 7) for readers, a
 261      * supplementary reader overflow word is used when the number of
 262      * readers exceeds the count field. We do this by treating the max
 263      * reader count value (RBITS) as a spinlock protecting overflow
 264      * updates.
 265      *
 266      * Waiters use a modified form of CLH lock used in
<span class="line-modified"> 267      * AbstractQueuedSynchronizer (see its internal documentation for</span>
<span class="line-modified"> 268      * a fuller account), where each node is tagged (field mode) as</span>
<span class="line-modified"> 269      * either a reader or writer. Sets of waiting readers are grouped</span>
<span class="line-modified"> 270      * (linked) under a common node (field cowait) so act as a single</span>
<span class="line-modified"> 271      * node with respect to most CLH mechanics.  By virtue of the</span>
<span class="line-modified"> 272      * queue structure, wait nodes need not actually carry sequence</span>
<span class="line-modified"> 273      * numbers; we know each is greater than its predecessor.  This</span>
<span class="line-modified"> 274      * simplifies the scheduling policy to a mainly-FIFO scheme that</span>
<span class="line-modified"> 275      * incorporates elements of Phase-Fair locks (see Brandenburg &amp;</span>
<span class="line-modified"> 276      * Anderson, especially http://www.cs.unc.edu/~bbb/diss/).  In</span>
<span class="line-modified"> 277      * particular, we use the phase-fair anti-barging rule: If an</span>
<span class="line-modified"> 278      * incoming reader arrives while read lock is held but there is a</span>
<span class="line-removed"> 279      * queued writer, this incoming reader is queued.  (This rule is</span>
<span class="line-removed"> 280      * responsible for some of the complexity of method acquireRead,</span>
<span class="line-removed"> 281      * but without it, the lock becomes highly unfair.) Method release</span>
<span class="line-removed"> 282      * does not (and sometimes cannot) itself wake up cowaiters. This</span>
<span class="line-removed"> 283      * is done by the primary thread, but helped by any other threads</span>
<span class="line-removed"> 284      * with nothing better to do in methods acquireRead and</span>
<span class="line-removed"> 285      * acquireWrite.</span>
 286      *
<span class="line-modified"> 287      * These rules apply to threads actually queued. All tryLock forms</span>
<span class="line-modified"> 288      * opportunistically try to acquire locks regardless of preference</span>
<span class="line-modified"> 289      * rules, and so may &quot;barge&quot; their way in.  Randomized spinning is</span>
<span class="line-modified"> 290      * used in the acquire methods to reduce (increasingly expensive)</span>
<span class="line-modified"> 291      * context switching while also avoiding sustained memory</span>
<span class="line-modified"> 292      * thrashing among many threads.  We limit spins to the head of</span>
<span class="line-modified"> 293      * queue. If, upon wakening, a thread fails to obtain lock, and is</span>
<span class="line-modified"> 294      * still (or becomes) the first waiting thread (which indicates</span>
<span class="line-modified"> 295      * that some other thread barged and obtained lock), it escalates</span>
<span class="line-removed"> 296      * spins (up to MAX_HEAD_SPINS) to reduce the likelihood of</span>
<span class="line-removed"> 297      * continually losing to barging threads.</span>
 298      *
 299      * Nearly all of these mechanics are carried out in methods
 300      * acquireWrite and acquireRead, that, as typical of such code,
 301      * sprawl out because actions and retries rely on consistent sets
 302      * of locally cached reads.
 303      *
<span class="line-modified"> 304      * As noted in Boehm&#39;s paper (above), sequence validation (mainly</span>
<span class="line-modified"> 305      * method validate()) requires stricter ordering rules than apply</span>
<span class="line-modified"> 306      * to normal volatile reads (of &quot;state&quot;).  To force orderings of</span>
<span class="line-modified"> 307      * reads before a validation and the validation itself in those</span>
<span class="line-modified"> 308      * cases where this is not already forced, we use acquireFence.</span>
<span class="line-modified"> 309      * Unlike in that paper, we allow writers to use plain writes.</span>
<span class="line-modified"> 310      * One would not expect reorderings of such writes with the lock</span>
<span class="line-removed"> 311      * acquisition CAS because there is a &quot;control dependency&quot;, but it</span>
<span class="line-removed"> 312      * is theoretically possible, so we additionally add a</span>
<span class="line-removed"> 313      * storeStoreFence after lock acquisition CAS.</span>
<span class="line-removed"> 314      *</span>
<span class="line-removed"> 315      * ----------------------------------------------------------------</span>
<span class="line-removed"> 316      * Here&#39;s an informal proof that plain reads by _successful_</span>
<span class="line-removed"> 317      * readers see plain writes from preceding but not following</span>
<span class="line-removed"> 318      * writers (following Boehm and the C++ standard [atomics.fences]):</span>
<span class="line-removed"> 319      *</span>
<span class="line-removed"> 320      * Because of the total synchronization order of accesses to</span>
<span class="line-removed"> 321      * volatile long state containing the sequence number, writers and</span>
<span class="line-removed"> 322      * _successful_ readers can be globally sequenced.</span>
<span class="line-removed"> 323      *</span>
<span class="line-removed"> 324      * int x, y;</span>
<span class="line-removed"> 325      *</span>
<span class="line-removed"> 326      * Writer 1:</span>
<span class="line-removed"> 327      * inc sequence (odd - &quot;locked&quot;)</span>
<span class="line-removed"> 328      * storeStoreFence();</span>
<span class="line-removed"> 329      * x = 1; y = 2;</span>
<span class="line-removed"> 330      * inc sequence (even - &quot;unlocked&quot;)</span>
<span class="line-removed"> 331      *</span>
<span class="line-removed"> 332      * Successful Reader:</span>
<span class="line-removed"> 333      * read sequence (even)</span>
<span class="line-removed"> 334      * // must see writes from Writer 1 but not Writer 2</span>
<span class="line-removed"> 335      * r1 = x; r2 = y;</span>
<span class="line-removed"> 336      * acquireFence();</span>
<span class="line-removed"> 337      * read sequence (even - validated unchanged)</span>
<span class="line-removed"> 338      * // use r1 and r2</span>
<span class="line-removed"> 339      *</span>
<span class="line-removed"> 340      * Writer 2:</span>
<span class="line-removed"> 341      * inc sequence (odd - &quot;locked&quot;)</span>
<span class="line-removed"> 342      * storeStoreFence();</span>
<span class="line-removed"> 343      * x = 3; y = 4;</span>
<span class="line-removed"> 344      * inc sequence (even - &quot;unlocked&quot;)</span>
<span class="line-removed"> 345      *</span>
<span class="line-removed"> 346      * Visibility of writer 1&#39;s stores is normal - reader&#39;s initial</span>
<span class="line-removed"> 347      * read of state synchronizes with writer 1&#39;s final write to state.</span>
<span class="line-removed"> 348      * Lack of visibility of writer 2&#39;s plain writes is less obvious.</span>
<span class="line-removed"> 349      * If reader&#39;s read of x or y saw writer 2&#39;s write, then (assuming</span>
<span class="line-removed"> 350      * semantics of C++ fences) the storeStoreFence would &quot;synchronize&quot;</span>
<span class="line-removed"> 351      * with reader&#39;s acquireFence and reader&#39;s validation read must see</span>
<span class="line-removed"> 352      * writer 2&#39;s initial write to state and so validation must fail.</span>
<span class="line-removed"> 353      * But making this &quot;proof&quot; formal and rigorous is an open problem!</span>
<span class="line-removed"> 354      * ----------------------------------------------------------------</span>
 355      *
 356      * The memory layout keeps lock state and queue pointers together
 357      * (normally on the same cache line). This usually works well for
 358      * read-mostly loads. In most other cases, the natural tendency of
<span class="line-modified"> 359      * adaptive-spin CLH locks to reduce memory contention lessens</span>
<span class="line-modified"> 360      * motivation to further spread out contended locations, but might</span>
<span class="line-modified"> 361      * be subject to future improvements.</span>
 362      */
 363 
 364     private static final long serialVersionUID = -6001602636862214147L;
 365 
<span class="line-removed"> 366     /** Number of processors, for spin control */</span>
<span class="line-removed"> 367     private static final int NCPU = Runtime.getRuntime().availableProcessors();</span>
<span class="line-removed"> 368 </span>
<span class="line-removed"> 369     /** Maximum number of retries before enqueuing on acquisition; at least 1 */</span>
<span class="line-removed"> 370     private static final int SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 6 : 1;</span>
<span class="line-removed"> 371 </span>
<span class="line-removed"> 372     /** Maximum number of tries before blocking at head on acquisition */</span>
<span class="line-removed"> 373     private static final int HEAD_SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 10 : 1;</span>
<span class="line-removed"> 374 </span>
<span class="line-removed"> 375     /** Maximum number of retries before re-blocking */</span>
<span class="line-removed"> 376     private static final int MAX_HEAD_SPINS = (NCPU &gt; 1) ? 1 &lt;&lt; 16 : 1;</span>
<span class="line-removed"> 377 </span>
<span class="line-removed"> 378     /** The period for yielding when waiting for overflow spinlock */</span>
<span class="line-removed"> 379     private static final int OVERFLOW_YIELD_RATE = 7; // must be power 2 - 1</span>
<span class="line-removed"> 380 </span>
 381     /** The number of bits to use for reader count before overflowing */
<span class="line-modified"> 382     private static final int LG_READERS = 7;</span>
 383 
 384     // Values for lock state and stamp operations
 385     private static final long RUNIT = 1L;
 386     private static final long WBIT  = 1L &lt;&lt; LG_READERS;
 387     private static final long RBITS = WBIT - 1L;
 388     private static final long RFULL = RBITS - 1L;
 389     private static final long ABITS = RBITS | WBIT;
 390     private static final long SBITS = ~RBITS; // note overlap with ABITS


 391 
 392     /*
 393      * 3 stamp modes can be distinguished by examining (m = stamp &amp; ABITS):
 394      * write mode: m == WBIT
 395      * optimistic read mode: m == 0L (even when read lock is held)
 396      * read mode: m &gt; 0L &amp;&amp; m &lt;= RFULL (the stamp is a copy of state, but the
 397      * read hold count in the stamp is unused other than to determine mode)
 398      *
 399      * This differs slightly from the encoding of state:
 400      * (state &amp; ABITS) == 0L indicates the lock is currently unlocked.
 401      * (state &amp; ABITS) == RBITS is a special transient value
 402      * indicating spin-locked to manipulate reader bits overflow.
 403      */
 404 
 405     /** Initial value for lock state; avoids failure value zero. */
 406     private static final long ORIGIN = WBIT &lt;&lt; 1;
 407 
 408     // Special value from cancelled acquire methods so caller can throw IE
 409     private static final long INTERRUPTED = 1L;
 410 
<span class="line-modified"> 411     // Values for node status; order matters</span>
<span class="line-modified"> 412     private static final int WAITING   = -1;</span>
<span class="line-modified"> 413     private static final int CANCELLED =  1;</span>
<span class="line-modified"> 414 </span>
<span class="line-modified"> 415     // Modes for nodes (int not boolean to allow arithmetic)</span>
<span class="line-modified"> 416     private static final int RMODE = 0;</span>
<span class="line-modified"> 417     private static final int WMODE = 1;</span>
<span class="line-modified"> 418 </span>
<span class="line-modified"> 419     /** Wait nodes */</span>
<span class="line-modified"> 420     static final class WNode {</span>
<span class="line-modified"> 421         volatile WNode prev;</span>
<span class="line-modified"> 422         volatile WNode next;</span>
<span class="line-modified"> 423         volatile WNode cowait;    // list of linked readers</span>
<span class="line-modified"> 424         volatile Thread thread;   // non-null while possibly parked</span>
<span class="line-modified"> 425         volatile int status;      // 0, WAITING, or CANCELLED</span>
<span class="line-modified"> 426         final int mode;           // RMODE or WMODE</span>
<span class="line-modified"> 427         WNode(int m, WNode p) { mode = m; prev = p; }</span>



































 428     }
 429 
 430     /** Head of CLH queue */
<span class="line-modified"> 431     private transient volatile WNode whead;</span>
 432     /** Tail (last) of CLH queue */
<span class="line-modified"> 433     private transient volatile WNode wtail;</span>
 434 
 435     // views
 436     transient ReadLockView readLockView;
 437     transient WriteLockView writeLockView;
 438     transient ReadWriteLockView readWriteLockView;
 439 
 440     /** Lock sequence/state */
 441     private transient volatile long state;
 442     /** extra reader count when state read count saturated */
 443     private transient int readerOverflow;
 444 
 445     /**
 446      * Creates a new lock, initially in unlocked state.
 447      */
 448     public StampedLock() {
 449         state = ORIGIN;
 450     }
 451 
<span class="line-modified"> 452     private boolean casState(long expectedValue, long newValue) {</span>
<span class="line-modified"> 453         return STATE.compareAndSet(this, expectedValue, newValue);</span>


 454     }
 455 
<span class="line-modified"> 456     private long tryWriteLock(long s) {</span>
<span class="line-modified"> 457         // assert (s &amp; ABITS) == 0L;</span>
<span class="line-modified"> 458         long next;</span>
<span class="line-modified"> 459         if (casState(s, next = s | WBIT)) {</span>
<span class="line-modified"> 460             VarHandle.storeStoreFence();</span>
<span class="line-modified"> 461             return next;</span>
 462         }
 463         return 0L;
 464     }
 465 






























 466     /**
 467      * Exclusively acquires the lock, blocking if necessary
 468      * until available.
 469      *
 470      * @return a write stamp that can be used to unlock or convert mode
 471      */
 472     @ReservedStackAccess
 473     public long writeLock() {
<span class="line-modified"> 474         long next;</span>
<span class="line-modified"> 475         return ((next = tryWriteLock()) != 0L) ? next : acquireWrite(false, 0L);</span>





 476     }
 477 
 478     /**
 479      * Exclusively acquires the lock if it is immediately available.
 480      *
 481      * @return a write stamp that can be used to unlock or convert mode,
 482      * or zero if the lock is not available
 483      */
<span class="line-removed"> 484     @ReservedStackAccess</span>
 485     public long tryWriteLock() {
<span class="line-modified"> 486         long s;</span>
<span class="line-removed"> 487         return (((s = state) &amp; ABITS) == 0L) ? tryWriteLock(s) : 0L;</span>
 488     }
 489 
 490     /**
 491      * Exclusively acquires the lock if it is available within the
 492      * given time and the current thread has not been interrupted.
 493      * Behavior under timeout and interruption matches that specified
 494      * for method {@link Lock#tryLock(long,TimeUnit)}.
 495      *
 496      * @param time the maximum time to wait for the lock
 497      * @param unit the time unit of the {@code time} argument
 498      * @return a write stamp that can be used to unlock or convert mode,
 499      * or zero if the lock is not available
 500      * @throws InterruptedException if the current thread is interrupted
 501      * before acquiring the lock
 502      */
 503     public long tryWriteLock(long time, TimeUnit unit)
 504         throws InterruptedException {
 505         long nanos = unit.toNanos(time);
 506         if (!Thread.interrupted()) {
<span class="line-modified"> 507             long next, deadline;</span>
<span class="line-modified"> 508             if ((next = tryWriteLock()) != 0L)</span>
<span class="line-modified"> 509                 return next;</span>
 510             if (nanos &lt;= 0L)
 511                 return 0L;
<span class="line-modified"> 512             if ((deadline = System.nanoTime() + nanos) == 0L)</span>
<span class="line-modified"> 513                 deadline = 1L;</span>
<span class="line-modified"> 514             if ((next = acquireWrite(true, deadline)) != INTERRUPTED)</span>
<span class="line-removed"> 515                 return next;</span>
 516         }
 517         throw new InterruptedException();
 518     }
 519 
 520     /**
 521      * Exclusively acquires the lock, blocking if necessary
 522      * until available or the current thread is interrupted.
 523      * Behavior under interruption matches that specified
 524      * for method {@link Lock#lockInterruptibly()}.
 525      *
 526      * @return a write stamp that can be used to unlock or convert mode
 527      * @throws InterruptedException if the current thread is interrupted
 528      * before acquiring the lock
 529      */
<span class="line-removed"> 530     @ReservedStackAccess</span>
 531     public long writeLockInterruptibly() throws InterruptedException {
<span class="line-modified"> 532         long next;</span>
 533         if (!Thread.interrupted() &amp;&amp;
<span class="line-modified"> 534             (next = acquireWrite(true, 0L)) != INTERRUPTED)</span>
<span class="line-modified"> 535             return next;</span>

 536         throw new InterruptedException();
 537     }
 538 
 539     /**
 540      * Non-exclusively acquires the lock, blocking if necessary
 541      * until available.
 542      *
 543      * @return a read stamp that can be used to unlock or convert mode
 544      */
 545     @ReservedStackAccess
 546     public long readLock() {
<span class="line-modified"> 547         long s, next;</span>
<span class="line-modified"> 548         // bypass acquireRead on common uncontended case</span>
<span class="line-modified"> 549         return (whead == wtail</span>
<span class="line-modified"> 550                 &amp;&amp; ((s = state) &amp; ABITS) &lt; RFULL</span>
<span class="line-modified"> 551                 &amp;&amp; casState(s, next = s + RUNIT))</span>
<span class="line-modified"> 552             ? next</span>
<span class="line-removed"> 553             : acquireRead(false, 0L);</span>
 554     }
 555 
 556     /**
 557      * Non-exclusively acquires the lock if it is immediately available.
 558      *
 559      * @return a read stamp that can be used to unlock or convert mode,
 560      * or zero if the lock is not available
 561      */
<span class="line-removed"> 562     @ReservedStackAccess</span>
 563     public long tryReadLock() {
<span class="line-modified"> 564         long s, m, next;</span>
<span class="line-removed"> 565         while ((m = (s = state) &amp; ABITS) != WBIT) {</span>
<span class="line-removed"> 566             if (m &lt; RFULL) {</span>
<span class="line-removed"> 567                 if (casState(s, next = s + RUNIT))</span>
<span class="line-removed"> 568                     return next;</span>
<span class="line-removed"> 569             }</span>
<span class="line-removed"> 570             else if ((next = tryIncReaderOverflow(s)) != 0L)</span>
<span class="line-removed"> 571                 return next;</span>
<span class="line-removed"> 572         }</span>
<span class="line-removed"> 573         return 0L;</span>
 574     }
 575 
 576     /**
 577      * Non-exclusively acquires the lock if it is available within the
 578      * given time and the current thread has not been interrupted.
 579      * Behavior under timeout and interruption matches that specified
 580      * for method {@link Lock#tryLock(long,TimeUnit)}.
 581      *
 582      * @param time the maximum time to wait for the lock
 583      * @param unit the time unit of the {@code time} argument
 584      * @return a read stamp that can be used to unlock or convert mode,
 585      * or zero if the lock is not available
 586      * @throws InterruptedException if the current thread is interrupted
 587      * before acquiring the lock
 588      */
<span class="line-removed"> 589     @ReservedStackAccess</span>
 590     public long tryReadLock(long time, TimeUnit unit)
 591         throws InterruptedException {
<span class="line-removed"> 592         long s, m, next, deadline;</span>
 593         long nanos = unit.toNanos(time);
 594         if (!Thread.interrupted()) {
<span class="line-modified"> 595             if ((m = (s = state) &amp; ABITS) != WBIT) {</span>
<span class="line-modified"> 596                 if (m &lt; RFULL) {</span>
<span class="line-modified"> 597                     if (casState(s, next = s + RUNIT))</span>
<span class="line-removed"> 598                         return next;</span>
<span class="line-removed"> 599                 }</span>
<span class="line-removed"> 600                 else if ((next = tryIncReaderOverflow(s)) != 0L)</span>
<span class="line-removed"> 601                     return next;</span>
<span class="line-removed"> 602             }</span>
 603             if (nanos &lt;= 0L)
 604                 return 0L;
<span class="line-modified"> 605             if ((deadline = System.nanoTime() + nanos) == 0L)</span>
<span class="line-modified"> 606                 deadline = 1L;</span>
<span class="line-modified"> 607             if ((next = acquireRead(true, deadline)) != INTERRUPTED)</span>
<span class="line-removed"> 608                 return next;</span>
 609         }
 610         throw new InterruptedException();
 611     }
 612 
 613     /**
 614      * Non-exclusively acquires the lock, blocking if necessary
 615      * until available or the current thread is interrupted.
 616      * Behavior under interruption matches that specified
 617      * for method {@link Lock#lockInterruptibly()}.
 618      *
 619      * @return a read stamp that can be used to unlock or convert mode
 620      * @throws InterruptedException if the current thread is interrupted
 621      * before acquiring the lock
 622      */
<span class="line-removed"> 623     @ReservedStackAccess</span>
 624     public long readLockInterruptibly() throws InterruptedException {
<span class="line-modified"> 625         long s, next;</span>
<span class="line-modified"> 626         if (!Thread.interrupted()</span>
<span class="line-modified"> 627             // bypass acquireRead on common uncontended case</span>
<span class="line-modified"> 628             &amp;&amp; ((whead == wtail</span>
<span class="line-modified"> 629                  &amp;&amp; ((s = state) &amp; ABITS) &lt; RFULL</span>
<span class="line-removed"> 630                  &amp;&amp; casState(s, next = s + RUNIT))</span>
<span class="line-removed"> 631                 ||</span>
<span class="line-removed"> 632                 (next = acquireRead(true, 0L)) != INTERRUPTED))</span>
<span class="line-removed"> 633             return next;</span>
 634         throw new InterruptedException();
 635     }
 636 
 637     /**
 638      * Returns a stamp that can later be validated, or zero
 639      * if exclusively locked.
 640      *
 641      * @return a valid optimistic read stamp, or zero if exclusively locked
 642      */
 643     public long tryOptimisticRead() {
 644         long s;
 645         return (((s = state) &amp; WBIT) == 0L) ? (s &amp; SBITS) : 0L;
 646     }
 647 
 648     /**
 649      * Returns true if the lock has not been exclusively acquired
 650      * since issuance of the given stamp. Always returns false if the
 651      * stamp is zero. Always returns true if the stamp represents a
 652      * currently held lock. Invoking this method with a value not
 653      * obtained from {@link #tryOptimisticRead} or a locking method
 654      * for this lock has no defined effect or result.
 655      *
 656      * @param stamp a stamp
 657      * @return {@code true} if the lock has not been exclusively acquired
 658      * since issuance of the given stamp; else false
 659      */
 660     public boolean validate(long stamp) {
<span class="line-modified"> 661         VarHandle.acquireFence();</span>
 662         return (stamp &amp; SBITS) == (state &amp; SBITS);
 663     }
 664 
<span class="line-removed"> 665     /**</span>
<span class="line-removed"> 666      * Returns an unlocked state, incrementing the version and</span>
<span class="line-removed"> 667      * avoiding special failure value 0L.</span>
<span class="line-removed"> 668      *</span>
<span class="line-removed"> 669      * @param s a write-locked state (or stamp)</span>
<span class="line-removed"> 670      */</span>
<span class="line-removed"> 671     private static long unlockWriteState(long s) {</span>
<span class="line-removed"> 672         return ((s += WBIT) == 0L) ? ORIGIN : s;</span>
<span class="line-removed"> 673     }</span>
<span class="line-removed"> 674 </span>
<span class="line-removed"> 675     private long unlockWriteInternal(long s) {</span>
<span class="line-removed"> 676         long next; WNode h;</span>
<span class="line-removed"> 677         STATE.setVolatile(this, next = unlockWriteState(s));</span>
<span class="line-removed"> 678         if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="line-removed"> 679             release(h);</span>
<span class="line-removed"> 680         return next;</span>
<span class="line-removed"> 681     }</span>
<span class="line-removed"> 682 </span>
 683     /**
 684      * If the lock state matches the given stamp, releases the
 685      * exclusive lock.
 686      *
 687      * @param stamp a stamp returned by a write-lock operation
 688      * @throws IllegalMonitorStateException if the stamp does
 689      * not match the current state of this lock
 690      */
 691     @ReservedStackAccess
 692     public void unlockWrite(long stamp) {
 693         if (state != stamp || (stamp &amp; WBIT) == 0L)
 694             throw new IllegalMonitorStateException();
<span class="line-modified"> 695         unlockWriteInternal(stamp);</span>
 696     }
 697 
 698     /**
 699      * If the lock state matches the given stamp, releases the
 700      * non-exclusive lock.
 701      *
 702      * @param stamp a stamp returned by a read-lock operation
 703      * @throws IllegalMonitorStateException if the stamp does
 704      * not match the current state of this lock
 705      */
 706     @ReservedStackAccess
 707     public void unlockRead(long stamp) {
<span class="line-modified"> 708         long s, m; WNode h;</span>
<span class="line-modified"> 709         while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)</span>
<span class="line-modified"> 710                &amp;&amp; (stamp &amp; RBITS) &gt; 0L</span>
<span class="line-modified"> 711                &amp;&amp; ((m = s &amp; RBITS) &gt; 0L)) {</span>
<span class="line-modified"> 712             if (m &lt; RFULL) {</span>
<span class="line-modified"> 713                 if (casState(s, s - RUNIT)) {</span>
<span class="line-modified"> 714                     if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="line-modified"> 715                         release(h);</span>
<span class="line-modified"> 716                     return;</span>

 717                 }


 718             }
<span class="line-removed"> 719             else if (tryDecReaderOverflow(s) != 0L)</span>
<span class="line-removed"> 720                 return;</span>
 721         }
 722         throw new IllegalMonitorStateException();
 723     }
 724 
 725     /**
 726      * If the lock state matches the given stamp, releases the
 727      * corresponding mode of the lock.
 728      *
 729      * @param stamp a stamp returned by a lock operation
 730      * @throws IllegalMonitorStateException if the stamp does
 731      * not match the current state of this lock
 732      */
<span class="line-removed"> 733     @ReservedStackAccess</span>
 734     public void unlock(long stamp) {
 735         if ((stamp &amp; WBIT) != 0L)
 736             unlockWrite(stamp);
 737         else
 738             unlockRead(stamp);
 739     }
 740 
 741     /**
 742      * If the lock state matches the given stamp, atomically performs one of
 743      * the following actions. If the stamp represents holding a write
 744      * lock, returns it.  Or, if a read lock, if the write lock is
 745      * available, releases the read lock and returns a write stamp.
 746      * Or, if an optimistic read, returns a write stamp only if
 747      * immediately available. This method returns zero in all other
 748      * cases.
 749      *
 750      * @param stamp a stamp
 751      * @return a valid write stamp, or zero on failure
 752      */
 753     public long tryConvertToWriteLock(long stamp) {
<span class="line-modified"> 754         long a = stamp &amp; ABITS, m, s, next;</span>
 755         while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {
 756             if ((m = s &amp; ABITS) == 0L) {
 757                 if (a != 0L)
 758                     break;
<span class="line-modified"> 759                 if ((next = tryWriteLock(s)) != 0L)</span>
<span class="line-modified"> 760                     return next;</span>
<span class="line-modified"> 761             }</span>
<span class="line-modified"> 762             else if (m == WBIT) {</span>

 763                 if (a != m)
 764                     break;
 765                 return stamp;
<span class="line-modified"> 766             }</span>
<span class="line-modified"> 767             else if (m == RUNIT &amp;&amp; a != 0L) {</span>
<span class="line-modified"> 768                 if (casState(s, next = s - RUNIT + WBIT)) {</span>
<span class="line-modified"> 769                     VarHandle.storeStoreFence();</span>
<span class="line-removed"> 770                     return next;</span>
<span class="line-removed"> 771                 }</span>
<span class="line-removed"> 772             }</span>
<span class="line-removed"> 773             else</span>
 774                 break;
 775         }
 776         return 0L;
 777     }
 778 
 779     /**
 780      * If the lock state matches the given stamp, atomically performs one of
 781      * the following actions. If the stamp represents holding a write
 782      * lock, releases it and obtains a read lock.  Or, if a read lock,
 783      * returns it. Or, if an optimistic read, acquires a read lock and
 784      * returns a read stamp only if immediately available. This method
 785      * returns zero in all other cases.
 786      *
 787      * @param stamp a stamp
 788      * @return a valid read stamp, or zero on failure
 789      */
 790     public long tryConvertToReadLock(long stamp) {
<span class="line-modified"> 791         long a, s, next; WNode h;</span>
 792         while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {
 793             if ((a = stamp &amp; ABITS) &gt;= WBIT) {
<span class="line-modified"> 794                 // write stamp</span>
<span class="line-removed"> 795                 if (s != stamp)</span>
 796                     break;
<span class="line-modified"> 797                 STATE.setVolatile(this, next = unlockWriteState(s) + RUNIT);</span>
<span class="line-modified"> 798                 if ((h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="line-modified"> 799                     release(h);</span>
<span class="line-modified"> 800                 return next;</span>
<span class="line-removed"> 801             }</span>
<span class="line-removed"> 802             else if (a == 0L) {</span>
<span class="line-removed"> 803                 // optimistic read stamp</span>
 804                 if ((s &amp; ABITS) &lt; RFULL) {
<span class="line-modified"> 805                     if (casState(s, next = s + RUNIT))</span>
<span class="line-modified"> 806                         return next;</span>
<span class="line-modified"> 807                 }</span>
<span class="line-modified"> 808                 else if ((next = tryIncReaderOverflow(s)) != 0L)</span>
<span class="line-modified"> 809                     return next;</span>
<span class="line-removed"> 810             }</span>
<span class="line-removed"> 811             else {</span>
<span class="line-removed"> 812                 // already a read stamp</span>
 813                 if ((s &amp; ABITS) == 0L)
 814                     break;
 815                 return stamp;
 816             }
 817         }
 818         return 0L;
 819     }
 820 
 821     /**
 822      * If the lock state matches the given stamp then, atomically, if the stamp
 823      * represents holding a lock, releases it and returns an
 824      * observation stamp.  Or, if an optimistic read, returns it if
 825      * validated. This method returns zero in all other cases, and so
 826      * may be useful as a form of &quot;tryUnlock&quot;.
 827      *
 828      * @param stamp a stamp
 829      * @return a valid optimistic read stamp, or zero on failure
 830      */
 831     public long tryConvertToOptimisticRead(long stamp) {
<span class="line-modified"> 832         long a, m, s, next; WNode h;</span>
<span class="line-modified"> 833         VarHandle.acquireFence();</span>
 834         while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {
 835             if ((a = stamp &amp; ABITS) &gt;= WBIT) {
<span class="line-modified"> 836                 // write stamp</span>
<span class="line-removed"> 837                 if (s != stamp)</span>
 838                     break;
<span class="line-modified"> 839                 return unlockWriteInternal(s);</span>
<span class="line-modified"> 840             }</span>
<span class="line-removed"> 841             else if (a == 0L)</span>
<span class="line-removed"> 842                 // already an optimistic read stamp</span>
 843                 return stamp;
<span class="line-modified"> 844             else if ((m = s &amp; ABITS) == 0L) // invalid read stamp</span>
 845                 break;
<span class="line-modified"> 846             else if (m &lt; RFULL) {</span>
<span class="line-modified"> 847                 if (casState(s, next = s - RUNIT)) {</span>
<span class="line-modified"> 848                     if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="line-modified"> 849                         release(h);</span>
<span class="line-modified"> 850                     return next &amp; SBITS;</span>
 851                 }
<span class="line-modified"> 852             }</span>
<span class="line-modified"> 853             else if ((next = tryDecReaderOverflow(s)) != 0L)</span>
<span class="line-removed"> 854                 return next &amp; SBITS;</span>
 855         }
 856         return 0L;
 857     }
 858 
 859     /**
 860      * Releases the write lock if it is held, without requiring a
 861      * stamp value. This method may be useful for recovery after
 862      * errors.
 863      *
 864      * @return {@code true} if the lock was held, else false
 865      */
 866     @ReservedStackAccess
 867     public boolean tryUnlockWrite() {
 868         long s;
 869         if (((s = state) &amp; WBIT) != 0L) {
<span class="line-modified"> 870             unlockWriteInternal(s);</span>
 871             return true;
 872         }
 873         return false;
 874     }
 875 
 876     /**
 877      * Releases one hold of the read lock if it is held, without
 878      * requiring a stamp value. This method may be useful for recovery
 879      * after errors.
 880      *
 881      * @return {@code true} if the read lock was held, else false
 882      */
 883     @ReservedStackAccess
 884     public boolean tryUnlockRead() {
<span class="line-modified"> 885         long s, m; WNode h;</span>
 886         while ((m = (s = state) &amp; ABITS) != 0L &amp;&amp; m &lt; WBIT) {
 887             if (m &lt; RFULL) {
 888                 if (casState(s, s - RUNIT)) {
<span class="line-modified"> 889                     if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="line-modified"> 890                         release(h);</span>
 891                     return true;
 892                 }
 893             }
 894             else if (tryDecReaderOverflow(s) != 0L)
 895                 return true;
 896         }
 897         return false;
 898     }
 899 
 900     // status monitoring methods
 901 
 902     /**
 903      * Returns combined state-held and overflow read count for given
 904      * state s.
 905      */
 906     private int getReadLockCount(long s) {
 907         long readers;
 908         if ((readers = s &amp; RBITS) &gt;= RFULL)
 909             readers = RFULL + readerOverflow;
 910         return (int) readers;
</pre>
<hr />
<pre>
1116             return tryWriteLock(time, unit) != 0L;
1117         }
1118         public void unlock() { unstampedUnlockWrite(); }
1119         public Condition newCondition() {
1120             throw new UnsupportedOperationException();
1121         }
1122     }
1123 
1124     final class ReadWriteLockView implements ReadWriteLock {
1125         public Lock readLock() { return asReadLock(); }
1126         public Lock writeLock() { return asWriteLock(); }
1127     }
1128 
1129     // Unlock methods without stamp argument checks for view classes.
1130     // Needed because view-class lock methods throw away stamps.
1131 
1132     final void unstampedUnlockWrite() {
1133         long s;
1134         if (((s = state) &amp; WBIT) == 0L)
1135             throw new IllegalMonitorStateException();
<span class="line-modified">1136         unlockWriteInternal(s);</span>
1137     }
1138 
1139     final void unstampedUnlockRead() {
<span class="line-modified">1140         long s, m; WNode h;</span>
1141         while ((m = (s = state) &amp; RBITS) &gt; 0L) {
1142             if (m &lt; RFULL) {
1143                 if (casState(s, s - RUNIT)) {
<span class="line-modified">1144                     if (m == RUNIT &amp;&amp; (h = whead) != null &amp;&amp; h.status != 0)</span>
<span class="line-modified">1145                         release(h);</span>
1146                     return;
1147                 }
1148             }
1149             else if (tryDecReaderOverflow(s) != 0L)
1150                 return;
1151         }
1152         throw new IllegalMonitorStateException();
1153     }
1154 
1155     private void readObject(java.io.ObjectInputStream s)
1156         throws java.io.IOException, ClassNotFoundException {
1157         s.defaultReadObject();
<span class="line-modified">1158         STATE.setVolatile(this, ORIGIN); // reset to unlocked state</span>
1159     }
1160 
<span class="line-modified">1161     // internals</span>
1162 
1163     /**
1164      * Tries to increment readerOverflow by first setting state
1165      * access bits value to RBITS, indicating hold of spinlock,
1166      * then updating, then releasing.
1167      *
1168      * @param s a reader overflow stamp: (s &amp; ABITS) &gt;= RFULL
1169      * @return new stamp on success, else zero
1170      */
1171     private long tryIncReaderOverflow(long s) {
1172         // assert (s &amp; ABITS) &gt;= RFULL;
<span class="line-modified">1173         if ((s &amp; ABITS) == RFULL) {</span>
<span class="line-removed">1174             if (casState(s, s | RBITS)) {</span>
<span class="line-removed">1175                 ++readerOverflow;</span>
<span class="line-removed">1176                 STATE.setVolatile(this, s);</span>
<span class="line-removed">1177                 return s;</span>
<span class="line-removed">1178             }</span>
<span class="line-removed">1179         }</span>
<span class="line-removed">1180         else if ((LockSupport.nextSecondarySeed() &amp; OVERFLOW_YIELD_RATE) == 0)</span>
<span class="line-removed">1181             Thread.yield();</span>
<span class="line-removed">1182         else</span>
1183             Thread.onSpinWait();




1184         return 0L;
1185     }
1186 
1187     /**
1188      * Tries to decrement readerOverflow.
1189      *
1190      * @param s a reader overflow stamp: (s &amp; ABITS) &gt;= RFULL
1191      * @return new stamp on success, else zero
1192      */
1193     private long tryDecReaderOverflow(long s) {
1194         // assert (s &amp; ABITS) &gt;= RFULL;
<span class="line-modified">1195         if ((s &amp; ABITS) == RFULL) {</span>
<span class="line-modified">1196             if (casState(s, s | RBITS)) {</span>
<span class="line-modified">1197                 int r; long next;</span>
<span class="line-modified">1198                 if ((r = readerOverflow) &gt; 0) {</span>
<span class="line-modified">1199                     readerOverflow = r - 1;</span>
<span class="line-modified">1200                     next = s;</span>
<span class="line-modified">1201                 }</span>
<span class="line-removed">1202                 else</span>
<span class="line-removed">1203                     next = s - RUNIT;</span>
<span class="line-removed">1204                 STATE.setVolatile(this, next);</span>
<span class="line-removed">1205                 return next;</span>
1206             }



1207         }
<span class="line-removed">1208         else if ((LockSupport.nextSecondarySeed() &amp; OVERFLOW_YIELD_RATE) == 0)</span>
<span class="line-removed">1209             Thread.yield();</span>
<span class="line-removed">1210         else</span>
<span class="line-removed">1211             Thread.onSpinWait();</span>
1212         return 0L;
1213     }
1214 


1215     /**
<span class="line-modified">1216      * Wakes up the successor of h (normally whead). This is normally</span>
<span class="line-modified">1217      * just h.next, but may require traversal from wtail if next</span>
<span class="line-modified">1218      * pointers are lagging. This may fail to wake up an acquiring</span>
<span class="line-modified">1219      * thread when one or more have been cancelled, but the cancel</span>
<span class="line-removed">1220      * methods themselves provide extra safeguards to ensure liveness.</span>
1221      */
<span class="line-modified">1222     private void release(WNode h) {</span>
<span class="line-modified">1223         if (h != null) {</span>
<span class="line-modified">1224             WNode q; Thread w;</span>
<span class="line-modified">1225             WSTATUS.compareAndSet(h, WAITING, 0);</span>
<span class="line-modified">1226             if ((q = h.next) == null || q.status == CANCELLED) {</span>
<span class="line-modified">1227                 for (WNode t = wtail; t != null &amp;&amp; t != h; t = t.prev)</span>
<span class="line-modified">1228                     if (t.status &lt;= 0)</span>
<span class="line-modified">1229                         q = t;</span>








1230             }
<span class="line-removed">1231             if (q != null &amp;&amp; (w = q.thread) != null)</span>
<span class="line-removed">1232                 LockSupport.unpark(w);</span>
1233         }
1234     }
1235 












1236     /**
<span class="line-modified">1237      * See above for explanation.</span>

1238      *
1239      * @param interruptible true if should check interrupts and if so
1240      * return INTERRUPTED
<span class="line-modified">1241      * @param deadline if nonzero, the System.nanoTime value to timeout</span>
<span class="line-modified">1242      * at (and return zero)</span>
1243      * @return next state, or INTERRUPTED
1244      */
<span class="line-modified">1245     private long acquireWrite(boolean interruptible, long deadline) {</span>
<span class="line-modified">1246         WNode node = null, p;</span>
<span class="line-modified">1247         for (int spins = -1;;) { // spin while enqueuing</span>
<span class="line-modified">1248             long m, s, ns;</span>
<span class="line-modified">1249             if ((m = (s = state) &amp; ABITS) == 0L) {</span>
<span class="line-modified">1250                 if ((ns = tryWriteLock(s)) != 0L)</span>
<span class="line-modified">1251                     return ns;</span>
<span class="line-modified">1252             }</span>
<span class="line-modified">1253             else if (spins &lt; 0)</span>
<span class="line-modified">1254                 spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : 0;</span>
<span class="line-modified">1255             else if (spins &gt; 0) {</span>
<span class="line-modified">1256                 --spins;</span>
<span class="line-modified">1257                 Thread.onSpinWait();</span>
<span class="line-modified">1258             }</span>
<span class="line-removed">1259             else if ((p = wtail) == null) { // initialize queue</span>
<span class="line-removed">1260                 WNode hd = new WNode(WMODE, null);</span>
<span class="line-removed">1261                 if (WHEAD.weakCompareAndSet(this, null, hd))</span>
<span class="line-removed">1262                     wtail = hd;</span>
<span class="line-removed">1263             }</span>
<span class="line-removed">1264             else if (node == null)</span>
<span class="line-removed">1265                 node = new WNode(WMODE, p);</span>
<span class="line-removed">1266             else if (node.prev != p)</span>
<span class="line-removed">1267                 node.prev = p;</span>
<span class="line-removed">1268             else if (WTAIL.weakCompareAndSet(this, p, node)) {</span>
<span class="line-removed">1269                 p.next = node;</span>
<span class="line-removed">1270                 break;</span>
<span class="line-removed">1271             }</span>
<span class="line-removed">1272         }</span>
<span class="line-removed">1273 </span>
<span class="line-removed">1274         boolean wasInterrupted = false;</span>
<span class="line-removed">1275         for (int spins = -1;;) {</span>
<span class="line-removed">1276             WNode h, np, pp; int ps;</span>
<span class="line-removed">1277             if ((h = whead) == p) {</span>
<span class="line-removed">1278                 if (spins &lt; 0)</span>
<span class="line-removed">1279                     spins = HEAD_SPINS;</span>
<span class="line-removed">1280                 else if (spins &lt; MAX_HEAD_SPINS)</span>
<span class="line-removed">1281                     spins &lt;&lt;= 1;</span>
<span class="line-removed">1282                 for (int k = spins; k &gt; 0; --k) { // spin at head</span>
<span class="line-removed">1283                     long s, ns;</span>
<span class="line-removed">1284                     if (((s = state) &amp; ABITS) == 0L) {</span>
<span class="line-removed">1285                         if ((ns = tryWriteLock(s)) != 0L) {</span>
<span class="line-removed">1286                             whead = node;</span>
<span class="line-removed">1287                             node.prev = null;</span>
<span class="line-removed">1288                             if (wasInterrupted)</span>
<span class="line-removed">1289                                 Thread.currentThread().interrupt();</span>
<span class="line-removed">1290                             return ns;</span>
<span class="line-removed">1291                         }</span>
<span class="line-removed">1292                     }</span>
<span class="line-removed">1293                     else</span>
<span class="line-removed">1294                         Thread.onSpinWait();</span>
<span class="line-removed">1295                 }</span>
<span class="line-removed">1296             }</span>
<span class="line-removed">1297             else if (h != null) { // help release stale waiters</span>
<span class="line-removed">1298                 WNode c; Thread w;</span>
<span class="line-removed">1299                 while ((c = h.cowait) != null) {</span>
<span class="line-removed">1300                     if (WCOWAIT.weakCompareAndSet(h, c, c.cowait) &amp;&amp;</span>
<span class="line-removed">1301                         (w = c.thread) != null)</span>
<span class="line-removed">1302                         LockSupport.unpark(w);</span>
1303                 }
1304             }
<span class="line-modified">1305             if (whead == h) {</span>
<span class="line-modified">1306                 if ((np = node.prev) != p) {</span>
<span class="line-modified">1307                     if (np != null)</span>
<span class="line-modified">1308                         (p = np).next = node;   // stale</span>
<span class="line-modified">1309                 }</span>
<span class="line-modified">1310                 else if ((ps = p.status) == 0)</span>
<span class="line-modified">1311                     WSTATUS.compareAndSet(p, 0, WAITING);</span>
<span class="line-modified">1312                 else if (ps == CANCELLED) {</span>
<span class="line-modified">1313                     if ((pp = p.prev) != null) {</span>
<span class="line-modified">1314                         node.prev = pp;</span>
<span class="line-removed">1315                         pp.next = node;</span>
<span class="line-removed">1316                     }</span>
<span class="line-removed">1317                 }</span>
<span class="line-removed">1318                 else {</span>
<span class="line-removed">1319                     long time; // 0 argument to park means no timeout</span>
<span class="line-removed">1320                     if (deadline == 0L)</span>
<span class="line-removed">1321                         time = 0L;</span>
<span class="line-removed">1322                     else if ((time = deadline - System.nanoTime()) &lt;= 0L)</span>
<span class="line-removed">1323                         return cancelWaiter(node, node, false);</span>
<span class="line-removed">1324                     Thread wt = Thread.currentThread();</span>
<span class="line-removed">1325                     node.thread = wt;</span>
<span class="line-removed">1326                     if (p.status &lt; 0 &amp;&amp; (p != h || (state &amp; ABITS) != 0L) &amp;&amp;</span>
<span class="line-removed">1327                         whead == h &amp;&amp; node.prev == p) {</span>
<span class="line-removed">1328                         if (time == 0L)</span>
<span class="line-removed">1329                             LockSupport.park(this);</span>
<span class="line-removed">1330                         else</span>
<span class="line-removed">1331                             LockSupport.parkNanos(this, time);</span>
<span class="line-removed">1332                     }</span>
<span class="line-removed">1333                     node.thread = null;</span>
<span class="line-removed">1334                     if (Thread.interrupted()) {</span>
<span class="line-removed">1335                         if (interruptible)</span>
<span class="line-removed">1336                             return cancelWaiter(node, node, true);</span>
<span class="line-removed">1337                         wasInterrupted = true;</span>
<span class="line-removed">1338                     }</span>
1339                 }































1340             }
1341         }

1342     }
1343 
1344     /**
1345      * See above for explanation.
1346      *
1347      * @param interruptible true if should check interrupts and if so
1348      * return INTERRUPTED
<span class="line-modified">1349      * @param deadline if nonzero, the System.nanoTime value to timeout</span>
<span class="line-modified">1350      * at (and return zero)</span>
1351      * @return next state, or INTERRUPTED
1352      */
<span class="line-modified">1353     private long acquireRead(boolean interruptible, long deadline) {</span>
<span class="line-modified">1354         boolean wasInterrupted = false;</span>
<span class="line-modified">1355         WNode node = null, p;</span>
<span class="line-modified">1356         for (int spins = -1;;) {</span>
<span class="line-modified">1357             WNode h;</span>
<span class="line-modified">1358             if ((h = whead) == (p = wtail)) {</span>
<span class="line-modified">1359                 for (long m, s, ns;;) {</span>
<span class="line-modified">1360                     if ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span>
<span class="line-modified">1361                         casState(s, ns = s + RUNIT) :</span>
<span class="line-modified">1362                         (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != 0L)) {</span>
<span class="line-modified">1363                         if (wasInterrupted)</span>
<span class="line-modified">1364                             Thread.currentThread().interrupt();</span>
<span class="line-modified">1365                         return ns;</span>
<span class="line-modified">1366                     }</span>
<span class="line-modified">1367                     else if (m &gt;= WBIT) {</span>
<span class="line-modified">1368                         if (spins &gt; 0) {</span>
<span class="line-modified">1369                             --spins;</span>
<span class="line-modified">1370                             Thread.onSpinWait();</span>
<span class="line-modified">1371                         }</span>
<span class="line-modified">1372                         else {</span>
<span class="line-modified">1373                             if (spins == 0) {</span>
<span class="line-modified">1374                                 WNode nh = whead, np = wtail;</span>
<span class="line-modified">1375                                 if ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))</span>
<span class="line-modified">1376                                     break;</span>
<span class="line-modified">1377                             }</span>
<span class="line-removed">1378                             spins = SPINS;</span>
<span class="line-removed">1379                         }</span>
1380                     }

1381                 }
<span class="line-modified">1382             }</span>
<span class="line-modified">1383             if (p == null) { // initialize queue</span>
<span class="line-modified">1384                 WNode hd = new WNode(WMODE, null);</span>
<span class="line-modified">1385                 if (WHEAD.weakCompareAndSet(this, null, hd))</span>
<span class="line-modified">1386                     wtail = hd;</span>
<span class="line-modified">1387             }</span>
<span class="line-modified">1388             else if (node == null)</span>
<span class="line-modified">1389                 node = new WNode(RMODE, p);</span>
<span class="line-modified">1390             else if (h == p || p.mode != RMODE) {</span>
<span class="line-modified">1391                 if (node.prev != p)</span>
<span class="line-modified">1392                     node.prev = p;</span>
<span class="line-modified">1393                 else if (WTAIL.weakCompareAndSet(this, p, node)) {</span>
<span class="line-modified">1394                     p.next = node;</span>
<span class="line-modified">1395                     break;</span>
<span class="line-modified">1396                 }</span>
<span class="line-modified">1397             }</span>
<span class="line-modified">1398             else if (!WCOWAIT.compareAndSet(p, node.cowait = p.cowait, node))</span>
<span class="line-modified">1399                 node.cowait = null;</span>
<span class="line-modified">1400             else {</span>
<span class="line-modified">1401                 for (;;) {</span>
<span class="line-modified">1402                     WNode pp, c; Thread w;</span>
<span class="line-modified">1403                     if ((h = whead) != null &amp;&amp; (c = h.cowait) != null &amp;&amp;</span>
<span class="line-modified">1404                         WCOWAIT.compareAndSet(h, c, c.cowait) &amp;&amp;</span>
<span class="line-modified">1405                         (w = c.thread) != null) // help release</span>
<span class="line-removed">1406                         LockSupport.unpark(w);</span>
<span class="line-removed">1407                     if (Thread.interrupted()) {</span>
<span class="line-removed">1408                         if (interruptible)</span>
<span class="line-removed">1409                             return cancelWaiter(node, p, true);</span>
<span class="line-removed">1410                         wasInterrupted = true;</span>
<span class="line-removed">1411                     }</span>
<span class="line-removed">1412                     if (h == (pp = p.prev) || h == p || pp == null) {</span>
<span class="line-removed">1413                         long m, s, ns;</span>
<span class="line-removed">1414                         do {</span>
<span class="line-removed">1415                             if ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span>
<span class="line-removed">1416                                 casState(s, ns = s + RUNIT) :</span>
<span class="line-removed">1417                                 (m &lt; WBIT &amp;&amp;</span>
<span class="line-removed">1418                                  (ns = tryIncReaderOverflow(s)) != 0L)) {</span>
<span class="line-removed">1419                                 if (wasInterrupted)</span>
<span class="line-removed">1420                                     Thread.currentThread().interrupt();</span>
<span class="line-removed">1421                                 return ns;</span>
<span class="line-removed">1422                             }</span>
<span class="line-removed">1423                         } while (m &lt; WBIT);</span>
<span class="line-removed">1424                     }</span>
<span class="line-removed">1425                     if (whead == h &amp;&amp; p.prev == pp) {</span>
<span class="line-removed">1426                         long time;</span>
<span class="line-removed">1427                         if (pp == null || h == p || p.status &gt; 0) {</span>
<span class="line-removed">1428                             node = null; // throw away</span>
<span class="line-removed">1429                             break;</span>
<span class="line-removed">1430                         }</span>
<span class="line-removed">1431                         if (deadline == 0L)</span>
<span class="line-removed">1432                             time = 0L;</span>
<span class="line-removed">1433                         else if ((time = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="line-removed">1434                             if (wasInterrupted)</span>
<span class="line-removed">1435                                 Thread.currentThread().interrupt();</span>
<span class="line-removed">1436                             return cancelWaiter(node, p, false);</span>
<span class="line-removed">1437                         }</span>
<span class="line-removed">1438                         Thread wt = Thread.currentThread();</span>
<span class="line-removed">1439                         node.thread = wt;</span>
<span class="line-removed">1440                         if ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;</span>
<span class="line-removed">1441                             whead == h &amp;&amp; p.prev == pp) {</span>
<span class="line-removed">1442                             if (time == 0L)</span>
<span class="line-removed">1443                                 LockSupport.park(this);</span>
<span class="line-removed">1444                             else</span>
<span class="line-removed">1445                                 LockSupport.parkNanos(this, time);</span>
<span class="line-removed">1446                         }</span>
<span class="line-removed">1447                         node.thread = null;</span>
1448                     }
1449                 }










1450             }
1451         }
1452 
<span class="line-modified">1453         for (int spins = -1;;) {</span>
<span class="line-modified">1454             WNode h, np, pp; int ps;</span>
<span class="line-modified">1455             if ((h = whead) == p) {</span>
<span class="line-modified">1456                 if (spins &lt; 0)</span>
<span class="line-modified">1457                     spins = HEAD_SPINS;</span>
<span class="line-modified">1458                 else if (spins &lt; MAX_HEAD_SPINS)</span>
<span class="line-modified">1459                     spins &lt;&lt;= 1;</span>
<span class="line-modified">1460                 for (int k = spins;;) { // spin at head</span>
<span class="line-modified">1461                     long m, s, ns;</span>
<span class="line-modified">1462                     if ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span>
<span class="line-modified">1463                         casState(s, ns = s + RUNIT) :</span>
<span class="line-modified">1464                         (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != 0L)) {</span>
<span class="line-modified">1465                         WNode c; Thread w;</span>
<span class="line-removed">1466                         whead = node;</span>
<span class="line-removed">1467                         node.prev = null;</span>
<span class="line-removed">1468                         while ((c = node.cowait) != null) {</span>
<span class="line-removed">1469                             if (WCOWAIT.compareAndSet(node, c, c.cowait) &amp;&amp;</span>
<span class="line-removed">1470                                 (w = c.thread) != null)</span>
<span class="line-removed">1471                                 LockSupport.unpark(w);</span>
<span class="line-removed">1472                         }</span>
<span class="line-removed">1473                         if (wasInterrupted)</span>
<span class="line-removed">1474                             Thread.currentThread().interrupt();</span>
<span class="line-removed">1475                         return ns;</span>
<span class="line-removed">1476                     }</span>
<span class="line-removed">1477                     else if (m &gt;= WBIT &amp;&amp; --k &lt;= 0)</span>
<span class="line-removed">1478                         break;</span>
<span class="line-removed">1479                     else</span>
<span class="line-removed">1480                         Thread.onSpinWait();</span>
1481                 }
1482             }
<span class="line-modified">1483             else if (h != null) {</span>
<span class="line-modified">1484                 WNode c; Thread w;</span>
<span class="line-modified">1485                 while ((c = h.cowait) != null) {</span>
<span class="line-modified">1486                     if (WCOWAIT.compareAndSet(h, c, c.cowait) &amp;&amp;</span>
<span class="line-modified">1487                         (w = c.thread) != null)</span>
<span class="line-modified">1488                         LockSupport.unpark(w);</span>

1489                 }























1490             }
<span class="line-modified">1491             if (whead == h) {</span>
<span class="line-modified">1492                 if ((np = node.prev) != p) {</span>
<span class="line-modified">1493                     if (np != null)</span>
<span class="line-modified">1494                         (p = np).next = node;   // stale</span>
<span class="line-modified">1495                 }</span>
<span class="line-modified">1496                 else if ((ps = p.status) == 0)</span>
<span class="line-modified">1497                     WSTATUS.compareAndSet(p, 0, WAITING);</span>
<span class="line-modified">1498                 else if (ps == CANCELLED) {</span>
<span class="line-modified">1499                     if ((pp = p.prev) != null) {</span>
<span class="line-modified">1500                         node.prev = pp;</span>
<span class="line-modified">1501                         pp.next = node;</span>













1502                     }

1503                 }
<span class="line-modified">1504                 else {</span>
<span class="line-modified">1505                     long time;</span>
<span class="line-modified">1506                     if (deadline == 0L)</span>
<span class="line-modified">1507                         time = 0L;</span>
<span class="line-modified">1508                     else if ((time = deadline - System.nanoTime()) &lt;= 0L)</span>
<span class="line-removed">1509                         return cancelWaiter(node, node, false);</span>
<span class="line-removed">1510                     Thread wt = Thread.currentThread();</span>
<span class="line-removed">1511                     node.thread = wt;</span>
<span class="line-removed">1512                     if (p.status &lt; 0 &amp;&amp;</span>
<span class="line-removed">1513                         (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;</span>
<span class="line-removed">1514                         whead == h &amp;&amp; node.prev == p) {</span>
<span class="line-removed">1515                             if (time == 0L)</span>
<span class="line-removed">1516                                 LockSupport.park(this);</span>
<span class="line-removed">1517                             else</span>
<span class="line-removed">1518                                 LockSupport.parkNanos(this, time);</span>
1519                     }
<span class="line-modified">1520                     node.thread = null;</span>
<span class="line-modified">1521                     if (Thread.interrupted()) {</span>
<span class="line-modified">1522                         if (interruptible)</span>
<span class="line-modified">1523                             return cancelWaiter(node, node, true);</span>
<span class="line-modified">1524                         wasInterrupted = true;</span>
















1525                     }
1526                 }
1527             }
1528         }
1529     }
1530 
1531     /**
1532      * If node non-null, forces cancel status and unsplices it from
<span class="line-modified">1533      * queue if possible and wakes up any cowaiters (of the node, or</span>
<span class="line-modified">1534      * group, as applicable), and in any case helps release current</span>
<span class="line-removed">1535      * first waiter if lock is free. (Calling with null arguments</span>
<span class="line-removed">1536      * serves as a conditional form of release, which is not currently</span>
<span class="line-removed">1537      * needed but may be needed under possible future cancellation</span>
<span class="line-removed">1538      * policies). This is a variant of cancellation methods in</span>
<span class="line-removed">1539      * AbstractQueuedSynchronizer (see its detailed explanation in AQS</span>
<span class="line-removed">1540      * internal documentation).</span>
1541      *
<span class="line-modified">1542      * @param node if non-null, the waiter</span>
<span class="line-removed">1543      * @param group either node or the group node is cowaiting with</span>
1544      * @param interrupted if already interrupted
1545      * @return INTERRUPTED if interrupted or Thread.interrupted, else zero
1546      */
<span class="line-modified">1547     private long cancelWaiter(WNode node, WNode group, boolean interrupted) {</span>
<span class="line-modified">1548         if (node != null &amp;&amp; group != null) {</span>
<span class="line-modified">1549             Thread w;</span>
1550             node.status = CANCELLED;
<span class="line-modified">1551             // unsplice cancelled nodes from group</span>
<span class="line-modified">1552             for (WNode p = group, q; (q = p.cowait) != null;) {</span>
<span class="line-modified">1553                 if (q.status == CANCELLED) {</span>
<span class="line-removed">1554                     WCOWAIT.compareAndSet(p, q, q.cowait);</span>
<span class="line-removed">1555                     p = group; // restart</span>
<span class="line-removed">1556                 }</span>
<span class="line-removed">1557                 else</span>
<span class="line-removed">1558                     p = q;</span>
<span class="line-removed">1559             }</span>
<span class="line-removed">1560             if (group == node) {</span>
<span class="line-removed">1561                 for (WNode r = group.cowait; r != null; r = r.cowait) {</span>
<span class="line-removed">1562                     if ((w = r.thread) != null)</span>
<span class="line-removed">1563                         LockSupport.unpark(w); // wake up uncancelled co-waiters</span>
<span class="line-removed">1564                 }</span>
<span class="line-removed">1565                 for (WNode pred = node.prev; pred != null; ) { // unsplice</span>
<span class="line-removed">1566                     WNode succ, pp;        // find valid successor</span>
<span class="line-removed">1567                     while ((succ = node.next) == null ||</span>
<span class="line-removed">1568                            succ.status == CANCELLED) {</span>
<span class="line-removed">1569                         WNode q = null;    // find successor the slow way</span>
<span class="line-removed">1570                         for (WNode t = wtail; t != null &amp;&amp; t != node; t = t.prev)</span>
<span class="line-removed">1571                             if (t.status != CANCELLED)</span>
<span class="line-removed">1572                                 q = t;     // don&#39;t link if succ cancelled</span>
<span class="line-removed">1573                         if (succ == q ||   // ensure accurate successor</span>
<span class="line-removed">1574                             WNEXT.compareAndSet(node, succ, succ = q)) {</span>
<span class="line-removed">1575                             if (succ == null &amp;&amp; node == wtail)</span>
<span class="line-removed">1576                                 WTAIL.compareAndSet(this, node, pred);</span>
<span class="line-removed">1577                             break;</span>
<span class="line-removed">1578                         }</span>
<span class="line-removed">1579                     }</span>
<span class="line-removed">1580                     if (pred.next == node) // unsplice pred link</span>
<span class="line-removed">1581                         WNEXT.compareAndSet(pred, node, succ);</span>
<span class="line-removed">1582                     if (succ != null &amp;&amp; (w = succ.thread) != null) {</span>
<span class="line-removed">1583                         // wake up succ to observe new pred</span>
<span class="line-removed">1584                         succ.thread = null;</span>
<span class="line-removed">1585                         LockSupport.unpark(w);</span>
<span class="line-removed">1586                     }</span>
<span class="line-removed">1587                     if (pred.status != CANCELLED || (pp = pred.prev) == null)</span>
<span class="line-removed">1588                         break;</span>
<span class="line-removed">1589                     node.prev = pp;        // repeat if new pred wrong/cancelled</span>
<span class="line-removed">1590                     WNEXT.compareAndSet(pp, pred, succ);</span>
<span class="line-removed">1591                     pred = pp;</span>
<span class="line-removed">1592                 }</span>
<span class="line-removed">1593             }</span>
1594         }
<span class="line-modified">1595         WNode h; // Possibly release first waiter</span>
<span class="line-modified">1596         while ((h = whead) != null) {</span>
<span class="line-modified">1597             long s; WNode q; // similar to release() but check eligibility</span>
<span class="line-modified">1598             if ((q = h.next) == null || q.status == CANCELLED) {</span>
<span class="line-modified">1599                 for (WNode t = wtail; t != null &amp;&amp; t != h; t = t.prev)</span>
<span class="line-modified">1600                     if (t.status &lt;= 0)</span>
<span class="line-modified">1601                         q = t;</span>
<span class="line-modified">1602             }</span>
<span class="line-modified">1603             if (h == whead) {</span>
<span class="line-modified">1604                 if (q != null &amp;&amp; h.status == 0 &amp;&amp;</span>
<span class="line-modified">1605                     ((s = state) &amp; ABITS) != WBIT &amp;&amp; // waiter is eligible</span>
<span class="line-modified">1606                     (s == 0L || q.mode == RMODE))</span>
<span class="line-modified">1607                     release(h);</span>
<span class="line-modified">1608                 break;</span>
<span class="line-modified">1609             }</span>



1610         }
1611         return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;
1612     }
1613 
<span class="line-modified">1614     // VarHandle mechanics</span>
<span class="line-modified">1615     private static final VarHandle STATE;</span>
<span class="line-modified">1616     private static final VarHandle WHEAD;</span>
<span class="line-modified">1617     private static final VarHandle WTAIL;</span>
<span class="line-modified">1618     private static final VarHandle WNEXT;</span>
<span class="line-modified">1619     private static final VarHandle WSTATUS;</span>
<span class="line-modified">1620     private static final VarHandle WCOWAIT;</span>


1621     static {
<span class="line-modified">1622         try {</span>
<span class="line-removed">1623             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-removed">1624             STATE = l.findVarHandle(StampedLock.class, &quot;state&quot;, long.class);</span>
<span class="line-removed">1625             WHEAD = l.findVarHandle(StampedLock.class, &quot;whead&quot;, WNode.class);</span>
<span class="line-removed">1626             WTAIL = l.findVarHandle(StampedLock.class, &quot;wtail&quot;, WNode.class);</span>
<span class="line-removed">1627             WSTATUS = l.findVarHandle(WNode.class, &quot;status&quot;, int.class);</span>
<span class="line-removed">1628             WNEXT = l.findVarHandle(WNode.class, &quot;next&quot;, WNode.class);</span>
<span class="line-removed">1629             WCOWAIT = l.findVarHandle(WNode.class, &quot;cowait&quot;, WNode.class);</span>
<span class="line-removed">1630         } catch (ReflectiveOperationException e) {</span>
<span class="line-removed">1631             throw new ExceptionInInitializerError(e);</span>
<span class="line-removed">1632         }</span>
1633     }
1634 }
</pre>
</td>
<td>
<hr />
<pre>
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent.locks;
  37 


  38 import java.util.concurrent.TimeUnit;
<span class="line-added">  39 import jdk.internal.misc.Unsafe;</span>
  40 import jdk.internal.vm.annotation.ReservedStackAccess;
  41 
  42 /**
  43  * A capability-based lock with three modes for controlling read/write
  44  * access.  The state of a StampedLock consists of a version and mode.
  45  * Lock acquisition methods return a stamp that represents and
  46  * controls access with respect to a lock state; &quot;try&quot; versions of
  47  * these methods may instead return the special value zero to
  48  * represent failure to acquire access. Lock release and conversion
  49  * methods require stamps as arguments, and fail if they do not match
  50  * the state of the lock. The three modes are:
  51  *
  52  * &lt;ul&gt;
  53  *
  54  *  &lt;li&gt;&lt;b&gt;Writing.&lt;/b&gt; Method {@link #writeLock} possibly blocks
  55  *   waiting for exclusive access, returning a stamp that can be used
  56  *   in method {@link #unlockWrite} to release the lock. Untimed and
  57  *   timed versions of {@code tryWriteLock} are also provided. When
  58  *   the lock is held in write mode, no read locks may be obtained,
  59  *   and all optimistic read validations will fail.
</pre>
<hr />
<pre>
 114  * &lt;p&gt;Like {@link java.util.concurrent.Semaphore Semaphore}, but unlike most
 115  * {@link Lock} implementations, StampedLocks have no notion of ownership.
 116  * Locks acquired in one thread can be released or converted in another.
 117  *
 118  * &lt;p&gt;The scheduling policy of StampedLock does not consistently
 119  * prefer readers over writers or vice versa.  All &quot;try&quot; methods are
 120  * best-effort and do not necessarily conform to any scheduling or
 121  * fairness policy. A zero return from any &quot;try&quot; method for acquiring
 122  * or converting locks does not carry any information about the state
 123  * of the lock; a subsequent invocation may succeed.
 124  *
 125  * &lt;p&gt;Because it supports coordinated usage across multiple lock
 126  * modes, this class does not directly implement the {@link Lock} or
 127  * {@link ReadWriteLock} interfaces. However, a StampedLock may be
 128  * viewed {@link #asReadLock()}, {@link #asWriteLock()}, or {@link
 129  * #asReadWriteLock()} in applications requiring only the associated
 130  * set of functionality.
 131  *
 132  * &lt;p&gt;&lt;b&gt;Memory Synchronization.&lt;/b&gt; Methods with the effect of
 133  * successfully locking in any mode have the same memory
<span class="line-modified"> 134  * synchronization effects as a &lt;em&gt;Lock&lt;/em&gt; action, as described in</span>
<span class="line-modified"> 135  * Chapter 17 of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>

 136  * Methods successfully unlocking in write mode have the same memory
 137  * synchronization effects as an &lt;em&gt;Unlock&lt;/em&gt; action.  In optimistic
 138  * read usages, actions prior to the most recent write mode unlock action
 139  * are guaranteed to happen-before those following a tryOptimisticRead
 140  * only if a later validate returns true; otherwise there is no guarantee
 141  * that the reads between tryOptimisticRead and validate obtain a
 142  * consistent snapshot.
 143  *
 144  * &lt;p&gt;&lt;b&gt;Sample Usage.&lt;/b&gt; The following illustrates some usage idioms
 145  * in a class that maintains simple two-dimensional points. The sample
 146  * code illustrates some try/catch conventions even though they are
 147  * not strictly needed here because no exceptions can occur in their
 148  * bodies.
 149  *
 150  * &lt;pre&gt; {@code
 151  * class Point {
 152  *   private double x, y;
 153  *   private final StampedLock sl = new StampedLock();
 154  *
 155  *   // an exclusively locked method
</pre>
<hr />
<pre>
 218  *     try {
 219  *       while (x == 0.0 &amp;&amp; y == 0.0) {
 220  *         long ws = sl.tryConvertToWriteLock(stamp);
 221  *         if (ws != 0L) {
 222  *           stamp = ws;
 223  *           x = newX;
 224  *           y = newY;
 225  *           break;
 226  *         }
 227  *         else {
 228  *           sl.unlockRead(stamp);
 229  *           stamp = sl.writeLock();
 230  *         }
 231  *       }
 232  *     } finally {
 233  *       sl.unlock(stamp);
 234  *     }
 235  *   }
 236  * }}&lt;/pre&gt;
 237  *
<span class="line-added"> 238  * @jls 17.4 Memory Model</span>
 239  * @since 1.8
 240  * @author Doug Lea
 241  */
 242 public class StampedLock implements java.io.Serializable {
 243     /*
 244      * Algorithmic notes:
 245      *
 246      * The design employs elements of Sequence locks
 247      * (as used in linux kernels; see Lameter&#39;s
 248      * http://www.lameter.com/gelato2005.pdf
 249      * and elsewhere; see
 250      * Boehm&#39;s http://www.hpl.hp.com/techreports/2012/HPL-2012-68.html)
 251      * and Ordered RW locks (see Shirako et al
 252      * http://dl.acm.org/citation.cfm?id=2312015)
 253      *
 254      * Conceptually, the primary state of the lock includes a sequence
 255      * number that is odd when write-locked and even otherwise.
 256      * However, this is offset by a reader count that is non-zero when
 257      * read-locked.  The read count is ignored when validating
 258      * &quot;optimistic&quot; seqlock-reader-style stamps.  Because we must use
 259      * a small finite number of bits (currently 7) for readers, a
 260      * supplementary reader overflow word is used when the number of
 261      * readers exceeds the count field. We do this by treating the max
 262      * reader count value (RBITS) as a spinlock protecting overflow
 263      * updates.
 264      *
 265      * Waiters use a modified form of CLH lock used in
<span class="line-modified"> 266      * AbstractQueuedSynchronizer (AQS; see its internal documentation</span>
<span class="line-modified"> 267      * for a fuller account), where each node is either a ReaderNode</span>
<span class="line-modified"> 268      * or WriterNode. Implementation of queued Writer mode is</span>
<span class="line-modified"> 269      * identical to AQS except for lock-state operations.  Sets of</span>
<span class="line-modified"> 270      * waiting readers are grouped (linked) under a common node (field</span>
<span class="line-modified"> 271      * cowaiters) so act as a single node with respect to most CLH</span>
<span class="line-modified"> 272      * mechanics.  This simplifies the scheduling policy to a</span>
<span class="line-modified"> 273      * mainly-FIFO scheme that incorporates elements of Phase-Fair</span>
<span class="line-modified"> 274      * locks (see Brandenburg &amp; Anderson, especially</span>
<span class="line-modified"> 275      * http://www.cs.unc.edu/~bbb/diss/).  Method release does not</span>
<span class="line-modified"> 276      * itself wake up cowaiters. This is done by the primary thread,</span>
<span class="line-modified"> 277      * but helped by other cowaiters as they awaken.</span>







 278      *
<span class="line-modified"> 279      * These rules apply to threads actually queued. Threads may also</span>
<span class="line-modified"> 280      * try to acquire locks before or in the process of enqueueing</span>
<span class="line-modified"> 281      * regardless of preference rules, and so may &quot;barge&quot; their way</span>
<span class="line-modified"> 282      * in.  Methods writeLock and readLock (but not the other variants</span>
<span class="line-modified"> 283      * of each) first unconditionally try to CAS state, falling back</span>
<span class="line-modified"> 284      * to test-and-test-and-set retries on failure, slightly shrinking</span>
<span class="line-modified"> 285      * race windows on initial attempts, thus making success more</span>
<span class="line-modified"> 286      * likely. Also, when some threads cancel (via interrupt or</span>
<span class="line-modified"> 287      * timeout), phase-fairness is at best roughly approximated.</span>


 288      *
 289      * Nearly all of these mechanics are carried out in methods
 290      * acquireWrite and acquireRead, that, as typical of such code,
 291      * sprawl out because actions and retries rely on consistent sets
 292      * of locally cached reads.
 293      *
<span class="line-modified"> 294      * For an explanation of the use of acquireFence, see</span>
<span class="line-modified"> 295      * http://gee.cs.oswego.edu/dl/html/j9mm.html as well as Boehm&#39;s</span>
<span class="line-modified"> 296      * paper (above). Note that sequence validation (mainly method</span>
<span class="line-modified"> 297      * validate()) requires stricter ordering rules than apply to</span>
<span class="line-modified"> 298      * normal volatile reads (of &quot;state&quot;).  To ensure that writeLock</span>
<span class="line-modified"> 299      * acquisitions strictly precede subsequent writes in cases where</span>
<span class="line-modified"> 300      * this is not already forced, we use a storeStoreFence.</span>












































 301      *
 302      * The memory layout keeps lock state and queue pointers together
 303      * (normally on the same cache line). This usually works well for
 304      * read-mostly loads. In most other cases, the natural tendency of
<span class="line-modified"> 305      * CLH locks to reduce memory contention lessens motivation to</span>
<span class="line-modified"> 306      * further spread out contended locations, but might be subject to</span>
<span class="line-modified"> 307      * future improvements.</span>
 308      */
 309 
 310     private static final long serialVersionUID = -6001602636862214147L;
 311 















 312     /** The number of bits to use for reader count before overflowing */
<span class="line-modified"> 313     private static final int LG_READERS = 7; // 127 readers</span>
 314 
 315     // Values for lock state and stamp operations
 316     private static final long RUNIT = 1L;
 317     private static final long WBIT  = 1L &lt;&lt; LG_READERS;
 318     private static final long RBITS = WBIT - 1L;
 319     private static final long RFULL = RBITS - 1L;
 320     private static final long ABITS = RBITS | WBIT;
 321     private static final long SBITS = ~RBITS; // note overlap with ABITS
<span class="line-added"> 322     // not writing and conservatively non-overflowing</span>
<span class="line-added"> 323     private static final long RSAFE = ~(3L &lt;&lt; (LG_READERS - 1));</span>
 324 
 325     /*
 326      * 3 stamp modes can be distinguished by examining (m = stamp &amp; ABITS):
 327      * write mode: m == WBIT
 328      * optimistic read mode: m == 0L (even when read lock is held)
 329      * read mode: m &gt; 0L &amp;&amp; m &lt;= RFULL (the stamp is a copy of state, but the
 330      * read hold count in the stamp is unused other than to determine mode)
 331      *
 332      * This differs slightly from the encoding of state:
 333      * (state &amp; ABITS) == 0L indicates the lock is currently unlocked.
 334      * (state &amp; ABITS) == RBITS is a special transient value
 335      * indicating spin-locked to manipulate reader bits overflow.
 336      */
 337 
 338     /** Initial value for lock state; avoids failure value zero. */
 339     private static final long ORIGIN = WBIT &lt;&lt; 1;
 340 
 341     // Special value from cancelled acquire methods so caller can throw IE
 342     private static final long INTERRUPTED = 1L;
 343 
<span class="line-modified"> 344     // Bits for Node.status</span>
<span class="line-modified"> 345     static final int WAITING   = 1;</span>
<span class="line-modified"> 346     static final int CANCELLED = 0x80000000; // must be negative</span>
<span class="line-modified"> 347 </span>
<span class="line-modified"> 348     /** CLH nodes */</span>
<span class="line-modified"> 349     abstract static class Node {</span>
<span class="line-modified"> 350         volatile Node prev;       // initially attached via casTail</span>
<span class="line-modified"> 351         volatile Node next;       // visibly nonnull when signallable</span>
<span class="line-modified"> 352         Thread waiter;            // visibly nonnull when enqueued</span>
<span class="line-modified"> 353         volatile int status;      // written by owner, atomic bit ops by others</span>
<span class="line-modified"> 354 </span>
<span class="line-modified"> 355         // methods for atomic operations</span>
<span class="line-modified"> 356         final boolean casPrev(Node c, Node v) {  // for cleanQueue</span>
<span class="line-modified"> 357             return U.weakCompareAndSetReference(this, PREV, c, v);</span>
<span class="line-modified"> 358         }</span>
<span class="line-modified"> 359         final boolean casNext(Node c, Node v) {  // for cleanQueue</span>
<span class="line-modified"> 360             return U.weakCompareAndSetReference(this, NEXT, c, v);</span>
<span class="line-added"> 361         }</span>
<span class="line-added"> 362         final int getAndUnsetStatus(int v) {     // for signalling</span>
<span class="line-added"> 363             return U.getAndBitwiseAndInt(this, STATUS, ~v);</span>
<span class="line-added"> 364         }</span>
<span class="line-added"> 365         final void setPrevRelaxed(Node p) {      // for off-queue assignment</span>
<span class="line-added"> 366             U.putReference(this, PREV, p);</span>
<span class="line-added"> 367         }</span>
<span class="line-added"> 368         final void setStatusRelaxed(int s) {     // for off-queue assignment</span>
<span class="line-added"> 369             U.putInt(this, STATUS, s);</span>
<span class="line-added"> 370         }</span>
<span class="line-added"> 371         final void clearStatus() {               // for reducing unneeded signals</span>
<span class="line-added"> 372             U.putIntOpaque(this, STATUS, 0);</span>
<span class="line-added"> 373         }</span>
<span class="line-added"> 374 </span>
<span class="line-added"> 375         private static final long STATUS</span>
<span class="line-added"> 376             = U.objectFieldOffset(Node.class, &quot;status&quot;);</span>
<span class="line-added"> 377         private static final long NEXT</span>
<span class="line-added"> 378             = U.objectFieldOffset(Node.class, &quot;next&quot;);</span>
<span class="line-added"> 379         private static final long PREV</span>
<span class="line-added"> 380             = U.objectFieldOffset(Node.class, &quot;prev&quot;);</span>
<span class="line-added"> 381     }</span>
<span class="line-added"> 382 </span>
<span class="line-added"> 383     static final class WriterNode extends Node { // node for writers</span>
<span class="line-added"> 384     }</span>
<span class="line-added"> 385 </span>
<span class="line-added"> 386     static final class ReaderNode extends Node { // node for readers</span>
<span class="line-added"> 387         volatile ReaderNode cowaiters;           // list of linked readers</span>
<span class="line-added"> 388         final boolean casCowaiters(ReaderNode c, ReaderNode v) {</span>
<span class="line-added"> 389             return U.weakCompareAndSetReference(this, COWAITERS, c, v);</span>
<span class="line-added"> 390         }</span>
<span class="line-added"> 391         final void setCowaitersRelaxed(ReaderNode p) {</span>
<span class="line-added"> 392             U.putReference(this, COWAITERS, p);</span>
<span class="line-added"> 393         }</span>
<span class="line-added"> 394         private static final long COWAITERS</span>
<span class="line-added"> 395             = U.objectFieldOffset(ReaderNode.class, &quot;cowaiters&quot;);</span>
 396     }
 397 
 398     /** Head of CLH queue */
<span class="line-modified"> 399     private transient volatile Node head;</span>
 400     /** Tail (last) of CLH queue */
<span class="line-modified"> 401     private transient volatile Node tail;</span>
 402 
 403     // views
 404     transient ReadLockView readLockView;
 405     transient WriteLockView writeLockView;
 406     transient ReadWriteLockView readWriteLockView;
 407 
 408     /** Lock sequence/state */
 409     private transient volatile long state;
 410     /** extra reader count when state read count saturated */
 411     private transient int readerOverflow;
 412 
 413     /**
 414      * Creates a new lock, initially in unlocked state.
 415      */
 416     public StampedLock() {
 417         state = ORIGIN;
 418     }
 419 
<span class="line-modified"> 420     // internal lock methods</span>
<span class="line-modified"> 421 </span>
<span class="line-added"> 422     private boolean casState(long expect, long update) {</span>
<span class="line-added"> 423         return U.compareAndSetLong(this, STATE, expect, update);</span>
 424     }
 425 
<span class="line-modified"> 426     @ReservedStackAccess</span>
<span class="line-modified"> 427     private long tryAcquireWrite() {</span>
<span class="line-modified"> 428         long s, nextState;</span>
<span class="line-modified"> 429         if (((s = state) &amp; ABITS) == 0L &amp;&amp; casState(s, nextState = s | WBIT)) {</span>
<span class="line-modified"> 430             U.storeStoreFence();</span>
<span class="line-modified"> 431             return nextState;</span>
 432         }
 433         return 0L;
 434     }
 435 
<span class="line-added"> 436     @ReservedStackAccess</span>
<span class="line-added"> 437     private long tryAcquireRead() {</span>
<span class="line-added"> 438         for (long s, m, nextState;;) {</span>
<span class="line-added"> 439             if ((m = (s = state) &amp; ABITS) &lt; RFULL) {</span>
<span class="line-added"> 440                 if (casState(s, nextState = s + RUNIT))</span>
<span class="line-added"> 441                     return nextState;</span>
<span class="line-added"> 442             }</span>
<span class="line-added"> 443             else if (m == WBIT)</span>
<span class="line-added"> 444                 return 0L;</span>
<span class="line-added"> 445             else if ((nextState = tryIncReaderOverflow(s)) != 0L)</span>
<span class="line-added"> 446                 return nextState;</span>
<span class="line-added"> 447         }</span>
<span class="line-added"> 448     }</span>
<span class="line-added"> 449 </span>
<span class="line-added"> 450     /**</span>
<span class="line-added"> 451      * Returns an unlocked state, incrementing the version and</span>
<span class="line-added"> 452      * avoiding special failure value 0L.</span>
<span class="line-added"> 453      *</span>
<span class="line-added"> 454      * @param s a write-locked state (or stamp)</span>
<span class="line-added"> 455      */</span>
<span class="line-added"> 456     private static long unlockWriteState(long s) {</span>
<span class="line-added"> 457         return ((s += WBIT) == 0L) ? ORIGIN : s;</span>
<span class="line-added"> 458     }</span>
<span class="line-added"> 459 </span>
<span class="line-added"> 460     private long releaseWrite(long s) {</span>
<span class="line-added"> 461         long nextState = state = unlockWriteState(s);</span>
<span class="line-added"> 462         signalNext(head);</span>
<span class="line-added"> 463         return nextState;</span>
<span class="line-added"> 464     }</span>
<span class="line-added"> 465 </span>
 466     /**
 467      * Exclusively acquires the lock, blocking if necessary
 468      * until available.
 469      *
 470      * @return a write stamp that can be used to unlock or convert mode
 471      */
 472     @ReservedStackAccess
 473     public long writeLock() {
<span class="line-modified"> 474         // try unconditional CAS confirming weak read</span>
<span class="line-modified"> 475         long s = U.getLongOpaque(this, STATE) &amp; ~ABITS, nextState;</span>
<span class="line-added"> 476         if (casState(s, nextState = s | WBIT)) {</span>
<span class="line-added"> 477             U.storeStoreFence();</span>
<span class="line-added"> 478             return nextState;</span>
<span class="line-added"> 479         }</span>
<span class="line-added"> 480         return acquireWrite(false, false, 0L);</span>
 481     }
 482 
 483     /**
 484      * Exclusively acquires the lock if it is immediately available.
 485      *
 486      * @return a write stamp that can be used to unlock or convert mode,
 487      * or zero if the lock is not available
 488      */

 489     public long tryWriteLock() {
<span class="line-modified"> 490         return tryAcquireWrite();</span>

 491     }
 492 
 493     /**
 494      * Exclusively acquires the lock if it is available within the
 495      * given time and the current thread has not been interrupted.
 496      * Behavior under timeout and interruption matches that specified
 497      * for method {@link Lock#tryLock(long,TimeUnit)}.
 498      *
 499      * @param time the maximum time to wait for the lock
 500      * @param unit the time unit of the {@code time} argument
 501      * @return a write stamp that can be used to unlock or convert mode,
 502      * or zero if the lock is not available
 503      * @throws InterruptedException if the current thread is interrupted
 504      * before acquiring the lock
 505      */
 506     public long tryWriteLock(long time, TimeUnit unit)
 507         throws InterruptedException {
 508         long nanos = unit.toNanos(time);
 509         if (!Thread.interrupted()) {
<span class="line-modified"> 510             long nextState;</span>
<span class="line-modified"> 511             if ((nextState = tryAcquireWrite()) != 0L)</span>
<span class="line-modified"> 512                 return nextState;</span>
 513             if (nanos &lt;= 0L)
 514                 return 0L;
<span class="line-modified"> 515             nextState = acquireWrite(true, true, System.nanoTime() + nanos);</span>
<span class="line-modified"> 516             if (nextState != INTERRUPTED)</span>
<span class="line-modified"> 517                 return nextState;</span>

 518         }
 519         throw new InterruptedException();
 520     }
 521 
 522     /**
 523      * Exclusively acquires the lock, blocking if necessary
 524      * until available or the current thread is interrupted.
 525      * Behavior under interruption matches that specified
 526      * for method {@link Lock#lockInterruptibly()}.
 527      *
 528      * @return a write stamp that can be used to unlock or convert mode
 529      * @throws InterruptedException if the current thread is interrupted
 530      * before acquiring the lock
 531      */

 532     public long writeLockInterruptibly() throws InterruptedException {
<span class="line-modified"> 533         long nextState;</span>
 534         if (!Thread.interrupted() &amp;&amp;
<span class="line-modified"> 535             ((nextState = tryAcquireWrite()) != 0L ||</span>
<span class="line-modified"> 536              (nextState = acquireWrite(true, false, 0L)) != INTERRUPTED))</span>
<span class="line-added"> 537             return nextState;</span>
 538         throw new InterruptedException();
 539     }
 540 
 541     /**
 542      * Non-exclusively acquires the lock, blocking if necessary
 543      * until available.
 544      *
 545      * @return a read stamp that can be used to unlock or convert mode
 546      */
 547     @ReservedStackAccess
 548     public long readLock() {
<span class="line-modified"> 549         // unconditionally optimistically try non-overflow case once</span>
<span class="line-modified"> 550         long s = U.getLongOpaque(this, STATE) &amp; RSAFE, nextState;</span>
<span class="line-modified"> 551         if (casState(s, nextState = s + RUNIT))</span>
<span class="line-modified"> 552             return nextState;</span>
<span class="line-modified"> 553         else</span>
<span class="line-modified"> 554             return acquireRead(false, false, 0L);</span>

 555     }
 556 
 557     /**
 558      * Non-exclusively acquires the lock if it is immediately available.
 559      *
 560      * @return a read stamp that can be used to unlock or convert mode,
 561      * or zero if the lock is not available
 562      */

 563     public long tryReadLock() {
<span class="line-modified"> 564         return tryAcquireRead();</span>









 565     }
 566 
 567     /**
 568      * Non-exclusively acquires the lock if it is available within the
 569      * given time and the current thread has not been interrupted.
 570      * Behavior under timeout and interruption matches that specified
 571      * for method {@link Lock#tryLock(long,TimeUnit)}.
 572      *
 573      * @param time the maximum time to wait for the lock
 574      * @param unit the time unit of the {@code time} argument
 575      * @return a read stamp that can be used to unlock or convert mode,
 576      * or zero if the lock is not available
 577      * @throws InterruptedException if the current thread is interrupted
 578      * before acquiring the lock
 579      */

 580     public long tryReadLock(long time, TimeUnit unit)
 581         throws InterruptedException {

 582         long nanos = unit.toNanos(time);
 583         if (!Thread.interrupted()) {
<span class="line-modified"> 584             long nextState;</span>
<span class="line-modified"> 585             if (tail == head &amp;&amp; (nextState = tryAcquireRead()) != 0L)</span>
<span class="line-modified"> 586                 return nextState;</span>





 587             if (nanos &lt;= 0L)
 588                 return 0L;
<span class="line-modified"> 589             nextState = acquireRead(true, true, System.nanoTime() + nanos);</span>
<span class="line-modified"> 590             if (nextState != INTERRUPTED)</span>
<span class="line-modified"> 591                 return nextState;</span>

 592         }
 593         throw new InterruptedException();
 594     }
 595 
 596     /**
 597      * Non-exclusively acquires the lock, blocking if necessary
 598      * until available or the current thread is interrupted.
 599      * Behavior under interruption matches that specified
 600      * for method {@link Lock#lockInterruptibly()}.
 601      *
 602      * @return a read stamp that can be used to unlock or convert mode
 603      * @throws InterruptedException if the current thread is interrupted
 604      * before acquiring the lock
 605      */

 606     public long readLockInterruptibly() throws InterruptedException {
<span class="line-modified"> 607         long nextState;</span>
<span class="line-modified"> 608         if (!Thread.interrupted() &amp;&amp;</span>
<span class="line-modified"> 609             ((nextState = tryAcquireRead()) != 0L ||</span>
<span class="line-modified"> 610              (nextState = acquireRead(true, false, 0L)) != INTERRUPTED))</span>
<span class="line-modified"> 611             return nextState;</span>




 612         throw new InterruptedException();
 613     }
 614 
 615     /**
 616      * Returns a stamp that can later be validated, or zero
 617      * if exclusively locked.
 618      *
 619      * @return a valid optimistic read stamp, or zero if exclusively locked
 620      */
 621     public long tryOptimisticRead() {
 622         long s;
 623         return (((s = state) &amp; WBIT) == 0L) ? (s &amp; SBITS) : 0L;
 624     }
 625 
 626     /**
 627      * Returns true if the lock has not been exclusively acquired
 628      * since issuance of the given stamp. Always returns false if the
 629      * stamp is zero. Always returns true if the stamp represents a
 630      * currently held lock. Invoking this method with a value not
 631      * obtained from {@link #tryOptimisticRead} or a locking method
 632      * for this lock has no defined effect or result.
 633      *
 634      * @param stamp a stamp
 635      * @return {@code true} if the lock has not been exclusively acquired
 636      * since issuance of the given stamp; else false
 637      */
 638     public boolean validate(long stamp) {
<span class="line-modified"> 639         U.loadFence();</span>
 640         return (stamp &amp; SBITS) == (state &amp; SBITS);
 641     }
 642 


















 643     /**
 644      * If the lock state matches the given stamp, releases the
 645      * exclusive lock.
 646      *
 647      * @param stamp a stamp returned by a write-lock operation
 648      * @throws IllegalMonitorStateException if the stamp does
 649      * not match the current state of this lock
 650      */
 651     @ReservedStackAccess
 652     public void unlockWrite(long stamp) {
 653         if (state != stamp || (stamp &amp; WBIT) == 0L)
 654             throw new IllegalMonitorStateException();
<span class="line-modified"> 655         releaseWrite(stamp);</span>
 656     }
 657 
 658     /**
 659      * If the lock state matches the given stamp, releases the
 660      * non-exclusive lock.
 661      *
 662      * @param stamp a stamp returned by a read-lock operation
 663      * @throws IllegalMonitorStateException if the stamp does
 664      * not match the current state of this lock
 665      */
 666     @ReservedStackAccess
 667     public void unlockRead(long stamp) {
<span class="line-modified"> 668         long s, m;</span>
<span class="line-modified"> 669         if ((stamp &amp; RBITS) != 0L) {</span>
<span class="line-modified"> 670             while (((s = state) &amp; SBITS) == (stamp &amp; SBITS) &amp;&amp;</span>
<span class="line-modified"> 671                    ((m = s &amp; RBITS) != 0L)) {</span>
<span class="line-modified"> 672                 if (m &lt; RFULL) {</span>
<span class="line-modified"> 673                     if (casState(s, s - RUNIT)) {</span>
<span class="line-modified"> 674                         if (m == RUNIT)</span>
<span class="line-modified"> 675                             signalNext(head);</span>
<span class="line-modified"> 676                         return;</span>
<span class="line-added"> 677                     }</span>
 678                 }
<span class="line-added"> 679                 else if (tryDecReaderOverflow(s) != 0L)</span>
<span class="line-added"> 680                     return;</span>
 681             }


 682         }
 683         throw new IllegalMonitorStateException();
 684     }
 685 
 686     /**
 687      * If the lock state matches the given stamp, releases the
 688      * corresponding mode of the lock.
 689      *
 690      * @param stamp a stamp returned by a lock operation
 691      * @throws IllegalMonitorStateException if the stamp does
 692      * not match the current state of this lock
 693      */

 694     public void unlock(long stamp) {
 695         if ((stamp &amp; WBIT) != 0L)
 696             unlockWrite(stamp);
 697         else
 698             unlockRead(stamp);
 699     }
 700 
 701     /**
 702      * If the lock state matches the given stamp, atomically performs one of
 703      * the following actions. If the stamp represents holding a write
 704      * lock, returns it.  Or, if a read lock, if the write lock is
 705      * available, releases the read lock and returns a write stamp.
 706      * Or, if an optimistic read, returns a write stamp only if
 707      * immediately available. This method returns zero in all other
 708      * cases.
 709      *
 710      * @param stamp a stamp
 711      * @return a valid write stamp, or zero on failure
 712      */
 713     public long tryConvertToWriteLock(long stamp) {
<span class="line-modified"> 714         long a = stamp &amp; ABITS, m, s, nextState;</span>
 715         while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {
 716             if ((m = s &amp; ABITS) == 0L) {
 717                 if (a != 0L)
 718                     break;
<span class="line-modified"> 719                 if (casState(s, nextState = s | WBIT)) {</span>
<span class="line-modified"> 720                     U.storeStoreFence();</span>
<span class="line-modified"> 721                     return nextState;</span>
<span class="line-modified"> 722                 }</span>
<span class="line-added"> 723             } else if (m == WBIT) {</span>
 724                 if (a != m)
 725                     break;
 726                 return stamp;
<span class="line-modified"> 727             } else if (m == RUNIT &amp;&amp; a != 0L) {</span>
<span class="line-modified"> 728                 if (casState(s, nextState = s - RUNIT + WBIT))</span>
<span class="line-modified"> 729                     return nextState;</span>
<span class="line-modified"> 730             } else</span>




 731                 break;
 732         }
 733         return 0L;
 734     }
 735 
 736     /**
 737      * If the lock state matches the given stamp, atomically performs one of
 738      * the following actions. If the stamp represents holding a write
 739      * lock, releases it and obtains a read lock.  Or, if a read lock,
 740      * returns it. Or, if an optimistic read, acquires a read lock and
 741      * returns a read stamp only if immediately available. This method
 742      * returns zero in all other cases.
 743      *
 744      * @param stamp a stamp
 745      * @return a valid read stamp, or zero on failure
 746      */
 747     public long tryConvertToReadLock(long stamp) {
<span class="line-modified"> 748         long a, s, nextState;</span>
 749         while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {
 750             if ((a = stamp &amp; ABITS) &gt;= WBIT) {
<span class="line-modified"> 751                 if (s != stamp) // write stamp</span>

 752                     break;
<span class="line-modified"> 753                 nextState = state = unlockWriteState(s) + RUNIT;</span>
<span class="line-modified"> 754                 signalNext(head);</span>
<span class="line-modified"> 755                 return nextState;</span>
<span class="line-modified"> 756             } else if (a == 0L) { // optimistic read stamp</span>



 757                 if ((s &amp; ABITS) &lt; RFULL) {
<span class="line-modified"> 758                     if (casState(s, nextState = s + RUNIT))</span>
<span class="line-modified"> 759                         return nextState;</span>
<span class="line-modified"> 760                 } else if ((nextState = tryIncReaderOverflow(s)) != 0L)</span>
<span class="line-modified"> 761                     return nextState;</span>
<span class="line-modified"> 762             } else { // already a read stamp</span>



 763                 if ((s &amp; ABITS) == 0L)
 764                     break;
 765                 return stamp;
 766             }
 767         }
 768         return 0L;
 769     }
 770 
 771     /**
 772      * If the lock state matches the given stamp then, atomically, if the stamp
 773      * represents holding a lock, releases it and returns an
 774      * observation stamp.  Or, if an optimistic read, returns it if
 775      * validated. This method returns zero in all other cases, and so
 776      * may be useful as a form of &quot;tryUnlock&quot;.
 777      *
 778      * @param stamp a stamp
 779      * @return a valid optimistic read stamp, or zero on failure
 780      */
 781     public long tryConvertToOptimisticRead(long stamp) {
<span class="line-modified"> 782         long a, m, s, nextState;</span>
<span class="line-modified"> 783         U.loadFence();</span>
 784         while (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) {
 785             if ((a = stamp &amp; ABITS) &gt;= WBIT) {
<span class="line-modified"> 786                 if (s != stamp)   // write stamp</span>

 787                     break;
<span class="line-modified"> 788                 return releaseWrite(s);</span>
<span class="line-modified"> 789             } else if (a == 0L) { // already an optimistic read stamp</span>


 790                 return stamp;
<span class="line-modified"> 791             } else if ((m = s &amp; ABITS) == 0L) { // invalid read stamp</span>
 792                 break;
<span class="line-modified"> 793             } else if (m &lt; RFULL) {</span>
<span class="line-modified"> 794                 if (casState(s, nextState = s - RUNIT)) {</span>
<span class="line-modified"> 795                     if (m == RUNIT)</span>
<span class="line-modified"> 796                         signalNext(head);</span>
<span class="line-modified"> 797                     return nextState &amp; SBITS;</span>
 798                 }
<span class="line-modified"> 799             } else if ((nextState = tryDecReaderOverflow(s)) != 0L)</span>
<span class="line-modified"> 800                 return nextState &amp; SBITS;</span>

 801         }
 802         return 0L;
 803     }
 804 
 805     /**
 806      * Releases the write lock if it is held, without requiring a
 807      * stamp value. This method may be useful for recovery after
 808      * errors.
 809      *
 810      * @return {@code true} if the lock was held, else false
 811      */
 812     @ReservedStackAccess
 813     public boolean tryUnlockWrite() {
 814         long s;
 815         if (((s = state) &amp; WBIT) != 0L) {
<span class="line-modified"> 816             releaseWrite(s);</span>
 817             return true;
 818         }
 819         return false;
 820     }
 821 
 822     /**
 823      * Releases one hold of the read lock if it is held, without
 824      * requiring a stamp value. This method may be useful for recovery
 825      * after errors.
 826      *
 827      * @return {@code true} if the read lock was held, else false
 828      */
 829     @ReservedStackAccess
 830     public boolean tryUnlockRead() {
<span class="line-modified"> 831         long s, m;</span>
 832         while ((m = (s = state) &amp; ABITS) != 0L &amp;&amp; m &lt; WBIT) {
 833             if (m &lt; RFULL) {
 834                 if (casState(s, s - RUNIT)) {
<span class="line-modified"> 835                     if (m == RUNIT)</span>
<span class="line-modified"> 836                         signalNext(head);</span>
 837                     return true;
 838                 }
 839             }
 840             else if (tryDecReaderOverflow(s) != 0L)
 841                 return true;
 842         }
 843         return false;
 844     }
 845 
 846     // status monitoring methods
 847 
 848     /**
 849      * Returns combined state-held and overflow read count for given
 850      * state s.
 851      */
 852     private int getReadLockCount(long s) {
 853         long readers;
 854         if ((readers = s &amp; RBITS) &gt;= RFULL)
 855             readers = RFULL + readerOverflow;
 856         return (int) readers;
</pre>
<hr />
<pre>
1062             return tryWriteLock(time, unit) != 0L;
1063         }
1064         public void unlock() { unstampedUnlockWrite(); }
1065         public Condition newCondition() {
1066             throw new UnsupportedOperationException();
1067         }
1068     }
1069 
1070     final class ReadWriteLockView implements ReadWriteLock {
1071         public Lock readLock() { return asReadLock(); }
1072         public Lock writeLock() { return asWriteLock(); }
1073     }
1074 
1075     // Unlock methods without stamp argument checks for view classes.
1076     // Needed because view-class lock methods throw away stamps.
1077 
1078     final void unstampedUnlockWrite() {
1079         long s;
1080         if (((s = state) &amp; WBIT) == 0L)
1081             throw new IllegalMonitorStateException();
<span class="line-modified">1082         releaseWrite(s);</span>
1083     }
1084 
1085     final void unstampedUnlockRead() {
<span class="line-modified">1086         long s, m;</span>
1087         while ((m = (s = state) &amp; RBITS) &gt; 0L) {
1088             if (m &lt; RFULL) {
1089                 if (casState(s, s - RUNIT)) {
<span class="line-modified">1090                     if (m == RUNIT)</span>
<span class="line-modified">1091                         signalNext(head);</span>
1092                     return;
1093                 }
1094             }
1095             else if (tryDecReaderOverflow(s) != 0L)
1096                 return;
1097         }
1098         throw new IllegalMonitorStateException();
1099     }
1100 
1101     private void readObject(java.io.ObjectInputStream s)
1102         throws java.io.IOException, ClassNotFoundException {
1103         s.defaultReadObject();
<span class="line-modified">1104         state = ORIGIN; // reset to unlocked state</span>
1105     }
1106 
<span class="line-modified">1107     // overflow handling methods</span>
1108 
1109     /**
1110      * Tries to increment readerOverflow by first setting state
1111      * access bits value to RBITS, indicating hold of spinlock,
1112      * then updating, then releasing.
1113      *
1114      * @param s a reader overflow stamp: (s &amp; ABITS) &gt;= RFULL
1115      * @return new stamp on success, else zero
1116      */
1117     private long tryIncReaderOverflow(long s) {
1118         // assert (s &amp; ABITS) &gt;= RFULL;
<span class="line-modified">1119         if ((s &amp; ABITS) != RFULL)</span>









1120             Thread.onSpinWait();
<span class="line-added">1121         else if (casState(s, s | RBITS)) {</span>
<span class="line-added">1122             ++readerOverflow;</span>
<span class="line-added">1123             return state = s;</span>
<span class="line-added">1124         }</span>
1125         return 0L;
1126     }
1127 
1128     /**
1129      * Tries to decrement readerOverflow.
1130      *
1131      * @param s a reader overflow stamp: (s &amp; ABITS) &gt;= RFULL
1132      * @return new stamp on success, else zero
1133      */
1134     private long tryDecReaderOverflow(long s) {
1135         // assert (s &amp; ABITS) &gt;= RFULL;
<span class="line-modified">1136         if ((s &amp; ABITS) != RFULL)</span>
<span class="line-modified">1137             Thread.onSpinWait();</span>
<span class="line-modified">1138         else if (casState(s, s | RBITS)) {</span>
<span class="line-modified">1139             int r; long nextState;</span>
<span class="line-modified">1140             if ((r = readerOverflow) &gt; 0) {</span>
<span class="line-modified">1141                 readerOverflow = r - 1;</span>
<span class="line-modified">1142                 nextState = s;</span>




1143             }
<span class="line-added">1144             else</span>
<span class="line-added">1145                 nextState = s - RUNIT;</span>
<span class="line-added">1146             return state = nextState;</span>
1147         }




1148         return 0L;
1149     }
1150 
<span class="line-added">1151     // release methods</span>
<span class="line-added">1152 </span>
1153     /**
<span class="line-modified">1154      * Wakes up the successor of given node, if one exists, and unsets its</span>
<span class="line-modified">1155      * WAITING status to avoid park race. This may fail to wake up an</span>
<span class="line-modified">1156      * eligible thread when one or more have been cancelled, but</span>
<span class="line-modified">1157      * cancelAcquire ensures liveness.</span>

1158      */
<span class="line-modified">1159     static final void signalNext(Node h) {</span>
<span class="line-modified">1160         Node s;</span>
<span class="line-modified">1161         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp; s.status &gt; 0) {</span>
<span class="line-modified">1162             s.getAndUnsetStatus(WAITING);</span>
<span class="line-modified">1163             LockSupport.unpark(s.waiter);</span>
<span class="line-modified">1164         }</span>
<span class="line-modified">1165     }</span>
<span class="line-modified">1166 </span>
<span class="line-added">1167     /**</span>
<span class="line-added">1168      * Removes and unparks all cowaiters of node, if it exists.</span>
<span class="line-added">1169      */</span>
<span class="line-added">1170     private static void signalCowaiters(ReaderNode node) {</span>
<span class="line-added">1171         if (node != null) {</span>
<span class="line-added">1172             for (ReaderNode c; (c = node.cowaiters) != null; ) {</span>
<span class="line-added">1173                 if (node.casCowaiters(c, c.cowaiters))</span>
<span class="line-added">1174                     LockSupport.unpark(c.waiter);</span>
1175             }


1176         }
1177     }
1178 
<span class="line-added">1179     // queue link methods</span>
<span class="line-added">1180     private boolean casTail(Node c, Node v) {</span>
<span class="line-added">1181         return U.compareAndSetReference(this, TAIL, c, v);</span>
<span class="line-added">1182     }</span>
<span class="line-added">1183 </span>
<span class="line-added">1184     /** tries once to CAS a new dummy node for head */</span>
<span class="line-added">1185     private void tryInitializeHead() {</span>
<span class="line-added">1186         Node h = new WriterNode();</span>
<span class="line-added">1187         if (U.compareAndSetReference(this, HEAD, null, h))</span>
<span class="line-added">1188             tail = h;</span>
<span class="line-added">1189     }</span>
<span class="line-added">1190 </span>
1191     /**
<span class="line-modified">1192      * For explanation, see above and AbstractQueuedSynchronizer</span>
<span class="line-added">1193      * internal documentation.</span>
1194      *
1195      * @param interruptible true if should check interrupts and if so
1196      * return INTERRUPTED
<span class="line-modified">1197      * @param timed if true use timed waits</span>
<span class="line-modified">1198      * @param time the System.nanoTime value to timeout at (and return zero)</span>
1199      * @return next state, or INTERRUPTED
1200      */
<span class="line-modified">1201     private long acquireWrite(boolean interruptible, boolean timed, long time) {</span>
<span class="line-modified">1202         byte spins = 0, postSpins = 0;   // retries upon unpark of first thread</span>
<span class="line-modified">1203         boolean interrupted = false, first = false;</span>
<span class="line-modified">1204         WriterNode node = null;</span>
<span class="line-modified">1205         Node pred = null;</span>
<span class="line-modified">1206         for (long s, nextState;;) {</span>
<span class="line-modified">1207             if (!first &amp;&amp; (pred = (node == null) ? null : node.prev) != null &amp;&amp;</span>
<span class="line-modified">1208                 !(first = (head == pred))) {</span>
<span class="line-modified">1209                 if (pred.status &lt; 0) {</span>
<span class="line-modified">1210                     cleanQueue();           // predecessor cancelled</span>
<span class="line-modified">1211                     continue;</span>
<span class="line-modified">1212                 } else if (pred.prev == null) {</span>
<span class="line-modified">1213                     Thread.onSpinWait();    // ensure serialization</span>
<span class="line-modified">1214                     continue;</span>












































1215                 }
1216             }
<span class="line-modified">1217             if ((first || pred == null) &amp;&amp; ((s = state) &amp; ABITS) == 0L &amp;&amp;</span>
<span class="line-modified">1218                 casState(s, nextState = s | WBIT)) {</span>
<span class="line-modified">1219                 U.storeStoreFence();</span>
<span class="line-modified">1220                 if (first) {</span>
<span class="line-modified">1221                     node.prev = null;</span>
<span class="line-modified">1222                     head = node;</span>
<span class="line-modified">1223                     pred.next = null;</span>
<span class="line-modified">1224                     node.waiter = null;</span>
<span class="line-modified">1225                     if (interrupted)</span>
<span class="line-modified">1226                         Thread.currentThread().interrupt();</span>
























1227                 }
<span class="line-added">1228                 return nextState;</span>
<span class="line-added">1229             } else if (node == null) {          // retry before enqueuing</span>
<span class="line-added">1230                 node = new WriterNode();</span>
<span class="line-added">1231             } else if (pred == null) {          // try to enqueue</span>
<span class="line-added">1232                 Node t = tail;</span>
<span class="line-added">1233                 node.setPrevRelaxed(t);</span>
<span class="line-added">1234                 if (t == null)</span>
<span class="line-added">1235                     tryInitializeHead();</span>
<span class="line-added">1236                 else if (!casTail(t, node))</span>
<span class="line-added">1237                     node.setPrevRelaxed(null);  // back out</span>
<span class="line-added">1238                 else</span>
<span class="line-added">1239                     t.next = node;</span>
<span class="line-added">1240             } else if (first &amp;&amp; spins != 0) {   // reduce unfairness</span>
<span class="line-added">1241                 --spins;</span>
<span class="line-added">1242                 Thread.onSpinWait();</span>
<span class="line-added">1243             } else if (node.status == 0) {      // enable signal</span>
<span class="line-added">1244                 if (node.waiter == null)</span>
<span class="line-added">1245                     node.waiter = Thread.currentThread();</span>
<span class="line-added">1246                 node.status = WAITING;</span>
<span class="line-added">1247             } else {</span>
<span class="line-added">1248                 long nanos;</span>
<span class="line-added">1249                 spins = postSpins = (byte)((postSpins &lt;&lt; 1) | 1);</span>
<span class="line-added">1250                 if (!timed)</span>
<span class="line-added">1251                     LockSupport.park(this);</span>
<span class="line-added">1252                 else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="line-added">1253                     LockSupport.parkNanos(this, nanos);</span>
<span class="line-added">1254                 else</span>
<span class="line-added">1255                     break;</span>
<span class="line-added">1256                 node.clearStatus();</span>
<span class="line-added">1257                 if ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span>
<span class="line-added">1258                     break;</span>
1259             }
1260         }
<span class="line-added">1261         return cancelAcquire(node, interrupted);</span>
1262     }
1263 
1264     /**
1265      * See above for explanation.
1266      *
1267      * @param interruptible true if should check interrupts and if so
1268      * return INTERRUPTED
<span class="line-modified">1269      * @param timed if true use timed waits</span>
<span class="line-modified">1270      * @param time the System.nanoTime value to timeout at (and return zero)</span>
1271      * @return next state, or INTERRUPTED
1272      */
<span class="line-modified">1273     private long acquireRead(boolean interruptible, boolean timed, long time) {</span>
<span class="line-modified">1274         boolean interrupted = false;</span>
<span class="line-modified">1275         ReaderNode node = null;</span>
<span class="line-modified">1276         /*</span>
<span class="line-modified">1277          * Loop:</span>
<span class="line-modified">1278          *   if empty, try to acquire</span>
<span class="line-modified">1279          *   if tail is Reader, try to cowait; restart if leader stale or cancels</span>
<span class="line-modified">1280          *   else try to create and enqueue node, and wait in 2nd loop below</span>
<span class="line-modified">1281          */</span>
<span class="line-modified">1282         for (;;) {</span>
<span class="line-modified">1283             ReaderNode leader; long nextState;</span>
<span class="line-modified">1284             Node tailPred = null, t = tail;</span>
<span class="line-modified">1285             if ((t == null || (tailPred = t.prev) == null) &amp;&amp;</span>
<span class="line-modified">1286                 (nextState = tryAcquireRead()) != 0L) // try now if empty</span>
<span class="line-modified">1287                 return nextState;</span>
<span class="line-modified">1288             else if (t == null)</span>
<span class="line-modified">1289                 tryInitializeHead();</span>
<span class="line-modified">1290             else if (tailPred == null || !(t instanceof ReaderNode)) {</span>
<span class="line-modified">1291                 if (node == null)</span>
<span class="line-modified">1292                     node = new ReaderNode();</span>
<span class="line-modified">1293                 if (tail == t) {</span>
<span class="line-modified">1294                     node.setPrevRelaxed(t);</span>
<span class="line-modified">1295                     if (casTail(t, node)) {</span>
<span class="line-modified">1296                         t.next = node;</span>
<span class="line-modified">1297                         break; // node is leader; wait in loop below</span>


1298                     }
<span class="line-added">1299                     node.setPrevRelaxed(null);</span>
1300                 }
<span class="line-modified">1301             } else if ((leader = (ReaderNode)t) == tail) { // try to cowait</span>
<span class="line-modified">1302                 for (boolean attached = false;;) {</span>
<span class="line-modified">1303                     if (leader.status &lt; 0 || leader.prev == null)</span>
<span class="line-modified">1304                         break;</span>
<span class="line-modified">1305                     else if (node == null)</span>
<span class="line-modified">1306                         node = new ReaderNode();</span>
<span class="line-modified">1307                     else if (node.waiter == null)</span>
<span class="line-modified">1308                         node.waiter = Thread.currentThread();</span>
<span class="line-modified">1309                     else if (!attached) {</span>
<span class="line-modified">1310                         ReaderNode c = leader.cowaiters;</span>
<span class="line-modified">1311                         node.setCowaitersRelaxed(c);</span>
<span class="line-modified">1312                         attached = leader.casCowaiters(c, node);</span>
<span class="line-modified">1313                         if (!attached)</span>
<span class="line-modified">1314                             node.setCowaitersRelaxed(null);</span>
<span class="line-modified">1315                     } else {</span>
<span class="line-modified">1316                         long nanos = 0L;</span>
<span class="line-modified">1317                         if (!timed)</span>
<span class="line-modified">1318                             LockSupport.park(this);</span>
<span class="line-modified">1319                         else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="line-modified">1320                             LockSupport.parkNanos(this, nanos);</span>
<span class="line-modified">1321                         interrupted |= Thread.interrupted();</span>
<span class="line-modified">1322                         if ((interrupted &amp;&amp; interruptible) ||</span>
<span class="line-modified">1323                             (timed &amp;&amp; nanos &lt;= 0L))</span>
<span class="line-modified">1324                             return cancelCowaiter(node, leader, interrupted);</span>










































1325                     }
1326                 }
<span class="line-added">1327                 if (node != null)</span>
<span class="line-added">1328                     node.waiter = null;</span>
<span class="line-added">1329                 long ns = tryAcquireRead();</span>
<span class="line-added">1330                 signalCowaiters(leader);</span>
<span class="line-added">1331                 if (interrupted)</span>
<span class="line-added">1332                     Thread.currentThread().interrupt();</span>
<span class="line-added">1333                 if (ns != 0L)</span>
<span class="line-added">1334                     return ns;</span>
<span class="line-added">1335                 else</span>
<span class="line-added">1336                     node = null; // restart if stale, missed, or leader cancelled</span>
1337             }
1338         }
1339 
<span class="line-modified">1340         // node is leader of a cowait group; almost same as acquireWrite</span>
<span class="line-modified">1341         byte spins = 0, postSpins = 0;   // retries upon unpark of first thread</span>
<span class="line-modified">1342         boolean first = false;</span>
<span class="line-modified">1343         Node pred = null;</span>
<span class="line-modified">1344         for (long nextState;;) {</span>
<span class="line-modified">1345             if (!first &amp;&amp; (pred = node.prev) != null &amp;&amp;</span>
<span class="line-modified">1346                 !(first = (head == pred))) {</span>
<span class="line-modified">1347                 if (pred.status &lt; 0) {</span>
<span class="line-modified">1348                     cleanQueue();           // predecessor cancelled</span>
<span class="line-modified">1349                     continue;</span>
<span class="line-modified">1350                 } else if (pred.prev == null) {</span>
<span class="line-modified">1351                     Thread.onSpinWait();    // ensure serialization</span>
<span class="line-modified">1352                     continue;</span>















1353                 }
1354             }
<span class="line-modified">1355             if ((first || pred == null) &amp;&amp;</span>
<span class="line-modified">1356                 (nextState = tryAcquireRead()) != 0L) {</span>
<span class="line-modified">1357                 if (first) {</span>
<span class="line-modified">1358                     node.prev = null;</span>
<span class="line-modified">1359                     head = node;</span>
<span class="line-modified">1360                     pred.next = null;</span>
<span class="line-added">1361                     node.waiter = null;</span>
1362                 }
<span class="line-added">1363                 signalCowaiters(node);</span>
<span class="line-added">1364                 if (interrupted)</span>
<span class="line-added">1365                     Thread.currentThread().interrupt();</span>
<span class="line-added">1366                 return nextState;</span>
<span class="line-added">1367             } else if (first &amp;&amp; spins != 0) {</span>
<span class="line-added">1368                 --spins;</span>
<span class="line-added">1369                 Thread.onSpinWait();</span>
<span class="line-added">1370             } else if (node.status == 0) {</span>
<span class="line-added">1371                 if (node.waiter == null)</span>
<span class="line-added">1372                     node.waiter = Thread.currentThread();</span>
<span class="line-added">1373                 node.status = WAITING;</span>
<span class="line-added">1374             } else {</span>
<span class="line-added">1375                 long nanos;</span>
<span class="line-added">1376                 spins = postSpins = (byte)((postSpins &lt;&lt; 1) | 1);</span>
<span class="line-added">1377                 if (!timed)</span>
<span class="line-added">1378                     LockSupport.park(this);</span>
<span class="line-added">1379                 else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="line-added">1380                     LockSupport.parkNanos(this, nanos);</span>
<span class="line-added">1381                 else</span>
<span class="line-added">1382                     break;</span>
<span class="line-added">1383                 node.clearStatus();</span>
<span class="line-added">1384                 if ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span>
<span class="line-added">1385                     break;</span>
1386             }
<span class="line-modified">1387         }</span>
<span class="line-modified">1388         return cancelAcquire(node, interrupted);</span>
<span class="line-modified">1389     }</span>
<span class="line-modified">1390 </span>
<span class="line-modified">1391     // Cancellation support</span>
<span class="line-modified">1392 </span>
<span class="line-modified">1393     /**</span>
<span class="line-modified">1394      * Possibly repeatedly traverses from tail, unsplicing cancelled</span>
<span class="line-modified">1395      * nodes until none are found. Unparks nodes that may have been</span>
<span class="line-modified">1396      * relinked to be next eligible acquirer.</span>
<span class="line-modified">1397      */</span>
<span class="line-added">1398     private void cleanQueue() {</span>
<span class="line-added">1399         for (;;) {                               // restart point</span>
<span class="line-added">1400             for (Node q = tail, s = null, p, n;;) { // (p, q, s) triples</span>
<span class="line-added">1401                 if (q == null || (p = q.prev) == null)</span>
<span class="line-added">1402                     return;                      // end of list</span>
<span class="line-added">1403                 if (s == null ? tail != q : (s.prev != q || s.status &lt; 0))</span>
<span class="line-added">1404                     break;                       // inconsistent</span>
<span class="line-added">1405                 if (q.status &lt; 0) {              // cancelled</span>
<span class="line-added">1406                     if ((s == null ? casTail(q, p) : s.casPrev(q, p)) &amp;&amp;</span>
<span class="line-added">1407                         q.prev == p) {</span>
<span class="line-added">1408                         p.casNext(q, s);         // OK if fails</span>
<span class="line-added">1409                         if (p.prev == null)</span>
<span class="line-added">1410                             signalNext(p);</span>
1411                     }
<span class="line-added">1412                     break;</span>
1413                 }
<span class="line-modified">1414                 if ((n = p.next) != q) {         // help finish</span>
<span class="line-modified">1415                     if (n != null &amp;&amp; q.prev == p &amp;&amp; q.status &gt;= 0) {</span>
<span class="line-modified">1416                         p.casNext(n, q);</span>
<span class="line-modified">1417                         if (p.prev == null)</span>
<span class="line-modified">1418                             signalNext(p);</span>










1419                     }
<span class="line-modified">1420                     break;</span>
<span class="line-modified">1421                 }</span>
<span class="line-modified">1422                 s = q;</span>
<span class="line-modified">1423                 q = q.prev;</span>
<span class="line-modified">1424             }</span>
<span class="line-added">1425         }</span>
<span class="line-added">1426     }</span>
<span class="line-added">1427 </span>
<span class="line-added">1428     /**</span>
<span class="line-added">1429      * If leader exists, possibly repeatedly traverses cowaiters,</span>
<span class="line-added">1430      * unsplicing the given cancelled node until not found.</span>
<span class="line-added">1431      */</span>
<span class="line-added">1432     private void unlinkCowaiter(ReaderNode node, ReaderNode leader) {</span>
<span class="line-added">1433         if (leader != null) {</span>
<span class="line-added">1434             while (leader.prev != null &amp;&amp; leader.status &gt;= 0) {</span>
<span class="line-added">1435                 for (ReaderNode p = leader, q; ; p = q) {</span>
<span class="line-added">1436                     if ((q = p.cowaiters) == null)</span>
<span class="line-added">1437                         return;</span>
<span class="line-added">1438                     if (q == node) {</span>
<span class="line-added">1439                         p.casCowaiters(q, q.cowaiters);</span>
<span class="line-added">1440                         break;  // recheck even if succeeded</span>
1441                     }
1442                 }
1443             }
1444         }
1445     }
1446 
1447     /**
1448      * If node non-null, forces cancel status and unsplices it from
<span class="line-modified">1449      * queue, wakes up any cowaiters, and possibly wakes up successor</span>
<span class="line-modified">1450      * to recheck status.</span>






1451      *
<span class="line-modified">1452      * @param node the waiter (may be null if not yet enqueued)</span>

1453      * @param interrupted if already interrupted
1454      * @return INTERRUPTED if interrupted or Thread.interrupted, else zero
1455      */
<span class="line-modified">1456     private long cancelAcquire(Node node, boolean interrupted) {</span>
<span class="line-modified">1457         if (node != null) {</span>
<span class="line-modified">1458             node.waiter = null;</span>
1459             node.status = CANCELLED;
<span class="line-modified">1460             cleanQueue();</span>
<span class="line-modified">1461             if (node instanceof ReaderNode)</span>
<span class="line-modified">1462                 signalCowaiters((ReaderNode)node);</span>








































1463         }
<span class="line-modified">1464         return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;</span>
<span class="line-modified">1465     }</span>
<span class="line-modified">1466 </span>
<span class="line-modified">1467     /**</span>
<span class="line-modified">1468      * If node non-null, forces cancel status and unsplices from</span>
<span class="line-modified">1469      * leader&#39;s cowaiters list unless/until it is also cancelled.</span>
<span class="line-modified">1470      *</span>
<span class="line-modified">1471      * @param node if non-null, the waiter</span>
<span class="line-modified">1472      * @param leader if non-null, the node heading cowaiters list</span>
<span class="line-modified">1473      * @param interrupted if already interrupted</span>
<span class="line-modified">1474      * @return INTERRUPTED if interrupted or Thread.interrupted, else zero</span>
<span class="line-modified">1475      */</span>
<span class="line-modified">1476     private long cancelCowaiter(ReaderNode node, ReaderNode leader,</span>
<span class="line-modified">1477                                 boolean interrupted) {</span>
<span class="line-modified">1478         if (node != null) {</span>
<span class="line-added">1479             node.waiter = null;</span>
<span class="line-added">1480             node.status = CANCELLED;</span>
<span class="line-added">1481             unlinkCowaiter(node, leader);</span>
1482         }
1483         return (interrupted || Thread.interrupted()) ? INTERRUPTED : 0L;
1484     }
1485 
<span class="line-modified">1486     // Unsafe</span>
<span class="line-modified">1487     private static final Unsafe U = Unsafe.getUnsafe();</span>
<span class="line-modified">1488     private static final long STATE</span>
<span class="line-modified">1489         = U.objectFieldOffset(StampedLock.class, &quot;state&quot;);</span>
<span class="line-modified">1490     private static final long HEAD</span>
<span class="line-modified">1491         = U.objectFieldOffset(StampedLock.class, &quot;head&quot;);</span>
<span class="line-modified">1492     private static final long TAIL</span>
<span class="line-added">1493         = U.objectFieldOffset(StampedLock.class, &quot;tail&quot;);</span>
<span class="line-added">1494 </span>
1495     static {
<span class="line-modified">1496         Class&lt;?&gt; ensureLoaded = LockSupport.class;</span>










1497     }
1498 }
</pre>
</td>
</tr>
</table>
<center><a href="ReentrantReadWriteLock.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../package-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/StrictMath.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.util.Random;
  29 import jdk.internal.math.DoubleConsts;
  30 import jdk.internal.HotSpotIntrinsicCandidate;
  31 
  32 /**
  33  * The class {@code StrictMath} contains methods for performing basic
  34  * numeric operations such as the elementary exponential, logarithm,
  35  * square root, and trigonometric functions.
  36  *
  37  * &lt;p&gt;To help ensure portability of Java programs, the definitions of
  38  * some of the numeric functions in this package require that they
  39  * produce the same results as certain published algorithms. These
  40  * algorithms are available from the well-known network library
  41  * {@code netlib} as the package &quot;Freely Distributable Math
  42  * Library,&quot; &lt;a
  43  * href=&quot;https://www.netlib.org/fdlibm/&quot;&gt;{@code fdlibm}&lt;/a&gt;. These
  44  * algorithms, which are written in the C programming language, are
  45  * then to be understood as executed with all floating-point
  46  * operations following the rules of Java floating-point arithmetic.
  47  *
  48  * &lt;p&gt;The Java math library is defined with respect to
  49  * {@code fdlibm} version 5.3. Where {@code fdlibm} provides
  50  * more than one definition for a function (such as
  51  * {@code acos}), use the &quot;IEEE 754 core function&quot; version
  52  * (residing in a file whose name begins with the letter
  53  * {@code e}).  The methods which require {@code fdlibm}
  54  * semantics are {@code sin}, {@code cos}, {@code tan},
  55  * {@code asin}, {@code acos}, {@code atan},
  56  * {@code exp}, {@code log}, {@code log10},
  57  * {@code cbrt}, {@code atan2}, {@code pow},
  58  * {@code sinh}, {@code cosh}, {@code tanh},
  59  * {@code hypot}, {@code expm1}, and {@code log1p}.
  60  *
  61  * &lt;p&gt;
  62  * The platform uses signed two&#39;s complement integer arithmetic with
  63  * int and long primitive types.  The developer should choose
  64  * the primitive type to ensure that arithmetic operations consistently
  65  * produce correct results, which in some cases means the operations
  66  * will not overflow the range of values of the computation.
  67  * The best practice is to choose the primitive type and algorithm to avoid
  68  * overflow. In cases where the size is {@code int} or {@code long} and
  69  * overflow errors need to be detected, the methods {@code addExact},
<a name="2" id="anc2"></a><span class="line-modified">  70  * {@code subtractExact}, {@code multiplyExact}, and {@code toIntExact}</span>

  71  * throw an {@code ArithmeticException} when the results overflow.
<a name="3" id="anc3"></a><span class="line-modified">  72  * For other arithmetic operations such as divide, absolute value,</span>
<span class="line-modified">  73  * increment by one, decrement by one, and negation overflow occurs only with</span>
<span class="line-modified">  74  * a specific minimum or maximum value and should be checked against</span>
<span class="line-removed">  75  * the minimum or maximum as appropriate.</span>
  76  *
  77  * @author  unascribed
  78  * @author  Joseph D. Darcy
  79  * @since   1.3
  80  */
  81 
  82 public final class StrictMath {
  83 
  84     /**
  85      * Don&#39;t let anyone instantiate this class.
  86      */
  87     private StrictMath() {}
  88 
  89     /**
  90      * The {@code double} value that is closer than any other to
  91      * &lt;i&gt;e&lt;/i&gt;, the base of the natural logarithms.
  92      */
  93     public static final double E = 2.7182818284590452354;
  94 
  95     /**
  96      * The {@code double} value that is closer than any other to
  97      * &lt;i&gt;pi&lt;/i&gt;, the ratio of the circumference of a circle to its
  98      * diameter.
  99      */
 100     public static final double PI = 3.14159265358979323846;
 101 
 102     /**
 103      * Constant by which to multiply an angular value in degrees to obtain an
 104      * angular value in radians.
 105      */
 106     private static final double DEGREES_TO_RADIANS = 0.017453292519943295;
 107 
 108     /**
 109      * Constant by which to multiply an angular value in radians to obtain an
 110      * angular value in degrees.
 111      */
 112 
 113     private static final double RADIANS_TO_DEGREES = 57.29577951308232;
 114 
 115     /**
 116      * Returns the trigonometric sine of an angle. Special cases:
 117      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 118      * result is NaN.
 119      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 120      * same sign as the argument.&lt;/ul&gt;
 121      *
 122      * @param   a   an angle, in radians.
 123      * @return  the sine of the argument.
 124      */
 125     public static native double sin(double a);
 126 
 127     /**
 128      * Returns the trigonometric cosine of an angle. Special cases:
 129      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 130      * result is NaN.&lt;/ul&gt;
 131      *
 132      * @param   a   an angle, in radians.
 133      * @return  the cosine of the argument.
 134      */
 135     public static native double cos(double a);
 136 
 137     /**
 138      * Returns the trigonometric tangent of an angle. Special cases:
 139      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the result
 140      * is NaN.
 141      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 142      * same sign as the argument.&lt;/ul&gt;
 143      *
 144      * @param   a   an angle, in radians.
 145      * @return  the tangent of the argument.
 146      */
 147     public static native double tan(double a);
 148 
 149     /**
 150      * Returns the arc sine of a value; the returned angle is in the
 151      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 152      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 153      * than 1, then the result is NaN.
 154      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 155      * same sign as the argument.&lt;/ul&gt;
 156      *
 157      * @param   a   the value whose arc sine is to be returned.
 158      * @return  the arc sine of the argument.
 159      */
 160     public static native double asin(double a);
 161 
 162     /**
 163      * Returns the arc cosine of a value; the returned angle is in the
 164      * range 0.0 through &lt;i&gt;pi&lt;/i&gt;.  Special case:
 165      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 166      * than 1, then the result is NaN.&lt;/ul&gt;
 167      *
 168      * @param   a   the value whose arc cosine is to be returned.
 169      * @return  the arc cosine of the argument.
 170      */
 171     public static native double acos(double a);
 172 
 173     /**
 174      * Returns the arc tangent of a value; the returned angle is in the
 175      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 176      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, then the result is NaN.
 177      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 178      * same sign as the argument.&lt;/ul&gt;
 179      *
 180      * @param   a   the value whose arc tangent is to be returned.
 181      * @return  the arc tangent of the argument.
 182      */
 183     public static native double atan(double a);
 184 
 185     /**
 186      * Converts an angle measured in degrees to an approximately
 187      * equivalent angle measured in radians.  The conversion from
 188      * degrees to radians is generally inexact.
 189      *
 190      * @param   angdeg   an angle, in degrees
 191      * @return  the measurement of the angle {@code angdeg}
 192      *          in radians.
 193      */
 194     public static strictfp double toRadians(double angdeg) {
 195         // Do not delegate to Math.toRadians(angdeg) because
 196         // this method has the strictfp modifier.
 197         return angdeg * DEGREES_TO_RADIANS;
 198     }
 199 
 200     /**
 201      * Converts an angle measured in radians to an approximately
 202      * equivalent angle measured in degrees.  The conversion from
 203      * radians to degrees is generally inexact; users should
 204      * &lt;i&gt;not&lt;/i&gt; expect {@code cos(toRadians(90.0))} to exactly
 205      * equal {@code 0.0}.
 206      *
 207      * @param   angrad   an angle, in radians
 208      * @return  the measurement of the angle {@code angrad}
 209      *          in degrees.
 210      */
 211     public static strictfp double toDegrees(double angrad) {
 212         // Do not delegate to Math.toDegrees(angrad) because
 213         // this method has the strictfp modifier.
 214         return angrad * RADIANS_TO_DEGREES;
 215     }
 216 
 217     /**
 218      * Returns Euler&#39;s number &lt;i&gt;e&lt;/i&gt; raised to the power of a
 219      * {@code double} value. Special cases:
 220      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is NaN.
 221      * &lt;li&gt;If the argument is positive infinity, then the result is
 222      * positive infinity.
 223      * &lt;li&gt;If the argument is negative infinity, then the result is
 224      * positive zero.&lt;/ul&gt;
 225      *
 226      * @param   a   the exponent to raise &lt;i&gt;e&lt;/i&gt; to.
 227      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code a}&lt;/sup&gt;,
 228      *          where &lt;i&gt;e&lt;/i&gt; is the base of the natural logarithms.
 229      */
 230     public static double exp(double a) {
 231         return FdLibm.Exp.compute(a);
 232     }
 233 
 234     /**
 235      * Returns the natural logarithm (base &lt;i&gt;e&lt;/i&gt;) of a {@code double}
 236      * value. Special cases:
 237      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 238      * is NaN.
 239      * &lt;li&gt;If the argument is positive infinity, then the result is
 240      * positive infinity.
 241      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 242      * result is negative infinity.&lt;/ul&gt;
 243      *
 244      * @param   a   a value
 245      * @return  the value ln&amp;nbsp;{@code a}, the natural logarithm of
 246      *          {@code a}.
 247      */
 248     public static native double log(double a);
 249 
 250     /**
 251      * Returns the base 10 logarithm of a {@code double} value.
 252      * Special cases:
 253      *
 254      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 255      * is NaN.
 256      * &lt;li&gt;If the argument is positive infinity, then the result is
 257      * positive infinity.
 258      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 259      * result is negative infinity.
 260      * &lt;li&gt; If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for
 261      * integer &lt;i&gt;n&lt;/i&gt;, then the result is &lt;i&gt;n&lt;/i&gt;.
 262      * &lt;/ul&gt;
 263      *
 264      * @param   a   a value
 265      * @return  the base 10 logarithm of  {@code a}.
 266      * @since 1.5
 267      */
 268     public static native double log10(double a);
 269 
 270     /**
 271      * Returns the correctly rounded positive square root of a
 272      * {@code double} value.
 273      * Special cases:
 274      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 275      * is NaN.
 276      * &lt;li&gt;If the argument is positive infinity, then the result is positive
 277      * infinity.
 278      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 279      * result is the same as the argument.&lt;/ul&gt;
 280      * Otherwise, the result is the {@code double} value closest to
 281      * the true mathematical square root of the argument value.
 282      *
 283      * @param   a   a value.
 284      * @return  the positive square root of {@code a}.
 285      */
 286     @HotSpotIntrinsicCandidate
 287     public static native double sqrt(double a);
 288 
 289     /**
 290      * Returns the cube root of a {@code double} value.  For
 291      * positive finite {@code x}, {@code cbrt(-x) ==
 292      * -cbrt(x)}; that is, the cube root of a negative value is
 293      * the negative of the cube root of that value&#39;s magnitude.
 294      * Special cases:
 295      *
 296      * &lt;ul&gt;
 297      *
 298      * &lt;li&gt;If the argument is NaN, then the result is NaN.
 299      *
 300      * &lt;li&gt;If the argument is infinite, then the result is an infinity
 301      * with the same sign as the argument.
 302      *
 303      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 304      * same sign as the argument.
 305      *
 306      * &lt;/ul&gt;
 307      *
 308      * @param   a   a value.
 309      * @return  the cube root of {@code a}.
 310      * @since 1.5
 311      */
 312     public static double cbrt(double a) {
 313         return FdLibm.Cbrt.compute(a);
 314     }
 315 
 316     /**
 317      * Computes the remainder operation on two arguments as prescribed
 318      * by the IEEE 754 standard.
 319      * The remainder value is mathematically equal to
 320      * &lt;code&gt;f1&amp;nbsp;-&amp;nbsp;f2&lt;/code&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;,
 321      * where &lt;i&gt;n&lt;/i&gt; is the mathematical integer closest to the exact
 322      * mathematical value of the quotient {@code f1/f2}, and if two
 323      * mathematical integers are equally close to {@code f1/f2},
 324      * then &lt;i&gt;n&lt;/i&gt; is the integer that is even. If the remainder is
 325      * zero, its sign is the same as the sign of the first argument.
 326      * Special cases:
 327      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, or the first argument is infinite,
 328      * or the second argument is positive zero or negative zero, then the
 329      * result is NaN.
 330      * &lt;li&gt;If the first argument is finite and the second argument is
 331      * infinite, then the result is the same as the first argument.&lt;/ul&gt;
 332      *
 333      * @param   f1   the dividend.
 334      * @param   f2   the divisor.
 335      * @return  the remainder when {@code f1} is divided by
 336      *          {@code f2}.
 337      */
 338     public static native double IEEEremainder(double f1, double f2);
 339 
 340     /**
 341      * Returns the smallest (closest to negative infinity)
 342      * {@code double} value that is greater than or equal to the
 343      * argument and is equal to a mathematical integer. Special cases:
 344      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 345      * mathematical integer, then the result is the same as the
 346      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 347      * positive zero or negative zero, then the result is the same as
 348      * the argument.  &lt;li&gt;If the argument value is less than zero but
 349      * greater than -1.0, then the result is negative zero.&lt;/ul&gt; Note
 350      * that the value of {@code StrictMath.ceil(x)} is exactly the
 351      * value of {@code -StrictMath.floor(-x)}.
 352      *
 353      * @param   a   a value.
 354      * @return  the smallest (closest to negative infinity)
 355      *          floating-point value that is greater than or equal to
 356      *          the argument and is equal to a mathematical integer.
 357      */
 358     public static double ceil(double a) {
 359         return floorOrCeil(a, -0.0, 1.0, 1.0);
 360     }
 361 
 362     /**
 363      * Returns the largest (closest to positive infinity)
 364      * {@code double} value that is less than or equal to the
 365      * argument and is equal to a mathematical integer. Special cases:
 366      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 367      * mathematical integer, then the result is the same as the
 368      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 369      * positive zero or negative zero, then the result is the same as
 370      * the argument.&lt;/ul&gt;
 371      *
 372      * @param   a   a value.
 373      * @return  the largest (closest to positive infinity)
 374      *          floating-point value that less than or equal to the argument
 375      *          and is equal to a mathematical integer.
 376      */
 377     public static double floor(double a) {
 378         return floorOrCeil(a, -1.0, 0.0, -1.0);
 379     }
 380 
 381     /**
 382      * Internal method to share logic between floor and ceil.
 383      *
 384      * @param a the value to be floored or ceiled
 385      * @param negativeBoundary result for values in (-1, 0)
 386      * @param positiveBoundary result for values in (0, 1)
 387      * @param increment value to add when the argument is non-integral
 388      */
 389     private static double floorOrCeil(double a,
 390                                       double negativeBoundary,
 391                                       double positiveBoundary,
 392                                       double sign) {
 393         int exponent = Math.getExponent(a);
 394 
 395         if (exponent &lt; 0) {
 396             /*
 397              * Absolute value of argument is less than 1.
 398              * floorOrceil(-0.0) =&gt; -0.0
 399              * floorOrceil(+0.0) =&gt; +0.0
 400              */
 401             return ((a == 0.0) ? a :
 402                     ( (a &lt; 0.0) ?  negativeBoundary : positiveBoundary) );
 403         } else if (exponent &gt;= 52) {
 404             /*
 405              * Infinity, NaN, or a value so large it must be integral.
 406              */
 407             return a;
 408         }
 409         // Else the argument is either an integral value already XOR it
 410         // has to be rounded to one.
 411         assert exponent &gt;= 0 &amp;&amp; exponent &lt;= 51;
 412 
 413         long doppel = Double.doubleToRawLongBits(a);
 414         long mask   = DoubleConsts.SIGNIF_BIT_MASK &gt;&gt; exponent;
 415 
 416         if ( (mask &amp; doppel) == 0L )
 417             return a; // integral value
 418         else {
 419             double result = Double.longBitsToDouble(doppel &amp; (~mask));
 420             if (sign*a &gt; 0.0)
 421                 result = result + sign;
 422             return result;
 423         }
 424     }
 425 
 426     /**
 427      * Returns the {@code double} value that is closest in value
 428      * to the argument and is equal to a mathematical integer. If two
 429      * {@code double} values that are mathematical integers are
 430      * equally close to the value of the argument, the result is the
 431      * integer value that is even. Special cases:
 432      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical
 433      * integer, then the result is the same as the argument.
 434      * &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative
 435      * zero, then the result is the same as the argument.&lt;/ul&gt;
 436      *
 437      * @param   a   a value.
 438      * @return  the closest floating-point value to {@code a} that is
 439      *          equal to a mathematical integer.
 440      * @author Joseph D. Darcy
 441      */
 442     public static double rint(double a) {
 443         /*
 444          * If the absolute value of a is not less than 2^52, it
 445          * is either a finite integer (the double format does not have
 446          * enough significand bits for a number that large to have any
 447          * fractional portion), an infinity, or a NaN.  In any of
 448          * these cases, rint of the argument is the argument.
 449          *
 450          * Otherwise, the sum (twoToThe52 + a ) will properly round
 451          * away any fractional portion of a since ulp(twoToThe52) ==
 452          * 1.0; subtracting out twoToThe52 from this sum will then be
 453          * exact and leave the rounded integer portion of a.
 454          *
 455          * This method does *not* need to be declared strictfp to get
 456          * fully reproducible results.  Whether or not a method is
 457          * declared strictfp can only make a difference in the
 458          * returned result if some operation would overflow or
 459          * underflow with strictfp semantics.  The operation
 460          * (twoToThe52 + a ) cannot overflow since large values of a
 461          * are screened out; the add cannot underflow since twoToThe52
 462          * is too large.  The subtraction ((twoToThe52 + a ) -
 463          * twoToThe52) will be exact as discussed above and thus
 464          * cannot overflow or meaningfully underflow.  Finally, the
 465          * last multiply in the return statement is by plus or minus
 466          * 1.0, which is exact too.
 467          */
 468         double twoToThe52 = (double)(1L &lt;&lt; 52); // 2^52
 469         double sign = Math.copySign(1.0, a); // preserve sign info
 470         a = Math.abs(a);
 471 
 472         if (a &lt; twoToThe52) { // E_min &lt;= ilogb(a) &lt;= 51
 473             a = ((twoToThe52 + a ) - twoToThe52);
 474         }
 475 
 476         return sign * a; // restore original sign
 477     }
 478 
 479     /**
 480      * Returns the angle &lt;i&gt;theta&lt;/i&gt; from the conversion of rectangular
 481      * coordinates ({@code x},&amp;nbsp;{@code y}) to polar
 482      * coordinates (r,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;).
 483      * This method computes the phase &lt;i&gt;theta&lt;/i&gt; by computing an arc tangent
 484      * of {@code y/x} in the range of -&lt;i&gt;pi&lt;/i&gt; to &lt;i&gt;pi&lt;/i&gt;. Special
 485      * cases:
 486      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, then the result is NaN.
 487      * &lt;li&gt;If the first argument is positive zero and the second argument
 488      * is positive, or the first argument is positive and finite and the
 489      * second argument is positive infinity, then the result is positive
 490      * zero.
 491      * &lt;li&gt;If the first argument is negative zero and the second argument
 492      * is positive, or the first argument is negative and finite and the
 493      * second argument is positive infinity, then the result is negative zero.
 494      * &lt;li&gt;If the first argument is positive zero and the second argument
 495      * is negative, or the first argument is positive and finite and the
 496      * second argument is negative infinity, then the result is the
 497      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;.
 498      * &lt;li&gt;If the first argument is negative zero and the second argument
 499      * is negative, or the first argument is negative and finite and the
 500      * second argument is negative infinity, then the result is the
 501      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;.
 502      * &lt;li&gt;If the first argument is positive and the second argument is
 503      * positive zero or negative zero, or the first argument is positive
 504      * infinity and the second argument is finite, then the result is the
 505      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/2.
 506      * &lt;li&gt;If the first argument is negative and the second argument is
 507      * positive zero or negative zero, or the first argument is negative
 508      * infinity and the second argument is finite, then the result is the
 509      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;/2.
 510      * &lt;li&gt;If both arguments are positive infinity, then the result is the
 511      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/4.
 512      * &lt;li&gt;If the first argument is positive infinity and the second argument
 513      * is negative infinity, then the result is the {@code double}
 514      * value closest to 3*&lt;i&gt;pi&lt;/i&gt;/4.
 515      * &lt;li&gt;If the first argument is negative infinity and the second argument
 516      * is positive infinity, then the result is the {@code double} value
 517      * closest to -&lt;i&gt;pi&lt;/i&gt;/4.
 518      * &lt;li&gt;If both arguments are negative infinity, then the result is the
 519      * {@code double} value closest to -3*&lt;i&gt;pi&lt;/i&gt;/4.&lt;/ul&gt;
 520      *
 521      * @param   y   the ordinate coordinate
 522      * @param   x   the abscissa coordinate
 523      * @return  the &lt;i&gt;theta&lt;/i&gt; component of the point
 524      *          (&lt;i&gt;r&lt;/i&gt;,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;)
 525      *          in polar coordinates that corresponds to the point
 526      *          (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in Cartesian coordinates.
 527      */
 528     public static native double atan2(double y, double x);
 529 
 530     /**
 531      * Returns the value of the first argument raised to the power of the
 532      * second argument. Special cases:
 533      *
 534      * &lt;ul&gt;&lt;li&gt;If the second argument is positive or negative zero, then the
 535      * result is 1.0.
 536      * &lt;li&gt;If the second argument is 1.0, then the result is the same as the
 537      * first argument.
 538      * &lt;li&gt;If the second argument is NaN, then the result is NaN.
 539      * &lt;li&gt;If the first argument is NaN and the second argument is nonzero,
 540      * then the result is NaN.
 541      *
 542      * &lt;li&gt;If
 543      * &lt;ul&gt;
 544      * &lt;li&gt;the absolute value of the first argument is greater than 1
 545      * and the second argument is positive infinity, or
 546      * &lt;li&gt;the absolute value of the first argument is less than 1 and
 547      * the second argument is negative infinity,
 548      * &lt;/ul&gt;
 549      * then the result is positive infinity.
 550      *
 551      * &lt;li&gt;If
 552      * &lt;ul&gt;
 553      * &lt;li&gt;the absolute value of the first argument is greater than 1 and
 554      * the second argument is negative infinity, or
 555      * &lt;li&gt;the absolute value of the
 556      * first argument is less than 1 and the second argument is positive
 557      * infinity,
 558      * &lt;/ul&gt;
 559      * then the result is positive zero.
 560      *
 561      * &lt;li&gt;If the absolute value of the first argument equals 1 and the
 562      * second argument is infinite, then the result is NaN.
 563      *
 564      * &lt;li&gt;If
 565      * &lt;ul&gt;
 566      * &lt;li&gt;the first argument is positive zero and the second argument
 567      * is greater than zero, or
 568      * &lt;li&gt;the first argument is positive infinity and the second
 569      * argument is less than zero,
 570      * &lt;/ul&gt;
 571      * then the result is positive zero.
 572      *
 573      * &lt;li&gt;If
 574      * &lt;ul&gt;
 575      * &lt;li&gt;the first argument is positive zero and the second argument
 576      * is less than zero, or
 577      * &lt;li&gt;the first argument is positive infinity and the second
 578      * argument is greater than zero,
 579      * &lt;/ul&gt;
 580      * then the result is positive infinity.
 581      *
 582      * &lt;li&gt;If
 583      * &lt;ul&gt;
 584      * &lt;li&gt;the first argument is negative zero and the second argument
 585      * is greater than zero but not a finite odd integer, or
 586      * &lt;li&gt;the first argument is negative infinity and the second
 587      * argument is less than zero but not a finite odd integer,
 588      * &lt;/ul&gt;
 589      * then the result is positive zero.
 590      *
 591      * &lt;li&gt;If
 592      * &lt;ul&gt;
 593      * &lt;li&gt;the first argument is negative zero and the second argument
 594      * is a positive finite odd integer, or
 595      * &lt;li&gt;the first argument is negative infinity and the second
 596      * argument is a negative finite odd integer,
 597      * &lt;/ul&gt;
 598      * then the result is negative zero.
 599      *
 600      * &lt;li&gt;If
 601      * &lt;ul&gt;
 602      * &lt;li&gt;the first argument is negative zero and the second argument
 603      * is less than zero but not a finite odd integer, or
 604      * &lt;li&gt;the first argument is negative infinity and the second
 605      * argument is greater than zero but not a finite odd integer,
 606      * &lt;/ul&gt;
 607      * then the result is positive infinity.
 608      *
 609      * &lt;li&gt;If
 610      * &lt;ul&gt;
 611      * &lt;li&gt;the first argument is negative zero and the second argument
 612      * is a negative finite odd integer, or
 613      * &lt;li&gt;the first argument is negative infinity and the second
 614      * argument is a positive finite odd integer,
 615      * &lt;/ul&gt;
 616      * then the result is negative infinity.
 617      *
 618      * &lt;li&gt;If the first argument is finite and less than zero
 619      * &lt;ul&gt;
 620      * &lt;li&gt; if the second argument is a finite even integer, the
 621      * result is equal to the result of raising the absolute value of
 622      * the first argument to the power of the second argument
 623      *
 624      * &lt;li&gt;if the second argument is a finite odd integer, the result
 625      * is equal to the negative of the result of raising the absolute
 626      * value of the first argument to the power of the second
 627      * argument
 628      *
 629      * &lt;li&gt;if the second argument is finite and not an integer, then
 630      * the result is NaN.
 631      * &lt;/ul&gt;
 632      *
 633      * &lt;li&gt;If both arguments are integers, then the result is exactly equal
 634      * to the mathematical result of raising the first argument to the power
 635      * of the second argument if that result can in fact be represented
 636      * exactly as a {@code double} value.&lt;/ul&gt;
 637      *
 638      * &lt;p&gt;(In the foregoing descriptions, a floating-point value is
 639      * considered to be an integer if and only if it is finite and a
 640      * fixed point of the method {@link #ceil ceil} or,
 641      * equivalently, a fixed point of the method {@link #floor
 642      * floor}. A value is a fixed point of a one-argument
 643      * method if and only if the result of applying the method to the
 644      * value is equal to the value.)
 645      *
 646      * @param   a   base.
 647      * @param   b   the exponent.
 648      * @return  the value {@code a}&lt;sup&gt;{@code b}&lt;/sup&gt;.
 649      */
 650     public static double pow(double a, double b) {
 651         return FdLibm.Pow.compute(a, b);
 652     }
 653 
 654     /**
 655      * Returns the closest {@code int} to the argument, with ties
 656      * rounding to positive infinity.
 657      *
 658      * &lt;p&gt;Special cases:
 659      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 660      * &lt;li&gt;If the argument is negative infinity or any value less than or
 661      * equal to the value of {@code Integer.MIN_VALUE}, the result is
 662      * equal to the value of {@code Integer.MIN_VALUE}.
 663      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 664      * equal to the value of {@code Integer.MAX_VALUE}, the result is
 665      * equal to the value of {@code Integer.MAX_VALUE}.&lt;/ul&gt;
 666      *
 667      * @param   a   a floating-point value to be rounded to an integer.
 668      * @return  the value of the argument rounded to the nearest
 669      *          {@code int} value.
 670      * @see     java.lang.Integer#MAX_VALUE
 671      * @see     java.lang.Integer#MIN_VALUE
 672      */
 673     public static int round(float a) {
 674         return Math.round(a);
 675     }
 676 
 677     /**
 678      * Returns the closest {@code long} to the argument, with ties
 679      * rounding to positive infinity.
 680      *
 681      * &lt;p&gt;Special cases:
 682      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 683      * &lt;li&gt;If the argument is negative infinity or any value less than or
 684      * equal to the value of {@code Long.MIN_VALUE}, the result is
 685      * equal to the value of {@code Long.MIN_VALUE}.
 686      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 687      * equal to the value of {@code Long.MAX_VALUE}, the result is
 688      * equal to the value of {@code Long.MAX_VALUE}.&lt;/ul&gt;
 689      *
 690      * @param   a  a floating-point value to be rounded to a
 691      *          {@code long}.
 692      * @return  the value of the argument rounded to the nearest
 693      *          {@code long} value.
 694      * @see     java.lang.Long#MAX_VALUE
 695      * @see     java.lang.Long#MIN_VALUE
 696      */
 697     public static long round(double a) {
 698         return Math.round(a);
 699     }
 700 
 701     private static final class RandomNumberGeneratorHolder {
 702         static final Random randomNumberGenerator = new Random();
 703     }
 704 
 705     /**
 706      * Returns a {@code double} value with a positive sign, greater
 707      * than or equal to {@code 0.0} and less than {@code 1.0}.
 708      * Returned values are chosen pseudorandomly with (approximately)
 709      * uniform distribution from that range.
 710      *
 711      * &lt;p&gt;When this method is first called, it creates a single new
 712      * pseudorandom-number generator, exactly as if by the expression
 713      *
 714      * &lt;blockquote&gt;{@code new java.util.Random()}&lt;/blockquote&gt;
 715      *
 716      * This new pseudorandom-number generator is used thereafter for
 717      * all calls to this method and is used nowhere else.
 718      *
 719      * &lt;p&gt;This method is properly synchronized to allow correct use by
 720      * more than one thread. However, if many threads need to generate
 721      * pseudorandom numbers at a great rate, it may reduce contention
 722      * for each thread to have its own pseudorandom-number generator.
 723      *
 724      * @return  a pseudorandom {@code double} greater than or equal
 725      * to {@code 0.0} and less than {@code 1.0}.
 726      * @see Random#nextDouble()
 727      */
 728     public static double random() {
 729         return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();
 730     }
 731 
 732     /**
 733      * Returns the sum of its arguments,
 734      * throwing an exception if the result overflows an {@code int}.
 735      *
 736      * @param x the first value
 737      * @param y the second value
 738      * @return the result
 739      * @throws ArithmeticException if the result overflows an int
 740      * @see Math#addExact(int,int)
 741      * @since 1.8
 742      */
 743     public static int addExact(int x, int y) {
 744         return Math.addExact(x, y);
 745     }
 746 
 747     /**
 748      * Returns the sum of its arguments,
 749      * throwing an exception if the result overflows a {@code long}.
 750      *
 751      * @param x the first value
 752      * @param y the second value
 753      * @return the result
 754      * @throws ArithmeticException if the result overflows a long
 755      * @see Math#addExact(long,long)
 756      * @since 1.8
 757      */
 758     public static long addExact(long x, long y) {
 759         return Math.addExact(x, y);
 760     }
 761 
 762     /**
 763      * Returns the difference of the arguments,
 764      * throwing an exception if the result overflows an {@code int}.
 765      *
 766      * @param x the first value
 767      * @param y the second value to subtract from the first
 768      * @return the result
 769      * @throws ArithmeticException if the result overflows an int
 770      * @see Math#subtractExact(int,int)
 771      * @since 1.8
 772      */
 773     public static int subtractExact(int x, int y) {
 774         return Math.subtractExact(x, y);
 775     }
 776 
 777     /**
 778      * Returns the difference of the arguments,
 779      * throwing an exception if the result overflows a {@code long}.
 780      *
 781      * @param x the first value
 782      * @param y the second value to subtract from the first
 783      * @return the result
 784      * @throws ArithmeticException if the result overflows a long
 785      * @see Math#subtractExact(long,long)
 786      * @since 1.8
 787      */
 788     public static long subtractExact(long x, long y) {
 789         return Math.subtractExact(x, y);
 790     }
 791 
 792     /**
 793      * Returns the product of the arguments,
 794      * throwing an exception if the result overflows an {@code int}.
 795      *
 796      * @param x the first value
 797      * @param y the second value
 798      * @return the result
 799      * @throws ArithmeticException if the result overflows an int
 800      * @see Math#multiplyExact(int,int)
 801      * @since 1.8
 802      */
 803     public static int multiplyExact(int x, int y) {
 804         return Math.multiplyExact(x, y);
 805     }
 806 
 807     /**
 808      * Returns the product of the arguments, throwing an exception if the result
 809      * overflows a {@code long}.
 810      *
 811      * @param x the first value
 812      * @param y the second value
 813      * @return the result
 814      * @throws ArithmeticException if the result overflows a long
 815      * @see Math#multiplyExact(long,int)
 816      * @since 9
 817      */
 818     public static long multiplyExact(long x, int y) {
 819         return Math.multiplyExact(x, y);
 820     }
 821 
 822     /**
 823      * Returns the product of the arguments,
 824      * throwing an exception if the result overflows a {@code long}.
 825      *
 826      * @param x the first value
 827      * @param y the second value
 828      * @return the result
 829      * @throws ArithmeticException if the result overflows a long
 830      * @see Math#multiplyExact(long,long)
 831      * @since 1.8
 832      */
 833     public static long multiplyExact(long x, long y) {
 834         return Math.multiplyExact(x, y);
 835     }
 836 
 837     /**
<a name="4" id="anc4"></a><span class="line-modified"> 838      * Returns the value of the {@code long} argument;</span>
<span class="line-modified"> 839      * throwing an exception if the value overflows an {@code int}.</span>


























































































 840      *
 841      * @param value the long value
 842      * @return the argument as an int
 843      * @throws ArithmeticException if the {@code argument} overflows an int
 844      * @see Math#toIntExact(long)
 845      * @since 1.8
 846      */
 847     public static int toIntExact(long value) {
 848         return Math.toIntExact(value);
 849     }
 850 
 851     /**
 852      * Returns the exact mathematical product of the arguments.
 853      *
 854      * @param x the first value
 855      * @param y the second value
 856      * @return the result
 857      * @see Math#multiplyFull(int,int)
 858      * @since 9
 859      */
 860     public static long multiplyFull(int x, int y) {
 861         return Math.multiplyFull(x, y);
 862     }
 863 
 864     /**
 865      * Returns as a {@code long} the most significant 64 bits of the 128-bit
 866      * product of two 64-bit factors.
 867      *
 868      * @param x the first value
 869      * @param y the second value
 870      * @return the result
 871      * @see Math#multiplyHigh(long,long)
 872      * @since 9
 873      */
 874     public static long multiplyHigh(long x, long y) {
 875         return Math.multiplyHigh(x, y);
 876     }
 877 
 878     /**
 879      * Returns the largest (closest to positive infinity)
 880      * {@code int} value that is less than or equal to the algebraic quotient.
 881      * There is one special case, if the dividend is the
 882      * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},
 883      * then integer overflow occurs and
 884      * the result is equal to the {@code Integer.MIN_VALUE}.
 885      * &lt;p&gt;
 886      * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
 887      * a comparison to the integer division {@code /} operator.
 888      *
 889      * @param x the dividend
 890      * @param y the divisor
 891      * @return the largest (closest to positive infinity)
 892      * {@code int} value that is less than or equal to the algebraic quotient.
 893      * @throws ArithmeticException if the divisor {@code y} is zero
 894      * @see Math#floorDiv(int, int)
 895      * @see Math#floor(double)
 896      * @since 1.8
 897      */
 898     public static int floorDiv(int x, int y) {
 899         return Math.floorDiv(x, y);
 900     }
 901 
 902     /**
 903      * Returns the largest (closest to positive infinity)
 904      * {@code long} value that is less than or equal to the algebraic quotient.
 905      * There is one special case, if the dividend is the
 906      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
 907      * then integer overflow occurs and
 908      * the result is equal to {@code Long.MIN_VALUE}.
 909      * &lt;p&gt;
 910      * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
 911      * a comparison to the integer division {@code /} operator.
 912      *
 913      * @param x the dividend
 914      * @param y the divisor
 915      * @return the largest (closest to positive infinity)
 916      * {@code int} value that is less than or equal to the algebraic quotient.
 917      * @throws ArithmeticException if the divisor {@code y} is zero
 918      * @see Math#floorDiv(long, int)
 919      * @see Math#floor(double)
 920      * @since 9
 921      */
 922     public static long floorDiv(long x, int y) {
 923         return Math.floorDiv(x, y);
 924     }
 925 
 926     /**
 927      * Returns the largest (closest to positive infinity)
 928      * {@code long} value that is less than or equal to the algebraic quotient.
 929      * There is one special case, if the dividend is the
 930      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
 931      * then integer overflow occurs and
 932      * the result is equal to the {@code Long.MIN_VALUE}.
 933      * &lt;p&gt;
 934      * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
 935      * a comparison to the integer division {@code /} operator.
 936      *
 937      * @param x the dividend
 938      * @param y the divisor
 939      * @return the largest (closest to positive infinity)
 940      * {@code long} value that is less than or equal to the algebraic quotient.
 941      * @throws ArithmeticException if the divisor {@code y} is zero
 942      * @see Math#floorDiv(long, long)
 943      * @see Math#floor(double)
 944      * @since 1.8
 945      */
 946     public static long floorDiv(long x, long y) {
 947         return Math.floorDiv(x, y);
 948     }
 949 
 950     /**
 951      * Returns the floor modulus of the {@code int} arguments.
 952      * &lt;p&gt;
 953      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
 954      * has the same sign as the divisor {@code y}, and
 955      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
 956      * &lt;p&gt;
 957      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
 958      * &lt;ul&gt;
 959      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
 960      * &lt;/ul&gt;
 961      * &lt;p&gt;
 962      * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
 963      * a comparison to the {@code %} operator.
 964      *
 965      * @param x the dividend
 966      * @param y the divisor
 967      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
 968      * @throws ArithmeticException if the divisor {@code y} is zero
 969      * @see Math#floorMod(int, int)
 970      * @see StrictMath#floorDiv(int, int)
 971      * @since 1.8
 972      */
 973     public static int floorMod(int x, int y) {
 974         return Math.floorMod(x , y);
 975     }
 976 
 977     /**
 978      * Returns the floor modulus of the {@code long} and {@code int} arguments.
 979      * &lt;p&gt;
 980      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
 981      * has the same sign as the divisor {@code y}, and
 982      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
 983      *
 984      * &lt;p&gt;
 985      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
 986      * &lt;ul&gt;
 987      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
 988      * &lt;/ul&gt;
 989      * &lt;p&gt;
 990      * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
 991      * a comparison to the {@code %} operator.
 992      *
 993      * @param x the dividend
 994      * @param y the divisor
 995      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
 996      * @throws ArithmeticException if the divisor {@code y} is zero
 997      * @see Math#floorMod(long, int)
 998      * @see StrictMath#floorDiv(long, int)
 999      * @since 9
1000      */
1001     public static int floorMod(long x, int y) {
1002         return Math.floorMod(x , y);
1003     }
1004 
1005     /**
1006      * Returns the floor modulus of the {@code long} arguments.
1007      * &lt;p&gt;
1008      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1009      * has the same sign as the divisor {@code y}, and
1010      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1011      * &lt;p&gt;
1012      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1013      * &lt;ul&gt;
1014      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1015      * &lt;/ul&gt;
1016      * &lt;p&gt;
1017      * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
1018      * a comparison to the {@code %} operator.
1019      *
1020      * @param x the dividend
1021      * @param y the divisor
1022      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1023      * @throws ArithmeticException if the divisor {@code y} is zero
1024      * @see Math#floorMod(long, long)
1025      * @see StrictMath#floorDiv(long, long)
1026      * @since 1.8
1027      */
1028     public static long floorMod(long x, long y) {
1029         return Math.floorMod(x, y);
1030     }
1031 
1032     /**
1033      * Returns the absolute value of an {@code int} value.
1034      * If the argument is not negative, the argument is returned.
1035      * If the argument is negative, the negation of the argument is returned.
1036      *
1037      * &lt;p&gt;Note that if the argument is equal to the value of
1038      * {@link Integer#MIN_VALUE}, the most negative representable
1039      * {@code int} value, the result is that same value, which is
1040      * negative.
1041      *
1042      * @param   a   the  argument whose absolute value is to be determined.
1043      * @return  the absolute value of the argument.
1044      */
1045     public static int abs(int a) {
1046         return Math.abs(a);
1047     }
1048 
1049     /**
1050      * Returns the absolute value of a {@code long} value.
1051      * If the argument is not negative, the argument is returned.
1052      * If the argument is negative, the negation of the argument is returned.
1053      *
1054      * &lt;p&gt;Note that if the argument is equal to the value of
1055      * {@link Long#MIN_VALUE}, the most negative representable
1056      * {@code long} value, the result is that same value, which
1057      * is negative.
1058      *
1059      * @param   a   the  argument whose absolute value is to be determined.
1060      * @return  the absolute value of the argument.
1061      */
1062     public static long abs(long a) {
1063         return Math.abs(a);
1064     }
1065 
1066     /**
1067      * Returns the absolute value of a {@code float} value.
1068      * If the argument is not negative, the argument is returned.
1069      * If the argument is negative, the negation of the argument is returned.
1070      * Special cases:
1071      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the
1072      * result is positive zero.
1073      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1074      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1075      *
1076      * @apiNote As implied by the above, one valid implementation of
1077      * this method is given by the expression below which computes a
1078      * {@code float} with the same exponent and significand as the
1079      * argument but with a guaranteed zero sign bit indicating a
1080      * positive value: &lt;br&gt;
1081      * {@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToRawIntBits(a))}
1082      *
1083      * @param   a   the argument whose absolute value is to be determined
1084      * @return  the absolute value of the argument.
1085      */
1086     public static float abs(float a) {
1087         return Math.abs(a);
1088     }
1089 
1090     /**
1091      * Returns the absolute value of a {@code double} value.
1092      * If the argument is not negative, the argument is returned.
1093      * If the argument is negative, the negation of the argument is returned.
1094      * Special cases:
1095      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the result
1096      * is positive zero.
1097      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1098      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1099      *
1100      * @apiNote As implied by the above, one valid implementation of
1101      * this method is given by the expression below which computes a
1102      * {@code double} with the same exponent and significand as the
1103      * argument but with a guaranteed zero sign bit indicating a
1104      * positive value: &lt;br&gt;
1105      * {@code Double.longBitsToDouble((Double.doubleToRawLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1)}
1106      *
1107      * @param   a   the argument whose absolute value is to be determined
1108      * @return  the absolute value of the argument.
1109      */
1110     public static double abs(double a) {
1111         return Math.abs(a);
1112     }
1113 
1114     /**
1115      * Returns the greater of two {@code int} values. That is, the
1116      * result is the argument closer to the value of
1117      * {@link Integer#MAX_VALUE}. If the arguments have the same value,
1118      * the result is that same value.
1119      *
1120      * @param   a   an argument.
1121      * @param   b   another argument.
1122      * @return  the larger of {@code a} and {@code b}.
1123      */
1124     @HotSpotIntrinsicCandidate
1125     public static int max(int a, int b) {
1126         return Math.max(a, b);
1127     }
1128 
1129     /**
1130      * Returns the greater of two {@code long} values. That is, the
1131      * result is the argument closer to the value of
1132      * {@link Long#MAX_VALUE}. If the arguments have the same value,
1133      * the result is that same value.
1134      *
1135      * @param   a   an argument.
1136      * @param   b   another argument.
1137      * @return  the larger of {@code a} and {@code b}.
1138         */
1139     public static long max(long a, long b) {
1140         return Math.max(a, b);
1141     }
1142 
1143     /**
1144      * Returns the greater of two {@code float} values.  That is,
1145      * the result is the argument closer to positive infinity. If the
1146      * arguments have the same value, the result is that same
1147      * value. If either value is NaN, then the result is NaN.  Unlike
1148      * the numerical comparison operators, this method considers
1149      * negative zero to be strictly smaller than positive zero. If one
1150      * argument is positive zero and the other negative zero, the
1151      * result is positive zero.
1152      *
1153      * @param   a   an argument.
1154      * @param   b   another argument.
1155      * @return  the larger of {@code a} and {@code b}.
1156      */
1157     @HotSpotIntrinsicCandidate
1158     public static float max(float a, float b) {
1159         return Math.max(a, b);
1160     }
1161 
1162     /**
1163      * Returns the greater of two {@code double} values.  That
1164      * is, the result is the argument closer to positive infinity. If
1165      * the arguments have the same value, the result is that same
1166      * value. If either value is NaN, then the result is NaN.  Unlike
1167      * the numerical comparison operators, this method considers
1168      * negative zero to be strictly smaller than positive zero. If one
1169      * argument is positive zero and the other negative zero, the
1170      * result is positive zero.
1171      *
1172      * @param   a   an argument.
1173      * @param   b   another argument.
1174      * @return  the larger of {@code a} and {@code b}.
1175      */
1176     @HotSpotIntrinsicCandidate
1177     public static double max(double a, double b) {
1178         return Math.max(a, b);
1179     }
1180 
1181     /**
1182      * Returns the smaller of two {@code int} values. That is,
1183      * the result the argument closer to the value of
1184      * {@link Integer#MIN_VALUE}.  If the arguments have the same
1185      * value, the result is that same value.
1186      *
1187      * @param   a   an argument.
1188      * @param   b   another argument.
1189      * @return  the smaller of {@code a} and {@code b}.
1190      */
1191     @HotSpotIntrinsicCandidate
1192     public static int min(int a, int b) {
1193         return Math.min(a, b);
1194     }
1195 
1196     /**
1197      * Returns the smaller of two {@code long} values. That is,
1198      * the result is the argument closer to the value of
1199      * {@link Long#MIN_VALUE}. If the arguments have the same
1200      * value, the result is that same value.
1201      *
1202      * @param   a   an argument.
1203      * @param   b   another argument.
1204      * @return  the smaller of {@code a} and {@code b}.
1205      */
1206     public static long min(long a, long b) {
1207         return Math.min(a, b);
1208     }
1209 
1210     /**
1211      * Returns the smaller of two {@code float} values.  That is,
1212      * the result is the value closer to negative infinity. If the
1213      * arguments have the same value, the result is that same
1214      * value. If either value is NaN, then the result is NaN.  Unlike
1215      * the numerical comparison operators, this method considers
1216      * negative zero to be strictly smaller than positive zero.  If
1217      * one argument is positive zero and the other is negative zero,
1218      * the result is negative zero.
1219      *
1220      * @param   a   an argument.
1221      * @param   b   another argument.
1222      * @return  the smaller of {@code a} and {@code b.}
1223      */
1224     @HotSpotIntrinsicCandidate
1225     public static float min(float a, float b) {
1226         return Math.min(a, b);
1227     }
1228 
1229     /**
1230      * Returns the smaller of two {@code double} values.  That
1231      * is, the result is the value closer to negative infinity. If the
1232      * arguments have the same value, the result is that same
1233      * value. If either value is NaN, then the result is NaN.  Unlike
1234      * the numerical comparison operators, this method considers
1235      * negative zero to be strictly smaller than positive zero. If one
1236      * argument is positive zero and the other is negative zero, the
1237      * result is negative zero.
1238      *
1239      * @param   a   an argument.
1240      * @param   b   another argument.
1241      * @return  the smaller of {@code a} and {@code b}.
1242      */
1243     @HotSpotIntrinsicCandidate
1244     public static double min(double a, double b) {
1245         return Math.min(a, b);
1246     }
1247 
1248     /**
1249      * Returns the fused multiply add of the three arguments; that is,
1250      * returns the exact product of the first two arguments summed
1251      * with the third argument and then rounded once to the nearest
1252      * {@code double}.
1253      *
1254      * The rounding is done using the {@linkplain
1255      * java.math.RoundingMode#HALF_EVEN round to nearest even
1256      * rounding mode}.
1257      *
1258      * In contrast, if {@code a * b + c} is evaluated as a regular
1259      * floating-point expression, two rounding errors are involved,
1260      * the first for the multiply operation, the second for the
1261      * addition operation.
1262      *
1263      * &lt;p&gt;Special cases:
1264      * &lt;ul&gt;
1265      * &lt;li&gt; If any argument is NaN, the result is NaN.
1266      *
1267      * &lt;li&gt; If one of the first two arguments is infinite and the
1268      * other is zero, the result is NaN.
1269      *
1270      * &lt;li&gt; If the exact product of the first two arguments is infinite
1271      * (in other words, at least one of the arguments is infinite and
1272      * the other is neither zero nor NaN) and the third argument is an
1273      * infinity of the opposite sign, the result is NaN.
1274      *
1275      * &lt;/ul&gt;
1276      *
1277      * &lt;p&gt;Note that {@code fusedMac(a, 1.0, c)} returns the same
1278      * result as ({@code a + c}).  However,
1279      * {@code fusedMac(a, b, +0.0)} does &lt;em&gt;not&lt;/em&gt; always return the
1280      * same result as ({@code a * b}) since
1281      * {@code fusedMac(-0.0, +0.0, +0.0)} is {@code +0.0} while
1282      * ({@code -0.0 * +0.0}) is {@code -0.0}; {@code fusedMac(a, b, -0.0)} is
1283      * equivalent to ({@code a * b}) however.
1284      *
1285      * @apiNote This method corresponds to the fusedMultiplyAdd
1286      * operation defined in IEEE 754-2008.
1287      *
1288      * @param a a value
1289      * @param b a value
1290      * @param c a value
1291      *
1292      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1293      * computed, as if with unlimited range and precision, and rounded
1294      * once to the nearest {@code double} value
1295      *
1296      * @since 9
1297      */
1298     public static double fma(double a, double b, double c) {
1299         return Math.fma(a, b, c);
1300     }
1301 
1302     /**
1303      * Returns the fused multiply add of the three arguments; that is,
1304      * returns the exact product of the first two arguments summed
1305      * with the third argument and then rounded once to the nearest
1306      * {@code float}.
1307      *
1308      * The rounding is done using the {@linkplain
1309      * java.math.RoundingMode#HALF_EVEN round to nearest even
1310      * rounding mode}.
1311      *
1312      * In contrast, if {@code a * b + c} is evaluated as a regular
1313      * floating-point expression, two rounding errors are involved,
1314      * the first for the multiply operation, the second for the
1315      * addition operation.
1316      *
1317      * &lt;p&gt;Special cases:
1318      * &lt;ul&gt;
1319      * &lt;li&gt; If any argument is NaN, the result is NaN.
1320      *
1321      * &lt;li&gt; If one of the first two arguments is infinite and the
1322      * other is zero, the result is NaN.
1323      *
1324      * &lt;li&gt; If the exact product of the first two arguments is infinite
1325      * (in other words, at least one of the arguments is infinite and
1326      * the other is neither zero nor NaN) and the third argument is an
1327      * infinity of the opposite sign, the result is NaN.
1328      *
1329      * &lt;/ul&gt;
1330      *
1331      * &lt;p&gt;Note that {@code fma(a, 1.0f, c)} returns the same
1332      * result as ({@code a + c}).  However,
1333      * {@code fma(a, b, +0.0f)} does &lt;em&gt;not&lt;/em&gt; always return the
1334      * same result as ({@code a * b}) since
1335      * {@code fma(-0.0f, +0.0f, +0.0f)} is {@code +0.0f} while
1336      * ({@code -0.0f * +0.0f}) is {@code -0.0f}; {@code fma(a, b, -0.0f)} is
1337      * equivalent to ({@code a * b}) however.
1338      *
1339      * @apiNote This method corresponds to the fusedMultiplyAdd
1340      * operation defined in IEEE 754-2008.
1341      *
1342      * @param a a value
1343      * @param b a value
1344      * @param c a value
1345      *
1346      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1347      * computed, as if with unlimited range and precision, and rounded
1348      * once to the nearest {@code float} value
1349      *
1350      * @since 9
1351      */
1352     public static float fma(float a, float b, float c) {
1353         return Math.fma(a, b, c);
1354     }
1355 
1356     /**
1357      * Returns the size of an ulp of the argument.  An ulp, unit in
1358      * the last place, of a {@code double} value is the positive
1359      * distance between this floating-point value and the {@code
1360      * double} value next larger in magnitude.  Note that for non-NaN
1361      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1362      *
1363      * &lt;p&gt;Special Cases:
1364      * &lt;ul&gt;
1365      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1366      * &lt;li&gt; If the argument is positive or negative infinity, then the
1367      * result is positive infinity.
1368      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1369      * {@code Double.MIN_VALUE}.
1370      * &lt;li&gt; If the argument is &amp;plusmn;{@code Double.MAX_VALUE}, then
1371      * the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.
1372      * &lt;/ul&gt;
1373      *
1374      * @param d the floating-point value whose ulp is to be returned
1375      * @return the size of an ulp of the argument
1376      * @author Joseph D. Darcy
1377      * @since 1.5
1378      */
1379     public static double ulp(double d) {
1380         return Math.ulp(d);
1381     }
1382 
1383     /**
1384      * Returns the size of an ulp of the argument.  An ulp, unit in
1385      * the last place, of a {@code float} value is the positive
1386      * distance between this floating-point value and the {@code
1387      * float} value next larger in magnitude.  Note that for non-NaN
1388      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1389      *
1390      * &lt;p&gt;Special Cases:
1391      * &lt;ul&gt;
1392      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1393      * &lt;li&gt; If the argument is positive or negative infinity, then the
1394      * result is positive infinity.
1395      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1396      * {@code Float.MIN_VALUE}.
1397      * &lt;li&gt; If the argument is &amp;plusmn;{@code Float.MAX_VALUE}, then
1398      * the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.
1399      * &lt;/ul&gt;
1400      *
1401      * @param f the floating-point value whose ulp is to be returned
1402      * @return the size of an ulp of the argument
1403      * @author Joseph D. Darcy
1404      * @since 1.5
1405      */
1406     public static float ulp(float f) {
1407         return Math.ulp(f);
1408     }
1409 
1410     /**
1411      * Returns the signum function of the argument; zero if the argument
1412      * is zero, 1.0 if the argument is greater than zero, -1.0 if the
1413      * argument is less than zero.
1414      *
1415      * &lt;p&gt;Special Cases:
1416      * &lt;ul&gt;
1417      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1418      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1419      *      result is the same as the argument.
1420      * &lt;/ul&gt;
1421      *
1422      * @param d the floating-point value whose signum is to be returned
1423      * @return the signum function of the argument
1424      * @author Joseph D. Darcy
1425      * @since 1.5
1426      */
1427     public static double signum(double d) {
1428         return Math.signum(d);
1429     }
1430 
1431     /**
1432      * Returns the signum function of the argument; zero if the argument
1433      * is zero, 1.0f if the argument is greater than zero, -1.0f if the
1434      * argument is less than zero.
1435      *
1436      * &lt;p&gt;Special Cases:
1437      * &lt;ul&gt;
1438      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1439      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1440      *      result is the same as the argument.
1441      * &lt;/ul&gt;
1442      *
1443      * @param f the floating-point value whose signum is to be returned
1444      * @return the signum function of the argument
1445      * @author Joseph D. Darcy
1446      * @since 1.5
1447      */
1448     public static float signum(float f) {
1449         return Math.signum(f);
1450     }
1451 
1452     /**
1453      * Returns the hyperbolic sine of a {@code double} value.
1454      * The hyperbolic sine of &lt;i&gt;x&lt;/i&gt; is defined to be
1455      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1456      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1457      *
1458      * &lt;p&gt;Special cases:
1459      * &lt;ul&gt;
1460      *
1461      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1462      *
1463      * &lt;li&gt;If the argument is infinite, then the result is an infinity
1464      * with the same sign as the argument.
1465      *
1466      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1467      * same sign as the argument.
1468      *
1469      * &lt;/ul&gt;
1470      *
1471      * @param   x The number whose hyperbolic sine is to be returned.
1472      * @return  The hyperbolic sine of {@code x}.
1473      * @since 1.5
1474      */
1475     public static native double sinh(double x);
1476 
1477     /**
1478      * Returns the hyperbolic cosine of a {@code double} value.
1479      * The hyperbolic cosine of &lt;i&gt;x&lt;/i&gt; is defined to be
1480      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1481      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1482      *
1483      * &lt;p&gt;Special cases:
1484      * &lt;ul&gt;
1485      *
1486      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1487      *
1488      * &lt;li&gt;If the argument is infinite, then the result is positive
1489      * infinity.
1490      *
1491      * &lt;li&gt;If the argument is zero, then the result is {@code 1.0}.
1492      *
1493      * &lt;/ul&gt;
1494      *
1495      * @param   x The number whose hyperbolic cosine is to be returned.
1496      * @return  The hyperbolic cosine of {@code x}.
1497      * @since 1.5
1498      */
1499     public static native double cosh(double x);
1500 
1501     /**
1502      * Returns the hyperbolic tangent of a {@code double} value.
1503      * The hyperbolic tangent of &lt;i&gt;x&lt;/i&gt; is defined to be
1504      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/(&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;),
1505      * in other words, {@linkplain Math#sinh
1506      * sinh(&lt;i&gt;x&lt;/i&gt;)}/{@linkplain Math#cosh cosh(&lt;i&gt;x&lt;/i&gt;)}.  Note
1507      * that the absolute value of the exact tanh is always less than
1508      * 1.
1509      *
1510      * &lt;p&gt;Special cases:
1511      * &lt;ul&gt;
1512      *
1513      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1514      *
1515      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1516      * same sign as the argument.
1517      *
1518      * &lt;li&gt;If the argument is positive infinity, then the result is
1519      * {@code +1.0}.
1520      *
1521      * &lt;li&gt;If the argument is negative infinity, then the result is
1522      * {@code -1.0}.
1523      *
1524      * &lt;/ul&gt;
1525      *
1526      * @param   x The number whose hyperbolic tangent is to be returned.
1527      * @return  The hyperbolic tangent of {@code x}.
1528      * @since 1.5
1529      */
1530     public static native double tanh(double x);
1531 
1532     /**
1533      * Returns sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
1534      * without intermediate overflow or underflow.
1535      *
1536      * &lt;p&gt;Special cases:
1537      * &lt;ul&gt;
1538      *
1539      * &lt;li&gt; If either argument is infinite, then the result
1540      * is positive infinity.
1541      *
1542      * &lt;li&gt; If either argument is NaN and neither argument is infinite,
1543      * then the result is NaN.
1544      *
1545      * &lt;/ul&gt;
1546      *
1547      * @param x a value
1548      * @param y a value
1549      * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
1550      * without intermediate overflow or underflow
1551      * @since 1.5
1552      */
1553     public static double hypot(double x, double y) {
1554         return FdLibm.Hypot.compute(x, y);
1555     }
1556 
1557     /**
1558      * Returns &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-1.  Note that for values of
1559      * &lt;i&gt;x&lt;/i&gt; near 0, the exact sum of
1560      * {@code expm1(x)}&amp;nbsp;+&amp;nbsp;1 is much closer to the true
1561      * result of &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt; than {@code exp(x)}.
1562      *
1563      * &lt;p&gt;Special cases:
1564      * &lt;ul&gt;
1565      * &lt;li&gt;If the argument is NaN, the result is NaN.
1566      *
1567      * &lt;li&gt;If the argument is positive infinity, then the result is
1568      * positive infinity.
1569      *
1570      * &lt;li&gt;If the argument is negative infinity, then the result is
1571      * -1.0.
1572      *
1573      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1574      * same sign as the argument.
1575      *
1576      * &lt;/ul&gt;
1577      *
1578      * @param   x   the exponent to raise &lt;i&gt;e&lt;/i&gt; to in the computation of
1579      *              &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-1.
1580      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;1.
1581      * @since 1.5
1582      */
1583     public static native double expm1(double x);
1584 
1585     /**
1586      * Returns the natural logarithm of the sum of the argument and 1.
1587      * Note that for small values {@code x}, the result of
1588      * {@code log1p(x)} is much closer to the true result of ln(1
1589      * + {@code x}) than the floating-point evaluation of
1590      * {@code log(1.0+x)}.
1591      *
1592      * &lt;p&gt;Special cases:
1593      * &lt;ul&gt;
1594      *
1595      * &lt;li&gt;If the argument is NaN or less than -1, then the result is
1596      * NaN.
1597      *
1598      * &lt;li&gt;If the argument is positive infinity, then the result is
1599      * positive infinity.
1600      *
1601      * &lt;li&gt;If the argument is negative one, then the result is
1602      * negative infinity.
1603      *
1604      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1605      * same sign as the argument.
1606      *
1607      * &lt;/ul&gt;
1608      *
1609      * @param   x   a value
1610      * @return the value ln({@code x}&amp;nbsp;+&amp;nbsp;1), the natural
1611      * log of {@code x}&amp;nbsp;+&amp;nbsp;1
1612      * @since 1.5
1613      */
1614     public static native double log1p(double x);
1615 
1616     /**
1617      * Returns the first floating-point argument with the sign of the
1618      * second floating-point argument.  For this method, a NaN
1619      * {@code sign} argument is always treated as if it were
1620      * positive.
1621      *
1622      * @param magnitude  the parameter providing the magnitude of the result
1623      * @param sign   the parameter providing the sign of the result
1624      * @return a value with the magnitude of {@code magnitude}
1625      * and the sign of {@code sign}.
1626      * @since 1.6
1627      */
1628     public static double copySign(double magnitude, double sign) {
1629         return Math.copySign(magnitude, (Double.isNaN(sign)?1.0d:sign));
1630     }
1631 
1632     /**
1633      * Returns the first floating-point argument with the sign of the
1634      * second floating-point argument.  For this method, a NaN
1635      * {@code sign} argument is always treated as if it were
1636      * positive.
1637      *
1638      * @param magnitude  the parameter providing the magnitude of the result
1639      * @param sign   the parameter providing the sign of the result
1640      * @return a value with the magnitude of {@code magnitude}
1641      * and the sign of {@code sign}.
1642      * @since 1.6
1643      */
1644     public static float copySign(float magnitude, float sign) {
1645         return Math.copySign(magnitude, (Float.isNaN(sign)?1.0f:sign));
1646     }
1647     /**
1648      * Returns the unbiased exponent used in the representation of a
1649      * {@code float}.  Special cases:
1650      *
1651      * &lt;ul&gt;
1652      * &lt;li&gt;If the argument is NaN or infinite, then the result is
1653      * {@link Float#MAX_EXPONENT} + 1.
1654      * &lt;li&gt;If the argument is zero or subnormal, then the result is
1655      * {@link Float#MIN_EXPONENT} -1.
1656      * &lt;/ul&gt;
1657      * @param f a {@code float} value
1658      * @return the unbiased exponent of the argument
1659      * @since 1.6
1660      */
1661     public static int getExponent(float f) {
1662         return Math.getExponent(f);
1663     }
1664 
1665     /**
1666      * Returns the unbiased exponent used in the representation of a
1667      * {@code double}.  Special cases:
1668      *
1669      * &lt;ul&gt;
1670      * &lt;li&gt;If the argument is NaN or infinite, then the result is
1671      * {@link Double#MAX_EXPONENT} + 1.
1672      * &lt;li&gt;If the argument is zero or subnormal, then the result is
1673      * {@link Double#MIN_EXPONENT} -1.
1674      * &lt;/ul&gt;
1675      * @param d a {@code double} value
1676      * @return the unbiased exponent of the argument
1677      * @since 1.6
1678      */
1679     public static int getExponent(double d) {
1680         return Math.getExponent(d);
1681     }
1682 
1683     /**
1684      * Returns the floating-point number adjacent to the first
1685      * argument in the direction of the second argument.  If both
1686      * arguments compare as equal the second argument is returned.
1687      *
1688      * &lt;p&gt;Special cases:
1689      * &lt;ul&gt;
1690      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
1691      *
1692      * &lt;li&gt; If both arguments are signed zeros, {@code direction}
1693      * is returned unchanged (as implied by the requirement of
1694      * returning the second argument if the arguments compare as
1695      * equal).
1696      *
1697      * &lt;li&gt; If {@code start} is
1698      * &amp;plusmn;{@link Double#MIN_VALUE} and {@code direction}
1699      * has a value such that the result should have a smaller
1700      * magnitude, then a zero with the same sign as {@code start}
1701      * is returned.
1702      *
1703      * &lt;li&gt; If {@code start} is infinite and
1704      * {@code direction} has a value such that the result should
1705      * have a smaller magnitude, {@link Double#MAX_VALUE} with the
1706      * same sign as {@code start} is returned.
1707      *
1708      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
1709      * {@link Double#MAX_VALUE} and {@code direction} has a
1710      * value such that the result should have a larger magnitude, an
1711      * infinity with same sign as {@code start} is returned.
1712      * &lt;/ul&gt;
1713      *
1714      * @param start  starting floating-point value
1715      * @param direction value indicating which of
1716      * {@code start}&#39;s neighbors or {@code start} should
1717      * be returned
1718      * @return The floating-point number adjacent to {@code start} in the
1719      * direction of {@code direction}.
1720      * @since 1.6
1721      */
1722     public static double nextAfter(double start, double direction) {
1723         return Math.nextAfter(start, direction);
1724     }
1725 
1726     /**
1727      * Returns the floating-point number adjacent to the first
1728      * argument in the direction of the second argument.  If both
1729      * arguments compare as equal a value equivalent to the second argument
1730      * is returned.
1731      *
1732      * &lt;p&gt;Special cases:
1733      * &lt;ul&gt;
1734      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
1735      *
1736      * &lt;li&gt; If both arguments are signed zeros, a value equivalent
1737      * to {@code direction} is returned.
1738      *
1739      * &lt;li&gt; If {@code start} is
1740      * &amp;plusmn;{@link Float#MIN_VALUE} and {@code direction}
1741      * has a value such that the result should have a smaller
1742      * magnitude, then a zero with the same sign as {@code start}
1743      * is returned.
1744      *
1745      * &lt;li&gt; If {@code start} is infinite and
1746      * {@code direction} has a value such that the result should
1747      * have a smaller magnitude, {@link Float#MAX_VALUE} with the
1748      * same sign as {@code start} is returned.
1749      *
1750      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
1751      * {@link Float#MAX_VALUE} and {@code direction} has a
1752      * value such that the result should have a larger magnitude, an
1753      * infinity with same sign as {@code start} is returned.
1754      * &lt;/ul&gt;
1755      *
1756      * @param start  starting floating-point value
1757      * @param direction value indicating which of
1758      * {@code start}&#39;s neighbors or {@code start} should
1759      * be returned
1760      * @return The floating-point number adjacent to {@code start} in the
1761      * direction of {@code direction}.
1762      * @since 1.6
1763      */
1764     public static float nextAfter(float start, double direction) {
1765         return Math.nextAfter(start, direction);
1766     }
1767 
1768     /**
1769      * Returns the floating-point value adjacent to {@code d} in
1770      * the direction of positive infinity.  This method is
1771      * semantically equivalent to {@code nextAfter(d,
1772      * Double.POSITIVE_INFINITY)}; however, a {@code nextUp}
1773      * implementation may run faster than its equivalent
1774      * {@code nextAfter} call.
1775      *
1776      * &lt;p&gt;Special Cases:
1777      * &lt;ul&gt;
1778      * &lt;li&gt; If the argument is NaN, the result is NaN.
1779      *
1780      * &lt;li&gt; If the argument is positive infinity, the result is
1781      * positive infinity.
1782      *
1783      * &lt;li&gt; If the argument is zero, the result is
1784      * {@link Double#MIN_VALUE}
1785      *
1786      * &lt;/ul&gt;
1787      *
1788      * @param d starting floating-point value
1789      * @return The adjacent floating-point value closer to positive
1790      * infinity.
1791      * @since 1.6
1792      */
1793     public static double nextUp(double d) {
1794         return Math.nextUp(d);
1795     }
1796 
1797     /**
1798      * Returns the floating-point value adjacent to {@code f} in
1799      * the direction of positive infinity.  This method is
1800      * semantically equivalent to {@code nextAfter(f,
1801      * Float.POSITIVE_INFINITY)}; however, a {@code nextUp}
1802      * implementation may run faster than its equivalent
1803      * {@code nextAfter} call.
1804      *
1805      * &lt;p&gt;Special Cases:
1806      * &lt;ul&gt;
1807      * &lt;li&gt; If the argument is NaN, the result is NaN.
1808      *
1809      * &lt;li&gt; If the argument is positive infinity, the result is
1810      * positive infinity.
1811      *
1812      * &lt;li&gt; If the argument is zero, the result is
1813      * {@link Float#MIN_VALUE}
1814      *
1815      * &lt;/ul&gt;
1816      *
1817      * @param f starting floating-point value
1818      * @return The adjacent floating-point value closer to positive
1819      * infinity.
1820      * @since 1.6
1821      */
1822     public static float nextUp(float f) {
1823         return Math.nextUp(f);
1824     }
1825 
1826     /**
1827      * Returns the floating-point value adjacent to {@code d} in
1828      * the direction of negative infinity.  This method is
1829      * semantically equivalent to {@code nextAfter(d,
1830      * Double.NEGATIVE_INFINITY)}; however, a
1831      * {@code nextDown} implementation may run faster than its
1832      * equivalent {@code nextAfter} call.
1833      *
1834      * &lt;p&gt;Special Cases:
1835      * &lt;ul&gt;
1836      * &lt;li&gt; If the argument is NaN, the result is NaN.
1837      *
1838      * &lt;li&gt; If the argument is negative infinity, the result is
1839      * negative infinity.
1840      *
1841      * &lt;li&gt; If the argument is zero, the result is
1842      * {@code -Double.MIN_VALUE}
1843      *
1844      * &lt;/ul&gt;
1845      *
1846      * @param d  starting floating-point value
1847      * @return The adjacent floating-point value closer to negative
1848      * infinity.
1849      * @since 1.8
1850      */
1851     public static double nextDown(double d) {
1852         return Math.nextDown(d);
1853     }
1854 
1855     /**
1856      * Returns the floating-point value adjacent to {@code f} in
1857      * the direction of negative infinity.  This method is
1858      * semantically equivalent to {@code nextAfter(f,
1859      * Float.NEGATIVE_INFINITY)}; however, a
1860      * {@code nextDown} implementation may run faster than its
1861      * equivalent {@code nextAfter} call.
1862      *
1863      * &lt;p&gt;Special Cases:
1864      * &lt;ul&gt;
1865      * &lt;li&gt; If the argument is NaN, the result is NaN.
1866      *
1867      * &lt;li&gt; If the argument is negative infinity, the result is
1868      * negative infinity.
1869      *
1870      * &lt;li&gt; If the argument is zero, the result is
1871      * {@code -Float.MIN_VALUE}
1872      *
1873      * &lt;/ul&gt;
1874      *
1875      * @param f  starting floating-point value
1876      * @return The adjacent floating-point value closer to negative
1877      * infinity.
1878      * @since 1.8
1879      */
1880     public static float nextDown(float f) {
1881         return Math.nextDown(f);
1882     }
1883 
1884     /**
1885      * Returns {@code d} &amp;times;
1886      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
1887      * by a single correctly rounded floating-point multiply to a
1888      * member of the double value set.  See the Java
1889      * Language Specification for a discussion of floating-point
1890      * value sets.  If the exponent of the result is between {@link
1891      * Double#MIN_EXPONENT} and {@link Double#MAX_EXPONENT}, the
1892      * answer is calculated exactly.  If the exponent of the result
1893      * would be larger than {@code Double.MAX_EXPONENT}, an
1894      * infinity is returned.  Note that if the result is subnormal,
1895      * precision may be lost; that is, when {@code scalb(x, n)}
1896      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
1897      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
1898      * sign as {@code d}.
1899      *
1900      * &lt;p&gt;Special cases:
1901      * &lt;ul&gt;
1902      * &lt;li&gt; If the first argument is NaN, NaN is returned.
1903      * &lt;li&gt; If the first argument is infinite, then an infinity of the
1904      * same sign is returned.
1905      * &lt;li&gt; If the first argument is zero, then a zero of the same
1906      * sign is returned.
1907      * &lt;/ul&gt;
1908      *
1909      * @param d number to be scaled by a power of two.
1910      * @param scaleFactor power of 2 used to scale {@code d}
1911      * @return {@code d} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
1912      * @since 1.6
1913      */
1914     public static double scalb(double d, int scaleFactor) {
1915         return Math.scalb(d, scaleFactor);
1916     }
1917 
1918     /**
1919      * Returns {@code f} &amp;times;
1920      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
1921      * by a single correctly rounded floating-point multiply to a
1922      * member of the float value set.  See the Java
1923      * Language Specification for a discussion of floating-point
1924      * value sets.  If the exponent of the result is between {@link
1925      * Float#MIN_EXPONENT} and {@link Float#MAX_EXPONENT}, the
1926      * answer is calculated exactly.  If the exponent of the result
1927      * would be larger than {@code Float.MAX_EXPONENT}, an
1928      * infinity is returned.  Note that if the result is subnormal,
1929      * precision may be lost; that is, when {@code scalb(x, n)}
1930      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
1931      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
1932      * sign as {@code f}.
1933      *
1934      * &lt;p&gt;Special cases:
1935      * &lt;ul&gt;
1936      * &lt;li&gt; If the first argument is NaN, NaN is returned.
1937      * &lt;li&gt; If the first argument is infinite, then an infinity of the
1938      * same sign is returned.
1939      * &lt;li&gt; If the first argument is zero, then a zero of the same
1940      * sign is returned.
1941      * &lt;/ul&gt;
1942      *
1943      * @param f number to be scaled by a power of two.
1944      * @param scaleFactor power of 2 used to scale {@code f}
1945      * @return {@code f} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
1946      * @since 1.6
1947      */
1948     public static float scalb(float f, int scaleFactor) {
1949         return Math.scalb(f, scaleFactor);
1950     }
1951 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
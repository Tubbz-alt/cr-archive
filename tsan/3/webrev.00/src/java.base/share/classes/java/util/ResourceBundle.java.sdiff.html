<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/ResourceBundle.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="RegularEnumSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Scanner.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/ResourceBundle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  62 import java.util.jar.JarEntry;
  63 import java.util.spi.ResourceBundleControlProvider;
  64 import java.util.spi.ResourceBundleProvider;
  65 import java.util.stream.Collectors;
  66 import java.util.stream.Stream;
  67 
  68 import jdk.internal.loader.BootLoader;
  69 import jdk.internal.access.JavaUtilResourceBundleAccess;
  70 import jdk.internal.access.SharedSecrets;
  71 import jdk.internal.reflect.CallerSensitive;
  72 import jdk.internal.reflect.Reflection;
  73 import sun.security.action.GetPropertyAction;
  74 import sun.util.locale.BaseLocale;
  75 import sun.util.locale.LocaleObjectCache;
  76 import static sun.security.util.SecurityConstants.GET_CLASSLOADER_PERMISSION;
  77 
  78 
  79 /**
  80  *
  81  * Resource bundles contain locale-specific objects.  When your program needs a
<span class="line-modified">  82  * locale-specific resource, a &lt;code&gt;String&lt;/code&gt; for example, your program can</span>
  83  * load it from the resource bundle that is appropriate for the current user&#39;s
  84  * locale. In this way, you can write program code that is largely independent
  85  * of the user&#39;s locale isolating most, if not all, of the locale-specific
  86  * information in resource bundles.
  87  *
  88  * &lt;p&gt;
  89  * This allows you to write programs that can:
  90  * &lt;UL&gt;
  91  * &lt;LI&gt; be easily localized, or translated, into different languages
  92  * &lt;LI&gt; handle multiple locales at once
  93  * &lt;LI&gt; be easily modified later to support even more locales
  94  * &lt;/UL&gt;
  95  *
  96  * &lt;P&gt;
  97  * Resource bundles belong to families whose members share a common base
  98  * name, but whose names also have additional components that identify
  99  * their locales. For example, the base name of a family of resource
 100  * bundles might be &quot;MyResources&quot;. The family should have a default
 101  * resource bundle which simply has the same name as its family -
 102  * &quot;MyResources&quot; - and will be used as the bundle of last resort if a
 103  * specific locale is not supported. The family can then provide as
 104  * many locale-specific members as needed, for example a German one
 105  * named &quot;MyResources_de&quot;.
 106  *
 107  * &lt;P&gt;
 108  * Each resource bundle in a family contains the same items, but the items have
 109  * been translated for the locale represented by that resource bundle.
 110  * For example, both &quot;MyResources&quot; and &quot;MyResources_de&quot; may have a
<span class="line-modified"> 111  * &lt;code&gt;String&lt;/code&gt; that&#39;s used on a button for canceling operations.</span>
<span class="line-modified"> 112  * In &quot;MyResources&quot; the &lt;code&gt;String&lt;/code&gt; may contain &quot;Cancel&quot; and in</span>
 113  * &quot;MyResources_de&quot; it may contain &quot;Abbrechen&quot;.
 114  *
 115  * &lt;P&gt;
 116  * If there are different resources for different countries, you
 117  * can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for
 118  * the German language (de) in Switzerland (CH). If you want to only
 119  * modify some of the resources
 120  * in the specialization, you can do so.
 121  *
 122  * &lt;P&gt;
 123  * When your program needs a locale-specific object, it loads
<span class="line-modified"> 124  * the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the</span>
 125  * {@link #getBundle(java.lang.String, java.util.Locale) getBundle}
 126  * method:
 127  * &lt;blockquote&gt;
 128  * &lt;pre&gt;
 129  * ResourceBundle myResources =
 130  *      ResourceBundle.getBundle(&quot;MyResources&quot;, currentLocale);
 131  * &lt;/pre&gt;
 132  * &lt;/blockquote&gt;
 133  *
 134  * &lt;P&gt;
 135  * Resource bundles contain key/value pairs. The keys uniquely
 136  * identify a locale-specific object in the bundle. Here&#39;s an
<span class="line-modified"> 137  * example of a &lt;code&gt;ListResourceBundle&lt;/code&gt; that contains</span>
 138  * two key/value pairs:
 139  * &lt;blockquote&gt;
 140  * &lt;pre&gt;
 141  * public class MyResources extends ListResourceBundle {
 142  *     protected Object[][] getContents() {
 143  *         return new Object[][] {
 144  *             // LOCALIZE THE SECOND STRING OF EACH ARRAY (e.g., &quot;OK&quot;)
 145  *             {&quot;OkKey&quot;, &quot;OK&quot;},
 146  *             {&quot;CancelKey&quot;, &quot;Cancel&quot;},
 147  *             // END OF MATERIAL TO LOCALIZE
 148  *        };
 149  *     }
 150  * }
 151  * &lt;/pre&gt;
 152  * &lt;/blockquote&gt;
<span class="line-modified"> 153  * Keys are always &lt;code&gt;String&lt;/code&gt;s.</span>
 154  * In this example, the keys are &quot;OkKey&quot; and &quot;CancelKey&quot;.
 155  * In the above example, the values
<span class="line-modified"> 156  * are also &lt;code&gt;String&lt;/code&gt;s--&quot;OK&quot; and &quot;Cancel&quot;--but</span>
 157  * they don&#39;t have to be. The values can be any type of object.
 158  *
 159  * &lt;P&gt;
 160  * You retrieve an object from resource bundle using the appropriate
 161  * getter method. Because &quot;OkKey&quot; and &quot;CancelKey&quot;
<span class="line-modified"> 162  * are both strings, you would use &lt;code&gt;getString&lt;/code&gt; to retrieve them:</span>
 163  * &lt;blockquote&gt;
 164  * &lt;pre&gt;
 165  * button1 = new Button(myResources.getString(&quot;OkKey&quot;));
 166  * button2 = new Button(myResources.getString(&quot;CancelKey&quot;));
 167  * &lt;/pre&gt;
 168  * &lt;/blockquote&gt;
 169  * The getter methods all require the key as an argument and return
 170  * the object if found. If the object is not found, the getter method
<span class="line-modified"> 171  * throws a &lt;code&gt;MissingResourceException&lt;/code&gt;.</span>
 172  *
 173  * &lt;P&gt;
<span class="line-modified"> 174  * Besides &lt;code&gt;getString&lt;/code&gt;, &lt;code&gt;ResourceBundle&lt;/code&gt; also provides</span>
<span class="line-modified"> 175  * a method for getting string arrays, &lt;code&gt;getStringArray&lt;/code&gt;,</span>
<span class="line-modified"> 176  * as well as a generic &lt;code&gt;getObject&lt;/code&gt; method for any other</span>
<span class="line-modified"> 177  * type of object. When using &lt;code&gt;getObject&lt;/code&gt;, you&#39;ll</span>
 178  * have to cast the result to the appropriate type. For example:
 179  * &lt;blockquote&gt;
 180  * &lt;pre&gt;
 181  * int[] myIntegers = (int[]) myResources.getObject(&quot;intList&quot;);
 182  * &lt;/pre&gt;
 183  * &lt;/blockquote&gt;
 184  *
 185  * &lt;P&gt;
<span class="line-modified"> 186  * The Java Platform provides two subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt;,</span>
<span class="line-modified"> 187  * &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt;,</span>
 188  * that provide a fairly simple way to create resources.
<span class="line-modified"> 189  * As you saw briefly in a previous example, &lt;code&gt;ListResourceBundle&lt;/code&gt;</span>
 190  * manages its resource as a list of key/value pairs.
<span class="line-modified"> 191  * &lt;code&gt;PropertyResourceBundle&lt;/code&gt; uses a properties file to manage</span>
 192  * its resources.
 193  *
 194  * &lt;p&gt;
<span class="line-modified"> 195  * If &lt;code&gt;ListResourceBundle&lt;/code&gt; or &lt;code&gt;PropertyResourceBundle&lt;/code&gt;</span>
<span class="line-modified"> 196  * do not suit your needs, you can write your own &lt;code&gt;ResourceBundle&lt;/code&gt;</span>
<span class="line-modified"> 197  * subclass.  Your subclasses must override two methods: &lt;code&gt;handleGetObject&lt;/code&gt;</span>
<span class="line-modified"> 198  * and &lt;code&gt;getKeys()&lt;/code&gt;.</span>
 199  *
 200  * &lt;p&gt;
 201  * The implementation of a {@code ResourceBundle} subclass must be thread-safe
 202  * if it&#39;s simultaneously used by multiple threads. The default implementations
 203  * of the non-abstract methods in this class, and the methods in the direct
 204  * known concrete subclasses {@code ListResourceBundle} and
 205  * {@code PropertyResourceBundle} are thread-safe.
 206  *
<span class="line-modified"> 207  * &lt;h3&gt;&lt;a id=&quot;resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;&lt;/h3&gt;</span>
 208  *
 209  * Resource bundles can be deployed in modules in the following ways:
 210  *
<span class="line-modified"> 211  * &lt;h4&gt;Resource bundles together with an application&lt;/h4&gt;</span>
 212  *
 213  * Resource bundles can be deployed together with an application in the same
 214  * module.  In that case, the resource bundles are loaded
 215  * by code in the module by calling the {@link #getBundle(String)}
 216  * or {@link #getBundle(String, Locale)} method.
 217  *
<span class="line-modified"> 218  * &lt;h4&gt;&lt;a id=&quot;service-providers&quot;&gt;Resource bundles as service providers&lt;/a&gt;&lt;/h4&gt;</span>
 219  *
 220  * Resource bundles can be deployed in one or more &lt;em&gt;service provider modules&lt;/em&gt;
 221  * and they can be located using {@link ServiceLoader}.
 222  * A {@linkplain ResourceBundleProvider service} interface or class must be
 223  * defined. The caller module declares that it uses the service, the service
 224  * provider modules declare that they provide implementations of the service.
 225  * Refer to {@link ResourceBundleProvider} for developing resource bundle
 226  * services and deploying resource bundle providers.
 227  * The module obtaining the resource bundle can be a resource bundle
 228  * provider itself; in which case this module only locates the resource bundle
 229  * via service provider mechanism.
 230  *
 231  * &lt;p&gt;A {@linkplain ResourceBundleProvider resource bundle provider} can
 232  * provide resource bundles in any format such XML which replaces the need
 233  * of {@link Control ResourceBundle.Control}.
 234  *
<span class="line-modified"> 235  * &lt;h4&gt;&lt;a id=&quot;other-modules&quot;&gt;Resource bundles in other modules and class path&lt;/a&gt;&lt;/h4&gt;</span>
 236  *
 237  * Resource bundles in a named module may be &lt;em&gt;encapsulated&lt;/em&gt; so that
 238  * it cannot be located by code in other modules.  Resource bundles
 239  * in unnamed modules and class path are open for any module to access.
 240  * Resource bundle follows the resource encapsulation rules as specified
 241  * in {@link Module#getResourceAsStream(String)}.
 242  *
 243  * &lt;p&gt;The {@code getBundle} factory methods with no {@code Control} parameter
 244  * locate and load resource bundles from
 245  * {@linkplain ResourceBundleProvider service providers}.
 246  * It may continue the search as if calling {@link Module#getResourceAsStream(String)}
 247  * to find the named resource from a given module and calling
 248  * {@link ClassLoader#getResourceAsStream(String)}; refer to
 249  * the specification of the {@code getBundle} method for details.
 250  * Only non-encapsulated resource bundles of &quot;{@code java.class}&quot;
 251  * or &quot;{@code java.properties}&quot; format are searched.
 252  *
 253  * &lt;p&gt;If the caller module is a
 254  * &lt;a href=&quot;{@docRoot}/java.base/java/util/spi/ResourceBundleProvider.html#obtain-resource-bundle&quot;&gt;
 255  * resource bundle provider&lt;/a&gt;, it does not fall back to the
 256  * class loader search.
 257  *
<span class="line-modified"> 258  * &lt;h4&gt;Resource bundles in automatic modules&lt;/h4&gt;</span>
 259  *
 260  * A common format of resource bundles is in {@linkplain PropertyResourceBundle
 261  * .properties} file format.  Typically {@code .properties} resource bundles
 262  * are packaged in a JAR file.  Resource bundle only JAR file can be readily
 263  * deployed as an &lt;a href=&quot;{@docRoot}/java.base/java/lang/module/ModuleFinder.html#automatic-modules&quot;&gt;
 264  * automatic module&lt;/a&gt;.  For example, if the JAR file contains the
 265  * entry &quot;{@code p/q/Foo_ja.properties}&quot; and no {@code .class} entry,
 266  * when resolved and defined as an automatic module, no package is derived
 267  * for this module.  This allows resource bundles in {@code .properties}
 268  * format packaged in one or more JAR files that may contain entries
 269  * in the same directory and can be resolved successfully as
 270  * automatic modules.
 271  *
 272  * &lt;h3&gt;ResourceBundle.Control&lt;/h3&gt;
 273  *
 274  * The {@link ResourceBundle.Control} class provides information necessary
<span class="line-modified"> 275  * to perform the bundle loading process by the &lt;code&gt;getBundle&lt;/code&gt;</span>
<span class="line-modified"> 276  * factory methods that take a &lt;code&gt;ResourceBundle.Control&lt;/code&gt;</span>
 277  * instance. You can implement your own subclass in order to enable
 278  * non-standard resource bundle formats, change the search strategy, or
 279  * define caching parameters. Refer to the descriptions of the class and the
 280  * {@link #getBundle(String, Locale, ClassLoader, Control) getBundle}
 281  * factory method for details.
 282  *
 283  * &lt;p&gt; {@link ResourceBundle.Control} is designed for an application deployed
 284  * in an unnamed module, for example to support resource bundles in
 285  * non-standard formats or package localized resources in a non-traditional
 286  * convention. {@link ResourceBundleProvider} is the replacement for
 287  * {@code ResourceBundle.Control} when migrating to modules.
 288  * {@code UnsupportedOperationException} will be thrown when a factory
 289  * method that takes the {@code ResourceBundle.Control} parameter is called.
 290  *
 291  * &lt;p&gt;&lt;a id=&quot;modify_default_behavior&quot;&gt;For the {@code getBundle} factory&lt;/a&gt;
 292  * methods that take no {@link Control} instance, their &lt;a
 293  * href=&quot;#default_behavior&quot;&gt; default behavior&lt;/a&gt; of resource bundle loading
 294  * can be modified with custom {@link
 295  * ResourceBundleControlProvider} implementations.
 296  * If any of the
 297  * providers provides a {@link Control} for the given base name, that {@link
 298  * Control} will be used instead of the default {@link Control}. If there is
 299  * more than one service provider for supporting the same base name,
 300  * the first one returned from {@link ServiceLoader} will be used.
 301  * A custom {@link Control} implementation is ignored by named modules.
 302  *
<span class="line-modified"> 303  * &lt;h3&gt;Cache Management&lt;/h3&gt;</span>
 304  *
<span class="line-modified"> 305  * Resource bundle instances created by the &lt;code&gt;getBundle&lt;/code&gt; factory</span>
 306  * methods are cached by default, and the factory methods return the same
 307  * resource bundle instance multiple times if it has been
<span class="line-modified"> 308  * cached. &lt;code&gt;getBundle&lt;/code&gt; clients may clear the cache, manage the</span>
 309  * lifetime of cached resource bundle instances using time-to-live values,
 310  * or specify not to cache resource bundle instances. Refer to the
 311  * descriptions of the {@linkplain #getBundle(String, Locale, ClassLoader,
<span class="line-modified"> 312  * Control) &lt;code&gt;getBundle&lt;/code&gt; factory method}, {@link</span>
 313  * #clearCache(ClassLoader) clearCache}, {@link
 314  * Control#getTimeToLive(String, Locale)
 315  * ResourceBundle.Control.getTimeToLive}, and {@link
 316  * Control#needsReload(String, Locale, String, ClassLoader, ResourceBundle,
 317  * long) ResourceBundle.Control.needsReload} for details.
 318  *
<span class="line-modified"> 319  * &lt;h3&gt;Example&lt;/h3&gt;</span>
 320  *
<span class="line-modified"> 321  * The following is a very simple example of a &lt;code&gt;ResourceBundle&lt;/code&gt;</span>
<span class="line-modified"> 322  * subclass, &lt;code&gt;MyResources&lt;/code&gt;, that manages two resources (for a larger number of</span>
<span class="line-modified"> 323  * resources you would probably use a &lt;code&gt;Map&lt;/code&gt;).</span>
 324  * Notice that you don&#39;t need to supply a value if
<span class="line-modified"> 325  * a &quot;parent-level&quot; &lt;code&gt;ResourceBundle&lt;/code&gt; handles the same</span>
 326  * key with the same value (as for the okKey below).
 327  * &lt;blockquote&gt;
 328  * &lt;pre&gt;
 329  * // default (English language, United States)
 330  * public class MyResources extends ResourceBundle {
 331  *     public Object handleGetObject(String key) {
 332  *         if (key.equals(&quot;okKey&quot;)) return &quot;Ok&quot;;
 333  *         if (key.equals(&quot;cancelKey&quot;)) return &quot;Cancel&quot;;
 334  *         return null;
 335  *     }
 336  *
 337  *     public Enumeration&amp;lt;String&amp;gt; getKeys() {
 338  *         return Collections.enumeration(keySet());
 339  *     }
 340  *
 341  *     // Overrides handleKeySet() so that the getKeys() implementation
 342  *     // can rely on the keySet() value.
 343  *     protected Set&amp;lt;String&amp;gt; handleKeySet() {
 344  *         return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;okKey&quot;, &quot;cancelKey&quot;));
 345  *     }
 346  * }
 347  *
 348  * // German language
 349  * public class MyResources_de extends MyResources {
 350  *     public Object handleGetObject(String key) {
 351  *         // don&#39;t need okKey, since parent level handles it.
 352  *         if (key.equals(&quot;cancelKey&quot;)) return &quot;Abbrechen&quot;;
 353  *         return null;
 354  *     }
 355  *
 356  *     protected Set&amp;lt;String&amp;gt; handleKeySet() {
 357  *         return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;cancelKey&quot;));
 358  *     }
 359  * }
 360  * &lt;/pre&gt;
 361  * &lt;/blockquote&gt;
 362  * You do not have to restrict yourself to using a single family of
<span class="line-modified"> 363  * &lt;code&gt;ResourceBundle&lt;/code&gt;s. For example, you could have a set of bundles for</span>
<span class="line-modified"> 364  * exception messages, &lt;code&gt;ExceptionResources&lt;/code&gt;</span>
<span class="line-modified"> 365  * (&lt;code&gt;ExceptionResources_fr&lt;/code&gt;, &lt;code&gt;ExceptionResources_de&lt;/code&gt;, ...),</span>
<span class="line-modified"> 366  * and one for widgets, &lt;code&gt;WidgetResource&lt;/code&gt; (&lt;code&gt;WidgetResources_fr&lt;/code&gt;,</span>
<span class="line-modified"> 367  * &lt;code&gt;WidgetResources_de&lt;/code&gt;, ...); breaking up the resources however you like.</span>
 368  *
 369  * @see ListResourceBundle
 370  * @see PropertyResourceBundle
 371  * @see MissingResourceException
 372  * @see ResourceBundleProvider
 373  * @since 1.1
 374  * @revised 9
 375  * @spec JPMS
 376  */
 377 public abstract class ResourceBundle {
 378 
 379     /** initial size of the bundle cache */
 380     private static final int INITIAL_CACHE_SIZE = 32;
 381 
 382     static {
 383         SharedSecrets.setJavaUtilResourceBundleAccess(
 384             new JavaUtilResourceBundleAccess() {
 385                 @Override
 386                 public void setParent(ResourceBundle bundle,
 387                                       ResourceBundle parent) {
</pre>
<hr />
<pre>
 495     /**
 496      * A Set of the keys contained only in this ResourceBundle.
 497      */
 498     private volatile Set&lt;String&gt; keySet;
 499 
 500     /**
 501      * Sole constructor.  (For invocation by subclass constructors, typically
 502      * implicit.)
 503      */
 504     public ResourceBundle() {
 505     }
 506 
 507     /**
 508      * Gets a string for the given key from this resource bundle or one of its parents.
 509      * Calling this method is equivalent to calling
 510      * &lt;blockquote&gt;
 511      * &lt;code&gt;(String) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
 512      * &lt;/blockquote&gt;
 513      *
 514      * @param key the key for the desired string
<span class="line-modified"> 515      * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 516      * @exception MissingResourceException if no object for the given key can be found</span>
<span class="line-modified"> 517      * @exception ClassCastException if the object found for the given key is not a string</span>
 518      * @return the string for the given key
 519      */
 520     public final String getString(String key) {
 521         return (String) getObject(key);
 522     }
 523 
 524     /**
 525      * Gets a string array for the given key from this resource bundle or one of its parents.
 526      * Calling this method is equivalent to calling
 527      * &lt;blockquote&gt;
 528      * &lt;code&gt;(String[]) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
 529      * &lt;/blockquote&gt;
 530      *
 531      * @param key the key for the desired string array
<span class="line-modified"> 532      * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 533      * @exception MissingResourceException if no object for the given key can be found</span>
<span class="line-modified"> 534      * @exception ClassCastException if the object found for the given key is not a string array</span>
 535      * @return the string array for the given key
 536      */
 537     public final String[] getStringArray(String key) {
 538         return (String[]) getObject(key);
 539     }
 540 
 541     /**
 542      * Gets an object for the given key from this resource bundle or one of its parents.
 543      * This method first tries to obtain the object from this resource bundle using
 544      * {@link #handleGetObject(java.lang.String) handleGetObject}.
 545      * If not successful, and the parent resource bundle is not null,
<span class="line-modified"> 546      * it calls the parent&#39;s &lt;code&gt;getObject&lt;/code&gt; method.</span>
 547      * If still not successful, it throws a MissingResourceException.
 548      *
 549      * @param key the key for the desired object
<span class="line-modified"> 550      * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 551      * @exception MissingResourceException if no object for the given key can be found</span>
 552      * @return the object for the given key
 553      */
 554     public final Object getObject(String key) {
 555         Object obj = handleGetObject(key);
 556         if (obj == null) {
 557             if (parent != null) {
 558                 obj = parent.getObject(key);
 559             }
 560             if (obj == null) {
 561                 throw new MissingResourceException(&quot;Can&#39;t find resource for bundle &quot;
 562                                                    +this.getClass().getName()
 563                                                    +&quot;, key &quot;+key,
 564                                                    this.getClass().getName(),
 565                                                    key);
 566             }
 567         }
 568         return obj;
 569     }
 570 
 571     /**
</pre>
<hr />
<pre>
 820      */
 821     private static class BundleReference extends SoftReference&lt;ResourceBundle&gt;
 822                                          implements CacheKeyReference {
 823         private final CacheKey cacheKey;
 824 
 825         BundleReference(ResourceBundle referent, ReferenceQueue&lt;Object&gt; q, CacheKey key) {
 826             super(referent, q);
 827             cacheKey = key;
 828         }
 829 
 830         @Override
 831         public CacheKey getCacheKey() {
 832             return cacheKey;
 833         }
 834     }
 835 
 836     /**
 837      * Gets a resource bundle using the specified base name, the default locale,
 838      * and the caller module. Calling this method is equivalent to calling
 839      * &lt;blockquote&gt;
<span class="line-modified"> 840      * &lt;code&gt;getBundle(baseName, Locale.getDefault(), callerModule)&lt;/code&gt;,</span>
 841      * &lt;/blockquote&gt;
 842      *
 843      * @param baseName the base name of the resource bundle, a fully qualified class name
<span class="line-modified"> 844      * @exception java.lang.NullPointerException</span>
<span class="line-modified"> 845      *     if &lt;code&gt;baseName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 846      * @exception MissingResourceException</span>
 847      *     if no resource bundle for the specified base name can be found
 848      * @return a resource bundle for the given base name and the default locale
 849      *
 850      * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
 851      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
 852      */
 853     @CallerSensitive
 854     public static final ResourceBundle getBundle(String baseName)
 855     {
 856         Class&lt;?&gt; caller = Reflection.getCallerClass();
 857         return getBundleImpl(baseName, Locale.getDefault(),
 858                              caller, getDefaultControl(caller, baseName));
 859     }
 860 
 861     /**
 862      * Returns a resource bundle using the specified base name, the
 863      * default locale and the specified control. Calling this method
 864      * is equivalent to calling
 865      * &lt;pre&gt;
 866      * getBundle(baseName, Locale.getDefault(),
 867      *           this.getClass().getClassLoader(), control),
 868      * &lt;/pre&gt;
<span class="line-modified"> 869      * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security</span>
<span class="line-modified"> 870      * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link</span>
 871      * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
 872      * complete description of the resource bundle loading process with a
<span class="line-modified"> 873      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.</span>
 874      *
 875      * @param baseName
 876      *        the base name of the resource bundle, a fully qualified class
 877      *        name
 878      * @param control
 879      *        the control which gives information for the resource bundle
 880      *        loading process
 881      * @return a resource bundle for the given base name and the default locale
 882      * @throws NullPointerException
<span class="line-modified"> 883      *         if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;control&lt;/code&gt; is</span>
<span class="line-modified"> 884      *         &lt;code&gt;null&lt;/code&gt;</span>
 885      * @throws MissingResourceException
 886      *         if no resource bundle for the specified base name can be found
 887      * @throws IllegalArgumentException
<span class="line-modified"> 888      *         if the given &lt;code&gt;control&lt;/code&gt; doesn&#39;t perform properly</span>
<span class="line-modified"> 889      *         (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)</span>
<span class="line-modified"> 890      *         Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as</span>
 891      *         needed.
 892      * @throws UnsupportedOperationException
 893      *         if this method is called in a named module
 894      * @since 1.6
 895      * @revised 9
 896      * @spec JPMS
 897      */
 898     @CallerSensitive
 899     public static final ResourceBundle getBundle(String baseName,
 900                                                  Control control) {
 901         Class&lt;?&gt; caller = Reflection.getCallerClass();
 902         Locale targetLocale = Locale.getDefault();
 903         checkNamedModule(caller);
 904         return getBundleImpl(baseName, targetLocale, caller, control);
 905     }
 906 
 907     /**
 908      * Gets a resource bundle using the specified base name and locale,
 909      * and the caller module. Calling this method is equivalent to calling
 910      * &lt;blockquote&gt;
<span class="line-modified"> 911      * &lt;code&gt;getBundle(baseName, locale, callerModule)&lt;/code&gt;,</span>
 912      * &lt;/blockquote&gt;
 913      *
 914      * @param baseName
 915      *        the base name of the resource bundle, a fully qualified class name
 916      * @param locale
 917      *        the locale for which a resource bundle is desired
<span class="line-modified"> 918      * @exception NullPointerException</span>
<span class="line-modified"> 919      *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified"> 920      * @exception MissingResourceException</span>
 921      *        if no resource bundle for the specified base name can be found
 922      * @return a resource bundle for the given base name and locale
 923      *
 924      * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
 925      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
 926      */
 927     @CallerSensitive
 928     public static final ResourceBundle getBundle(String baseName,
 929                                                  Locale locale)
 930     {
 931         Class&lt;?&gt; caller = Reflection.getCallerClass();
 932         return getBundleImpl(baseName, locale,
 933                              caller, getDefaultControl(caller, baseName));
 934     }
 935 
 936     /**
 937      * Gets a resource bundle using the specified base name and the default locale
 938      * on behalf of the specified module. This method is equivalent to calling
 939      * &lt;blockquote&gt;
<span class="line-modified"> 940      * &lt;code&gt;getBundle(baseName, Locale.getDefault(), module)&lt;/code&gt;</span>
 941      * &lt;/blockquote&gt;
 942      *
 943      * @param baseName the base name of the resource bundle,
 944      *                 a fully qualified class name
 945      * @param module   the module for which the resource bundle is searched
 946      * @throws NullPointerException
 947      *         if {@code baseName} or {@code module} is {@code null}
 948      * @throws SecurityException
 949      *         if a security manager exists and the caller is not the specified
 950      *         module and doesn&#39;t have {@code RuntimePermission(&quot;getClassLoader&quot;)}
 951      * @throws MissingResourceException
 952      *         if no resource bundle for the specified base name can be found in the
 953      *         specified module
 954      * @return a resource bundle for the given base name and the default locale
 955      * @since 9
 956      * @spec JPMS
 957      * @see ResourceBundleProvider
 958      * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
 959      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
 960      */
</pre>
<hr />
<pre>
1008      * @return a resource bundle for the given base name and locale in the module
1009      * @since 9
1010      * @spec JPMS
1011      * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
1012      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
1013      */
1014     @CallerSensitive
1015     public static ResourceBundle getBundle(String baseName, Locale targetLocale, Module module) {
1016         return getBundleFromModule(Reflection.getCallerClass(), module, baseName, targetLocale,
1017                                    getDefaultControl(module, baseName));
1018     }
1019 
1020     /**
1021      * Returns a resource bundle using the specified base name, target
1022      * locale and control, and the caller&#39;s class loader. Calling this
1023      * method is equivalent to calling
1024      * &lt;pre&gt;
1025      * getBundle(baseName, targetLocale, this.getClass().getClassLoader(),
1026      *           control),
1027      * &lt;/pre&gt;
<span class="line-modified">1028      * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security</span>
<span class="line-modified">1029      * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link</span>
1030      * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
1031      * complete description of the resource bundle loading process with a
<span class="line-modified">1032      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.</span>
1033      *
1034      * @param baseName
1035      *        the base name of the resource bundle, a fully qualified
1036      *        class name
1037      * @param targetLocale
1038      *        the locale for which a resource bundle is desired
1039      * @param control
1040      *        the control which gives information for the resource
1041      *        bundle loading process
1042      * @return a resource bundle for the given base name and a
<span class="line-modified">1043      *         &lt;code&gt;Locale&lt;/code&gt; in &lt;code&gt;locales&lt;/code&gt;</span>
1044      * @throws NullPointerException
<span class="line-modified">1045      *         if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locales&lt;/code&gt; or</span>
<span class="line-modified">1046      *         &lt;code&gt;control&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
1047      * @throws MissingResourceException
1048      *         if no resource bundle for the specified base name in any
<span class="line-modified">1049      *         of the &lt;code&gt;locales&lt;/code&gt; can be found.</span>
1050      * @throws IllegalArgumentException
<span class="line-modified">1051      *         if the given &lt;code&gt;control&lt;/code&gt; doesn&#39;t perform properly</span>
<span class="line-modified">1052      *         (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)</span>
<span class="line-modified">1053      *         Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as</span>
1054      *         needed.
1055      * @throws UnsupportedOperationException
1056      *         if this method is called in a named module
1057      * @since 1.6
1058      * @revised 9
1059      * @spec JPMS
1060      */
1061     @CallerSensitive
1062     public static final ResourceBundle getBundle(String baseName, Locale targetLocale,
1063                                                  Control control) {
1064         Class&lt;?&gt; caller = Reflection.getCallerClass();
1065         checkNamedModule(caller);
1066         return getBundleImpl(baseName, targetLocale, caller, control);
1067     }
1068 
1069     /**
1070      * Gets a resource bundle using the specified base name, locale, and class
1071      * loader.
1072      *
1073      * &lt;p&gt;When this method is called from a named module and the given
1074      * loader is the class loader of the caller module, this is equivalent
1075      * to calling:
1076      * &lt;blockquote&gt;&lt;pre&gt;
1077      * getBundle(baseName, targetLocale, callerModule)
1078      * &lt;/pre&gt;&lt;/blockquote&gt;
1079      *
1080      * otherwise, this is equivalent to calling:
1081      * &lt;blockquote&gt;&lt;pre&gt;
1082      * getBundle(baseName, targetLocale, loader, control)
1083      * &lt;/pre&gt;&lt;/blockquote&gt;
1084      * where {@code control} is the default instance of {@link Control} unless
1085      * a {@code Control} instance is provided by
1086      * {@link ResourceBundleControlProvider} SPI.  Refer to the
1087      * description of &lt;a href=&quot;#modify_default_behavior&quot;&gt;modifying the default
1088      * behavior&lt;/a&gt;. The following describes the default behavior.
1089      *
1090      * &lt;p&gt;
1091      * &lt;b&gt;&lt;a id=&quot;default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;&lt;/b&gt;
1092      *
<span class="line-modified">1093      * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; uses the base name, the specified locale, and</span>
1094      * the default locale (obtained from {@link java.util.Locale#getDefault()
1095      * Locale.getDefault}) to generate a sequence of &lt;a
1096      * id=&quot;candidates&quot;&gt;&lt;em&gt;candidate bundle names&lt;/em&gt;&lt;/a&gt;.  If the specified
1097      * locale&#39;s language, script, country, and variant are all empty strings,
1098      * then the base name is the only candidate bundle name.  Otherwise, a list
1099      * of candidate locales is generated from the attribute values of the
1100      * specified locale (language, script, country and variant) and appended to
1101      * the base name.  Typically, this will look like the following:
1102      *
1103      * &lt;pre&gt;
1104      *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
1105      *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country
1106      *     baseName + &quot;_&quot; + language + &quot;_&quot; + script
1107      *     baseName + &quot;_&quot; + language + &quot;_&quot; + country + &quot;_&quot; + variant
1108      *     baseName + &quot;_&quot; + language + &quot;_&quot; + country
1109      *     baseName + &quot;_&quot; + language
1110      * &lt;/pre&gt;
1111      *
1112      * &lt;p&gt;Candidate bundle names where the final component is an empty string
1113      * are omitted, along with the underscore.  For example, if country is an
</pre>
<hr />
<pre>
1123      * &lt;/pre&gt;
1124      *
1125      * In the case that the variant contains one or more underscores (&#39;_&#39;), a
1126      * sequence of bundle names generated by truncating the last underscore and
1127      * the part following it is inserted after a candidate bundle name with the
1128      * original variant.  For example, for a locale with language &quot;en&quot;, script
1129      * &quot;Latn, country &quot;US&quot; and variant &quot;WINDOWS_VISTA&quot;, and bundle base name
1130      * &quot;MyResource&quot;, the list of candidate bundle names below is generated:
1131      *
1132      * &lt;pre&gt;
1133      * MyResource_en_Latn_US_WINDOWS_VISTA
1134      * MyResource_en_Latn_US_WINDOWS
1135      * MyResource_en_Latn_US
1136      * MyResource_en_Latn
1137      * MyResource_en_US_WINDOWS_VISTA
1138      * MyResource_en_US_WINDOWS
1139      * MyResource_en_US
1140      * MyResource_en
1141      * &lt;/pre&gt;
1142      *
<span class="line-modified">1143      * &lt;blockquote&gt;&lt;b&gt;Note:&lt;/b&gt; For some &lt;code&gt;Locale&lt;/code&gt;s, the list of</span>
1144      * candidate bundle names contains extra names, or the order of bundle names
1145      * is slightly modified.  See the description of the default implementation
1146      * of {@link Control#getCandidateLocales(String, Locale)
1147      * getCandidateLocales} for details.&lt;/blockquote&gt;
1148      *
<span class="line-modified">1149      * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; then iterates over the candidate bundle names</span>
1150      * to find the first one for which it can &lt;em&gt;instantiate&lt;/em&gt; an actual
1151      * resource bundle. It uses the default controls&#39; {@link Control#getFormats
1152      * getFormats} method, which generates two bundle names for each generated
1153      * name, the first a class name and the second a properties file name. For
1154      * each candidate bundle name, it attempts to create a resource bundle:
1155      *
1156      * &lt;ul&gt;&lt;li&gt;First, it attempts to load a class using the generated class name.
1157      * If such a class can be found and loaded using the specified class
1158      * loader, is assignment compatible with ResourceBundle, is accessible from
<span class="line-modified">1159      * ResourceBundle, and can be instantiated, &lt;code&gt;getBundle&lt;/code&gt; creates a</span>
1160      * new instance of this class and uses it as the &lt;em&gt;result resource
1161      * bundle&lt;/em&gt;.
1162      *
<span class="line-modified">1163      * &lt;li&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; attempts to locate a property</span>
1164      * resource file using the generated properties file name.  It generates a
1165      * path name from the candidate bundle name by replacing all &quot;.&quot; characters
1166      * with &quot;/&quot; and appending the string &quot;.properties&quot;.  It attempts to find a
1167      * &quot;resource&quot; with this name using {@link
1168      * java.lang.ClassLoader#getResource(java.lang.String)
1169      * ClassLoader.getResource}.  (Note that a &quot;resource&quot; in the sense of
<span class="line-modified">1170      * &lt;code&gt;getResource&lt;/code&gt; has nothing to do with the contents of a</span>
1171      * resource bundle, it is just a container of data, such as a file.)  If it
1172      * finds a &quot;resource&quot;, it attempts to create a new {@link
1173      * PropertyResourceBundle} instance from its contents.  If successful, this
1174      * instance becomes the &lt;em&gt;result resource bundle&lt;/em&gt;.  &lt;/ul&gt;
1175      *
1176      * &lt;p&gt;This continues until a result resource bundle is instantiated or the
1177      * list of candidate bundle names is exhausted.  If no matching resource
1178      * bundle is found, the default control&#39;s {@link Control#getFallbackLocale
1179      * getFallbackLocale} method is called, which returns the current default
1180      * locale.  A new sequence of candidate locale names is generated using this
1181      * locale and searched again, as above.
1182      *
1183      * &lt;p&gt;If still no result bundle is found, the base name alone is looked up. If
<span class="line-modified">1184      * this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.</span>
1185      *
1186      * &lt;p&gt;&lt;a id=&quot;parent_chain&quot;&gt; Once a result resource bundle has been found,
1187      * its &lt;em&gt;parent chain&lt;/em&gt; is instantiated&lt;/a&gt;.  If the result bundle already
1188      * has a parent (perhaps because it was returned from a cache) the chain is
1189      * complete.
1190      *
<span class="line-modified">1191      * &lt;p&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; examines the remainder of the</span>
1192      * candidate locale list that was used during the pass that generated the
1193      * result resource bundle.  (As before, candidate bundle names where the
1194      * final component is an empty string are omitted.)  When it comes to the
1195      * end of the candidate list, it tries the plain bundle name.  With each of the
1196      * candidate bundle names it attempts to instantiate a resource bundle (first
1197      * looking for a class and then a properties file, as described above).
1198      *
1199      * &lt;p&gt;Whenever it succeeds, it calls the previously instantiated resource
1200      * bundle&#39;s {@link #setParent(java.util.ResourceBundle) setParent} method
1201      * with the new resource bundle.  This continues until the list of names
1202      * is exhausted or the current bundle already has a non-null parent.
1203      *
1204      * &lt;p&gt;Once the parent chain is complete, the bundle is returned.
1205      *
<span class="line-modified">1206      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;code&gt;getBundle&lt;/code&gt; caches instantiated resource</span>
1207      * bundles and might return the same resource bundle instance multiple times.
1208      *
<span class="line-modified">1209      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;The &lt;code&gt;baseName&lt;/code&gt; argument should be a fully</span>
1210      * qualified class name. However, for compatibility with earlier versions,
1211      * Java SE Runtime Environments do not verify this, and so it is
<span class="line-modified">1212      * possible to access &lt;code&gt;PropertyResourceBundle&lt;/code&gt;s by specifying a</span>
1213      * path name (using &quot;/&quot;) instead of a fully qualified class name (using
1214      * &quot;.&quot;).
1215      *
1216      * &lt;p&gt;&lt;a id=&quot;default_behavior_example&quot;&gt;
1217      * &lt;strong&gt;Example:&lt;/strong&gt;&lt;/a&gt;
1218      * &lt;p&gt;
1219      * The following class and property files are provided:
1220      * &lt;ul&gt;
1221      *     &lt;li&gt;MyResources.class
1222      *     &lt;li&gt;MyResources.properties
1223      *     &lt;li&gt;MyResources_fr.properties
1224      *     &lt;li&gt;MyResources_fr_CH.class
1225      *     &lt;li&gt;MyResources_fr_CH.properties
1226      *     &lt;li&gt;MyResources_en.properties
1227      *     &lt;li&gt;MyResources_es_ES.class
1228      * &lt;/ul&gt;
1229      *
1230      * The contents of all files are valid (that is, public non-abstract
<span class="line-modified">1231      * subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt; for the &quot;.class&quot; files,</span>
1232      * syntactically correct &quot;.properties&quot; files).  The default locale is
<span class="line-modified">1233      * &lt;code&gt;Locale(&quot;en&quot;, &quot;GB&quot;)&lt;/code&gt;.</span>
1234      *
<span class="line-modified">1235      * &lt;p&gt;Calling &lt;code&gt;getBundle&lt;/code&gt; with the locale arguments below will</span>
1236      * instantiate resource bundles as follows:
1237      *
1238      * &lt;table class=&quot;striped&quot;&gt;
1239      * &lt;caption style=&quot;display:none&quot;&gt;getBundle() locale to resource bundle mapping&lt;/caption&gt;
1240      * &lt;thead&gt;
1241      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Locale&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Resource bundle&lt;/th&gt;&lt;/tr&gt;
1242      * &lt;/thead&gt;
1243      * &lt;tbody&gt;
1244      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;fr&quot;, &quot;CH&quot;)&lt;/th&gt;&lt;td&gt;MyResources_fr_CH.class, parent MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1245      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;fr&quot;, &quot;FR&quot;)&lt;/th&gt;&lt;td&gt;MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1246      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/th&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1247      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;en&quot;, &quot;US&quot;)&lt;/th&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1248      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;es&quot;, &quot;ES&quot;)&lt;/th&gt;&lt;td&gt;MyResources_es_ES.class, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1249      * &lt;/tbody&gt;
1250      * &lt;/table&gt;
1251      *
1252      * &lt;p&gt;The file MyResources_fr_CH.properties is never used because it is
1253      * hidden by the MyResources_fr_CH.class. Likewise, MyResources.properties
1254      * is also hidden by MyResources.class.
1255      *
1256      * @apiNote If the caller module is a named module and the given
1257      * {@code loader} is the caller module&#39;s class loader, this method is
1258      * equivalent to {@code getBundle(baseName, locale)}; otherwise, it may not
1259      * find resource bundles from named modules.
1260      * Use {@link #getBundle(String, Locale, Module)} to load resource bundles
1261      * on behalf on a specific module instead.
1262      *
1263      * @param baseName the base name of the resource bundle, a fully qualified class name
1264      * @param locale the locale for which a resource bundle is desired
1265      * @param loader the class loader from which to load the resource bundle
1266      * @return a resource bundle for the given base name and locale
<span class="line-modified">1267      * @exception java.lang.NullPointerException</span>
<span class="line-modified">1268      *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">1269      * @exception MissingResourceException</span>
1270      *        if no resource bundle for the specified base name can be found
1271      * @since 1.2
1272      * @revised 9
1273      * @spec JPMS
1274      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
1275      */
1276     @CallerSensitive
1277     public static ResourceBundle getBundle(String baseName, Locale locale,
1278                                            ClassLoader loader)
1279     {
1280         if (loader == null) {
1281             throw new NullPointerException();
1282         }
1283         Class&lt;?&gt; caller = Reflection.getCallerClass();
1284         return getBundleImpl(baseName, locale, caller, loader, getDefaultControl(caller, baseName));
1285     }
1286 
1287     /**
1288      * Returns a resource bundle using the specified base name, target
1289      * locale, class loader and control. Unlike the {@link
1290      * #getBundle(String, Locale, ClassLoader) getBundle}
1291      * factory methods with no {@code control} argument, the given
<span class="line-modified">1292      * &lt;code&gt;control&lt;/code&gt; specifies how to locate and instantiate resource</span>
1293      * bundles. Conceptually, the bundle loading process with the given
<span class="line-modified">1294      * &lt;code&gt;control&lt;/code&gt; is performed in the following steps.</span>
1295      *
1296      * &lt;ol&gt;
1297      * &lt;li&gt;This factory method looks up the resource bundle in the cache for
<span class="line-modified">1298      * the specified &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt; and</span>
<span class="line-modified">1299      * &lt;code&gt;loader&lt;/code&gt;.  If the requested resource bundle instance is</span>
1300      * found in the cache and the time-to-live periods of the instance and
1301      * all of its parent instances have not expired, the instance is returned
1302      * to the caller. Otherwise, this factory method proceeds with the
1303      * loading process below.&lt;/li&gt;
1304      *
1305      * &lt;li&gt;The {@link ResourceBundle.Control#getFormats(String)
1306      * control.getFormats} method is called to get resource bundle formats
1307      * to produce bundle or resource names. The strings
<span class="line-modified">1308      * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;</span>
1309      * designate class-based and {@linkplain PropertyResourceBundle
1310      * property}-based resource bundles, respectively. Other strings
<span class="line-modified">1311      * starting with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions</span>
1312      * and must not be used for application-defined formats. Other strings
1313      * designate application-defined formats.&lt;/li&gt;
1314      *
1315      * &lt;li&gt;The {@link ResourceBundle.Control#getCandidateLocales(String,
1316      * Locale) control.getCandidateLocales} method is called with the target
<span class="line-modified">1317      * locale to get a list of &lt;em&gt;candidate &lt;code&gt;Locale&lt;/code&gt;s&lt;/em&gt; for</span>
1318      * which resource bundles are searched.&lt;/li&gt;
1319      *
1320      * &lt;li&gt;The {@link ResourceBundle.Control#newBundle(String, Locale,
1321      * String, ClassLoader, boolean) control.newBundle} method is called to
<span class="line-modified">1322      * instantiate a &lt;code&gt;ResourceBundle&lt;/code&gt; for the base bundle name, a</span>
1323      * candidate locale, and a format. (Refer to the note on the cache
1324      * lookup below.) This step is iterated over all combinations of the
<span class="line-modified">1325      * candidate locales and formats until the &lt;code&gt;newBundle&lt;/code&gt; method</span>
<span class="line-modified">1326      * returns a &lt;code&gt;ResourceBundle&lt;/code&gt; instance or the iteration has</span>
1327      * used up all the combinations. For example, if the candidate locales
<span class="line-modified">1328      * are &lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;, &lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt; and</span>
<span class="line-modified">1329      * &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; and the formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;</span>
<span class="line-modified">1330      * and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, then the following is the</span>
1331      * sequence of locale-format combinations to be used to call
<span class="line-modified">1332      * &lt;code&gt;control.newBundle&lt;/code&gt;.</span>
1333      *
1334      * &lt;table class=striped style=&quot;width: 50%; text-align: left; margin-left: 40px;&quot;&gt;
1335      * &lt;caption style=&quot;display:none&quot;&gt;locale-format combinations for newBundle&lt;/caption&gt;
1336      * &lt;thead&gt;
1337      * &lt;tr&gt;
1338      * &lt;th scope=&quot;col&quot;&gt;Index&lt;/th&gt;
<span class="line-modified">1339      * &lt;th scope=&quot;col&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/th&gt;</span>
<span class="line-modified">1340      * &lt;th scope=&quot;col&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/th&gt;</span>
1341      * &lt;/tr&gt;
1342      * &lt;/thead&gt;
1343      * &lt;tbody&gt;
1344      * &lt;tr&gt;
1345      * &lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
<span class="line-modified">1346      * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">1347      * &lt;td&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;</span>
1348      * &lt;/tr&gt;
1349      * &lt;tr&gt;
1350      * &lt;th scope=&quot;row&quot;&gt;2&lt;/th&gt;
<span class="line-modified">1351      * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">1352      * &lt;td&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;</span>
1353      * &lt;/tr&gt;
1354      * &lt;tr&gt;
1355      * &lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
<span class="line-modified">1356      * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">1357      * &lt;td&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;</span>
1358      * &lt;/tr&gt;
1359      * &lt;tr&gt;
1360      * &lt;th scope=&quot;row&quot;&gt;4&lt;/th&gt;
<span class="line-modified">1361      * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">1362      * &lt;td&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;</span>
1363      * &lt;/tr&gt;
1364      * &lt;tr&gt;
1365      * &lt;th scope=&quot;row&quot;&gt;5&lt;/th&gt;
<span class="line-modified">1366      * &lt;td&gt;&lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">1367      * &lt;td&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;</span>
1368      * &lt;/tr&gt;
1369      * &lt;tr&gt;
1370      * &lt;th scope=&quot;row&quot;&gt;6&lt;/th&gt;
<span class="line-modified">1371      * &lt;td&gt;&lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;&lt;/td&gt;</span>
<span class="line-modified">1372      * &lt;td&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;</span>
1373      * &lt;/tr&gt;
1374      * &lt;/tbody&gt;
1375      * &lt;/table&gt;
1376      * &lt;/li&gt;
1377      *
1378      * &lt;li&gt;If the previous step has found no resource bundle, proceed to
1379      * Step 6. If a bundle has been found that is a base bundle (a bundle
<span class="line-modified">1380      * for &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;), and the candidate locale list only contained</span>
<span class="line-modified">1381      * &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;, return the bundle to the caller. If a bundle</span>
1382      * has been found that is a base bundle, but the candidate locale list
1383      * contained locales other than Locale(&quot;&quot;), put the bundle on hold and
1384      * proceed to Step 6. If a bundle has been found that is not a base
1385      * bundle, proceed to Step 7.&lt;/li&gt;
1386      *
1387      * &lt;li&gt;The {@link ResourceBundle.Control#getFallbackLocale(String,
1388      * Locale) control.getFallbackLocale} method is called to get a fallback
1389      * locale (alternative to the current target locale) to try further
1390      * finding a resource bundle. If the method returns a non-null locale,
1391      * it becomes the next target locale and the loading process starts over
1392      * from Step 3. Otherwise, if a base bundle was found and put on hold in
1393      * a previous Step 5, it is returned to the caller now. Otherwise, a
1394      * MissingResourceException is thrown.&lt;/li&gt;
1395      *
1396      * &lt;li&gt;At this point, we have found a resource bundle that&#39;s not the
1397      * base bundle. If this bundle set its parent during its instantiation,
1398      * it is returned to the caller. Otherwise, its &lt;a
1399      * href=&quot;./ResourceBundle.html#parent_chain&quot;&gt;parent chain&lt;/a&gt; is
1400      * instantiated based on the list of candidate locales from which it was
1401      * found. Finally, the bundle is returned to the caller.&lt;/li&gt;
1402      * &lt;/ol&gt;
1403      *
1404      * &lt;p&gt;During the resource bundle loading process above, this factory
1405      * method looks up the cache before calling the {@link
1406      * Control#newBundle(String, Locale, String, ClassLoader, boolean)
1407      * control.newBundle} method.  If the time-to-live period of the
1408      * resource bundle found in the cache has expired, the factory method
1409      * calls the {@link ResourceBundle.Control#needsReload(String, Locale,
1410      * String, ClassLoader, ResourceBundle, long) control.needsReload}
1411      * method to determine whether the resource bundle needs to be reloaded.
1412      * If reloading is required, the factory method calls
<span class="line-modified">1413      * &lt;code&gt;control.newBundle&lt;/code&gt; to reload the resource bundle.  If</span>
<span class="line-modified">1414      * &lt;code&gt;control.newBundle&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the factory</span>
1415      * method puts a dummy resource bundle in the cache as a mark of
1416      * nonexistent resource bundles in order to avoid lookup overhead for
1417      * subsequent requests. Such dummy resource bundles are under the same
<span class="line-modified">1418      * expiration control as specified by &lt;code&gt;control&lt;/code&gt;.</span>
1419      *
1420      * &lt;p&gt;All resource bundles loaded are cached by default. Refer to
1421      * {@link Control#getTimeToLive(String,Locale)
1422      * control.getTimeToLive} for details.
1423      *
1424      * &lt;p&gt;The following is an example of the bundle loading process with the
<span class="line-modified">1425      * default &lt;code&gt;ResourceBundle.Control&lt;/code&gt; implementation.</span>
1426      *
1427      * &lt;p&gt;Conditions:
1428      * &lt;ul&gt;
<span class="line-modified">1429      * &lt;li&gt;Base bundle name: &lt;code&gt;foo.bar.Messages&lt;/code&gt;</span>
<span class="line-modified">1430      * &lt;li&gt;Requested &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#ITALY}&lt;/li&gt;</span>
<span class="line-modified">1431      * &lt;li&gt;Default &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#FRENCH}&lt;/li&gt;</span>
1432      * &lt;li&gt;Available resource bundles:
<span class="line-modified">1433      * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and</span>
<span class="line-modified">1434      * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;</span>
1435      * &lt;/ul&gt;
1436      *
<span class="line-modified">1437      * &lt;p&gt;First, &lt;code&gt;getBundle&lt;/code&gt; tries loading a resource bundle in</span>
1438      * the following sequence.
1439      *
1440      * &lt;ul&gt;
<span class="line-modified">1441      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it_IT&lt;/code&gt;</span>
<span class="line-modified">1442      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it_IT.properties&lt;/code&gt;</span>
<span class="line-modified">1443      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">1444      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it.properties&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">1445      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">1446      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;</span>
1447      * &lt;/ul&gt;
1448      *
<span class="line-modified">1449      * &lt;p&gt;At this point, &lt;code&gt;getBundle&lt;/code&gt; finds</span>
<span class="line-modified">1450      * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;, which is put on hold</span>
<span class="line-modified">1451      * because it&#39;s the base bundle.  &lt;code&gt;getBundle&lt;/code&gt; calls {@link</span>
1452      * Control#getFallbackLocale(String, Locale)
1453      * control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)} which
<span class="line-modified">1454      * returns &lt;code&gt;Locale.FRENCH&lt;/code&gt;. Next, &lt;code&gt;getBundle&lt;/code&gt;</span>
1455      * tries loading a bundle in the following sequence.
1456      *
1457      * &lt;ul&gt;
<span class="line-modified">1458      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_fr&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">1459      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">1460      * &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;</span>
<span class="line-modified">1461      * &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;</span>
1462      * &lt;/ul&gt;
1463      *
<span class="line-modified">1464      * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; finds</span>
<span class="line-modified">1465      * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and creates a</span>
<span class="line-modified">1466      * &lt;code&gt;ResourceBundle&lt;/code&gt; instance. Then, &lt;code&gt;getBundle&lt;/code&gt;</span>
1467      * sets up its parent chain from the list of the candidate locales.  Only
<span class="line-modified">1468      * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt; is found in the list and</span>
<span class="line-modified">1469      * &lt;code&gt;getBundle&lt;/code&gt; creates a &lt;code&gt;ResourceBundle&lt;/code&gt; instance</span>
1470      * that becomes the parent of the instance for
<span class="line-modified">1471      * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;.</span>
1472      *
1473      * @param baseName
1474      *        the base name of the resource bundle, a fully qualified
1475      *        class name
1476      * @param targetLocale
1477      *        the locale for which a resource bundle is desired
1478      * @param loader
1479      *        the class loader from which to load the resource bundle
1480      * @param control
1481      *        the control which gives information for the resource
1482      *        bundle loading process
1483      * @return a resource bundle for the given base name and locale
1484      * @throws NullPointerException
<span class="line-modified">1485      *         if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt;,</span>
<span class="line-modified">1486      *         &lt;code&gt;loader&lt;/code&gt;, or &lt;code&gt;control&lt;/code&gt; is</span>
<span class="line-modified">1487      *         &lt;code&gt;null&lt;/code&gt;</span>
1488      * @throws MissingResourceException
1489      *         if no resource bundle for the specified base name can be found
1490      * @throws IllegalArgumentException
<span class="line-modified">1491      *         if the given &lt;code&gt;control&lt;/code&gt; doesn&#39;t perform properly</span>
<span class="line-modified">1492      *         (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)</span>
<span class="line-modified">1493      *         Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as</span>
1494      *         needed.
1495      * @throws UnsupportedOperationException
1496      *         if this method is called in a named module
1497      * @since 1.6
1498      * @revised 9
1499      * @spec JPMS
1500      */
1501     @CallerSensitive
1502     public static ResourceBundle getBundle(String baseName, Locale targetLocale,
1503                                            ClassLoader loader, Control control) {
1504         if (loader == null || control == null) {
1505             throw new NullPointerException();
1506         }
1507         Class&lt;?&gt; caller = Reflection.getCallerClass();
1508         checkNamedModule(caller);
1509         return getBundleImpl(baseName, targetLocale, caller, loader, control);
1510     }
1511 
1512     private static Control getDefaultControl(Class&lt;?&gt; caller, String baseName) {
1513         return getDefaultControl(caller.getModule(), baseName);
</pre>
<hr />
<pre>
1683                 }
1684             }
1685         }
1686 
1687         if (bundle == null) {
1688             if (baseBundle == null) {
1689                 throwMissingResourceException(baseName, locale, cacheKey.getCause());
1690             }
1691             bundle = baseBundle;
1692         }
1693 
1694         // keep callerModule and module reachable for as long as we are operating
1695         // with WeakReference(s) to them (in CacheKey)...
1696         Reference.reachabilityFence(callerModule);
1697         Reference.reachabilityFence(module);
1698 
1699         return bundle;
1700     }
1701 
1702     /**
<span class="line-modified">1703      * Checks if the given &lt;code&gt;List&lt;/code&gt; is not null, not empty,</span>
1704      * not having null in its elements.
1705      */
1706     private static boolean checkList(List&lt;?&gt; a) {
1707         boolean valid = (a != null &amp;&amp; !a.isEmpty());
1708         if (valid) {
1709             int size = a.size();
1710             for (int i = 0; valid &amp;&amp; i &lt; size; i++) {
1711                 valid = (a.get(i) != null);
1712             }
1713         }
1714         return valid;
1715     }
1716 
1717     private static ResourceBundle findBundle(Module callerModule,
1718                                              Module module,
1719                                              CacheKey cacheKey,
1720                                              List&lt;Locale&gt; candidateLocales,
1721                                              List&lt;String&gt; formats,
1722                                              int index,
1723                                              Control control,
</pre>
<hr />
<pre>
2049                                                       Throwable cause) {
2050         // If the cause is a MissingResourceException, avoid creating
2051         // a long chain. (6355009)
2052         if (cause instanceof MissingResourceException) {
2053             cause = null;
2054         }
2055         throw new MissingResourceException(&quot;Can&#39;t find bundle for base name &quot;
2056                                            + baseName + &quot;, locale &quot; + locale,
2057                                            baseName + &quot;_&quot; + locale, // className
2058                                            &quot;&quot;,                      // key
2059                                            cause);
2060     }
2061 
2062     /**
2063      * Finds a bundle in the cache. Any expired bundles are marked as
2064      * `expired&#39; and removed from the cache upon return.
2065      *
2066      * @param cacheKey the key to look up the cache
2067      * @param control the Control to be used for the expiration control
2068      * @return the cached bundle, or null if the bundle is not found in the
<span class="line-modified">2069      * cache or its parent has expired. &lt;code&gt;bundle.expire&lt;/code&gt; is true</span>
2070      * upon return if the bundle in the cache has expired.
2071      */
2072     private static ResourceBundle findBundleInCache(CacheKey cacheKey,
2073                                                     Control control) {
2074         BundleReference bundleRef = cacheList.get(cacheKey);
2075         if (bundleRef == null) {
2076             return null;
2077         }
2078         ResourceBundle bundle = bundleRef.get();
2079         if (bundle == null) {
2080             return null;
2081         }
2082         ResourceBundle p = bundle.parent;
2083         assert p != NONEXISTENT_BUNDLE;
2084         // If the parent has expired, then this one must also expire. We
2085         // check only the immediate parent because the actual loading is
2086         // done from the root (base) to leaf (child) and the purpose of
2087         // checking is to propagate expiration towards the leaf. For
2088         // example, if the requested locale is ja_JP_JP and there are
2089         // bundles for all of the candidates in the cache, we have a list,
</pre>
<hr />
<pre>
2233      * by the caller&#39;s module.
2234      *
2235      * @since 1.6
2236      * @revised 9
2237      * @spec JPMS
2238      * @see ResourceBundle.Control#getTimeToLive(String,Locale)
2239      */
2240     @CallerSensitive
2241     public static final void clearCache() {
2242         Class&lt;?&gt; caller = Reflection.getCallerClass();
2243         cacheList.keySet().removeIf(
2244             key -&gt; key.getCallerModule() == caller.getModule()
2245         );
2246     }
2247 
2248     /**
2249      * Removes all resource bundles from the cache that have been loaded
2250      * by the given class loader.
2251      *
2252      * @param loader the class loader
<span class="line-modified">2253      * @exception NullPointerException if &lt;code&gt;loader&lt;/code&gt; is null</span>
2254      * @since 1.6
2255      * @see ResourceBundle.Control#getTimeToLive(String,Locale)
2256      */
2257     public static final void clearCache(ClassLoader loader) {
2258         Objects.requireNonNull(loader);
2259         cacheList.keySet().removeIf(
2260             key -&gt; {
2261                 Module m;
2262                 return (m = key.getModule()) != null &amp;&amp;
2263                        getLoader(m) == loader;
2264             }
2265         );
2266     }
2267 
2268     /**
2269      * Gets an object for the given key from this resource bundle.
2270      * Returns null if this resource bundle does not contain an
2271      * object for the given key.
2272      *
2273      * @param key the key for the desired object
<span class="line-modified">2274      * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
2275      * @return the object for the given key, or null
2276      */
2277     protected abstract Object handleGetObject(String key);
2278 
2279     /**
2280      * Returns an enumeration of the keys.
2281      *
<span class="line-modified">2282      * @return an &lt;code&gt;Enumeration&lt;/code&gt; of the keys contained in</span>
<span class="line-modified">2283      *         this &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.</span>
2284      */
2285     public abstract Enumeration&lt;String&gt; getKeys();
2286 
2287     /**
<span class="line-modified">2288      * Determines whether the given &lt;code&gt;key&lt;/code&gt; is contained in</span>
<span class="line-modified">2289      * this &lt;code&gt;ResourceBundle&lt;/code&gt; or its parent bundles.</span>
2290      *
2291      * @param key
<span class="line-modified">2292      *        the resource &lt;code&gt;key&lt;/code&gt;</span>
<span class="line-modified">2293      * @return &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;key&lt;/code&gt; is</span>
<span class="line-modified">2294      *        contained in this &lt;code&gt;ResourceBundle&lt;/code&gt; or its</span>
<span class="line-modified">2295      *        parent bundles; &lt;code&gt;false&lt;/code&gt; otherwise.</span>
<span class="line-modified">2296      * @exception NullPointerException</span>
<span class="line-modified">2297      *         if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
2298      * @since 1.6
2299      */
2300     public boolean containsKey(String key) {
2301         if (key == null) {
2302             throw new NullPointerException();
2303         }
2304         for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
2305             if (rb.handleKeySet().contains(key)) {
2306                 return true;
2307             }
2308         }
2309         return false;
2310     }
2311 
2312     /**
<span class="line-modified">2313      * Returns a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this</span>
<span class="line-modified">2314      * &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.</span>
2315      *
<span class="line-modified">2316      * @return a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this</span>
<span class="line-modified">2317      *         &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.</span>
2318      * @since 1.6
2319      */
2320     public Set&lt;String&gt; keySet() {
2321         Set&lt;String&gt; keys = new HashSet&lt;&gt;();
2322         for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
2323             keys.addAll(rb.handleKeySet());
2324         }
2325         return keys;
2326     }
2327 
2328     /**
<span class="line-modified">2329      * Returns a &lt;code&gt;Set&lt;/code&gt; of the keys contained &lt;em&gt;only&lt;/em&gt;</span>
<span class="line-modified">2330      * in this &lt;code&gt;ResourceBundle&lt;/code&gt;.</span>
2331      *
<span class="line-modified">2332      * &lt;p&gt;The default implementation returns a &lt;code&gt;Set&lt;/code&gt; of the</span>
2333      * keys returned by the {@link #getKeys() getKeys} method except
2334      * for the ones for which the {@link #handleGetObject(String)
<span class="line-modified">2335      * handleGetObject} method returns &lt;code&gt;null&lt;/code&gt;. Once the</span>
<span class="line-modified">2336      * &lt;code&gt;Set&lt;/code&gt; has been created, the value is kept in this</span>
<span class="line-modified">2337      * &lt;code&gt;ResourceBundle&lt;/code&gt; in order to avoid producing the</span>
<span class="line-modified">2338      * same &lt;code&gt;Set&lt;/code&gt; in subsequent calls. Subclasses can</span>
2339      * override this method for faster handling.
2340      *
<span class="line-modified">2341      * @return a &lt;code&gt;Set&lt;/code&gt; of the keys contained only in this</span>
<span class="line-modified">2342      *        &lt;code&gt;ResourceBundle&lt;/code&gt;</span>
2343      * @since 1.6
2344      */
2345     protected Set&lt;String&gt; handleKeySet() {
2346         if (keySet == null) {
2347             synchronized (this) {
2348                 if (keySet == null) {
2349                     Set&lt;String&gt; keys = new HashSet&lt;&gt;();
2350                     Enumeration&lt;String&gt; enumKeys = getKeys();
2351                     while (enumKeys.hasMoreElements()) {
2352                         String key = enumKeys.nextElement();
2353                         if (handleGetObject(key) != null) {
2354                             keys.add(key);
2355                         }
2356                     }
2357                     keySet = keys;
2358                 }
2359             }
2360         }
2361         return keySet;
2362     }
2363 
2364 
2365 
2366     /**
<span class="line-modified">2367      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; defines a set of callback methods</span>
2368      * that are invoked by the {@link ResourceBundle#getBundle(String,
2369      * Locale, ClassLoader, Control) ResourceBundle.getBundle} factory
2370      * methods during the bundle loading process. In other words, a
<span class="line-modified">2371      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; collaborates with the factory</span>
2372      * methods for loading resource bundles. The default implementation of
2373      * the callback methods provides the information necessary for the
2374      * factory methods to perform the &lt;a
2375      * href=&quot;./ResourceBundle.html#default_behavior&quot;&gt;default behavior&lt;/a&gt;.
2376      *
2377      * &lt;p&gt; {@link ResourceBundle.Control} is designed for an application deployed
2378      * in an unnamed module, for example to support resource bundles in
2379      * non-standard formats or package localized resources in a non-traditional
2380      * convention. {@link ResourceBundleProvider} is the replacement for
2381      * {@code ResourceBundle.Control} when migrating to modules.
2382      * {@code UnsupportedOperationException} will be thrown when a factory
2383      * method that takes the {@code ResourceBundle.Control} parameter is called.
2384      *
2385      * &lt;p&gt;In addition to the callback methods, the {@link
2386      * #toBundleName(String, Locale) toBundleName} and {@link
2387      * #toResourceName(String, String) toResourceName} methods are defined
2388      * primarily for convenience in implementing the callback
<span class="line-modified">2389      * methods. However, the &lt;code&gt;toBundleName&lt;/code&gt; method could be</span>
2390      * overridden to provide different conventions in the organization and
<span class="line-modified">2391      * packaging of localized resources.  The &lt;code&gt;toResourceName&lt;/code&gt;</span>
<span class="line-modified">2392      * method is &lt;code&gt;final&lt;/code&gt; to avoid use of wrong resource and class</span>
2393      * name separators.
2394      *
2395      * &lt;p&gt;Two factory methods, {@link #getControl(List)} and {@link
2396      * #getNoFallbackControl(List)}, provide
<span class="line-modified">2397      * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances that implement common</span>
2398      * variations of the default bundle loading process.
2399      *
2400      * &lt;p&gt;The formats returned by the {@link Control#getFormats(String)
2401      * getFormats} method and candidate locales returned by the {@link
2402      * ResourceBundle.Control#getCandidateLocales(String, Locale)
2403      * getCandidateLocales} method must be consistent in all
<span class="line-modified">2404      * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; invocations for the same base</span>
<span class="line-modified">2405      * bundle. Otherwise, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; methods</span>
2406      * may return unintended bundles. For example, if only
<span class="line-modified">2407      * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; is returned by the &lt;code&gt;getFormats&lt;/code&gt;</span>
<span class="line-modified">2408      * method for the first call to &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;</span>
<span class="line-modified">2409      * and only &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for the second call, then the</span>
2410      * second call will return the class-based one that has been cached
2411      * during the first call.
2412      *
<span class="line-modified">2413      * &lt;p&gt;A &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instance must be thread-safe</span>
2414      * if it&#39;s simultaneously used by multiple threads.
<span class="line-modified">2415      * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; does not synchronize to call</span>
<span class="line-modified">2416      * the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; methods. The default</span>
2417      * implementations of the methods are thread-safe.
2418      *
<span class="line-modified">2419      * &lt;p&gt;Applications can specify &lt;code&gt;ResourceBundle.Control&lt;/code&gt;</span>
<span class="line-modified">2420      * instances returned by the &lt;code&gt;getControl&lt;/code&gt; factory methods or</span>
<span class="line-modified">2421      * created from a subclass of &lt;code&gt;ResourceBundle.Control&lt;/code&gt; to</span>
2422      * customize the bundle loading process. The following are examples of
2423      * changing the default bundle loading process.
2424      *
2425      * &lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;
2426      *
<span class="line-modified">2427      * &lt;p&gt;The following code lets &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; look</span>
2428      * up only properties-based resources.
2429      *
2430      * &lt;pre&gt;
2431      * import java.util.*;
2432      * import static java.util.ResourceBundle.Control.*;
2433      * ...
2434      * ResourceBundle bundle =
2435      *   ResourceBundle.getBundle(&quot;MyResources&quot;, new Locale(&quot;fr&quot;, &quot;CH&quot;),
2436      *                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));
2437      * &lt;/pre&gt;
2438      *
2439      * Given the resource bundles in the &lt;a
2440      * href=&quot;./ResourceBundle.html#default_behavior_example&quot;&gt;example&lt;/a&gt; in
<span class="line-modified">2441      * the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; description, this</span>
<span class="line-modified">2442      * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; call loads</span>
<span class="line-modified">2443      * &lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt; whose parent is</span>
<span class="line-modified">2444      * &lt;code&gt;MyResources_fr.properties&lt;/code&gt; whose parent is</span>
<span class="line-modified">2445      * &lt;code&gt;MyResources.properties&lt;/code&gt;. (&lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt;</span>
<span class="line-modified">2446      * is not hidden, but &lt;code&gt;MyResources_fr_CH.class&lt;/code&gt; is.)</span>
2447      *
2448      * &lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;
2449      *
2450      * &lt;p&gt;The following is an example of loading XML-based bundles
2451      * using {@link Properties#loadFromXML(java.io.InputStream)
2452      * Properties.loadFromXML}.
2453      *
2454      * &lt;pre&gt;
2455      * ResourceBundle rb = ResourceBundle.getBundle(&quot;Messages&quot;,
2456      *     new ResourceBundle.Control() {
2457      *         public List&amp;lt;String&amp;gt; getFormats(String baseName) {
2458      *             if (baseName == null)
2459      *                 throw new NullPointerException();
2460      *             return Arrays.asList(&quot;xml&quot;);
2461      *         }
2462      *         public ResourceBundle newBundle(String baseName,
2463      *                                         Locale locale,
2464      *                                         String format,
2465      *                                         ClassLoader loader,
2466      *                                         boolean reload)
</pre>
<hr />
<pre>
2512      *     }
2513      *     public Enumeration&amp;lt;String&amp;gt; getKeys() {
2514      *         ...
2515      *     }
2516      * }
2517      * &lt;/pre&gt;
2518      *
2519      * @apiNote {@code ResourceBundle.Control} is not supported
2520      * in named modules. If the {@code ResourceBundle.getBundle} method with
2521      * a {@code ResourceBundle.Control} is called in a named module, the method
2522      * will throw an {@link UnsupportedOperationException}. Any service providers
2523      * of {@link ResourceBundleControlProvider} are ignored in named modules.
2524      *
2525      * @since 1.6
2526      * @revised 9
2527      * @spec JPMS
2528      * @see java.util.spi.ResourceBundleProvider
2529      */
2530     public static class Control {
2531         /**
<span class="line-modified">2532          * The default format &lt;code&gt;List&lt;/code&gt;, which contains the strings</span>
<span class="line-modified">2533          * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, in</span>
<span class="line-modified">2534          * this order. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.</span>
2535          *
2536          * @see #getFormats(String)
2537          */
2538         public static final List&lt;String&gt; FORMAT_DEFAULT
2539             = List.of(&quot;java.class&quot;, &quot;java.properties&quot;);
2540 
2541         /**
<span class="line-modified">2542          * The class-only format &lt;code&gt;List&lt;/code&gt; containing</span>
<span class="line-modified">2543          * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.</span>
2544          *
2545          * @see #getFormats(String)
2546          */
2547         public static final List&lt;String&gt; FORMAT_CLASS = List.of(&quot;java.class&quot;);
2548 
2549         /**
<span class="line-modified">2550          * The properties-only format &lt;code&gt;List&lt;/code&gt; containing</span>
<span class="line-modified">2551          * &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.</span>
2552          *
2553          * @see #getFormats(String)
2554          */
2555         public static final List&lt;String&gt; FORMAT_PROPERTIES
2556             = List.of(&quot;java.properties&quot;);
2557 
2558         /**
2559          * The time-to-live constant for not caching loaded resource bundle
2560          * instances.
2561          *
2562          * @see #getTimeToLive(String, Locale)
2563          */
2564         public static final long TTL_DONT_CACHE = -1;
2565 
2566         /**
2567          * The time-to-live constant for disabling the expiration control
2568          * for loaded resource bundle instances in the cache.
2569          *
2570          * @see #getTimeToLive(String, Locale)
2571          */
2572         public static final long TTL_NO_EXPIRATION_CONTROL = -2;
2573 
2574         private static final Control INSTANCE = new Control();
2575 
2576         /**
2577          * Sole constructor. (For invocation by subclass constructors,
2578          * typically implicit.)
2579          */
2580         protected Control() {
2581         }
2582 
2583         /**
<span class="line-modified">2584          * Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link</span>
2585          * #getFormats(String) getFormats} method returns the specified
<span class="line-modified">2586          * &lt;code&gt;formats&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must be equal to</span>
2587          * one of {@link Control#FORMAT_PROPERTIES}, {@link
2588          * Control#FORMAT_CLASS} or {@link
<span class="line-modified">2589          * Control#FORMAT_DEFAULT}. &lt;code&gt;ResourceBundle.Control&lt;/code&gt;</span>
2590          * instances returned by this method are singletons and thread-safe.
2591          *
2592          * &lt;p&gt;Specifying {@link Control#FORMAT_DEFAULT} is equivalent to
<span class="line-modified">2593          * instantiating the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; class,</span>
2594          * except that this method returns a singleton.
2595          *
2596          * @param formats
2597          *        the formats to be returned by the
<span class="line-modified">2598          *        &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method</span>
<span class="line-modified">2599          * @return a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the</span>
<span class="line-modified">2600          *        specified &lt;code&gt;formats&lt;/code&gt;</span>
<span class="line-modified">2601          * @exception NullPointerException</span>
<span class="line-modified">2602          *        if &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">2603          * @exception IllegalArgumentException</span>
<span class="line-modified">2604          *        if &lt;code&gt;formats&lt;/code&gt; is unknown</span>
2605          */
2606         public static final Control getControl(List&lt;String&gt; formats) {
2607             if (formats.equals(Control.FORMAT_PROPERTIES)) {
2608                 return SingleFormatControl.PROPERTIES_ONLY;
2609             }
2610             if (formats.equals(Control.FORMAT_CLASS)) {
2611                 return SingleFormatControl.CLASS_ONLY;
2612             }
2613             if (formats.equals(Control.FORMAT_DEFAULT)) {
2614                 return Control.INSTANCE;
2615             }
2616             throw new IllegalArgumentException();
2617         }
2618 
2619         /**
<span class="line-modified">2620          * Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link</span>
2621          * #getFormats(String) getFormats} method returns the specified
<span class="line-modified">2622          * &lt;code&gt;formats&lt;/code&gt; and the {@link</span>
2623          * Control#getFallbackLocale(String, Locale) getFallbackLocale}
<span class="line-modified">2624          * method returns &lt;code&gt;null&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must</span>
2625          * be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link
2626          * Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
<span class="line-modified">2627          * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances returned by this</span>
2628          * method are singletons and thread-safe.
2629          *
2630          * @param formats
2631          *        the formats to be returned by the
<span class="line-modified">2632          *        &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method</span>
<span class="line-modified">2633          * @return a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the</span>
<span class="line-modified">2634          *        specified &lt;code&gt;formats&lt;/code&gt; with no fallback</span>
<span class="line-modified">2635          *        &lt;code&gt;Locale&lt;/code&gt; support</span>
<span class="line-modified">2636          * @exception NullPointerException</span>
<span class="line-modified">2637          *        if &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-modified">2638          * @exception IllegalArgumentException</span>
<span class="line-modified">2639          *        if &lt;code&gt;formats&lt;/code&gt; is unknown</span>
2640          */
2641         public static final Control getNoFallbackControl(List&lt;String&gt; formats) {
2642             if (formats.equals(Control.FORMAT_DEFAULT)) {
2643                 return NoFallbackControl.NO_FALLBACK;
2644             }
2645             if (formats.equals(Control.FORMAT_PROPERTIES)) {
2646                 return NoFallbackControl.PROPERTIES_ONLY_NO_FALLBACK;
2647             }
2648             if (formats.equals(Control.FORMAT_CLASS)) {
2649                 return NoFallbackControl.CLASS_ONLY_NO_FALLBACK;
2650             }
2651             throw new IllegalArgumentException();
2652         }
2653 
2654         /**
<span class="line-modified">2655          * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing</span>
2656          * formats to be used to load resource bundles for the given
<span class="line-modified">2657          * &lt;code&gt;baseName&lt;/code&gt;. The &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;</span>
2658          * factory method tries to load resource bundles with formats in the
2659          * order specified by the list. The list returned by this method
<span class="line-modified">2660          * must have at least one &lt;code&gt;String&lt;/code&gt;. The predefined</span>
<span class="line-modified">2661          * formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; for class-based resource</span>
<span class="line-modified">2662          * bundles and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for {@linkplain</span>
2663          * PropertyResourceBundle properties-based} ones. Strings starting
<span class="line-modified">2664          * with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions and</span>
2665          * must not be used by application-defined formats.
2666          *
2667          * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
<span class="line-modified">2668          * &lt;code&gt;List&lt;/code&gt;.  However, the returned &lt;code&gt;List&lt;/code&gt; must</span>
2669          * not be mutated after it has been returned by
<span class="line-modified">2670          * &lt;code&gt;getFormats&lt;/code&gt;.</span>
2671          *
2672          * &lt;p&gt;The default implementation returns {@link #FORMAT_DEFAULT} so
<span class="line-modified">2673          * that the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method</span>
2674          * looks up first class-based resource bundles, then
2675          * properties-based ones.
2676          *
2677          * @param baseName
2678          *        the base name of the resource bundle, a fully qualified class
2679          *        name
<span class="line-modified">2680          * @return a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing</span>
2681          *        formats for loading resource bundles.
<span class="line-modified">2682          * @exception NullPointerException</span>
<span class="line-modified">2683          *        if &lt;code&gt;baseName&lt;/code&gt; is null</span>
2684          * @see #FORMAT_DEFAULT
2685          * @see #FORMAT_CLASS
2686          * @see #FORMAT_PROPERTIES
2687          */
2688         public List&lt;String&gt; getFormats(String baseName) {
2689             if (baseName == null) {
2690                 throw new NullPointerException();
2691             }
2692             return FORMAT_DEFAULT;
2693         }
2694 
2695         /**
<span class="line-modified">2696          * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s as candidate</span>
<span class="line-modified">2697          * locales for &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;. This</span>
<span class="line-modified">2698          * method is called by the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;</span>
2699          * factory method each time the factory method tries finding a
<span class="line-modified">2700          * resource bundle for a target &lt;code&gt;Locale&lt;/code&gt;.</span>
2701          *
2702          * &lt;p&gt;The sequence of the candidate locales also corresponds to the
2703          * runtime resource lookup path (also known as the &lt;I&gt;parent
2704          * chain&lt;/I&gt;), if the corresponding resource bundles for the
2705          * candidate locales exist and their parents are not defined by
2706          * loaded resource bundles themselves.  The last element of the list
2707          * must be a {@linkplain Locale#ROOT root locale} if it is desired to
2708          * have the base bundle as the terminal of the parent chain.
2709          *
<span class="line-modified">2710          * &lt;p&gt;If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the</span>
<span class="line-modified">2711          * root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root</span>
<span class="line-modified">2712          * &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the</span>
<span class="line-modified">2713          * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only</span>
2714          * the base bundle as the resulting resource bundle.
2715          *
2716          * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
<span class="line-modified">2717          * &lt;code&gt;List&lt;/code&gt;. However, the returned &lt;code&gt;List&lt;/code&gt; must not</span>
2718          * be mutated after it has been returned by
<span class="line-modified">2719          * &lt;code&gt;getCandidateLocales&lt;/code&gt;.</span>
2720          *
<span class="line-modified">2721          * &lt;p&gt;The default implementation returns a &lt;code&gt;List&lt;/code&gt; containing</span>
<span class="line-modified">2722          * &lt;code&gt;Locale&lt;/code&gt;s using the rules described below.  In the</span>
2723          * description below, &lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;V&lt;/em&gt;
2724          * respectively represent non-empty language, script, country, and
2725          * variant.  For example, [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] represents a
<span class="line-modified">2726          * &lt;code&gt;Locale&lt;/code&gt; that has non-empty values only for language and</span>
2727          * country.  The form &lt;em&gt;L&lt;/em&gt;(&quot;xx&quot;) represents the (non-empty)
<span class="line-modified">2728          * language value is &quot;xx&quot;.  For all cases, &lt;code&gt;Locale&lt;/code&gt;s whose</span>
2729          * final component values are empty strings are omitted.
2730          *
<span class="line-modified">2731          * &lt;ol&gt;&lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with an empty script value,</span>
<span class="line-modified">2732          * append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component</span>
2733          * one by one as below:
2734          *
2735          * &lt;ul&gt;
2736          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;] &lt;/li&gt;
2737          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] &lt;/li&gt;
2738          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;] &lt;/li&gt;
<span class="line-modified">2739          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; &lt;/li&gt;</span>
2740          * &lt;/ul&gt;&lt;/li&gt;
2741          *
<span class="line-modified">2742          * &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a non-empty script value,</span>
<span class="line-modified">2743          * append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component</span>
2744          * up to language, then append candidates generated from the
<span class="line-modified">2745          * &lt;code&gt;Locale&lt;/code&gt; with country and variant restored:</span>
2746          *
2747          * &lt;ul&gt;
2748          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
2749          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
2750          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
2751          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
2752          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
2753          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<span class="line-modified">2754          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
2755          * &lt;/ul&gt;&lt;/li&gt;
2756          *
<span class="line-modified">2757          * &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a variant value consisting</span>
2758          * of multiple subtags separated by underscore, generate candidate
<span class="line-modified">2759          * &lt;code&gt;Locale&lt;/code&gt;s by omitting the variant subtags one by one, then</span>
<span class="line-modified">2760          * insert them after every occurrence of &lt;code&gt; Locale&lt;/code&gt;s with the</span>
2761          * full variant value in the original list.  For example, if
2762          * the variant consists of two subtags &lt;em&gt;V1&lt;/em&gt; and &lt;em&gt;V2&lt;/em&gt;:
2763          *
2764          * &lt;ul&gt;
2765          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
2766          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
2767          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
2768          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
2769          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
2770          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
2771          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
2772          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<span class="line-modified">2773          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
2774          * &lt;/ul&gt;&lt;/li&gt;
2775          *
<span class="line-modified">2776          * &lt;li&gt;Special cases for Chinese.  When an input &lt;code&gt;Locale&lt;/code&gt; has the</span>
2777          * language &quot;zh&quot; (Chinese) and an empty script value, either &quot;Hans&quot; (Simplified) or
2778          * &quot;Hant&quot; (Traditional) might be supplied, depending on the country.
2779          * When the country is &quot;CN&quot; (China) or &quot;SG&quot; (Singapore), &quot;Hans&quot; is supplied.
2780          * When the country is &quot;HK&quot; (Hong Kong SAR China), &quot;MO&quot; (Macau SAR China),
2781          * or &quot;TW&quot; (Taiwan), &quot;Hant&quot; is supplied.  For all other countries or when the country
2782          * is empty, no script is supplied.  For example, for &lt;code&gt;Locale(&quot;zh&quot;, &quot;CN&quot;)
2783          * &lt;/code&gt;, the candidate list will be:
2784          * &lt;ul&gt;
2785          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
2786          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;)]&lt;/li&gt;
2787          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
2788          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<span class="line-modified">2789          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
2790          * &lt;/ul&gt;
2791          *
<span class="line-modified">2792          * For &lt;code&gt;Locale(&quot;zh&quot;, &quot;TW&quot;)&lt;/code&gt;, the candidate list will be:</span>
2793          * &lt;ul&gt;
2794          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
2795          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;)]&lt;/li&gt;
2796          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
2797          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<span class="line-modified">2798          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
2799          * &lt;/ul&gt;&lt;/li&gt;
2800          *
<span class="line-modified">2801          * &lt;li&gt;Special cases for Norwegian.  Both &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;,</span>
<span class="line-modified">2802          * &quot;NY&quot;)&lt;/code&gt; and &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; represent Norwegian</span>
2803          * Nynorsk.  When a locale&#39;s language is &quot;nn&quot;, the standard candidate
2804          * list is generated up to [&lt;em&gt;L&lt;/em&gt;(&quot;nn&quot;)], and then the following
2805          * candidates are added:
2806          *
2807          * &lt;ul&gt;&lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;NY&quot;)]&lt;/li&gt;
2808          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
2809          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<span class="line-modified">2810          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
2811          * &lt;/ul&gt;
2812          *
<span class="line-modified">2813          * If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first</span>
<span class="line-modified">2814          * converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is</span>
2815          * followed.
2816          *
2817          * &lt;p&gt;Also, Java treats the language &quot;no&quot; as a synonym of Norwegian
<span class="line-modified">2818          * Bokm&amp;#xE5;l &quot;nb&quot;.  Except for the single case &lt;code&gt;Locale(&quot;no&quot;,</span>
<span class="line-modified">2819          * &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; (handled above), when an input &lt;code&gt;Locale&lt;/code&gt;</span>
<span class="line-modified">2820          * has language &quot;no&quot; or &quot;nb&quot;, candidate &lt;code&gt;Locale&lt;/code&gt;s with</span>
2821          * language code &quot;no&quot; and &quot;nb&quot; are interleaved, first using the
2822          * requested language, then using its synonym. For example,
<span class="line-modified">2823          * &lt;code&gt;Locale(&quot;nb&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; generates the following</span>
2824          * candidate list:
2825          *
2826          * &lt;ul&gt;
2827          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
2828          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
2829          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
2830          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
2831          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;)]&lt;/li&gt;
2832          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<span class="line-modified">2833          * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</span>
2834          * &lt;/ul&gt;
2835          *
<span class="line-modified">2836          * &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; would generate the same list</span>
2837          * except that locales with &quot;no&quot; would appear before the corresponding
2838          * locales with &quot;nb&quot;.&lt;/li&gt;
2839          * &lt;/ol&gt;
2840          *
2841          * &lt;p&gt;The default implementation uses an {@link ArrayList} that
2842          * overriding implementations may modify before returning it to the
2843          * caller. However, a subclass must not modify it after it has
<span class="line-modified">2844          * been returned by &lt;code&gt;getCandidateLocales&lt;/code&gt;.</span>
2845          *
<span class="line-modified">2846          * &lt;p&gt;For example, if the given &lt;code&gt;baseName&lt;/code&gt; is &quot;Messages&quot;</span>
<span class="line-modified">2847          * and the given &lt;code&gt;locale&lt;/code&gt; is</span>
2848          * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then a
<span class="line-modified">2849          * &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s:</span>
2850          * &lt;pre&gt;
2851          *     Locale(&quot;ja&quot;, &quot;&quot;, &quot;XX&quot;)
2852          *     Locale(&quot;ja&quot;)
2853          *     Locale.ROOT
2854          * &lt;/pre&gt;
2855          * is returned. And if the resource bundles for the &quot;ja&quot; and
<span class="line-modified">2856          * &quot;&quot; &lt;code&gt;Locale&lt;/code&gt;s are found, then the runtime resource</span>
2857          * lookup path (parent chain) is:
2858          * &lt;pre&gt;{@code
2859          *     Messages_ja -&gt; Messages
2860          * }&lt;/pre&gt;
2861          *
2862          * @param baseName
2863          *        the base name of the resource bundle, a fully
2864          *        qualified class name
2865          * @param locale
2866          *        the locale for which a resource bundle is desired
<span class="line-modified">2867          * @return a &lt;code&gt;List&lt;/code&gt; of candidate</span>
<span class="line-modified">2868          *        &lt;code&gt;Locale&lt;/code&gt;s for the given &lt;code&gt;locale&lt;/code&gt;</span>
<span class="line-modified">2869          * @exception NullPointerException</span>
<span class="line-modified">2870          *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is</span>
<span class="line-modified">2871          *        &lt;code&gt;null&lt;/code&gt;</span>
2872          */
2873         public List&lt;Locale&gt; getCandidateLocales(String baseName, Locale locale) {
2874             if (baseName == null) {
2875                 throw new NullPointerException();
2876             }
2877             return new ArrayList&lt;&gt;(CANDIDATES_CACHE.get(locale.getBaseLocale()));
2878         }
2879 
2880         private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();
2881 
2882         private static class CandidateListCache extends LocaleObjectCache&lt;BaseLocale, List&lt;Locale&gt;&gt; {
2883             protected List&lt;Locale&gt; createObject(BaseLocale base) {
2884                 String language = base.getLanguage();
2885                 String script = base.getScript();
2886                 String region = base.getRegion();
2887                 String variant = base.getVariant();
2888 
2889                 // Special handling for Norwegian
2890                 boolean isNorwegianBokmal = false;
2891                 boolean isNorwegianNynorsk = false;
</pre>
<hr />
<pre>
2986                     if (variants != null) {
2987                         for (String v : variants) {
2988                             list.add(Locale.getInstance(language, &quot;&quot;, region, v, null));
2989                         }
2990                     }
2991                     if (!region.isEmpty()) {
2992                         list.add(Locale.getInstance(language, &quot;&quot;, region, &quot;&quot;, null));
2993                     }
2994                 }
2995                 if (!language.isEmpty()) {
2996                     list.add(Locale.getInstance(language, &quot;&quot;, &quot;&quot;, &quot;&quot;, null));
2997                 }
2998                 // Add root locale at the end
2999                 list.add(Locale.ROOT);
3000 
3001                 return list;
3002             }
3003         }
3004 
3005         /**
<span class="line-modified">3006          * Returns a &lt;code&gt;Locale&lt;/code&gt; to be used as a fallback locale for</span>
3007          * further resource bundle searches by the
<span class="line-modified">3008          * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method. This method</span>
3009          * is called from the factory method every time when no resulting
<span class="line-modified">3010          * resource bundle has been found for &lt;code&gt;baseName&lt;/code&gt; and</span>
<span class="line-modified">3011          * &lt;code&gt;locale&lt;/code&gt;, where locale is either the parameter for</span>
<span class="line-modified">3012          * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; or the previous fallback</span>
3013          * locale returned by this method.
3014          *
<span class="line-modified">3015          * &lt;p&gt;The method returns &lt;code&gt;null&lt;/code&gt; if no further fallback</span>
3016          * search is desired.
3017          *
3018          * &lt;p&gt;The default implementation returns the {@linkplain
<span class="line-modified">3019          * Locale#getDefault() default &lt;code&gt;Locale&lt;/code&gt;} if the given</span>
<span class="line-modified">3020          * &lt;code&gt;locale&lt;/code&gt; isn&#39;t the default one.  Otherwise,</span>
<span class="line-modified">3021          * &lt;code&gt;null&lt;/code&gt; is returned.</span>
3022          *
3023          * @param baseName
3024          *        the base name of the resource bundle, a fully
3025          *        qualified class name for which
<span class="line-modified">3026          *        &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been</span>
3027          *        unable to find any resource bundles (except for the
3028          *        base bundle)
3029          * @param locale
<span class="line-modified">3030          *        the &lt;code&gt;Locale&lt;/code&gt; for which</span>
<span class="line-modified">3031          *        &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been</span>
3032          *        unable to find any resource bundles (except for the
3033          *        base bundle)
<span class="line-modified">3034          * @return a &lt;code&gt;Locale&lt;/code&gt; for the fallback search,</span>
<span class="line-modified">3035          *        or &lt;code&gt;null&lt;/code&gt; if no further fallback search</span>
3036          *        is desired.
<span class="line-modified">3037          * @exception NullPointerException</span>
<span class="line-modified">3038          *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;</span>
<span class="line-modified">3039          *        is &lt;code&gt;null&lt;/code&gt;</span>
3040          */
3041         public Locale getFallbackLocale(String baseName, Locale locale) {
3042             if (baseName == null) {
3043                 throw new NullPointerException();
3044             }
3045             Locale defaultLocale = Locale.getDefault();
3046             return locale.equals(defaultLocale) ? null : defaultLocale;
3047         }
3048 
3049         /**
3050          * Instantiates a resource bundle for the given bundle name of the
3051          * given format and locale, using the given class loader if
<span class="line-modified">3052          * necessary. This method returns &lt;code&gt;null&lt;/code&gt; if there is no</span>
3053          * resource bundle available for the given parameters. If a resource
3054          * bundle can&#39;t be instantiated due to an unexpected error, the
<span class="line-modified">3055          * error must be reported by throwing an &lt;code&gt;Error&lt;/code&gt; or</span>
<span class="line-modified">3056          * &lt;code&gt;Exception&lt;/code&gt; rather than simply returning</span>
<span class="line-modified">3057          * &lt;code&gt;null&lt;/code&gt;.</span>
3058          *
<span class="line-modified">3059          * &lt;p&gt;If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it</span>
3060          * indicates that this method is being called because the previously
3061          * loaded resource bundle has expired.
3062          *
3063          * @implSpec
3064          *
3065          * Resource bundles in named modules are subject to the encapsulation
3066          * rules specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
3067          * A resource bundle in a named module visible to the given class loader
3068          * is accessible when the package of the resource file corresponding
3069          * to the resource bundle is open unconditionally.
3070          *
3071          * &lt;p&gt;The default implementation instantiates a
<span class="line-modified">3072          * &lt;code&gt;ResourceBundle&lt;/code&gt; as follows.</span>
3073          *
3074          * &lt;ul&gt;
3075          *
3076          * &lt;li&gt;The bundle name is obtained by calling {@link
3077          * #toBundleName(String, Locale) toBundleName(baseName,
3078          * locale)}.&lt;/li&gt;
3079          *
<span class="line-modified">3080          * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;, the</span>
3081          * {@link Class} specified by the bundle name is loaded with the
3082          * given class loader. If the {@code Class} is found and accessible
<span class="line-modified">3083          * then the &lt;code&gt;ResourceBundle&lt;/code&gt; is instantiated.  The</span>
3084          * resource bundle is accessible if the package of the bundle class file
3085          * is open unconditionally; otherwise, {@code IllegalAccessException}
3086          * will be thrown.
<span class="line-modified">3087          * Note that the &lt;code&gt;reload&lt;/code&gt; flag is ignored for loading</span>
3088          * class-based resource bundles in this default implementation.
3089          * &lt;/li&gt;
3090          *
<span class="line-modified">3091          * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;,</span>
3092          * {@link #toResourceName(String, String) toResourceName(bundlename,
3093          * &quot;properties&quot;)} is called to get the resource name.
<span class="line-modified">3094          * If &lt;code&gt;reload&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, {@link</span>
3095          * ClassLoader#getResource(String) load.getResource} is called
3096          * to get a {@link URL} for creating a {@link
<span class="line-modified">3097          * URLConnection}. This &lt;code&gt;URLConnection&lt;/code&gt; is used to</span>
3098          * {@linkplain URLConnection#setUseCaches(boolean) disable the
3099          * caches} of the underlying resource loading layers,
3100          * and to {@linkplain URLConnection#getInputStream() get an
<span class="line-modified">3101          * &lt;code&gt;InputStream&lt;/code&gt;}.</span>
3102          * Otherwise, {@link ClassLoader#getResourceAsStream(String)
3103          * loader.getResourceAsStream} is called to get an {@link
3104          * InputStream}. Then, a {@link
3105          * PropertyResourceBundle} is constructed with the
<span class="line-modified">3106          * &lt;code&gt;InputStream&lt;/code&gt;.&lt;/li&gt;</span>
3107          *
<span class="line-modified">3108          * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is neither &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;</span>
<span class="line-modified">3109          * nor &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, an</span>
<span class="line-modified">3110          * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.&lt;/li&gt;</span>
3111          *
3112          * &lt;/ul&gt;
3113          *
3114          * @param baseName
3115          *        the base bundle name of the resource bundle, a fully
3116          *        qualified class name
3117          * @param locale
3118          *        the locale for which the resource bundle should be
3119          *        instantiated
3120          * @param format
3121          *        the resource bundle format to be loaded
3122          * @param loader
<span class="line-modified">3123          *        the &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle</span>
3124          * @param reload
<span class="line-modified">3125          *        the flag to indicate bundle reloading; &lt;code&gt;true&lt;/code&gt;</span>
3126          *        if reloading an expired resource bundle,
<span class="line-modified">3127          *        &lt;code&gt;false&lt;/code&gt; otherwise</span>
3128          * @return the resource bundle instance,
<span class="line-modified">3129          *        or &lt;code&gt;null&lt;/code&gt; if none could be found.</span>
<span class="line-modified">3130          * @exception NullPointerException</span>
<span class="line-modified">3131          *        if &lt;code&gt;bundleName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,</span>
<span class="line-modified">3132          *        &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is</span>
<span class="line-modified">3133          *        &lt;code&gt;null&lt;/code&gt;, or if &lt;code&gt;null&lt;/code&gt; is returned by</span>
3134          *        {@link #toBundleName(String, Locale) toBundleName}
<span class="line-modified">3135          * @exception IllegalArgumentException</span>
<span class="line-modified">3136          *        if &lt;code&gt;format&lt;/code&gt; is unknown, or if the resource</span>
3137          *        found for the given parameters contains malformed data.
<span class="line-modified">3138          * @exception ClassCastException</span>
<span class="line-modified">3139          *        if the loaded class cannot be cast to &lt;code&gt;ResourceBundle&lt;/code&gt;</span>
<span class="line-modified">3140          * @exception IllegalAccessException</span>
3141          *        if the class or its nullary constructor is not
3142          *        accessible.
<span class="line-modified">3143          * @exception InstantiationException</span>
3144          *        if the instantiation of a class fails for some other
3145          *        reason.
<span class="line-modified">3146          * @exception ExceptionInInitializerError</span>
3147          *        if the initialization provoked by this method fails.
<span class="line-modified">3148          * @exception SecurityException</span>
3149          *        If a security manager is present and creation of new
3150          *        instances is denied. See {@link Class#newInstance()}
3151          *        for details.
<span class="line-modified">3152          * @exception IOException</span>
3153          *        if an error occurred when reading resources using
3154          *        any I/O operations
3155          * @see java.util.spi.ResourceBundleProvider#getBundle(String, Locale)
3156          * @revised 9
3157          * @spec JPMS
3158          */
3159         public ResourceBundle newBundle(String baseName, Locale locale, String format,
3160                                         ClassLoader loader, boolean reload)
3161                     throws IllegalAccessException, InstantiationException, IOException {
3162             /*
3163              * Legacy mechanism to locate resource bundle in unnamed module only
3164              * that is visible to the given loader and accessible to the given caller.
3165              */
3166             String bundleName = toBundleName(baseName, locale);
3167             ResourceBundle bundle = null;
3168             if (format.equals(&quot;java.class&quot;)) {
3169                 try {
3170                     Class&lt;?&gt; c = loader.loadClass(bundleName);
3171                     // If the class isn&#39;t a ResourceBundle subclass, throw a
3172                     // ClassCastException.
</pre>
<hr />
<pre>
3239                         });
3240                 } catch (PrivilegedActionException e) {
3241                     throw (IOException) e.getException();
3242                 }
3243                 if (stream != null) {
3244                     try {
3245                         bundle = new PropertyResourceBundle(stream);
3246                     } finally {
3247                         stream.close();
3248                     }
3249                 }
3250             } else {
3251                 throw new IllegalArgumentException(&quot;unknown format: &quot; + format);
3252             }
3253             return bundle;
3254         }
3255 
3256         /**
3257          * Returns the time-to-live (TTL) value for resource bundles that
3258          * are loaded under this
<span class="line-modified">3259          * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;. Positive time-to-live values</span>
3260          * specify the number of milliseconds a bundle can remain in the
3261          * cache without being validated against the source data from which
3262          * it was constructed. The value 0 indicates that a bundle must be
3263          * validated each time it is retrieved from the cache. {@link
3264          * #TTL_DONT_CACHE} specifies that loaded resource bundles are not
3265          * put in the cache. {@link #TTL_NO_EXPIRATION_CONTROL} specifies
3266          * that loaded resource bundles are put in the cache with no
3267          * expiration control.
3268          *
3269          * &lt;p&gt;The expiration affects only the bundle loading process by the
<span class="line-modified">3270          * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method.  That is,</span>
3271          * if the factory method finds a resource bundle in the cache that
3272          * has expired, the factory method calls the {@link
3273          * #needsReload(String, Locale, String, ClassLoader, ResourceBundle,
3274          * long) needsReload} method to determine whether the resource
<span class="line-modified">3275          * bundle needs to be reloaded. If &lt;code&gt;needsReload&lt;/code&gt; returns</span>
<span class="line-modified">3276          * &lt;code&gt;true&lt;/code&gt;, the cached resource bundle instance is removed</span>
3277          * from the cache. Otherwise, the instance stays in the cache,
3278          * updated with the new TTL value returned by this method.
3279          *
3280          * &lt;p&gt;All cached resource bundles are subject to removal from the
3281          * cache due to memory constraints of the runtime environment.
3282          * Returning a large positive value doesn&#39;t mean to lock loaded
3283          * resource bundles in the cache.
3284          *
3285          * &lt;p&gt;The default implementation returns {@link #TTL_NO_EXPIRATION_CONTROL}.
3286          *
3287          * @param baseName
3288          *        the base name of the resource bundle for which the
3289          *        expiration value is specified.
3290          * @param locale
3291          *        the locale of the resource bundle for which the
3292          *        expiration value is specified.
3293          * @return the time (0 or a positive millisecond offset from the
3294          *        cached time) to get loaded bundles expired in the cache,
3295          *        {@link #TTL_NO_EXPIRATION_CONTROL} to disable the
3296          *        expiration control, or {@link #TTL_DONT_CACHE} to disable
3297          *        caching.
<span class="line-modified">3298          * @exception NullPointerException</span>
<span class="line-modified">3299          *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is</span>
<span class="line-modified">3300          *        &lt;code&gt;null&lt;/code&gt;</span>
3301          */
3302         public long getTimeToLive(String baseName, Locale locale) {
3303             if (baseName == null || locale == null) {
3304                 throw new NullPointerException();
3305             }
3306             return TTL_NO_EXPIRATION_CONTROL;
3307         }
3308 
3309         /**
<span class="line-modified">3310          * Determines if the expired &lt;code&gt;bundle&lt;/code&gt; in the cache needs</span>
3311          * to be reloaded based on the loading time given by
<span class="line-modified">3312          * &lt;code&gt;loadTime&lt;/code&gt; or some other criteria. The method returns</span>
<span class="line-modified">3313          * &lt;code&gt;true&lt;/code&gt; if reloading is required; &lt;code&gt;false&lt;/code&gt;</span>
<span class="line-modified">3314          * otherwise. &lt;code&gt;loadTime&lt;/code&gt; is a millisecond offset since</span>
<span class="line-modified">3315          * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt;</span>
3316          * Epoch&lt;/a&gt;.
3317          *
3318          * &lt;p&gt;
<span class="line-modified">3319          * The calling &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method</span>
<span class="line-modified">3320          * calls this method on the &lt;code&gt;ResourceBundle.Control&lt;/code&gt;</span>
3321          * instance used for its current invocation, not on the instance
3322          * used in the invocation that originally loaded the resource
3323          * bundle.
3324          *
<span class="line-modified">3325          * &lt;p&gt;The default implementation compares &lt;code&gt;loadTime&lt;/code&gt; and</span>
3326          * the last modified time of the source data of the resource
3327          * bundle. If it&#39;s determined that the source data has been modified
<span class="line-modified">3328          * since &lt;code&gt;loadTime&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is</span>
<span class="line-modified">3329          * returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. This</span>
<span class="line-modified">3330          * implementation assumes that the given &lt;code&gt;format&lt;/code&gt; is the</span>
3331          * same string as its file suffix if it&#39;s not one of the default
<span class="line-modified">3332          * formats, &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; or</span>
<span class="line-modified">3333          * &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;.</span>
3334          *
3335          * @param baseName
3336          *        the base bundle name of the resource bundle, a
3337          *        fully qualified class name
3338          * @param locale
3339          *        the locale for which the resource bundle
3340          *        should be instantiated
3341          * @param format
3342          *        the resource bundle format to be loaded
3343          * @param loader
<span class="line-modified">3344          *        the &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle</span>
3345          * @param bundle
3346          *        the resource bundle instance that has been expired
3347          *        in the cache
3348          * @param loadTime
<span class="line-modified">3349          *        the time when &lt;code&gt;bundle&lt;/code&gt; was loaded and put</span>
3350          *        in the cache
<span class="line-modified">3351          * @return &lt;code&gt;true&lt;/code&gt; if the expired bundle needs to be</span>
<span class="line-modified">3352          *        reloaded; &lt;code&gt;false&lt;/code&gt; otherwise.</span>
<span class="line-modified">3353          * @exception NullPointerException</span>
<span class="line-modified">3354          *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,</span>
<span class="line-modified">3355          *        &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;loader&lt;/code&gt;, or</span>
<span class="line-modified">3356          *        &lt;code&gt;bundle&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
3357          */
3358         public boolean needsReload(String baseName, Locale locale,
3359                                    String format, ClassLoader loader,
3360                                    ResourceBundle bundle, long loadTime) {
3361             if (bundle == null) {
3362                 throw new NullPointerException();
3363             }
3364             if (format.equals(&quot;java.class&quot;) || format.equals(&quot;java.properties&quot;)) {
3365                 format = format.substring(5);
3366             }
3367             boolean result = false;
3368             try {
3369                 String resourceName = toResourceName0(toBundleName(baseName, locale), format);
3370                 if (resourceName == null) {
3371                     return result;
3372                 }
3373                 URL url = loader.getResource(resourceName);
3374                 if (url != null) {
3375                     long lastModified = 0;
3376                     URLConnection connection = url.openConnection();
</pre>
<hr />
<pre>
3383                                 lastModified = ent.getTime();
3384                                 if (lastModified == -1) {
3385                                     lastModified = 0;
3386                                 }
3387                             }
3388                         } else {
3389                             lastModified = connection.getLastModified();
3390                         }
3391                     }
3392                     result = lastModified &gt;= loadTime;
3393                 }
3394             } catch (NullPointerException npe) {
3395                 throw npe;
3396             } catch (Exception e) {
3397                 // ignore other exceptions
3398             }
3399             return result;
3400         }
3401 
3402         /**
<span class="line-modified">3403          * Converts the given &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;</span>
3404          * to the bundle name. This method is called from the default
3405          * implementation of the {@link #newBundle(String, Locale, String,
3406          * ClassLoader, boolean) newBundle} and {@link #needsReload(String,
3407          * Locale, String, ClassLoader, ResourceBundle, long) needsReload}
3408          * methods.
3409          *
3410          * &lt;p&gt;This implementation returns the following value:
3411          * &lt;pre&gt;
3412          *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
3413          * &lt;/pre&gt;
<span class="line-modified">3414          * where &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;country&lt;/code&gt;,</span>
<span class="line-modified">3415          * and &lt;code&gt;variant&lt;/code&gt; are the language, script, country, and variant</span>
<span class="line-modified">3416          * values of &lt;code&gt;locale&lt;/code&gt;, respectively. Final component values that</span>
3417          * are empty Strings are omitted along with the preceding &#39;_&#39;.  When the
3418          * script is empty, the script value is omitted along with the preceding &#39;_&#39;.
<span class="line-modified">3419          * If all of the values are empty strings, then &lt;code&gt;baseName&lt;/code&gt;</span>
3420          * is returned.
3421          *
<span class="line-modified">3422          * &lt;p&gt;For example, if &lt;code&gt;baseName&lt;/code&gt; is</span>
<span class="line-modified">3423          * &lt;code&gt;&quot;baseName&quot;&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt; is</span>
3424          * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then
3425          * &lt;code&gt;&quot;baseName_ja_&amp;thinsp;_XX&quot;&lt;/code&gt; is returned. If the given
<span class="line-modified">3426          * locale is &lt;code&gt;Locale(&quot;en&quot;)&lt;/code&gt;, then</span>
<span class="line-modified">3427          * &lt;code&gt;&quot;baseName_en&quot;&lt;/code&gt; is returned.</span>
3428          *
3429          * &lt;p&gt;Overriding this method allows applications to use different
3430          * conventions in the organization and packaging of localized
3431          * resources.
3432          *
3433          * @param baseName
3434          *        the base name of the resource bundle, a fully
3435          *        qualified class name
3436          * @param locale
3437          *        the locale for which a resource bundle should be
3438          *        loaded
3439          * @return the bundle name for the resource bundle
<span class="line-modified">3440          * @exception NullPointerException</span>
<span class="line-modified">3441          *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;</span>
<span class="line-modified">3442          *        is &lt;code&gt;null&lt;/code&gt;</span>
3443          * @see java.util.spi.AbstractResourceBundleProvider#toBundleName(String, Locale)
3444          */
3445         public String toBundleName(String baseName, Locale locale) {
3446             if (locale == Locale.ROOT) {
3447                 return baseName;
3448             }
3449 
3450             String language = locale.getLanguage();
3451             String script = locale.getScript();
3452             String country = locale.getCountry();
3453             String variant = locale.getVariant();
3454 
3455             if (language == &quot;&quot; &amp;&amp; country == &quot;&quot; &amp;&amp; variant == &quot;&quot;) {
3456                 return baseName;
3457             }
3458 
3459             StringBuilder sb = new StringBuilder(baseName);
3460             sb.append(&#39;_&#39;);
3461             if (script != &quot;&quot;) {
3462                 if (variant != &quot;&quot;) {
</pre>
<hr />
<pre>
3478             return sb.toString();
3479 
3480         }
3481 
3482         /**
3483          * Converts the given {@code bundleName} to the form required
3484          * by the {@link ClassLoader#getResource ClassLoader.getResource}
3485          * method by replacing all occurrences of {@code &#39;.&#39;} in
3486          * {@code bundleName} with {@code &#39;/&#39;} and appending a
3487          * {@code &#39;.&#39;} and the given file {@code suffix}. For
3488          * example, if {@code bundleName} is
3489          * {@code &quot;foo.bar.MyResources_ja_JP&quot;} and {@code suffix}
3490          * is {@code &quot;properties&quot;}, then
3491          * {@code &quot;foo/bar/MyResources_ja_JP.properties&quot;} is returned.
3492          *
3493          * @param bundleName
3494          *        the bundle name
3495          * @param suffix
3496          *        the file type suffix
3497          * @return the converted resource name
<span class="line-modified">3498          * @exception NullPointerException</span>
3499          *         if {@code bundleName} or {@code suffix}
3500          *         is {@code null}
3501          */
3502         public final String toResourceName(String bundleName, String suffix) {
3503             StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());
3504             sb.append(bundleName.replace(&#39;.&#39;, &#39;/&#39;)).append(&#39;.&#39;).append(suffix);
3505             return sb.toString();
3506         }
3507 
3508         private String toResourceName0(String bundleName, String suffix) {
3509             // application protocol check
3510             if (bundleName.contains(&quot;://&quot;)) {
3511                 return null;
3512             } else {
3513                 return toResourceName(bundleName, suffix);
3514             }
3515         }
3516     }
3517 
3518     @SuppressWarnings(&quot;unchecked&quot;)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  62 import java.util.jar.JarEntry;
  63 import java.util.spi.ResourceBundleControlProvider;
  64 import java.util.spi.ResourceBundleProvider;
  65 import java.util.stream.Collectors;
  66 import java.util.stream.Stream;
  67 
  68 import jdk.internal.loader.BootLoader;
  69 import jdk.internal.access.JavaUtilResourceBundleAccess;
  70 import jdk.internal.access.SharedSecrets;
  71 import jdk.internal.reflect.CallerSensitive;
  72 import jdk.internal.reflect.Reflection;
  73 import sun.security.action.GetPropertyAction;
  74 import sun.util.locale.BaseLocale;
  75 import sun.util.locale.LocaleObjectCache;
  76 import static sun.security.util.SecurityConstants.GET_CLASSLOADER_PERMISSION;
  77 
  78 
  79 /**
  80  *
  81  * Resource bundles contain locale-specific objects.  When your program needs a
<span class="line-modified">  82  * locale-specific resource, a {@code String} for example, your program can</span>
  83  * load it from the resource bundle that is appropriate for the current user&#39;s
  84  * locale. In this way, you can write program code that is largely independent
  85  * of the user&#39;s locale isolating most, if not all, of the locale-specific
  86  * information in resource bundles.
  87  *
  88  * &lt;p&gt;
  89  * This allows you to write programs that can:
  90  * &lt;UL&gt;
  91  * &lt;LI&gt; be easily localized, or translated, into different languages
  92  * &lt;LI&gt; handle multiple locales at once
  93  * &lt;LI&gt; be easily modified later to support even more locales
  94  * &lt;/UL&gt;
  95  *
  96  * &lt;P&gt;
  97  * Resource bundles belong to families whose members share a common base
  98  * name, but whose names also have additional components that identify
  99  * their locales. For example, the base name of a family of resource
 100  * bundles might be &quot;MyResources&quot;. The family should have a default
 101  * resource bundle which simply has the same name as its family -
 102  * &quot;MyResources&quot; - and will be used as the bundle of last resort if a
 103  * specific locale is not supported. The family can then provide as
 104  * many locale-specific members as needed, for example a German one
 105  * named &quot;MyResources_de&quot;.
 106  *
 107  * &lt;P&gt;
 108  * Each resource bundle in a family contains the same items, but the items have
 109  * been translated for the locale represented by that resource bundle.
 110  * For example, both &quot;MyResources&quot; and &quot;MyResources_de&quot; may have a
<span class="line-modified"> 111  * {@code String} that&#39;s used on a button for canceling operations.</span>
<span class="line-modified"> 112  * In &quot;MyResources&quot; the {@code String} may contain &quot;Cancel&quot; and in</span>
 113  * &quot;MyResources_de&quot; it may contain &quot;Abbrechen&quot;.
 114  *
 115  * &lt;P&gt;
 116  * If there are different resources for different countries, you
 117  * can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for
 118  * the German language (de) in Switzerland (CH). If you want to only
 119  * modify some of the resources
 120  * in the specialization, you can do so.
 121  *
 122  * &lt;P&gt;
 123  * When your program needs a locale-specific object, it loads
<span class="line-modified"> 124  * the {@code ResourceBundle} class using the</span>
 125  * {@link #getBundle(java.lang.String, java.util.Locale) getBundle}
 126  * method:
 127  * &lt;blockquote&gt;
 128  * &lt;pre&gt;
 129  * ResourceBundle myResources =
 130  *      ResourceBundle.getBundle(&quot;MyResources&quot;, currentLocale);
 131  * &lt;/pre&gt;
 132  * &lt;/blockquote&gt;
 133  *
 134  * &lt;P&gt;
 135  * Resource bundles contain key/value pairs. The keys uniquely
 136  * identify a locale-specific object in the bundle. Here&#39;s an
<span class="line-modified"> 137  * example of a {@code ListResourceBundle} that contains</span>
 138  * two key/value pairs:
 139  * &lt;blockquote&gt;
 140  * &lt;pre&gt;
 141  * public class MyResources extends ListResourceBundle {
 142  *     protected Object[][] getContents() {
 143  *         return new Object[][] {
 144  *             // LOCALIZE THE SECOND STRING OF EACH ARRAY (e.g., &quot;OK&quot;)
 145  *             {&quot;OkKey&quot;, &quot;OK&quot;},
 146  *             {&quot;CancelKey&quot;, &quot;Cancel&quot;},
 147  *             // END OF MATERIAL TO LOCALIZE
 148  *        };
 149  *     }
 150  * }
 151  * &lt;/pre&gt;
 152  * &lt;/blockquote&gt;
<span class="line-modified"> 153  * Keys are always {@code String}s.</span>
 154  * In this example, the keys are &quot;OkKey&quot; and &quot;CancelKey&quot;.
 155  * In the above example, the values
<span class="line-modified"> 156  * are also {@code String}s--&quot;OK&quot; and &quot;Cancel&quot;--but</span>
 157  * they don&#39;t have to be. The values can be any type of object.
 158  *
 159  * &lt;P&gt;
 160  * You retrieve an object from resource bundle using the appropriate
 161  * getter method. Because &quot;OkKey&quot; and &quot;CancelKey&quot;
<span class="line-modified"> 162  * are both strings, you would use {@code getString} to retrieve them:</span>
 163  * &lt;blockquote&gt;
 164  * &lt;pre&gt;
 165  * button1 = new Button(myResources.getString(&quot;OkKey&quot;));
 166  * button2 = new Button(myResources.getString(&quot;CancelKey&quot;));
 167  * &lt;/pre&gt;
 168  * &lt;/blockquote&gt;
 169  * The getter methods all require the key as an argument and return
 170  * the object if found. If the object is not found, the getter method
<span class="line-modified"> 171  * throws a {@code MissingResourceException}.</span>
 172  *
 173  * &lt;P&gt;
<span class="line-modified"> 174  * Besides {@code getString}, {@code ResourceBundle} also provides</span>
<span class="line-modified"> 175  * a method for getting string arrays, {@code getStringArray},</span>
<span class="line-modified"> 176  * as well as a generic {@code getObject} method for any other</span>
<span class="line-modified"> 177  * type of object. When using {@code getObject}, you&#39;ll</span>
 178  * have to cast the result to the appropriate type. For example:
 179  * &lt;blockquote&gt;
 180  * &lt;pre&gt;
 181  * int[] myIntegers = (int[]) myResources.getObject(&quot;intList&quot;);
 182  * &lt;/pre&gt;
 183  * &lt;/blockquote&gt;
 184  *
 185  * &lt;P&gt;
<span class="line-modified"> 186  * The Java Platform provides two subclasses of {@code ResourceBundle},</span>
<span class="line-modified"> 187  * {@code ListResourceBundle} and {@code PropertyResourceBundle},</span>
 188  * that provide a fairly simple way to create resources.
<span class="line-modified"> 189  * As you saw briefly in a previous example, {@code ListResourceBundle}</span>
 190  * manages its resource as a list of key/value pairs.
<span class="line-modified"> 191  * {@code PropertyResourceBundle} uses a properties file to manage</span>
 192  * its resources.
 193  *
 194  * &lt;p&gt;
<span class="line-modified"> 195  * If {@code ListResourceBundle} or {@code PropertyResourceBundle}</span>
<span class="line-modified"> 196  * do not suit your needs, you can write your own {@code ResourceBundle}</span>
<span class="line-modified"> 197  * subclass.  Your subclasses must override two methods: {@code handleGetObject}</span>
<span class="line-modified"> 198  * and {@code getKeys()}.</span>
 199  *
 200  * &lt;p&gt;
 201  * The implementation of a {@code ResourceBundle} subclass must be thread-safe
 202  * if it&#39;s simultaneously used by multiple threads. The default implementations
 203  * of the non-abstract methods in this class, and the methods in the direct
 204  * known concrete subclasses {@code ListResourceBundle} and
 205  * {@code PropertyResourceBundle} are thread-safe.
 206  *
<span class="line-modified"> 207  * &lt;h2&gt;&lt;a id=&quot;resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;&lt;/h2&gt;</span>
 208  *
 209  * Resource bundles can be deployed in modules in the following ways:
 210  *
<span class="line-modified"> 211  * &lt;h3&gt;Resource bundles together with an application&lt;/h3&gt;</span>
 212  *
 213  * Resource bundles can be deployed together with an application in the same
 214  * module.  In that case, the resource bundles are loaded
 215  * by code in the module by calling the {@link #getBundle(String)}
 216  * or {@link #getBundle(String, Locale)} method.
 217  *
<span class="line-modified"> 218  * &lt;h3&gt;&lt;a id=&quot;service-providers&quot;&gt;Resource bundles as service providers&lt;/a&gt;&lt;/h3&gt;</span>
 219  *
 220  * Resource bundles can be deployed in one or more &lt;em&gt;service provider modules&lt;/em&gt;
 221  * and they can be located using {@link ServiceLoader}.
 222  * A {@linkplain ResourceBundleProvider service} interface or class must be
 223  * defined. The caller module declares that it uses the service, the service
 224  * provider modules declare that they provide implementations of the service.
 225  * Refer to {@link ResourceBundleProvider} for developing resource bundle
 226  * services and deploying resource bundle providers.
 227  * The module obtaining the resource bundle can be a resource bundle
 228  * provider itself; in which case this module only locates the resource bundle
 229  * via service provider mechanism.
 230  *
 231  * &lt;p&gt;A {@linkplain ResourceBundleProvider resource bundle provider} can
 232  * provide resource bundles in any format such XML which replaces the need
 233  * of {@link Control ResourceBundle.Control}.
 234  *
<span class="line-modified"> 235  * &lt;h3&gt;&lt;a id=&quot;other-modules&quot;&gt;Resource bundles in other modules and class path&lt;/a&gt;&lt;/h3&gt;</span>
 236  *
 237  * Resource bundles in a named module may be &lt;em&gt;encapsulated&lt;/em&gt; so that
 238  * it cannot be located by code in other modules.  Resource bundles
 239  * in unnamed modules and class path are open for any module to access.
 240  * Resource bundle follows the resource encapsulation rules as specified
 241  * in {@link Module#getResourceAsStream(String)}.
 242  *
 243  * &lt;p&gt;The {@code getBundle} factory methods with no {@code Control} parameter
 244  * locate and load resource bundles from
 245  * {@linkplain ResourceBundleProvider service providers}.
 246  * It may continue the search as if calling {@link Module#getResourceAsStream(String)}
 247  * to find the named resource from a given module and calling
 248  * {@link ClassLoader#getResourceAsStream(String)}; refer to
 249  * the specification of the {@code getBundle} method for details.
 250  * Only non-encapsulated resource bundles of &quot;{@code java.class}&quot;
 251  * or &quot;{@code java.properties}&quot; format are searched.
 252  *
 253  * &lt;p&gt;If the caller module is a
 254  * &lt;a href=&quot;{@docRoot}/java.base/java/util/spi/ResourceBundleProvider.html#obtain-resource-bundle&quot;&gt;
 255  * resource bundle provider&lt;/a&gt;, it does not fall back to the
 256  * class loader search.
 257  *
<span class="line-modified"> 258  * &lt;h3&gt;Resource bundles in automatic modules&lt;/h3&gt;</span>
 259  *
 260  * A common format of resource bundles is in {@linkplain PropertyResourceBundle
 261  * .properties} file format.  Typically {@code .properties} resource bundles
 262  * are packaged in a JAR file.  Resource bundle only JAR file can be readily
 263  * deployed as an &lt;a href=&quot;{@docRoot}/java.base/java/lang/module/ModuleFinder.html#automatic-modules&quot;&gt;
 264  * automatic module&lt;/a&gt;.  For example, if the JAR file contains the
 265  * entry &quot;{@code p/q/Foo_ja.properties}&quot; and no {@code .class} entry,
 266  * when resolved and defined as an automatic module, no package is derived
 267  * for this module.  This allows resource bundles in {@code .properties}
 268  * format packaged in one or more JAR files that may contain entries
 269  * in the same directory and can be resolved successfully as
 270  * automatic modules.
 271  *
 272  * &lt;h3&gt;ResourceBundle.Control&lt;/h3&gt;
 273  *
 274  * The {@link ResourceBundle.Control} class provides information necessary
<span class="line-modified"> 275  * to perform the bundle loading process by the {@code getBundle}</span>
<span class="line-modified"> 276  * factory methods that take a {@code ResourceBundle.Control}</span>
 277  * instance. You can implement your own subclass in order to enable
 278  * non-standard resource bundle formats, change the search strategy, or
 279  * define caching parameters. Refer to the descriptions of the class and the
 280  * {@link #getBundle(String, Locale, ClassLoader, Control) getBundle}
 281  * factory method for details.
 282  *
 283  * &lt;p&gt; {@link ResourceBundle.Control} is designed for an application deployed
 284  * in an unnamed module, for example to support resource bundles in
 285  * non-standard formats or package localized resources in a non-traditional
 286  * convention. {@link ResourceBundleProvider} is the replacement for
 287  * {@code ResourceBundle.Control} when migrating to modules.
 288  * {@code UnsupportedOperationException} will be thrown when a factory
 289  * method that takes the {@code ResourceBundle.Control} parameter is called.
 290  *
 291  * &lt;p&gt;&lt;a id=&quot;modify_default_behavior&quot;&gt;For the {@code getBundle} factory&lt;/a&gt;
 292  * methods that take no {@link Control} instance, their &lt;a
 293  * href=&quot;#default_behavior&quot;&gt; default behavior&lt;/a&gt; of resource bundle loading
 294  * can be modified with custom {@link
 295  * ResourceBundleControlProvider} implementations.
 296  * If any of the
 297  * providers provides a {@link Control} for the given base name, that {@link
 298  * Control} will be used instead of the default {@link Control}. If there is
 299  * more than one service provider for supporting the same base name,
 300  * the first one returned from {@link ServiceLoader} will be used.
 301  * A custom {@link Control} implementation is ignored by named modules.
 302  *
<span class="line-modified"> 303  * &lt;h2&gt;Cache Management&lt;/h2&gt;</span>
 304  *
<span class="line-modified"> 305  * Resource bundle instances created by the {@code getBundle} factory</span>
 306  * methods are cached by default, and the factory methods return the same
 307  * resource bundle instance multiple times if it has been
<span class="line-modified"> 308  * cached. {@code getBundle} clients may clear the cache, manage the</span>
 309  * lifetime of cached resource bundle instances using time-to-live values,
 310  * or specify not to cache resource bundle instances. Refer to the
 311  * descriptions of the {@linkplain #getBundle(String, Locale, ClassLoader,
<span class="line-modified"> 312  * Control) {@code getBundle} factory method}, {@link</span>
 313  * #clearCache(ClassLoader) clearCache}, {@link
 314  * Control#getTimeToLive(String, Locale)
 315  * ResourceBundle.Control.getTimeToLive}, and {@link
 316  * Control#needsReload(String, Locale, String, ClassLoader, ResourceBundle,
 317  * long) ResourceBundle.Control.needsReload} for details.
 318  *
<span class="line-modified"> 319  * &lt;h2&gt;Example&lt;/h2&gt;</span>
 320  *
<span class="line-modified"> 321  * The following is a very simple example of a {@code ResourceBundle}</span>
<span class="line-modified"> 322  * subclass, {@code MyResources}, that manages two resources (for a larger number of</span>
<span class="line-modified"> 323  * resources you would probably use a {@code Map}).</span>
 324  * Notice that you don&#39;t need to supply a value if
<span class="line-modified"> 325  * a &quot;parent-level&quot; {@code ResourceBundle} handles the same</span>
 326  * key with the same value (as for the okKey below).
 327  * &lt;blockquote&gt;
 328  * &lt;pre&gt;
 329  * // default (English language, United States)
 330  * public class MyResources extends ResourceBundle {
 331  *     public Object handleGetObject(String key) {
 332  *         if (key.equals(&quot;okKey&quot;)) return &quot;Ok&quot;;
 333  *         if (key.equals(&quot;cancelKey&quot;)) return &quot;Cancel&quot;;
 334  *         return null;
 335  *     }
 336  *
 337  *     public Enumeration&amp;lt;String&amp;gt; getKeys() {
 338  *         return Collections.enumeration(keySet());
 339  *     }
 340  *
 341  *     // Overrides handleKeySet() so that the getKeys() implementation
 342  *     // can rely on the keySet() value.
 343  *     protected Set&amp;lt;String&amp;gt; handleKeySet() {
 344  *         return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;okKey&quot;, &quot;cancelKey&quot;));
 345  *     }
 346  * }
 347  *
 348  * // German language
 349  * public class MyResources_de extends MyResources {
 350  *     public Object handleGetObject(String key) {
 351  *         // don&#39;t need okKey, since parent level handles it.
 352  *         if (key.equals(&quot;cancelKey&quot;)) return &quot;Abbrechen&quot;;
 353  *         return null;
 354  *     }
 355  *
 356  *     protected Set&amp;lt;String&amp;gt; handleKeySet() {
 357  *         return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;cancelKey&quot;));
 358  *     }
 359  * }
 360  * &lt;/pre&gt;
 361  * &lt;/blockquote&gt;
 362  * You do not have to restrict yourself to using a single family of
<span class="line-modified"> 363  * {@code ResourceBundle}s. For example, you could have a set of bundles for</span>
<span class="line-modified"> 364  * exception messages, {@code ExceptionResources}</span>
<span class="line-modified"> 365  * ({@code ExceptionResources_fr}, {@code ExceptionResources_de}, ...),</span>
<span class="line-modified"> 366  * and one for widgets, {@code WidgetResource} ({@code WidgetResources_fr},</span>
<span class="line-modified"> 367  * {@code WidgetResources_de}, ...); breaking up the resources however you like.</span>
 368  *
 369  * @see ListResourceBundle
 370  * @see PropertyResourceBundle
 371  * @see MissingResourceException
 372  * @see ResourceBundleProvider
 373  * @since 1.1
 374  * @revised 9
 375  * @spec JPMS
 376  */
 377 public abstract class ResourceBundle {
 378 
 379     /** initial size of the bundle cache */
 380     private static final int INITIAL_CACHE_SIZE = 32;
 381 
 382     static {
 383         SharedSecrets.setJavaUtilResourceBundleAccess(
 384             new JavaUtilResourceBundleAccess() {
 385                 @Override
 386                 public void setParent(ResourceBundle bundle,
 387                                       ResourceBundle parent) {
</pre>
<hr />
<pre>
 495     /**
 496      * A Set of the keys contained only in this ResourceBundle.
 497      */
 498     private volatile Set&lt;String&gt; keySet;
 499 
 500     /**
 501      * Sole constructor.  (For invocation by subclass constructors, typically
 502      * implicit.)
 503      */
 504     public ResourceBundle() {
 505     }
 506 
 507     /**
 508      * Gets a string for the given key from this resource bundle or one of its parents.
 509      * Calling this method is equivalent to calling
 510      * &lt;blockquote&gt;
 511      * &lt;code&gt;(String) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
 512      * &lt;/blockquote&gt;
 513      *
 514      * @param key the key for the desired string
<span class="line-modified"> 515      * @throws    NullPointerException if {@code key} is {@code null}</span>
<span class="line-modified"> 516      * @throws    MissingResourceException if no object for the given key can be found</span>
<span class="line-modified"> 517      * @throws    ClassCastException if the object found for the given key is not a string</span>
 518      * @return the string for the given key
 519      */
 520     public final String getString(String key) {
 521         return (String) getObject(key);
 522     }
 523 
 524     /**
 525      * Gets a string array for the given key from this resource bundle or one of its parents.
 526      * Calling this method is equivalent to calling
 527      * &lt;blockquote&gt;
 528      * &lt;code&gt;(String[]) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
 529      * &lt;/blockquote&gt;
 530      *
 531      * @param key the key for the desired string array
<span class="line-modified"> 532      * @throws    NullPointerException if {@code key} is {@code null}</span>
<span class="line-modified"> 533      * @throws    MissingResourceException if no object for the given key can be found</span>
<span class="line-modified"> 534      * @throws    ClassCastException if the object found for the given key is not a string array</span>
 535      * @return the string array for the given key
 536      */
 537     public final String[] getStringArray(String key) {
 538         return (String[]) getObject(key);
 539     }
 540 
 541     /**
 542      * Gets an object for the given key from this resource bundle or one of its parents.
 543      * This method first tries to obtain the object from this resource bundle using
 544      * {@link #handleGetObject(java.lang.String) handleGetObject}.
 545      * If not successful, and the parent resource bundle is not null,
<span class="line-modified"> 546      * it calls the parent&#39;s {@code getObject} method.</span>
 547      * If still not successful, it throws a MissingResourceException.
 548      *
 549      * @param key the key for the desired object
<span class="line-modified"> 550      * @throws    NullPointerException if {@code key} is {@code null}</span>
<span class="line-modified"> 551      * @throws    MissingResourceException if no object for the given key can be found</span>
 552      * @return the object for the given key
 553      */
 554     public final Object getObject(String key) {
 555         Object obj = handleGetObject(key);
 556         if (obj == null) {
 557             if (parent != null) {
 558                 obj = parent.getObject(key);
 559             }
 560             if (obj == null) {
 561                 throw new MissingResourceException(&quot;Can&#39;t find resource for bundle &quot;
 562                                                    +this.getClass().getName()
 563                                                    +&quot;, key &quot;+key,
 564                                                    this.getClass().getName(),
 565                                                    key);
 566             }
 567         }
 568         return obj;
 569     }
 570 
 571     /**
</pre>
<hr />
<pre>
 820      */
 821     private static class BundleReference extends SoftReference&lt;ResourceBundle&gt;
 822                                          implements CacheKeyReference {
 823         private final CacheKey cacheKey;
 824 
 825         BundleReference(ResourceBundle referent, ReferenceQueue&lt;Object&gt; q, CacheKey key) {
 826             super(referent, q);
 827             cacheKey = key;
 828         }
 829 
 830         @Override
 831         public CacheKey getCacheKey() {
 832             return cacheKey;
 833         }
 834     }
 835 
 836     /**
 837      * Gets a resource bundle using the specified base name, the default locale,
 838      * and the caller module. Calling this method is equivalent to calling
 839      * &lt;blockquote&gt;
<span class="line-modified"> 840      * {@code getBundle(baseName, Locale.getDefault(), callerModule)},</span>
 841      * &lt;/blockquote&gt;
 842      *
 843      * @param baseName the base name of the resource bundle, a fully qualified class name
<span class="line-modified"> 844      * @throws    java.lang.NullPointerException</span>
<span class="line-modified"> 845      *     if {@code baseName} is {@code null}</span>
<span class="line-modified"> 846      * @throws    MissingResourceException</span>
 847      *     if no resource bundle for the specified base name can be found
 848      * @return a resource bundle for the given base name and the default locale
 849      *
 850      * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
 851      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
 852      */
 853     @CallerSensitive
 854     public static final ResourceBundle getBundle(String baseName)
 855     {
 856         Class&lt;?&gt; caller = Reflection.getCallerClass();
 857         return getBundleImpl(baseName, Locale.getDefault(),
 858                              caller, getDefaultControl(caller, baseName));
 859     }
 860 
 861     /**
 862      * Returns a resource bundle using the specified base name, the
 863      * default locale and the specified control. Calling this method
 864      * is equivalent to calling
 865      * &lt;pre&gt;
 866      * getBundle(baseName, Locale.getDefault(),
 867      *           this.getClass().getClassLoader(), control),
 868      * &lt;/pre&gt;
<span class="line-modified"> 869      * except that {@code getClassLoader()} is run with the security</span>
<span class="line-modified"> 870      * privileges of {@code ResourceBundle}.  See {@link</span>
 871      * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
 872      * complete description of the resource bundle loading process with a
<span class="line-modified"> 873      * {@code ResourceBundle.Control}.</span>
 874      *
 875      * @param baseName
 876      *        the base name of the resource bundle, a fully qualified class
 877      *        name
 878      * @param control
 879      *        the control which gives information for the resource bundle
 880      *        loading process
 881      * @return a resource bundle for the given base name and the default locale
 882      * @throws NullPointerException
<span class="line-modified"> 883      *         if {@code baseName} or {@code control} is</span>
<span class="line-modified"> 884      *         {@code null}</span>
 885      * @throws MissingResourceException
 886      *         if no resource bundle for the specified base name can be found
 887      * @throws IllegalArgumentException
<span class="line-modified"> 888      *         if the given {@code control} doesn&#39;t perform properly</span>
<span class="line-modified"> 889      *         (e.g., {@code control.getCandidateLocales} returns null.)</span>
<span class="line-modified"> 890      *         Note that validation of {@code control} is performed as</span>
 891      *         needed.
 892      * @throws UnsupportedOperationException
 893      *         if this method is called in a named module
 894      * @since 1.6
 895      * @revised 9
 896      * @spec JPMS
 897      */
 898     @CallerSensitive
 899     public static final ResourceBundle getBundle(String baseName,
 900                                                  Control control) {
 901         Class&lt;?&gt; caller = Reflection.getCallerClass();
 902         Locale targetLocale = Locale.getDefault();
 903         checkNamedModule(caller);
 904         return getBundleImpl(baseName, targetLocale, caller, control);
 905     }
 906 
 907     /**
 908      * Gets a resource bundle using the specified base name and locale,
 909      * and the caller module. Calling this method is equivalent to calling
 910      * &lt;blockquote&gt;
<span class="line-modified"> 911      * {@code getBundle(baseName, locale, callerModule)},</span>
 912      * &lt;/blockquote&gt;
 913      *
 914      * @param baseName
 915      *        the base name of the resource bundle, a fully qualified class name
 916      * @param locale
 917      *        the locale for which a resource bundle is desired
<span class="line-modified"> 918      * @throws    NullPointerException</span>
<span class="line-modified"> 919      *        if {@code baseName} or {@code locale} is {@code null}</span>
<span class="line-modified"> 920      * @throws    MissingResourceException</span>
 921      *        if no resource bundle for the specified base name can be found
 922      * @return a resource bundle for the given base name and locale
 923      *
 924      * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
 925      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
 926      */
 927     @CallerSensitive
 928     public static final ResourceBundle getBundle(String baseName,
 929                                                  Locale locale)
 930     {
 931         Class&lt;?&gt; caller = Reflection.getCallerClass();
 932         return getBundleImpl(baseName, locale,
 933                              caller, getDefaultControl(caller, baseName));
 934     }
 935 
 936     /**
 937      * Gets a resource bundle using the specified base name and the default locale
 938      * on behalf of the specified module. This method is equivalent to calling
 939      * &lt;blockquote&gt;
<span class="line-modified"> 940      * {@code getBundle(baseName, Locale.getDefault(), module)}</span>
 941      * &lt;/blockquote&gt;
 942      *
 943      * @param baseName the base name of the resource bundle,
 944      *                 a fully qualified class name
 945      * @param module   the module for which the resource bundle is searched
 946      * @throws NullPointerException
 947      *         if {@code baseName} or {@code module} is {@code null}
 948      * @throws SecurityException
 949      *         if a security manager exists and the caller is not the specified
 950      *         module and doesn&#39;t have {@code RuntimePermission(&quot;getClassLoader&quot;)}
 951      * @throws MissingResourceException
 952      *         if no resource bundle for the specified base name can be found in the
 953      *         specified module
 954      * @return a resource bundle for the given base name and the default locale
 955      * @since 9
 956      * @spec JPMS
 957      * @see ResourceBundleProvider
 958      * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
 959      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
 960      */
</pre>
<hr />
<pre>
1008      * @return a resource bundle for the given base name and locale in the module
1009      * @since 9
1010      * @spec JPMS
1011      * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
1012      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
1013      */
1014     @CallerSensitive
1015     public static ResourceBundle getBundle(String baseName, Locale targetLocale, Module module) {
1016         return getBundleFromModule(Reflection.getCallerClass(), module, baseName, targetLocale,
1017                                    getDefaultControl(module, baseName));
1018     }
1019 
1020     /**
1021      * Returns a resource bundle using the specified base name, target
1022      * locale and control, and the caller&#39;s class loader. Calling this
1023      * method is equivalent to calling
1024      * &lt;pre&gt;
1025      * getBundle(baseName, targetLocale, this.getClass().getClassLoader(),
1026      *           control),
1027      * &lt;/pre&gt;
<span class="line-modified">1028      * except that {@code getClassLoader()} is run with the security</span>
<span class="line-modified">1029      * privileges of {@code ResourceBundle}.  See {@link</span>
1030      * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
1031      * complete description of the resource bundle loading process with a
<span class="line-modified">1032      * {@code ResourceBundle.Control}.</span>
1033      *
1034      * @param baseName
1035      *        the base name of the resource bundle, a fully qualified
1036      *        class name
1037      * @param targetLocale
1038      *        the locale for which a resource bundle is desired
1039      * @param control
1040      *        the control which gives information for the resource
1041      *        bundle loading process
1042      * @return a resource bundle for the given base name and a
<span class="line-modified">1043      *         {@code Locale} in {@code locales}</span>
1044      * @throws NullPointerException
<span class="line-modified">1045      *         if {@code baseName}, {@code locales} or</span>
<span class="line-modified">1046      *         {@code control} is {@code null}</span>
1047      * @throws MissingResourceException
1048      *         if no resource bundle for the specified base name in any
<span class="line-modified">1049      *         of the {@code locales} can be found.</span>
1050      * @throws IllegalArgumentException
<span class="line-modified">1051      *         if the given {@code control} doesn&#39;t perform properly</span>
<span class="line-modified">1052      *         (e.g., {@code control.getCandidateLocales} returns null.)</span>
<span class="line-modified">1053      *         Note that validation of {@code control} is performed as</span>
1054      *         needed.
1055      * @throws UnsupportedOperationException
1056      *         if this method is called in a named module
1057      * @since 1.6
1058      * @revised 9
1059      * @spec JPMS
1060      */
1061     @CallerSensitive
1062     public static final ResourceBundle getBundle(String baseName, Locale targetLocale,
1063                                                  Control control) {
1064         Class&lt;?&gt; caller = Reflection.getCallerClass();
1065         checkNamedModule(caller);
1066         return getBundleImpl(baseName, targetLocale, caller, control);
1067     }
1068 
1069     /**
1070      * Gets a resource bundle using the specified base name, locale, and class
1071      * loader.
1072      *
1073      * &lt;p&gt;When this method is called from a named module and the given
1074      * loader is the class loader of the caller module, this is equivalent
1075      * to calling:
1076      * &lt;blockquote&gt;&lt;pre&gt;
1077      * getBundle(baseName, targetLocale, callerModule)
1078      * &lt;/pre&gt;&lt;/blockquote&gt;
1079      *
1080      * otherwise, this is equivalent to calling:
1081      * &lt;blockquote&gt;&lt;pre&gt;
1082      * getBundle(baseName, targetLocale, loader, control)
1083      * &lt;/pre&gt;&lt;/blockquote&gt;
1084      * where {@code control} is the default instance of {@link Control} unless
1085      * a {@code Control} instance is provided by
1086      * {@link ResourceBundleControlProvider} SPI.  Refer to the
1087      * description of &lt;a href=&quot;#modify_default_behavior&quot;&gt;modifying the default
1088      * behavior&lt;/a&gt;. The following describes the default behavior.
1089      *
1090      * &lt;p&gt;
1091      * &lt;b&gt;&lt;a id=&quot;default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;&lt;/b&gt;
1092      *
<span class="line-modified">1093      * &lt;p&gt;{@code getBundle} uses the base name, the specified locale, and</span>
1094      * the default locale (obtained from {@link java.util.Locale#getDefault()
1095      * Locale.getDefault}) to generate a sequence of &lt;a
1096      * id=&quot;candidates&quot;&gt;&lt;em&gt;candidate bundle names&lt;/em&gt;&lt;/a&gt;.  If the specified
1097      * locale&#39;s language, script, country, and variant are all empty strings,
1098      * then the base name is the only candidate bundle name.  Otherwise, a list
1099      * of candidate locales is generated from the attribute values of the
1100      * specified locale (language, script, country and variant) and appended to
1101      * the base name.  Typically, this will look like the following:
1102      *
1103      * &lt;pre&gt;
1104      *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
1105      *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country
1106      *     baseName + &quot;_&quot; + language + &quot;_&quot; + script
1107      *     baseName + &quot;_&quot; + language + &quot;_&quot; + country + &quot;_&quot; + variant
1108      *     baseName + &quot;_&quot; + language + &quot;_&quot; + country
1109      *     baseName + &quot;_&quot; + language
1110      * &lt;/pre&gt;
1111      *
1112      * &lt;p&gt;Candidate bundle names where the final component is an empty string
1113      * are omitted, along with the underscore.  For example, if country is an
</pre>
<hr />
<pre>
1123      * &lt;/pre&gt;
1124      *
1125      * In the case that the variant contains one or more underscores (&#39;_&#39;), a
1126      * sequence of bundle names generated by truncating the last underscore and
1127      * the part following it is inserted after a candidate bundle name with the
1128      * original variant.  For example, for a locale with language &quot;en&quot;, script
1129      * &quot;Latn, country &quot;US&quot; and variant &quot;WINDOWS_VISTA&quot;, and bundle base name
1130      * &quot;MyResource&quot;, the list of candidate bundle names below is generated:
1131      *
1132      * &lt;pre&gt;
1133      * MyResource_en_Latn_US_WINDOWS_VISTA
1134      * MyResource_en_Latn_US_WINDOWS
1135      * MyResource_en_Latn_US
1136      * MyResource_en_Latn
1137      * MyResource_en_US_WINDOWS_VISTA
1138      * MyResource_en_US_WINDOWS
1139      * MyResource_en_US
1140      * MyResource_en
1141      * &lt;/pre&gt;
1142      *
<span class="line-modified">1143      * &lt;blockquote&gt;&lt;b&gt;Note:&lt;/b&gt; For some {@code Locale}s, the list of</span>
1144      * candidate bundle names contains extra names, or the order of bundle names
1145      * is slightly modified.  See the description of the default implementation
1146      * of {@link Control#getCandidateLocales(String, Locale)
1147      * getCandidateLocales} for details.&lt;/blockquote&gt;
1148      *
<span class="line-modified">1149      * &lt;p&gt;{@code getBundle} then iterates over the candidate bundle names</span>
1150      * to find the first one for which it can &lt;em&gt;instantiate&lt;/em&gt; an actual
1151      * resource bundle. It uses the default controls&#39; {@link Control#getFormats
1152      * getFormats} method, which generates two bundle names for each generated
1153      * name, the first a class name and the second a properties file name. For
1154      * each candidate bundle name, it attempts to create a resource bundle:
1155      *
1156      * &lt;ul&gt;&lt;li&gt;First, it attempts to load a class using the generated class name.
1157      * If such a class can be found and loaded using the specified class
1158      * loader, is assignment compatible with ResourceBundle, is accessible from
<span class="line-modified">1159      * ResourceBundle, and can be instantiated, {@code getBundle} creates a</span>
1160      * new instance of this class and uses it as the &lt;em&gt;result resource
1161      * bundle&lt;/em&gt;.
1162      *
<span class="line-modified">1163      * &lt;li&gt;Otherwise, {@code getBundle} attempts to locate a property</span>
1164      * resource file using the generated properties file name.  It generates a
1165      * path name from the candidate bundle name by replacing all &quot;.&quot; characters
1166      * with &quot;/&quot; and appending the string &quot;.properties&quot;.  It attempts to find a
1167      * &quot;resource&quot; with this name using {@link
1168      * java.lang.ClassLoader#getResource(java.lang.String)
1169      * ClassLoader.getResource}.  (Note that a &quot;resource&quot; in the sense of
<span class="line-modified">1170      * {@code getResource} has nothing to do with the contents of a</span>
1171      * resource bundle, it is just a container of data, such as a file.)  If it
1172      * finds a &quot;resource&quot;, it attempts to create a new {@link
1173      * PropertyResourceBundle} instance from its contents.  If successful, this
1174      * instance becomes the &lt;em&gt;result resource bundle&lt;/em&gt;.  &lt;/ul&gt;
1175      *
1176      * &lt;p&gt;This continues until a result resource bundle is instantiated or the
1177      * list of candidate bundle names is exhausted.  If no matching resource
1178      * bundle is found, the default control&#39;s {@link Control#getFallbackLocale
1179      * getFallbackLocale} method is called, which returns the current default
1180      * locale.  A new sequence of candidate locale names is generated using this
1181      * locale and searched again, as above.
1182      *
1183      * &lt;p&gt;If still no result bundle is found, the base name alone is looked up. If
<span class="line-modified">1184      * this still fails, a {@code MissingResourceException} is thrown.</span>
1185      *
1186      * &lt;p&gt;&lt;a id=&quot;parent_chain&quot;&gt; Once a result resource bundle has been found,
1187      * its &lt;em&gt;parent chain&lt;/em&gt; is instantiated&lt;/a&gt;.  If the result bundle already
1188      * has a parent (perhaps because it was returned from a cache) the chain is
1189      * complete.
1190      *
<span class="line-modified">1191      * &lt;p&gt;Otherwise, {@code getBundle} examines the remainder of the</span>
1192      * candidate locale list that was used during the pass that generated the
1193      * result resource bundle.  (As before, candidate bundle names where the
1194      * final component is an empty string are omitted.)  When it comes to the
1195      * end of the candidate list, it tries the plain bundle name.  With each of the
1196      * candidate bundle names it attempts to instantiate a resource bundle (first
1197      * looking for a class and then a properties file, as described above).
1198      *
1199      * &lt;p&gt;Whenever it succeeds, it calls the previously instantiated resource
1200      * bundle&#39;s {@link #setParent(java.util.ResourceBundle) setParent} method
1201      * with the new resource bundle.  This continues until the list of names
1202      * is exhausted or the current bundle already has a non-null parent.
1203      *
1204      * &lt;p&gt;Once the parent chain is complete, the bundle is returned.
1205      *
<span class="line-modified">1206      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; {@code getBundle} caches instantiated resource</span>
1207      * bundles and might return the same resource bundle instance multiple times.
1208      *
<span class="line-modified">1209      * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;The {@code baseName} argument should be a fully</span>
1210      * qualified class name. However, for compatibility with earlier versions,
1211      * Java SE Runtime Environments do not verify this, and so it is
<span class="line-modified">1212      * possible to access {@code PropertyResourceBundle}s by specifying a</span>
1213      * path name (using &quot;/&quot;) instead of a fully qualified class name (using
1214      * &quot;.&quot;).
1215      *
1216      * &lt;p&gt;&lt;a id=&quot;default_behavior_example&quot;&gt;
1217      * &lt;strong&gt;Example:&lt;/strong&gt;&lt;/a&gt;
1218      * &lt;p&gt;
1219      * The following class and property files are provided:
1220      * &lt;ul&gt;
1221      *     &lt;li&gt;MyResources.class
1222      *     &lt;li&gt;MyResources.properties
1223      *     &lt;li&gt;MyResources_fr.properties
1224      *     &lt;li&gt;MyResources_fr_CH.class
1225      *     &lt;li&gt;MyResources_fr_CH.properties
1226      *     &lt;li&gt;MyResources_en.properties
1227      *     &lt;li&gt;MyResources_es_ES.class
1228      * &lt;/ul&gt;
1229      *
1230      * The contents of all files are valid (that is, public non-abstract
<span class="line-modified">1231      * subclasses of {@code ResourceBundle} for the &quot;.class&quot; files,</span>
1232      * syntactically correct &quot;.properties&quot; files).  The default locale is
<span class="line-modified">1233      * {@code Locale(&quot;en&quot;, &quot;GB&quot;)}.</span>
1234      *
<span class="line-modified">1235      * &lt;p&gt;Calling {@code getBundle} with the locale arguments below will</span>
1236      * instantiate resource bundles as follows:
1237      *
1238      * &lt;table class=&quot;striped&quot;&gt;
1239      * &lt;caption style=&quot;display:none&quot;&gt;getBundle() locale to resource bundle mapping&lt;/caption&gt;
1240      * &lt;thead&gt;
1241      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Locale&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Resource bundle&lt;/th&gt;&lt;/tr&gt;
1242      * &lt;/thead&gt;
1243      * &lt;tbody&gt;
1244      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;fr&quot;, &quot;CH&quot;)&lt;/th&gt;&lt;td&gt;MyResources_fr_CH.class, parent MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1245      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;fr&quot;, &quot;FR&quot;)&lt;/th&gt;&lt;td&gt;MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1246      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/th&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1247      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;en&quot;, &quot;US&quot;)&lt;/th&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1248      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;es&quot;, &quot;ES&quot;)&lt;/th&gt;&lt;td&gt;MyResources_es_ES.class, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
1249      * &lt;/tbody&gt;
1250      * &lt;/table&gt;
1251      *
1252      * &lt;p&gt;The file MyResources_fr_CH.properties is never used because it is
1253      * hidden by the MyResources_fr_CH.class. Likewise, MyResources.properties
1254      * is also hidden by MyResources.class.
1255      *
1256      * @apiNote If the caller module is a named module and the given
1257      * {@code loader} is the caller module&#39;s class loader, this method is
1258      * equivalent to {@code getBundle(baseName, locale)}; otherwise, it may not
1259      * find resource bundles from named modules.
1260      * Use {@link #getBundle(String, Locale, Module)} to load resource bundles
1261      * on behalf on a specific module instead.
1262      *
1263      * @param baseName the base name of the resource bundle, a fully qualified class name
1264      * @param locale the locale for which a resource bundle is desired
1265      * @param loader the class loader from which to load the resource bundle
1266      * @return a resource bundle for the given base name and locale
<span class="line-modified">1267      * @throws    java.lang.NullPointerException</span>
<span class="line-modified">1268      *        if {@code baseName}, {@code locale}, or {@code loader} is {@code null}</span>
<span class="line-modified">1269      * @throws    MissingResourceException</span>
1270      *        if no resource bundle for the specified base name can be found
1271      * @since 1.2
1272      * @revised 9
1273      * @spec JPMS
1274      * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
1275      */
1276     @CallerSensitive
1277     public static ResourceBundle getBundle(String baseName, Locale locale,
1278                                            ClassLoader loader)
1279     {
1280         if (loader == null) {
1281             throw new NullPointerException();
1282         }
1283         Class&lt;?&gt; caller = Reflection.getCallerClass();
1284         return getBundleImpl(baseName, locale, caller, loader, getDefaultControl(caller, baseName));
1285     }
1286 
1287     /**
1288      * Returns a resource bundle using the specified base name, target
1289      * locale, class loader and control. Unlike the {@link
1290      * #getBundle(String, Locale, ClassLoader) getBundle}
1291      * factory methods with no {@code control} argument, the given
<span class="line-modified">1292      * {@code control} specifies how to locate and instantiate resource</span>
1293      * bundles. Conceptually, the bundle loading process with the given
<span class="line-modified">1294      * {@code control} is performed in the following steps.</span>
1295      *
1296      * &lt;ol&gt;
1297      * &lt;li&gt;This factory method looks up the resource bundle in the cache for
<span class="line-modified">1298      * the specified {@code baseName}, {@code targetLocale} and</span>
<span class="line-modified">1299      * {@code loader}.  If the requested resource bundle instance is</span>
1300      * found in the cache and the time-to-live periods of the instance and
1301      * all of its parent instances have not expired, the instance is returned
1302      * to the caller. Otherwise, this factory method proceeds with the
1303      * loading process below.&lt;/li&gt;
1304      *
1305      * &lt;li&gt;The {@link ResourceBundle.Control#getFormats(String)
1306      * control.getFormats} method is called to get resource bundle formats
1307      * to produce bundle or resource names. The strings
<span class="line-modified">1308      * {@code &quot;java.class&quot;} and {@code &quot;java.properties&quot;}</span>
1309      * designate class-based and {@linkplain PropertyResourceBundle
1310      * property}-based resource bundles, respectively. Other strings
<span class="line-modified">1311      * starting with {@code &quot;java.&quot;} are reserved for future extensions</span>
1312      * and must not be used for application-defined formats. Other strings
1313      * designate application-defined formats.&lt;/li&gt;
1314      *
1315      * &lt;li&gt;The {@link ResourceBundle.Control#getCandidateLocales(String,
1316      * Locale) control.getCandidateLocales} method is called with the target
<span class="line-modified">1317      * locale to get a list of &lt;em&gt;candidate {@code Locale}s&lt;/em&gt; for</span>
1318      * which resource bundles are searched.&lt;/li&gt;
1319      *
1320      * &lt;li&gt;The {@link ResourceBundle.Control#newBundle(String, Locale,
1321      * String, ClassLoader, boolean) control.newBundle} method is called to
<span class="line-modified">1322      * instantiate a {@code ResourceBundle} for the base bundle name, a</span>
1323      * candidate locale, and a format. (Refer to the note on the cache
1324      * lookup below.) This step is iterated over all combinations of the
<span class="line-modified">1325      * candidate locales and formats until the {@code newBundle} method</span>
<span class="line-modified">1326      * returns a {@code ResourceBundle} instance or the iteration has</span>
1327      * used up all the combinations. For example, if the candidate locales
<span class="line-modified">1328      * are {@code Locale(&quot;de&quot;, &quot;DE&quot;)}, {@code Locale(&quot;de&quot;)} and</span>
<span class="line-modified">1329      * {@code Locale(&quot;&quot;)} and the formats are {@code &quot;java.class&quot;}</span>
<span class="line-modified">1330      * and {@code &quot;java.properties&quot;}, then the following is the</span>
1331      * sequence of locale-format combinations to be used to call
<span class="line-modified">1332      * {@code control.newBundle}.</span>
1333      *
1334      * &lt;table class=striped style=&quot;width: 50%; text-align: left; margin-left: 40px;&quot;&gt;
1335      * &lt;caption style=&quot;display:none&quot;&gt;locale-format combinations for newBundle&lt;/caption&gt;
1336      * &lt;thead&gt;
1337      * &lt;tr&gt;
1338      * &lt;th scope=&quot;col&quot;&gt;Index&lt;/th&gt;
<span class="line-modified">1339      * &lt;th scope=&quot;col&quot;&gt;{@code Locale}&lt;/th&gt;</span>
<span class="line-modified">1340      * &lt;th scope=&quot;col&quot;&gt;{@code format}&lt;/th&gt;</span>
1341      * &lt;/tr&gt;
1342      * &lt;/thead&gt;
1343      * &lt;tbody&gt;
1344      * &lt;tr&gt;
1345      * &lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
<span class="line-modified">1346      * &lt;td&gt;{@code Locale(&quot;de&quot;, &quot;DE&quot;)}&lt;/td&gt;</span>
<span class="line-modified">1347      * &lt;td&gt;{@code java.class}&lt;/td&gt;</span>
1348      * &lt;/tr&gt;
1349      * &lt;tr&gt;
1350      * &lt;th scope=&quot;row&quot;&gt;2&lt;/th&gt;
<span class="line-modified">1351      * &lt;td&gt;{@code Locale(&quot;de&quot;, &quot;DE&quot;)}&lt;/td&gt;</span>
<span class="line-modified">1352      * &lt;td&gt;{@code java.properties}&lt;/td&gt;</span>
1353      * &lt;/tr&gt;
1354      * &lt;tr&gt;
1355      * &lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
<span class="line-modified">1356      * &lt;td&gt;{@code Locale(&quot;de&quot;)}&lt;/td&gt;</span>
<span class="line-modified">1357      * &lt;td&gt;{@code java.class}&lt;/td&gt;</span>
1358      * &lt;/tr&gt;
1359      * &lt;tr&gt;
1360      * &lt;th scope=&quot;row&quot;&gt;4&lt;/th&gt;
<span class="line-modified">1361      * &lt;td&gt;{@code Locale(&quot;de&quot;)}&lt;/td&gt;</span>
<span class="line-modified">1362      * &lt;td&gt;{@code java.properties}&lt;/td&gt;</span>
1363      * &lt;/tr&gt;
1364      * &lt;tr&gt;
1365      * &lt;th scope=&quot;row&quot;&gt;5&lt;/th&gt;
<span class="line-modified">1366      * &lt;td&gt;{@code Locale(&quot;&quot;)}&lt;/td&gt;</span>
<span class="line-modified">1367      * &lt;td&gt;{@code java.class}&lt;/td&gt;</span>
1368      * &lt;/tr&gt;
1369      * &lt;tr&gt;
1370      * &lt;th scope=&quot;row&quot;&gt;6&lt;/th&gt;
<span class="line-modified">1371      * &lt;td&gt;{@code Locale(&quot;&quot;)}&lt;/td&gt;</span>
<span class="line-modified">1372      * &lt;td&gt;{@code java.properties}&lt;/td&gt;</span>
1373      * &lt;/tr&gt;
1374      * &lt;/tbody&gt;
1375      * &lt;/table&gt;
1376      * &lt;/li&gt;
1377      *
1378      * &lt;li&gt;If the previous step has found no resource bundle, proceed to
1379      * Step 6. If a bundle has been found that is a base bundle (a bundle
<span class="line-modified">1380      * for {@code Locale(&quot;&quot;)}), and the candidate locale list only contained</span>
<span class="line-modified">1381      * {@code Locale(&quot;&quot;)}, return the bundle to the caller. If a bundle</span>
1382      * has been found that is a base bundle, but the candidate locale list
1383      * contained locales other than Locale(&quot;&quot;), put the bundle on hold and
1384      * proceed to Step 6. If a bundle has been found that is not a base
1385      * bundle, proceed to Step 7.&lt;/li&gt;
1386      *
1387      * &lt;li&gt;The {@link ResourceBundle.Control#getFallbackLocale(String,
1388      * Locale) control.getFallbackLocale} method is called to get a fallback
1389      * locale (alternative to the current target locale) to try further
1390      * finding a resource bundle. If the method returns a non-null locale,
1391      * it becomes the next target locale and the loading process starts over
1392      * from Step 3. Otherwise, if a base bundle was found and put on hold in
1393      * a previous Step 5, it is returned to the caller now. Otherwise, a
1394      * MissingResourceException is thrown.&lt;/li&gt;
1395      *
1396      * &lt;li&gt;At this point, we have found a resource bundle that&#39;s not the
1397      * base bundle. If this bundle set its parent during its instantiation,
1398      * it is returned to the caller. Otherwise, its &lt;a
1399      * href=&quot;./ResourceBundle.html#parent_chain&quot;&gt;parent chain&lt;/a&gt; is
1400      * instantiated based on the list of candidate locales from which it was
1401      * found. Finally, the bundle is returned to the caller.&lt;/li&gt;
1402      * &lt;/ol&gt;
1403      *
1404      * &lt;p&gt;During the resource bundle loading process above, this factory
1405      * method looks up the cache before calling the {@link
1406      * Control#newBundle(String, Locale, String, ClassLoader, boolean)
1407      * control.newBundle} method.  If the time-to-live period of the
1408      * resource bundle found in the cache has expired, the factory method
1409      * calls the {@link ResourceBundle.Control#needsReload(String, Locale,
1410      * String, ClassLoader, ResourceBundle, long) control.needsReload}
1411      * method to determine whether the resource bundle needs to be reloaded.
1412      * If reloading is required, the factory method calls
<span class="line-modified">1413      * {@code control.newBundle} to reload the resource bundle.  If</span>
<span class="line-modified">1414      * {@code control.newBundle} returns {@code null}, the factory</span>
1415      * method puts a dummy resource bundle in the cache as a mark of
1416      * nonexistent resource bundles in order to avoid lookup overhead for
1417      * subsequent requests. Such dummy resource bundles are under the same
<span class="line-modified">1418      * expiration control as specified by {@code control}.</span>
1419      *
1420      * &lt;p&gt;All resource bundles loaded are cached by default. Refer to
1421      * {@link Control#getTimeToLive(String,Locale)
1422      * control.getTimeToLive} for details.
1423      *
1424      * &lt;p&gt;The following is an example of the bundle loading process with the
<span class="line-modified">1425      * default {@code ResourceBundle.Control} implementation.</span>
1426      *
1427      * &lt;p&gt;Conditions:
1428      * &lt;ul&gt;
<span class="line-modified">1429      * &lt;li&gt;Base bundle name: {@code foo.bar.Messages}</span>
<span class="line-modified">1430      * &lt;li&gt;Requested {@code Locale}: {@link Locale#ITALY}&lt;/li&gt;</span>
<span class="line-modified">1431      * &lt;li&gt;Default {@code Locale}: {@link Locale#FRENCH}&lt;/li&gt;</span>
1432      * &lt;li&gt;Available resource bundles:
<span class="line-modified">1433      * {@code foo/bar/Messages_fr.properties} and</span>
<span class="line-modified">1434      * {@code foo/bar/Messages.properties}&lt;/li&gt;</span>
1435      * &lt;/ul&gt;
1436      *
<span class="line-modified">1437      * &lt;p&gt;First, {@code getBundle} tries loading a resource bundle in</span>
1438      * the following sequence.
1439      *
1440      * &lt;ul&gt;
<span class="line-modified">1441      * &lt;li&gt;class {@code foo.bar.Messages_it_IT}</span>
<span class="line-modified">1442      * &lt;li&gt;file {@code foo/bar/Messages_it_IT.properties}</span>
<span class="line-modified">1443      * &lt;li&gt;class {@code foo.bar.Messages_it}&lt;/li&gt;</span>
<span class="line-modified">1444      * &lt;li&gt;file {@code foo/bar/Messages_it.properties}&lt;/li&gt;</span>
<span class="line-modified">1445      * &lt;li&gt;class {@code foo.bar.Messages}&lt;/li&gt;</span>
<span class="line-modified">1446      * &lt;li&gt;file {@code foo/bar/Messages.properties}&lt;/li&gt;</span>
1447      * &lt;/ul&gt;
1448      *
<span class="line-modified">1449      * &lt;p&gt;At this point, {@code getBundle} finds</span>
<span class="line-modified">1450      * {@code foo/bar/Messages.properties}, which is put on hold</span>
<span class="line-modified">1451      * because it&#39;s the base bundle.  {@code getBundle} calls {@link</span>
1452      * Control#getFallbackLocale(String, Locale)
1453      * control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)} which
<span class="line-modified">1454      * returns {@code Locale.FRENCH}. Next, {@code getBundle}</span>
1455      * tries loading a bundle in the following sequence.
1456      *
1457      * &lt;ul&gt;
<span class="line-modified">1458      * &lt;li&gt;class {@code foo.bar.Messages_fr}&lt;/li&gt;</span>
<span class="line-modified">1459      * &lt;li&gt;file {@code foo/bar/Messages_fr.properties}&lt;/li&gt;</span>
<span class="line-modified">1460      * &lt;li&gt;class {@code foo.bar.Messages}&lt;/li&gt;</span>
<span class="line-modified">1461      * &lt;li&gt;file {@code foo/bar/Messages.properties}&lt;/li&gt;</span>
1462      * &lt;/ul&gt;
1463      *
<span class="line-modified">1464      * &lt;p&gt;{@code getBundle} finds</span>
<span class="line-modified">1465      * {@code foo/bar/Messages_fr.properties} and creates a</span>
<span class="line-modified">1466      * {@code ResourceBundle} instance. Then, {@code getBundle}</span>
1467      * sets up its parent chain from the list of the candidate locales.  Only
<span class="line-modified">1468      * {@code foo/bar/Messages.properties} is found in the list and</span>
<span class="line-modified">1469      * {@code getBundle} creates a {@code ResourceBundle} instance</span>
1470      * that becomes the parent of the instance for
<span class="line-modified">1471      * {@code foo/bar/Messages_fr.properties}.</span>
1472      *
1473      * @param baseName
1474      *        the base name of the resource bundle, a fully qualified
1475      *        class name
1476      * @param targetLocale
1477      *        the locale for which a resource bundle is desired
1478      * @param loader
1479      *        the class loader from which to load the resource bundle
1480      * @param control
1481      *        the control which gives information for the resource
1482      *        bundle loading process
1483      * @return a resource bundle for the given base name and locale
1484      * @throws NullPointerException
<span class="line-modified">1485      *         if {@code baseName}, {@code targetLocale},</span>
<span class="line-modified">1486      *         {@code loader}, or {@code control} is</span>
<span class="line-modified">1487      *         {@code null}</span>
1488      * @throws MissingResourceException
1489      *         if no resource bundle for the specified base name can be found
1490      * @throws IllegalArgumentException
<span class="line-modified">1491      *         if the given {@code control} doesn&#39;t perform properly</span>
<span class="line-modified">1492      *         (e.g., {@code control.getCandidateLocales} returns null.)</span>
<span class="line-modified">1493      *         Note that validation of {@code control} is performed as</span>
1494      *         needed.
1495      * @throws UnsupportedOperationException
1496      *         if this method is called in a named module
1497      * @since 1.6
1498      * @revised 9
1499      * @spec JPMS
1500      */
1501     @CallerSensitive
1502     public static ResourceBundle getBundle(String baseName, Locale targetLocale,
1503                                            ClassLoader loader, Control control) {
1504         if (loader == null || control == null) {
1505             throw new NullPointerException();
1506         }
1507         Class&lt;?&gt; caller = Reflection.getCallerClass();
1508         checkNamedModule(caller);
1509         return getBundleImpl(baseName, targetLocale, caller, loader, control);
1510     }
1511 
1512     private static Control getDefaultControl(Class&lt;?&gt; caller, String baseName) {
1513         return getDefaultControl(caller.getModule(), baseName);
</pre>
<hr />
<pre>
1683                 }
1684             }
1685         }
1686 
1687         if (bundle == null) {
1688             if (baseBundle == null) {
1689                 throwMissingResourceException(baseName, locale, cacheKey.getCause());
1690             }
1691             bundle = baseBundle;
1692         }
1693 
1694         // keep callerModule and module reachable for as long as we are operating
1695         // with WeakReference(s) to them (in CacheKey)...
1696         Reference.reachabilityFence(callerModule);
1697         Reference.reachabilityFence(module);
1698 
1699         return bundle;
1700     }
1701 
1702     /**
<span class="line-modified">1703      * Checks if the given {@code List} is not null, not empty,</span>
1704      * not having null in its elements.
1705      */
1706     private static boolean checkList(List&lt;?&gt; a) {
1707         boolean valid = (a != null &amp;&amp; !a.isEmpty());
1708         if (valid) {
1709             int size = a.size();
1710             for (int i = 0; valid &amp;&amp; i &lt; size; i++) {
1711                 valid = (a.get(i) != null);
1712             }
1713         }
1714         return valid;
1715     }
1716 
1717     private static ResourceBundle findBundle(Module callerModule,
1718                                              Module module,
1719                                              CacheKey cacheKey,
1720                                              List&lt;Locale&gt; candidateLocales,
1721                                              List&lt;String&gt; formats,
1722                                              int index,
1723                                              Control control,
</pre>
<hr />
<pre>
2049                                                       Throwable cause) {
2050         // If the cause is a MissingResourceException, avoid creating
2051         // a long chain. (6355009)
2052         if (cause instanceof MissingResourceException) {
2053             cause = null;
2054         }
2055         throw new MissingResourceException(&quot;Can&#39;t find bundle for base name &quot;
2056                                            + baseName + &quot;, locale &quot; + locale,
2057                                            baseName + &quot;_&quot; + locale, // className
2058                                            &quot;&quot;,                      // key
2059                                            cause);
2060     }
2061 
2062     /**
2063      * Finds a bundle in the cache. Any expired bundles are marked as
2064      * `expired&#39; and removed from the cache upon return.
2065      *
2066      * @param cacheKey the key to look up the cache
2067      * @param control the Control to be used for the expiration control
2068      * @return the cached bundle, or null if the bundle is not found in the
<span class="line-modified">2069      * cache or its parent has expired. {@code bundle.expire} is true</span>
2070      * upon return if the bundle in the cache has expired.
2071      */
2072     private static ResourceBundle findBundleInCache(CacheKey cacheKey,
2073                                                     Control control) {
2074         BundleReference bundleRef = cacheList.get(cacheKey);
2075         if (bundleRef == null) {
2076             return null;
2077         }
2078         ResourceBundle bundle = bundleRef.get();
2079         if (bundle == null) {
2080             return null;
2081         }
2082         ResourceBundle p = bundle.parent;
2083         assert p != NONEXISTENT_BUNDLE;
2084         // If the parent has expired, then this one must also expire. We
2085         // check only the immediate parent because the actual loading is
2086         // done from the root (base) to leaf (child) and the purpose of
2087         // checking is to propagate expiration towards the leaf. For
2088         // example, if the requested locale is ja_JP_JP and there are
2089         // bundles for all of the candidates in the cache, we have a list,
</pre>
<hr />
<pre>
2233      * by the caller&#39;s module.
2234      *
2235      * @since 1.6
2236      * @revised 9
2237      * @spec JPMS
2238      * @see ResourceBundle.Control#getTimeToLive(String,Locale)
2239      */
2240     @CallerSensitive
2241     public static final void clearCache() {
2242         Class&lt;?&gt; caller = Reflection.getCallerClass();
2243         cacheList.keySet().removeIf(
2244             key -&gt; key.getCallerModule() == caller.getModule()
2245         );
2246     }
2247 
2248     /**
2249      * Removes all resource bundles from the cache that have been loaded
2250      * by the given class loader.
2251      *
2252      * @param loader the class loader
<span class="line-modified">2253      * @throws    NullPointerException if {@code loader} is null</span>
2254      * @since 1.6
2255      * @see ResourceBundle.Control#getTimeToLive(String,Locale)
2256      */
2257     public static final void clearCache(ClassLoader loader) {
2258         Objects.requireNonNull(loader);
2259         cacheList.keySet().removeIf(
2260             key -&gt; {
2261                 Module m;
2262                 return (m = key.getModule()) != null &amp;&amp;
2263                        getLoader(m) == loader;
2264             }
2265         );
2266     }
2267 
2268     /**
2269      * Gets an object for the given key from this resource bundle.
2270      * Returns null if this resource bundle does not contain an
2271      * object for the given key.
2272      *
2273      * @param key the key for the desired object
<span class="line-modified">2274      * @throws    NullPointerException if {@code key} is {@code null}</span>
2275      * @return the object for the given key, or null
2276      */
2277     protected abstract Object handleGetObject(String key);
2278 
2279     /**
2280      * Returns an enumeration of the keys.
2281      *
<span class="line-modified">2282      * @return an {@code Enumeration} of the keys contained in</span>
<span class="line-modified">2283      *         this {@code ResourceBundle} and its parent bundles.</span>
2284      */
2285     public abstract Enumeration&lt;String&gt; getKeys();
2286 
2287     /**
<span class="line-modified">2288      * Determines whether the given {@code key} is contained in</span>
<span class="line-modified">2289      * this {@code ResourceBundle} or its parent bundles.</span>
2290      *
2291      * @param key
<span class="line-modified">2292      *        the resource {@code key}</span>
<span class="line-modified">2293      * @return {@code true} if the given {@code key} is</span>
<span class="line-modified">2294      *        contained in this {@code ResourceBundle} or its</span>
<span class="line-modified">2295      *        parent bundles; {@code false} otherwise.</span>
<span class="line-modified">2296      * @throws    NullPointerException</span>
<span class="line-modified">2297      *         if {@code key} is {@code null}</span>
2298      * @since 1.6
2299      */
2300     public boolean containsKey(String key) {
2301         if (key == null) {
2302             throw new NullPointerException();
2303         }
2304         for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
2305             if (rb.handleKeySet().contains(key)) {
2306                 return true;
2307             }
2308         }
2309         return false;
2310     }
2311 
2312     /**
<span class="line-modified">2313      * Returns a {@code Set} of all keys contained in this</span>
<span class="line-modified">2314      * {@code ResourceBundle} and its parent bundles.</span>
2315      *
<span class="line-modified">2316      * @return a {@code Set} of all keys contained in this</span>
<span class="line-modified">2317      *         {@code ResourceBundle} and its parent bundles.</span>
2318      * @since 1.6
2319      */
2320     public Set&lt;String&gt; keySet() {
2321         Set&lt;String&gt; keys = new HashSet&lt;&gt;();
2322         for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
2323             keys.addAll(rb.handleKeySet());
2324         }
2325         return keys;
2326     }
2327 
2328     /**
<span class="line-modified">2329      * Returns a {@code Set} of the keys contained &lt;em&gt;only&lt;/em&gt;</span>
<span class="line-modified">2330      * in this {@code ResourceBundle}.</span>
2331      *
<span class="line-modified">2332      * &lt;p&gt;The default implementation returns a {@code Set} of the</span>
2333      * keys returned by the {@link #getKeys() getKeys} method except
2334      * for the ones for which the {@link #handleGetObject(String)
<span class="line-modified">2335      * handleGetObject} method returns {@code null}. Once the</span>
<span class="line-modified">2336      * {@code Set} has been created, the value is kept in this</span>
<span class="line-modified">2337      * {@code ResourceBundle} in order to avoid producing the</span>
<span class="line-modified">2338      * same {@code Set} in subsequent calls. Subclasses can</span>
2339      * override this method for faster handling.
2340      *
<span class="line-modified">2341      * @return a {@code Set} of the keys contained only in this</span>
<span class="line-modified">2342      *        {@code ResourceBundle}</span>
2343      * @since 1.6
2344      */
2345     protected Set&lt;String&gt; handleKeySet() {
2346         if (keySet == null) {
2347             synchronized (this) {
2348                 if (keySet == null) {
2349                     Set&lt;String&gt; keys = new HashSet&lt;&gt;();
2350                     Enumeration&lt;String&gt; enumKeys = getKeys();
2351                     while (enumKeys.hasMoreElements()) {
2352                         String key = enumKeys.nextElement();
2353                         if (handleGetObject(key) != null) {
2354                             keys.add(key);
2355                         }
2356                     }
2357                     keySet = keys;
2358                 }
2359             }
2360         }
2361         return keySet;
2362     }
2363 
2364 
2365 
2366     /**
<span class="line-modified">2367      * {@code ResourceBundle.Control} defines a set of callback methods</span>
2368      * that are invoked by the {@link ResourceBundle#getBundle(String,
2369      * Locale, ClassLoader, Control) ResourceBundle.getBundle} factory
2370      * methods during the bundle loading process. In other words, a
<span class="line-modified">2371      * {@code ResourceBundle.Control} collaborates with the factory</span>
2372      * methods for loading resource bundles. The default implementation of
2373      * the callback methods provides the information necessary for the
2374      * factory methods to perform the &lt;a
2375      * href=&quot;./ResourceBundle.html#default_behavior&quot;&gt;default behavior&lt;/a&gt;.
2376      *
2377      * &lt;p&gt; {@link ResourceBundle.Control} is designed for an application deployed
2378      * in an unnamed module, for example to support resource bundles in
2379      * non-standard formats or package localized resources in a non-traditional
2380      * convention. {@link ResourceBundleProvider} is the replacement for
2381      * {@code ResourceBundle.Control} when migrating to modules.
2382      * {@code UnsupportedOperationException} will be thrown when a factory
2383      * method that takes the {@code ResourceBundle.Control} parameter is called.
2384      *
2385      * &lt;p&gt;In addition to the callback methods, the {@link
2386      * #toBundleName(String, Locale) toBundleName} and {@link
2387      * #toResourceName(String, String) toResourceName} methods are defined
2388      * primarily for convenience in implementing the callback
<span class="line-modified">2389      * methods. However, the {@code toBundleName} method could be</span>
2390      * overridden to provide different conventions in the organization and
<span class="line-modified">2391      * packaging of localized resources.  The {@code toResourceName}</span>
<span class="line-modified">2392      * method is {@code final} to avoid use of wrong resource and class</span>
2393      * name separators.
2394      *
2395      * &lt;p&gt;Two factory methods, {@link #getControl(List)} and {@link
2396      * #getNoFallbackControl(List)}, provide
<span class="line-modified">2397      * {@code ResourceBundle.Control} instances that implement common</span>
2398      * variations of the default bundle loading process.
2399      *
2400      * &lt;p&gt;The formats returned by the {@link Control#getFormats(String)
2401      * getFormats} method and candidate locales returned by the {@link
2402      * ResourceBundle.Control#getCandidateLocales(String, Locale)
2403      * getCandidateLocales} method must be consistent in all
<span class="line-modified">2404      * {@code ResourceBundle.getBundle} invocations for the same base</span>
<span class="line-modified">2405      * bundle. Otherwise, the {@code ResourceBundle.getBundle} methods</span>
2406      * may return unintended bundles. For example, if only
<span class="line-modified">2407      * {@code &quot;java.class&quot;} is returned by the {@code getFormats}</span>
<span class="line-modified">2408      * method for the first call to {@code ResourceBundle.getBundle}</span>
<span class="line-modified">2409      * and only {@code &quot;java.properties&quot;} for the second call, then the</span>
2410      * second call will return the class-based one that has been cached
2411      * during the first call.
2412      *
<span class="line-modified">2413      * &lt;p&gt;A {@code ResourceBundle.Control} instance must be thread-safe</span>
2414      * if it&#39;s simultaneously used by multiple threads.
<span class="line-modified">2415      * {@code ResourceBundle.getBundle} does not synchronize to call</span>
<span class="line-modified">2416      * the {@code ResourceBundle.Control} methods. The default</span>
2417      * implementations of the methods are thread-safe.
2418      *
<span class="line-modified">2419      * &lt;p&gt;Applications can specify {@code ResourceBundle.Control}</span>
<span class="line-modified">2420      * instances returned by the {@code getControl} factory methods or</span>
<span class="line-modified">2421      * created from a subclass of {@code ResourceBundle.Control} to</span>
2422      * customize the bundle loading process. The following are examples of
2423      * changing the default bundle loading process.
2424      *
2425      * &lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;
2426      *
<span class="line-modified">2427      * &lt;p&gt;The following code lets {@code ResourceBundle.getBundle} look</span>
2428      * up only properties-based resources.
2429      *
2430      * &lt;pre&gt;
2431      * import java.util.*;
2432      * import static java.util.ResourceBundle.Control.*;
2433      * ...
2434      * ResourceBundle bundle =
2435      *   ResourceBundle.getBundle(&quot;MyResources&quot;, new Locale(&quot;fr&quot;, &quot;CH&quot;),
2436      *                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));
2437      * &lt;/pre&gt;
2438      *
2439      * Given the resource bundles in the &lt;a
2440      * href=&quot;./ResourceBundle.html#default_behavior_example&quot;&gt;example&lt;/a&gt; in
<span class="line-modified">2441      * the {@code ResourceBundle.getBundle} description, this</span>
<span class="line-modified">2442      * {@code ResourceBundle.getBundle} call loads</span>
<span class="line-modified">2443      * {@code MyResources_fr_CH.properties} whose parent is</span>
<span class="line-modified">2444      * {@code MyResources_fr.properties} whose parent is</span>
<span class="line-modified">2445      * {@code MyResources.properties}. ({@code MyResources_fr_CH.properties}</span>
<span class="line-modified">2446      * is not hidden, but {@code MyResources_fr_CH.class} is.)</span>
2447      *
2448      * &lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;
2449      *
2450      * &lt;p&gt;The following is an example of loading XML-based bundles
2451      * using {@link Properties#loadFromXML(java.io.InputStream)
2452      * Properties.loadFromXML}.
2453      *
2454      * &lt;pre&gt;
2455      * ResourceBundle rb = ResourceBundle.getBundle(&quot;Messages&quot;,
2456      *     new ResourceBundle.Control() {
2457      *         public List&amp;lt;String&amp;gt; getFormats(String baseName) {
2458      *             if (baseName == null)
2459      *                 throw new NullPointerException();
2460      *             return Arrays.asList(&quot;xml&quot;);
2461      *         }
2462      *         public ResourceBundle newBundle(String baseName,
2463      *                                         Locale locale,
2464      *                                         String format,
2465      *                                         ClassLoader loader,
2466      *                                         boolean reload)
</pre>
<hr />
<pre>
2512      *     }
2513      *     public Enumeration&amp;lt;String&amp;gt; getKeys() {
2514      *         ...
2515      *     }
2516      * }
2517      * &lt;/pre&gt;
2518      *
2519      * @apiNote {@code ResourceBundle.Control} is not supported
2520      * in named modules. If the {@code ResourceBundle.getBundle} method with
2521      * a {@code ResourceBundle.Control} is called in a named module, the method
2522      * will throw an {@link UnsupportedOperationException}. Any service providers
2523      * of {@link ResourceBundleControlProvider} are ignored in named modules.
2524      *
2525      * @since 1.6
2526      * @revised 9
2527      * @spec JPMS
2528      * @see java.util.spi.ResourceBundleProvider
2529      */
2530     public static class Control {
2531         /**
<span class="line-modified">2532          * The default format {@code List}, which contains the strings</span>
<span class="line-modified">2533          * {@code &quot;java.class&quot;} and {@code &quot;java.properties&quot;}, in</span>
<span class="line-modified">2534          * this order. This {@code List} is unmodifiable.</span>
2535          *
2536          * @see #getFormats(String)
2537          */
2538         public static final List&lt;String&gt; FORMAT_DEFAULT
2539             = List.of(&quot;java.class&quot;, &quot;java.properties&quot;);
2540 
2541         /**
<span class="line-modified">2542          * The class-only format {@code List} containing</span>
<span class="line-modified">2543          * {@code &quot;java.class&quot;}. This {@code List} is unmodifiable.</span>
2544          *
2545          * @see #getFormats(String)
2546          */
2547         public static final List&lt;String&gt; FORMAT_CLASS = List.of(&quot;java.class&quot;);
2548 
2549         /**
<span class="line-modified">2550          * The properties-only format {@code List} containing</span>
<span class="line-modified">2551          * {@code &quot;java.properties&quot;}. This {@code List} is unmodifiable.</span>
2552          *
2553          * @see #getFormats(String)
2554          */
2555         public static final List&lt;String&gt; FORMAT_PROPERTIES
2556             = List.of(&quot;java.properties&quot;);
2557 
2558         /**
2559          * The time-to-live constant for not caching loaded resource bundle
2560          * instances.
2561          *
2562          * @see #getTimeToLive(String, Locale)
2563          */
2564         public static final long TTL_DONT_CACHE = -1;
2565 
2566         /**
2567          * The time-to-live constant for disabling the expiration control
2568          * for loaded resource bundle instances in the cache.
2569          *
2570          * @see #getTimeToLive(String, Locale)
2571          */
2572         public static final long TTL_NO_EXPIRATION_CONTROL = -2;
2573 
2574         private static final Control INSTANCE = new Control();
2575 
2576         /**
2577          * Sole constructor. (For invocation by subclass constructors,
2578          * typically implicit.)
2579          */
2580         protected Control() {
2581         }
2582 
2583         /**
<span class="line-modified">2584          * Returns a {@code ResourceBundle.Control} in which the {@link</span>
2585          * #getFormats(String) getFormats} method returns the specified
<span class="line-modified">2586          * {@code formats}. The {@code formats} must be equal to</span>
2587          * one of {@link Control#FORMAT_PROPERTIES}, {@link
2588          * Control#FORMAT_CLASS} or {@link
<span class="line-modified">2589          * Control#FORMAT_DEFAULT}. {@code ResourceBundle.Control}</span>
2590          * instances returned by this method are singletons and thread-safe.
2591          *
2592          * &lt;p&gt;Specifying {@link Control#FORMAT_DEFAULT} is equivalent to
<span class="line-modified">2593          * instantiating the {@code ResourceBundle.Control} class,</span>
2594          * except that this method returns a singleton.
2595          *
2596          * @param formats
2597          *        the formats to be returned by the
<span class="line-modified">2598          *        {@code ResourceBundle.Control.getFormats} method</span>
<span class="line-modified">2599          * @return a {@code ResourceBundle.Control} supporting the</span>
<span class="line-modified">2600          *        specified {@code formats}</span>
<span class="line-modified">2601          * @throws    NullPointerException</span>
<span class="line-modified">2602          *        if {@code formats} is {@code null}</span>
<span class="line-modified">2603          * @throws    IllegalArgumentException</span>
<span class="line-modified">2604          *        if {@code formats} is unknown</span>
2605          */
2606         public static final Control getControl(List&lt;String&gt; formats) {
2607             if (formats.equals(Control.FORMAT_PROPERTIES)) {
2608                 return SingleFormatControl.PROPERTIES_ONLY;
2609             }
2610             if (formats.equals(Control.FORMAT_CLASS)) {
2611                 return SingleFormatControl.CLASS_ONLY;
2612             }
2613             if (formats.equals(Control.FORMAT_DEFAULT)) {
2614                 return Control.INSTANCE;
2615             }
2616             throw new IllegalArgumentException();
2617         }
2618 
2619         /**
<span class="line-modified">2620          * Returns a {@code ResourceBundle.Control} in which the {@link</span>
2621          * #getFormats(String) getFormats} method returns the specified
<span class="line-modified">2622          * {@code formats} and the {@link</span>
2623          * Control#getFallbackLocale(String, Locale) getFallbackLocale}
<span class="line-modified">2624          * method returns {@code null}. The {@code formats} must</span>
2625          * be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link
2626          * Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
<span class="line-modified">2627          * {@code ResourceBundle.Control} instances returned by this</span>
2628          * method are singletons and thread-safe.
2629          *
2630          * @param formats
2631          *        the formats to be returned by the
<span class="line-modified">2632          *        {@code ResourceBundle.Control.getFormats} method</span>
<span class="line-modified">2633          * @return a {@code ResourceBundle.Control} supporting the</span>
<span class="line-modified">2634          *        specified {@code formats} with no fallback</span>
<span class="line-modified">2635          *        {@code Locale} support</span>
<span class="line-modified">2636          * @throws    NullPointerException</span>
<span class="line-modified">2637          *        if {@code formats} is {@code null}</span>
<span class="line-modified">2638          * @throws    IllegalArgumentException</span>
<span class="line-modified">2639          *        if {@code formats} is unknown</span>
2640          */
2641         public static final Control getNoFallbackControl(List&lt;String&gt; formats) {
2642             if (formats.equals(Control.FORMAT_DEFAULT)) {
2643                 return NoFallbackControl.NO_FALLBACK;
2644             }
2645             if (formats.equals(Control.FORMAT_PROPERTIES)) {
2646                 return NoFallbackControl.PROPERTIES_ONLY_NO_FALLBACK;
2647             }
2648             if (formats.equals(Control.FORMAT_CLASS)) {
2649                 return NoFallbackControl.CLASS_ONLY_NO_FALLBACK;
2650             }
2651             throw new IllegalArgumentException();
2652         }
2653 
2654         /**
<span class="line-modified">2655          * Returns a {@code List} of {@code String}s containing</span>
2656          * formats to be used to load resource bundles for the given
<span class="line-modified">2657          * {@code baseName}. The {@code ResourceBundle.getBundle}</span>
2658          * factory method tries to load resource bundles with formats in the
2659          * order specified by the list. The list returned by this method
<span class="line-modified">2660          * must have at least one {@code String}. The predefined</span>
<span class="line-modified">2661          * formats are {@code &quot;java.class&quot;} for class-based resource</span>
<span class="line-modified">2662          * bundles and {@code &quot;java.properties&quot;} for {@linkplain</span>
2663          * PropertyResourceBundle properties-based} ones. Strings starting
<span class="line-modified">2664          * with {@code &quot;java.&quot;} are reserved for future extensions and</span>
2665          * must not be used by application-defined formats.
2666          *
2667          * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
<span class="line-modified">2668          * {@code List}.  However, the returned {@code List} must</span>
2669          * not be mutated after it has been returned by
<span class="line-modified">2670          * {@code getFormats}.</span>
2671          *
2672          * &lt;p&gt;The default implementation returns {@link #FORMAT_DEFAULT} so
<span class="line-modified">2673          * that the {@code ResourceBundle.getBundle} factory method</span>
2674          * looks up first class-based resource bundles, then
2675          * properties-based ones.
2676          *
2677          * @param baseName
2678          *        the base name of the resource bundle, a fully qualified class
2679          *        name
<span class="line-modified">2680          * @return a {@code List} of {@code String}s containing</span>
2681          *        formats for loading resource bundles.
<span class="line-modified">2682          * @throws    NullPointerException</span>
<span class="line-modified">2683          *        if {@code baseName} is null</span>
2684          * @see #FORMAT_DEFAULT
2685          * @see #FORMAT_CLASS
2686          * @see #FORMAT_PROPERTIES
2687          */
2688         public List&lt;String&gt; getFormats(String baseName) {
2689             if (baseName == null) {
2690                 throw new NullPointerException();
2691             }
2692             return FORMAT_DEFAULT;
2693         }
2694 
2695         /**
<span class="line-modified">2696          * Returns a {@code List} of {@code Locale}s as candidate</span>
<span class="line-modified">2697          * locales for {@code baseName} and {@code locale}. This</span>
<span class="line-modified">2698          * method is called by the {@code ResourceBundle.getBundle}</span>
2699          * factory method each time the factory method tries finding a
<span class="line-modified">2700          * resource bundle for a target {@code Locale}.</span>
2701          *
2702          * &lt;p&gt;The sequence of the candidate locales also corresponds to the
2703          * runtime resource lookup path (also known as the &lt;I&gt;parent
2704          * chain&lt;/I&gt;), if the corresponding resource bundles for the
2705          * candidate locales exist and their parents are not defined by
2706          * loaded resource bundles themselves.  The last element of the list
2707          * must be a {@linkplain Locale#ROOT root locale} if it is desired to
2708          * have the base bundle as the terminal of the parent chain.
2709          *
<span class="line-modified">2710          * &lt;p&gt;If the given locale is equal to {@code Locale.ROOT} (the</span>
<span class="line-modified">2711          * root locale), a {@code List} containing only the root</span>
<span class="line-modified">2712          * {@code Locale} must be returned. In this case, the</span>
<span class="line-modified">2713          * {@code ResourceBundle.getBundle} factory method loads only</span>
2714          * the base bundle as the resulting resource bundle.
2715          *
2716          * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
<span class="line-modified">2717          * {@code List}. However, the returned {@code List} must not</span>
2718          * be mutated after it has been returned by
<span class="line-modified">2719          * {@code getCandidateLocales}.</span>
2720          *
<span class="line-modified">2721          * &lt;p&gt;The default implementation returns a {@code List} containing</span>
<span class="line-modified">2722          * {@code Locale}s using the rules described below.  In the</span>
2723          * description below, &lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;V&lt;/em&gt;
2724          * respectively represent non-empty language, script, country, and
2725          * variant.  For example, [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] represents a
<span class="line-modified">2726          * {@code Locale} that has non-empty values only for language and</span>
2727          * country.  The form &lt;em&gt;L&lt;/em&gt;(&quot;xx&quot;) represents the (non-empty)
<span class="line-modified">2728          * language value is &quot;xx&quot;.  For all cases, {@code Locale}s whose</span>
2729          * final component values are empty strings are omitted.
2730          *
<span class="line-modified">2731          * &lt;ol&gt;&lt;li&gt;For an input {@code Locale} with an empty script value,</span>
<span class="line-modified">2732          * append candidate {@code Locale}s by omitting the final component</span>
2733          * one by one as below:
2734          *
2735          * &lt;ul&gt;
2736          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;] &lt;/li&gt;
2737          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] &lt;/li&gt;
2738          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;] &lt;/li&gt;
<span class="line-modified">2739          * &lt;li&gt; {@code Locale.ROOT} &lt;/li&gt;</span>
2740          * &lt;/ul&gt;&lt;/li&gt;
2741          *
<span class="line-modified">2742          * &lt;li&gt;For an input {@code Locale} with a non-empty script value,</span>
<span class="line-modified">2743          * append candidate {@code Locale}s by omitting the final component</span>
2744          * up to language, then append candidates generated from the
<span class="line-modified">2745          * {@code Locale} with country and variant restored:</span>
2746          *
2747          * &lt;ul&gt;
2748          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
2749          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
2750          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
2751          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
2752          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
2753          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<span class="line-modified">2754          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
2755          * &lt;/ul&gt;&lt;/li&gt;
2756          *
<span class="line-modified">2757          * &lt;li&gt;For an input {@code Locale} with a variant value consisting</span>
2758          * of multiple subtags separated by underscore, generate candidate
<span class="line-modified">2759          * {@code Locale}s by omitting the variant subtags one by one, then</span>
<span class="line-modified">2760          * insert them after every occurrence of {@code  Locale}s with the</span>
2761          * full variant value in the original list.  For example, if
2762          * the variant consists of two subtags &lt;em&gt;V1&lt;/em&gt; and &lt;em&gt;V2&lt;/em&gt;:
2763          *
2764          * &lt;ul&gt;
2765          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
2766          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
2767          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
2768          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
2769          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
2770          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
2771          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
2772          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<span class="line-modified">2773          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
2774          * &lt;/ul&gt;&lt;/li&gt;
2775          *
<span class="line-modified">2776          * &lt;li&gt;Special cases for Chinese.  When an input {@code Locale} has the</span>
2777          * language &quot;zh&quot; (Chinese) and an empty script value, either &quot;Hans&quot; (Simplified) or
2778          * &quot;Hant&quot; (Traditional) might be supplied, depending on the country.
2779          * When the country is &quot;CN&quot; (China) or &quot;SG&quot; (Singapore), &quot;Hans&quot; is supplied.
2780          * When the country is &quot;HK&quot; (Hong Kong SAR China), &quot;MO&quot; (Macau SAR China),
2781          * or &quot;TW&quot; (Taiwan), &quot;Hant&quot; is supplied.  For all other countries or when the country
2782          * is empty, no script is supplied.  For example, for &lt;code&gt;Locale(&quot;zh&quot;, &quot;CN&quot;)
2783          * &lt;/code&gt;, the candidate list will be:
2784          * &lt;ul&gt;
2785          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
2786          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;)]&lt;/li&gt;
2787          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
2788          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<span class="line-modified">2789          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
2790          * &lt;/ul&gt;
2791          *
<span class="line-modified">2792          * For {@code Locale(&quot;zh&quot;, &quot;TW&quot;)}, the candidate list will be:</span>
2793          * &lt;ul&gt;
2794          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
2795          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;)]&lt;/li&gt;
2796          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
2797          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<span class="line-modified">2798          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
2799          * &lt;/ul&gt;&lt;/li&gt;
2800          *
<span class="line-modified">2801          * &lt;li&gt;Special cases for Norwegian.  Both {@code Locale(&quot;no&quot;, &quot;NO&quot;,</span>
<span class="line-modified">2802          * &quot;NY&quot;)} and {@code Locale(&quot;nn&quot;, &quot;NO&quot;)} represent Norwegian</span>
2803          * Nynorsk.  When a locale&#39;s language is &quot;nn&quot;, the standard candidate
2804          * list is generated up to [&lt;em&gt;L&lt;/em&gt;(&quot;nn&quot;)], and then the following
2805          * candidates are added:
2806          *
2807          * &lt;ul&gt;&lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;NY&quot;)]&lt;/li&gt;
2808          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
2809          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<span class="line-modified">2810          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
2811          * &lt;/ul&gt;
2812          *
<span class="line-modified">2813          * If the locale is exactly {@code Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)}, it is first</span>
<span class="line-modified">2814          * converted to {@code Locale(&quot;nn&quot;, &quot;NO&quot;)} and then the above procedure is</span>
2815          * followed.
2816          *
2817          * &lt;p&gt;Also, Java treats the language &quot;no&quot; as a synonym of Norwegian
<span class="line-modified">2818          * Bokm&amp;#xE5;l &quot;nb&quot;.  Except for the single case {@code Locale(&quot;no&quot;,</span>
<span class="line-modified">2819          * &quot;NO&quot;, &quot;NY&quot;)} (handled above), when an input {@code Locale}</span>
<span class="line-modified">2820          * has language &quot;no&quot; or &quot;nb&quot;, candidate {@code Locale}s with</span>
2821          * language code &quot;no&quot; and &quot;nb&quot; are interleaved, first using the
2822          * requested language, then using its synonym. For example,
<span class="line-modified">2823          * {@code Locale(&quot;nb&quot;, &quot;NO&quot;, &quot;POSIX&quot;)} generates the following</span>
2824          * candidate list:
2825          *
2826          * &lt;ul&gt;
2827          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
2828          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
2829          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
2830          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;
2831          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;)]&lt;/li&gt;
2832          * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<span class="line-modified">2833          * &lt;li&gt; {@code Locale.ROOT}&lt;/li&gt;</span>
2834          * &lt;/ul&gt;
2835          *
<span class="line-modified">2836          * {@code Locale(&quot;no&quot;, &quot;NO&quot;, &quot;POSIX&quot;)} would generate the same list</span>
2837          * except that locales with &quot;no&quot; would appear before the corresponding
2838          * locales with &quot;nb&quot;.&lt;/li&gt;
2839          * &lt;/ol&gt;
2840          *
2841          * &lt;p&gt;The default implementation uses an {@link ArrayList} that
2842          * overriding implementations may modify before returning it to the
2843          * caller. However, a subclass must not modify it after it has
<span class="line-modified">2844          * been returned by {@code getCandidateLocales}.</span>
2845          *
<span class="line-modified">2846          * &lt;p&gt;For example, if the given {@code baseName} is &quot;Messages&quot;</span>
<span class="line-modified">2847          * and the given {@code locale} is</span>
2848          * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then a
<span class="line-modified">2849          * {@code List} of {@code Locale}s:</span>
2850          * &lt;pre&gt;
2851          *     Locale(&quot;ja&quot;, &quot;&quot;, &quot;XX&quot;)
2852          *     Locale(&quot;ja&quot;)
2853          *     Locale.ROOT
2854          * &lt;/pre&gt;
2855          * is returned. And if the resource bundles for the &quot;ja&quot; and
<span class="line-modified">2856          * &quot;&quot; {@code Locale}s are found, then the runtime resource</span>
2857          * lookup path (parent chain) is:
2858          * &lt;pre&gt;{@code
2859          *     Messages_ja -&gt; Messages
2860          * }&lt;/pre&gt;
2861          *
2862          * @param baseName
2863          *        the base name of the resource bundle, a fully
2864          *        qualified class name
2865          * @param locale
2866          *        the locale for which a resource bundle is desired
<span class="line-modified">2867          * @return a {@code List} of candidate</span>
<span class="line-modified">2868          *        {@code Locale}s for the given {@code locale}</span>
<span class="line-modified">2869          * @throws    NullPointerException</span>
<span class="line-modified">2870          *        if {@code baseName} or {@code locale} is</span>
<span class="line-modified">2871          *        {@code null}</span>
2872          */
2873         public List&lt;Locale&gt; getCandidateLocales(String baseName, Locale locale) {
2874             if (baseName == null) {
2875                 throw new NullPointerException();
2876             }
2877             return new ArrayList&lt;&gt;(CANDIDATES_CACHE.get(locale.getBaseLocale()));
2878         }
2879 
2880         private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();
2881 
2882         private static class CandidateListCache extends LocaleObjectCache&lt;BaseLocale, List&lt;Locale&gt;&gt; {
2883             protected List&lt;Locale&gt; createObject(BaseLocale base) {
2884                 String language = base.getLanguage();
2885                 String script = base.getScript();
2886                 String region = base.getRegion();
2887                 String variant = base.getVariant();
2888 
2889                 // Special handling for Norwegian
2890                 boolean isNorwegianBokmal = false;
2891                 boolean isNorwegianNynorsk = false;
</pre>
<hr />
<pre>
2986                     if (variants != null) {
2987                         for (String v : variants) {
2988                             list.add(Locale.getInstance(language, &quot;&quot;, region, v, null));
2989                         }
2990                     }
2991                     if (!region.isEmpty()) {
2992                         list.add(Locale.getInstance(language, &quot;&quot;, region, &quot;&quot;, null));
2993                     }
2994                 }
2995                 if (!language.isEmpty()) {
2996                     list.add(Locale.getInstance(language, &quot;&quot;, &quot;&quot;, &quot;&quot;, null));
2997                 }
2998                 // Add root locale at the end
2999                 list.add(Locale.ROOT);
3000 
3001                 return list;
3002             }
3003         }
3004 
3005         /**
<span class="line-modified">3006          * Returns a {@code Locale} to be used as a fallback locale for</span>
3007          * further resource bundle searches by the
<span class="line-modified">3008          * {@code ResourceBundle.getBundle} factory method. This method</span>
3009          * is called from the factory method every time when no resulting
<span class="line-modified">3010          * resource bundle has been found for {@code baseName} and</span>
<span class="line-modified">3011          * {@code locale}, where locale is either the parameter for</span>
<span class="line-modified">3012          * {@code ResourceBundle.getBundle} or the previous fallback</span>
3013          * locale returned by this method.
3014          *
<span class="line-modified">3015          * &lt;p&gt;The method returns {@code null} if no further fallback</span>
3016          * search is desired.
3017          *
3018          * &lt;p&gt;The default implementation returns the {@linkplain
<span class="line-modified">3019          * Locale#getDefault() default {@code Locale}} if the given</span>
<span class="line-modified">3020          * {@code locale} isn&#39;t the default one.  Otherwise,</span>
<span class="line-modified">3021          * {@code null} is returned.</span>
3022          *
3023          * @param baseName
3024          *        the base name of the resource bundle, a fully
3025          *        qualified class name for which
<span class="line-modified">3026          *        {@code ResourceBundle.getBundle} has been</span>
3027          *        unable to find any resource bundles (except for the
3028          *        base bundle)
3029          * @param locale
<span class="line-modified">3030          *        the {@code Locale} for which</span>
<span class="line-modified">3031          *        {@code ResourceBundle.getBundle} has been</span>
3032          *        unable to find any resource bundles (except for the
3033          *        base bundle)
<span class="line-modified">3034          * @return a {@code Locale} for the fallback search,</span>
<span class="line-modified">3035          *        or {@code null} if no further fallback search</span>
3036          *        is desired.
<span class="line-modified">3037          * @throws    NullPointerException</span>
<span class="line-modified">3038          *        if {@code baseName} or {@code locale}</span>
<span class="line-modified">3039          *        is {@code null}</span>
3040          */
3041         public Locale getFallbackLocale(String baseName, Locale locale) {
3042             if (baseName == null) {
3043                 throw new NullPointerException();
3044             }
3045             Locale defaultLocale = Locale.getDefault();
3046             return locale.equals(defaultLocale) ? null : defaultLocale;
3047         }
3048 
3049         /**
3050          * Instantiates a resource bundle for the given bundle name of the
3051          * given format and locale, using the given class loader if
<span class="line-modified">3052          * necessary. This method returns {@code null} if there is no</span>
3053          * resource bundle available for the given parameters. If a resource
3054          * bundle can&#39;t be instantiated due to an unexpected error, the
<span class="line-modified">3055          * error must be reported by throwing an {@code Error} or</span>
<span class="line-modified">3056          * {@code Exception} rather than simply returning</span>
<span class="line-modified">3057          * {@code null}.</span>
3058          *
<span class="line-modified">3059          * &lt;p&gt;If the {@code reload} flag is {@code true}, it</span>
3060          * indicates that this method is being called because the previously
3061          * loaded resource bundle has expired.
3062          *
3063          * @implSpec
3064          *
3065          * Resource bundles in named modules are subject to the encapsulation
3066          * rules specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
3067          * A resource bundle in a named module visible to the given class loader
3068          * is accessible when the package of the resource file corresponding
3069          * to the resource bundle is open unconditionally.
3070          *
3071          * &lt;p&gt;The default implementation instantiates a
<span class="line-modified">3072          * {@code ResourceBundle} as follows.</span>
3073          *
3074          * &lt;ul&gt;
3075          *
3076          * &lt;li&gt;The bundle name is obtained by calling {@link
3077          * #toBundleName(String, Locale) toBundleName(baseName,
3078          * locale)}.&lt;/li&gt;
3079          *
<span class="line-modified">3080          * &lt;li&gt;If {@code format} is {@code &quot;java.class&quot;}, the</span>
3081          * {@link Class} specified by the bundle name is loaded with the
3082          * given class loader. If the {@code Class} is found and accessible
<span class="line-modified">3083          * then the {@code ResourceBundle} is instantiated.  The</span>
3084          * resource bundle is accessible if the package of the bundle class file
3085          * is open unconditionally; otherwise, {@code IllegalAccessException}
3086          * will be thrown.
<span class="line-modified">3087          * Note that the {@code reload} flag is ignored for loading</span>
3088          * class-based resource bundles in this default implementation.
3089          * &lt;/li&gt;
3090          *
<span class="line-modified">3091          * &lt;li&gt;If {@code format} is {@code &quot;java.properties&quot;},</span>
3092          * {@link #toResourceName(String, String) toResourceName(bundlename,
3093          * &quot;properties&quot;)} is called to get the resource name.
<span class="line-modified">3094          * If {@code reload} is {@code true}, {@link</span>
3095          * ClassLoader#getResource(String) load.getResource} is called
3096          * to get a {@link URL} for creating a {@link
<span class="line-modified">3097          * URLConnection}. This {@code URLConnection} is used to</span>
3098          * {@linkplain URLConnection#setUseCaches(boolean) disable the
3099          * caches} of the underlying resource loading layers,
3100          * and to {@linkplain URLConnection#getInputStream() get an
<span class="line-modified">3101          * {@code InputStream}}.</span>
3102          * Otherwise, {@link ClassLoader#getResourceAsStream(String)
3103          * loader.getResourceAsStream} is called to get an {@link
3104          * InputStream}. Then, a {@link
3105          * PropertyResourceBundle} is constructed with the
<span class="line-modified">3106          * {@code InputStream}.&lt;/li&gt;</span>
3107          *
<span class="line-modified">3108          * &lt;li&gt;If {@code format} is neither {@code &quot;java.class&quot;}</span>
<span class="line-modified">3109          * nor {@code &quot;java.properties&quot;}, an</span>
<span class="line-modified">3110          * {@code IllegalArgumentException} is thrown.&lt;/li&gt;</span>
3111          *
3112          * &lt;/ul&gt;
3113          *
3114          * @param baseName
3115          *        the base bundle name of the resource bundle, a fully
3116          *        qualified class name
3117          * @param locale
3118          *        the locale for which the resource bundle should be
3119          *        instantiated
3120          * @param format
3121          *        the resource bundle format to be loaded
3122          * @param loader
<span class="line-modified">3123          *        the {@code ClassLoader} to use to load the bundle</span>
3124          * @param reload
<span class="line-modified">3125          *        the flag to indicate bundle reloading; {@code true}</span>
3126          *        if reloading an expired resource bundle,
<span class="line-modified">3127          *        {@code false} otherwise</span>
3128          * @return the resource bundle instance,
<span class="line-modified">3129          *        or {@code null} if none could be found.</span>
<span class="line-modified">3130          * @throws    NullPointerException</span>
<span class="line-modified">3131          *        if {@code bundleName}, {@code locale},</span>
<span class="line-modified">3132          *        {@code format}, or {@code loader} is</span>
<span class="line-modified">3133          *        {@code null}, or if {@code null} is returned by</span>
3134          *        {@link #toBundleName(String, Locale) toBundleName}
<span class="line-modified">3135          * @throws    IllegalArgumentException</span>
<span class="line-modified">3136          *        if {@code format} is unknown, or if the resource</span>
3137          *        found for the given parameters contains malformed data.
<span class="line-modified">3138          * @throws    ClassCastException</span>
<span class="line-modified">3139          *        if the loaded class cannot be cast to {@code ResourceBundle}</span>
<span class="line-modified">3140          * @throws    IllegalAccessException</span>
3141          *        if the class or its nullary constructor is not
3142          *        accessible.
<span class="line-modified">3143          * @throws    InstantiationException</span>
3144          *        if the instantiation of a class fails for some other
3145          *        reason.
<span class="line-modified">3146          * @throws    ExceptionInInitializerError</span>
3147          *        if the initialization provoked by this method fails.
<span class="line-modified">3148          * @throws    SecurityException</span>
3149          *        If a security manager is present and creation of new
3150          *        instances is denied. See {@link Class#newInstance()}
3151          *        for details.
<span class="line-modified">3152          * @throws    IOException</span>
3153          *        if an error occurred when reading resources using
3154          *        any I/O operations
3155          * @see java.util.spi.ResourceBundleProvider#getBundle(String, Locale)
3156          * @revised 9
3157          * @spec JPMS
3158          */
3159         public ResourceBundle newBundle(String baseName, Locale locale, String format,
3160                                         ClassLoader loader, boolean reload)
3161                     throws IllegalAccessException, InstantiationException, IOException {
3162             /*
3163              * Legacy mechanism to locate resource bundle in unnamed module only
3164              * that is visible to the given loader and accessible to the given caller.
3165              */
3166             String bundleName = toBundleName(baseName, locale);
3167             ResourceBundle bundle = null;
3168             if (format.equals(&quot;java.class&quot;)) {
3169                 try {
3170                     Class&lt;?&gt; c = loader.loadClass(bundleName);
3171                     // If the class isn&#39;t a ResourceBundle subclass, throw a
3172                     // ClassCastException.
</pre>
<hr />
<pre>
3239                         });
3240                 } catch (PrivilegedActionException e) {
3241                     throw (IOException) e.getException();
3242                 }
3243                 if (stream != null) {
3244                     try {
3245                         bundle = new PropertyResourceBundle(stream);
3246                     } finally {
3247                         stream.close();
3248                     }
3249                 }
3250             } else {
3251                 throw new IllegalArgumentException(&quot;unknown format: &quot; + format);
3252             }
3253             return bundle;
3254         }
3255 
3256         /**
3257          * Returns the time-to-live (TTL) value for resource bundles that
3258          * are loaded under this
<span class="line-modified">3259          * {@code ResourceBundle.Control}. Positive time-to-live values</span>
3260          * specify the number of milliseconds a bundle can remain in the
3261          * cache without being validated against the source data from which
3262          * it was constructed. The value 0 indicates that a bundle must be
3263          * validated each time it is retrieved from the cache. {@link
3264          * #TTL_DONT_CACHE} specifies that loaded resource bundles are not
3265          * put in the cache. {@link #TTL_NO_EXPIRATION_CONTROL} specifies
3266          * that loaded resource bundles are put in the cache with no
3267          * expiration control.
3268          *
3269          * &lt;p&gt;The expiration affects only the bundle loading process by the
<span class="line-modified">3270          * {@code ResourceBundle.getBundle} factory method.  That is,</span>
3271          * if the factory method finds a resource bundle in the cache that
3272          * has expired, the factory method calls the {@link
3273          * #needsReload(String, Locale, String, ClassLoader, ResourceBundle,
3274          * long) needsReload} method to determine whether the resource
<span class="line-modified">3275          * bundle needs to be reloaded. If {@code needsReload} returns</span>
<span class="line-modified">3276          * {@code true}, the cached resource bundle instance is removed</span>
3277          * from the cache. Otherwise, the instance stays in the cache,
3278          * updated with the new TTL value returned by this method.
3279          *
3280          * &lt;p&gt;All cached resource bundles are subject to removal from the
3281          * cache due to memory constraints of the runtime environment.
3282          * Returning a large positive value doesn&#39;t mean to lock loaded
3283          * resource bundles in the cache.
3284          *
3285          * &lt;p&gt;The default implementation returns {@link #TTL_NO_EXPIRATION_CONTROL}.
3286          *
3287          * @param baseName
3288          *        the base name of the resource bundle for which the
3289          *        expiration value is specified.
3290          * @param locale
3291          *        the locale of the resource bundle for which the
3292          *        expiration value is specified.
3293          * @return the time (0 or a positive millisecond offset from the
3294          *        cached time) to get loaded bundles expired in the cache,
3295          *        {@link #TTL_NO_EXPIRATION_CONTROL} to disable the
3296          *        expiration control, or {@link #TTL_DONT_CACHE} to disable
3297          *        caching.
<span class="line-modified">3298          * @throws    NullPointerException</span>
<span class="line-modified">3299          *        if {@code baseName} or {@code locale} is</span>
<span class="line-modified">3300          *        {@code null}</span>
3301          */
3302         public long getTimeToLive(String baseName, Locale locale) {
3303             if (baseName == null || locale == null) {
3304                 throw new NullPointerException();
3305             }
3306             return TTL_NO_EXPIRATION_CONTROL;
3307         }
3308 
3309         /**
<span class="line-modified">3310          * Determines if the expired {@code bundle} in the cache needs</span>
3311          * to be reloaded based on the loading time given by
<span class="line-modified">3312          * {@code loadTime} or some other criteria. The method returns</span>
<span class="line-modified">3313          * {@code true} if reloading is required; {@code false}</span>
<span class="line-modified">3314          * otherwise. {@code loadTime} is a millisecond offset since</span>
<span class="line-modified">3315          * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt; {@code Calendar}</span>
3316          * Epoch&lt;/a&gt;.
3317          *
3318          * &lt;p&gt;
<span class="line-modified">3319          * The calling {@code ResourceBundle.getBundle} factory method</span>
<span class="line-modified">3320          * calls this method on the {@code ResourceBundle.Control}</span>
3321          * instance used for its current invocation, not on the instance
3322          * used in the invocation that originally loaded the resource
3323          * bundle.
3324          *
<span class="line-modified">3325          * &lt;p&gt;The default implementation compares {@code loadTime} and</span>
3326          * the last modified time of the source data of the resource
3327          * bundle. If it&#39;s determined that the source data has been modified
<span class="line-modified">3328          * since {@code loadTime}, {@code true} is</span>
<span class="line-modified">3329          * returned. Otherwise, {@code false} is returned. This</span>
<span class="line-modified">3330          * implementation assumes that the given {@code format} is the</span>
3331          * same string as its file suffix if it&#39;s not one of the default
<span class="line-modified">3332          * formats, {@code &quot;java.class&quot;} or</span>
<span class="line-modified">3333          * {@code &quot;java.properties&quot;}.</span>
3334          *
3335          * @param baseName
3336          *        the base bundle name of the resource bundle, a
3337          *        fully qualified class name
3338          * @param locale
3339          *        the locale for which the resource bundle
3340          *        should be instantiated
3341          * @param format
3342          *        the resource bundle format to be loaded
3343          * @param loader
<span class="line-modified">3344          *        the {@code ClassLoader} to use to load the bundle</span>
3345          * @param bundle
3346          *        the resource bundle instance that has been expired
3347          *        in the cache
3348          * @param loadTime
<span class="line-modified">3349          *        the time when {@code bundle} was loaded and put</span>
3350          *        in the cache
<span class="line-modified">3351          * @return {@code true} if the expired bundle needs to be</span>
<span class="line-modified">3352          *        reloaded; {@code false} otherwise.</span>
<span class="line-modified">3353          * @throws    NullPointerException</span>
<span class="line-modified">3354          *        if {@code baseName}, {@code locale},</span>
<span class="line-modified">3355          *        {@code format}, {@code loader}, or</span>
<span class="line-modified">3356          *        {@code bundle} is {@code null}</span>
3357          */
3358         public boolean needsReload(String baseName, Locale locale,
3359                                    String format, ClassLoader loader,
3360                                    ResourceBundle bundle, long loadTime) {
3361             if (bundle == null) {
3362                 throw new NullPointerException();
3363             }
3364             if (format.equals(&quot;java.class&quot;) || format.equals(&quot;java.properties&quot;)) {
3365                 format = format.substring(5);
3366             }
3367             boolean result = false;
3368             try {
3369                 String resourceName = toResourceName0(toBundleName(baseName, locale), format);
3370                 if (resourceName == null) {
3371                     return result;
3372                 }
3373                 URL url = loader.getResource(resourceName);
3374                 if (url != null) {
3375                     long lastModified = 0;
3376                     URLConnection connection = url.openConnection();
</pre>
<hr />
<pre>
3383                                 lastModified = ent.getTime();
3384                                 if (lastModified == -1) {
3385                                     lastModified = 0;
3386                                 }
3387                             }
3388                         } else {
3389                             lastModified = connection.getLastModified();
3390                         }
3391                     }
3392                     result = lastModified &gt;= loadTime;
3393                 }
3394             } catch (NullPointerException npe) {
3395                 throw npe;
3396             } catch (Exception e) {
3397                 // ignore other exceptions
3398             }
3399             return result;
3400         }
3401 
3402         /**
<span class="line-modified">3403          * Converts the given {@code baseName} and {@code locale}</span>
3404          * to the bundle name. This method is called from the default
3405          * implementation of the {@link #newBundle(String, Locale, String,
3406          * ClassLoader, boolean) newBundle} and {@link #needsReload(String,
3407          * Locale, String, ClassLoader, ResourceBundle, long) needsReload}
3408          * methods.
3409          *
3410          * &lt;p&gt;This implementation returns the following value:
3411          * &lt;pre&gt;
3412          *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
3413          * &lt;/pre&gt;
<span class="line-modified">3414          * where {@code language}, {@code script}, {@code country},</span>
<span class="line-modified">3415          * and {@code variant} are the language, script, country, and variant</span>
<span class="line-modified">3416          * values of {@code locale}, respectively. Final component values that</span>
3417          * are empty Strings are omitted along with the preceding &#39;_&#39;.  When the
3418          * script is empty, the script value is omitted along with the preceding &#39;_&#39;.
<span class="line-modified">3419          * If all of the values are empty strings, then {@code baseName}</span>
3420          * is returned.
3421          *
<span class="line-modified">3422          * &lt;p&gt;For example, if {@code baseName} is</span>
<span class="line-modified">3423          * {@code &quot;baseName&quot;} and {@code locale} is</span>
3424          * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then
3425          * &lt;code&gt;&quot;baseName_ja_&amp;thinsp;_XX&quot;&lt;/code&gt; is returned. If the given
<span class="line-modified">3426          * locale is {@code Locale(&quot;en&quot;)}, then</span>
<span class="line-modified">3427          * {@code &quot;baseName_en&quot;} is returned.</span>
3428          *
3429          * &lt;p&gt;Overriding this method allows applications to use different
3430          * conventions in the organization and packaging of localized
3431          * resources.
3432          *
3433          * @param baseName
3434          *        the base name of the resource bundle, a fully
3435          *        qualified class name
3436          * @param locale
3437          *        the locale for which a resource bundle should be
3438          *        loaded
3439          * @return the bundle name for the resource bundle
<span class="line-modified">3440          * @throws    NullPointerException</span>
<span class="line-modified">3441          *        if {@code baseName} or {@code locale}</span>
<span class="line-modified">3442          *        is {@code null}</span>
3443          * @see java.util.spi.AbstractResourceBundleProvider#toBundleName(String, Locale)
3444          */
3445         public String toBundleName(String baseName, Locale locale) {
3446             if (locale == Locale.ROOT) {
3447                 return baseName;
3448             }
3449 
3450             String language = locale.getLanguage();
3451             String script = locale.getScript();
3452             String country = locale.getCountry();
3453             String variant = locale.getVariant();
3454 
3455             if (language == &quot;&quot; &amp;&amp; country == &quot;&quot; &amp;&amp; variant == &quot;&quot;) {
3456                 return baseName;
3457             }
3458 
3459             StringBuilder sb = new StringBuilder(baseName);
3460             sb.append(&#39;_&#39;);
3461             if (script != &quot;&quot;) {
3462                 if (variant != &quot;&quot;) {
</pre>
<hr />
<pre>
3478             return sb.toString();
3479 
3480         }
3481 
3482         /**
3483          * Converts the given {@code bundleName} to the form required
3484          * by the {@link ClassLoader#getResource ClassLoader.getResource}
3485          * method by replacing all occurrences of {@code &#39;.&#39;} in
3486          * {@code bundleName} with {@code &#39;/&#39;} and appending a
3487          * {@code &#39;.&#39;} and the given file {@code suffix}. For
3488          * example, if {@code bundleName} is
3489          * {@code &quot;foo.bar.MyResources_ja_JP&quot;} and {@code suffix}
3490          * is {@code &quot;properties&quot;}, then
3491          * {@code &quot;foo/bar/MyResources_ja_JP.properties&quot;} is returned.
3492          *
3493          * @param bundleName
3494          *        the bundle name
3495          * @param suffix
3496          *        the file type suffix
3497          * @return the converted resource name
<span class="line-modified">3498          * @throws    NullPointerException</span>
3499          *         if {@code bundleName} or {@code suffix}
3500          *         is {@code null}
3501          */
3502         public final String toResourceName(String bundleName, String suffix) {
3503             StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());
3504             sb.append(bundleName.replace(&#39;.&#39;, &#39;/&#39;)).append(&#39;.&#39;).append(suffix);
3505             return sb.toString();
3506         }
3507 
3508         private String toResourceName0(String bundleName, String suffix) {
3509             // application protocol check
3510             if (bundleName.contains(&quot;://&quot;)) {
3511                 return null;
3512             } else {
3513                 return toResourceName(bundleName, suffix);
3514             }
3515         }
3516     }
3517 
3518     @SuppressWarnings(&quot;unchecked&quot;)
</pre>
</td>
</tr>
</table>
<center><a href="RegularEnumSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Scanner.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
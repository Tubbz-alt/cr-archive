<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/concurrent/atomic/AtomicInteger.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  * This file is available under and governed by the GNU General Public
 27  * License version 2 only, as published by the Free Software Foundation.
 28  * However, the following notice accompanied the original version of this
 29  * file:
 30  *
 31  * Written by Doug Lea with assistance from members of JCP JSR-166
 32  * Expert Group and released to the public domain, as explained at
 33  * http://creativecommons.org/publicdomain/zero/1.0/
 34  */
 35 
 36 package java.util.concurrent.atomic;
 37 
 38 import java.lang.invoke.VarHandle;
 39 import java.util.function.IntBinaryOperator;
 40 import java.util.function.IntUnaryOperator;
 41 import jdk.internal.misc.Unsafe;
 42 
 43 /**
 44  * An {@code int} value that may be updated atomically.  See the
 45  * {@link VarHandle} specification for descriptions of the properties
 46  * of atomic accesses. An {@code AtomicInteger} is used in
 47  * applications such as atomically incremented counters, and cannot be
 48  * used as a replacement for an {@link java.lang.Integer}. However,
 49  * this class does extend {@code Number} to allow uniform access by
 50  * tools and utilities that deal with numerically-based classes.
 51  *
 52  * @since 1.5
 53  * @author Doug Lea
 54  */
 55 public class AtomicInteger extends Number implements java.io.Serializable {
 56     private static final long serialVersionUID = 6214790243416807050L;
 57 
 58     /*
 59      * This class intended to be implemented using VarHandles, but there
 60      * are unresolved cyclic startup dependencies.
 61      */
 62     private static final Unsafe U = Unsafe.getUnsafe();
 63     private static final long VALUE
 64         = U.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);
 65 
 66     private volatile int value;
 67 
 68     /**
 69      * Creates a new AtomicInteger with the given initial value.
 70      *
 71      * @param initialValue the initial value
 72      */
 73     public AtomicInteger(int initialValue) {
 74         value = initialValue;
 75     }
 76 
 77     /**
 78      * Creates a new AtomicInteger with initial value {@code 0}.
 79      */
 80     public AtomicInteger() {
 81     }
 82 
 83     /**
 84      * Returns the current value,
 85      * with memory effects as specified by {@link VarHandle#getVolatile}.
 86      *
 87      * @return the current value
 88      */
 89     public final int get() {
 90         return value;
 91     }
 92 
 93     /**
 94      * Sets the value to {@code newValue},
 95      * with memory effects as specified by {@link VarHandle#setVolatile}.
 96      *
 97      * @param newValue the new value
 98      */
 99     public final void set(int newValue) {
100         value = newValue;
101     }
102 
103     /**
104      * Sets the value to {@code newValue},
105      * with memory effects as specified by {@link VarHandle#setRelease}.
106      *
107      * @param newValue the new value
108      * @since 1.6
109      */
110     public final void lazySet(int newValue) {
111         U.putIntRelease(this, VALUE, newValue);
112     }
113 
114     /**
115      * Atomically sets the value to {@code newValue} and returns the old value,
116      * with memory effects as specified by {@link VarHandle#getAndSet}.
117      *
118      * @param newValue the new value
119      * @return the previous value
120      */
121     public final int getAndSet(int newValue) {
122         return U.getAndSetInt(this, VALUE, newValue);
123     }
124 
125     /**
126      * Atomically sets the value to {@code newValue}
127      * if the current value {@code == expectedValue},
128      * with memory effects as specified by {@link VarHandle#compareAndSet}.
129      *
130      * @param expectedValue the expected value
131      * @param newValue the new value
132      * @return {@code true} if successful. False return indicates that
133      * the actual value was not equal to the expected value.
134      */
135     public final boolean compareAndSet(int expectedValue, int newValue) {
136         return U.compareAndSetInt(this, VALUE, expectedValue, newValue);
137     }
138 
139     /**
140      * Possibly atomically sets the value to {@code newValue}
141      * if the current value {@code == expectedValue},
142      * with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
143      *
144      * @deprecated This method has plain memory effects but the method
145      * name implies volatile memory effects (see methods such as
146      * {@link #compareAndExchange} and {@link #compareAndSet}).  To avoid
147      * confusion over plain or volatile memory effects it is recommended that
148      * the method {@link #weakCompareAndSetPlain} be used instead.
149      *
150      * @param expectedValue the expected value
151      * @param newValue the new value
152      * @return {@code true} if successful
153      * @see #weakCompareAndSetPlain
154      */
155     @Deprecated(since=&quot;9&quot;)
156     public final boolean weakCompareAndSet(int expectedValue, int newValue) {
157         return U.weakCompareAndSetIntPlain(this, VALUE, expectedValue, newValue);
158     }
159 
160     /**
161      * Possibly atomically sets the value to {@code newValue}
162      * if the current value {@code == expectedValue},
163      * with memory effects as specified by {@link VarHandle#weakCompareAndSetPlain}.
164      *
165      * @param expectedValue the expected value
166      * @param newValue the new value
167      * @return {@code true} if successful
168      * @since 9
169      */
170     public final boolean weakCompareAndSetPlain(int expectedValue, int newValue) {
171         return U.weakCompareAndSetIntPlain(this, VALUE, expectedValue, newValue);
172     }
173 
174     /**
175      * Atomically increments the current value,
176      * with memory effects as specified by {@link VarHandle#getAndAdd}.
177      *
178      * &lt;p&gt;Equivalent to {@code getAndAdd(1)}.
179      *
180      * @return the previous value
181      */
182     public final int getAndIncrement() {
183         return U.getAndAddInt(this, VALUE, 1);
184     }
185 
186     /**
187      * Atomically decrements the current value,
188      * with memory effects as specified by {@link VarHandle#getAndAdd}.
189      *
190      * &lt;p&gt;Equivalent to {@code getAndAdd(-1)}.
191      *
192      * @return the previous value
193      */
194     public final int getAndDecrement() {
195         return U.getAndAddInt(this, VALUE, -1);
196     }
197 
198     /**
199      * Atomically adds the given value to the current value,
200      * with memory effects as specified by {@link VarHandle#getAndAdd}.
201      *
202      * @param delta the value to add
203      * @return the previous value
204      */
205     public final int getAndAdd(int delta) {
206         return U.getAndAddInt(this, VALUE, delta);
207     }
208 
209     /**
210      * Atomically increments the current value,
211      * with memory effects as specified by {@link VarHandle#getAndAdd}.
212      *
213      * &lt;p&gt;Equivalent to {@code addAndGet(1)}.
214      *
215      * @return the updated value
216      */
217     public final int incrementAndGet() {
218         return U.getAndAddInt(this, VALUE, 1) + 1;
219     }
220 
221     /**
222      * Atomically decrements the current value,
223      * with memory effects as specified by {@link VarHandle#getAndAdd}.
224      *
225      * &lt;p&gt;Equivalent to {@code addAndGet(-1)}.
226      *
227      * @return the updated value
228      */
229     public final int decrementAndGet() {
230         return U.getAndAddInt(this, VALUE, -1) - 1;
231     }
232 
233     /**
234      * Atomically adds the given value to the current value,
235      * with memory effects as specified by {@link VarHandle#getAndAdd}.
236      *
237      * @param delta the value to add
238      * @return the updated value
239      */
240     public final int addAndGet(int delta) {
241         return U.getAndAddInt(this, VALUE, delta) + delta;
242     }
243 
244     /**
245      * Atomically updates (with memory effects as specified by {@link
246      * VarHandle#compareAndSet}) the current value with the results of
247      * applying the given function, returning the previous value. The
248      * function should be side-effect-free, since it may be re-applied
249      * when attempted updates fail due to contention among threads.
250      *
251      * @param updateFunction a side-effect-free function
252      * @return the previous value
253      * @since 1.8
254      */
255     public final int getAndUpdate(IntUnaryOperator updateFunction) {
256         int prev = get(), next = 0;
257         for (boolean haveNext = false;;) {
258             if (!haveNext)
259                 next = updateFunction.applyAsInt(prev);
260             if (weakCompareAndSetVolatile(prev, next))
261                 return prev;
262             haveNext = (prev == (prev = get()));
263         }
264     }
265 
266     /**
267      * Atomically updates (with memory effects as specified by {@link
268      * VarHandle#compareAndSet}) the current value with the results of
269      * applying the given function, returning the updated value. The
270      * function should be side-effect-free, since it may be re-applied
271      * when attempted updates fail due to contention among threads.
272      *
273      * @param updateFunction a side-effect-free function
274      * @return the updated value
275      * @since 1.8
276      */
277     public final int updateAndGet(IntUnaryOperator updateFunction) {
278         int prev = get(), next = 0;
279         for (boolean haveNext = false;;) {
280             if (!haveNext)
281                 next = updateFunction.applyAsInt(prev);
282             if (weakCompareAndSetVolatile(prev, next))
283                 return next;
284             haveNext = (prev == (prev = get()));
285         }
286     }
287 
288     /**
289      * Atomically updates (with memory effects as specified by {@link
290      * VarHandle#compareAndSet}) the current value with the results of
291      * applying the given function to the current and given values,
292      * returning the previous value. The function should be
293      * side-effect-free, since it may be re-applied when attempted
294      * updates fail due to contention among threads.  The function is
295      * applied with the current value as its first argument, and the
296      * given update as the second argument.
297      *
298      * @param x the update value
299      * @param accumulatorFunction a side-effect-free function of two arguments
300      * @return the previous value
301      * @since 1.8
302      */
303     public final int getAndAccumulate(int x,
304                                       IntBinaryOperator accumulatorFunction) {
305         int prev = get(), next = 0;
306         for (boolean haveNext = false;;) {
307             if (!haveNext)
308                 next = accumulatorFunction.applyAsInt(prev, x);
309             if (weakCompareAndSetVolatile(prev, next))
310                 return prev;
311             haveNext = (prev == (prev = get()));
312         }
313     }
314 
315     /**
316      * Atomically updates (with memory effects as specified by {@link
317      * VarHandle#compareAndSet}) the current value with the results of
318      * applying the given function to the current and given values,
319      * returning the updated value. The function should be
320      * side-effect-free, since it may be re-applied when attempted
321      * updates fail due to contention among threads.  The function is
322      * applied with the current value as its first argument, and the
323      * given update as the second argument.
324      *
325      * @param x the update value
326      * @param accumulatorFunction a side-effect-free function of two arguments
327      * @return the updated value
328      * @since 1.8
329      */
330     public final int accumulateAndGet(int x,
331                                       IntBinaryOperator accumulatorFunction) {
332         int prev = get(), next = 0;
333         for (boolean haveNext = false;;) {
334             if (!haveNext)
335                 next = accumulatorFunction.applyAsInt(prev, x);
336             if (weakCompareAndSetVolatile(prev, next))
337                 return next;
338             haveNext = (prev == (prev = get()));
339         }
340     }
341 
342     /**
343      * Returns the String representation of the current value.
344      * @return the String representation of the current value
345      */
346     public String toString() {
347         return Integer.toString(get());
348     }
349 
350     /**
351      * Returns the current value of this {@code AtomicInteger} as an
352      * {@code int},
353      * with memory effects as specified by {@link VarHandle#getVolatile}.
354      *
355      * Equivalent to {@link #get()}.
356      */
357     public int intValue() {
358         return get();
359     }
360 
361     /**
362      * Returns the current value of this {@code AtomicInteger} as a
363      * {@code long} after a widening primitive conversion,
364      * with memory effects as specified by {@link VarHandle#getVolatile}.
365      * @jls 5.1.2 Widening Primitive Conversion
366      */
367     public long longValue() {
368         return (long)get();
369     }
370 
371     /**
372      * Returns the current value of this {@code AtomicInteger} as a
373      * {@code float} after a widening primitive conversion,
374      * with memory effects as specified by {@link VarHandle#getVolatile}.
375      * @jls 5.1.2 Widening Primitive Conversion
376      */
377     public float floatValue() {
378         return (float)get();
379     }
380 
381     /**
382      * Returns the current value of this {@code AtomicInteger} as a
383      * {@code double} after a widening primitive conversion,
384      * with memory effects as specified by {@link VarHandle#getVolatile}.
385      * @jls 5.1.2 Widening Primitive Conversion
386      */
387     public double doubleValue() {
388         return (double)get();
389     }
390 
391     // jdk9
392 
393     /**
394      * Returns the current value, with memory semantics of reading as
395      * if the variable was declared non-{@code volatile}.
396      *
397      * @return the value
398      * @since 9
399      */
400     public final int getPlain() {
401         return U.getInt(this, VALUE);
402     }
403 
404     /**
405      * Sets the value to {@code newValue}, with memory semantics
406      * of setting as if the variable was declared non-{@code volatile}
407      * and non-{@code final}.
408      *
409      * @param newValue the new value
410      * @since 9
411      */
412     public final void setPlain(int newValue) {
413         U.putInt(this, VALUE, newValue);
414     }
415 
416     /**
417      * Returns the current value,
418      * with memory effects as specified by {@link VarHandle#getOpaque}.
419      *
420      * @return the value
421      * @since 9
422      */
423     public final int getOpaque() {
424         return U.getIntOpaque(this, VALUE);
425     }
426 
427     /**
428      * Sets the value to {@code newValue},
429      * with memory effects as specified by {@link VarHandle#setOpaque}.
430      *
431      * @param newValue the new value
432      * @since 9
433      */
434     public final void setOpaque(int newValue) {
435         U.putIntOpaque(this, VALUE, newValue);
436     }
437 
438     /**
439      * Returns the current value,
440      * with memory effects as specified by {@link VarHandle#getAcquire}.
441      *
442      * @return the value
443      * @since 9
444      */
445     public final int getAcquire() {
446         return U.getIntAcquire(this, VALUE);
447     }
448 
449     /**
450      * Sets the value to {@code newValue},
451      * with memory effects as specified by {@link VarHandle#setRelease}.
452      *
453      * @param newValue the new value
454      * @since 9
455      */
456     public final void setRelease(int newValue) {
457         U.putIntRelease(this, VALUE, newValue);
458     }
459 
460     /**
461      * Atomically sets the value to {@code newValue} if the current value,
462      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code == expectedValue},
463      * with memory effects as specified by
464      * {@link VarHandle#compareAndExchange}.
465      *
466      * @param expectedValue the expected value
467      * @param newValue the new value
468      * @return the witness value, which will be the same as the
469      * expected value if successful
470      * @since 9
471      */
472     public final int compareAndExchange(int expectedValue, int newValue) {
473         return U.compareAndExchangeInt(this, VALUE, expectedValue, newValue);
474     }
475 
476     /**
477      * Atomically sets the value to {@code newValue} if the current value,
478      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code == expectedValue},
479      * with memory effects as specified by
480      * {@link VarHandle#compareAndExchangeAcquire}.
481      *
482      * @param expectedValue the expected value
483      * @param newValue the new value
484      * @return the witness value, which will be the same as the
485      * expected value if successful
486      * @since 9
487      */
488     public final int compareAndExchangeAcquire(int expectedValue, int newValue) {
489         return U.compareAndExchangeIntAcquire(this, VALUE, expectedValue, newValue);
490     }
491 
492     /**
493      * Atomically sets the value to {@code newValue} if the current value,
494      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code == expectedValue},
495      * with memory effects as specified by
496      * {@link VarHandle#compareAndExchangeRelease}.
497      *
498      * @param expectedValue the expected value
499      * @param newValue the new value
500      * @return the witness value, which will be the same as the
501      * expected value if successful
502      * @since 9
503      */
504     public final int compareAndExchangeRelease(int expectedValue, int newValue) {
505         return U.compareAndExchangeIntRelease(this, VALUE, expectedValue, newValue);
506     }
507 
508     /**
509      * Possibly atomically sets the value to {@code newValue} if
510      * the current value {@code == expectedValue},
511      * with memory effects as specified by
512      * {@link VarHandle#weakCompareAndSet}.
513      *
514      * @param expectedValue the expected value
515      * @param newValue the new value
516      * @return {@code true} if successful
517      * @since 9
518      */
519     public final boolean weakCompareAndSetVolatile(int expectedValue, int newValue) {
520         return U.weakCompareAndSetInt(this, VALUE, expectedValue, newValue);
521     }
522 
523     /**
524      * Possibly atomically sets the value to {@code newValue} if
525      * the current value {@code == expectedValue},
526      * with memory effects as specified by
527      * {@link VarHandle#weakCompareAndSetAcquire}.
528      *
529      * @param expectedValue the expected value
530      * @param newValue the new value
531      * @return {@code true} if successful
532      * @since 9
533      */
534     public final boolean weakCompareAndSetAcquire(int expectedValue, int newValue) {
535         return U.weakCompareAndSetIntAcquire(this, VALUE, expectedValue, newValue);
536     }
537 
538     /**
539      * Possibly atomically sets the value to {@code newValue} if
540      * the current value {@code == expectedValue},
541      * with memory effects as specified by
542      * {@link VarHandle#weakCompareAndSetRelease}.
543      *
544      * @param expectedValue the expected value
545      * @param newValue the new value
546      * @return {@code true} if successful
547      * @since 9
548      */
549     public final boolean weakCompareAndSetRelease(int expectedValue, int newValue) {
550         return U.weakCompareAndSetIntRelease(this, VALUE, expectedValue, newValue);
551     }
552 
553 }
    </pre>
  </body>
</html>
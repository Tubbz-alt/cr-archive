<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/text/ChoiceFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CharacterIteratorFieldDelegate.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CollationElementIterator.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/ChoiceFormat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,12 ***</span>
  import java.io.IOException;
  import java.io.ObjectInputStream;
  import java.util.Arrays;
  
  /**
<span class="line-modified">!  * A &lt;code&gt;ChoiceFormat&lt;/code&gt; allows you to attach a format to a range of numbers.</span>
<span class="line-modified">!  * It is generally used in a &lt;code&gt;MessageFormat&lt;/code&gt; for handling plurals.</span>
   * The choice is specified with an ascending list of doubles, where each item
   * specifies a half-open interval up to the next item:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * X matches j if and only if limit[j] &amp;le; X &amp;lt; limit[j+1]
<span class="line-new-header">--- 42,12 ---</span>
  import java.io.IOException;
  import java.io.ObjectInputStream;
  import java.util.Arrays;
  
  /**
<span class="line-modified">!  * A {@code ChoiceFormat} allows you to attach a format to a range of numbers.</span>
<span class="line-modified">!  * It is generally used in a {@code MessageFormat} for handling plurals.</span>
   * The choice is specified with an ascending list of doubles, where each item
   * specifies a half-open interval up to the next item:
   * &lt;blockquote&gt;
   * &lt;pre&gt;
   * X matches j if and only if limit[j] &amp;le; X &amp;lt; limit[j+1]
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,29 ***</span>
   * in ascending order, the results of formatting will be incorrect.  ChoiceFormat
   * also accepts &lt;code&gt;&amp;#92;u221E&lt;/code&gt; as equivalent to infinity(INF).
   *
   * &lt;p&gt;
   * &lt;strong&gt;Note:&lt;/strong&gt;
<span class="line-modified">!  * &lt;code&gt;ChoiceFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;</span>
<span class="line-modified">!  * classes in that you create a &lt;code&gt;ChoiceFormat&lt;/code&gt; object with a</span>
<span class="line-modified">!  * constructor (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory</span>
<span class="line-modified">!  * method). The factory methods aren&#39;t necessary because &lt;code&gt;ChoiceFormat&lt;/code&gt;</span>
   * doesn&#39;t require any complex setup for a given locale. In fact,
<span class="line-modified">!  * &lt;code&gt;ChoiceFormat&lt;/code&gt; doesn&#39;t implement any locale specific behavior.</span>
   *
   * &lt;p&gt;
<span class="line-modified">!  * When creating a &lt;code&gt;ChoiceFormat&lt;/code&gt;, you must specify an array of formats</span>
   * and an array of limits. The length of these arrays must be the same.
   * For example,
   * &lt;ul&gt;
   * &lt;li&gt;
   *     &lt;em&gt;limits&lt;/em&gt; = {1,2,3,4,5,6,7}&lt;br&gt;
   *     &lt;em&gt;formats&lt;/em&gt; = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;}
   * &lt;li&gt;
   *     &lt;em&gt;limits&lt;/em&gt; = {0, 1, ChoiceFormat.nextDouble(1)}&lt;br&gt;
   *     &lt;em&gt;formats&lt;/em&gt; = {&quot;no files&quot;, &quot;one file&quot;, &quot;many files&quot;}&lt;br&gt;
<span class="line-modified">!  *     (&lt;code&gt;nextDouble&lt;/code&gt; can be used to get the next higher double, to</span>
   *     make the half-open interval.)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;
   * Here is a simple example that shows formatting and parsing:
<span class="line-new-header">--- 58,29 ---</span>
   * in ascending order, the results of formatting will be incorrect.  ChoiceFormat
   * also accepts &lt;code&gt;&amp;#92;u221E&lt;/code&gt; as equivalent to infinity(INF).
   *
   * &lt;p&gt;
   * &lt;strong&gt;Note:&lt;/strong&gt;
<span class="line-modified">!  * {@code ChoiceFormat} differs from the other {@code Format}</span>
<span class="line-modified">!  * classes in that you create a {@code ChoiceFormat} object with a</span>
<span class="line-modified">!  * constructor (not with a {@code getInstance} style factory</span>
<span class="line-modified">!  * method). The factory methods aren&#39;t necessary because {@code ChoiceFormat}</span>
   * doesn&#39;t require any complex setup for a given locale. In fact,
<span class="line-modified">!  * {@code ChoiceFormat} doesn&#39;t implement any locale specific behavior.</span>
   *
   * &lt;p&gt;
<span class="line-modified">!  * When creating a {@code ChoiceFormat}, you must specify an array of formats</span>
   * and an array of limits. The length of these arrays must be the same.
   * For example,
   * &lt;ul&gt;
   * &lt;li&gt;
   *     &lt;em&gt;limits&lt;/em&gt; = {1,2,3,4,5,6,7}&lt;br&gt;
   *     &lt;em&gt;formats&lt;/em&gt; = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;}
   * &lt;li&gt;
   *     &lt;em&gt;limits&lt;/em&gt; = {0, 1, ChoiceFormat.nextDouble(1)}&lt;br&gt;
   *     &lt;em&gt;formats&lt;/em&gt; = {&quot;no files&quot;, &quot;one file&quot;, &quot;many files&quot;}&lt;br&gt;
<span class="line-modified">!  *     ({@code nextDouble} can be used to get the next higher double, to</span>
   *     make the half-open interval.)
   * &lt;/ul&gt;
   *
   * &lt;p&gt;
   * Here is a simple example that shows formatting and parsing:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,11 ***</span>
   * Format with NaN : is negative
   * Format with +INF : is more than 2.
   * }&lt;/pre&gt;
   * &lt;/blockquote&gt;
   *
<span class="line-modified">!  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;</span>
   *
   * &lt;p&gt;
   * Choice formats are not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
<span class="line-new-header">--- 149,11 ---</span>
   * Format with NaN : is negative
   * Format with +INF : is more than 2.
   * }&lt;/pre&gt;
   * &lt;/blockquote&gt;
   *
<span class="line-modified">!  * &lt;h2&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h2&gt;</span>
   *
   * &lt;p&gt;
   * Choice formats are not synchronized.
   * It is recommended to create separate format instances for each thread.
   * If multiple threads access a format concurrently, it must be synchronized
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,16 ***</span>
   * @since 1.1
   */
  public class ChoiceFormat extends NumberFormat {
  
      // Proclaim serial compatibility with 1.1 FCS
      private static final long serialVersionUID = 1795184449645032964L;
  
      /**
       * Sets the pattern.
       * @param newPattern See the class description.
<span class="line-modified">!      * @exception NullPointerException if {@code newPattern}</span>
       *            is {@code null}
       */
      public void applyPattern(String newPattern) {
          StringBuffer[] segments = new StringBuffer[2];
          for (int i = 0; i &lt; segments.length; ++i) {
<span class="line-new-header">--- 166,17 ---</span>
   * @since 1.1
   */
  public class ChoiceFormat extends NumberFormat {
  
      // Proclaim serial compatibility with 1.1 FCS
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = 1795184449645032964L;
  
      /**
       * Sets the pattern.
       * @param newPattern See the class description.
<span class="line-modified">!      * @throws    NullPointerException if {@code newPattern}</span>
       *            is {@code null}
       */
      public void applyPattern(String newPattern) {
          StringBuffer[] segments = new StringBuffer[2];
          for (int i = 0; i &lt; segments.length; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,11 ***</span>
  
      /**
       * Constructs with limits and corresponding formats based on the pattern.
       *
       * @param newPattern the new pattern string
<span class="line-modified">!      * @exception NullPointerException if {@code newPattern} is</span>
       *            {@code null}
       * @see #applyPattern
       */
      public ChoiceFormat(String newPattern)  {
          applyPattern(newPattern);
<span class="line-new-header">--- 311,11 ---</span>
  
      /**
       * Constructs with limits and corresponding formats based on the pattern.
       *
       * @param newPattern the new pattern string
<span class="line-modified">!      * @throws    NullPointerException if {@code newPattern} is</span>
       *            {@code null}
       * @see #applyPattern
       */
      public ChoiceFormat(String newPattern)  {
          applyPattern(newPattern);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,11 ***</span>
      /**
       * Constructs with the limits and the corresponding formats.
       *
       * @param limits limits in ascending order
       * @param formats corresponding format strings
<span class="line-modified">!      * @exception NullPointerException if {@code limits} or {@code formats}</span>
       *            is {@code null}
       * @see #setChoices
       */
      public ChoiceFormat(double[] limits, String[] formats) {
          setChoices(limits, formats);
<span class="line-new-header">--- 324,11 ---</span>
      /**
       * Constructs with the limits and the corresponding formats.
       *
       * @param limits limits in ascending order
       * @param formats corresponding format strings
<span class="line-modified">!      * @throws    NullPointerException if {@code limits} or {@code formats}</span>
       *            is {@code null}
       * @see #setChoices
       */
      public ChoiceFormat(double[] limits, String[] formats) {
          setChoices(limits, formats);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 344,11 ***</span>
       * @param formats are the formats you want to use for each limit.
       * They can be either Format objects or Strings.
       * When formatting with object Y,
       * if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
       * is called. Otherwise Y.toString() is called.
<span class="line-modified">!      * @exception NullPointerException if {@code limits} or</span>
       *            {@code formats} is {@code null}
       */
      public void setChoices(double[] limits, String formats[]) {
          if (limits.length != formats.length) {
              throw new IllegalArgumentException(
<span class="line-new-header">--- 345,11 ---</span>
       * @param formats are the formats you want to use for each limit.
       * They can be either Format objects or Strings.
       * When formatting with object Y,
       * if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
       * is called. Otherwise Y.toString() is called.
<span class="line-modified">!      * @throws    NullPointerException if {@code limits} or</span>
       *            {@code formats} is {@code null}
       */
      public void setChoices(double[] limits, String formats[]) {
          if (limits.length != formats.length) {
              throw new IllegalArgumentException(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,11 ***</span>
  
      // Overrides
  
      /**
       * Specialization of format. This method really calls
<span class="line-modified">!      * &lt;code&gt;format(double, StringBuffer, FieldPosition)&lt;/code&gt;</span>
       * thus the range of longs that are supported is only equal to
       * the range that can be stored by double. This will never be
       * a practical limitation.
       */
      public StringBuffer format(long number, StringBuffer toAppendTo,
<span class="line-new-header">--- 379,11 ---</span>
  
      // Overrides
  
      /**
       * Specialization of format. This method really calls
<span class="line-modified">!      * {@code format(double, StringBuffer, FieldPosition)}</span>
       * thus the range of longs that are supported is only equal to
       * the range that can be stored by double. This will never be
       * a practical limitation.
       */
      public StringBuffer format(long number, StringBuffer toAppendTo,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 393,11 ***</span>
      /**
       * Returns pattern with formatted double.
       * @param number number to be formatted and substituted.
       * @param toAppendTo where text is appended.
       * @param status ignore no useful status is returned.
<span class="line-modified">!      * @exception NullPointerException if {@code toAppendTo}</span>
       *            is {@code null}
       */
     public StringBuffer format(double number, StringBuffer toAppendTo,
                                 FieldPosition status) {
          // find the number
<span class="line-new-header">--- 394,11 ---</span>
      /**
       * Returns pattern with formatted double.
       * @param number number to be formatted and substituted.
       * @param toAppendTo where text is appended.
       * @param status ignore no useful status is returned.
<span class="line-modified">!      * @throws    NullPointerException if {@code toAppendTo}</span>
       *            is {@code null}
       */
     public StringBuffer format(double number, StringBuffer toAppendTo,
                                 FieldPosition status) {
          // find the number
</pre>
<hr />
<pre>
<span class="line-old-header">*** 423,11 ***</span>
       * occurred, status.index is set to the first unparsed character
       * in the source text.  On exit, if an error did occur,
       * status.index is unchanged and status.errorIndex is set to the
       * first index of the character that caused the parse to fail.
       * @return A Number representing the value of the number parsed.
<span class="line-modified">!      * @exception NullPointerException if {@code status} is {@code null}</span>
       *            or if {@code text} is {@code null} and the list of
       *            choice strings is not empty.
       */
      public Number parse(String text, ParsePosition status) {
          // find the best number (defined as the one with the longest parse)
<span class="line-new-header">--- 424,11 ---</span>
       * occurred, status.index is set to the first unparsed character
       * in the source text.  On exit, if an error did occur,
       * status.index is unchanged and status.errorIndex is set to the
       * first index of the character that caused the parse to fail.
       * @return A Number representing the value of the number parsed.
<span class="line-modified">!      * @throws    NullPointerException if {@code status} is {@code null}</span>
       *            or if {@code text} is {@code null} and the list of
       *            choice strings is not empty.
       */
      public Number parse(String text, ParsePosition status) {
          // find the best number (defined as the one with the longest parse)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 526,10 ***</span>
<span class="line-new-header">--- 527,11 ---</span>
      /**
       * After reading an object from the input stream, do a simple verification
       * to maintain class invariants.
       * @throws InvalidObjectException if the objects read from the stream is invalid.
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
          in.defaultReadObject();
          if (choiceLimits.length != choiceFormats.length) {
              throw new InvalidObjectException(
                      &quot;limits and format arrays of different length.&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 538,20 ***</span>
  
      // ===============privates===========================
  
      /**
       * A list of lower bounds for the choices.  The formatter will return
<span class="line-modified">!      * &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.</span>
       * @serial
       */
      private double[] choiceLimits;
  
      /**
       * A list of choice strings.  The formatter will return
<span class="line-modified">!      * &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to</span>
<span class="line-modified">!      * &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.</span>
       * @serial
       */
      private String[] choiceFormats;
  
      /**
<span class="line-new-header">--- 540,20 ---</span>
  
      // ===============privates===========================
  
      /**
       * A list of lower bounds for the choices.  The formatter will return
<span class="line-modified">!      * {@code choiceFormats[i]} if the number being formatted is greater than or equal to</span>
<span class="line-modified">!      * {@code choiceLimits[i]} and less than {@code choiceLimits[i+1]}.</span>
       * @serial
       */
      private double[] choiceLimits;
  
      /**
       * A list of choice strings.  The formatter will return
<span class="line-modified">!      * {@code choiceFormats[i]} if the number being formatted is greater than or equal to</span>
<span class="line-modified">!      * {@code choiceLimits[i]} and less than {@code choiceLimits[i+1]}.</span>
       * @serial
       */
      private String[] choiceFormats;
  
      /**
</pre>
<center><a href="CharacterIteratorFieldDelegate.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CollationElementIterator.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
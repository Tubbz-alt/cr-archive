<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/net/DatagramSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DatagramPacket.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/DatagramSocket.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,13 ***</span>
<span class="line-new-header">--- 24,15 ---</span>
   */
  
  package java.net;
  
  import java.io.IOException;
<span class="line-added">+ import java.io.UncheckedIOException;</span>
  import java.nio.channels.DatagramChannel;
  import java.security.AccessController;
  import java.security.PrivilegedExceptionAction;
<span class="line-added">+ import java.util.Objects;</span>
  import java.util.Set;
  import java.util.Collections;
  
  /**
   * This class represents a socket for sending and receiving datagram packets.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,52 ***</span>
   * is individually addressed and routed. Multiple packets sent from
   * one machine to another may be routed differently, and may arrive in
   * any order.
   *
   * &lt;p&gt; Where possible, a newly constructed {@code DatagramSocket} has the
<span class="line-modified">!  * {@link SocketOptions#SO_BROADCAST SO_BROADCAST} socket option enabled so as</span>
   * to allow the transmission of broadcast datagrams. In order to receive
   * broadcast packets a DatagramSocket should be bound to the wildcard address.
   * In some implementations, broadcast packets may also be received when
   * a DatagramSocket is bound to a more specific address.
   * &lt;p&gt;
   * Example:
<span class="line-modified">!  * {@code</span>
   *              DatagramSocket s = new DatagramSocket(null);
   *              s.bind(new InetSocketAddress(8888));
<span class="line-modified">!  * }</span>
   * Which is equivalent to:
<span class="line-modified">!  * {@code</span>
   *              DatagramSocket s = new DatagramSocket(8888);
<span class="line-modified">!  * }</span>
   * Both cases will create a DatagramSocket able to receive broadcasts on
   * UDP port 8888.
   *
   * @author  Pavani Diwanji
   * @see     java.net.DatagramPacket
   * @see     java.nio.channels.DatagramChannel
   * @since 1.0
   */
<span class="line-modified">! public</span>
<span class="line-removed">- class DatagramSocket implements java.io.Closeable {</span>
      /**
       * Various states of this socket.
       */
<span class="line-removed">-     private boolean created = false;</span>
      private boolean bound = false;
      private boolean closed = false;
<span class="line-modified">!     private Object closeLock = new Object();</span>
  
      /*
       * The implementation of this DatagramSocket.
       */
<span class="line-modified">!     DatagramSocketImpl impl;</span>
  
      /**
       * Are we using an older DatagramSocketImpl?
       */
<span class="line-modified">!     boolean oldImpl = false;</span>
  
      /**
       * Set when a socket is ST_CONNECTED until we are certain
       * that any packets which might have been received prior
       * to calling connect() but not read by the application
<span class="line-new-header">--- 42,96 ---</span>
   * is individually addressed and routed. Multiple packets sent from
   * one machine to another may be routed differently, and may arrive in
   * any order.
   *
   * &lt;p&gt; Where possible, a newly constructed {@code DatagramSocket} has the
<span class="line-modified">!  * {@link StandardSocketOptions#SO_BROADCAST SO_BROADCAST} socket option enabled so as</span>
   * to allow the transmission of broadcast datagrams. In order to receive
   * broadcast packets a DatagramSocket should be bound to the wildcard address.
   * In some implementations, broadcast packets may also be received when
   * a DatagramSocket is bound to a more specific address.
   * &lt;p&gt;
   * Example:
<span class="line-modified">!  * &lt;pre&gt;{@code</span>
   *              DatagramSocket s = new DatagramSocket(null);
   *              s.bind(new InetSocketAddress(8888));
<span class="line-modified">!  * }&lt;/pre&gt;</span>
   * Which is equivalent to:
<span class="line-modified">!  * &lt;pre&gt;{@code</span>
   *              DatagramSocket s = new DatagramSocket(8888);
<span class="line-modified">!  * }&lt;/pre&gt;</span>
   * Both cases will create a DatagramSocket able to receive broadcasts on
   * UDP port 8888.
   *
<span class="line-added">+  * &lt;p&gt; The {@code DatagramSocket} class defines convenience</span>
<span class="line-added">+  * methods to set and get several socket options. This class also</span>
<span class="line-added">+  * defines the {@link #setOption(SocketOption,Object) setOption}</span>
<span class="line-added">+  * and {@link #getOption(SocketOption) getOption} methods to set</span>
<span class="line-added">+  * and query socket options.</span>
<span class="line-added">+  * A {@code DatagramSocket} supports the following socket options:</span>
<span class="line-added">+  * &lt;blockquote&gt;</span>
<span class="line-added">+  * &lt;a id=&quot;SocketOptions&quot;&gt;&lt;/a&gt;</span>
<span class="line-added">+  * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added">+  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;</span>
<span class="line-added">+  * &lt;thead&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  * &lt;/thead&gt;</span>
<span class="line-added">+  * &lt;tbody&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; The size of the socket send buffer &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; The size of the socket receive buffer &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; Re-use address &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_BROADCAST SO_BROADCAST} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; Allow transmission of broadcast datagrams &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  *   &lt;tr&gt;</span>
<span class="line-added">+  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_TOS IP_TOS} &lt;/th&gt;</span>
<span class="line-added">+  *     &lt;td&gt; The Type of Service (ToS) octet in the Internet Protocol (IP) header &lt;/td&gt;</span>
<span class="line-added">+  *   &lt;/tr&gt;</span>
<span class="line-added">+  * &lt;/tbody&gt;</span>
<span class="line-added">+  * &lt;/table&gt;</span>
<span class="line-added">+  * &lt;/blockquote&gt;</span>
<span class="line-added">+  * An implementation may also support additional options. In particular an implementation</span>
<span class="line-added">+  * may support &lt;a href=&quot;MulticastSocket.html#MulticastOptions&quot;&gt;multicast options&lt;/a&gt; which</span>
<span class="line-added">+  * can be useful when using a plain {@code DatagramSocket} to send datagrams to a</span>
<span class="line-added">+  * multicast group.</span>
<span class="line-added">+  *</span>
   * @author  Pavani Diwanji
   * @see     java.net.DatagramPacket
   * @see     java.nio.channels.DatagramChannel
   * @since 1.0
   */
<span class="line-modified">! public class DatagramSocket implements java.io.Closeable {</span>
      /**
       * Various states of this socket.
       */
      private boolean bound = false;
      private boolean closed = false;
<span class="line-modified">!     private volatile boolean created;</span>
<span class="line-added">+     private final Object closeLock = new Object();</span>
  
      /*
       * The implementation of this DatagramSocket.
       */
<span class="line-modified">!     private final DatagramSocketImpl impl;</span>
  
      /**
       * Are we using an older DatagramSocketImpl?
       */
<span class="line-modified">!     final boolean oldImpl;</span>
  
      /**
       * Set when a socket is ST_CONNECTED until we are certain
       * that any packets which might have been received prior
       * to calling connect() but not read by the application
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,13 ***</span>
       * &lt;p&gt;If there is a security manager,
       * its {@code checkListen} method is first called
       * with 0 as its argument to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
<span class="line-modified">!      * @exception  SocketException  if the socket could not be opened,</span>
       *               or the socket could not bind to the specified local port.
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       *
       * @see SecurityManager#checkListen
       */
      public DatagramSocket() throws SocketException {
<span class="line-new-header">--- 231,13 ---</span>
       * &lt;p&gt;If there is a security manager,
       * its {@code checkListen} method is first called
       * with 0 as its argument to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
<span class="line-modified">!      * @throws     SocketException  if the socket could not be opened,</span>
       *               or the socket could not bind to the specified local port.
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       *
       * @see SecurityManager#checkListen
       */
      public DatagramSocket() throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,11 ***</span>
       */
      protected DatagramSocket(DatagramSocketImpl impl) {
          if (impl == null)
              throw new NullPointerException();
          this.impl = impl;
<span class="line-modified">!         checkOldImpl();</span>
      }
  
      /**
       * Creates a datagram socket, bound to the specified local
       * socket address.
<span class="line-new-header">--- 254,11 ---</span>
       */
      protected DatagramSocket(DatagramSocketImpl impl) {
          if (impl == null)
              throw new NullPointerException();
          this.impl = impl;
<span class="line-modified">!         this.oldImpl = checkOldImpl(impl);</span>
      }
  
      /**
       * Creates a datagram socket, bound to the specified local
       * socket address.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 226,21 ***</span>
       * This could result in a SecurityException.
       *
       * @param bindaddr local socket address to bind, or {@code null}
       *                 for an unbound socket.
       *
<span class="line-modified">!      * @exception  SocketException  if the socket could not be opened,</span>
       *               or the socket could not bind to the specified local port.
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       *
       * @see SecurityManager#checkListen
       * @since   1.4
       */
      public DatagramSocket(SocketAddress bindaddr) throws SocketException {
          // create a datagram socket.
<span class="line-modified">!         createImpl();</span>
          if (bindaddr != null) {
              try {
                  bind(bindaddr);
              } finally {
                  if (!isBound())
<span class="line-new-header">--- 272,33 ---</span>
       * This could result in a SecurityException.
       *
       * @param bindaddr local socket address to bind, or {@code null}
       *                 for an unbound socket.
       *
<span class="line-modified">!      * @throws     SocketException  if the socket could not be opened,</span>
       *               or the socket could not bind to the specified local port.
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       *
       * @see SecurityManager#checkListen
       * @since   1.4
       */
      public DatagramSocket(SocketAddress bindaddr) throws SocketException {
<span class="line-added">+         // Special case initialization for the DatagramChannel socket adaptor.</span>
<span class="line-added">+         if (this instanceof sun.nio.ch.DatagramSocketAdaptor) {</span>
<span class="line-added">+             this.impl = null;  // no DatagramSocketImpl</span>
<span class="line-added">+             this.oldImpl = false;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // create a datagram socket.
<span class="line-modified">!         boolean multicast = (this instanceof MulticastSocket);</span>
<span class="line-added">+         this.impl = createImpl(multicast);</span>
<span class="line-added">+         // creates the udp socket</span>
<span class="line-added">+         impl.create();</span>
<span class="line-added">+         created = true;</span>
<span class="line-added">+         this.oldImpl = checkOldImpl(impl);</span>
          if (bindaddr != null) {
              try {
                  bind(bindaddr);
              } finally {
                  if (!isBound())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,13 ***</span>
       * with the {@code port} argument
       * as its argument to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
       * @param      port port to use.
<span class="line-modified">!      * @exception  SocketException  if the socket could not be opened,</span>
       *               or the socket could not bind to the specified local port.
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       *
       * @see SecurityManager#checkListen
       */
      public DatagramSocket(int port) throws SocketException {
<span class="line-new-header">--- 318,13 ---</span>
       * with the {@code port} argument
       * as its argument to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
       * @param      port port to use.
<span class="line-modified">!      * @throws     SocketException  if the socket could not be opened,</span>
       *               or the socket could not bind to the specified local port.
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       *
       * @see SecurityManager#checkListen
       */
      public DatagramSocket(int port) throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,25 ***</span>
       * This could result in a SecurityException.
       *
       * @param port local port to use
       * @param laddr local address to bind
       *
<span class="line-modified">!      * @exception  SocketException  if the socket could not be opened,</span>
       *               or the socket could not bind to the specified local port.
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       *
       * @see SecurityManager#checkListen
       * @since   1.1
       */
      public DatagramSocket(int port, InetAddress laddr) throws SocketException {
          this(new InetSocketAddress(laddr, port));
      }
  
<span class="line-modified">!     private void checkOldImpl() {</span>
<span class="line-modified">!         if (impl == null)</span>
<span class="line-modified">!             return;</span>
          // DatagramSocketImpl.peekData() is a protected method, therefore we need to use
          // getDeclaredMethod, therefore we need permission to access the member
          try {
              AccessController.doPrivileged(
                  new PrivilegedExceptionAction&lt;&gt;() {
<span class="line-new-header">--- 345,27 ---</span>
       * This could result in a SecurityException.
       *
       * @param port local port to use
       * @param laddr local address to bind
       *
<span class="line-modified">!      * @throws     SocketException  if the socket could not be opened,</span>
       *               or the socket could not bind to the specified local port.
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkListen} method doesn&#39;t allow the operation.
       *
       * @see SecurityManager#checkListen
       * @since   1.1
       */
      public DatagramSocket(int port, InetAddress laddr) throws SocketException {
          this(new InetSocketAddress(laddr, port));
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Return true if the given DatagramSocketImpl is an &quot;old&quot; impl. An old impl</span>
<span class="line-modified">!      * is one that doesn&#39;t implement the abstract methods added in Java SE 1.4.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static boolean checkOldImpl(DatagramSocketImpl impl) {</span>
          // DatagramSocketImpl.peekData() is a protected method, therefore we need to use
          // getDeclaredMethod, therefore we need permission to access the member
          try {
              AccessController.doPrivileged(
                  new PrivilegedExceptionAction&lt;&gt;() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,47 ***</span>
                          cl[0] = DatagramPacket.class;
                          impl.getClass().getDeclaredMethod(&quot;peekData&quot;, cl);
                          return null;
                      }
                  });
          } catch (java.security.PrivilegedActionException e) {
<span class="line-modified">!             oldImpl = true;</span>
          }
      }
  
      static Class&lt;?&gt; implClass = null;
  
<span class="line-modified">!     void createImpl() throws SocketException {</span>
<span class="line-modified">!         if (impl == null) {</span>
<span class="line-modified">!             if (factory != null) {</span>
<span class="line-modified">!                 impl = factory.createDatagramSocketImpl();</span>
<span class="line-modified">!                 checkOldImpl();</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 boolean isMulticast = (this instanceof MulticastSocket) ? true : false;</span>
<span class="line-modified">!                 impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(isMulticast);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 checkOldImpl();</span>
<span class="line-modified">!             }</span>
          }
<span class="line-modified">!         // creates a udp socket</span>
<span class="line-removed">-         impl.create();</span>
<span class="line-removed">-         impl.setDatagramSocket(this);</span>
<span class="line-removed">-         created = true;</span>
      }
  
      /**
<span class="line-modified">!      * Get the {@code DatagramSocketImpl} attached to this socket,</span>
<span class="line-modified">!      * creating it if necessary.</span>
       *
       * @return  the {@code DatagramSocketImpl} attached to that
       *          DatagramSocket
<span class="line-modified">!      * @throws SocketException if creation fails.</span>
       * @since 1.4
       */
<span class="line-modified">!     DatagramSocketImpl getImpl() throws SocketException {</span>
<span class="line-modified">!         if (!created)</span>
<span class="line-modified">!             createImpl();</span>
          return impl;
      }
  
      /**
       * Binds this DatagramSocket to a specific address and port.
<span class="line-new-header">--- 374,51 ---</span>
                          cl[0] = DatagramPacket.class;
                          impl.getClass().getDeclaredMethod(&quot;peekData&quot;, cl);
                          return null;
                      }
                  });
<span class="line-added">+             return false;</span>
          } catch (java.security.PrivilegedActionException e) {
<span class="line-modified">!             return true;</span>
          }
      }
  
      static Class&lt;?&gt; implClass = null;
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Creates a DatagramSocketImpl.</span>
<span class="line-modified">!      * @param multicast true if the DatagramSocketImpl is for a MulticastSocket</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static DatagramSocketImpl createImpl(boolean multicast) throws SocketException {</span>
<span class="line-modified">!         DatagramSocketImpl impl;</span>
<span class="line-modified">!         DatagramSocketImplFactory factory = DatagramSocket.factory;</span>
<span class="line-modified">!         if (factory != null) {</span>
<span class="line-modified">!             impl = factory.createDatagramSocketImpl();</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);</span>
          }
<span class="line-modified">!         return impl;</span>
      }
  
      /**
<span class="line-modified">!      * Return the {@code DatagramSocketImpl} attached to this socket,</span>
<span class="line-modified">!      * creating the socket if not already created.</span>
       *
       * @return  the {@code DatagramSocketImpl} attached to that
       *          DatagramSocket
<span class="line-modified">!      * @throws SocketException if creating the socket fails</span>
       * @since 1.4
       */
<span class="line-modified">!     final DatagramSocketImpl getImpl() throws SocketException {</span>
<span class="line-modified">!         if (!created) {</span>
<span class="line-modified">!             synchronized (this) {</span>
<span class="line-added">+                 if (!created)  {</span>
<span class="line-added">+                     impl.create();</span>
<span class="line-added">+                     created = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          return impl;
      }
  
      /**
       * Binds this DatagramSocket to a specific address and port.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,17 ***</span>
  
      /**
       * Connects the socket to a remote address for this socket. When a
       * socket is connected to a remote address, packets may only be
       * sent to or received from that address. By default a datagram
<span class="line-modified">!      * socket is not connected.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If the remote destination to which the socket is connected does not</span>
<span class="line-modified">!      * exist, or is otherwise unreachable, and if an ICMP destination unreachable</span>
<span class="line-modified">!      * packet has been received for that address, then a subsequent call to</span>
<span class="line-modified">!      * send or receive may throw a PortUnreachableException. Note, there is no</span>
<span class="line-modified">!      * guarantee that the exception will be thrown.</span>
       *
       * &lt;p&gt; If a security manager has been installed then it is invoked to check
       * access to the remote address. Specifically, if the given {@code address}
       * is a {@link InetAddress#isMulticastAddress multicast address},
       * the security manager&#39;s {@link
<span class="line-new-header">--- 474,21 ---</span>
  
      /**
       * Connects the socket to a remote address for this socket. When a
       * socket is connected to a remote address, packets may only be
       * sent to or received from that address. By default a datagram
<span class="line-modified">!      * socket is not connected. If the socket is already closed,</span>
<span class="line-added">+      * then this method has no effect.</span>
       *
<span class="line-modified">!      * &lt;p&gt; If this socket is not bound then this method will first cause the</span>
<span class="line-modified">!      * socket to be bound to an address that is assigned automatically,</span>
<span class="line-modified">!      * as if invoking the {@link #bind bind} method with a parameter of</span>
<span class="line-modified">!      * {@code null}. If the remote destination to which the socket is connected</span>
<span class="line-modified">!      * does not exist, or is otherwise unreachable, and if an ICMP destination</span>
<span class="line-added">+      * unreachable packet has been received for that address, then a subsequent</span>
<span class="line-added">+      * call to send or receive may throw a PortUnreachableException. Note,</span>
<span class="line-added">+      * there is no guarantee that the exception will be thrown.</span>
       *
       * &lt;p&gt; If a security manager has been installed then it is invoked to check
       * access to the remote address. Specifically, if the given {@code address}
       * is a {@link InetAddress#isMulticastAddress multicast address},
       * the security manager&#39;s {@link
</pre>
<hr />
<pre>
<span class="line-old-header">*** 431,18 ***</span>
       * and {@link java.lang.SecurityManager#checkAccept checkAccept} methods
       * are invoked, with the given {@code address} and {@code port}, to
       * verify that datagrams are permitted to be sent and received
       * respectively.
       *
<span class="line-modified">!      * &lt;p&gt; When a socket is connected, {@link #receive receive} and</span>
<span class="line-modified">!      * {@link #send send} &lt;b&gt;will not perform any security checks&lt;/b&gt;</span>
<span class="line-modified">!      * on incoming and outgoing packets, other than matching the packet&#39;s</span>
<span class="line-modified">!      * and the socket&#39;s address and port. On a send operation, if the</span>
<span class="line-modified">!      * packet&#39;s address is set and the packet&#39;s address and the socket&#39;s</span>
<span class="line-modified">!      * address do not match, an {@code IllegalArgumentException} will be</span>
<span class="line-modified">!      * thrown. A socket connected to a multicast address may only be used</span>
<span class="line-modified">!      * to send packets.</span>
       *
       * @param address the remote address for the socket
       *
       * @param port the remote port for the socket.
       *
<span class="line-new-header">--- 499,19 ---</span>
       * and {@link java.lang.SecurityManager#checkAccept checkAccept} methods
       * are invoked, with the given {@code address} and {@code port}, to
       * verify that datagrams are permitted to be sent and received
       * respectively.
       *
<span class="line-modified">!      * &lt;p&gt; Care should be taken to ensure that a connected datagram socket</span>
<span class="line-modified">!      * is not shared with untrusted code. When a socket is connected,</span>
<span class="line-modified">!      * {@link #receive receive} and {@link #send send} &lt;b&gt;will not perform</span>
<span class="line-modified">!      * any security checks&lt;/b&gt; on incoming and outgoing packets, other than</span>
<span class="line-modified">!      * matching the packet&#39;s and the socket&#39;s address and port. On a send</span>
<span class="line-modified">!      * operation, if the packet&#39;s address is set and the packet&#39;s address</span>
<span class="line-modified">!      * and the socket&#39;s address do not match, an {@code IllegalArgumentException}</span>
<span class="line-modified">!      * will be thrown. A socket connected to a multicast address may only</span>
<span class="line-added">+      * be used to send packets.</span>
       *
       * @param address the remote address for the socket
       *
       * @param port the remote port for the socket.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,26 ***</span>
       *
       * @throws SecurityException
       *         if a security manager has been installed and it does
       *         not permit access to the given remote address
       *
       * @see #disconnect
       */
      public void connect(InetAddress address, int port) {
          try {
              connectInternal(address, port);
          } catch (SocketException se) {
<span class="line-modified">!             throw new Error(&quot;connect failed&quot;, se);</span>
          }
      }
  
      /**
       * Connects this socket to a remote socket address (IP address + port number).
       *
       * &lt;p&gt; If given an {@link InetSocketAddress InetSocketAddress}, this method
       * behaves as if invoking {@link #connect(InetAddress,int) connect(InetAddress,int)}
<span class="line-modified">!      * with the given socket addresses IP address and port number.</span>
       *
       * @param   addr    The remote address.
       *
       * @throws  SocketException
       *          if the connect fails
<span class="line-new-header">--- 520,34 ---</span>
       *
       * @throws SecurityException
       *         if a security manager has been installed and it does
       *         not permit access to the given remote address
       *
<span class="line-added">+      * @throws UncheckedIOException</span>
<span class="line-added">+      *         may be thrown if connect fails, for example, if the</span>
<span class="line-added">+      *         destination address is non-routable</span>
<span class="line-added">+      *</span>
       * @see #disconnect
<span class="line-added">+      *</span>
<span class="line-added">+      * @since 1.2</span>
       */
      public void connect(InetAddress address, int port) {
          try {
              connectInternal(address, port);
          } catch (SocketException se) {
<span class="line-modified">!             throw new UncheckedIOException(&quot;connect failed&quot;, se);</span>
          }
      }
  
      /**
       * Connects this socket to a remote socket address (IP address + port number).
       *
       * &lt;p&gt; If given an {@link InetSocketAddress InetSocketAddress}, this method
       * behaves as if invoking {@link #connect(InetAddress,int) connect(InetAddress,int)}
<span class="line-modified">!      * with the given socket addresses IP address and port number, except that the</span>
<span class="line-added">+      * {@code SocketException} that may be raised is not wrapped in an</span>
<span class="line-added">+      * {@code UncheckedIOException}.</span>
       *
       * @param   addr    The remote address.
       *
       * @throws  SocketException
       *          if the connect fails
</pre>
<hr />
<pre>
<span class="line-old-header">*** 498,11 ***</span>
<span class="line-new-header">--- 575,22 ---</span>
  
      /**
       * Disconnects the socket. If the socket is closed or not connected,
       * then this method has no effect.
       *
<span class="line-added">+      * @apiNote If this method throws an UncheckedIOException, the socket</span>
<span class="line-added">+      *          may be left in an unspecified state. It is strongly</span>
<span class="line-added">+      *          recommended that the socket be closed when disconnect</span>
<span class="line-added">+      *          fails.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws  UncheckedIOException</span>
<span class="line-added">+      *          may be thrown if disconnect fails to dissolve the</span>
<span class="line-added">+      *          association and restore the socket to a consistent state.</span>
<span class="line-added">+      *</span>
       * @see #connect
<span class="line-added">+      *</span>
<span class="line-added">+      * @since 1.2</span>
       */
      public void disconnect() {
          synchronized (this) {
              if (isClosed())
                  return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,10 ***</span>
<span class="line-new-header">--- 639,11 ---</span>
       * If the socket was connected prior to being {@link #close closed},
       * then this method will continue to return the connected address
       * after the socket is closed.
       *
       * @return the address to which this socket is connected.
<span class="line-added">+      * @since 1.2</span>
       */
      public InetAddress getInetAddress() {
          return connectedAddress;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 565,10 ***</span>
<span class="line-new-header">--- 654,11 ---</span>
       * If the socket was connected prior to being {@link #close closed},
       * then this method will continue to return the connected port number
       * after the socket is closed.
       *
       * @return the port number to which this socket is connected.
<span class="line-added">+      * @since 1.2</span>
       */
      public int getPort() {
          return connectedPort;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,11 ***</span>
       * @see #getLocalAddress()
       * @see #getLocalPort()
       * @see #bind(SocketAddress)
       * @since 1.4
       */
<span class="line-removed">- </span>
      public SocketAddress getLocalSocketAddress() {
          if (isClosed())
              return null;
          if (!isBound())
              return null;
<span class="line-new-header">--- 692,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 632,59 ***</span>
       * {@code p.getPort()}. Each call to a security manager method
       * could result in a SecurityException if the operation is not allowed.
       *
       * @param      p   the {@code DatagramPacket} to be sent.
       *
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkMulticast} or {@code checkConnect}
       *             method doesn&#39;t allow the send.
<span class="line-modified">!      * @exception  PortUnreachableException may be thrown if the socket is connected</span>
       *             to a currently unreachable destination. Note, there is no
       *             guarantee that the exception will be thrown.
<span class="line-modified">!      * @exception  java.nio.channels.IllegalBlockingModeException</span>
       *             if this socket has an associated channel,
       *             and the channel is in non-blocking mode.
<span class="line-modified">!      * @exception  IllegalArgumentException if the socket is connected,</span>
<span class="line-modified">!      *             and connected address and packet address differ.</span>
       *
       * @see        java.net.DatagramPacket
       * @see        SecurityManager#checkMulticast(InetAddress)
       * @see        SecurityManager#checkConnect
       * @revised 1.4
       * @spec JSR-51
       */
      public void send(DatagramPacket p) throws IOException  {
<span class="line-removed">-         InetAddress packetAddress = null;</span>
          synchronized (p) {
              if (isClosed())
                  throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-modified">!             checkAddress (p.getAddress(), &quot;send&quot;);</span>
              if (connectState == ST_NOT_CONNECTED) {
                  // check the address is ok with the security manager on every send.
                  SecurityManager security = System.getSecurityManager();
  
                  // The reason you want to synchronize on datagram packet
                  // is because you don&#39;t want an applet to change the address
                  // while you are trying to send the packet for example
                  // after the security check but before the send.
                  if (security != null) {
<span class="line-modified">!                     if (p.getAddress().isMulticastAddress()) {</span>
<span class="line-modified">!                         security.checkMulticast(p.getAddress());</span>
                      } else {
<span class="line-modified">!                         security.checkConnect(p.getAddress().getHostAddress(),</span>
<span class="line-modified">!                                               p.getPort());</span>
                      }
                  }
              } else {
                  // we&#39;re connected
<span class="line-removed">-                 packetAddress = p.getAddress();</span>
                  if (packetAddress == null) {
                      p.setAddress(connectedAddress);
                      p.setPort(connectedPort);
                  } else if ((!packetAddress.equals(connectedAddress)) ||
<span class="line-modified">!                            p.getPort() != connectedPort) {</span>
                      throw new IllegalArgumentException(&quot;connected address &quot; +
                                                         &quot;and packet address&quot; +
                                                         &quot; differ&quot;);
                  }
              }
<span class="line-new-header">--- 721,66 ---</span>
       * {@code p.getPort()}. Each call to a security manager method
       * could result in a SecurityException if the operation is not allowed.
       *
       * @param      p   the {@code DatagramPacket} to be sent.
       *
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkMulticast} or {@code checkConnect}
       *             method doesn&#39;t allow the send.
<span class="line-modified">!      * @throws     PortUnreachableException may be thrown if the socket is connected</span>
       *             to a currently unreachable destination. Note, there is no
       *             guarantee that the exception will be thrown.
<span class="line-modified">!      * @throws     java.nio.channels.IllegalBlockingModeException</span>
       *             if this socket has an associated channel,
       *             and the channel is in non-blocking mode.
<span class="line-modified">!      * @throws     IllegalArgumentException if the socket is connected,</span>
<span class="line-modified">!      *             and connected address and packet address differ, or</span>
<span class="line-added">+      *             if the socket is not connected and the packet address</span>
<span class="line-added">+      *             is not set or if its port is out of range.</span>
       *
       * @see        java.net.DatagramPacket
       * @see        SecurityManager#checkMulticast(InetAddress)
       * @see        SecurityManager#checkConnect
       * @revised 1.4
       * @spec JSR-51
       */
      public void send(DatagramPacket p) throws IOException  {
          synchronized (p) {
              if (isClosed())
                  throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-modified">!             InetAddress packetAddress = p.getAddress();</span>
<span class="line-added">+             int packetPort = p.getPort();</span>
<span class="line-added">+             checkAddress (packetAddress, &quot;send&quot;);</span>
              if (connectState == ST_NOT_CONNECTED) {
<span class="line-added">+                 if (packetAddress == null) {</span>
<span class="line-added">+                     throw new IllegalArgumentException(&quot;Address not set&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (packetPort &lt; 0 || packetPort &gt; 0xFFFF)</span>
<span class="line-added">+                     throw new IllegalArgumentException(&quot;port out of range:&quot; + packetPort);</span>
                  // check the address is ok with the security manager on every send.
                  SecurityManager security = System.getSecurityManager();
  
                  // The reason you want to synchronize on datagram packet
                  // is because you don&#39;t want an applet to change the address
                  // while you are trying to send the packet for example
                  // after the security check but before the send.
                  if (security != null) {
<span class="line-modified">!                     if (packetAddress.isMulticastAddress()) {</span>
<span class="line-modified">!                         security.checkMulticast(packetAddress);</span>
                      } else {
<span class="line-modified">!                         security.checkConnect(packetAddress.getHostAddress(),</span>
<span class="line-modified">!                                 packetPort);</span>
                      }
                  }
              } else {
                  // we&#39;re connected
                  if (packetAddress == null) {
                      p.setAddress(connectedAddress);
                      p.setPort(connectedPort);
                  } else if ((!packetAddress.equals(connectedAddress)) ||
<span class="line-modified">!                         packetPort != connectedPort) {</span>
                      throw new IllegalArgumentException(&quot;connected address &quot; +
                                                         &quot;and packet address&quot; +
                                                         &quot; differ&quot;);
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 705,23 ***</span>
       * This method blocks until a datagram is received. The
       * {@code length} field of the datagram packet object contains
       * the length of the received message. If the message is longer than
       * the packet&#39;s length, the message is truncated.
       * &lt;p&gt;
<span class="line-modified">!      * If there is a security manager, a packet cannot be received if the</span>
<span class="line-modified">!      * security manager&#39;s {@code checkAccept} method</span>
<span class="line-modified">!      * does not allow it.</span>
       *
       * @param      p   the {@code DatagramPacket} into which to place
       *                 the incoming data.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs.</span>
<span class="line-modified">!      * @exception  SocketTimeoutException  if setSoTimeout was previously called</span>
       *                 and the timeout has expired.
<span class="line-modified">!      * @exception  PortUnreachableException may be thrown if the socket is connected</span>
       *             to a currently unreachable destination. Note, there is no guarantee that the
       *             exception will be thrown.
<span class="line-modified">!      * @exception  java.nio.channels.IllegalBlockingModeException</span>
       *             if this socket has an associated channel,
       *             and the channel is in non-blocking mode.
       * @see        java.net.DatagramPacket
       * @see        java.net.DatagramSocket
       * @revised 1.4
<span class="line-new-header">--- 801,25 ---</span>
       * This method blocks until a datagram is received. The
       * {@code length} field of the datagram packet object contains
       * the length of the received message. If the message is longer than
       * the packet&#39;s length, the message is truncated.
       * &lt;p&gt;
<span class="line-modified">!      * If there is a security manager, and the socket is not currently</span>
<span class="line-modified">!      * connected to a remote address, a packet cannot be received if the</span>
<span class="line-modified">!      * security manager&#39;s {@code checkAccept} method does not allow it.</span>
<span class="line-added">+      * Datagrams that are not permitted by the security manager are silently</span>
<span class="line-added">+      * discarded.</span>
       *
       * @param      p   the {@code DatagramPacket} into which to place
       *                 the incoming data.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs.</span>
<span class="line-modified">!      * @throws     SocketTimeoutException  if setSoTimeout was previously called</span>
       *                 and the timeout has expired.
<span class="line-modified">!      * @throws     PortUnreachableException may be thrown if the socket is connected</span>
       *             to a currently unreachable destination. Note, there is no guarantee that the
       *             exception will be thrown.
<span class="line-modified">!      * @throws     java.nio.channels.IllegalBlockingModeException</span>
       *             if this socket has an associated channel,
       *             and the channel is in non-blocking mode.
       * @see        java.net.DatagramPacket
       * @see        java.net.DatagramSocket
       * @revised 1.4
</pre>
<hr />
<pre>
<span class="line-old-header">*** 847,11 ***</span>
       * @since   1.1
       */
      public InetAddress getLocalAddress() {
          if (isClosed())
              return null;
<span class="line-modified">!         InetAddress in = null;</span>
          try {
              in = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);
              if (in.isAnyLocalAddress()) {
                  in = InetAddress.anyLocalAddress();
              }
<span class="line-new-header">--- 945,11 ---</span>
       * @since   1.1
       */
      public InetAddress getLocalAddress() {
          if (isClosed())
              return null;
<span class="line-modified">!         InetAddress in;</span>
          try {
              in = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);
              if (in.isAnyLocalAddress()) {
                  in = InetAddress.anyLocalAddress();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 868,12 ***</span>
      /**
       * Returns the port number on the local host to which this socket
       * is bound.
       *
       * @return  the port number on the local host to which this socket is bound,
<span class="line-modified">!                 {@code -1} if the socket is closed, or</span>
<span class="line-modified">!                 {@code 0} if it is not bound yet.</span>
       */
      public int getLocalPort() {
          if (isClosed())
              return -1;
          try {
<span class="line-new-header">--- 966,12 ---</span>
      /**
       * Returns the port number on the local host to which this socket
       * is bound.
       *
       * @return  the port number on the local host to which this socket is bound,
<span class="line-modified">!      *          {@code -1} if the socket is closed, or</span>
<span class="line-modified">!      *          {@code 0} if it is not bound yet.</span>
       */
      public int getLocalPort() {
          if (isClosed())
              return -1;
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 881,28 ***</span>
          } catch (Exception e) {
              return 0;
          }
      }
  
<span class="line-modified">!     /** Enable/disable SO_TIMEOUT with the specified timeout, in</span>
<span class="line-modified">!      *  milliseconds. With this option set to a non-zero timeout,</span>
<span class="line-modified">!      *  a call to receive() for this DatagramSocket</span>
<span class="line-modified">!      *  will block for only this amount of time.  If the timeout expires,</span>
<span class="line-modified">!      *  a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the</span>
<span class="line-modified">!      *  DatagramSocket is still valid.  The option &lt;B&gt;must&lt;/B&gt; be enabled</span>
<span class="line-modified">!      *  prior to entering the blocking operation to have effect.  The</span>
<span class="line-modified">!      *  timeout must be {@code &gt; 0}.</span>
<span class="line-modified">!      *  A timeout of zero is interpreted as an infinite timeout.</span>
       *
       * @param timeout the specified timeout in milliseconds.
       * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
       * @since   1.1
       * @see #getSoTimeout()
       */
      public synchronized void setSoTimeout(int timeout) throws SocketException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
          getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
      }
  
      /**
       * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
<span class="line-new-header">--- 979,32 ---</span>
          } catch (Exception e) {
              return 0;
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Enable/disable SO_TIMEOUT with the specified timeout, in</span>
<span class="line-modified">!      * milliseconds. With this option set to a positive timeout value,</span>
<span class="line-modified">!      * a call to receive() for this DatagramSocket</span>
<span class="line-modified">!      * will block for only this amount of time.  If the timeout expires,</span>
<span class="line-modified">!      * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the</span>
<span class="line-modified">!      * DatagramSocket is still valid. A timeout of zero is interpreted</span>
<span class="line-modified">!      * as an infinite timeout.</span>
<span class="line-modified">!      * The option &lt;B&gt;must&lt;/B&gt; be enabled prior to entering the blocking</span>
<span class="line-added">+      * operation to have effect.</span>
       *
       * @param timeout the specified timeout in milliseconds.
       * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
<span class="line-added">+      * @throws IllegalArgumentException if {@code timeout} is negative</span>
       * @since   1.1
       * @see #getSoTimeout()
       */
      public synchronized void setSoTimeout(int timeout) throws SocketException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-added">+         if (timeout &lt; 0)</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
          getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
      }
  
      /**
       * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 948,18 ***</span>
       * packet is sent or discarded.
       *
       * @param size the size to which to set the send buffer
       * size. This value must be greater than 0.
       *
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as an UDP error.
<span class="line-modified">!      * @exception IllegalArgumentException if the value is 0 or is</span>
       * negative.
       * @see #getSendBufferSize()
       */
<span class="line-modified">!     public synchronized void setSendBufferSize(int size)</span>
<span class="line-removed">-     throws SocketException{</span>
          if (!(size &gt; 0)) {
              throw new IllegalArgumentException(&quot;negative send size&quot;);
          }
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-new-header">--- 1050,18 ---</span>
       * packet is sent or discarded.
       *
       * @param size the size to which to set the send buffer
       * size. This value must be greater than 0.
       *
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as an UDP error.
<span class="line-modified">!      * @throws    IllegalArgumentException if the value is 0 or is</span>
       * negative.
       * @see #getSendBufferSize()
<span class="line-added">+      * @since 1.2</span>
       */
<span class="line-modified">!     public synchronized void setSendBufferSize(int size) throws SocketException {</span>
          if (!(size &gt; 0)) {
              throw new IllegalArgumentException(&quot;negative send size&quot;);
          }
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 969,13 ***</span>
      /**
       * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
       * buffer size used by the platform for output on this {@code DatagramSocket}.
       *
       * @return the value of the SO_SNDBUF option for this {@code DatagramSocket}
<span class="line-modified">!      * @exception SocketException if there is an error in</span>
       * the underlying protocol, such as an UDP error.
       * @see #setSendBufferSize
       */
      public synchronized int getSendBufferSize() throws SocketException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
          int result = 0;
<span class="line-new-header">--- 1071,14 ---</span>
      /**
       * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
       * buffer size used by the platform for output on this {@code DatagramSocket}.
       *
       * @return the value of the SO_SNDBUF option for this {@code DatagramSocket}
<span class="line-modified">!      * @throws    SocketException if there is an error in</span>
       * the underlying protocol, such as an UDP error.
       * @see #setSendBufferSize
<span class="line-added">+      * @since 1.2</span>
       */
      public synchronized int getSendBufferSize() throws SocketException {
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
          int result = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1006,18 ***</span>
       * than SO_RCVBUF can be received.
       *
       * @param size the size to which to set the receive buffer
       * size. This value must be greater than 0.
       *
<span class="line-modified">!      * @exception SocketException if there is an error in</span>
       * the underlying protocol, such as an UDP error.
<span class="line-modified">!      * @exception IllegalArgumentException if the value is 0 or is</span>
       * negative.
       * @see #getReceiveBufferSize()
       */
<span class="line-modified">!     public synchronized void setReceiveBufferSize(int size)</span>
<span class="line-removed">-     throws SocketException{</span>
          if (size &lt;= 0) {
              throw new IllegalArgumentException(&quot;invalid receive size&quot;);
          }
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
<span class="line-new-header">--- 1109,18 ---</span>
       * than SO_RCVBUF can be received.
       *
       * @param size the size to which to set the receive buffer
       * size. This value must be greater than 0.
       *
<span class="line-modified">!      * @throws    SocketException if there is an error in</span>
       * the underlying protocol, such as an UDP error.
<span class="line-modified">!      * @throws    IllegalArgumentException if the value is 0 or is</span>
       * negative.
       * @see #getReceiveBufferSize()
<span class="line-added">+      * @since 1.2</span>
       */
<span class="line-modified">!     public synchronized void setReceiveBufferSize(int size) throws SocketException {</span>
          if (size &lt;= 0) {
              throw new IllegalArgumentException(&quot;invalid receive size&quot;);
          }
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1027,15 ***</span>
      /**
       * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
       * buffer size used by the platform for input on this {@code DatagramSocket}.
       *
       * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
<span class="line-modified">!      * @exception SocketException if there is an error in the underlying protocol, such as an UDP error.</span>
       * @see #setReceiveBufferSize(int)
       */
<span class="line-modified">!     public synchronized int getReceiveBufferSize()</span>
<span class="line-removed">-     throws SocketException{</span>
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
          int result = 0;
          Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
          if (o instanceof Integer) {
<span class="line-new-header">--- 1130,15 ---</span>
      /**
       * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
       * buffer size used by the platform for input on this {@code DatagramSocket}.
       *
       * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
<span class="line-modified">!      * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.</span>
       * @see #setReceiveBufferSize(int)
<span class="line-added">+      * @since 1.2</span>
       */
<span class="line-modified">!     public synchronized int getReceiveBufferSize() throws SocketException {</span>
          if (isClosed())
              throw new SocketException(&quot;Socket is closed&quot;);
          int result = 0;
          Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
          if (o instanceof Integer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1067,11 ***</span>
       * The behaviour when {@code SO_REUSEADDR} is enabled or
       * disabled after a socket is bound (See {@link #isBound()})
       * is not defined.
       *
       * @param on  whether to enable or disable the
<span class="line-modified">!      * @exception SocketException if an error occurs enabling or</span>
       *            disabling the {@code SO_REUSEADDR} socket option,
       *            or the socket is closed.
       * @since 1.4
       * @see #getReuseAddress()
       * @see #bind(SocketAddress)
<span class="line-new-header">--- 1170,11 ---</span>
       * The behaviour when {@code SO_REUSEADDR} is enabled or
       * disabled after a socket is bound (See {@link #isBound()})
       * is not defined.
       *
       * @param on  whether to enable or disable the
<span class="line-modified">!      * @throws    SocketException if an error occurs enabling or</span>
       *            disabling the {@code SO_REUSEADDR} socket option,
       *            or the socket is closed.
       * @since 1.4
       * @see #getReuseAddress()
       * @see #bind(SocketAddress)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1090,11 ***</span>
  
      /**
       * Tests if SO_REUSEADDR is enabled.
       *
       * @return a {@code boolean} indicating whether or not SO_REUSEADDR is enabled.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as an UDP error.
       * @since   1.4
       * @see #setReuseAddress(boolean)
       */
      public synchronized boolean getReuseAddress() throws SocketException {
<span class="line-new-header">--- 1193,11 ---</span>
  
      /**
       * Tests if SO_REUSEADDR is enabled.
       *
       * @return a {@code boolean} indicating whether or not SO_REUSEADDR is enabled.
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as an UDP error.
       * @since   1.4
       * @see #setReuseAddress(boolean)
       */
      public synchronized boolean getReuseAddress() throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1128,11 ***</span>
      }
  
      /**
       * Tests if SO_BROADCAST is enabled.
       * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
<span class="line-modified">!      * @exception SocketException if there is an error</span>
       * in the underlying protocol, such as an UDP error.
       * @since 1.4
       * @see #setBroadcast(boolean)
       */
      public synchronized boolean getBroadcast() throws SocketException {
<span class="line-new-header">--- 1231,11 ---</span>
      }
  
      /**
       * Tests if SO_BROADCAST is enabled.
       * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
<span class="line-modified">!      * @throws    SocketException if there is an error</span>
       * in the underlying protocol, such as an UDP error.
       * @since 1.4
       * @see #setBroadcast(boolean)
       */
      public synchronized boolean getBroadcast() throws SocketException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1268,11 ***</span>
      }
  
      /**
       * User defined factory for all datagram sockets.
       */
<span class="line-modified">!     static DatagramSocketImplFactory factory;</span>
  
      /**
       * Sets the datagram socket implementation factory for the
       * application. The factory can be specified only once.
       * &lt;p&gt;
<span class="line-new-header">--- 1371,11 ---</span>
      }
  
      /**
       * User defined factory for all datagram sockets.
       */
<span class="line-modified">!     private static volatile DatagramSocketImplFactory factory;</span>
  
      /**
       * Sets the datagram socket implementation factory for the
       * application. The factory can be specified only once.
       * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1287,14 ***</span>
       * the security manager&#39;s {@code checkSetFactory} method
       * to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
       * @param      fac   the desired factory.
<span class="line-modified">!      * @exception  IOException  if an I/O error occurs when setting the</span>
       *              datagram socket factory.
<span class="line-modified">!      * @exception  SocketException  if the factory is already defined.</span>
<span class="line-modified">!      * @exception  SecurityException  if a security manager exists and its</span>
       *             {@code checkSetFactory} method doesn&#39;t allow the operation.
       * @see       java.net.DatagramSocketImplFactory#createDatagramSocketImpl()
       * @see       SecurityManager#checkSetFactory
       * @since 1.3
       */
<span class="line-new-header">--- 1390,14 ---</span>
       * the security manager&#39;s {@code checkSetFactory} method
       * to ensure the operation is allowed.
       * This could result in a SecurityException.
       *
       * @param      fac   the desired factory.
<span class="line-modified">!      * @throws     IOException  if an I/O error occurs when setting the</span>
       *              datagram socket factory.
<span class="line-modified">!      * @throws     SocketException  if the factory is already defined.</span>
<span class="line-modified">!      * @throws     SecurityException  if a security manager exists and its</span>
       *             {@code checkSetFactory} method doesn&#39;t allow the operation.
       * @see       java.net.DatagramSocketImplFactory#createDatagramSocketImpl()
       * @see       SecurityManager#checkSetFactory
       * @since 1.3
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1341,10 ***</span>
<span class="line-new-header">--- 1444,13 ---</span>
       * @since 9
       */
      public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value)
          throws IOException
      {
<span class="line-added">+         Objects.requireNonNull(name);</span>
<span class="line-added">+         if (isClosed())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
          getImpl().setOption(name, value);
          return this;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1369,10 ***</span>
<span class="line-new-header">--- 1475,13 ---</span>
       *         do not require any security permission.
       *
       * @since 9
       */
      public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="line-added">+         Objects.requireNonNull(name);</span>
<span class="line-added">+         if (isClosed())</span>
<span class="line-added">+             throw new SocketException(&quot;Socket is closed&quot;);</span>
          return getImpl().getOption(name);
      }
  
      private static Set&lt;SocketOption&lt;?&gt;&gt; options;
      private static boolean optionsSet = false;
</pre>
<center><a href="DatagramPacket.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DatagramSocketImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
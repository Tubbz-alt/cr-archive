<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/stream/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MatchOps.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../zip/Adler32.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/stream/package-info.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 /**
 27  * Classes to support functional-style operations on streams of elements, such
 28  * as map-reduce transformations on collections.  For example:
 29  *
 30  * &lt;pre&gt;{@code
 31  *     int sum = widgets.stream()
 32  *                      .filter(b -&gt; b.getColor() == RED)
 33  *                      .mapToInt(b -&gt; b.getWeight())
 34  *                      .sum();
 35  * }&lt;/pre&gt;
 36  *
 37  * &lt;p&gt;Here we use {@code widgets}, a {@code Collection&lt;Widget&gt;},
 38  * as a source for a stream, and then perform a filter-map-reduce on the stream
 39  * to obtain the sum of the weights of the red widgets.  (Summation is an
 40  * example of a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;
 41  * operation.)
 42  *
 43  * &lt;p&gt;The key abstraction introduced in this package is &lt;em&gt;stream&lt;/em&gt;.  The
 44  * classes {@link java.util.stream.Stream}, {@link java.util.stream.IntStream},
 45  * {@link java.util.stream.LongStream}, and {@link java.util.stream.DoubleStream}
<span class="line-modified"> 46  * are streams over objects and the primitive {@code int}, {@code long} and</span>
 47  * {@code double} types.  Streams differ from collections in several ways:
 48  *
 49  * &lt;ul&gt;
 50  *     &lt;li&gt;No storage.  A stream is not a data structure that stores elements;
 51  *     instead, it conveys elements from a source such as a data structure,
 52  *     an array, a generator function, or an I/O channel, through a pipeline of
 53  *     computational operations.&lt;/li&gt;
 54  *     &lt;li&gt;Functional in nature.  An operation on a stream produces a result,
 55  *     but does not modify its source.  For example, filtering a {@code Stream}
 56  *     obtained from a collection produces a new {@code Stream} without the
 57  *     filtered elements, rather than removing elements from the source
 58  *     collection.&lt;/li&gt;
 59  *     &lt;li&gt;Laziness-seeking.  Many stream operations, such as filtering, mapping,
 60  *     or duplicate removal, can be implemented lazily, exposing opportunities
 61  *     for optimization.  For example, &quot;find the first {@code String} with
 62  *     three consecutive vowels&quot; need not examine all the input strings.
 63  *     Stream operations are divided into intermediate ({@code Stream}-producing)
 64  *     operations and terminal (value- or side-effect-producing) operations.
 65  *     Intermediate operations are always lazy.&lt;/li&gt;
 66  *     &lt;li&gt;Possibly unbounded.  While collections have a finite size, streams
</pre>
<hr />
<pre>
159  * is a necessary, but not sufficient, condition for the processing of an infinite
160  * stream to terminate normally in finite time.
161  *
162  * &lt;h3&gt;&lt;a id=&quot;Parallelism&quot;&gt;Parallelism&lt;/a&gt;&lt;/h3&gt;
163  *
164  * &lt;p&gt;Processing elements with an explicit {@code for-}loop is inherently serial.
165  * Streams facilitate parallel execution by reframing the computation as a pipeline of
166  * aggregate operations, rather than as imperative operations on each individual
167  * element.  All streams operations can execute either in serial or in parallel.
168  * The stream implementations in the JDK create serial streams unless parallelism is
169  * explicitly requested.  For example, {@code Collection} has methods
170  * {@link java.util.Collection#stream} and {@link java.util.Collection#parallelStream},
171  * which produce sequential and parallel streams respectively; other
172  * stream-bearing methods such as {@link java.util.stream.IntStream#range(int, int)}
173  * produce sequential streams but these streams can be efficiently parallelized by
174  * invoking their {@link java.util.stream.BaseStream#parallel()} method.
175  * To execute the prior &quot;sum of weights of widgets&quot; query in parallel, we would
176  * do:
177  *
178  * &lt;pre&gt;{@code
<span class="line-modified">179  *     int sumOfWeights = widgets.}&lt;code&gt;&lt;b&gt;parallelStream()&lt;/b&gt;&lt;/code&gt;{@code</span>
180  *                               .filter(b -&gt; b.getColor() == RED)
181  *                               .mapToInt(b -&gt; b.getWeight())
182  *                               .sum();
183  * }&lt;/pre&gt;
184  *
185  * &lt;p&gt;The only difference between the serial and parallel versions of this
186  * example is the creation of the initial stream, using &quot;{@code parallelStream()}&quot;
187  * instead of &quot;{@code stream()}&quot;. The stream pipeline is executed sequentially or
188  * in parallel depending on the mode of the stream on which the terminal operation
189  * is invoked. The sequential or parallel mode of a stream can be determined with the
190  * {@link java.util.stream.BaseStream#isParallel()} method, and the
191  * stream&#39;s mode can be modified with the
192  * {@link java.util.stream.BaseStream#sequential()} and
193  * {@link java.util.stream.BaseStream#parallel()} operations.
194  * The most recent sequential or parallel mode setting applies to the
195  * execution of the entire stream pipeline.
196  *
197  * &lt;p&gt;Except for operations identified as explicitly nondeterministic, such
198  * as {@code findAny()}, whether a stream executes sequentially or in parallel
199  * should not change the result of the computation.
</pre>
<hr />
<pre>
225  * &lt;p&gt;Accordingly, behavioral parameters in stream pipelines whose source might
226  * not be concurrent should never modify the stream&#39;s data source.
227  * A behavioral parameter is said to &lt;em&gt;interfere&lt;/em&gt; with a non-concurrent
228  * data source if it modifies, or causes to be
229  * modified, the stream&#39;s data source.  The need for non-interference applies
230  * to all pipelines, not just parallel ones.  Unless the stream source is
231  * concurrent, modifying a stream&#39;s data source during execution of a stream
232  * pipeline can cause exceptions, incorrect answers, or nonconformant behavior.
233  *
234  * For well-behaved stream sources, the source can be modified before the
235  * terminal operation commences and those modifications will be reflected in
236  * the covered elements.  For example, consider the following code:
237  *
238  * &lt;pre&gt;{@code
239  *     List&lt;String&gt; l = new ArrayList(Arrays.asList(&quot;one&quot;, &quot;two&quot;));
240  *     Stream&lt;String&gt; sl = l.stream();
241  *     l.add(&quot;three&quot;);
242  *     String s = sl.collect(joining(&quot; &quot;));
243  * }&lt;/pre&gt;
244  *
<span class="line-modified">245  * First a list is created consisting of two strings: &quot;one&quot;; and &quot;two&quot;. Then a</span>
246  * stream is created from that list. Next the list is modified by adding a third
247  * string: &quot;three&quot;. Finally the elements of the stream are collected and joined
248  * together. Since the list was modified before the terminal {@code collect}
249  * operation commenced the result will be a string of &quot;one two three&quot;. All the
250  * streams returned from JDK collections, and most other JDK classes,
251  * are well-behaved in this manner; for streams generated by other libraries, see
252  * &lt;a href=&quot;package-summary.html#StreamSources&quot;&gt;Low-level stream
253  * construction&lt;/a&gt; for requirements for building well-behaved streams.
254  *
255  * &lt;h3&gt;&lt;a id=&quot;Statelessness&quot;&gt;Stateless behaviors&lt;/a&gt;&lt;/h3&gt;
256  *
257  * Stream pipeline results may be nondeterministic or incorrect if the behavioral
258  * parameters to the stream operations are &lt;em&gt;stateful&lt;/em&gt;.  A stateful lambda
259  * (or other object implementing the appropriate functional interface) is one
260  * whose result depends on any state which might change during the execution
261  * of the stream pipeline.  An example of a stateful lambda is the parameter
262  * to {@code map()} in:
263  *
264  * &lt;pre&gt;{@code
265  *     Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());
</pre>
<hr />
<pre>
327  * &lt;p&gt;As an example of how to transform a stream pipeline that inappropriately
328  * uses side-effects to one that does not, the following code searches a stream
329  * of strings for those matching a given regular expression, and puts the
330  * matches in a list.
331  *
332  * &lt;pre&gt;{@code
333  *     ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();
334  *     stream.filter(s -&gt; pattern.matcher(s).matches())
335  *           .forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!
336  * }&lt;/pre&gt;
337  *
338  * This code unnecessarily uses side-effects.  If executed in parallel, the
339  * non-thread-safety of {@code ArrayList} would cause incorrect results, and
340  * adding needed synchronization would cause contention, undermining the
341  * benefit of parallelism.  Furthermore, using side-effects here is completely
342  * unnecessary; the {@code forEach()} can simply be replaced with a reduction
343  * operation that is safer, more efficient, and more amenable to
344  * parallelization:
345  *
346  * &lt;pre&gt;{@code
<span class="line-modified">347  *     List&lt;String&gt;results =</span>
348  *         stream.filter(s -&gt; pattern.matcher(s).matches())
349  *               .collect(Collectors.toList());  // No side-effects!
350  * }&lt;/pre&gt;
351  *
352  * &lt;h3&gt;&lt;a id=&quot;Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/h3&gt;
353  *
354  * &lt;p&gt;Streams may or may not have a defined &lt;em&gt;encounter order&lt;/em&gt;.  Whether
355  * or not a stream has an encounter order depends on the source and the
356  * intermediate operations.  Certain stream sources (such as {@code List} or
357  * arrays) are intrinsically ordered, whereas others (such as {@code HashSet})
358  * are not.  Some intermediate operations, such as {@code sorted()}, may impose
359  * an encounter order on an otherwise unordered stream, and others may render an
360  * ordered stream unordered, such as {@link java.util.stream.BaseStream#unordered()}.
361  * Further, some terminal operations may ignore encounter order, such as
362  * {@code forEach()}.
363  *
364  * &lt;p&gt;If a stream is ordered, most operations are constrained to operate on the
365  * elements in their encounter order; if the source of a stream is a {@code List}
366  * containing {@code [1, 2, 3]}, then the result of executing {@code map(x -&gt; x*2)}
367  * must be {@code [2, 4, 6]}.  However, if the source has no defined encounter
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 /**
 27  * Classes to support functional-style operations on streams of elements, such
 28  * as map-reduce transformations on collections.  For example:
 29  *
 30  * &lt;pre&gt;{@code
 31  *     int sum = widgets.stream()
 32  *                      .filter(b -&gt; b.getColor() == RED)
 33  *                      .mapToInt(b -&gt; b.getWeight())
 34  *                      .sum();
 35  * }&lt;/pre&gt;
 36  *
 37  * &lt;p&gt;Here we use {@code widgets}, a {@code Collection&lt;Widget&gt;},
 38  * as a source for a stream, and then perform a filter-map-reduce on the stream
 39  * to obtain the sum of the weights of the red widgets.  (Summation is an
 40  * example of a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;
 41  * operation.)
 42  *
 43  * &lt;p&gt;The key abstraction introduced in this package is &lt;em&gt;stream&lt;/em&gt;.  The
 44  * classes {@link java.util.stream.Stream}, {@link java.util.stream.IntStream},
 45  * {@link java.util.stream.LongStream}, and {@link java.util.stream.DoubleStream}
<span class="line-modified"> 46  * are streams over objects and the primitive {@code int}, {@code long}, and</span>
 47  * {@code double} types.  Streams differ from collections in several ways:
 48  *
 49  * &lt;ul&gt;
 50  *     &lt;li&gt;No storage.  A stream is not a data structure that stores elements;
 51  *     instead, it conveys elements from a source such as a data structure,
 52  *     an array, a generator function, or an I/O channel, through a pipeline of
 53  *     computational operations.&lt;/li&gt;
 54  *     &lt;li&gt;Functional in nature.  An operation on a stream produces a result,
 55  *     but does not modify its source.  For example, filtering a {@code Stream}
 56  *     obtained from a collection produces a new {@code Stream} without the
 57  *     filtered elements, rather than removing elements from the source
 58  *     collection.&lt;/li&gt;
 59  *     &lt;li&gt;Laziness-seeking.  Many stream operations, such as filtering, mapping,
 60  *     or duplicate removal, can be implemented lazily, exposing opportunities
 61  *     for optimization.  For example, &quot;find the first {@code String} with
 62  *     three consecutive vowels&quot; need not examine all the input strings.
 63  *     Stream operations are divided into intermediate ({@code Stream}-producing)
 64  *     operations and terminal (value- or side-effect-producing) operations.
 65  *     Intermediate operations are always lazy.&lt;/li&gt;
 66  *     &lt;li&gt;Possibly unbounded.  While collections have a finite size, streams
</pre>
<hr />
<pre>
159  * is a necessary, but not sufficient, condition for the processing of an infinite
160  * stream to terminate normally in finite time.
161  *
162  * &lt;h3&gt;&lt;a id=&quot;Parallelism&quot;&gt;Parallelism&lt;/a&gt;&lt;/h3&gt;
163  *
164  * &lt;p&gt;Processing elements with an explicit {@code for-}loop is inherently serial.
165  * Streams facilitate parallel execution by reframing the computation as a pipeline of
166  * aggregate operations, rather than as imperative operations on each individual
167  * element.  All streams operations can execute either in serial or in parallel.
168  * The stream implementations in the JDK create serial streams unless parallelism is
169  * explicitly requested.  For example, {@code Collection} has methods
170  * {@link java.util.Collection#stream} and {@link java.util.Collection#parallelStream},
171  * which produce sequential and parallel streams respectively; other
172  * stream-bearing methods such as {@link java.util.stream.IntStream#range(int, int)}
173  * produce sequential streams but these streams can be efficiently parallelized by
174  * invoking their {@link java.util.stream.BaseStream#parallel()} method.
175  * To execute the prior &quot;sum of weights of widgets&quot; query in parallel, we would
176  * do:
177  *
178  * &lt;pre&gt;{@code
<span class="line-modified">179  *     int sumOfWeights = widgets.parallelStream()</span>
180  *                               .filter(b -&gt; b.getColor() == RED)
181  *                               .mapToInt(b -&gt; b.getWeight())
182  *                               .sum();
183  * }&lt;/pre&gt;
184  *
185  * &lt;p&gt;The only difference between the serial and parallel versions of this
186  * example is the creation of the initial stream, using &quot;{@code parallelStream()}&quot;
187  * instead of &quot;{@code stream()}&quot;. The stream pipeline is executed sequentially or
188  * in parallel depending on the mode of the stream on which the terminal operation
189  * is invoked. The sequential or parallel mode of a stream can be determined with the
190  * {@link java.util.stream.BaseStream#isParallel()} method, and the
191  * stream&#39;s mode can be modified with the
192  * {@link java.util.stream.BaseStream#sequential()} and
193  * {@link java.util.stream.BaseStream#parallel()} operations.
194  * The most recent sequential or parallel mode setting applies to the
195  * execution of the entire stream pipeline.
196  *
197  * &lt;p&gt;Except for operations identified as explicitly nondeterministic, such
198  * as {@code findAny()}, whether a stream executes sequentially or in parallel
199  * should not change the result of the computation.
</pre>
<hr />
<pre>
225  * &lt;p&gt;Accordingly, behavioral parameters in stream pipelines whose source might
226  * not be concurrent should never modify the stream&#39;s data source.
227  * A behavioral parameter is said to &lt;em&gt;interfere&lt;/em&gt; with a non-concurrent
228  * data source if it modifies, or causes to be
229  * modified, the stream&#39;s data source.  The need for non-interference applies
230  * to all pipelines, not just parallel ones.  Unless the stream source is
231  * concurrent, modifying a stream&#39;s data source during execution of a stream
232  * pipeline can cause exceptions, incorrect answers, or nonconformant behavior.
233  *
234  * For well-behaved stream sources, the source can be modified before the
235  * terminal operation commences and those modifications will be reflected in
236  * the covered elements.  For example, consider the following code:
237  *
238  * &lt;pre&gt;{@code
239  *     List&lt;String&gt; l = new ArrayList(Arrays.asList(&quot;one&quot;, &quot;two&quot;));
240  *     Stream&lt;String&gt; sl = l.stream();
241  *     l.add(&quot;three&quot;);
242  *     String s = sl.collect(joining(&quot; &quot;));
243  * }&lt;/pre&gt;
244  *
<span class="line-modified">245  * First a list is created consisting of two strings: &quot;one&quot; and &quot;two&quot;. Then a</span>
246  * stream is created from that list. Next the list is modified by adding a third
247  * string: &quot;three&quot;. Finally the elements of the stream are collected and joined
248  * together. Since the list was modified before the terminal {@code collect}
249  * operation commenced the result will be a string of &quot;one two three&quot;. All the
250  * streams returned from JDK collections, and most other JDK classes,
251  * are well-behaved in this manner; for streams generated by other libraries, see
252  * &lt;a href=&quot;package-summary.html#StreamSources&quot;&gt;Low-level stream
253  * construction&lt;/a&gt; for requirements for building well-behaved streams.
254  *
255  * &lt;h3&gt;&lt;a id=&quot;Statelessness&quot;&gt;Stateless behaviors&lt;/a&gt;&lt;/h3&gt;
256  *
257  * Stream pipeline results may be nondeterministic or incorrect if the behavioral
258  * parameters to the stream operations are &lt;em&gt;stateful&lt;/em&gt;.  A stateful lambda
259  * (or other object implementing the appropriate functional interface) is one
260  * whose result depends on any state which might change during the execution
261  * of the stream pipeline.  An example of a stateful lambda is the parameter
262  * to {@code map()} in:
263  *
264  * &lt;pre&gt;{@code
265  *     Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());
</pre>
<hr />
<pre>
327  * &lt;p&gt;As an example of how to transform a stream pipeline that inappropriately
328  * uses side-effects to one that does not, the following code searches a stream
329  * of strings for those matching a given regular expression, and puts the
330  * matches in a list.
331  *
332  * &lt;pre&gt;{@code
333  *     ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();
334  *     stream.filter(s -&gt; pattern.matcher(s).matches())
335  *           .forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!
336  * }&lt;/pre&gt;
337  *
338  * This code unnecessarily uses side-effects.  If executed in parallel, the
339  * non-thread-safety of {@code ArrayList} would cause incorrect results, and
340  * adding needed synchronization would cause contention, undermining the
341  * benefit of parallelism.  Furthermore, using side-effects here is completely
342  * unnecessary; the {@code forEach()} can simply be replaced with a reduction
343  * operation that is safer, more efficient, and more amenable to
344  * parallelization:
345  *
346  * &lt;pre&gt;{@code
<span class="line-modified">347  *     List&lt;String&gt; results =</span>
348  *         stream.filter(s -&gt; pattern.matcher(s).matches())
349  *               .collect(Collectors.toList());  // No side-effects!
350  * }&lt;/pre&gt;
351  *
352  * &lt;h3&gt;&lt;a id=&quot;Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/h3&gt;
353  *
354  * &lt;p&gt;Streams may or may not have a defined &lt;em&gt;encounter order&lt;/em&gt;.  Whether
355  * or not a stream has an encounter order depends on the source and the
356  * intermediate operations.  Certain stream sources (such as {@code List} or
357  * arrays) are intrinsically ordered, whereas others (such as {@code HashSet})
358  * are not.  Some intermediate operations, such as {@code sorted()}, may impose
359  * an encounter order on an otherwise unordered stream, and others may render an
360  * ordered stream unordered, such as {@link java.util.stream.BaseStream#unordered()}.
361  * Further, some terminal operations may ignore encounter order, such as
362  * {@code forEach()}.
363  *
364  * &lt;p&gt;If a stream is ordered, most operations are constrained to operate on the
365  * elements in their encounter order; if the source of a stream is a {@code List}
366  * containing {@code [1, 2, 3]}, then the result of executing {@code map(x -&gt; x*2)}
367  * must be {@code [2, 4, 6]}.  However, if the source has no defined encounter
</pre>
</td>
</tr>
</table>
<center><a href="MatchOps.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../zip/Adler32.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
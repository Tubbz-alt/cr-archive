<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/Base64.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.FilterOutputStream;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.nio.ByteBuffer;
  33 import java.nio.charset.StandardCharsets;
<a name="1" id="anc1"></a>


  34 import jdk.internal.HotSpotIntrinsicCandidate;
  35 
  36 /**
  37  * This class consists exclusively of static methods for obtaining
  38  * encoders and decoders for the Base64 encoding scheme. The
  39  * implementation of this class supports the following types of Base64
  40  * as specified in
  41  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc4648.txt&quot;&gt;RFC 4648&lt;/a&gt; and
  42  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;.
  43  *
  44  * &lt;ul&gt;
  45  * &lt;li&gt;&lt;a id=&quot;basic&quot;&gt;&lt;b&gt;Basic&lt;/b&gt;&lt;/a&gt;
  46  * &lt;p&gt; Uses &quot;The Base64 Alphabet&quot; as specified in Table 1 of
  47  *     RFC 4648 and RFC 2045 for encoding and decoding operation.
  48  *     The encoder does not add any line feed (line separator)
  49  *     character. The decoder rejects data that contains characters
  50  *     outside the base64 alphabet.&lt;/p&gt;&lt;/li&gt;
  51  *
  52  * &lt;li&gt;&lt;a id=&quot;url&quot;&gt;&lt;b&gt;URL and Filename safe&lt;/b&gt;&lt;/a&gt;
  53  * &lt;p&gt; Uses the &quot;URL and Filename safe Base64 Alphabet&quot; as specified
  54  *     in Table 2 of RFC 4648 for encoding and decoding. The
  55  *     encoder does not add any line feed (line separator) character.
  56  *     The decoder rejects data that contains characters outside the
  57  *     base64 alphabet.&lt;/p&gt;&lt;/li&gt;
  58  *
  59  * &lt;li&gt;&lt;a id=&quot;mime&quot;&gt;&lt;b&gt;MIME&lt;/b&gt;&lt;/a&gt;
  60  * &lt;p&gt; Uses &quot;The Base64 Alphabet&quot; as specified in Table 1 of
  61  *     RFC 2045 for encoding and decoding operation. The encoded output
  62  *     must be represented in lines of no more than 76 characters each
  63  *     and uses a carriage return {@code &#39;\r&#39;} followed immediately by
  64  *     a linefeed {@code &#39;\n&#39;} as the line separator. No line separator
  65  *     is added to the end of the encoded output. All line separators
  66  *     or other characters not found in the base64 alphabet table are
  67  *     ignored in decoding operation.&lt;/p&gt;&lt;/li&gt;
  68  * &lt;/ul&gt;
  69  *
  70  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a
  71  * method of this class will cause a {@link java.lang.NullPointerException
  72  * NullPointerException} to be thrown.
  73  *
  74  * @author  Xueming Shen
  75  * @since   1.8
  76  */
  77 
  78 public class Base64 {
  79 
  80     private Base64() {}
  81 
  82     /**
  83      * Returns a {@link Encoder} that encodes using the
  84      * &lt;a href=&quot;#basic&quot;&gt;Basic&lt;/a&gt; type base64 encoding scheme.
  85      *
  86      * @return  A Base64 encoder.
  87      */
  88     public static Encoder getEncoder() {
  89          return Encoder.RFC4648;
  90     }
  91 
  92     /**
  93      * Returns a {@link Encoder} that encodes using the
  94      * &lt;a href=&quot;#url&quot;&gt;URL and Filename safe&lt;/a&gt; type base64
  95      * encoding scheme.
  96      *
  97      * @return  A Base64 encoder.
  98      */
  99     public static Encoder getUrlEncoder() {
 100          return Encoder.RFC4648_URLSAFE;
 101     }
 102 
 103     /**
 104      * Returns a {@link Encoder} that encodes using the
 105      * &lt;a href=&quot;#mime&quot;&gt;MIME&lt;/a&gt; type base64 encoding scheme.
 106      *
 107      * @return  A Base64 encoder.
 108      */
 109     public static Encoder getMimeEncoder() {
 110         return Encoder.RFC2045;
 111     }
 112 
 113     /**
 114      * Returns a {@link Encoder} that encodes using the
 115      * &lt;a href=&quot;#mime&quot;&gt;MIME&lt;/a&gt; type base64 encoding scheme
 116      * with specified line length and line separators.
 117      *
 118      * @param   lineLength
 119      *          the length of each output line (rounded down to nearest multiple
 120      *          of 4). If the rounded down line length is not a positive value,
 121      *          the output will not be separated in lines
 122      * @param   lineSeparator
 123      *          the line separator for each output line
 124      *
 125      * @return  A Base64 encoder.
 126      *
 127      * @throws  IllegalArgumentException if {@code lineSeparator} includes any
 128      *          character of &quot;The Base64 Alphabet&quot; as specified in Table 1 of
 129      *          RFC 2045.
 130      */
 131     public static Encoder getMimeEncoder(int lineLength, byte[] lineSeparator) {
 132          Objects.requireNonNull(lineSeparator);
 133          int[] base64 = Decoder.fromBase64;
 134          for (byte b : lineSeparator) {
 135              if (base64[b &amp; 0xff] != -1)
 136                  throw new IllegalArgumentException(
 137                      &quot;Illegal base64 line separator character 0x&quot; + Integer.toString(b, 16));
 138          }
 139          // round down to nearest multiple of 4
 140          lineLength &amp;= ~0b11;
 141          if (lineLength &lt;= 0) {
 142              return Encoder.RFC4648;
 143          }
 144          return new Encoder(false, lineSeparator, lineLength, true);
 145     }
 146 
 147     /**
 148      * Returns a {@link Decoder} that decodes using the
 149      * &lt;a href=&quot;#basic&quot;&gt;Basic&lt;/a&gt; type base64 encoding scheme.
 150      *
 151      * @return  A Base64 decoder.
 152      */
 153     public static Decoder getDecoder() {
 154          return Decoder.RFC4648;
 155     }
 156 
 157     /**
 158      * Returns a {@link Decoder} that decodes using the
 159      * &lt;a href=&quot;#url&quot;&gt;URL and Filename safe&lt;/a&gt; type base64
 160      * encoding scheme.
 161      *
 162      * @return  A Base64 decoder.
 163      */
 164     public static Decoder getUrlDecoder() {
 165          return Decoder.RFC4648_URLSAFE;
 166     }
 167 
 168     /**
 169      * Returns a {@link Decoder} that decodes using the
 170      * &lt;a href=&quot;#mime&quot;&gt;MIME&lt;/a&gt; type base64 decoding scheme.
 171      *
 172      * @return  A Base64 decoder.
 173      */
 174     public static Decoder getMimeDecoder() {
 175          return Decoder.RFC2045;
 176     }
 177 
 178     /**
 179      * This class implements an encoder for encoding byte data using
 180      * the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.
 181      *
 182      * &lt;p&gt; Instances of {@link Encoder} class are safe for use by
 183      * multiple concurrent threads.
 184      *
 185      * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to
 186      * a method of this class will cause a
 187      * {@link java.lang.NullPointerException NullPointerException} to
 188      * be thrown.
 189      * &lt;p&gt; If the encoded byte output of the needed size can not
 190      *     be allocated, the encode methods of this class will
 191      *     cause an {@link java.lang.OutOfMemoryError OutOfMemoryError}
 192      *     to be thrown.
 193      *
 194      * @see     Decoder
 195      * @since   1.8
 196      */
 197     public static class Encoder {
 198 
 199         private final byte[] newline;
 200         private final int linemax;
 201         private final boolean isURL;
 202         private final boolean doPadding;
 203 
 204         private Encoder(boolean isURL, byte[] newline, int linemax, boolean doPadding) {
 205             this.isURL = isURL;
 206             this.newline = newline;
 207             this.linemax = linemax;
 208             this.doPadding = doPadding;
 209         }
 210 
 211         /**
 212          * This array is a lookup table that translates 6-bit positive integer
 213          * index values into their &quot;Base64 Alphabet&quot; equivalents as specified
 214          * in &quot;Table 1: The Base64 Alphabet&quot; of RFC 2045 (and RFC 4648).
 215          */
 216         private static final char[] toBase64 = {
 217             &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;,
 218             &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;,
 219             &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;,
 220             &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;,
 221             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;, &#39;/&#39;
 222         };
 223 
 224         /**
 225          * It&#39;s the lookup table for &quot;URL and Filename safe Base64&quot; as specified
 226          * in Table 2 of the RFC 4648, with the &#39;+&#39; and &#39;/&#39; changed to &#39;-&#39; and
 227          * &#39;_&#39;. This table is used when BASE64_URL is specified.
 228          */
 229         private static final char[] toBase64URL = {
 230             &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;,
 231             &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;,
 232             &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;,
 233             &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;,
 234             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;-&#39;, &#39;_&#39;
 235         };
 236 
 237         private static final int MIMELINEMAX = 76;
 238         private static final byte[] CRLF = new byte[] {&#39;\r&#39;, &#39;\n&#39;};
 239 
 240         static final Encoder RFC4648 = new Encoder(false, null, -1, true);
 241         static final Encoder RFC4648_URLSAFE = new Encoder(true, null, -1, true);
 242         static final Encoder RFC2045 = new Encoder(false, CRLF, MIMELINEMAX, true);
 243 
 244         /**
 245          * Calculates the length of the encoded output bytes.
 246          *
 247          * @param srclen length of the bytes to encode
 248          * @param throwOOME if true, throws OutOfMemoryError if the length of
 249          *                  the encoded bytes overflows; else returns the
 250          *                  length
 251          * @return length of the encoded bytes, or -1 if the length overflows
 252          *
 253          */
 254         private final int encodedOutLength(int srclen, boolean throwOOME) {
 255             int len = 0;
 256             try {
 257                 if (doPadding) {
 258                     len = Math.multiplyExact(4, (Math.addExact(srclen, 2) / 3));
 259                 } else {
 260                     int n = srclen % 3;
 261                     len = Math.addExact(Math.multiplyExact(4, (srclen / 3)), (n == 0 ? 0 : n + 1));
 262                 }
 263                 if (linemax &gt; 0) {                             // line separators
 264                     len = Math.addExact(len, (len - 1) / linemax * newline.length);
 265                 }
 266             } catch (ArithmeticException ex) {
 267                 if (throwOOME) {
 268                     throw new OutOfMemoryError(&quot;Encoded size is too large&quot;);
 269                 } else {
 270                     // let the caller know that encoded bytes length
 271                     // is too large
 272                     len = -1;
 273                 }
 274             }
 275             return len;
 276         }
 277 
 278         /**
 279          * Encodes all bytes from the specified byte array into a newly-allocated
 280          * byte array using the {@link Base64} encoding scheme. The returned byte
 281          * array is of the length of the resulting bytes.
 282          *
 283          * @param   src
 284          *          the byte array to encode
 285          * @return  A newly-allocated byte array containing the resulting
 286          *          encoded bytes.
 287          */
 288         public byte[] encode(byte[] src) {
 289             int len = encodedOutLength(src.length, true);          // dst array size
 290             byte[] dst = new byte[len];
 291             int ret = encode0(src, 0, src.length, dst);
 292             if (ret != dst.length)
 293                  return Arrays.copyOf(dst, ret);
 294             return dst;
 295         }
 296 
 297         /**
 298          * Encodes all bytes from the specified byte array using the
 299          * {@link Base64} encoding scheme, writing the resulting bytes to the
 300          * given output byte array, starting at offset 0.
 301          *
 302          * &lt;p&gt; It is the responsibility of the invoker of this method to make
 303          * sure the output byte array {@code dst} has enough space for encoding
 304          * all bytes from the input byte array. No bytes will be written to the
 305          * output byte array if the output byte array is not big enough.
 306          *
 307          * @param   src
 308          *          the byte array to encode
 309          * @param   dst
 310          *          the output byte array
 311          * @return  The number of bytes written to the output byte array
 312          *
 313          * @throws  IllegalArgumentException if {@code dst} does not have enough
 314          *          space for encoding all input bytes.
 315          */
 316         public int encode(byte[] src, byte[] dst) {
 317             int len = encodedOutLength(src.length, false);         // dst array size
 318             if (dst.length &lt; len || len == -1)
 319                 throw new IllegalArgumentException(
 320                     &quot;Output byte array is too small for encoding all input bytes&quot;);
 321             return encode0(src, 0, src.length, dst);
 322         }
 323 
 324         /**
 325          * Encodes the specified byte array into a String using the {@link Base64}
 326          * encoding scheme.
 327          *
 328          * &lt;p&gt; This method first encodes all input bytes into a base64 encoded
 329          * byte array and then constructs a new String by using the encoded byte
 330          * array and the {@link java.nio.charset.StandardCharsets#ISO_8859_1
 331          * ISO-8859-1} charset.
 332          *
 333          * &lt;p&gt; In other words, an invocation of this method has exactly the same
 334          * effect as invoking
 335          * {@code new String(encode(src), StandardCharsets.ISO_8859_1)}.
 336          *
 337          * @param   src
 338          *          the byte array to encode
 339          * @return  A String containing the resulting Base64 encoded characters
 340          */
 341         @SuppressWarnings(&quot;deprecation&quot;)
 342         public String encodeToString(byte[] src) {
 343             byte[] encoded = encode(src);
 344             return new String(encoded, 0, 0, encoded.length);
 345         }
 346 
 347         /**
 348          * Encodes all remaining bytes from the specified byte buffer into
 349          * a newly-allocated ByteBuffer using the {@link Base64} encoding
 350          * scheme.
 351          *
 352          * Upon return, the source buffer&#39;s position will be updated to
 353          * its limit; its limit will not have been changed. The returned
 354          * output buffer&#39;s position will be zero and its limit will be the
 355          * number of resulting encoded bytes.
 356          *
 357          * @param   buffer
 358          *          the source ByteBuffer to encode
 359          * @return  A newly-allocated byte buffer containing the encoded bytes.
 360          */
 361         public ByteBuffer encode(ByteBuffer buffer) {
 362             int len = encodedOutLength(buffer.remaining(), true);
 363             byte[] dst = new byte[len];
 364             int ret = 0;
 365             if (buffer.hasArray()) {
 366                 ret = encode0(buffer.array(),
 367                               buffer.arrayOffset() + buffer.position(),
 368                               buffer.arrayOffset() + buffer.limit(),
 369                               dst);
 370                 buffer.position(buffer.limit());
 371             } else {
 372                 byte[] src = new byte[buffer.remaining()];
 373                 buffer.get(src);
 374                 ret = encode0(src, 0, src.length, dst);
 375             }
 376             if (ret != dst.length)
 377                  dst = Arrays.copyOf(dst, ret);
 378             return ByteBuffer.wrap(dst);
 379         }
 380 
 381         /**
 382          * Wraps an output stream for encoding byte data using the {@link Base64}
 383          * encoding scheme.
 384          *
 385          * &lt;p&gt; It is recommended to promptly close the returned output stream after
 386          * use, during which it will flush all possible leftover bytes to the underlying
 387          * output stream. Closing the returned output stream will close the underlying
 388          * output stream.
 389          *
 390          * @param   os
 391          *          the output stream.
 392          * @return  the output stream for encoding the byte data into the
 393          *          specified Base64 encoded format
 394          */
 395         public OutputStream wrap(OutputStream os) {
 396             Objects.requireNonNull(os);
 397             return new EncOutputStream(os, isURL ? toBase64URL : toBase64,
 398                                        newline, linemax, doPadding);
 399         }
 400 
 401         /**
 402          * Returns an encoder instance that encodes equivalently to this one,
 403          * but without adding any padding character at the end of the encoded
 404          * byte data.
 405          *
 406          * &lt;p&gt; The encoding scheme of this encoder instance is unaffected by
 407          * this invocation. The returned encoder instance should be used for
 408          * non-padding encoding operation.
 409          *
 410          * @return an equivalent encoder that encodes without adding any
 411          *         padding character at the end
 412          */
 413         public Encoder withoutPadding() {
 414             if (!doPadding)
 415                 return this;
 416             return new Encoder(isURL, newline, linemax, false);
 417         }
 418 
 419         @HotSpotIntrinsicCandidate
 420         private void encodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL) {
 421             char[] base64 = isURL ? toBase64URL : toBase64;
 422             for (int sp0 = sp, dp0 = dp ; sp0 &lt; sl; ) {
 423                 int bits = (src[sp0++] &amp; 0xff) &lt;&lt; 16 |
 424                            (src[sp0++] &amp; 0xff) &lt;&lt;  8 |
 425                            (src[sp0++] &amp; 0xff);
 426                 dst[dp0++] = (byte)base64[(bits &gt;&gt;&gt; 18) &amp; 0x3f];
 427                 dst[dp0++] = (byte)base64[(bits &gt;&gt;&gt; 12) &amp; 0x3f];
 428                 dst[dp0++] = (byte)base64[(bits &gt;&gt;&gt; 6)  &amp; 0x3f];
 429                 dst[dp0++] = (byte)base64[bits &amp; 0x3f];
 430             }
 431         }
 432 
 433         private int encode0(byte[] src, int off, int end, byte[] dst) {
 434             char[] base64 = isURL ? toBase64URL : toBase64;
 435             int sp = off;
 436             int slen = (end - off) / 3 * 3;
 437             int sl = off + slen;
 438             if (linemax &gt; 0 &amp;&amp; slen  &gt; linemax / 4 * 3)
 439                 slen = linemax / 4 * 3;
 440             int dp = 0;
 441             while (sp &lt; sl) {
 442                 int sl0 = Math.min(sp + slen, sl);
 443                 encodeBlock(src, sp, sl0, dst, dp, isURL);
 444                 int dlen = (sl0 - sp) / 3 * 4;
 445                 dp += dlen;
 446                 sp = sl0;
 447                 if (dlen == linemax &amp;&amp; sp &lt; end) {
 448                     for (byte b : newline){
 449                         dst[dp++] = b;
 450                     }
 451                 }
 452             }
 453             if (sp &lt; end) {               // 1 or 2 leftover bytes
 454                 int b0 = src[sp++] &amp; 0xff;
 455                 dst[dp++] = (byte)base64[b0 &gt;&gt; 2];
 456                 if (sp == end) {
 457                     dst[dp++] = (byte)base64[(b0 &lt;&lt; 4) &amp; 0x3f];
 458                     if (doPadding) {
 459                         dst[dp++] = &#39;=&#39;;
 460                         dst[dp++] = &#39;=&#39;;
 461                     }
 462                 } else {
 463                     int b1 = src[sp++] &amp; 0xff;
 464                     dst[dp++] = (byte)base64[(b0 &lt;&lt; 4) &amp; 0x3f | (b1 &gt;&gt; 4)];
 465                     dst[dp++] = (byte)base64[(b1 &lt;&lt; 2) &amp; 0x3f];
 466                     if (doPadding) {
 467                         dst[dp++] = &#39;=&#39;;
 468                     }
 469                 }
 470             }
 471             return dp;
 472         }
 473     }
 474 
 475     /**
 476      * This class implements a decoder for decoding byte data using the
 477      * Base64 encoding scheme as specified in RFC 4648 and RFC 2045.
 478      *
 479      * &lt;p&gt; The Base64 padding character {@code &#39;=&#39;} is accepted and
 480      * interpreted as the end of the encoded byte data, but is not
 481      * required. So if the final unit of the encoded byte data only has
 482      * two or three Base64 characters (without the corresponding padding
 483      * character(s) padded), they are decoded as if followed by padding
 484      * character(s). If there is a padding character present in the
 485      * final unit, the correct number of padding character(s) must be
 486      * present, otherwise {@code IllegalArgumentException} (
 487      * {@code IOException} when reading from a Base64 stream) is thrown
 488      * during decoding.
 489      *
 490      * &lt;p&gt; Instances of {@link Decoder} class are safe for use by
 491      * multiple concurrent threads.
 492      *
 493      * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to
 494      * a method of this class will cause a
 495      * {@link java.lang.NullPointerException NullPointerException} to
 496      * be thrown.
 497      * &lt;p&gt; If the decoded byte output of the needed size can not
 498      *     be allocated, the decode methods of this class will
 499      *     cause an {@link java.lang.OutOfMemoryError OutOfMemoryError}
 500      *     to be thrown.
 501      *
 502      * @see     Encoder
 503      * @since   1.8
 504      */
 505     public static class Decoder {
 506 
 507         private final boolean isURL;
 508         private final boolean isMIME;
 509 
 510         private Decoder(boolean isURL, boolean isMIME) {
 511             this.isURL = isURL;
 512             this.isMIME = isMIME;
 513         }
 514 
 515         /**
 516          * Lookup table for decoding unicode characters drawn from the
 517          * &quot;Base64 Alphabet&quot; (as specified in Table 1 of RFC 2045) into
 518          * their 6-bit positive integer equivalents.  Characters that
 519          * are not in the Base64 alphabet but fall within the bounds of
 520          * the array are encoded to -1.
 521          *
 522          */
 523         private static final int[] fromBase64 = new int[256];
 524         static {
 525             Arrays.fill(fromBase64, -1);
 526             for (int i = 0; i &lt; Encoder.toBase64.length; i++)
 527                 fromBase64[Encoder.toBase64[i]] = i;
 528             fromBase64[&#39;=&#39;] = -2;
 529         }
 530 
 531         /**
 532          * Lookup table for decoding &quot;URL and Filename safe Base64 Alphabet&quot;
 533          * as specified in Table2 of the RFC 4648.
 534          */
 535         private static final int[] fromBase64URL = new int[256];
 536 
 537         static {
 538             Arrays.fill(fromBase64URL, -1);
 539             for (int i = 0; i &lt; Encoder.toBase64URL.length; i++)
 540                 fromBase64URL[Encoder.toBase64URL[i]] = i;
 541             fromBase64URL[&#39;=&#39;] = -2;
 542         }
 543 
 544         static final Decoder RFC4648         = new Decoder(false, false);
 545         static final Decoder RFC4648_URLSAFE = new Decoder(true, false);
 546         static final Decoder RFC2045         = new Decoder(false, true);
 547 
 548         /**
 549          * Decodes all bytes from the input byte array using the {@link Base64}
 550          * encoding scheme, writing the results into a newly-allocated output
 551          * byte array. The returned byte array is of the length of the resulting
 552          * bytes.
 553          *
 554          * @param   src
 555          *          the byte array to decode
 556          *
 557          * @return  A newly-allocated byte array containing the decoded bytes.
 558          *
 559          * @throws  IllegalArgumentException
 560          *          if {@code src} is not in valid Base64 scheme
 561          */
 562         public byte[] decode(byte[] src) {
 563             byte[] dst = new byte[decodedOutLength(src, 0, src.length)];
 564             int ret = decode0(src, 0, src.length, dst);
 565             if (ret != dst.length) {
 566                 dst = Arrays.copyOf(dst, ret);
 567             }
 568             return dst;
 569         }
 570 
 571         /**
 572          * Decodes a Base64 encoded String into a newly-allocated byte array
 573          * using the {@link Base64} encoding scheme.
 574          *
 575          * &lt;p&gt; An invocation of this method has exactly the same effect as invoking
 576          * {@code decode(src.getBytes(StandardCharsets.ISO_8859_1))}
 577          *
 578          * @param   src
 579          *          the string to decode
 580          *
 581          * @return  A newly-allocated byte array containing the decoded bytes.
 582          *
 583          * @throws  IllegalArgumentException
 584          *          if {@code src} is not in valid Base64 scheme
 585          */
 586         public byte[] decode(String src) {
<a name="2" id="anc2"></a><span class="line-modified"> 587             return decode(src.getBytes(StandardCharsets.ISO_8859_1));</span>
 588         }
 589 
 590         /**
 591          * Decodes all bytes from the input byte array using the {@link Base64}
 592          * encoding scheme, writing the results into the given output byte array,
 593          * starting at offset 0.
 594          *
 595          * &lt;p&gt; It is the responsibility of the invoker of this method to make
 596          * sure the output byte array {@code dst} has enough space for decoding
 597          * all bytes from the input byte array. No bytes will be written to
 598          * the output byte array if the output byte array is not big enough.
 599          *
 600          * &lt;p&gt; If the input byte array is not in valid Base64 encoding scheme
 601          * then some bytes may have been written to the output byte array before
 602          * IllegalargumentException is thrown.
 603          *
 604          * @param   src
 605          *          the byte array to decode
 606          * @param   dst
 607          *          the output byte array
 608          *
 609          * @return  The number of bytes written to the output byte array
 610          *
 611          * @throws  IllegalArgumentException
 612          *          if {@code src} is not in valid Base64 scheme, or {@code dst}
 613          *          does not have enough space for decoding all input bytes.
 614          */
 615         public int decode(byte[] src, byte[] dst) {
 616             int len = decodedOutLength(src, 0, src.length);
 617             if (dst.length &lt; len || len == -1)
 618                 throw new IllegalArgumentException(
 619                     &quot;Output byte array is too small for decoding all input bytes&quot;);
 620             return decode0(src, 0, src.length, dst);
 621         }
 622 
 623         /**
 624          * Decodes all bytes from the input byte buffer using the {@link Base64}
 625          * encoding scheme, writing the results into a newly-allocated ByteBuffer.
 626          *
 627          * &lt;p&gt; Upon return, the source buffer&#39;s position will be updated to
 628          * its limit; its limit will not have been changed. The returned
 629          * output buffer&#39;s position will be zero and its limit will be the
 630          * number of resulting decoded bytes
 631          *
 632          * &lt;p&gt; {@code IllegalArgumentException} is thrown if the input buffer
 633          * is not in valid Base64 encoding scheme. The position of the input
 634          * buffer will not be advanced in this case.
 635          *
 636          * @param   buffer
 637          *          the ByteBuffer to decode
 638          *
 639          * @return  A newly-allocated byte buffer containing the decoded bytes
 640          *
 641          * @throws  IllegalArgumentException
 642          *          if {@code buffer} is not in valid Base64 scheme
 643          */
 644         public ByteBuffer decode(ByteBuffer buffer) {
 645             int pos0 = buffer.position();
 646             try {
 647                 byte[] src;
 648                 int sp, sl;
 649                 if (buffer.hasArray()) {
 650                     src = buffer.array();
 651                     sp = buffer.arrayOffset() + buffer.position();
 652                     sl = buffer.arrayOffset() + buffer.limit();
 653                     buffer.position(buffer.limit());
 654                 } else {
 655                     src = new byte[buffer.remaining()];
 656                     buffer.get(src);
 657                     sp = 0;
 658                     sl = src.length;
 659                 }
 660                 byte[] dst = new byte[decodedOutLength(src, sp, sl)];
 661                 return ByteBuffer.wrap(dst, 0, decode0(src, sp, sl, dst));
 662             } catch (IllegalArgumentException iae) {
 663                 buffer.position(pos0);
 664                 throw iae;
 665             }
 666         }
 667 
 668         /**
 669          * Returns an input stream for decoding {@link Base64} encoded byte stream.
 670          *
 671          * &lt;p&gt; The {@code read}  methods of the returned {@code InputStream} will
 672          * throw {@code IOException} when reading bytes that cannot be decoded.
 673          *
 674          * &lt;p&gt; Closing the returned input stream will close the underlying
 675          * input stream.
 676          *
 677          * @param   is
 678          *          the input stream
 679          *
 680          * @return  the input stream for decoding the specified Base64 encoded
 681          *          byte stream
 682          */
 683         public InputStream wrap(InputStream is) {
 684             Objects.requireNonNull(is);
 685             return new DecInputStream(is, isURL ? fromBase64URL : fromBase64, isMIME);
 686         }
 687 
 688         /**
 689          * Calculates the length of the decoded output bytes.
 690          *
 691          * @param src the byte array to decode
 692          * @param sp the source  position
 693          * @param sl the source limit
 694          *
 695          * @return length of the decoded bytes
 696          *
 697          */
 698         private int decodedOutLength(byte[] src, int sp, int sl) {
 699             int[] base64 = isURL ? fromBase64URL : fromBase64;
 700             int paddings = 0;
 701             int len = sl - sp;
 702             if (len == 0)
 703                 return 0;
 704             if (len &lt; 2) {
 705                 if (isMIME &amp;&amp; base64[0] == -1)
 706                     return 0;
 707                 throw new IllegalArgumentException(
 708                     &quot;Input byte[] should at least have 2 bytes for base64 bytes&quot;);
 709             }
 710             if (isMIME) {
 711                 // scan all bytes to fill out all non-alphabet. a performance
 712                 // trade-off of pre-scan or Arrays.copyOf
 713                 int n = 0;
 714                 while (sp &lt; sl) {
 715                     int b = src[sp++] &amp; 0xff;
 716                     if (b == &#39;=&#39;) {
 717                         len -= (sl - sp + 1);
 718                         break;
 719                     }
 720                     if ((b = base64[b]) == -1)
 721                         n++;
 722                 }
 723                 len -= n;
 724             } else {
 725                 if (src[sl - 1] == &#39;=&#39;) {
 726                     paddings++;
 727                     if (src[sl - 2] == &#39;=&#39;)
 728                         paddings++;
 729                 }
 730             }
 731             if (paddings == 0 &amp;&amp; (len &amp; 0x3) !=  0)
 732                 paddings = 4 - (len &amp; 0x3);
 733 
 734             // If len is near to Integer.MAX_VALUE, (len + 3)
 735             // can possibly overflow, perform this operation as
 736             // long and cast it back to integer when the value comes under
 737             // integer limit. The final value will always be in integer
 738             // limits
 739             return 3 * (int) ((len + 3L) / 4) - paddings;
 740         }
 741 
 742         private int decode0(byte[] src, int sp, int sl, byte[] dst) {
 743             int[] base64 = isURL ? fromBase64URL : fromBase64;
 744             int dp = 0;
 745             int bits = 0;
 746             int shiftto = 18;       // pos of first byte of 4-byte atom
 747 
 748             while (sp &lt; sl) {
 749                 if (shiftto == 18 &amp;&amp; sp + 4 &lt; sl) {       // fast path
 750                     int sl0 = sp + ((sl - sp) &amp; ~0b11);
 751                     while (sp &lt; sl0) {
 752                         int b1 = base64[src[sp++] &amp; 0xff];
 753                         int b2 = base64[src[sp++] &amp; 0xff];
 754                         int b3 = base64[src[sp++] &amp; 0xff];
 755                         int b4 = base64[src[sp++] &amp; 0xff];
 756                         if ((b1 | b2 | b3 | b4) &lt; 0) {    // non base64 byte
 757                             sp -= 4;
 758                             break;
 759                         }
 760                         int bits0 = b1 &lt;&lt; 18 | b2 &lt;&lt; 12 | b3 &lt;&lt; 6 | b4;
 761                         dst[dp++] = (byte)(bits0 &gt;&gt; 16);
 762                         dst[dp++] = (byte)(bits0 &gt;&gt;  8);
 763                         dst[dp++] = (byte)(bits0);
 764                     }
 765                     if (sp &gt;= sl)
 766                         break;
 767                 }
 768                 int b = src[sp++] &amp; 0xff;
 769                 if ((b = base64[b]) &lt; 0) {
 770                     if (b == -2) {         // padding byte &#39;=&#39;
 771                         // =     shiftto==18 unnecessary padding
 772                         // x=    shiftto==12 a dangling single x
 773                         // x     to be handled together with non-padding case
 774                         // xx=   shiftto==6&amp;&amp;sp==sl missing last =
 775                         // xx=y  shiftto==6 last is not =
 776                         if (shiftto == 6 &amp;&amp; (sp == sl || src[sp++] != &#39;=&#39;) ||
 777                             shiftto == 18) {
 778                             throw new IllegalArgumentException(
 779                                 &quot;Input byte array has wrong 4-byte ending unit&quot;);
 780                         }
 781                         break;
 782                     }
 783                     if (isMIME)    // skip if for rfc2045
 784                         continue;
 785                     else
 786                         throw new IllegalArgumentException(
 787                             &quot;Illegal base64 character &quot; +
 788                             Integer.toString(src[sp - 1], 16));
 789                 }
 790                 bits |= (b &lt;&lt; shiftto);
 791                 shiftto -= 6;
 792                 if (shiftto &lt; 0) {
 793                     dst[dp++] = (byte)(bits &gt;&gt; 16);
 794                     dst[dp++] = (byte)(bits &gt;&gt;  8);
 795                     dst[dp++] = (byte)(bits);
 796                     shiftto = 18;
 797                     bits = 0;
 798                 }
 799             }
 800             // reached end of byte array or hit padding &#39;=&#39; characters.
 801             if (shiftto == 6) {
 802                 dst[dp++] = (byte)(bits &gt;&gt; 16);
 803             } else if (shiftto == 0) {
 804                 dst[dp++] = (byte)(bits &gt;&gt; 16);
 805                 dst[dp++] = (byte)(bits &gt;&gt;  8);
 806             } else if (shiftto == 12) {
 807                 // dangling single &quot;x&quot;, incorrectly encoded.
 808                 throw new IllegalArgumentException(
 809                     &quot;Last unit does not have enough valid bits&quot;);
 810             }
 811             // anything left is invalid, if is not MIME.
 812             // if MIME, ignore all non-base64 character
 813             while (sp &lt; sl) {
 814                 if (isMIME &amp;&amp; base64[src[sp++] &amp; 0xff] &lt; 0)
 815                     continue;
 816                 throw new IllegalArgumentException(
 817                     &quot;Input byte array has incorrect ending byte at &quot; + sp);
 818             }
 819             return dp;
 820         }
 821     }
 822 
 823     /*
 824      * An output stream for encoding bytes into the Base64.
 825      */
 826     private static class EncOutputStream extends FilterOutputStream {
 827 
 828         private int leftover = 0;
 829         private int b0, b1, b2;
 830         private boolean closed = false;
 831 
 832         private final char[] base64;    // byte-&gt;base64 mapping
 833         private final byte[] newline;   // line separator, if needed
 834         private final int linemax;
 835         private final boolean doPadding;// whether or not to pad
 836         private int linepos = 0;
 837         private byte[] buf;
 838 
 839         EncOutputStream(OutputStream os, char[] base64,
 840                         byte[] newline, int linemax, boolean doPadding) {
 841             super(os);
 842             this.base64 = base64;
 843             this.newline = newline;
 844             this.linemax = linemax;
 845             this.doPadding = doPadding;
 846             this.buf = new byte[linemax &lt;= 0 ? 8124 : linemax];
 847         }
 848 
 849         @Override
 850         public void write(int b) throws IOException {
 851             byte[] buf = new byte[1];
 852             buf[0] = (byte)(b &amp; 0xff);
 853             write(buf, 0, 1);
 854         }
 855 
 856         private void checkNewline() throws IOException {
 857             if (linepos == linemax) {
 858                 out.write(newline);
 859                 linepos = 0;
 860             }
 861         }
 862 
 863         private void writeb4(char b1, char b2, char b3, char b4) throws IOException {
 864             buf[0] = (byte)b1;
 865             buf[1] = (byte)b2;
 866             buf[2] = (byte)b3;
 867             buf[3] = (byte)b4;
 868             out.write(buf, 0, 4);
 869         }
 870 
 871         @Override
 872         public void write(byte[] b, int off, int len) throws IOException {
 873             if (closed)
 874                 throw new IOException(&quot;Stream is closed&quot;);
 875             if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off)
 876                 throw new ArrayIndexOutOfBoundsException();
 877             if (len == 0)
 878                 return;
 879             if (leftover != 0) {
 880                 if (leftover == 1) {
 881                     b1 = b[off++] &amp; 0xff;
 882                     len--;
 883                     if (len == 0) {
 884                         leftover++;
 885                         return;
 886                     }
 887                 }
 888                 b2 = b[off++] &amp; 0xff;
 889                 len--;
 890                 checkNewline();
 891                 writeb4(base64[b0 &gt;&gt; 2],
 892                         base64[(b0 &lt;&lt; 4) &amp; 0x3f | (b1 &gt;&gt; 4)],
 893                         base64[(b1 &lt;&lt; 2) &amp; 0x3f | (b2 &gt;&gt; 6)],
 894                         base64[b2 &amp; 0x3f]);
 895                 linepos += 4;
 896             }
 897             int nBits24 = len / 3;
 898             leftover = len - (nBits24 * 3);
 899 
 900             while (nBits24 &gt; 0) {
 901                 checkNewline();
 902                 int dl = linemax &lt;= 0 ? buf.length : buf.length - linepos;
 903                 int sl = off + Math.min(nBits24, dl / 4) * 3;
 904                 int dp = 0;
 905                 for (int sp = off; sp &lt; sl; ) {
 906                     int bits = (b[sp++] &amp; 0xff) &lt;&lt; 16 |
 907                                (b[sp++] &amp; 0xff) &lt;&lt;  8 |
 908                                (b[sp++] &amp; 0xff);
 909                     buf[dp++] = (byte)base64[(bits &gt;&gt;&gt; 18) &amp; 0x3f];
 910                     buf[dp++] = (byte)base64[(bits &gt;&gt;&gt; 12) &amp; 0x3f];
 911                     buf[dp++] = (byte)base64[(bits &gt;&gt;&gt; 6)  &amp; 0x3f];
 912                     buf[dp++] = (byte)base64[bits &amp; 0x3f];
 913                 }
 914                 out.write(buf, 0, dp);
 915                 off = sl;
 916                 linepos += dp;
 917                 nBits24 -= dp / 4;
 918             }
 919             if (leftover == 1) {
 920                 b0 = b[off++] &amp; 0xff;
 921             } else if (leftover == 2) {
 922                 b0 = b[off++] &amp; 0xff;
 923                 b1 = b[off++] &amp; 0xff;
 924             }
 925         }
 926 
 927         @Override
 928         public void close() throws IOException {
 929             if (!closed) {
 930                 closed = true;
 931                 if (leftover == 1) {
 932                     checkNewline();
 933                     out.write(base64[b0 &gt;&gt; 2]);
 934                     out.write(base64[(b0 &lt;&lt; 4) &amp; 0x3f]);
 935                     if (doPadding) {
 936                         out.write(&#39;=&#39;);
 937                         out.write(&#39;=&#39;);
 938                     }
 939                 } else if (leftover == 2) {
 940                     checkNewline();
 941                     out.write(base64[b0 &gt;&gt; 2]);
 942                     out.write(base64[(b0 &lt;&lt; 4) &amp; 0x3f | (b1 &gt;&gt; 4)]);
 943                     out.write(base64[(b1 &lt;&lt; 2) &amp; 0x3f]);
 944                     if (doPadding) {
 945                        out.write(&#39;=&#39;);
 946                     }
 947                 }
 948                 leftover = 0;
 949                 out.close();
 950             }
 951         }
 952     }
 953 
 954     /*
 955      * An input stream for decoding Base64 bytes
 956      */
 957     private static class DecInputStream extends InputStream {
 958 
 959         private final InputStream is;
 960         private final boolean isMIME;
 961         private final int[] base64;      // base64 -&gt; byte mapping
 962         private int bits = 0;            // 24-bit buffer for decoding
 963         private int nextin = 18;         // next available &quot;off&quot; in &quot;bits&quot; for input;
 964                                          // -&gt; 18, 12, 6, 0
 965         private int nextout = -8;        // next available &quot;off&quot; in &quot;bits&quot; for output;
 966                                          // -&gt; 8, 0, -8 (no byte for output)
 967         private boolean eof = false;
 968         private boolean closed = false;
 969 
 970         DecInputStream(InputStream is, int[] base64, boolean isMIME) {
 971             this.is = is;
 972             this.base64 = base64;
 973             this.isMIME = isMIME;
 974         }
 975 
 976         private byte[] sbBuf = new byte[1];
 977 
 978         @Override
 979         public int read() throws IOException {
 980             return read(sbBuf, 0, 1) == -1 ? -1 : sbBuf[0] &amp; 0xff;
 981         }
 982 
 983         private int eof(byte[] b, int off, int len, int oldOff)
 984             throws IOException
 985         {
 986             eof = true;
 987             if (nextin != 18) {
 988                 if (nextin == 12)
 989                     throw new IOException(&quot;Base64 stream has one un-decoded dangling byte.&quot;);
 990                 // treat ending xx/xxx without padding character legal.
 991                 // same logic as v == &#39;=&#39; below
 992                 b[off++] = (byte)(bits &gt;&gt; (16));
 993                 if (nextin == 0) {           // only one padding byte
 994                     if (len == 1) {          // no enough output space
 995                         bits &gt;&gt;= 8;          // shift to lowest byte
 996                         nextout = 0;
 997                     } else {
 998                         b[off++] = (byte) (bits &gt;&gt;  8);
 999                     }
1000                 }
1001             }
1002             return off == oldOff ? -1 : off - oldOff;
1003         }
1004 
1005         private int padding(byte[] b, int off, int len, int oldOff)
1006             throws IOException
1007         {
1008             // =     shiftto==18 unnecessary padding
1009             // x=    shiftto==12 dangling x, invalid unit
1010             // xx=   shiftto==6 &amp;&amp; missing last &#39;=&#39;
1011             // xx=y  or last is not &#39;=&#39;
1012             if (nextin == 18 || nextin == 12 ||
1013                 nextin == 6 &amp;&amp; is.read() != &#39;=&#39;) {
1014                 throw new IOException(&quot;Illegal base64 ending sequence:&quot; + nextin);
1015             }
1016             b[off++] = (byte)(bits &gt;&gt; (16));
1017             if (nextin == 0) {           // only one padding byte
1018                 if (len == 1) {          // no enough output space
1019                     bits &gt;&gt;= 8;          // shift to lowest byte
1020                     nextout = 0;
1021                 } else {
1022                     b[off++] = (byte) (bits &gt;&gt;  8);
1023                 }
1024             }
1025             eof = true;
1026             return off - oldOff;
1027         }
1028 
1029         @Override
1030         public int read(byte[] b, int off, int len) throws IOException {
1031             if (closed)
1032                 throw new IOException(&quot;Stream is closed&quot;);
1033             if (eof &amp;&amp; nextout &lt; 0)    // eof and no leftover
1034                 return -1;
1035             if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off)
1036                 throw new IndexOutOfBoundsException();
1037             int oldOff = off;
1038             while (nextout &gt;= 0) {       // leftover output byte(s) in bits buf
1039                 if (len == 0)
1040                     return off - oldOff;
1041                 b[off++] = (byte)(bits &gt;&gt; nextout);
1042                 len--;
1043                 nextout -= 8;
1044             }
1045             bits = 0;
1046             while (len &gt; 0) {
1047                 int v = is.read();
1048                 if (v == -1) {
1049                     return eof(b, off, len, oldOff);
1050                 }
1051                 if ((v = base64[v]) &lt; 0) {
1052                     if (v == -2) {       // padding byte(s)
1053                         return padding(b, off, len, oldOff);
1054                     }
1055                     if (v == -1) {
1056                         if (!isMIME)
1057                             throw new IOException(&quot;Illegal base64 character &quot; +
1058                                 Integer.toString(v, 16));
1059                         continue;        // skip if for rfc2045
1060                     }
1061                     // neve be here
1062                 }
1063                 bits |= (v &lt;&lt; nextin);
1064                 if (nextin == 0) {
1065                     nextin = 18;         // clear for next in
1066                     b[off++] = (byte)(bits &gt;&gt; 16);
1067                     if (len == 1) {
1068                         nextout = 8;    // 2 bytes left in bits
1069                         break;
1070                     }
1071                     b[off++] = (byte)(bits &gt;&gt; 8);
1072                     if (len == 2) {
1073                         nextout = 0;    // 1 byte left in bits
1074                         break;
1075                     }
1076                     b[off++] = (byte)bits;
1077                     len -= 3;
1078                     bits = 0;
1079                 } else {
1080                     nextin -= 6;
1081                 }
1082             }
1083             return off - oldOff;
1084         }
1085 
1086         @Override
1087         public int available() throws IOException {
1088             if (closed)
1089                 throw new IOException(&quot;Stream is closed&quot;);
1090             return is.available();   // TBD:
1091         }
1092 
1093         @Override
1094         public void close() throws IOException {
1095             if (!closed) {
1096                 closed = true;
1097                 is.close();
1098             }
1099         }
1100     }
1101 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
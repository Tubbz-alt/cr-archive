<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #warn This file is preprocessed before being compiled
 27 
 28 package java.nio;
 29 
 30 import java.io.FileDescriptor;
 31 import java.lang.ref.Reference;
 32 import java.util.Objects;
<a name="1" id="anc1"></a>
 33 import jdk.internal.misc.VM;
 34 import jdk.internal.ref.Cleaner;
 35 import sun.nio.ch.DirectBuffer;
 36 
 37 
 38 class Direct$Type$Buffer$RW$$BO$
 39 #if[rw]
 40     extends {#if[byte]?Mapped$Type$Buffer:$Type$Buffer}
 41 #else[rw]
 42     extends Direct$Type$Buffer$BO$
 43 #end[rw]
 44     implements DirectBuffer
 45 {
 46 
 47 #if[rw]
 48 
 49     // Cached array base offset
 50     private static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset($type$[].class);
 51 
 52     // Cached unaligned-access capability
 53     protected static final boolean UNALIGNED = Bits.unaligned();
 54 
 55     // Base address, used in all indexing calculations
 56     // NOTE: moved up to Buffer.java for speed in JNI GetDirectBufferAddress
 57     //    protected long address;
 58 
 59     // An object attached to this buffer. If this buffer is a view of another
 60     // buffer then we use this field to keep a reference to that buffer to
 61     // ensure that its memory isn&#39;t freed before we are done with it.
 62     private final Object att;
 63 
 64     public Object attachment() {
 65         return att;
 66     }
 67 
 68 #if[byte]
 69 
 70     private static class Deallocator
 71         implements Runnable
 72     {
 73 
 74         private long address;
 75         private long size;
 76         private int capacity;
 77 
 78         private Deallocator(long address, long size, int capacity) {
 79             assert (address != 0);
 80             this.address = address;
 81             this.size = size;
 82             this.capacity = capacity;
 83         }
 84 
 85         public void run() {
 86             if (address == 0) {
 87                 // Paranoia
 88                 return;
 89             }
 90             UNSAFE.freeMemory(address);
 91             address = 0;
 92             Bits.unreserveMemory(size, capacity);
 93         }
 94 
 95     }
 96 
 97     private final Cleaner cleaner;
 98 
 99     public Cleaner cleaner() { return cleaner; }
100 
101 #else[byte]
102 
103     public Cleaner cleaner() { return null; }
104 
105 #end[byte]
106 
107 #end[rw]
108 
109 #if[byte]
110 
111     // Primary constructor
112     //
113     Direct$Type$Buffer$RW$(int cap) {                   // package-private
114 #if[rw]
<a name="2" id="anc2"></a><span class="line-modified">115         super(-1, 0, cap, cap);</span>
116         boolean pa = VM.isDirectMemoryPageAligned();
117         int ps = Bits.pageSize();
118         long size = Math.max(1L, (long)cap + (pa ? ps : 0));
119         Bits.reserveMemory(size, cap);
120 
121         long base = 0;
122         try {
123             base = UNSAFE.allocateMemory(size);
124         } catch (OutOfMemoryError x) {
125             Bits.unreserveMemory(size, cap);
126             throw x;
127         }
128         UNSAFE.setMemory(base, size, (byte) 0);
129         if (pa &amp;&amp; (base % ps != 0)) {
130             // Round up to page boundary
131             address = base + ps - (base &amp; (ps - 1));
132         } else {
133             address = base;
134         }
135         cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
136         att = null;
137 #else[rw]
138         super(cap);
139         this.isReadOnly = true;
140 #end[rw]
141     }
142 
143 #if[rw]
144 
145     // Invoked to construct a direct ByteBuffer referring to the block of
146     // memory. A given arbitrary object may also be attached to the buffer.
147     //
<a name="3" id="anc3"></a><span class="line-modified">148     Direct$Type$Buffer(long addr, int cap, Object ob) {</span>
<span class="line-modified">149         super(-1, 0, cap, cap);</span>
150         address = addr;
151         cleaner = null;
152         att = ob;
153     }
154 
155 
156     // Invoked only by JNI: NewDirectByteBuffer(void*, long)
157     //
158     private Direct$Type$Buffer(long addr, int cap) {
<a name="4" id="anc4"></a><span class="line-modified">159         super(-1, 0, cap, cap);</span>
160         address = addr;
161         cleaner = null;
162         att = null;
163     }
164 
165 #end[rw]
166 
167     // For memory-mapped buffers -- invoked by FileChannelImpl via reflection
168     //
169     protected Direct$Type$Buffer$RW$(int cap, long addr,
170                                      FileDescriptor fd,
<a name="5" id="anc5"></a><span class="line-modified">171                                      Runnable unmapper)</span>

172     {
173 #if[rw]
<a name="6" id="anc6"></a><span class="line-modified">174         super(-1, 0, cap, cap, fd);</span>
175         address = addr;
176         cleaner = Cleaner.create(this, unmapper);
177         att = null;
178 #else[rw]
<a name="7" id="anc7"></a><span class="line-modified">179         super(cap, addr, fd, unmapper);</span>
180         this.isReadOnly = true;
181 #end[rw]
182     }
183 
184 #end[byte]
185 
186     // For duplicates and slices
187     //
188     Direct$Type$Buffer$RW$$BO$(DirectBuffer db,         // package-private
189                                int mark, int pos, int lim, int cap,
<a name="8" id="anc8"></a><span class="line-modified">190                                int off)</span>
191     {
192 #if[rw]
<a name="9" id="anc9"></a><span class="line-modified">193         super(mark, pos, lim, cap);</span>
194         address = db.address() + off;
195 #if[byte]
196         cleaner = null;
197 #end[byte]
198         Object attachment = db.attachment();
199         att = (attachment == null ? db : attachment);
200 #else[rw]
<a name="10" id="anc10"></a><span class="line-modified">201         super(db, mark, pos, lim, cap, off);</span>
202         this.isReadOnly = true;
203 #end[rw]
204     }
205 
206     @Override
207     Object base() {
208         return null;
209     }
210 
211     public $Type$Buffer slice() {
212         int pos = this.position();
213         int lim = this.limit();
214         assert (pos &lt;= lim);
215         int rem = (pos &lt;= lim ? lim - pos : 0);
216         int off = (pos &lt;&lt; $LG_BYTES_PER_VALUE$);
217         assert (off &gt;= 0);
<a name="11" id="anc11"></a><span class="line-modified">218         return new Direct$Type$Buffer$RW$$BO$(this, -1, 0, rem, rem, off);</span>
219     }
220 
221     @Override
222     public $Type$Buffer slice(int index, int length) {
223         Objects.checkFromIndexSize(index, length, limit());
224         return new Direct$Type$Buffer$RW$$BO$(this,
225                                               -1,
226                                               0,
227                                               length,
228                                               length,
<a name="12" id="anc12"></a><span class="line-modified">229                                               index);</span>
230     }
231 
232     public $Type$Buffer duplicate() {
233         return new Direct$Type$Buffer$RW$$BO$(this,
234                                               this.markValue(),
235                                               this.position(),
236                                               this.limit(),
237                                               this.capacity(),
<a name="13" id="anc13"></a><span class="line-modified">238                                               0);</span>
239     }
240 
241     public $Type$Buffer asReadOnlyBuffer() {
242 #if[rw]
243         return new Direct$Type$BufferR$BO$(this,
244                                            this.markValue(),
245                                            this.position(),
246                                            this.limit(),
247                                            this.capacity(),
<a name="14" id="anc14"></a><span class="line-modified">248                                            0);</span>
249 #else[rw]
250         return duplicate();
251 #end[rw]
252     }
253 
254 #if[rw]
255 
256     public long address() {
257         return address;
258     }
259 
260     private long ix(int i) {
261         return address + ((long)i &lt;&lt; $LG_BYTES_PER_VALUE$);
262     }
263 
264     public $type$ get() {
265         try {
<a name="15" id="anc15"></a>
266             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(nextGetIndex()))));
267         } finally {
268             Reference.reachabilityFence(this);
269         }
270     }
271 
272     public $type$ get(int i) {
273         try {
<a name="16" id="anc16"></a>
274             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(checkIndex(i)))));
275         } finally {
276             Reference.reachabilityFence(this);
277         }
278     }
279 
280 #if[streamableType]
281     $type$ getUnchecked(int i) {
282         try {
283             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(i))));
284         } finally {
285             Reference.reachabilityFence(this);
286         }
287     }
288 #end[streamableType]
289 
290     public $Type$Buffer get($type$[] dst, int offset, int length) {
291 #if[rw]
<a name="17" id="anc17"></a>
292         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
<a name="18" id="anc18"></a><span class="line-modified">293             checkBounds(offset, length, dst.length);</span>
294             int pos = position();
295             int lim = limit();
296             assert (pos &lt;= lim);
297             int rem = (pos &lt;= lim ? lim - pos : 0);
298             if (length &gt; rem)
299                 throw new BufferUnderflowException();
300 
301             long dstOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
302             try {
303 #if[!byte]
304                 if (order() != ByteOrder.nativeOrder())
305                     UNSAFE.copySwapMemory(null,
306                                           ix(pos),
307                                           dst,
308                                           dstOffset,
309                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
310                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
311                 else
312 #end[!byte]
313                     UNSAFE.copyMemory(null,
314                                       ix(pos),
315                                       dst,
316                                       dstOffset,
317                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
318             } finally {
319                 Reference.reachabilityFence(this);
320             }
321             position(pos + length);
322         } else {
323             super.get(dst, offset, length);
324         }
325         return this;
326 #else[rw]
327         throw new ReadOnlyBufferException();
328 #end[rw]
329     }
330 
331     public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {
332 #if[rw]
<a name="19" id="anc19"></a>
333         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
334             Objects.checkFromIndexSize(index, length, limit());
335             Objects.checkFromIndexSize(offset, length, dst.length);
336 
337             long dstOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
338             try {
339 #if[!byte]
340                 if (order() != ByteOrder.nativeOrder())
341                     UNSAFE.copySwapMemory(null,
342                                           ix(index),
343                                           dst,
344                                           dstOffset,
345                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
346                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
347                 else
348 #end[!byte]
349                     UNSAFE.copyMemory(null,
350                                       ix(index),
351                                       dst,
352                                       dstOffset,
353                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
354             } finally {
355                 Reference.reachabilityFence(this);
356             }
357         } else {
358             super.get(index, dst, offset, length);
359         }
360         return this;
361 #else[rw]
362         throw new ReadOnlyBufferException();
363 #end[rw]
364     }
365 #end[rw]
366 
367     public $Type$Buffer put($type$ x) {
368 #if[rw]
369         try {
<a name="20" id="anc20"></a>
370             UNSAFE.put$Swaptype$(ix(nextPutIndex()), $swap$($toBits$(x)));
371         } finally {
372             Reference.reachabilityFence(this);
373         }
374         return this;
375 #else[rw]
376         throw new ReadOnlyBufferException();
377 #end[rw]
378     }
379 
380     public $Type$Buffer put(int i, $type$ x) {
381 #if[rw]
382         try {
<a name="21" id="anc21"></a>
383             UNSAFE.put$Swaptype$(ix(checkIndex(i)), $swap$($toBits$(x)));
384         } finally {
385             Reference.reachabilityFence(this);
386         }
387         return this;
388 #else[rw]
389         throw new ReadOnlyBufferException();
390 #end[rw]
391     }
392 
393     public $Type$Buffer put($Type$Buffer src) {
394 #if[rw]
<a name="22" id="anc22"></a>
395         if (src instanceof Direct$Type$Buffer$BO$) {
396             if (src == this)
397                 throw createSameBufferException();
398             Direct$Type$Buffer$RW$$BO$ sb = (Direct$Type$Buffer$RW$$BO$)src;
399 
400             int spos = sb.position();
401             int slim = sb.limit();
402             assert (spos &lt;= slim);
403             int srem = (spos &lt;= slim ? slim - spos : 0);
404 
405             int pos = position();
406             int lim = limit();
407             assert (pos &lt;= lim);
408             int rem = (pos &lt;= lim ? lim - pos : 0);
409 
410             if (srem &gt; rem)
411                 throw new BufferOverflowException();
412             try {
413                 UNSAFE.copyMemory(sb.ix(spos), ix(pos), (long)srem &lt;&lt; $LG_BYTES_PER_VALUE$);
414             } finally {
415                 Reference.reachabilityFence(sb);
416                 Reference.reachabilityFence(this);
417             }
418             sb.position(spos + srem);
419             position(pos + srem);
420         } else if (src.hb != null) {
421 
422             int spos = src.position();
423             int slim = src.limit();
424             assert (spos &lt;= slim);
425             int srem = (spos &lt;= slim ? slim - spos : 0);
426 
427             put(src.hb, src.offset + spos, srem);
428             src.position(spos + srem);
429 
430         } else {
431             super.put(src);
432         }
433         return this;
434 #else[rw]
435         throw new ReadOnlyBufferException();
436 #end[rw]
437     }
438 
439     public $Type$Buffer put($type$[] src, int offset, int length) {
440 #if[rw]
<a name="23" id="anc23"></a>
441         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
<a name="24" id="anc24"></a><span class="line-modified">442             checkBounds(offset, length, src.length);</span>
443             int pos = position();
444             int lim = limit();
445             assert (pos &lt;= lim);
446             int rem = (pos &lt;= lim ? lim - pos : 0);
447             if (length &gt; rem)
448                 throw new BufferOverflowException();
449 
450             long srcOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
451             try {
452 #if[!byte]
453                 if (order() != ByteOrder.nativeOrder())
454                     UNSAFE.copySwapMemory(src,
455                                           srcOffset,
456                                           null,
457                                           ix(pos),
458                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
459                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
460                 else
461 #end[!byte]
462                     UNSAFE.copyMemory(src,
463                                       srcOffset,
464                                       null,
465                                       ix(pos),
466                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
467             } finally {
468                 Reference.reachabilityFence(this);
469             }
470             position(pos + length);
471         } else {
472             super.put(src, offset, length);
473         }
474         return this;
475 #else[rw]
476         throw new ReadOnlyBufferException();
477 #end[rw]
478     }
479 
480     public $Type$Buffer put(int index, $type$[] src, int offset, int length) {
481 #if[rw]
<a name="25" id="anc25"></a>
482         if (((long)length &lt;&lt; $LG_BYTES_PER_VALUE$) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
483             Objects.checkFromIndexSize(index, length, limit());
484             Objects.checkFromIndexSize(offset, length, src.length);
485 
486 
487             long srcOffset = ARRAY_BASE_OFFSET + ((long)offset &lt;&lt; $LG_BYTES_PER_VALUE$);
488             try {
489 #if[!byte]
490                 if (order() != ByteOrder.nativeOrder())
491                     UNSAFE.copySwapMemory(src,
492                                           srcOffset,
493                                           null,
494                                           ix(index),
495                                           (long)length &lt;&lt; $LG_BYTES_PER_VALUE$,
496                                           (long)1 &lt;&lt; $LG_BYTES_PER_VALUE$);
497                 else
498 #end[!byte]
499                     UNSAFE.copyMemory(src,
500                                       srcOffset,
501                                       null,
502                                       ix(index),
503                                       (long)length &lt;&lt; $LG_BYTES_PER_VALUE$);
504             } finally {
505                 Reference.reachabilityFence(this);
506             }
507         } else {
508             super.put(index, src, offset, length);
509         }
510         return this;
511 #else[rw]
512         throw new ReadOnlyBufferException();
513 #end[rw]
514     }
515 
516     public $Type$Buffer compact() {
517 #if[rw]
518         int pos = position();
519         int lim = limit();
520         assert (pos &lt;= lim);
521         int rem = (pos &lt;= lim ? lim - pos : 0);
522         try {
523             UNSAFE.copyMemory(ix(pos), ix(0), (long)rem &lt;&lt; $LG_BYTES_PER_VALUE$);
524         } finally {
525             Reference.reachabilityFence(this);
526         }
527         position(rem);
528         limit(capacity());
529         discardMark();
530         return this;
531 #else[rw]
532         throw new ReadOnlyBufferException();
533 #end[rw]
534     }
535 
536     public boolean isDirect() {
537         return true;
538     }
539 
540     public boolean isReadOnly() {
541         return {#if[rw]?false:true};
542     }
543 
544 
545 #if[char]
546 
547     public String toString(int start, int end) {
<a name="26" id="anc26"></a><span class="line-modified">548         if ((end &gt; limit()) || (start &gt; end))</span>
<span class="line-removed">549             throw new IndexOutOfBoundsException();</span>
550         try {
551             int len = end - start;
552             char[] ca = new char[len];
553             CharBuffer cb = CharBuffer.wrap(ca);
554             CharBuffer db = this.duplicate();
555             db.position(start);
556             db.limit(end);
557             cb.put(db);
558             return new String(ca);
559         } catch (StringIndexOutOfBoundsException x) {
560             throw new IndexOutOfBoundsException();
561         }
562     }
563 
564 
565     // --- Methods to support CharSequence ---
566 
567     public CharBuffer subSequence(int start, int end) {
568         int pos = position();
569         int lim = limit();
570         assert (pos &lt;= lim);
571         pos = (pos &lt;= lim ? pos : lim);
572         int len = lim - pos;
573 
<a name="27" id="anc27"></a><span class="line-modified">574         if ((start &lt; 0) || (end &gt; len) || (start &gt; end))</span>
<span class="line-removed">575             throw new IndexOutOfBoundsException();</span>
576         return new DirectCharBuffer$RW$$BO$(this,
577                                             -1,
578                                             pos + start,
579                                             pos + end,
580                                             capacity(),
<a name="28" id="anc28"></a><span class="line-modified">581                                             offset);</span>
582     }
583 
584 #end[char]
585 
586 
587 
588 #if[!byte]
589 
590     public ByteOrder order() {
591 #if[boS]
592         return ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN)
593                 ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
594 #end[boS]
595 #if[boU]
596         return ((ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
597                 ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
598 #end[boU]
599     }
600 
601 #end[!byte]
602 
603 #if[char]
604     ByteOrder charRegionOrder() {
605         return order();
606     }
607 #end[char]
608 
609 
610 #if[byte]
611     // #BIN
612     //
613     // Binary-data access methods  for short, char, int, long, float,
614     // and double will be inserted here
615 
616 #end[byte]
617 
618 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
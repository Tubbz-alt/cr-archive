<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/SocketInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketImplFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketOptions.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/SocketInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 31 import java.nio.channels.FileChannel;
 32 
 33 import sun.net.ConnectionResetException;
 34 
 35 /**
 36  * This stream extends FileInputStream to implement a
 37  * SocketInputStream. Note that this class should &lt;b&gt;NOT&lt;/b&gt; be
 38  * public.
 39  *
 40  * @author      Jonathan Payne
 41  * @author      Arthur van Hoff
 42  */
 43 class SocketInputStream extends FileInputStream {
 44     static {
 45         init();
 46     }
 47 
 48     private boolean eof;
 49     private AbstractPlainSocketImpl impl = null;
 50     private byte temp[];
<span class="line-removed"> 51     private Socket socket = null;</span>
 52 
 53     /**
 54      * Creates a new SocketInputStream. Can only be called
 55      * by a Socket. This method needs to hang on to the owner Socket so
 56      * that the fd will not be closed.
 57      * @param impl the implemented socket input stream
 58      */
 59     SocketInputStream(AbstractPlainSocketImpl impl) throws IOException {
 60         super(impl.getFileDescriptor());
 61         this.impl = impl;
<span class="line-removed"> 62         socket = impl.getSocket();</span>
 63     }
 64 
 65     /**
 66      * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
 67      * object associated with this file input stream.&lt;/p&gt;
 68      *
 69      * The {@code getChannel} method of {@code SocketInputStream}
 70      * returns {@code null} since it is a socket based stream.&lt;/p&gt;
 71      *
 72      * @return  the file channel associated with this file input stream
 73      *
 74      * @since 1.4
 75      * @spec JSR-51
 76      */
 77     public final FileChannel getChannel() {
 78         return null;
 79     }
 80 
 81     /**
 82      * Reads into an array of bytes at the specified offset using
 83      * the received socket primitive.
 84      * @param fd the FileDescriptor
 85      * @param b the buffer into which the data is read
 86      * @param off the start offset of the data
 87      * @param len the maximum number of bytes read
 88      * @param timeout the read timeout in ms
 89      * @return the actual number of bytes read, -1 is
 90      *          returned when the end of the stream is reached.
<span class="line-modified"> 91      * @exception IOException If an I/O error has occurred.</span>
 92      */
 93     private native int socketRead0(FileDescriptor fd,
 94                                    byte b[], int off, int len,
 95                                    int timeout)
 96         throws IOException;
 97 
 98     // wrap native call to allow instrumentation
 99     /**
100      * Reads into an array of bytes at the specified offset using
101      * the received socket primitive.
102      * @param fd the FileDescriptor
103      * @param b the buffer into which the data is read
104      * @param off the start offset of the data
105      * @param len the maximum number of bytes read
106      * @param timeout the read timeout in ms
107      * @return the actual number of bytes read, -1 is
108      *          returned when the end of the stream is reached.
<span class="line-modified">109      * @exception IOException If an I/O error has occurred.</span>
110      */
111     private int socketRead(FileDescriptor fd,
112                            byte b[], int off, int len,
113                            int timeout)
114         throws IOException {
115         return socketRead0(fd, b, off, len, timeout);
116     }
117 
118     /**
119      * Reads into a byte array data from the socket.
120      * @param b the buffer into which the data is read
121      * @return the actual number of bytes read, -1 is
122      *          returned when the end of the stream is reached.
<span class="line-modified">123      * @exception IOException If an I/O error has occurred.</span>
124      */
125     public int read(byte b[]) throws IOException {
126         return read(b, 0, b.length);
127     }
128 
129     /**
130      * Reads into a byte array &lt;i&gt;b&lt;/i&gt; at offset &lt;i&gt;off&lt;/i&gt;,
131      * &lt;i&gt;length&lt;/i&gt; bytes of data.
132      * @param b the buffer into which the data is read
133      * @param off the start offset of the data
134      * @param length the maximum number of bytes read
135      * @return the actual number of bytes read, -1 is
136      *          returned when the end of the stream is reached.
<span class="line-modified">137      * @exception IOException If an I/O error has occurred.</span>
138      */
139     public int read(byte b[], int off, int length) throws IOException {
140         return read(b, off, length, impl.getTimeout());
141     }
142 
143     int read(byte b[], int off, int length, int timeout) throws IOException {
144         int n;
145 
146         // EOF already encountered
147         if (eof) {
148             return -1;
149         }
150 
151         // connection reset
152         if (impl.isConnectionReset()) {
153             throw new SocketException(&quot;Connection reset&quot;);
154         }
155 
156         // bounds check
157         if (length &lt;= 0 || off &lt; 0 || length &gt; b.length - off) {
</pre>
<hr />
<pre>
191 
192     /**
193      * Reads a single byte from the socket.
194      */
195     public int read() throws IOException {
196         if (eof) {
197             return -1;
198         }
199         temp = new byte[1];
200         int n = read(temp, 0, 1);
201         if (n &lt;= 0) {
202             return -1;
203         }
204         return temp[0] &amp; 0xff;
205     }
206 
207     /**
208      * Skips n bytes of input.
209      * @param numbytes the number of bytes to skip
210      * @return  the actual number of bytes skipped.
<span class="line-modified">211      * @exception IOException If an I/O error has occurred.</span>
212      */
213     public long skip(long numbytes) throws IOException {
214         if (numbytes &lt;= 0) {
215             return 0;
216         }
217         long n = numbytes;
218         int buflen = (int) Math.min(1024, n);
219         byte data[] = new byte[buflen];
220         while (n &gt; 0) {
221             int r = read(data, 0, (int) Math.min((long) buflen, n));
222             if (r &lt; 0) {
223                 break;
224             }
225             n -= r;
226         }
227         return numbytes - n;
228     }
229 
230     /**
231      * Returns the number of bytes that can be read without blocking.
232      * @return the number of immediately available bytes
233      */
234     public int available() throws IOException {
235         int available = impl.available();
236         return eof ? 0 : available;
237     }
238 
<span class="line-removed">239     /**</span>
<span class="line-removed">240      * Closes the stream.</span>
<span class="line-removed">241      */</span>
<span class="line-removed">242     private boolean closing = false;</span>
<span class="line-removed">243     public void close() throws IOException {</span>
<span class="line-removed">244         // Prevent recursion. See BugId 4484411</span>
<span class="line-removed">245         if (closing)</span>
<span class="line-removed">246             return;</span>
<span class="line-removed">247         closing = true;</span>
<span class="line-removed">248         if (socket != null) {</span>
<span class="line-removed">249             if (!socket.isClosed())</span>
<span class="line-removed">250                 socket.close();</span>
<span class="line-removed">251         } else</span>
<span class="line-removed">252             impl.close();</span>
<span class="line-removed">253         closing = false;</span>
<span class="line-removed">254     }</span>
<span class="line-removed">255 </span>
256     void setEOF(boolean eof) {
257         this.eof = eof;
258     }
259 






260     /**
261      * Overrides finalize, the fd is closed by the Socket.
262      */
263     @SuppressWarnings({&quot;deprecation&quot;, &quot;removal&quot;})
264     protected void finalize() {}
265 
266     /**
267      * Perform class load-time initializations.
268      */
269     private static native void init();
270 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 31 import java.nio.channels.FileChannel;
 32 
 33 import sun.net.ConnectionResetException;
 34 
 35 /**
 36  * This stream extends FileInputStream to implement a
 37  * SocketInputStream. Note that this class should &lt;b&gt;NOT&lt;/b&gt; be
 38  * public.
 39  *
 40  * @author      Jonathan Payne
 41  * @author      Arthur van Hoff
 42  */
 43 class SocketInputStream extends FileInputStream {
 44     static {
 45         init();
 46     }
 47 
 48     private boolean eof;
 49     private AbstractPlainSocketImpl impl = null;
 50     private byte temp[];

 51 
 52     /**
 53      * Creates a new SocketInputStream. Can only be called
 54      * by a Socket. This method needs to hang on to the owner Socket so
 55      * that the fd will not be closed.
 56      * @param impl the implemented socket input stream
 57      */
 58     SocketInputStream(AbstractPlainSocketImpl impl) throws IOException {
 59         super(impl.getFileDescriptor());
 60         this.impl = impl;

 61     }
 62 
 63     /**
 64      * Returns the unique {@link java.nio.channels.FileChannel FileChannel}
 65      * object associated with this file input stream.&lt;/p&gt;
 66      *
 67      * The {@code getChannel} method of {@code SocketInputStream}
 68      * returns {@code null} since it is a socket based stream.&lt;/p&gt;
 69      *
 70      * @return  the file channel associated with this file input stream
 71      *
 72      * @since 1.4
 73      * @spec JSR-51
 74      */
 75     public final FileChannel getChannel() {
 76         return null;
 77     }
 78 
 79     /**
 80      * Reads into an array of bytes at the specified offset using
 81      * the received socket primitive.
 82      * @param fd the FileDescriptor
 83      * @param b the buffer into which the data is read
 84      * @param off the start offset of the data
 85      * @param len the maximum number of bytes read
 86      * @param timeout the read timeout in ms
 87      * @return the actual number of bytes read, -1 is
 88      *          returned when the end of the stream is reached.
<span class="line-modified"> 89      * @throws    IOException If an I/O error has occurred.</span>
 90      */
 91     private native int socketRead0(FileDescriptor fd,
 92                                    byte b[], int off, int len,
 93                                    int timeout)
 94         throws IOException;
 95 
 96     // wrap native call to allow instrumentation
 97     /**
 98      * Reads into an array of bytes at the specified offset using
 99      * the received socket primitive.
100      * @param fd the FileDescriptor
101      * @param b the buffer into which the data is read
102      * @param off the start offset of the data
103      * @param len the maximum number of bytes read
104      * @param timeout the read timeout in ms
105      * @return the actual number of bytes read, -1 is
106      *          returned when the end of the stream is reached.
<span class="line-modified">107      * @throws    IOException If an I/O error has occurred.</span>
108      */
109     private int socketRead(FileDescriptor fd,
110                            byte b[], int off, int len,
111                            int timeout)
112         throws IOException {
113         return socketRead0(fd, b, off, len, timeout);
114     }
115 
116     /**
117      * Reads into a byte array data from the socket.
118      * @param b the buffer into which the data is read
119      * @return the actual number of bytes read, -1 is
120      *          returned when the end of the stream is reached.
<span class="line-modified">121      * @throws    IOException If an I/O error has occurred.</span>
122      */
123     public int read(byte b[]) throws IOException {
124         return read(b, 0, b.length);
125     }
126 
127     /**
128      * Reads into a byte array &lt;i&gt;b&lt;/i&gt; at offset &lt;i&gt;off&lt;/i&gt;,
129      * &lt;i&gt;length&lt;/i&gt; bytes of data.
130      * @param b the buffer into which the data is read
131      * @param off the start offset of the data
132      * @param length the maximum number of bytes read
133      * @return the actual number of bytes read, -1 is
134      *          returned when the end of the stream is reached.
<span class="line-modified">135      * @throws    IOException If an I/O error has occurred.</span>
136      */
137     public int read(byte b[], int off, int length) throws IOException {
138         return read(b, off, length, impl.getTimeout());
139     }
140 
141     int read(byte b[], int off, int length, int timeout) throws IOException {
142         int n;
143 
144         // EOF already encountered
145         if (eof) {
146             return -1;
147         }
148 
149         // connection reset
150         if (impl.isConnectionReset()) {
151             throw new SocketException(&quot;Connection reset&quot;);
152         }
153 
154         // bounds check
155         if (length &lt;= 0 || off &lt; 0 || length &gt; b.length - off) {
</pre>
<hr />
<pre>
189 
190     /**
191      * Reads a single byte from the socket.
192      */
193     public int read() throws IOException {
194         if (eof) {
195             return -1;
196         }
197         temp = new byte[1];
198         int n = read(temp, 0, 1);
199         if (n &lt;= 0) {
200             return -1;
201         }
202         return temp[0] &amp; 0xff;
203     }
204 
205     /**
206      * Skips n bytes of input.
207      * @param numbytes the number of bytes to skip
208      * @return  the actual number of bytes skipped.
<span class="line-modified">209      * @throws    IOException If an I/O error has occurred.</span>
210      */
211     public long skip(long numbytes) throws IOException {
212         if (numbytes &lt;= 0) {
213             return 0;
214         }
215         long n = numbytes;
216         int buflen = (int) Math.min(1024, n);
217         byte data[] = new byte[buflen];
218         while (n &gt; 0) {
219             int r = read(data, 0, (int) Math.min((long) buflen, n));
220             if (r &lt; 0) {
221                 break;
222             }
223             n -= r;
224         }
225         return numbytes - n;
226     }
227 
228     /**
229      * Returns the number of bytes that can be read without blocking.
230      * @return the number of immediately available bytes
231      */
232     public int available() throws IOException {
233         int available = impl.available();
234         return eof ? 0 : available;
235     }
236 

















237     void setEOF(boolean eof) {
238         this.eof = eof;
239     }
240 
<span class="line-added">241     public void close() throws IOException {</span>
<span class="line-added">242         // No longer used. Socket.getInputStream returns an</span>
<span class="line-added">243         // InputStream which calls Socket.close directly</span>
<span class="line-added">244         assert false;</span>
<span class="line-added">245     }</span>
<span class="line-added">246 </span>
247     /**
248      * Overrides finalize, the fd is closed by the Socket.
249      */
250     @SuppressWarnings({&quot;deprecation&quot;, &quot;removal&quot;})
251     protected void finalize() {}
252 
253     /**
254      * Perform class load-time initializations.
255      */
256     private static native void init();
257 }
</pre>
</td>
</tr>
</table>
<center><a href="SocketImplFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SocketOptions.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
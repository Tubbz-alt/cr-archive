<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/time/chrono/JapaneseEra.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * This file is available under and governed by the GNU General Public
 28  * License version 2 only, as published by the Free Software Foundation.
 29  * However, the following notice accompanied the original version of this
 30  * file:
 31  *
 32  * Copyright (c) 2012, Stephen Colebourne &amp; Michael Nascimento Santos
 33  *
 34  * All rights reserved.
 35  *
 36  * Redistribution and use in source and binary forms, with or without
 37  * modification, are permitted provided that the following conditions are met:
 38  *
 39  *  * Redistributions of source code must retain the above copyright notice,
 40  *    this list of conditions and the following disclaimer.
 41  *
 42  *  * Redistributions in binary form must reproduce the above copyright notice,
 43  *    this list of conditions and the following disclaimer in the documentation
 44  *    and/or other materials provided with the distribution.
 45  *
 46  *  * Neither the name of JSR-310 nor the names of its contributors
 47  *    may be used to endorse or promote products derived from this software
 48  *    without specific prior written permission.
 49  *
 50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 61  */
 62 package java.time.chrono;
 63 
 64 import static java.time.chrono.JapaneseDate.MEIJI_6_ISODATE;
 65 import static java.time.temporal.ChronoField.ERA;
 66 
 67 import java.io.DataInput;
 68 import java.io.DataOutput;
 69 import java.io.IOException;
 70 import java.io.InvalidObjectException;
 71 import java.io.ObjectInputStream;
 72 import java.io.ObjectStreamException;
 73 import java.io.Serializable;
 74 import java.time.DateTimeException;
 75 import java.time.LocalDate;
 76 import java.time.format.DateTimeFormatterBuilder;
 77 import java.time.format.TextStyle;
 78 import java.time.temporal.ChronoField;
 79 import java.time.temporal.TemporalField;
 80 import java.time.temporal.UnsupportedTemporalTypeException;
 81 import java.time.temporal.ValueRange;
 82 import java.util.Arrays;
 83 import java.util.Locale;
 84 import java.util.Objects;
 85 
 86 import sun.util.calendar.CalendarDate;
 87 
 88 /**
 89  * An era in the Japanese Imperial calendar system.
 90  * &lt;p&gt;
 91  * The Japanese government defines the official name and start date of
 92  * each era. Eras are consecutive and their date ranges do not overlap,
 93  * so the end date of one era is always the day before the start date
 94  * of the next era.
 95  * &lt;p&gt;
 96  * The Java SE Platform supports all eras defined by the Japanese government,
 97  * beginning with the Meiji era. Each era is identified in the Platform by an
 98  * integer value and a name. The {@link #of(int)} and {@link #valueOf(String)}
 99  * methods may be used to obtain a singleton instance of {@code JapaneseEra}
100  * for each era. The {@link #values()} method returns the singleton instances
101  * of all supported eras.
102  * &lt;p&gt;
103  * For convenience, this class declares a number of public static final fields
104  * that refer to singleton instances returned by the {@link #values()} method.
105  *
106  * @apiNote
107  * The fields declared in this class may evolve over time, in line with the
108  * results of the {@link #values()} method. However, there is not necessarily
109  * a 1:1 correspondence between the fields and the singleton instances.
110  *
111  * @apiNote
112  * The Japanese government may announce a new era and define its start
113  * date but not its official name. In this scenario, the singleton instance
114  * that represents the new era may return a name that is not stable until
115  * the official name is defined. Developers should exercise caution when
116  * relying on the name returned by any singleton instance that does not
117  * correspond to a public static final field.
118  *
119  * @implSpec
120  * This class is immutable and thread-safe.
121  *
122  * @since 1.8
123  */
124 public final class JapaneseEra
125         implements Era, Serializable {
126 
127     // The offset value to 0-based index from the era value.
128     // i.e., getValue() + ERA_OFFSET == 0-based index
129     static final int ERA_OFFSET = 2;
130 
131     static final sun.util.calendar.Era[] ERA_CONFIG;
132 
133     /**
134      * The singleton instance for the &#39;Meiji&#39; era (1868-01-01 - 1912-07-29)
135      * which has the value -1.
136      */
137     public static final JapaneseEra MEIJI = new JapaneseEra(-1, LocalDate.of(1868, 1, 1));
138     /**
139      * The singleton instance for the &#39;Taisho&#39; era (1912-07-30 - 1926-12-24)
140      * which has the value 0.
141      */
142     public static final JapaneseEra TAISHO = new JapaneseEra(0, LocalDate.of(1912, 7, 30));
143     /**
144      * The singleton instance for the &#39;Showa&#39; era (1926-12-25 - 1989-01-07)
145      * which has the value 1.
146      */
147     public static final JapaneseEra SHOWA = new JapaneseEra(1, LocalDate.of(1926, 12, 25));
148     /**
149      * The singleton instance for the &#39;Heisei&#39; era (1989-01-08 - 2019-04-30)
150      * which has the value 2.
151      */
152     public static final JapaneseEra HEISEI = new JapaneseEra(2, LocalDate.of(1989, 1, 8));
153     /**
<a name="1" id="anc1"></a><span class="line-modified">154      * The singleton instance for the &#39;NewEra&#39; era (2019-05-01 - current)</span>
<span class="line-modified">155      * which has the value 3.</span>



156      */
<a name="2" id="anc2"></a><span class="line-modified">157     private static final JapaneseEra NEWERA = new JapaneseEra(3, LocalDate.of(2019, 5, 1));</span>
158 
159     // The number of predefined JapaneseEra constants.
160     // There may be a supplemental era defined by the property.
<a name="3" id="anc3"></a><span class="line-modified">161     private static final int N_ERA_CONSTANTS = NEWERA.getValue() + ERA_OFFSET;</span>
162 
163     /**
164      * Serialization version.
165      */
<a name="4" id="anc4"></a>
166     private static final long serialVersionUID = 1466499369062886794L;
167 
168     // array for the singleton JapaneseEra instances
169     private static final JapaneseEra[] KNOWN_ERAS;
170 
171     static {
172         ERA_CONFIG = JapaneseChronology.JCAL.getEras();
173 
174         KNOWN_ERAS = new JapaneseEra[ERA_CONFIG.length];
175         KNOWN_ERAS[0] = MEIJI;
176         KNOWN_ERAS[1] = TAISHO;
177         KNOWN_ERAS[2] = SHOWA;
178         KNOWN_ERAS[3] = HEISEI;
<a name="5" id="anc5"></a><span class="line-modified">179         KNOWN_ERAS[4] = NEWERA;</span>
180         for (int i = N_ERA_CONSTANTS; i &lt; ERA_CONFIG.length; i++) {
181             CalendarDate date = ERA_CONFIG[i].getSinceDate();
182             LocalDate isoDate = LocalDate.of(date.getYear(), date.getMonth(), date.getDayOfMonth());
183             KNOWN_ERAS[i] = new JapaneseEra(i - ERA_OFFSET + 1, isoDate);
184         }
185     };
186 
187     /**
188      * The era value.
189      * @serial
190      */
191     private final transient int eraValue;
192 
193     // the first day of the era
194     private final transient LocalDate since;
195 
196     /**
197      * Creates an instance.
198      *
199      * @param eraValue  the era value, validated
200      * @param since  the date representing the first date of the era, validated not null
201      */
202     private JapaneseEra(int eraValue, LocalDate since) {
203         this.eraValue = eraValue;
204         this.since = since;
205     }
206 
207     //-----------------------------------------------------------------------
208     /**
209      * Returns the Sun private Era instance corresponding to this {@code JapaneseEra}.
210      *
211      * @return the Sun private Era instance for this {@code JapaneseEra}.
212      */
213     sun.util.calendar.Era getPrivateEra() {
214         return ERA_CONFIG[ordinal(eraValue)];
215     }
216 
217     //-----------------------------------------------------------------------
218     /**
219      * Obtains an instance of {@code JapaneseEra} from an {@code int} value.
220      * &lt;ul&gt;
221      * &lt;li&gt;The value {@code 1} is associated with the &#39;Showa&#39; era, because
222      * it contains 1970-01-01 (ISO calendar system).&lt;/li&gt;
223      * &lt;li&gt;The values {@code -1} and {@code 0} are associated with two earlier
224      * eras, Meiji and Taisho, respectively.&lt;/li&gt;
225      * &lt;li&gt;A value greater than {@code 1} is associated with a later era,
226      * beginning with Heisei ({@code 2}).&lt;/li&gt;
227      * &lt;/ul&gt;
228      * &lt;p&gt;
229      * Every instance of {@code JapaneseEra} that is returned from the {@link #values()}
230      * method has an int value (available via {@link Era#getValue()} which is
231      * accepted by this method.
232      *
233      * @param japaneseEra  the era to represent
234      * @return the {@code JapaneseEra} singleton, not null
235      * @throws DateTimeException if the value is invalid
236      */
237     public static JapaneseEra of(int japaneseEra) {
238         int i = ordinal(japaneseEra);
239         if (i &lt; 0 || i &gt;= KNOWN_ERAS.length) {
240             throw new DateTimeException(&quot;Invalid era: &quot; + japaneseEra);
241         }
242         return KNOWN_ERAS[i];
243     }
244 
245     /**
246      * Returns the {@code JapaneseEra} with the name.
247      * &lt;p&gt;
248      * The string must match exactly the name of the era.
249      * (Extraneous whitespace characters are not permitted.)
250      * &lt;p&gt;
251      * Valid era names are the names of eras returned from {@link #values()}.
252      *
253      * @param japaneseEra  the japaneseEra name; non-null
254      * @return the {@code JapaneseEra} singleton, never null
255      * @throws IllegalArgumentException if there is not JapaneseEra with the specified name
256      */
257     public static JapaneseEra valueOf(String japaneseEra) {
258         Objects.requireNonNull(japaneseEra, &quot;japaneseEra&quot;);
259         for (JapaneseEra era : KNOWN_ERAS) {
260             if (era.getName().equals(japaneseEra)) {
261                 return era;
262             }
263         }
264         throw new IllegalArgumentException(&quot;japaneseEra is invalid&quot;);
265     }
266 
267     /**
268      * Returns an array of JapaneseEras. The array may contain eras defined
269      * by the Japanese government beyond the known era singletons.
270      *
271      * &lt;p&gt;
272      * This method may be used to iterate over the JapaneseEras as follows:
273      * &lt;pre&gt;
274      * for (JapaneseEra c : JapaneseEra.values())
275      *     System.out.println(c);
276      * &lt;/pre&gt;
277      *
278      * @return an array of JapaneseEras
279      */
280     public static JapaneseEra[] values() {
281         return Arrays.copyOf(KNOWN_ERAS, KNOWN_ERAS.length);
282     }
283 
284     /**
285      * {@inheritDoc}
286      *
287      * @param style {@inheritDoc}
288      * @param locale {@inheritDoc}
289      */
290     @Override
291     public String getDisplayName(TextStyle style, Locale locale) {
292         // If this JapaneseEra is a supplemental one, obtain the name from
293         // the era definition.
294         if (getValue() &gt; N_ERA_CONSTANTS - ERA_OFFSET) {
295             Objects.requireNonNull(locale, &quot;locale&quot;);
296             return style.asNormal() == TextStyle.NARROW ? getAbbreviation() : getName();
297         }
298 
299         return new DateTimeFormatterBuilder()
300             .appendText(ERA, style)
301             .toFormatter(locale)
302             .withChronology(JapaneseChronology.INSTANCE)
303             .format(this == MEIJI ? MEIJI_6_ISODATE : since);
304     }
305 
306     //-----------------------------------------------------------------------
307     /**
308      * Obtains an instance of {@code JapaneseEra} from a date.
309      *
310      * @param date  the date, not null
311      * @return the Era singleton, never null
312      */
313     static JapaneseEra from(LocalDate date) {
314         if (date.isBefore(MEIJI_6_ISODATE)) {
315             throw new DateTimeException(&quot;JapaneseDate before Meiji 6 are not supported&quot;);
316         }
317         for (int i = KNOWN_ERAS.length - 1; i &gt; 0; i--) {
318             JapaneseEra era = KNOWN_ERAS[i];
319             if (date.compareTo(era.since) &gt;= 0) {
320                 return era;
321             }
322         }
323         return null;
324     }
325 
326     static JapaneseEra toJapaneseEra(sun.util.calendar.Era privateEra) {
327         for (int i = ERA_CONFIG.length - 1; i &gt;= 0; i--) {
328             if (ERA_CONFIG[i].equals(privateEra)) {
329                 return KNOWN_ERAS[i];
330             }
331         }
332         return null;
333     }
334 
335     static sun.util.calendar.Era privateEraFrom(LocalDate isoDate) {
336         for (int i = KNOWN_ERAS.length - 1; i &gt; 0; i--) {
337             JapaneseEra era = KNOWN_ERAS[i];
338             if (isoDate.compareTo(era.since) &gt;= 0) {
339                 return ERA_CONFIG[i];
340             }
341         }
342         return null;
343     }
344 
345     /**
346      * Returns the index into the arrays from the Era value.
347      * the eraValue is a valid Era number, -1..2.
348      *
349      * @param eraValue  the era value to convert to the index
350      * @return the index of the current Era
351      */
352     private static int ordinal(int eraValue) {
353         return eraValue + ERA_OFFSET - 1;
354     }
355 
356     //-----------------------------------------------------------------------
357     /**
358      * Gets the numeric era {@code int} value.
359      * &lt;p&gt;
360      * The {@link #SHOWA} era that contains 1970-01-01 (ISO calendar system) has the value 1.
361      * Later eras are numbered from 2 ({@link #HEISEI}).
362      * Earlier eras are numbered 0 ({@link #TAISHO}), -1 ({@link #MEIJI})).
363      *
364      * @return the era value
365      */
366     @Override
367     public int getValue() {
368         return eraValue;
369     }
370 
371     //-----------------------------------------------------------------------
372     /**
373      * Gets the range of valid values for the specified field.
374      * &lt;p&gt;
375      * The range object expresses the minimum and maximum valid values for a field.
376      * This era is used to enhance the accuracy of the returned range.
377      * If it is not possible to return the range, because the field is not supported
378      * or for some other reason, an exception is thrown.
379      * &lt;p&gt;
380      * If the field is a {@link ChronoField} then the query is implemented here.
381      * The {@code ERA} field returns the range.
382      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
383      * &lt;p&gt;
384      * If the field is not a {@code ChronoField}, then the result of this method
385      * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
386      * passing {@code this} as the argument.
387      * Whether the range can be obtained is determined by the field.
388      * &lt;p&gt;
389      * The range of valid Japanese eras can change over time due to the nature
390      * of the Japanese calendar system.
391      *
392      * @param field  the field to query the range for, not null
393      * @return the range of valid values for the field, not null
394      * @throws DateTimeException if the range for the field cannot be obtained
395      * @throws UnsupportedTemporalTypeException if the unit is not supported
396      */
397     @Override  // override as super would return range from 0 to 1
398     public ValueRange range(TemporalField field) {
399         if (field == ERA) {
400             return JapaneseChronology.INSTANCE.range(ERA);
401         }
402         return Era.super.range(field);
403     }
404 
405     //-----------------------------------------------------------------------
406     String getAbbreviation() {
407         return ERA_CONFIG[ordinal(getValue())].getAbbreviation();
408     }
409 
410     String getName() {
411         return ERA_CONFIG[ordinal(getValue())].getName();
412     }
413 
414     @Override
415     public String toString() {
416         return getName();
417     }
418 
419     //-----------------------------------------------------------------------
420     /**
421      * Defend against malicious streams.
422      *
423      * @param s the stream to read
424      * @throws InvalidObjectException always
425      */
<a name="6" id="anc6"></a>
426     private void readObject(ObjectInputStream s) throws InvalidObjectException {
427         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
428     }
429 
430     //-----------------------------------------------------------------------
431     /**
432      * Writes the object using a
433      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
434      * @serialData
435      * &lt;pre&gt;
436      *  out.writeByte(5);        // identifies a JapaneseEra
437      *  out.writeInt(getValue());
438      * &lt;/pre&gt;
439      *
440      * @return the instance of {@code Ser}, not null
441      */
<a name="7" id="anc7"></a>
442     private Object writeReplace() {
443         return new Ser(Ser.JAPANESE_ERA_TYPE, this);
444     }
445 
446     void writeExternal(DataOutput out) throws IOException {
447         out.writeByte(this.getValue());
448     }
449 
450     static JapaneseEra readExternal(DataInput in) throws IOException {
451         byte eraValue = in.readByte();
452         return JapaneseEra.of(eraValue);
453     }
454 
455 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
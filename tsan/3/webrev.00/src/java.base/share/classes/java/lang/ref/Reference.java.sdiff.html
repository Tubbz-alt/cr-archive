<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/ref/Reference.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../module/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/ref/Reference.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
306         SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
307             @Override
308             public boolean waitForReferenceProcessing()
309                 throws InterruptedException
310             {
311                 return Reference.waitForReferenceProcessing();
312             }
313 
314             @Override
315             public void runFinalization() {
316                 Finalizer.runFinalization();
317             }
318         });
319     }
320 
321     /* -- Referent accessor and setters -- */
322 
323     /**
324      * Returns this reference object&#39;s referent.  If this reference object has
325      * been cleared, either by the program or by the garbage collector, then
<span class="line-modified">326      * this method returns &lt;code&gt;null&lt;/code&gt;.</span>
327      *
328      * @return   The object to which this reference refers, or
<span class="line-modified">329      *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</span>
330      */
331     @HotSpotIntrinsicCandidate
332     public T get() {
333         return this.referent;
334     }
335 
336     /**
337      * Clears this reference object.  Invoking this method will not cause this
338      * object to be enqueued.
339      *
340      * &lt;p&gt; This method is invoked only by Java code; when the garbage collector
341      * clears references it does so directly, without invoking this method.
342      */
343     public void clear() {
344         this.referent = null;
345     }
346 
347     /* -- Queue operations -- */
348 
349     /**
350      * Tells whether or not this reference object has been enqueued, either by
351      * the program or by the garbage collector.  If this reference object was
352      * not registered with a queue when it was created, then this method will
<span class="line-modified">353      * always return &lt;code&gt;false&lt;/code&gt;.</span>
354      *
<span class="line-modified">355      * @return   &lt;code&gt;true&lt;/code&gt; if and only if this reference object has</span>
356      *           been enqueued
357      */
358     public boolean isEnqueued() {
359         return (this.queue == ReferenceQueue.ENQUEUED);
360     }
361 
362     /**
363      * Clears this reference object and adds it to the queue with which
364      * it is registered, if any.
365      *
366      * &lt;p&gt; This method is invoked only by Java code; when the garbage collector
367      * enqueues references it does so directly, without invoking this method.
368      *
<span class="line-modified">369      * @return   &lt;code&gt;true&lt;/code&gt; if this reference object was successfully</span>
<span class="line-modified">370      *           enqueued; &lt;code&gt;false&lt;/code&gt; if it was already enqueued or if</span>
371      *           it was not registered with a queue when it was created
372      */
373     public boolean enqueue() {
374         this.referent = null;
375         return this.queue.enqueue(this);
376     }
377 
378     /**
379      * Throws {@link CloneNotSupportedException}. A {@code Reference} cannot be
380      * meaningfully cloned. Construct a new {@code Reference} instead.
381      *
382      * @return never returns normally
383      * @throws  CloneNotSupportedException always
384      *
385      * @since 11
386      */
387     @Override
388     protected Object clone() throws CloneNotSupportedException {
389         throw new CloneNotSupportedException();
390     }
</pre>
<hr />
<pre>
401     }
402 
403     /**
404      * Ensures that the object referenced by the given reference remains
405      * &lt;a href=&quot;package-summary.html#reachability&quot;&gt;&lt;em&gt;strongly reachable&lt;/em&gt;&lt;/a&gt;,
406      * regardless of any prior actions of the program that might otherwise cause
407      * the object to become unreachable; thus, the referenced object is not
408      * reclaimable by garbage collection at least until after the invocation of
409      * this method.  Invocation of this method does not itself initiate garbage
410      * collection or finalization.
411      *
412      * &lt;p&gt; This method establishes an ordering for
413      * &lt;a href=&quot;package-summary.html#reachability&quot;&gt;&lt;em&gt;strong reachability&lt;/em&gt;&lt;/a&gt;
414      * with respect to garbage collection.  It controls relations that are
415      * otherwise only implicit in a program -- the reachability conditions
416      * triggering garbage collection.  This method is designed for use in
417      * uncommon situations of premature finalization where using
418      * {@code synchronized} blocks or methods, or using other synchronization
419      * facilities are not possible or do not provide the desired control.  This
420      * method is applicable only when reclamation may have visible effects,
<span class="line-modified">421      * which is possible for objects with finalizers (See</span>
<span class="line-modified">422      * &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6&quot;&gt;</span>
<span class="line-modified">423      * Section 12.6 17 of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;&lt;/a&gt;)</span>
<span class="line-modified">424      * that are implemented in ways that rely on ordering control for correctness.</span>
425      *
426      * @apiNote
427      * Finalization may occur whenever the virtual machine detects that no
428      * reference to an object will ever be stored in the heap: The garbage
429      * collector may reclaim an object even if the fields of that object are
430      * still in use, so long as the object has otherwise become unreachable.
431      * This may have surprising and undesirable effects in cases such as the
432      * following example in which the bookkeeping associated with a class is
433      * managed through array indices.  Here, method {@code action} uses a
434      * {@code reachabilityFence} to ensure that the {@code Resource} object is
435      * not reclaimed before bookkeeping on an associated
436      * {@code ExternalResource} has been performed; in particular here, to
437      * ensure that the array slot holding the {@code ExternalResource} is not
438      * nulled out in method {@link Object#finalize}, which may otherwise run
439      * concurrently.
440      *
441      * &lt;pre&gt; {@code
442      * class Resource {
443      *   private static ExternalResource[] externalResourceArray = ...
444      *
</pre>
<hr />
<pre>
491      * }
492      * private ExternalResource getExternalResource() {
493      *   ExternalResource ext = externalResourceArray[myIndex];
494      *   Reference.reachabilityFence(this);
495      *   return ext;
496      * }}&lt;/pre&gt;
497      *
498      * &lt;p&gt; Method {@code reachabilityFence} is not required in constructions
499      * that themselves ensure reachability.  For example, because objects that
500      * are locked cannot, in general, be reclaimed, it would suffice if all
501      * accesses of the object, in all methods of class {@code Resource}
502      * (including {@code finalize}) were enclosed in {@code synchronized (this)}
503      * blocks.  (Further, such blocks must not include infinite loops, or
504      * themselves be unreachable, which fall into the corner case exceptions to
505      * the &quot;in general&quot; disclaimer.)  However, method {@code reachabilityFence}
506      * remains a better option in cases where this approach is not as efficient,
507      * desirable, or possible; for example because it would encounter deadlock.
508      *
509      * @param ref the reference. If {@code null}, this method has no effect.
510      * @since 9

511      */
512     @ForceInline
513     public static void reachabilityFence(Object ref) {
514         // Does nothing. This method is annotated with @ForceInline to eliminate
515         // most of the overhead that using @DontInline would cause with the
516         // HotSpot JVM, when this fence is used in a wide variety of situations.
517         // HotSpot JVM retains the ref and does not GC it before a call to
518         // this method, because the JIT-compilers do not have GC-only safepoints.
519     }
520 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
306         SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
307             @Override
308             public boolean waitForReferenceProcessing()
309                 throws InterruptedException
310             {
311                 return Reference.waitForReferenceProcessing();
312             }
313 
314             @Override
315             public void runFinalization() {
316                 Finalizer.runFinalization();
317             }
318         });
319     }
320 
321     /* -- Referent accessor and setters -- */
322 
323     /**
324      * Returns this reference object&#39;s referent.  If this reference object has
325      * been cleared, either by the program or by the garbage collector, then
<span class="line-modified">326      * this method returns {@code null}.</span>
327      *
328      * @return   The object to which this reference refers, or
<span class="line-modified">329      *           {@code null} if this reference object has been cleared</span>
330      */
331     @HotSpotIntrinsicCandidate
332     public T get() {
333         return this.referent;
334     }
335 
336     /**
337      * Clears this reference object.  Invoking this method will not cause this
338      * object to be enqueued.
339      *
340      * &lt;p&gt; This method is invoked only by Java code; when the garbage collector
341      * clears references it does so directly, without invoking this method.
342      */
343     public void clear() {
344         this.referent = null;
345     }
346 
347     /* -- Queue operations -- */
348 
349     /**
350      * Tells whether or not this reference object has been enqueued, either by
351      * the program or by the garbage collector.  If this reference object was
352      * not registered with a queue when it was created, then this method will
<span class="line-modified">353      * always return {@code false}.</span>
354      *
<span class="line-modified">355      * @return   {@code true} if and only if this reference object has</span>
356      *           been enqueued
357      */
358     public boolean isEnqueued() {
359         return (this.queue == ReferenceQueue.ENQUEUED);
360     }
361 
362     /**
363      * Clears this reference object and adds it to the queue with which
364      * it is registered, if any.
365      *
366      * &lt;p&gt; This method is invoked only by Java code; when the garbage collector
367      * enqueues references it does so directly, without invoking this method.
368      *
<span class="line-modified">369      * @return   {@code true} if this reference object was successfully</span>
<span class="line-modified">370      *           enqueued; {@code false} if it was already enqueued or if</span>
371      *           it was not registered with a queue when it was created
372      */
373     public boolean enqueue() {
374         this.referent = null;
375         return this.queue.enqueue(this);
376     }
377 
378     /**
379      * Throws {@link CloneNotSupportedException}. A {@code Reference} cannot be
380      * meaningfully cloned. Construct a new {@code Reference} instead.
381      *
382      * @return never returns normally
383      * @throws  CloneNotSupportedException always
384      *
385      * @since 11
386      */
387     @Override
388     protected Object clone() throws CloneNotSupportedException {
389         throw new CloneNotSupportedException();
390     }
</pre>
<hr />
<pre>
401     }
402 
403     /**
404      * Ensures that the object referenced by the given reference remains
405      * &lt;a href=&quot;package-summary.html#reachability&quot;&gt;&lt;em&gt;strongly reachable&lt;/em&gt;&lt;/a&gt;,
406      * regardless of any prior actions of the program that might otherwise cause
407      * the object to become unreachable; thus, the referenced object is not
408      * reclaimable by garbage collection at least until after the invocation of
409      * this method.  Invocation of this method does not itself initiate garbage
410      * collection or finalization.
411      *
412      * &lt;p&gt; This method establishes an ordering for
413      * &lt;a href=&quot;package-summary.html#reachability&quot;&gt;&lt;em&gt;strong reachability&lt;/em&gt;&lt;/a&gt;
414      * with respect to garbage collection.  It controls relations that are
415      * otherwise only implicit in a program -- the reachability conditions
416      * triggering garbage collection.  This method is designed for use in
417      * uncommon situations of premature finalization where using
418      * {@code synchronized} blocks or methods, or using other synchronization
419      * facilities are not possible or do not provide the desired control.  This
420      * method is applicable only when reclamation may have visible effects,
<span class="line-modified">421      * which is possible for objects with finalizers (See Section 12.6</span>
<span class="line-modified">422      * of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;) that</span>
<span class="line-modified">423      * are implemented in ways that rely on ordering control for</span>
<span class="line-modified">424      * correctness.</span>
425      *
426      * @apiNote
427      * Finalization may occur whenever the virtual machine detects that no
428      * reference to an object will ever be stored in the heap: The garbage
429      * collector may reclaim an object even if the fields of that object are
430      * still in use, so long as the object has otherwise become unreachable.
431      * This may have surprising and undesirable effects in cases such as the
432      * following example in which the bookkeeping associated with a class is
433      * managed through array indices.  Here, method {@code action} uses a
434      * {@code reachabilityFence} to ensure that the {@code Resource} object is
435      * not reclaimed before bookkeeping on an associated
436      * {@code ExternalResource} has been performed; in particular here, to
437      * ensure that the array slot holding the {@code ExternalResource} is not
438      * nulled out in method {@link Object#finalize}, which may otherwise run
439      * concurrently.
440      *
441      * &lt;pre&gt; {@code
442      * class Resource {
443      *   private static ExternalResource[] externalResourceArray = ...
444      *
</pre>
<hr />
<pre>
491      * }
492      * private ExternalResource getExternalResource() {
493      *   ExternalResource ext = externalResourceArray[myIndex];
494      *   Reference.reachabilityFence(this);
495      *   return ext;
496      * }}&lt;/pre&gt;
497      *
498      * &lt;p&gt; Method {@code reachabilityFence} is not required in constructions
499      * that themselves ensure reachability.  For example, because objects that
500      * are locked cannot, in general, be reclaimed, it would suffice if all
501      * accesses of the object, in all methods of class {@code Resource}
502      * (including {@code finalize}) were enclosed in {@code synchronized (this)}
503      * blocks.  (Further, such blocks must not include infinite loops, or
504      * themselves be unreachable, which fall into the corner case exceptions to
505      * the &quot;in general&quot; disclaimer.)  However, method {@code reachabilityFence}
506      * remains a better option in cases where this approach is not as efficient,
507      * desirable, or possible; for example because it would encounter deadlock.
508      *
509      * @param ref the reference. If {@code null}, this method has no effect.
510      * @since 9
<span class="line-added">511      * @jls 12.6 Finalization of Class Instances</span>
512      */
513     @ForceInline
514     public static void reachabilityFence(Object ref) {
515         // Does nothing. This method is annotated with @ForceInline to eliminate
516         // most of the overhead that using @DontInline would cause with the
517         // HotSpot JVM, when this fence is used in a wide variety of situations.
518         // HotSpot JVM retains the ref and does not GC it before a call to
519         // this method, because the JIT-compilers do not have GC-only safepoints.
520     }
521 }
</pre>
</td>
</tr>
</table>
<center><a href="../module/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
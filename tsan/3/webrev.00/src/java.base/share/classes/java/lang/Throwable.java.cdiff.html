<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/Throwable.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadGroup.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TypeNotPresentException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Throwable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,12 ***</span>
   * questions.
   */
  
  package java.lang;
  
<span class="line-modified">! import  java.io.*;</span>
<span class="line-modified">! import  java.util.*;</span>
  
  /**
   * The {@code Throwable} class is the superclass of all errors and
   * exceptions in the Java language. Only objects that are instances of this
   * class (or one of its subclasses) are thrown by the Java Virtual Machine or
<span class="line-new-header">--- 23,12 ---</span>
   * questions.
   */
  
  package java.lang;
  
<span class="line-modified">! import java.io.*;</span>
<span class="line-modified">! import java.util.*;</span>
  
  /**
   * The {@code Throwable} class is the superclass of all errors and
   * exceptions in the Java language. Only objects that are instances of this
   * class (or one of its subclasses) are thrown by the Java Virtual Machine or
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,10 ***</span>
<span class="line-new-header">--- 112,11 ---</span>
   * @jls 11.2 Compile-Time Checking of Exceptions
   * @since 1.0
   */
  public class Throwable implements Serializable {
      /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = -3042686055658047285L;
  
      /**
       * The JVM saves some indication of the stack backtrace in this slot.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,10 ***</span>
<span class="line-new-header">--- 228,11 ---</span>
       * zero-element list, the field is reset to the sentinel value.
       *
       * @serial
       * @since 1.7
       */
<span class="line-added">+     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
      private List&lt;Throwable&gt; suppressedExceptions = SUPPRESSED_SENTINEL;
  
      /** Message for trying to suppress a null exception. */
      private static final String NULL_CAUSE_MESSAGE = &quot;Cannot suppress a null exception.&quot;;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 691,11 ***</span>
                                           String caption,
                                           String prefix,
                                           Set&lt;Throwable&gt; dejaVu) {
          assert Thread.holdsLock(s.lock());
          if (dejaVu.contains(this)) {
<span class="line-modified">!             s.println(&quot;\t[CIRCULAR REFERENCE:&quot; + this + &quot;]&quot;);</span>
          } else {
              dejaVu.add(this);
              // Compute number of frames in common between this and enclosing trace
              StackTraceElement[] trace = getOurStackTrace();
              int m = trace.length - 1;
<span class="line-new-header">--- 693,11 ---</span>
                                           String caption,
                                           String prefix,
                                           Set&lt;Throwable&gt; dejaVu) {
          assert Thread.holdsLock(s.lock());
          if (dejaVu.contains(this)) {
<span class="line-modified">!             s.println(prefix + caption + &quot;[CIRCULAR REFERENCE: &quot; + this + &quot;]&quot;);</span>
          } else {
              dejaVu.add(this);
              // Compute number of frames in common between this and enclosing trace
              StackTraceElement[] trace = getOurStackTrace();
              int m = trace.length - 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 899,69 ***</span>
       *
       * Note that there are no constraints on the value the {@code
       * cause} field can hold; both {@code null} and {@code this} are
       * valid values for the field.
       */
      private void readObject(ObjectInputStream s)
          throws IOException, ClassNotFoundException {
          s.defaultReadObject();     // read in all fields
<span class="line-modified">!         if (suppressedExceptions != null) {</span>
<span class="line-modified">!             List&lt;Throwable&gt; suppressed = null;</span>
<span class="line-modified">!             if (suppressedExceptions.isEmpty()) {</span>
<span class="line-modified">!                 // Use the sentinel for a zero-length list</span>
<span class="line-modified">!                 suppressed = SUPPRESSED_SENTINEL;</span>
<span class="line-modified">!             } else { // Copy Throwables to new list</span>
<span class="line-modified">!                 suppressed = new ArrayList&lt;&gt;(1);</span>
<span class="line-modified">!                 for (Throwable t : suppressedExceptions) {</span>
                      // Enforce constraints on suppressed exceptions in
                      // case of corrupt or malicious stream.
                      Objects.requireNonNull(t, NULL_CAUSE_MESSAGE);
                      if (t == this)
                          throw new IllegalArgumentException(SELF_SUPPRESSION_MESSAGE);
<span class="line-modified">!                     suppressed.add(t);</span>
                  }
              }
<span class="line-modified">!             suppressedExceptions = suppressed;</span>
<span class="line-modified">!         } // else a null suppressedExceptions field remains null</span>
  
          /*
           * For zero-length stack traces, use a clone of
           * UNASSIGNED_STACK rather than UNASSIGNED_STACK itself to
           * allow identity comparison against UNASSIGNED_STACK in
           * getOurStackTrace.  The identity of UNASSIGNED_STACK in
           * stackTrace indicates to the getOurStackTrace method that
           * the stackTrace needs to be constructed from the information
           * in backtrace.
           */
<span class="line-modified">!         if (stackTrace != null) {</span>
<span class="line-modified">!             if (stackTrace.length == 0) {</span>
<span class="line-modified">!                 stackTrace = UNASSIGNED_STACK.clone();</span>
<span class="line-modified">!             }  else if (stackTrace.length == 1 &amp;&amp;</span>
                          // Check for the marker of an immutable stack trace
<span class="line-modified">!                         SentinelHolder.STACK_TRACE_ELEMENT_SENTINEL.equals(stackTrace[0])) {</span>
<span class="line-modified">!                 stackTrace = null;</span>
<span class="line-modified">!             } else { // Verify stack trace elements are non-null.</span>
<span class="line-modified">!                 for(StackTraceElement ste : stackTrace) {</span>
<span class="line-modified">!                     Objects.requireNonNull(ste, &quot;null StackTraceElement in serial stream.&quot;);</span>
                  }
              }
          } else {
<span class="line-modified">!             // A null stackTrace field in the serial form can result</span>
<span class="line-modified">!             // from an exception serialized without that field in</span>
<span class="line-modified">!             // older JDK releases; treat such exceptions as having</span>
<span class="line-modified">!             // empty stack traces.</span>
<span class="line-modified">!             stackTrace = UNASSIGNED_STACK.clone();</span>
          }
      }
  
      /**
       * Write a {@code Throwable} object to a stream.
       *
       * A {@code null} stack trace field is represented in the serial
       * form as a one-element array whose element is equal to {@code
       * new StackTraceElement(&quot;&quot;, &quot;&quot;, null, Integer.MIN_VALUE)}.
       */
      private synchronized void writeObject(ObjectOutputStream s)
          throws IOException {
          // Ensure that the stackTrace field is initialized to a
          // non-null value, if appropriate.  As of JDK 7, a null stack
          // trace field is a valid value indicating the stack trace
<span class="line-new-header">--- 901,100 ---</span>
       *
       * Note that there are no constraints on the value the {@code
       * cause} field can hold; both {@code null} and {@code this} are
       * valid values for the field.
       */
<span class="line-added">+     @java.io.Serial</span>
      private void readObject(ObjectInputStream s)
          throws IOException, ClassNotFoundException {
          s.defaultReadObject();     // read in all fields
<span class="line-modified">! </span>
<span class="line-modified">!         // Set suppressed exceptions and stack trace elements fields</span>
<span class="line-modified">!         // to marker values until the contents from the serial stream</span>
<span class="line-modified">!         // are validated.</span>
<span class="line-modified">!         List&lt;Throwable&gt; candidateSuppressedExceptions = suppressedExceptions;</span>
<span class="line-modified">!         suppressedExceptions = SUPPRESSED_SENTINEL;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         StackTraceElement[] candidateStackTrace = stackTrace;</span>
<span class="line-added">+         stackTrace = UNASSIGNED_STACK.clone();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (candidateSuppressedExceptions != null) {</span>
<span class="line-added">+             int suppressedSize = validateSuppressedExceptionsList(candidateSuppressedExceptions);</span>
<span class="line-added">+             if (suppressedSize &gt; 0) { // Copy valid Throwables to new list</span>
<span class="line-added">+                 var suppList  = new ArrayList&lt;Throwable&gt;(Math.min(100, suppressedSize));</span>
<span class="line-added">+ </span>
<span class="line-added">+                 for (Throwable t : candidateSuppressedExceptions) {</span>
                      // Enforce constraints on suppressed exceptions in
                      // case of corrupt or malicious stream.
                      Objects.requireNonNull(t, NULL_CAUSE_MESSAGE);
                      if (t == this)
                          throw new IllegalArgumentException(SELF_SUPPRESSION_MESSAGE);
<span class="line-modified">!                     suppList.add(t);</span>
                  }
<span class="line-added">+                 // If there are any invalid suppressed exceptions,</span>
<span class="line-added">+                 // implicitly use the sentinel value assigned earlier.</span>
<span class="line-added">+                 suppressedExceptions = suppList;</span>
              }
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             suppressedExceptions = null;</span>
<span class="line-added">+         }</span>
  
          /*
           * For zero-length stack traces, use a clone of
           * UNASSIGNED_STACK rather than UNASSIGNED_STACK itself to
           * allow identity comparison against UNASSIGNED_STACK in
           * getOurStackTrace.  The identity of UNASSIGNED_STACK in
           * stackTrace indicates to the getOurStackTrace method that
           * the stackTrace needs to be constructed from the information
           * in backtrace.
           */
<span class="line-modified">!         if (candidateStackTrace != null) {</span>
<span class="line-modified">!             // Work from a clone of the candidateStackTrace to ensure</span>
<span class="line-modified">!             // consistency of checks.</span>
<span class="line-modified">!             candidateStackTrace = candidateStackTrace.clone();</span>
<span class="line-added">+             if (candidateStackTrace.length &gt;= 1) {</span>
<span class="line-added">+                 if (candidateStackTrace.length == 1 &amp;&amp;</span>
                          // Check for the marker of an immutable stack trace
<span class="line-modified">!                         SentinelHolder.STACK_TRACE_ELEMENT_SENTINEL.equals(candidateStackTrace[0])) {</span>
<span class="line-modified">!                     stackTrace = null;</span>
<span class="line-modified">!                 } else { // Verify stack trace elements are non-null.</span>
<span class="line-modified">!                     for (StackTraceElement ste : candidateStackTrace) {</span>
<span class="line-modified">!                         Objects.requireNonNull(ste, &quot;null StackTraceElement in serial stream.&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     stackTrace = candidateStackTrace;</span>
                  }
              }
<span class="line-added">+         }</span>
<span class="line-added">+         // A null stackTrace field in the serial form can result from</span>
<span class="line-added">+         // an exception serialized without that field in older JDK</span>
<span class="line-added">+         // releases; treat such exceptions as having empty stack</span>
<span class="line-added">+         // traces by leaving stackTrace assigned to a clone of</span>
<span class="line-added">+         // UNASSIGNED_STACK.</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private int validateSuppressedExceptionsList(List&lt;Throwable&gt; deserSuppressedExceptions)</span>
<span class="line-added">+         throws IOException {</span>
<span class="line-added">+         if (!Object.class.getModule().</span>
<span class="line-added">+             equals(deserSuppressedExceptions.getClass().getModule())) {</span>
<span class="line-added">+             throw new StreamCorruptedException(&quot;List implementation not in base module.&quot;);</span>
          } else {
<span class="line-modified">!             int size = deserSuppressedExceptions.size();</span>
<span class="line-modified">!             if (size &lt; 0) {</span>
<span class="line-modified">!                 throw new StreamCorruptedException(&quot;Negative list size reported.&quot;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return size;</span>
          }
      }
  
      /**
       * Write a {@code Throwable} object to a stream.
       *
       * A {@code null} stack trace field is represented in the serial
       * form as a one-element array whose element is equal to {@code
       * new StackTraceElement(&quot;&quot;, &quot;&quot;, null, Integer.MIN_VALUE)}.
       */
<span class="line-added">+     @java.io.Serial</span>
      private synchronized void writeObject(ObjectOutputStream s)
          throws IOException {
          // Ensure that the stackTrace field is initialized to a
          // non-null value, if appropriate.  As of JDK 7, a null stack
          // trace field is a valid value indicating the stack trace
</pre>
<center><a href="ThreadGroup.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TypeNotPresentException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
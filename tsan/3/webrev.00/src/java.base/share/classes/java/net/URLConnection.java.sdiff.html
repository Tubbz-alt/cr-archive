<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/URLConnection.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="URLClassLoader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URLPermission.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/URLConnection.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 310                     sun.net.www.MimeTable.loadTable();
 311 
 312                 public String getContentTypeFor(String fileName) {
 313                     return internalMap.getContentTypeFor(fileName);
 314                 }
 315             };
 316         }
 317 
 318         return map;
 319     }
 320 
 321     /**
 322      * Sets the FileNameMap.
 323      * &lt;p&gt;
 324      * If there is a security manager, this method first calls
 325      * the security manager&#39;s {@code checkSetFactory} method
 326      * to ensure the operation is allowed.
 327      * This could result in a SecurityException.
 328      *
 329      * @param map the FileNameMap to be set
<span class="line-modified"> 330      * @exception  SecurityException  if a security manager exists and its</span>
 331      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
 332      * @see        SecurityManager#checkSetFactory
 333      * @see #getFileNameMap()
 334      * @since 1.2
 335      */
 336     public static void setFileNameMap(FileNameMap map) {
 337         SecurityManager sm = System.getSecurityManager();
 338         if (sm != null) sm.checkSetFactory();
 339         fileNameMap = map;
 340     }
 341 
 342     /**
 343      * Opens a communications link to the resource referenced by this
 344      * URL, if such a connection has not already been established.
 345      * &lt;p&gt;
 346      * If the {@code connect} method is called when the connection
 347      * has already been opened (indicated by the {@code connected}
 348      * field having the value {@code true}), the call is ignored.
 349      * &lt;p&gt;
 350      * URLConnection objects go through two phases: first they are
 351      * created, then they are connected.  After being created, and
 352      * before being connected, various options can be specified
 353      * (e.g., doInput and UseCaches).  After connecting, it is an
 354      * error to try to set them.  Operations that depend on being
 355      * connected, like getContentLength, will implicitly perform the
 356      * connection, if necessary.
 357      *
 358      * @throws SocketTimeoutException if the timeout expires before
 359      *               the connection can be established
<span class="line-modified"> 360      * @exception  IOException  if an I/O error occurs while opening the</span>
 361      *               connection.
 362      * @see java.net.URLConnection#connected
 363      * @see #getConnectTimeout()
 364      * @see #setConnectTimeout(int)
 365      */
 366     public abstract void connect() throws IOException;
 367 
 368     /**
 369      * Sets a specified timeout value, in milliseconds, to be used
 370      * when opening a communications link to the resource referenced
 371      * by this URLConnection.  If the timeout expires before the
 372      * connection can be established, a
 373      * java.net.SocketTimeoutException is raised. A timeout of zero is
 374      * interpreted as an infinite timeout.
 375 
 376      * &lt;p&gt; Some non-standard implementation of this method may ignore
 377      * the specified timeout. To see the connect timeout set, please
 378      * call getConnectTimeout().
 379      *
 380      * @param timeout an {@code int} that specifies the connect
</pre>
<hr />
<pre>
 717      *     java.net.ContentHandlerFactory ContentHandlerFactory}
 718      *     implementations using the system class
 719      *     loader. The order that factories are located is implementation
 720      *     specific, and an implementation is free to cache the located
 721      *     factories. A {@linkplain java.util.ServiceConfigurationError
 722      *     ServiceConfigurationError}, {@code Error} or {@code RuntimeException}
 723      *     thrown from the {@code createContentHandler}, if encountered, will
 724      *     be propagated to the calling thread. The {@code
 725      *     createContentHandler} method of each factory, if instantiated, is
 726      *     invoked, with the content type, until a factory returns non-null,
 727      *     or all factories have been exhausted.
 728      * &lt;li&gt;Failing that, this method tries to load a content handler
 729      *     class as defined by {@link java.net.ContentHandler ContentHandler}.
 730      *     If the class does not exist, or is not a subclass of {@code
 731      *     ContentHandler}, then an {@code UnknownServiceException} is thrown.
 732      * &lt;/ol&gt;
 733      *
 734      * @return     the object fetched. The {@code instanceof} operator
 735      *               should be used to determine the specific kind of object
 736      *               returned.
<span class="line-modified"> 737      * @exception  IOException              if an I/O error occurs while</span>
 738      *               getting the content.
<span class="line-modified"> 739      * @exception  UnknownServiceException  if the protocol does not support</span>
 740      *               the content type.
 741      * @see        java.net.ContentHandlerFactory#createContentHandler(java.lang.String)
 742      * @see        java.net.URLConnection#getContentType()
 743      * @see        java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)
 744      */
 745     public Object getContent() throws IOException {
 746         // Must call getInputStream before GetHeaderField gets called
 747         // so that FileNotFoundException has a chance to be thrown up
 748         // from here without being caught.
 749         getInputStream();
 750         return getContentHandler().getContent(this);
 751     }
 752 
 753     /**
 754      * Retrieves the contents of this URL connection.
 755      *
 756      * @param classes the {@code Class} array
 757      * indicating the requested types
 758      * @return     the object fetched that is the first match of the type
 759      *               specified in the classes array. null if none of
 760      *               the requested types are supported.
 761      *               The {@code instanceof} operator should be used to
 762      *               determine the specific kind of object returned.
<span class="line-modified"> 763      * @exception  IOException              if an I/O error occurs while</span>
 764      *               getting the content.
<span class="line-modified"> 765      * @exception  UnknownServiceException  if the protocol does not support</span>
 766      *               the content type.
 767      * @see        java.net.URLConnection#getContent()
 768      * @see        java.net.ContentHandlerFactory#createContentHandler(java.lang.String)
 769      * @see        java.net.URLConnection#getContent(java.lang.Class[])
 770      * @see        java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)
 771      * @since 1.3
 772      */
 773     public Object getContent(Class&lt;?&gt;[] classes) throws IOException {
 774         // Must call getInputStream before GetHeaderField gets called
 775         // so that FileNotFoundException has a chance to be thrown up
 776         // from here without being caught.
 777         getInputStream();
 778         return getContentHandler().getContent(this, classes);
 779     }
 780 
 781     /**
 782      * Returns a permission object representing the permission
 783      * necessary to make the connection represented by this
 784      * object. This method returns null if no permission is
 785      * required to make the connection. By default, this method
</pre>
<hr />
<pre>
 796      * sever, say foo.com, may redirect the connection to a different
 797      * host, say bar.com. Before connecting the permission returned by
 798      * the connection will represent the permission needed to connect
 799      * to foo.com, while the permission returned after connecting will
 800      * be to bar.com.
 801      *
 802      * &lt;p&gt;Permissions are generally used for two purposes: to protect
 803      * caches of objects obtained through URLConnections, and to check
 804      * the right of a recipient to learn about a particular URL. In
 805      * the first case, the permission should be obtained
 806      * &lt;em&gt;after&lt;/em&gt; the object has been obtained. For example, in an
 807      * HTTP connection, this will represent the permission to connect
 808      * to the host from which the data was ultimately fetched. In the
 809      * second case, the permission should be obtained and tested
 810      * &lt;em&gt;before&lt;/em&gt; connecting.
 811      *
 812      * @return the permission object representing the permission
 813      * necessary to make the connection represented by this
 814      * URLConnection.
 815      *
<span class="line-modified"> 816      * @exception IOException if the computation of the permission</span>
 817      * requires network or file I/O and an exception occurs while
 818      * computing it.
 819      */
 820     public Permission getPermission() throws IOException {
 821         return SecurityConstants.ALL_PERMISSION;
 822     }
 823 
 824     /**
 825      * Returns an input stream that reads from this open connection.
 826      *
 827      * A SocketTimeoutException can be thrown when reading from the
 828      * returned input stream if the read timeout expires before data
 829      * is available for read.
 830      *
 831      * @return     an input stream that reads from this open connection.
<span class="line-modified"> 832      * @exception  IOException              if an I/O error occurs while</span>
 833      *               creating the input stream.
<span class="line-modified"> 834      * @exception  UnknownServiceException  if the protocol does not support</span>
 835      *               input.
 836      * @see #setReadTimeout(int)
 837      * @see #getReadTimeout()
 838      */
 839     public InputStream getInputStream() throws IOException {
 840         throw new UnknownServiceException(&quot;protocol doesn&#39;t support input&quot;);
 841     }
 842 
 843     /**
 844      * Returns an output stream that writes to this connection.
 845      *
 846      * @return     an output stream that writes to this connection.
<span class="line-modified"> 847      * @exception  IOException              if an I/O error occurs while</span>
 848      *               creating the output stream.
<span class="line-modified"> 849      * @exception  UnknownServiceException  if the protocol does not support</span>
 850      *               output.
 851      */
 852     public OutputStream getOutputStream() throws IOException {
 853         throw new UnknownServiceException(&quot;protocol doesn&#39;t support output&quot;);
 854     }
 855 
 856     /**
 857      * Returns a {@code String} representation of this URL connection.
 858      *
 859      * @return  a string representation of this {@code URLConnection}.
 860      */
 861     public String toString() {
 862         return this.getClass().getName() + &quot;:&quot; + url;
 863     }
 864 
 865     /**
 866      * Sets the value of the {@code doInput} field for this
 867      * {@code URLConnection} to the specified value.
 868      * &lt;p&gt;
 869      * A URL connection can be used for input and/or output.  Set the doInput
</pre>
<hr />
<pre>
1233     }
1234 
1235     /**
1236      * The ContentHandler factory.
1237      */
1238     private static volatile ContentHandlerFactory factory;
1239 
1240     /**
1241      * Sets the {@code ContentHandlerFactory} of an
1242      * application. It can be called at most once by an application.
1243      * &lt;p&gt;
1244      * The {@code ContentHandlerFactory} instance is used to
1245      * construct a content handler from a content type.
1246      * &lt;p&gt;
1247      * If there is a security manager, this method first calls
1248      * the security manager&#39;s {@code checkSetFactory} method
1249      * to ensure the operation is allowed.
1250      * This could result in a SecurityException.
1251      *
1252      * @param      fac   the desired factory.
<span class="line-modified">1253      * @exception  Error  if the factory has already been defined.</span>
<span class="line-modified">1254      * @exception  SecurityException  if a security manager exists and its</span>
1255      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
1256      * @see        java.net.ContentHandlerFactory
1257      * @see        java.net.URLConnection#getContent()
1258      * @see        SecurityManager#checkSetFactory
1259      */
1260     public static synchronized void setContentHandlerFactory(ContentHandlerFactory fac) {
1261         if (factory != null) {
1262             throw new Error(&quot;factory already defined&quot;);
1263         }
1264         SecurityManager security = System.getSecurityManager();
1265         if (security != null) {
1266             security.checkSetFactory();
1267         }
1268         factory = fac;
1269     }
1270 
1271     private static final Hashtable&lt;String, ContentHandler&gt; handlers = new Hashtable&lt;&gt;();
1272 
1273     /**
1274      * Gets the Content Handler appropriate for this connection.
</pre>
<hr />
<pre>
1462      */
1463     public static String guessContentTypeFromName(String fname) {
1464         return getFileNameMap().getContentTypeFor(fname);
1465     }
1466 
1467     /**
1468      * Tries to determine the type of an input stream based on the
1469      * characters at the beginning of the input stream. This method can
1470      * be used by subclasses that override the
1471      * {@code getContentType} method.
1472      * &lt;p&gt;
1473      * Ideally, this routine would not be needed. But many
1474      * {@code http} servers return the incorrect content type; in
1475      * addition, there are many nonstandard extensions. Direct inspection
1476      * of the bytes to determine the content type is often more accurate
1477      * than believing the content type claimed by the {@code http} server.
1478      *
1479      * @param      is   an input stream that supports marks.
1480      * @return     a guess at the content type, or {@code null} if none
1481      *             can be determined.
<span class="line-modified">1482      * @exception  IOException  if an I/O error occurs while reading the</span>
1483      *               input stream.
1484      * @see        java.io.InputStream#mark(int)
1485      * @see        java.io.InputStream#markSupported()
1486      * @see        java.net.URLConnection#getContentType()
1487      */
1488     public static String guessContentTypeFromStream(InputStream is)
1489                         throws IOException {
1490         // If we can&#39;t read ahead safely, just give up on guessing
1491         if (!is.markSupported())
1492             return null;
1493 
1494         is.mark(16);
1495         int c1 = is.read();
1496         int c2 = is.read();
1497         int c3 = is.read();
1498         int c4 = is.read();
1499         int c5 = is.read();
1500         int c6 = is.read();
1501         int c7 = is.read();
1502         int c8 = is.read();
</pre>
</td>
<td>
<hr />
<pre>
 310                     sun.net.www.MimeTable.loadTable();
 311 
 312                 public String getContentTypeFor(String fileName) {
 313                     return internalMap.getContentTypeFor(fileName);
 314                 }
 315             };
 316         }
 317 
 318         return map;
 319     }
 320 
 321     /**
 322      * Sets the FileNameMap.
 323      * &lt;p&gt;
 324      * If there is a security manager, this method first calls
 325      * the security manager&#39;s {@code checkSetFactory} method
 326      * to ensure the operation is allowed.
 327      * This could result in a SecurityException.
 328      *
 329      * @param map the FileNameMap to be set
<span class="line-modified"> 330      * @throws     SecurityException  if a security manager exists and its</span>
 331      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
 332      * @see        SecurityManager#checkSetFactory
 333      * @see #getFileNameMap()
 334      * @since 1.2
 335      */
 336     public static void setFileNameMap(FileNameMap map) {
 337         SecurityManager sm = System.getSecurityManager();
 338         if (sm != null) sm.checkSetFactory();
 339         fileNameMap = map;
 340     }
 341 
 342     /**
 343      * Opens a communications link to the resource referenced by this
 344      * URL, if such a connection has not already been established.
 345      * &lt;p&gt;
 346      * If the {@code connect} method is called when the connection
 347      * has already been opened (indicated by the {@code connected}
 348      * field having the value {@code true}), the call is ignored.
 349      * &lt;p&gt;
 350      * URLConnection objects go through two phases: first they are
 351      * created, then they are connected.  After being created, and
 352      * before being connected, various options can be specified
 353      * (e.g., doInput and UseCaches).  After connecting, it is an
 354      * error to try to set them.  Operations that depend on being
 355      * connected, like getContentLength, will implicitly perform the
 356      * connection, if necessary.
 357      *
 358      * @throws SocketTimeoutException if the timeout expires before
 359      *               the connection can be established
<span class="line-modified"> 360      * @throws     IOException  if an I/O error occurs while opening the</span>
 361      *               connection.
 362      * @see java.net.URLConnection#connected
 363      * @see #getConnectTimeout()
 364      * @see #setConnectTimeout(int)
 365      */
 366     public abstract void connect() throws IOException;
 367 
 368     /**
 369      * Sets a specified timeout value, in milliseconds, to be used
 370      * when opening a communications link to the resource referenced
 371      * by this URLConnection.  If the timeout expires before the
 372      * connection can be established, a
 373      * java.net.SocketTimeoutException is raised. A timeout of zero is
 374      * interpreted as an infinite timeout.
 375 
 376      * &lt;p&gt; Some non-standard implementation of this method may ignore
 377      * the specified timeout. To see the connect timeout set, please
 378      * call getConnectTimeout().
 379      *
 380      * @param timeout an {@code int} that specifies the connect
</pre>
<hr />
<pre>
 717      *     java.net.ContentHandlerFactory ContentHandlerFactory}
 718      *     implementations using the system class
 719      *     loader. The order that factories are located is implementation
 720      *     specific, and an implementation is free to cache the located
 721      *     factories. A {@linkplain java.util.ServiceConfigurationError
 722      *     ServiceConfigurationError}, {@code Error} or {@code RuntimeException}
 723      *     thrown from the {@code createContentHandler}, if encountered, will
 724      *     be propagated to the calling thread. The {@code
 725      *     createContentHandler} method of each factory, if instantiated, is
 726      *     invoked, with the content type, until a factory returns non-null,
 727      *     or all factories have been exhausted.
 728      * &lt;li&gt;Failing that, this method tries to load a content handler
 729      *     class as defined by {@link java.net.ContentHandler ContentHandler}.
 730      *     If the class does not exist, or is not a subclass of {@code
 731      *     ContentHandler}, then an {@code UnknownServiceException} is thrown.
 732      * &lt;/ol&gt;
 733      *
 734      * @return     the object fetched. The {@code instanceof} operator
 735      *               should be used to determine the specific kind of object
 736      *               returned.
<span class="line-modified"> 737      * @throws     IOException              if an I/O error occurs while</span>
 738      *               getting the content.
<span class="line-modified"> 739      * @throws     UnknownServiceException  if the protocol does not support</span>
 740      *               the content type.
 741      * @see        java.net.ContentHandlerFactory#createContentHandler(java.lang.String)
 742      * @see        java.net.URLConnection#getContentType()
 743      * @see        java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)
 744      */
 745     public Object getContent() throws IOException {
 746         // Must call getInputStream before GetHeaderField gets called
 747         // so that FileNotFoundException has a chance to be thrown up
 748         // from here without being caught.
 749         getInputStream();
 750         return getContentHandler().getContent(this);
 751     }
 752 
 753     /**
 754      * Retrieves the contents of this URL connection.
 755      *
 756      * @param classes the {@code Class} array
 757      * indicating the requested types
 758      * @return     the object fetched that is the first match of the type
 759      *               specified in the classes array. null if none of
 760      *               the requested types are supported.
 761      *               The {@code instanceof} operator should be used to
 762      *               determine the specific kind of object returned.
<span class="line-modified"> 763      * @throws     IOException              if an I/O error occurs while</span>
 764      *               getting the content.
<span class="line-modified"> 765      * @throws     UnknownServiceException  if the protocol does not support</span>
 766      *               the content type.
 767      * @see        java.net.URLConnection#getContent()
 768      * @see        java.net.ContentHandlerFactory#createContentHandler(java.lang.String)
 769      * @see        java.net.URLConnection#getContent(java.lang.Class[])
 770      * @see        java.net.URLConnection#setContentHandlerFactory(java.net.ContentHandlerFactory)
 771      * @since 1.3
 772      */
 773     public Object getContent(Class&lt;?&gt;[] classes) throws IOException {
 774         // Must call getInputStream before GetHeaderField gets called
 775         // so that FileNotFoundException has a chance to be thrown up
 776         // from here without being caught.
 777         getInputStream();
 778         return getContentHandler().getContent(this, classes);
 779     }
 780 
 781     /**
 782      * Returns a permission object representing the permission
 783      * necessary to make the connection represented by this
 784      * object. This method returns null if no permission is
 785      * required to make the connection. By default, this method
</pre>
<hr />
<pre>
 796      * sever, say foo.com, may redirect the connection to a different
 797      * host, say bar.com. Before connecting the permission returned by
 798      * the connection will represent the permission needed to connect
 799      * to foo.com, while the permission returned after connecting will
 800      * be to bar.com.
 801      *
 802      * &lt;p&gt;Permissions are generally used for two purposes: to protect
 803      * caches of objects obtained through URLConnections, and to check
 804      * the right of a recipient to learn about a particular URL. In
 805      * the first case, the permission should be obtained
 806      * &lt;em&gt;after&lt;/em&gt; the object has been obtained. For example, in an
 807      * HTTP connection, this will represent the permission to connect
 808      * to the host from which the data was ultimately fetched. In the
 809      * second case, the permission should be obtained and tested
 810      * &lt;em&gt;before&lt;/em&gt; connecting.
 811      *
 812      * @return the permission object representing the permission
 813      * necessary to make the connection represented by this
 814      * URLConnection.
 815      *
<span class="line-modified"> 816      * @throws    IOException if the computation of the permission</span>
 817      * requires network or file I/O and an exception occurs while
 818      * computing it.
 819      */
 820     public Permission getPermission() throws IOException {
 821         return SecurityConstants.ALL_PERMISSION;
 822     }
 823 
 824     /**
 825      * Returns an input stream that reads from this open connection.
 826      *
 827      * A SocketTimeoutException can be thrown when reading from the
 828      * returned input stream if the read timeout expires before data
 829      * is available for read.
 830      *
 831      * @return     an input stream that reads from this open connection.
<span class="line-modified"> 832      * @throws     IOException              if an I/O error occurs while</span>
 833      *               creating the input stream.
<span class="line-modified"> 834      * @throws     UnknownServiceException  if the protocol does not support</span>
 835      *               input.
 836      * @see #setReadTimeout(int)
 837      * @see #getReadTimeout()
 838      */
 839     public InputStream getInputStream() throws IOException {
 840         throw new UnknownServiceException(&quot;protocol doesn&#39;t support input&quot;);
 841     }
 842 
 843     /**
 844      * Returns an output stream that writes to this connection.
 845      *
 846      * @return     an output stream that writes to this connection.
<span class="line-modified"> 847      * @throws     IOException              if an I/O error occurs while</span>
 848      *               creating the output stream.
<span class="line-modified"> 849      * @throws     UnknownServiceException  if the protocol does not support</span>
 850      *               output.
 851      */
 852     public OutputStream getOutputStream() throws IOException {
 853         throw new UnknownServiceException(&quot;protocol doesn&#39;t support output&quot;);
 854     }
 855 
 856     /**
 857      * Returns a {@code String} representation of this URL connection.
 858      *
 859      * @return  a string representation of this {@code URLConnection}.
 860      */
 861     public String toString() {
 862         return this.getClass().getName() + &quot;:&quot; + url;
 863     }
 864 
 865     /**
 866      * Sets the value of the {@code doInput} field for this
 867      * {@code URLConnection} to the specified value.
 868      * &lt;p&gt;
 869      * A URL connection can be used for input and/or output.  Set the doInput
</pre>
<hr />
<pre>
1233     }
1234 
1235     /**
1236      * The ContentHandler factory.
1237      */
1238     private static volatile ContentHandlerFactory factory;
1239 
1240     /**
1241      * Sets the {@code ContentHandlerFactory} of an
1242      * application. It can be called at most once by an application.
1243      * &lt;p&gt;
1244      * The {@code ContentHandlerFactory} instance is used to
1245      * construct a content handler from a content type.
1246      * &lt;p&gt;
1247      * If there is a security manager, this method first calls
1248      * the security manager&#39;s {@code checkSetFactory} method
1249      * to ensure the operation is allowed.
1250      * This could result in a SecurityException.
1251      *
1252      * @param      fac   the desired factory.
<span class="line-modified">1253      * @throws     Error  if the factory has already been defined.</span>
<span class="line-modified">1254      * @throws     SecurityException  if a security manager exists and its</span>
1255      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
1256      * @see        java.net.ContentHandlerFactory
1257      * @see        java.net.URLConnection#getContent()
1258      * @see        SecurityManager#checkSetFactory
1259      */
1260     public static synchronized void setContentHandlerFactory(ContentHandlerFactory fac) {
1261         if (factory != null) {
1262             throw new Error(&quot;factory already defined&quot;);
1263         }
1264         SecurityManager security = System.getSecurityManager();
1265         if (security != null) {
1266             security.checkSetFactory();
1267         }
1268         factory = fac;
1269     }
1270 
1271     private static final Hashtable&lt;String, ContentHandler&gt; handlers = new Hashtable&lt;&gt;();
1272 
1273     /**
1274      * Gets the Content Handler appropriate for this connection.
</pre>
<hr />
<pre>
1462      */
1463     public static String guessContentTypeFromName(String fname) {
1464         return getFileNameMap().getContentTypeFor(fname);
1465     }
1466 
1467     /**
1468      * Tries to determine the type of an input stream based on the
1469      * characters at the beginning of the input stream. This method can
1470      * be used by subclasses that override the
1471      * {@code getContentType} method.
1472      * &lt;p&gt;
1473      * Ideally, this routine would not be needed. But many
1474      * {@code http} servers return the incorrect content type; in
1475      * addition, there are many nonstandard extensions. Direct inspection
1476      * of the bytes to determine the content type is often more accurate
1477      * than believing the content type claimed by the {@code http} server.
1478      *
1479      * @param      is   an input stream that supports marks.
1480      * @return     a guess at the content type, or {@code null} if none
1481      *             can be determined.
<span class="line-modified">1482      * @throws     IOException  if an I/O error occurs while reading the</span>
1483      *               input stream.
1484      * @see        java.io.InputStream#mark(int)
1485      * @see        java.io.InputStream#markSupported()
1486      * @see        java.net.URLConnection#getContentType()
1487      */
1488     public static String guessContentTypeFromStream(InputStream is)
1489                         throws IOException {
1490         // If we can&#39;t read ahead safely, just give up on guessing
1491         if (!is.markSupported())
1492             return null;
1493 
1494         is.mark(16);
1495         int c1 = is.read();
1496         int c2 = is.read();
1497         int c3 = is.read();
1498         int c4 = is.read();
1499         int c5 = is.read();
1500         int c6 = is.read();
1501         int c7 = is.read();
1502         int c8 = is.read();
</pre>
</td>
</tr>
</table>
<center><a href="URLClassLoader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="URLPermission.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
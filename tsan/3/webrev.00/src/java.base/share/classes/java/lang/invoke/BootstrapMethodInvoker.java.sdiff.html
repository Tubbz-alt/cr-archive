<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/BootstrapMethodInvoker.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractConstantGroup.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="BoundMethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/BootstrapMethodInvoker.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
347         }
348         return x;
349     }
350 
351     private static void maybeReBoxElements(Object[] xa) {
352         for (int i = 0; i &lt; xa.length; i++) {
353             xa[i] = maybeReBox(xa[i]);
354         }
355     }
356 
357     /** Canonical VM-aware implementation of BootstrapCallInfo.
358      * Knows how to dig into the JVM for lazily resolved (pull-mode) constants.
359      */
360     private static final class VM_BSCI&lt;T&gt; extends BSCIWithCache&lt;T&gt; {
361         private final int[] indexInfo;
362         private final Class&lt;?&gt; caller;  // for index resolution only
363 
364         VM_BSCI(MethodHandle bsm, String name, T type,
365                 Lookup lookup, int[] indexInfo) {
366             super(bsm, name, type, indexInfo[0]);
<span class="line-modified">367             if (!lookup.hasPrivateAccess())  //D.I.D.</span>
368                 throw new AssertionError(&quot;bad Lookup object&quot;);
369             this.caller = lookup.lookupClass();
370             this.indexInfo = indexInfo;
371             // scoop up all the easy stuff right away:
372             prefetchIntoCache(0, size());
373         }
374 
375         @Override Object fillCache(int i) {
376             Object[] buf = { null };
377             copyConstants(i, i+1, buf, 0);
378             Object res = wrapNull(buf[0]);
379             cache[i] = res;
380             int next = i + 1;
381             if (next &lt; cache.length &amp;&amp; cache[next] == null)
382                 maybePrefetchIntoCache(next, false);  // try to prefetch
383             return res;
384         }
385 
386         @Override public int copyConstants(int start, int end,
387                                            Object[] buf, int pos) {
</pre>
<hr />
<pre>
443 
444         private void prefetchIntoCache(int i, int pfLimit) {
445             if (pfLimit &lt;= i)  return;  // corner case
446             Object[] temp = new Object[pfLimit - i];
447             if (TRACE_METHOD_LINKAGE) {
448                 System.out.println(&quot;prefetching BSM arguments: &quot; +
449                         Arrays.asList(caller.getSimpleName(), Arrays.toString(indexInfo), i, pfLimit));
450             }
451             copyOutBootstrapArguments(caller, indexInfo,
452                                       i, pfLimit, temp, 0,
453                                       false, NOT_PRESENT);
454             for (Object x : temp) {
455                 if (x != NOT_PRESENT &amp;&amp; cache[i] == null) {
456                     cache[i] = wrapNull(maybeReBox(x));
457                 }
458                 i++;
459             }
460         }
461     }
462 
<span class="line-modified">463     /*non-public*/ static final</span>
<span class="line-modified">464     class PushAdapter {</span>
465         // skeleton for push-mode BSM which wraps a pull-mode BSM:
466         static Object pushToBootstrapMethod(MethodHandle pullModeBSM,
467                                             MethodHandles.Lookup lookup, String name, Object type,
468                                             Object... arguments) throws Throwable {
469             ConstantGroup cons = makeConstantGroup(Arrays.asList(arguments));
470             BootstrapCallInfo&lt;?&gt; bsci = makeBootstrapCallInfo(pullModeBSM, name, type, cons);
471             if (TRACE_METHOD_LINKAGE)
472                 System.out.println(&quot;pull-mode BSM gets pushed arguments from fake BSCI&quot;);
473             return pullModeBSM.invoke(lookup, bsci);
474         }
475 
476         static final MethodHandle MH_pushToBootstrapMethod;
477         static {
478             final Class&lt;?&gt; THIS_CLASS = PushAdapter.class;
479             try {
480                 MH_pushToBootstrapMethod = IMPL_LOOKUP
481                     .findStatic(THIS_CLASS, &quot;pushToBootstrapMethod&quot;,
482                                 MethodType.methodType(Object.class, MethodHandle.class,
483                                         Lookup.class, String.class, Object.class, Object[].class));
484             } catch (Throwable ex) {
485                 throw new InternalError(ex);
486             }
487         }
488     }
489 
<span class="line-modified">490     /*non-public*/ static final</span>
<span class="line-modified">491     class PullAdapter {</span>
492         // skeleton for pull-mode BSM which wraps a push-mode BSM:
493         static Object pullFromBootstrapMethod(MethodHandle pushModeBSM,
494                                               MethodHandles.Lookup lookup,
495                                               BootstrapCallInfo&lt;?&gt; bsci)
496                 throws Throwable {
497             int argc = bsci.size();
498             switch (argc) {
499                 case 0:
500                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType());
501                 case 1:
502                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType(),
503                             bsci.get(0));
504                 case 2:
505                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType(),
506                             bsci.get(0), bsci.get(1));
507                 case 3:
508                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType(),
509                             bsci.get(0), bsci.get(1), bsci.get(2));
510                 case 4:
511                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType(),
</pre>
</td>
<td>
<hr />
<pre>
347         }
348         return x;
349     }
350 
351     private static void maybeReBoxElements(Object[] xa) {
352         for (int i = 0; i &lt; xa.length; i++) {
353             xa[i] = maybeReBox(xa[i]);
354         }
355     }
356 
357     /** Canonical VM-aware implementation of BootstrapCallInfo.
358      * Knows how to dig into the JVM for lazily resolved (pull-mode) constants.
359      */
360     private static final class VM_BSCI&lt;T&gt; extends BSCIWithCache&lt;T&gt; {
361         private final int[] indexInfo;
362         private final Class&lt;?&gt; caller;  // for index resolution only
363 
364         VM_BSCI(MethodHandle bsm, String name, T type,
365                 Lookup lookup, int[] indexInfo) {
366             super(bsm, name, type, indexInfo[0]);
<span class="line-modified">367             if (!lookup.hasFullPrivilegeAccess())  //D.I.D.</span>
368                 throw new AssertionError(&quot;bad Lookup object&quot;);
369             this.caller = lookup.lookupClass();
370             this.indexInfo = indexInfo;
371             // scoop up all the easy stuff right away:
372             prefetchIntoCache(0, size());
373         }
374 
375         @Override Object fillCache(int i) {
376             Object[] buf = { null };
377             copyConstants(i, i+1, buf, 0);
378             Object res = wrapNull(buf[0]);
379             cache[i] = res;
380             int next = i + 1;
381             if (next &lt; cache.length &amp;&amp; cache[next] == null)
382                 maybePrefetchIntoCache(next, false);  // try to prefetch
383             return res;
384         }
385 
386         @Override public int copyConstants(int start, int end,
387                                            Object[] buf, int pos) {
</pre>
<hr />
<pre>
443 
444         private void prefetchIntoCache(int i, int pfLimit) {
445             if (pfLimit &lt;= i)  return;  // corner case
446             Object[] temp = new Object[pfLimit - i];
447             if (TRACE_METHOD_LINKAGE) {
448                 System.out.println(&quot;prefetching BSM arguments: &quot; +
449                         Arrays.asList(caller.getSimpleName(), Arrays.toString(indexInfo), i, pfLimit));
450             }
451             copyOutBootstrapArguments(caller, indexInfo,
452                                       i, pfLimit, temp, 0,
453                                       false, NOT_PRESENT);
454             for (Object x : temp) {
455                 if (x != NOT_PRESENT &amp;&amp; cache[i] == null) {
456                     cache[i] = wrapNull(maybeReBox(x));
457                 }
458                 i++;
459             }
460         }
461     }
462 
<span class="line-modified">463     /*non-public*/</span>
<span class="line-modified">464     static final class PushAdapter {</span>
465         // skeleton for push-mode BSM which wraps a pull-mode BSM:
466         static Object pushToBootstrapMethod(MethodHandle pullModeBSM,
467                                             MethodHandles.Lookup lookup, String name, Object type,
468                                             Object... arguments) throws Throwable {
469             ConstantGroup cons = makeConstantGroup(Arrays.asList(arguments));
470             BootstrapCallInfo&lt;?&gt; bsci = makeBootstrapCallInfo(pullModeBSM, name, type, cons);
471             if (TRACE_METHOD_LINKAGE)
472                 System.out.println(&quot;pull-mode BSM gets pushed arguments from fake BSCI&quot;);
473             return pullModeBSM.invoke(lookup, bsci);
474         }
475 
476         static final MethodHandle MH_pushToBootstrapMethod;
477         static {
478             final Class&lt;?&gt; THIS_CLASS = PushAdapter.class;
479             try {
480                 MH_pushToBootstrapMethod = IMPL_LOOKUP
481                     .findStatic(THIS_CLASS, &quot;pushToBootstrapMethod&quot;,
482                                 MethodType.methodType(Object.class, MethodHandle.class,
483                                         Lookup.class, String.class, Object.class, Object[].class));
484             } catch (Throwable ex) {
485                 throw new InternalError(ex);
486             }
487         }
488     }
489 
<span class="line-modified">490     /*non-public*/</span>
<span class="line-modified">491     static final class PullAdapter {</span>
492         // skeleton for pull-mode BSM which wraps a push-mode BSM:
493         static Object pullFromBootstrapMethod(MethodHandle pushModeBSM,
494                                               MethodHandles.Lookup lookup,
495                                               BootstrapCallInfo&lt;?&gt; bsci)
496                 throws Throwable {
497             int argc = bsci.size();
498             switch (argc) {
499                 case 0:
500                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType());
501                 case 1:
502                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType(),
503                             bsci.get(0));
504                 case 2:
505                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType(),
506                             bsci.get(0), bsci.get(1));
507                 case 3:
508                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType(),
509                             bsci.get(0), bsci.get(1), bsci.get(2));
510                 case 4:
511                     return pushModeBSM.invoke(lookup, bsci.invocationName(), bsci.invocationType(),
</pre>
</td>
</tr>
</table>
<center><a href="AbstractConstantGroup.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="BoundMethodHandle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
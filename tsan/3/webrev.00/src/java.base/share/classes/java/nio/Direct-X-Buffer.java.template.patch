diff a/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template b/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
--- a/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
+++ b/src/java.base/share/classes/java/nio/Direct-X-Buffer.java.template
@@ -28,10 +28,11 @@
 package java.nio;
 
 import java.io.FileDescriptor;
 import java.lang.ref.Reference;
 import java.util.Objects;
+import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.misc.VM;
 import jdk.internal.ref.Cleaner;
 import sun.nio.ch.DirectBuffer;
 
 
@@ -110,11 +111,11 @@
 
     // Primary constructor
     //
     Direct$Type$Buffer$RW$(int cap) {                   // package-private
 #if[rw]
-        super(-1, 0, cap, cap);
+        super(-1, 0, cap, cap, null);
         boolean pa = VM.isDirectMemoryPageAligned();
         int ps = Bits.pageSize();
         long size = Math.max(1L, (long)cap + (pa ? ps : 0));
         Bits.reserveMemory(size, cap);
 
@@ -143,22 +144,22 @@
 #if[rw]
 
     // Invoked to construct a direct ByteBuffer referring to the block of
     // memory. A given arbitrary object may also be attached to the buffer.
     //
-    Direct$Type$Buffer(long addr, int cap, Object ob) {
-        super(-1, 0, cap, cap);
+    Direct$Type$Buffer(long addr, int cap, Object ob, MemorySegmentProxy segment) {
+        super(-1, 0, cap, cap, segment);
         address = addr;
         cleaner = null;
         att = ob;
     }
 
 
     // Invoked only by JNI: NewDirectByteBuffer(void*, long)
     //
     private Direct$Type$Buffer(long addr, int cap) {
-        super(-1, 0, cap, cap);
+        super(-1, 0, cap, cap, null);
         address = addr;
         cleaner = null;
         att = null;
     }
 
@@ -166,41 +167,42 @@
 
     // For memory-mapped buffers -- invoked by FileChannelImpl via reflection
     //
     protected Direct$Type$Buffer$RW$(int cap, long addr,
                                      FileDescriptor fd,
-                                     Runnable unmapper)
+                                     Runnable unmapper,
+                                     boolean isSync, MemorySegmentProxy segment)
     {
 #if[rw]
-        super(-1, 0, cap, cap, fd);
+        super(-1, 0, cap, cap, fd, isSync, segment);
         address = addr;
         cleaner = Cleaner.create(this, unmapper);
         att = null;
 #else[rw]
-        super(cap, addr, fd, unmapper);
+        super(cap, addr, fd, unmapper, isSync, segment);
         this.isReadOnly = true;
 #end[rw]
     }
 
 #end[byte]
 
     // For duplicates and slices
     //
     Direct$Type$Buffer$RW$$BO$(DirectBuffer db,         // package-private
                                int mark, int pos, int lim, int cap,
-                               int off)
+                               int off, MemorySegmentProxy segment)
     {
 #if[rw]
-        super(mark, pos, lim, cap);
+        super(mark, pos, lim, cap, segment);
         address = db.address() + off;
 #if[byte]
         cleaner = null;
 #end[byte]
         Object attachment = db.attachment();
         att = (attachment == null ? db : attachment);
 #else[rw]
-        super(db, mark, pos, lim, cap, off);
+        super(db, mark, pos, lim, cap, off, segment);
         this.isReadOnly = true;
 #end[rw]
     }
 
     @Override
@@ -213,41 +215,41 @@
         int lim = this.limit();
         assert (pos <= lim);
         int rem = (pos <= lim ? lim - pos : 0);
         int off = (pos << $LG_BYTES_PER_VALUE$);
         assert (off >= 0);
-        return new Direct$Type$Buffer$RW$$BO$(this, -1, 0, rem, rem, off);
+        return new Direct$Type$Buffer$RW$$BO$(this, -1, 0, rem, rem, off, segment);
     }
 
     @Override
     public $Type$Buffer slice(int index, int length) {
         Objects.checkFromIndexSize(index, length, limit());
         return new Direct$Type$Buffer$RW$$BO$(this,
                                               -1,
                                               0,
                                               length,
                                               length,
-                                              index);
+                                              index, segment);
     }
 
     public $Type$Buffer duplicate() {
         return new Direct$Type$Buffer$RW$$BO$(this,
                                               this.markValue(),
                                               this.position(),
                                               this.limit(),
                                               this.capacity(),
-                                              0);
+                                              0, segment);
     }
 
     public $Type$Buffer asReadOnlyBuffer() {
 #if[rw]
         return new Direct$Type$BufferR$BO$(this,
                                            this.markValue(),
                                            this.position(),
                                            this.limit(),
                                            this.capacity(),
-                                           0);
+                                           0, segment);
 #else[rw]
         return duplicate();
 #end[rw]
     }
 
@@ -261,18 +263,20 @@
         return address + ((long)i << $LG_BYTES_PER_VALUE$);
     }
 
     public $type$ get() {
         try {
+            checkSegment();
             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(nextGetIndex()))));
         } finally {
             Reference.reachabilityFence(this);
         }
     }
 
     public $type$ get(int i) {
         try {
+            checkSegment();
             return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(checkIndex(i)))));
         } finally {
             Reference.reachabilityFence(this);
         }
     }
@@ -287,12 +291,13 @@
     }
 #end[streamableType]
 
     public $Type$Buffer get($type$[] dst, int offset, int length) {
 #if[rw]
+        checkSegment();
         if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
-            checkBounds(offset, length, dst.length);
+            Objects.checkFromIndexSize(offset, length, dst.length);
             int pos = position();
             int lim = limit();
             assert (pos <= lim);
             int rem = (pos <= lim ? lim - pos : 0);
             if (length > rem)
@@ -328,10 +333,11 @@
 #end[rw]
     }
 
     public $Type$Buffer get(int index, $type$[] dst, int offset, int length) {
 #if[rw]
+        checkSegment();
         if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {
             Objects.checkFromIndexSize(index, length, limit());
             Objects.checkFromIndexSize(offset, length, dst.length);
 
             long dstOffset = ARRAY_BASE_OFFSET + ((long)offset << $LG_BYTES_PER_VALUE$);
@@ -365,10 +371,11 @@
 #end[rw]
 
     public $Type$Buffer put($type$ x) {
 #if[rw]
         try {
+            checkSegment();
             UNSAFE.put$Swaptype$(ix(nextPutIndex()), $swap$($toBits$(x)));
         } finally {
             Reference.reachabilityFence(this);
         }
         return this;
@@ -378,10 +385,11 @@
     }
 
     public $Type$Buffer put(int i, $type$ x) {
 #if[rw]
         try {
+            checkSegment();
             UNSAFE.put$Swaptype$(ix(checkIndex(i)), $swap$($toBits$(x)));
         } finally {
             Reference.reachabilityFence(this);
         }
         return this;
@@ -390,10 +398,11 @@
 #end[rw]
     }
 
     public $Type$Buffer put($Type$Buffer src) {
 #if[rw]
+        checkSegment();
         if (src instanceof Direct$Type$Buffer$BO$) {
             if (src == this)
                 throw createSameBufferException();
             Direct$Type$Buffer$RW$$BO$ sb = (Direct$Type$Buffer$RW$$BO$)src;
 
@@ -436,12 +445,13 @@
 #end[rw]
     }
 
     public $Type$Buffer put($type$[] src, int offset, int length) {
 #if[rw]
+        checkSegment();
         if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
-            checkBounds(offset, length, src.length);
+            Objects.checkFromIndexSize(offset, length, src.length);
             int pos = position();
             int lim = limit();
             assert (pos <= lim);
             int rem = (pos <= lim ? lim - pos : 0);
             if (length > rem)
@@ -477,10 +487,11 @@
 #end[rw]
     }
 
     public $Type$Buffer put(int index, $type$[] src, int offset, int length) {
 #if[rw]
+        checkSegment();
         if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) {
             Objects.checkFromIndexSize(index, length, limit());
             Objects.checkFromIndexSize(offset, length, src.length);
 
 
@@ -543,12 +554,11 @@
 
 
 #if[char]
 
     public String toString(int start, int end) {
-        if ((end > limit()) || (start > end))
-            throw new IndexOutOfBoundsException();
+        Objects.checkFromToIndex(start, end, limit());
         try {
             int len = end - start;
             char[] ca = new char[len];
             CharBuffer cb = CharBuffer.wrap(ca);
             CharBuffer db = this.duplicate();
@@ -569,18 +579,17 @@
         int lim = limit();
         assert (pos <= lim);
         pos = (pos <= lim ? pos : lim);
         int len = lim - pos;
 
-        if ((start < 0) || (end > len) || (start > end))
-            throw new IndexOutOfBoundsException();
+        Objects.checkFromToIndex(start, end, len);
         return new DirectCharBuffer$RW$$BO$(this,
                                             -1,
                                             pos + start,
                                             pos + end,
                                             capacity(),
-                                            offset);
+                                            offset, segment);
     }
 
 #end[char]
 
 

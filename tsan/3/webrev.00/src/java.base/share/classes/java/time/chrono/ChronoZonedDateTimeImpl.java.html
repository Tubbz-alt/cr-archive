<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/time/chrono/ChronoZonedDateTimeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * This file is available under and governed by the GNU General Public
 28  * License version 2 only, as published by the Free Software Foundation.
 29  * However, the following notice accompanied the original version of this
 30  * file:
 31  *
 32  * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 33  *
 34  * All rights reserved.
 35  *
 36  * Redistribution and use in source and binary forms, with or without
 37  * modification, are permitted provided that the following conditions are met:
 38  *
 39  *  * Redistributions of source code must retain the above copyright notice,
 40  *    this list of conditions and the following disclaimer.
 41  *
 42  *  * Redistributions in binary form must reproduce the above copyright notice,
 43  *    this list of conditions and the following disclaimer in the documentation
 44  *    and/or other materials provided with the distribution.
 45  *
 46  *  * Neither the name of JSR-310 nor the names of its contributors
 47  *    may be used to endorse or promote products derived from this software
 48  *    without specific prior written permission.
 49  *
 50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 61  */
 62 package java.time.chrono;
 63 
 64 import static java.time.temporal.ChronoUnit.SECONDS;
 65 
 66 import java.io.IOException;
 67 import java.io.InvalidObjectException;
 68 import java.io.ObjectInput;
 69 import java.io.ObjectInputStream;
 70 import java.io.ObjectOutput;
 71 import java.io.Serializable;
 72 import java.time.Instant;
 73 import java.time.LocalDateTime;
 74 import java.time.ZoneId;
 75 import java.time.ZoneOffset;
 76 import java.time.temporal.ChronoField;
 77 import java.time.temporal.ChronoUnit;
 78 import java.time.temporal.Temporal;
 79 import java.time.temporal.TemporalField;
 80 import java.time.temporal.TemporalUnit;
 81 import java.time.zone.ZoneOffsetTransition;
 82 import java.time.zone.ZoneRules;
 83 import java.util.List;
 84 import java.util.Objects;
 85 
 86 /**
 87  * A date-time with a time-zone in the calendar neutral API.
 88  * &lt;p&gt;
 89  * {@code ZoneChronoDateTime} is an immutable representation of a date-time with a time-zone.
 90  * This class stores all date and time fields, to a precision of nanoseconds,
 91  * as well as a time-zone and zone offset.
 92  * &lt;p&gt;
 93  * The purpose of storing the time-zone is to distinguish the ambiguous case where
 94  * the local time-line overlaps, typically as a result of the end of daylight time.
 95  * Information about the local-time can be obtained using methods on the time-zone.
 96  *
 97  * @implSpec
 98  * This class is immutable and thread-safe.
 99  *
100  * @serial Document the delegation of this class in the serialized-form specification.
101  * @param &lt;D&gt; the concrete type for the date of this date-time
102  * @since 1.8
103  */
104 final class ChronoZonedDateTimeImpl&lt;D extends ChronoLocalDate&gt;
105         implements ChronoZonedDateTime&lt;D&gt;, Serializable {
106 
107     /**
108      * Serialization version.
109      */
110     @java.io.Serial
111     private static final long serialVersionUID = -5261813987200935591L;
112 
113     /**
114      * The local date-time.
115      */
116     private final transient ChronoLocalDateTimeImpl&lt;D&gt; dateTime;
117     /**
118      * The zone offset.
119      */
120     private final transient ZoneOffset offset;
121     /**
122      * The zone ID.
123      */
124     private final transient ZoneId zone;
125 
126     //-----------------------------------------------------------------------
127     /**
128      * Obtains an instance from a local date-time using the preferred offset if possible.
129      *
130      * @param localDateTime  the local date-time, not null
131      * @param zone  the zone identifier, not null
132      * @param preferredOffset  the zone offset, null if no preference
133      * @return the zoned date-time, not null
134      */
135     static &lt;R extends ChronoLocalDate&gt; ChronoZonedDateTime&lt;R&gt; ofBest(
136             ChronoLocalDateTimeImpl&lt;R&gt; localDateTime, ZoneId zone, ZoneOffset preferredOffset) {
137         Objects.requireNonNull(localDateTime, &quot;localDateTime&quot;);
138         Objects.requireNonNull(zone, &quot;zone&quot;);
139         if (zone instanceof ZoneOffset) {
140             return new ChronoZonedDateTimeImpl&lt;&gt;(localDateTime, (ZoneOffset) zone, zone);
141         }
142         ZoneRules rules = zone.getRules();
143         LocalDateTime isoLDT = LocalDateTime.from(localDateTime);
144         List&lt;ZoneOffset&gt; validOffsets = rules.getValidOffsets(isoLDT);
145         ZoneOffset offset;
146         if (validOffsets.size() == 1) {
147             offset = validOffsets.get(0);
148         } else if (validOffsets.size() == 0) {
149             ZoneOffsetTransition trans = rules.getTransition(isoLDT);
150             localDateTime = localDateTime.plusSeconds(trans.getDuration().getSeconds());
151             offset = trans.getOffsetAfter();
152         } else {
153             if (preferredOffset != null &amp;&amp; validOffsets.contains(preferredOffset)) {
154                 offset = preferredOffset;
155             } else {
156                 offset = validOffsets.get(0);
157             }
158         }
159         Objects.requireNonNull(offset, &quot;offset&quot;);  // protect against bad ZoneRules
160         return new ChronoZonedDateTimeImpl&lt;&gt;(localDateTime, offset, zone);
161     }
162 
163     /**
164      * Obtains an instance from an instant using the specified time-zone.
165      *
166      * @param chrono  the chronology, not null
167      * @param instant  the instant, not null
168      * @param zone  the zone identifier, not null
169      * @return the zoned date-time, not null
170      */
171     static ChronoZonedDateTimeImpl&lt;?&gt; ofInstant(Chronology chrono, Instant instant, ZoneId zone) {
172         ZoneRules rules = zone.getRules();
173         ZoneOffset offset = rules.getOffset(instant);
174         Objects.requireNonNull(offset, &quot;offset&quot;);  // protect against bad ZoneRules
175         LocalDateTime ldt = LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);
176         ChronoLocalDateTimeImpl&lt;?&gt; cldt = (ChronoLocalDateTimeImpl&lt;?&gt;)chrono.localDateTime(ldt);
177         return new ChronoZonedDateTimeImpl&lt;&gt;(cldt, offset, zone);
178     }
179 
180     /**
181      * Obtains an instance from an {@code Instant}.
182      *
183      * @param instant  the instant to create the date-time from, not null
184      * @param zone  the time-zone to use, validated not null
185      * @return the zoned date-time, validated not null
186      */
187     @SuppressWarnings(&quot;unchecked&quot;)
188     private ChronoZonedDateTimeImpl&lt;D&gt; create(Instant instant, ZoneId zone) {
189         return (ChronoZonedDateTimeImpl&lt;D&gt;)ofInstant(getChronology(), instant, zone);
190     }
191 
192     /**
193      * Casts the {@code Temporal} to {@code ChronoZonedDateTimeImpl} ensuring it bas the specified chronology.
194      *
195      * @param chrono  the chronology to check for, not null
196      * @param temporal  a date-time to cast, not null
197      * @return the date-time checked and cast to {@code ChronoZonedDateTimeImpl}, not null
198      * @throws ClassCastException if the date-time cannot be cast to ChronoZonedDateTimeImpl
199      *  or the chronology is not equal this Chronology
200      */
201     static &lt;R extends ChronoLocalDate&gt; ChronoZonedDateTimeImpl&lt;R&gt; ensureValid(Chronology chrono, Temporal temporal) {
202         @SuppressWarnings(&quot;unchecked&quot;)
203         ChronoZonedDateTimeImpl&lt;R&gt; other = (ChronoZonedDateTimeImpl&lt;R&gt;) temporal;
204         if (chrono.equals(other.getChronology()) == false) {
205             throw new ClassCastException(&quot;Chronology mismatch, required: &quot; + chrono.getId()
206                     + &quot;, actual: &quot; + other.getChronology().getId());
207         }
208         return other;
209     }
210 
211     //-----------------------------------------------------------------------
212     /**
213      * Constructor.
214      *
215      * @param dateTime  the date-time, not null
216      * @param offset  the zone offset, not null
217      * @param zone  the zone ID, not null
218      */
219     private ChronoZonedDateTimeImpl(ChronoLocalDateTimeImpl&lt;D&gt; dateTime, ZoneOffset offset, ZoneId zone) {
220         this.dateTime = Objects.requireNonNull(dateTime, &quot;dateTime&quot;);
221         this.offset = Objects.requireNonNull(offset, &quot;offset&quot;);
222         this.zone = Objects.requireNonNull(zone, &quot;zone&quot;);
223     }
224 
225     //-----------------------------------------------------------------------
226     @Override
227     public ZoneOffset getOffset() {
228         return offset;
229     }
230 
231     @Override
232     public ChronoZonedDateTime&lt;D&gt; withEarlierOffsetAtOverlap() {
233         ZoneOffsetTransition trans = getZone().getRules().getTransition(LocalDateTime.from(this));
234         if (trans != null &amp;&amp; trans.isOverlap()) {
235             ZoneOffset earlierOffset = trans.getOffsetBefore();
236             if (earlierOffset.equals(offset) == false) {
237                 return new ChronoZonedDateTimeImpl&lt;&gt;(dateTime, earlierOffset, zone);
238             }
239         }
240         return this;
241     }
242 
243     @Override
244     public ChronoZonedDateTime&lt;D&gt; withLaterOffsetAtOverlap() {
245         ZoneOffsetTransition trans = getZone().getRules().getTransition(LocalDateTime.from(this));
246         if (trans != null) {
247             ZoneOffset offset = trans.getOffsetAfter();
248             if (offset.equals(getOffset()) == false) {
249                 return new ChronoZonedDateTimeImpl&lt;&gt;(dateTime, offset, zone);
250             }
251         }
252         return this;
253     }
254 
255     //-----------------------------------------------------------------------
256     @Override
257     public ChronoLocalDateTime&lt;D&gt; toLocalDateTime() {
258         return dateTime;
259     }
260 
261     @Override
262     public ZoneId getZone() {
263         return zone;
264     }
265 
266     @Override
267     public ChronoZonedDateTime&lt;D&gt; withZoneSameLocal(ZoneId zone) {
268         return ofBest(dateTime, zone, offset);
269     }
270 
271     @Override
272     public ChronoZonedDateTime&lt;D&gt; withZoneSameInstant(ZoneId zone) {
273         Objects.requireNonNull(zone, &quot;zone&quot;);
274         return this.zone.equals(zone) ? this : create(dateTime.toInstant(offset), zone);
275     }
276 
277     //-----------------------------------------------------------------------
278     @Override
279     public boolean isSupported(TemporalField field) {
280         return field instanceof ChronoField || (field != null &amp;&amp; field.isSupportedBy(this));
281     }
282 
283     //-----------------------------------------------------------------------
284     @Override
285     public ChronoZonedDateTime&lt;D&gt; with(TemporalField field, long newValue) {
286         if (field instanceof ChronoField) {
287             ChronoField f = (ChronoField) field;
288             switch (f) {
289                 case INSTANT_SECONDS: return plus(newValue - toEpochSecond(), SECONDS);
290                 case OFFSET_SECONDS: {
291                     ZoneOffset offset = ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue));
292                     return create(dateTime.toInstant(offset), zone);
293                 }
294             }
295             return ofBest(dateTime.with(field, newValue), zone, offset);
296         }
297         return ChronoZonedDateTimeImpl.ensureValid(getChronology(), field.adjustInto(this, newValue));
298     }
299 
300     //-----------------------------------------------------------------------
301     @Override
302     public ChronoZonedDateTime&lt;D&gt; plus(long amountToAdd, TemporalUnit unit) {
303         if (unit instanceof ChronoUnit) {
304             return with(dateTime.plus(amountToAdd, unit));
305         }
306         return ChronoZonedDateTimeImpl.ensureValid(getChronology(), unit.addTo(this, amountToAdd));   /// TODO: Generics replacement Risk!
307     }
308 
309     //-----------------------------------------------------------------------
310     @Override
311     public long until(Temporal endExclusive, TemporalUnit unit) {
312         Objects.requireNonNull(endExclusive, &quot;endExclusive&quot;);
313         @SuppressWarnings(&quot;unchecked&quot;)
314         ChronoZonedDateTime&lt;D&gt; end = (ChronoZonedDateTime&lt;D&gt;) getChronology().zonedDateTime(endExclusive);
315         if (unit instanceof ChronoUnit) {
316             end = end.withZoneSameInstant(offset);
317             return dateTime.until(end.toLocalDateTime(), unit);
318         }
319         Objects.requireNonNull(unit, &quot;unit&quot;);
320         return unit.between(this, end);
321     }
322 
323     //-----------------------------------------------------------------------
324     /**
325      * Writes the ChronoZonedDateTime using a
326      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
327      * @serialData
328      * &lt;pre&gt;
329      *  out.writeByte(3);                  // identifies a ChronoZonedDateTime
330      *  out.writeObject(toLocalDateTime());
331      *  out.writeObject(getOffset());
332      *  out.writeObject(getZone());
333      * &lt;/pre&gt;
334      *
335      * @return the instance of {@code Ser}, not null
336      */
337     @java.io.Serial
338     private Object writeReplace() {
339         return new Ser(Ser.CHRONO_ZONE_DATE_TIME_TYPE, this);
340     }
341 
342     /**
343      * Defend against malicious streams.
344      *
345      * @param s the stream to read
346      * @throws InvalidObjectException always
347      */
348     @java.io.Serial
349     private void readObject(ObjectInputStream s) throws InvalidObjectException {
350         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
351     }
352 
353     void writeExternal(ObjectOutput out) throws IOException {
354         out.writeObject(dateTime);
355         out.writeObject(offset);
356         out.writeObject(zone);
357     }
358 
359     static ChronoZonedDateTime&lt;?&gt; readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
360         ChronoLocalDateTime&lt;?&gt; dateTime = (ChronoLocalDateTime&lt;?&gt;) in.readObject();
361         ZoneOffset offset = (ZoneOffset) in.readObject();
362         ZoneId zone = (ZoneId) in.readObject();
363         return dateTime.atZone(offset).withZoneSameLocal(zone);
364         // TODO: ZDT uses ofLenient()
365     }
366 
367     //-------------------------------------------------------------------------
368     @Override
369     public boolean equals(Object obj) {
370         if (this == obj) {
371             return true;
372         }
373         if (obj instanceof ChronoZonedDateTime) {
374             return compareTo((ChronoZonedDateTime&lt;?&gt;) obj) == 0;
375         }
376         return false;
377     }
378 
379     @Override
380     public int hashCode() {
381         return toLocalDateTime().hashCode() ^ getOffset().hashCode() ^ Integer.rotateLeft(getZone().hashCode(), 3);
382     }
383 
384     @Override
385     public String toString() {
386         String str = toLocalDateTime().toString() + getOffset().toString();
387         if (getOffset() != getZone()) {
388             str += &#39;[&#39; + getZone().toString() + &#39;]&#39;;
389         }
390         return str;
391     }
392 
393 
394 }
    </pre>
  </body>
</html>
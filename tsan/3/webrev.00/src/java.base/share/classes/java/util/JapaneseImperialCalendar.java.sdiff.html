<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/JapaneseImperialCalendar.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="InvalidPropertiesFormatException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="JumboEnumSet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/JapaneseImperialCalendar.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  33 import sun.util.calendar.CalendarSystem;
  34 import sun.util.calendar.CalendarUtils;
  35 import sun.util.calendar.Era;
  36 import sun.util.calendar.Gregorian;
  37 import sun.util.calendar.LocalGregorianCalendar;
  38 import sun.util.calendar.ZoneInfo;
  39 
  40 /**
  41  * {@code JapaneseImperialCalendar} implements a Japanese
  42  * calendar system in which the imperial era-based year numbering is
  43  * supported from the Meiji era. The following are the eras supported
  44  * by this calendar system.
  45  * &lt;pre&gt;{@code
  46  * ERA value   Era name    Since (in Gregorian)
  47  * ------------------------------------------------------
  48  *     0       N/A         N/A
  49  *     1       Meiji       1868-01-01T00:00:00 local time
  50  *     2       Taisho      1912-07-30T00:00:00 local time
  51  *     3       Showa       1926-12-25T00:00:00 local time
  52  *     4       Heisei      1989-01-08T00:00:00 local time
<span class="line-modified">  53  *     5       NewEra      2019-05-01T00:00:00 local time</span>
  54  * ------------------------------------------------------
  55  * }&lt;/pre&gt;
  56  *
  57  * &lt;p&gt;{@code ERA} value 0 specifies the years before Meiji and
  58  * the Gregorian year values are used. Unlike
  59  * {@link GregorianCalendar}, the Julian to Gregorian transition is not
  60  * supported because it doesn&#39;t make any sense to the Japanese
  61  * calendar systems used before Meiji. To represent the years before
  62  * Gregorian year 1, 0 and negative values are used. The Japanese
  63  * Imperial rescripts and government decrees don&#39;t specify how to deal
  64  * with time differences for applying the era transitions. This
  65  * calendar implementation assumes local time for all transitions.
  66  *
  67  * &lt;p&gt;A new era can be specified using property
  68  * jdk.calendar.japanese.supplemental.era. The new era is added to the
  69  * predefined eras. The syntax of the property is as follows.
  70  * &lt;pre&gt;
  71  *   {@code name=&lt;name&gt;,abbr=&lt;abbr&gt;,since=&lt;time[&#39;u&#39;]&gt;}
  72  * &lt;/pre&gt;
  73  * where
</pre>
<hr />
<pre>
 112      * The ERA constant designating the Meiji era.
 113      */
 114     public static final int MEIJI = 1;
 115 
 116     /**
 117      * The ERA constant designating the Taisho era.
 118      */
 119     public static final int TAISHO = 2;
 120 
 121     /**
 122      * The ERA constant designating the Showa era.
 123      */
 124     public static final int SHOWA = 3;
 125 
 126     /**
 127      * The ERA constant designating the Heisei era.
 128      */
 129     public static final int HEISEI = 4;
 130 
 131     /**
<span class="line-modified"> 132      * The ERA constant designating the NewEra era.</span>
 133      */
<span class="line-modified"> 134     private static final int NEWERA = 5;</span>
 135 
 136     private static final int EPOCH_OFFSET   = 719163; // Fixed date of January 1, 1970 (Gregorian)
 137 
 138     // Useful millisecond constants.  Although ONE_DAY and ONE_WEEK can fit
 139     // into ints, they must be longs in order to prevent arithmetic overflow
 140     // when performing (bug 4173516).
 141     private static final int  ONE_SECOND = 1000;
 142     private static final int  ONE_MINUTE = 60*ONE_SECOND;
 143     private static final int  ONE_HOUR   = 60*ONE_MINUTE;
 144     private static final long ONE_DAY    = 24*ONE_HOUR;
 145 
 146     // Reference to the sun.util.calendar.LocalGregorianCalendar instance (singleton).
 147     private static final LocalGregorianCalendar jcal
 148         = (LocalGregorianCalendar) CalendarSystem.forName(&quot;japanese&quot;);
 149 
 150     // Gregorian calendar instance. This is required because era
 151     // transition dates are given in Gregorian dates.
 152     private static final Gregorian gcal = CalendarSystem.getGregorianCalendar();
 153 
 154     // The Era instance representing &quot;before Meiji&quot;.
</pre>
<hr />
<pre>
 234         292278994,      // YEAR
 235         DECEMBER,       // MONTH
 236         53,             // WEEK_OF_YEAR
 237         6,              // WEEK_OF_MONTH
 238         31,             // DAY_OF_MONTH
 239         366,            // DAY_OF_YEAR
 240         SATURDAY,       // DAY_OF_WEEK
 241         6,              // DAY_OF_WEEK_IN
 242         PM,             // AM_PM
 243         11,             // HOUR
 244         23,             // HOUR_OF_DAY
 245         59,             // MINUTE
 246         59,             // SECOND
 247         999,            // MILLISECOND
 248         14*ONE_HOUR,    // ZONE_OFFSET
 249         2*ONE_HOUR      // DST_OFFSET (double summer time)
 250     };
 251 
 252     // Proclaim serialization compatibility with JDK 1.6
 253     @SuppressWarnings(&quot;FieldNameHidesFieldInSuperclass&quot;)

 254     private static final long serialVersionUID = -3364572813905467929L;
 255 
 256     static {
 257         Era[] es = jcal.getEras();
 258         int length = es.length + 1;
 259         eras = new Era[length];
 260         sinceFixedDates = new long[length];
 261 
 262         // eras[BEFORE_MEIJI] and sinceFixedDate[BEFORE_MEIJI] are the
 263         // same as Gregorian.
 264         int index = BEFORE_MEIJI;
 265         int current = index;
 266         sinceFixedDates[index] = gcal.getFixedDate(BEFORE_MEIJI_ERA.getSinceDate());
 267         eras[index++] = BEFORE_MEIJI_ERA;
 268         for (Era e : es) {
 269             if(e.getSince(TimeZone.NO_TIMEZONE) &lt; System.currentTimeMillis()) {
 270                 current = index;
 271             }
 272             CalendarDate d = e.getSinceDate();
 273             sinceFixedDates[index] = gcal.getFixedDate(d);
</pre>
<hr />
<pre>
 400      *
 401      * &lt;p&gt;&lt;em&gt;Add rule 1&lt;/em&gt;. The value of {@code field}
 402      * after the call minus the value of {@code field} before the
 403      * call is {@code amount}, modulo any overflow that has occurred in
 404      * {@code field}. Overflow occurs when a field value exceeds its
 405      * range and, as a result, the next larger field is incremented or
 406      * decremented and the field value is adjusted back into its range.&lt;/p&gt;
 407      *
 408      * &lt;p&gt;&lt;em&gt;Add rule 2&lt;/em&gt;. If a smaller field is expected to be
 409      * invariant, but it is impossible for it to be equal to its
 410      * prior value because of changes in its minimum or maximum after
 411      * {@code field} is changed, then its value is adjusted to be as close
 412      * as possible to its expected value. A smaller field represents a
 413      * smaller unit of time. {@code HOUR} is a smaller field than
 414      * {@code DAY_OF_MONTH}. No adjustment is made to smaller fields
 415      * that are not expected to be invariant. The calendar system
 416      * determines what fields are expected to be invariant.&lt;/p&gt;
 417      *
 418      * @param field the calendar field.
 419      * @param amount the amount of date or time to be added to the field.
<span class="line-modified"> 420      * @exception IllegalArgumentException if {@code field} is</span>
 421      * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown,
 422      * or if any calendar fields have out-of-range values in
 423      * non-lenient mode.
 424      */
 425     @Override
 426     public void add(int field, int amount) {
 427         // If amount == 0, do nothing even the given field is out of
 428         // range. This is tested by JCK.
 429         if (amount == 0) {
 430             return;   // Do nothing!
 431         }
 432 
 433         if (field &lt; 0 || field &gt;= ZONE_OFFSET) {
 434             throw new IllegalArgumentException();
 435         }
 436 
 437         // Sync the time and calendar fields.
 438         complete();
 439 
 440         if (field == YEAR) {
</pre>
<hr />
<pre>
 551         }
 552     }
 553 
 554     @Override
 555     public void roll(int field, boolean up) {
 556         roll(field, up ? +1 : -1);
 557     }
 558 
 559     /**
 560      * Adds a signed amount to the specified calendar field without changing larger fields.
 561      * A negative roll amount means to subtract from field without changing
 562      * larger fields. If the specified amount is 0, this method performs nothing.
 563      *
 564      * &lt;p&gt;This method calls {@link #complete()} before adding the
 565      * amount so that all the calendar fields are normalized. If there
 566      * is any calendar field having an out-of-range value in non-lenient mode, then an
 567      * {@code IllegalArgumentException} is thrown.
 568      *
 569      * @param field the calendar field.
 570      * @param amount the signed amount to add to {@code field}.
<span class="line-modified"> 571      * @exception IllegalArgumentException if {@code field} is</span>
 572      * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown,
 573      * or if any calendar fields have out-of-range values in
 574      * non-lenient mode.
 575      * @see #roll(int,boolean)
 576      * @see #add(int,int)
 577      * @see #set(int,int)
 578      */
 579     @Override
 580     public void roll(int field, int amount) {
 581         // If amount == 0, do nothing even the given field is out of
 582         // range. This is tested by JCK.
 583         if (amount == 0) {
 584             return;
 585         }
 586 
 587         if (field &lt; 0 || field &gt;= ZONE_OFFSET) {
 588             throw new IllegalArgumentException();
 589         }
 590 
 591         // Sync the time and calendar fields.
</pre>
<hr />
<pre>
1744             // The spec is to calculate WEEK_OF_YEAR in the
1745             // ISO8601-style. This creates problems, though.
1746             if (weekOfYear == 0) {
1747                 // If the date belongs to the last week of the
1748                 // previous year, use the week number of &quot;12/31&quot; of
1749                 // the &quot;previous&quot; year. Again, if the previous year is
1750                 // a transition year, we need to take care of it.
1751                 // Usually the previous day of the first day of a year
1752                 // is December 31, which is not always true in the
1753                 // Japanese imperial calendar system.
1754                 long fixedDec31 = fixedDateJan1 - 1;
1755                 long prevJan1;
1756                 LocalGregorianCalendar.Date d = getCalendarDate(fixedDec31);
1757                 if (!(transitionYear || isTransitionYear(d.getNormalizedYear()))) {
1758                     prevJan1 = fixedDateJan1 - 365;
1759                     if (d.isLeapYear()) {
1760                         --prevJan1;
1761                     }
1762                 } else if (transitionYear) {
1763                     if (jdate.getYear() == 1) {
<span class="line-modified">1764                         // As of NewEra (since Meiji) there&#39;s no case</span>
1765                         // that there are multiple transitions in a
1766                         // year.  Historically there was such
1767                         // case. There might be such case again in the
1768                         // future.
<span class="line-modified">1769                         if (era &gt; NEWERA) {</span>
1770                             CalendarDate pd = eras[era - 1].getSinceDate();
1771                             if (normalizedYear == pd.getYear()) {
1772                                 d.setMonth(pd.getMonth()).setDayOfMonth(pd.getDayOfMonth());
1773                             }
1774                         } else {
1775                             d.setMonth(LocalGregorianCalendar.JANUARY).setDayOfMonth(1);
1776                         }
1777                         jcal.normalize(d);
1778                         prevJan1 = jcal.getFixedDate(d);
1779                     } else {
1780                         prevJan1 = fixedDateJan1 - 365;
1781                         if (d.isLeapYear()) {
1782                             --prevJan1;
1783                         }
1784                     }
1785                 } else {
1786                     CalendarDate cd = eras[getEraIndex(jdate)].getSinceDate();
1787                     d.setMonth(cd.getMonth()).setDayOfMonth(cd.getDayOfMonth());
1788                     jcal.normalize(d);
1789                     prevJan1 = jcal.getFixedDate(d);
</pre>
<hr />
<pre>
1849         // We can always use `jcal&#39; since Julian and Gregorian are the
1850         // same thing for this calculation.
1851         long fixedDay1st = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(fixedDay1 + 6,
1852                                                                              getFirstDayOfWeek());
1853         int ndays = (int)(fixedDay1st - fixedDay1);
1854         assert ndays &lt;= 7;
1855         if (ndays &gt;= getMinimalDaysInFirstWeek()) {
1856             fixedDay1st -= 7;
1857         }
1858         int normalizedDayOfPeriod = (int)(fixedDate - fixedDay1st);
1859         if (normalizedDayOfPeriod &gt;= 0) {
1860             return normalizedDayOfPeriod / 7 + 1;
1861         }
1862         return CalendarUtils.floorDivide(normalizedDayOfPeriod, 7) + 1;
1863     }
1864 
1865     /**
1866      * Converts calendar field values to the time value (millisecond
1867      * offset from the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;).
1868      *
<span class="line-modified">1869      * @exception IllegalArgumentException if any calendar fields are invalid.</span>
1870      */
1871     protected void computeTime() {
1872         // In non-lenient mode, perform brief checking of calendar
1873         // fields which have been set externally. Through this
1874         // checking, the field values are stored in originalFields[]
1875         // to see if any of them are normalized later.
1876         if (!isLenient()) {
1877             if (originalFields == null) {
1878                 originalFields = new int[FIELD_COUNT];
1879             }
1880             for (int field = 0; field &lt; FIELD_COUNT; field++) {
1881                 int value = internalGet(field);
1882                 if (isExternallySet(field)) {
1883                     // Quick validation for any out of range values
1884                     if (value &lt; getMinimum(field) || value &gt; getMaximum(field)) {
1885                         throw new IllegalArgumentException(getFieldName(field));
1886                     }
1887                 }
1888                 originalFields[field] = value;
1889             }
</pre>
<hr />
<pre>
2374         if (n &gt; max) {
2375             n -= range;
2376         } else if (n &lt; min) {
2377             n += range;
2378         }
2379         assert n &gt;= min &amp;&amp; n &lt;= max;
2380         return n;
2381     }
2382 
2383     /**
2384      * Returns the ERA.  We need a special method for this because the
2385      * default ERA is the current era, but a zero (unset) ERA means before Meiji.
2386      */
2387     private int internalGetEra() {
2388         return isSet(ERA) ? internalGet(ERA) : currentEra;
2389     }
2390 
2391     /**
2392      * Updates internal state.
2393      */

2394     private void readObject(ObjectInputStream stream)
2395             throws IOException, ClassNotFoundException {
2396         stream.defaultReadObject();
2397         if (jdate == null) {
2398             jdate = jcal.newCalendarDate(getZone());
2399             cachedFixedDate = Long.MIN_VALUE;
2400         }
2401     }
2402 }
</pre>
</td>
<td>
<hr />
<pre>
  33 import sun.util.calendar.CalendarSystem;
  34 import sun.util.calendar.CalendarUtils;
  35 import sun.util.calendar.Era;
  36 import sun.util.calendar.Gregorian;
  37 import sun.util.calendar.LocalGregorianCalendar;
  38 import sun.util.calendar.ZoneInfo;
  39 
  40 /**
  41  * {@code JapaneseImperialCalendar} implements a Japanese
  42  * calendar system in which the imperial era-based year numbering is
  43  * supported from the Meiji era. The following are the eras supported
  44  * by this calendar system.
  45  * &lt;pre&gt;{@code
  46  * ERA value   Era name    Since (in Gregorian)
  47  * ------------------------------------------------------
  48  *     0       N/A         N/A
  49  *     1       Meiji       1868-01-01T00:00:00 local time
  50  *     2       Taisho      1912-07-30T00:00:00 local time
  51  *     3       Showa       1926-12-25T00:00:00 local time
  52  *     4       Heisei      1989-01-08T00:00:00 local time
<span class="line-modified">  53  *     5       Reiwa       2019-05-01T00:00:00 local time</span>
  54  * ------------------------------------------------------
  55  * }&lt;/pre&gt;
  56  *
  57  * &lt;p&gt;{@code ERA} value 0 specifies the years before Meiji and
  58  * the Gregorian year values are used. Unlike
  59  * {@link GregorianCalendar}, the Julian to Gregorian transition is not
  60  * supported because it doesn&#39;t make any sense to the Japanese
  61  * calendar systems used before Meiji. To represent the years before
  62  * Gregorian year 1, 0 and negative values are used. The Japanese
  63  * Imperial rescripts and government decrees don&#39;t specify how to deal
  64  * with time differences for applying the era transitions. This
  65  * calendar implementation assumes local time for all transitions.
  66  *
  67  * &lt;p&gt;A new era can be specified using property
  68  * jdk.calendar.japanese.supplemental.era. The new era is added to the
  69  * predefined eras. The syntax of the property is as follows.
  70  * &lt;pre&gt;
  71  *   {@code name=&lt;name&gt;,abbr=&lt;abbr&gt;,since=&lt;time[&#39;u&#39;]&gt;}
  72  * &lt;/pre&gt;
  73  * where
</pre>
<hr />
<pre>
 112      * The ERA constant designating the Meiji era.
 113      */
 114     public static final int MEIJI = 1;
 115 
 116     /**
 117      * The ERA constant designating the Taisho era.
 118      */
 119     public static final int TAISHO = 2;
 120 
 121     /**
 122      * The ERA constant designating the Showa era.
 123      */
 124     public static final int SHOWA = 3;
 125 
 126     /**
 127      * The ERA constant designating the Heisei era.
 128      */
 129     public static final int HEISEI = 4;
 130 
 131     /**
<span class="line-modified"> 132      * The ERA constant designating the Reiwa era.</span>
 133      */
<span class="line-modified"> 134     private static final int REIWA = 5;</span>
 135 
 136     private static final int EPOCH_OFFSET   = 719163; // Fixed date of January 1, 1970 (Gregorian)
 137 
 138     // Useful millisecond constants.  Although ONE_DAY and ONE_WEEK can fit
 139     // into ints, they must be longs in order to prevent arithmetic overflow
 140     // when performing (bug 4173516).
 141     private static final int  ONE_SECOND = 1000;
 142     private static final int  ONE_MINUTE = 60*ONE_SECOND;
 143     private static final int  ONE_HOUR   = 60*ONE_MINUTE;
 144     private static final long ONE_DAY    = 24*ONE_HOUR;
 145 
 146     // Reference to the sun.util.calendar.LocalGregorianCalendar instance (singleton).
 147     private static final LocalGregorianCalendar jcal
 148         = (LocalGregorianCalendar) CalendarSystem.forName(&quot;japanese&quot;);
 149 
 150     // Gregorian calendar instance. This is required because era
 151     // transition dates are given in Gregorian dates.
 152     private static final Gregorian gcal = CalendarSystem.getGregorianCalendar();
 153 
 154     // The Era instance representing &quot;before Meiji&quot;.
</pre>
<hr />
<pre>
 234         292278994,      // YEAR
 235         DECEMBER,       // MONTH
 236         53,             // WEEK_OF_YEAR
 237         6,              // WEEK_OF_MONTH
 238         31,             // DAY_OF_MONTH
 239         366,            // DAY_OF_YEAR
 240         SATURDAY,       // DAY_OF_WEEK
 241         6,              // DAY_OF_WEEK_IN
 242         PM,             // AM_PM
 243         11,             // HOUR
 244         23,             // HOUR_OF_DAY
 245         59,             // MINUTE
 246         59,             // SECOND
 247         999,            // MILLISECOND
 248         14*ONE_HOUR,    // ZONE_OFFSET
 249         2*ONE_HOUR      // DST_OFFSET (double summer time)
 250     };
 251 
 252     // Proclaim serialization compatibility with JDK 1.6
 253     @SuppressWarnings(&quot;FieldNameHidesFieldInSuperclass&quot;)
<span class="line-added"> 254     @java.io.Serial</span>
 255     private static final long serialVersionUID = -3364572813905467929L;
 256 
 257     static {
 258         Era[] es = jcal.getEras();
 259         int length = es.length + 1;
 260         eras = new Era[length];
 261         sinceFixedDates = new long[length];
 262 
 263         // eras[BEFORE_MEIJI] and sinceFixedDate[BEFORE_MEIJI] are the
 264         // same as Gregorian.
 265         int index = BEFORE_MEIJI;
 266         int current = index;
 267         sinceFixedDates[index] = gcal.getFixedDate(BEFORE_MEIJI_ERA.getSinceDate());
 268         eras[index++] = BEFORE_MEIJI_ERA;
 269         for (Era e : es) {
 270             if(e.getSince(TimeZone.NO_TIMEZONE) &lt; System.currentTimeMillis()) {
 271                 current = index;
 272             }
 273             CalendarDate d = e.getSinceDate();
 274             sinceFixedDates[index] = gcal.getFixedDate(d);
</pre>
<hr />
<pre>
 401      *
 402      * &lt;p&gt;&lt;em&gt;Add rule 1&lt;/em&gt;. The value of {@code field}
 403      * after the call minus the value of {@code field} before the
 404      * call is {@code amount}, modulo any overflow that has occurred in
 405      * {@code field}. Overflow occurs when a field value exceeds its
 406      * range and, as a result, the next larger field is incremented or
 407      * decremented and the field value is adjusted back into its range.&lt;/p&gt;
 408      *
 409      * &lt;p&gt;&lt;em&gt;Add rule 2&lt;/em&gt;. If a smaller field is expected to be
 410      * invariant, but it is impossible for it to be equal to its
 411      * prior value because of changes in its minimum or maximum after
 412      * {@code field} is changed, then its value is adjusted to be as close
 413      * as possible to its expected value. A smaller field represents a
 414      * smaller unit of time. {@code HOUR} is a smaller field than
 415      * {@code DAY_OF_MONTH}. No adjustment is made to smaller fields
 416      * that are not expected to be invariant. The calendar system
 417      * determines what fields are expected to be invariant.&lt;/p&gt;
 418      *
 419      * @param field the calendar field.
 420      * @param amount the amount of date or time to be added to the field.
<span class="line-modified"> 421      * @throws    IllegalArgumentException if {@code field} is</span>
 422      * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown,
 423      * or if any calendar fields have out-of-range values in
 424      * non-lenient mode.
 425      */
 426     @Override
 427     public void add(int field, int amount) {
 428         // If amount == 0, do nothing even the given field is out of
 429         // range. This is tested by JCK.
 430         if (amount == 0) {
 431             return;   // Do nothing!
 432         }
 433 
 434         if (field &lt; 0 || field &gt;= ZONE_OFFSET) {
 435             throw new IllegalArgumentException();
 436         }
 437 
 438         // Sync the time and calendar fields.
 439         complete();
 440 
 441         if (field == YEAR) {
</pre>
<hr />
<pre>
 552         }
 553     }
 554 
 555     @Override
 556     public void roll(int field, boolean up) {
 557         roll(field, up ? +1 : -1);
 558     }
 559 
 560     /**
 561      * Adds a signed amount to the specified calendar field without changing larger fields.
 562      * A negative roll amount means to subtract from field without changing
 563      * larger fields. If the specified amount is 0, this method performs nothing.
 564      *
 565      * &lt;p&gt;This method calls {@link #complete()} before adding the
 566      * amount so that all the calendar fields are normalized. If there
 567      * is any calendar field having an out-of-range value in non-lenient mode, then an
 568      * {@code IllegalArgumentException} is thrown.
 569      *
 570      * @param field the calendar field.
 571      * @param amount the signed amount to add to {@code field}.
<span class="line-modified"> 572      * @throws    IllegalArgumentException if {@code field} is</span>
 573      * {@code ZONE_OFFSET}, {@code DST_OFFSET}, or unknown,
 574      * or if any calendar fields have out-of-range values in
 575      * non-lenient mode.
 576      * @see #roll(int,boolean)
 577      * @see #add(int,int)
 578      * @see #set(int,int)
 579      */
 580     @Override
 581     public void roll(int field, int amount) {
 582         // If amount == 0, do nothing even the given field is out of
 583         // range. This is tested by JCK.
 584         if (amount == 0) {
 585             return;
 586         }
 587 
 588         if (field &lt; 0 || field &gt;= ZONE_OFFSET) {
 589             throw new IllegalArgumentException();
 590         }
 591 
 592         // Sync the time and calendar fields.
</pre>
<hr />
<pre>
1745             // The spec is to calculate WEEK_OF_YEAR in the
1746             // ISO8601-style. This creates problems, though.
1747             if (weekOfYear == 0) {
1748                 // If the date belongs to the last week of the
1749                 // previous year, use the week number of &quot;12/31&quot; of
1750                 // the &quot;previous&quot; year. Again, if the previous year is
1751                 // a transition year, we need to take care of it.
1752                 // Usually the previous day of the first day of a year
1753                 // is December 31, which is not always true in the
1754                 // Japanese imperial calendar system.
1755                 long fixedDec31 = fixedDateJan1 - 1;
1756                 long prevJan1;
1757                 LocalGregorianCalendar.Date d = getCalendarDate(fixedDec31);
1758                 if (!(transitionYear || isTransitionYear(d.getNormalizedYear()))) {
1759                     prevJan1 = fixedDateJan1 - 365;
1760                     if (d.isLeapYear()) {
1761                         --prevJan1;
1762                     }
1763                 } else if (transitionYear) {
1764                     if (jdate.getYear() == 1) {
<span class="line-modified">1765                         // As of Reiwa (since Meiji) there&#39;s no case</span>
1766                         // that there are multiple transitions in a
1767                         // year.  Historically there was such
1768                         // case. There might be such case again in the
1769                         // future.
<span class="line-modified">1770                         if (era &gt; REIWA) {</span>
1771                             CalendarDate pd = eras[era - 1].getSinceDate();
1772                             if (normalizedYear == pd.getYear()) {
1773                                 d.setMonth(pd.getMonth()).setDayOfMonth(pd.getDayOfMonth());
1774                             }
1775                         } else {
1776                             d.setMonth(LocalGregorianCalendar.JANUARY).setDayOfMonth(1);
1777                         }
1778                         jcal.normalize(d);
1779                         prevJan1 = jcal.getFixedDate(d);
1780                     } else {
1781                         prevJan1 = fixedDateJan1 - 365;
1782                         if (d.isLeapYear()) {
1783                             --prevJan1;
1784                         }
1785                     }
1786                 } else {
1787                     CalendarDate cd = eras[getEraIndex(jdate)].getSinceDate();
1788                     d.setMonth(cd.getMonth()).setDayOfMonth(cd.getDayOfMonth());
1789                     jcal.normalize(d);
1790                     prevJan1 = jcal.getFixedDate(d);
</pre>
<hr />
<pre>
1850         // We can always use `jcal&#39; since Julian and Gregorian are the
1851         // same thing for this calculation.
1852         long fixedDay1st = LocalGregorianCalendar.getDayOfWeekDateOnOrBefore(fixedDay1 + 6,
1853                                                                              getFirstDayOfWeek());
1854         int ndays = (int)(fixedDay1st - fixedDay1);
1855         assert ndays &lt;= 7;
1856         if (ndays &gt;= getMinimalDaysInFirstWeek()) {
1857             fixedDay1st -= 7;
1858         }
1859         int normalizedDayOfPeriod = (int)(fixedDate - fixedDay1st);
1860         if (normalizedDayOfPeriod &gt;= 0) {
1861             return normalizedDayOfPeriod / 7 + 1;
1862         }
1863         return CalendarUtils.floorDivide(normalizedDayOfPeriod, 7) + 1;
1864     }
1865 
1866     /**
1867      * Converts calendar field values to the time value (millisecond
1868      * offset from the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;).
1869      *
<span class="line-modified">1870      * @throws    IllegalArgumentException if any calendar fields are invalid.</span>
1871      */
1872     protected void computeTime() {
1873         // In non-lenient mode, perform brief checking of calendar
1874         // fields which have been set externally. Through this
1875         // checking, the field values are stored in originalFields[]
1876         // to see if any of them are normalized later.
1877         if (!isLenient()) {
1878             if (originalFields == null) {
1879                 originalFields = new int[FIELD_COUNT];
1880             }
1881             for (int field = 0; field &lt; FIELD_COUNT; field++) {
1882                 int value = internalGet(field);
1883                 if (isExternallySet(field)) {
1884                     // Quick validation for any out of range values
1885                     if (value &lt; getMinimum(field) || value &gt; getMaximum(field)) {
1886                         throw new IllegalArgumentException(getFieldName(field));
1887                     }
1888                 }
1889                 originalFields[field] = value;
1890             }
</pre>
<hr />
<pre>
2375         if (n &gt; max) {
2376             n -= range;
2377         } else if (n &lt; min) {
2378             n += range;
2379         }
2380         assert n &gt;= min &amp;&amp; n &lt;= max;
2381         return n;
2382     }
2383 
2384     /**
2385      * Returns the ERA.  We need a special method for this because the
2386      * default ERA is the current era, but a zero (unset) ERA means before Meiji.
2387      */
2388     private int internalGetEra() {
2389         return isSet(ERA) ? internalGet(ERA) : currentEra;
2390     }
2391 
2392     /**
2393      * Updates internal state.
2394      */
<span class="line-added">2395     @java.io.Serial</span>
2396     private void readObject(ObjectInputStream stream)
2397             throws IOException, ClassNotFoundException {
2398         stream.defaultReadObject();
2399         if (jdate == null) {
2400             jdate = jcal.newCalendarDate(getZone());
2401             cachedFixedDate = Long.MIN_VALUE;
2402         }
2403     }
2404 }
</pre>
</td>
</tr>
</table>
<center><a href="InvalidPropertiesFormatException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="JumboEnumSet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/DualPivotQuicksort.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DoubleSummaryStatistics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DuplicateFormatFlagsException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/DualPivotQuicksort.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 



  28 /**
<span class="line-modified">  29  * This class implements the Dual-Pivot Quicksort algorithm by</span>
<span class="line-modified">  30  * Vladimir Yaroslavskiy, Jon Bentley, and Josh Bloch. The algorithm</span>
<span class="line-modified">  31  * offers O(n log(n)) performance on many data sets that cause other</span>
<span class="line-modified">  32  * quicksorts to degrade to quadratic performance, and is typically</span>
  33  * faster than traditional (one-pivot) Quicksort implementations.
  34  *
<span class="line-modified">  35  * All exposed methods are package-private, designed to be invoked</span>
<span class="line-modified">  36  * from public methods (in class Arrays) after performing any</span>
<span class="line-modified">  37  * necessary array bounds checks and expanding parameters into the</span>
<span class="line-removed">  38  * required forms.</span>
  39  *
  40  * @author Vladimir Yaroslavskiy
  41  * @author Jon Bentley
  42  * @author Josh Bloch



  43  *
<span class="line-modified">  44  * @version 2011.02.11 m765.827.12i:5\7pm</span>
<span class="line-removed">  45  * @since 1.7</span>
  46  */
  47 final class DualPivotQuicksort {
  48 
  49     /**
  50      * Prevents instantiation.
  51      */
  52     private DualPivotQuicksort() {}
  53 
<span class="line-modified">  54     /*</span>
<span class="line-modified">  55      * Tuning parameters.</span>
  56      */

  57 
  58     /**
<span class="line-modified">  59      * The maximum number of runs in merge sort.</span>
  60      */
<span class="line-modified">  61     private static final int MAX_RUN_COUNT = 67;</span>
  62 
  63     /**
<span class="line-modified">  64      * If the length of an array to be sorted is less than this</span>
<span class="line-removed">  65      * constant, Quicksort is used in preference to merge sort.</span>
  66      */
<span class="line-modified">  67     private static final int QUICKSORT_THRESHOLD = 286;</span>
  68 
  69     /**
<span class="line-modified">  70      * If the length of an array to be sorted is less than this</span>
<span class="line-removed">  71      * constant, insertion sort is used in preference to Quicksort.</span>
  72      */
<span class="line-modified">  73     private static final int INSERTION_SORT_THRESHOLD = 47;</span>
  74 
  75     /**
<span class="line-modified">  76      * If the length of a byte array to be sorted is greater than this</span>
<span class="line-removed">  77      * constant, counting sort is used in preference to insertion sort.</span>
  78      */
<span class="line-modified">  79     private static final int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;</span>
  80 
  81     /**
<span class="line-modified">  82      * If the length of a short or char array to be sorted is greater</span>
<span class="line-removed">  83      * than this constant, counting sort is used in preference to Quicksort.</span>
  84      */
<span class="line-modified">  85     private static final int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;</span>
  86 
<span class="line-modified">  87     /*</span>
<span class="line-modified">  88      * Sorting methods for seven primitive types.</span>
  89      */

  90 
  91     /**
<span class="line-modified">  92      * Sorts the specified range of the array using the given</span>
<span class="line-modified">  93      * workspace array slice if possible for merging</span>
<span class="line-modified">  94      *</span>
<span class="line-removed">  95      * @param a the array to be sorted</span>
<span class="line-removed">  96      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-removed">  97      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-removed">  98      * @param work a workspace array (slice)</span>
<span class="line-removed">  99      * @param workBase origin of usable space in work array</span>
<span class="line-removed"> 100      * @param workLen usable size of work array</span>
<span class="line-removed"> 101      */</span>
<span class="line-removed"> 102     static void sort(int[] a, int left, int right,</span>
<span class="line-removed"> 103                      int[] work, int workBase, int workLen) {</span>
<span class="line-removed"> 104         // Use Quicksort on small arrays</span>
<span class="line-removed"> 105         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-removed"> 106             sort(a, left, right, true);</span>
<span class="line-removed"> 107             return;</span>
<span class="line-removed"> 108         }</span>
 109 
<span class="line-modified"> 110         /*</span>
<span class="line-modified"> 111          * Index run[i] is the start of i-th run</span>
<span class="line-modified"> 112          * (ascending or descending sequence).</span>
<span class="line-modified"> 113          */</span>
<span class="line-removed"> 114         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-removed"> 115         int count = 0; run[0] = left;</span>
 116 
<span class="line-modified"> 117         // Check if the array is nearly sorted</span>
<span class="line-modified"> 118         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-modified"> 119             // Equal items in the beginning of the sequence</span>
<span class="line-modified"> 120             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed"> 121                 k++;</span>
<span class="line-removed"> 122             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed"> 123             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed"> 124                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed"> 125             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed"> 126                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed"> 127                 // Transform into an ascending sequence</span>
<span class="line-removed"> 128                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed"> 129                     int t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed"> 130                 }</span>
<span class="line-removed"> 131             }</span>
 132 
<span class="line-modified"> 133             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified"> 134             // ascending sequence</span>
<span class="line-modified"> 135             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified"> 136                 count--;</span>
<span class="line-removed"> 137             }</span>
 138 
<span class="line-modified"> 139             /*</span>
<span class="line-modified"> 140              * The array is not highly structured,</span>
<span class="line-modified"> 141              * use Quicksort instead of merge sort.</span>
<span class="line-modified"> 142              */</span>
<span class="line-removed"> 143             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-removed"> 144                 sort(a, left, right, true);</span>
<span class="line-removed"> 145                 return;</span>
<span class="line-removed"> 146             }</span>
<span class="line-removed"> 147         }</span>
 148 
<span class="line-modified"> 149         // These invariants should hold true:</span>
<span class="line-modified"> 150         //    run[0] = 0</span>
<span class="line-modified"> 151         //    run[&lt;last&gt;] = right + 1; (terminator)</span>

 152 
<span class="line-modified"> 153         if (count == 0) {</span>
<span class="line-modified"> 154             // A single equal run</span>
<span class="line-modified"> 155             return;</span>
<span class="line-modified"> 156         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-modified"> 157             // Either a single ascending or a transformed descending run.</span>
<span class="line-modified"> 158             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-modified"> 159             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-modified"> 160             return;</span>
<span class="line-modified"> 161         }</span>
<span class="line-modified"> 162         right++;</span>
<span class="line-modified"> 163         if (run[count] &lt; right) {</span>
<span class="line-modified"> 164             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-modified"> 165             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed"> 166             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed"> 167             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed"> 168             run[++count] = right;</span>
<span class="line-removed"> 169         }</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171         // Determine alternation base for merge</span>
<span class="line-removed"> 172         byte odd = 0;</span>
<span class="line-removed"> 173         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed"> 174 </span>
<span class="line-removed"> 175         // Use or create temporary array b for merging</span>
<span class="line-removed"> 176         int[] b;                 // temp array; alternates with a</span>
<span class="line-removed"> 177         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed"> 178         int blen = right - left; // space needed for b</span>
<span class="line-removed"> 179         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed"> 180             work = new int[blen];</span>
<span class="line-removed"> 181             workBase = 0;</span>
<span class="line-removed"> 182         }</span>
<span class="line-removed"> 183         if (odd == 0) {</span>
<span class="line-removed"> 184             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed"> 185             b = a;</span>
<span class="line-removed"> 186             bo = 0;</span>
<span class="line-removed"> 187             a = work;</span>
<span class="line-removed"> 188             ao = workBase - left;</span>
<span class="line-removed"> 189         } else {</span>
<span class="line-removed"> 190             b = work;</span>
<span class="line-removed"> 191             ao = 0;</span>
<span class="line-removed"> 192             bo = workBase - left;</span>
<span class="line-removed"> 193         }</span>
<span class="line-removed"> 194 </span>
<span class="line-removed"> 195         // Merging</span>
<span class="line-removed"> 196         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed"> 197             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed"> 198                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed"> 199                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed"> 200                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed"> 201                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed"> 202                     } else {</span>
<span class="line-removed"> 203                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed"> 204                     }</span>
<span class="line-removed"> 205                 }</span>
<span class="line-removed"> 206                 run[++last] = hi;</span>
<span class="line-removed"> 207             }</span>
<span class="line-removed"> 208             if ((count &amp; 1) != 0) {</span>
<span class="line-removed"> 209                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed"> 210                     b[i + bo] = a[i + ao]</span>
<span class="line-removed"> 211                 );</span>
<span class="line-removed"> 212                 run[++last] = right;</span>
<span class="line-removed"> 213             }</span>
<span class="line-removed"> 214             int[] t = a; a = b; b = t;</span>
<span class="line-removed"> 215             int o = ao; ao = bo; bo = o;</span>
 216         }

 217     }
 218 
 219     /**
<span class="line-modified"> 220      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>







 221      *
 222      * @param a the array to be sorted
<span class="line-modified"> 223      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 224      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified"> 225      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified"> 226      */</span>
<span class="line-modified"> 227     private static void sort(int[] a, int left, int right, boolean leftmost) {</span>
<span class="line-modified"> 228         int length = right - left + 1;</span>
<span class="line-removed"> 229 </span>
<span class="line-removed"> 230         // Use insertion sort on tiny arrays</span>
<span class="line-removed"> 231         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-removed"> 232             if (leftmost) {</span>
<span class="line-removed"> 233                 /*</span>
<span class="line-removed"> 234                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-removed"> 235                  * optimized for server VM, is used in case of</span>
<span class="line-removed"> 236                  * the leftmost part.</span>
<span class="line-removed"> 237                  */</span>
<span class="line-removed"> 238                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-removed"> 239                     int ai = a[i + 1];</span>
<span class="line-removed"> 240                     while (ai &lt; a[j]) {</span>
<span class="line-removed"> 241                         a[j + 1] = a[j];</span>
<span class="line-removed"> 242                         if (j-- == left) {</span>
<span class="line-removed"> 243                             break;</span>
<span class="line-removed"> 244                         }</span>
<span class="line-removed"> 245                     }</span>
<span class="line-removed"> 246                     a[j + 1] = ai;</span>
<span class="line-removed"> 247                 }</span>
<span class="line-removed"> 248             } else {</span>
<span class="line-removed"> 249                 /*</span>
<span class="line-removed"> 250                  * Skip the longest ascending sequence.</span>
<span class="line-removed"> 251                  */</span>
<span class="line-removed"> 252                 do {</span>
<span class="line-removed"> 253                     if (left &gt;= right) {</span>
<span class="line-removed"> 254                         return;</span>
<span class="line-removed"> 255                     }</span>
<span class="line-removed"> 256                 } while (a[++left] &gt;= a[left - 1]);</span>
<span class="line-removed"> 257 </span>
<span class="line-removed"> 258                 /*</span>
<span class="line-removed"> 259                  * Every element from adjoining part plays the role</span>
<span class="line-removed"> 260                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-removed"> 261                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed"> 262                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed"> 263                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed"> 264                  * than traditional implementation of insertion sort.</span>
<span class="line-removed"> 265                  */</span>
<span class="line-removed"> 266                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-removed"> 267                     int a1 = a[k], a2 = a[left];</span>
<span class="line-removed"> 268 </span>
<span class="line-removed"> 269                     if (a1 &lt; a2) {</span>
<span class="line-removed"> 270                         a2 = a1; a1 = a[left];</span>
<span class="line-removed"> 271                     }</span>
<span class="line-removed"> 272                     while (a1 &lt; a[--k]) {</span>
<span class="line-removed"> 273                         a[k + 2] = a[k];</span>
<span class="line-removed"> 274                     }</span>
<span class="line-removed"> 275                     a[++k + 1] = a1;</span>
<span class="line-removed"> 276 </span>
<span class="line-removed"> 277                     while (a2 &lt; a[--k]) {</span>
<span class="line-removed"> 278                         a[k + 1] = a[k];</span>
<span class="line-removed"> 279                     }</span>
<span class="line-removed"> 280                     a[k + 1] = a2;</span>
<span class="line-removed"> 281                 }</span>
<span class="line-removed"> 282                 int last = a[right];</span>
 283 
<span class="line-modified"> 284                 while (last &lt; a[--right]) {</span>
<span class="line-modified"> 285                     a[right + 1] = a[right];</span>
<span class="line-modified"> 286                 }</span>
<span class="line-modified"> 287                 a[right + 1] = last;</span>
<span class="line-modified"> 288             }</span>
<span class="line-modified"> 289             return;</span>
 290         }

 291 
<span class="line-modified"> 292         // Inexpensive approximation of length / 7</span>
<span class="line-modified"> 293         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-modified"> 294 </span>
<span class="line-modified"> 295         /*</span>
<span class="line-modified"> 296          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-modified"> 297          * center element in the range. These elements will be used for</span>
<span class="line-modified"> 298          * pivot selection as described below. The choice for spacing</span>
<span class="line-modified"> 299          * these elements was empirically determined to work well on</span>
<span class="line-modified"> 300          * a wide variety of inputs.</span>
<span class="line-modified"> 301          */</span>
<span class="line-modified"> 302         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified"> 303         int e2 = e3 - seventh;</span>
<span class="line-modified"> 304         int e1 = e2 - seventh;</span>
<span class="line-modified"> 305         int e4 = e3 + seventh;</span>
<span class="line-removed"> 306         int e5 = e4 + seventh;</span>
<span class="line-removed"> 307 </span>
<span class="line-removed"> 308         // Sort these elements using insertion sort</span>
<span class="line-removed"> 309         if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
 310 
<span class="line-modified"> 311         if (a[e3] &lt; a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified"> 312             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-modified"> 313         }</span>
<span class="line-modified"> 314         if (a[e4] &lt; a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified"> 315             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified"> 316                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
 317             }
<span class="line-modified"> 318         }</span>
<span class="line-modified"> 319         if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-modified"> 320             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified"> 321                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified"> 322                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-modified"> 323                 }</span>

 324             }
<span class="line-removed"> 325         }</span>
 326 
<span class="line-modified"> 327         // Pointers</span>
<span class="line-modified"> 328         int less  = left;  // The index of the first element of center part</span>
<span class="line-modified"> 329         int great = right; // The index before the first element of right part</span>





 330 
<span class="line-removed"> 331         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
 332             /*
<span class="line-modified"> 333              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-modified"> 334              * These values are inexpensive approximations of the first and</span>
<span class="line-removed"> 335              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
 336              */
<span class="line-modified"> 337             int pivot1 = a[e2];</span>
<span class="line-modified"> 338             int pivot2 = a[e4];</span>


 339 
 340             /*
<span class="line-modified"> 341              * The first and the last elements to be sorted are moved to the</span>
<span class="line-modified"> 342              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed"> 343              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed"> 344              * positions, and excluded from subsequent sorting.</span>
 345              */
<span class="line-modified"> 346             a[e2] = a[left];</span>
<span class="line-removed"> 347             a[e4] = a[right];</span>
 348 
 349             /*
<span class="line-modified"> 350              * Skip elements, which are less or greater than pivot values.</span>



 351              */
<span class="line-modified"> 352             while (a[++less] &lt; pivot1);</span>
<span class="line-modified"> 353             while (a[--great] &gt; pivot2);</span>




 354 
 355             /*
<span class="line-modified"> 356              * Partitioning:</span>

 357              *
<span class="line-modified"> 358              *   left part           center part                   right part</span>
<span class="line-modified"> 359              * +--------------------------------------------------------------+</span>
<span class="line-modified"> 360              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-modified"> 361              * +--------------------------------------------------------------+</span>
<span class="line-modified"> 362              *               ^                          ^       ^</span>
<span class="line-modified"> 363              *               |                          |       |</span>
<span class="line-modified"> 364              *              less                        k     great</span>
<span class="line-removed"> 365              *</span>
<span class="line-removed"> 366              * Invariants:</span>
<span class="line-removed"> 367              *</span>
<span class="line-removed"> 368              *              all in (left, less)   &lt; pivot1</span>
<span class="line-removed"> 369              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-removed"> 370              *              all in (great, right) &gt; pivot2</span>
<span class="line-removed"> 371              *</span>
<span class="line-removed"> 372              * Pointer k is the first index of ?-part.</span>
 373              */
<span class="line-modified"> 374             outer:</span>
<span class="line-modified"> 375             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified"> 376                 int ak = a[k];</span>
<span class="line-modified"> 377                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-modified"> 378                     a[k] = a[less];</span>
<span class="line-modified"> 379                     /*</span>
<span class="line-modified"> 380                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-modified"> 381                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="line-modified"> 382                      */</span>
<span class="line-modified"> 383                     a[less] = ak;</span>
<span class="line-modified"> 384                     ++less;</span>
<span class="line-modified"> 385                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-modified"> 386                     while (a[great] &gt; pivot2) {</span>
<span class="line-modified"> 387                         if (great-- == k) {</span>
<span class="line-modified"> 388                             break outer;</span>
<span class="line-modified"> 389                         }</span>
<span class="line-modified"> 390                     }</span>
<span class="line-removed"> 391                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed"> 392                         a[k] = a[less];</span>
<span class="line-removed"> 393                         a[less] = a[great];</span>
<span class="line-removed"> 394                         ++less;</span>
<span class="line-removed"> 395                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed"> 396                         a[k] = a[great];</span>
<span class="line-removed"> 397                     }</span>
<span class="line-removed"> 398                     /*</span>
<span class="line-removed"> 399                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed"> 400                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="line-removed"> 401                      */</span>
<span class="line-removed"> 402                     a[great] = ak;</span>
<span class="line-removed"> 403                     --great;</span>
 404                 }
 405             }
 406 
<span class="line-modified"> 407             // Swap pivots into their final positions</span>
<span class="line-modified"> 408             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-modified"> 409             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-removed"> 410 </span>
<span class="line-removed"> 411             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed"> 412             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed"> 413             sort(a, great + 2, right, false);</span>
 414 
 415             /*
<span class="line-modified"> 416              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-removed"> 417              * swap internal pivot values to ends.</span>
 418              */
<span class="line-modified"> 419             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>

 420                 /*
<span class="line-modified"> 421                  * Skip elements, which are equal to pivot values.</span>


 422                  */
<span class="line-modified"> 423                 while (a[less] == pivot1) {</span>
<span class="line-modified"> 424                     ++less;</span>
<span class="line-removed"> 425                 }</span>
 426 
<span class="line-modified"> 427                 while (a[great] == pivot2) {</span>
<span class="line-modified"> 428                     --great;</span>
<span class="line-modified"> 429                 }</span>












 430 
 431                 /*
<span class="line-modified"> 432                  * Partitioning:</span>
 433                  *
<span class="line-modified"> 434                  *   left part         center part                  right part</span>
<span class="line-modified"> 435                  * +----------------------------------------------------------+</span>
<span class="line-modified"> 436                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-modified"> 437                  * +----------------------------------------------------------+</span>
<span class="line-modified"> 438                  *              ^                        ^       ^</span>
<span class="line-modified"> 439                  *              |                        |       |</span>
<span class="line-modified"> 440                  *             less                      k     great</span>
 441                  *
 442                  * Invariants:
 443                  *
<span class="line-modified"> 444                  *              all in (*,  less) == pivot1</span>
<span class="line-modified"> 445                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-modified"> 446                  *              all in (great, *) == pivot2</span>
 447                  *
<span class="line-modified"> 448                  * Pointer k is the first index of ?-part.</span>
 449                  */
<span class="line-modified"> 450                 outer:</span>
<span class="line-removed"> 451                 for (int k = less - 1; ++k &lt;= great; ) {</span>
 452                     int ak = a[k];
<span class="line-modified"> 453                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-modified"> 454                         a[k] = a[less];</span>
<span class="line-modified"> 455                         a[less] = ak;</span>
<span class="line-modified"> 456                         ++less;</span>
<span class="line-modified"> 457                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-modified"> 458                         while (a[great] == pivot2) {</span>
<span class="line-modified"> 459                             if (great-- == k) {</span>
<span class="line-modified"> 460                                 break outer;</span>




 461                             }
 462                         }
<span class="line-modified"> 463                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-modified"> 464                             a[k] = a[less];</span>
<span class="line-modified"> 465                             /*</span>
<span class="line-removed"> 466                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed"> 467                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed"> 468                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed"> 469                              * of different signs. Therefore in float and</span>
<span class="line-removed"> 470                              * double sorting methods we have to use more</span>
<span class="line-removed"> 471                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed"> 472                              */</span>
<span class="line-removed"> 473                             a[less] = pivot1;</span>
<span class="line-removed"> 474                             ++less;</span>
<span class="line-removed"> 475                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed"> 476                             a[k] = a[great];</span>
<span class="line-removed"> 477                         }</span>
<span class="line-removed"> 478                         a[great] = ak;</span>
<span class="line-removed"> 479                         --great;</span>
 480                     }
 481                 }
<span class="line-removed"> 482             }</span>
<span class="line-removed"> 483 </span>
<span class="line-removed"> 484             // Sort center part recursively</span>
<span class="line-removed"> 485             sort(a, less, great, false);</span>
 486 
<span class="line-modified"> 487         } else { // Partitioning with one pivot</span>
<span class="line-modified"> 488             /*</span>
<span class="line-modified"> 489              * Use the third of the five sorted elements as pivot.</span>
<span class="line-modified"> 490              * This value is inexpensive approximation of the median.</span>
<span class="line-modified"> 491              */</span>
<span class="line-removed"> 492             int pivot = a[e3];</span>
 493 
<span class="line-modified"> 494             /*</span>
<span class="line-modified"> 495              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-modified"> 496              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-modified"> 497              *</span>
<span class="line-modified"> 498              *   left part    center part              right part</span>
<span class="line-modified"> 499              * +-------------------------------------------------+</span>
<span class="line-modified"> 500              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-modified"> 501              * +-------------------------------------------------+</span>
<span class="line-modified"> 502              *              ^              ^        ^</span>
<span class="line-modified"> 503              *              |              |        |</span>
<span class="line-removed"> 504              *             less            k      great</span>
<span class="line-removed"> 505              *</span>
<span class="line-removed"> 506              * Invariants:</span>
<span class="line-removed"> 507              *</span>
<span class="line-removed"> 508              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed"> 509              *   all in [less, k)     == pivot</span>
<span class="line-removed"> 510              *   all in (great, right) &gt; pivot</span>
<span class="line-removed"> 511              *</span>
<span class="line-removed"> 512              * Pointer k is the first index of ?-part.</span>
<span class="line-removed"> 513              */</span>
<span class="line-removed"> 514             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed"> 515                 if (a[k] == pivot) {</span>
<span class="line-removed"> 516                     continue;</span>
<span class="line-removed"> 517                 }</span>
<span class="line-removed"> 518                 int ak = a[k];</span>
<span class="line-removed"> 519                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed"> 520                     a[k] = a[less];</span>
<span class="line-removed"> 521                     a[less] = ak;</span>
<span class="line-removed"> 522                     ++less;</span>
<span class="line-removed"> 523                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed"> 524                     while (a[great] &gt; pivot) {</span>
<span class="line-removed"> 525                         --great;</span>
<span class="line-removed"> 526                     }</span>
<span class="line-removed"> 527                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-removed"> 528                         a[k] = a[less];</span>
<span class="line-removed"> 529                         a[less] = a[great];</span>
<span class="line-removed"> 530                         ++less;</span>
<span class="line-removed"> 531                     } else { // a[great] == pivot</span>
<span class="line-removed"> 532                         /*</span>
<span class="line-removed"> 533                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed"> 534                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed"> 535                          * if a[great] and pivot are floating-point</span>
<span class="line-removed"> 536                          * zeros of different signs. Therefore in float</span>
<span class="line-removed"> 537                          * and double sorting methods we have to use</span>
<span class="line-removed"> 538                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed"> 539                          */</span>
<span class="line-removed"> 540                         a[k] = pivot;</span>
<span class="line-removed"> 541                     }</span>
<span class="line-removed"> 542                     a[great] = ak;</span>
<span class="line-removed"> 543                     --great;</span>
 544                 }
<span class="line-removed"> 545             }</span>
<span class="line-removed"> 546 </span>
<span class="line-removed"> 547             /*</span>
<span class="line-removed"> 548              * Sort left and right parts recursively.</span>
<span class="line-removed"> 549              * All elements from center part are equal</span>
<span class="line-removed"> 550              * and, therefore, already sorted.</span>
<span class="line-removed"> 551              */</span>
<span class="line-removed"> 552             sort(a, left, less - 1, leftmost);</span>
<span class="line-removed"> 553             sort(a, great + 1, right, false);</span>
<span class="line-removed"> 554         }</span>
<span class="line-removed"> 555     }</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557     /**</span>
<span class="line-removed"> 558      * Sorts the specified range of the array using the given</span>
<span class="line-removed"> 559      * workspace array slice if possible for merging</span>
<span class="line-removed"> 560      *</span>
<span class="line-removed"> 561      * @param a the array to be sorted</span>
<span class="line-removed"> 562      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-removed"> 563      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-removed"> 564      * @param work a workspace array (slice)</span>
<span class="line-removed"> 565      * @param workBase origin of usable space in work array</span>
<span class="line-removed"> 566      * @param workLen usable size of work array</span>
<span class="line-removed"> 567      */</span>
<span class="line-removed"> 568     static void sort(long[] a, int left, int right,</span>
<span class="line-removed"> 569                      long[] work, int workBase, int workLen) {</span>
<span class="line-removed"> 570         // Use Quicksort on small arrays</span>
<span class="line-removed"> 571         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-removed"> 572             sort(a, left, right, true);</span>
<span class="line-removed"> 573             return;</span>
<span class="line-removed"> 574         }</span>
 575 
<span class="line-modified"> 576         /*</span>
<span class="line-removed"> 577          * Index run[i] is the start of i-th run</span>
<span class="line-removed"> 578          * (ascending or descending sequence).</span>
<span class="line-removed"> 579          */</span>
<span class="line-removed"> 580         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-removed"> 581         int count = 0; run[0] = left;</span>
 582 
<span class="line-modified"> 583         // Check if the array is nearly sorted</span>
<span class="line-modified"> 584         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-modified"> 585             // Equal items in the beginning of the sequence</span>
<span class="line-modified"> 586             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-modified"> 587                 k++;</span>
<span class="line-removed"> 588             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed"> 589             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed"> 590                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed"> 591             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed"> 592                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed"> 593                 // Transform into an ascending sequence</span>
<span class="line-removed"> 594                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed"> 595                     long t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed"> 596                 }</span>
<span class="line-removed"> 597             }</span>
 598 
<span class="line-modified"> 599             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified"> 600             // ascending sequence</span>
<span class="line-modified"> 601             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified"> 602                 count--;</span>
<span class="line-modified"> 603             }</span>



 604 
<span class="line-modified"> 605             /*</span>
<span class="line-modified"> 606              * The array is not highly structured,</span>
<span class="line-modified"> 607              * use Quicksort instead of merge sort.</span>
<span class="line-modified"> 608              */</span>
<span class="line-modified"> 609             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-modified"> 610                 sort(a, left, right, true);</span>
<span class="line-modified"> 611                 return;</span>
<span class="line-modified"> 612             }</span>
<span class="line-modified"> 613         }</span>












 614 
<span class="line-modified"> 615         // These invariants should hold true:</span>
<span class="line-modified"> 616         //    run[0] = 0</span>
<span class="line-removed"> 617         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
 618 
<span class="line-modified"> 619         if (count == 0) {</span>
<span class="line-modified"> 620             // A single equal run</span>
<span class="line-removed"> 621             return;</span>
<span class="line-removed"> 622         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-removed"> 623             // Either a single ascending or a transformed descending run.</span>
<span class="line-removed"> 624             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-removed"> 625             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-removed"> 626             return;</span>
<span class="line-removed"> 627         }</span>
<span class="line-removed"> 628         right++;</span>
<span class="line-removed"> 629         if (run[count] &lt; right) {</span>
<span class="line-removed"> 630             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed"> 631             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed"> 632             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed"> 633             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed"> 634             run[++count] = right;</span>
<span class="line-removed"> 635         }</span>
<span class="line-removed"> 636 </span>
<span class="line-removed"> 637         // Determine alternation base for merge</span>
<span class="line-removed"> 638         byte odd = 0;</span>
<span class="line-removed"> 639         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed"> 640 </span>
<span class="line-removed"> 641         // Use or create temporary array b for merging</span>
<span class="line-removed"> 642         long[] b;                 // temp array; alternates with a</span>
<span class="line-removed"> 643         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed"> 644         int blen = right - left; // space needed for b</span>
<span class="line-removed"> 645         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed"> 646             work = new long[blen];</span>
<span class="line-removed"> 647             workBase = 0;</span>
<span class="line-removed"> 648         }</span>
<span class="line-removed"> 649         if (odd == 0) {</span>
<span class="line-removed"> 650             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed"> 651             b = a;</span>
<span class="line-removed"> 652             bo = 0;</span>
<span class="line-removed"> 653             a = work;</span>
<span class="line-removed"> 654             ao = workBase - left;</span>
<span class="line-removed"> 655         } else {</span>
<span class="line-removed"> 656             b = work;</span>
<span class="line-removed"> 657             ao = 0;</span>
<span class="line-removed"> 658             bo = workBase - left;</span>
<span class="line-removed"> 659         }</span>
<span class="line-removed"> 660 </span>
<span class="line-removed"> 661         // Merging</span>
<span class="line-removed"> 662         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed"> 663             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed"> 664                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed"> 665                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed"> 666                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed"> 667                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed"> 668                     } else {</span>
<span class="line-removed"> 669                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed"> 670                     }</span>
<span class="line-removed"> 671                 }</span>
<span class="line-removed"> 672                 run[++last] = hi;</span>
<span class="line-removed"> 673             }</span>
<span class="line-removed"> 674             if ((count &amp; 1) != 0) {</span>
<span class="line-removed"> 675                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed"> 676                     b[i + bo] = a[i + ao]</span>
<span class="line-removed"> 677                 );</span>
<span class="line-removed"> 678                 run[++last] = right;</span>
<span class="line-removed"> 679             }</span>
<span class="line-removed"> 680             long[] t = a; a = b; b = t;</span>
<span class="line-removed"> 681             int o = ao; ao = bo; bo = o;</span>
<span class="line-removed"> 682         }</span>
<span class="line-removed"> 683     }</span>
 684 
<span class="line-modified"> 685     /**</span>
<span class="line-modified"> 686      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
<span class="line-modified"> 687      *</span>
<span class="line-modified"> 688      * @param a the array to be sorted</span>
<span class="line-modified"> 689      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 690      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-removed"> 691      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-removed"> 692      */</span>
<span class="line-removed"> 693     private static void sort(long[] a, int left, int right, boolean leftmost) {</span>
<span class="line-removed"> 694         int length = right - left + 1;</span>
<span class="line-removed"> 695 </span>
<span class="line-removed"> 696         // Use insertion sort on tiny arrays</span>
<span class="line-removed"> 697         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-removed"> 698             if (leftmost) {</span>
<span class="line-removed"> 699                 /*</span>
<span class="line-removed"> 700                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-removed"> 701                  * optimized for server VM, is used in case of</span>
<span class="line-removed"> 702                  * the leftmost part.</span>
<span class="line-removed"> 703                  */</span>
<span class="line-removed"> 704                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-removed"> 705                     long ai = a[i + 1];</span>
<span class="line-removed"> 706                     while (ai &lt; a[j]) {</span>
<span class="line-removed"> 707                         a[j + 1] = a[j];</span>
<span class="line-removed"> 708                         if (j-- == left) {</span>
<span class="line-removed"> 709                             break;</span>
 710                         }
 711                     }
<span class="line-removed"> 712                     a[j + 1] = ai;</span>
 713                 }
<span class="line-modified"> 714             } else {</span>
 715                 /*
<span class="line-modified"> 716                  * Skip the longest ascending sequence.</span>
 717                  */
<span class="line-modified"> 718                 do {</span>
<span class="line-removed"> 719                     if (left &gt;= right) {</span>
<span class="line-removed"> 720                         return;</span>
<span class="line-removed"> 721                     }</span>
<span class="line-removed"> 722                 } while (a[++left] &gt;= a[left - 1]);</span>
 723 
 724                 /*
<span class="line-modified"> 725                  * Every element from adjoining part plays the role</span>
<span class="line-modified"> 726                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-modified"> 727                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed"> 728                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed"> 729                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed"> 730                  * than traditional implementation of insertion sort.</span>
 731                  */
<span class="line-modified"> 732                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-modified"> 733                     long a1 = a[k], a2 = a[left];</span>
<span class="line-modified"> 734 </span>
<span class="line-modified"> 735                     if (a1 &lt; a2) {</span>
<span class="line-removed"> 736                         a2 = a1; a1 = a[left];</span>
<span class="line-removed"> 737                     }</span>
<span class="line-removed"> 738                     while (a1 &lt; a[--k]) {</span>
<span class="line-removed"> 739                         a[k + 2] = a[k];</span>
<span class="line-removed"> 740                     }</span>
<span class="line-removed"> 741                     a[++k + 1] = a1;</span>
<span class="line-removed"> 742 </span>
<span class="line-removed"> 743                     while (a2 &lt; a[--k]) {</span>
<span class="line-removed"> 744                         a[k + 1] = a[k];</span>
<span class="line-removed"> 745                     }</span>
<span class="line-removed"> 746                     a[k + 1] = a2;</span>
<span class="line-removed"> 747                 }</span>
<span class="line-removed"> 748                 long last = a[right];</span>
<span class="line-removed"> 749 </span>
<span class="line-removed"> 750                 while (last &lt; a[--right]) {</span>
<span class="line-removed"> 751                     a[right + 1] = a[right];</span>
 752                 }
<span class="line-removed"> 753                 a[right + 1] = last;</span>
 754             }
<span class="line-modified"> 755             return;</span>
 756         }

 757 
<span class="line-modified"> 758         // Inexpensive approximation of length / 7</span>
<span class="line-modified"> 759         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-modified"> 760 </span>
<span class="line-modified"> 761         /*</span>
<span class="line-modified"> 762          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-modified"> 763          * center element in the range. These elements will be used for</span>
<span class="line-modified"> 764          * pivot selection as described below. The choice for spacing</span>
<span class="line-modified"> 765          * these elements was empirically determined to work well on</span>
<span class="line-modified"> 766          * a wide variety of inputs.</span>
<span class="line-modified"> 767          */</span>
<span class="line-modified"> 768         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified"> 769         int e2 = e3 - seventh;</span>
<span class="line-modified"> 770         int e1 = e2 - seventh;</span>
<span class="line-modified"> 771         int e4 = e3 + seventh;</span>
<span class="line-modified"> 772         int e5 = e4 + seventh;</span>




 773 
<span class="line-modified"> 774         // Sort these elements using insertion sort</span>
<span class="line-modified"> 775         if (a[e2] &lt; a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>



 776 
<span class="line-modified"> 777         if (a[e3] &lt; a[e2]) { long t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified"> 778             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed"> 779         }</span>
<span class="line-removed"> 780         if (a[e4] &lt; a[e3]) { long t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-removed"> 781             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed"> 782                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed"> 783             }</span>
<span class="line-removed"> 784         }</span>
<span class="line-removed"> 785         if (a[e5] &lt; a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-removed"> 786             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-removed"> 787                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed"> 788                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
 789                 }

 790             }
<span class="line-modified"> 791         }</span>
<span class="line-removed"> 792 </span>
<span class="line-removed"> 793         // Pointers</span>
<span class="line-removed"> 794         int less  = left;  // The index of the first element of center part</span>
<span class="line-removed"> 795         int great = right; // The index before the first element of right part</span>
 796 
<span class="line-removed"> 797         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
 798             /*
<span class="line-modified"> 799              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-modified"> 800              * These values are inexpensive approximations of the first and</span>
<span class="line-modified"> 801              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>




 802              */
<span class="line-modified"> 803             long pivot1 = a[e2];</span>
<span class="line-removed"> 804             long pivot2 = a[e4];</span>
 805 
<span class="line-modified"> 806             /*</span>
<span class="line-modified"> 807              * The first and the last elements to be sorted are moved to the</span>
<span class="line-removed"> 808              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed"> 809              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed"> 810              * positions, and excluded from subsequent sorting.</span>
<span class="line-removed"> 811              */</span>
<span class="line-removed"> 812             a[e2] = a[left];</span>
<span class="line-removed"> 813             a[e4] = a[right];</span>
 814 
<span class="line-modified"> 815             /*</span>
<span class="line-removed"> 816              * Skip elements, which are less or greater than pivot values.</span>
<span class="line-removed"> 817              */</span>
<span class="line-removed"> 818             while (a[++less] &lt; pivot1);</span>
<span class="line-removed"> 819             while (a[--great] &gt; pivot2);</span>
 820 
<span class="line-removed"> 821             /*</span>
<span class="line-removed"> 822              * Partitioning:</span>
<span class="line-removed"> 823              *</span>
<span class="line-removed"> 824              *   left part           center part                   right part</span>
<span class="line-removed"> 825              * +--------------------------------------------------------------+</span>
<span class="line-removed"> 826              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-removed"> 827              * +--------------------------------------------------------------+</span>
<span class="line-removed"> 828              *               ^                          ^       ^</span>
<span class="line-removed"> 829              *               |                          |       |</span>
<span class="line-removed"> 830              *              less                        k     great</span>
<span class="line-removed"> 831              *</span>
<span class="line-removed"> 832              * Invariants:</span>
<span class="line-removed"> 833              *</span>
<span class="line-removed"> 834              *              all in (left, less)   &lt; pivot1</span>
<span class="line-removed"> 835              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-removed"> 836              *              all in (great, right) &gt; pivot2</span>
<span class="line-removed"> 837              *</span>
<span class="line-removed"> 838              * Pointer k is the first index of ?-part.</span>
<span class="line-removed"> 839              */</span>
<span class="line-removed"> 840             outer:</span>
<span class="line-removed"> 841             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed"> 842                 long ak = a[k];</span>
<span class="line-removed"> 843                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-removed"> 844                     a[k] = a[less];</span>
 845                     /*
<span class="line-modified"> 846                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-removed"> 847                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
 848                      */
<span class="line-modified"> 849                     a[less] = ak;</span>
<span class="line-modified"> 850                     ++less;</span>
<span class="line-modified"> 851                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-modified"> 852                     while (a[great] &gt; pivot2) {</span>
<span class="line-removed"> 853                         if (great-- == k) {</span>
<span class="line-removed"> 854                             break outer;</span>
<span class="line-removed"> 855                         }</span>
 856                     }
<span class="line-modified"> 857                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-modified"> 858                         a[k] = a[less];</span>
<span class="line-modified"> 859                         a[less] = a[great];</span>
<span class="line-modified"> 860                         ++less;</span>
<span class="line-modified"> 861                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-modified"> 862                         a[k] = a[great];</span>









 863                     }

 864                     /*
<span class="line-modified"> 865                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed"> 866                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
 867                      */
<span class="line-modified"> 868                     a[great] = ak;</span>
<span class="line-modified"> 869                     --great;</span>


 870                 }
 871             }
 872 
<span class="line-removed"> 873             // Swap pivots into their final positions</span>
<span class="line-removed"> 874             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-removed"> 875             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-removed"> 876 </span>
<span class="line-removed"> 877             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed"> 878             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed"> 879             sort(a, great + 2, right, false);</span>
<span class="line-removed"> 880 </span>
 881             /*
<span class="line-modified"> 882              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-removed"> 883              * swap internal pivot values to ends.</span>
 884              */
<span class="line-modified"> 885             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>


 886                 /*
<span class="line-modified"> 887                  * Skip elements, which are equal to pivot values.</span>


 888                  */
<span class="line-modified"> 889                 while (a[less] == pivot1) {</span>
<span class="line-removed"> 890                     ++less;</span>
<span class="line-removed"> 891                 }</span>
 892 
<span class="line-modified"> 893                 while (a[great] == pivot2) {</span>
<span class="line-modified"> 894                     --great;</span>
<span class="line-modified"> 895                 }</span>

 896 
<span class="line-modified"> 897                 /*</span>
<span class="line-modified"> 898                  * Partitioning:</span>
<span class="line-removed"> 899                  *</span>
<span class="line-removed"> 900                  *   left part         center part                  right part</span>
<span class="line-removed"> 901                  * +----------------------------------------------------------+</span>
<span class="line-removed"> 902                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-removed"> 903                  * +----------------------------------------------------------+</span>
<span class="line-removed"> 904                  *              ^                        ^       ^</span>
<span class="line-removed"> 905                  *              |                        |       |</span>
<span class="line-removed"> 906                  *             less                      k     great</span>
<span class="line-removed"> 907                  *</span>
<span class="line-removed"> 908                  * Invariants:</span>
<span class="line-removed"> 909                  *</span>
<span class="line-removed"> 910                  *              all in (*,  less) == pivot1</span>
<span class="line-removed"> 911                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-removed"> 912                  *              all in (great, *) == pivot2</span>
<span class="line-removed"> 913                  *</span>
<span class="line-removed"> 914                  * Pointer k is the first index of ?-part.</span>
<span class="line-removed"> 915                  */</span>
<span class="line-removed"> 916                 outer:</span>
<span class="line-removed"> 917                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed"> 918                     long ak = a[k];</span>
<span class="line-removed"> 919                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-removed"> 920                         a[k] = a[less];</span>
<span class="line-removed"> 921                         a[less] = ak;</span>
<span class="line-removed"> 922                         ++less;</span>
<span class="line-removed"> 923                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-removed"> 924                         while (a[great] == pivot2) {</span>
<span class="line-removed"> 925                             if (great-- == k) {</span>
<span class="line-removed"> 926                                 break outer;</span>
<span class="line-removed"> 927                             }</span>
<span class="line-removed"> 928                         }</span>
<span class="line-removed"> 929                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed"> 930                             a[k] = a[less];</span>
<span class="line-removed"> 931                             /*</span>
<span class="line-removed"> 932                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed"> 933                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed"> 934                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed"> 935                              * of different signs. Therefore in float and</span>
<span class="line-removed"> 936                              * double sorting methods we have to use more</span>
<span class="line-removed"> 937                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed"> 938                              */</span>
<span class="line-removed"> 939                             a[less] = pivot1;</span>
<span class="line-removed"> 940                             ++less;</span>
<span class="line-removed"> 941                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed"> 942                             a[k] = a[great];</span>
<span class="line-removed"> 943                         }</span>
<span class="line-removed"> 944                         a[great] = ak;</span>
<span class="line-removed"> 945                         --great;</span>
 946                     }
<span class="line-modified"> 947                 }</span>
<span class="line-removed"> 948             }</span>
 949 
<span class="line-modified"> 950             // Sort center part recursively</span>
<span class="line-removed"> 951             sort(a, less, great, false);</span>
 952 
<span class="line-modified"> 953         } else { // Partitioning with one pivot</span>
<span class="line-modified"> 954             /*</span>
<span class="line-removed"> 955              * Use the third of the five sorted elements as pivot.</span>
<span class="line-removed"> 956              * This value is inexpensive approximation of the median.</span>
<span class="line-removed"> 957              */</span>
<span class="line-removed"> 958             long pivot = a[e3];</span>
<span class="line-removed"> 959 </span>
<span class="line-removed"> 960             /*</span>
<span class="line-removed"> 961              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-removed"> 962              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-removed"> 963              *</span>
<span class="line-removed"> 964              *   left part    center part              right part</span>
<span class="line-removed"> 965              * +-------------------------------------------------+</span>
<span class="line-removed"> 966              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed"> 967              * +-------------------------------------------------+</span>
<span class="line-removed"> 968              *              ^              ^        ^</span>
<span class="line-removed"> 969              *              |              |        |</span>
<span class="line-removed"> 970              *             less            k      great</span>
<span class="line-removed"> 971              *</span>
<span class="line-removed"> 972              * Invariants:</span>
<span class="line-removed"> 973              *</span>
<span class="line-removed"> 974              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed"> 975              *   all in [less, k)     == pivot</span>
<span class="line-removed"> 976              *   all in (great, right) &gt; pivot</span>
<span class="line-removed"> 977              *</span>
<span class="line-removed"> 978              * Pointer k is the first index of ?-part.</span>
<span class="line-removed"> 979              */</span>
<span class="line-removed"> 980             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed"> 981                 if (a[k] == pivot) {</span>
<span class="line-removed"> 982                     continue;</span>
<span class="line-removed"> 983                 }</span>
<span class="line-removed"> 984                 long ak = a[k];</span>
<span class="line-removed"> 985                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed"> 986                     a[k] = a[less];</span>
<span class="line-removed"> 987                     a[less] = ak;</span>
<span class="line-removed"> 988                     ++less;</span>
<span class="line-removed"> 989                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed"> 990                     while (a[great] &gt; pivot) {</span>
<span class="line-removed"> 991                         --great;</span>
 992                     }
<span class="line-modified"> 993                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-modified"> 994                         a[k] = a[less];</span>
<span class="line-modified"> 995                         a[less] = a[great];</span>
<span class="line-modified"> 996                         ++less;</span>
<span class="line-removed"> 997                     } else { // a[great] == pivot</span>
<span class="line-removed"> 998                         /*</span>
<span class="line-removed"> 999                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed">1000                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed">1001                          * if a[great] and pivot are floating-point</span>
<span class="line-removed">1002                          * zeros of different signs. Therefore in float</span>
<span class="line-removed">1003                          * and double sorting methods we have to use</span>
<span class="line-removed">1004                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed">1005                          */</span>
<span class="line-removed">1006                         a[k] = pivot;</span>
1007                     }
<span class="line-modified">1008                     a[great] = ak;</span>
<span class="line-removed">1009                     --great;</span>
1010                 }
1011             }
<span class="line-removed">1012 </span>
<span class="line-removed">1013             /*</span>
<span class="line-removed">1014              * Sort left and right parts recursively.</span>
<span class="line-removed">1015              * All elements from center part are equal</span>
<span class="line-removed">1016              * and, therefore, already sorted.</span>
<span class="line-removed">1017              */</span>
<span class="line-removed">1018             sort(a, left, less - 1, leftmost);</span>
<span class="line-removed">1019             sort(a, great + 1, right, false);</span>
1020         }
1021     }
1022 
1023     /**
<span class="line-modified">1024      * Sorts the specified range of the array using the given</span>
<span class="line-removed">1025      * workspace array slice if possible for merging</span>
1026      *
1027      * @param a the array to be sorted
<span class="line-modified">1028      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1029      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1030      * @param work a workspace array (slice)</span>
<span class="line-modified">1031      * @param workBase origin of usable space in work array</span>
<span class="line-modified">1032      * @param workLen usable size of work array</span>
<span class="line-modified">1033      */</span>
<span class="line-removed">1034     static void sort(short[] a, int left, int right,</span>
<span class="line-removed">1035                      short[] work, int workBase, int workLen) {</span>
<span class="line-removed">1036         // Use counting sort on large arrays</span>
<span class="line-removed">1037         if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {</span>
<span class="line-removed">1038             int[] count = new int[NUM_SHORT_VALUES];</span>
<span class="line-removed">1039 </span>
<span class="line-removed">1040             for (int i = left - 1; ++i &lt;= right;</span>
<span class="line-removed">1041                 count[a[i] - Short.MIN_VALUE]++</span>
<span class="line-removed">1042             );</span>
<span class="line-removed">1043             for (int i = NUM_SHORT_VALUES, k = right + 1; k &gt; left; ) {</span>
<span class="line-removed">1044                 while (count[--i] == 0);</span>
<span class="line-removed">1045                 short value = (short) (i + Short.MIN_VALUE);</span>
<span class="line-removed">1046                 int s = count[i];</span>
1047 
<span class="line-modified">1048                 do {</span>
<span class="line-modified">1049                     a[--k] = value;</span>
<span class="line-modified">1050                 } while (--s &gt; 0);</span>


1051             }
<span class="line-removed">1052         } else { // Use Dual-Pivot Quicksort on small arrays</span>
<span class="line-removed">1053             doSort(a, left, right, work, workBase, workLen);</span>
1054         }
1055     }
1056 
<span class="line-removed">1057     /** The number of distinct short values. */</span>
<span class="line-removed">1058     private static final int NUM_SHORT_VALUES = 1 &lt;&lt; 16;</span>
<span class="line-removed">1059 </span>
1060     /**
<span class="line-modified">1061      * Sorts the specified range of the array.</span>
1062      *
1063      * @param a the array to be sorted
<span class="line-modified">1064      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1065      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1066      * @param work a workspace array (slice)</span>
<span class="line-modified">1067      * @param workBase origin of usable space in work array</span>
<span class="line-modified">1068      * @param workLen usable size of work array</span>
<span class="line-modified">1069      */</span>
<span class="line-removed">1070     private static void doSort(short[] a, int left, int right,</span>
<span class="line-removed">1071                                short[] work, int workBase, int workLen) {</span>
<span class="line-removed">1072         // Use Quicksort on small arrays</span>
<span class="line-removed">1073         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-removed">1074             sort(a, left, right, true);</span>
<span class="line-removed">1075             return;</span>
1076         }
<span class="line-modified">1077 </span>
<span class="line-modified">1078         /*</span>
<span class="line-modified">1079          * Index run[i] is the start of i-th run</span>
<span class="line-modified">1080          * (ascending or descending sequence).</span>
<span class="line-removed">1081          */</span>
<span class="line-removed">1082         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-removed">1083         int count = 0; run[0] = left;</span>
<span class="line-removed">1084 </span>
<span class="line-removed">1085         // Check if the array is nearly sorted</span>
<span class="line-removed">1086         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-removed">1087             // Equal items in the beginning of the sequence</span>
<span class="line-removed">1088             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed">1089                 k++;</span>
<span class="line-removed">1090             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed">1091             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed">1092                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed">1093             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed">1094                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed">1095                 // Transform into an ascending sequence</span>
<span class="line-removed">1096                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed">1097                     short t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed">1098                 }</span>
<span class="line-removed">1099             }</span>
<span class="line-removed">1100 </span>
<span class="line-removed">1101             // Merge a transformed descending sequence followed by an</span>
<span class="line-removed">1102             // ascending sequence</span>
<span class="line-removed">1103             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-removed">1104                 count--;</span>
<span class="line-removed">1105             }</span>
<span class="line-removed">1106 </span>
<span class="line-removed">1107             /*</span>
<span class="line-removed">1108              * The array is not highly structured,</span>
<span class="line-removed">1109              * use Quicksort instead of merge sort.</span>
<span class="line-removed">1110              */</span>
<span class="line-removed">1111             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-removed">1112                 sort(a, left, right, true);</span>
<span class="line-removed">1113                 return;</span>
<span class="line-removed">1114             }</span>
1115         }

1116 
<span class="line-modified">1117         // These invariants should hold true:</span>
<span class="line-modified">1118         //    run[0] = 0</span>
<span class="line-modified">1119         //    run[&lt;last&gt;] = right + 1; (terminator)</span>









1120 
<span class="line-modified">1121         if (count == 0) {</span>
<span class="line-modified">1122             // A single equal run</span>
<span class="line-removed">1123             return;</span>
<span class="line-removed">1124         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-removed">1125             // Either a single ascending or a transformed descending run.</span>
<span class="line-removed">1126             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-removed">1127             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-removed">1128             return;</span>
<span class="line-removed">1129         }</span>
<span class="line-removed">1130         right++;</span>
<span class="line-removed">1131         if (run[count] &lt; right) {</span>
<span class="line-removed">1132             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed">1133             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed">1134             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed">1135             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed">1136             run[++count] = right;</span>
<span class="line-removed">1137         }</span>
<span class="line-removed">1138 </span>
<span class="line-removed">1139         // Determine alternation base for merge</span>
<span class="line-removed">1140         byte odd = 0;</span>
<span class="line-removed">1141         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed">1142 </span>
<span class="line-removed">1143         // Use or create temporary array b for merging</span>
<span class="line-removed">1144         short[] b;                 // temp array; alternates with a</span>
<span class="line-removed">1145         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed">1146         int blen = right - left; // space needed for b</span>
<span class="line-removed">1147         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed">1148             work = new short[blen];</span>
<span class="line-removed">1149             workBase = 0;</span>
<span class="line-removed">1150         }</span>
<span class="line-removed">1151         if (odd == 0) {</span>
<span class="line-removed">1152             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed">1153             b = a;</span>
<span class="line-removed">1154             bo = 0;</span>
<span class="line-removed">1155             a = work;</span>
<span class="line-removed">1156             ao = workBase - left;</span>
<span class="line-removed">1157         } else {</span>
<span class="line-removed">1158             b = work;</span>
<span class="line-removed">1159             ao = 0;</span>
<span class="line-removed">1160             bo = workBase - left;</span>
<span class="line-removed">1161         }</span>
<span class="line-removed">1162 </span>
<span class="line-removed">1163         // Merging</span>
<span class="line-removed">1164         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed">1165             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed">1166                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed">1167                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed">1168                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed">1169                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed">1170                     } else {</span>
<span class="line-removed">1171                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed">1172                     }</span>
<span class="line-removed">1173                 }</span>
<span class="line-removed">1174                 run[++last] = hi;</span>
1175             }
<span class="line-modified">1176             if ((count &amp; 1) != 0) {</span>
<span class="line-modified">1177                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-modified">1178                     b[i + bo] = a[i + ao]</span>
<span class="line-modified">1179                 );</span>
<span class="line-modified">1180                 run[++last] = right;</span>
1181             }
<span class="line-removed">1182             short[] t = a; a = b; b = t;</span>
<span class="line-removed">1183             int o = ao; ao = bo; bo = o;</span>
1184         }

1185     }
1186 
1187     /**
<span class="line-modified">1188      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
1189      *

1190      * @param a the array to be sorted
<span class="line-modified">1191      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1192      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1193      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified">1194      */</span>
<span class="line-modified">1195     private static void sort(short[] a, int left, int right, boolean leftmost) {</span>
<span class="line-removed">1196         int length = right - left + 1;</span>
<span class="line-removed">1197 </span>
<span class="line-removed">1198         // Use insertion sort on tiny arrays</span>
<span class="line-removed">1199         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-removed">1200             if (leftmost) {</span>
<span class="line-removed">1201                 /*</span>
<span class="line-removed">1202                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-removed">1203                  * optimized for server VM, is used in case of</span>
<span class="line-removed">1204                  * the leftmost part.</span>
<span class="line-removed">1205                  */</span>
<span class="line-removed">1206                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-removed">1207                     short ai = a[i + 1];</span>
<span class="line-removed">1208                     while (ai &lt; a[j]) {</span>
<span class="line-removed">1209                         a[j + 1] = a[j];</span>
<span class="line-removed">1210                         if (j-- == left) {</span>
<span class="line-removed">1211                             break;</span>
<span class="line-removed">1212                         }</span>
<span class="line-removed">1213                     }</span>
<span class="line-removed">1214                     a[j + 1] = ai;</span>
<span class="line-removed">1215                 }</span>
<span class="line-removed">1216             } else {</span>
<span class="line-removed">1217                 /*</span>
<span class="line-removed">1218                  * Skip the longest ascending sequence.</span>
<span class="line-removed">1219                  */</span>
<span class="line-removed">1220                 do {</span>
<span class="line-removed">1221                     if (left &gt;= right) {</span>
<span class="line-removed">1222                         return;</span>
<span class="line-removed">1223                     }</span>
<span class="line-removed">1224                 } while (a[++left] &gt;= a[left - 1]);</span>
1225 
<span class="line-modified">1226                 /*</span>
<span class="line-modified">1227                  * Every element from adjoining part plays the role</span>
<span class="line-modified">1228                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-modified">1229                  * left range check on each iteration. Moreover, we use</span>
<span class="line-modified">1230                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-modified">1231                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-modified">1232                  * than traditional implementation of insertion sort.</span>
<span class="line-modified">1233                  */</span>
<span class="line-removed">1234                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-removed">1235                     short a1 = a[k], a2 = a[left];</span>
1236 
<span class="line-modified">1237                     if (a1 &lt; a2) {</span>
<span class="line-modified">1238                         a2 = a1; a1 = a[left];</span>
<span class="line-modified">1239                     }</span>
<span class="line-modified">1240                     while (a1 &lt; a[--k]) {</span>
<span class="line-removed">1241                         a[k + 2] = a[k];</span>
<span class="line-removed">1242                     }</span>
<span class="line-removed">1243                     a[++k + 1] = a1;</span>
1244 
<span class="line-modified">1245                     while (a2 &lt; a[--k]) {</span>
<span class="line-modified">1246                         a[k + 1] = a[k];</span>
<span class="line-modified">1247                     }</span>
<span class="line-modified">1248                     a[k + 1] = a2;</span>
<span class="line-removed">1249                 }</span>
<span class="line-removed">1250                 short last = a[right];</span>
1251 
<span class="line-modified">1252                 while (last &lt; a[--right]) {</span>
<span class="line-modified">1253                     a[right + 1] = a[right];</span>
<span class="line-removed">1254                 }</span>
<span class="line-removed">1255                 a[right + 1] = last;</span>
<span class="line-removed">1256             }</span>
<span class="line-removed">1257             return;</span>
<span class="line-removed">1258         }</span>
1259 
<span class="line-modified">1260         // Inexpensive approximation of length / 7</span>
<span class="line-removed">1261         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
1262 
<span class="line-modified">1263         /*</span>
<span class="line-modified">1264          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-removed">1265          * center element in the range. These elements will be used for</span>
<span class="line-removed">1266          * pivot selection as described below. The choice for spacing</span>
<span class="line-removed">1267          * these elements was empirically determined to work well on</span>
<span class="line-removed">1268          * a wide variety of inputs.</span>
<span class="line-removed">1269          */</span>
<span class="line-removed">1270         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-removed">1271         int e2 = e3 - seventh;</span>
<span class="line-removed">1272         int e1 = e2 - seventh;</span>
<span class="line-removed">1273         int e4 = e3 + seventh;</span>
<span class="line-removed">1274         int e5 = e4 + seventh;</span>
1275 
<span class="line-modified">1276         // Sort these elements using insertion sort</span>
<span class="line-modified">1277         if (a[e2] &lt; a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>




1278 
<span class="line-modified">1279         if (a[e3] &lt; a[e2]) { short t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified">1280             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">1281         }</span>
<span class="line-removed">1282         if (a[e4] &lt; a[e3]) { short t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-removed">1283             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">1284                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">1285             }</span>
<span class="line-removed">1286         }</span>
<span class="line-removed">1287         if (a[e5] &lt; a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-removed">1288             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-removed">1289                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">1290                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
1291                 }
1292             }
<span class="line-removed">1293         }</span>
<span class="line-removed">1294 </span>
<span class="line-removed">1295         // Pointers</span>
<span class="line-removed">1296         int less  = left;  // The index of the first element of center part</span>
<span class="line-removed">1297         int great = right; // The index before the first element of right part</span>
<span class="line-removed">1298 </span>
<span class="line-removed">1299         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
<span class="line-removed">1300             /*</span>
<span class="line-removed">1301              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-removed">1302              * These values are inexpensive approximations of the first and</span>
<span class="line-removed">1303              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="line-removed">1304              */</span>
<span class="line-removed">1305             short pivot1 = a[e2];</span>
<span class="line-removed">1306             short pivot2 = a[e4];</span>
<span class="line-removed">1307 </span>
<span class="line-removed">1308             /*</span>
<span class="line-removed">1309              * The first and the last elements to be sorted are moved to the</span>
<span class="line-removed">1310              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed">1311              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed">1312              * positions, and excluded from subsequent sorting.</span>
<span class="line-removed">1313              */</span>
<span class="line-removed">1314             a[e2] = a[left];</span>
<span class="line-removed">1315             a[e4] = a[right];</span>
1316 
1317             /*
<span class="line-modified">1318              * Skip elements, which are less or greater than pivot values.</span>
1319              */
<span class="line-modified">1320             while (a[++less] &lt; pivot1);</span>
<span class="line-modified">1321             while (a[--great] &gt; pivot2);</span>
1322 
<span class="line-removed">1323             /*</span>
<span class="line-removed">1324              * Partitioning:</span>
<span class="line-removed">1325              *</span>
<span class="line-removed">1326              *   left part           center part                   right part</span>
<span class="line-removed">1327              * +--------------------------------------------------------------+</span>
<span class="line-removed">1328              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-removed">1329              * +--------------------------------------------------------------+</span>
<span class="line-removed">1330              *               ^                          ^       ^</span>
<span class="line-removed">1331              *               |                          |       |</span>
<span class="line-removed">1332              *              less                        k     great</span>
<span class="line-removed">1333              *</span>
<span class="line-removed">1334              * Invariants:</span>
<span class="line-removed">1335              *</span>
<span class="line-removed">1336              *              all in (left, less)   &lt; pivot1</span>
<span class="line-removed">1337              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-removed">1338              *              all in (great, right) &gt; pivot2</span>
<span class="line-removed">1339              *</span>
<span class="line-removed">1340              * Pointer k is the first index of ?-part.</span>
<span class="line-removed">1341              */</span>
<span class="line-removed">1342             outer:</span>
<span class="line-removed">1343             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed">1344                 short ak = a[k];</span>
<span class="line-removed">1345                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-removed">1346                     a[k] = a[less];</span>
1347                     /*
<span class="line-modified">1348                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-modified">1349                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
1350                      */
<span class="line-modified">1351                     a[less] = ak;</span>
<span class="line-modified">1352                     ++less;</span>
<span class="line-modified">1353                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-modified">1354                     while (a[great] &gt; pivot2) {</span>
<span class="line-modified">1355                         if (great-- == k) {</span>
<span class="line-removed">1356                             break outer;</span>
<span class="line-removed">1357                         }</span>
<span class="line-removed">1358                     }</span>
<span class="line-removed">1359                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed">1360                         a[k] = a[less];</span>
<span class="line-removed">1361                         a[less] = a[great];</span>
<span class="line-removed">1362                         ++less;</span>
<span class="line-removed">1363                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed">1364                         a[k] = a[great];</span>
<span class="line-removed">1365                     }</span>
1366                     /*
<span class="line-modified">1367                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-modified">1368                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
1369                      */
<span class="line-modified">1370                     a[great] = ak;</span>
<span class="line-removed">1371                     --great;</span>
1372                 }
<span class="line-removed">1373             }</span>
1374 
<span class="line-modified">1375             // Swap pivots into their final positions</span>
<span class="line-modified">1376             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-removed">1377             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
1378 
<span class="line-modified">1379             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed">1380             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed">1381             sort(a, great + 2, right, false);</span>
1382 
<span class="line-modified">1383             /*</span>
<span class="line-removed">1384              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-removed">1385              * swap internal pivot values to ends.</span>
<span class="line-removed">1386              */</span>
<span class="line-removed">1387             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="line-removed">1388                 /*</span>
<span class="line-removed">1389                  * Skip elements, which are equal to pivot values.</span>
<span class="line-removed">1390                  */</span>
<span class="line-removed">1391                 while (a[less] == pivot1) {</span>
<span class="line-removed">1392                     ++less;</span>
<span class="line-removed">1393                 }</span>
1394 
<span class="line-modified">1395                 while (a[great] == pivot2) {</span>
<span class="line-modified">1396                     --great;</span>



1397                 }
1398 
<span class="line-modified">1399                 /*</span>
<span class="line-removed">1400                  * Partitioning:</span>
<span class="line-removed">1401                  *</span>
<span class="line-removed">1402                  *   left part         center part                  right part</span>
<span class="line-removed">1403                  * +----------------------------------------------------------+</span>
<span class="line-removed">1404                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-removed">1405                  * +----------------------------------------------------------+</span>
<span class="line-removed">1406                  *              ^                        ^       ^</span>
<span class="line-removed">1407                  *              |                        |       |</span>
<span class="line-removed">1408                  *             less                      k     great</span>
<span class="line-removed">1409                  *</span>
<span class="line-removed">1410                  * Invariants:</span>
<span class="line-removed">1411                  *</span>
<span class="line-removed">1412                  *              all in (*,  less) == pivot1</span>
<span class="line-removed">1413                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-removed">1414                  *              all in (great, *) == pivot2</span>
<span class="line-removed">1415                  *</span>
<span class="line-removed">1416                  * Pointer k is the first index of ?-part.</span>
<span class="line-removed">1417                  */</span>
<span class="line-removed">1418                 outer:</span>
<span class="line-removed">1419                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed">1420                     short ak = a[k];</span>
<span class="line-removed">1421                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-removed">1422                         a[k] = a[less];</span>
<span class="line-removed">1423                         a[less] = ak;</span>
<span class="line-removed">1424                         ++less;</span>
<span class="line-removed">1425                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-removed">1426                         while (a[great] == pivot2) {</span>
<span class="line-removed">1427                             if (great-- == k) {</span>
<span class="line-removed">1428                                 break outer;</span>
<span class="line-removed">1429                             }</span>
<span class="line-removed">1430                         }</span>
<span class="line-removed">1431                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed">1432                             a[k] = a[less];</span>
<span class="line-removed">1433                             /*</span>
<span class="line-removed">1434                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed">1435                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed">1436                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed">1437                              * of different signs. Therefore in float and</span>
<span class="line-removed">1438                              * double sorting methods we have to use more</span>
<span class="line-removed">1439                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed">1440                              */</span>
<span class="line-removed">1441                             a[less] = pivot1;</span>
<span class="line-removed">1442                             ++less;</span>
<span class="line-removed">1443                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed">1444                             a[k] = a[great];</span>
<span class="line-removed">1445                         }</span>
<span class="line-removed">1446                         a[great] = ak;</span>
<span class="line-removed">1447                         --great;</span>
<span class="line-removed">1448                     }</span>
<span class="line-removed">1449                 }</span>
<span class="line-removed">1450             }</span>
1451 
<span class="line-modified">1452             // Sort center part recursively</span>
<span class="line-modified">1453             sort(a, less, great, false);</span>



1454 
<span class="line-modified">1455         } else { // Partitioning with one pivot</span>
<span class="line-removed">1456             /*</span>
<span class="line-removed">1457              * Use the third of the five sorted elements as pivot.</span>
<span class="line-removed">1458              * This value is inexpensive approximation of the median.</span>
<span class="line-removed">1459              */</span>
<span class="line-removed">1460             short pivot = a[e3];</span>
1461 
<span class="line-modified">1462             /*</span>
<span class="line-modified">1463              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-modified">1464              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-modified">1465              *</span>
<span class="line-removed">1466              *   left part    center part              right part</span>
<span class="line-removed">1467              * +-------------------------------------------------+</span>
<span class="line-removed">1468              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed">1469              * +-------------------------------------------------+</span>
<span class="line-removed">1470              *              ^              ^        ^</span>
<span class="line-removed">1471              *              |              |        |</span>
<span class="line-removed">1472              *             less            k      great</span>
<span class="line-removed">1473              *</span>
<span class="line-removed">1474              * Invariants:</span>
<span class="line-removed">1475              *</span>
<span class="line-removed">1476              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed">1477              *   all in [less, k)     == pivot</span>
<span class="line-removed">1478              *   all in (great, right) &gt; pivot</span>
<span class="line-removed">1479              *</span>
<span class="line-removed">1480              * Pointer k is the first index of ?-part.</span>
<span class="line-removed">1481              */</span>
<span class="line-removed">1482             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed">1483                 if (a[k] == pivot) {</span>
<span class="line-removed">1484                     continue;</span>
<span class="line-removed">1485                 }</span>
<span class="line-removed">1486                 short ak = a[k];</span>
<span class="line-removed">1487                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed">1488                     a[k] = a[less];</span>
<span class="line-removed">1489                     a[less] = ak;</span>
<span class="line-removed">1490                     ++less;</span>
<span class="line-removed">1491                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed">1492                     while (a[great] &gt; pivot) {</span>
<span class="line-removed">1493                         --great;</span>
<span class="line-removed">1494                     }</span>
<span class="line-removed">1495                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-removed">1496                         a[k] = a[less];</span>
<span class="line-removed">1497                         a[less] = a[great];</span>
<span class="line-removed">1498                         ++less;</span>
<span class="line-removed">1499                     } else { // a[great] == pivot</span>
<span class="line-removed">1500                         /*</span>
<span class="line-removed">1501                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed">1502                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed">1503                          * if a[great] and pivot are floating-point</span>
<span class="line-removed">1504                          * zeros of different signs. Therefore in float</span>
<span class="line-removed">1505                          * and double sorting methods we have to use</span>
<span class="line-removed">1506                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed">1507                          */</span>
<span class="line-removed">1508                         a[k] = pivot;</span>
<span class="line-removed">1509                     }</span>
<span class="line-removed">1510                     a[great] = ak;</span>
<span class="line-removed">1511                     --great;</span>
1512                 }
1513             }
<span class="line-modified">1514 </span>
<span class="line-removed">1515             /*</span>
<span class="line-removed">1516              * Sort left and right parts recursively.</span>
<span class="line-removed">1517              * All elements from center part are equal</span>
<span class="line-removed">1518              * and, therefore, already sorted.</span>
<span class="line-removed">1519              */</span>
<span class="line-removed">1520             sort(a, left, less - 1, leftmost);</span>
<span class="line-removed">1521             sort(a, great + 1, right, false);</span>
1522         }
<span class="line-removed">1523     }</span>
1524 
<span class="line-modified">1525     /**</span>
<span class="line-modified">1526      * Sorts the specified range of the array using the given</span>
<span class="line-modified">1527      * workspace array slice if possible for merging</span>
<span class="line-modified">1528      *</span>
<span class="line-modified">1529      * @param a the array to be sorted</span>
<span class="line-removed">1530      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-removed">1531      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-removed">1532      * @param work a workspace array (slice)</span>
<span class="line-removed">1533      * @param workBase origin of usable space in work array</span>
<span class="line-removed">1534      * @param workLen usable size of work array</span>
<span class="line-removed">1535      */</span>
<span class="line-removed">1536     static void sort(char[] a, int left, int right,</span>
<span class="line-removed">1537                      char[] work, int workBase, int workLen) {</span>
<span class="line-removed">1538         // Use counting sort on large arrays</span>
<span class="line-removed">1539         if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR) {</span>
<span class="line-removed">1540             int[] count = new int[NUM_CHAR_VALUES];</span>
<span class="line-removed">1541 </span>
<span class="line-removed">1542             for (int i = left - 1; ++i &lt;= right;</span>
<span class="line-removed">1543                 count[a[i]]++</span>
<span class="line-removed">1544             );</span>
<span class="line-removed">1545             for (int i = NUM_CHAR_VALUES, k = right + 1; k &gt; left; ) {</span>
<span class="line-removed">1546                 while (count[--i] == 0);</span>
<span class="line-removed">1547                 char value = (char) i;</span>
<span class="line-removed">1548                 int s = count[i];</span>
1549 
<span class="line-modified">1550                 do {</span>
<span class="line-modified">1551                     a[--k] = value;</span>
<span class="line-modified">1552                 } while (--s &gt; 0);</span>

1553             }
<span class="line-modified">1554         } else { // Use Dual-Pivot Quicksort on small arrays</span>
<span class="line-removed">1555             doSort(a, left, right, work, workBase, workLen);</span>
1556         }

1557     }
1558 
<span class="line-removed">1559     /** The number of distinct char values. */</span>
<span class="line-removed">1560     private static final int NUM_CHAR_VALUES = 1 &lt;&lt; 16;</span>
<span class="line-removed">1561 </span>
1562     /**
<span class="line-modified">1563      * Sorts the specified range of the array.</span>
1564      *
<span class="line-modified">1565      * @param a the array to be sorted</span>
<span class="line-modified">1566      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1567      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1568      * @param work a workspace array (slice)</span>
<span class="line-modified">1569      * @param workBase origin of usable space in work array</span>
<span class="line-modified">1570      * @param workLen usable size of work array</span>
<span class="line-modified">1571      */</span>
<span class="line-modified">1572     private static void doSort(char[] a, int left, int right,</span>
<span class="line-modified">1573                                char[] work, int workBase, int workLen) {</span>
<span class="line-modified">1574         // Use Quicksort on small arrays</span>
<span class="line-modified">1575         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-modified">1576             sort(a, left, right, true);</span>
<span class="line-modified">1577             return;</span>








1578         }
1579 
1580         /*
<span class="line-modified">1581          * Index run[i] is the start of i-th run</span>
<span class="line-removed">1582          * (ascending or descending sequence).</span>
1583          */
<span class="line-modified">1584         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-modified">1585         int count = 0; run[0] = left;</span>
<span class="line-removed">1586 </span>
<span class="line-removed">1587         // Check if the array is nearly sorted</span>
<span class="line-removed">1588         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-removed">1589             // Equal items in the beginning of the sequence</span>
<span class="line-removed">1590             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed">1591                 k++;</span>
<span class="line-removed">1592             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed">1593             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed">1594                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed">1595             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed">1596                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed">1597                 // Transform into an ascending sequence</span>
<span class="line-removed">1598                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed">1599                     char t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed">1600                 }</span>
<span class="line-removed">1601             }</span>
1602 
<span class="line-modified">1603             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified">1604             // ascending sequence</span>
<span class="line-modified">1605             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified">1606                 count--;</span>
<span class="line-removed">1607             }</span>
1608 
<span class="line-modified">1609             /*</span>
<span class="line-modified">1610              * The array is not highly structured,</span>
<span class="line-modified">1611              * use Quicksort instead of merge sort.</span>
<span class="line-modified">1612              */</span>
<span class="line-modified">1613             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-modified">1614                 sort(a, left, right, true);</span>
<span class="line-modified">1615                 return;</span>
<span class="line-removed">1616             }</span>
1617         }
1618 
<span class="line-modified">1619         // These invariants should hold true:</span>
<span class="line-removed">1620         //    run[0] = 0</span>
<span class="line-removed">1621         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
1622 
<span class="line-modified">1623         if (count == 0) {</span>
<span class="line-modified">1624             // A single equal run</span>
<span class="line-modified">1625             return;</span>
<span class="line-modified">1626         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-modified">1627             // Either a single ascending or a transformed descending run.</span>
<span class="line-modified">1628             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-modified">1629             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-modified">1630             return;</span>
<span class="line-removed">1631         }</span>
<span class="line-removed">1632         right++;</span>
<span class="line-removed">1633         if (run[count] &lt; right) {</span>
<span class="line-removed">1634             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed">1635             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed">1636             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed">1637             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed">1638             run[++count] = right;</span>
<span class="line-removed">1639         }</span>
<span class="line-removed">1640 </span>
<span class="line-removed">1641         // Determine alternation base for merge</span>
<span class="line-removed">1642         byte odd = 0;</span>
<span class="line-removed">1643         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed">1644 </span>
<span class="line-removed">1645         // Use or create temporary array b for merging</span>
<span class="line-removed">1646         char[] b;                 // temp array; alternates with a</span>
<span class="line-removed">1647         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed">1648         int blen = right - left; // space needed for b</span>
<span class="line-removed">1649         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed">1650             work = new char[blen];</span>
<span class="line-removed">1651             workBase = 0;</span>
<span class="line-removed">1652         }</span>
<span class="line-removed">1653         if (odd == 0) {</span>
<span class="line-removed">1654             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed">1655             b = a;</span>
<span class="line-removed">1656             bo = 0;</span>
<span class="line-removed">1657             a = work;</span>
<span class="line-removed">1658             ao = workBase - left;</span>
1659         } else {
<span class="line-modified">1660             b = work;</span>
<span class="line-removed">1661             ao = 0;</span>
<span class="line-removed">1662             bo = workBase - left;</span>
<span class="line-removed">1663         }</span>
<span class="line-removed">1664 </span>
<span class="line-removed">1665         // Merging</span>
<span class="line-removed">1666         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed">1667             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed">1668                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed">1669                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed">1670                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed">1671                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed">1672                     } else {</span>
<span class="line-removed">1673                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed">1674                     }</span>
<span class="line-removed">1675                 }</span>
<span class="line-removed">1676                 run[++last] = hi;</span>
<span class="line-removed">1677             }</span>
<span class="line-removed">1678             if ((count &amp; 1) != 0) {</span>
<span class="line-removed">1679                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed">1680                     b[i + bo] = a[i + ao]</span>
<span class="line-removed">1681                 );</span>
<span class="line-removed">1682                 run[++last] = right;</span>
<span class="line-removed">1683             }</span>
<span class="line-removed">1684             char[] t = a; a = b; b = t;</span>
<span class="line-removed">1685             int o = ao; ao = bo; bo = o;</span>
1686         }

1687     }
1688 
1689     /**
<span class="line-modified">1690      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
1691      *
<span class="line-modified">1692      * @param a the array to be sorted</span>
<span class="line-modified">1693      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1694      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">1695      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified">1696      */</span>
<span class="line-modified">1697     private static void sort(char[] a, int left, int right, boolean leftmost) {</span>
<span class="line-modified">1698         int length = right - left + 1;</span>
<span class="line-modified">1699 </span>
<span class="line-modified">1700         // Use insertion sort on tiny arrays</span>
<span class="line-modified">1701         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-modified">1702             if (leftmost) {</span>
<span class="line-modified">1703                 /*</span>
<span class="line-modified">1704                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-modified">1705                  * optimized for server VM, is used in case of</span>
<span class="line-modified">1706                  * the leftmost part.</span>
<span class="line-modified">1707                  */</span>
<span class="line-modified">1708                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-modified">1709                     char ai = a[i + 1];</span>
<span class="line-modified">1710                     while (ai &lt; a[j]) {</span>
<span class="line-modified">1711                         a[j + 1] = a[j];</span>
<span class="line-modified">1712                         if (j-- == left) {</span>
<span class="line-modified">1713                             break;</span>
<span class="line-modified">1714                         }</span>
<span class="line-removed">1715                     }</span>
<span class="line-removed">1716                     a[j + 1] = ai;</span>
1717                 }
<span class="line-modified">1718             } else {</span>
1719                 /*
<span class="line-modified">1720                  * Skip the longest ascending sequence.</span>
1721                  */
<span class="line-modified">1722                 do {</span>
<span class="line-modified">1723                     if (left &gt;= right) {</span>
<span class="line-modified">1724                         return;</span>
<span class="line-removed">1725                     }</span>
<span class="line-removed">1726                 } while (a[++left] &gt;= a[left - 1]);</span>
1727 
1728                 /*
<span class="line-modified">1729                  * Every element from adjoining part plays the role</span>
<span class="line-removed">1730                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-removed">1731                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed">1732                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed">1733                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed">1734                  * than traditional implementation of insertion sort.</span>
1735                  */
<span class="line-modified">1736                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-modified">1737                     char a1 = a[k], a2 = a[left];</span>

1738 
<span class="line-modified">1739                     if (a1 &lt; a2) {</span>
<span class="line-modified">1740                         a2 = a1; a1 = a[left];</span>
<span class="line-modified">1741                     }</span>
<span class="line-modified">1742                     while (a1 &lt; a[--k]) {</span>
<span class="line-modified">1743                         a[k + 2] = a[k];</span>
<span class="line-removed">1744                     }</span>
<span class="line-removed">1745                     a[++k + 1] = a1;</span>
1746 
<span class="line-modified">1747                     while (a2 &lt; a[--k]) {</span>
<span class="line-modified">1748                         a[k + 1] = a[k];</span>


1749                     }
<span class="line-removed">1750                     a[k + 1] = a2;</span>
1751                 }
<span class="line-removed">1752                 char last = a[right];</span>
1753 
<span class="line-modified">1754                 while (last &lt; a[--right]) {</span>
<span class="line-modified">1755                     a[right + 1] = a[right];</span>
<span class="line-modified">1756                 }</span>
<span class="line-modified">1757                 a[right + 1] = last;</span>








1758             }
<span class="line-removed">1759             return;</span>
1760         }
1761 
<span class="line-removed">1762         // Inexpensive approximation of length / 7</span>
<span class="line-removed">1763         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-removed">1764 </span>
1765         /*
<span class="line-modified">1766          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-removed">1767          * center element in the range. These elements will be used for</span>
<span class="line-removed">1768          * pivot selection as described below. The choice for spacing</span>
<span class="line-removed">1769          * these elements was empirically determined to work well on</span>
<span class="line-removed">1770          * a wide variety of inputs.</span>
1771          */
<span class="line-modified">1772         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified">1773         int e2 = e3 - seventh;</span>
<span class="line-removed">1774         int e1 = e2 - seventh;</span>
<span class="line-removed">1775         int e4 = e3 + seventh;</span>
<span class="line-removed">1776         int e5 = e4 + seventh;</span>
<span class="line-removed">1777 </span>
<span class="line-removed">1778         // Sort these elements using insertion sort</span>
<span class="line-removed">1779         if (a[e2] &lt; a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">1780 </span>
<span class="line-removed">1781         if (a[e3] &lt; a[e2]) { char t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">1782             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
1783         }
<span class="line-modified">1784         if (a[e4] &lt; a[e3]) { char t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">1785             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified">1786                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
1787             }
1788         }
<span class="line-modified">1789         if (a[e5] &lt; a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-modified">1790             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">1791                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">1792                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">1793                 }</span>
1794             }
1795         }






























1796 
<span class="line-modified">1797         // Pointers</span>
<span class="line-modified">1798         int less  = left;  // The index of the first element of center part</span>
<span class="line-modified">1799         int great = right; // The index before the first element of right part</span>











1800 
<span class="line-removed">1801         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
1802             /*
<span class="line-modified">1803              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-removed">1804              * These values are inexpensive approximations of the first and</span>
<span class="line-removed">1805              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
1806              */
<span class="line-modified">1807             char pivot1 = a[e2];</span>
<span class="line-modified">1808             char pivot2 = a[e4];</span>


1809 
1810             /*
<span class="line-modified">1811              * The first and the last elements to be sorted are moved to the</span>
<span class="line-removed">1812              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed">1813              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed">1814              * positions, and excluded from subsequent sorting.</span>
1815              */
<span class="line-modified">1816             a[e2] = a[left];</span>
<span class="line-modified">1817             a[e4] = a[right];</span>


1818 
1819             /*
<span class="line-modified">1820              * Skip elements, which are less or greater than pivot values.</span>

1821              */
<span class="line-modified">1822             while (a[++less] &lt; pivot1);</span>
<span class="line-modified">1823             while (a[--great] &gt; pivot2);</span>


1824 
1825             /*
<span class="line-modified">1826              * Partitioning:</span>
<span class="line-modified">1827              *</span>
<span class="line-removed">1828              *   left part           center part                   right part</span>
<span class="line-removed">1829              * +--------------------------------------------------------------+</span>
<span class="line-removed">1830              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-removed">1831              * +--------------------------------------------------------------+</span>
<span class="line-removed">1832              *               ^                          ^       ^</span>
<span class="line-removed">1833              *               |                          |       |</span>
<span class="line-removed">1834              *              less                        k     great</span>
<span class="line-removed">1835              *</span>
<span class="line-removed">1836              * Invariants:</span>
<span class="line-removed">1837              *</span>
<span class="line-removed">1838              *              all in (left, less)   &lt; pivot1</span>
<span class="line-removed">1839              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-removed">1840              *              all in (great, right) &gt; pivot2</span>
<span class="line-removed">1841              *</span>
<span class="line-removed">1842              * Pointer k is the first index of ?-part.</span>
1843              */
<span class="line-modified">1844             outer:</span>
<span class="line-modified">1845             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified">1846                 char ak = a[k];</span>
<span class="line-removed">1847                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-removed">1848                     a[k] = a[less];</span>
<span class="line-removed">1849                     /*</span>
<span class="line-removed">1850                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-removed">1851                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="line-removed">1852                      */</span>
<span class="line-removed">1853                     a[less] = ak;</span>
<span class="line-removed">1854                     ++less;</span>
<span class="line-removed">1855                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-removed">1856                     while (a[great] &gt; pivot2) {</span>
<span class="line-removed">1857                         if (great-- == k) {</span>
<span class="line-removed">1858                             break outer;</span>
<span class="line-removed">1859                         }</span>
<span class="line-removed">1860                     }</span>
<span class="line-removed">1861                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed">1862                         a[k] = a[less];</span>
<span class="line-removed">1863                         a[less] = a[great];</span>
<span class="line-removed">1864                         ++less;</span>
<span class="line-removed">1865                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed">1866                         a[k] = a[great];</span>
<span class="line-removed">1867                     }</span>
<span class="line-removed">1868                     /*</span>
<span class="line-removed">1869                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed">1870                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="line-removed">1871                      */</span>
<span class="line-removed">1872                     a[great] = ak;</span>
<span class="line-removed">1873                     --great;</span>
<span class="line-removed">1874                 }</span>
1875             }
1876 
<span class="line-modified">1877             // Swap pivots into their final positions</span>
<span class="line-modified">1878             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-modified">1879             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-modified">1880 </span>
<span class="line-modified">1881             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed">1882             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed">1883             sort(a, great + 2, right, false);</span>
1884 
1885             /*
<span class="line-modified">1886              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-modified">1887              * swap internal pivot values to ends.</span>


1888              */
<span class="line-modified">1889             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="line-modified">1890                 /*</span>
<span class="line-modified">1891                  * Skip elements, which are equal to pivot values.</span>



























































1892                  */
<span class="line-modified">1893                 while (a[less] == pivot1) {</span>
<span class="line-modified">1894                     ++less;</span>














































1895                 }
1896 
<span class="line-modified">1897                 while (a[great] == pivot2) {</span>
<span class="line-modified">1898                     --great;</span>














1899                 }
1900 

















1901                 /*
<span class="line-modified">1902                  * Partitioning:</span>
1903                  *
<span class="line-modified">1904                  *   left part         center part                  right part</span>
<span class="line-modified">1905                  * +----------------------------------------------------------+</span>
<span class="line-modified">1906                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-modified">1907                  * +----------------------------------------------------------+</span>
<span class="line-modified">1908                  *              ^                        ^       ^</span>
<span class="line-modified">1909                  *              |                        |       |</span>
<span class="line-modified">1910                  *             less                      k     great</span>
1911                  *
1912                  * Invariants:
1913                  *
<span class="line-modified">1914                  *              all in (*,  less) == pivot1</span>
<span class="line-modified">1915                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-modified">1916                  *              all in (great, *) == pivot2</span>
1917                  *
<span class="line-modified">1918                  * Pointer k is the first index of ?-part.</span>
1919                  */
<span class="line-modified">1920                 outer:</span>
<span class="line-modified">1921                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified">1922                     char ak = a[k];</span>
<span class="line-modified">1923                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-modified">1924                         a[k] = a[less];</span>
<span class="line-modified">1925                         a[less] = ak;</span>
<span class="line-modified">1926                         ++less;</span>
<span class="line-modified">1927                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-modified">1928                         while (a[great] == pivot2) {</span>
<span class="line-modified">1929                             if (great-- == k) {</span>
<span class="line-modified">1930                                 break outer;</span>
1931                             }



1932                         }
<span class="line-removed">1933                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed">1934                             a[k] = a[less];</span>
<span class="line-removed">1935                             /*</span>
<span class="line-removed">1936                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed">1937                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed">1938                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed">1939                              * of different signs. Therefore in float and</span>
<span class="line-removed">1940                              * double sorting methods we have to use more</span>
<span class="line-removed">1941                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed">1942                              */</span>
<span class="line-removed">1943                             a[less] = pivot1;</span>
<span class="line-removed">1944                             ++less;</span>
<span class="line-removed">1945                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed">1946                             a[k] = a[great];</span>
<span class="line-removed">1947                         }</span>
<span class="line-removed">1948                         a[great] = ak;</span>
<span class="line-removed">1949                         --great;</span>
1950                     }
1951                 }
















1952             }



1953 
<span class="line-modified">1954             // Sort center part recursively</span>
<span class="line-modified">1955             sort(a, less, great, false);</span>

















1956 
<span class="line-removed">1957         } else { // Partitioning with one pivot</span>
1958             /*
<span class="line-modified">1959              * Use the third of the five sorted elements as pivot.</span>
<span class="line-removed">1960              * This value is inexpensive approximation of the median.</span>
1961              */
<span class="line-modified">1962             char pivot = a[e3];</span>








1963 
1964             /*
<span class="line-modified">1965              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-removed">1966              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-removed">1967              *</span>
<span class="line-removed">1968              *   left part    center part              right part</span>
<span class="line-removed">1969              * +-------------------------------------------------+</span>
<span class="line-removed">1970              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed">1971              * +-------------------------------------------------+</span>
<span class="line-removed">1972              *              ^              ^        ^</span>
<span class="line-removed">1973              *              |              |        |</span>
<span class="line-removed">1974              *             less            k      great</span>
<span class="line-removed">1975              *</span>
<span class="line-removed">1976              * Invariants:</span>
1977              *
<span class="line-modified">1978              *   all in (left, less)   &lt; pivot</span>
<span class="line-modified">1979              *   all in [less, k)     == pivot</span>
<span class="line-modified">1980              *   all in (great, right) &gt; pivot</span>
<span class="line-modified">1981              *</span>
<span class="line-modified">1982              * Pointer k is the first index of ?-part.</span>
1983              */
<span class="line-modified">1984             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-modified">1985                 if (a[k] == pivot) {</span>
<span class="line-modified">1986                     continue;</span>
<span class="line-modified">1987                 }</span>
<span class="line-modified">1988                 char ak = a[k];</span>
<span class="line-modified">1989                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-modified">1990                     a[k] = a[less];</span>
<span class="line-modified">1991                     a[less] = ak;</span>
<span class="line-modified">1992                     ++less;</span>
<span class="line-modified">1993                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-modified">1994                     while (a[great] &gt; pivot) {</span>
<span class="line-modified">1995                         --great;</span>


1996                     }
<span class="line-modified">1997                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-modified">1998                         a[k] = a[less];</span>
<span class="line-modified">1999                         a[less] = a[great];</span>
<span class="line-modified">2000                         ++less;</span>
<span class="line-modified">2001                     } else { // a[great] == pivot</span>
<span class="line-modified">2002                         /*</span>
<span class="line-modified">2003                          * Even though a[great] equals to pivot, the</span>
<span class="line-modified">2004                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-modified">2005                          * if a[great] and pivot are floating-point</span>
<span class="line-modified">2006                          * zeros of different signs. Therefore in float</span>
<span class="line-modified">2007                          * and double sorting methods we have to use</span>
<span class="line-modified">2008                          * more accurate assignment a[k] = a[great].</span>
<span class="line-modified">2009                          */</span>
<span class="line-modified">2010                         a[k] = pivot;</span>








2011                     }
<span class="line-modified">2012                     a[great] = ak;</span>
<span class="line-removed">2013                     --great;</span>
2014                 }
2015             }
2016 
2017             /*
<span class="line-modified">2018              * Sort left and right parts recursively.</span>
<span class="line-removed">2019              * All elements from center part are equal</span>
<span class="line-removed">2020              * and, therefore, already sorted.</span>
2021              */
<span class="line-modified">2022             sort(a, left, less - 1, leftmost);</span>
<span class="line-modified">2023             sort(a, great + 1, right, false);</span>































2024         }
2025     }
2026 
<span class="line-removed">2027     /** The number of distinct byte values. */</span>
<span class="line-removed">2028     private static final int NUM_BYTE_VALUES = 1 &lt;&lt; 8;</span>
<span class="line-removed">2029 </span>
2030     /**
<span class="line-modified">2031      * Sorts the specified range of the array.</span>
2032      *
2033      * @param a the array to be sorted
<span class="line-modified">2034      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2035      * @param right the index of the last element, inclusive, to be sorted</span>
2036      */
<span class="line-modified">2037     static void sort(byte[] a, int left, int right) {</span>
<span class="line-modified">2038         // Use counting sort on large arrays</span>
<span class="line-modified">2039         if (right - left &gt; COUNTING_SORT_THRESHOLD_FOR_BYTE) {</span>
<span class="line-removed">2040             int[] count = new int[NUM_BYTE_VALUES];</span>
<span class="line-removed">2041 </span>
<span class="line-removed">2042             for (int i = left - 1; ++i &lt;= right;</span>
<span class="line-removed">2043                 count[a[i] - Byte.MIN_VALUE]++</span>
<span class="line-removed">2044             );</span>
<span class="line-removed">2045             for (int i = NUM_BYTE_VALUES, k = right + 1; k &gt; left; ) {</span>
<span class="line-removed">2046                 while (count[--i] == 0);</span>
<span class="line-removed">2047                 byte value = (byte) (i + Byte.MIN_VALUE);</span>
<span class="line-removed">2048                 int s = count[i];</span>
2049 
<span class="line-modified">2050                 do {</span>
<span class="line-modified">2051                     a[--k] = value;</span>
<span class="line-modified">2052                 } while (--s &gt; 0);</span>
<span class="line-removed">2053             }</span>
<span class="line-removed">2054         } else { // Use insertion sort on small arrays</span>
<span class="line-removed">2055             for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-removed">2056                 byte ai = a[i + 1];</span>
<span class="line-removed">2057                 while (ai &lt; a[j]) {</span>
<span class="line-removed">2058                     a[j + 1] = a[j];</span>
<span class="line-removed">2059                     if (j-- == left) {</span>
<span class="line-removed">2060                         break;</span>
<span class="line-removed">2061                     }</span>
2062                 }
<span class="line-modified">2063                 a[j + 1] = ai;</span>
2064             }
2065         }
2066     }
2067 
2068     /**
<span class="line-modified">2069      * Sorts the specified range of the array using the given</span>
<span class="line-removed">2070      * workspace array slice if possible for merging</span>
2071      *
2072      * @param a the array to be sorted
<span class="line-modified">2073      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2074      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2075      * @param work a workspace array (slice)</span>
<span class="line-modified">2076      * @param workBase origin of usable space in work array</span>
<span class="line-modified">2077      * @param workLen usable size of work array</span>
<span class="line-modified">2078      */</span>
<span class="line-modified">2079     static void sort(float[] a, int left, int right,</span>
<span class="line-modified">2080                      float[] work, int workBase, int workLen) {</span>
<span class="line-modified">2081         /*</span>
<span class="line-modified">2082          * Phase 1: Move NaNs to the end of the array.</span>
<span class="line-modified">2083          */</span>
<span class="line-removed">2084         while (left &lt;= right &amp;&amp; Float.isNaN(a[right])) {</span>
<span class="line-removed">2085             --right;</span>
2086         }
<span class="line-modified">2087         for (int k = right; --k &gt;= left; ) {</span>
<span class="line-modified">2088             float ak = a[k];</span>
<span class="line-modified">2089             if (ak != ak) { // a[k] is NaN</span>
<span class="line-modified">2090                 a[k] = a[right];</span>
<span class="line-modified">2091                 a[right] = ak;</span>
<span class="line-modified">2092                 --right;</span>

















2093             }
2094         }


2095 
<span class="line-modified">2096         /*</span>
<span class="line-modified">2097          * Phase 2: Sort everything except NaNs (which are already in place).</span>
<span class="line-modified">2098          */</span>
<span class="line-modified">2099         doSort(a, left, right, work, workBase, workLen);</span>






2100 
2101         /*
<span class="line-modified">2102          * Phase 3: Place negative zeros before positive zeros.</span>


2103          */
<span class="line-modified">2104         int hi = right;</span>


2105 
2106         /*
<span class="line-modified">2107          * Find the first zero, or first positive, or last negative element.</span>
2108          */
<span class="line-modified">2109         while (left &lt; hi) {</span>
<span class="line-removed">2110             int middle = (left + hi) &gt;&gt;&gt; 1;</span>
<span class="line-removed">2111             float middleValue = a[middle];</span>
2112 
<span class="line-modified">2113             if (middleValue &lt; 0.0f) {</span>
<span class="line-modified">2114                 left = middle + 1;</span>
<span class="line-modified">2115             } else {</span>
<span class="line-modified">2116                 hi = middle;</span>



















2117             }
<span class="line-removed">2118         }</span>
2119 
<span class="line-modified">2120         /*</span>
<span class="line-modified">2121          * Skip the last negative value (if any) or all leading negative zeros.</span>
<span class="line-modified">2122          */</span>
<span class="line-modified">2123         while (left &lt;= right &amp;&amp; Float.floatToRawIntBits(a[left]) &lt; 0) {</span>
<span class="line-modified">2124             ++left;</span>
















































2125         }
2126 
2127         /*
<span class="line-modified">2128          * Move negative zeros to the beginning of the sub-range.</span>
<span class="line-removed">2129          *</span>
<span class="line-removed">2130          * Partitioning:</span>
<span class="line-removed">2131          *</span>
<span class="line-removed">2132          * +----------------------------------------------------+</span>
<span class="line-removed">2133          * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span>
<span class="line-removed">2134          * +----------------------------------------------------+</span>
<span class="line-removed">2135          *              ^          ^         ^</span>
<span class="line-removed">2136          *              |          |         |</span>
<span class="line-removed">2137          *             left        p         k</span>
<span class="line-removed">2138          *</span>
<span class="line-removed">2139          * Invariants:</span>
<span class="line-removed">2140          *</span>
<span class="line-removed">2141          *   all in (*,  left)  &lt;  0.0</span>
<span class="line-removed">2142          *   all in [left,  p) == -0.0</span>
<span class="line-removed">2143          *   all in [p,     k) ==  0.0</span>
<span class="line-removed">2144          *   all in [k, right] &gt;=  0.0</span>
<span class="line-removed">2145          *</span>
<span class="line-removed">2146          * Pointer k is the first index of ?-part.</span>
2147          */
<span class="line-modified">2148         for (int k = left, p = left - 1; ++k &lt;= right; ) {</span>
<span class="line-modified">2149             float ak = a[k];</span>
<span class="line-modified">2150             if (ak != 0.0f) {</span>
<span class="line-modified">2151                 break;</span>
<span class="line-modified">2152             }</span>
<span class="line-modified">2153             if (Float.floatToRawIntBits(ak) &lt; 0) { // ak is -0.0f</span>
<span class="line-modified">2154                 a[k] = 0.0f;</span>
<span class="line-removed">2155                 a[++p] = -0.0f;</span>
2156             }

2157         }

2158     }
2159 
2160     /**
<span class="line-modified">2161      * Sorts the specified range of the array.</span>
2162      *
<span class="line-modified">2163      * @param a the array to be sorted</span>
<span class="line-modified">2164      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2165      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2166      * @param work a workspace array (slice)</span>
<span class="line-modified">2167      * @param workBase origin of usable space in work array</span>
<span class="line-modified">2168      * @param workLen usable size of work array</span>
<span class="line-modified">2169      */</span>
<span class="line-modified">2170     private static void doSort(float[] a, int left, int right,</span>
<span class="line-modified">2171                                float[] work, int workBase, int workLen) {</span>
<span class="line-modified">2172         // Use Quicksort on small arrays</span>
<span class="line-modified">2173         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-modified">2174             sort(a, left, right, true);</span>
<span class="line-modified">2175             return;</span>








2176         }
2177 
2178         /*
<span class="line-modified">2179          * Index run[i] is the start of i-th run</span>
<span class="line-removed">2180          * (ascending or descending sequence).</span>
2181          */
<span class="line-modified">2182         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-modified">2183         int count = 0; run[0] = left;</span>
<span class="line-removed">2184 </span>
<span class="line-removed">2185         // Check if the array is nearly sorted</span>
<span class="line-removed">2186         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-removed">2187             // Equal items in the beginning of the sequence</span>
<span class="line-removed">2188             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed">2189                 k++;</span>
<span class="line-removed">2190             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed">2191             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed">2192                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed">2193             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed">2194                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed">2195                 // Transform into an ascending sequence</span>
<span class="line-removed">2196                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed">2197                     float t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed">2198                 }</span>
<span class="line-removed">2199             }</span>
2200 
<span class="line-modified">2201             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified">2202             // ascending sequence</span>
<span class="line-modified">2203             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified">2204                 count--;</span>
<span class="line-removed">2205             }</span>
2206 
<span class="line-modified">2207             /*</span>
<span class="line-modified">2208              * The array is not highly structured,</span>
<span class="line-modified">2209              * use Quicksort instead of merge sort.</span>
<span class="line-modified">2210              */</span>
<span class="line-modified">2211             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-modified">2212                 sort(a, left, right, true);</span>
<span class="line-modified">2213                 return;</span>
<span class="line-removed">2214             }</span>
2215         }
2216 
<span class="line-modified">2217         // These invariants should hold true:</span>
<span class="line-removed">2218         //    run[0] = 0</span>
<span class="line-removed">2219         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
2220 
<span class="line-modified">2221         if (count == 0) {</span>
<span class="line-modified">2222             // A single equal run</span>
<span class="line-modified">2223             return;</span>
<span class="line-modified">2224         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-modified">2225             // Either a single ascending or a transformed descending run.</span>
<span class="line-modified">2226             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-modified">2227             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-modified">2228             return;</span>
<span class="line-removed">2229         }</span>
<span class="line-removed">2230         right++;</span>
<span class="line-removed">2231         if (run[count] &lt; right) {</span>
<span class="line-removed">2232             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed">2233             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed">2234             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed">2235             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed">2236             run[++count] = right;</span>
<span class="line-removed">2237         }</span>
<span class="line-removed">2238 </span>
<span class="line-removed">2239         // Determine alternation base for merge</span>
<span class="line-removed">2240         byte odd = 0;</span>
<span class="line-removed">2241         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed">2242 </span>
<span class="line-removed">2243         // Use or create temporary array b for merging</span>
<span class="line-removed">2244         float[] b;                 // temp array; alternates with a</span>
<span class="line-removed">2245         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed">2246         int blen = right - left; // space needed for b</span>
<span class="line-removed">2247         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed">2248             work = new float[blen];</span>
<span class="line-removed">2249             workBase = 0;</span>
<span class="line-removed">2250         }</span>
<span class="line-removed">2251         if (odd == 0) {</span>
<span class="line-removed">2252             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed">2253             b = a;</span>
<span class="line-removed">2254             bo = 0;</span>
<span class="line-removed">2255             a = work;</span>
<span class="line-removed">2256             ao = workBase - left;</span>
2257         } else {
<span class="line-modified">2258             b = work;</span>
<span class="line-removed">2259             ao = 0;</span>
<span class="line-removed">2260             bo = workBase - left;</span>
<span class="line-removed">2261         }</span>
<span class="line-removed">2262 </span>
<span class="line-removed">2263         // Merging</span>
<span class="line-removed">2264         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed">2265             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed">2266                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed">2267                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed">2268                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed">2269                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed">2270                     } else {</span>
<span class="line-removed">2271                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed">2272                     }</span>
<span class="line-removed">2273                 }</span>
<span class="line-removed">2274                 run[++last] = hi;</span>
<span class="line-removed">2275             }</span>
<span class="line-removed">2276             if ((count &amp; 1) != 0) {</span>
<span class="line-removed">2277                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed">2278                     b[i + bo] = a[i + ao]</span>
<span class="line-removed">2279                 );</span>
<span class="line-removed">2280                 run[++last] = right;</span>
<span class="line-removed">2281             }</span>
<span class="line-removed">2282             float[] t = a; a = b; b = t;</span>
<span class="line-removed">2283             int o = ao; ao = bo; bo = o;</span>
2284         }

2285     }
2286 
2287     /**
<span class="line-modified">2288      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
2289      *
<span class="line-modified">2290      * @param a the array to be sorted</span>
<span class="line-modified">2291      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2292      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2293      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified">2294      */</span>
<span class="line-modified">2295     private static void sort(float[] a, int left, int right, boolean leftmost) {</span>
<span class="line-modified">2296         int length = right - left + 1;</span>
<span class="line-modified">2297 </span>
<span class="line-modified">2298         // Use insertion sort on tiny arrays</span>
<span class="line-modified">2299         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-modified">2300             if (leftmost) {</span>
<span class="line-modified">2301                 /*</span>
<span class="line-modified">2302                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-modified">2303                  * optimized for server VM, is used in case of</span>
<span class="line-modified">2304                  * the leftmost part.</span>
<span class="line-modified">2305                  */</span>
<span class="line-modified">2306                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-modified">2307                     float ai = a[i + 1];</span>
<span class="line-modified">2308                     while (ai &lt; a[j]) {</span>
<span class="line-modified">2309                         a[j + 1] = a[j];</span>
<span class="line-modified">2310                         if (j-- == left) {</span>
<span class="line-modified">2311                             break;</span>
<span class="line-modified">2312                         }</span>
<span class="line-removed">2313                     }</span>
<span class="line-removed">2314                     a[j + 1] = ai;</span>
2315                 }
<span class="line-modified">2316             } else {</span>
2317                 /*
<span class="line-modified">2318                  * Skip the longest ascending sequence.</span>
2319                  */
<span class="line-modified">2320                 do {</span>
<span class="line-modified">2321                     if (left &gt;= right) {</span>
<span class="line-modified">2322                         return;</span>
<span class="line-removed">2323                     }</span>
<span class="line-removed">2324                 } while (a[++left] &gt;= a[left - 1]);</span>
2325 
2326                 /*
<span class="line-modified">2327                  * Every element from adjoining part plays the role</span>
<span class="line-removed">2328                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-removed">2329                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed">2330                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed">2331                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed">2332                  * than traditional implementation of insertion sort.</span>
2333                  */
<span class="line-modified">2334                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-modified">2335                     float a1 = a[k], a2 = a[left];</span>

2336 
<span class="line-modified">2337                     if (a1 &lt; a2) {</span>
<span class="line-modified">2338                         a2 = a1; a1 = a[left];</span>
<span class="line-modified">2339                     }</span>
<span class="line-modified">2340                     while (a1 &lt; a[--k]) {</span>
<span class="line-modified">2341                         a[k + 2] = a[k];</span>
<span class="line-removed">2342                     }</span>
<span class="line-removed">2343                     a[++k + 1] = a1;</span>
2344 
<span class="line-modified">2345                     while (a2 &lt; a[--k]) {</span>
<span class="line-modified">2346                         a[k + 1] = a[k];</span>


2347                     }
<span class="line-removed">2348                     a[k + 1] = a2;</span>
2349                 }
<span class="line-removed">2350                 float last = a[right];</span>
2351 
<span class="line-modified">2352                 while (last &lt; a[--right]) {</span>
<span class="line-modified">2353                     a[right + 1] = a[right];</span>
<span class="line-modified">2354                 }</span>
<span class="line-modified">2355                 a[right + 1] = last;</span>








2356             }
<span class="line-removed">2357             return;</span>
2358         }
2359 
<span class="line-removed">2360         // Inexpensive approximation of length / 7</span>
<span class="line-removed">2361         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-removed">2362 </span>
2363         /*
<span class="line-modified">2364          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-removed">2365          * center element in the range. These elements will be used for</span>
<span class="line-removed">2366          * pivot selection as described below. The choice for spacing</span>
<span class="line-removed">2367          * these elements was empirically determined to work well on</span>
<span class="line-removed">2368          * a wide variety of inputs.</span>
2369          */
<span class="line-modified">2370         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified">2371         int e2 = e3 - seventh;</span>
<span class="line-removed">2372         int e1 = e2 - seventh;</span>
<span class="line-removed">2373         int e4 = e3 + seventh;</span>
<span class="line-removed">2374         int e5 = e4 + seventh;</span>
<span class="line-removed">2375 </span>
<span class="line-removed">2376         // Sort these elements using insertion sort</span>
<span class="line-removed">2377         if (a[e2] &lt; a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">2378 </span>
<span class="line-removed">2379         if (a[e3] &lt; a[e2]) { float t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">2380             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
2381         }
<span class="line-modified">2382         if (a[e4] &lt; a[e3]) { float t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">2383             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified">2384                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
2385             }
2386         }
<span class="line-modified">2387         if (a[e5] &lt; a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-modified">2388             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">2389                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">2390                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">2391                 }</span>
2392             }
2393         }

2394 
<span class="line-modified">2395         // Pointers</span>
<span class="line-removed">2396         int less  = left;  // The index of the first element of center part</span>
<span class="line-removed">2397         int great = right; // The index before the first element of right part</span>
<span class="line-removed">2398 </span>
<span class="line-removed">2399         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
<span class="line-removed">2400             /*</span>
<span class="line-removed">2401              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-removed">2402              * These values are inexpensive approximations of the first and</span>
<span class="line-removed">2403              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="line-removed">2404              */</span>
<span class="line-removed">2405             float pivot1 = a[e2];</span>
<span class="line-removed">2406             float pivot2 = a[e4];</span>
2407 
<span class="line-modified">2408             /*</span>
<span class="line-modified">2409              * The first and the last elements to be sorted are moved to the</span>
<span class="line-modified">2410              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-modified">2411              * is complete, the pivots are swapped back into their final</span>
<span class="line-modified">2412              * positions, and excluded from subsequent sorting.</span>
<span class="line-modified">2413              */</span>
<span class="line-modified">2414             a[e2] = a[left];</span>
<span class="line-modified">2415             a[e4] = a[right];</span>







2416 
<span class="line-modified">2417             /*</span>
<span class="line-modified">2418              * Skip elements, which are less or greater than pivot values.</span>
<span class="line-modified">2419              */</span>
<span class="line-modified">2420             while (a[++less] &lt; pivot1);</span>
<span class="line-modified">2421             while (a[--great] &gt; pivot2);</span>













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































2422 
2423             /*
<span class="line-modified">2424              * Partitioning:</span>
<span class="line-modified">2425              *</span>
<span class="line-modified">2426              *   left part           center part                   right part</span>
<span class="line-modified">2427              * +--------------------------------------------------------------+</span>
<span class="line-modified">2428              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-modified">2429              * +--------------------------------------------------------------+</span>
<span class="line-modified">2430              *               ^                          ^       ^</span>
<span class="line-modified">2431              *               |                          |       |</span>
<span class="line-modified">2432              *              less                        k     great</span>
<span class="line-modified">2433              *</span>
<span class="line-modified">2434              * Invariants:</span>












































2435              *
<span class="line-modified">2436              *              all in (left, less)   &lt; pivot1</span>
<span class="line-modified">2437              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-modified">2438              *              all in (great, right) &gt; pivot2</span>



































































































































































































































2439              *
<span class="line-modified">2440              * Pointer k is the first index of ?-part.</span>




2441              */
<span class="line-modified">2442             outer:</span>
<span class="line-modified">2443             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified">2444                 float ak = a[k];</span>
<span class="line-modified">2445                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-modified">2446                     a[k] = a[less];</span>



















2447                     /*
<span class="line-modified">2448                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-removed">2449                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
2450                      */
<span class="line-modified">2451                     a[less] = ak;</span>
<span class="line-modified">2452                     ++less;</span>
<span class="line-modified">2453                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-removed">2454                     while (a[great] &gt; pivot2) {</span>
<span class="line-removed">2455                         if (great-- == k) {</span>
<span class="line-removed">2456                             break outer;</span>
<span class="line-removed">2457                         }</span>
<span class="line-removed">2458                     }</span>
<span class="line-removed">2459                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed">2460                         a[k] = a[less];</span>
<span class="line-removed">2461                         a[less] = a[great];</span>
<span class="line-removed">2462                         ++less;</span>
<span class="line-removed">2463                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed">2464                         a[k] = a[great];</span>
2465                     }

2466                     /*
<span class="line-modified">2467                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed">2468                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
2469                      */
<span class="line-modified">2470                     a[great] = ak;</span>
<span class="line-modified">2471                     --great;</span>


2472                 }
2473             }
2474 
<span class="line-removed">2475             // Swap pivots into their final positions</span>
<span class="line-removed">2476             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-removed">2477             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-removed">2478 </span>
<span class="line-removed">2479             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-removed">2480             sort(a, left, less - 2, leftmost);</span>
<span class="line-removed">2481             sort(a, great + 2, right, false);</span>
<span class="line-removed">2482 </span>
2483             /*
<span class="line-modified">2484              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-removed">2485              * swap internal pivot values to ends.</span>
2486              */
<span class="line-modified">2487             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="line-modified">2488                 /*</span>
<span class="line-removed">2489                  * Skip elements, which are equal to pivot values.</span>
<span class="line-removed">2490                  */</span>
<span class="line-removed">2491                 while (a[less] == pivot1) {</span>
<span class="line-removed">2492                     ++less;</span>
<span class="line-removed">2493                 }</span>
<span class="line-removed">2494 </span>
<span class="line-removed">2495                 while (a[great] == pivot2) {</span>
<span class="line-removed">2496                     --great;</span>
<span class="line-removed">2497                 }</span>
2498 
2499                 /*
<span class="line-modified">2500                  * Partitioning:</span>
<span class="line-modified">2501                  *</span>
<span class="line-modified">2502                  *   left part         center part                  right part</span>
<span class="line-removed">2503                  * +----------------------------------------------------------+</span>
<span class="line-removed">2504                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-removed">2505                  * +----------------------------------------------------------+</span>
<span class="line-removed">2506                  *              ^                        ^       ^</span>
<span class="line-removed">2507                  *              |                        |       |</span>
<span class="line-removed">2508                  *             less                      k     great</span>
<span class="line-removed">2509                  *</span>
<span class="line-removed">2510                  * Invariants:</span>
<span class="line-removed">2511                  *</span>
<span class="line-removed">2512                  *              all in (*,  less) == pivot1</span>
<span class="line-removed">2513                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-removed">2514                  *              all in (great, *) == pivot2</span>
<span class="line-removed">2515                  *</span>
<span class="line-removed">2516                  * Pointer k is the first index of ?-part.</span>
2517                  */
<span class="line-modified">2518                 outer:</span>
<span class="line-modified">2519                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-modified">2520                     float ak = a[k];</span>
<span class="line-modified">2521                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-removed">2522                         a[k] = a[less];</span>
<span class="line-removed">2523                         a[less] = ak;</span>
<span class="line-removed">2524                         ++less;</span>
<span class="line-removed">2525                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-removed">2526                         while (a[great] == pivot2) {</span>
<span class="line-removed">2527                             if (great-- == k) {</span>
<span class="line-removed">2528                                 break outer;</span>
<span class="line-removed">2529                             }</span>
<span class="line-removed">2530                         }</span>
<span class="line-removed">2531                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed">2532                             a[k] = a[less];</span>
<span class="line-removed">2533                             /*</span>
<span class="line-removed">2534                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed">2535                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed">2536                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed">2537                              * of different signs. Therefore in float and</span>
<span class="line-removed">2538                              * double sorting methods we have to use more</span>
<span class="line-removed">2539                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed">2540                              */</span>
<span class="line-removed">2541                             a[less] = a[great];</span>
<span class="line-removed">2542                             ++less;</span>
<span class="line-removed">2543                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed">2544                             a[k] = a[great];</span>
<span class="line-removed">2545                         }</span>
<span class="line-removed">2546                         a[great] = ak;</span>
<span class="line-removed">2547                         --great;</span>
2548                     }
<span class="line-modified">2549                 }</span>
<span class="line-removed">2550             }</span>
2551 
<span class="line-modified">2552             // Sort center part recursively</span>
<span class="line-modified">2553             sort(a, less, great, false);</span>


2554 
<span class="line-modified">2555         } else { // Partitioning with one pivot</span>
<span class="line-removed">2556             /*</span>
<span class="line-removed">2557              * Use the third of the five sorted elements as pivot.</span>
<span class="line-removed">2558              * This value is inexpensive approximation of the median.</span>
<span class="line-removed">2559              */</span>
<span class="line-removed">2560             float pivot = a[e3];</span>
2561 
<span class="line-modified">2562             /*</span>
<span class="line-modified">2563              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-removed">2564              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-removed">2565              *</span>
<span class="line-removed">2566              *   left part    center part              right part</span>
<span class="line-removed">2567              * +-------------------------------------------------+</span>
<span class="line-removed">2568              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed">2569              * +-------------------------------------------------+</span>
<span class="line-removed">2570              *              ^              ^        ^</span>
<span class="line-removed">2571              *              |              |        |</span>
<span class="line-removed">2572              *             less            k      great</span>
<span class="line-removed">2573              *</span>
<span class="line-removed">2574              * Invariants:</span>
<span class="line-removed">2575              *</span>
<span class="line-removed">2576              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed">2577              *   all in [less, k)     == pivot</span>
<span class="line-removed">2578              *   all in (great, right) &gt; pivot</span>
<span class="line-removed">2579              *</span>
<span class="line-removed">2580              * Pointer k is the first index of ?-part.</span>
<span class="line-removed">2581              */</span>
<span class="line-removed">2582             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed">2583                 if (a[k] == pivot) {</span>
<span class="line-removed">2584                     continue;</span>
<span class="line-removed">2585                 }</span>
<span class="line-removed">2586                 float ak = a[k];</span>
<span class="line-removed">2587                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed">2588                     a[k] = a[less];</span>
<span class="line-removed">2589                     a[less] = ak;</span>
<span class="line-removed">2590                     ++less;</span>
<span class="line-removed">2591                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed">2592                     while (a[great] &gt; pivot) {</span>
<span class="line-removed">2593                         --great;</span>
2594                     }
<span class="line-modified">2595                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-modified">2596                         a[k] = a[less];</span>
<span class="line-modified">2597                         a[less] = a[great];</span>
<span class="line-modified">2598                         ++less;</span>
<span class="line-removed">2599                     } else { // a[great] == pivot</span>
<span class="line-removed">2600                         /*</span>
<span class="line-removed">2601                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed">2602                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed">2603                          * if a[great] and pivot are floating-point</span>
<span class="line-removed">2604                          * zeros of different signs. Therefore in float</span>
<span class="line-removed">2605                          * and double sorting methods we have to use</span>
<span class="line-removed">2606                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed">2607                          */</span>
<span class="line-removed">2608                         a[k] = a[great];</span>
2609                     }
<span class="line-modified">2610                     a[great] = ak;</span>
<span class="line-removed">2611                     --great;</span>
2612                 }
2613             }


2614 
<span class="line-modified">2615             /*</span>
<span class="line-modified">2616              * Sort left and right parts recursively.</span>
<span class="line-modified">2617              * All elements from center part are equal</span>
<span class="line-modified">2618              * and, therefore, already sorted.</span>
<span class="line-modified">2619              */</span>
<span class="line-modified">2620             sort(a, left, less - 1, leftmost);</span>
<span class="line-modified">2621             sort(a, great + 1, right, false);</span>










2622         }
2623     }
2624 
2625     /**
<span class="line-modified">2626      * Sorts the specified range of the array using the given</span>
<span class="line-removed">2627      * workspace array slice if possible for merging</span>
2628      *
2629      * @param a the array to be sorted
<span class="line-modified">2630      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2631      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2632      * @param work a workspace array (slice)</span>
<span class="line-modified">2633      * @param workBase origin of usable space in work array</span>
<span class="line-modified">2634      * @param workLen usable size of work array</span>
<span class="line-modified">2635      */</span>
<span class="line-removed">2636     static void sort(double[] a, int left, int right,</span>
<span class="line-removed">2637                      double[] work, int workBase, int workLen) {</span>
<span class="line-removed">2638         /*</span>
<span class="line-removed">2639          * Phase 1: Move NaNs to the end of the array.</span>
<span class="line-removed">2640          */</span>
<span class="line-removed">2641         while (left &lt;= right &amp;&amp; Double.isNaN(a[right])) {</span>
<span class="line-removed">2642             --right;</span>
2643         }
<span class="line-modified">2644         for (int k = right; --k &gt;= left; ) {</span>
<span class="line-modified">2645             double ak = a[k];</span>
<span class="line-modified">2646             if (ak != ak) { // a[k] is NaN</span>
<span class="line-modified">2647                 a[k] = a[right];</span>
<span class="line-modified">2648                 a[right] = ak;</span>
<span class="line-modified">2649                 --right;</span>






















2650             }
2651         }


2652 
<span class="line-modified">2653         /*</span>
<span class="line-modified">2654          * Phase 2: Sort everything except NaNs (which are already in place).</span>
<span class="line-modified">2655          */</span>
<span class="line-modified">2656         doSort(a, left, right, work, workBase, workLen);</span>






2657 
2658         /*
<span class="line-modified">2659          * Phase 3: Place negative zeros before positive zeros.</span>


2660          */
<span class="line-modified">2661         int hi = right;</span>


2662 
2663         /*
<span class="line-modified">2664          * Find the first zero, or first positive, or last negative element.</span>
2665          */
<span class="line-modified">2666         while (left &lt; hi) {</span>
<span class="line-removed">2667             int middle = (left + hi) &gt;&gt;&gt; 1;</span>
<span class="line-removed">2668             double middleValue = a[middle];</span>
2669 
<span class="line-modified">2670             if (middleValue &lt; 0.0d) {</span>
<span class="line-modified">2671                 left = middle + 1;</span>
<span class="line-modified">2672             } else {</span>
<span class="line-modified">2673                 hi = middle;</span>



















2674             }
<span class="line-removed">2675         }</span>
2676 
<span class="line-modified">2677         /*</span>
<span class="line-modified">2678          * Skip the last negative value (if any) or all leading negative zeros.</span>
<span class="line-modified">2679          */</span>
<span class="line-modified">2680         while (left &lt;= right &amp;&amp; Double.doubleToRawLongBits(a[left]) &lt; 0) {</span>
<span class="line-modified">2681             ++left;</span>
















































2682         }
2683 
2684         /*
<span class="line-modified">2685          * Move negative zeros to the beginning of the sub-range.</span>
<span class="line-removed">2686          *</span>
<span class="line-removed">2687          * Partitioning:</span>
<span class="line-removed">2688          *</span>
<span class="line-removed">2689          * +----------------------------------------------------+</span>
<span class="line-removed">2690          * |   &lt; 0.0   |   -0.0   |   0.0   |   ?  ( &gt;= 0.0 )   |</span>
<span class="line-removed">2691          * +----------------------------------------------------+</span>
<span class="line-removed">2692          *              ^          ^         ^</span>
<span class="line-removed">2693          *              |          |         |</span>
<span class="line-removed">2694          *             left        p         k</span>
<span class="line-removed">2695          *</span>
<span class="line-removed">2696          * Invariants:</span>
<span class="line-removed">2697          *</span>
<span class="line-removed">2698          *   all in (*,  left)  &lt;  0.0</span>
<span class="line-removed">2699          *   all in [left,  p) == -0.0</span>
<span class="line-removed">2700          *   all in [p,     k) ==  0.0</span>
<span class="line-removed">2701          *   all in [k, right] &gt;=  0.0</span>
<span class="line-removed">2702          *</span>
<span class="line-removed">2703          * Pointer k is the first index of ?-part.</span>
2704          */
<span class="line-modified">2705         for (int k = left, p = left - 1; ++k &lt;= right; ) {</span>
<span class="line-modified">2706             double ak = a[k];</span>
<span class="line-modified">2707             if (ak != 0.0d) {</span>
<span class="line-modified">2708                 break;</span>
<span class="line-modified">2709             }</span>
<span class="line-modified">2710             if (Double.doubleToRawLongBits(ak) &lt; 0) { // ak is -0.0d</span>
<span class="line-modified">2711                 a[k] = 0.0d;</span>
<span class="line-removed">2712                 a[++p] = -0.0d;</span>
2713             }

2714         }

2715     }
2716 
2717     /**
<span class="line-modified">2718      * Sorts the specified range of the array.</span>
2719      *
<span class="line-modified">2720      * @param a the array to be sorted</span>
<span class="line-modified">2721      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2722      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2723      * @param work a workspace array (slice)</span>
<span class="line-modified">2724      * @param workBase origin of usable space in work array</span>
<span class="line-modified">2725      * @param workLen usable size of work array</span>
<span class="line-modified">2726      */</span>
<span class="line-modified">2727     private static void doSort(double[] a, int left, int right,</span>
<span class="line-modified">2728                                double[] work, int workBase, int workLen) {</span>
<span class="line-modified">2729         // Use Quicksort on small arrays</span>
<span class="line-modified">2730         if (right - left &lt; QUICKSORT_THRESHOLD) {</span>
<span class="line-modified">2731             sort(a, left, right, true);</span>
<span class="line-modified">2732             return;</span>








2733         }
2734 
2735         /*
<span class="line-modified">2736          * Index run[i] is the start of i-th run</span>
<span class="line-removed">2737          * (ascending or descending sequence).</span>
2738          */
<span class="line-modified">2739         int[] run = new int[MAX_RUN_COUNT + 1];</span>
<span class="line-modified">2740         int count = 0; run[0] = left;</span>
<span class="line-removed">2741 </span>
<span class="line-removed">2742         // Check if the array is nearly sorted</span>
<span class="line-removed">2743         for (int k = left; k &lt; right; run[count] = k) {</span>
<span class="line-removed">2744             // Equal items in the beginning of the sequence</span>
<span class="line-removed">2745             while (k &lt; right &amp;&amp; a[k] == a[k + 1])</span>
<span class="line-removed">2746                 k++;</span>
<span class="line-removed">2747             if (k == right) break;  // Sequence finishes with equal items</span>
<span class="line-removed">2748             if (a[k] &lt; a[k + 1]) { // ascending</span>
<span class="line-removed">2749                 while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-removed">2750             } else if (a[k] &gt; a[k + 1]) { // descending</span>
<span class="line-removed">2751                 while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-removed">2752                 // Transform into an ascending sequence</span>
<span class="line-removed">2753                 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {</span>
<span class="line-removed">2754                     double t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span>
<span class="line-removed">2755                 }</span>
<span class="line-removed">2756             }</span>
2757 
<span class="line-modified">2758             // Merge a transformed descending sequence followed by an</span>
<span class="line-modified">2759             // ascending sequence</span>
<span class="line-modified">2760             if (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - 1]) {</span>
<span class="line-modified">2761                 count--;</span>
<span class="line-removed">2762             }</span>
2763 
<span class="line-modified">2764             /*</span>
<span class="line-modified">2765              * The array is not highly structured,</span>
<span class="line-modified">2766              * use Quicksort instead of merge sort.</span>
<span class="line-modified">2767              */</span>
<span class="line-modified">2768             if (++count == MAX_RUN_COUNT) {</span>
<span class="line-modified">2769                 sort(a, left, right, true);</span>
<span class="line-modified">2770                 return;</span>
<span class="line-removed">2771             }</span>
2772         }
2773 
<span class="line-modified">2774         // These invariants should hold true:</span>
<span class="line-removed">2775         //    run[0] = 0</span>
<span class="line-removed">2776         //    run[&lt;last&gt;] = right + 1; (terminator)</span>
2777 
<span class="line-modified">2778         if (count == 0) {</span>
<span class="line-modified">2779             // A single equal run</span>
<span class="line-modified">2780             return;</span>
<span class="line-modified">2781         } else if (count == 1 &amp;&amp; run[count] &gt; right) {</span>
<span class="line-modified">2782             // Either a single ascending or a transformed descending run.</span>
<span class="line-modified">2783             // Always check that a final run is a proper terminator, otherwise</span>
<span class="line-modified">2784             // we have an unterminated trailing run, to handle downstream.</span>
<span class="line-modified">2785             return;</span>
<span class="line-removed">2786         }</span>
<span class="line-removed">2787         right++;</span>
<span class="line-removed">2788         if (run[count] &lt; right) {</span>
<span class="line-removed">2789             // Corner case: the final run is not a terminator. This may happen</span>
<span class="line-removed">2790             // if a final run is an equals run, or there is a single-element run</span>
<span class="line-removed">2791             // at the end. Fix up by adding a proper terminator at the end.</span>
<span class="line-removed">2792             // Note that we terminate with (right + 1), incremented earlier.</span>
<span class="line-removed">2793             run[++count] = right;</span>
<span class="line-removed">2794         }</span>
<span class="line-removed">2795 </span>
<span class="line-removed">2796         // Determine alternation base for merge</span>
<span class="line-removed">2797         byte odd = 0;</span>
<span class="line-removed">2798         for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);</span>
<span class="line-removed">2799 </span>
<span class="line-removed">2800         // Use or create temporary array b for merging</span>
<span class="line-removed">2801         double[] b;                 // temp array; alternates with a</span>
<span class="line-removed">2802         int ao, bo;              // array offsets from &#39;left&#39;</span>
<span class="line-removed">2803         int blen = right - left; // space needed for b</span>
<span class="line-removed">2804         if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {</span>
<span class="line-removed">2805             work = new double[blen];</span>
<span class="line-removed">2806             workBase = 0;</span>
<span class="line-removed">2807         }</span>
<span class="line-removed">2808         if (odd == 0) {</span>
<span class="line-removed">2809             System.arraycopy(a, left, work, workBase, blen);</span>
<span class="line-removed">2810             b = a;</span>
<span class="line-removed">2811             bo = 0;</span>
<span class="line-removed">2812             a = work;</span>
<span class="line-removed">2813             ao = workBase - left;</span>
2814         } else {
<span class="line-modified">2815             b = work;</span>
<span class="line-removed">2816             ao = 0;</span>
<span class="line-removed">2817             bo = workBase - left;</span>
<span class="line-removed">2818         }</span>
<span class="line-removed">2819 </span>
<span class="line-removed">2820         // Merging</span>
<span class="line-removed">2821         for (int last; count &gt; 1; count = last) {</span>
<span class="line-removed">2822             for (int k = (last = 0) + 2; k &lt;= count; k += 2) {</span>
<span class="line-removed">2823                 int hi = run[k], mi = run[k - 1];</span>
<span class="line-removed">2824                 for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {</span>
<span class="line-removed">2825                     if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {</span>
<span class="line-removed">2826                         b[i + bo] = a[p++ + ao];</span>
<span class="line-removed">2827                     } else {</span>
<span class="line-removed">2828                         b[i + bo] = a[q++ + ao];</span>
<span class="line-removed">2829                     }</span>
<span class="line-removed">2830                 }</span>
<span class="line-removed">2831                 run[++last] = hi;</span>
<span class="line-removed">2832             }</span>
<span class="line-removed">2833             if ((count &amp; 1) != 0) {</span>
<span class="line-removed">2834                 for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span>
<span class="line-removed">2835                     b[i + bo] = a[i + ao]</span>
<span class="line-removed">2836                 );</span>
<span class="line-removed">2837                 run[++last] = right;</span>
<span class="line-removed">2838             }</span>
<span class="line-removed">2839             double[] t = a; a = b; b = t;</span>
<span class="line-removed">2840             int o = ao; ao = bo; bo = o;</span>
2841         }

2842     }
2843 
2844     /**
<span class="line-modified">2845      * Sorts the specified range of the array by Dual-Pivot Quicksort.</span>
2846      *
<span class="line-modified">2847      * @param a the array to be sorted</span>
<span class="line-modified">2848      * @param left the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">2849      * @param right the index of the last element, inclusive, to be sorted</span>
<span class="line-modified">2850      * @param leftmost indicates if this part is the leftmost in the range</span>
<span class="line-modified">2851      */</span>
<span class="line-modified">2852     private static void sort(double[] a, int left, int right, boolean leftmost) {</span>
<span class="line-modified">2853         int length = right - left + 1;</span>
<span class="line-modified">2854 </span>
<span class="line-modified">2855         // Use insertion sort on tiny arrays</span>
<span class="line-modified">2856         if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
<span class="line-modified">2857             if (leftmost) {</span>
<span class="line-modified">2858                 /*</span>
<span class="line-modified">2859                  * Traditional (without sentinel) insertion sort,</span>
<span class="line-modified">2860                  * optimized for server VM, is used in case of</span>
<span class="line-modified">2861                  * the leftmost part.</span>
<span class="line-modified">2862                  */</span>
<span class="line-modified">2863                 for (int i = left, j = i; i &lt; right; j = ++i) {</span>
<span class="line-modified">2864                     double ai = a[i + 1];</span>
<span class="line-modified">2865                     while (ai &lt; a[j]) {</span>
<span class="line-modified">2866                         a[j + 1] = a[j];</span>
<span class="line-modified">2867                         if (j-- == left) {</span>
<span class="line-modified">2868                             break;</span>
<span class="line-modified">2869                         }</span>
<span class="line-removed">2870                     }</span>
<span class="line-removed">2871                     a[j + 1] = ai;</span>
2872                 }
<span class="line-modified">2873             } else {</span>
2874                 /*
<span class="line-modified">2875                  * Skip the longest ascending sequence.</span>
2876                  */
<span class="line-modified">2877                 do {</span>
<span class="line-modified">2878                     if (left &gt;= right) {</span>
<span class="line-modified">2879                         return;</span>
<span class="line-removed">2880                     }</span>
<span class="line-removed">2881                 } while (a[++left] &gt;= a[left - 1]);</span>
2882 
2883                 /*
<span class="line-modified">2884                  * Every element from adjoining part plays the role</span>
<span class="line-removed">2885                  * of sentinel, therefore this allows us to avoid the</span>
<span class="line-removed">2886                  * left range check on each iteration. Moreover, we use</span>
<span class="line-removed">2887                  * the more optimized algorithm, so called pair insertion</span>
<span class="line-removed">2888                  * sort, which is faster (in the context of Quicksort)</span>
<span class="line-removed">2889                  * than traditional implementation of insertion sort.</span>
2890                  */
<span class="line-modified">2891                 for (int k = left; ++left &lt;= right; k = ++left) {</span>
<span class="line-modified">2892                     double a1 = a[k], a2 = a[left];</span>

2893 
<span class="line-modified">2894                     if (a1 &lt; a2) {</span>
<span class="line-modified">2895                         a2 = a1; a1 = a[left];</span>
<span class="line-modified">2896                     }</span>
<span class="line-modified">2897                     while (a1 &lt; a[--k]) {</span>
<span class="line-modified">2898                         a[k + 2] = a[k];</span>
<span class="line-removed">2899                     }</span>
<span class="line-removed">2900                     a[++k + 1] = a1;</span>
2901 
<span class="line-modified">2902                     while (a2 &lt; a[--k]) {</span>
<span class="line-modified">2903                         a[k + 1] = a[k];</span>


2904                     }
<span class="line-removed">2905                     a[k + 1] = a2;</span>
2906                 }
<span class="line-removed">2907                 double last = a[right];</span>
2908 
<span class="line-modified">2909                 while (last &lt; a[--right]) {</span>
<span class="line-modified">2910                     a[right + 1] = a[right];</span>
<span class="line-modified">2911                 }</span>
<span class="line-modified">2912                 a[right + 1] = last;</span>








2913             }
<span class="line-removed">2914             return;</span>
2915         }
2916 
<span class="line-removed">2917         // Inexpensive approximation of length / 7</span>
<span class="line-removed">2918         int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;</span>
<span class="line-removed">2919 </span>
2920         /*
<span class="line-modified">2921          * Sort five evenly spaced elements around (and including) the</span>
<span class="line-removed">2922          * center element in the range. These elements will be used for</span>
<span class="line-removed">2923          * pivot selection as described below. The choice for spacing</span>
<span class="line-removed">2924          * these elements was empirically determined to work well on</span>
<span class="line-removed">2925          * a wide variety of inputs.</span>
2926          */
<span class="line-modified">2927         int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint</span>
<span class="line-modified">2928         int e2 = e3 - seventh;</span>
<span class="line-removed">2929         int e1 = e2 - seventh;</span>
<span class="line-removed">2930         int e4 = e3 + seventh;</span>
<span class="line-removed">2931         int e5 = e4 + seventh;</span>
<span class="line-removed">2932 </span>
<span class="line-removed">2933         // Sort these elements using insertion sort</span>
<span class="line-removed">2934         if (a[e2] &lt; a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">2935 </span>
<span class="line-removed">2936         if (a[e3] &lt; a[e2]) { double t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">2937             if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
2938         }
<span class="line-modified">2939         if (a[e4] &lt; a[e3]) { double t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">2940             if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-modified">2941                 if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
2942             }
2943         }
<span class="line-modified">2944         if (a[e5] &lt; a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span>
<span class="line-modified">2945             if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;</span>
<span class="line-modified">2946                 if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;</span>
<span class="line-removed">2947                     if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-removed">2948                 }</span>
2949             }
2950         }

2951 
<span class="line-modified">2952         // Pointers</span>
<span class="line-removed">2953         int less  = left;  // The index of the first element of center part</span>
<span class="line-removed">2954         int great = right; // The index before the first element of right part</span>
<span class="line-removed">2955 </span>
<span class="line-removed">2956         if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {</span>
<span class="line-removed">2957             /*</span>
<span class="line-removed">2958              * Use the second and fourth of the five sorted elements as pivots.</span>
<span class="line-removed">2959              * These values are inexpensive approximations of the first and</span>
<span class="line-removed">2960              * second terciles of the array. Note that pivot1 &lt;= pivot2.</span>
<span class="line-removed">2961              */</span>
<span class="line-removed">2962             double pivot1 = a[e2];</span>
<span class="line-removed">2963             double pivot2 = a[e4];</span>
<span class="line-removed">2964 </span>
<span class="line-removed">2965             /*</span>
<span class="line-removed">2966              * The first and the last elements to be sorted are moved to the</span>
<span class="line-removed">2967              * locations formerly occupied by the pivots. When partitioning</span>
<span class="line-removed">2968              * is complete, the pivots are swapped back into their final</span>
<span class="line-removed">2969              * positions, and excluded from subsequent sorting.</span>
<span class="line-removed">2970              */</span>
<span class="line-removed">2971             a[e2] = a[left];</span>
<span class="line-removed">2972             a[e4] = a[right];</span>
2973 
<span class="line-modified">2974             /*</span>
<span class="line-modified">2975              * Skip elements, which are less or greater than pivot values.</span>
<span class="line-modified">2976              */</span>
<span class="line-modified">2977             while (a[++less] &lt; pivot1);</span>
<span class="line-modified">2978             while (a[--great] &gt; pivot2);</span>













2979 
<span class="line-modified">2980             /*</span>
<span class="line-modified">2981              * Partitioning:</span>
<span class="line-modified">2982              *</span>
<span class="line-modified">2983              *   left part           center part                   right part</span>
<span class="line-modified">2984              * +--------------------------------------------------------------+</span>
<span class="line-modified">2985              * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span>
<span class="line-modified">2986              * +--------------------------------------------------------------+</span>
<span class="line-modified">2987              *               ^                          ^       ^</span>
<span class="line-modified">2988              *               |                          |       |</span>
<span class="line-modified">2989              *              less                        k     great</span>
<span class="line-modified">2990              *</span>
<span class="line-modified">2991              * Invariants:</span>
<span class="line-modified">2992              *</span>
<span class="line-modified">2993              *              all in (left, less)   &lt; pivot1</span>
<span class="line-modified">2994              *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span>
<span class="line-modified">2995              *              all in (great, right) &gt; pivot2</span>
<span class="line-modified">2996              *</span>
<span class="line-modified">2997              * Pointer k is the first index of ?-part.</span>
<span class="line-modified">2998              */</span>
<span class="line-removed">2999             outer:</span>
<span class="line-removed">3000             for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed">3001                 double ak = a[k];</span>
<span class="line-removed">3002                 if (ak &lt; pivot1) { // Move a[k] to left part</span>
<span class="line-removed">3003                     a[k] = a[less];</span>
<span class="line-removed">3004                     /*</span>
<span class="line-removed">3005                      * Here and below we use &quot;a[i] = b; i++;&quot; instead</span>
<span class="line-removed">3006                      * of &quot;a[i++] = b;&quot; due to performance issue.</span>
<span class="line-removed">3007                      */</span>
<span class="line-removed">3008                     a[less] = ak;</span>
<span class="line-removed">3009                     ++less;</span>
<span class="line-removed">3010                 } else if (ak &gt; pivot2) { // Move a[k] to right part</span>
<span class="line-removed">3011                     while (a[great] &gt; pivot2) {</span>
<span class="line-removed">3012                         if (great-- == k) {</span>
<span class="line-removed">3013                             break outer;</span>
<span class="line-removed">3014                         }</span>
<span class="line-removed">3015                     }</span>
<span class="line-removed">3016                     if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2</span>
<span class="line-removed">3017                         a[k] = a[less];</span>
<span class="line-removed">3018                         a[less] = a[great];</span>
<span class="line-removed">3019                         ++less;</span>
<span class="line-removed">3020                     } else { // pivot1 &lt;= a[great] &lt;= pivot2</span>
<span class="line-removed">3021                         a[k] = a[great];</span>
<span class="line-removed">3022                     }</span>
<span class="line-removed">3023                     /*</span>
<span class="line-removed">3024                      * Here and below we use &quot;a[i] = b; i--;&quot; instead</span>
<span class="line-removed">3025                      * of &quot;a[i--] = b;&quot; due to performance issue.</span>
<span class="line-removed">3026                      */</span>
<span class="line-removed">3027                     a[great] = ak;</span>
<span class="line-removed">3028                     --great;</span>
3029                 }
3030             }


3031 
<span class="line-modified">3032             // Swap pivots into their final positions</span>
<span class="line-modified">3033             a[left]  = a[less  - 1]; a[less  - 1] = pivot1;</span>
<span class="line-modified">3034             a[right] = a[great + 1]; a[great + 1] = pivot2;</span>
<span class="line-modified">3035 </span>
<span class="line-modified">3036             // Sort left and right parts recursively, excluding known pivots</span>
<span class="line-modified">3037             sort(a, left, less - 2, leftmost);</span>
<span class="line-modified">3038             sort(a, great + 2, right, false);</span>











3039 
<span class="line-modified">3040             /*</span>
<span class="line-modified">3041              * If center part is too large (comprises &gt; 4/7 of the array),</span>
<span class="line-modified">3042              * swap internal pivot values to ends.</span>
<span class="line-modified">3043              */</span>
<span class="line-modified">3044             if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>
<span class="line-modified">3045                 /*</span>
<span class="line-removed">3046                  * Skip elements, which are equal to pivot values.</span>
<span class="line-removed">3047                  */</span>
<span class="line-removed">3048                 while (a[less] == pivot1) {</span>
<span class="line-removed">3049                     ++less;</span>
<span class="line-removed">3050                 }</span>
3051 
<span class="line-modified">3052                 while (a[great] == pivot2) {</span>
<span class="line-modified">3053                     --great;</span>
<span class="line-modified">3054                 }</span>

















3055 
<span class="line-modified">3056                 /*</span>
<span class="line-modified">3057                  * Partitioning:</span>
<span class="line-modified">3058                  *</span>
<span class="line-modified">3059                  *   left part         center part                  right part</span>
<span class="line-modified">3060                  * +----------------------------------------------------------+</span>
<span class="line-modified">3061                  * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span>
<span class="line-modified">3062                  * +----------------------------------------------------------+</span>
<span class="line-modified">3063                  *              ^                        ^       ^</span>
<span class="line-modified">3064                  *              |                        |       |</span>
<span class="line-modified">3065                  *             less                      k     great</span>
<span class="line-modified">3066                  *</span>
<span class="line-modified">3067                  * Invariants:</span>
<span class="line-modified">3068                  *</span>
<span class="line-modified">3069                  *              all in (*,  less) == pivot1</span>
<span class="line-modified">3070                  *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span>
<span class="line-modified">3071                  *              all in (great, *) == pivot2</span>
<span class="line-modified">3072                  *</span>
<span class="line-removed">3073                  * Pointer k is the first index of ?-part.</span>
<span class="line-removed">3074                  */</span>
<span class="line-removed">3075                 outer:</span>
<span class="line-removed">3076                 for (int k = less - 1; ++k &lt;= great; ) {</span>
<span class="line-removed">3077                     double ak = a[k];</span>
<span class="line-removed">3078                     if (ak == pivot1) { // Move a[k] to left part</span>
<span class="line-removed">3079                         a[k] = a[less];</span>
<span class="line-removed">3080                         a[less] = ak;</span>
<span class="line-removed">3081                         ++less;</span>
<span class="line-removed">3082                     } else if (ak == pivot2) { // Move a[k] to right part</span>
<span class="line-removed">3083                         while (a[great] == pivot2) {</span>
<span class="line-removed">3084                             if (great-- == k) {</span>
<span class="line-removed">3085                                 break outer;</span>
<span class="line-removed">3086                             }</span>
<span class="line-removed">3087                         }</span>
<span class="line-removed">3088                         if (a[great] == pivot1) { // a[great] &lt; pivot2</span>
<span class="line-removed">3089                             a[k] = a[less];</span>
<span class="line-removed">3090                             /*</span>
<span class="line-removed">3091                              * Even though a[great] equals to pivot1, the</span>
<span class="line-removed">3092                              * assignment a[less] = pivot1 may be incorrect,</span>
<span class="line-removed">3093                              * if a[great] and pivot1 are floating-point zeros</span>
<span class="line-removed">3094                              * of different signs. Therefore in float and</span>
<span class="line-removed">3095                              * double sorting methods we have to use more</span>
<span class="line-removed">3096                              * accurate assignment a[less] = a[great].</span>
<span class="line-removed">3097                              */</span>
<span class="line-removed">3098                             a[less] = a[great];</span>
<span class="line-removed">3099                             ++less;</span>
<span class="line-removed">3100                         } else { // pivot1 &lt; a[great] &lt; pivot2</span>
<span class="line-removed">3101                             a[k] = a[great];</span>
<span class="line-removed">3102                         }</span>
<span class="line-removed">3103                         a[great] = ak;</span>
<span class="line-removed">3104                         --great;</span>
<span class="line-removed">3105                     }</span>
<span class="line-removed">3106                 }</span>
3107             }


3108 
<span class="line-modified">3109             // Sort center part recursively</span>
<span class="line-modified">3110             sort(a, less, great, false);</span>




3111 
<span class="line-modified">3112         } else { // Partitioning with one pivot</span>
<span class="line-modified">3113             /*</span>
<span class="line-modified">3114              * Use the third of the five sorted elements as pivot.</span>
<span class="line-modified">3115              * This value is inexpensive approximation of the median.</span>
<span class="line-modified">3116              */</span>
<span class="line-modified">3117             double pivot = a[e3];</span>













3118 
<span class="line-modified">3119             /*</span>
<span class="line-modified">3120              * Partitioning degenerates to the traditional 3-way</span>
<span class="line-modified">3121              * (or &quot;Dutch National Flag&quot;) schema:</span>
<span class="line-modified">3122              *</span>
<span class="line-removed">3123              *   left part    center part              right part</span>
<span class="line-removed">3124              * +-------------------------------------------------+</span>
<span class="line-removed">3125              * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span>
<span class="line-removed">3126              * +-------------------------------------------------+</span>
<span class="line-removed">3127              *              ^              ^        ^</span>
<span class="line-removed">3128              *              |              |        |</span>
<span class="line-removed">3129              *             less            k      great</span>
<span class="line-removed">3130              *</span>
<span class="line-removed">3131              * Invariants:</span>
<span class="line-removed">3132              *</span>
<span class="line-removed">3133              *   all in (left, less)   &lt; pivot</span>
<span class="line-removed">3134              *   all in [less, k)     == pivot</span>
<span class="line-removed">3135              *   all in (great, right) &gt; pivot</span>
<span class="line-removed">3136              *</span>
<span class="line-removed">3137              * Pointer k is the first index of ?-part.</span>
<span class="line-removed">3138              */</span>
<span class="line-removed">3139             for (int k = less; k &lt;= great; ++k) {</span>
<span class="line-removed">3140                 if (a[k] == pivot) {</span>
<span class="line-removed">3141                     continue;</span>
<span class="line-removed">3142                 }</span>
<span class="line-removed">3143                 double ak = a[k];</span>
<span class="line-removed">3144                 if (ak &lt; pivot) { // Move a[k] to left part</span>
<span class="line-removed">3145                     a[k] = a[less];</span>
<span class="line-removed">3146                     a[less] = ak;</span>
<span class="line-removed">3147                     ++less;</span>
<span class="line-removed">3148                 } else { // a[k] &gt; pivot - Move a[k] to right part</span>
<span class="line-removed">3149                     while (a[great] &gt; pivot) {</span>
<span class="line-removed">3150                         --great;</span>
<span class="line-removed">3151                     }</span>
<span class="line-removed">3152                     if (a[great] &lt; pivot) { // a[great] &lt;= pivot</span>
<span class="line-removed">3153                         a[k] = a[less];</span>
<span class="line-removed">3154                         a[less] = a[great];</span>
<span class="line-removed">3155                         ++less;</span>
<span class="line-removed">3156                     } else { // a[great] == pivot</span>
<span class="line-removed">3157                         /*</span>
<span class="line-removed">3158                          * Even though a[great] equals to pivot, the</span>
<span class="line-removed">3159                          * assignment a[k] = pivot may be incorrect,</span>
<span class="line-removed">3160                          * if a[great] and pivot are floating-point</span>
<span class="line-removed">3161                          * zeros of different signs. Therefore in float</span>
<span class="line-removed">3162                          * and double sorting methods we have to use</span>
<span class="line-removed">3163                          * more accurate assignment a[k] = a[great].</span>
<span class="line-removed">3164                          */</span>
<span class="line-removed">3165                         a[k] = a[great];</span>
<span class="line-removed">3166                     }</span>
<span class="line-removed">3167                     a[great] = ak;</span>
<span class="line-removed">3168                     --great;</span>
<span class="line-removed">3169                 }</span>
3170             }












3171 
<span class="line-modified">3172             /*</span>
<span class="line-modified">3173              * Sort left and right parts recursively.</span>
<span class="line-modified">3174              * All elements from center part are equal</span>
<span class="line-modified">3175              * and, therefore, already sorted.</span>
<span class="line-modified">3176              */</span>
<span class="line-modified">3177             sort(a, left, less - 1, leftmost);</span>
<span class="line-modified">3178             sort(a, great + 1, right, false);</span>

3179         }
3180     }
3181 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
<span class="line-added">  28 import java.util.concurrent.CountedCompleter;</span>
<span class="line-added">  29 import java.util.concurrent.RecursiveTask;</span>
<span class="line-added">  30 </span>
  31 /**
<span class="line-modified">  32  * This class implements powerful and fully optimized versions, both</span>
<span class="line-modified">  33  * sequential and parallel, of the Dual-Pivot Quicksort algorithm by</span>
<span class="line-modified">  34  * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm</span>
<span class="line-modified">  35  * offers O(n log(n)) performance on all data sets, and is typically</span>
  36  * faster than traditional (one-pivot) Quicksort implementations.
  37  *
<span class="line-modified">  38  * There are also additional algorithms, invoked from the Dual-Pivot</span>
<span class="line-modified">  39  * Quicksort, such as mixed insertion sort, merging of runs and heap</span>
<span class="line-modified">  40  * sort, counting sort and parallel merge sort.</span>

  41  *
  42  * @author Vladimir Yaroslavskiy
  43  * @author Jon Bentley
  44  * @author Josh Bloch
<span class="line-added">  45  * @author Doug Lea</span>
<span class="line-added">  46  *</span>
<span class="line-added">  47  * @version 2018.08.18</span>
  48  *
<span class="line-modified">  49  * @since 1.7 * 14</span>

  50  */
  51 final class DualPivotQuicksort {
  52 
  53     /**
  54      * Prevents instantiation.
  55      */
  56     private DualPivotQuicksort() {}
  57 
<span class="line-modified">  58     /**</span>
<span class="line-modified">  59      * Max array size to use mixed insertion sort.</span>
  60      */
<span class="line-added">  61     private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;</span>
  62 
  63     /**
<span class="line-modified">  64      * Max array size to use insertion sort.</span>
  65      */
<span class="line-modified">  66     private static final int MAX_INSERTION_SORT_SIZE = 44;</span>
  67 
  68     /**
<span class="line-modified">  69      * Min array size to perform sorting in parallel.</span>

  70      */
<span class="line-modified">  71     private static final int MIN_PARALLEL_SORT_SIZE = 4 &lt;&lt; 10;</span>
  72 
  73     /**
<span class="line-modified">  74      * Min array size to try merging of runs.</span>

  75      */
<span class="line-modified">  76     private static final int MIN_TRY_MERGE_SIZE = 4 &lt;&lt; 10;</span>
  77 
  78     /**
<span class="line-modified">  79      * Min size of the first run to continue with scanning.</span>

  80      */
<span class="line-modified">  81     private static final int MIN_FIRST_RUN_SIZE = 16;</span>
  82 
  83     /**
<span class="line-modified">  84      * Min factor for the first runs to continue scanning.</span>

  85      */
<span class="line-modified">  86     private static final int MIN_FIRST_RUNS_FACTOR = 7;</span>
  87 
<span class="line-modified">  88     /**</span>
<span class="line-modified">  89      * Max capacity of the index array for tracking runs.</span>
  90      */
<span class="line-added">  91     private static final int MAX_RUN_CAPACITY = 5 &lt;&lt; 10;</span>
  92 
  93     /**
<span class="line-modified">  94      * Min number of runs, required by parallel merging.</span>
<span class="line-modified">  95      */</span>
<span class="line-modified">  96     private static final int MIN_RUN_COUNT = 4;</span>














  97 
<span class="line-modified">  98     /**</span>
<span class="line-modified">  99      * Min array size to use parallel merging of parts.</span>
<span class="line-modified"> 100      */</span>
<span class="line-modified"> 101     private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 &lt;&lt; 10;</span>


 102 
<span class="line-modified"> 103     /**</span>
<span class="line-modified"> 104      * Min size of a byte array to use counting sort.</span>
<span class="line-modified"> 105      */</span>
<span class="line-modified"> 106     private static final int MIN_BYTE_COUNTING_SORT_SIZE = 64;</span>











 107 
<span class="line-modified"> 108     /**</span>
<span class="line-modified"> 109      * Min size of a short or char array to use counting sort.</span>
<span class="line-modified"> 110      */</span>
<span class="line-modified"> 111     private static final int MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE = 1750;</span>

 112 
<span class="line-modified"> 113     /**</span>
<span class="line-modified"> 114      * Threshold of mixed insertion sort is incremented by this value.</span>
<span class="line-modified"> 115      */</span>
<span class="line-modified"> 116     private static final int DELTA = 3 &lt;&lt; 1;</span>





 117 
<span class="line-modified"> 118     /**</span>
<span class="line-modified"> 119      * Max recursive partitioning depth before using heap sort.</span>
<span class="line-modified"> 120      */</span>
<span class="line-added"> 121     private static final int MAX_RECURSION_DEPTH = 64 * DELTA;</span>
 122 
<span class="line-modified"> 123     /**</span>
<span class="line-modified"> 124      * Calculates the double depth of parallel merging.</span>
<span class="line-modified"> 125      * Depth is negative, if tasks split before sorting.</span>
<span class="line-modified"> 126      *</span>
<span class="line-modified"> 127      * @param parallelism the parallelism level</span>
<span class="line-modified"> 128      * @param size the target size</span>
<span class="line-modified"> 129      * @return the depth of parallel merging</span>
<span class="line-modified"> 130      */</span>
<span class="line-modified"> 131     private static int getDepth(int parallelism, int size) {</span>
<span class="line-modified"> 132         int depth = 0;</span>
<span class="line-modified"> 133 </span>
<span class="line-modified"> 134         while ((parallelism &gt;&gt;= 3) &gt; 0 &amp;&amp; (size &gt;&gt;= 2) &gt; 0) {</span>
<span class="line-modified"> 135             depth -= 2;</span>


















































 136         }
<span class="line-added"> 137         return depth;</span>
 138     }
 139 
 140     /**
<span class="line-modified"> 141      * Sorts the specified range of the array using parallel merge</span>
<span class="line-added"> 142      * sort and/or Dual-Pivot Quicksort.</span>
<span class="line-added"> 143      *</span>
<span class="line-added"> 144      * To balance the faster splitting and parallelism of merge sort</span>
<span class="line-added"> 145      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="line-added"> 146      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="line-added"> 147      * the four-way parallel merge is started, still ensuring enough</span>
<span class="line-added"> 148      * parallelism to process the partitions.</span>
 149      *
 150      * @param a the array to be sorted
<span class="line-modified"> 151      * @param parallelism the parallelism level</span>
<span class="line-modified"> 152      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 153      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified"> 154      */</span>
<span class="line-modified"> 155     static void sort(int[] a, int parallelism, int low, int high) {</span>
<span class="line-modified"> 156         int size = high - low;</span>






















































 157 
<span class="line-modified"> 158         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="line-modified"> 159             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="line-modified"> 160             int[] b = depth == 0 ? null : new int[size];</span>
<span class="line-modified"> 161             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="line-modified"> 162         } else {</span>
<span class="line-modified"> 163             sort(null, a, 0, low, high);</span>
 164         }
<span class="line-added"> 165     }</span>
 166 
<span class="line-modified"> 167     /**</span>
<span class="line-modified"> 168      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-modified"> 169      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-modified"> 170      *</span>
<span class="line-modified"> 171      * @param sorter parallel context</span>
<span class="line-modified"> 172      * @param a the array to be sorted</span>
<span class="line-modified"> 173      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-modified"> 174      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-modified"> 175      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 176      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified"> 177      */</span>
<span class="line-modified"> 178     static void sort(Sorter sorter, int[] a, int bits, int low, int high) {</span>
<span class="line-modified"> 179         while (true) {</span>
<span class="line-modified"> 180             int end = high - 1, size = high - low;</span>




 181 
<span class="line-modified"> 182             /*</span>
<span class="line-modified"> 183              * Run mixed insertion sort on small non-leftmost parts.</span>
<span class="line-modified"> 184              */</span>
<span class="line-modified"> 185             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="line-modified"> 186                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="line-modified"> 187                 return;</span>
 188             }
<span class="line-modified"> 189 </span>
<span class="line-modified"> 190             /*</span>
<span class="line-modified"> 191              * Invoke insertion sort on small leftmost part.</span>
<span class="line-modified"> 192              */</span>
<span class="line-modified"> 193             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-modified"> 194                 insertionSort(a, low, high);</span>
<span class="line-added"> 195                 return;</span>
 196             }

 197 
<span class="line-modified"> 198             /*</span>
<span class="line-modified"> 199              * Check if the whole array or large non-leftmost</span>
<span class="line-modified"> 200              * parts are nearly sorted and then merge runs.</span>
<span class="line-added"> 201              */</span>
<span class="line-added"> 202             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="line-added"> 203                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="line-added"> 204                 return;</span>
<span class="line-added"> 205             }</span>
 206 

 207             /*
<span class="line-modified"> 208              * Switch to heap sort if execution</span>
<span class="line-modified"> 209              * time is becoming quadratic.</span>

 210              */
<span class="line-modified"> 211             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-modified"> 212                 heapSort(a, low, high);</span>
<span class="line-added"> 213                 return;</span>
<span class="line-added"> 214             }</span>
 215 
 216             /*
<span class="line-modified"> 217              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-modified"> 218              * to select five sample elements and determine pivots.</span>


 219              */
<span class="line-modified"> 220             int step = (size &gt;&gt; 3) * 3 + 3;</span>

 221 
 222             /*
<span class="line-modified"> 223              * Five elements around (and including) the central element</span>
<span class="line-added"> 224              * will be used for pivot selection as described below. The</span>
<span class="line-added"> 225              * unequal choice of spacing these elements was empirically</span>
<span class="line-added"> 226              * determined to work well on a wide variety of inputs.</span>
 227              */
<span class="line-modified"> 228             int e1 = low + step;</span>
<span class="line-modified"> 229             int e5 = end - step;</span>
<span class="line-added"> 230             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 231             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 232             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 233             int a3 = a[e3];</span>
 234 
 235             /*
<span class="line-modified"> 236              * Sort these elements in place by the combination</span>
<span class="line-added"> 237              * of 4-element sorting network and insertion sort.</span>
 238              *
<span class="line-modified"> 239              *    5 ------o-----------o------------</span>
<span class="line-modified"> 240              *            |           |</span>
<span class="line-modified"> 241              *    4 ------|-----o-----o-----o------</span>
<span class="line-modified"> 242              *            |     |           |</span>
<span class="line-modified"> 243              *    2 ------o-----|-----o-----o------</span>
<span class="line-modified"> 244              *                  |     |</span>
<span class="line-modified"> 245              *    1 ------------o-----o------------</span>








 246              */
<span class="line-modified"> 247             if (a[e5] &lt; a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-modified"> 248             if (a[e4] &lt; a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-modified"> 249             if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-modified"> 250             if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-modified"> 251             if (a[e4] &lt; a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-modified"> 252 </span>
<span class="line-modified"> 253             if (a3 &lt; a[e2]) {</span>
<span class="line-modified"> 254                 if (a3 &lt; a[e1]) {</span>
<span class="line-modified"> 255                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-modified"> 256                 } else {</span>
<span class="line-modified"> 257                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-modified"> 258                 }</span>
<span class="line-modified"> 259             } else if (a3 &gt; a[e4]) {</span>
<span class="line-modified"> 260                 if (a3 &gt; a[e5]) {</span>
<span class="line-modified"> 261                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-modified"> 262                 } else {</span>
<span class="line-modified"> 263                     a[e3] = a[e4]; a[e4] = a3;</span>













 264                 }
 265             }
 266 
<span class="line-modified"> 267             // Pointers</span>
<span class="line-modified"> 268             int lower = low; // The index of the last element of the left part</span>
<span class="line-modified"> 269             int upper = end; // The index of the first element of the right part</span>




 270 
 271             /*
<span class="line-modified"> 272              * Partitioning with 2 pivots in case of different elements.</span>

 273              */
<span class="line-modified"> 274             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added"> 275 </span>
 276                 /*
<span class="line-modified"> 277                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added"> 278                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added"> 279                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
 280                  */
<span class="line-modified"> 281                 int pivot1 = a[e1];</span>
<span class="line-modified"> 282                 int pivot2 = a[e5];</span>

 283 
<span class="line-modified"> 284                 /*</span>
<span class="line-modified"> 285                  * The first and the last elements to be sorted are moved</span>
<span class="line-modified"> 286                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added"> 287                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added"> 288                  * into their final positions, and excluded from the next</span>
<span class="line-added"> 289                  * subsequent sorting.</span>
<span class="line-added"> 290                  */</span>
<span class="line-added"> 291                 a[e1] = a[lower];</span>
<span class="line-added"> 292                 a[e5] = a[upper];</span>
<span class="line-added"> 293 </span>
<span class="line-added"> 294                 /*</span>
<span class="line-added"> 295                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added"> 296                  */</span>
<span class="line-added"> 297                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added"> 298                 while (a[--upper] &gt; pivot2);</span>
 299 
 300                 /*
<span class="line-modified"> 301                  * Backward 3-interval partitioning</span>
 302                  *
<span class="line-modified"> 303                  *   left part                 central part          right part</span>
<span class="line-modified"> 304                  * +------------------------------------------------------------+</span>
<span class="line-modified"> 305                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-modified"> 306                  * +------------------------------------------------------------+</span>
<span class="line-modified"> 307                  *             ^       ^                            ^</span>
<span class="line-modified"> 308                  *             |       |                            |</span>
<span class="line-modified"> 309                  *           lower     k                          upper</span>
 310                  *
 311                  * Invariants:
 312                  *
<span class="line-modified"> 313                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-modified"> 314                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-modified"> 315                  *              all in [upper, end) &gt; pivot2</span>
 316                  *
<span class="line-modified"> 317                  * Pointer k is the last index of ?-part</span>
 318                  */
<span class="line-modified"> 319                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>

 320                     int ak = a[k];
<span class="line-modified"> 321 </span>
<span class="line-modified"> 322                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-modified"> 323                         while (lower &lt; k) {</span>
<span class="line-modified"> 324                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-modified"> 325                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-modified"> 326                                     a[k] = a[--upper];</span>
<span class="line-modified"> 327                                     a[upper] = a[lower];</span>
<span class="line-modified"> 328                                 } else {</span>
<span class="line-added"> 329                                     a[k] = a[lower];</span>
<span class="line-added"> 330                                 }</span>
<span class="line-added"> 331                                 a[lower] = ak;</span>
<span class="line-added"> 332                                 break;</span>
 333                             }
 334                         }
<span class="line-modified"> 335                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-modified"> 336                         a[k] = a[--upper];</span>
<span class="line-modified"> 337                         a[upper] = ak;</span>














 338                     }
 339                 }




 340 
<span class="line-modified"> 341                 /*</span>
<span class="line-modified"> 342                  * Swap the pivots into their final positions.</span>
<span class="line-modified"> 343                  */</span>
<span class="line-modified"> 344                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-modified"> 345                 a[end] = a[upper]; a[upper] = pivot2;</span>

 346 
<span class="line-modified"> 347                 /*</span>
<span class="line-modified"> 348                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="line-modified"> 349                  * excluding known pivots.</span>
<span class="line-modified"> 350                  */</span>
<span class="line-modified"> 351                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-modified"> 352                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="line-modified"> 353                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="line-modified"> 354                 } else {</span>
<span class="line-modified"> 355                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="line-modified"> 356                     sort(sorter, a, bits | 1, upper + 1, high);</span>








































 357                 }






























 358 
<span class="line-modified"> 359             } else { // Use single pivot in case of many equal elements</span>





 360 
<span class="line-modified"> 361                 /*</span>
<span class="line-modified"> 362                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-modified"> 363                  * This value is inexpensive approximation of the median.</span>
<span class="line-modified"> 364                  */</span>
<span class="line-modified"> 365                 int pivot = a[e3];</span>










 366 
<span class="line-modified"> 367                 /*</span>
<span class="line-modified"> 368                  * The first element to be sorted is moved to the</span>
<span class="line-modified"> 369                  * location formerly occupied by the pivot. After</span>
<span class="line-modified"> 370                  * completion of partitioning the pivot is swapped</span>
<span class="line-modified"> 371                  * back into its final position, and excluded from</span>
<span class="line-added"> 372                  * the next subsequent sorting.</span>
<span class="line-added"> 373                  */</span>
<span class="line-added"> 374                 a[e3] = a[lower];</span>
 375 
<span class="line-modified"> 376                 /*</span>
<span class="line-modified"> 377                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-modified"> 378                  *</span>
<span class="line-modified"> 379                  *   left part                 central part    right part</span>
<span class="line-modified"> 380                  * +------------------------------------------------------+</span>
<span class="line-modified"> 381                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-modified"> 382                  * +------------------------------------------------------+</span>
<span class="line-modified"> 383                  *              ^           ^                ^</span>
<span class="line-modified"> 384                  *              |           |                |</span>
<span class="line-added"> 385                  *            lower         k              upper</span>
<span class="line-added"> 386                  *</span>
<span class="line-added"> 387                  * Invariants:</span>
<span class="line-added"> 388                  *</span>
<span class="line-added"> 389                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added"> 390                  *   all in (k, upper)  == pivot</span>
<span class="line-added"> 391                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added"> 392                  *</span>
<span class="line-added"> 393                  * Pointer k is the last index of ?-part</span>
<span class="line-added"> 394                  */</span>
<span class="line-added"> 395                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added"> 396                     int ak = a[k];</span>
 397 
<span class="line-modified"> 398                     if (ak != pivot) {</span>
<span class="line-modified"> 399                         a[k] = pivot;</span>

 400 
<span class="line-modified"> 401                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-modified"> 402                             while (a[++lower] &lt; pivot);</span>































































 403 
<span class="line-modified"> 404                             if (a[lower] &gt; pivot) {</span>
<span class="line-modified"> 405                                 a[--upper] = a[lower];</span>
<span class="line-modified"> 406                             }</span>
<span class="line-modified"> 407                             a[lower] = ak;</span>
<span class="line-modified"> 408                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-modified"> 409                             a[--upper] = ak;</span>



















 410                         }
 411                     }

 412                 }
<span class="line-modified"> 413 </span>
 414                 /*
<span class="line-modified"> 415                  * Swap the pivot into its final position.</span>
 416                  */
<span class="line-modified"> 417                 a[low] = a[lower]; a[lower] = pivot;</span>




 418 
 419                 /*
<span class="line-modified"> 420                  * Sort the right part (possibly in parallel), excluding</span>
<span class="line-modified"> 421                  * known pivot. All elements from the central part are</span>
<span class="line-modified"> 422                  * equal and therefore already sorted.</span>



 423                  */
<span class="line-modified"> 424                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-modified"> 425                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="line-modified"> 426                 } else {</span>
<span class="line-modified"> 427                     sort(sorter, a, bits | 1, upper, high);</span>
















 428                 }

 429             }
<span class="line-modified"> 430             high = lower; // Iterate along the left part</span>
 431         }
<span class="line-added"> 432     }</span>
 433 
<span class="line-modified"> 434     /**</span>
<span class="line-modified"> 435      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="line-modified"> 436      *</span>
<span class="line-modified"> 437      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="line-modified"> 438      * pin insertion sort and pair insertion sort.</span>
<span class="line-modified"> 439      *</span>
<span class="line-modified"> 440      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="line-modified"> 441      * from the left part plays the role of sentinel, because it</span>
<span class="line-modified"> 442      * is less than any elements from the given part. Therefore,</span>
<span class="line-modified"> 443      * expensive check of the left range can be skipped on each</span>
<span class="line-modified"> 444      * iteration unless it is the leftmost call.</span>
<span class="line-modified"> 445      *</span>
<span class="line-modified"> 446      * @param a the array to be sorted</span>
<span class="line-modified"> 447      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 448      * @param end the index of the last element for simple insertion sort</span>
<span class="line-added"> 449      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added"> 450      */</span>
<span class="line-added"> 451     private static void mixedInsertionSort(int[] a, int low, int end, int high) {</span>
<span class="line-added"> 452         if (end == high) {</span>
 453 
<span class="line-modified"> 454             /*</span>
<span class="line-modified"> 455              * Invoke simple insertion sort on tiny array.</span>
<span class="line-added"> 456              */</span>
<span class="line-added"> 457             for (int i; ++low &lt; end; ) {</span>
<span class="line-added"> 458                 int ai = a[i = low];</span>
 459 
<span class="line-modified"> 460                 while (ai &lt; a[--i]) {</span>
<span class="line-modified"> 461                     a[i + 1] = a[i];</span>










 462                 }
<span class="line-added"> 463                 a[i + 1] = ai;</span>
 464             }
<span class="line-modified"> 465         } else {</span>




 466 

 467             /*
<span class="line-modified"> 468              * Start with pin insertion sort on small part.</span>
<span class="line-modified"> 469              *</span>
<span class="line-modified"> 470              * Pin insertion sort is extended simple insertion sort.</span>
<span class="line-added"> 471              * The main idea of this sort is to put elements larger</span>
<span class="line-added"> 472              * than an element called pin to the end of array (the</span>
<span class="line-added"> 473              * proper area for such elements). It avoids expensive</span>
<span class="line-added"> 474              * movements of these elements through the whole array.</span>
 475              */
<span class="line-modified"> 476             int pin = a[end];</span>

 477 
<span class="line-modified"> 478             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="line-modified"> 479                 int ai = a[i = low];</span>






 480 
<span class="line-modified"> 481                 if (ai &lt; a[i - 1]) { // Small element</span>




 482 
























 483                     /*
<span class="line-modified"> 484                      * Insert small element into sorted part.</span>

 485                      */
<span class="line-modified"> 486                     a[i] = a[--i];</span>
<span class="line-modified"> 487 </span>
<span class="line-modified"> 488                     while (ai &lt; a[--i]) {</span>
<span class="line-modified"> 489                         a[i + 1] = a[i];</span>



 490                     }
<span class="line-modified"> 491                     a[i + 1] = ai;</span>
<span class="line-modified"> 492 </span>
<span class="line-modified"> 493                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="line-modified"> 494 </span>
<span class="line-modified"> 495                     /*</span>
<span class="line-modified"> 496                      * Find element smaller than pin.</span>
<span class="line-added"> 497                      */</span>
<span class="line-added"> 498                     while (a[--p] &gt; pin);</span>
<span class="line-added"> 499 </span>
<span class="line-added"> 500                     /*</span>
<span class="line-added"> 501                      * Swap it with large element.</span>
<span class="line-added"> 502                      */</span>
<span class="line-added"> 503                     if (p &gt; i) {</span>
<span class="line-added"> 504                         ai = a[p];</span>
<span class="line-added"> 505                         a[p] = a[i];</span>
 506                     }
<span class="line-added"> 507 </span>
 508                     /*
<span class="line-modified"> 509                      * Insert small element into sorted part.</span>

 510                      */
<span class="line-modified"> 511                     while (ai &lt; a[--i]) {</span>
<span class="line-modified"> 512                         a[i + 1] = a[i];</span>
<span class="line-added"> 513                     }</span>
<span class="line-added"> 514                     a[i + 1] = ai;</span>
 515                 }
 516             }
 517 








 518             /*
<span class="line-modified"> 519              * Continue with pair insertion sort on remain part.</span>

 520              */
<span class="line-modified"> 521             for (int i; low &lt; high; ++low) {</span>
<span class="line-added"> 522                 int a1 = a[i = low], a2 = a[++low];</span>
<span class="line-added"> 523 </span>
 524                 /*
<span class="line-modified"> 525                  * Insert two elements per iteration: at first, insert the</span>
<span class="line-added"> 526                  * larger element and then insert the smaller element, but</span>
<span class="line-added"> 527                  * from the position where the larger element was inserted.</span>
 528                  */
<span class="line-modified"> 529                 if (a1 &gt; a2) {</span>


 530 
<span class="line-modified"> 531                     while (a1 &lt; a[--i]) {</span>
<span class="line-modified"> 532                         a[i + 2] = a[i];</span>
<span class="line-modified"> 533                     }</span>
<span class="line-added"> 534                     a[++i + 1] = a1;</span>
 535 
<span class="line-modified"> 536                     while (a2 &lt; a[--i]) {</span>
<span class="line-modified"> 537                         a[i + 1] = a[i];</span>















































 538                     }
<span class="line-modified"> 539                     a[i + 1] = a2;</span>

 540 
<span class="line-modified"> 541                 } else if (a1 &lt; a[i - 1]) {</span>

 542 
<span class="line-modified"> 543                     while (a2 &lt; a[--i]) {</span>
<span class="line-modified"> 544                         a[i + 2] = a[i];</span>





































 545                     }
<span class="line-modified"> 546                     a[++i + 1] = a2;</span>
<span class="line-modified"> 547 </span>
<span class="line-modified"> 548                     while (a1 &lt; a[--i]) {</span>
<span class="line-modified"> 549                         a[i + 1] = a[i];</span>










 550                     }
<span class="line-modified"> 551                     a[i + 1] = a1;</span>

 552                 }
 553             }








 554         }
 555     }
 556 
 557     /**
<span class="line-modified"> 558      * Sorts the specified range of the array using insertion sort.</span>

 559      *
 560      * @param a the array to be sorted
<span class="line-modified"> 561      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 562      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified"> 563      */</span>
<span class="line-modified"> 564     private static void insertionSort(int[] a, int low, int high) {</span>
<span class="line-modified"> 565         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-modified"> 566             int ai = a[i = k];</span>













 567 
<span class="line-modified"> 568             if (ai &lt; a[i - 1]) {</span>
<span class="line-modified"> 569                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-modified"> 570                     a[i + 1] = a[i];</span>
<span class="line-added"> 571                 }</span>
<span class="line-added"> 572                 a[i + 1] = ai;</span>
 573             }


 574         }
 575     }
 576 



 577     /**
<span class="line-modified"> 578      * Sorts the specified range of the array using heap sort.</span>
 579      *
 580      * @param a the array to be sorted
<span class="line-modified"> 581      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified"> 582      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified"> 583      */</span>
<span class="line-modified"> 584     private static void heapSort(int[] a, int low, int high) {</span>
<span class="line-modified"> 585         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="line-modified"> 586             pushDown(a, --k, a[k], low, high);</span>






 587         }
<span class="line-modified"> 588         while (--high &gt; low) {</span>
<span class="line-modified"> 589             int max = a[low];</span>
<span class="line-modified"> 590             pushDown(a, low, a[high], low, high);</span>
<span class="line-modified"> 591             a[high] = max;</span>


































 592         }
<span class="line-added"> 593     }</span>
 594 
<span class="line-modified"> 595     /**</span>
<span class="line-modified"> 596      * Pushes specified element down during heap sort.</span>
<span class="line-modified"> 597      *</span>
<span class="line-added"> 598      * @param a the given array</span>
<span class="line-added"> 599      * @param p the start index</span>
<span class="line-added"> 600      * @param value the given element</span>
<span class="line-added"> 601      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added"> 602      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added"> 603      */</span>
<span class="line-added"> 604     private static void pushDown(int[] a, int p, int value, int low, int high) {</span>
<span class="line-added"> 605         for (int k ;; a[p] = a[p = k]) {</span>
<span class="line-added"> 606             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
 607 
<span class="line-modified"> 608             if (k &gt; high) {</span>
<span class="line-modified"> 609                 break;</span>




















































 610             }
<span class="line-modified"> 611             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="line-modified"> 612                 --k;</span>
<span class="line-modified"> 613             }</span>
<span class="line-modified"> 614             if (a[k] &lt;= value) {</span>
<span class="line-modified"> 615                 break;</span>
 616             }


 617         }
<span class="line-added"> 618         a[p] = value;</span>
 619     }
 620 
 621     /**
<span class="line-modified"> 622      * Tries to sort the specified range of the array.</span>
 623      *
<span class="line-added"> 624      * @param sorter parallel context</span>
 625      * @param a the array to be sorted
<span class="line-modified"> 626      * @param low the index of the first element to be sorted</span>
<span class="line-modified"> 627      * @param size the array size</span>
<span class="line-modified"> 628      * @return true if finally sorted, false otherwise</span>
<span class="line-modified"> 629      */</span>
<span class="line-modified"> 630     private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {</span>





























 631 
<span class="line-modified"> 632         /*</span>
<span class="line-modified"> 633          * The run array is constructed only if initial runs are</span>
<span class="line-modified"> 634          * long enough to continue, run[i] then holds start index</span>
<span class="line-modified"> 635          * of the i-th sequence of elements in non-descending order.</span>
<span class="line-modified"> 636          */</span>
<span class="line-modified"> 637         int[] run = null;</span>
<span class="line-modified"> 638         int high = low + size;</span>
<span class="line-modified"> 639         int count = 1, last = low;</span>


 640 
<span class="line-modified"> 641         /*</span>
<span class="line-modified"> 642          * Identify all possible runs.</span>
<span class="line-modified"> 643          */</span>
<span class="line-modified"> 644         for (int k = low + 1; k &lt; high; ) {</span>



 645 
<span class="line-modified"> 646             /*</span>
<span class="line-modified"> 647              * Find the end index of the current run.</span>
<span class="line-modified"> 648              */</span>
<span class="line-modified"> 649             if (a[k - 1] &lt; a[k]) {</span>


 650 
<span class="line-modified"> 651                 // Identify ascending sequence</span>
<span class="line-modified"> 652                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>





 653 
<span class="line-modified"> 654             } else if (a[k - 1] &gt; a[k]) {</span>

 655 
<span class="line-modified"> 656                 // Identify descending sequence</span>
<span class="line-modified"> 657                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>










 658 
<span class="line-modified"> 659                 // Reverse into ascending order</span>
<span class="line-modified"> 660                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="line-added"> 661                     int ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="line-added"> 662                 }</span>
<span class="line-added"> 663             } else { // Identify constant sequence</span>
<span class="line-added"> 664                 for (int ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
 665 
<span class="line-modified"> 666                 if (k &lt; high) {</span>
<span class="line-modified"> 667                     continue;</span>










 668                 }
 669             }























 670 
 671             /*
<span class="line-modified"> 672              * Check special cases.</span>
 673              */
<span class="line-modified"> 674             if (run == null) {</span>
<span class="line-modified"> 675                 if (k == high) {</span>
 676 
























 677                     /*
<span class="line-modified"> 678                      * The array is monotonous sequence,</span>
<span class="line-modified"> 679                      * and therefore already sorted.</span>
 680                      */
<span class="line-modified"> 681                     return true;</span>
<span class="line-modified"> 682                 }</span>
<span class="line-modified"> 683 </span>
<span class="line-modified"> 684                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="line-modified"> 685 </span>










 686                     /*
<span class="line-modified"> 687                      * The first run is too small</span>
<span class="line-modified"> 688                      * to proceed with scanning.</span>
 689                      */
<span class="line-modified"> 690                     return false;</span>

 691                 }

 692 
<span class="line-modified"> 693                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="line-modified"> 694                 run[0] = low;</span>

 695 
<span class="line-modified"> 696             } else if (a[last - 1] &gt; a[last]) {</span>


 697 
<span class="line-modified"> 698                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>










 699 
<span class="line-modified"> 700                     /*</span>
<span class="line-modified"> 701                      * The first runs are not long</span>
<span class="line-added"> 702                      * enough to continue scanning.</span>
<span class="line-added"> 703                      */</span>
<span class="line-added"> 704                     return false;</span>
 705                 }
 706 
<span class="line-modified"> 707                 if (++count == MAX_RUN_CAPACITY) {</span>



















































 708 
<span class="line-modified"> 709                     /*</span>
<span class="line-modified"> 710                      * Array is not highly structured.</span>
<span class="line-added"> 711                      */</span>
<span class="line-added"> 712                     return false;</span>
<span class="line-added"> 713                 }</span>
 714 
<span class="line-modified"> 715                 if (count == run.length) {</span>





 716 
<span class="line-modified"> 717                     /*</span>
<span class="line-modified"> 718                      * Increase capacity of index array.</span>
<span class="line-modified"> 719                      */</span>
<span class="line-modified"> 720                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>














































 721                 }
 722             }
<span class="line-modified"> 723             run[count] = (last = k);</span>







 724         }

 725 
<span class="line-modified"> 726         /*</span>
<span class="line-modified"> 727          * Merge runs of highly structured array.</span>
<span class="line-modified"> 728          */</span>
<span class="line-modified"> 729         if (count &gt; 1) {</span>
<span class="line-modified"> 730             int[] b; int offset = low;</span>



















 731 
<span class="line-modified"> 732             if (sorter == null || (b = (int[]) sorter.b) == null) {</span>
<span class="line-modified"> 733                 b = new int[size];</span>
<span class="line-modified"> 734             } else {</span>
<span class="line-added"> 735                 offset = sorter.offset;</span>
 736             }
<span class="line-modified"> 737             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>

 738         }
<span class="line-added"> 739         return true;</span>
 740     }
 741 



 742     /**
<span class="line-modified"> 743      * Merges the specified runs.</span>
 744      *
<span class="line-modified"> 745      * @param a the source array</span>
<span class="line-modified"> 746      * @param b the temporary buffer used in merging</span>
<span class="line-modified"> 747      * @param offset the start index in the source, inclusive</span>
<span class="line-modified"> 748      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="line-modified"> 749      * @param parallel indicates whether merging is performed in parallel</span>
<span class="line-modified"> 750      * @param run the start indexes of the runs, inclusive</span>
<span class="line-modified"> 751      * @param lo the start index of the first run, inclusive</span>
<span class="line-modified"> 752      * @param hi the start index of the last run, inclusive</span>
<span class="line-modified"> 753      * @return the destination where runs are merged</span>
<span class="line-modified"> 754      */</span>
<span class="line-modified"> 755     private static int[] mergeRuns(int[] a, int[] b, int offset,</span>
<span class="line-modified"> 756             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="line-modified"> 757 </span>
<span class="line-added"> 758         if (hi - lo == 1) {</span>
<span class="line-added"> 759             if (aim &gt;= 0) {</span>
<span class="line-added"> 760                 return a;</span>
<span class="line-added"> 761             }</span>
<span class="line-added"> 762             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="line-added"> 763                 b[--j] = a[--i]</span>
<span class="line-added"> 764             );</span>
<span class="line-added"> 765             return b;</span>
 766         }
 767 
 768         /*
<span class="line-modified"> 769          * Split into approximately equal parts.</span>

 770          */
<span class="line-modified"> 771         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="line-modified"> 772         while (run[++mi + 1] &lt;= rmi);</span>
















 773 
<span class="line-modified"> 774         /*</span>
<span class="line-modified"> 775          * Merge the left and right parts.</span>
<span class="line-modified"> 776          */</span>
<span class="line-modified"> 777         int[] a1, a2;</span>

 778 
<span class="line-modified"> 779         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="line-modified"> 780             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="line-modified"> 781             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="line-modified"> 782             a2 = (int[]) merger.getDestination();</span>
<span class="line-modified"> 783         } else {</span>
<span class="line-modified"> 784             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="line-modified"> 785             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>

 786         }
 787 
<span class="line-modified"> 788         int[] dst = a1 == a ? b : a;</span>


 789 
<span class="line-modified"> 790         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="line-modified"> 791         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="line-modified"> 792         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified"> 793         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified"> 794         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="line-modified"> 795 </span>
<span class="line-modified"> 796         if (parallel) {</span>
<span class="line-modified"> 797             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>




























 798         } else {
<span class="line-modified"> 799             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>

























 800         }
<span class="line-added"> 801         return dst;</span>
 802     }
 803 
 804     /**
<span class="line-modified"> 805      * Merges the sorted parts.</span>
 806      *
<span class="line-modified"> 807      * @param merger parallel context</span>
<span class="line-modified"> 808      * @param dst the destination where parts are merged</span>
<span class="line-modified"> 809      * @param k the start index of the destination, inclusive</span>
<span class="line-modified"> 810      * @param a1 the first part</span>
<span class="line-modified"> 811      * @param lo1 the start index of the first part, inclusive</span>
<span class="line-modified"> 812      * @param hi1 the end index of the first part, exclusive</span>
<span class="line-modified"> 813      * @param a2 the second part</span>
<span class="line-modified"> 814      * @param lo2 the start index of the second part, inclusive</span>
<span class="line-modified"> 815      * @param hi2 the end index of the second part, exclusive</span>
<span class="line-modified"> 816      */</span>
<span class="line-modified"> 817     private static void mergeParts(Merger merger, int[] dst, int k,</span>
<span class="line-modified"> 818             int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {</span>
<span class="line-modified"> 819 </span>
<span class="line-modified"> 820         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="line-modified"> 821 </span>
<span class="line-modified"> 822             while (true) {</span>
<span class="line-modified"> 823 </span>
<span class="line-modified"> 824                 /*</span>
<span class="line-modified"> 825                  * The first part must be larger.</span>
<span class="line-modified"> 826                  */</span>
<span class="line-modified"> 827                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="line-modified"> 828                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="line-modified"> 829                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>


 830                 }
<span class="line-modified"> 831 </span>
 832                 /*
<span class="line-modified"> 833                  * Small parts will be merged sequentially.</span>
 834                  */
<span class="line-modified"> 835                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="line-modified"> 836                     break;</span>
<span class="line-modified"> 837                 }</span>


 838 
 839                 /*
<span class="line-modified"> 840                  * Find the median of the larger part.</span>





 841                  */
<span class="line-modified"> 842                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="line-modified"> 843                 int key = a1[mi1];</span>
<span class="line-added"> 844                 int mi2 = hi2;</span>
 845 
<span class="line-modified"> 846                 /*</span>
<span class="line-modified"> 847                  * Partition the smaller part.</span>
<span class="line-modified"> 848                  */</span>
<span class="line-modified"> 849                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="line-modified"> 850                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>


 851 
<span class="line-modified"> 852                     if (key &gt; a2[t]) {</span>
<span class="line-modified"> 853                         loo = t + 1;</span>
<span class="line-added"> 854                     } else {</span>
<span class="line-added"> 855                         mi2 = t;</span>
 856                     }

 857                 }

 858 
<span class="line-modified"> 859                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="line-modified"> 860 </span>
<span class="line-modified"> 861                 /*</span>
<span class="line-modified"> 862                  * Merge the right sub-parts in parallel.</span>
<span class="line-added"> 863                  */</span>
<span class="line-added"> 864                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="line-added"> 865 </span>
<span class="line-added"> 866                 /*</span>
<span class="line-added"> 867                  * Process the sub-left parts.</span>
<span class="line-added"> 868                  */</span>
<span class="line-added"> 869                 hi1 = mi1;</span>
<span class="line-added"> 870                 hi2 = mi2;</span>
 871             }

 872         }
 873 



 874         /*
<span class="line-modified"> 875          * Merge small parts sequentially.</span>




 876          */
<span class="line-modified"> 877         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="line-modified"> 878             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>









 879         }
<span class="line-modified"> 880         if (dst != a1 || k &lt; lo1) {</span>
<span class="line-modified"> 881             while (lo1 &lt; hi1) {</span>
<span class="line-modified"> 882                 dst[k++] = a1[lo1++];</span>
 883             }
 884         }
<span class="line-modified"> 885         if (dst != a2 || k &lt; lo2) {</span>
<span class="line-modified"> 886             while (lo2 &lt; hi2) {</span>
<span class="line-modified"> 887                 dst[k++] = a2[lo2++];</span>


 888             }
 889         }
<span class="line-added"> 890     }</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892 // [long]</span>
<span class="line-added"> 893 </span>
<span class="line-added"> 894     /**</span>
<span class="line-added"> 895      * Sorts the specified range of the array using parallel merge</span>
<span class="line-added"> 896      * sort and/or Dual-Pivot Quicksort.</span>
<span class="line-added"> 897      *</span>
<span class="line-added"> 898      * To balance the faster splitting and parallelism of merge sort</span>
<span class="line-added"> 899      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="line-added"> 900      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="line-added"> 901      * the four-way parallel merge is started, still ensuring enough</span>
<span class="line-added"> 902      * parallelism to process the partitions.</span>
<span class="line-added"> 903      *</span>
<span class="line-added"> 904      * @param a the array to be sorted</span>
<span class="line-added"> 905      * @param parallelism the parallelism level</span>
<span class="line-added"> 906      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added"> 907      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added"> 908      */</span>
<span class="line-added"> 909     static void sort(long[] a, int parallelism, int low, int high) {</span>
<span class="line-added"> 910         int size = high - low;</span>
<span class="line-added"> 911 </span>
<span class="line-added"> 912         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="line-added"> 913             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="line-added"> 914             long[] b = depth == 0 ? null : new long[size];</span>
<span class="line-added"> 915             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="line-added"> 916         } else {</span>
<span class="line-added"> 917             sort(null, a, 0, low, high);</span>
<span class="line-added"> 918         }</span>
<span class="line-added"> 919     }</span>
 920 
<span class="line-modified"> 921     /**</span>
<span class="line-modified"> 922      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-modified"> 923      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added"> 924      *</span>
<span class="line-added"> 925      * @param sorter parallel context</span>
<span class="line-added"> 926      * @param a the array to be sorted</span>
<span class="line-added"> 927      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added"> 928      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added"> 929      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added"> 930      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added"> 931      */</span>
<span class="line-added"> 932     static void sort(Sorter sorter, long[] a, int bits, int low, int high) {</span>
<span class="line-added"> 933         while (true) {</span>
<span class="line-added"> 934             int end = high - 1, size = high - low;</span>
 935 

 936             /*
<span class="line-modified"> 937              * Run mixed insertion sort on small non-leftmost parts.</span>


 938              */
<span class="line-modified"> 939             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="line-modified"> 940                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="line-added"> 941                 return;</span>
<span class="line-added"> 942             }</span>
 943 
 944             /*
<span class="line-modified"> 945              * Invoke insertion sort on small leftmost part.</span>



 946              */
<span class="line-modified"> 947             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-modified"> 948                 insertionSort(a, low, high);</span>
<span class="line-added"> 949                 return;</span>
<span class="line-added"> 950             }</span>
 951 
 952             /*
<span class="line-modified"> 953              * Check if the whole array or large non-leftmost</span>
<span class="line-added"> 954              * parts are nearly sorted and then merge runs.</span>
 955              */
<span class="line-modified"> 956             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="line-modified"> 957                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="line-added"> 958                 return;</span>
<span class="line-added"> 959             }</span>
 960 
 961             /*
<span class="line-modified"> 962              * Switch to heap sort if execution</span>
<span class="line-modified"> 963              * time is becoming quadratic.</span>















 964              */
<span class="line-modified"> 965             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-modified"> 966                 heapSort(a, low, high);</span>
<span class="line-modified"> 967                 return;</span>




























 968             }
 969 
<span class="line-modified"> 970             /*</span>
<span class="line-modified"> 971              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-modified"> 972              * to select five sample elements and determine pivots.</span>
<span class="line-modified"> 973              */</span>
<span class="line-modified"> 974             int step = (size &gt;&gt; 3) * 3 + 3;</span>


 975 
 976             /*
<span class="line-modified"> 977              * Five elements around (and including) the central element</span>
<span class="line-modified"> 978              * will be used for pivot selection as described below. The</span>
<span class="line-added"> 979              * unequal choice of spacing these elements was empirically</span>
<span class="line-added"> 980              * determined to work well on a wide variety of inputs.</span>
 981              */
<span class="line-modified"> 982             int e1 = low + step;</span>
<span class="line-modified"> 983             int e5 = end - step;</span>
<span class="line-modified"> 984             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 985             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 986             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added"> 987             long a3 = a[e3];</span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989             /*</span>
<span class="line-added"> 990              * Sort these elements in place by the combination</span>
<span class="line-added"> 991              * of 4-element sorting network and insertion sort.</span>
<span class="line-added"> 992              *</span>
<span class="line-added"> 993              *    5 ------o-----------o------------</span>
<span class="line-added"> 994              *            |           |</span>
<span class="line-added"> 995              *    4 ------|-----o-----o-----o------</span>
<span class="line-added"> 996              *            |     |           |</span>
<span class="line-added"> 997              *    2 ------o-----|-----o-----o------</span>
<span class="line-added"> 998              *                  |     |</span>
<span class="line-added"> 999              *    1 ------------o-----o------------</span>
<span class="line-added">1000              */</span>
<span class="line-added">1001             if (a[e5] &lt; a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">1002             if (a[e4] &lt; a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">1003             if (a[e5] &lt; a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">1004             if (a[e2] &lt; a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">1005             if (a[e4] &lt; a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">1006 </span>
<span class="line-added">1007             if (a3 &lt; a[e2]) {</span>
<span class="line-added">1008                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">1009                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">1010                 } else {</span>
<span class="line-added">1011                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">1012                 }</span>
<span class="line-added">1013             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">1014                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">1015                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">1016                 } else {</span>
<span class="line-added">1017                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">1018                 }</span>
<span class="line-added">1019             }</span>
<span class="line-added">1020 </span>
<span class="line-added">1021             // Pointers</span>
<span class="line-added">1022             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">1023             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">1024 </span>
<span class="line-added">1025             /*</span>
<span class="line-added">1026              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">1027              */</span>
<span class="line-added">1028             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">1029 </span>
<span class="line-added">1030                 /*</span>
<span class="line-added">1031                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">1032                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">1033                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">1034                  */</span>
<span class="line-added">1035                 long pivot1 = a[e1];</span>
<span class="line-added">1036                 long pivot2 = a[e5];</span>
<span class="line-added">1037 </span>
<span class="line-added">1038                 /*</span>
<span class="line-added">1039                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">1040                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">1041                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">1042                  * into their final positions, and excluded from the next</span>
<span class="line-added">1043                  * subsequent sorting.</span>
1044                  */
<span class="line-modified">1045                 a[e1] = a[lower];</span>
<span class="line-modified">1046                 a[e5] = a[upper];</span>
<span class="line-added">1047 </span>
<span class="line-added">1048                 /*</span>
<span class="line-added">1049                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">1050                  */</span>
<span class="line-added">1051                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">1052                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">1053 </span>
<span class="line-added">1054                 /*</span>
<span class="line-added">1055                  * Backward 3-interval partitioning</span>
<span class="line-added">1056                  *</span>
<span class="line-added">1057                  *   left part                 central part          right part</span>
<span class="line-added">1058                  * +------------------------------------------------------------+</span>
<span class="line-added">1059                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">1060                  * +------------------------------------------------------------+</span>
<span class="line-added">1061                  *             ^       ^                            ^</span>
<span class="line-added">1062                  *             |       |                            |</span>
<span class="line-added">1063                  *           lower     k                          upper</span>
<span class="line-added">1064                  *</span>
<span class="line-added">1065                  * Invariants:</span>
<span class="line-added">1066                  *</span>
<span class="line-added">1067                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">1068                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">1069                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">1070                  *</span>
<span class="line-added">1071                  * Pointer k is the last index of ?-part</span>
<span class="line-added">1072                  */</span>
<span class="line-added">1073                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">1074                     long ak = a[k];</span>
<span class="line-added">1075 </span>
<span class="line-added">1076                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">1077                         while (lower &lt; k) {</span>
<span class="line-added">1078                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">1079                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">1080                                     a[k] = a[--upper];</span>
<span class="line-added">1081                                     a[upper] = a[lower];</span>
<span class="line-added">1082                                 } else {</span>
<span class="line-added">1083                                     a[k] = a[lower];</span>
<span class="line-added">1084                                 }</span>
<span class="line-added">1085                                 a[lower] = ak;</span>
<span class="line-added">1086                                 break;</span>
<span class="line-added">1087                             }</span>
<span class="line-added">1088                         }</span>
<span class="line-added">1089                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">1090                         a[k] = a[--upper];</span>
<span class="line-added">1091                         a[upper] = ak;</span>
<span class="line-added">1092                     }</span>
1093                 }
1094 
<span class="line-modified">1095                 /*</span>
<span class="line-modified">1096                  * Swap the pivots into their final positions.</span>
<span class="line-added">1097                  */</span>
<span class="line-added">1098                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">1099                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">1100 </span>
<span class="line-added">1101                 /*</span>
<span class="line-added">1102                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="line-added">1103                  * excluding known pivots.</span>
<span class="line-added">1104                  */</span>
<span class="line-added">1105                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">1106                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="line-added">1107                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="line-added">1108                 } else {</span>
<span class="line-added">1109                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="line-added">1110                     sort(sorter, a, bits | 1, upper + 1, high);</span>
1111                 }
1112 
<span class="line-added">1113             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">1114 </span>
<span class="line-added">1115                 /*</span>
<span class="line-added">1116                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">1117                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">1118                  */</span>
<span class="line-added">1119                 long pivot = a[e3];</span>
<span class="line-added">1120 </span>
<span class="line-added">1121                 /*</span>
<span class="line-added">1122                  * The first element to be sorted is moved to the</span>
<span class="line-added">1123                  * location formerly occupied by the pivot. After</span>
<span class="line-added">1124                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">1125                  * back into its final position, and excluded from</span>
<span class="line-added">1126                  * the next subsequent sorting.</span>
<span class="line-added">1127                  */</span>
<span class="line-added">1128                 a[e3] = a[lower];</span>
<span class="line-added">1129 </span>
1130                 /*
<span class="line-modified">1131                  * Traditional 3-way (Dutch National Flag) partitioning</span>
1132                  *
<span class="line-modified">1133                  *   left part                 central part    right part</span>
<span class="line-modified">1134                  * +------------------------------------------------------+</span>
<span class="line-modified">1135                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-modified">1136                  * +------------------------------------------------------+</span>
<span class="line-modified">1137                  *              ^           ^                ^</span>
<span class="line-modified">1138                  *              |           |                |</span>
<span class="line-modified">1139                  *            lower         k              upper</span>
1140                  *
1141                  * Invariants:
1142                  *
<span class="line-modified">1143                  *   all in (low, lower] &lt; pivot</span>
<span class="line-modified">1144                  *   all in (k, upper)  == pivot</span>
<span class="line-modified">1145                  *   all in [upper, end] &gt; pivot</span>
1146                  *
<span class="line-modified">1147                  * Pointer k is the last index of ?-part</span>
1148                  */
<span class="line-modified">1149                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-modified">1150                     long ak = a[k];</span>
<span class="line-modified">1151 </span>
<span class="line-modified">1152                     if (ak != pivot) {</span>
<span class="line-modified">1153                         a[k] = pivot;</span>
<span class="line-modified">1154 </span>
<span class="line-modified">1155                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-modified">1156                             while (a[++lower] &lt; pivot);</span>
<span class="line-modified">1157 </span>
<span class="line-modified">1158                             if (a[lower] &gt; pivot) {</span>
<span class="line-modified">1159                                 a[--upper] = a[lower];</span>
1160                             }
<span class="line-added">1161                             a[lower] = ak;</span>
<span class="line-added">1162                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">1163                             a[--upper] = ak;</span>
1164                         }

















1165                     }
1166                 }
<span class="line-added">1167 </span>
<span class="line-added">1168                 /*</span>
<span class="line-added">1169                  * Swap the pivot into its final position.</span>
<span class="line-added">1170                  */</span>
<span class="line-added">1171                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">1172 </span>
<span class="line-added">1173                 /*</span>
<span class="line-added">1174                  * Sort the right part (possibly in parallel), excluding</span>
<span class="line-added">1175                  * known pivot. All elements from the central part are</span>
<span class="line-added">1176                  * equal and therefore already sorted.</span>
<span class="line-added">1177                  */</span>
<span class="line-added">1178                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">1179                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="line-added">1180                 } else {</span>
<span class="line-added">1181                     sort(sorter, a, bits | 1, upper, high);</span>
<span class="line-added">1182                 }</span>
1183             }
<span class="line-added">1184             high = lower; // Iterate along the left part</span>
<span class="line-added">1185         }</span>
<span class="line-added">1186     }</span>
1187 
<span class="line-modified">1188     /**</span>
<span class="line-modified">1189      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="line-added">1190      *</span>
<span class="line-added">1191      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="line-added">1192      * pin insertion sort and pair insertion sort.</span>
<span class="line-added">1193      *</span>
<span class="line-added">1194      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="line-added">1195      * from the left part plays the role of sentinel, because it</span>
<span class="line-added">1196      * is less than any elements from the given part. Therefore,</span>
<span class="line-added">1197      * expensive check of the left range can be skipped on each</span>
<span class="line-added">1198      * iteration unless it is the leftmost call.</span>
<span class="line-added">1199      *</span>
<span class="line-added">1200      * @param a the array to be sorted</span>
<span class="line-added">1201      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1202      * @param end the index of the last element for simple insertion sort</span>
<span class="line-added">1203      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1204      */</span>
<span class="line-added">1205     private static void mixedInsertionSort(long[] a, int low, int end, int high) {</span>
<span class="line-added">1206         if (end == high) {</span>
1207 

1208             /*
<span class="line-modified">1209              * Invoke simple insertion sort on tiny array.</span>

1210              */
<span class="line-modified">1211             for (int i; ++low &lt; end; ) {</span>
<span class="line-added">1212                 long ai = a[i = low];</span>
<span class="line-added">1213 </span>
<span class="line-added">1214                 while (ai &lt; a[--i]) {</span>
<span class="line-added">1215                     a[i + 1] = a[i];</span>
<span class="line-added">1216                 }</span>
<span class="line-added">1217                 a[i + 1] = ai;</span>
<span class="line-added">1218             }</span>
<span class="line-added">1219         } else {</span>
1220 
1221             /*
<span class="line-modified">1222              * Start with pin insertion sort on small part.</span>











1223              *
<span class="line-modified">1224              * Pin insertion sort is extended simple insertion sort.</span>
<span class="line-modified">1225              * The main idea of this sort is to put elements larger</span>
<span class="line-modified">1226              * than an element called pin to the end of array (the</span>
<span class="line-modified">1227              * proper area for such elements). It avoids expensive</span>
<span class="line-modified">1228              * movements of these elements through the whole array.</span>
1229              */
<span class="line-modified">1230             long pin = a[end];</span>
<span class="line-modified">1231 </span>
<span class="line-modified">1232             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="line-modified">1233                 long ai = a[i = low];</span>
<span class="line-modified">1234 </span>
<span class="line-modified">1235                 if (ai &lt; a[i - 1]) { // Small element</span>
<span class="line-modified">1236 </span>
<span class="line-modified">1237                     /*</span>
<span class="line-modified">1238                      * Insert small element into sorted part.</span>
<span class="line-modified">1239                      */</span>
<span class="line-modified">1240                     a[i] = a[--i];</span>
<span class="line-modified">1241 </span>
<span class="line-added">1242                     while (ai &lt; a[--i]) {</span>
<span class="line-added">1243                         a[i + 1] = a[i];</span>
1244                     }
<span class="line-modified">1245                     a[i + 1] = ai;</span>
<span class="line-modified">1246 </span>
<span class="line-modified">1247                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="line-modified">1248 </span>
<span class="line-modified">1249                     /*</span>
<span class="line-modified">1250                      * Find element smaller than pin.</span>
<span class="line-modified">1251                      */</span>
<span class="line-modified">1252                     while (a[--p] &gt; pin);</span>
<span class="line-modified">1253 </span>
<span class="line-modified">1254                     /*</span>
<span class="line-modified">1255                      * Swap it with large element.</span>
<span class="line-modified">1256                      */</span>
<span class="line-modified">1257                     if (p &gt; i) {</span>
<span class="line-modified">1258                         ai = a[p];</span>
<span class="line-added">1259                         a[p] = a[i];</span>
<span class="line-added">1260                     }</span>
<span class="line-added">1261 </span>
<span class="line-added">1262                     /*</span>
<span class="line-added">1263                      * Insert small element into sorted part.</span>
<span class="line-added">1264                      */</span>
<span class="line-added">1265                     while (ai &lt; a[--i]) {</span>
<span class="line-added">1266                         a[i + 1] = a[i];</span>
1267                     }
<span class="line-modified">1268                     a[i + 1] = ai;</span>

1269                 }
1270             }
1271 
1272             /*
<span class="line-modified">1273              * Continue with pair insertion sort on remain part.</span>


1274              */
<span class="line-modified">1275             for (int i; low &lt; high; ++low) {</span>
<span class="line-modified">1276                 long a1 = a[i = low], a2 = a[++low];</span>
<span class="line-added">1277 </span>
<span class="line-added">1278                 /*</span>
<span class="line-added">1279                  * Insert two elements per iteration: at first, insert the</span>
<span class="line-added">1280                  * larger element and then insert the smaller element, but</span>
<span class="line-added">1281                  * from the position where the larger element was inserted.</span>
<span class="line-added">1282                  */</span>
<span class="line-added">1283                 if (a1 &gt; a2) {</span>
<span class="line-added">1284 </span>
<span class="line-added">1285                     while (a1 &lt; a[--i]) {</span>
<span class="line-added">1286                         a[i + 2] = a[i];</span>
<span class="line-added">1287                     }</span>
<span class="line-added">1288                     a[++i + 1] = a1;</span>
<span class="line-added">1289 </span>
<span class="line-added">1290                     while (a2 &lt; a[--i]) {</span>
<span class="line-added">1291                         a[i + 1] = a[i];</span>
<span class="line-added">1292                     }</span>
<span class="line-added">1293                     a[i + 1] = a2;</span>
<span class="line-added">1294 </span>
<span class="line-added">1295                 } else if (a1 &lt; a[i - 1]) {</span>
<span class="line-added">1296 </span>
<span class="line-added">1297                     while (a2 &lt; a[--i]) {</span>
<span class="line-added">1298                         a[i + 2] = a[i];</span>
<span class="line-added">1299                     }</span>
<span class="line-added">1300                     a[++i + 1] = a2;</span>
<span class="line-added">1301 </span>
<span class="line-added">1302                     while (a1 &lt; a[--i]) {</span>
<span class="line-added">1303                         a[i + 1] = a[i];</span>
<span class="line-added">1304                     }</span>
<span class="line-added">1305                     a[i + 1] = a1;</span>
<span class="line-added">1306                 }</span>
<span class="line-added">1307             }</span>
1308         }
1309     }
1310 



1311     /**
<span class="line-modified">1312      * Sorts the specified range of the array using insertion sort.</span>
1313      *
1314      * @param a the array to be sorted
<span class="line-modified">1315      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1316      * @param high the index of the last element, exclusive, to be sorted</span>
1317      */
<span class="line-modified">1318     private static void insertionSort(long[] a, int low, int high) {</span>
<span class="line-modified">1319         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-modified">1320             long ai = a[i = k];</span>









1321 
<span class="line-modified">1322             if (ai &lt; a[i - 1]) {</span>
<span class="line-modified">1323                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-modified">1324                     a[i + 1] = a[i];</span>









1325                 }
<span class="line-modified">1326                 a[i + 1] = ai;</span>
1327             }
1328         }
1329     }
1330 
1331     /**
<span class="line-modified">1332      * Sorts the specified range of the array using heap sort.</span>

1333      *
1334      * @param a the array to be sorted
<span class="line-modified">1335      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1336      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified">1337      */</span>
<span class="line-modified">1338     private static void heapSort(long[] a, int low, int high) {</span>
<span class="line-modified">1339         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="line-modified">1340             pushDown(a, --k, a[k], low, high);</span>
<span class="line-modified">1341         }</span>
<span class="line-modified">1342         while (--high &gt; low) {</span>
<span class="line-modified">1343             long max = a[low];</span>
<span class="line-modified">1344             pushDown(a, low, a[high], low, high);</span>
<span class="line-modified">1345             a[high] = max;</span>


1346         }
<span class="line-modified">1347     }</span>
<span class="line-modified">1348 </span>
<span class="line-modified">1349     /**</span>
<span class="line-modified">1350      * Pushes specified element down during heap sort.</span>
<span class="line-modified">1351      *</span>
<span class="line-modified">1352      * @param a the given array</span>
<span class="line-added">1353      * @param p the start index</span>
<span class="line-added">1354      * @param value the given element</span>
<span class="line-added">1355      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1356      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1357      */</span>
<span class="line-added">1358     private static void pushDown(long[] a, int p, long value, int low, int high) {</span>
<span class="line-added">1359         for (int k ;; a[p] = a[p = k]) {</span>
<span class="line-added">1360             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
<span class="line-added">1361 </span>
<span class="line-added">1362             if (k &gt; high) {</span>
<span class="line-added">1363                 break;</span>
<span class="line-added">1364             }</span>
<span class="line-added">1365             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="line-added">1366                 --k;</span>
<span class="line-added">1367             }</span>
<span class="line-added">1368             if (a[k] &lt;= value) {</span>
<span class="line-added">1369                 break;</span>
1370             }
1371         }
<span class="line-added">1372         a[p] = value;</span>
<span class="line-added">1373     }</span>
1374 
<span class="line-modified">1375     /**</span>
<span class="line-modified">1376      * Tries to sort the specified range of the array.</span>
<span class="line-modified">1377      *</span>
<span class="line-modified">1378      * @param sorter parallel context</span>
<span class="line-added">1379      * @param a the array to be sorted</span>
<span class="line-added">1380      * @param low the index of the first element to be sorted</span>
<span class="line-added">1381      * @param size the array size</span>
<span class="line-added">1382      * @return true if finally sorted, false otherwise</span>
<span class="line-added">1383      */</span>
<span class="line-added">1384     private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {</span>
1385 
1386         /*
<span class="line-modified">1387          * The run array is constructed only if initial runs are</span>
<span class="line-added">1388          * long enough to continue, run[i] then holds start index</span>
<span class="line-added">1389          * of the i-th sequence of elements in non-descending order.</span>
1390          */
<span class="line-modified">1391         int[] run = null;</span>
<span class="line-added">1392         int high = low + size;</span>
<span class="line-added">1393         int count = 1, last = low;</span>
1394 
1395         /*
<span class="line-modified">1396          * Identify all possible runs.</span>
1397          */
<span class="line-modified">1398         for (int k = low + 1; k &lt; high; ) {</span>


1399 
<span class="line-modified">1400             /*</span>
<span class="line-modified">1401              * Find the end index of the current run.</span>
<span class="line-modified">1402              */</span>
<span class="line-modified">1403             if (a[k - 1] &lt; a[k]) {</span>
<span class="line-added">1404 </span>
<span class="line-added">1405                 // Identify ascending sequence</span>
<span class="line-added">1406                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-added">1407 </span>
<span class="line-added">1408             } else if (a[k - 1] &gt; a[k]) {</span>
<span class="line-added">1409 </span>
<span class="line-added">1410                 // Identify descending sequence</span>
<span class="line-added">1411                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-added">1412 </span>
<span class="line-added">1413                 // Reverse into ascending order</span>
<span class="line-added">1414                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="line-added">1415                     long ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="line-added">1416                 }</span>
<span class="line-added">1417             } else { // Identify constant sequence</span>
<span class="line-added">1418                 for (long ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
<span class="line-added">1419 </span>
<span class="line-added">1420                 if (k &lt; high) {</span>
<span class="line-added">1421                     continue;</span>
<span class="line-added">1422                 }</span>
1423             }

1424 
<span class="line-modified">1425             /*</span>
<span class="line-modified">1426              * Check special cases.</span>
<span class="line-modified">1427              */</span>
<span class="line-modified">1428             if (run == null) {</span>
<span class="line-modified">1429                 if (k == high) {</span>
<span class="line-added">1430 </span>
<span class="line-added">1431                     /*</span>
<span class="line-added">1432                      * The array is monotonous sequence,</span>
<span class="line-added">1433                      * and therefore already sorted.</span>
<span class="line-added">1434                      */</span>
<span class="line-added">1435                     return true;</span>
<span class="line-added">1436                 }</span>
<span class="line-added">1437 </span>
<span class="line-added">1438                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="line-added">1439 </span>
<span class="line-added">1440                     /*</span>
<span class="line-added">1441                      * The first run is too small</span>
<span class="line-added">1442                      * to proceed with scanning.</span>
<span class="line-added">1443                      */</span>
<span class="line-added">1444                     return false;</span>
<span class="line-added">1445                 }</span>
<span class="line-added">1446 </span>
<span class="line-added">1447                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="line-added">1448                 run[0] = low;</span>
<span class="line-added">1449 </span>
<span class="line-added">1450             } else if (a[last - 1] &gt; a[last]) {</span>
<span class="line-added">1451 </span>
<span class="line-added">1452                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
<span class="line-added">1453 </span>
<span class="line-added">1454                     /*</span>
<span class="line-added">1455                      * The first runs are not long</span>
<span class="line-added">1456                      * enough to continue scanning.</span>
<span class="line-added">1457                      */</span>
<span class="line-added">1458                     return false;</span>
<span class="line-added">1459                 }</span>
<span class="line-added">1460 </span>
<span class="line-added">1461                 if (++count == MAX_RUN_CAPACITY) {</span>
<span class="line-added">1462 </span>
<span class="line-added">1463                     /*</span>
<span class="line-added">1464                      * Array is not highly structured.</span>
<span class="line-added">1465                      */</span>
<span class="line-added">1466                     return false;</span>
<span class="line-added">1467                 }</span>
<span class="line-added">1468 </span>
<span class="line-added">1469                 if (count == run.length) {</span>
<span class="line-added">1470 </span>
<span class="line-added">1471                     /*</span>
<span class="line-added">1472                      * Increase capacity of index array.</span>
<span class="line-added">1473                      */</span>
<span class="line-added">1474                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
<span class="line-added">1475                 }</span>
<span class="line-added">1476             }</span>
<span class="line-added">1477             run[count] = (last = k);</span>
1478         }
1479 
1480         /*
<span class="line-modified">1481          * Merge runs of highly structured array.</span>


















1482          */
<span class="line-modified">1483         if (count &gt; 1) {</span>
<span class="line-modified">1484             long[] b; int offset = low;</span>
<span class="line-modified">1485 </span>
<span class="line-modified">1486             if (sorter == null || (b = (long[]) sorter.b) == null) {</span>
<span class="line-modified">1487                 b = new long[size];</span>
<span class="line-modified">1488             } else {</span>
<span class="line-modified">1489                 offset = sorter.offset;</span>

1490             }
<span class="line-added">1491             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
1492         }
<span class="line-added">1493         return true;</span>
1494     }
1495 
1496     /**
<span class="line-modified">1497      * Merges the specified runs.</span>
1498      *
<span class="line-modified">1499      * @param a the source array</span>
<span class="line-modified">1500      * @param b the temporary buffer used in merging</span>
<span class="line-modified">1501      * @param offset the start index in the source, inclusive</span>
<span class="line-modified">1502      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="line-modified">1503      * @param parallel indicates whether merging is performed in parallel</span>
<span class="line-modified">1504      * @param run the start indexes of the runs, inclusive</span>
<span class="line-modified">1505      * @param lo the start index of the first run, inclusive</span>
<span class="line-modified">1506      * @param hi the start index of the last run, inclusive</span>
<span class="line-modified">1507      * @return the destination where runs are merged</span>
<span class="line-modified">1508      */</span>
<span class="line-modified">1509     private static long[] mergeRuns(long[] a, long[] b, int offset,</span>
<span class="line-modified">1510             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="line-modified">1511 </span>
<span class="line-added">1512         if (hi - lo == 1) {</span>
<span class="line-added">1513             if (aim &gt;= 0) {</span>
<span class="line-added">1514                 return a;</span>
<span class="line-added">1515             }</span>
<span class="line-added">1516             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="line-added">1517                 b[--j] = a[--i]</span>
<span class="line-added">1518             );</span>
<span class="line-added">1519             return b;</span>
1520         }
1521 
1522         /*
<span class="line-modified">1523          * Split into approximately equal parts.</span>

1524          */
<span class="line-modified">1525         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="line-modified">1526         while (run[++mi + 1] &lt;= rmi);</span>
















1527 
<span class="line-modified">1528         /*</span>
<span class="line-modified">1529          * Merge the left and right parts.</span>
<span class="line-modified">1530          */</span>
<span class="line-modified">1531         long[] a1, a2;</span>

1532 
<span class="line-modified">1533         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="line-modified">1534             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="line-modified">1535             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="line-modified">1536             a2 = (long[]) merger.getDestination();</span>
<span class="line-modified">1537         } else {</span>
<span class="line-modified">1538             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="line-modified">1539             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>

1540         }
1541 
<span class="line-modified">1542         long[] dst = a1 == a ? b : a;</span>


1543 
<span class="line-modified">1544         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="line-modified">1545         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="line-modified">1546         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified">1547         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified">1548         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="line-modified">1549 </span>
<span class="line-modified">1550         if (parallel) {</span>
<span class="line-modified">1551             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>




























1552         } else {
<span class="line-modified">1553             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>

























1554         }
<span class="line-added">1555         return dst;</span>
1556     }
1557 
1558     /**
<span class="line-modified">1559      * Merges the sorted parts.</span>
1560      *
<span class="line-modified">1561      * @param merger parallel context</span>
<span class="line-modified">1562      * @param dst the destination where parts are merged</span>
<span class="line-modified">1563      * @param k the start index of the destination, inclusive</span>
<span class="line-modified">1564      * @param a1 the first part</span>
<span class="line-modified">1565      * @param lo1 the start index of the first part, inclusive</span>
<span class="line-modified">1566      * @param hi1 the end index of the first part, exclusive</span>
<span class="line-modified">1567      * @param a2 the second part</span>
<span class="line-modified">1568      * @param lo2 the start index of the second part, inclusive</span>
<span class="line-modified">1569      * @param hi2 the end index of the second part, exclusive</span>
<span class="line-modified">1570      */</span>
<span class="line-modified">1571     private static void mergeParts(Merger merger, long[] dst, int k,</span>
<span class="line-modified">1572             long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {</span>
<span class="line-modified">1573 </span>
<span class="line-modified">1574         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="line-modified">1575 </span>
<span class="line-modified">1576             while (true) {</span>
<span class="line-modified">1577 </span>
<span class="line-modified">1578                 /*</span>
<span class="line-modified">1579                  * The first part must be larger.</span>
<span class="line-modified">1580                  */</span>
<span class="line-modified">1581                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="line-modified">1582                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="line-modified">1583                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>


1584                 }
<span class="line-modified">1585 </span>
1586                 /*
<span class="line-modified">1587                  * Small parts will be merged sequentially.</span>
1588                  */
<span class="line-modified">1589                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="line-modified">1590                     break;</span>
<span class="line-modified">1591                 }</span>


1592 
1593                 /*
<span class="line-modified">1594                  * Find the median of the larger part.</span>





1595                  */
<span class="line-modified">1596                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="line-modified">1597                 long key = a1[mi1];</span>
<span class="line-added">1598                 int mi2 = hi2;</span>
1599 
<span class="line-modified">1600                 /*</span>
<span class="line-modified">1601                  * Partition the smaller part.</span>
<span class="line-modified">1602                  */</span>
<span class="line-modified">1603                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="line-modified">1604                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>


1605 
<span class="line-modified">1606                     if (key &gt; a2[t]) {</span>
<span class="line-modified">1607                         loo = t + 1;</span>
<span class="line-added">1608                     } else {</span>
<span class="line-added">1609                         mi2 = t;</span>
1610                     }

1611                 }

1612 
<span class="line-modified">1613                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="line-modified">1614 </span>
<span class="line-modified">1615                 /*</span>
<span class="line-modified">1616                  * Merge the right sub-parts in parallel.</span>
<span class="line-added">1617                  */</span>
<span class="line-added">1618                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="line-added">1619 </span>
<span class="line-added">1620                 /*</span>
<span class="line-added">1621                  * Process the sub-left parts.</span>
<span class="line-added">1622                  */</span>
<span class="line-added">1623                 hi1 = mi1;</span>
<span class="line-added">1624                 hi2 = mi2;</span>
1625             }

1626         }
1627 



1628         /*
<span class="line-modified">1629          * Merge small parts sequentially.</span>




1630          */
<span class="line-modified">1631         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="line-modified">1632             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>









1633         }
<span class="line-modified">1634         if (dst != a1 || k &lt; lo1) {</span>
<span class="line-modified">1635             while (lo1 &lt; hi1) {</span>
<span class="line-modified">1636                 dst[k++] = a1[lo1++];</span>
1637             }
1638         }
<span class="line-modified">1639         if (dst != a2 || k &lt; lo2) {</span>
<span class="line-modified">1640             while (lo2 &lt; hi2) {</span>
<span class="line-modified">1641                 dst[k++] = a2[lo2++];</span>


1642             }
1643         }
<span class="line-added">1644     }</span>
1645 
<span class="line-modified">1646 // [byte]</span>











1647 
<span class="line-modified">1648     /**</span>
<span class="line-modified">1649      * Sorts the specified range of the array using</span>
<span class="line-modified">1650      * counting sort or insertion sort.</span>
<span class="line-modified">1651      *</span>
<span class="line-modified">1652      * @param a the array to be sorted</span>
<span class="line-modified">1653      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">1654      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified">1655      */</span>
<span class="line-added">1656     static void sort(byte[] a, int low, int high) {</span>
<span class="line-added">1657         if (high - low &gt; MIN_BYTE_COUNTING_SORT_SIZE) {</span>
<span class="line-added">1658             countingSort(a, low, high);</span>
<span class="line-added">1659         } else {</span>
<span class="line-added">1660             insertionSort(a, low, high);</span>
<span class="line-added">1661         }</span>
<span class="line-added">1662     }</span>
1663 
<span class="line-modified">1664     /**</span>
<span class="line-modified">1665      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-modified">1666      *</span>
<span class="line-modified">1667      * @param a the array to be sorted</span>
<span class="line-modified">1668      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1669      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1670      */</span>
<span class="line-added">1671     private static void insertionSort(byte[] a, int low, int high) {</span>
<span class="line-added">1672         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">1673             byte ai = a[i = k];</span>
<span class="line-added">1674 </span>
<span class="line-added">1675             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">1676                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">1677                     a[i + 1] = a[i];</span>
<span class="line-added">1678                 }</span>
<span class="line-added">1679                 a[i + 1] = ai;</span>
<span class="line-added">1680             }</span>
<span class="line-added">1681         }</span>
<span class="line-added">1682     }</span>
<span class="line-added">1683 </span>
<span class="line-added">1684     /**</span>
<span class="line-added">1685      * The number of distinct byte values.</span>
<span class="line-added">1686      */</span>
<span class="line-added">1687     private static final int NUM_BYTE_VALUES = 1 &lt;&lt; 8;</span>
<span class="line-added">1688 </span>
<span class="line-added">1689     /**</span>
<span class="line-added">1690      * Max index of byte counter.</span>
<span class="line-added">1691      */</span>
<span class="line-added">1692     private static final int MAX_BYTE_INDEX = Byte.MAX_VALUE + NUM_BYTE_VALUES + 1;</span>
<span class="line-added">1693 </span>
<span class="line-added">1694     /**</span>
<span class="line-added">1695      * Sorts the specified range of the array using counting sort.</span>
<span class="line-added">1696      *</span>
<span class="line-added">1697      * @param a the array to be sorted</span>
<span class="line-added">1698      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1699      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1700      */</span>
<span class="line-added">1701     private static void countingSort(byte[] a, int low, int high) {</span>
<span class="line-added">1702         int[] count = new int[NUM_BYTE_VALUES];</span>
<span class="line-added">1703 </span>
<span class="line-added">1704         /*</span>
<span class="line-added">1705          * Compute a histogram with the number of each values.</span>
<span class="line-added">1706          */</span>
<span class="line-added">1707         for (int i = high; i &gt; low; ++count[a[--i] &amp; 0xFF]);</span>
<span class="line-added">1708 </span>
<span class="line-added">1709         /*</span>
<span class="line-added">1710          * Place values on their final positions.</span>
<span class="line-added">1711          */</span>
<span class="line-added">1712         if (high - low &gt; NUM_BYTE_VALUES) {</span>
<span class="line-added">1713             for (int i = MAX_BYTE_INDEX; --i &gt; Byte.MAX_VALUE; ) {</span>
<span class="line-added">1714                 int value = i &amp; 0xFF;</span>
<span class="line-added">1715 </span>
<span class="line-added">1716                 for (low = high - count[value]; high &gt; low;</span>
<span class="line-added">1717                     a[--high] = (byte) value</span>
<span class="line-added">1718                 );</span>
<span class="line-added">1719             }</span>
<span class="line-added">1720         } else {</span>
<span class="line-added">1721             for (int i = MAX_BYTE_INDEX; high &gt; low; ) {</span>
<span class="line-added">1722                 while (count[--i &amp; 0xFF] == 0);</span>
<span class="line-added">1723 </span>
<span class="line-added">1724                 int value = i &amp; 0xFF;</span>
<span class="line-added">1725                 int c = count[value];</span>
<span class="line-added">1726 </span>
<span class="line-added">1727                 do {</span>
<span class="line-added">1728                     a[--high] = (byte) value;</span>
<span class="line-added">1729                 } while (--c &gt; 0);</span>
<span class="line-added">1730             }</span>
<span class="line-added">1731         }</span>
<span class="line-added">1732     }</span>
<span class="line-added">1733 </span>
<span class="line-added">1734 // [char]</span>
<span class="line-added">1735 </span>
<span class="line-added">1736     /**</span>
<span class="line-added">1737      * Sorts the specified range of the array using</span>
<span class="line-added">1738      * counting sort or Dual-Pivot Quicksort.</span>
<span class="line-added">1739      *</span>
<span class="line-added">1740      * @param a the array to be sorted</span>
<span class="line-added">1741      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1742      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1743      */</span>
<span class="line-added">1744     static void sort(char[] a, int low, int high) {</span>
<span class="line-added">1745         if (high - low &gt; MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {</span>
<span class="line-added">1746             countingSort(a, low, high);</span>
<span class="line-added">1747         } else {</span>
<span class="line-added">1748             sort(a, 0, low, high);</span>
<span class="line-added">1749         }</span>
<span class="line-added">1750     }</span>
<span class="line-added">1751 </span>
<span class="line-added">1752     /**</span>
<span class="line-added">1753      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-added">1754      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added">1755      *</span>
<span class="line-added">1756      * @param a the array to be sorted</span>
<span class="line-added">1757      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added">1758      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added">1759      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1760      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1761      */</span>
<span class="line-added">1762     static void sort(char[] a, int bits, int low, int high) {</span>
<span class="line-added">1763         while (true) {</span>
<span class="line-added">1764             int end = high - 1, size = high - low;</span>
<span class="line-added">1765 </span>
<span class="line-added">1766             /*</span>
<span class="line-added">1767              * Invoke insertion sort on small leftmost part.</span>
<span class="line-added">1768              */</span>
<span class="line-added">1769             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-added">1770                 insertionSort(a, low, high);</span>
<span class="line-added">1771                 return;</span>
<span class="line-added">1772             }</span>
<span class="line-added">1773 </span>
<span class="line-added">1774             /*</span>
<span class="line-added">1775              * Switch to counting sort if execution</span>
<span class="line-added">1776              * time is becoming quadratic.</span>
<span class="line-added">1777              */</span>
<span class="line-added">1778             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-added">1779                 countingSort(a, low, high);</span>
<span class="line-added">1780                 return;</span>
<span class="line-added">1781             }</span>
<span class="line-added">1782 </span>
<span class="line-added">1783             /*</span>
<span class="line-added">1784              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-added">1785              * to select five sample elements and determine pivots.</span>
<span class="line-added">1786              */</span>
<span class="line-added">1787             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="line-added">1788 </span>
<span class="line-added">1789             /*</span>
<span class="line-added">1790              * Five elements around (and including) the central element</span>
<span class="line-added">1791              * will be used for pivot selection as described below. The</span>
<span class="line-added">1792              * unequal choice of spacing these elements was empirically</span>
<span class="line-added">1793              * determined to work well on a wide variety of inputs.</span>
<span class="line-added">1794              */</span>
<span class="line-added">1795             int e1 = low + step;</span>
<span class="line-added">1796             int e5 = end - step;</span>
<span class="line-added">1797             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">1798             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added">1799             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">1800             char a3 = a[e3];</span>
<span class="line-added">1801 </span>
<span class="line-added">1802             /*</span>
<span class="line-added">1803              * Sort these elements in place by the combination</span>
<span class="line-added">1804              * of 4-element sorting network and insertion sort.</span>
<span class="line-added">1805              *</span>
<span class="line-added">1806              *    5 ------o-----------o------------</span>
<span class="line-added">1807              *            |           |</span>
<span class="line-added">1808              *    4 ------|-----o-----o-----o------</span>
<span class="line-added">1809              *            |     |           |</span>
<span class="line-added">1810              *    2 ------o-----|-----o-----o------</span>
<span class="line-added">1811              *                  |     |</span>
<span class="line-added">1812              *    1 ------------o-----o------------</span>
<span class="line-added">1813              */</span>
<span class="line-added">1814             if (a[e5] &lt; a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">1815             if (a[e4] &lt; a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">1816             if (a[e5] &lt; a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">1817             if (a[e2] &lt; a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">1818             if (a[e4] &lt; a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">1819 </span>
<span class="line-added">1820             if (a3 &lt; a[e2]) {</span>
<span class="line-added">1821                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">1822                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">1823                 } else {</span>
<span class="line-added">1824                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">1825                 }</span>
<span class="line-added">1826             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">1827                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">1828                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">1829                 } else {</span>
<span class="line-added">1830                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">1831                 }</span>
<span class="line-added">1832             }</span>
<span class="line-added">1833 </span>
<span class="line-added">1834             // Pointers</span>
<span class="line-added">1835             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">1836             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">1837 </span>
<span class="line-added">1838             /*</span>
<span class="line-added">1839              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">1840              */</span>
<span class="line-added">1841             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">1842 </span>
<span class="line-added">1843                 /*</span>
<span class="line-added">1844                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">1845                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">1846                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">1847                  */</span>
<span class="line-added">1848                 char pivot1 = a[e1];</span>
<span class="line-added">1849                 char pivot2 = a[e5];</span>
<span class="line-added">1850 </span>
<span class="line-added">1851                 /*</span>
<span class="line-added">1852                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">1853                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">1854                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">1855                  * into their final positions, and excluded from the next</span>
<span class="line-added">1856                  * subsequent sorting.</span>
<span class="line-added">1857                  */</span>
<span class="line-added">1858                 a[e1] = a[lower];</span>
<span class="line-added">1859                 a[e5] = a[upper];</span>
<span class="line-added">1860 </span>
<span class="line-added">1861                 /*</span>
<span class="line-added">1862                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">1863                  */</span>
<span class="line-added">1864                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">1865                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">1866 </span>
<span class="line-added">1867                 /*</span>
<span class="line-added">1868                  * Backward 3-interval partitioning</span>
<span class="line-added">1869                  *</span>
<span class="line-added">1870                  *   left part                 central part          right part</span>
<span class="line-added">1871                  * +------------------------------------------------------------+</span>
<span class="line-added">1872                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">1873                  * +------------------------------------------------------------+</span>
<span class="line-added">1874                  *             ^       ^                            ^</span>
<span class="line-added">1875                  *             |       |                            |</span>
<span class="line-added">1876                  *           lower     k                          upper</span>
<span class="line-added">1877                  *</span>
<span class="line-added">1878                  * Invariants:</span>
<span class="line-added">1879                  *</span>
<span class="line-added">1880                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">1881                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">1882                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">1883                  *</span>
<span class="line-added">1884                  * Pointer k is the last index of ?-part</span>
<span class="line-added">1885                  */</span>
<span class="line-added">1886                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">1887                     char ak = a[k];</span>
<span class="line-added">1888 </span>
<span class="line-added">1889                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">1890                         while (lower &lt; k) {</span>
<span class="line-added">1891                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">1892                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">1893                                     a[k] = a[--upper];</span>
<span class="line-added">1894                                     a[upper] = a[lower];</span>
<span class="line-added">1895                                 } else {</span>
<span class="line-added">1896                                     a[k] = a[lower];</span>
<span class="line-added">1897                                 }</span>
<span class="line-added">1898                                 a[lower] = ak;</span>
<span class="line-added">1899                                 break;</span>
<span class="line-added">1900                             }</span>
<span class="line-added">1901                         }</span>
<span class="line-added">1902                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">1903                         a[k] = a[--upper];</span>
<span class="line-added">1904                         a[upper] = ak;</span>
<span class="line-added">1905                     }</span>
<span class="line-added">1906                 }</span>
<span class="line-added">1907 </span>
<span class="line-added">1908                 /*</span>
<span class="line-added">1909                  * Swap the pivots into their final positions.</span>
<span class="line-added">1910                  */</span>
<span class="line-added">1911                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">1912                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">1913 </span>
<span class="line-added">1914                 /*</span>
<span class="line-added">1915                  * Sort non-left parts recursively,</span>
<span class="line-added">1916                  * excluding known pivots.</span>
<span class="line-added">1917                  */</span>
<span class="line-added">1918                 sort(a, bits | 1, lower + 1, upper);</span>
<span class="line-added">1919                 sort(a, bits | 1, upper + 1, high);</span>
<span class="line-added">1920 </span>
<span class="line-added">1921             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">1922 </span>
<span class="line-added">1923                 /*</span>
<span class="line-added">1924                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">1925                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">1926                  */</span>
<span class="line-added">1927                 char pivot = a[e3];</span>
<span class="line-added">1928 </span>
<span class="line-added">1929                 /*</span>
<span class="line-added">1930                  * The first element to be sorted is moved to the</span>
<span class="line-added">1931                  * location formerly occupied by the pivot. After</span>
<span class="line-added">1932                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">1933                  * back into its final position, and excluded from</span>
<span class="line-added">1934                  * the next subsequent sorting.</span>
<span class="line-added">1935                  */</span>
<span class="line-added">1936                 a[e3] = a[lower];</span>
<span class="line-added">1937 </span>
<span class="line-added">1938                 /*</span>
<span class="line-added">1939                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-added">1940                  *</span>
<span class="line-added">1941                  *   left part                 central part    right part</span>
<span class="line-added">1942                  * +------------------------------------------------------+</span>
<span class="line-added">1943                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-added">1944                  * +------------------------------------------------------+</span>
<span class="line-added">1945                  *              ^           ^                ^</span>
<span class="line-added">1946                  *              |           |                |</span>
<span class="line-added">1947                  *            lower         k              upper</span>
<span class="line-added">1948                  *</span>
<span class="line-added">1949                  * Invariants:</span>
<span class="line-added">1950                  *</span>
<span class="line-added">1951                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added">1952                  *   all in (k, upper)  == pivot</span>
<span class="line-added">1953                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added">1954                  *</span>
<span class="line-added">1955                  * Pointer k is the last index of ?-part</span>
<span class="line-added">1956                  */</span>
<span class="line-added">1957                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">1958                     char ak = a[k];</span>
<span class="line-added">1959 </span>
<span class="line-added">1960                     if (ak != pivot) {</span>
<span class="line-added">1961                         a[k] = pivot;</span>
<span class="line-added">1962 </span>
<span class="line-added">1963                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-added">1964                             while (a[++lower] &lt; pivot);</span>
<span class="line-added">1965 </span>
<span class="line-added">1966                             if (a[lower] &gt; pivot) {</span>
<span class="line-added">1967                                 a[--upper] = a[lower];</span>
<span class="line-added">1968                             }</span>
<span class="line-added">1969                             a[lower] = ak;</span>
<span class="line-added">1970                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">1971                             a[--upper] = ak;</span>
<span class="line-added">1972                         }</span>
<span class="line-added">1973                     }</span>
<span class="line-added">1974                 }</span>
<span class="line-added">1975 </span>
<span class="line-added">1976                 /*</span>
<span class="line-added">1977                  * Swap the pivot into its final position.</span>
<span class="line-added">1978                  */</span>
<span class="line-added">1979                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">1980 </span>
<span class="line-added">1981                 /*</span>
<span class="line-added">1982                  * Sort the right part, excluding known pivot.</span>
<span class="line-added">1983                  * All elements from the central part are</span>
<span class="line-added">1984                  * equal and therefore already sorted.</span>
<span class="line-added">1985                  */</span>
<span class="line-added">1986                 sort(a, bits | 1, upper, high);</span>
<span class="line-added">1987             }</span>
<span class="line-added">1988             high = lower; // Iterate along the left part</span>
<span class="line-added">1989         }</span>
<span class="line-added">1990     }</span>
<span class="line-added">1991 </span>
<span class="line-added">1992     /**</span>
<span class="line-added">1993      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-added">1994      *</span>
<span class="line-added">1995      * @param a the array to be sorted</span>
<span class="line-added">1996      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">1997      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">1998      */</span>
<span class="line-added">1999     private static void insertionSort(char[] a, int low, int high) {</span>
<span class="line-added">2000         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">2001             char ai = a[i = k];</span>
<span class="line-added">2002 </span>
<span class="line-added">2003             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">2004                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">2005                     a[i + 1] = a[i];</span>
<span class="line-added">2006                 }</span>
<span class="line-added">2007                 a[i + 1] = ai;</span>
<span class="line-added">2008             }</span>
<span class="line-added">2009         }</span>
<span class="line-added">2010     }</span>
<span class="line-added">2011 </span>
<span class="line-added">2012     /**</span>
<span class="line-added">2013      * The number of distinct char values.</span>
<span class="line-added">2014      */</span>
<span class="line-added">2015     private static final int NUM_CHAR_VALUES = 1 &lt;&lt; 16;</span>
<span class="line-added">2016 </span>
<span class="line-added">2017     /**</span>
<span class="line-added">2018      * Sorts the specified range of the array using counting sort.</span>
<span class="line-added">2019      *</span>
<span class="line-added">2020      * @param a the array to be sorted</span>
<span class="line-added">2021      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2022      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2023      */</span>
<span class="line-added">2024     private static void countingSort(char[] a, int low, int high) {</span>
<span class="line-added">2025         int[] count = new int[NUM_CHAR_VALUES];</span>
<span class="line-added">2026 </span>
<span class="line-added">2027         /*</span>
<span class="line-added">2028          * Compute a histogram with the number of each values.</span>
<span class="line-added">2029          */</span>
<span class="line-added">2030         for (int i = high; i &gt; low; ++count[a[--i]]);</span>
<span class="line-added">2031 </span>
<span class="line-added">2032         /*</span>
<span class="line-added">2033          * Place values on their final positions.</span>
<span class="line-added">2034          */</span>
<span class="line-added">2035         if (high - low &gt; NUM_CHAR_VALUES) {</span>
<span class="line-added">2036             for (int i = NUM_CHAR_VALUES; i &gt; 0; ) {</span>
<span class="line-added">2037                 for (low = high - count[--i]; high &gt; low;</span>
<span class="line-added">2038                     a[--high] = (char) i</span>
<span class="line-added">2039                 );</span>
<span class="line-added">2040             }</span>
<span class="line-added">2041         } else {</span>
<span class="line-added">2042             for (int i = NUM_CHAR_VALUES; high &gt; low; ) {</span>
<span class="line-added">2043                 while (count[--i] == 0);</span>
<span class="line-added">2044                 int c = count[i];</span>
<span class="line-added">2045 </span>
<span class="line-added">2046                 do {</span>
<span class="line-added">2047                     a[--high] = (char) i;</span>
<span class="line-added">2048                 } while (--c &gt; 0);</span>
<span class="line-added">2049             }</span>
<span class="line-added">2050         }</span>
<span class="line-added">2051     }</span>
<span class="line-added">2052 </span>
<span class="line-added">2053 // [short]</span>
<span class="line-added">2054 </span>
<span class="line-added">2055     /**</span>
<span class="line-added">2056      * Sorts the specified range of the array using</span>
<span class="line-added">2057      * counting sort or Dual-Pivot Quicksort.</span>
<span class="line-added">2058      *</span>
<span class="line-added">2059      * @param a the array to be sorted</span>
<span class="line-added">2060      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2061      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2062      */</span>
<span class="line-added">2063     static void sort(short[] a, int low, int high) {</span>
<span class="line-added">2064         if (high - low &gt; MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {</span>
<span class="line-added">2065             countingSort(a, low, high);</span>
<span class="line-added">2066         } else {</span>
<span class="line-added">2067             sort(a, 0, low, high);</span>
<span class="line-added">2068         }</span>
<span class="line-added">2069     }</span>
<span class="line-added">2070 </span>
<span class="line-added">2071     /**</span>
<span class="line-added">2072      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-added">2073      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added">2074      *</span>
<span class="line-added">2075      * @param a the array to be sorted</span>
<span class="line-added">2076      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added">2077      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added">2078      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2079      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2080      */</span>
<span class="line-added">2081     static void sort(short[] a, int bits, int low, int high) {</span>
<span class="line-added">2082         while (true) {</span>
<span class="line-added">2083             int end = high - 1, size = high - low;</span>
<span class="line-added">2084 </span>
<span class="line-added">2085             /*</span>
<span class="line-added">2086              * Invoke insertion sort on small leftmost part.</span>
<span class="line-added">2087              */</span>
<span class="line-added">2088             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-added">2089                 insertionSort(a, low, high);</span>
<span class="line-added">2090                 return;</span>
<span class="line-added">2091             }</span>
<span class="line-added">2092 </span>
<span class="line-added">2093             /*</span>
<span class="line-added">2094              * Switch to counting sort if execution</span>
<span class="line-added">2095              * time is becoming quadratic.</span>
<span class="line-added">2096              */</span>
<span class="line-added">2097             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-added">2098                 countingSort(a, low, high);</span>
<span class="line-added">2099                 return;</span>
<span class="line-added">2100             }</span>
<span class="line-added">2101 </span>
<span class="line-added">2102             /*</span>
<span class="line-added">2103              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-added">2104              * to select five sample elements and determine pivots.</span>
<span class="line-added">2105              */</span>
<span class="line-added">2106             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="line-added">2107 </span>
<span class="line-added">2108             /*</span>
<span class="line-added">2109              * Five elements around (and including) the central element</span>
<span class="line-added">2110              * will be used for pivot selection as described below. The</span>
<span class="line-added">2111              * unequal choice of spacing these elements was empirically</span>
<span class="line-added">2112              * determined to work well on a wide variety of inputs.</span>
<span class="line-added">2113              */</span>
<span class="line-added">2114             int e1 = low + step;</span>
<span class="line-added">2115             int e5 = end - step;</span>
<span class="line-added">2116             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">2117             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added">2118             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">2119             short a3 = a[e3];</span>
<span class="line-added">2120 </span>
<span class="line-added">2121             /*</span>
<span class="line-added">2122              * Sort these elements in place by the combination</span>
<span class="line-added">2123              * of 4-element sorting network and insertion sort.</span>
<span class="line-added">2124              *</span>
<span class="line-added">2125              *    5 ------o-----------o------------</span>
<span class="line-added">2126              *            |           |</span>
<span class="line-added">2127              *    4 ------|-----o-----o-----o------</span>
<span class="line-added">2128              *            |     |           |</span>
<span class="line-added">2129              *    2 ------o-----|-----o-----o------</span>
<span class="line-added">2130              *                  |     |</span>
<span class="line-added">2131              *    1 ------------o-----o------------</span>
<span class="line-added">2132              */</span>
<span class="line-added">2133             if (a[e5] &lt; a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">2134             if (a[e4] &lt; a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">2135             if (a[e5] &lt; a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">2136             if (a[e2] &lt; a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">2137             if (a[e4] &lt; a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">2138 </span>
<span class="line-added">2139             if (a3 &lt; a[e2]) {</span>
<span class="line-added">2140                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">2141                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">2142                 } else {</span>
<span class="line-added">2143                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">2144                 }</span>
<span class="line-added">2145             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">2146                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">2147                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">2148                 } else {</span>
<span class="line-added">2149                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">2150                 }</span>
<span class="line-added">2151             }</span>
<span class="line-added">2152 </span>
<span class="line-added">2153             // Pointers</span>
<span class="line-added">2154             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">2155             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">2156 </span>
<span class="line-added">2157             /*</span>
<span class="line-added">2158              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">2159              */</span>
<span class="line-added">2160             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">2161 </span>
<span class="line-added">2162                 /*</span>
<span class="line-added">2163                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">2164                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">2165                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">2166                  */</span>
<span class="line-added">2167                 short pivot1 = a[e1];</span>
<span class="line-added">2168                 short pivot2 = a[e5];</span>
<span class="line-added">2169 </span>
<span class="line-added">2170                 /*</span>
<span class="line-added">2171                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">2172                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">2173                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">2174                  * into their final positions, and excluded from the next</span>
<span class="line-added">2175                  * subsequent sorting.</span>
<span class="line-added">2176                  */</span>
<span class="line-added">2177                 a[e1] = a[lower];</span>
<span class="line-added">2178                 a[e5] = a[upper];</span>
<span class="line-added">2179 </span>
<span class="line-added">2180                 /*</span>
<span class="line-added">2181                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">2182                  */</span>
<span class="line-added">2183                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">2184                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">2185 </span>
<span class="line-added">2186                 /*</span>
<span class="line-added">2187                  * Backward 3-interval partitioning</span>
<span class="line-added">2188                  *</span>
<span class="line-added">2189                  *   left part                 central part          right part</span>
<span class="line-added">2190                  * +------------------------------------------------------------+</span>
<span class="line-added">2191                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">2192                  * +------------------------------------------------------------+</span>
<span class="line-added">2193                  *             ^       ^                            ^</span>
<span class="line-added">2194                  *             |       |                            |</span>
<span class="line-added">2195                  *           lower     k                          upper</span>
<span class="line-added">2196                  *</span>
<span class="line-added">2197                  * Invariants:</span>
<span class="line-added">2198                  *</span>
<span class="line-added">2199                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">2200                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">2201                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">2202                  *</span>
<span class="line-added">2203                  * Pointer k is the last index of ?-part</span>
<span class="line-added">2204                  */</span>
<span class="line-added">2205                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">2206                     short ak = a[k];</span>
<span class="line-added">2207 </span>
<span class="line-added">2208                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">2209                         while (lower &lt; k) {</span>
<span class="line-added">2210                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">2211                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">2212                                     a[k] = a[--upper];</span>
<span class="line-added">2213                                     a[upper] = a[lower];</span>
<span class="line-added">2214                                 } else {</span>
<span class="line-added">2215                                     a[k] = a[lower];</span>
<span class="line-added">2216                                 }</span>
<span class="line-added">2217                                 a[lower] = ak;</span>
<span class="line-added">2218                                 break;</span>
<span class="line-added">2219                             }</span>
<span class="line-added">2220                         }</span>
<span class="line-added">2221                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">2222                         a[k] = a[--upper];</span>
<span class="line-added">2223                         a[upper] = ak;</span>
<span class="line-added">2224                     }</span>
<span class="line-added">2225                 }</span>
<span class="line-added">2226 </span>
<span class="line-added">2227                 /*</span>
<span class="line-added">2228                  * Swap the pivots into their final positions.</span>
<span class="line-added">2229                  */</span>
<span class="line-added">2230                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">2231                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">2232 </span>
<span class="line-added">2233                 /*</span>
<span class="line-added">2234                  * Sort non-left parts recursively,</span>
<span class="line-added">2235                  * excluding known pivots.</span>
<span class="line-added">2236                  */</span>
<span class="line-added">2237                 sort(a, bits | 1, lower + 1, upper);</span>
<span class="line-added">2238                 sort(a, bits | 1, upper + 1, high);</span>
<span class="line-added">2239 </span>
<span class="line-added">2240             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">2241 </span>
<span class="line-added">2242                 /*</span>
<span class="line-added">2243                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">2244                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">2245                  */</span>
<span class="line-added">2246                 short pivot = a[e3];</span>
<span class="line-added">2247 </span>
<span class="line-added">2248                 /*</span>
<span class="line-added">2249                  * The first element to be sorted is moved to the</span>
<span class="line-added">2250                  * location formerly occupied by the pivot. After</span>
<span class="line-added">2251                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">2252                  * back into its final position, and excluded from</span>
<span class="line-added">2253                  * the next subsequent sorting.</span>
<span class="line-added">2254                  */</span>
<span class="line-added">2255                 a[e3] = a[lower];</span>
<span class="line-added">2256 </span>
<span class="line-added">2257                 /*</span>
<span class="line-added">2258                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-added">2259                  *</span>
<span class="line-added">2260                  *   left part                 central part    right part</span>
<span class="line-added">2261                  * +------------------------------------------------------+</span>
<span class="line-added">2262                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-added">2263                  * +------------------------------------------------------+</span>
<span class="line-added">2264                  *              ^           ^                ^</span>
<span class="line-added">2265                  *              |           |                |</span>
<span class="line-added">2266                  *            lower         k              upper</span>
<span class="line-added">2267                  *</span>
<span class="line-added">2268                  * Invariants:</span>
<span class="line-added">2269                  *</span>
<span class="line-added">2270                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added">2271                  *   all in (k, upper)  == pivot</span>
<span class="line-added">2272                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added">2273                  *</span>
<span class="line-added">2274                  * Pointer k is the last index of ?-part</span>
<span class="line-added">2275                  */</span>
<span class="line-added">2276                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">2277                     short ak = a[k];</span>
<span class="line-added">2278 </span>
<span class="line-added">2279                     if (ak != pivot) {</span>
<span class="line-added">2280                         a[k] = pivot;</span>
<span class="line-added">2281 </span>
<span class="line-added">2282                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-added">2283                             while (a[++lower] &lt; pivot);</span>
<span class="line-added">2284 </span>
<span class="line-added">2285                             if (a[lower] &gt; pivot) {</span>
<span class="line-added">2286                                 a[--upper] = a[lower];</span>
<span class="line-added">2287                             }</span>
<span class="line-added">2288                             a[lower] = ak;</span>
<span class="line-added">2289                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">2290                             a[--upper] = ak;</span>
<span class="line-added">2291                         }</span>
<span class="line-added">2292                     }</span>
<span class="line-added">2293                 }</span>
<span class="line-added">2294 </span>
<span class="line-added">2295                 /*</span>
<span class="line-added">2296                  * Swap the pivot into its final position.</span>
<span class="line-added">2297                  */</span>
<span class="line-added">2298                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">2299 </span>
<span class="line-added">2300                 /*</span>
<span class="line-added">2301                  * Sort the right part, excluding known pivot.</span>
<span class="line-added">2302                  * All elements from the central part are</span>
<span class="line-added">2303                  * equal and therefore already sorted.</span>
<span class="line-added">2304                  */</span>
<span class="line-added">2305                 sort(a, bits | 1, upper, high);</span>
<span class="line-added">2306             }</span>
<span class="line-added">2307             high = lower; // Iterate along the left part</span>
<span class="line-added">2308         }</span>
<span class="line-added">2309     }</span>
<span class="line-added">2310 </span>
<span class="line-added">2311     /**</span>
<span class="line-added">2312      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-added">2313      *</span>
<span class="line-added">2314      * @param a the array to be sorted</span>
<span class="line-added">2315      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2316      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2317      */</span>
<span class="line-added">2318     private static void insertionSort(short[] a, int low, int high) {</span>
<span class="line-added">2319         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">2320             short ai = a[i = k];</span>
<span class="line-added">2321 </span>
<span class="line-added">2322             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">2323                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">2324                     a[i + 1] = a[i];</span>
<span class="line-added">2325                 }</span>
<span class="line-added">2326                 a[i + 1] = ai;</span>
<span class="line-added">2327             }</span>
<span class="line-added">2328         }</span>
<span class="line-added">2329     }</span>
<span class="line-added">2330 </span>
<span class="line-added">2331     /**</span>
<span class="line-added">2332      * The number of distinct short values.</span>
<span class="line-added">2333      */</span>
<span class="line-added">2334     private static final int NUM_SHORT_VALUES = 1 &lt;&lt; 16;</span>
<span class="line-added">2335 </span>
<span class="line-added">2336     /**</span>
<span class="line-added">2337      * Max index of short counter.</span>
<span class="line-added">2338      */</span>
<span class="line-added">2339     private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;</span>
<span class="line-added">2340 </span>
<span class="line-added">2341     /**</span>
<span class="line-added">2342      * Sorts the specified range of the array using counting sort.</span>
<span class="line-added">2343      *</span>
<span class="line-added">2344      * @param a the array to be sorted</span>
<span class="line-added">2345      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2346      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2347      */</span>
<span class="line-added">2348     private static void countingSort(short[] a, int low, int high) {</span>
<span class="line-added">2349         int[] count = new int[NUM_SHORT_VALUES];</span>
<span class="line-added">2350 </span>
<span class="line-added">2351         /*</span>
<span class="line-added">2352          * Compute a histogram with the number of each values.</span>
<span class="line-added">2353          */</span>
<span class="line-added">2354         for (int i = high; i &gt; low; ++count[a[--i] &amp; 0xFFFF]);</span>
<span class="line-added">2355 </span>
<span class="line-added">2356         /*</span>
<span class="line-added">2357          * Place values on their final positions.</span>
<span class="line-added">2358          */</span>
<span class="line-added">2359         if (high - low &gt; NUM_SHORT_VALUES) {</span>
<span class="line-added">2360             for (int i = MAX_SHORT_INDEX; --i &gt; Short.MAX_VALUE; ) {</span>
<span class="line-added">2361                 int value = i &amp; 0xFFFF;</span>
<span class="line-added">2362 </span>
<span class="line-added">2363                 for (low = high - count[value]; high &gt; low;</span>
<span class="line-added">2364                     a[--high] = (short) value</span>
<span class="line-added">2365                 );</span>
<span class="line-added">2366             }</span>
<span class="line-added">2367         } else {</span>
<span class="line-added">2368             for (int i = MAX_SHORT_INDEX; high &gt; low; ) {</span>
<span class="line-added">2369                 while (count[--i &amp; 0xFFFF] == 0);</span>
<span class="line-added">2370 </span>
<span class="line-added">2371                 int value = i &amp; 0xFFFF;</span>
<span class="line-added">2372                 int c = count[value];</span>
<span class="line-added">2373 </span>
<span class="line-added">2374                 do {</span>
<span class="line-added">2375                     a[--high] = (short) value;</span>
<span class="line-added">2376                 } while (--c &gt; 0);</span>
<span class="line-added">2377             }</span>
<span class="line-added">2378         }</span>
<span class="line-added">2379     }</span>
<span class="line-added">2380 </span>
<span class="line-added">2381 // [float]</span>
<span class="line-added">2382 </span>
<span class="line-added">2383     /**</span>
<span class="line-added">2384      * Sorts the specified range of the array using parallel merge</span>
<span class="line-added">2385      * sort and/or Dual-Pivot Quicksort.</span>
<span class="line-added">2386      *</span>
<span class="line-added">2387      * To balance the faster splitting and parallelism of merge sort</span>
<span class="line-added">2388      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="line-added">2389      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="line-added">2390      * the four-way parallel merge is started, still ensuring enough</span>
<span class="line-added">2391      * parallelism to process the partitions.</span>
<span class="line-added">2392      *</span>
<span class="line-added">2393      * @param a the array to be sorted</span>
<span class="line-added">2394      * @param parallelism the parallelism level</span>
<span class="line-added">2395      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2396      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2397      */</span>
<span class="line-added">2398     static void sort(float[] a, int parallelism, int low, int high) {</span>
<span class="line-added">2399         /*</span>
<span class="line-added">2400          * Phase 1. Count the number of negative zero -0.0f,</span>
<span class="line-added">2401          * turn them into positive zero, and move all NaNs</span>
<span class="line-added">2402          * to the end of the array.</span>
<span class="line-added">2403          */</span>
<span class="line-added">2404         int numNegativeZero = 0;</span>
<span class="line-added">2405 </span>
<span class="line-added">2406         for (int k = high; k &gt; low; ) {</span>
<span class="line-added">2407             float ak = a[--k];</span>
<span class="line-added">2408 </span>
<span class="line-added">2409             if (ak == 0.0f &amp;&amp; Float.floatToRawIntBits(ak) &lt; 0) { // ak is -0.0f</span>
<span class="line-added">2410                 numNegativeZero += 1;</span>
<span class="line-added">2411                 a[k] = 0.0f;</span>
<span class="line-added">2412             } else if (ak != ak) { // ak is NaN</span>
<span class="line-added">2413                 a[k] = a[--high];</span>
<span class="line-added">2414                 a[high] = ak;</span>
<span class="line-added">2415             }</span>
<span class="line-added">2416         }</span>
<span class="line-added">2417 </span>
<span class="line-added">2418         /*</span>
<span class="line-added">2419          * Phase 2. Sort everything except NaNs,</span>
<span class="line-added">2420          * which are already in place.</span>
<span class="line-added">2421          */</span>
<span class="line-added">2422         int size = high - low;</span>
<span class="line-added">2423 </span>
<span class="line-added">2424         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="line-added">2425             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="line-added">2426             float[] b = depth == 0 ? null : new float[size];</span>
<span class="line-added">2427             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="line-added">2428         } else {</span>
<span class="line-added">2429             sort(null, a, 0, low, high);</span>
<span class="line-added">2430         }</span>
<span class="line-added">2431 </span>
<span class="line-added">2432         /*</span>
<span class="line-added">2433          * Phase 3. Turn positive zero 0.0f</span>
<span class="line-added">2434          * back into negative zero -0.0f.</span>
<span class="line-added">2435          */</span>
<span class="line-added">2436         if (++numNegativeZero == 1) {</span>
<span class="line-added">2437             return;</span>
<span class="line-added">2438         }</span>
<span class="line-added">2439 </span>
<span class="line-added">2440         /*</span>
<span class="line-added">2441          * Find the position one less than</span>
<span class="line-added">2442          * the index of the first zero.</span>
<span class="line-added">2443          */</span>
<span class="line-added">2444         while (low &lt;= high) {</span>
<span class="line-added">2445             int middle = (low + high) &gt;&gt;&gt; 1;</span>
<span class="line-added">2446 </span>
<span class="line-added">2447             if (a[middle] &lt; 0) {</span>
<span class="line-added">2448                 low = middle + 1;</span>
<span class="line-added">2449             } else {</span>
<span class="line-added">2450                 high = middle - 1;</span>
<span class="line-added">2451             }</span>
<span class="line-added">2452         }</span>
<span class="line-added">2453 </span>
<span class="line-added">2454         /*</span>
<span class="line-added">2455          * Replace the required number of 0.0f by -0.0f.</span>
<span class="line-added">2456          */</span>
<span class="line-added">2457         while (--numNegativeZero &gt; 0) {</span>
<span class="line-added">2458             a[++high] = -0.0f;</span>
<span class="line-added">2459         }</span>
<span class="line-added">2460     }</span>
<span class="line-added">2461 </span>
<span class="line-added">2462     /**</span>
<span class="line-added">2463      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-added">2464      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added">2465      *</span>
<span class="line-added">2466      * @param sorter parallel context</span>
<span class="line-added">2467      * @param a the array to be sorted</span>
<span class="line-added">2468      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added">2469      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added">2470      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2471      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2472      */</span>
<span class="line-added">2473     static void sort(Sorter sorter, float[] a, int bits, int low, int high) {</span>
<span class="line-added">2474         while (true) {</span>
<span class="line-added">2475             int end = high - 1, size = high - low;</span>
<span class="line-added">2476 </span>
<span class="line-added">2477             /*</span>
<span class="line-added">2478              * Run mixed insertion sort on small non-leftmost parts.</span>
<span class="line-added">2479              */</span>
<span class="line-added">2480             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="line-added">2481                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="line-added">2482                 return;</span>
<span class="line-added">2483             }</span>
<span class="line-added">2484 </span>
<span class="line-added">2485             /*</span>
<span class="line-added">2486              * Invoke insertion sort on small leftmost part.</span>
<span class="line-added">2487              */</span>
<span class="line-added">2488             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-added">2489                 insertionSort(a, low, high);</span>
<span class="line-added">2490                 return;</span>
<span class="line-added">2491             }</span>
<span class="line-added">2492 </span>
<span class="line-added">2493             /*</span>
<span class="line-added">2494              * Check if the whole array or large non-leftmost</span>
<span class="line-added">2495              * parts are nearly sorted and then merge runs.</span>
<span class="line-added">2496              */</span>
<span class="line-added">2497             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="line-added">2498                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="line-added">2499                 return;</span>
<span class="line-added">2500             }</span>
<span class="line-added">2501 </span>
<span class="line-added">2502             /*</span>
<span class="line-added">2503              * Switch to heap sort if execution</span>
<span class="line-added">2504              * time is becoming quadratic.</span>
<span class="line-added">2505              */</span>
<span class="line-added">2506             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-added">2507                 heapSort(a, low, high);</span>
<span class="line-added">2508                 return;</span>
<span class="line-added">2509             }</span>
<span class="line-added">2510 </span>
<span class="line-added">2511             /*</span>
<span class="line-added">2512              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-added">2513              * to select five sample elements and determine pivots.</span>
<span class="line-added">2514              */</span>
<span class="line-added">2515             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="line-added">2516 </span>
<span class="line-added">2517             /*</span>
<span class="line-added">2518              * Five elements around (and including) the central element</span>
<span class="line-added">2519              * will be used for pivot selection as described below. The</span>
<span class="line-added">2520              * unequal choice of spacing these elements was empirically</span>
<span class="line-added">2521              * determined to work well on a wide variety of inputs.</span>
<span class="line-added">2522              */</span>
<span class="line-added">2523             int e1 = low + step;</span>
<span class="line-added">2524             int e5 = end - step;</span>
<span class="line-added">2525             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">2526             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added">2527             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">2528             float a3 = a[e3];</span>
<span class="line-added">2529 </span>
<span class="line-added">2530             /*</span>
<span class="line-added">2531              * Sort these elements in place by the combination</span>
<span class="line-added">2532              * of 4-element sorting network and insertion sort.</span>
<span class="line-added">2533              *</span>
<span class="line-added">2534              *    5 ------o-----------o------------</span>
<span class="line-added">2535              *            |           |</span>
<span class="line-added">2536              *    4 ------|-----o-----o-----o------</span>
<span class="line-added">2537              *            |     |           |</span>
<span class="line-added">2538              *    2 ------o-----|-----o-----o------</span>
<span class="line-added">2539              *                  |     |</span>
<span class="line-added">2540              *    1 ------------o-----o------------</span>
<span class="line-added">2541              */</span>
<span class="line-added">2542             if (a[e5] &lt; a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">2543             if (a[e4] &lt; a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">2544             if (a[e5] &lt; a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">2545             if (a[e2] &lt; a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">2546             if (a[e4] &lt; a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">2547 </span>
<span class="line-added">2548             if (a3 &lt; a[e2]) {</span>
<span class="line-added">2549                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">2550                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">2551                 } else {</span>
<span class="line-added">2552                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">2553                 }</span>
<span class="line-added">2554             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">2555                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">2556                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">2557                 } else {</span>
<span class="line-added">2558                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">2559                 }</span>
<span class="line-added">2560             }</span>
<span class="line-added">2561 </span>
<span class="line-added">2562             // Pointers</span>
<span class="line-added">2563             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">2564             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">2565 </span>
<span class="line-added">2566             /*</span>
<span class="line-added">2567              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">2568              */</span>
<span class="line-added">2569             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">2570 </span>
<span class="line-added">2571                 /*</span>
<span class="line-added">2572                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">2573                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">2574                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">2575                  */</span>
<span class="line-added">2576                 float pivot1 = a[e1];</span>
<span class="line-added">2577                 float pivot2 = a[e5];</span>
<span class="line-added">2578 </span>
<span class="line-added">2579                 /*</span>
<span class="line-added">2580                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">2581                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">2582                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">2583                  * into their final positions, and excluded from the next</span>
<span class="line-added">2584                  * subsequent sorting.</span>
<span class="line-added">2585                  */</span>
<span class="line-added">2586                 a[e1] = a[lower];</span>
<span class="line-added">2587                 a[e5] = a[upper];</span>
<span class="line-added">2588 </span>
<span class="line-added">2589                 /*</span>
<span class="line-added">2590                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">2591                  */</span>
<span class="line-added">2592                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">2593                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">2594 </span>
<span class="line-added">2595                 /*</span>
<span class="line-added">2596                  * Backward 3-interval partitioning</span>
<span class="line-added">2597                  *</span>
<span class="line-added">2598                  *   left part                 central part          right part</span>
<span class="line-added">2599                  * +------------------------------------------------------------+</span>
<span class="line-added">2600                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">2601                  * +------------------------------------------------------------+</span>
<span class="line-added">2602                  *             ^       ^                            ^</span>
<span class="line-added">2603                  *             |       |                            |</span>
<span class="line-added">2604                  *           lower     k                          upper</span>
<span class="line-added">2605                  *</span>
<span class="line-added">2606                  * Invariants:</span>
<span class="line-added">2607                  *</span>
<span class="line-added">2608                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">2609                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">2610                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">2611                  *</span>
<span class="line-added">2612                  * Pointer k is the last index of ?-part</span>
<span class="line-added">2613                  */</span>
<span class="line-added">2614                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">2615                     float ak = a[k];</span>
<span class="line-added">2616 </span>
<span class="line-added">2617                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">2618                         while (lower &lt; k) {</span>
<span class="line-added">2619                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">2620                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">2621                                     a[k] = a[--upper];</span>
<span class="line-added">2622                                     a[upper] = a[lower];</span>
<span class="line-added">2623                                 } else {</span>
<span class="line-added">2624                                     a[k] = a[lower];</span>
<span class="line-added">2625                                 }</span>
<span class="line-added">2626                                 a[lower] = ak;</span>
<span class="line-added">2627                                 break;</span>
<span class="line-added">2628                             }</span>
<span class="line-added">2629                         }</span>
<span class="line-added">2630                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">2631                         a[k] = a[--upper];</span>
<span class="line-added">2632                         a[upper] = ak;</span>
<span class="line-added">2633                     }</span>
<span class="line-added">2634                 }</span>
<span class="line-added">2635 </span>
<span class="line-added">2636                 /*</span>
<span class="line-added">2637                  * Swap the pivots into their final positions.</span>
<span class="line-added">2638                  */</span>
<span class="line-added">2639                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">2640                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">2641 </span>
<span class="line-added">2642                 /*</span>
<span class="line-added">2643                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="line-added">2644                  * excluding known pivots.</span>
<span class="line-added">2645                  */</span>
<span class="line-added">2646                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">2647                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="line-added">2648                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="line-added">2649                 } else {</span>
<span class="line-added">2650                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="line-added">2651                     sort(sorter, a, bits | 1, upper + 1, high);</span>
<span class="line-added">2652                 }</span>
<span class="line-added">2653 </span>
<span class="line-added">2654             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">2655 </span>
<span class="line-added">2656                 /*</span>
<span class="line-added">2657                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">2658                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">2659                  */</span>
<span class="line-added">2660                 float pivot = a[e3];</span>
<span class="line-added">2661 </span>
<span class="line-added">2662                 /*</span>
<span class="line-added">2663                  * The first element to be sorted is moved to the</span>
<span class="line-added">2664                  * location formerly occupied by the pivot. After</span>
<span class="line-added">2665                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">2666                  * back into its final position, and excluded from</span>
<span class="line-added">2667                  * the next subsequent sorting.</span>
<span class="line-added">2668                  */</span>
<span class="line-added">2669                 a[e3] = a[lower];</span>
<span class="line-added">2670 </span>
<span class="line-added">2671                 /*</span>
<span class="line-added">2672                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-added">2673                  *</span>
<span class="line-added">2674                  *   left part                 central part    right part</span>
<span class="line-added">2675                  * +------------------------------------------------------+</span>
<span class="line-added">2676                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-added">2677                  * +------------------------------------------------------+</span>
<span class="line-added">2678                  *              ^           ^                ^</span>
<span class="line-added">2679                  *              |           |                |</span>
<span class="line-added">2680                  *            lower         k              upper</span>
<span class="line-added">2681                  *</span>
<span class="line-added">2682                  * Invariants:</span>
<span class="line-added">2683                  *</span>
<span class="line-added">2684                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added">2685                  *   all in (k, upper)  == pivot</span>
<span class="line-added">2686                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added">2687                  *</span>
<span class="line-added">2688                  * Pointer k is the last index of ?-part</span>
<span class="line-added">2689                  */</span>
<span class="line-added">2690                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">2691                     float ak = a[k];</span>
<span class="line-added">2692 </span>
<span class="line-added">2693                     if (ak != pivot) {</span>
<span class="line-added">2694                         a[k] = pivot;</span>
<span class="line-added">2695 </span>
<span class="line-added">2696                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-added">2697                             while (a[++lower] &lt; pivot);</span>
<span class="line-added">2698 </span>
<span class="line-added">2699                             if (a[lower] &gt; pivot) {</span>
<span class="line-added">2700                                 a[--upper] = a[lower];</span>
<span class="line-added">2701                             }</span>
<span class="line-added">2702                             a[lower] = ak;</span>
<span class="line-added">2703                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">2704                             a[--upper] = ak;</span>
<span class="line-added">2705                         }</span>
<span class="line-added">2706                     }</span>
<span class="line-added">2707                 }</span>
<span class="line-added">2708 </span>
<span class="line-added">2709                 /*</span>
<span class="line-added">2710                  * Swap the pivot into its final position.</span>
<span class="line-added">2711                  */</span>
<span class="line-added">2712                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">2713 </span>
<span class="line-added">2714                 /*</span>
<span class="line-added">2715                  * Sort the right part (possibly in parallel), excluding</span>
<span class="line-added">2716                  * known pivot. All elements from the central part are</span>
<span class="line-added">2717                  * equal and therefore already sorted.</span>
<span class="line-added">2718                  */</span>
<span class="line-added">2719                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">2720                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="line-added">2721                 } else {</span>
<span class="line-added">2722                     sort(sorter, a, bits | 1, upper, high);</span>
<span class="line-added">2723                 }</span>
<span class="line-added">2724             }</span>
<span class="line-added">2725             high = lower; // Iterate along the left part</span>
<span class="line-added">2726         }</span>
<span class="line-added">2727     }</span>
<span class="line-added">2728 </span>
<span class="line-added">2729     /**</span>
<span class="line-added">2730      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="line-added">2731      *</span>
<span class="line-added">2732      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="line-added">2733      * pin insertion sort and pair insertion sort.</span>
<span class="line-added">2734      *</span>
<span class="line-added">2735      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="line-added">2736      * from the left part plays the role of sentinel, because it</span>
<span class="line-added">2737      * is less than any elements from the given part. Therefore,</span>
<span class="line-added">2738      * expensive check of the left range can be skipped on each</span>
<span class="line-added">2739      * iteration unless it is the leftmost call.</span>
<span class="line-added">2740      *</span>
<span class="line-added">2741      * @param a the array to be sorted</span>
<span class="line-added">2742      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2743      * @param end the index of the last element for simple insertion sort</span>
<span class="line-added">2744      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2745      */</span>
<span class="line-added">2746     private static void mixedInsertionSort(float[] a, int low, int end, int high) {</span>
<span class="line-added">2747         if (end == high) {</span>
<span class="line-added">2748 </span>
<span class="line-added">2749             /*</span>
<span class="line-added">2750              * Invoke simple insertion sort on tiny array.</span>
<span class="line-added">2751              */</span>
<span class="line-added">2752             for (int i; ++low &lt; end; ) {</span>
<span class="line-added">2753                 float ai = a[i = low];</span>
<span class="line-added">2754 </span>
<span class="line-added">2755                 while (ai &lt; a[--i]) {</span>
<span class="line-added">2756                     a[i + 1] = a[i];</span>
<span class="line-added">2757                 }</span>
<span class="line-added">2758                 a[i + 1] = ai;</span>
<span class="line-added">2759             }</span>
<span class="line-added">2760         } else {</span>
<span class="line-added">2761 </span>
<span class="line-added">2762             /*</span>
<span class="line-added">2763              * Start with pin insertion sort on small part.</span>
<span class="line-added">2764              *</span>
<span class="line-added">2765              * Pin insertion sort is extended simple insertion sort.</span>
<span class="line-added">2766              * The main idea of this sort is to put elements larger</span>
<span class="line-added">2767              * than an element called pin to the end of array (the</span>
<span class="line-added">2768              * proper area for such elements). It avoids expensive</span>
<span class="line-added">2769              * movements of these elements through the whole array.</span>
<span class="line-added">2770              */</span>
<span class="line-added">2771             float pin = a[end];</span>
<span class="line-added">2772 </span>
<span class="line-added">2773             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="line-added">2774                 float ai = a[i = low];</span>
<span class="line-added">2775 </span>
<span class="line-added">2776                 if (ai &lt; a[i - 1]) { // Small element</span>
<span class="line-added">2777 </span>
<span class="line-added">2778                     /*</span>
<span class="line-added">2779                      * Insert small element into sorted part.</span>
<span class="line-added">2780                      */</span>
<span class="line-added">2781                     a[i] = a[--i];</span>
<span class="line-added">2782 </span>
<span class="line-added">2783                     while (ai &lt; a[--i]) {</span>
<span class="line-added">2784                         a[i + 1] = a[i];</span>
<span class="line-added">2785                     }</span>
<span class="line-added">2786                     a[i + 1] = ai;</span>
<span class="line-added">2787 </span>
<span class="line-added">2788                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="line-added">2789 </span>
<span class="line-added">2790                     /*</span>
<span class="line-added">2791                      * Find element smaller than pin.</span>
<span class="line-added">2792                      */</span>
<span class="line-added">2793                     while (a[--p] &gt; pin);</span>
<span class="line-added">2794 </span>
<span class="line-added">2795                     /*</span>
<span class="line-added">2796                      * Swap it with large element.</span>
<span class="line-added">2797                      */</span>
<span class="line-added">2798                     if (p &gt; i) {</span>
<span class="line-added">2799                         ai = a[p];</span>
<span class="line-added">2800                         a[p] = a[i];</span>
<span class="line-added">2801                     }</span>
<span class="line-added">2802 </span>
<span class="line-added">2803                     /*</span>
<span class="line-added">2804                      * Insert small element into sorted part.</span>
<span class="line-added">2805                      */</span>
<span class="line-added">2806                     while (ai &lt; a[--i]) {</span>
<span class="line-added">2807                         a[i + 1] = a[i];</span>
<span class="line-added">2808                     }</span>
<span class="line-added">2809                     a[i + 1] = ai;</span>
<span class="line-added">2810                 }</span>
<span class="line-added">2811             }</span>
<span class="line-added">2812 </span>
<span class="line-added">2813             /*</span>
<span class="line-added">2814              * Continue with pair insertion sort on remain part.</span>
<span class="line-added">2815              */</span>
<span class="line-added">2816             for (int i; low &lt; high; ++low) {</span>
<span class="line-added">2817                 float a1 = a[i = low], a2 = a[++low];</span>
<span class="line-added">2818 </span>
<span class="line-added">2819                 /*</span>
<span class="line-added">2820                  * Insert two elements per iteration: at first, insert the</span>
<span class="line-added">2821                  * larger element and then insert the smaller element, but</span>
<span class="line-added">2822                  * from the position where the larger element was inserted.</span>
<span class="line-added">2823                  */</span>
<span class="line-added">2824                 if (a1 &gt; a2) {</span>
<span class="line-added">2825 </span>
<span class="line-added">2826                     while (a1 &lt; a[--i]) {</span>
<span class="line-added">2827                         a[i + 2] = a[i];</span>
<span class="line-added">2828                     }</span>
<span class="line-added">2829                     a[++i + 1] = a1;</span>
<span class="line-added">2830 </span>
<span class="line-added">2831                     while (a2 &lt; a[--i]) {</span>
<span class="line-added">2832                         a[i + 1] = a[i];</span>
<span class="line-added">2833                     }</span>
<span class="line-added">2834                     a[i + 1] = a2;</span>
<span class="line-added">2835 </span>
<span class="line-added">2836                 } else if (a1 &lt; a[i - 1]) {</span>
<span class="line-added">2837 </span>
<span class="line-added">2838                     while (a2 &lt; a[--i]) {</span>
<span class="line-added">2839                         a[i + 2] = a[i];</span>
<span class="line-added">2840                     }</span>
<span class="line-added">2841                     a[++i + 1] = a2;</span>
<span class="line-added">2842 </span>
<span class="line-added">2843                     while (a1 &lt; a[--i]) {</span>
<span class="line-added">2844                         a[i + 1] = a[i];</span>
<span class="line-added">2845                     }</span>
<span class="line-added">2846                     a[i + 1] = a1;</span>
<span class="line-added">2847                 }</span>
<span class="line-added">2848             }</span>
<span class="line-added">2849         }</span>
<span class="line-added">2850     }</span>
<span class="line-added">2851 </span>
<span class="line-added">2852     /**</span>
<span class="line-added">2853      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-added">2854      *</span>
<span class="line-added">2855      * @param a the array to be sorted</span>
<span class="line-added">2856      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2857      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2858      */</span>
<span class="line-added">2859     private static void insertionSort(float[] a, int low, int high) {</span>
<span class="line-added">2860         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">2861             float ai = a[i = k];</span>
<span class="line-added">2862 </span>
<span class="line-added">2863             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">2864                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">2865                     a[i + 1] = a[i];</span>
<span class="line-added">2866                 }</span>
<span class="line-added">2867                 a[i + 1] = ai;</span>
<span class="line-added">2868             }</span>
<span class="line-added">2869         }</span>
<span class="line-added">2870     }</span>
<span class="line-added">2871 </span>
<span class="line-added">2872     /**</span>
<span class="line-added">2873      * Sorts the specified range of the array using heap sort.</span>
<span class="line-added">2874      *</span>
<span class="line-added">2875      * @param a the array to be sorted</span>
<span class="line-added">2876      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2877      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2878      */</span>
<span class="line-added">2879     private static void heapSort(float[] a, int low, int high) {</span>
<span class="line-added">2880         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="line-added">2881             pushDown(a, --k, a[k], low, high);</span>
<span class="line-added">2882         }</span>
<span class="line-added">2883         while (--high &gt; low) {</span>
<span class="line-added">2884             float max = a[low];</span>
<span class="line-added">2885             pushDown(a, low, a[high], low, high);</span>
<span class="line-added">2886             a[high] = max;</span>
<span class="line-added">2887         }</span>
<span class="line-added">2888     }</span>
<span class="line-added">2889 </span>
<span class="line-added">2890     /**</span>
<span class="line-added">2891      * Pushes specified element down during heap sort.</span>
<span class="line-added">2892      *</span>
<span class="line-added">2893      * @param a the given array</span>
<span class="line-added">2894      * @param p the start index</span>
<span class="line-added">2895      * @param value the given element</span>
<span class="line-added">2896      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">2897      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">2898      */</span>
<span class="line-added">2899     private static void pushDown(float[] a, int p, float value, int low, int high) {</span>
<span class="line-added">2900         for (int k ;; a[p] = a[p = k]) {</span>
<span class="line-added">2901             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
<span class="line-added">2902 </span>
<span class="line-added">2903             if (k &gt; high) {</span>
<span class="line-added">2904                 break;</span>
<span class="line-added">2905             }</span>
<span class="line-added">2906             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="line-added">2907                 --k;</span>
<span class="line-added">2908             }</span>
<span class="line-added">2909             if (a[k] &lt;= value) {</span>
<span class="line-added">2910                 break;</span>
<span class="line-added">2911             }</span>
<span class="line-added">2912         }</span>
<span class="line-added">2913         a[p] = value;</span>
<span class="line-added">2914     }</span>
<span class="line-added">2915 </span>
<span class="line-added">2916     /**</span>
<span class="line-added">2917      * Tries to sort the specified range of the array.</span>
<span class="line-added">2918      *</span>
<span class="line-added">2919      * @param sorter parallel context</span>
<span class="line-added">2920      * @param a the array to be sorted</span>
<span class="line-added">2921      * @param low the index of the first element to be sorted</span>
<span class="line-added">2922      * @param size the array size</span>
<span class="line-added">2923      * @return true if finally sorted, false otherwise</span>
<span class="line-added">2924      */</span>
<span class="line-added">2925     private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {</span>
<span class="line-added">2926 </span>
<span class="line-added">2927         /*</span>
<span class="line-added">2928          * The run array is constructed only if initial runs are</span>
<span class="line-added">2929          * long enough to continue, run[i] then holds start index</span>
<span class="line-added">2930          * of the i-th sequence of elements in non-descending order.</span>
<span class="line-added">2931          */</span>
<span class="line-added">2932         int[] run = null;</span>
<span class="line-added">2933         int high = low + size;</span>
<span class="line-added">2934         int count = 1, last = low;</span>
<span class="line-added">2935 </span>
<span class="line-added">2936         /*</span>
<span class="line-added">2937          * Identify all possible runs.</span>
<span class="line-added">2938          */</span>
<span class="line-added">2939         for (int k = low + 1; k &lt; high; ) {</span>
<span class="line-added">2940 </span>
<span class="line-added">2941             /*</span>
<span class="line-added">2942              * Find the end index of the current run.</span>
<span class="line-added">2943              */</span>
<span class="line-added">2944             if (a[k - 1] &lt; a[k]) {</span>
<span class="line-added">2945 </span>
<span class="line-added">2946                 // Identify ascending sequence</span>
<span class="line-added">2947                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-added">2948 </span>
<span class="line-added">2949             } else if (a[k - 1] &gt; a[k]) {</span>
<span class="line-added">2950 </span>
<span class="line-added">2951                 // Identify descending sequence</span>
<span class="line-added">2952                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-added">2953 </span>
<span class="line-added">2954                 // Reverse into ascending order</span>
<span class="line-added">2955                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="line-added">2956                     float ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="line-added">2957                 }</span>
<span class="line-added">2958             } else { // Identify constant sequence</span>
<span class="line-added">2959                 for (float ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
<span class="line-added">2960 </span>
<span class="line-added">2961                 if (k &lt; high) {</span>
<span class="line-added">2962                     continue;</span>
<span class="line-added">2963                 }</span>
<span class="line-added">2964             }</span>
<span class="line-added">2965 </span>
<span class="line-added">2966             /*</span>
<span class="line-added">2967              * Check special cases.</span>
<span class="line-added">2968              */</span>
<span class="line-added">2969             if (run == null) {</span>
<span class="line-added">2970                 if (k == high) {</span>
<span class="line-added">2971 </span>
<span class="line-added">2972                     /*</span>
<span class="line-added">2973                      * The array is monotonous sequence,</span>
<span class="line-added">2974                      * and therefore already sorted.</span>
<span class="line-added">2975                      */</span>
<span class="line-added">2976                     return true;</span>
<span class="line-added">2977                 }</span>
<span class="line-added">2978 </span>
<span class="line-added">2979                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="line-added">2980 </span>
<span class="line-added">2981                     /*</span>
<span class="line-added">2982                      * The first run is too small</span>
<span class="line-added">2983                      * to proceed with scanning.</span>
<span class="line-added">2984                      */</span>
<span class="line-added">2985                     return false;</span>
<span class="line-added">2986                 }</span>
<span class="line-added">2987 </span>
<span class="line-added">2988                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="line-added">2989                 run[0] = low;</span>
<span class="line-added">2990 </span>
<span class="line-added">2991             } else if (a[last - 1] &gt; a[last]) {</span>
<span class="line-added">2992 </span>
<span class="line-added">2993                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
<span class="line-added">2994 </span>
<span class="line-added">2995                     /*</span>
<span class="line-added">2996                      * The first runs are not long</span>
<span class="line-added">2997                      * enough to continue scanning.</span>
<span class="line-added">2998                      */</span>
<span class="line-added">2999                     return false;</span>
<span class="line-added">3000                 }</span>
<span class="line-added">3001 </span>
<span class="line-added">3002                 if (++count == MAX_RUN_CAPACITY) {</span>
<span class="line-added">3003 </span>
<span class="line-added">3004                     /*</span>
<span class="line-added">3005                      * Array is not highly structured.</span>
<span class="line-added">3006                      */</span>
<span class="line-added">3007                     return false;</span>
<span class="line-added">3008                 }</span>
<span class="line-added">3009 </span>
<span class="line-added">3010                 if (count == run.length) {</span>
<span class="line-added">3011 </span>
<span class="line-added">3012                     /*</span>
<span class="line-added">3013                      * Increase capacity of index array.</span>
<span class="line-added">3014                      */</span>
<span class="line-added">3015                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
<span class="line-added">3016                 }</span>
<span class="line-added">3017             }</span>
<span class="line-added">3018             run[count] = (last = k);</span>
<span class="line-added">3019         }</span>
<span class="line-added">3020 </span>
<span class="line-added">3021         /*</span>
<span class="line-added">3022          * Merge runs of highly structured array.</span>
<span class="line-added">3023          */</span>
<span class="line-added">3024         if (count &gt; 1) {</span>
<span class="line-added">3025             float[] b; int offset = low;</span>
<span class="line-added">3026 </span>
<span class="line-added">3027             if (sorter == null || (b = (float[]) sorter.b) == null) {</span>
<span class="line-added">3028                 b = new float[size];</span>
<span class="line-added">3029             } else {</span>
<span class="line-added">3030                 offset = sorter.offset;</span>
<span class="line-added">3031             }</span>
<span class="line-added">3032             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
<span class="line-added">3033         }</span>
<span class="line-added">3034         return true;</span>
<span class="line-added">3035     }</span>
<span class="line-added">3036 </span>
<span class="line-added">3037     /**</span>
<span class="line-added">3038      * Merges the specified runs.</span>
<span class="line-added">3039      *</span>
<span class="line-added">3040      * @param a the source array</span>
<span class="line-added">3041      * @param b the temporary buffer used in merging</span>
<span class="line-added">3042      * @param offset the start index in the source, inclusive</span>
<span class="line-added">3043      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="line-added">3044      * @param parallel indicates whether merging is performed in parallel</span>
<span class="line-added">3045      * @param run the start indexes of the runs, inclusive</span>
<span class="line-added">3046      * @param lo the start index of the first run, inclusive</span>
<span class="line-added">3047      * @param hi the start index of the last run, inclusive</span>
<span class="line-added">3048      * @return the destination where runs are merged</span>
<span class="line-added">3049      */</span>
<span class="line-added">3050     private static float[] mergeRuns(float[] a, float[] b, int offset,</span>
<span class="line-added">3051             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="line-added">3052 </span>
<span class="line-added">3053         if (hi - lo == 1) {</span>
<span class="line-added">3054             if (aim &gt;= 0) {</span>
<span class="line-added">3055                 return a;</span>
<span class="line-added">3056             }</span>
<span class="line-added">3057             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="line-added">3058                 b[--j] = a[--i]</span>
<span class="line-added">3059             );</span>
<span class="line-added">3060             return b;</span>
<span class="line-added">3061         }</span>
<span class="line-added">3062 </span>
<span class="line-added">3063         /*</span>
<span class="line-added">3064          * Split into approximately equal parts.</span>
<span class="line-added">3065          */</span>
<span class="line-added">3066         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="line-added">3067         while (run[++mi + 1] &lt;= rmi);</span>
<span class="line-added">3068 </span>
<span class="line-added">3069         /*</span>
<span class="line-added">3070          * Merge the left and right parts.</span>
<span class="line-added">3071          */</span>
<span class="line-added">3072         float[] a1, a2;</span>
<span class="line-added">3073 </span>
<span class="line-added">3074         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="line-added">3075             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="line-added">3076             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="line-added">3077             a2 = (float[]) merger.getDestination();</span>
<span class="line-added">3078         } else {</span>
<span class="line-added">3079             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="line-added">3080             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>
<span class="line-added">3081         }</span>
<span class="line-added">3082 </span>
<span class="line-added">3083         float[] dst = a1 == a ? b : a;</span>
<span class="line-added">3084 </span>
<span class="line-added">3085         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="line-added">3086         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="line-added">3087         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="line-added">3088         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="line-added">3089         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="line-added">3090 </span>
<span class="line-added">3091         if (parallel) {</span>
<span class="line-added">3092             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>
<span class="line-added">3093         } else {</span>
<span class="line-added">3094             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>
<span class="line-added">3095         }</span>
<span class="line-added">3096         return dst;</span>
<span class="line-added">3097     }</span>
<span class="line-added">3098 </span>
<span class="line-added">3099     /**</span>
<span class="line-added">3100      * Merges the sorted parts.</span>
<span class="line-added">3101      *</span>
<span class="line-added">3102      * @param merger parallel context</span>
<span class="line-added">3103      * @param dst the destination where parts are merged</span>
<span class="line-added">3104      * @param k the start index of the destination, inclusive</span>
<span class="line-added">3105      * @param a1 the first part</span>
<span class="line-added">3106      * @param lo1 the start index of the first part, inclusive</span>
<span class="line-added">3107      * @param hi1 the end index of the first part, exclusive</span>
<span class="line-added">3108      * @param a2 the second part</span>
<span class="line-added">3109      * @param lo2 the start index of the second part, inclusive</span>
<span class="line-added">3110      * @param hi2 the end index of the second part, exclusive</span>
<span class="line-added">3111      */</span>
<span class="line-added">3112     private static void mergeParts(Merger merger, float[] dst, int k,</span>
<span class="line-added">3113             float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {</span>
<span class="line-added">3114 </span>
<span class="line-added">3115         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="line-added">3116 </span>
<span class="line-added">3117             while (true) {</span>
<span class="line-added">3118 </span>
<span class="line-added">3119                 /*</span>
<span class="line-added">3120                  * The first part must be larger.</span>
<span class="line-added">3121                  */</span>
<span class="line-added">3122                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="line-added">3123                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="line-added">3124                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>
<span class="line-added">3125                 }</span>
<span class="line-added">3126 </span>
<span class="line-added">3127                 /*</span>
<span class="line-added">3128                  * Small parts will be merged sequentially.</span>
<span class="line-added">3129                  */</span>
<span class="line-added">3130                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="line-added">3131                     break;</span>
<span class="line-added">3132                 }</span>
<span class="line-added">3133 </span>
<span class="line-added">3134                 /*</span>
<span class="line-added">3135                  * Find the median of the larger part.</span>
<span class="line-added">3136                  */</span>
<span class="line-added">3137                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="line-added">3138                 float key = a1[mi1];</span>
<span class="line-added">3139                 int mi2 = hi2;</span>
<span class="line-added">3140 </span>
<span class="line-added">3141                 /*</span>
<span class="line-added">3142                  * Partition the smaller part.</span>
<span class="line-added">3143                  */</span>
<span class="line-added">3144                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="line-added">3145                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>
<span class="line-added">3146 </span>
<span class="line-added">3147                     if (key &gt; a2[t]) {</span>
<span class="line-added">3148                         loo = t + 1;</span>
<span class="line-added">3149                     } else {</span>
<span class="line-added">3150                         mi2 = t;</span>
<span class="line-added">3151                     }</span>
<span class="line-added">3152                 }</span>
<span class="line-added">3153 </span>
<span class="line-added">3154                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="line-added">3155 </span>
<span class="line-added">3156                 /*</span>
<span class="line-added">3157                  * Merge the right sub-parts in parallel.</span>
<span class="line-added">3158                  */</span>
<span class="line-added">3159                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="line-added">3160 </span>
<span class="line-added">3161                 /*</span>
<span class="line-added">3162                  * Process the sub-left parts.</span>
<span class="line-added">3163                  */</span>
<span class="line-added">3164                 hi1 = mi1;</span>
<span class="line-added">3165                 hi2 = mi2;</span>
<span class="line-added">3166             }</span>
<span class="line-added">3167         }</span>
<span class="line-added">3168 </span>
<span class="line-added">3169         /*</span>
<span class="line-added">3170          * Merge small parts sequentially.</span>
<span class="line-added">3171          */</span>
<span class="line-added">3172         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="line-added">3173             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>
<span class="line-added">3174         }</span>
<span class="line-added">3175         if (dst != a1 || k &lt; lo1) {</span>
<span class="line-added">3176             while (lo1 &lt; hi1) {</span>
<span class="line-added">3177                 dst[k++] = a1[lo1++];</span>
<span class="line-added">3178             }</span>
<span class="line-added">3179         }</span>
<span class="line-added">3180         if (dst != a2 || k &lt; lo2) {</span>
<span class="line-added">3181             while (lo2 &lt; hi2) {</span>
<span class="line-added">3182                 dst[k++] = a2[lo2++];</span>
<span class="line-added">3183             }</span>
<span class="line-added">3184         }</span>
<span class="line-added">3185     }</span>
<span class="line-added">3186 </span>
<span class="line-added">3187 // [double]</span>
<span class="line-added">3188 </span>
<span class="line-added">3189     /**</span>
<span class="line-added">3190      * Sorts the specified range of the array using parallel merge</span>
<span class="line-added">3191      * sort and/or Dual-Pivot Quicksort.</span>
<span class="line-added">3192      *</span>
<span class="line-added">3193      * To balance the faster splitting and parallelism of merge sort</span>
<span class="line-added">3194      * with the faster element partitioning of Quicksort, ranges are</span>
<span class="line-added">3195      * subdivided in tiers such that, if there is enough parallelism,</span>
<span class="line-added">3196      * the four-way parallel merge is started, still ensuring enough</span>
<span class="line-added">3197      * parallelism to process the partitions.</span>
<span class="line-added">3198      *</span>
<span class="line-added">3199      * @param a the array to be sorted</span>
<span class="line-added">3200      * @param parallelism the parallelism level</span>
<span class="line-added">3201      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">3202      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">3203      */</span>
<span class="line-added">3204     static void sort(double[] a, int parallelism, int low, int high) {</span>
<span class="line-added">3205         /*</span>
<span class="line-added">3206          * Phase 1. Count the number of negative zero -0.0d,</span>
<span class="line-added">3207          * turn them into positive zero, and move all NaNs</span>
<span class="line-added">3208          * to the end of the array.</span>
<span class="line-added">3209          */</span>
<span class="line-added">3210         int numNegativeZero = 0;</span>
<span class="line-added">3211 </span>
<span class="line-added">3212         for (int k = high; k &gt; low; ) {</span>
<span class="line-added">3213             double ak = a[--k];</span>
<span class="line-added">3214 </span>
<span class="line-added">3215             if (ak == 0.0d &amp;&amp; Double.doubleToRawLongBits(ak) &lt; 0) { // ak is -0.0d</span>
<span class="line-added">3216                 numNegativeZero += 1;</span>
<span class="line-added">3217                 a[k] = 0.0d;</span>
<span class="line-added">3218             } else if (ak != ak) { // ak is NaN</span>
<span class="line-added">3219                 a[k] = a[--high];</span>
<span class="line-added">3220                 a[high] = ak;</span>
<span class="line-added">3221             }</span>
<span class="line-added">3222         }</span>
<span class="line-added">3223 </span>
<span class="line-added">3224         /*</span>
<span class="line-added">3225          * Phase 2. Sort everything except NaNs,</span>
<span class="line-added">3226          * which are already in place.</span>
<span class="line-added">3227          */</span>
<span class="line-added">3228         int size = high - low;</span>
<span class="line-added">3229 </span>
<span class="line-added">3230         if (parallelism &gt; 1 &amp;&amp; size &gt; MIN_PARALLEL_SORT_SIZE) {</span>
<span class="line-added">3231             int depth = getDepth(parallelism, size &gt;&gt; 12);</span>
<span class="line-added">3232             double[] b = depth == 0 ? null : new double[size];</span>
<span class="line-added">3233             new Sorter(null, a, b, low, size, low, depth).invoke();</span>
<span class="line-added">3234         } else {</span>
<span class="line-added">3235             sort(null, a, 0, low, high);</span>
<span class="line-added">3236         }</span>
<span class="line-added">3237 </span>
<span class="line-added">3238         /*</span>
<span class="line-added">3239          * Phase 3. Turn positive zero 0.0d</span>
<span class="line-added">3240          * back into negative zero -0.0d.</span>
<span class="line-added">3241          */</span>
<span class="line-added">3242         if (++numNegativeZero == 1) {</span>
<span class="line-added">3243             return;</span>
<span class="line-added">3244         }</span>
<span class="line-added">3245 </span>
<span class="line-added">3246         /*</span>
<span class="line-added">3247          * Find the position one less than</span>
<span class="line-added">3248          * the index of the first zero.</span>
<span class="line-added">3249          */</span>
<span class="line-added">3250         while (low &lt;= high) {</span>
<span class="line-added">3251             int middle = (low + high) &gt;&gt;&gt; 1;</span>
<span class="line-added">3252 </span>
<span class="line-added">3253             if (a[middle] &lt; 0) {</span>
<span class="line-added">3254                 low = middle + 1;</span>
<span class="line-added">3255             } else {</span>
<span class="line-added">3256                 high = middle - 1;</span>
<span class="line-added">3257             }</span>
<span class="line-added">3258         }</span>
<span class="line-added">3259 </span>
<span class="line-added">3260         /*</span>
<span class="line-added">3261          * Replace the required number of 0.0d by -0.0d.</span>
<span class="line-added">3262          */</span>
<span class="line-added">3263         while (--numNegativeZero &gt; 0) {</span>
<span class="line-added">3264             a[++high] = -0.0d;</span>
<span class="line-added">3265         }</span>
<span class="line-added">3266     }</span>
<span class="line-added">3267 </span>
<span class="line-added">3268     /**</span>
<span class="line-added">3269      * Sorts the specified array using the Dual-Pivot Quicksort and/or</span>
<span class="line-added">3270      * other sorts in special-cases, possibly with parallel partitions.</span>
<span class="line-added">3271      *</span>
<span class="line-added">3272      * @param sorter parallel context</span>
<span class="line-added">3273      * @param a the array to be sorted</span>
<span class="line-added">3274      * @param bits the combination of recursion depth and bit flag, where</span>
<span class="line-added">3275      *        the right bit &quot;0&quot; indicates that array is the leftmost part</span>
<span class="line-added">3276      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">3277      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">3278      */</span>
<span class="line-added">3279     static void sort(Sorter sorter, double[] a, int bits, int low, int high) {</span>
<span class="line-added">3280         while (true) {</span>
<span class="line-added">3281             int end = high - 1, size = high - low;</span>
3282 
3283             /*
<span class="line-modified">3284              * Run mixed insertion sort on small non-leftmost parts.</span>
<span class="line-modified">3285              */</span>
<span class="line-modified">3286             if (size &lt; MAX_MIXED_INSERTION_SORT_SIZE + bits &amp;&amp; (bits &amp; 1) &gt; 0) {</span>
<span class="line-modified">3287                 mixedInsertionSort(a, low, high - 3 * ((size &gt;&gt; 5) &lt;&lt; 3), high);</span>
<span class="line-modified">3288                 return;</span>
<span class="line-modified">3289             }</span>
<span class="line-modified">3290 </span>
<span class="line-modified">3291             /*</span>
<span class="line-modified">3292              * Invoke insertion sort on small leftmost part.</span>
<span class="line-modified">3293              */</span>
<span class="line-modified">3294             if (size &lt; MAX_INSERTION_SORT_SIZE) {</span>
<span class="line-added">3295                 insertionSort(a, low, high);</span>
<span class="line-added">3296                 return;</span>
<span class="line-added">3297             }</span>
<span class="line-added">3298 </span>
<span class="line-added">3299             /*</span>
<span class="line-added">3300              * Check if the whole array or large non-leftmost</span>
<span class="line-added">3301              * parts are nearly sorted and then merge runs.</span>
<span class="line-added">3302              */</span>
<span class="line-added">3303             if ((bits == 0 || size &gt; MIN_TRY_MERGE_SIZE &amp;&amp; (bits &amp; 1) &gt; 0)</span>
<span class="line-added">3304                     &amp;&amp; tryMergeRuns(sorter, a, low, size)) {</span>
<span class="line-added">3305                 return;</span>
<span class="line-added">3306             }</span>
<span class="line-added">3307 </span>
<span class="line-added">3308             /*</span>
<span class="line-added">3309              * Switch to heap sort if execution</span>
<span class="line-added">3310              * time is becoming quadratic.</span>
<span class="line-added">3311              */</span>
<span class="line-added">3312             if ((bits += DELTA) &gt; MAX_RECURSION_DEPTH) {</span>
<span class="line-added">3313                 heapSort(a, low, high);</span>
<span class="line-added">3314                 return;</span>
<span class="line-added">3315             }</span>
<span class="line-added">3316 </span>
<span class="line-added">3317             /*</span>
<span class="line-added">3318              * Use an inexpensive approximation of the golden ratio</span>
<span class="line-added">3319              * to select five sample elements and determine pivots.</span>
<span class="line-added">3320              */</span>
<span class="line-added">3321             int step = (size &gt;&gt; 3) * 3 + 3;</span>
<span class="line-added">3322 </span>
<span class="line-added">3323             /*</span>
<span class="line-added">3324              * Five elements around (and including) the central element</span>
<span class="line-added">3325              * will be used for pivot selection as described below. The</span>
<span class="line-added">3326              * unequal choice of spacing these elements was empirically</span>
<span class="line-added">3327              * determined to work well on a wide variety of inputs.</span>
<span class="line-added">3328              */</span>
<span class="line-added">3329             int e1 = low + step;</span>
<span class="line-added">3330             int e5 = end - step;</span>
<span class="line-added">3331             int e3 = (e1 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">3332             int e2 = (e1 + e3) &gt;&gt;&gt; 1;</span>
<span class="line-added">3333             int e4 = (e3 + e5) &gt;&gt;&gt; 1;</span>
<span class="line-added">3334             double a3 = a[e3];</span>
<span class="line-added">3335 </span>
<span class="line-added">3336             /*</span>
<span class="line-added">3337              * Sort these elements in place by the combination</span>
<span class="line-added">3338              * of 4-element sorting network and insertion sort.</span>
3339              *
<span class="line-modified">3340              *    5 ------o-----------o------------</span>
<span class="line-modified">3341              *            |           |</span>
<span class="line-modified">3342              *    4 ------|-----o-----o-----o------</span>
<span class="line-added">3343              *            |     |           |</span>
<span class="line-added">3344              *    2 ------o-----|-----o-----o------</span>
<span class="line-added">3345              *                  |     |</span>
<span class="line-added">3346              *    1 ------------o-----o------------</span>
<span class="line-added">3347              */</span>
<span class="line-added">3348             if (a[e5] &lt; a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }</span>
<span class="line-added">3349             if (a[e4] &lt; a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }</span>
<span class="line-added">3350             if (a[e5] &lt; a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }</span>
<span class="line-added">3351             if (a[e2] &lt; a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }</span>
<span class="line-added">3352             if (a[e4] &lt; a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }</span>
<span class="line-added">3353 </span>
<span class="line-added">3354             if (a3 &lt; a[e2]) {</span>
<span class="line-added">3355                 if (a3 &lt; a[e1]) {</span>
<span class="line-added">3356                     a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;</span>
<span class="line-added">3357                 } else {</span>
<span class="line-added">3358                     a[e3] = a[e2]; a[e2] = a3;</span>
<span class="line-added">3359                 }</span>
<span class="line-added">3360             } else if (a3 &gt; a[e4]) {</span>
<span class="line-added">3361                 if (a3 &gt; a[e5]) {</span>
<span class="line-added">3362                     a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;</span>
<span class="line-added">3363                 } else {</span>
<span class="line-added">3364                     a[e3] = a[e4]; a[e4] = a3;</span>
<span class="line-added">3365                 }</span>
<span class="line-added">3366             }</span>
<span class="line-added">3367 </span>
<span class="line-added">3368             // Pointers</span>
<span class="line-added">3369             int lower = low; // The index of the last element of the left part</span>
<span class="line-added">3370             int upper = end; // The index of the first element of the right part</span>
<span class="line-added">3371 </span>
<span class="line-added">3372             /*</span>
<span class="line-added">3373              * Partitioning with 2 pivots in case of different elements.</span>
<span class="line-added">3374              */</span>
<span class="line-added">3375             if (a[e1] &lt; a[e2] &amp;&amp; a[e2] &lt; a[e3] &amp;&amp; a[e3] &lt; a[e4] &amp;&amp; a[e4] &lt; a[e5]) {</span>
<span class="line-added">3376 </span>
<span class="line-added">3377                 /*</span>
<span class="line-added">3378                  * Use the first and fifth of the five sorted elements as</span>
<span class="line-added">3379                  * the pivots. These values are inexpensive approximation</span>
<span class="line-added">3380                  * of tertiles. Note, that pivot1 &lt; pivot2.</span>
<span class="line-added">3381                  */</span>
<span class="line-added">3382                 double pivot1 = a[e1];</span>
<span class="line-added">3383                 double pivot2 = a[e5];</span>
<span class="line-added">3384 </span>
<span class="line-added">3385                 /*</span>
<span class="line-added">3386                  * The first and the last elements to be sorted are moved</span>
<span class="line-added">3387                  * to the locations formerly occupied by the pivots. When</span>
<span class="line-added">3388                  * partitioning is completed, the pivots are swapped back</span>
<span class="line-added">3389                  * into their final positions, and excluded from the next</span>
<span class="line-added">3390                  * subsequent sorting.</span>
<span class="line-added">3391                  */</span>
<span class="line-added">3392                 a[e1] = a[lower];</span>
<span class="line-added">3393                 a[e5] = a[upper];</span>
<span class="line-added">3394 </span>
<span class="line-added">3395                 /*</span>
<span class="line-added">3396                  * Skip elements, which are less or greater than the pivots.</span>
<span class="line-added">3397                  */</span>
<span class="line-added">3398                 while (a[++lower] &lt; pivot1);</span>
<span class="line-added">3399                 while (a[--upper] &gt; pivot2);</span>
<span class="line-added">3400 </span>
<span class="line-added">3401                 /*</span>
<span class="line-added">3402                  * Backward 3-interval partitioning</span>
<span class="line-added">3403                  *</span>
<span class="line-added">3404                  *   left part                 central part          right part</span>
<span class="line-added">3405                  * +------------------------------------------------------------+</span>
<span class="line-added">3406                  * |  &lt; pivot1  |   ?   |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |  &gt; pivot2  |</span>
<span class="line-added">3407                  * +------------------------------------------------------------+</span>
<span class="line-added">3408                  *             ^       ^                            ^</span>
<span class="line-added">3409                  *             |       |                            |</span>
<span class="line-added">3410                  *           lower     k                          upper</span>
<span class="line-added">3411                  *</span>
<span class="line-added">3412                  * Invariants:</span>
<span class="line-added">3413                  *</span>
<span class="line-added">3414                  *              all in (low, lower] &lt; pivot1</span>
<span class="line-added">3415                  *    pivot1 &lt;= all in (k, upper)  &lt;= pivot2</span>
<span class="line-added">3416                  *              all in [upper, end) &gt; pivot2</span>
<span class="line-added">3417                  *</span>
<span class="line-added">3418                  * Pointer k is the last index of ?-part</span>
<span class="line-added">3419                  */</span>
<span class="line-added">3420                 for (int unused = --lower, k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">3421                     double ak = a[k];</span>
<span class="line-added">3422 </span>
<span class="line-added">3423                     if (ak &lt; pivot1) { // Move a[k] to the left side</span>
<span class="line-added">3424                         while (lower &lt; k) {</span>
<span class="line-added">3425                             if (a[++lower] &gt;= pivot1) {</span>
<span class="line-added">3426                                 if (a[lower] &gt; pivot2) {</span>
<span class="line-added">3427                                     a[k] = a[--upper];</span>
<span class="line-added">3428                                     a[upper] = a[lower];</span>
<span class="line-added">3429                                 } else {</span>
<span class="line-added">3430                                     a[k] = a[lower];</span>
<span class="line-added">3431                                 }</span>
<span class="line-added">3432                                 a[lower] = ak;</span>
<span class="line-added">3433                                 break;</span>
<span class="line-added">3434                             }</span>
<span class="line-added">3435                         }</span>
<span class="line-added">3436                     } else if (ak &gt; pivot2) { // Move a[k] to the right side</span>
<span class="line-added">3437                         a[k] = a[--upper];</span>
<span class="line-added">3438                         a[upper] = ak;</span>
<span class="line-added">3439                     }</span>
<span class="line-added">3440                 }</span>
<span class="line-added">3441 </span>
<span class="line-added">3442                 /*</span>
<span class="line-added">3443                  * Swap the pivots into their final positions.</span>
<span class="line-added">3444                  */</span>
<span class="line-added">3445                 a[low] = a[lower]; a[lower] = pivot1;</span>
<span class="line-added">3446                 a[end] = a[upper]; a[upper] = pivot2;</span>
<span class="line-added">3447 </span>
<span class="line-added">3448                 /*</span>
<span class="line-added">3449                  * Sort non-left parts recursively (possibly in parallel),</span>
<span class="line-added">3450                  * excluding known pivots.</span>
<span class="line-added">3451                  */</span>
<span class="line-added">3452                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">3453                     sorter.forkSorter(bits | 1, lower + 1, upper);</span>
<span class="line-added">3454                     sorter.forkSorter(bits | 1, upper + 1, high);</span>
<span class="line-added">3455                 } else {</span>
<span class="line-added">3456                     sort(sorter, a, bits | 1, lower + 1, upper);</span>
<span class="line-added">3457                     sort(sorter, a, bits | 1, upper + 1, high);</span>
<span class="line-added">3458                 }</span>
<span class="line-added">3459 </span>
<span class="line-added">3460             } else { // Use single pivot in case of many equal elements</span>
<span class="line-added">3461 </span>
<span class="line-added">3462                 /*</span>
<span class="line-added">3463                  * Use the third of the five sorted elements as the pivot.</span>
<span class="line-added">3464                  * This value is inexpensive approximation of the median.</span>
<span class="line-added">3465                  */</span>
<span class="line-added">3466                 double pivot = a[e3];</span>
<span class="line-added">3467 </span>
<span class="line-added">3468                 /*</span>
<span class="line-added">3469                  * The first element to be sorted is moved to the</span>
<span class="line-added">3470                  * location formerly occupied by the pivot. After</span>
<span class="line-added">3471                  * completion of partitioning the pivot is swapped</span>
<span class="line-added">3472                  * back into its final position, and excluded from</span>
<span class="line-added">3473                  * the next subsequent sorting.</span>
<span class="line-added">3474                  */</span>
<span class="line-added">3475                 a[e3] = a[lower];</span>
<span class="line-added">3476 </span>
<span class="line-added">3477                 /*</span>
<span class="line-added">3478                  * Traditional 3-way (Dutch National Flag) partitioning</span>
<span class="line-added">3479                  *</span>
<span class="line-added">3480                  *   left part                 central part    right part</span>
<span class="line-added">3481                  * +------------------------------------------------------+</span>
<span class="line-added">3482                  * |   &lt; pivot   |     ?     |   == pivot   |   &gt; pivot   |</span>
<span class="line-added">3483                  * +------------------------------------------------------+</span>
<span class="line-added">3484                  *              ^           ^                ^</span>
<span class="line-added">3485                  *              |           |                |</span>
<span class="line-added">3486                  *            lower         k              upper</span>
<span class="line-added">3487                  *</span>
<span class="line-added">3488                  * Invariants:</span>
<span class="line-added">3489                  *</span>
<span class="line-added">3490                  *   all in (low, lower] &lt; pivot</span>
<span class="line-added">3491                  *   all in (k, upper)  == pivot</span>
<span class="line-added">3492                  *   all in [upper, end] &gt; pivot</span>
<span class="line-added">3493                  *</span>
<span class="line-added">3494                  * Pointer k is the last index of ?-part</span>
<span class="line-added">3495                  */</span>
<span class="line-added">3496                 for (int k = ++upper; --k &gt; lower; ) {</span>
<span class="line-added">3497                     double ak = a[k];</span>
<span class="line-added">3498 </span>
<span class="line-added">3499                     if (ak != pivot) {</span>
<span class="line-added">3500                         a[k] = pivot;</span>
<span class="line-added">3501 </span>
<span class="line-added">3502                         if (ak &lt; pivot) { // Move a[k] to the left side</span>
<span class="line-added">3503                             while (a[++lower] &lt; pivot);</span>
<span class="line-added">3504 </span>
<span class="line-added">3505                             if (a[lower] &gt; pivot) {</span>
<span class="line-added">3506                                 a[--upper] = a[lower];</span>
<span class="line-added">3507                             }</span>
<span class="line-added">3508                             a[lower] = ak;</span>
<span class="line-added">3509                         } else { // ak &gt; pivot - Move a[k] to the right side</span>
<span class="line-added">3510                             a[--upper] = ak;</span>
<span class="line-added">3511                         }</span>
<span class="line-added">3512                     }</span>
<span class="line-added">3513                 }</span>
<span class="line-added">3514 </span>
<span class="line-added">3515                 /*</span>
<span class="line-added">3516                  * Swap the pivot into its final position.</span>
<span class="line-added">3517                  */</span>
<span class="line-added">3518                 a[low] = a[lower]; a[lower] = pivot;</span>
<span class="line-added">3519 </span>
<span class="line-added">3520                 /*</span>
<span class="line-added">3521                  * Sort the right part (possibly in parallel), excluding</span>
<span class="line-added">3522                  * known pivot. All elements from the central part are</span>
<span class="line-added">3523                  * equal and therefore already sorted.</span>
<span class="line-added">3524                  */</span>
<span class="line-added">3525                 if (size &gt; MIN_PARALLEL_SORT_SIZE &amp;&amp; sorter != null) {</span>
<span class="line-added">3526                     sorter.forkSorter(bits | 1, upper, high);</span>
<span class="line-added">3527                 } else {</span>
<span class="line-added">3528                     sort(sorter, a, bits | 1, upper, high);</span>
<span class="line-added">3529                 }</span>
<span class="line-added">3530             }</span>
<span class="line-added">3531             high = lower; // Iterate along the left part</span>
<span class="line-added">3532         }</span>
<span class="line-added">3533     }</span>
<span class="line-added">3534 </span>
<span class="line-added">3535     /**</span>
<span class="line-added">3536      * Sorts the specified range of the array using mixed insertion sort.</span>
<span class="line-added">3537      *</span>
<span class="line-added">3538      * Mixed insertion sort is combination of simple insertion sort,</span>
<span class="line-added">3539      * pin insertion sort and pair insertion sort.</span>
<span class="line-added">3540      *</span>
<span class="line-added">3541      * In the context of Dual-Pivot Quicksort, the pivot element</span>
<span class="line-added">3542      * from the left part plays the role of sentinel, because it</span>
<span class="line-added">3543      * is less than any elements from the given part. Therefore,</span>
<span class="line-added">3544      * expensive check of the left range can be skipped on each</span>
<span class="line-added">3545      * iteration unless it is the leftmost call.</span>
<span class="line-added">3546      *</span>
<span class="line-added">3547      * @param a the array to be sorted</span>
<span class="line-added">3548      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">3549      * @param end the index of the last element for simple insertion sort</span>
<span class="line-added">3550      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">3551      */</span>
<span class="line-added">3552     private static void mixedInsertionSort(double[] a, int low, int end, int high) {</span>
<span class="line-added">3553         if (end == high) {</span>
<span class="line-added">3554 </span>
<span class="line-added">3555             /*</span>
<span class="line-added">3556              * Invoke simple insertion sort on tiny array.</span>
<span class="line-added">3557              */</span>
<span class="line-added">3558             for (int i; ++low &lt; end; ) {</span>
<span class="line-added">3559                 double ai = a[i = low];</span>
<span class="line-added">3560 </span>
<span class="line-added">3561                 while (ai &lt; a[--i]) {</span>
<span class="line-added">3562                     a[i + 1] = a[i];</span>
<span class="line-added">3563                 }</span>
<span class="line-added">3564                 a[i + 1] = ai;</span>
<span class="line-added">3565             }</span>
<span class="line-added">3566         } else {</span>
<span class="line-added">3567 </span>
<span class="line-added">3568             /*</span>
<span class="line-added">3569              * Start with pin insertion sort on small part.</span>
3570              *
<span class="line-modified">3571              * Pin insertion sort is extended simple insertion sort.</span>
<span class="line-added">3572              * The main idea of this sort is to put elements larger</span>
<span class="line-added">3573              * than an element called pin to the end of array (the</span>
<span class="line-added">3574              * proper area for such elements). It avoids expensive</span>
<span class="line-added">3575              * movements of these elements through the whole array.</span>
3576              */
<span class="line-modified">3577             double pin = a[end];</span>
<span class="line-modified">3578 </span>
<span class="line-modified">3579             for (int i, p = high; ++low &lt; end; ) {</span>
<span class="line-modified">3580                 double ai = a[i = low];</span>
<span class="line-modified">3581 </span>
<span class="line-added">3582                 if (ai &lt; a[i - 1]) { // Small element</span>
<span class="line-added">3583 </span>
<span class="line-added">3584                     /*</span>
<span class="line-added">3585                      * Insert small element into sorted part.</span>
<span class="line-added">3586                      */</span>
<span class="line-added">3587                     a[i] = a[--i];</span>
<span class="line-added">3588 </span>
<span class="line-added">3589                     while (ai &lt; a[--i]) {</span>
<span class="line-added">3590                         a[i + 1] = a[i];</span>
<span class="line-added">3591                     }</span>
<span class="line-added">3592                     a[i + 1] = ai;</span>
<span class="line-added">3593 </span>
<span class="line-added">3594                 } else if (p &gt; i &amp;&amp; ai &gt; pin) { // Large element</span>
<span class="line-added">3595 </span>
<span class="line-added">3596                     /*</span>
<span class="line-added">3597                      * Find element smaller than pin.</span>
<span class="line-added">3598                      */</span>
<span class="line-added">3599                     while (a[--p] &gt; pin);</span>
<span class="line-added">3600 </span>
3601                     /*
<span class="line-modified">3602                      * Swap it with large element.</span>

3603                      */
<span class="line-modified">3604                     if (p &gt; i) {</span>
<span class="line-modified">3605                         ai = a[p];</span>
<span class="line-modified">3606                         a[p] = a[i];</span>











3607                     }
<span class="line-added">3608 </span>
3609                     /*
<span class="line-modified">3610                      * Insert small element into sorted part.</span>

3611                      */
<span class="line-modified">3612                     while (ai &lt; a[--i]) {</span>
<span class="line-modified">3613                         a[i + 1] = a[i];</span>
<span class="line-added">3614                     }</span>
<span class="line-added">3615                     a[i + 1] = ai;</span>
3616                 }
3617             }
3618 








3619             /*
<span class="line-modified">3620              * Continue with pair insertion sort on remain part.</span>

3621              */
<span class="line-modified">3622             for (int i; low &lt; high; ++low) {</span>
<span class="line-modified">3623                 double a1 = a[i = low], a2 = a[++low];</span>









3624 
3625                 /*
<span class="line-modified">3626                  * Insert two elements per iteration: at first, insert the</span>
<span class="line-modified">3627                  * larger element and then insert the smaller element, but</span>
<span class="line-modified">3628                  * from the position where the larger element was inserted.</span>














3629                  */
<span class="line-modified">3630                 if (a1 &gt; a2) {</span>
<span class="line-modified">3631 </span>
<span class="line-modified">3632                     while (a1 &lt; a[--i]) {</span>
<span class="line-modified">3633                         a[i + 2] = a[i];</span>


























3634                     }
<span class="line-modified">3635                     a[++i + 1] = a1;</span>

3636 
<span class="line-modified">3637                     while (a2 &lt; a[--i]) {</span>
<span class="line-modified">3638                         a[i + 1] = a[i];</span>
<span class="line-added">3639                     }</span>
<span class="line-added">3640                     a[i + 1] = a2;</span>
3641 
<span class="line-modified">3642                 } else if (a1 &lt; a[i - 1]) {</span>





3643 
<span class="line-modified">3644                     while (a2 &lt; a[--i]) {</span>
<span class="line-modified">3645                         a[i + 2] = a[i];</span>






























3646                     }
<span class="line-modified">3647                     a[++i + 1] = a2;</span>
<span class="line-modified">3648 </span>
<span class="line-modified">3649                     while (a1 &lt; a[--i]) {</span>
<span class="line-modified">3650                         a[i + 1] = a[i];</span>










3651                     }
<span class="line-modified">3652                     a[i + 1] = a1;</span>

3653                 }
3654             }
<span class="line-added">3655         }</span>
<span class="line-added">3656     }</span>
3657 
<span class="line-modified">3658     /**</span>
<span class="line-modified">3659      * Sorts the specified range of the array using insertion sort.</span>
<span class="line-modified">3660      *</span>
<span class="line-modified">3661      * @param a the array to be sorted</span>
<span class="line-modified">3662      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">3663      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified">3664      */</span>
<span class="line-added">3665     private static void insertionSort(double[] a, int low, int high) {</span>
<span class="line-added">3666         for (int i, k = low; ++k &lt; high; ) {</span>
<span class="line-added">3667             double ai = a[i = k];</span>
<span class="line-added">3668 </span>
<span class="line-added">3669             if (ai &lt; a[i - 1]) {</span>
<span class="line-added">3670                 while (--i &gt;= low &amp;&amp; ai &lt; a[i]) {</span>
<span class="line-added">3671                     a[i + 1] = a[i];</span>
<span class="line-added">3672                 }</span>
<span class="line-added">3673                 a[i + 1] = ai;</span>
<span class="line-added">3674             }</span>
3675         }
3676     }
3677 
3678     /**
<span class="line-modified">3679      * Sorts the specified range of the array using heap sort.</span>

3680      *
3681      * @param a the array to be sorted
<span class="line-modified">3682      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-modified">3683      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-modified">3684      */</span>
<span class="line-modified">3685     private static void heapSort(double[] a, int low, int high) {</span>
<span class="line-modified">3686         for (int k = (low + high) &gt;&gt;&gt; 1; k &gt; low; ) {</span>
<span class="line-modified">3687             pushDown(a, --k, a[k], low, high);</span>







3688         }
<span class="line-modified">3689         while (--high &gt; low) {</span>
<span class="line-modified">3690             double max = a[low];</span>
<span class="line-modified">3691             pushDown(a, low, a[high], low, high);</span>
<span class="line-modified">3692             a[high] = max;</span>
<span class="line-modified">3693         }</span>
<span class="line-modified">3694     }</span>
<span class="line-added">3695 </span>
<span class="line-added">3696     /**</span>
<span class="line-added">3697      * Pushes specified element down during heap sort.</span>
<span class="line-added">3698      *</span>
<span class="line-added">3699      * @param a the given array</span>
<span class="line-added">3700      * @param p the start index</span>
<span class="line-added">3701      * @param value the given element</span>
<span class="line-added">3702      * @param low the index of the first element, inclusive, to be sorted</span>
<span class="line-added">3703      * @param high the index of the last element, exclusive, to be sorted</span>
<span class="line-added">3704      */</span>
<span class="line-added">3705     private static void pushDown(double[] a, int p, double value, int low, int high) {</span>
<span class="line-added">3706         for (int k ;; a[p] = a[p = k]) {</span>
<span class="line-added">3707             k = (p &lt;&lt; 1) - low + 2; // Index of the right child</span>
<span class="line-added">3708 </span>
<span class="line-added">3709             if (k &gt; high) {</span>
<span class="line-added">3710                 break;</span>
<span class="line-added">3711             }</span>
<span class="line-added">3712             if (k == high || a[k] &lt; a[k - 1]) {</span>
<span class="line-added">3713                 --k;</span>
<span class="line-added">3714             }</span>
<span class="line-added">3715             if (a[k] &lt;= value) {</span>
<span class="line-added">3716                 break;</span>
3717             }
3718         }
<span class="line-added">3719         a[p] = value;</span>
<span class="line-added">3720     }</span>
3721 
<span class="line-modified">3722     /**</span>
<span class="line-modified">3723      * Tries to sort the specified range of the array.</span>
<span class="line-modified">3724      *</span>
<span class="line-modified">3725      * @param sorter parallel context</span>
<span class="line-added">3726      * @param a the array to be sorted</span>
<span class="line-added">3727      * @param low the index of the first element to be sorted</span>
<span class="line-added">3728      * @param size the array size</span>
<span class="line-added">3729      * @return true if finally sorted, false otherwise</span>
<span class="line-added">3730      */</span>
<span class="line-added">3731     private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {</span>
3732 
3733         /*
<span class="line-modified">3734          * The run array is constructed only if initial runs are</span>
<span class="line-added">3735          * long enough to continue, run[i] then holds start index</span>
<span class="line-added">3736          * of the i-th sequence of elements in non-descending order.</span>
3737          */
<span class="line-modified">3738         int[] run = null;</span>
<span class="line-added">3739         int high = low + size;</span>
<span class="line-added">3740         int count = 1, last = low;</span>
3741 
3742         /*
<span class="line-modified">3743          * Identify all possible runs.</span>
3744          */
<span class="line-modified">3745         for (int k = low + 1; k &lt; high; ) {</span>


3746 
<span class="line-modified">3747             /*</span>
<span class="line-modified">3748              * Find the end index of the current run.</span>
<span class="line-modified">3749              */</span>
<span class="line-modified">3750             if (a[k - 1] &lt; a[k]) {</span>
<span class="line-added">3751 </span>
<span class="line-added">3752                 // Identify ascending sequence</span>
<span class="line-added">3753                 while (++k &lt; high &amp;&amp; a[k - 1] &lt;= a[k]);</span>
<span class="line-added">3754 </span>
<span class="line-added">3755             } else if (a[k - 1] &gt; a[k]) {</span>
<span class="line-added">3756 </span>
<span class="line-added">3757                 // Identify descending sequence</span>
<span class="line-added">3758                 while (++k &lt; high &amp;&amp; a[k - 1] &gt;= a[k]);</span>
<span class="line-added">3759 </span>
<span class="line-added">3760                 // Reverse into ascending order</span>
<span class="line-added">3761                 for (int i = last - 1, j = k; ++i &lt; --j &amp;&amp; a[i] &gt; a[j]; ) {</span>
<span class="line-added">3762                     double ai = a[i]; a[i] = a[j]; a[j] = ai;</span>
<span class="line-added">3763                 }</span>
<span class="line-added">3764             } else { // Identify constant sequence</span>
<span class="line-added">3765                 for (double ak = a[k]; ++k &lt; high &amp;&amp; ak == a[k]; );</span>
<span class="line-added">3766 </span>
<span class="line-added">3767                 if (k &lt; high) {</span>
<span class="line-added">3768                     continue;</span>
<span class="line-added">3769                 }</span>
3770             }

3771 
<span class="line-modified">3772             /*</span>
<span class="line-modified">3773              * Check special cases.</span>
<span class="line-modified">3774              */</span>
<span class="line-modified">3775             if (run == null) {</span>
<span class="line-modified">3776                 if (k == high) {</span>
<span class="line-added">3777 </span>
<span class="line-added">3778                     /*</span>
<span class="line-added">3779                      * The array is monotonous sequence,</span>
<span class="line-added">3780                      * and therefore already sorted.</span>
<span class="line-added">3781                      */</span>
<span class="line-added">3782                     return true;</span>
<span class="line-added">3783                 }</span>
<span class="line-added">3784 </span>
<span class="line-added">3785                 if (k - low &lt; MIN_FIRST_RUN_SIZE) {</span>
<span class="line-added">3786 </span>
<span class="line-added">3787                     /*</span>
<span class="line-added">3788                      * The first run is too small</span>
<span class="line-added">3789                      * to proceed with scanning.</span>
<span class="line-added">3790                      */</span>
<span class="line-added">3791                     return false;</span>
<span class="line-added">3792                 }</span>
<span class="line-added">3793 </span>
<span class="line-added">3794                 run = new int[((size &gt;&gt; 10) | 0x7F) &amp; 0x3FF];</span>
<span class="line-added">3795                 run[0] = low;</span>
<span class="line-added">3796 </span>
<span class="line-added">3797             } else if (a[last - 1] &gt; a[last]) {</span>
<span class="line-added">3798 </span>
<span class="line-added">3799                 if (count &gt; (k - low) &gt;&gt; MIN_FIRST_RUNS_FACTOR) {</span>
<span class="line-added">3800 </span>
<span class="line-added">3801                     /*</span>
<span class="line-added">3802                      * The first runs are not long</span>
<span class="line-added">3803                      * enough to continue scanning.</span>
<span class="line-added">3804                      */</span>
<span class="line-added">3805                     return false;</span>
<span class="line-added">3806                 }</span>
<span class="line-added">3807 </span>
<span class="line-added">3808                 if (++count == MAX_RUN_CAPACITY) {</span>
<span class="line-added">3809 </span>
<span class="line-added">3810                     /*</span>
<span class="line-added">3811                      * Array is not highly structured.</span>
<span class="line-added">3812                      */</span>
<span class="line-added">3813                     return false;</span>
<span class="line-added">3814                 }</span>
<span class="line-added">3815 </span>
<span class="line-added">3816                 if (count == run.length) {</span>
<span class="line-added">3817 </span>
<span class="line-added">3818                     /*</span>
<span class="line-added">3819                      * Increase capacity of index array.</span>
<span class="line-added">3820                      */</span>
<span class="line-added">3821                     run = Arrays.copyOf(run, count &lt;&lt; 1);</span>
<span class="line-added">3822                 }</span>
<span class="line-added">3823             }</span>
<span class="line-added">3824             run[count] = (last = k);</span>
3825         }
3826 
3827         /*
<span class="line-modified">3828          * Merge runs of highly structured array.</span>


















3829          */
<span class="line-modified">3830         if (count &gt; 1) {</span>
<span class="line-modified">3831             double[] b; int offset = low;</span>
<span class="line-modified">3832 </span>
<span class="line-modified">3833             if (sorter == null || (b = (double[]) sorter.b) == null) {</span>
<span class="line-modified">3834                 b = new double[size];</span>
<span class="line-modified">3835             } else {</span>
<span class="line-modified">3836                 offset = sorter.offset;</span>

3837             }
<span class="line-added">3838             mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);</span>
3839         }
<span class="line-added">3840         return true;</span>
3841     }
3842 
3843     /**
<span class="line-modified">3844      * Merges the specified runs.</span>
3845      *
<span class="line-modified">3846      * @param a the source array</span>
<span class="line-modified">3847      * @param b the temporary buffer used in merging</span>
<span class="line-modified">3848      * @param offset the start index in the source, inclusive</span>
<span class="line-modified">3849      * @param aim specifies merging: to source ( &gt; 0), buffer ( &lt; 0) or any ( == 0)</span>
<span class="line-modified">3850      * @param parallel indicates whether merging is performed in parallel</span>
<span class="line-modified">3851      * @param run the start indexes of the runs, inclusive</span>
<span class="line-modified">3852      * @param lo the start index of the first run, inclusive</span>
<span class="line-modified">3853      * @param hi the start index of the last run, inclusive</span>
<span class="line-modified">3854      * @return the destination where runs are merged</span>
<span class="line-modified">3855      */</span>
<span class="line-modified">3856     private static double[] mergeRuns(double[] a, double[] b, int offset,</span>
<span class="line-modified">3857             int aim, boolean parallel, int[] run, int lo, int hi) {</span>
<span class="line-modified">3858 </span>
<span class="line-added">3859         if (hi - lo == 1) {</span>
<span class="line-added">3860             if (aim &gt;= 0) {</span>
<span class="line-added">3861                 return a;</span>
<span class="line-added">3862             }</span>
<span class="line-added">3863             for (int i = run[hi], j = i - offset, low = run[lo]; i &gt; low;</span>
<span class="line-added">3864                 b[--j] = a[--i]</span>
<span class="line-added">3865             );</span>
<span class="line-added">3866             return b;</span>
3867         }
3868 
3869         /*
<span class="line-modified">3870          * Split into approximately equal parts.</span>

3871          */
<span class="line-modified">3872         int mi = lo, rmi = (run[lo] + run[hi]) &gt;&gt;&gt; 1;</span>
<span class="line-modified">3873         while (run[++mi + 1] &lt;= rmi);</span>
















3874 
<span class="line-modified">3875         /*</span>
<span class="line-modified">3876          * Merge the left and right parts.</span>
<span class="line-modified">3877          */</span>
<span class="line-modified">3878         double[] a1, a2;</span>

3879 
<span class="line-modified">3880         if (parallel &amp;&amp; hi - lo &gt; MIN_RUN_COUNT) {</span>
<span class="line-modified">3881             RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();</span>
<span class="line-modified">3882             a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);</span>
<span class="line-modified">3883             a2 = (double[]) merger.getDestination();</span>
<span class="line-modified">3884         } else {</span>
<span class="line-modified">3885             a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);</span>
<span class="line-modified">3886             a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);</span>

3887         }
3888 
<span class="line-modified">3889         double[] dst = a1 == a ? b : a;</span>


3890 
<span class="line-modified">3891         int k   = a1 == a ? run[lo] - offset : run[lo];</span>
<span class="line-modified">3892         int lo1 = a1 == b ? run[lo] - offset : run[lo];</span>
<span class="line-modified">3893         int hi1 = a1 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified">3894         int lo2 = a2 == b ? run[mi] - offset : run[mi];</span>
<span class="line-modified">3895         int hi2 = a2 == b ? run[hi] - offset : run[hi];</span>
<span class="line-modified">3896 </span>
<span class="line-modified">3897         if (parallel) {</span>
<span class="line-modified">3898             new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();</span>




























3899         } else {
<span class="line-modified">3900             mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);</span>

























3901         }
<span class="line-added">3902         return dst;</span>
3903     }
3904 
3905     /**
<span class="line-modified">3906      * Merges the sorted parts.</span>
3907      *
<span class="line-modified">3908      * @param merger parallel context</span>
<span class="line-modified">3909      * @param dst the destination where parts are merged</span>
<span class="line-modified">3910      * @param k the start index of the destination, inclusive</span>
<span class="line-modified">3911      * @param a1 the first part</span>
<span class="line-modified">3912      * @param lo1 the start index of the first part, inclusive</span>
<span class="line-modified">3913      * @param hi1 the end index of the first part, exclusive</span>
<span class="line-modified">3914      * @param a2 the second part</span>
<span class="line-modified">3915      * @param lo2 the start index of the second part, inclusive</span>
<span class="line-modified">3916      * @param hi2 the end index of the second part, exclusive</span>
<span class="line-modified">3917      */</span>
<span class="line-modified">3918     private static void mergeParts(Merger merger, double[] dst, int k,</span>
<span class="line-modified">3919             double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {</span>
<span class="line-modified">3920 </span>
<span class="line-modified">3921         if (merger != null &amp;&amp; a1 == a2) {</span>
<span class="line-modified">3922 </span>
<span class="line-modified">3923             while (true) {</span>
<span class="line-modified">3924 </span>
<span class="line-modified">3925                 /*</span>
<span class="line-modified">3926                  * The first part must be larger.</span>
<span class="line-modified">3927                  */</span>
<span class="line-modified">3928                 if (hi1 - lo1 &lt; hi2 - lo2) {</span>
<span class="line-modified">3929                     int lo = lo1; lo1 = lo2; lo2 = lo;</span>
<span class="line-modified">3930                     int hi = hi1; hi1 = hi2; hi2 = hi;</span>


3931                 }
<span class="line-modified">3932 </span>
3933                 /*
<span class="line-modified">3934                  * Small parts will be merged sequentially.</span>
3935                  */
<span class="line-modified">3936                 if (hi1 - lo1 &lt; MIN_PARALLEL_MERGE_PARTS_SIZE) {</span>
<span class="line-modified">3937                     break;</span>
<span class="line-modified">3938                 }</span>


3939 
3940                 /*
<span class="line-modified">3941                  * Find the median of the larger part.</span>





3942                  */
<span class="line-modified">3943                 int mi1 = (lo1 + hi1) &gt;&gt;&gt; 1;</span>
<span class="line-modified">3944                 double key = a1[mi1];</span>
<span class="line-added">3945                 int mi2 = hi2;</span>
3946 
<span class="line-modified">3947                 /*</span>
<span class="line-modified">3948                  * Partition the smaller part.</span>
<span class="line-modified">3949                  */</span>
<span class="line-modified">3950                 for (int loo = lo2; loo &lt; mi2; ) {</span>
<span class="line-modified">3951                     int t = (loo + mi2) &gt;&gt;&gt; 1;</span>


3952 
<span class="line-modified">3953                     if (key &gt; a2[t]) {</span>
<span class="line-modified">3954                         loo = t + 1;</span>
<span class="line-added">3955                     } else {</span>
<span class="line-added">3956                         mi2 = t;</span>
3957                     }

3958                 }

3959 
<span class="line-modified">3960                 int d = mi2 - lo2 + mi1 - lo1;</span>
<span class="line-modified">3961 </span>
<span class="line-modified">3962                 /*</span>
<span class="line-modified">3963                  * Merge the right sub-parts in parallel.</span>
<span class="line-added">3964                  */</span>
<span class="line-added">3965                 merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);</span>
<span class="line-added">3966 </span>
<span class="line-added">3967                 /*</span>
<span class="line-added">3968                  * Process the sub-left parts.</span>
<span class="line-added">3969                  */</span>
<span class="line-added">3970                 hi1 = mi1;</span>
<span class="line-added">3971                 hi2 = mi2;</span>
3972             }

3973         }
3974 



3975         /*
<span class="line-modified">3976          * Merge small parts sequentially.</span>




3977          */
<span class="line-modified">3978         while (lo1 &lt; hi1 &amp;&amp; lo2 &lt; hi2) {</span>
<span class="line-modified">3979             dst[k++] = a1[lo1] &lt; a2[lo2] ? a1[lo1++] : a2[lo2++];</span>









3980         }
<span class="line-modified">3981         if (dst != a1 || k &lt; lo1) {</span>
<span class="line-modified">3982             while (lo1 &lt; hi1) {</span>
<span class="line-modified">3983                 dst[k++] = a1[lo1++];</span>
3984             }
3985         }
<span class="line-modified">3986         if (dst != a2 || k &lt; lo2) {</span>
<span class="line-modified">3987             while (lo2 &lt; hi2) {</span>
<span class="line-modified">3988                 dst[k++] = a2[lo2++];</span>


3989             }
3990         }
<span class="line-added">3991     }</span>
3992 
<span class="line-modified">3993 // [class]</span>




















3994 
<span class="line-modified">3995     /**</span>
<span class="line-modified">3996      * This class implements parallel sorting.</span>
<span class="line-modified">3997      */</span>
<span class="line-modified">3998     private static final class Sorter extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-modified">3999         private static final long serialVersionUID = 20180818L;</span>
<span class="line-added">4000         private final Object a, b;</span>
<span class="line-added">4001         private final int low, size, offset, depth;</span>
<span class="line-added">4002 </span>
<span class="line-added">4003         private Sorter(CountedCompleter&lt;?&gt; parent,</span>
<span class="line-added">4004                 Object a, Object b, int low, int size, int offset, int depth) {</span>
<span class="line-added">4005             super(parent);</span>
<span class="line-added">4006             this.a = a;</span>
<span class="line-added">4007             this.b = b;</span>
<span class="line-added">4008             this.low = low;</span>
<span class="line-added">4009             this.size = size;</span>
<span class="line-added">4010             this.offset = offset;</span>
<span class="line-added">4011             this.depth = depth;</span>
<span class="line-added">4012         }</span>
4013 
<span class="line-modified">4014         @Override</span>
<span class="line-modified">4015         public final void compute() {</span>
<span class="line-modified">4016             if (depth &lt; 0) {</span>
<span class="line-modified">4017                 setPendingCount(2);</span>
<span class="line-modified">4018                 int half = size &gt;&gt; 1;</span>
<span class="line-modified">4019                 new Sorter(this, b, a, low, half, offset, depth + 1).fork();</span>
<span class="line-modified">4020                 new Sorter(this, b, a, low + half, size - half, offset, depth + 1).compute();</span>
<span class="line-modified">4021             } else {</span>
<span class="line-modified">4022                 if (a instanceof int[]) {</span>
<span class="line-modified">4023                     sort(this, (int[]) a, depth, low, low + size);</span>
<span class="line-modified">4024                 } else if (a instanceof long[]) {</span>
<span class="line-modified">4025                     sort(this, (long[]) a, depth, low, low + size);</span>
<span class="line-modified">4026                 } else if (a instanceof float[]) {</span>
<span class="line-modified">4027                     sort(this, (float[]) a, depth, low, low + size);</span>
<span class="line-modified">4028                 } else if (a instanceof double[]) {</span>
<span class="line-modified">4029                     sort(this, (double[]) a, depth, low, low + size);</span>
<span class="line-modified">4030                 } else {</span>
<span class="line-modified">4031                     throw new IllegalArgumentException(</span>
<span class="line-modified">4032                         &quot;Unknown type of array: &quot; + a.getClass().getName());</span>






























4033                 }
4034             }
<span class="line-added">4035             tryComplete();</span>
<span class="line-added">4036         }</span>
4037 
<span class="line-modified">4038         @Override</span>
<span class="line-modified">4039         public final void onCompletion(CountedCompleter&lt;?&gt; caller) {</span>
<span class="line-modified">4040             if (depth &lt; 0) {</span>
<span class="line-modified">4041                 int mi = low + (size &gt;&gt; 1);</span>
<span class="line-modified">4042                 boolean src = (depth &amp; 1) == 0;</span>
<span class="line-modified">4043 </span>
<span class="line-modified">4044                 new Merger(null,</span>
<span class="line-added">4045                     a,</span>
<span class="line-added">4046                     src ? low : low - offset,</span>
<span class="line-added">4047                     b,</span>
<span class="line-added">4048                     src ? low - offset : low,</span>
<span class="line-added">4049                     src ? mi - offset : mi,</span>
<span class="line-added">4050                     b,</span>
<span class="line-added">4051                     src ? mi - offset : mi,</span>
<span class="line-added">4052                     src ? low + size - offset : low + size</span>
<span class="line-added">4053                 ).invoke();</span>
<span class="line-added">4054             }</span>
<span class="line-added">4055         }</span>
4056 
<span class="line-modified">4057         private void forkSorter(int depth, int low, int high) {</span>
<span class="line-modified">4058             addToPendingCount(1);</span>
<span class="line-modified">4059             Object a = this.a; // Use local variable for performance</span>
<span class="line-modified">4060             new Sorter(this, a, b, low, high - low, offset, depth).fork();</span>
<span class="line-modified">4061         }</span>
<span class="line-modified">4062     }</span>





4063 
<span class="line-modified">4064     /**</span>
<span class="line-modified">4065      * This class implements parallel merging.</span>
<span class="line-modified">4066      */</span>
<span class="line-added">4067     private static final class Merger extends CountedCompleter&lt;Void&gt; {</span>
<span class="line-added">4068         private static final long serialVersionUID = 20180818L;</span>
<span class="line-added">4069         private final Object dst, a1, a2;</span>
<span class="line-added">4070         private final int k, lo1, hi1, lo2, hi2;</span>
<span class="line-added">4071 </span>
<span class="line-added">4072         private Merger(CountedCompleter&lt;?&gt; parent, Object dst, int k,</span>
<span class="line-added">4073                 Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {</span>
<span class="line-added">4074             super(parent);</span>
<span class="line-added">4075             this.dst = dst;</span>
<span class="line-added">4076             this.k = k;</span>
<span class="line-added">4077             this.a1 = a1;</span>
<span class="line-added">4078             this.lo1 = lo1;</span>
<span class="line-added">4079             this.hi1 = hi1;</span>
<span class="line-added">4080             this.a2 = a2;</span>
<span class="line-added">4081             this.lo2 = lo2;</span>
<span class="line-added">4082             this.hi2 = hi2;</span>
<span class="line-added">4083         }</span>
4084 
<span class="line-modified">4085         @Override</span>
<span class="line-modified">4086         public final void compute() {</span>
<span class="line-modified">4087             if (dst instanceof int[]) {</span>
<span class="line-modified">4088                 mergeParts(this, (int[]) dst, k,</span>
<span class="line-modified">4089                     (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);</span>
<span class="line-modified">4090             } else if (dst instanceof long[]) {</span>
<span class="line-modified">4091                 mergeParts(this, (long[]) dst, k,</span>
<span class="line-modified">4092                     (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);</span>
<span class="line-modified">4093             } else if (dst instanceof float[]) {</span>
<span class="line-modified">4094                 mergeParts(this, (float[]) dst, k,</span>
<span class="line-modified">4095                     (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);</span>
<span class="line-modified">4096             } else if (dst instanceof double[]) {</span>
<span class="line-modified">4097                 mergeParts(this, (double[]) dst, k,</span>
<span class="line-modified">4098                     (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);</span>
<span class="line-modified">4099             } else {</span>
<span class="line-modified">4100                 throw new IllegalArgumentException(</span>
<span class="line-modified">4101                     &quot;Unknown type of array: &quot; + dst.getClass().getName());</span>


































4102             }
<span class="line-added">4103             propagateCompletion();</span>
<span class="line-added">4104         }</span>
4105 
<span class="line-modified">4106         private void forkMerger(Object dst, int k,</span>
<span class="line-modified">4107                 Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {</span>
<span class="line-added">4108             addToPendingCount(1);</span>
<span class="line-added">4109             new Merger(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();</span>
<span class="line-added">4110         }</span>
<span class="line-added">4111     }</span>
4112 
<span class="line-modified">4113     /**</span>
<span class="line-modified">4114      * This class implements parallel merging of runs.</span>
<span class="line-modified">4115      */</span>
<span class="line-modified">4116     private static final class RunMerger extends RecursiveTask&lt;Object&gt; {</span>
<span class="line-modified">4117         private static final long serialVersionUID = 20180818L;</span>
<span class="line-modified">4118         private final Object a, b;</span>
<span class="line-added">4119         private final int[] run;</span>
<span class="line-added">4120         private final int offset, aim, lo, hi;</span>
<span class="line-added">4121 </span>
<span class="line-added">4122         private RunMerger(Object a, Object b, int offset,</span>
<span class="line-added">4123                 int aim, int[] run, int lo, int hi) {</span>
<span class="line-added">4124             this.a = a;</span>
<span class="line-added">4125             this.b = b;</span>
<span class="line-added">4126             this.offset = offset;</span>
<span class="line-added">4127             this.aim = aim;</span>
<span class="line-added">4128             this.run = run;</span>
<span class="line-added">4129             this.lo = lo;</span>
<span class="line-added">4130             this.hi = hi;</span>
<span class="line-added">4131         }</span>
4132 
<span class="line-modified">4133         @Override</span>
<span class="line-modified">4134         protected final Object compute() {</span>
<span class="line-modified">4135             if (a instanceof int[]) {</span>
<span class="line-modified">4136                 return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);</span>















































4137             }
<span class="line-added">4138             if (a instanceof long[]) {</span>
<span class="line-added">4139                 return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);</span>
<span class="line-added">4140             }</span>
<span class="line-added">4141             if (a instanceof float[]) {</span>
<span class="line-added">4142                 return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);</span>
<span class="line-added">4143             }</span>
<span class="line-added">4144             if (a instanceof double[]) {</span>
<span class="line-added">4145                 return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);</span>
<span class="line-added">4146             }</span>
<span class="line-added">4147             throw new IllegalArgumentException(</span>
<span class="line-added">4148                 &quot;Unknown type of array: &quot; + a.getClass().getName());</span>
<span class="line-added">4149         }</span>
4150 
<span class="line-modified">4151         private RunMerger forkMe() {</span>
<span class="line-modified">4152             fork();</span>
<span class="line-modified">4153             return this;</span>
<span class="line-modified">4154         }</span>
<span class="line-modified">4155 </span>
<span class="line-modified">4156         private Object getDestination() {</span>
<span class="line-modified">4157             join();</span>
<span class="line-added">4158             return getRawResult();</span>
4159         }
4160     }
4161 }
</pre>
</td>
</tr>
</table>
<center><a href="DoubleSummaryStatistics.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DuplicateFormatFlagsException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
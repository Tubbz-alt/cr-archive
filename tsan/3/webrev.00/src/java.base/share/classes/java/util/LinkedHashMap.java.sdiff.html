<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/LinkedHashMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="JumboEnumSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedHashSet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/LinkedHashMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
179      * errors due to ambiguous usages. So, we keep the name to
180      * preserve unmodified compilability.
181      *
182      * The changes in node classes also require using two fields
183      * (head, tail) rather than a pointer to a header node to maintain
184      * the doubly-linked before/after list. This class also
185      * previously used a different style of callback methods upon
186      * access, insertion, and removal.
187      */
188 
189     /**
190      * HashMap.Node subclass for normal LinkedHashMap entries.
191      */
192     static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
193         Entry&lt;K,V&gt; before, after;
194         Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
195             super(hash, key, value, next);
196         }
197     }
198 

199     private static final long serialVersionUID = 3801124242820219131L;
200 
201     /**
202      * The head (eldest) of the doubly linked list.
203      */
204     transient LinkedHashMap.Entry&lt;K,V&gt; head;
205 
206     /**
207      * The tail (youngest) of the doubly linked list.
208      */
209     transient LinkedHashMap.Entry&lt;K,V&gt; tail;
210 
211     /**
212      * The iteration ordering method for this linked hash map: {@code true}
213      * for access-order, {@code false} for insertion-order.
214      *
215      * @serial
216      */
217     final boolean accessOrder;
218 
</pre>
<hr />
<pre>
519      * which removes the corresponding mapping from the map, via the
520      * {@code Iterator.remove}, {@code Set.remove},
521      * {@code removeAll}, {@code retainAll}, and {@code clear}
522      * operations.  It does not support the {@code add} or {@code addAll}
523      * operations.
524      * Its {@link Spliterator} typically provides faster sequential
525      * performance but much poorer parallel performance than that of
526      * {@code HashMap}.
527      *
528      * @return a set view of the keys contained in this map
529      */
530     public Set&lt;K&gt; keySet() {
531         Set&lt;K&gt; ks = keySet;
532         if (ks == null) {
533             ks = new LinkedKeySet();
534             keySet = ks;
535         }
536         return ks;
537     }
538 




















539     final class LinkedKeySet extends AbstractSet&lt;K&gt; {
540         public final int size()                 { return size; }
541         public final void clear()               { LinkedHashMap.this.clear(); }
542         public final Iterator&lt;K&gt; iterator() {
543             return new LinkedKeyIterator();
544         }
545         public final boolean contains(Object o) { return containsKey(o); }
546         public final boolean remove(Object key) {
547             return removeNode(hash(key), key, null, false, true) != null;
548         }
549         public final Spliterator&lt;K&gt; spliterator()  {
550             return Spliterators.spliterator(this, Spliterator.SIZED |
551                                             Spliterator.ORDERED |
552                                             Spliterator.DISTINCT);
553         }









554         public final void forEach(Consumer&lt;? super K&gt; action) {
555             if (action == null)
556                 throw new NullPointerException();
557             int mc = modCount;
558             for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)
559                 action.accept(e.key);
560             if (modCount != mc)
561                 throw new ConcurrentModificationException();
562         }
563     }
564 
565     /**
566      * Returns a {@link Collection} view of the values contained in this map.
567      * The collection is backed by the map, so changes to the map are
568      * reflected in the collection, and vice-versa.  If the map is
569      * modified while an iteration over the collection is in progress
570      * (except through the iterator&#39;s own {@code remove} operation),
571      * the results of the iteration are undefined.  The collection
572      * supports element removal, which removes the corresponding
573      * mapping from the map, via the {@code Iterator.remove},
</pre>
<hr />
<pre>
583     public Collection&lt;V&gt; values() {
584         Collection&lt;V&gt; vs = values;
585         if (vs == null) {
586             vs = new LinkedValues();
587             values = vs;
588         }
589         return vs;
590     }
591 
592     final class LinkedValues extends AbstractCollection&lt;V&gt; {
593         public final int size()                 { return size; }
594         public final void clear()               { LinkedHashMap.this.clear(); }
595         public final Iterator&lt;V&gt; iterator() {
596             return new LinkedValueIterator();
597         }
598         public final boolean contains(Object o) { return containsValue(o); }
599         public final Spliterator&lt;V&gt; spliterator() {
600             return Spliterators.spliterator(this, Spliterator.SIZED |
601                                             Spliterator.ORDERED);
602         }









603         public final void forEach(Consumer&lt;? super V&gt; action) {
604             if (action == null)
605                 throw new NullPointerException();
606             int mc = modCount;
607             for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)
608                 action.accept(e.value);
609             if (modCount != mc)
610                 throw new ConcurrentModificationException();
611         }
612     }
613 
614     /**
615      * Returns a {@link Set} view of the mappings contained in this map.
616      * The set is backed by the map, so changes to the map are
617      * reflected in the set, and vice-versa.  If the map is modified
618      * while an iteration over the set is in progress (except through
619      * the iterator&#39;s own {@code remove} operation, or through the
620      * {@code setValue} operation on a map entry returned by the
621      * iterator) the results of the iteration are undefined.  The set
622      * supports element removal, which removes the corresponding
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
179      * errors due to ambiguous usages. So, we keep the name to
180      * preserve unmodified compilability.
181      *
182      * The changes in node classes also require using two fields
183      * (head, tail) rather than a pointer to a header node to maintain
184      * the doubly-linked before/after list. This class also
185      * previously used a different style of callback methods upon
186      * access, insertion, and removal.
187      */
188 
189     /**
190      * HashMap.Node subclass for normal LinkedHashMap entries.
191      */
192     static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
193         Entry&lt;K,V&gt; before, after;
194         Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
195             super(hash, key, value, next);
196         }
197     }
198 
<span class="line-added">199     @java.io.Serial</span>
200     private static final long serialVersionUID = 3801124242820219131L;
201 
202     /**
203      * The head (eldest) of the doubly linked list.
204      */
205     transient LinkedHashMap.Entry&lt;K,V&gt; head;
206 
207     /**
208      * The tail (youngest) of the doubly linked list.
209      */
210     transient LinkedHashMap.Entry&lt;K,V&gt; tail;
211 
212     /**
213      * The iteration ordering method for this linked hash map: {@code true}
214      * for access-order, {@code false} for insertion-order.
215      *
216      * @serial
217      */
218     final boolean accessOrder;
219 
</pre>
<hr />
<pre>
520      * which removes the corresponding mapping from the map, via the
521      * {@code Iterator.remove}, {@code Set.remove},
522      * {@code removeAll}, {@code retainAll}, and {@code clear}
523      * operations.  It does not support the {@code add} or {@code addAll}
524      * operations.
525      * Its {@link Spliterator} typically provides faster sequential
526      * performance but much poorer parallel performance than that of
527      * {@code HashMap}.
528      *
529      * @return a set view of the keys contained in this map
530      */
531     public Set&lt;K&gt; keySet() {
532         Set&lt;K&gt; ks = keySet;
533         if (ks == null) {
534             ks = new LinkedKeySet();
535             keySet = ks;
536         }
537         return ks;
538     }
539 
<span class="line-added">540     @Override</span>
<span class="line-added">541     final &lt;T&gt; T[] keysToArray(T[] a) {</span>
<span class="line-added">542         Object[] r = a;</span>
<span class="line-added">543         int idx = 0;</span>
<span class="line-added">544         for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) {</span>
<span class="line-added">545             r[idx++] = e.key;</span>
<span class="line-added">546         }</span>
<span class="line-added">547         return a;</span>
<span class="line-added">548     }</span>
<span class="line-added">549 </span>
<span class="line-added">550     @Override</span>
<span class="line-added">551     final &lt;T&gt; T[] valuesToArray(T[] a) {</span>
<span class="line-added">552         Object[] r = a;</span>
<span class="line-added">553         int idx = 0;</span>
<span class="line-added">554         for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) {</span>
<span class="line-added">555             r[idx++] = e.value;</span>
<span class="line-added">556         }</span>
<span class="line-added">557         return a;</span>
<span class="line-added">558     }</span>
<span class="line-added">559 </span>
560     final class LinkedKeySet extends AbstractSet&lt;K&gt; {
561         public final int size()                 { return size; }
562         public final void clear()               { LinkedHashMap.this.clear(); }
563         public final Iterator&lt;K&gt; iterator() {
564             return new LinkedKeyIterator();
565         }
566         public final boolean contains(Object o) { return containsKey(o); }
567         public final boolean remove(Object key) {
568             return removeNode(hash(key), key, null, false, true) != null;
569         }
570         public final Spliterator&lt;K&gt; spliterator()  {
571             return Spliterators.spliterator(this, Spliterator.SIZED |
572                                             Spliterator.ORDERED |
573                                             Spliterator.DISTINCT);
574         }
<span class="line-added">575 </span>
<span class="line-added">576         public Object[] toArray() {</span>
<span class="line-added">577             return keysToArray(new Object[size]);</span>
<span class="line-added">578         }</span>
<span class="line-added">579 </span>
<span class="line-added">580         public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="line-added">581             return keysToArray(prepareArray(a));</span>
<span class="line-added">582         }</span>
<span class="line-added">583 </span>
584         public final void forEach(Consumer&lt;? super K&gt; action) {
585             if (action == null)
586                 throw new NullPointerException();
587             int mc = modCount;
588             for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)
589                 action.accept(e.key);
590             if (modCount != mc)
591                 throw new ConcurrentModificationException();
592         }
593     }
594 
595     /**
596      * Returns a {@link Collection} view of the values contained in this map.
597      * The collection is backed by the map, so changes to the map are
598      * reflected in the collection, and vice-versa.  If the map is
599      * modified while an iteration over the collection is in progress
600      * (except through the iterator&#39;s own {@code remove} operation),
601      * the results of the iteration are undefined.  The collection
602      * supports element removal, which removes the corresponding
603      * mapping from the map, via the {@code Iterator.remove},
</pre>
<hr />
<pre>
613     public Collection&lt;V&gt; values() {
614         Collection&lt;V&gt; vs = values;
615         if (vs == null) {
616             vs = new LinkedValues();
617             values = vs;
618         }
619         return vs;
620     }
621 
622     final class LinkedValues extends AbstractCollection&lt;V&gt; {
623         public final int size()                 { return size; }
624         public final void clear()               { LinkedHashMap.this.clear(); }
625         public final Iterator&lt;V&gt; iterator() {
626             return new LinkedValueIterator();
627         }
628         public final boolean contains(Object o) { return containsValue(o); }
629         public final Spliterator&lt;V&gt; spliterator() {
630             return Spliterators.spliterator(this, Spliterator.SIZED |
631                                             Spliterator.ORDERED);
632         }
<span class="line-added">633 </span>
<span class="line-added">634         public Object[] toArray() {</span>
<span class="line-added">635             return valuesToArray(new Object[size]);</span>
<span class="line-added">636         }</span>
<span class="line-added">637 </span>
<span class="line-added">638         public &lt;T&gt; T[] toArray(T[] a) {</span>
<span class="line-added">639             return valuesToArray(prepareArray(a));</span>
<span class="line-added">640         }</span>
<span class="line-added">641 </span>
642         public final void forEach(Consumer&lt;? super V&gt; action) {
643             if (action == null)
644                 throw new NullPointerException();
645             int mc = modCount;
646             for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after)
647                 action.accept(e.value);
648             if (modCount != mc)
649                 throw new ConcurrentModificationException();
650         }
651     }
652 
653     /**
654      * Returns a {@link Set} view of the mappings contained in this map.
655      * The set is backed by the map, so changes to the map are
656      * reflected in the set, and vice-versa.  If the map is modified
657      * while an iteration over the set is in progress (except through
658      * the iterator&#39;s own {@code remove} operation, or through the
659      * {@code setValue} operation on a map entry returned by the
660      * iterator) the results of the iteration are undefined.  The set
661      * supports element removal, which removes the corresponding
</pre>
</td>
</tr>
</table>
<center><a href="JumboEnumSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="LinkedHashSet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
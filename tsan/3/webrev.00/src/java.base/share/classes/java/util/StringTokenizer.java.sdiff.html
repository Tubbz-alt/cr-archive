<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/StringTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Stack.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TimeZone.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/StringTokenizer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 82  * The following example illustrates how the {@code String.split}
 83  * method can be used to break up a string into its basic tokens:
 84  * &lt;blockquote&gt;&lt;pre&gt;
 85  *     String[] result = &quot;this is a test&quot;.split(&quot;\\s&quot;);
 86  *     for (int x=0; x&amp;lt;result.length; x++)
 87  *         System.out.println(result[x]);
 88  * &lt;/pre&gt;&lt;/blockquote&gt;
 89  * &lt;p&gt;
 90  * prints the following output:
 91  * &lt;blockquote&gt;&lt;pre&gt;
 92  *     this
 93  *     is
 94  *     a
 95  *     test
 96  * &lt;/pre&gt;&lt;/blockquote&gt;
 97  *
 98  * @author  unascribed
 99  * @see     java.io.StreamTokenizer
100  * @since   1.0
101  */
<span class="line-modified">102 public</span>
<span class="line-removed">103 class StringTokenizer implements Enumeration&lt;Object&gt; {</span>
104     private int currentPosition;
105     private int newPosition;
106     private int maxPosition;
107     private String str;
108     private String delimiters;
109     private boolean retDelims;
110     private boolean delimsChanged;
111 
112     /**
113      * maxDelimCodePoint stores the value of the delimiter character with the
114      * highest value. It is used to optimize the detection of delimiter
115      * characters.
116      *
117      * It is unlikely to provide any optimization benefit in the
118      * hasSurrogates case because most string characters will be
119      * smaller than the limit, but we keep it so that the two code
120      * paths remain similar.
121      */
122     private int maxDelimCodePoint;
123 
</pre>
<hr />
<pre>
172     /**
173      * Constructs a string tokenizer for the specified string. All
174      * characters in the {@code delim} argument are the delimiters
175      * for separating tokens.
176      * &lt;p&gt;
177      * If the {@code returnDelims} flag is {@code true}, then
178      * the delimiter characters are also returned as tokens. Each
179      * delimiter is returned as a string of length one. If the flag is
180      * {@code false}, the delimiter characters are skipped and only
181      * serve as separators between tokens.
182      * &lt;p&gt;
183      * Note that if {@code delim} is {@code null}, this constructor does
184      * not throw an exception. However, trying to invoke other methods on the
185      * resulting {@code StringTokenizer} may result in a
186      * {@code NullPointerException}.
187      *
188      * @param   str            a string to be parsed.
189      * @param   delim          the delimiters.
190      * @param   returnDelims   flag indicating whether to return the delimiters
191      *                         as tokens.
<span class="line-modified">192      * @exception NullPointerException if str is {@code null}</span>
193      */
194     public StringTokenizer(String str, String delim, boolean returnDelims) {
195         currentPosition = 0;
196         newPosition = -1;
197         delimsChanged = false;
198         this.str = str;
199         maxPosition = str.length();
200         delimiters = delim;
201         retDelims = returnDelims;
202         setMaxDelimCodePoint();
203     }
204 
205     /**
206      * Constructs a string tokenizer for the specified string. The
207      * characters in the {@code delim} argument are the delimiters
208      * for separating tokens. Delimiter characters themselves will not
209      * be treated as tokens.
210      * &lt;p&gt;
211      * Note that if {@code delim} is {@code null}, this constructor does
212      * not throw an exception. However, trying to invoke other methods on the
213      * resulting {@code StringTokenizer} may result in a
214      * {@code NullPointerException}.
215      *
216      * @param   str     a string to be parsed.
217      * @param   delim   the delimiters.
<span class="line-modified">218      * @exception NullPointerException if str is {@code null}</span>
219      */
220     public StringTokenizer(String str, String delim) {
221         this(str, delim, false);
222     }
223 
224     /**
225      * Constructs a string tokenizer for the specified string. The
226      * tokenizer uses the default delimiter set, which is
227      * &lt;code&gt;&quot;&amp;nbsp;&amp;#92;t&amp;#92;n&amp;#92;r&amp;#92;f&quot;&lt;/code&gt;: the space character,
228      * the tab character, the newline character, the carriage-return character,
229      * and the form-feed character. Delimiter characters themselves will
230      * not be treated as tokens.
231      *
232      * @param   str   a string to be parsed.
<span class="line-modified">233      * @exception NullPointerException if str is {@code null}</span>
234      */
235     public StringTokenizer(String str) {
236         this(str, &quot; \t\n\r\f&quot;, false);
237     }
238 
239     /**
240      * Skips delimiters starting from the specified position. If retDelims
241      * is false, returns the index of the first non-delimiter character at or
242      * after startPos. If retDelims is true, startPos is returned.
243      */
244     private int skipDelimiters(int startPos) {
245         if (delimiters == null)
246             throw new NullPointerException();
247 
248         int position = startPos;
249         while (!retDelims &amp;&amp; position &lt; maxPosition) {
250             if (!hasSurrogates) {
251                 char c = str.charAt(position);
252                 if ((c &gt; maxDelimCodePoint) || (delimiters.indexOf(c) &lt; 0))
253                     break;
</pre>
<hr />
<pre>
311      * {@code nextToken} with no argument will successfully return a token.
312      *
313      * @return  {@code true} if and only if there is at least one token
314      *          in the string after the current position; {@code false}
315      *          otherwise.
316      */
317     public boolean hasMoreTokens() {
318         /*
319          * Temporarily store this position and use it in the following
320          * nextToken() method only if the delimiters haven&#39;t been changed in
321          * that nextToken() invocation.
322          */
323         newPosition = skipDelimiters(currentPosition);
324         return (newPosition &lt; maxPosition);
325     }
326 
327     /**
328      * Returns the next token from this string tokenizer.
329      *
330      * @return     the next token from this string tokenizer.
<span class="line-modified">331      * @exception  NoSuchElementException  if there are no more tokens in this</span>
332      *               tokenizer&#39;s string.
333      */
334     public String nextToken() {
335         /*
336          * If next position already computed in hasMoreElements() and
337          * delimiters have changed between the computation and this invocation,
338          * then use the computed value.
339          */
340 
341         currentPosition = (newPosition &gt;= 0 &amp;&amp; !delimsChanged) ?
342             newPosition : skipDelimiters(currentPosition);
343 
344         /* Reset these anyway */
345         delimsChanged = false;
346         newPosition = -1;
347 
348         if (currentPosition &gt;= maxPosition)
349             throw new NoSuchElementException();
350         int start = currentPosition;
351         currentPosition = scanToken(currentPosition);
352         return str.substring(start, currentPosition);
353     }
354 
355     /**
356      * Returns the next token in this string tokenizer&#39;s string. First,
357      * the set of characters considered to be delimiters by this
358      * {@code StringTokenizer} object is changed to be the characters in
359      * the string {@code delim}. Then the next token in the string
360      * after the current position is returned. The current position is
361      * advanced beyond the recognized token.  The new delimiter set
362      * remains the default after this call.
363      *
364      * @param      delim   the new delimiters.
365      * @return     the next token, after switching to the new delimiter set.
<span class="line-modified">366      * @exception  NoSuchElementException  if there are no more tokens in this</span>
367      *               tokenizer&#39;s string.
<span class="line-modified">368      * @exception NullPointerException if delim is {@code null}</span>
369      */
370     public String nextToken(String delim) {
371         delimiters = delim;
372 
373         /* delimiter string specified, so set the appropriate flag. */
374         delimsChanged = true;
375 
376         setMaxDelimCodePoint();
377         return nextToken();
378     }
379 
380     /**
381      * Returns the same value as the {@code hasMoreTokens}
382      * method. It exists so that this class can implement the
383      * {@code Enumeration} interface.
384      *
385      * @return  {@code true} if there are more tokens;
386      *          {@code false} otherwise.
387      * @see     java.util.Enumeration
388      * @see     java.util.StringTokenizer#hasMoreTokens()
389      */
390     public boolean hasMoreElements() {
391         return hasMoreTokens();
392     }
393 
394     /**
395      * Returns the same value as the {@code nextToken} method,
396      * except that its declared return value is {@code Object} rather than
397      * {@code String}. It exists so that this class can implement the
398      * {@code Enumeration} interface.
399      *
400      * @return     the next token in the string.
<span class="line-modified">401      * @exception  NoSuchElementException  if there are no more tokens in this</span>
402      *               tokenizer&#39;s string.
403      * @see        java.util.Enumeration
404      * @see        java.util.StringTokenizer#nextToken()
405      */
406     public Object nextElement() {
407         return nextToken();
408     }
409 
410     /**
411      * Calculates the number of times that this tokenizer&#39;s
412      * {@code nextToken} method can be called before it generates an
413      * exception. The current position is not advanced.
414      *
415      * @return  the number of tokens remaining in the string using the current
416      *          delimiter set.
417      * @see     java.util.StringTokenizer#nextToken()
418      */
419     public int countTokens() {
420         int count = 0;
421         int currpos = currentPosition;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 82  * The following example illustrates how the {@code String.split}
 83  * method can be used to break up a string into its basic tokens:
 84  * &lt;blockquote&gt;&lt;pre&gt;
 85  *     String[] result = &quot;this is a test&quot;.split(&quot;\\s&quot;);
 86  *     for (int x=0; x&amp;lt;result.length; x++)
 87  *         System.out.println(result[x]);
 88  * &lt;/pre&gt;&lt;/blockquote&gt;
 89  * &lt;p&gt;
 90  * prints the following output:
 91  * &lt;blockquote&gt;&lt;pre&gt;
 92  *     this
 93  *     is
 94  *     a
 95  *     test
 96  * &lt;/pre&gt;&lt;/blockquote&gt;
 97  *
 98  * @author  unascribed
 99  * @see     java.io.StreamTokenizer
100  * @since   1.0
101  */
<span class="line-modified">102 public class StringTokenizer implements Enumeration&lt;Object&gt; {</span>

103     private int currentPosition;
104     private int newPosition;
105     private int maxPosition;
106     private String str;
107     private String delimiters;
108     private boolean retDelims;
109     private boolean delimsChanged;
110 
111     /**
112      * maxDelimCodePoint stores the value of the delimiter character with the
113      * highest value. It is used to optimize the detection of delimiter
114      * characters.
115      *
116      * It is unlikely to provide any optimization benefit in the
117      * hasSurrogates case because most string characters will be
118      * smaller than the limit, but we keep it so that the two code
119      * paths remain similar.
120      */
121     private int maxDelimCodePoint;
122 
</pre>
<hr />
<pre>
171     /**
172      * Constructs a string tokenizer for the specified string. All
173      * characters in the {@code delim} argument are the delimiters
174      * for separating tokens.
175      * &lt;p&gt;
176      * If the {@code returnDelims} flag is {@code true}, then
177      * the delimiter characters are also returned as tokens. Each
178      * delimiter is returned as a string of length one. If the flag is
179      * {@code false}, the delimiter characters are skipped and only
180      * serve as separators between tokens.
181      * &lt;p&gt;
182      * Note that if {@code delim} is {@code null}, this constructor does
183      * not throw an exception. However, trying to invoke other methods on the
184      * resulting {@code StringTokenizer} may result in a
185      * {@code NullPointerException}.
186      *
187      * @param   str            a string to be parsed.
188      * @param   delim          the delimiters.
189      * @param   returnDelims   flag indicating whether to return the delimiters
190      *                         as tokens.
<span class="line-modified">191      * @throws    NullPointerException if str is {@code null}</span>
192      */
193     public StringTokenizer(String str, String delim, boolean returnDelims) {
194         currentPosition = 0;
195         newPosition = -1;
196         delimsChanged = false;
197         this.str = str;
198         maxPosition = str.length();
199         delimiters = delim;
200         retDelims = returnDelims;
201         setMaxDelimCodePoint();
202     }
203 
204     /**
205      * Constructs a string tokenizer for the specified string. The
206      * characters in the {@code delim} argument are the delimiters
207      * for separating tokens. Delimiter characters themselves will not
208      * be treated as tokens.
209      * &lt;p&gt;
210      * Note that if {@code delim} is {@code null}, this constructor does
211      * not throw an exception. However, trying to invoke other methods on the
212      * resulting {@code StringTokenizer} may result in a
213      * {@code NullPointerException}.
214      *
215      * @param   str     a string to be parsed.
216      * @param   delim   the delimiters.
<span class="line-modified">217      * @throws    NullPointerException if str is {@code null}</span>
218      */
219     public StringTokenizer(String str, String delim) {
220         this(str, delim, false);
221     }
222 
223     /**
224      * Constructs a string tokenizer for the specified string. The
225      * tokenizer uses the default delimiter set, which is
226      * &lt;code&gt;&quot;&amp;nbsp;&amp;#92;t&amp;#92;n&amp;#92;r&amp;#92;f&quot;&lt;/code&gt;: the space character,
227      * the tab character, the newline character, the carriage-return character,
228      * and the form-feed character. Delimiter characters themselves will
229      * not be treated as tokens.
230      *
231      * @param   str   a string to be parsed.
<span class="line-modified">232      * @throws    NullPointerException if str is {@code null}</span>
233      */
234     public StringTokenizer(String str) {
235         this(str, &quot; \t\n\r\f&quot;, false);
236     }
237 
238     /**
239      * Skips delimiters starting from the specified position. If retDelims
240      * is false, returns the index of the first non-delimiter character at or
241      * after startPos. If retDelims is true, startPos is returned.
242      */
243     private int skipDelimiters(int startPos) {
244         if (delimiters == null)
245             throw new NullPointerException();
246 
247         int position = startPos;
248         while (!retDelims &amp;&amp; position &lt; maxPosition) {
249             if (!hasSurrogates) {
250                 char c = str.charAt(position);
251                 if ((c &gt; maxDelimCodePoint) || (delimiters.indexOf(c) &lt; 0))
252                     break;
</pre>
<hr />
<pre>
310      * {@code nextToken} with no argument will successfully return a token.
311      *
312      * @return  {@code true} if and only if there is at least one token
313      *          in the string after the current position; {@code false}
314      *          otherwise.
315      */
316     public boolean hasMoreTokens() {
317         /*
318          * Temporarily store this position and use it in the following
319          * nextToken() method only if the delimiters haven&#39;t been changed in
320          * that nextToken() invocation.
321          */
322         newPosition = skipDelimiters(currentPosition);
323         return (newPosition &lt; maxPosition);
324     }
325 
326     /**
327      * Returns the next token from this string tokenizer.
328      *
329      * @return     the next token from this string tokenizer.
<span class="line-modified">330      * @throws     NoSuchElementException  if there are no more tokens in this</span>
331      *               tokenizer&#39;s string.
332      */
333     public String nextToken() {
334         /*
335          * If next position already computed in hasMoreElements() and
336          * delimiters have changed between the computation and this invocation,
337          * then use the computed value.
338          */
339 
340         currentPosition = (newPosition &gt;= 0 &amp;&amp; !delimsChanged) ?
341             newPosition : skipDelimiters(currentPosition);
342 
343         /* Reset these anyway */
344         delimsChanged = false;
345         newPosition = -1;
346 
347         if (currentPosition &gt;= maxPosition)
348             throw new NoSuchElementException();
349         int start = currentPosition;
350         currentPosition = scanToken(currentPosition);
351         return str.substring(start, currentPosition);
352     }
353 
354     /**
355      * Returns the next token in this string tokenizer&#39;s string. First,
356      * the set of characters considered to be delimiters by this
357      * {@code StringTokenizer} object is changed to be the characters in
358      * the string {@code delim}. Then the next token in the string
359      * after the current position is returned. The current position is
360      * advanced beyond the recognized token.  The new delimiter set
361      * remains the default after this call.
362      *
363      * @param      delim   the new delimiters.
364      * @return     the next token, after switching to the new delimiter set.
<span class="line-modified">365      * @throws     NoSuchElementException  if there are no more tokens in this</span>
366      *               tokenizer&#39;s string.
<span class="line-modified">367      * @throws    NullPointerException if delim is {@code null}</span>
368      */
369     public String nextToken(String delim) {
370         delimiters = delim;
371 
372         /* delimiter string specified, so set the appropriate flag. */
373         delimsChanged = true;
374 
375         setMaxDelimCodePoint();
376         return nextToken();
377     }
378 
379     /**
380      * Returns the same value as the {@code hasMoreTokens}
381      * method. It exists so that this class can implement the
382      * {@code Enumeration} interface.
383      *
384      * @return  {@code true} if there are more tokens;
385      *          {@code false} otherwise.
386      * @see     java.util.Enumeration
387      * @see     java.util.StringTokenizer#hasMoreTokens()
388      */
389     public boolean hasMoreElements() {
390         return hasMoreTokens();
391     }
392 
393     /**
394      * Returns the same value as the {@code nextToken} method,
395      * except that its declared return value is {@code Object} rather than
396      * {@code String}. It exists so that this class can implement the
397      * {@code Enumeration} interface.
398      *
399      * @return     the next token in the string.
<span class="line-modified">400      * @throws     NoSuchElementException  if there are no more tokens in this</span>
401      *               tokenizer&#39;s string.
402      * @see        java.util.Enumeration
403      * @see        java.util.StringTokenizer#nextToken()
404      */
405     public Object nextElement() {
406         return nextToken();
407     }
408 
409     /**
410      * Calculates the number of times that this tokenizer&#39;s
411      * {@code nextToken} method can be called before it generates an
412      * exception. The current position is not advanced.
413      *
414      * @return  the number of tokens remaining in the string using the current
415      *          delimiter set.
416      * @see     java.util.StringTokenizer#nextToken()
417      */
418     public int countTokens() {
419         int count = 0;
420         int currpos = currentPosition;
</pre>
</td>
</tr>
</table>
<center><a href="Stack.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TimeZone.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
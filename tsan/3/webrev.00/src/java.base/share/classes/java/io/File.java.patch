diff a/src/java.base/share/classes/java/io/File.java b/src/java.base/share/classes/java/io/File.java
--- a/src/java.base/share/classes/java/io/File.java
+++ b/src/java.base/share/classes/java/io/File.java
@@ -27,10 +27,11 @@
 
 import java.net.URI;
 import java.net.URL;
 import java.net.MalformedURLException;
 import java.net.URISyntaxException;
+import java.nio.file.FileStore;
 import java.nio.file.FileSystems;
 import java.nio.file.Path;
 import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.List;
@@ -44,12 +45,12 @@
  * abstract, system-independent view of hierarchical pathnames.  An
  * <em>abstract pathname</em> has two components:
  *
  * <ol>
  * <li> An optional system-dependent <em>prefix</em> string,
- *      such as a disk-drive specifier, <code>"/"</code>&nbsp;for the UNIX root
- *      directory, or <code>"\\\\"</code>&nbsp;for a Microsoft Windows UNC pathname, and
+ *      such as a disk-drive specifier, {@code "/"}&nbsp;for the UNIX root
+ *      directory, or {@code "\\\\"}&nbsp;for a Microsoft Windows UNC pathname, and
  * <li> A sequence of zero or more string <em>names</em>.
  * </ol>
  *
  * The first name in an abstract pathname may be a directory name or, in the
  * case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name
@@ -59,11 +60,11 @@
  *
  * <p> The conversion of a pathname string to or from an abstract pathname is
  * inherently system-dependent.  When an abstract pathname is converted into a
  * pathname string, each name is separated from the next by a single copy of
  * the default <em>separator character</em>.  The default name-separator
- * character is defined by the system property <code>file.separator</code>, and
+ * character is defined by the system property {@code file.separator}, and
  * is made available in the public static fields {@link
  * #separator} and {@link #separatorChar} of this class.
  * When a pathname string is converted into an abstract pathname, the names
  * within it may be separated by the default name-separator character or by any
  * other name-separator character that is supported by the underlying system.
@@ -71,13 +72,13 @@
  * <p> A pathname, whether abstract or in string form, may be either
  * <em>absolute</em> or <em>relative</em>.  An absolute pathname is complete in
  * that no other information is required in order to locate the file that it
  * denotes.  A relative pathname, in contrast, must be interpreted in terms of
  * information taken from some other pathname.  By default the classes in the
- * <code>java.io</code> package always resolve relative pathnames against the
+ * {@code java.io} package always resolve relative pathnames against the
  * current user directory.  This directory is named by the system property
- * <code>user.dir</code>, and is typically the directory in which the Java
+ * {@code user.dir}, and is typically the directory in which the Java
  * virtual machine was invoked.
  *
  * <p> The <em>parent</em> of an abstract pathname may be obtained by invoking
  * the {@link #getParent} method of this class and consists of the pathname's
  * prefix and each name in the pathname's name sequence except for the last.
@@ -92,18 +93,18 @@
  * as follows:
  *
  * <ul>
  *
  * <li> For UNIX platforms, the prefix of an absolute pathname is always
- * <code>"/"</code>.  Relative pathnames have no prefix.  The abstract pathname
- * denoting the root directory has the prefix <code>"/"</code> and an empty
+ * {@code "/"}.  Relative pathnames have no prefix.  The abstract pathname
+ * denoting the root directory has the prefix {@code "/"} and an empty
  * name sequence.
  *
  * <li> For Microsoft Windows platforms, the prefix of a pathname that contains a drive
- * specifier consists of the drive letter followed by <code>":"</code> and
- * possibly followed by <code>"\\"</code> if the pathname is absolute.  The
- * prefix of a UNC pathname is <code>"\\\\"</code>; the hostname and the share
+ * specifier consists of the drive letter followed by {@code ":"} and
+ * possibly followed by {@code "\\"} if the pathname is absolute.  The
+ * prefix of a UNC pathname is {@code "\\\\"}; the hostname and the share
  * name are the first two names in the name sequence.  A relative pathname that
  * does not specify a drive has no prefix.
  *
  * </ul>
  *
@@ -122,15 +123,15 @@
  * system may have multiple sets of access permissions on a single object.
  * For example, one set may apply to the object's <i>owner</i>, and another
  * may apply to all other users.  The access permissions on an object may
  * cause some methods in this class to fail.
  *
- * <p> Instances of the <code>File</code> class are immutable; that is, once
- * created, the abstract pathname represented by a <code>File</code> object
+ * <p> Instances of the {@code File} class are immutable; that is, once
+ * created, the abstract pathname represented by a {@code File} object
  * will never change.
  *
- * <h3>Interoperability with {@code java.nio.file} package</h3>
+ * <h2>Interoperability with {@code java.nio.file} package</h2>
  *
  * <p> The <a href="../../java/nio/file/package-summary.html">{@code java.nio.file}</a>
  * package defines interfaces and classes for the Java virtual machine to access
  * files, file attributes, and file systems. This API may be used to overcome
  * many of the limitations of the {@code java.io.File} class.
@@ -180,15 +181,17 @@
      * returning false does not guarantee that the path is valid.
      *
      * @return true if the file path is invalid.
      */
     final boolean isInvalid() {
-        if (status == null) {
-            status = (this.path.indexOf('\u0000') < 0) ? PathStatus.CHECKED
-                                                       : PathStatus.INVALID;
+        PathStatus s = status;
+        if (s == null) {
+            s = (this.path.indexOf('\u0000') < 0) ? PathStatus.CHECKED
+                                                  : PathStatus.INVALID;
+            status = s;
         }
-        return status == PathStatus.INVALID;
+        return s == PathStatus.INVALID;
     }
 
     /**
      * The length of this abstract pathname's prefix, or zero if it has no
      * prefix.
@@ -204,12 +207,12 @@
     }
 
     /**
      * The system-dependent default name-separator character.  This field is
      * initialized to contain the first character of the value of the system
-     * property <code>file.separator</code>.  On UNIX systems the value of this
-     * field is <code>'/'</code>; on Microsoft Windows systems it is <code>'\\'</code>.
+     * property {@code file.separator}.  On UNIX systems the value of this
+     * field is {@code '/'}; on Microsoft Windows systems it is {@code '\\'}.
      *
      * @see     java.lang.System#getProperty(java.lang.String)
      */
     public static final char separatorChar = fs.getSeparator();
 
@@ -221,14 +224,14 @@
     public static final String separator = "" + separatorChar;
 
     /**
      * The system-dependent path-separator character.  This field is
      * initialized to contain the first character of the value of the system
-     * property <code>path.separator</code>.  This character is used to
+     * property {@code path.separator}.  This character is used to
      * separate filenames in a sequence of files given as a <em>path list</em>.
-     * On UNIX systems, this character is <code>':'</code>; on Microsoft Windows systems it
-     * is <code>';'</code>.
+     * On UNIX systems, this character is {@code ':'}; on Microsoft Windows systems it
+     * is {@code ';'}.
      *
      * @see     java.lang.System#getProperty(java.lang.String)
      */
     public static final char pathSeparatorChar = fs.getPathSeparator();
 
@@ -261,17 +264,17 @@
         this.path = fs.resolve(parent.path, child);
         this.prefixLength = parent.prefixLength;
     }
 
     /**
-     * Creates a new <code>File</code> instance by converting the given
+     * Creates a new {@code File} instance by converting the given
      * pathname string into an abstract pathname.  If the given string is
      * the empty string, then the result is the empty abstract pathname.
      *
      * @param   pathname  A pathname string
      * @throws  NullPointerException
-     *          If the <code>pathname</code> argument is <code>null</code>
+     *          If the {@code pathname} argument is {@code null}
      */
     public File(String pathname) {
         if (pathname == null) {
             throw new NullPointerException();
         }
@@ -285,33 +288,33 @@
        directory defined by the FileSystem.getDefaultParent method.  On Unix
        this default is "/", while on Microsoft Windows it is "\\".  This is required for
        compatibility with the original behavior of this class. */
 
     /**
-     * Creates a new <code>File</code> instance from a parent pathname string
+     * Creates a new {@code File} instance from a parent pathname string
      * and a child pathname string.
      *
-     * <p> If <code>parent</code> is <code>null</code> then the new
-     * <code>File</code> instance is created as if by invoking the
-     * single-argument <code>File</code> constructor on the given
-     * <code>child</code> pathname string.
+     * <p> If {@code parent} is {@code null} then the new
+     * {@code File} instance is created as if by invoking the
+     * single-argument {@code File} constructor on the given
+     * {@code child} pathname string.
      *
-     * <p> Otherwise the <code>parent</code> pathname string is taken to denote
-     * a directory, and the <code>child</code> pathname string is taken to
-     * denote either a directory or a file.  If the <code>child</code> pathname
+     * <p> Otherwise the {@code parent} pathname string is taken to denote
+     * a directory, and the {@code child} pathname string is taken to
+     * denote either a directory or a file.  If the {@code child} pathname
      * string is absolute then it is converted into a relative pathname in a
-     * system-dependent way.  If <code>parent</code> is the empty string then
-     * the new <code>File</code> instance is created by converting
-     * <code>child</code> into an abstract pathname and resolving the result
+     * system-dependent way.  If {@code parent} is the empty string then
+     * the new {@code File} instance is created by converting
+     * {@code child} into an abstract pathname and resolving the result
      * against a system-dependent default directory.  Otherwise each pathname
      * string is converted into an abstract pathname and the child abstract
      * pathname is resolved against the parent.
      *
      * @param   parent  The parent pathname string
      * @param   child   The child pathname string
      * @throws  NullPointerException
-     *          If <code>child</code> is <code>null</code>
+     *          If {@code child} is {@code null}
      */
     public File(String parent, String child) {
         if (child == null) {
             throw new NullPointerException();
         }
@@ -328,33 +331,33 @@
         }
         this.prefixLength = fs.prefixLength(this.path);
     }
 
     /**
-     * Creates a new <code>File</code> instance from a parent abstract
+     * Creates a new {@code File} instance from a parent abstract
      * pathname and a child pathname string.
      *
-     * <p> If <code>parent</code> is <code>null</code> then the new
-     * <code>File</code> instance is created as if by invoking the
-     * single-argument <code>File</code> constructor on the given
-     * <code>child</code> pathname string.
+     * <p> If {@code parent} is {@code null} then the new
+     * {@code File} instance is created as if by invoking the
+     * single-argument {@code File} constructor on the given
+     * {@code child} pathname string.
      *
-     * <p> Otherwise the <code>parent</code> abstract pathname is taken to
-     * denote a directory, and the <code>child</code> pathname string is taken
-     * to denote either a directory or a file.  If the <code>child</code>
+     * <p> Otherwise the {@code parent} abstract pathname is taken to
+     * denote a directory, and the {@code child} pathname string is taken
+     * to denote either a directory or a file.  If the {@code child}
      * pathname string is absolute then it is converted into a relative
-     * pathname in a system-dependent way.  If <code>parent</code> is the empty
-     * abstract pathname then the new <code>File</code> instance is created by
-     * converting <code>child</code> into an abstract pathname and resolving
+     * pathname in a system-dependent way.  If {@code parent} is the empty
+     * abstract pathname then the new {@code File} instance is created by
+     * converting {@code child} into an abstract pathname and resolving
      * the result against a system-dependent default directory.  Otherwise each
      * pathname string is converted into an abstract pathname and the child
      * abstract pathname is resolved against the parent.
      *
      * @param   parent  The parent abstract pathname
      * @param   child   The child pathname string
      * @throws  NullPointerException
-     *          If <code>child</code> is <code>null</code>
+     *          If {@code child} is {@code null}
      */
     public File(File parent, String child) {
         if (child == null) {
             throw new NullPointerException();
         }
@@ -456,19 +459,19 @@
         return path.substring(index + 1);
     }
 
     /**
      * Returns the pathname string of this abstract pathname's parent, or
-     * <code>null</code> if this pathname does not name a parent directory.
+     * {@code null} if this pathname does not name a parent directory.
      *
      * <p> The <em>parent</em> of an abstract pathname consists of the
      * pathname's prefix, if any, and each name in the pathname's name
      * sequence except for the last.  If the name sequence is empty then
      * the pathname does not name a parent directory.
      *
      * @return  The pathname string of the parent directory named by this
-     *          abstract pathname, or <code>null</code> if this pathname
+     *          abstract pathname, or {@code null} if this pathname
      *          does not name a parent
      */
     public String getParent() {
         int index = path.lastIndexOf(separatorChar);
         if (index < prefixLength) {
@@ -479,20 +482,20 @@
         return path.substring(0, index);
     }
 
     /**
      * Returns the abstract pathname of this abstract pathname's parent,
-     * or <code>null</code> if this pathname does not name a parent
+     * or {@code null} if this pathname does not name a parent
      * directory.
      *
      * <p> The <em>parent</em> of an abstract pathname consists of the
      * pathname's prefix, if any, and each name in the pathname's name
      * sequence except for the last.  If the name sequence is empty then
      * the pathname does not name a parent directory.
      *
      * @return  The abstract pathname of the parent directory named by this
-     *          abstract pathname, or <code>null</code> if this pathname
+     *          abstract pathname, or {@code null} if this pathname
      *          does not name a parent
      *
      * @since 1.2
      */
     public File getParentFile() {
@@ -516,16 +519,16 @@
     /* -- Path operations -- */
 
     /**
      * Tests whether this abstract pathname is absolute.  The definition of
      * absolute pathname is system dependent.  On UNIX systems, a pathname is
-     * absolute if its prefix is <code>"/"</code>.  On Microsoft Windows systems, a
+     * absolute if its prefix is {@code "/"}.  On Microsoft Windows systems, a
      * pathname is absolute if its prefix is a drive specifier followed by
-     * <code>"\\"</code>, or if its prefix is <code>"\\\\"</code>.
+     * {@code "\\"}, or if its prefix is {@code "\\\\"}.
      *
-     * @return  <code>true</code> if this abstract pathname is absolute,
-     *          <code>false</code> otherwise
+     * @return  {@code true} if this abstract pathname is absolute,
+     *          {@code false} otherwise
      */
     public boolean isAbsolute() {
         return fs.isAbsolute(this);
     }
 
@@ -534,11 +537,11 @@
      *
      * <p> If this abstract pathname is already absolute, then the pathname
      * string is simply returned as if by the {@link #getPath}
      * method.  If this abstract pathname is the empty abstract pathname then
      * the pathname string of the current user directory, which is named by the
-     * system property <code>user.dir</code>, is returned.  Otherwise this
+     * system property {@code user.dir}, is returned.  Otherwise this
      * pathname is resolved in a system-dependent way.  On UNIX systems, a
      * relative pathname is made absolute by resolving it against the current
      * user directory.  On Microsoft Windows systems, a relative pathname is made absolute
      * by resolving it against the current directory of the drive named by the
      * pathname, if any; if not, it is resolved against the current user
@@ -654,11 +657,11 @@
             p = p + "/";
         return p;
     }
 
     /**
-     * Converts this abstract pathname into a <code>file:</code> URL.  The
+     * Converts this abstract pathname into a {@code file:} URL.  The
      * exact form of the URL is system-dependent.  If it can be determined that
      * the file denoted by this abstract pathname is a directory, then the
      * resulting URL will end with a slash.
      *
      * @return  A URL object representing the equivalent file URL
@@ -747,13 +750,13 @@
      * abstract pathname. On some platforms it may be possible to start the
      * Java virtual machine with special privileges that allow it to read
      * files that are marked as unreadable. Consequently this method may return
      * {@code true} even though the file does not have read permissions.
      *
-     * @return  <code>true</code> if and only if the file specified by this
+     * @return  {@code true} if and only if the file specified by this
      *          abstract pathname exists <em>and</em> can be read by the
-     *          application; <code>false</code> otherwise
+     *          application; {@code false} otherwise
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkRead(java.lang.String)}
      *          method denies read access to the file
@@ -774,14 +777,14 @@
      * abstract pathname. On some platforms it may be possible to start the
      * Java virtual machine with special privileges that allow it to modify
      * files that are marked read-only. Consequently this method may return
      * {@code true} even though the file is marked read-only.
      *
-     * @return  <code>true</code> if and only if the file system actually
+     * @return  {@code true} if and only if the file system actually
      *          contains a file denoted by this abstract pathname <em>and</em>
      *          the application is allowed to write to the file;
-     *          <code>false</code> otherwise.
+     *          {@code false} otherwise.
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
      *          method denies write access to the file
@@ -799,12 +802,12 @@
 
     /**
      * Tests whether the file or directory denoted by this abstract pathname
      * exists.
      *
-     * @return  <code>true</code> if and only if the file or directory denoted
-     *          by this abstract pathname exists; <code>false</code> otherwise
+     * @return  {@code true} if and only if the file or directory denoted
+     *          by this abstract pathname exists; {@code false} otherwise
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkRead(java.lang.String)}
      *          method denies read access to the file or directory
@@ -828,13 +831,13 @@
      * that the file is not a directory, or where several attributes of the
      * same file are required at the same time, then the {@link
      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
      * Files.readAttributes} method may be used.
      *
-     * @return <code>true</code> if and only if the file denoted by this
+     * @return {@code true} if and only if the file denoted by this
      *          abstract pathname exists <em>and</em> is a directory;
-     *          <code>false</code> otherwise
+     *          {@code false} otherwise
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkRead(java.lang.String)}
      *          method denies read access to the file
@@ -861,13 +864,13 @@
      * that the file is not a normal file, or where several attributes of the
      * same file are required at the same time, then the {@link
      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
      * Files.readAttributes} method may be used.
      *
-     * @return  <code>true</code> if and only if the file denoted by this
+     * @return  {@code true} if and only if the file denoted by this
      *          abstract pathname exists <em>and</em> is a normal file;
-     *          <code>false</code> otherwise
+     *          {@code false} otherwise
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkRead(java.lang.String)}
      *          method denies read access to the file
@@ -885,14 +888,14 @@
 
     /**
      * Tests whether the file named by this abstract pathname is a hidden
      * file.  The exact definition of <em>hidden</em> is system-dependent.  On
      * UNIX systems, a file is considered to be hidden if its name begins with
-     * a period character (<code>'.'</code>).  On Microsoft Windows systems, a file is
+     * a period character ({@code '.'}).  On Microsoft Windows systems, a file is
      * considered to be hidden if it has been marked as such in the filesystem.
      *
-     * @return  <code>true</code> if and only if the file denoted by this
+     * @return  {@code true} if and only if the file denoted by this
      *          abstract pathname is hidden according to the conventions of the
      *          underlying platform
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
@@ -930,13 +933,13 @@
      * Files.readAttributes} method may be used.  If however only the
      * time of last modification is required, then the
      * {@link java.nio.file.Files#getLastModifiedTime(Path,LinkOption[])
      * Files.getLastModifiedTime} method may be used instead.
      *
-     * @return  A <code>long</code> value representing the time the file was
+     * @return  A {@code long} value representing the time the file was
      *          last modified, measured in milliseconds since the epoch
-     *          (00:00:00 GMT, January 1, 1970), or <code>0L</code> if the
+     *          (00:00:00 GMT, January 1, 1970), or {@code 0L} if the
      *          file does not exist or if an I/O error occurs.  The value may
      *          be negative indicating the number of milliseconds before the
      *          epoch
      *
      * @throws  SecurityException
@@ -964,12 +967,12 @@
      * are required at the same time, then the {@link
      * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])
      * Files.readAttributes} method may be used.
      *
      * @return  The length, in bytes, of the file denoted by this abstract
-     *          pathname, or <code>0L</code> if the file does not exist.  Some
-     *          operating systems may return <code>0L</code> for pathnames
+     *          pathname, or {@code 0L} if the file does not exist.  Some
+     *          operating systems may return {@code 0L} for pathnames
      *          denoting system-dependent entities such as devices or pipes.
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkRead(java.lang.String)}
@@ -999,12 +1002,12 @@
      * Note: this method should <i>not</i> be used for file-locking, as
      * the resulting protocol cannot be made to work reliably. The
      * {@link java.nio.channels.FileLock FileLock}
      * facility should be used instead.
      *
-     * @return  <code>true</code> if the named file does not exist and was
-     *          successfully created; <code>false</code> if the named file
+     * @return  {@code true} if the named file does not exist and was
+     *          successfully created; {@code false} if the named file
      *          already exists
      *
      * @throws  IOException
      *          If an I/O error occurred
      *
@@ -1032,12 +1035,12 @@
      * <p> Note that the {@link java.nio.file.Files} class defines the {@link
      * java.nio.file.Files#delete(Path) delete} method to throw an {@link IOException}
      * when a file cannot be deleted. This is useful for error reporting and to
      * diagnose why a file cannot be deleted.
      *
-     * @return  <code>true</code> if and only if the file or directory is
-     *          successfully deleted; <code>false</code> otherwise
+     * @return  {@code true} if and only if the file or directory is
+     *          successfully deleted; {@code false} otherwise
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkDelete} method denies
      *          delete access to the file
@@ -1307,12 +1310,12 @@
     }
 
     /**
      * Creates the directory named by this abstract pathname.
      *
-     * @return  <code>true</code> if and only if the directory was
-     *          created; <code>false</code> otherwise
+     * @return  {@code true} if and only if the directory was
+     *          created; {@code false} otherwise
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
      *          method does not permit the named directory to be created
@@ -1332,12 +1335,12 @@
      * Creates the directory named by this abstract pathname, including any
      * necessary but nonexistent parent directories.  Note that if this
      * operation fails it may have succeeded in creating some of the necessary
      * parent directories.
      *
-     * @return  <code>true</code> if and only if the directory was created,
-     *          along with all necessary parent directories; <code>false</code>
+     * @return  {@code true} if and only if the directory was created,
+     *          along with all necessary parent directories; {@code false}
      *          otherwise
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkRead(java.lang.String)}
@@ -1381,20 +1384,20 @@
      * java.nio.file.Files#move move} method to move or rename a file in a
      * platform independent manner.
      *
      * @param  dest  The new abstract pathname for the named file
      *
-     * @return  <code>true</code> if and only if the renaming succeeded;
-     *          <code>false</code> otherwise
+     * @return  {@code true} if and only if the renaming succeeded;
+     *          {@code false} otherwise
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
      *          method denies write access to either the old or new pathnames
      *
      * @throws  NullPointerException
-     *          If parameter <code>dest</code> is <code>null</code>
+     *          If parameter {@code dest} is {@code null}
      */
     public boolean renameTo(File dest) {
         if (dest == null) {
             throw new NullPointerException();
         }
@@ -1416,17 +1419,17 @@
      * <p> All platforms support file-modification times to the nearest second,
      * but some provide more precision.  The argument will be truncated to fit
      * the supported precision.  If the operation succeeds and no intervening
      * operations on the file take place, then the next invocation of the
      * {@link #lastModified} method will return the (possibly
-     * truncated) <code>time</code> argument that was passed to this method.
+     * truncated) {@code time} argument that was passed to this method.
      *
      * @param  time  The new last-modified time, measured in milliseconds since
      *               the epoch (00:00:00 GMT, January 1, 1970)
      *
-     * @return <code>true</code> if and only if the operation succeeded;
-     *          <code>false</code> otherwise
+     * @return {@code true} if and only if the operation succeeded;
+     *          {@code false} otherwise
      *
      * @throws  IllegalArgumentException  If the argument is negative
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
@@ -1454,12 +1457,12 @@
      * to allow write access. On some platforms it may be possible to start the
      * Java virtual machine with special privileges that allow it to modify
      * files that are marked read-only. Whether or not a read-only file or
      * directory may be deleted depends upon the underlying system.
      *
-     * @return <code>true</code> if and only if the operation succeeded;
-     *          <code>false</code> otherwise
+     * @return {@code true} if and only if the operation succeeded;
+     *          {@code false} otherwise
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkWrite(java.lang.String)}
      *          method denies write access to the named file
@@ -1486,21 +1489,21 @@
      * <p> The {@link java.nio.file.Files} class defines methods that operate on
      * file attributes including file permissions. This may be used when finer
      * manipulation of file permissions is required.
      *
      * @param   writable
-     *          If <code>true</code>, sets the access permission to allow write
-     *          operations; if <code>false</code> to disallow write operations
+     *          If {@code true}, sets the access permission to allow write
+     *          operations; if {@code false} to disallow write operations
      *
      * @param   ownerOnly
-     *          If <code>true</code>, the write permission applies only to the
+     *          If {@code true}, the write permission applies only to the
      *          owner's write permission; otherwise, it applies to everybody.  If
      *          the underlying file system can not distinguish the owner's write
      *          permission from that of others, then the permission will apply to
      *          everybody, regardless of this value.
      *
-     * @return  <code>true</code> if and only if the operation succeeded. The
+     * @return  {@code true} if and only if the operation succeeded. The
      *          operation will fail if the user does not have permission to change
      *          the access permissions of this abstract pathname.
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
@@ -1532,14 +1535,14 @@
      * <pre>{@code
      *     file.setWritable(arg, true)
      * }</pre>
      *
      * @param   writable
-     *          If <code>true</code>, sets the access permission to allow write
-     *          operations; if <code>false</code> to disallow write operations
+     *          If {@code true}, sets the access permission to allow write
+     *          operations; if {@code false} to disallow write operations
      *
-     * @return  <code>true</code> if and only if the operation succeeded.  The
+     * @return  {@code true} if and only if the operation succeeded.  The
      *          operation will fail if the user does not have permission to
      *          change the access permissions of this abstract pathname.
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
@@ -1561,24 +1564,24 @@
      * <p> The {@link java.nio.file.Files} class defines methods that operate on
      * file attributes including file permissions. This may be used when finer
      * manipulation of file permissions is required.
      *
      * @param   readable
-     *          If <code>true</code>, sets the access permission to allow read
-     *          operations; if <code>false</code> to disallow read operations
+     *          If {@code true}, sets the access permission to allow read
+     *          operations; if {@code false} to disallow read operations
      *
      * @param   ownerOnly
-     *          If <code>true</code>, the read permission applies only to the
+     *          If {@code true}, the read permission applies only to the
      *          owner's read permission; otherwise, it applies to everybody.  If
      *          the underlying file system can not distinguish the owner's read
      *          permission from that of others, then the permission will apply to
      *          everybody, regardless of this value.
      *
-     * @return  <code>true</code> if and only if the operation succeeded.  The
+     * @return  {@code true} if and only if the operation succeeded.  The
      *          operation will fail if the user does not have permission to
      *          change the access permissions of this abstract pathname.  If
-     *          <code>readable</code> is <code>false</code> and the underlying
+     *          {@code readable} is {@code false} and the underlying
      *          file system does not implement a read permission, then the
      *          operation will fail.
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
@@ -1610,17 +1613,17 @@
      * <pre>{@code
      *     file.setReadable(arg, true)
      * }</pre>
      *
      * @param  readable
-     *          If <code>true</code>, sets the access permission to allow read
-     *          operations; if <code>false</code> to disallow read operations
+     *          If {@code true}, sets the access permission to allow read
+     *          operations; if {@code false} to disallow read operations
      *
-     * @return  <code>true</code> if and only if the operation succeeded.  The
+     * @return  {@code true} if and only if the operation succeeded.  The
      *          operation will fail if the user does not have permission to
      *          change the access permissions of this abstract pathname.  If
-     *          <code>readable</code> is <code>false</code> and the underlying
+     *          {@code readable} is {@code false} and the underlying
      *          file system does not implement a read permission, then the
      *          operation will fail.
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
@@ -1642,24 +1645,24 @@
      * <p> The {@link java.nio.file.Files} class defines methods that operate on
      * file attributes including file permissions. This may be used when finer
      * manipulation of file permissions is required.
      *
      * @param   executable
-     *          If <code>true</code>, sets the access permission to allow execute
-     *          operations; if <code>false</code> to disallow execute operations
+     *          If {@code true}, sets the access permission to allow execute
+     *          operations; if {@code false} to disallow execute operations
      *
      * @param   ownerOnly
-     *          If <code>true</code>, the execute permission applies only to the
+     *          If {@code true}, the execute permission applies only to the
      *          owner's execute permission; otherwise, it applies to everybody.
      *          If the underlying file system can not distinguish the owner's
      *          execute permission from that of others, then the permission will
      *          apply to everybody, regardless of this value.
      *
-     * @return  <code>true</code> if and only if the operation succeeded.  The
+     * @return  {@code true} if and only if the operation succeeded.  The
      *          operation will fail if the user does not have permission to
      *          change the access permissions of this abstract pathname.  If
-     *          <code>executable</code> is <code>false</code> and the underlying
+     *          {@code executable} is {@code false} and the underlying
      *          file system does not implement an execute permission, then the
      *          operation will fail.
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
@@ -1691,17 +1694,17 @@
      * <pre>{@code
      *     file.setExecutable(arg, true)
      * }</pre>
      *
      * @param   executable
-     *          If <code>true</code>, sets the access permission to allow execute
-     *          operations; if <code>false</code> to disallow execute operations
+     *          If {@code true}, sets the access permission to allow execute
+     *          operations; if {@code false} to disallow execute operations
      *
-     * @return   <code>true</code> if and only if the operation succeeded.  The
+     * @return   {@code true} if and only if the operation succeeded.  The
      *           operation will fail if the user does not have permission to
      *           change the access permissions of this abstract pathname.  If
-     *           <code>executable</code> is <code>false</code> and the underlying
+     *           {@code executable} is {@code false} and the underlying
      *           file system does not implement an execute permission, then the
      *           operation will fail.
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
@@ -1719,11 +1722,11 @@
      * abstract pathname. On some platforms it may be possible to start the
      * Java virtual machine with special privileges that allow it to execute
      * files that are not marked executable. Consequently this method may return
      * {@code true} even though the file does not have execute permissions.
      *
-     * @return  <code>true</code> if and only if the abstract pathname exists
+     * @return  {@code true} if and only if the abstract pathname exists
      *          <em>and</em> the application is allowed to execute the file
      *
      * @throws  SecurityException
      *          If a security manager exists and its {@link
      *          java.lang.SecurityManager#checkExec(java.lang.String)}
@@ -1794,38 +1797,45 @@
 
     /* -- Disk usage -- */
 
     /**
      * Returns the size of the partition <a href="#partName">named</a> by this
-     * abstract pathname.
+     * abstract pathname. If the total number of bytes in the partition is
+     * greater than {@link Long#MAX_VALUE}, then {@code Long.MAX_VALUE} will be
+     * returned.
      *
      * @return  The size, in bytes, of the partition or {@code 0L} if this
-     *          abstract pathname does not name a partition
+     *          abstract pathname does not name a partition or if the size
+     *          cannot be obtained
      *
      * @throws  SecurityException
      *          If a security manager has been installed and it denies
      *          {@link RuntimePermission}{@code ("getFileSystemAttributes")}
      *          or its {@link SecurityManager#checkRead(String)} method denies
      *          read access to the file named by this abstract pathname
      *
      * @since  1.6
+     * @see FileStore#getTotalSpace
      */
     public long getTotalSpace() {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
             sm.checkPermission(new RuntimePermission("getFileSystemAttributes"));
             sm.checkRead(path);
         }
         if (isInvalid()) {
             return 0L;
         }
-        return fs.getSpace(this, FileSystem.SPACE_TOTAL);
+        long space = fs.getSpace(this, FileSystem.SPACE_TOTAL);
+        return space >= 0L ? space : Long.MAX_VALUE;
     }
 
     /**
      * Returns the number of unallocated bytes in the partition <a
-     * href="#partName">named</a> by this abstract path name.
+     * href="#partName">named</a> by this abstract path name.  If the
+     * number of unallocated bytes in the partition is greater than
+     * {@link Long#MAX_VALUE}, then {@code Long.MAX_VALUE} will be returned.
      *
      * <p> The returned number of unallocated bytes is a hint, but not
      * a guarantee, that it is possible to use most or any of these
      * bytes.  The number of unallocated bytes is most likely to be
      * accurate immediately after this call.  It is likely to be made
@@ -1833,73 +1843,81 @@
      * on the system outside of this virtual machine.  This method
      * makes no guarantee that write operations to this file system
      * will succeed.
      *
      * @return  The number of unallocated bytes on the partition or {@code 0L}
-     *          if the abstract pathname does not name a partition.  This
-     *          value will be less than or equal to the total file system size
-     *          returned by {@link #getTotalSpace}.
+     *          if the abstract pathname does not name a partition or if this
+     *          number cannot be obtained.  This value will be less than or
+     *          equal to the total file system size returned by
+     *          {@link #getTotalSpace}.
      *
      * @throws  SecurityException
      *          If a security manager has been installed and it denies
      *          {@link RuntimePermission}{@code ("getFileSystemAttributes")}
      *          or its {@link SecurityManager#checkRead(String)} method denies
      *          read access to the file named by this abstract pathname
      *
      * @since  1.6
+     * @see FileStore#getUnallocatedSpace
      */
     public long getFreeSpace() {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
             sm.checkPermission(new RuntimePermission("getFileSystemAttributes"));
             sm.checkRead(path);
         }
         if (isInvalid()) {
             return 0L;
         }
-        return fs.getSpace(this, FileSystem.SPACE_FREE);
+        long space = fs.getSpace(this, FileSystem.SPACE_FREE);
+        return space >= 0L ? space : Long.MAX_VALUE;
     }
 
     /**
      * Returns the number of bytes available to this virtual machine on the
-     * partition <a href="#partName">named</a> by this abstract pathname.  When
-     * possible, this method checks for write permissions and other operating
-     * system restrictions and will therefore usually provide a more accurate
-     * estimate of how much new data can actually be written than {@link
-     * #getFreeSpace}.
+     * partition <a href="#partName">named</a> by this abstract pathname.  If
+     * the number of available bytes in the partition is greater than
+     * {@link Long#MAX_VALUE}, then {@code Long.MAX_VALUE} will be returned.
+     * When possible, this method checks for write permissions and other
+     * operating system restrictions and will therefore usually provide a more
+     * accurate estimate of how much new data can actually be written than
+     * {@link #getFreeSpace}.
      *
      * <p> The returned number of available bytes is a hint, but not a
      * guarantee, that it is possible to use most or any of these bytes.  The
-     * number of unallocated bytes is most likely to be accurate immediately
+     * number of available bytes is most likely to be accurate immediately
      * after this call.  It is likely to be made inaccurate by any external
      * I/O operations including those made on the system outside of this
      * virtual machine.  This method makes no guarantee that write operations
      * to this file system will succeed.
      *
      * @return  The number of available bytes on the partition or {@code 0L}
-     *          if the abstract pathname does not name a partition.  On
-     *          systems where this information is not available, this method
-     *          will be equivalent to a call to {@link #getFreeSpace}.
+     *          if the abstract pathname does not name a partition or if this
+     *          number cannot be obtained.  On systems where this information
+     *          is not available, this method will be equivalent to a call to
+     *          {@link #getFreeSpace}.
      *
      * @throws  SecurityException
      *          If a security manager has been installed and it denies
      *          {@link RuntimePermission}{@code ("getFileSystemAttributes")}
      *          or its {@link SecurityManager#checkRead(String)} method denies
      *          read access to the file named by this abstract pathname
      *
      * @since  1.6
+     * @see FileStore#getUsableSpace
      */
     public long getUsableSpace() {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
             sm.checkPermission(new RuntimePermission("getFileSystemAttributes"));
             sm.checkRead(path);
         }
         if (isInvalid()) {
             return 0L;
         }
-        return fs.getSpace(this, FileSystem.SPACE_USABLE);
+        long space = fs.getSpace(this, FileSystem.SPACE_USABLE);
+        return space >= 0L ? space : Long.MAX_VALUE;
     }
 
     /* -- Temporary files -- */
 
     private static class TempDirectory {
@@ -2003,51 +2021,51 @@
      *
      * This method provides only part of a temporary-file facility.  To arrange
      * for a file created by this method to be deleted automatically, use the
      * {@link #deleteOnExit} method.
      *
-     * <p> The <code>prefix</code> argument must be at least three characters
+     * <p> The {@code prefix} argument must be at least three characters
      * long.  It is recommended that the prefix be a short, meaningful string
-     * such as <code>"hjb"</code> or <code>"mail"</code>.  The
-     * <code>suffix</code> argument may be <code>null</code>, in which case the
-     * suffix <code>".tmp"</code> will be used.
+     * such as {@code "hjb"} or {@code "mail"}.  The
+     * {@code suffix} argument may be {@code null}, in which case the
+     * suffix {@code ".tmp"} will be used.
      *
      * <p> To create the new file, the prefix and the suffix may first be
      * adjusted to fit the limitations of the underlying platform.  If the
      * prefix is too long then it will be truncated, but its first three
      * characters will always be preserved.  If the suffix is too long then it
      * too will be truncated, but if it begins with a period character
-     * (<code>'.'</code>) then the period and the first three characters
+     * ({@code '.'}) then the period and the first three characters
      * following it will always be preserved.  Once these adjustments have been
      * made the name of the new file will be generated by concatenating the
      * prefix, five or more internally-generated characters, and the suffix.
      *
-     * <p> If the <code>directory</code> argument is <code>null</code> then the
+     * <p> If the {@code directory} argument is {@code null} then the
      * system-dependent default temporary-file directory will be used.  The
      * default temporary-file directory is specified by the system property
-     * <code>java.io.tmpdir</code>.  On UNIX systems the default value of this
-     * property is typically <code>"/tmp"</code> or <code>"/var/tmp"</code>; on
-     * Microsoft Windows systems it is typically <code>"C:\\WINNT\\TEMP"</code>.  A different
+     * {@code java.io.tmpdir}.  On UNIX systems the default value of this
+     * property is typically {@code "/tmp"} or {@code "/var/tmp"}; on
+     * Microsoft Windows systems it is typically {@code "C:\\WINNT\\TEMP"}.  A different
      * value may be given to this system property when the Java virtual machine
      * is invoked, but programmatic changes to this property are not guaranteed
      * to have any effect upon the temporary directory used by this method.
      *
      * @param  prefix     The prefix string to be used in generating the file's
      *                    name; must be at least three characters long
      *
      * @param  suffix     The suffix string to be used in generating the file's
-     *                    name; may be <code>null</code>, in which case the
-     *                    suffix <code>".tmp"</code> will be used
+     *                    name; may be {@code null}, in which case the
+     *                    suffix {@code ".tmp"} will be used
      *
      * @param  directory  The directory in which the file is to be created, or
-     *                    <code>null</code> if the default temporary-file
+     *                    {@code null} if the default temporary-file
      *                    directory is to be used
      *
      * @return  An abstract pathname denoting a newly-created empty file
      *
      * @throws  IllegalArgumentException
-     *          If the <code>prefix</code> argument contains fewer than three
+     *          If the {@code prefix} argument contains fewer than three
      *          characters
      *
      * @throws  IOException  If a file could not be created
      *
      * @throws  SecurityException
@@ -2109,17 +2127,17 @@
      *
      * @param  prefix     The prefix string to be used in generating the file's
      *                    name; must be at least three characters long
      *
      * @param  suffix     The suffix string to be used in generating the file's
-     *                    name; may be <code>null</code>, in which case the
-     *                    suffix <code>".tmp"</code> will be used
+     *                    name; may be {@code null}, in which case the
+     *                    suffix {@code ".tmp"} will be used
      *
      * @return  An abstract pathname denoting a newly-created empty file
      *
      * @throws  IllegalArgumentException
-     *          If the <code>prefix</code> argument contains fewer than three
+     *          If the {@code prefix} argument contains fewer than three
      *          characters
      *
      * @throws  IOException  If a file could not be created
      *
      * @throws  SecurityException
@@ -2159,21 +2177,21 @@
         return fs.compare(this, pathname);
     }
 
     /**
      * Tests this abstract pathname for equality with the given object.
-     * Returns <code>true</code> if and only if the argument is not
-     * <code>null</code> and is an abstract pathname that denotes the same file
+     * Returns {@code true} if and only if the argument is not
+     * {@code null} and is an abstract pathname that denotes the same file
      * or directory as this abstract pathname.  Whether or not two abstract
      * pathnames are equal depends upon the underlying system.  On UNIX
      * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
      * systems it is not.
      *
      * @param   obj   The object to be compared with this abstract pathname
      *
-     * @return  <code>true</code> if and only if the objects are the same;
-     *          <code>false</code> otherwise
+     * @return  {@code true} if and only if the objects are the same;
+     *          {@code false} otherwise
      */
     public boolean equals(Object obj) {
         if ((obj != null) && (obj instanceof File)) {
             return compareTo((File)obj) == 0;
         }
@@ -2184,14 +2202,14 @@
      * Computes a hash code for this abstract pathname.  Because equality of
      * abstract pathnames is inherently system-dependent, so is the computation
      * of their hash codes.  On UNIX systems, the hash code of an abstract
      * pathname is equal to the exclusive <em>or</em> of the hash code
      * of its pathname string and the decimal value
-     * <code>1234321</code>.  On Microsoft Windows systems, the hash
+     * {@code 1234321}.  On Microsoft Windows systems, the hash
      * code is equal to the exclusive <em>or</em> of the hash code of
      * its pathname string converted to lower case and the decimal
-     * value <code>1234321</code>.  Locale is not taken into account on
+     * value {@code 1234321}.  Locale is not taken into account on
      * lowercasing the pathname string.
      *
      * @return  A hash code for this abstract pathname
      */
     public int hashCode() {
@@ -2213,10 +2231,11 @@
      * The separator character is saved also so it can be replaced
      * in case the path is reconstituted on a different host type.
      *
      * @serialData  Default fields followed by separator character.
      */
+    @java.io.Serial
     private synchronized void writeObject(java.io.ObjectOutputStream s)
         throws IOException
     {
         s.defaultWriteObject();
         s.writeChar(separatorChar); // Add the separator character
@@ -2226,10 +2245,11 @@
      * readObject is called to restore this filename.
      * The original separator character is read.  If it is different
      * than the separator character on this system, then the old separator
      * is replaced by the local separator.
      */
+    @java.io.Serial
     private synchronized void readObject(java.io.ObjectInputStream s)
          throws IOException, ClassNotFoundException
     {
         ObjectInputStream.GetField fields = s.readFields();
         String pathField = (String)fields.get("path", null);
@@ -2247,10 +2267,11 @@
             = UNSAFE.objectFieldOffset(File.class, "path");
     private static final long PREFIX_LENGTH_OFFSET
             = UNSAFE.objectFieldOffset(File.class, "prefixLength");
 
     /** use serialVersionUID from JDK 1.0.2 for interoperability */
+    @java.io.Serial
     private static final long serialVersionUID = 301077366599181567L;
 
     // -- Integration with java.nio.file --
 
     private transient volatile Path filePath;

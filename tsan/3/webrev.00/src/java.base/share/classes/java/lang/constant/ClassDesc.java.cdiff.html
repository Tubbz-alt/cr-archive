<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/constant/ClassDesc.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../annotation/IncompleteAnnotationException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Constable.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/constant/ClassDesc.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 70,11 ***</span>
       * {@link #ofDescriptor(String)} or use the predefined constants in
       * {@link ConstantDescs}).
       *
       * @param name the fully qualified (dot-separated) binary class name
       * @return a {@linkplain ClassDesc} describing the desired class
<span class="line-modified">!      * @throws NullPointerException if any argument is {@code null}</span>
       * @throws IllegalArgumentException if the name string is not in the
       * correct format
       */
      static ClassDesc of(String name) {
          ConstantUtils.validateBinaryClassName(requireNonNull(name));
<span class="line-new-header">--- 70,11 ---</span>
       * {@link #ofDescriptor(String)} or use the predefined constants in
       * {@link ConstantDescs}).
       *
       * @param name the fully qualified (dot-separated) binary class name
       * @return a {@linkplain ClassDesc} describing the desired class
<span class="line-modified">!      * @throws NullPointerException if the argument is {@code null}</span>
       * @throws IllegalArgumentException if the name string is not in the
       * correct format
       */
      static ClassDesc of(String name) {
          ConstantUtils.validateBinaryClassName(requireNonNull(name));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,11 ***</span>
       * {@code &quot;[I&quot;}, {@code &quot;V&quot;}, {@code &quot;[Ljava/lang/String;&quot;}, etc.
       * See JVMS 4.3.2 (&quot;Field Descriptors&quot;) for more detail.
       *
       * @param descriptor a field descriptor string
       * @return a {@linkplain ClassDesc} describing the desired class
<span class="line-modified">!      * @throws NullPointerException if any argument is {@code null}</span>
       * @throws IllegalArgumentException if the name string is not in the
       * correct format
       * @jvms 4.3.2 Field Descriptors
       * @jvms 4.4.1 The CONSTANT_Class_info Structure
       */
<span class="line-new-header">--- 121,11 ---</span>
       * {@code &quot;[I&quot;}, {@code &quot;V&quot;}, {@code &quot;[Ljava/lang/String;&quot;}, etc.
       * See JVMS 4.3.2 (&quot;Field Descriptors&quot;) for more detail.
       *
       * @param descriptor a field descriptor string
       * @return a {@linkplain ClassDesc} describing the desired class
<span class="line-modified">!      * @throws NullPointerException if the argument is {@code null}</span>
       * @throws IllegalArgumentException if the name string is not in the
       * correct format
       * @jvms 4.3.2 Field Descriptors
       * @jvms 4.4.1 The CONSTANT_Class_info Structure
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,11 ***</span>
       * descriptor for the class {@code java.util.Map.Entry} could be obtained
       * by {@code d.nested(&quot;Entry&quot;)}.
       *
       * @param nestedName the unqualified name of the nested class
       * @return a {@linkplain ClassDesc} describing the nested class
<span class="line-modified">!      * @throws NullPointerException if any argument is {@code null}</span>
       * @throws IllegalStateException if this {@linkplain ClassDesc} does not
       * describe a class or interface type
       * @throws IllegalArgumentException if the nested class name is invalid
       */
      default ClassDesc nested(String nestedName) {
<span class="line-new-header">--- 191,11 ---</span>
       * descriptor for the class {@code java.util.Map.Entry} could be obtained
       * by {@code d.nested(&quot;Entry&quot;)}.
       *
       * @param nestedName the unqualified name of the nested class
       * @return a {@linkplain ClassDesc} describing the nested class
<span class="line-modified">!      * @throws NullPointerException if the argument is {@code null}</span>
       * @throws IllegalStateException if this {@linkplain ClassDesc} does not
       * describe a class or interface type
       * @throws IllegalArgumentException if the nested class name is invalid
       */
      default ClassDesc nested(String nestedName) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,18 ***</span>
       *
       * @param firstNestedName the unqualified name of the first level of nested class
       * @param moreNestedNames the unqualified name(s) of the remaining levels of
       *                       nested class
       * @return a {@linkplain ClassDesc} describing the nested class
<span class="line-modified">!      * @throws NullPointerException if any argument is {@code null}</span>
       * @throws IllegalStateException if this {@linkplain ClassDesc} does not
       * describe a class or interface type
       * @throws IllegalArgumentException if the nested class name is invalid
       */
      default ClassDesc nested(String firstNestedName, String... moreNestedNames) {
          if (!isClassOrInterface())
              throw new IllegalStateException(&quot;Outer class is not a class or interface type&quot;);
          return moreNestedNames.length == 0
                 ? nested(firstNestedName)
                 : nested(firstNestedName + Stream.of(moreNestedNames).collect(joining(&quot;$&quot;, &quot;$&quot;, &quot;&quot;)));
      }
  
<span class="line-new-header">--- 211,23 ---</span>
       *
       * @param firstNestedName the unqualified name of the first level of nested class
       * @param moreNestedNames the unqualified name(s) of the remaining levels of
       *                       nested class
       * @return a {@linkplain ClassDesc} describing the nested class
<span class="line-modified">!      * @throws NullPointerException if any argument or its contents is {@code null}</span>
       * @throws IllegalStateException if this {@linkplain ClassDesc} does not
       * describe a class or interface type
       * @throws IllegalArgumentException if the nested class name is invalid
       */
      default ClassDesc nested(String firstNestedName, String... moreNestedNames) {
          if (!isClassOrInterface())
              throw new IllegalStateException(&quot;Outer class is not a class or interface type&quot;);
<span class="line-added">+         validateMemberName(firstNestedName, false);</span>
<span class="line-added">+         requireNonNull(moreNestedNames);</span>
<span class="line-added">+         for (String addNestedNames : moreNestedNames) {</span>
<span class="line-added">+             validateMemberName(addNestedNames, false);</span>
<span class="line-added">+         }</span>
          return moreNestedNames.length == 0
                 ? nested(firstNestedName)
                 : nested(firstNestedName + Stream.of(moreNestedNames).collect(joining(&quot;$&quot;, &quot;$&quot;, &quot;&quot;)));
      }
  
</pre>
<center><a href="../annotation/IncompleteAnnotationException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Constable.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/StringCoding.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.io.UnsupportedEncodingException;
  29 import java.lang.ref.SoftReference;
  30 import java.nio.ByteBuffer;
  31 import java.nio.CharBuffer;
  32 import java.nio.charset.Charset;
  33 import java.nio.charset.CharsetDecoder;
  34 import java.nio.charset.CharsetEncoder;
  35 import java.nio.charset.CharacterCodingException;
  36 import java.nio.charset.CoderResult;
  37 import java.nio.charset.CodingErrorAction;
  38 import java.nio.charset.IllegalCharsetNameException;
  39 import java.nio.charset.MalformedInputException;
  40 import java.nio.charset.UnmappableCharacterException;
  41 import java.nio.charset.UnsupportedCharsetException;
  42 import java.util.Arrays;
  43 import jdk.internal.HotSpotIntrinsicCandidate;
  44 import sun.nio.cs.HistoricallyNamedCharset;
  45 import sun.nio.cs.ArrayDecoder;
  46 import sun.nio.cs.ArrayEncoder;
  47 
  48 import static java.lang.String.LATIN1;
  49 import static java.lang.String.UTF16;
  50 import static java.lang.String.COMPACT_STRINGS;
  51 import static java.lang.Character.isSurrogate;
  52 import static java.lang.Character.highSurrogate;
  53 import static java.lang.Character.lowSurrogate;
  54 import static java.lang.Character.isSupplementaryCodePoint;
  55 import static java.lang.StringUTF16.putChar;
  56 
  57 /**
  58  * Utility class for string encoding and decoding.
  59  */
  60 
  61 class StringCoding {
  62 
  63     private StringCoding() { }
  64 
  65     /** The cached coders for each thread */
  66     private static final ThreadLocal&lt;SoftReference&lt;StringDecoder&gt;&gt; decoder =
  67         new ThreadLocal&lt;&gt;();
  68     private static final ThreadLocal&lt;SoftReference&lt;StringEncoder&gt;&gt; encoder =
  69         new ThreadLocal&lt;&gt;();
  70 
  71     private static final Charset ISO_8859_1 = sun.nio.cs.ISO_8859_1.INSTANCE;
  72     private static final Charset US_ASCII = sun.nio.cs.US_ASCII.INSTANCE;
  73     private static final Charset UTF_8 = sun.nio.cs.UTF_8.INSTANCE;
  74 
  75     private static &lt;T&gt; T deref(ThreadLocal&lt;SoftReference&lt;T&gt;&gt; tl) {
  76         SoftReference&lt;T&gt; sr = tl.get();
  77         if (sr == null)
  78             return null;
  79         return sr.get();
  80     }
  81 
  82     private static &lt;T&gt; void set(ThreadLocal&lt;SoftReference&lt;T&gt;&gt; tl, T ob) {
  83         tl.set(new SoftReference&lt;&gt;(ob));
  84     }
  85 
  86     // Trim the given byte array to the given length
  87     private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {
  88         if (len == ba.length &amp;&amp; (isTrusted || System.getSecurityManager() == null))
  89             return ba;
  90         else
  91             return Arrays.copyOf(ba, len);
  92     }
  93 
  94     private static int scale(int len, float expansionFactor) {
  95         // We need to perform double, not float, arithmetic; otherwise
  96         // we lose low order bits when len is larger than 2**24.
  97         return (int)(len * (double)expansionFactor);
  98     }
  99 
 100     private static Charset lookupCharset(String csn) {
 101         if (Charset.isSupported(csn)) {
 102             try {
 103                 return Charset.forName(csn);
 104             } catch (UnsupportedCharsetException x) {
 105                 throw new Error(x);
 106             }
 107         }
 108         return null;
 109     }
 110 
 111     static class Result {
 112         byte[] value;
 113         byte coder;
 114 
 115         Result with() {
 116             coder = COMPACT_STRINGS ? LATIN1 : UTF16;
 117             value = new byte[0];
 118             return this;
 119         }
 120 
 121         Result with(char[] val, int off, int len) {
 122             if (String.COMPACT_STRINGS) {
 123                 byte[] bs = StringUTF16.compress(val, off, len);
 124                 if (bs != null) {
 125                     value = bs;
 126                     coder = LATIN1;
 127                     return this;
 128                 }
 129             }
 130             coder = UTF16;
 131             value = StringUTF16.toBytes(val, off, len);
 132             return this;
 133         }
 134 
 135         Result with(byte[] val, byte coder) {
 136             this.coder = coder;
 137             value = val;
 138             return this;
 139         }
 140     }
 141 
 142     @HotSpotIntrinsicCandidate
 143     public static boolean hasNegatives(byte[] ba, int off, int len) {
 144         for (int i = off; i &lt; off + len; i++) {
 145             if (ba[i] &lt; 0) {
 146                 return true;
 147             }
 148         }
 149         return false;
 150     }
 151 
 152     // -- Decoding --
 153     static class StringDecoder {
 154         private final String requestedCharsetName;
 155         private final Charset cs;
 156         private final boolean isASCIICompatible;
 157         private final CharsetDecoder cd;
 158         protected final Result result;
 159 
 160         StringDecoder(Charset cs, String rcn) {
 161             this.requestedCharsetName = rcn;
 162             this.cs = cs;
 163             this.cd = cs.newDecoder()
 164                 .onMalformedInput(CodingErrorAction.REPLACE)
 165                 .onUnmappableCharacter(CodingErrorAction.REPLACE);
 166             this.result = new Result();
 167             this.isASCIICompatible = (cd instanceof ArrayDecoder) &amp;&amp;
 168                     ((ArrayDecoder)cd).isASCIICompatible();
 169         }
 170 
 171         String charsetName() {
 172             if (cs instanceof HistoricallyNamedCharset)
 173                 return ((HistoricallyNamedCharset)cs).historicalName();
 174             return cs.name();
 175         }
 176 
 177         final String requestedCharsetName() {
 178             return requestedCharsetName;
 179         }
 180 
 181         Result decode(byte[] ba, int off, int len) {
 182             if (len == 0) {
 183                 return result.with();
 184             }
 185             // fastpath for ascii compatible
 186             if (isASCIICompatible &amp;&amp; !hasNegatives(ba, off, len)) {
 187                 if (COMPACT_STRINGS) {
 188                     return result.with(Arrays.copyOfRange(ba, off, off + len),
 189                                       LATIN1);
 190                 } else {
 191                     return result.with(StringLatin1.inflate(ba, off, len), UTF16);
 192                 }
 193             }
 194             // fastpath for always Latin1 decodable single byte
 195             if (COMPACT_STRINGS &amp;&amp; cd instanceof ArrayDecoder &amp;&amp; ((ArrayDecoder)cd).isLatin1Decodable()) {
 196                 byte[] dst = new byte[len];
 197                 ((ArrayDecoder)cd).decodeToLatin1(ba, off, len, dst);
 198                 return result.with(dst, LATIN1);
 199             }
 200             int en = scale(len, cd.maxCharsPerByte());
 201             char[] ca = new char[en];
 202             if (cd instanceof ArrayDecoder) {
 203                 int clen = ((ArrayDecoder)cd).decode(ba, off, len, ca);
 204                 return result.with(ca, 0, clen);
 205             }
 206             cd.reset();
 207             ByteBuffer bb = ByteBuffer.wrap(ba, off, len);
 208             CharBuffer cb = CharBuffer.wrap(ca);
 209             try {
 210                 CoderResult cr = cd.decode(bb, cb, true);
 211                 if (!cr.isUnderflow())
 212                     cr.throwException();
 213                 cr = cd.flush(cb);
 214                 if (!cr.isUnderflow())
 215                     cr.throwException();
 216             } catch (CharacterCodingException x) {
 217                 // Substitution is always enabled,
 218                 // so this shouldn&#39;t happen
 219                 throw new Error(x);
 220             }
 221             return result.with(ca, 0, cb.position());
 222         }
 223     }
 224 
 225     static Result decode(String charsetName, byte[] ba, int off, int len)
 226         throws UnsupportedEncodingException
 227     {
 228         StringDecoder sd = deref(decoder);
 229         String csn = (charsetName == null) ? &quot;ISO-8859-1&quot; : charsetName;
 230         if ((sd == null) || !(csn.equals(sd.requestedCharsetName())
 231                               || csn.equals(sd.charsetName()))) {
 232             sd = null;
 233             try {
 234                 Charset cs = lookupCharset(csn);
 235                 if (cs != null) {
 236                     if (cs == UTF_8) {
 237                         return decodeUTF8(ba, off, len, true);
 238                     }
 239                     if (cs == ISO_8859_1) {
 240                         return decodeLatin1(ba, off, len);
 241                     }
 242                     if (cs == US_ASCII) {
 243                         return decodeASCII(ba, off, len);
 244                     }
 245                     sd = new StringDecoder(cs, csn);
 246                 }
 247             } catch (IllegalCharsetNameException x) {}
 248             if (sd == null)
 249                 throw new UnsupportedEncodingException(csn);
 250             set(decoder, sd);
 251         }
 252         return sd.decode(ba, off, len);
 253     }
 254 
 255     static Result decode(Charset cs, byte[] ba, int off, int len) {
 256         if (cs == UTF_8) {
 257             return decodeUTF8(ba, off, len, true);
 258         }
 259         if (cs == ISO_8859_1) {
 260             return decodeLatin1(ba, off, len);
 261         }
 262         if (cs == US_ASCII) {
 263             return decodeASCII(ba, off, len);
 264         }
 265 
 266         // (1)We never cache the &quot;external&quot; cs, the only benefit of creating
 267         // an additional StringDe/Encoder object to wrap it is to share the
 268         // de/encode() method. These SD/E objects are short-lived, the young-gen
 269         // gc should be able to take care of them well. But the best approach
 270         // is still not to generate them if not really necessary.
 271         // (2)The defensive copy of the input byte/char[] has a big performance
 272         // impact, as well as the outgoing result byte/char[]. Need to do the
 273         // optimization check of (sm==null &amp;&amp; classLoader0==null) for both.
 274         // (3)There might be a timing gap in isTrusted setting. getClassLoader0()
 275         // is only checked (and then isTrusted gets set) when (SM==null). It is
 276         // possible that the SM==null for now but then SM is NOT null later
 277         // when safeTrim() is invoked...the &quot;safe&quot; way to do is to redundant
 278         // check (... &amp;&amp; (isTrusted || SM == null || getClassLoader0())) in trim
 279         // but it then can be argued that the SM is null when the operation
 280         // is started...
 281         CharsetDecoder cd = cs.newDecoder();
 282         // ascii fastpath
 283         if ((cd instanceof ArrayDecoder) &amp;&amp;
 284             ((ArrayDecoder)cd).isASCIICompatible() &amp;&amp; !hasNegatives(ba, off, len)) {
 285             return decodeLatin1(ba, off, len);
 286         }
 287         // fastpath for always Latin1 decodable single byte
 288         if (COMPACT_STRINGS &amp;&amp; cd instanceof ArrayDecoder &amp;&amp; ((ArrayDecoder)cd).isLatin1Decodable()) {
 289             byte[] dst = new byte[len];
 290             ((ArrayDecoder)cd).decodeToLatin1(ba, off, len, dst);
 291             return new Result().with(dst, LATIN1);
 292         }
 293 
 294         int en = scale(len, cd.maxCharsPerByte());
 295         if (len == 0) {
 296             return new Result().with();
 297         }
 298         cd.onMalformedInput(CodingErrorAction.REPLACE)
 299           .onUnmappableCharacter(CodingErrorAction.REPLACE)
 300           .reset();
 301         char[] ca = new char[en];
 302         if (cd instanceof ArrayDecoder) {
 303             int clen = ((ArrayDecoder)cd).decode(ba, off, len, ca);
 304             return new Result().with(ca, 0, clen);
 305         }
 306         if (cs.getClass().getClassLoader0() != null &amp;&amp;
 307             System.getSecurityManager() != null) {
 308             ba = Arrays.copyOfRange(ba, off, off + len);
 309             off = 0;
 310         }
 311         ByteBuffer bb = ByteBuffer.wrap(ba, off, len);
 312         CharBuffer cb = CharBuffer.wrap(ca);
 313         try {
 314             CoderResult cr = cd.decode(bb, cb, true);
 315             if (!cr.isUnderflow())
 316                 cr.throwException();
 317             cr = cd.flush(cb);
 318             if (!cr.isUnderflow())
 319                 cr.throwException();
 320         } catch (CharacterCodingException x) {
 321             // Substitution is always enabled,
 322             // so this shouldn&#39;t happen
 323             throw new Error(x);
 324         }
 325         return new Result().with(ca, 0, cb.position());
 326     }
 327 
 328     static Result decode(byte[] ba, int off, int len) {
 329         Charset cs = Charset.defaultCharset();
 330         if (cs == UTF_8) {
 331             return decodeUTF8(ba, off, len, true);
 332         }
 333         if (cs == ISO_8859_1) {
 334             return decodeLatin1(ba, off, len);
 335         }
 336         if (cs == US_ASCII) {
 337             return decodeASCII(ba, off, len);
 338         }
 339         StringDecoder sd = deref(decoder);
 340         if (sd == null || !cs.name().equals(sd.cs.name())) {
 341             sd = new StringDecoder(cs, cs.name());
 342             set(decoder, sd);
 343         }
 344         return sd.decode(ba, off, len);
 345     }
 346 
 347     // -- Encoding --
 348     private static class StringEncoder {
 349         private Charset cs;
 350         private CharsetEncoder ce;
 351         private final boolean isASCIICompatible;
 352         private final String requestedCharsetName;
 353         private final boolean isTrusted;
 354 
 355         private StringEncoder(Charset cs, String rcn) {
 356             this.requestedCharsetName = rcn;
 357             this.cs = cs;
 358             this.ce = cs.newEncoder()
 359                 .onMalformedInput(CodingErrorAction.REPLACE)
 360                 .onUnmappableCharacter(CodingErrorAction.REPLACE);
 361             this.isTrusted = (cs.getClass().getClassLoader0() == null);
 362             this.isASCIICompatible = (ce instanceof ArrayEncoder) &amp;&amp;
 363                     ((ArrayEncoder)ce).isASCIICompatible();
 364         }
 365 
 366         String charsetName() {
 367             if (cs instanceof HistoricallyNamedCharset)
 368                 return ((HistoricallyNamedCharset)cs).historicalName();
 369             return cs.name();
 370         }
 371 
 372         final String requestedCharsetName() {
 373             return requestedCharsetName;
 374         }
 375 
 376         byte[] encode(byte coder, byte[] val) {
 377             // fastpath for ascii compatible
 378             if (coder == LATIN1 &amp;&amp; isASCIICompatible &amp;&amp;
 379                 !hasNegatives(val, 0, val.length)) {
 380                 return Arrays.copyOf(val, val.length);
 381             }
 382             int len = val.length &gt;&gt; coder;  // assume LATIN1=0/UTF16=1;
 383             int en = scale(len, ce.maxBytesPerChar());
 384             byte[] ba = new byte[en];
 385             if (len == 0) {
 386                 return ba;
 387             }
 388             if (ce instanceof ArrayEncoder) {
 389                 int blen = (coder == LATIN1 ) ? ((ArrayEncoder)ce).encodeFromLatin1(val, 0, len, ba)
 390                                               : ((ArrayEncoder)ce).encodeFromUTF16(val, 0, len, ba);
 391                 if (blen != -1) {
 392                     return safeTrim(ba, blen, isTrusted);
 393                 }
 394             }
 395             char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)
 396                                            : StringUTF16.toChars(val);
 397             ce.reset();
 398             ByteBuffer bb = ByteBuffer.wrap(ba);
 399             CharBuffer cb = CharBuffer.wrap(ca, 0, len);
 400             try {
 401                 CoderResult cr = ce.encode(cb, bb, true);
 402                 if (!cr.isUnderflow())
 403                     cr.throwException();
 404                 cr = ce.flush(bb);
 405                 if (!cr.isUnderflow())
 406                     cr.throwException();
 407             } catch (CharacterCodingException x) {
 408                 // Substitution is always enabled,
 409                 // so this shouldn&#39;t happen
 410                 throw new Error(x);
 411             }
 412             return safeTrim(ba, bb.position(), isTrusted);
 413         }
 414     }
 415 
 416     static byte[] encode(String charsetName, byte coder, byte[] val)
 417         throws UnsupportedEncodingException
 418     {
 419         StringEncoder se = deref(encoder);
 420         String csn = (charsetName == null) ? &quot;ISO-8859-1&quot; : charsetName;
 421         if ((se == null) || !(csn.equals(se.requestedCharsetName())
 422                               || csn.equals(se.charsetName()))) {
 423             se = null;
 424             try {
 425                 Charset cs = lookupCharset(csn);
 426                 if (cs != null) {
 427                     if (cs == UTF_8) {
 428                         return encodeUTF8(coder, val, true);
 429                     }
 430                     if (cs == ISO_8859_1) {
 431                         return encode8859_1(coder, val);
 432                     }
 433                     if (cs == US_ASCII) {
 434                         return encodeASCII(coder, val);
 435                     }
 436                     se = new StringEncoder(cs, csn);
 437                 }
 438             } catch (IllegalCharsetNameException x) {}
 439             if (se == null) {
 440                 throw new UnsupportedEncodingException (csn);
 441             }
 442             set(encoder, se);
 443         }
 444         return se.encode(coder, val);
 445     }
 446 
 447     static byte[] encode(Charset cs, byte coder, byte[] val) {
 448         if (cs == UTF_8) {
 449             return encodeUTF8(coder, val, true);
 450         }
 451         if (cs == ISO_8859_1) {
 452             return encode8859_1(coder, val);
 453         }
 454         if (cs == US_ASCII) {
 455             return encodeASCII(coder, val);
 456         }
 457         CharsetEncoder ce = cs.newEncoder();
 458         // fastpath for ascii compatible
 459         if (coder == LATIN1 &amp;&amp; (((ce instanceof ArrayEncoder) &amp;&amp;
 460                                  ((ArrayEncoder)ce).isASCIICompatible() &amp;&amp;
 461                                  !hasNegatives(val, 0, val.length)))) {
 462             return Arrays.copyOf(val, val.length);
 463         }
 464         int len = val.length &gt;&gt; coder;  // assume LATIN1=0/UTF16=1;
 465         int en = scale(len, ce.maxBytesPerChar());
 466         byte[] ba = new byte[en];
 467         if (len == 0) {
 468             return ba;
 469         }
 470         ce.onMalformedInput(CodingErrorAction.REPLACE)
 471           .onUnmappableCharacter(CodingErrorAction.REPLACE)
 472           .reset();
 473         if (ce instanceof ArrayEncoder) {
 474             int blen = (coder == LATIN1 ) ? ((ArrayEncoder)ce).encodeFromLatin1(val, 0, len, ba)
 475                                           : ((ArrayEncoder)ce).encodeFromUTF16(val, 0, len, ba);
 476             if (blen != -1) {
 477                 return safeTrim(ba, blen, true);
 478             }
 479         }
 480         boolean isTrusted = cs.getClass().getClassLoader0() == null ||
 481                             System.getSecurityManager() == null;
 482         char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)
 483                                        : StringUTF16.toChars(val);
 484         ByteBuffer bb = ByteBuffer.wrap(ba);
 485         CharBuffer cb = CharBuffer.wrap(ca, 0, len);
 486         try {
 487             CoderResult cr = ce.encode(cb, bb, true);
 488             if (!cr.isUnderflow())
 489                 cr.throwException();
 490             cr = ce.flush(bb);
 491             if (!cr.isUnderflow())
 492                 cr.throwException();
 493         } catch (CharacterCodingException x) {
 494             throw new Error(x);
 495         }
 496         return safeTrim(ba, bb.position(), isTrusted);
 497     }
 498 
 499     static byte[] encode(byte coder, byte[] val) {
 500         Charset cs = Charset.defaultCharset();
 501         if (cs == UTF_8) {
 502             return encodeUTF8(coder, val, true);
 503         }
 504         if (cs == ISO_8859_1) {
 505             return encode8859_1(coder, val);
 506         }
 507         if (cs == US_ASCII) {
 508             return encodeASCII(coder, val);
 509         }
 510         StringEncoder se = deref(encoder);
 511         if (se == null || !cs.name().equals(se.cs.name())) {
 512             se = new StringEncoder(cs, cs.name());
 513             set(encoder, se);
 514         }
 515         return se.encode(coder, val);
 516     }
 517 
 518     /**
 519      *  Print a message directly to stderr, bypassing all character conversion
 520      *  methods.
 521      *  @param msg  message to print
 522      */
 523     private static native void err(String msg);
 524 
 525      /* The cached Result for each thread */
 526     private static final ThreadLocal&lt;StringCoding.Result&gt;
 527         resultCached = new ThreadLocal&lt;&gt;() {
 528             protected StringCoding.Result initialValue() {
 529                 return new StringCoding.Result();
 530             }};
 531 
 532     ////////////////////////// ascii //////////////////////////////
 533 
 534     private static Result decodeASCII(byte[] ba, int off, int len) {
 535         Result result = resultCached.get();
 536         if (COMPACT_STRINGS &amp;&amp; !hasNegatives(ba, off, len)) {
 537             return result.with(Arrays.copyOfRange(ba, off, off + len),
 538                                LATIN1);
 539         }
 540         byte[] dst = new byte[len&lt;&lt;1];
 541         int dp = 0;
 542         while (dp &lt; len) {
 543             int b = ba[off++];
 544             putChar(dst, dp++, (b &gt;= 0) ? (char)b : repl);
 545         }
 546         return result.with(dst, UTF16);
 547     }
 548 
 549     private static byte[] encodeASCII(byte coder, byte[] val) {
 550         if (coder == LATIN1) {
 551             byte[] dst = new byte[val.length];
 552             for (int i = 0; i &lt; val.length; i++) {
 553                 if (val[i] &lt; 0) {
 554                     dst[i] = &#39;?&#39;;
 555                 } else {
 556                     dst[i] = val[i];
 557                 }
 558             }
 559             return dst;
 560         }
 561         int len = val.length &gt;&gt; 1;
 562         byte[] dst = new byte[len];
 563         int dp = 0;
 564         for (int i = 0; i &lt; len; i++) {
 565             char c = StringUTF16.getChar(val, i);
 566             if (c &lt; 0x80) {
 567                 dst[dp++] = (byte)c;
 568                 continue;
 569             }
 570             if (Character.isHighSurrogate(c) &amp;&amp; i + 1 &lt; len &amp;&amp;
 571                 Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {
 572                 i++;
 573             }
 574             dst[dp++] = &#39;?&#39;;
 575         }
 576         if (len == dp) {
 577             return dst;
 578         }
 579         return Arrays.copyOf(dst, dp);
 580     }
 581 
 582     ////////////////////////// latin1/8859_1 ///////////////////////////
 583 
 584     private static Result decodeLatin1(byte[] ba, int off, int len) {
 585        Result result = resultCached.get();
 586        if (COMPACT_STRINGS) {
 587            return result.with(Arrays.copyOfRange(ba, off, off + len), LATIN1);
 588        } else {
 589            return result.with(StringLatin1.inflate(ba, off, len), UTF16);
 590        }
 591     }
 592 
 593     @HotSpotIntrinsicCandidate
 594     private static int implEncodeISOArray(byte[] sa, int sp,
 595                                           byte[] da, int dp, int len) {
 596         int i = 0;
 597         for (; i &lt; len; i++) {
 598             char c = StringUTF16.getChar(sa, sp++);
 599             if (c &gt; &#39;\u00FF&#39;)
 600                 break;
 601             da[dp++] = (byte)c;
 602         }
 603         return i;
 604     }
 605 
 606     private static byte[] encode8859_1(byte coder, byte[] val) {
 607         return encode8859_1(coder, val, true);
 608     }
 609 
 610     private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {
 611         if (coder == LATIN1) {
 612             return Arrays.copyOf(val, val.length);
 613         }
 614         int len = val.length &gt;&gt; 1;
 615         byte[] dst = new byte[len];
 616         int dp = 0;
 617         int sp = 0;
 618         int sl = len;
 619         while (sp &lt; sl) {
 620             int ret = implEncodeISOArray(val, sp, dst, dp, len);
 621             sp = sp + ret;
 622             dp = dp + ret;
 623             if (ret != len) {
 624                 if (!doReplace) {
 625                     throwUnmappable(sp, 1);
 626                 }
 627                 char c = StringUTF16.getChar(val, sp++);
 628                 if (Character.isHighSurrogate(c) &amp;&amp; sp &lt; sl &amp;&amp;
 629                     Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {
 630                     sp++;
 631                 }
 632                 dst[dp++] = &#39;?&#39;;
 633                 len = sl - sp;
 634             }
 635         }
 636         if (dp == dst.length) {
 637             return dst;
 638         }
 639         return Arrays.copyOf(dst, dp);
 640     }
 641 
 642     //////////////////////////////// utf8 ////////////////////////////////////
 643 
 644     private static boolean isNotContinuation(int b) {
 645         return (b &amp; 0xc0) != 0x80;
 646     }
 647 
 648     private static boolean isMalformed3(int b1, int b2, int b3) {
 649         return (b1 == (byte)0xe0 &amp;&amp; (b2 &amp; 0xe0) == 0x80) ||
 650                (b2 &amp; 0xc0) != 0x80 || (b3 &amp; 0xc0) != 0x80;
 651     }
 652 
 653     private static boolean isMalformed3_2(int b1, int b2) {
 654         return (b1 == (byte)0xe0 &amp;&amp; (b2 &amp; 0xe0) == 0x80) ||
 655                (b2 &amp; 0xc0) != 0x80;
 656     }
 657 
 658     private static boolean isMalformed4(int b2, int b3, int b4) {
 659         return (b2 &amp; 0xc0) != 0x80 || (b3 &amp; 0xc0) != 0x80 ||
 660                (b4 &amp; 0xc0) != 0x80;
 661     }
 662 
 663     private static boolean isMalformed4_2(int b1, int b2) {
 664         return (b1 == 0xf0 &amp;&amp; (b2  &lt; 0x90 || b2 &gt; 0xbf)) ||
 665                (b1 == 0xf4 &amp;&amp; (b2 &amp; 0xf0) != 0x80) ||
 666                (b2 &amp; 0xc0) != 0x80;
 667     }
 668 
 669     private static boolean isMalformed4_3(int b3) {
 670         return (b3 &amp; 0xc0) != 0x80;
 671     }
 672 
 673     // for nb == 3/4
 674     private static int malformedN(byte[] src, int sp, int nb) {
 675         if (nb == 3) {
 676             int b1 = src[sp++];
 677             int b2 = src[sp++];    // no need to lookup b3
 678             return ((b1 == (byte)0xe0 &amp;&amp; (b2 &amp; 0xe0) == 0x80) ||
 679                     isNotContinuation(b2)) ? 1 : 2;
 680         } else if (nb == 4) { // we don&#39;t care the speed here
 681             int b1 = src[sp++] &amp; 0xff;
 682             int b2 = src[sp++] &amp; 0xff;
 683             if (b1 &gt; 0xf4 ||
 684                 (b1 == 0xf0 &amp;&amp; (b2 &lt; 0x90 || b2 &gt; 0xbf)) ||
 685                 (b1 == 0xf4 &amp;&amp; (b2 &amp; 0xf0) != 0x80) ||
 686                 isNotContinuation(b2))
 687                 return 1;
 688             if (isNotContinuation(src[sp++]))
 689                 return 2;
 690             return 3;
 691         }
 692         assert false;
 693         return -1;
 694     }
 695 
 696     private static void throwMalformed(int off, int nb) {
 697         String msg = &quot;malformed input off : &quot; + off + &quot;, length : &quot; + nb;
 698         throw new IllegalArgumentException(msg, new MalformedInputException(nb));
 699     }
 700 
 701     private static void throwMalformed(byte[] val) {
 702         int dp = 0;
 703         while (dp &lt; val.length &amp;&amp; val[dp] &gt;=0) { dp++; }
 704         throwMalformed(dp, 1);
 705     }
 706 
 707     private static void throwUnmappable(int off, int nb) {
 708         String msg = &quot;malformed input off : &quot; + off + &quot;, length : &quot; + nb;
 709         throw new IllegalArgumentException(msg, new UnmappableCharacterException(nb));
 710     }
 711 
 712     private static void throwUnmappable(byte[] val) {
 713         int dp = 0;
 714         while (dp &lt; val.length &amp;&amp; val[dp] &gt;=0) { dp++; }
 715         throwUnmappable(dp, 1);
 716     }
 717 
 718     private static char repl = &#39;\ufffd&#39;;
 719 
 720     private static Result decodeUTF8(byte[] src, int sp, int len, boolean doReplace) {
 721         // ascii-bais, which has a relative impact to the non-ascii-only bytes
 722         if (COMPACT_STRINGS &amp;&amp; !hasNegatives(src, sp, len))
 723             return resultCached.get().with(Arrays.copyOfRange(src, sp, sp + len),
 724                                            LATIN1);
 725         return decodeUTF8_0(src, sp, len, doReplace);
 726     }
 727 
 728     private static Result decodeUTF8_0(byte[] src, int sp, int len, boolean doReplace) {
 729         Result ret = resultCached.get();
 730 
 731         int sl = sp + len;
 732         int dp = 0;
 733         byte[] dst = new byte[len];
 734 
 735         if (COMPACT_STRINGS) {
 736             while (sp &lt; sl) {
 737                 int b1 = src[sp];
 738                 if (b1 &gt;= 0) {
 739                     dst[dp++] = (byte)b1;
 740                     sp++;
 741                     continue;
 742                 }
 743                 if ((b1 == (byte)0xc2 || b1 == (byte)0xc3) &amp;&amp;
 744                     sp + 1 &lt; sl) {
 745                     int b2 = src[sp + 1];
 746                     if (!isNotContinuation(b2)) {
 747                         dst[dp++] = (byte)(((b1 &lt;&lt; 6) ^ b2)^
 748                                            (((byte) 0xC0 &lt;&lt; 6) ^
 749                                            ((byte) 0x80 &lt;&lt; 0)));
 750                         sp += 2;
 751                         continue;
 752                     }
 753                 }
 754                 // anything not a latin1, including the repl
 755                 // we have to go with the utf16
 756                 break;
 757             }
 758             if (sp == sl) {
 759                 if (dp != dst.length) {
 760                     dst = Arrays.copyOf(dst, dp);
 761                 }
 762                 return ret.with(dst, LATIN1);
 763             }
 764         }
 765         if (dp == 0) {
 766             dst = new byte[len &lt;&lt; 1];
 767         } else {
 768             byte[] buf = new byte[len &lt;&lt; 1];
 769             StringLatin1.inflate(dst, 0, buf, 0, dp);
 770             dst = buf;
 771         }
 772         while (sp &lt; sl) {
 773             int b1 = src[sp++];
 774             if (b1 &gt;= 0) {
 775                 putChar(dst, dp++, (char) b1);
 776             } else if ((b1 &gt;&gt; 5) == -2 &amp;&amp; (b1 &amp; 0x1e) != 0) {
 777                 if (sp &lt; sl) {
 778                     int b2 = src[sp++];
 779                     if (isNotContinuation(b2)) {
 780                         if (!doReplace) {
 781                             throwMalformed(sp - 1, 1);
 782                         }
 783                         putChar(dst, dp++, repl);
 784                         sp--;
 785                     } else {
 786                         putChar(dst, dp++, (char)(((b1 &lt;&lt; 6) ^ b2)^
 787                                                   (((byte) 0xC0 &lt;&lt; 6) ^
 788                                                   ((byte) 0x80 &lt;&lt; 0))));
 789                     }
 790                     continue;
 791                 }
 792                 if (!doReplace) {
 793                     throwMalformed(sp, 1);  // underflow()
 794                 }
 795                 putChar(dst, dp++, repl);
 796                 break;
 797             } else if ((b1 &gt;&gt; 4) == -2) {
 798                 if (sp + 1 &lt; sl) {
 799                     int b2 = src[sp++];
 800                     int b3 = src[sp++];
 801                     if (isMalformed3(b1, b2, b3)) {
 802                         if (!doReplace) {
 803                             throwMalformed(sp - 3, 3);
 804                         }
 805                         putChar(dst, dp++, repl);
 806                         sp -= 3;
 807                         sp += malformedN(src, sp, 3);
 808                     } else {
 809                         char c = (char)((b1 &lt;&lt; 12) ^
 810                                         (b2 &lt;&lt;  6) ^
 811                                         (b3 ^
 812                                          (((byte) 0xE0 &lt;&lt; 12) ^
 813                                          ((byte) 0x80 &lt;&lt;  6) ^
 814                                          ((byte) 0x80 &lt;&lt;  0))));
 815                         if (isSurrogate(c)) {
 816                             if (!doReplace) {
 817                                 throwMalformed(sp - 3, 3);
 818                             }
 819                             putChar(dst, dp++, repl);
 820                         } else {
 821                             putChar(dst, dp++, c);
 822                         }
 823                     }
 824                     continue;
 825                 }
 826                 if (sp  &lt; sl &amp;&amp; isMalformed3_2(b1, src[sp])) {
 827                     if (!doReplace) {
 828                         throwMalformed(sp - 1, 2);
 829                     }
 830                     putChar(dst, dp++, repl);
 831                     continue;
 832                 }
 833                 if (!doReplace){
 834                     throwMalformed(sp, 1);
 835                 }
 836                 putChar(dst, dp++, repl);
 837                 break;
 838             } else if ((b1 &gt;&gt; 3) == -2) {
 839                 if (sp + 2 &lt; sl) {
 840                     int b2 = src[sp++];
 841                     int b3 = src[sp++];
 842                     int b4 = src[sp++];
 843                     int uc = ((b1 &lt;&lt; 18) ^
 844                               (b2 &lt;&lt; 12) ^
 845                               (b3 &lt;&lt;  6) ^
 846                               (b4 ^
 847                                (((byte) 0xF0 &lt;&lt; 18) ^
 848                                ((byte) 0x80 &lt;&lt; 12) ^
 849                                ((byte) 0x80 &lt;&lt;  6) ^
 850                                ((byte) 0x80 &lt;&lt;  0))));
 851                     if (isMalformed4(b2, b3, b4) ||
 852                         !isSupplementaryCodePoint(uc)) { // shortest form check
 853                         if (!doReplace) {
 854                             throwMalformed(sp - 4, 4);
 855                         }
 856                         putChar(dst, dp++, repl);
 857                         sp -= 4;
 858                         sp += malformedN(src, sp, 4);
 859                     } else {
 860                         putChar(dst, dp++, highSurrogate(uc));
 861                         putChar(dst, dp++, lowSurrogate(uc));
 862                     }
 863                     continue;
 864                 }
 865                 b1 &amp;= 0xff;
 866                 if (b1 &gt; 0xf4 ||
 867                     sp  &lt; sl &amp;&amp; isMalformed4_2(b1, src[sp] &amp; 0xff)) {
 868                     if (!doReplace) {
 869                         throwMalformed(sp - 1, 1);  // or 2
 870                     }
 871                     putChar(dst, dp++, repl);
 872                     continue;
 873                 }
 874                 if (!doReplace) {
 875                     throwMalformed(sp - 1, 1);
 876                 }
 877                 sp++;
 878                 putChar(dst, dp++, repl);
 879                 if (sp  &lt; sl &amp;&amp; isMalformed4_3(src[sp])) {
 880                     continue;
 881                 }
 882                 break;
 883             } else {
 884                 if (!doReplace) {
 885                     throwMalformed(sp - 1, 1);
 886                 }
 887                 putChar(dst, dp++, repl);
 888             }
 889         }
 890         if (dp != len) {
 891             dst = Arrays.copyOf(dst, dp &lt;&lt; 1);
 892         }
 893         return ret.with(dst, UTF16);
 894     }
 895 
 896     private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {
 897         if (coder == UTF16)
 898             return encodeUTF8_UTF16(val, doReplace);
 899 
 900         if (!hasNegatives(val, 0, val.length))
 901             return Arrays.copyOf(val, val.length);
 902 
 903         int dp = 0;
 904         byte[] dst = new byte[val.length &lt;&lt; 1];
 905         for (int sp = 0; sp &lt; val.length; sp++) {
 906             byte c = val[sp];
 907             if (c &lt; 0) {
 908                 dst[dp++] = (byte)(0xc0 | ((c &amp; 0xff) &gt;&gt; 6));
 909                 dst[dp++] = (byte)(0x80 | (c &amp; 0x3f));
 910             } else {
 911                 dst[dp++] = c;
 912             }
 913         }
 914         if (dp == dst.length)
 915             return dst;
 916         return Arrays.copyOf(dst, dp);
 917     }
 918 
 919     private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {
 920         int dp = 0;
 921         int sp = 0;
 922         int sl = val.length &gt;&gt; 1;
 923         byte[] dst = new byte[sl * 3];
 924         char c;
 925         while (sp &lt; sl &amp;&amp; (c = StringUTF16.getChar(val, sp)) &lt; &#39;\u0080&#39;) {
 926             // ascii fast loop;
 927             dst[dp++] = (byte)c;
 928             sp++;
 929         }
 930         while (sp &lt; sl) {
 931             c = StringUTF16.getChar(val, sp++);
 932             if (c &lt; 0x80) {
 933                 dst[dp++] = (byte)c;
 934             } else if (c &lt; 0x800) {
 935                 dst[dp++] = (byte)(0xc0 | (c &gt;&gt; 6));
 936                 dst[dp++] = (byte)(0x80 | (c &amp; 0x3f));
 937             } else if (Character.isSurrogate(c)) {
 938                 int uc = -1;
 939                 char c2;
 940                 if (Character.isHighSurrogate(c) &amp;&amp; sp &lt; sl &amp;&amp;
 941                     Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {
 942                     uc = Character.toCodePoint(c, c2);
 943                 }
 944                 if (uc &lt; 0) {
 945                     if (doReplace) {
 946                         dst[dp++] = &#39;?&#39;;
 947                     } else {
 948                         throwUnmappable(sp - 1, 1); // or 2, does not matter here
 949                     }
 950                 } else {
 951                     dst[dp++] = (byte)(0xf0 | ((uc &gt;&gt; 18)));
 952                     dst[dp++] = (byte)(0x80 | ((uc &gt;&gt; 12) &amp; 0x3f));
 953                     dst[dp++] = (byte)(0x80 | ((uc &gt;&gt;  6) &amp; 0x3f));
 954                     dst[dp++] = (byte)(0x80 | (uc &amp; 0x3f));
 955                     sp++;  // 2 chars
 956                 }
 957             } else {
 958                 // 3 bytes, 16 bits
 959                 dst[dp++] = (byte)(0xe0 | ((c &gt;&gt; 12)));
 960                 dst[dp++] = (byte)(0x80 | ((c &gt;&gt;  6) &amp; 0x3f));
 961                 dst[dp++] = (byte)(0x80 | (c &amp; 0x3f));
 962             }
 963         }
 964         if (dp == dst.length) {
 965             return dst;
 966         }
 967         return Arrays.copyOf(dst, dp);
 968     }
 969 
 970     ////////////////////// for j.u.z.ZipCoder //////////////////////////
 971 
 972     /*
 973      * Throws iae, instead of replacing, if malformed or unmappable.
 974      */
 975     static String newStringUTF8NoRepl(byte[] src, int off, int len) {
 976         if (COMPACT_STRINGS &amp;&amp; !hasNegatives(src, off, len))
 977             return new String(Arrays.copyOfRange(src, off, off + len), LATIN1);
 978         Result ret = decodeUTF8_0(src, off, len, false);
 979         return new String(ret.value, ret.coder);
 980     }
 981 
 982     /*
 983      * Throws iae, instead of replacing, if unmappable.
 984      */
 985     static byte[] getBytesUTF8NoRepl(String s) {
 986         return encodeUTF8(s.coder(), s.value(), false);
 987     }
 988 
 989     ////////////////////// for j.n.f.Files //////////////////////////
 990 
 991     private static boolean isASCII(byte[] src) {
 992         return !hasNegatives(src, 0, src.length);
 993     }
 994 
 995     private static String newStringLatin1(byte[] src) {
 996         if (COMPACT_STRINGS)
 997            return new String(src, LATIN1);
 998         return new String(StringLatin1.inflate(src, 0, src.length), UTF16);
 999     }
1000 
1001     static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {
1002         try {
1003             return newStringNoRepl1(src, cs);
1004         } catch (IllegalArgumentException e) {
1005             //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause
1006             Throwable cause = e.getCause();
1007             if (cause instanceof MalformedInputException) {
1008                 throw (MalformedInputException)cause;
1009             }
1010             throw (CharacterCodingException)cause;
1011         }
1012     }
1013 
1014     static String newStringNoRepl1(byte[] src, Charset cs) {
1015         if (cs == UTF_8) {
1016             if (COMPACT_STRINGS &amp;&amp; isASCII(src))
1017                 return new String(src, LATIN1);
1018             Result ret = decodeUTF8_0(src, 0, src.length, false);
1019             return new String(ret.value, ret.coder);
1020         }
1021         if (cs == ISO_8859_1) {
1022             return newStringLatin1(src);
1023         }
1024         if (cs == US_ASCII) {
1025             if (isASCII(src)) {
1026                 return newStringLatin1(src);
1027             } else {
1028                 throwMalformed(src);
1029             }
1030         }
1031 
1032         CharsetDecoder cd = cs.newDecoder();
1033         // ascii fastpath
1034         if ((cd instanceof ArrayDecoder) &amp;&amp;
1035             ((ArrayDecoder)cd).isASCIICompatible() &amp;&amp; isASCII(src)) {
1036             return newStringLatin1(src);
1037         }
1038         int len = src.length;
1039         if (len == 0) {
1040             return &quot;&quot;;
1041         }
1042         int en = scale(len, cd.maxCharsPerByte());
1043         char[] ca = new char[en];
1044         if (cs.getClass().getClassLoader0() != null &amp;&amp;
1045             System.getSecurityManager() != null) {
1046             src = Arrays.copyOf(src, len);
1047         }
1048         ByteBuffer bb = ByteBuffer.wrap(src);
1049         CharBuffer cb = CharBuffer.wrap(ca);
1050         try {
1051             CoderResult cr = cd.decode(bb, cb, true);
1052             if (!cr.isUnderflow())
1053                 cr.throwException();
1054             cr = cd.flush(cb);
1055             if (!cr.isUnderflow())
1056                 cr.throwException();
1057         } catch (CharacterCodingException x) {
1058             throw new IllegalArgumentException(x);  // todo
1059         }
1060         Result ret = resultCached.get().with(ca, 0, cb.position());
1061         return new String(ret.value, ret.coder);
1062     }
1063 
1064     /*
1065      * Throws CCE, instead of replacing, if unmappable.
1066      */
1067     static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {
1068         try {
1069             return getBytesNoRepl1(s, cs);
1070         } catch (IllegalArgumentException e) {
1071             //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause
1072             Throwable cause = e.getCause();
1073             if (cause instanceof UnmappableCharacterException) {
1074                 throw (UnmappableCharacterException)cause;
1075             }
1076             throw (CharacterCodingException)cause;
1077         }
1078     }
1079 
1080     static byte[] getBytesNoRepl1(String s, Charset cs) {
1081         byte[] val = s.value();
1082         byte coder = s.coder();
1083         if (cs == UTF_8) {
1084             if (coder == LATIN1 &amp;&amp; isASCII(val)) {
1085                 return val;
1086             }
1087             return encodeUTF8(coder, val, false);
1088         }
1089         if (cs == ISO_8859_1) {
1090             if (coder == LATIN1) {
1091                 return val;
1092             }
1093             return encode8859_1(coder, val, false);
1094         }
1095         if (cs == US_ASCII) {
1096             if (coder == LATIN1) {
1097                 if (isASCII(val)) {
1098                     return val;
1099                 } else {
1100                     throwUnmappable(val);
1101                 }
1102             }
1103         }
1104         CharsetEncoder ce = cs.newEncoder();
1105         // fastpath for ascii compatible
1106         if (coder == LATIN1 &amp;&amp; (((ce instanceof ArrayEncoder) &amp;&amp;
1107                                  ((ArrayEncoder)ce).isASCIICompatible() &amp;&amp;
1108                                  isASCII(val)))) {
1109             return val;
1110         }
1111         int len = val.length &gt;&gt; coder;  // assume LATIN1=0/UTF16=1;
1112         int en = scale(len, ce.maxBytesPerChar());
1113         byte[] ba = new byte[en];
1114         if (len == 0) {
1115             return ba;
1116         }
1117         if (ce instanceof ArrayEncoder) {
1118             int blen = (coder == LATIN1 ) ? ((ArrayEncoder)ce).encodeFromLatin1(val, 0, len, ba)
1119                                           : ((ArrayEncoder)ce).encodeFromUTF16(val, 0, len, ba);
1120             if (blen != -1) {
1121                 return safeTrim(ba, blen, true);
1122             }
1123         }
1124         boolean isTrusted = cs.getClass().getClassLoader0() == null ||
1125                             System.getSecurityManager() == null;
1126         char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)
1127                                        : StringUTF16.toChars(val);
1128         ByteBuffer bb = ByteBuffer.wrap(ba);
1129         CharBuffer cb = CharBuffer.wrap(ca, 0, len);
1130         try {
1131             CoderResult cr = ce.encode(cb, bb, true);
1132             if (!cr.isUnderflow())
1133                 cr.throwException();
1134             cr = ce.flush(bb);
1135             if (!cr.isUnderflow())
1136                 cr.throwException();
1137         } catch (CharacterCodingException x) {
1138             throw new IllegalArgumentException(x);
1139         }
1140         return safeTrim(ba, bb.position(), isTrusted);
1141     }
1142 }
    </pre>
  </body>
</html>
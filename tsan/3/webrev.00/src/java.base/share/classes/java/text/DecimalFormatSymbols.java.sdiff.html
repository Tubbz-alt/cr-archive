<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/text/DecimalFormatSymbols.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="DecimalFormat.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DigitList.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/DecimalFormatSymbols.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
  28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
  29  *
  30  *   The original version of this source code and documentation is copyrighted
  31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
  32  * materials are provided under terms of a License Agreement between Taligent
  33  * and Sun. This technology is protected by multiple US and International
  34  * patents. This notice and attribution to Taligent may not be removed.
  35  *   Taligent is a registered trademark of Taligent, Inc.
  36  *
  37  */
  38 
  39 package java.text;
  40 

  41 import java.io.IOException;
  42 import java.io.ObjectInputStream;
  43 import java.io.Serializable;
  44 import java.text.spi.DecimalFormatSymbolsProvider;
  45 import java.util.Currency;
  46 import java.util.Locale;

  47 import sun.util.locale.provider.CalendarDataUtility;
  48 import sun.util.locale.provider.LocaleProviderAdapter;
  49 import sun.util.locale.provider.LocaleServiceProviderPool;
  50 import sun.util.locale.provider.ResourceBundleBasedAdapter;
  51 
  52 /**
  53  * This class represents the set of symbols (such as the decimal separator,
<span class="line-modified">  54  * the grouping separator, and so on) needed by &lt;code&gt;DecimalFormat&lt;/code&gt;</span>
<span class="line-modified">  55  * to format numbers. &lt;code&gt;DecimalFormat&lt;/code&gt; creates for itself an instance of</span>
<span class="line-modified">  56  * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; from its locale data.  If you need to change any</span>
<span class="line-modified">  57  * of these symbols, you can get the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object from</span>
<span class="line-modified">  58  * your &lt;code&gt;DecimalFormat&lt;/code&gt; and modify it.</span>
  59  *
  60  * &lt;p&gt;If the locale contains &quot;rg&quot; (region override)
  61  * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
  62  * the symbols are overridden for the designated region.
  63  *
  64  * @see          java.util.Locale
  65  * @see          DecimalFormat
  66  * @author       Mark Davis
  67  * @author       Alan Liu
  68  * @since 1.1
  69  */
  70 
  71 public class DecimalFormatSymbols implements Cloneable, Serializable {
  72 
  73     /**
  74      * Create a DecimalFormatSymbols object for the default
  75      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
  76      * This constructor can only construct instances for the locales
  77      * supported by the Java runtime environment, not for those
  78      * supported by installed
</pre>
<hr />
<pre>
  90     }
  91 
  92     /**
  93      * Create a DecimalFormatSymbols object for the given locale.
  94      * This constructor can only construct instances for the locales
  95      * supported by the Java runtime environment, not for those
  96      * supported by installed
  97      * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
  98      * implementations. For full locale coverage, use the
  99      * {@link #getInstance(Locale) getInstance} method.
 100      * If the specified locale contains the {@link java.util.Locale#UNICODE_LOCALE_EXTENSION}
 101      * for the numbering system, the instance is initialized with the specified numbering
 102      * system if the JRE implementation supports it. For example,
 103      * &lt;pre&gt;
 104      * NumberFormat.getNumberInstance(Locale.forLanguageTag(&quot;th-TH-u-nu-thai&quot;))
 105      * &lt;/pre&gt;
 106      * This may return a {@code NumberFormat} instance with the Thai numbering system,
 107      * instead of the Latin numbering system.
 108      *
 109      * @param locale the desired locale
<span class="line-modified"> 110      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</span>
 111      */
 112     public DecimalFormatSymbols( Locale locale ) {
 113         initialize( locale );
 114     }
 115 
 116     /**
 117      * Returns an array of all locales for which the
<span class="line-modified"> 118      * &lt;code&gt;getInstance&lt;/code&gt; methods of this class can return</span>
 119      * localized instances.
 120      * The returned array represents the union of locales supported by the Java
 121      * runtime and by installed
 122      * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
<span class="line-modified"> 123      * implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;</span>
 124      * instance equal to {@link java.util.Locale#US Locale.US}.
 125      *
 126      * @return an array of locales for which localized
<span class="line-modified"> 127      *         &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instances are available.</span>
 128      * @since 1.6
 129      */
 130     public static Locale[] getAvailableLocales() {
 131         LocaleServiceProviderPool pool =
 132             LocaleServiceProviderPool.getPool(DecimalFormatSymbolsProvider.class);
 133         return pool.getAvailableLocales();
 134     }
 135 
 136     /**
<span class="line-modified"> 137      * Gets the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance for the default</span>
<span class="line-modified"> 138      * locale.  This method provides access to &lt;code&gt;DecimalFormatSymbols&lt;/code&gt;</span>
 139      * instances for locales supported by the Java runtime itself as well
 140      * as for those supported by installed
 141      * {@link java.text.spi.DecimalFormatSymbolsProvider
 142      * DecimalFormatSymbolsProvider} implementations.
 143      * &lt;p&gt;This is equivalent to calling
 144      * {@link #getInstance(Locale)
 145      *     getInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 146      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 147      * @see java.util.Locale.Category#FORMAT
<span class="line-modified"> 148      * @return a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance.</span>
 149      * @since 1.6
 150      */
 151     public static final DecimalFormatSymbols getInstance() {
 152         return getInstance(Locale.getDefault(Locale.Category.FORMAT));
 153     }
 154 
 155     /**
<span class="line-modified"> 156      * Gets the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance for the specified</span>
<span class="line-modified"> 157      * locale.  This method provides access to &lt;code&gt;DecimalFormatSymbols&lt;/code&gt;</span>
 158      * instances for locales supported by the Java runtime itself as well
 159      * as for those supported by installed
 160      * {@link java.text.spi.DecimalFormatSymbolsProvider
 161      * DecimalFormatSymbolsProvider} implementations.
 162      * If the specified locale contains the {@link java.util.Locale#UNICODE_LOCALE_EXTENSION}
 163      * for the numbering system, the instance is initialized with the specified numbering
 164      * system if the JRE implementation supports it. For example,
 165      * &lt;pre&gt;
 166      * NumberFormat.getNumberInstance(Locale.forLanguageTag(&quot;th-TH-u-nu-thai&quot;))
 167      * &lt;/pre&gt;
 168      * This may return a {@code NumberFormat} instance with the Thai numbering system,
 169      * instead of the Latin numbering system.
 170      *
 171      * @param locale the desired locale.
<span class="line-modified"> 172      * @return a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance.</span>
<span class="line-modified"> 173      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</span>
 174      * @since 1.6
 175      */
 176     public static final DecimalFormatSymbols getInstance(Locale locale) {
 177         LocaleProviderAdapter adapter;
 178         adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, locale);
 179         DecimalFormatSymbolsProvider provider = adapter.getDecimalFormatSymbolsProvider();
 180         DecimalFormatSymbols dfsyms = provider.getInstance(locale);
 181         if (dfsyms == null) {
 182             provider = LocaleProviderAdapter.forJRE().getDecimalFormatSymbolsProvider();
 183             dfsyms = provider.getInstance(locale);
 184         }
 185         return dfsyms;
 186     }
 187 
 188     /**
 189      * Gets the character used for zero. Different for Arabic, etc.
 190      *
 191      * @return the character used for zero
 192      */
 193     public char getZeroDigit() {
 194         return zeroDigit;
 195     }
 196 
 197     /**
 198      * Sets the character used for zero. Different for Arabic, etc.
 199      *
 200      * @param zeroDigit the character used for zero
 201      */
 202     public void setZeroDigit(char zeroDigit) {

 203         this.zeroDigit = zeroDigit;
 204     }
 205 
 206     /**
<span class="line-modified"> 207      * Gets the character used for thousands separator. Different for French, etc.</span>
 208      *
 209      * @return the grouping separator
 210      */
 211     public char getGroupingSeparator() {
 212         return groupingSeparator;
 213     }
 214 
 215     /**
<span class="line-modified"> 216      * Sets the character used for thousands separator. Different for French, etc.</span>
 217      *
 218      * @param groupingSeparator the grouping separator
 219      */
 220     public void setGroupingSeparator(char groupingSeparator) {

 221         this.groupingSeparator = groupingSeparator;
 222     }
 223 
 224     /**
 225      * Gets the character used for decimal sign. Different for French, etc.
 226      *
 227      * @return the character used for decimal sign
 228      */
 229     public char getDecimalSeparator() {
 230         return decimalSeparator;
 231     }
 232 
 233     /**
 234      * Sets the character used for decimal sign. Different for French, etc.
 235      *
 236      * @param decimalSeparator the character used for decimal sign
 237      */
 238     public void setDecimalSeparator(char decimalSeparator) {

 239         this.decimalSeparator = decimalSeparator;
 240     }
 241 
 242     /**
 243      * Gets the character used for per mille sign. Different for Arabic, etc.
 244      *
 245      * @return the character used for per mille sign
 246      */
 247     public char getPerMill() {
 248         return perMill;
 249     }
 250 
 251     /**
 252      * Sets the character used for per mille sign. Different for Arabic, etc.
 253      *
 254      * @param perMill the character used for per mille sign
 255      */
 256     public void setPerMill(char perMill) {

 257         this.perMill = perMill;

 258     }
 259 
 260     /**
 261      * Gets the character used for percent sign. Different for Arabic, etc.
 262      *
 263      * @return the character used for percent sign
 264      */
 265     public char getPercent() {
 266         return percent;
 267     }
 268 
 269     /**
 270      * Sets the character used for percent sign. Different for Arabic, etc.
 271      *
 272      * @param percent the character used for percent sign
 273      */
 274     public void setPercent(char percent) {

 275         this.percent = percent;

 276     }
 277 
 278     /**
 279      * Gets the character used for a digit in a pattern.
 280      *
 281      * @return the character used for a digit in a pattern
 282      */
 283     public char getDigit() {
 284         return digit;
 285     }
 286 
 287     /**
 288      * Sets the character used for a digit in a pattern.
 289      *
 290      * @param digit the character used for a digit in a pattern
 291      */
 292     public void setDigit(char digit) {

 293         this.digit = digit;
 294     }
 295 
 296     /**
 297      * Gets the character used to separate positive and negative subpatterns
 298      * in a pattern.
 299      *
 300      * @return the pattern separator
 301      */
 302     public char getPatternSeparator() {
 303         return patternSeparator;
 304     }
 305 
 306     /**
 307      * Sets the character used to separate positive and negative subpatterns
 308      * in a pattern.
 309      *
 310      * @param patternSeparator the pattern separator
 311      */
 312     public void setPatternSeparator(char patternSeparator) {

 313         this.patternSeparator = patternSeparator;
 314     }
 315 
 316     /**
 317      * Gets the string used to represent infinity. Almost always left
 318      * unchanged.
 319      *
 320      * @return the string representing infinity
 321      */
 322     public String getInfinity() {
 323         return infinity;
 324     }
 325 
 326     /**
 327      * Sets the string used to represent infinity. Almost always left
 328      * unchanged.
 329      *
 330      * @param infinity the string representing infinity
 331      */
 332     public void setInfinity(String infinity) {

 333         this.infinity = infinity;
 334     }
 335 
 336     /**
 337      * Gets the string used to represent &quot;not a number&quot;. Almost always left
 338      * unchanged.
 339      *
 340      * @return the string representing &quot;not a number&quot;
 341      */
 342     public String getNaN() {
 343         return NaN;
 344     }
 345 
 346     /**
 347      * Sets the string used to represent &quot;not a number&quot;. Almost always left
 348      * unchanged.
 349      *
 350      * @param NaN the string representing &quot;not a number&quot;
 351      */
 352     public void setNaN(String NaN) {

 353         this.NaN = NaN;
 354     }
 355 
 356     /**
 357      * Gets the character used to represent minus sign. If no explicit
 358      * negative format is specified, one is formed by prefixing
 359      * minusSign to the positive format.
 360      *
 361      * @return the character representing minus sign
 362      */
 363     public char getMinusSign() {
 364         return minusSign;
 365     }
 366 
 367     /**
 368      * Sets the character used to represent minus sign. If no explicit
 369      * negative format is specified, one is formed by prefixing
 370      * minusSign to the positive format.
 371      *
 372      * @param minusSign the character representing minus sign
 373      */
 374     public void setMinusSign(char minusSign) {

 375         this.minusSign = minusSign;

 376     }
 377 
 378     /**
 379      * Returns the currency symbol for the currency of these
 380      * DecimalFormatSymbols in their locale.
 381      *
 382      * @return the currency symbol
 383      * @since 1.2
 384      */
 385     public String getCurrencySymbol()
 386     {
 387         initializeCurrency(locale);
 388         return currencySymbol;
 389     }
 390 
 391     /**
 392      * Sets the currency symbol for the currency of these
 393      * DecimalFormatSymbols in their locale.
 394      *
 395      * @param currency the currency symbol
 396      * @since 1.2
 397      */
 398     public void setCurrencySymbol(String currency)
 399     {
 400         initializeCurrency(locale);

 401         currencySymbol = currency;
 402     }
 403 
 404     /**
 405      * Returns the ISO 4217 currency code of the currency of these
 406      * DecimalFormatSymbols.
 407      *
 408      * @return the currency code
 409      * @since 1.2
 410      */
 411     public String getInternationalCurrencySymbol()
 412     {
 413         initializeCurrency(locale);
 414         return intlCurrencySymbol;
 415     }
 416 
 417     /**
 418      * Sets the ISO 4217 currency code of the currency of these
 419      * DecimalFormatSymbols.
 420      * If the currency code is valid (as defined by
 421      * {@link java.util.Currency#getInstance(java.lang.String) Currency.getInstance}),
 422      * this also sets the currency attribute to the corresponding Currency
 423      * instance and the currency symbol attribute to the currency&#39;s symbol
 424      * in the DecimalFormatSymbols&#39; locale. If the currency code is not valid,
 425      * then the currency attribute is set to null and the currency symbol
 426      * attribute is not modified.
 427      *
 428      * @param currencyCode the currency code
 429      * @see #setCurrency
 430      * @see #setCurrencySymbol
 431      * @since 1.2
 432      */
 433     public void setInternationalCurrencySymbol(String currencyCode)
 434     {
 435         initializeCurrency(locale);

 436         intlCurrencySymbol = currencyCode;
 437         currency = null;
 438         if (currencyCode != null) {
 439             try {
 440                 currency = Currency.getInstance(currencyCode);
 441                 currencySymbol = currency.getSymbol();
 442             } catch (IllegalArgumentException e) {
 443             }
 444         }
 445     }
 446 
 447     /**
 448      * Gets the currency of these DecimalFormatSymbols. May be null if the
 449      * currency symbol attribute was previously set to a value that&#39;s not
 450      * a valid ISO 4217 currency code.
 451      *
 452      * @return the currency used, or null
 453      * @since 1.4
 454      */
 455     public Currency getCurrency() {
 456         initializeCurrency(locale);
 457         return currency;
 458     }
 459 
 460     /**
 461      * Sets the currency of these DecimalFormatSymbols.
 462      * This also sets the currency symbol attribute to the currency&#39;s symbol
 463      * in the DecimalFormatSymbols&#39; locale, and the international currency
 464      * symbol attribute to the currency&#39;s ISO 4217 currency code.
 465      *
 466      * @param currency the new currency to be used
<span class="line-modified"> 467      * @exception NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null</span>
 468      * @since 1.4
 469      * @see #setCurrencySymbol
 470      * @see #setInternationalCurrencySymbol
 471      */
 472     public void setCurrency(Currency currency) {
 473         if (currency == null) {
 474             throw new NullPointerException();
 475         }
 476         initializeCurrency(locale);

 477         this.currency = currency;
 478         intlCurrencySymbol = currency.getCurrencyCode();
 479         currencySymbol = currency.getSymbol(locale);
 480     }
 481 
 482 
 483     /**
 484      * Returns the monetary decimal separator.
 485      *
 486      * @return the monetary decimal separator
 487      * @since 1.2
 488      */
 489     public char getMonetaryDecimalSeparator()
 490     {
 491         return monetarySeparator;
 492     }
 493 
 494     /**
 495      * Sets the monetary decimal separator.
 496      *
 497      * @param sep the monetary decimal separator
 498      * @since 1.2
 499      */
 500     public void setMonetaryDecimalSeparator(char sep)
 501     {

 502         monetarySeparator = sep;
 503     }
 504 
<span class="line-removed"> 505     //------------------------------------------------------------</span>
<span class="line-removed"> 506     // BEGIN   Package Private methods ... to be made public later</span>
<span class="line-removed"> 507     //------------------------------------------------------------</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509     /**</span>
<span class="line-removed"> 510      * Returns the character used to separate the mantissa from the exponent.</span>
<span class="line-removed"> 511      */</span>
<span class="line-removed"> 512     char getExponentialSymbol()</span>
<span class="line-removed"> 513     {</span>
<span class="line-removed"> 514         return exponential;</span>
<span class="line-removed"> 515     }</span>
<span class="line-removed"> 516 </span>
 517     /**
 518      * Returns the string used to separate the mantissa from the exponent.
 519      * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
 520      *
 521      * @return the exponent separator string
 522      * @see #setExponentSeparator(java.lang.String)
 523      * @since 1.6
 524      */
 525     public String getExponentSeparator()
 526     {
 527         return exponentialSeparator;
 528     }
 529 
<span class="line-removed"> 530     /**</span>
<span class="line-removed"> 531      * Sets the character used to separate the mantissa from the exponent.</span>
<span class="line-removed"> 532      */</span>
<span class="line-removed"> 533     void setExponentialSymbol(char exp)</span>
<span class="line-removed"> 534     {</span>
<span class="line-removed"> 535         exponential = exp;</span>
<span class="line-removed"> 536     }</span>
<span class="line-removed"> 537 </span>
 538     /**
 539      * Sets the string used to separate the mantissa from the exponent.
 540      * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
 541      *
 542      * @param exp the exponent separator string
<span class="line-modified"> 543      * @exception NullPointerException if &lt;code&gt;exp&lt;/code&gt; is null</span>
 544      * @see #getExponentSeparator()
 545      * @since 1.6
 546      */
 547     public void setExponentSeparator(String exp)
 548     {
 549         if (exp == null) {
 550             throw new NullPointerException();
 551         }

 552         exponentialSeparator = exp;
 553     }
 554 




























































































































































 555 
 556     //------------------------------------------------------------
 557     // END     Package Private methods ... to be made public later
 558     //------------------------------------------------------------
 559 
 560     /**
 561      * Standard override.
 562      */
 563     @Override
 564     public Object clone() {
 565         try {
 566             return (DecimalFormatSymbols)super.clone();
 567             // other fields are bit-copied
 568         } catch (CloneNotSupportedException e) {
 569             throw new InternalError(e);
 570         }
 571     }
 572 
 573     /**
 574      * Override equals.
 575      */
 576     @Override
 577     public boolean equals(Object obj) {
 578         if (obj == null) return false;
 579         if (this == obj) return true;
 580         if (getClass() != obj.getClass()) return false;
 581         DecimalFormatSymbols other = (DecimalFormatSymbols) obj;
 582         return (zeroDigit == other.zeroDigit &amp;&amp;
<span class="line-modified"> 583         groupingSeparator == other.groupingSeparator &amp;&amp;</span>
<span class="line-modified"> 584         decimalSeparator == other.decimalSeparator &amp;&amp;</span>
<span class="line-modified"> 585         percent == other.percent &amp;&amp;</span>
<span class="line-modified"> 586         perMill == other.perMill &amp;&amp;</span>
<span class="line-modified"> 587         digit == other.digit &amp;&amp;</span>
<span class="line-modified"> 588         minusSign == other.minusSign &amp;&amp;</span>
<span class="line-modified"> 589         patternSeparator == other.patternSeparator &amp;&amp;</span>
<span class="line-modified"> 590         infinity.equals(other.infinity) &amp;&amp;</span>
<span class="line-modified"> 591         NaN.equals(other.NaN) &amp;&amp;</span>
<span class="line-modified"> 592         getCurrencySymbol().equals(other.getCurrencySymbol()) &amp;&amp; // possible currency init occurs here</span>
<span class="line-modified"> 593         intlCurrencySymbol.equals(other.intlCurrencySymbol) &amp;&amp;</span>
<span class="line-modified"> 594         currency == other.currency &amp;&amp;</span>
<span class="line-modified"> 595         monetarySeparator == other.monetarySeparator &amp;&amp;</span>
<span class="line-modified"> 596         exponentialSeparator.equals(other.exponentialSeparator) &amp;&amp;</span>
<span class="line-modified"> 597         locale.equals(other.locale));</span>




 598     }
 599 
 600     /**
 601      * Override hashCode.
 602      */

 603     @Override
 604     public int hashCode() {
<span class="line-modified"> 605             int result = zeroDigit;</span>
<span class="line-modified"> 606             result = result * 37 + groupingSeparator;</span>
<span class="line-modified"> 607             result = result * 37 + decimalSeparator;</span>
<span class="line-modified"> 608             return result;</span>




















 609     }
 610 
 611     /**
 612      * Initializes the symbols from the FormatData resource bundle.
 613      */
 614     private void initialize( Locale locale ) {
 615         this.locale = locale;
 616 
 617         // check for region override
 618         Locale override = locale.getUnicodeLocaleType(&quot;nu&quot;) == null ?
 619             CalendarDataUtility.findRegionOverride(locale) :
 620             locale;
 621 
 622         // get resource bundle data
 623         LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, override);
 624         // Avoid potential recursions
 625         if (!(adapter instanceof ResourceBundleBasedAdapter)) {
 626             adapter = LocaleProviderAdapter.getResourceBundleBased();
 627         }
 628         Object[] data = adapter.getLocaleResources(override).getDecimalFormatSymbolsData();
 629         String[] numberElements = (String[]) data[0];
 630 
 631         decimalSeparator = numberElements[0].charAt(0);
 632         groupingSeparator = numberElements[1].charAt(0);
 633         patternSeparator = numberElements[2].charAt(0);
<span class="line-modified"> 634         percent = numberElements[3].charAt(0);</span>

 635         zeroDigit = numberElements[4].charAt(0); //different for Arabic,etc.
 636         digit = numberElements[5].charAt(0);
<span class="line-modified"> 637         minusSign = numberElements[6].charAt(0);</span>

 638         exponential = numberElements[7].charAt(0);
 639         exponentialSeparator = numberElements[7]; //string representation new since 1.6
<span class="line-modified"> 640         perMill = numberElements[8].charAt(0);</span>

 641         infinity  = numberElements[9];
 642         NaN = numberElements[10];
 643 






 644         // maybe filled with previously cached values, or null.
 645         intlCurrencySymbol = (String) data[1];
 646         currencySymbol = (String) data[2];

 647 
<span class="line-modified"> 648         // Currently the monetary decimal separator is the same as the</span>
<span class="line-modified"> 649         // standard decimal separator for all locales that we support.</span>
<span class="line-modified"> 650         // If that changes, add a new entry to NumberElements.</span>
<span class="line-modified"> 651         monetarySeparator = decimalSeparator;</span>




 652     }
 653 
 654     /**
 655      * Lazy initialization for currency related fields
 656      */
 657     private void initializeCurrency(Locale locale) {
 658         if (currencyInitialized) {
 659             return;
 660         }
 661 
 662         // Try to obtain the currency used in the locale&#39;s country.
 663         // Check for empty country string separately because it&#39;s a valid
 664         // country ID for Locale (and used for the C locale), but not a valid
 665         // ISO 3166 country code, and exceptions are expensive.
 666         if (!locale.getCountry().isEmpty()) {
 667             try {
 668                 currency = Currency.getInstance(locale);
 669             } catch (IllegalArgumentException e) {
 670                 // use default values below for compatibility
 671             }
</pre>
<hr />
<pre>
 687                 currencySymbol = currency.getSymbol(locale);
 688                 data[1] = intlCurrencySymbol;
 689                 data[2] = currencySymbol;
 690             }
 691         } else {
 692             // default values
 693             intlCurrencySymbol = &quot;XXX&quot;;
 694             try {
 695                 currency = Currency.getInstance(intlCurrencySymbol);
 696             } catch (IllegalArgumentException e) {
 697             }
 698             currencySymbol = &quot;\u00A4&quot;;
 699         }
 700 
 701         currencyInitialized = true;
 702     }
 703 
 704     /**
 705      * Reads the default serializable fields, provides default values for objects
 706      * in older serial versions, and initializes non-serializable fields.
<span class="line-modified"> 707      * If &lt;code&gt;serialVersionOnStream&lt;/code&gt;</span>
<span class="line-modified"> 708      * is less than 1, initializes &lt;code&gt;monetarySeparator&lt;/code&gt; to be</span>
<span class="line-modified"> 709      * the same as &lt;code&gt;decimalSeparator&lt;/code&gt; and &lt;code&gt;exponential&lt;/code&gt;</span>
 710      * to be &#39;E&#39;.
<span class="line-modified"> 711      * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 2,</span>
<span class="line-modified"> 712      * initializes &lt;code&gt;locale&lt;/code&gt;to the root locale, and initializes</span>
<span class="line-modified"> 713      * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 3, it initializes</span>
<span class="line-modified"> 714      * &lt;code&gt;exponentialSeparator&lt;/code&gt; using &lt;code&gt;exponential&lt;/code&gt;.</span>
<span class="line-modified"> 715      * Sets &lt;code&gt;serialVersionOnStream&lt;/code&gt; back to the maximum allowed value so that</span>






 716      * default serialization will work properly if this object is streamed out again.
 717      * Initializes the currency from the intlCurrencySymbol field.
 718      *


 719      * @since  1.1.6
 720      */

 721     private void readObject(ObjectInputStream stream)
 722             throws IOException, ClassNotFoundException {
 723         stream.defaultReadObject();
 724         if (serialVersionOnStream &lt; 1) {
 725             // Didn&#39;t have monetarySeparator or exponential field;
 726             // use defaults.
 727             monetarySeparator = decimalSeparator;
 728             exponential       = &#39;E&#39;;
 729         }
 730         if (serialVersionOnStream &lt; 2) {
 731             // didn&#39;t have locale; use root locale
 732             locale = Locale.ROOT;
 733         }
 734         if (serialVersionOnStream &lt; 3) {
 735             // didn&#39;t have exponentialSeparator. Create one using exponential
 736             exponentialSeparator = Character.toString(exponential);
 737         }





















 738         serialVersionOnStream = currentSerialVersion;
 739 
 740         if (intlCurrencySymbol != null) {
 741             try {
 742                  currency = Currency.getInstance(intlCurrencySymbol);
 743             } catch (IllegalArgumentException e) {
 744             }
 745             currencyInitialized = true;
 746         }
 747     }
 748 
 749     /**
 750      * Character used for zero.
 751      *
 752      * @serial
 753      * @see #getZeroDigit
 754      */
 755     private  char    zeroDigit;
 756 
 757     /**
<span class="line-modified"> 758      * Character used for thousands separator.</span>
 759      *
 760      * @serial
 761      * @see #getGroupingSeparator
 762      */
 763     private  char    groupingSeparator;
 764 
 765     /**
 766      * Character used for decimal sign.
 767      *
 768      * @serial
 769      * @see #getDecimalSeparator
 770      */
 771     private  char    decimalSeparator;
 772 
 773     /**
 774      * Character used for per mille sign.
 775      *
 776      * @serial
 777      * @see #getPerMill
 778      */
</pre>
<hr />
<pre>
 845      */
 846     private  char    monetarySeparator; // Field new in JDK 1.1.6
 847 
 848     /**
 849      * The character used to distinguish the exponent in a number formatted
 850      * in exponential notation, e.g. &#39;E&#39; for a number such as &quot;1.23E45&quot;.
 851      * &lt;p&gt;
 852      * Note that the public API provides no way to set this field,
 853      * even though it is supported by the implementation and the stream format.
 854      * The intent is that this will be added to the API in the future.
 855      *
 856      * @serial
 857      * @since  1.1.6
 858      */
 859     private  char    exponential;       // Field new in JDK 1.1.6
 860 
 861     /**
 862      * The string used to separate the mantissa from the exponent.
 863      * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
 864      * &lt;p&gt;
<span class="line-modified"> 865      * If both &lt;code&gt;exponential&lt;/code&gt; and &lt;code&gt;exponentialSeparator&lt;/code&gt;</span>
<span class="line-modified"> 866      * exist, this &lt;code&gt;exponentialSeparator&lt;/code&gt; has the precedence.</span>
 867      *
 868      * @serial
 869      * @since 1.6
 870      */
 871     private  String    exponentialSeparator;       // Field new in JDK 1.6
 872 
 873     /**
 874      * The locale of these currency format symbols.
 875      *
 876      * @serial
 877      * @since 1.4
 878      */
 879     private Locale locale;
 880 









































 881     // currency; only the ISO code is serialized.
 882     private transient Currency currency;
 883     private transient volatile boolean currencyInitialized;
 884 
 885     // Proclaim JDK 1.1 FCS compatibility

 886     static final long serialVersionUID = 5772796243397350300L;
 887 
 888     // The internal serial version which says which version was written
 889     // - 0 (default) for version up to JDK 1.1.5
 890     // - 1 for version from JDK 1.1.6, which includes two new fields:
 891     //     monetarySeparator and exponential.
 892     // - 2 for version from J2SE 1.4, which includes locale field.
 893     // - 3 for version from J2SE 1.6, which includes exponentialSeparator field.
<span class="line-modified"> 894     private static final int currentSerialVersion = 3;</span>



 895 
 896     /**
<span class="line-modified"> 897      * Describes the version of &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; present on the stream.</span>
 898      * Possible values are:
 899      * &lt;ul&gt;
 900      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): versions prior to JDK 1.1.6.
 901      *
 902      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: Versions written by JDK 1.1.6 or later, which include
<span class="line-modified"> 903      *      two new fields: &lt;code&gt;monetarySeparator&lt;/code&gt; and &lt;code&gt;exponential&lt;/code&gt;.</span>
 904      * &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: Versions written by J2SE 1.4 or later, which include a
<span class="line-modified"> 905      *      new &lt;code&gt;locale&lt;/code&gt; field.</span>
 906      * &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: Versions written by J2SE 1.6 or later, which include a
<span class="line-modified"> 907      *      new &lt;code&gt;exponentialSeparator&lt;/code&gt; field.</span>
<span class="line-modified"> 908      * &lt;/ul&gt;</span>
<span class="line-modified"> 909      * When streaming out a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt;, the most recent format</span>
<span class="line-modified"> 910      * (corresponding to the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;)</span>





 911      * is always written.
 912      *
 913      * @serial
 914      * @since  1.1.6
 915      */
 916     private int serialVersionOnStream = currentSerialVersion;
 917 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
  28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
  29  *
  30  *   The original version of this source code and documentation is copyrighted
  31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
  32  * materials are provided under terms of a License Agreement between Taligent
  33  * and Sun. This technology is protected by multiple US and International
  34  * patents. This notice and attribution to Taligent may not be removed.
  35  *   Taligent is a registered trademark of Taligent, Inc.
  36  *
  37  */
  38 
  39 package java.text;
  40 
<span class="line-added">  41 import java.io.InvalidObjectException;</span>
  42 import java.io.IOException;
  43 import java.io.ObjectInputStream;
  44 import java.io.Serializable;
  45 import java.text.spi.DecimalFormatSymbolsProvider;
  46 import java.util.Currency;
  47 import java.util.Locale;
<span class="line-added">  48 import java.util.Objects;</span>
  49 import sun.util.locale.provider.CalendarDataUtility;
  50 import sun.util.locale.provider.LocaleProviderAdapter;
  51 import sun.util.locale.provider.LocaleServiceProviderPool;
  52 import sun.util.locale.provider.ResourceBundleBasedAdapter;
  53 
  54 /**
  55  * This class represents the set of symbols (such as the decimal separator,
<span class="line-modified">  56  * the grouping separator, and so on) needed by {@code DecimalFormat}</span>
<span class="line-modified">  57  * to format numbers. {@code DecimalFormat} creates for itself an instance of</span>
<span class="line-modified">  58  * {@code DecimalFormatSymbols} from its locale data.  If you need to change any</span>
<span class="line-modified">  59  * of these symbols, you can get the {@code DecimalFormatSymbols} object from</span>
<span class="line-modified">  60  * your {@code DecimalFormat} and modify it.</span>
  61  *
  62  * &lt;p&gt;If the locale contains &quot;rg&quot; (region override)
  63  * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
  64  * the symbols are overridden for the designated region.
  65  *
  66  * @see          java.util.Locale
  67  * @see          DecimalFormat
  68  * @author       Mark Davis
  69  * @author       Alan Liu
  70  * @since 1.1
  71  */
  72 
  73 public class DecimalFormatSymbols implements Cloneable, Serializable {
  74 
  75     /**
  76      * Create a DecimalFormatSymbols object for the default
  77      * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
  78      * This constructor can only construct instances for the locales
  79      * supported by the Java runtime environment, not for those
  80      * supported by installed
</pre>
<hr />
<pre>
  92     }
  93 
  94     /**
  95      * Create a DecimalFormatSymbols object for the given locale.
  96      * This constructor can only construct instances for the locales
  97      * supported by the Java runtime environment, not for those
  98      * supported by installed
  99      * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
 100      * implementations. For full locale coverage, use the
 101      * {@link #getInstance(Locale) getInstance} method.
 102      * If the specified locale contains the {@link java.util.Locale#UNICODE_LOCALE_EXTENSION}
 103      * for the numbering system, the instance is initialized with the specified numbering
 104      * system if the JRE implementation supports it. For example,
 105      * &lt;pre&gt;
 106      * NumberFormat.getNumberInstance(Locale.forLanguageTag(&quot;th-TH-u-nu-thai&quot;))
 107      * &lt;/pre&gt;
 108      * This may return a {@code NumberFormat} instance with the Thai numbering system,
 109      * instead of the Latin numbering system.
 110      *
 111      * @param locale the desired locale
<span class="line-modified"> 112      * @throws    NullPointerException if {@code locale} is null</span>
 113      */
 114     public DecimalFormatSymbols( Locale locale ) {
 115         initialize( locale );
 116     }
 117 
 118     /**
 119      * Returns an array of all locales for which the
<span class="line-modified"> 120      * {@code getInstance} methods of this class can return</span>
 121      * localized instances.
 122      * The returned array represents the union of locales supported by the Java
 123      * runtime and by installed
 124      * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
<span class="line-modified"> 125      * implementations.  It must contain at least a {@code Locale}</span>
 126      * instance equal to {@link java.util.Locale#US Locale.US}.
 127      *
 128      * @return an array of locales for which localized
<span class="line-modified"> 129      *         {@code DecimalFormatSymbols} instances are available.</span>
 130      * @since 1.6
 131      */
 132     public static Locale[] getAvailableLocales() {
 133         LocaleServiceProviderPool pool =
 134             LocaleServiceProviderPool.getPool(DecimalFormatSymbolsProvider.class);
 135         return pool.getAvailableLocales();
 136     }
 137 
 138     /**
<span class="line-modified"> 139      * Gets the {@code DecimalFormatSymbols} instance for the default</span>
<span class="line-modified"> 140      * locale.  This method provides access to {@code DecimalFormatSymbols}</span>
 141      * instances for locales supported by the Java runtime itself as well
 142      * as for those supported by installed
 143      * {@link java.text.spi.DecimalFormatSymbolsProvider
 144      * DecimalFormatSymbolsProvider} implementations.
 145      * &lt;p&gt;This is equivalent to calling
 146      * {@link #getInstance(Locale)
 147      *     getInstance(Locale.getDefault(Locale.Category.FORMAT))}.
 148      * @see java.util.Locale#getDefault(java.util.Locale.Category)
 149      * @see java.util.Locale.Category#FORMAT
<span class="line-modified"> 150      * @return a {@code DecimalFormatSymbols} instance.</span>
 151      * @since 1.6
 152      */
 153     public static final DecimalFormatSymbols getInstance() {
 154         return getInstance(Locale.getDefault(Locale.Category.FORMAT));
 155     }
 156 
 157     /**
<span class="line-modified"> 158      * Gets the {@code DecimalFormatSymbols} instance for the specified</span>
<span class="line-modified"> 159      * locale.  This method provides access to {@code DecimalFormatSymbols}</span>
 160      * instances for locales supported by the Java runtime itself as well
 161      * as for those supported by installed
 162      * {@link java.text.spi.DecimalFormatSymbolsProvider
 163      * DecimalFormatSymbolsProvider} implementations.
 164      * If the specified locale contains the {@link java.util.Locale#UNICODE_LOCALE_EXTENSION}
 165      * for the numbering system, the instance is initialized with the specified numbering
 166      * system if the JRE implementation supports it. For example,
 167      * &lt;pre&gt;
 168      * NumberFormat.getNumberInstance(Locale.forLanguageTag(&quot;th-TH-u-nu-thai&quot;))
 169      * &lt;/pre&gt;
 170      * This may return a {@code NumberFormat} instance with the Thai numbering system,
 171      * instead of the Latin numbering system.
 172      *
 173      * @param locale the desired locale.
<span class="line-modified"> 174      * @return a {@code DecimalFormatSymbols} instance.</span>
<span class="line-modified"> 175      * @throws    NullPointerException if {@code locale} is null</span>
 176      * @since 1.6
 177      */
 178     public static final DecimalFormatSymbols getInstance(Locale locale) {
 179         LocaleProviderAdapter adapter;
 180         adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, locale);
 181         DecimalFormatSymbolsProvider provider = adapter.getDecimalFormatSymbolsProvider();
 182         DecimalFormatSymbols dfsyms = provider.getInstance(locale);
 183         if (dfsyms == null) {
 184             provider = LocaleProviderAdapter.forJRE().getDecimalFormatSymbolsProvider();
 185             dfsyms = provider.getInstance(locale);
 186         }
 187         return dfsyms;
 188     }
 189 
 190     /**
 191      * Gets the character used for zero. Different for Arabic, etc.
 192      *
 193      * @return the character used for zero
 194      */
 195     public char getZeroDigit() {
 196         return zeroDigit;
 197     }
 198 
 199     /**
 200      * Sets the character used for zero. Different for Arabic, etc.
 201      *
 202      * @param zeroDigit the character used for zero
 203      */
 204     public void setZeroDigit(char zeroDigit) {
<span class="line-added"> 205         hashCode = 0;</span>
 206         this.zeroDigit = zeroDigit;
 207     }
 208 
 209     /**
<span class="line-modified"> 210      * Gets the character used for grouping separator. Different for French, etc.</span>
 211      *
 212      * @return the grouping separator
 213      */
 214     public char getGroupingSeparator() {
 215         return groupingSeparator;
 216     }
 217 
 218     /**
<span class="line-modified"> 219      * Sets the character used for grouping separator. Different for French, etc.</span>
 220      *
 221      * @param groupingSeparator the grouping separator
 222      */
 223     public void setGroupingSeparator(char groupingSeparator) {
<span class="line-added"> 224         hashCode = 0;</span>
 225         this.groupingSeparator = groupingSeparator;
 226     }
 227 
 228     /**
 229      * Gets the character used for decimal sign. Different for French, etc.
 230      *
 231      * @return the character used for decimal sign
 232      */
 233     public char getDecimalSeparator() {
 234         return decimalSeparator;
 235     }
 236 
 237     /**
 238      * Sets the character used for decimal sign. Different for French, etc.
 239      *
 240      * @param decimalSeparator the character used for decimal sign
 241      */
 242     public void setDecimalSeparator(char decimalSeparator) {
<span class="line-added"> 243         hashCode = 0;</span>
 244         this.decimalSeparator = decimalSeparator;
 245     }
 246 
 247     /**
 248      * Gets the character used for per mille sign. Different for Arabic, etc.
 249      *
 250      * @return the character used for per mille sign
 251      */
 252     public char getPerMill() {
 253         return perMill;
 254     }
 255 
 256     /**
 257      * Sets the character used for per mille sign. Different for Arabic, etc.
 258      *
 259      * @param perMill the character used for per mille sign
 260      */
 261     public void setPerMill(char perMill) {
<span class="line-added"> 262         hashCode = 0;</span>
 263         this.perMill = perMill;
<span class="line-added"> 264         this.perMillText = Character.toString(perMill);</span>
 265     }
 266 
 267     /**
 268      * Gets the character used for percent sign. Different for Arabic, etc.
 269      *
 270      * @return the character used for percent sign
 271      */
 272     public char getPercent() {
 273         return percent;
 274     }
 275 
 276     /**
 277      * Sets the character used for percent sign. Different for Arabic, etc.
 278      *
 279      * @param percent the character used for percent sign
 280      */
 281     public void setPercent(char percent) {
<span class="line-added"> 282         hashCode = 0;</span>
 283         this.percent = percent;
<span class="line-added"> 284         this.percentText = Character.toString(percent);</span>
 285     }
 286 
 287     /**
 288      * Gets the character used for a digit in a pattern.
 289      *
 290      * @return the character used for a digit in a pattern
 291      */
 292     public char getDigit() {
 293         return digit;
 294     }
 295 
 296     /**
 297      * Sets the character used for a digit in a pattern.
 298      *
 299      * @param digit the character used for a digit in a pattern
 300      */
 301     public void setDigit(char digit) {
<span class="line-added"> 302         hashCode = 0;</span>
 303         this.digit = digit;
 304     }
 305 
 306     /**
 307      * Gets the character used to separate positive and negative subpatterns
 308      * in a pattern.
 309      *
 310      * @return the pattern separator
 311      */
 312     public char getPatternSeparator() {
 313         return patternSeparator;
 314     }
 315 
 316     /**
 317      * Sets the character used to separate positive and negative subpatterns
 318      * in a pattern.
 319      *
 320      * @param patternSeparator the pattern separator
 321      */
 322     public void setPatternSeparator(char patternSeparator) {
<span class="line-added"> 323         hashCode = 0;</span>
 324         this.patternSeparator = patternSeparator;
 325     }
 326 
 327     /**
 328      * Gets the string used to represent infinity. Almost always left
 329      * unchanged.
 330      *
 331      * @return the string representing infinity
 332      */
 333     public String getInfinity() {
 334         return infinity;
 335     }
 336 
 337     /**
 338      * Sets the string used to represent infinity. Almost always left
 339      * unchanged.
 340      *
 341      * @param infinity the string representing infinity
 342      */
 343     public void setInfinity(String infinity) {
<span class="line-added"> 344         hashCode = 0;</span>
 345         this.infinity = infinity;
 346     }
 347 
 348     /**
 349      * Gets the string used to represent &quot;not a number&quot;. Almost always left
 350      * unchanged.
 351      *
 352      * @return the string representing &quot;not a number&quot;
 353      */
 354     public String getNaN() {
 355         return NaN;
 356     }
 357 
 358     /**
 359      * Sets the string used to represent &quot;not a number&quot;. Almost always left
 360      * unchanged.
 361      *
 362      * @param NaN the string representing &quot;not a number&quot;
 363      */
 364     public void setNaN(String NaN) {
<span class="line-added"> 365         hashCode = 0;</span>
 366         this.NaN = NaN;
 367     }
 368 
 369     /**
 370      * Gets the character used to represent minus sign. If no explicit
 371      * negative format is specified, one is formed by prefixing
 372      * minusSign to the positive format.
 373      *
 374      * @return the character representing minus sign
 375      */
 376     public char getMinusSign() {
 377         return minusSign;
 378     }
 379 
 380     /**
 381      * Sets the character used to represent minus sign. If no explicit
 382      * negative format is specified, one is formed by prefixing
 383      * minusSign to the positive format.
 384      *
 385      * @param minusSign the character representing minus sign
 386      */
 387     public void setMinusSign(char minusSign) {
<span class="line-added"> 388         hashCode = 0;</span>
 389         this.minusSign = minusSign;
<span class="line-added"> 390         this.minusSignText = Character.toString(minusSign);</span>
 391     }
 392 
 393     /**
 394      * Returns the currency symbol for the currency of these
 395      * DecimalFormatSymbols in their locale.
 396      *
 397      * @return the currency symbol
 398      * @since 1.2
 399      */
 400     public String getCurrencySymbol()
 401     {
 402         initializeCurrency(locale);
 403         return currencySymbol;
 404     }
 405 
 406     /**
 407      * Sets the currency symbol for the currency of these
 408      * DecimalFormatSymbols in their locale.
 409      *
 410      * @param currency the currency symbol
 411      * @since 1.2
 412      */
 413     public void setCurrencySymbol(String currency)
 414     {
 415         initializeCurrency(locale);
<span class="line-added"> 416         hashCode = 0;</span>
 417         currencySymbol = currency;
 418     }
 419 
 420     /**
 421      * Returns the ISO 4217 currency code of the currency of these
 422      * DecimalFormatSymbols.
 423      *
 424      * @return the currency code
 425      * @since 1.2
 426      */
 427     public String getInternationalCurrencySymbol()
 428     {
 429         initializeCurrency(locale);
 430         return intlCurrencySymbol;
 431     }
 432 
 433     /**
 434      * Sets the ISO 4217 currency code of the currency of these
 435      * DecimalFormatSymbols.
 436      * If the currency code is valid (as defined by
 437      * {@link java.util.Currency#getInstance(java.lang.String) Currency.getInstance}),
 438      * this also sets the currency attribute to the corresponding Currency
 439      * instance and the currency symbol attribute to the currency&#39;s symbol
 440      * in the DecimalFormatSymbols&#39; locale. If the currency code is not valid,
 441      * then the currency attribute is set to null and the currency symbol
 442      * attribute is not modified.
 443      *
 444      * @param currencyCode the currency code
 445      * @see #setCurrency
 446      * @see #setCurrencySymbol
 447      * @since 1.2
 448      */
 449     public void setInternationalCurrencySymbol(String currencyCode)
 450     {
 451         initializeCurrency(locale);
<span class="line-added"> 452         hashCode = 0;</span>
 453         intlCurrencySymbol = currencyCode;
 454         currency = null;
 455         if (currencyCode != null) {
 456             try {
 457                 currency = Currency.getInstance(currencyCode);
 458                 currencySymbol = currency.getSymbol();
 459             } catch (IllegalArgumentException e) {
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * Gets the currency of these DecimalFormatSymbols. May be null if the
 466      * currency symbol attribute was previously set to a value that&#39;s not
 467      * a valid ISO 4217 currency code.
 468      *
 469      * @return the currency used, or null
 470      * @since 1.4
 471      */
 472     public Currency getCurrency() {
 473         initializeCurrency(locale);
 474         return currency;
 475     }
 476 
 477     /**
 478      * Sets the currency of these DecimalFormatSymbols.
 479      * This also sets the currency symbol attribute to the currency&#39;s symbol
 480      * in the DecimalFormatSymbols&#39; locale, and the international currency
 481      * symbol attribute to the currency&#39;s ISO 4217 currency code.
 482      *
 483      * @param currency the new currency to be used
<span class="line-modified"> 484      * @throws    NullPointerException if {@code currency} is null</span>
 485      * @since 1.4
 486      * @see #setCurrencySymbol
 487      * @see #setInternationalCurrencySymbol
 488      */
 489     public void setCurrency(Currency currency) {
 490         if (currency == null) {
 491             throw new NullPointerException();
 492         }
 493         initializeCurrency(locale);
<span class="line-added"> 494         hashCode = 0;</span>
 495         this.currency = currency;
 496         intlCurrencySymbol = currency.getCurrencyCode();
 497         currencySymbol = currency.getSymbol(locale);
 498     }
 499 
 500 
 501     /**
 502      * Returns the monetary decimal separator.
 503      *
 504      * @return the monetary decimal separator
 505      * @since 1.2
 506      */
 507     public char getMonetaryDecimalSeparator()
 508     {
 509         return monetarySeparator;
 510     }
 511 
 512     /**
 513      * Sets the monetary decimal separator.
 514      *
 515      * @param sep the monetary decimal separator
 516      * @since 1.2
 517      */
 518     public void setMonetaryDecimalSeparator(char sep)
 519     {
<span class="line-added"> 520         hashCode = 0;</span>
 521         monetarySeparator = sep;
 522     }
 523 












 524     /**
 525      * Returns the string used to separate the mantissa from the exponent.
 526      * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
 527      *
 528      * @return the exponent separator string
 529      * @see #setExponentSeparator(java.lang.String)
 530      * @since 1.6
 531      */
 532     public String getExponentSeparator()
 533     {
 534         return exponentialSeparator;
 535     }
 536 








 537     /**
 538      * Sets the string used to separate the mantissa from the exponent.
 539      * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
 540      *
 541      * @param exp the exponent separator string
<span class="line-modified"> 542      * @throws    NullPointerException if {@code exp} is null</span>
 543      * @see #getExponentSeparator()
 544      * @since 1.6
 545      */
 546     public void setExponentSeparator(String exp)
 547     {
 548         if (exp == null) {
 549             throw new NullPointerException();
 550         }
<span class="line-added"> 551         hashCode = 0;</span>
 552         exponentialSeparator = exp;
 553     }
 554 
<span class="line-added"> 555     /**</span>
<span class="line-added"> 556      * Gets the character used for grouping separator for currencies.</span>
<span class="line-added"> 557      * May be different from {@code grouping separator} in some locales,</span>
<span class="line-added"> 558      * e.g, German in Austria.</span>
<span class="line-added"> 559      *</span>
<span class="line-added"> 560      * @return the monetary grouping separator</span>
<span class="line-added"> 561      * @since 15</span>
<span class="line-added"> 562      */</span>
<span class="line-added"> 563     public char getMonetaryGroupingSeparator() {</span>
<span class="line-added"> 564         return monetaryGroupingSeparator;</span>
<span class="line-added"> 565     }</span>
<span class="line-added"> 566 </span>
<span class="line-added"> 567     /**</span>
<span class="line-added"> 568      * Sets the character used for grouping separator for currencies.</span>
<span class="line-added"> 569      * Invocation of this method will not affect the normal</span>
<span class="line-added"> 570      * {@code grouping separator}.</span>
<span class="line-added"> 571      *</span>
<span class="line-added"> 572      * @param monetaryGroupingSeparator the monetary grouping separator</span>
<span class="line-added"> 573      * @see #setGroupingSeparator(char)</span>
<span class="line-added"> 574      * @since 15</span>
<span class="line-added"> 575      */</span>
<span class="line-added"> 576     public void setMonetaryGroupingSeparator(char monetaryGroupingSeparator)</span>
<span class="line-added"> 577     {</span>
<span class="line-added"> 578         hashCode = 0;</span>
<span class="line-added"> 579         this.monetaryGroupingSeparator = monetaryGroupingSeparator;</span>
<span class="line-added"> 580     }</span>
<span class="line-added"> 581 </span>
<span class="line-added"> 582     //------------------------------------------------------------</span>
<span class="line-added"> 583     // BEGIN   Package Private methods ... to be made public later</span>
<span class="line-added"> 584     //------------------------------------------------------------</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586     /**</span>
<span class="line-added"> 587      * Returns the character used to separate the mantissa from the exponent.</span>
<span class="line-added"> 588      */</span>
<span class="line-added"> 589     char getExponentialSymbol()</span>
<span class="line-added"> 590     {</span>
<span class="line-added"> 591         return exponential;</span>
<span class="line-added"> 592     }</span>
<span class="line-added"> 593 </span>
<span class="line-added"> 594     /**</span>
<span class="line-added"> 595      * Sets the character used to separate the mantissa from the exponent.</span>
<span class="line-added"> 596      */</span>
<span class="line-added"> 597     void setExponentialSymbol(char exp)</span>
<span class="line-added"> 598     {</span>
<span class="line-added"> 599         exponential = exp;</span>
<span class="line-added"> 600     }</span>
<span class="line-added"> 601 </span>
<span class="line-added"> 602     /**</span>
<span class="line-added"> 603      * Gets the string used for per mille sign. Different for Arabic, etc.</span>
<span class="line-added"> 604      *</span>
<span class="line-added"> 605      * @return the string used for per mille sign</span>
<span class="line-added"> 606      * @since 13</span>
<span class="line-added"> 607      */</span>
<span class="line-added"> 608     String getPerMillText() {</span>
<span class="line-added"> 609         return perMillText;</span>
<span class="line-added"> 610     }</span>
<span class="line-added"> 611 </span>
<span class="line-added"> 612     /**</span>
<span class="line-added"> 613      * Sets the string used for per mille sign. Different for Arabic, etc.</span>
<span class="line-added"> 614      *</span>
<span class="line-added"> 615      * Setting the {@code perMillText} affects the return value of</span>
<span class="line-added"> 616      * {@link #getPerMill()}, in which the first non-format character of</span>
<span class="line-added"> 617      * {@code perMillText} is returned.</span>
<span class="line-added"> 618      *</span>
<span class="line-added"> 619      * @param perMillText the string used for per mille sign</span>
<span class="line-added"> 620      * @throws NullPointerException if {@code perMillText} is null</span>
<span class="line-added"> 621      * @throws IllegalArgumentException if {@code perMillText} is an empty string</span>
<span class="line-added"> 622      * @see #getPerMill()</span>
<span class="line-added"> 623      * @see #getPerMillText()</span>
<span class="line-added"> 624      * @since 13</span>
<span class="line-added"> 625      */</span>
<span class="line-added"> 626     void setPerMillText(String perMillText) {</span>
<span class="line-added"> 627         Objects.requireNonNull(perMillText);</span>
<span class="line-added"> 628         if (perMillText.isEmpty()) {</span>
<span class="line-added"> 629             throw new IllegalArgumentException(&quot;Empty argument string&quot;);</span>
<span class="line-added"> 630         }</span>
<span class="line-added"> 631 </span>
<span class="line-added"> 632         hashCode = 0;</span>
<span class="line-added"> 633         this.perMillText = perMillText;</span>
<span class="line-added"> 634         this.perMill = findNonFormatChar(perMillText, &#39;\u2030&#39;);</span>
<span class="line-added"> 635     }</span>
<span class="line-added"> 636 </span>
<span class="line-added"> 637     /**</span>
<span class="line-added"> 638      * Gets the string used for percent sign. Different for Arabic, etc.</span>
<span class="line-added"> 639      *</span>
<span class="line-added"> 640      * @return the string used for percent sign</span>
<span class="line-added"> 641      * @since 13</span>
<span class="line-added"> 642      */</span>
<span class="line-added"> 643     String getPercentText() {</span>
<span class="line-added"> 644         return percentText;</span>
<span class="line-added"> 645     }</span>
<span class="line-added"> 646 </span>
<span class="line-added"> 647     /**</span>
<span class="line-added"> 648      * Sets the string used for percent sign. Different for Arabic, etc.</span>
<span class="line-added"> 649      *</span>
<span class="line-added"> 650      * Setting the {@code percentText} affects the return value of</span>
<span class="line-added"> 651      * {@link #getPercent()}, in which the first non-format character of</span>
<span class="line-added"> 652      * {@code percentText} is returned.</span>
<span class="line-added"> 653      *</span>
<span class="line-added"> 654      * @param percentText the string used for percent sign</span>
<span class="line-added"> 655      * @throws NullPointerException if {@code percentText} is null</span>
<span class="line-added"> 656      * @throws IllegalArgumentException if {@code percentText} is an empty string</span>
<span class="line-added"> 657      * @see #getPercent()</span>
<span class="line-added"> 658      * @see #getPercentText()</span>
<span class="line-added"> 659      * @since 13</span>
<span class="line-added"> 660      */</span>
<span class="line-added"> 661     void setPercentText(String percentText) {</span>
<span class="line-added"> 662         Objects.requireNonNull(percentText);</span>
<span class="line-added"> 663         if (percentText.isEmpty()) {</span>
<span class="line-added"> 664             throw new IllegalArgumentException(&quot;Empty argument string&quot;);</span>
<span class="line-added"> 665         }</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667         hashCode = 0;</span>
<span class="line-added"> 668         this.percentText = percentText;</span>
<span class="line-added"> 669         this.percent = findNonFormatChar(percentText, &#39;%&#39;);</span>
<span class="line-added"> 670     }</span>
<span class="line-added"> 671 </span>
<span class="line-added"> 672     /**</span>
<span class="line-added"> 673      * Gets the string used to represent minus sign. If no explicit</span>
<span class="line-added"> 674      * negative format is specified, one is formed by prefixing</span>
<span class="line-added"> 675      * minusSignText to the positive format.</span>
<span class="line-added"> 676      *</span>
<span class="line-added"> 677      * @return the string representing minus sign</span>
<span class="line-added"> 678      * @since 13</span>
<span class="line-added"> 679      */</span>
<span class="line-added"> 680     String getMinusSignText() {</span>
<span class="line-added"> 681         return minusSignText;</span>
<span class="line-added"> 682     }</span>
<span class="line-added"> 683 </span>
<span class="line-added"> 684     /**</span>
<span class="line-added"> 685      * Sets the string used to represent minus sign. If no explicit</span>
<span class="line-added"> 686      * negative format is specified, one is formed by prefixing</span>
<span class="line-added"> 687      * minusSignText to the positive format.</span>
<span class="line-added"> 688      *</span>
<span class="line-added"> 689      * Setting the {@code minusSignText} affects the return value of</span>
<span class="line-added"> 690      * {@link #getMinusSign()}, in which the first non-format character of</span>
<span class="line-added"> 691      * {@code minusSignText} is returned.</span>
<span class="line-added"> 692      *</span>
<span class="line-added"> 693      * @param minusSignText the character representing minus sign</span>
<span class="line-added"> 694      * @throws NullPointerException if {@code minusSignText} is null</span>
<span class="line-added"> 695      * @throws IllegalArgumentException if {@code minusSignText} is an</span>
<span class="line-added"> 696      *  empty string</span>
<span class="line-added"> 697      * @see #getMinusSign()</span>
<span class="line-added"> 698      * @see #getMinusSignText()</span>
<span class="line-added"> 699      * @since 13</span>
<span class="line-added"> 700      */</span>
<span class="line-added"> 701     void setMinusSignText(String minusSignText) {</span>
<span class="line-added"> 702         Objects.requireNonNull(minusSignText);</span>
<span class="line-added"> 703         if (minusSignText.isEmpty()) {</span>
<span class="line-added"> 704             throw new IllegalArgumentException(&quot;Empty argument string&quot;);</span>
<span class="line-added"> 705         }</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707         hashCode = 0;</span>
<span class="line-added"> 708         this.minusSignText = minusSignText;</span>
<span class="line-added"> 709         this.minusSign = findNonFormatChar(minusSignText, &#39;-&#39;);</span>
<span class="line-added"> 710     }</span>
 711 
 712     //------------------------------------------------------------
 713     // END     Package Private methods ... to be made public later
 714     //------------------------------------------------------------
 715 
 716     /**
 717      * Standard override.
 718      */
 719     @Override
 720     public Object clone() {
 721         try {
 722             return (DecimalFormatSymbols)super.clone();
 723             // other fields are bit-copied
 724         } catch (CloneNotSupportedException e) {
 725             throw new InternalError(e);
 726         }
 727     }
 728 
 729     /**
 730      * Override equals.
 731      */
 732     @Override
 733     public boolean equals(Object obj) {
 734         if (obj == null) return false;
 735         if (this == obj) return true;
 736         if (getClass() != obj.getClass()) return false;
 737         DecimalFormatSymbols other = (DecimalFormatSymbols) obj;
 738         return (zeroDigit == other.zeroDigit &amp;&amp;
<span class="line-modified"> 739             groupingSeparator == other.groupingSeparator &amp;&amp;</span>
<span class="line-modified"> 740             decimalSeparator == other.decimalSeparator &amp;&amp;</span>
<span class="line-modified"> 741             percent == other.percent &amp;&amp;</span>
<span class="line-modified"> 742             percentText.equals(other.percentText) &amp;&amp;</span>
<span class="line-modified"> 743             perMill == other.perMill &amp;&amp;</span>
<span class="line-modified"> 744             perMillText.equals(other.perMillText) &amp;&amp;</span>
<span class="line-modified"> 745             digit == other.digit &amp;&amp;</span>
<span class="line-modified"> 746             minusSign == other.minusSign &amp;&amp;</span>
<span class="line-modified"> 747             minusSignText.equals(other.minusSignText) &amp;&amp;</span>
<span class="line-modified"> 748             patternSeparator == other.patternSeparator &amp;&amp;</span>
<span class="line-modified"> 749             infinity.equals(other.infinity) &amp;&amp;</span>
<span class="line-modified"> 750             NaN.equals(other.NaN) &amp;&amp;</span>
<span class="line-modified"> 751             getCurrencySymbol().equals(other.getCurrencySymbol()) &amp;&amp; // possible currency init occurs here</span>
<span class="line-modified"> 752             intlCurrencySymbol.equals(other.intlCurrencySymbol) &amp;&amp;</span>
<span class="line-modified"> 753             currency == other.currency &amp;&amp;</span>
<span class="line-added"> 754             monetarySeparator == other.monetarySeparator &amp;&amp;</span>
<span class="line-added"> 755             monetaryGroupingSeparator == other.monetaryGroupingSeparator &amp;&amp;</span>
<span class="line-added"> 756             exponentialSeparator.equals(other.exponentialSeparator) &amp;&amp;</span>
<span class="line-added"> 757             locale.equals(other.locale));</span>
 758     }
 759 
 760     /**
 761      * Override hashCode.
 762      */
<span class="line-added"> 763     private volatile int hashCode;</span>
 764     @Override
 765     public int hashCode() {
<span class="line-modified"> 766         if (hashCode == 0) {</span>
<span class="line-modified"> 767             hashCode = Objects.hash(</span>
<span class="line-modified"> 768                 zeroDigit,</span>
<span class="line-modified"> 769                 groupingSeparator,</span>
<span class="line-added"> 770                 decimalSeparator,</span>
<span class="line-added"> 771                 percent,</span>
<span class="line-added"> 772                 percentText,</span>
<span class="line-added"> 773                 perMill,</span>
<span class="line-added"> 774                 perMillText,</span>
<span class="line-added"> 775                 digit,</span>
<span class="line-added"> 776                 minusSign,</span>
<span class="line-added"> 777                 minusSignText,</span>
<span class="line-added"> 778                 patternSeparator,</span>
<span class="line-added"> 779                 infinity,</span>
<span class="line-added"> 780                 NaN,</span>
<span class="line-added"> 781                 getCurrencySymbol(), // possible currency init occurs here</span>
<span class="line-added"> 782                 intlCurrencySymbol,</span>
<span class="line-added"> 783                 currency,</span>
<span class="line-added"> 784                 monetarySeparator,</span>
<span class="line-added"> 785                 monetaryGroupingSeparator,</span>
<span class="line-added"> 786                 exponentialSeparator,</span>
<span class="line-added"> 787                 locale);</span>
<span class="line-added"> 788         }</span>
<span class="line-added"> 789         return hashCode;</span>
 790     }
 791 
 792     /**
 793      * Initializes the symbols from the FormatData resource bundle.
 794      */
 795     private void initialize( Locale locale ) {
 796         this.locale = locale;
 797 
 798         // check for region override
 799         Locale override = locale.getUnicodeLocaleType(&quot;nu&quot;) == null ?
 800             CalendarDataUtility.findRegionOverride(locale) :
 801             locale;
 802 
 803         // get resource bundle data
 804         LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, override);
 805         // Avoid potential recursions
 806         if (!(adapter instanceof ResourceBundleBasedAdapter)) {
 807             adapter = LocaleProviderAdapter.getResourceBundleBased();
 808         }
 809         Object[] data = adapter.getLocaleResources(override).getDecimalFormatSymbolsData();
 810         String[] numberElements = (String[]) data[0];
 811 
 812         decimalSeparator = numberElements[0].charAt(0);
 813         groupingSeparator = numberElements[1].charAt(0);
 814         patternSeparator = numberElements[2].charAt(0);
<span class="line-modified"> 815         percentText = numberElements[3];</span>
<span class="line-added"> 816         percent = findNonFormatChar(percentText, &#39;%&#39;);</span>
 817         zeroDigit = numberElements[4].charAt(0); //different for Arabic,etc.
 818         digit = numberElements[5].charAt(0);
<span class="line-modified"> 819         minusSignText = numberElements[6];</span>
<span class="line-added"> 820         minusSign = findNonFormatChar(minusSignText, &#39;-&#39;);</span>
 821         exponential = numberElements[7].charAt(0);
 822         exponentialSeparator = numberElements[7]; //string representation new since 1.6
<span class="line-modified"> 823         perMillText = numberElements[8];</span>
<span class="line-added"> 824         perMill = findNonFormatChar(perMillText, &#39;\u2030&#39;);</span>
 825         infinity  = numberElements[9];
 826         NaN = numberElements[10];
 827 
<span class="line-added"> 828         // monetary decimal/grouping separators may be missing in resource bundles</span>
<span class="line-added"> 829         monetarySeparator = numberElements.length &lt; 12 || numberElements[11].isEmpty() ?</span>
<span class="line-added"> 830             decimalSeparator : numberElements[11].charAt(0);</span>
<span class="line-added"> 831         monetaryGroupingSeparator = numberElements.length &lt; 13 || numberElements[12].isEmpty() ?</span>
<span class="line-added"> 832             groupingSeparator : numberElements[12].charAt(0);</span>
<span class="line-added"> 833 </span>
 834         // maybe filled with previously cached values, or null.
 835         intlCurrencySymbol = (String) data[1];
 836         currencySymbol = (String) data[2];
<span class="line-added"> 837     }</span>
 838 
<span class="line-modified"> 839     /**</span>
<span class="line-modified"> 840      * Obtains non-format single character from String</span>
<span class="line-modified"> 841      */</span>
<span class="line-modified"> 842     private char findNonFormatChar(String src, char defChar) {</span>
<span class="line-added"> 843         return (char)src.chars()</span>
<span class="line-added"> 844             .filter(c -&gt; Character.getType(c) != Character.FORMAT)</span>
<span class="line-added"> 845             .findFirst()</span>
<span class="line-added"> 846             .orElse(defChar);</span>
 847     }
 848 
 849     /**
 850      * Lazy initialization for currency related fields
 851      */
 852     private void initializeCurrency(Locale locale) {
 853         if (currencyInitialized) {
 854             return;
 855         }
 856 
 857         // Try to obtain the currency used in the locale&#39;s country.
 858         // Check for empty country string separately because it&#39;s a valid
 859         // country ID for Locale (and used for the C locale), but not a valid
 860         // ISO 3166 country code, and exceptions are expensive.
 861         if (!locale.getCountry().isEmpty()) {
 862             try {
 863                 currency = Currency.getInstance(locale);
 864             } catch (IllegalArgumentException e) {
 865                 // use default values below for compatibility
 866             }
</pre>
<hr />
<pre>
 882                 currencySymbol = currency.getSymbol(locale);
 883                 data[1] = intlCurrencySymbol;
 884                 data[2] = currencySymbol;
 885             }
 886         } else {
 887             // default values
 888             intlCurrencySymbol = &quot;XXX&quot;;
 889             try {
 890                 currency = Currency.getInstance(intlCurrencySymbol);
 891             } catch (IllegalArgumentException e) {
 892             }
 893             currencySymbol = &quot;\u00A4&quot;;
 894         }
 895 
 896         currencyInitialized = true;
 897     }
 898 
 899     /**
 900      * Reads the default serializable fields, provides default values for objects
 901      * in older serial versions, and initializes non-serializable fields.
<span class="line-modified"> 902      * If {@code serialVersionOnStream}</span>
<span class="line-modified"> 903      * is less than 1, initializes {@code monetarySeparator} to be</span>
<span class="line-modified"> 904      * the same as {@code decimalSeparator} and {@code exponential}</span>
 905      * to be &#39;E&#39;.
<span class="line-modified"> 906      * If {@code serialVersionOnStream} is less than 2,</span>
<span class="line-modified"> 907      * initializes {@code locale}to the root locale, and initializes</span>
<span class="line-modified"> 908      * If {@code serialVersionOnStream} is less than 3, it initializes</span>
<span class="line-modified"> 909      * {@code exponentialSeparator} using {@code exponential}.</span>
<span class="line-modified"> 910      * If {@code serialVersionOnStream} is less than 4, it initializes</span>
<span class="line-added"> 911      * {@code perMillText}, {@code percentText}, and</span>
<span class="line-added"> 912      * {@code minusSignText} using {@code perMill}, {@code percent}, and</span>
<span class="line-added"> 913      * {@code minusSign} respectively.</span>
<span class="line-added"> 914      * If {@code serialVersionOnStream} is less than 5, it initializes</span>
<span class="line-added"> 915      * {@code monetaryGroupingSeparator} using {@code groupingSeparator}.</span>
<span class="line-added"> 916      * Sets {@code serialVersionOnStream} back to the maximum allowed value so that</span>
 917      * default serialization will work properly if this object is streamed out again.
 918      * Initializes the currency from the intlCurrencySymbol field.
 919      *
<span class="line-added"> 920      * @throws InvalidObjectException if {@code char} and {@code String}</span>
<span class="line-added"> 921      *      representations of either percent, per mille, and/or minus sign disagree.</span>
 922      * @since  1.1.6
 923      */
<span class="line-added"> 924     @java.io.Serial</span>
 925     private void readObject(ObjectInputStream stream)
 926             throws IOException, ClassNotFoundException {
 927         stream.defaultReadObject();
 928         if (serialVersionOnStream &lt; 1) {
 929             // Didn&#39;t have monetarySeparator or exponential field;
 930             // use defaults.
 931             monetarySeparator = decimalSeparator;
 932             exponential       = &#39;E&#39;;
 933         }
 934         if (serialVersionOnStream &lt; 2) {
 935             // didn&#39;t have locale; use root locale
 936             locale = Locale.ROOT;
 937         }
 938         if (serialVersionOnStream &lt; 3) {
 939             // didn&#39;t have exponentialSeparator. Create one using exponential
 940             exponentialSeparator = Character.toString(exponential);
 941         }
<span class="line-added"> 942         if (serialVersionOnStream &lt; 4) {</span>
<span class="line-added"> 943             // didn&#39;t have perMillText, percentText, and minusSignText.</span>
<span class="line-added"> 944             // Create one using corresponding char variations.</span>
<span class="line-added"> 945             perMillText = Character.toString(perMill);</span>
<span class="line-added"> 946             percentText = Character.toString(percent);</span>
<span class="line-added"> 947             minusSignText = Character.toString(minusSign);</span>
<span class="line-added"> 948         } else {</span>
<span class="line-added"> 949             // Check whether char and text fields agree</span>
<span class="line-added"> 950             if (findNonFormatChar(perMillText, &#39;\uFFFF&#39;) != perMill ||</span>
<span class="line-added"> 951                 findNonFormatChar(percentText, &#39;\uFFFF&#39;) != percent ||</span>
<span class="line-added"> 952                 findNonFormatChar(minusSignText, &#39;\uFFFF&#39;) != minusSign) {</span>
<span class="line-added"> 953                 throw new InvalidObjectException(</span>
<span class="line-added"> 954                     &quot;&#39;char&#39; and &#39;String&#39; representations of either percent, &quot; +</span>
<span class="line-added"> 955                     &quot;per mille, and/or minus sign disagree.&quot;);</span>
<span class="line-added"> 956             }</span>
<span class="line-added"> 957         }</span>
<span class="line-added"> 958         if (serialVersionOnStream &lt; 5) {</span>
<span class="line-added"> 959             // didn&#39;t have monetaryGroupingSeparator. Create one using groupingSeparator</span>
<span class="line-added"> 960             monetaryGroupingSeparator = groupingSeparator;</span>
<span class="line-added"> 961         }</span>
<span class="line-added"> 962 </span>
 963         serialVersionOnStream = currentSerialVersion;
 964 
 965         if (intlCurrencySymbol != null) {
 966             try {
 967                  currency = Currency.getInstance(intlCurrencySymbol);
 968             } catch (IllegalArgumentException e) {
 969             }
 970             currencyInitialized = true;
 971         }
 972     }
 973 
 974     /**
 975      * Character used for zero.
 976      *
 977      * @serial
 978      * @see #getZeroDigit
 979      */
 980     private  char    zeroDigit;
 981 
 982     /**
<span class="line-modified"> 983      * Character used for grouping separator.</span>
 984      *
 985      * @serial
 986      * @see #getGroupingSeparator
 987      */
 988     private  char    groupingSeparator;
 989 
 990     /**
 991      * Character used for decimal sign.
 992      *
 993      * @serial
 994      * @see #getDecimalSeparator
 995      */
 996     private  char    decimalSeparator;
 997 
 998     /**
 999      * Character used for per mille sign.
1000      *
1001      * @serial
1002      * @see #getPerMill
1003      */
</pre>
<hr />
<pre>
1070      */
1071     private  char    monetarySeparator; // Field new in JDK 1.1.6
1072 
1073     /**
1074      * The character used to distinguish the exponent in a number formatted
1075      * in exponential notation, e.g. &#39;E&#39; for a number such as &quot;1.23E45&quot;.
1076      * &lt;p&gt;
1077      * Note that the public API provides no way to set this field,
1078      * even though it is supported by the implementation and the stream format.
1079      * The intent is that this will be added to the API in the future.
1080      *
1081      * @serial
1082      * @since  1.1.6
1083      */
1084     private  char    exponential;       // Field new in JDK 1.1.6
1085 
1086     /**
1087      * The string used to separate the mantissa from the exponent.
1088      * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
1089      * &lt;p&gt;
<span class="line-modified">1090      * If both {@code exponential} and {@code exponentialSeparator}</span>
<span class="line-modified">1091      * exist, this {@code exponentialSeparator} has the precedence.</span>
1092      *
1093      * @serial
1094      * @since 1.6
1095      */
1096     private  String    exponentialSeparator;       // Field new in JDK 1.6
1097 
1098     /**
1099      * The locale of these currency format symbols.
1100      *
1101      * @serial
1102      * @since 1.4
1103      */
1104     private Locale locale;
1105 
<span class="line-added">1106     /**</span>
<span class="line-added">1107      * String representation of per mille sign, which may include</span>
<span class="line-added">1108      * formatting characters, such as BiDi control characters.</span>
<span class="line-added">1109      * The first non-format character of this string is the same as</span>
<span class="line-added">1110      * {@code perMill}.</span>
<span class="line-added">1111      *</span>
<span class="line-added">1112      * @serial</span>
<span class="line-added">1113      * @since 13</span>
<span class="line-added">1114      */</span>
<span class="line-added">1115     private  String perMillText;</span>
<span class="line-added">1116 </span>
<span class="line-added">1117     /**</span>
<span class="line-added">1118      * String representation of percent sign, which may include</span>
<span class="line-added">1119      * formatting characters, such as BiDi control characters.</span>
<span class="line-added">1120      * The first non-format character of this string is the same as</span>
<span class="line-added">1121      * {@code percent}.</span>
<span class="line-added">1122      *</span>
<span class="line-added">1123      * @serial</span>
<span class="line-added">1124      * @since 13</span>
<span class="line-added">1125      */</span>
<span class="line-added">1126     private  String percentText;</span>
<span class="line-added">1127 </span>
<span class="line-added">1128     /**</span>
<span class="line-added">1129      * String representation of minus sign, which may include</span>
<span class="line-added">1130      * formatting characters, such as BiDi control characters.</span>
<span class="line-added">1131      * The first non-format character of this string is the same as</span>
<span class="line-added">1132      * {@code minusSign}.</span>
<span class="line-added">1133      *</span>
<span class="line-added">1134      * @serial</span>
<span class="line-added">1135      * @since 13</span>
<span class="line-added">1136      */</span>
<span class="line-added">1137     private  String minusSignText;</span>
<span class="line-added">1138 </span>
<span class="line-added">1139     /**</span>
<span class="line-added">1140      * The grouping separator used when formatting currency values.</span>
<span class="line-added">1141      *</span>
<span class="line-added">1142      * @serial</span>
<span class="line-added">1143      * @since 15</span>
<span class="line-added">1144      */</span>
<span class="line-added">1145     private  char    monetaryGroupingSeparator;</span>
<span class="line-added">1146 </span>
1147     // currency; only the ISO code is serialized.
1148     private transient Currency currency;
1149     private transient volatile boolean currencyInitialized;
1150 
1151     // Proclaim JDK 1.1 FCS compatibility
<span class="line-added">1152     @java.io.Serial</span>
1153     static final long serialVersionUID = 5772796243397350300L;
1154 
1155     // The internal serial version which says which version was written
1156     // - 0 (default) for version up to JDK 1.1.5
1157     // - 1 for version from JDK 1.1.6, which includes two new fields:
1158     //     monetarySeparator and exponential.
1159     // - 2 for version from J2SE 1.4, which includes locale field.
1160     // - 3 for version from J2SE 1.6, which includes exponentialSeparator field.
<span class="line-modified">1161     // - 4 for version from Java SE 13, which includes perMillText, percentText,</span>
<span class="line-added">1162     //      and minusSignText field.</span>
<span class="line-added">1163     // - 5 for version from Java SE 15, which includes monetaryGroupingSeparator.</span>
<span class="line-added">1164     private static final int currentSerialVersion = 5;</span>
1165 
1166     /**
<span class="line-modified">1167      * Describes the version of {@code DecimalFormatSymbols} present on the stream.</span>
1168      * Possible values are:
1169      * &lt;ul&gt;
1170      * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): versions prior to JDK 1.1.6.
1171      *
1172      * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: Versions written by JDK 1.1.6 or later, which include
<span class="line-modified">1173      *      two new fields: {@code monetarySeparator} and {@code exponential}.</span>
1174      * &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: Versions written by J2SE 1.4 or later, which include a
<span class="line-modified">1175      *      new {@code locale} field.</span>
1176      * &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: Versions written by J2SE 1.6 or later, which include a
<span class="line-modified">1177      *      new {@code exponentialSeparator} field.</span>
<span class="line-modified">1178      * &lt;li&gt;&lt;b&gt;4&lt;/b&gt;: Versions written by Java SE 13 or later, which include</span>
<span class="line-modified">1179      *      new {@code perMillText}, {@code percentText}, and</span>
<span class="line-modified">1180      *      {@code minusSignText} field.</span>
<span class="line-added">1181      * &lt;li&gt;&lt;b&gt;5&lt;/b&gt;: Versions written by Java SE 15 or later, which include</span>
<span class="line-added">1182      *      new {@code monetaryGroupingSeparator} field.</span>
<span class="line-added">1183      * * &lt;/ul&gt;</span>
<span class="line-added">1184      * When streaming out a {@code DecimalFormatSymbols}, the most recent format</span>
<span class="line-added">1185      * (corresponding to the highest allowable {@code serialVersionOnStream})</span>
1186      * is always written.
1187      *
1188      * @serial
1189      * @since  1.1.6
1190      */
1191     private int serialVersionOnStream = currentSerialVersion;
1192 }
</pre>
</td>
</tr>
</table>
<center><a href="DecimalFormat.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="DigitList.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
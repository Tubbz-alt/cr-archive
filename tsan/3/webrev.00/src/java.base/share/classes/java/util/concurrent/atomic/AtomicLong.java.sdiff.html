<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/atomic/AtomicLong.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AtomicInteger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AtomicReference.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/atomic/AtomicLong.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  * This file is available under and governed by the GNU General Public
 27  * License version 2 only, as published by the Free Software Foundation.
 28  * However, the following notice accompanied the original version of this
 29  * file:
 30  *
 31  * Written by Doug Lea with assistance from members of JCP JSR-166
 32  * Expert Group and released to the public domain, as explained at
 33  * http://creativecommons.org/publicdomain/zero/1.0/
 34  */
 35 
 36 package java.util.concurrent.atomic;
 37 
 38 import java.lang.invoke.VarHandle;
 39 import java.util.function.LongBinaryOperator;
 40 import java.util.function.LongUnaryOperator;

 41 
 42 /**
 43  * A {@code long} value that may be updated atomically.  See the
 44  * {@link VarHandle} specification for descriptions of the properties
 45  * of atomic accesses. An {@code AtomicLong} is used in applications
 46  * such as atomically incremented sequence numbers, and cannot be used
 47  * as a replacement for a {@link java.lang.Long}. However, this class
 48  * does extend {@code Number} to allow uniform access by tools and
 49  * utilities that deal with numerically-based classes.
 50  *
 51  * @since 1.5
 52  * @author Doug Lea
 53  */
 54 public class AtomicLong extends Number implements java.io.Serializable {
 55     private static final long serialVersionUID = 1927816293512124184L;
 56 
 57     /**
 58      * Records whether the underlying JVM supports lockless
 59      * compareAndSet for longs. While the intrinsic compareAndSetLong
 60      * method works in either case, some constructions should be
 61      * handled at Java level to avoid locking user-visible locks.
 62      */
 63     static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();
 64 
 65     /**
 66      * Returns whether underlying JVM supports lockless CompareAndSet
 67      * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.
 68      */
 69     private static native boolean VMSupportsCS8();
 70 
 71     /*
 72      * This class intended to be implemented using VarHandles, but there
 73      * are unresolved cyclic startup dependencies.
 74      */
<span class="line-modified"> 75     private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span>
<span class="line-modified"> 76     private static final long VALUE = U.objectFieldOffset(AtomicLong.class, &quot;value&quot;);</span>

 77 
 78     private volatile long value;
 79 
 80     /**
 81      * Creates a new AtomicLong with the given initial value.
 82      *
 83      * @param initialValue the initial value
 84      */
 85     public AtomicLong(long initialValue) {
 86         value = initialValue;
 87     }
 88 
 89     /**
 90      * Creates a new AtomicLong with initial value {@code 0}.
 91      */
 92     public AtomicLong() {
 93     }
 94 
 95     /**
 96      * Returns the current value,
</pre>
<hr />
<pre>
347             if (!haveNext)
348                 next = accumulatorFunction.applyAsLong(prev, x);
349             if (weakCompareAndSetVolatile(prev, next))
350                 return next;
351             haveNext = (prev == (prev = get()));
352         }
353     }
354 
355     /**
356      * Returns the String representation of the current value.
357      * @return the String representation of the current value
358      */
359     public String toString() {
360         return Long.toString(get());
361     }
362 
363     /**
364      * Returns the current value of this {@code AtomicLong} as an {@code int}
365      * after a narrowing primitive conversion,
366      * with memory effects as specified by {@link VarHandle#getVolatile}.
<span class="line-modified">367      * @jls 5.1.3 Narrowing Primitive Conversions</span>
368      */
369     public int intValue() {
370         return (int)get();
371     }
372 
373     /**
374      * Returns the current value of this {@code AtomicLong} as a {@code long},
375      * with memory effects as specified by {@link VarHandle#getVolatile}.
376      * Equivalent to {@link #get()}.
377      */
378     public long longValue() {
379         return get();
380     }
381 
382     /**
383      * Returns the current value of this {@code AtomicLong} as a {@code float}
384      * after a widening primitive conversion,
385      * with memory effects as specified by {@link VarHandle#getVolatile}.
<span class="line-modified">386      * @jls 5.1.2 Widening Primitive Conversions</span>
387      */
388     public float floatValue() {
389         return (float)get();
390     }
391 
392     /**
393      * Returns the current value of this {@code AtomicLong} as a {@code double}
394      * after a widening primitive conversion,
395      * with memory effects as specified by {@link VarHandle#getVolatile}.
<span class="line-modified">396      * @jls 5.1.2 Widening Primitive Conversions</span>
397      */
398     public double doubleValue() {
399         return (double)get();
400     }
401 
402     // jdk9
403 
404     /**
405      * Returns the current value, with memory semantics of reading as if the
406      * variable was declared non-{@code volatile}.
407      *
408      * @return the value
409      * @since 9
410      */
411     public final long getPlain() {
412         return U.getLong(this, VALUE);
413     }
414 
415     /**
416      * Sets the value to {@code newValue}, with memory semantics
</pre>
</td>
<td>
<hr />
<pre>
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  * This file is available under and governed by the GNU General Public
 27  * License version 2 only, as published by the Free Software Foundation.
 28  * However, the following notice accompanied the original version of this
 29  * file:
 30  *
 31  * Written by Doug Lea with assistance from members of JCP JSR-166
 32  * Expert Group and released to the public domain, as explained at
 33  * http://creativecommons.org/publicdomain/zero/1.0/
 34  */
 35 
 36 package java.util.concurrent.atomic;
 37 
 38 import java.lang.invoke.VarHandle;
 39 import java.util.function.LongBinaryOperator;
 40 import java.util.function.LongUnaryOperator;
<span class="line-added"> 41 import jdk.internal.misc.Unsafe;</span>
 42 
 43 /**
 44  * A {@code long} value that may be updated atomically.  See the
 45  * {@link VarHandle} specification for descriptions of the properties
 46  * of atomic accesses. An {@code AtomicLong} is used in applications
 47  * such as atomically incremented sequence numbers, and cannot be used
 48  * as a replacement for a {@link java.lang.Long}. However, this class
 49  * does extend {@code Number} to allow uniform access by tools and
 50  * utilities that deal with numerically-based classes.
 51  *
 52  * @since 1.5
 53  * @author Doug Lea
 54  */
 55 public class AtomicLong extends Number implements java.io.Serializable {
 56     private static final long serialVersionUID = 1927816293512124184L;
 57 
 58     /**
 59      * Records whether the underlying JVM supports lockless
 60      * compareAndSet for longs. While the intrinsic compareAndSetLong
 61      * method works in either case, some constructions should be
 62      * handled at Java level to avoid locking user-visible locks.
 63      */
 64     static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();
 65 
 66     /**
 67      * Returns whether underlying JVM supports lockless CompareAndSet
 68      * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.
 69      */
 70     private static native boolean VMSupportsCS8();
 71 
 72     /*
 73      * This class intended to be implemented using VarHandles, but there
 74      * are unresolved cyclic startup dependencies.
 75      */
<span class="line-modified"> 76     private static final Unsafe U = Unsafe.getUnsafe();</span>
<span class="line-modified"> 77     private static final long VALUE</span>
<span class="line-added"> 78         = U.objectFieldOffset(AtomicLong.class, &quot;value&quot;);</span>
 79 
 80     private volatile long value;
 81 
 82     /**
 83      * Creates a new AtomicLong with the given initial value.
 84      *
 85      * @param initialValue the initial value
 86      */
 87     public AtomicLong(long initialValue) {
 88         value = initialValue;
 89     }
 90 
 91     /**
 92      * Creates a new AtomicLong with initial value {@code 0}.
 93      */
 94     public AtomicLong() {
 95     }
 96 
 97     /**
 98      * Returns the current value,
</pre>
<hr />
<pre>
349             if (!haveNext)
350                 next = accumulatorFunction.applyAsLong(prev, x);
351             if (weakCompareAndSetVolatile(prev, next))
352                 return next;
353             haveNext = (prev == (prev = get()));
354         }
355     }
356 
357     /**
358      * Returns the String representation of the current value.
359      * @return the String representation of the current value
360      */
361     public String toString() {
362         return Long.toString(get());
363     }
364 
365     /**
366      * Returns the current value of this {@code AtomicLong} as an {@code int}
367      * after a narrowing primitive conversion,
368      * with memory effects as specified by {@link VarHandle#getVolatile}.
<span class="line-modified">369      * @jls 5.1.3 Narrowing Primitive Conversion</span>
370      */
371     public int intValue() {
372         return (int)get();
373     }
374 
375     /**
376      * Returns the current value of this {@code AtomicLong} as a {@code long},
377      * with memory effects as specified by {@link VarHandle#getVolatile}.
378      * Equivalent to {@link #get()}.
379      */
380     public long longValue() {
381         return get();
382     }
383 
384     /**
385      * Returns the current value of this {@code AtomicLong} as a {@code float}
386      * after a widening primitive conversion,
387      * with memory effects as specified by {@link VarHandle#getVolatile}.
<span class="line-modified">388      * @jls 5.1.2 Widening Primitive Conversion</span>
389      */
390     public float floatValue() {
391         return (float)get();
392     }
393 
394     /**
395      * Returns the current value of this {@code AtomicLong} as a {@code double}
396      * after a widening primitive conversion,
397      * with memory effects as specified by {@link VarHandle#getVolatile}.
<span class="line-modified">398      * @jls 5.1.2 Widening Primitive Conversion</span>
399      */
400     public double doubleValue() {
401         return (double)get();
402     }
403 
404     // jdk9
405 
406     /**
407      * Returns the current value, with memory semantics of reading as if the
408      * variable was declared non-{@code volatile}.
409      *
410      * @return the value
411      * @since 9
412      */
413     public final long getPlain() {
414         return U.getLong(this, VALUE);
415     }
416 
417     /**
418      * Sets the value to {@code newValue}, with memory semantics
</pre>
</td>
</tr>
</table>
<center><a href="AtomicInteger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AtomicReference.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/zip/ZipOutputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipOutputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.io.OutputStream;
 29 import java.io.IOException;
 30 import java.nio.charset.Charset;
<span class="line-removed"> 31 import java.nio.charset.StandardCharsets;</span>
 32 import java.util.Vector;
 33 import java.util.HashSet;
 34 import static java.util.zip.ZipConstants64.*;
 35 import static java.util.zip.ZipUtils.*;

 36 import sun.security.action.GetPropertyAction;
 37 
 38 /**
 39  * This class implements an output stream filter for writing files in the
 40  * ZIP file format. Includes support for both compressed and uncompressed
 41  * entries.
 42  *
 43  * @author      David Connelly
 44  * @since 1.1
 45  */
<span class="line-modified"> 46 public</span>
<span class="line-removed"> 47 class ZipOutputStream extends DeflaterOutputStream implements ZipConstants {</span>
 48 
 49     /**
 50      * Whether to use ZIP64 for zip files with more than 64k entries.
 51      * Until ZIP64 support in zip implementations is ubiquitous, this
 52      * system property allows the creation of zip files which can be
 53      * read by legacy zip implementations which tolerate &quot;incorrect&quot;
 54      * total entry count fields, such as the ones in jdk6, and even
 55      * some in jdk7.
 56      */
 57     private static final boolean inhibitZip64 =
 58         Boolean.parseBoolean(
 59             GetPropertyAction.privilegedGetProperty(&quot;jdk.util.zip.inhibitZip64&quot;));
 60 
 61     private static class XEntry {
 62         final ZipEntry entry;
 63         final long offset;
 64         public XEntry(ZipEntry entry, long offset) {
 65             this.entry = entry;
 66             this.offset = offset;
 67         }
</pre>
<hr />
<pre>
100 
101     /**
102      * Compression method for uncompressed (STORED) entries.
103      */
104     public static final int STORED = ZipEntry.STORED;
105 
106     /**
107      * Compression method for compressed (DEFLATED) entries.
108      */
109     public static final int DEFLATED = ZipEntry.DEFLATED;
110 
111     /**
112      * Creates a new ZIP output stream.
113      *
114      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used
115      * to encode the entry names and comments.
116      *
117      * @param out the actual output stream
118      */
119     public ZipOutputStream(OutputStream out) {
<span class="line-modified">120         this(out, StandardCharsets.UTF_8);</span>
121     }
122 
123     /**
124      * Creates a new ZIP output stream.
125      *
126      * @param out the actual output stream
127      *
128      * @param charset the {@linkplain java.nio.charset.Charset charset}
129      *                to be used to encode the entry names and comments
130      *
131      * @since 1.7
132      */
133     public ZipOutputStream(OutputStream out, Charset charset) {
134         super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true));
135         if (charset == null)
136             throw new NullPointerException(&quot;charset is null&quot;);
137         this.zc = ZipCoder.get(charset);
138         usesDefaultDeflater = true;
139     }
140 
141     /**
142      * Sets the ZIP file comment.
<span class="line-modified">143      * @param comment the comment string</span>
<span class="line-modified">144      * @exception IllegalArgumentException if the length of the specified</span>
145      *            ZIP file comment is greater than 0xFFFF bytes
146      */
147     public void setComment(String comment) {
148         if (comment != null) {
149             this.comment = zc.getBytes(comment);
150             if (this.comment.length &gt; 0xffff)
151                 throw new IllegalArgumentException(&quot;ZIP file comment too long.&quot;);
152         }
153     }
154 
155     /**
156      * Sets the default compression method for subsequent entries. This
157      * default will be used whenever the compression method is not specified
158      * for an individual ZIP file entry, and is initially set to DEFLATED.
<span class="line-modified">159      * @param method the default compression method</span>
<span class="line-modified">160      * @exception IllegalArgumentException if the specified compression method</span>
161      *            is invalid
162      */
163     public void setMethod(int method) {
164         if (method != DEFLATED &amp;&amp; method != STORED) {
165             throw new IllegalArgumentException(&quot;invalid compression method&quot;);
166         }
167         this.method = method;
168     }
169 
170     /**
171      * Sets the compression level for subsequent entries which are DEFLATED.
172      * The default setting is DEFAULT_COMPRESSION.
<span class="line-modified">173      * @param level the compression level (0-9)</span>
<span class="line-modified">174      * @exception IllegalArgumentException if the compression level is invalid</span>
175      */
176     public void setLevel(int level) {
177         def.setLevel(level);
178     }
179 
180     /**
181      * Begins writing a new ZIP file entry and positions the stream to the
182      * start of the entry data. Closes the current entry if still active.
183      * The default compression method will be used if no compression method
184      * was specified for the entry, and the current time will be used if
185      * the entry has no set modification time.
<span class="line-modified">186      * @param e the ZIP entry to be written</span>
<span class="line-modified">187      * @exception ZipException if a ZIP format error has occurred</span>
<span class="line-modified">188      * @exception IOException if an I/O error has occurred</span>
189      */
190     public void putNextEntry(ZipEntry e) throws IOException {
191         ensureOpen();
192         if (current != null) {
193             closeEntry();       // close previous entry
194         }
195         if (e.xdostime == -1) {
196             // by default, do NOT use extended timestamps in extra
197             // data, for now.
198             e.setTime(System.currentTimeMillis());
199         }
200         if (e.method == -1) {
201             e.method = method;  // use default method
202         }
203         // store size, compressed size, and crc-32 in LOC header
204         e.flag = 0;
205         switch (e.method) {
206         case DEFLATED:
207             // store size, compressed size, and crc-32 in data descriptor
208             // immediately following the compressed entry data
</pre>
<hr />
<pre>
225                 throw new ZipException(
226                     &quot;STORED entry missing size, compressed size, or crc-32&quot;);
227             }
228             break;
229         default:
230             throw new ZipException(&quot;unsupported compression method&quot;);
231         }
232         if (! names.add(e.name)) {
233             throw new ZipException(&quot;duplicate entry: &quot; + e.name);
234         }
235         if (zc.isUTF8())
236             e.flag |= USE_UTF8;
237         current = new XEntry(e, written);
238         xentries.add(current);
239         writeLOC(current);
240     }
241 
242     /**
243      * Closes the current ZIP entry and positions the stream for writing
244      * the next entry.
<span class="line-modified">245      * @exception ZipException if a ZIP format error has occurred</span>
<span class="line-modified">246      * @exception IOException if an I/O error has occurred</span>
247      */
248     public void closeEntry() throws IOException {
249         ensureOpen();
250         if (current != null) {
251             ZipEntry e = current.entry;
252             switch (e.method) {
253             case DEFLATED:
254                 def.finish();
255                 while (!def.finished()) {
256                     deflate();
257                 }
258                 if ((e.flag &amp; 8) == 0) {
259                     // verify size, compressed size, and crc-32 settings
260                     if (e.size != def.getBytesRead()) {
261                         throw new ZipException(
262                             &quot;invalid entry size (expected &quot; + e.size +
263                             &quot; but got &quot; + def.getBytesRead() + &quot; bytes)&quot;);
264                     }
265                     if (e.csize != def.getBytesWritten()) {
266                         throw new ZipException(
</pre>
<hr />
<pre>
290                         &quot; but got &quot; + (written - locoff) + &quot; bytes)&quot;);
291                 }
292                 if (e.crc != crc.getValue()) {
293                     throw new ZipException(
294                          &quot;invalid entry crc-32 (expected 0x&quot; +
295                          Long.toHexString(e.crc) + &quot; but got 0x&quot; +
296                          Long.toHexString(crc.getValue()) + &quot;)&quot;);
297                 }
298                 break;
299             default:
300                 throw new ZipException(&quot;invalid compression method&quot;);
301             }
302             crc.reset();
303             current = null;
304         }
305     }
306 
307     /**
308      * Writes an array of bytes to the current ZIP entry data. This method
309      * will block until all the bytes are written.
<span class="line-modified">310      * @param b the data to be written</span>
<span class="line-modified">311      * @param off the start offset in the data</span>
<span class="line-modified">312      * @param len the number of bytes that are written</span>
<span class="line-modified">313      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">314      * @exception IOException if an I/O error has occurred</span>
315      */
316     public synchronized void write(byte[] b, int off, int len)
317         throws IOException
318     {
319         ensureOpen();
320         if (off &lt; 0 || len &lt; 0 || off &gt; b.length - len) {
321             throw new IndexOutOfBoundsException();
322         } else if (len == 0) {
323             return;
324         }
325 
326         if (current == null) {
327             throw new ZipException(&quot;no current ZIP entry&quot;);
328         }
329         ZipEntry entry = current.entry;
330         switch (entry.method) {
331         case DEFLATED:
332             super.write(b, off, len);
333             break;
334         case STORED:
335             written += len;
336             if (written - locoff &gt; entry.size) {
337                 throw new ZipException(
338                     &quot;attempt to write past end of STORED entry&quot;);
339             }
340             out.write(b, off, len);
341             break;
342         default:
343             throw new ZipException(&quot;invalid compression method&quot;);
344         }
345         crc.update(b, off, len);
346     }
347 
348     /**
349      * Finishes writing the contents of the ZIP output stream without closing
350      * the underlying stream. Use this method when applying multiple filters
351      * in succession to the same output stream.
<span class="line-modified">352      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">353      * @exception IOException if an I/O exception has occurred</span>
354      */
355     public void finish() throws IOException {
356         ensureOpen();
357         if (finished) {
358             return;
359         }
360         if (current != null) {
361             closeEntry();
362         }
363         // write central directory
364         long off = written;
365         for (XEntry xentry : xentries)
366             writeCEN(xentry);
367         writeEND(off, written - off);
368         finished = true;
369     }
370 
371     /**
372      * Closes the ZIP output stream as well as the stream being filtered.
<span class="line-modified">373      * @exception ZipException if a ZIP file error has occurred</span>
<span class="line-modified">374      * @exception IOException if an I/O error has occurred</span>
375      */
376     public void close() throws IOException {
377         if (!closed) {
378             super.close();
379             closed = true;
380         }
381     }
382 
383     /*
384      * Writes local file (LOC) header for specified entry.
385      */
386     private void writeLOC(XEntry xentry) throws IOException {
387         ZipEntry e = xentry.entry;
388         int flag = e.flag;
389         boolean hasZip64 = false;
390         int elen = getExtraLen(e.extra);
391 
392         writeInt(LOCSIG);               // LOC header signature
393         if ((flag &amp; 8) == 8) {
394             writeShort(version(e));     // version needed to extract
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.zip;
 27 
 28 import java.io.OutputStream;
 29 import java.io.IOException;
 30 import java.nio.charset.Charset;

 31 import java.util.Vector;
 32 import java.util.HashSet;
 33 import static java.util.zip.ZipConstants64.*;
 34 import static java.util.zip.ZipUtils.*;
<span class="line-added"> 35 import sun.nio.cs.UTF_8;</span>
 36 import sun.security.action.GetPropertyAction;
 37 
 38 /**
 39  * This class implements an output stream filter for writing files in the
 40  * ZIP file format. Includes support for both compressed and uncompressed
 41  * entries.
 42  *
 43  * @author      David Connelly
 44  * @since 1.1
 45  */
<span class="line-modified"> 46 public class ZipOutputStream extends DeflaterOutputStream implements ZipConstants {</span>

 47 
 48     /**
 49      * Whether to use ZIP64 for zip files with more than 64k entries.
 50      * Until ZIP64 support in zip implementations is ubiquitous, this
 51      * system property allows the creation of zip files which can be
 52      * read by legacy zip implementations which tolerate &quot;incorrect&quot;
 53      * total entry count fields, such as the ones in jdk6, and even
 54      * some in jdk7.
 55      */
 56     private static final boolean inhibitZip64 =
 57         Boolean.parseBoolean(
 58             GetPropertyAction.privilegedGetProperty(&quot;jdk.util.zip.inhibitZip64&quot;));
 59 
 60     private static class XEntry {
 61         final ZipEntry entry;
 62         final long offset;
 63         public XEntry(ZipEntry entry, long offset) {
 64             this.entry = entry;
 65             this.offset = offset;
 66         }
</pre>
<hr />
<pre>
 99 
100     /**
101      * Compression method for uncompressed (STORED) entries.
102      */
103     public static final int STORED = ZipEntry.STORED;
104 
105     /**
106      * Compression method for compressed (DEFLATED) entries.
107      */
108     public static final int DEFLATED = ZipEntry.DEFLATED;
109 
110     /**
111      * Creates a new ZIP output stream.
112      *
113      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used
114      * to encode the entry names and comments.
115      *
116      * @param out the actual output stream
117      */
118     public ZipOutputStream(OutputStream out) {
<span class="line-modified">119         this(out, UTF_8.INSTANCE);</span>
120     }
121 
122     /**
123      * Creates a new ZIP output stream.
124      *
125      * @param out the actual output stream
126      *
127      * @param charset the {@linkplain java.nio.charset.Charset charset}
128      *                to be used to encode the entry names and comments
129      *
130      * @since 1.7
131      */
132     public ZipOutputStream(OutputStream out, Charset charset) {
133         super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true));
134         if (charset == null)
135             throw new NullPointerException(&quot;charset is null&quot;);
136         this.zc = ZipCoder.get(charset);
137         usesDefaultDeflater = true;
138     }
139 
140     /**
141      * Sets the ZIP file comment.
<span class="line-modified">142      * @param     comment the comment string</span>
<span class="line-modified">143      * @throws    IllegalArgumentException if the length of the specified</span>
144      *            ZIP file comment is greater than 0xFFFF bytes
145      */
146     public void setComment(String comment) {
147         if (comment != null) {
148             this.comment = zc.getBytes(comment);
149             if (this.comment.length &gt; 0xffff)
150                 throw new IllegalArgumentException(&quot;ZIP file comment too long.&quot;);
151         }
152     }
153 
154     /**
155      * Sets the default compression method for subsequent entries. This
156      * default will be used whenever the compression method is not specified
157      * for an individual ZIP file entry, and is initially set to DEFLATED.
<span class="line-modified">158      * @param     method the default compression method</span>
<span class="line-modified">159      * @throws    IllegalArgumentException if the specified compression method</span>
160      *            is invalid
161      */
162     public void setMethod(int method) {
163         if (method != DEFLATED &amp;&amp; method != STORED) {
164             throw new IllegalArgumentException(&quot;invalid compression method&quot;);
165         }
166         this.method = method;
167     }
168 
169     /**
170      * Sets the compression level for subsequent entries which are DEFLATED.
171      * The default setting is DEFAULT_COMPRESSION.
<span class="line-modified">172      * @param     level the compression level (0-9)</span>
<span class="line-modified">173      * @throws    IllegalArgumentException if the compression level is invalid</span>
174      */
175     public void setLevel(int level) {
176         def.setLevel(level);
177     }
178 
179     /**
180      * Begins writing a new ZIP file entry and positions the stream to the
181      * start of the entry data. Closes the current entry if still active.
182      * The default compression method will be used if no compression method
183      * was specified for the entry, and the current time will be used if
184      * the entry has no set modification time.
<span class="line-modified">185      * @param     e the ZIP entry to be written</span>
<span class="line-modified">186      * @throws    ZipException if a ZIP format error has occurred</span>
<span class="line-modified">187      * @throws    IOException if an I/O error has occurred</span>
188      */
189     public void putNextEntry(ZipEntry e) throws IOException {
190         ensureOpen();
191         if (current != null) {
192             closeEntry();       // close previous entry
193         }
194         if (e.xdostime == -1) {
195             // by default, do NOT use extended timestamps in extra
196             // data, for now.
197             e.setTime(System.currentTimeMillis());
198         }
199         if (e.method == -1) {
200             e.method = method;  // use default method
201         }
202         // store size, compressed size, and crc-32 in LOC header
203         e.flag = 0;
204         switch (e.method) {
205         case DEFLATED:
206             // store size, compressed size, and crc-32 in data descriptor
207             // immediately following the compressed entry data
</pre>
<hr />
<pre>
224                 throw new ZipException(
225                     &quot;STORED entry missing size, compressed size, or crc-32&quot;);
226             }
227             break;
228         default:
229             throw new ZipException(&quot;unsupported compression method&quot;);
230         }
231         if (! names.add(e.name)) {
232             throw new ZipException(&quot;duplicate entry: &quot; + e.name);
233         }
234         if (zc.isUTF8())
235             e.flag |= USE_UTF8;
236         current = new XEntry(e, written);
237         xentries.add(current);
238         writeLOC(current);
239     }
240 
241     /**
242      * Closes the current ZIP entry and positions the stream for writing
243      * the next entry.
<span class="line-modified">244      * @throws    ZipException if a ZIP format error has occurred</span>
<span class="line-modified">245      * @throws    IOException if an I/O error has occurred</span>
246      */
247     public void closeEntry() throws IOException {
248         ensureOpen();
249         if (current != null) {
250             ZipEntry e = current.entry;
251             switch (e.method) {
252             case DEFLATED:
253                 def.finish();
254                 while (!def.finished()) {
255                     deflate();
256                 }
257                 if ((e.flag &amp; 8) == 0) {
258                     // verify size, compressed size, and crc-32 settings
259                     if (e.size != def.getBytesRead()) {
260                         throw new ZipException(
261                             &quot;invalid entry size (expected &quot; + e.size +
262                             &quot; but got &quot; + def.getBytesRead() + &quot; bytes)&quot;);
263                     }
264                     if (e.csize != def.getBytesWritten()) {
265                         throw new ZipException(
</pre>
<hr />
<pre>
289                         &quot; but got &quot; + (written - locoff) + &quot; bytes)&quot;);
290                 }
291                 if (e.crc != crc.getValue()) {
292                     throw new ZipException(
293                          &quot;invalid entry crc-32 (expected 0x&quot; +
294                          Long.toHexString(e.crc) + &quot; but got 0x&quot; +
295                          Long.toHexString(crc.getValue()) + &quot;)&quot;);
296                 }
297                 break;
298             default:
299                 throw new ZipException(&quot;invalid compression method&quot;);
300             }
301             crc.reset();
302             current = null;
303         }
304     }
305 
306     /**
307      * Writes an array of bytes to the current ZIP entry data. This method
308      * will block until all the bytes are written.
<span class="line-modified">309      * @param     b the data to be written</span>
<span class="line-modified">310      * @param     off the start offset in the data</span>
<span class="line-modified">311      * @param     len the number of bytes that are written</span>
<span class="line-modified">312      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">313      * @throws    IOException if an I/O error has occurred</span>
314      */
315     public synchronized void write(byte[] b, int off, int len)
316         throws IOException
317     {
318         ensureOpen();
319         if (off &lt; 0 || len &lt; 0 || off &gt; b.length - len) {
320             throw new IndexOutOfBoundsException();
321         } else if (len == 0) {
322             return;
323         }
324 
325         if (current == null) {
326             throw new ZipException(&quot;no current ZIP entry&quot;);
327         }
328         ZipEntry entry = current.entry;
329         switch (entry.method) {
330         case DEFLATED:
331             super.write(b, off, len);
332             break;
333         case STORED:
334             written += len;
335             if (written - locoff &gt; entry.size) {
336                 throw new ZipException(
337                     &quot;attempt to write past end of STORED entry&quot;);
338             }
339             out.write(b, off, len);
340             break;
341         default:
342             throw new ZipException(&quot;invalid compression method&quot;);
343         }
344         crc.update(b, off, len);
345     }
346 
347     /**
348      * Finishes writing the contents of the ZIP output stream without closing
349      * the underlying stream. Use this method when applying multiple filters
350      * in succession to the same output stream.
<span class="line-modified">351      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">352      * @throws    IOException if an I/O exception has occurred</span>
353      */
354     public void finish() throws IOException {
355         ensureOpen();
356         if (finished) {
357             return;
358         }
359         if (current != null) {
360             closeEntry();
361         }
362         // write central directory
363         long off = written;
364         for (XEntry xentry : xentries)
365             writeCEN(xentry);
366         writeEND(off, written - off);
367         finished = true;
368     }
369 
370     /**
371      * Closes the ZIP output stream as well as the stream being filtered.
<span class="line-modified">372      * @throws    ZipException if a ZIP file error has occurred</span>
<span class="line-modified">373      * @throws    IOException if an I/O error has occurred</span>
374      */
375     public void close() throws IOException {
376         if (!closed) {
377             super.close();
378             closed = true;
379         }
380     }
381 
382     /*
383      * Writes local file (LOC) header for specified entry.
384      */
385     private void writeLOC(XEntry xentry) throws IOException {
386         ZipEntry e = xentry.entry;
387         int flag = e.flag;
388         boolean hasZip64 = false;
389         int elen = getExtraLen(e.extra);
390 
391         writeInt(LOCSIG);               // LOC header signature
392         if ((flag &amp; 8) == 8) {
393             writeShort(version(e));     // version needed to extract
</pre>
</td>
</tr>
</table>
<center><a href="ZipInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
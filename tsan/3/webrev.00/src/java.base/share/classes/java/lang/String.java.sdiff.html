<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/String.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StrictMath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringBuffer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/String.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.io.ObjectStreamField;
  29 import java.io.UnsupportedEncodingException;
  30 import java.lang.annotation.Native;
  31 import java.lang.invoke.MethodHandles;
  32 import java.lang.constant.Constable;
  33 import java.lang.constant.ConstantDesc;
  34 import java.nio.charset.Charset;
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Comparator;
  38 import java.util.Formatter;

  39 import java.util.Locale;
  40 import java.util.Objects;
  41 import java.util.Optional;
  42 import java.util.Spliterator;
  43 import java.util.StringJoiner;
  44 import java.util.function.Function;
  45 import java.util.regex.Matcher;
  46 import java.util.regex.Pattern;
  47 import java.util.regex.PatternSyntaxException;
  48 import java.util.stream.Collectors;
  49 import java.util.stream.IntStream;
  50 import java.util.stream.Stream;
  51 import java.util.stream.StreamSupport;
  52 import jdk.internal.HotSpotIntrinsicCandidate;
  53 import jdk.internal.vm.annotation.Stable;
  54 
  55 import static java.util.function.Predicate.not;
  56 
  57 /**
  58  * The {@code String} class represents character strings. All
  59  * string literals in Java programs, such as {@code &quot;abc&quot;}, are
  60  * implemented as instances of this class.
  61  * &lt;p&gt;
  62  * Strings are constant; their values cannot be changed after they
  63  * are created. String buffers support mutable strings.
  64  * Because String objects are immutable they can be shared. For example:
  65  * &lt;blockquote&gt;&lt;pre&gt;
  66  *     String str = &quot;abc&quot;;
  67  * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
  68  * is equivalent to:
  69  * &lt;blockquote&gt;&lt;pre&gt;
  70  *     char data[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};
  71  *     String str = new String(data);
  72  * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
  73  * Here are some more examples of how strings can be used:
  74  * &lt;blockquote&gt;&lt;pre&gt;
  75  *     System.out.println(&quot;abc&quot;);
  76  *     String cde = &quot;cde&quot;;
  77  *     System.out.println(&quot;abc&quot; + cde);
<span class="line-modified">  78  *     String c = &quot;abc&quot;.substring(2,3);</span>
  79  *     String d = cde.substring(1, 2);
  80  * &lt;/pre&gt;&lt;/blockquote&gt;
  81  * &lt;p&gt;
  82  * The class {@code String} includes methods for examining
  83  * individual characters of the sequence, for comparing strings, for
  84  * searching strings, for extracting substrings, and for creating a
  85  * copy of a string with all characters translated to uppercase or to
  86  * lowercase. Case mapping is based on the Unicode Standard version
  87  * specified by the {@link java.lang.Character Character} class.
  88  * &lt;p&gt;
  89  * The Java language provides special support for the string
  90  * concatenation operator (&amp;nbsp;+&amp;nbsp;), and for conversion of
  91  * other objects to strings. For additional information on string
  92  * concatenation and conversion, see &lt;i&gt;The Java&amp;trade; Language Specification&lt;/i&gt;.
  93  *
  94  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  95  * or method in this class will cause a {@link NullPointerException} to be
  96  * thrown.
  97  *
  98  * &lt;p&gt;A {@code String} represents a string in the UTF-16 format
</pre>
<hr />
<pre>
 147      */
 148     @Stable
 149     private final byte[] value;
 150 
 151     /**
 152      * The identifier of the encoding used to encode the bytes in
 153      * {@code value}. The supported values in this implementation are
 154      *
 155      * LATIN1
 156      * UTF16
 157      *
 158      * @implNote This field is trusted by the VM, and is a subject to
 159      * constant folding if String instance is constant. Overwriting this
 160      * field after construction will cause problems.
 161      */
 162     private final byte coder;
 163 
 164     /** Cache the hash code for the string */
 165     private int hash; // Default to 0
 166 






 167     /** use serialVersionUID from JDK 1.0.2 for interoperability */

 168     private static final long serialVersionUID = -6849794470754667710L;
 169 
 170     /**
 171      * If String compaction is disabled, the bytes in {@code value} are
 172      * always encoded in UTF16.
 173      *
 174      * For methods with several possible implementation paths, when String
 175      * compaction is disabled, only one code path is taken.
 176      *
 177      * The instance field value is generally opaque to optimizing JIT
 178      * compilers. Therefore, in performance-sensitive place, an explicit
 179      * check of the static boolean {@code COMPACT_STRINGS} is done first
 180      * before checking the {@code coder} field since the static boolean
 181      * {@code COMPACT_STRINGS} would be constant folded away by an
 182      * optimizing JIT compiler. The idioms for these cases are as follows.
 183      *
 184      * For code such as:
 185      *
 186      *    if (coder == LATIN1) { ... }
 187      *
</pre>
<hr />
<pre>
 200      *
 201      * @implNote
 202      * The actual value for this field is injected by JVM. The static
 203      * initialization block is used to set the value here to communicate
 204      * that this static final field is not statically foldable, and to
 205      * avoid any possible circular dependency during vm initialization.
 206      */
 207     static final boolean COMPACT_STRINGS;
 208 
 209     static {
 210         COMPACT_STRINGS = true;
 211     }
 212 
 213     /**
 214      * Class String is special cased within the Serialization Stream Protocol.
 215      *
 216      * A String instance is written into an ObjectOutputStream according to
 217      * &lt;a href=&quot;{@docRoot}/../specs/serialization/protocol.html#stream-elements&quot;&gt;
 218      * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;
 219      */

 220     private static final ObjectStreamField[] serialPersistentFields =
 221         new ObjectStreamField[0];
 222 
 223     /**
 224      * Initializes a newly created {@code String} object so that it represents
 225      * an empty character sequence.  Note that use of this constructor is
 226      * unnecessary since Strings are immutable.
 227      */
 228     public String() {
 229         this.value = &quot;&quot;.value;
 230         this.coder = &quot;&quot;.coder;
 231     }
 232 
 233     /**
 234      * Initializes a newly created {@code String} object so that it represents
 235      * the same sequence of characters as the argument; in other words, the
 236      * newly created string is a copy of the argument string. Unless an
 237      * explicit copy of {@code original} is needed, use of this constructor is
 238      * unnecessary since Strings are immutable.
 239      *
</pre>
<hr />
<pre>
 676      * @since 1.6
 677      */
 678     public boolean isEmpty() {
 679         return value.length == 0;
 680     }
 681 
 682     /**
 683      * Returns the {@code char} value at the
 684      * specified index. An index ranges from {@code 0} to
 685      * {@code length() - 1}. The first {@code char} value of the sequence
 686      * is at index {@code 0}, the next at index {@code 1},
 687      * and so on, as for array indexing.
 688      *
 689      * &lt;p&gt;If the {@code char} value specified by the index is a
 690      * &lt;a href=&quot;Character.html#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate
 691      * value is returned.
 692      *
 693      * @param      index   the index of the {@code char} value.
 694      * @return     the {@code char} value at the specified index of this string.
 695      *             The first {@code char} value is at index {@code 0}.
<span class="line-modified"> 696      * @exception  IndexOutOfBoundsException  if the {@code index}</span>
 697      *             argument is negative or not less than the length of this
 698      *             string.
 699      */
 700     public char charAt(int index) {
 701         if (isLatin1()) {
 702             return StringLatin1.charAt(value, index);
 703         } else {
 704             return StringUTF16.charAt(value, index);
 705         }
 706     }
 707 
 708     /**
 709      * Returns the character (Unicode code point) at the specified
 710      * index. The index refers to {@code char} values
 711      * (Unicode code units) and ranges from {@code 0} to
 712      * {@link #length()}{@code  - 1}.
 713      *
 714      * &lt;p&gt; If the {@code char} value specified at the given index
 715      * is in the high-surrogate range, the following index is less
 716      * than the length of this {@code String}, and the
 717      * {@code char} value at the following index is in the
 718      * low-surrogate range, then the supplementary code point
 719      * corresponding to this surrogate pair is returned. Otherwise,
 720      * the {@code char} value at the given index is returned.
 721      *
 722      * @param      index the index to the {@code char} values
 723      * @return     the code point value of the character at the
 724      *             {@code index}
<span class="line-modified"> 725      * @exception  IndexOutOfBoundsException  if the {@code index}</span>
 726      *             argument is negative or not less than the length of this
 727      *             string.
 728      * @since      1.5
 729      */
 730     public int codePointAt(int index) {
 731         if (isLatin1()) {
 732             checkIndex(index, value.length);
 733             return value[index] &amp; 0xff;
 734         }
 735         int length = value.length &gt;&gt; 1;
 736         checkIndex(index, length);
 737         return StringUTF16.codePointAt(value, index, length);
 738     }
 739 
 740     /**
 741      * Returns the character (Unicode code point) before the specified
 742      * index. The index refers to {@code char} values
 743      * (Unicode code units) and ranges from {@code 1} to {@link
 744      * CharSequence#length() length}.
 745      *
 746      * &lt;p&gt; If the {@code char} value at {@code (index - 1)}
 747      * is in the low-surrogate range, {@code (index - 2)} is not
 748      * negative, and the {@code char} value at {@code (index -
 749      * 2)} is in the high-surrogate range, then the
 750      * supplementary code point value of the surrogate pair is
 751      * returned. If the {@code char} value at {@code index -
 752      * 1} is an unpaired low-surrogate or a high-surrogate, the
 753      * surrogate value is returned.
 754      *
 755      * @param     index the index following the code point that should be returned
 756      * @return    the Unicode code point value before the given index.
<span class="line-modified"> 757      * @exception IndexOutOfBoundsException if the {@code index}</span>
 758      *            argument is less than 1 or greater than the length
 759      *            of this string.
 760      * @since     1.5
 761      */
 762     public int codePointBefore(int index) {
 763         int i = index - 1;
 764         if (i &lt; 0 || i &gt;= length()) {
 765             throw new StringIndexOutOfBoundsException(index);
 766         }
 767         if (isLatin1()) {
 768             return (value[i] &amp; 0xff);
 769         }
 770         return StringUTF16.codePointBefore(value, index);
 771     }
 772 
 773     /**
 774      * Returns the number of Unicode code points in the specified text
 775      * range of this {@code String}. The text range begins at the
 776      * specified {@code beginIndex} and extends to the
 777      * {@code char} at index {@code endIndex - 1}. Thus the
 778      * length (in {@code char}s) of the text range is
 779      * {@code endIndex-beginIndex}. Unpaired surrogates within
 780      * the text range count as one code point each.
 781      *
 782      * @param beginIndex the index to the first {@code char} of
 783      * the text range.
 784      * @param endIndex the index after the last {@code char} of
 785      * the text range.
 786      * @return the number of Unicode code points in the specified text
 787      * range
<span class="line-modified"> 788      * @exception IndexOutOfBoundsException if the</span>
 789      * {@code beginIndex} is negative, or {@code endIndex}
 790      * is larger than the length of this {@code String}, or
 791      * {@code beginIndex} is larger than {@code endIndex}.
 792      * @since  1.5
 793      */
 794     public int codePointCount(int beginIndex, int endIndex) {
 795         if (beginIndex &lt; 0 || beginIndex &gt; endIndex ||
 796             endIndex &gt; length()) {
 797             throw new IndexOutOfBoundsException();
 798         }
 799         if (isLatin1()) {
 800             return endIndex - beginIndex;
 801         }
 802         return StringUTF16.codePointCount(value, beginIndex, endIndex);
 803     }
 804 
 805     /**
 806      * Returns the index within this {@code String} that is
 807      * offset from the given {@code index} by
 808      * {@code codePointOffset} code points. Unpaired surrogates
 809      * within the text range given by {@code index} and
 810      * {@code codePointOffset} count as one code point each.
 811      *
 812      * @param index the index to be offset
 813      * @param codePointOffset the offset in code points
 814      * @return the index within this {@code String}
<span class="line-modified"> 815      * @exception IndexOutOfBoundsException if {@code index}</span>
 816      *   is negative or larger then the length of this
 817      *   {@code String}, or if {@code codePointOffset} is positive
 818      *   and the substring starting with {@code index} has fewer
 819      *   than {@code codePointOffset} code points,
 820      *   or if {@code codePointOffset} is negative and the substring
 821      *   before {@code index} has fewer than the absolute value
 822      *   of {@code codePointOffset} code points.
 823      * @since 1.5
 824      */
 825     public int offsetByCodePoints(int index, int codePointOffset) {
 826         if (index &lt; 0 || index &gt; length()) {
 827             throw new IndexOutOfBoundsException();
 828         }
 829         return Character.offsetByCodePoints(this, index, codePointOffset);
 830     }
 831 
 832     /**
 833      * Copies characters from this string into the destination character
 834      * array.
 835      * &lt;p&gt;
 836      * The first character to be copied is at index {@code srcBegin};
 837      * the last character to be copied is at index {@code srcEnd-1}
 838      * (thus the total number of characters to be copied is
 839      * {@code srcEnd-srcBegin}). The characters are copied into the
 840      * subarray of {@code dst} starting at index {@code dstBegin}
 841      * and ending at index:
 842      * &lt;blockquote&gt;&lt;pre&gt;
 843      *     dstBegin + (srcEnd-srcBegin) - 1
 844      * &lt;/pre&gt;&lt;/blockquote&gt;
 845      *
 846      * @param      srcBegin   index of the first character in the string
 847      *                        to copy.
 848      * @param      srcEnd     index after the last character in the string
 849      *                        to copy.
 850      * @param      dst        the destination array.
 851      * @param      dstBegin   the start offset in the destination array.
<span class="line-modified"> 852      * @exception IndexOutOfBoundsException If any of the following</span>
 853      *            is true:
 854      *            &lt;ul&gt;&lt;li&gt;{@code srcBegin} is negative.
 855      *            &lt;li&gt;{@code srcBegin} is greater than {@code srcEnd}
 856      *            &lt;li&gt;{@code srcEnd} is greater than the length of this
 857      *                string
 858      *            &lt;li&gt;{@code dstBegin} is negative
 859      *            &lt;li&gt;{@code dstBegin+(srcEnd-srcBegin)} is larger than
 860      *                {@code dst.length}&lt;/ul&gt;
 861      */
 862     public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {
 863         checkBoundsBeginEnd(srcBegin, srcEnd, length());
 864         checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);
 865         if (isLatin1()) {
 866             StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);
 867         } else {
 868             StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);
 869         }
 870     }
 871 
 872     /**
</pre>
<hr />
<pre>
 997      * object.
 998      *
 999      * &lt;p&gt;For finer-grained String comparison, refer to
1000      * {@link java.text.Collator}.
1001      *
1002      * @param  anObject
1003      *         The object to compare this {@code String} against
1004      *
1005      * @return  {@code true} if the given object represents a {@code String}
1006      *          equivalent to this string, {@code false} otherwise
1007      *
1008      * @see  #compareTo(String)
1009      * @see  #equalsIgnoreCase(String)
1010      */
1011     public boolean equals(Object anObject) {
1012         if (this == anObject) {
1013             return true;
1014         }
1015         if (anObject instanceof String) {
1016             String aString = (String)anObject;
<span class="line-modified">1017             if (coder() == aString.coder()) {</span>
<span class="line-modified">1018                 return isLatin1() ? StringLatin1.equals(value, aString.value)</span>
<span class="line-removed">1019                                   : StringUTF16.equals(value, aString.value);</span>
1020             }
1021         }
1022         return false;
1023     }
1024 
1025     /**
1026      * Compares this string to the specified {@code StringBuffer}.  The result
1027      * is {@code true} if and only if this {@code String} represents the same
1028      * sequence of characters as the specified {@code StringBuffer}. This method
1029      * synchronizes on the {@code StringBuffer}.
1030      *
1031      * &lt;p&gt;For finer-grained String comparison, refer to
1032      * {@link java.text.Collator}.
1033      *
1034      * @param  sb
1035      *         The {@code StringBuffer} to compare this {@code String} against
1036      *
1037      * @return  {@code true} if this {@code String} represents the same
1038      *          sequence of characters as the specified {@code StringBuffer},
1039      *          {@code false} otherwise
1040      *
1041      * @since  1.4
1042      */
1043     public boolean contentEquals(StringBuffer sb) {
1044         return contentEquals((CharSequence)sb);
1045     }
1046 
1047     private boolean nonSyncContentEquals(AbstractStringBuilder sb) {
1048         int len = length();
1049         if (len != sb.length()) {
1050             return false;
1051         }
1052         byte v1[] = value;
1053         byte v2[] = sb.getValue();
<span class="line-modified">1054         if (coder() == sb.getCoder()) {</span>

1055             int n = v1.length;
1056             for (int i = 0; i &lt; n; i++) {
1057                 if (v1[i] != v2[i]) {
1058                     return false;
1059                 }
1060             }
1061         } else {
<span class="line-modified">1062             if (!isLatin1()) {  // utf16 str and latin1 abs can never be &quot;equal&quot;</span>
1063                 return false;
1064             }
1065             return StringUTF16.contentEquals(v1, v2, len);
1066         }
1067         return true;
1068     }
1069 
1070     /**
1071      * Compares this string to the specified {@code CharSequence}.  The
1072      * result is {@code true} if and only if this {@code String} represents the
1073      * same sequence of char values as the specified sequence. Note that if the
1074      * {@code CharSequence} is a {@code StringBuffer} then the method
1075      * synchronizes on it.
1076      *
1077      * &lt;p&gt;For finer-grained String comparison, refer to
1078      * {@link java.text.Collator}.
1079      *
1080      * @param  cs
1081      *         The sequence to compare this {@code String} against
1082      *
</pre>
<hr />
<pre>
1186      * string lexicographically precedes the longer string. In this case,
1187      * {@code compareTo} returns the difference of the lengths of the
1188      * strings -- that is, the value:
1189      * &lt;blockquote&gt;&lt;pre&gt;
1190      * this.length()-anotherString.length()
1191      * &lt;/pre&gt;&lt;/blockquote&gt;
1192      *
1193      * &lt;p&gt;For finer-grained String comparison, refer to
1194      * {@link java.text.Collator}.
1195      *
1196      * @param   anotherString   the {@code String} to be compared.
1197      * @return  the value {@code 0} if the argument string is equal to
1198      *          this string; a value less than {@code 0} if this string
1199      *          is lexicographically less than the string argument; and a
1200      *          value greater than {@code 0} if this string is
1201      *          lexicographically greater than the string argument.
1202      */
1203     public int compareTo(String anotherString) {
1204         byte v1[] = value;
1205         byte v2[] = anotherString.value;
<span class="line-modified">1206         if (coder() == anotherString.coder()) {</span>
<span class="line-modified">1207             return isLatin1() ? StringLatin1.compareTo(v1, v2)</span>
<span class="line-modified">1208                               : StringUTF16.compareTo(v1, v2);</span>

1209         }
<span class="line-modified">1210         return isLatin1() ? StringLatin1.compareToUTF16(v1, v2)</span>
<span class="line-modified">1211                           : StringUTF16.compareToLatin1(v1, v2);</span>
1212      }
1213 
1214     /**
1215      * A Comparator that orders {@code String} objects as by
1216      * {@code compareToIgnoreCase}. This comparator is serializable.
1217      * &lt;p&gt;
1218      * Note that this Comparator does &lt;em&gt;not&lt;/em&gt; take locale into account,
1219      * and will result in an unsatisfactory ordering for certain locales.
1220      * The {@link java.text.Collator} class provides locale-sensitive comparison.
1221      *
1222      * @see     java.text.Collator
1223      * @since   1.2
1224      */
1225     public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER
1226                                          = new CaseInsensitiveComparator();
1227     private static class CaseInsensitiveComparator
1228             implements Comparator&lt;String&gt;, java.io.Serializable {
1229         // use serialVersionUID from JDK 1.2.2 for interoperability

1230         private static final long serialVersionUID = 8575799808933029326L;
1231 
1232         public int compare(String s1, String s2) {
1233             byte v1[] = s1.value;
1234             byte v2[] = s2.value;
<span class="line-modified">1235             if (s1.coder() == s2.coder()) {</span>
<span class="line-modified">1236                 return s1.isLatin1() ? StringLatin1.compareToCI(v1, v2)</span>
<span class="line-modified">1237                                      : StringUTF16.compareToCI(v1, v2);</span>

1238             }
<span class="line-modified">1239             return s1.isLatin1() ? StringLatin1.compareToCI_UTF16(v1, v2)</span>
<span class="line-modified">1240                                  : StringUTF16.compareToCI_Latin1(v1, v2);</span>
1241         }
1242 
1243         /** Replaces the de-serialized object. */

1244         private Object readResolve() { return CASE_INSENSITIVE_ORDER; }
1245     }
1246 
1247     /**
1248      * Compares two strings lexicographically, ignoring case
1249      * differences. This method returns an integer whose sign is that of
1250      * calling {@code compareTo} with normalized versions of the strings
1251      * where case differences have been eliminated by calling
1252      * {@code Character.toLowerCase(Character.toUpperCase(character))} on
1253      * each character.
1254      * &lt;p&gt;
1255      * Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account,
1256      * and will result in an unsatisfactory ordering for certain locales.
1257      * The {@link java.text.Collator} class provides locale-sensitive comparison.
1258      *
1259      * @param   str   the {@code String} to be compared.
1260      * @return  a negative integer, zero, or a positive integer as the
1261      *          specified String is greater than, equal to, or less
1262      *          than this String, ignoring case considerations.
1263      * @see     java.text.Collator
</pre>
<hr />
<pre>
1294      * {@link java.text.Collator} class provides locale-sensitive comparison.
1295      *
1296      * @param   toffset   the starting offset of the subregion in this string.
1297      * @param   other     the string argument.
1298      * @param   ooffset   the starting offset of the subregion in the string
1299      *                    argument.
1300      * @param   len       the number of characters to compare.
1301      * @return  {@code true} if the specified subregion of this string
1302      *          exactly matches the specified subregion of the string argument;
1303      *          {@code false} otherwise.
1304      */
1305     public boolean regionMatches(int toffset, String other, int ooffset, int len) {
1306         byte tv[] = value;
1307         byte ov[] = other.value;
1308         // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.
1309         if ((ooffset &lt; 0) || (toffset &lt; 0) ||
1310              (toffset &gt; (long)length() - len) ||
1311              (ooffset &gt; (long)other.length() - len)) {
1312             return false;
1313         }
<span class="line-modified">1314         if (coder() == other.coder()) {</span>

1315             if (!isLatin1() &amp;&amp; (len &gt; 0)) {
1316                 toffset = toffset &lt;&lt; 1;
1317                 ooffset = ooffset &lt;&lt; 1;
1318                 len = len &lt;&lt; 1;
1319             }
1320             while (len-- &gt; 0) {
1321                 if (tv[toffset++] != ov[ooffset++]) {
1322                     return false;
1323                 }
1324             }
1325         } else {
<span class="line-modified">1326             if (coder() == LATIN1) {</span>
1327                 while (len-- &gt; 0) {
1328                     if (StringLatin1.getChar(tv, toffset++) !=
1329                         StringUTF16.getChar(ov, ooffset++)) {
1330                         return false;
1331                     }
1332                 }
1333             } else {
1334                 while (len-- &gt; 0) {
1335                     if (StringUTF16.getChar(tv, toffset++) !=
1336                         StringLatin1.getChar(ov, ooffset++)) {
1337                         return false;
1338                     }
1339                 }
1340             }
1341         }
1342         return true;
1343     }
1344 
1345     /**
1346      * Tests if two string regions are equal.
</pre>
<hr />
<pre>
1388      * @param   len          the number of characters to compare.
1389      * @return  {@code true} if the specified subregion of this string
1390      *          matches the specified subregion of the string argument;
1391      *          {@code false} otherwise. Whether the matching is exact
1392      *          or case insensitive depends on the {@code ignoreCase}
1393      *          argument.
1394      */
1395     public boolean regionMatches(boolean ignoreCase, int toffset,
1396             String other, int ooffset, int len) {
1397         if (!ignoreCase) {
1398             return regionMatches(toffset, other, ooffset, len);
1399         }
1400         // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.
1401         if ((ooffset &lt; 0) || (toffset &lt; 0)
1402                 || (toffset &gt; (long)length() - len)
1403                 || (ooffset &gt; (long)other.length() - len)) {
1404             return false;
1405         }
1406         byte tv[] = value;
1407         byte ov[] = other.value;
<span class="line-modified">1408         if (coder() == other.coder()) {</span>
<span class="line-modified">1409             return isLatin1()</span>

1410               ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)
1411               : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);
1412         }
<span class="line-modified">1413         return isLatin1()</span>
1414               ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)
1415               : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);
1416     }
1417 
1418     /**
1419      * Tests if the substring of this string beginning at the
1420      * specified index starts with the specified prefix.
1421      *
1422      * @param   prefix    the prefix.
1423      * @param   toffset   where to begin looking in this string.
1424      * @return  {@code true} if the character sequence represented by the
1425      *          argument is a prefix of the substring of this object starting
1426      *          at index {@code toffset}; {@code false} otherwise.
1427      *          The result is {@code false} if {@code toffset} is
1428      *          negative or greater than the length of this
1429      *          {@code String} object; otherwise the result is the same
1430      *          as the result of the expression
1431      *          &lt;pre&gt;
1432      *          this.substring(toffset).startsWith(prefix)
1433      *          &lt;/pre&gt;
1434      */
1435     public boolean startsWith(String prefix, int toffset) {
1436         // Note: toffset might be near -1&gt;&gt;&gt;1.
1437         if (toffset &lt; 0 || toffset &gt; length() - prefix.length()) {
1438             return false;
1439         }
1440         byte ta[] = value;
1441         byte pa[] = prefix.value;
1442         int po = 0;
1443         int pc = pa.length;
<span class="line-modified">1444         if (coder() == prefix.coder()) {</span>
<span class="line-modified">1445             int to = isLatin1() ? toffset : toffset &lt;&lt; 1;</span>

1446             while (po &lt; pc) {
1447                 if (ta[to++] != pa[po++]) {
1448                     return false;
1449                 }
1450             }
1451         } else {
<span class="line-modified">1452             if (isLatin1()) {  // &amp;&amp; pcoder == UTF16</span>
1453                 return false;
1454             }
1455             // coder == UTF16 &amp;&amp; pcoder == LATIN1)
1456             while (po &lt; pc) {
1457                 if (StringUTF16.getChar(ta, toffset++) != (pa[po++] &amp; 0xff)) {
1458                     return false;
1459                }
1460             }
1461         }
1462         return true;
1463     }
1464 
1465     /**
1466      * Tests if this string starts with the specified prefix.
1467      *
1468      * @param   prefix   the prefix.
1469      * @return  {@code true} if the character sequence represented by the
1470      *          argument is a prefix of the character sequence represented by
1471      *          this string; {@code false} otherwise.
1472      *          Note also that {@code true} will be returned if the
</pre>
<hr />
<pre>
1491      *          as determined by the {@link #equals(Object)} method.
1492      */
1493     public boolean endsWith(String suffix) {
1494         return startsWith(suffix, length() - suffix.length());
1495     }
1496 
1497     /**
1498      * Returns a hash code for this string. The hash code for a
1499      * {@code String} object is computed as
1500      * &lt;blockquote&gt;&lt;pre&gt;
1501      * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
1502      * &lt;/pre&gt;&lt;/blockquote&gt;
1503      * using {@code int} arithmetic, where {@code s[i]} is the
1504      * &lt;i&gt;i&lt;/i&gt;th character of the string, {@code n} is the length of
1505      * the string, and {@code ^} indicates exponentiation.
1506      * (The hash value of the empty string is zero.)
1507      *
1508      * @return  a hash code value for this object.
1509      */
1510     public int hashCode() {








1511         int h = hash;
<span class="line-modified">1512         if (h == 0 &amp;&amp; value.length &gt; 0) {</span>
<span class="line-modified">1513             hash = h = isLatin1() ? StringLatin1.hashCode(value)</span>
<span class="line-modified">1514                                   : StringUTF16.hashCode(value);</span>





1515         }
1516         return h;
1517     }
1518 
1519     /**
1520      * Returns the index within this string of the first occurrence of
1521      * the specified character. If a character with value
1522      * {@code ch} occurs in the character sequence represented by
1523      * this {@code String} object, then the index (in Unicode
1524      * code units) of the first such occurrence is returned. For
1525      * values of {@code ch} in the range from 0 to 0xFFFF
1526      * (inclusive), this is the smallest value &lt;i&gt;k&lt;/i&gt; such that:
1527      * &lt;blockquote&gt;&lt;pre&gt;
1528      * this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch
1529      * &lt;/pre&gt;&lt;/blockquote&gt;
1530      * is true. For other values of {@code ch}, it is the
1531      * smallest value &lt;i&gt;k&lt;/i&gt; such that:
1532      * &lt;blockquote&gt;&lt;pre&gt;
1533      * this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch
1534      * &lt;/pre&gt;&lt;/blockquote&gt;
</pre>
<hr />
<pre>
1652     public int lastIndexOf(int ch, int fromIndex) {
1653         return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)
1654                           : StringUTF16.lastIndexOf(value, ch, fromIndex);
1655     }
1656 
1657     /**
1658      * Returns the index within this string of the first occurrence of the
1659      * specified substring.
1660      *
1661      * &lt;p&gt;The returned index is the smallest value {@code k} for which:
1662      * &lt;pre&gt;{@code
1663      * this.startsWith(str, k)
1664      * }&lt;/pre&gt;
1665      * If no such value of {@code k} exists, then {@code -1} is returned.
1666      *
1667      * @param   str   the substring to search for.
1668      * @return  the index of the first occurrence of the specified substring,
1669      *          or {@code -1} if there is no such occurrence.
1670      */
1671     public int indexOf(String str) {
<span class="line-modified">1672         if (coder() == str.coder()) {</span>

1673             return isLatin1() ? StringLatin1.indexOf(value, str.value)
1674                               : StringUTF16.indexOf(value, str.value);
1675         }
<span class="line-modified">1676         if (coder() == LATIN1) {  // str.coder == UTF16</span>
1677             return -1;
1678         }
1679         return StringUTF16.indexOfLatin1(value, str.value);
1680     }
1681 
1682     /**
1683      * Returns the index within this string of the first occurrence of the
1684      * specified substring, starting at the specified index.
1685      *
1686      * &lt;p&gt;The returned index is the smallest value {@code k} for which:
1687      * &lt;pre&gt;{@code
1688      *     k &gt;= Math.min(fromIndex, this.length()) &amp;&amp;
1689      *                   this.startsWith(str, k)
1690      * }&lt;/pre&gt;
1691      * If no such value of {@code k} exists, then {@code -1} is returned.
1692      *
1693      * @param   str         the substring to search for.
1694      * @param   fromIndex   the index from which to start the search.
1695      * @return  the index of the first occurrence of the specified substring,
1696      *          starting at the specified index,
</pre>
<hr />
<pre>
1820         if (srcCoder == LATIN1) {    // &amp;&amp; tgtCoder == UTF16
1821             return -1;
1822         }
1823         // srcCoder == UTF16 &amp;&amp; tgtCoder == LATIN1
1824         return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);
1825     }
1826 
1827     /**
1828      * Returns a string that is a substring of this string. The
1829      * substring begins with the character at the specified index and
1830      * extends to the end of this string. &lt;p&gt;
1831      * Examples:
1832      * &lt;blockquote&gt;&lt;pre&gt;
1833      * &quot;unhappy&quot;.substring(2) returns &quot;happy&quot;
1834      * &quot;Harbison&quot;.substring(3) returns &quot;bison&quot;
1835      * &quot;emptiness&quot;.substring(9) returns &quot;&quot; (an empty string)
1836      * &lt;/pre&gt;&lt;/blockquote&gt;
1837      *
1838      * @param      beginIndex   the beginning index, inclusive.
1839      * @return     the specified substring.
<span class="line-modified">1840      * @exception  IndexOutOfBoundsException  if</span>
1841      *             {@code beginIndex} is negative or larger than the
1842      *             length of this {@code String} object.
1843      */
1844     public String substring(int beginIndex) {
<span class="line-modified">1845         if (beginIndex &lt; 0) {</span>
<span class="line-removed">1846             throw new StringIndexOutOfBoundsException(beginIndex);</span>
<span class="line-removed">1847         }</span>
<span class="line-removed">1848         int subLen = length() - beginIndex;</span>
<span class="line-removed">1849         if (subLen &lt; 0) {</span>
<span class="line-removed">1850             throw new StringIndexOutOfBoundsException(subLen);</span>
<span class="line-removed">1851         }</span>
<span class="line-removed">1852         if (beginIndex == 0) {</span>
<span class="line-removed">1853             return this;</span>
<span class="line-removed">1854         }</span>
<span class="line-removed">1855         return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)</span>
<span class="line-removed">1856                           : StringUTF16.newString(value, beginIndex, subLen);</span>
1857     }
1858 
1859     /**
1860      * Returns a string that is a substring of this string. The
1861      * substring begins at the specified {@code beginIndex} and
1862      * extends to the character at index {@code endIndex - 1}.
1863      * Thus the length of the substring is {@code endIndex-beginIndex}.
1864      * &lt;p&gt;
1865      * Examples:
1866      * &lt;blockquote&gt;&lt;pre&gt;
1867      * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;
1868      * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;
1869      * &lt;/pre&gt;&lt;/blockquote&gt;
1870      *
1871      * @param      beginIndex   the beginning index, inclusive.
1872      * @param      endIndex     the ending index, exclusive.
1873      * @return     the specified substring.
<span class="line-modified">1874      * @exception  IndexOutOfBoundsException  if the</span>
1875      *             {@code beginIndex} is negative, or
1876      *             {@code endIndex} is larger than the length of
1877      *             this {@code String} object, or
1878      *             {@code beginIndex} is larger than
1879      *             {@code endIndex}.
1880      */
1881     public String substring(int beginIndex, int endIndex) {
1882         int length = length();
1883         checkBoundsBeginEnd(beginIndex, endIndex, length);
1884         int subLen = endIndex - beginIndex;
1885         if (beginIndex == 0 &amp;&amp; endIndex == length) {
1886             return this;
1887         }
1888         return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)
1889                           : StringUTF16.newString(value, beginIndex, subLen);
1890     }
1891 
1892     /**
1893      * Returns a character sequence that is a subsequence of this sequence.
1894      *
</pre>
<hr />
<pre>
1929      * {@code String} object is returned. Otherwise, a
1930      * {@code String} object is returned that represents a character
1931      * sequence that is the concatenation of the character sequence
1932      * represented by this {@code String} object and the character
1933      * sequence represented by the argument string.&lt;p&gt;
1934      * Examples:
1935      * &lt;blockquote&gt;&lt;pre&gt;
1936      * &quot;cares&quot;.concat(&quot;s&quot;) returns &quot;caress&quot;
1937      * &quot;to&quot;.concat(&quot;get&quot;).concat(&quot;her&quot;) returns &quot;together&quot;
1938      * &lt;/pre&gt;&lt;/blockquote&gt;
1939      *
1940      * @param   str   the {@code String} that is concatenated to the end
1941      *                of this {@code String}.
1942      * @return  a string that represents the concatenation of this object&#39;s
1943      *          characters followed by the string argument&#39;s characters.
1944      */
1945     public String concat(String str) {
1946         if (str.isEmpty()) {
1947             return this;
1948         }
<span class="line-modified">1949         if (coder() == str.coder()) {</span>
<span class="line-removed">1950             byte[] val = this.value;</span>
<span class="line-removed">1951             byte[] oval = str.value;</span>
<span class="line-removed">1952             int len = val.length + oval.length;</span>
<span class="line-removed">1953             byte[] buf = Arrays.copyOf(val, len);</span>
<span class="line-removed">1954             System.arraycopy(oval, 0, buf, val.length, oval.length);</span>
<span class="line-removed">1955             return new String(buf, coder);</span>
<span class="line-removed">1956         }</span>
<span class="line-removed">1957         int len = length();</span>
<span class="line-removed">1958         int olen = str.length();</span>
<span class="line-removed">1959         byte[] buf = StringUTF16.newBytesFor(len + olen);</span>
<span class="line-removed">1960         getBytes(buf, 0, UTF16);</span>
<span class="line-removed">1961         str.getBytes(buf, len, UTF16);</span>
<span class="line-removed">1962         return new String(buf, UTF16);</span>
1963     }
1964 
1965     /**
1966      * Returns a string resulting from replacing all occurrences of
1967      * {@code oldChar} in this string with {@code newChar}.
1968      * &lt;p&gt;
1969      * If the character {@code oldChar} does not occur in the
1970      * character sequence represented by this {@code String} object,
1971      * then a reference to this {@code String} object is returned.
1972      * Otherwise, a {@code String} object is returned that
1973      * represents a character sequence identical to the character sequence
1974      * represented by this {@code String} object, except that every
1975      * occurrence of {@code oldChar} is replaced by an occurrence
1976      * of {@code newChar}.
1977      * &lt;p&gt;
1978      * Examples:
1979      * &lt;blockquote&gt;&lt;pre&gt;
1980      * &quot;mesquite in your cellar&quot;.replace(&#39;e&#39;, &#39;o&#39;)
1981      *         returns &quot;mosquito in your collar&quot;
1982      * &quot;the war of baronets&quot;.replace(&#39;r&#39;, &#39;y&#39;)
</pre>
<hr />
<pre>
2131      * @since 1.4
2132      * @spec JSR-51
2133      */
2134     public String replaceAll(String regex, String replacement) {
2135         return Pattern.compile(regex).matcher(this).replaceAll(replacement);
2136     }
2137 
2138     /**
2139      * Replaces each substring of this string that matches the literal target
2140      * sequence with the specified literal replacement sequence. The
2141      * replacement proceeds from the beginning of the string to the end, for
2142      * example, replacing &quot;aa&quot; with &quot;b&quot; in the string &quot;aaa&quot; will result in
2143      * &quot;ba&quot; rather than &quot;ab&quot;.
2144      *
2145      * @param  target The sequence of char values to be replaced
2146      * @param  replacement The replacement sequence of char values
2147      * @return  The resulting string
2148      * @since 1.5
2149      */
2150     public String replace(CharSequence target, CharSequence replacement) {
<span class="line-modified">2151         String tgtStr = target.toString();</span>
2152         String replStr = replacement.toString();
<span class="line-removed">2153         int j = indexOf(tgtStr);</span>
<span class="line-removed">2154         if (j &lt; 0) {</span>
<span class="line-removed">2155             return this;</span>
<span class="line-removed">2156         }</span>
<span class="line-removed">2157         int tgtLen = tgtStr.length();</span>
<span class="line-removed">2158         int tgtLen1 = Math.max(tgtLen, 1);</span>
2159         int thisLen = length();































2160 
<span class="line-modified">2161         int newLenHint = thisLen - tgtLen + replStr.length();</span>
<span class="line-modified">2162         if (newLenHint &lt; 0) {</span>
<span class="line-modified">2163             throw new OutOfMemoryError();</span>



2164         }
<span class="line-removed">2165         StringBuilder sb = new StringBuilder(newLenHint);</span>
<span class="line-removed">2166         int i = 0;</span>
<span class="line-removed">2167         do {</span>
<span class="line-removed">2168             sb.append(this, i, j).append(replStr);</span>
<span class="line-removed">2169             i = j + tgtLen;</span>
<span class="line-removed">2170         } while (j &lt; thisLen &amp;&amp; (j = indexOf(tgtStr, j + tgtLen1)) &gt; 0);</span>
<span class="line-removed">2171         return sb.append(this, i, thisLen).toString();</span>
2172     }
2173 
2174     /**
2175      * Splits this string around matches of the given
2176      * &lt;a href=&quot;../util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt;.
2177      *
2178      * &lt;p&gt; The array returned by this method contains each substring of this
2179      * string that is terminated by another substring that matches the given
2180      * expression or is terminated by the end of the string.  The substrings in
2181      * the array are in the order in which they occur in this string.  If the
2182      * expression does not match any part of the input then the resulting array
2183      * has just one element, namely this string.
2184      *
2185      * &lt;p&gt; When there is a positive-width match at the beginning of this
2186      * string then an empty leading substring is included at the beginning
2187      * of the resulting array. A zero-width match at the beginning however
2188      * never produces such empty leading substring.
2189      *
2190      * &lt;p&gt; The {@code limit} parameter controls the number of times the
2191      * pattern is applied and therefore affects the length of the resulting
</pre>
<hr />
<pre>
2640      * object is returned, representing the substring of this string that
2641      * begins with the character at index &lt;i&gt;k&lt;/i&gt; and ends with the
2642      * character at index &lt;i&gt;m&lt;/i&gt;-that is, the result of
2643      * {@code this.substring(k, m + 1)}.
2644      * &lt;p&gt;
2645      * This method may be used to trim space (as defined above) from
2646      * the beginning and end of a string.
2647      *
2648      * @return  a string whose value is this string, with all leading
2649      *          and trailing space removed, or this string if it
2650      *          has no leading or trailing space.
2651      */
2652     public String trim() {
2653         String ret = isLatin1() ? StringLatin1.trim(value)
2654                                 : StringUTF16.trim(value);
2655         return ret == null ? this : ret;
2656     }
2657 
2658     /**
2659      * Returns a string whose value is this string, with all leading
<span class="line-modified">2660      * and trailing {@link Character#isWhitespace(int) white space}</span>
2661      * removed.
2662      * &lt;p&gt;
2663      * If this {@code String} object represents an empty string,
2664      * or if all code points in this string are
<span class="line-modified">2665      * {@link Character#isWhitespace(int) white space}, then an empty string</span>
2666      * is returned.
2667      * &lt;p&gt;
2668      * Otherwise, returns a substring of this string beginning with the first
<span class="line-modified">2669      * code point that is not a {@link Character#isWhitespace(int) white space}</span>
2670      * up to and including the last code point that is not a
<span class="line-modified">2671      * {@link Character#isWhitespace(int) white space}.</span>
2672      * &lt;p&gt;
2673      * This method may be used to strip
<span class="line-modified">2674      * {@link Character#isWhitespace(int) white space} from</span>
2675      * the beginning and end of a string.
2676      *
2677      * @return  a string whose value is this string, with all leading
2678      *          and trailing white space removed
2679      *
2680      * @see Character#isWhitespace(int)
2681      *
2682      * @since 11
2683      */
2684     public String strip() {
2685         String ret = isLatin1() ? StringLatin1.strip(value)
2686                                 : StringUTF16.strip(value);
2687         return ret == null ? this : ret;
2688     }
2689 
2690     /**
2691      * Returns a string whose value is this string, with all leading
<span class="line-modified">2692      * {@link Character#isWhitespace(int) white space} removed.</span>
2693      * &lt;p&gt;
2694      * If this {@code String} object represents an empty string,
2695      * or if all code points in this string are
<span class="line-modified">2696      * {@link Character#isWhitespace(int) white space}, then an empty string</span>
2697      * is returned.
2698      * &lt;p&gt;
2699      * Otherwise, returns a substring of this string beginning with the first
<span class="line-modified">2700      * code point that is not a {@link Character#isWhitespace(int) white space}</span>
2701      * up to and including the last code point of this string.
2702      * &lt;p&gt;
2703      * This method may be used to trim
<span class="line-modified">2704      * {@link Character#isWhitespace(int) white space} from</span>
2705      * the beginning of a string.
2706      *
2707      * @return  a string whose value is this string, with all leading white
2708      *          space removed
2709      *
2710      * @see Character#isWhitespace(int)
2711      *
2712      * @since 11
2713      */
2714     public String stripLeading() {
2715         String ret = isLatin1() ? StringLatin1.stripLeading(value)
2716                                 : StringUTF16.stripLeading(value);
2717         return ret == null ? this : ret;
2718     }
2719 
2720     /**
2721      * Returns a string whose value is this string, with all trailing
<span class="line-modified">2722      * {@link Character#isWhitespace(int) white space} removed.</span>
2723      * &lt;p&gt;
2724      * If this {@code String} object represents an empty string,
2725      * or if all characters in this string are
<span class="line-modified">2726      * {@link Character#isWhitespace(int) white space}, then an empty string</span>
2727      * is returned.
2728      * &lt;p&gt;
2729      * Otherwise, returns a substring of this string beginning with the first
2730      * code point of this string up to and including the last code point
<span class="line-modified">2731      * that is not a {@link Character#isWhitespace(int) white space}.</span>
2732      * &lt;p&gt;
2733      * This method may be used to trim
<span class="line-modified">2734      * {@link Character#isWhitespace(int) white space} from</span>
2735      * the end of a string.
2736      *
2737      * @return  a string whose value is this string, with all trailing white
2738      *          space removed
2739      *
2740      * @see Character#isWhitespace(int)
2741      *
2742      * @since 11
2743      */
2744     public String stripTrailing() {
2745         String ret = isLatin1() ? StringLatin1.stripTrailing(value)
2746                                 : StringUTF16.stripTrailing(value);
2747         return ret == null ? this : ret;
2748     }
2749 
2750     /**
2751      * Returns {@code true} if the string is empty or contains only
<span class="line-modified">2752      * {@link Character#isWhitespace(int) white space} codepoints,</span>
2753      * otherwise {@code false}.
2754      *
2755      * @return {@code true} if the string is empty or contains only
<span class="line-modified">2756      *         {@link Character#isWhitespace(int) white space} codepoints,</span>
2757      *         otherwise {@code false}
2758      *
2759      * @see Character#isWhitespace(int)
2760      *
2761      * @since 11
2762      */
2763     public boolean isBlank() {
2764         return indexOfNonWhitespace() == length();
2765     }
2766 
<span class="line-removed">2767     private Stream&lt;String&gt; lines(int maxLeading, int maxTrailing) {</span>
<span class="line-removed">2768         return isLatin1() ? StringLatin1.lines(value, maxLeading, maxTrailing)</span>
<span class="line-removed">2769                           : StringUTF16.lines(value, maxLeading, maxTrailing);</span>
<span class="line-removed">2770     }</span>
<span class="line-removed">2771 </span>
2772     /**
2773      * Returns a stream of lines extracted from this string,
2774      * separated by line terminators.
2775      * &lt;p&gt;
2776      * A &lt;i&gt;line terminator&lt;/i&gt; is one of the following:
2777      * a line feed character {@code &quot;\n&quot;} (U+000A),
2778      * a carriage return character {@code &quot;\r&quot;} (U+000D),
2779      * or a carriage return followed immediately by a line feed
2780      * {@code &quot;\r\n&quot;} (U+000D U+000A).
2781      * &lt;p&gt;
2782      * A &lt;i&gt;line&lt;/i&gt; is either a sequence of zero or more characters
2783      * followed by a line terminator, or it is a sequence of one or
2784      * more characters followed by the end of the string. A
2785      * line does not include the line terminator.
2786      * &lt;p&gt;
2787      * The stream returned by this method contains the lines from
2788      * this string in the order in which they occur.
2789      *
2790      * @apiNote This definition of &lt;i&gt;line&lt;/i&gt; implies that an empty
2791      *          string has zero lines and that there is no empty line
2792      *          following a line terminator at the end of a string.
2793      *
2794      * @implNote This method provides better performance than
2795      *           split(&quot;\R&quot;) by supplying elements lazily and
2796      *           by faster search of new line terminators.
2797      *
2798      * @return  the stream of lines extracted from this string
2799      *
2800      * @since 11
2801      */
2802     public Stream&lt;String&gt; lines() {
<span class="line-modified">2803         return lines(0, 0);</span>
2804     }
2805 
2806     /**
2807      * Adjusts the indentation of each line of this string based on the value of
2808      * {@code n}, and normalizes line termination characters.
2809      * &lt;p&gt;
2810      * This string is conceptually separated into lines using
2811      * {@link String#lines()}. Each line is then adjusted as described below
2812      * and then suffixed with a line feed {@code &quot;\n&quot;} (U+000A). The resulting
2813      * lines are then concatenated and returned.
2814      * &lt;p&gt;
2815      * If {@code n &gt; 0} then {@code n} spaces (U+0020) are inserted at the
2816      * beginning of each line.
2817      * &lt;p&gt;
2818      * If {@code n &lt; 0} then up to {@code n}
<span class="line-modified">2819      * {@link Character#isWhitespace(int) white space characters} are removed</span>
2820      * from the beginning of each line. If a given line does not contain
2821      * sufficient white space then all leading
<span class="line-modified">2822      * {@link Character#isWhitespace(int) white space characters} are removed.</span>
2823      * Each white space character is treated as a single character. In
2824      * particular, the tab character {@code &quot;\t&quot;} (U+0009) is considered a
2825      * single character; it is not expanded.
2826      * &lt;p&gt;
2827      * If {@code n == 0} then the line remains unchanged. However, line
2828      * terminators are still normalized.
2829      *
2830      * @param n  number of leading
<span class="line-modified">2831      *           {@link Character#isWhitespace(int) white space characters}</span>
2832      *           to add or remove
2833      *
2834      * @return string with indentation adjusted and line endings normalized
2835      *
2836      * @see String#lines()
2837      * @see String#isBlank()
2838      * @see Character#isWhitespace(int)
2839      *
2840      * @since 12
2841      */
2842     public String indent(int n) {
<span class="line-modified">2843         return isEmpty() ? &quot;&quot; :  indent(n, false);</span>
<span class="line-modified">2844     }</span>
<span class="line-modified">2845 </span>
<span class="line-modified">2846     private String indent(int n, boolean removeBlanks) {</span>
<span class="line-removed">2847         Stream&lt;String&gt; stream = removeBlanks ? lines(Integer.MAX_VALUE, Integer.MAX_VALUE)</span>
<span class="line-removed">2848                                              : lines();</span>
2849         if (n &gt; 0) {
2850             final String spaces = &quot; &quot;.repeat(n);
2851             stream = stream.map(s -&gt; spaces + s);
2852         } else if (n == Integer.MIN_VALUE) {
2853             stream = stream.map(s -&gt; s.stripLeading());
2854         } else if (n &lt; 0) {
2855             stream = stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));
2856         }
2857         return stream.collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;));
2858     }
2859 
2860     private int indexOfNonWhitespace() {
2861         return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)
2862                           : StringUTF16.indexOfNonWhitespace(value);
2863     }
2864 
2865     private int lastIndexOfNonWhitespace() {
2866         return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)
2867                           : StringUTF16.lastIndexOfNonWhitespace(value);
2868     }
2869 






































































































































































































































































































2870     /**
2871      * This method allows the application of a function to {@code this}
2872      * string. The function should expect a single String argument
2873      * and produce an {@code R} result.
2874      * &lt;p&gt;
2875      * Any exception thrown by {@code f()} will be propagated to the
2876      * caller.
2877      *
2878      * @param f    functional interface to a apply
2879      *
2880      * @param &lt;R&gt;  class of the result
2881      *
2882      * @return     the result of applying the function to this string
2883      *
2884      * @see java.util.function.Function
2885      *
2886      * @since 12
2887      */
2888     public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) {
2889         return f.apply(this);
</pre>
<hr />
<pre>
3012      *         &lt;a href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.
3013      *
3014      * @throws  java.util.IllegalFormatException
3015      *          If a format string contains an illegal syntax, a format
3016      *          specifier that is incompatible with the given arguments,
3017      *          insufficient arguments given the format string, or other
3018      *          illegal conditions.  For specification of all possible
3019      *          formatting errors, see the &lt;a
3020      *          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
3021      *          formatter class specification
3022      *
3023      * @return  A formatted string
3024      *
3025      * @see  java.util.Formatter
3026      * @since  1.5
3027      */
3028     public static String format(Locale l, String format, Object... args) {
3029         return new Formatter(l).format(format, args).toString();
3030     }
3031 
































3032     /**
3033      * Returns the string representation of the {@code Object} argument.
3034      *
3035      * @param   obj   an {@code Object}.
3036      * @return  if the argument is {@code null}, then a string equal to
3037      *          {@code &quot;null&quot;}; otherwise, the value of
3038      *          {@code obj.toString()} is returned.
3039      * @see     java.lang.Object#toString()
3040      */
3041     public static String valueOf(Object obj) {
3042         return (obj == null) ? &quot;null&quot; : obj.toString();
3043     }
3044 
3045     /**
3046      * Returns the string representation of the {@code char} array
3047      * argument. The contents of the character array are copied; subsequent
3048      * modification of the character array does not affect the returned
3049      * string.
3050      *
3051      * @param   data     the character array.
</pre>
<hr />
<pre>
3054      */
3055     public static String valueOf(char data[]) {
3056         return new String(data);
3057     }
3058 
3059     /**
3060      * Returns the string representation of a specific subarray of the
3061      * {@code char} array argument.
3062      * &lt;p&gt;
3063      * The {@code offset} argument is the index of the first
3064      * character of the subarray. The {@code count} argument
3065      * specifies the length of the subarray. The contents of the subarray
3066      * are copied; subsequent modification of the character array does not
3067      * affect the returned string.
3068      *
3069      * @param   data     the character array.
3070      * @param   offset   initial offset of the subarray.
3071      * @param   count    length of the subarray.
3072      * @return  a {@code String} that contains the characters of the
3073      *          specified subarray of the character array.
<span class="line-modified">3074      * @exception IndexOutOfBoundsException if {@code offset} is</span>
3075      *          negative, or {@code count} is negative, or
3076      *          {@code offset+count} is larger than
3077      *          {@code data.length}.
3078      */
3079     public static String valueOf(char data[], int offset, int count) {
3080         return new String(data, offset, count);
3081     }
3082 
3083     /**
3084      * Equivalent to {@link #valueOf(char[], int, int)}.
3085      *
3086      * @param   data     the character array.
3087      * @param   offset   initial offset of the subarray.
3088      * @param   count    length of the subarray.
3089      * @return  a {@code String} that contains the characters of the
3090      *          specified subarray of the character array.
<span class="line-modified">3091      * @exception IndexOutOfBoundsException if {@code offset} is</span>
3092      *          negative, or {@code count} is negative, or
3093      *          {@code offset+count} is larger than
3094      *          {@code data.length}.
3095      */
3096     public static String copyValueOf(char data[], int offset, int count) {
3097         return new String(data, offset, count);
3098     }
3099 
3100     /**
3101      * Equivalent to {@link #valueOf(char[])}.
3102      *
3103      * @param   data   the character array.
3104      * @return  a {@code String} that contains the characters of the
3105      *          character array.
3106      */
3107     public static String copyValueOf(char data[]) {
3108         return new String(data);
3109     }
3110 
3111     /**
</pre>
<hr />
<pre>
3336             this.value = Arrays.copyOfRange(val, 0, length &lt;&lt; 1);
3337         }
3338     }
3339 
3340    /*
3341     * Package private constructor which shares value array for speed.
3342     */
3343     String(byte[] value, byte coder) {
3344         this.value = value;
3345         this.coder = coder;
3346     }
3347 
3348     byte coder() {
3349         return COMPACT_STRINGS ? coder : UTF16;
3350     }
3351 
3352     byte[] value() {
3353         return value;
3354     }
3355 
<span class="line-modified">3356     private boolean isLatin1() {</span>
3357         return COMPACT_STRINGS &amp;&amp; coder == LATIN1;
3358     }
3359 
3360     @Native static final byte LATIN1 = 0;
3361     @Native static final byte UTF16  = 1;
3362 
3363     /*
3364      * StringIndexOutOfBoundsException  if {@code index} is
3365      * negative or greater than or equal to {@code length}.
3366      */
3367     static void checkIndex(int index, int length) {
3368         if (index &lt; 0 || index &gt;= length) {
3369             throw new StringIndexOutOfBoundsException(&quot;index &quot; + index +
<span class="line-modified">3370                                                       &quot;,length &quot; + length);</span>
3371         }
3372     }
3373 
3374     /*
3375      * StringIndexOutOfBoundsException  if {@code offset}
3376      * is negative or greater than {@code length}.
3377      */
3378     static void checkOffset(int offset, int length) {
3379         if (offset &lt; 0 || offset &gt; length) {
3380             throw new StringIndexOutOfBoundsException(&quot;offset &quot; + offset +
<span class="line-modified">3381                                                       &quot;,length &quot; + length);</span>
3382         }
3383     }
3384 
3385     /*
3386      * Check {@code offset}, {@code count} against {@code 0} and {@code length}
3387      * bounds.
3388      *
3389      * @throws  StringIndexOutOfBoundsException
3390      *          If {@code offset} is negative, {@code count} is negative,
3391      *          or {@code offset} is greater than {@code length - count}
3392      */
3393     static void checkBoundsOffCount(int offset, int count, int length) {
3394         if (offset &lt; 0 || count &lt; 0 || offset &gt; length - count) {
3395             throw new StringIndexOutOfBoundsException(
3396                 &quot;offset &quot; + offset + &quot;, count &quot; + count + &quot;, length &quot; + length);
3397         }
3398     }
3399 
3400     /*
3401      * Check {@code begin}, {@code end} against {@code 0} and {@code length}
</pre>
</td>
<td>
<hr />
<pre>
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.io.ObjectStreamField;
  29 import java.io.UnsupportedEncodingException;
  30 import java.lang.annotation.Native;
  31 import java.lang.invoke.MethodHandles;
  32 import java.lang.constant.Constable;
  33 import java.lang.constant.ConstantDesc;
  34 import java.nio.charset.Charset;
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Comparator;
  38 import java.util.Formatter;
<span class="line-added">  39 import java.util.List;</span>
  40 import java.util.Locale;
  41 import java.util.Objects;
  42 import java.util.Optional;
  43 import java.util.Spliterator;
  44 import java.util.StringJoiner;
  45 import java.util.function.Function;
  46 import java.util.regex.Matcher;
  47 import java.util.regex.Pattern;
  48 import java.util.regex.PatternSyntaxException;
  49 import java.util.stream.Collectors;
  50 import java.util.stream.IntStream;
  51 import java.util.stream.Stream;
  52 import java.util.stream.StreamSupport;
  53 import jdk.internal.HotSpotIntrinsicCandidate;
  54 import jdk.internal.vm.annotation.Stable;
  55 
  56 import static java.util.function.Predicate.not;
  57 
  58 /**
  59  * The {@code String} class represents character strings. All
  60  * string literals in Java programs, such as {@code &quot;abc&quot;}, are
  61  * implemented as instances of this class.
  62  * &lt;p&gt;
  63  * Strings are constant; their values cannot be changed after they
  64  * are created. String buffers support mutable strings.
  65  * Because String objects are immutable they can be shared. For example:
  66  * &lt;blockquote&gt;&lt;pre&gt;
  67  *     String str = &quot;abc&quot;;
  68  * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
  69  * is equivalent to:
  70  * &lt;blockquote&gt;&lt;pre&gt;
  71  *     char data[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};
  72  *     String str = new String(data);
  73  * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;
  74  * Here are some more examples of how strings can be used:
  75  * &lt;blockquote&gt;&lt;pre&gt;
  76  *     System.out.println(&quot;abc&quot;);
  77  *     String cde = &quot;cde&quot;;
  78  *     System.out.println(&quot;abc&quot; + cde);
<span class="line-modified">  79  *     String c = &quot;abc&quot;.substring(2, 3);</span>
  80  *     String d = cde.substring(1, 2);
  81  * &lt;/pre&gt;&lt;/blockquote&gt;
  82  * &lt;p&gt;
  83  * The class {@code String} includes methods for examining
  84  * individual characters of the sequence, for comparing strings, for
  85  * searching strings, for extracting substrings, and for creating a
  86  * copy of a string with all characters translated to uppercase or to
  87  * lowercase. Case mapping is based on the Unicode Standard version
  88  * specified by the {@link java.lang.Character Character} class.
  89  * &lt;p&gt;
  90  * The Java language provides special support for the string
  91  * concatenation operator (&amp;nbsp;+&amp;nbsp;), and for conversion of
  92  * other objects to strings. For additional information on string
  93  * concatenation and conversion, see &lt;i&gt;The Java&amp;trade; Language Specification&lt;/i&gt;.
  94  *
  95  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  96  * or method in this class will cause a {@link NullPointerException} to be
  97  * thrown.
  98  *
  99  * &lt;p&gt;A {@code String} represents a string in the UTF-16 format
</pre>
<hr />
<pre>
 148      */
 149     @Stable
 150     private final byte[] value;
 151 
 152     /**
 153      * The identifier of the encoding used to encode the bytes in
 154      * {@code value}. The supported values in this implementation are
 155      *
 156      * LATIN1
 157      * UTF16
 158      *
 159      * @implNote This field is trusted by the VM, and is a subject to
 160      * constant folding if String instance is constant. Overwriting this
 161      * field after construction will cause problems.
 162      */
 163     private final byte coder;
 164 
 165     /** Cache the hash code for the string */
 166     private int hash; // Default to 0
 167 
<span class="line-added"> 168     /**</span>
<span class="line-added"> 169      * Cache if the hash has been calculated as actually being zero, enabling</span>
<span class="line-added"> 170      * us to avoid recalculating this.</span>
<span class="line-added"> 171      */</span>
<span class="line-added"> 172     private boolean hashIsZero; // Default to false;</span>
<span class="line-added"> 173 </span>
 174     /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added"> 175     @java.io.Serial</span>
 176     private static final long serialVersionUID = -6849794470754667710L;
 177 
 178     /**
 179      * If String compaction is disabled, the bytes in {@code value} are
 180      * always encoded in UTF16.
 181      *
 182      * For methods with several possible implementation paths, when String
 183      * compaction is disabled, only one code path is taken.
 184      *
 185      * The instance field value is generally opaque to optimizing JIT
 186      * compilers. Therefore, in performance-sensitive place, an explicit
 187      * check of the static boolean {@code COMPACT_STRINGS} is done first
 188      * before checking the {@code coder} field since the static boolean
 189      * {@code COMPACT_STRINGS} would be constant folded away by an
 190      * optimizing JIT compiler. The idioms for these cases are as follows.
 191      *
 192      * For code such as:
 193      *
 194      *    if (coder == LATIN1) { ... }
 195      *
</pre>
<hr />
<pre>
 208      *
 209      * @implNote
 210      * The actual value for this field is injected by JVM. The static
 211      * initialization block is used to set the value here to communicate
 212      * that this static final field is not statically foldable, and to
 213      * avoid any possible circular dependency during vm initialization.
 214      */
 215     static final boolean COMPACT_STRINGS;
 216 
 217     static {
 218         COMPACT_STRINGS = true;
 219     }
 220 
 221     /**
 222      * Class String is special cased within the Serialization Stream Protocol.
 223      *
 224      * A String instance is written into an ObjectOutputStream according to
 225      * &lt;a href=&quot;{@docRoot}/../specs/serialization/protocol.html#stream-elements&quot;&gt;
 226      * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;
 227      */
<span class="line-added"> 228     @java.io.Serial</span>
 229     private static final ObjectStreamField[] serialPersistentFields =
 230         new ObjectStreamField[0];
 231 
 232     /**
 233      * Initializes a newly created {@code String} object so that it represents
 234      * an empty character sequence.  Note that use of this constructor is
 235      * unnecessary since Strings are immutable.
 236      */
 237     public String() {
 238         this.value = &quot;&quot;.value;
 239         this.coder = &quot;&quot;.coder;
 240     }
 241 
 242     /**
 243      * Initializes a newly created {@code String} object so that it represents
 244      * the same sequence of characters as the argument; in other words, the
 245      * newly created string is a copy of the argument string. Unless an
 246      * explicit copy of {@code original} is needed, use of this constructor is
 247      * unnecessary since Strings are immutable.
 248      *
</pre>
<hr />
<pre>
 685      * @since 1.6
 686      */
 687     public boolean isEmpty() {
 688         return value.length == 0;
 689     }
 690 
 691     /**
 692      * Returns the {@code char} value at the
 693      * specified index. An index ranges from {@code 0} to
 694      * {@code length() - 1}. The first {@code char} value of the sequence
 695      * is at index {@code 0}, the next at index {@code 1},
 696      * and so on, as for array indexing.
 697      *
 698      * &lt;p&gt;If the {@code char} value specified by the index is a
 699      * &lt;a href=&quot;Character.html#unicode&quot;&gt;surrogate&lt;/a&gt;, the surrogate
 700      * value is returned.
 701      *
 702      * @param      index   the index of the {@code char} value.
 703      * @return     the {@code char} value at the specified index of this string.
 704      *             The first {@code char} value is at index {@code 0}.
<span class="line-modified"> 705      * @throws     IndexOutOfBoundsException  if the {@code index}</span>
 706      *             argument is negative or not less than the length of this
 707      *             string.
 708      */
 709     public char charAt(int index) {
 710         if (isLatin1()) {
 711             return StringLatin1.charAt(value, index);
 712         } else {
 713             return StringUTF16.charAt(value, index);
 714         }
 715     }
 716 
 717     /**
 718      * Returns the character (Unicode code point) at the specified
 719      * index. The index refers to {@code char} values
 720      * (Unicode code units) and ranges from {@code 0} to
 721      * {@link #length()}{@code  - 1}.
 722      *
 723      * &lt;p&gt; If the {@code char} value specified at the given index
 724      * is in the high-surrogate range, the following index is less
 725      * than the length of this {@code String}, and the
 726      * {@code char} value at the following index is in the
 727      * low-surrogate range, then the supplementary code point
 728      * corresponding to this surrogate pair is returned. Otherwise,
 729      * the {@code char} value at the given index is returned.
 730      *
 731      * @param      index the index to the {@code char} values
 732      * @return     the code point value of the character at the
 733      *             {@code index}
<span class="line-modified"> 734      * @throws     IndexOutOfBoundsException  if the {@code index}</span>
 735      *             argument is negative or not less than the length of this
 736      *             string.
 737      * @since      1.5
 738      */
 739     public int codePointAt(int index) {
 740         if (isLatin1()) {
 741             checkIndex(index, value.length);
 742             return value[index] &amp; 0xff;
 743         }
 744         int length = value.length &gt;&gt; 1;
 745         checkIndex(index, length);
 746         return StringUTF16.codePointAt(value, index, length);
 747     }
 748 
 749     /**
 750      * Returns the character (Unicode code point) before the specified
 751      * index. The index refers to {@code char} values
 752      * (Unicode code units) and ranges from {@code 1} to {@link
 753      * CharSequence#length() length}.
 754      *
 755      * &lt;p&gt; If the {@code char} value at {@code (index - 1)}
 756      * is in the low-surrogate range, {@code (index - 2)} is not
 757      * negative, and the {@code char} value at {@code (index -
 758      * 2)} is in the high-surrogate range, then the
 759      * supplementary code point value of the surrogate pair is
 760      * returned. If the {@code char} value at {@code index -
 761      * 1} is an unpaired low-surrogate or a high-surrogate, the
 762      * surrogate value is returned.
 763      *
 764      * @param     index the index following the code point that should be returned
 765      * @return    the Unicode code point value before the given index.
<span class="line-modified"> 766      * @throws    IndexOutOfBoundsException if the {@code index}</span>
 767      *            argument is less than 1 or greater than the length
 768      *            of this string.
 769      * @since     1.5
 770      */
 771     public int codePointBefore(int index) {
 772         int i = index - 1;
 773         if (i &lt; 0 || i &gt;= length()) {
 774             throw new StringIndexOutOfBoundsException(index);
 775         }
 776         if (isLatin1()) {
 777             return (value[i] &amp; 0xff);
 778         }
 779         return StringUTF16.codePointBefore(value, index);
 780     }
 781 
 782     /**
 783      * Returns the number of Unicode code points in the specified text
 784      * range of this {@code String}. The text range begins at the
 785      * specified {@code beginIndex} and extends to the
 786      * {@code char} at index {@code endIndex - 1}. Thus the
 787      * length (in {@code char}s) of the text range is
 788      * {@code endIndex-beginIndex}. Unpaired surrogates within
 789      * the text range count as one code point each.
 790      *
 791      * @param beginIndex the index to the first {@code char} of
 792      * the text range.
 793      * @param endIndex the index after the last {@code char} of
 794      * the text range.
 795      * @return the number of Unicode code points in the specified text
 796      * range
<span class="line-modified"> 797      * @throws    IndexOutOfBoundsException if the</span>
 798      * {@code beginIndex} is negative, or {@code endIndex}
 799      * is larger than the length of this {@code String}, or
 800      * {@code beginIndex} is larger than {@code endIndex}.
 801      * @since  1.5
 802      */
 803     public int codePointCount(int beginIndex, int endIndex) {
 804         if (beginIndex &lt; 0 || beginIndex &gt; endIndex ||
 805             endIndex &gt; length()) {
 806             throw new IndexOutOfBoundsException();
 807         }
 808         if (isLatin1()) {
 809             return endIndex - beginIndex;
 810         }
 811         return StringUTF16.codePointCount(value, beginIndex, endIndex);
 812     }
 813 
 814     /**
 815      * Returns the index within this {@code String} that is
 816      * offset from the given {@code index} by
 817      * {@code codePointOffset} code points. Unpaired surrogates
 818      * within the text range given by {@code index} and
 819      * {@code codePointOffset} count as one code point each.
 820      *
 821      * @param index the index to be offset
 822      * @param codePointOffset the offset in code points
 823      * @return the index within this {@code String}
<span class="line-modified"> 824      * @throws    IndexOutOfBoundsException if {@code index}</span>
 825      *   is negative or larger then the length of this
 826      *   {@code String}, or if {@code codePointOffset} is positive
 827      *   and the substring starting with {@code index} has fewer
 828      *   than {@code codePointOffset} code points,
 829      *   or if {@code codePointOffset} is negative and the substring
 830      *   before {@code index} has fewer than the absolute value
 831      *   of {@code codePointOffset} code points.
 832      * @since 1.5
 833      */
 834     public int offsetByCodePoints(int index, int codePointOffset) {
 835         if (index &lt; 0 || index &gt; length()) {
 836             throw new IndexOutOfBoundsException();
 837         }
 838         return Character.offsetByCodePoints(this, index, codePointOffset);
 839     }
 840 
 841     /**
 842      * Copies characters from this string into the destination character
 843      * array.
 844      * &lt;p&gt;
 845      * The first character to be copied is at index {@code srcBegin};
 846      * the last character to be copied is at index {@code srcEnd-1}
 847      * (thus the total number of characters to be copied is
 848      * {@code srcEnd-srcBegin}). The characters are copied into the
 849      * subarray of {@code dst} starting at index {@code dstBegin}
 850      * and ending at index:
 851      * &lt;blockquote&gt;&lt;pre&gt;
 852      *     dstBegin + (srcEnd-srcBegin) - 1
 853      * &lt;/pre&gt;&lt;/blockquote&gt;
 854      *
 855      * @param      srcBegin   index of the first character in the string
 856      *                        to copy.
 857      * @param      srcEnd     index after the last character in the string
 858      *                        to copy.
 859      * @param      dst        the destination array.
 860      * @param      dstBegin   the start offset in the destination array.
<span class="line-modified"> 861      * @throws    IndexOutOfBoundsException If any of the following</span>
 862      *            is true:
 863      *            &lt;ul&gt;&lt;li&gt;{@code srcBegin} is negative.
 864      *            &lt;li&gt;{@code srcBegin} is greater than {@code srcEnd}
 865      *            &lt;li&gt;{@code srcEnd} is greater than the length of this
 866      *                string
 867      *            &lt;li&gt;{@code dstBegin} is negative
 868      *            &lt;li&gt;{@code dstBegin+(srcEnd-srcBegin)} is larger than
 869      *                {@code dst.length}&lt;/ul&gt;
 870      */
 871     public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {
 872         checkBoundsBeginEnd(srcBegin, srcEnd, length());
 873         checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);
 874         if (isLatin1()) {
 875             StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);
 876         } else {
 877             StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);
 878         }
 879     }
 880 
 881     /**
</pre>
<hr />
<pre>
1006      * object.
1007      *
1008      * &lt;p&gt;For finer-grained String comparison, refer to
1009      * {@link java.text.Collator}.
1010      *
1011      * @param  anObject
1012      *         The object to compare this {@code String} against
1013      *
1014      * @return  {@code true} if the given object represents a {@code String}
1015      *          equivalent to this string, {@code false} otherwise
1016      *
1017      * @see  #compareTo(String)
1018      * @see  #equalsIgnoreCase(String)
1019      */
1020     public boolean equals(Object anObject) {
1021         if (this == anObject) {
1022             return true;
1023         }
1024         if (anObject instanceof String) {
1025             String aString = (String)anObject;
<span class="line-modified">1026             if (!COMPACT_STRINGS || this.coder == aString.coder) {</span>
<span class="line-modified">1027                 return StringLatin1.equals(value, aString.value);</span>

1028             }
1029         }
1030         return false;
1031     }
1032 
1033     /**
1034      * Compares this string to the specified {@code StringBuffer}.  The result
1035      * is {@code true} if and only if this {@code String} represents the same
1036      * sequence of characters as the specified {@code StringBuffer}. This method
1037      * synchronizes on the {@code StringBuffer}.
1038      *
1039      * &lt;p&gt;For finer-grained String comparison, refer to
1040      * {@link java.text.Collator}.
1041      *
1042      * @param  sb
1043      *         The {@code StringBuffer} to compare this {@code String} against
1044      *
1045      * @return  {@code true} if this {@code String} represents the same
1046      *          sequence of characters as the specified {@code StringBuffer},
1047      *          {@code false} otherwise
1048      *
1049      * @since  1.4
1050      */
1051     public boolean contentEquals(StringBuffer sb) {
1052         return contentEquals((CharSequence)sb);
1053     }
1054 
1055     private boolean nonSyncContentEquals(AbstractStringBuilder sb) {
1056         int len = length();
1057         if (len != sb.length()) {
1058             return false;
1059         }
1060         byte v1[] = value;
1061         byte v2[] = sb.getValue();
<span class="line-modified">1062         byte coder = coder();</span>
<span class="line-added">1063         if (coder == sb.getCoder()) {</span>
1064             int n = v1.length;
1065             for (int i = 0; i &lt; n; i++) {
1066                 if (v1[i] != v2[i]) {
1067                     return false;
1068                 }
1069             }
1070         } else {
<span class="line-modified">1071             if (coder != LATIN1) {  // utf16 str and latin1 abs can never be &quot;equal&quot;</span>
1072                 return false;
1073             }
1074             return StringUTF16.contentEquals(v1, v2, len);
1075         }
1076         return true;
1077     }
1078 
1079     /**
1080      * Compares this string to the specified {@code CharSequence}.  The
1081      * result is {@code true} if and only if this {@code String} represents the
1082      * same sequence of char values as the specified sequence. Note that if the
1083      * {@code CharSequence} is a {@code StringBuffer} then the method
1084      * synchronizes on it.
1085      *
1086      * &lt;p&gt;For finer-grained String comparison, refer to
1087      * {@link java.text.Collator}.
1088      *
1089      * @param  cs
1090      *         The sequence to compare this {@code String} against
1091      *
</pre>
<hr />
<pre>
1195      * string lexicographically precedes the longer string. In this case,
1196      * {@code compareTo} returns the difference of the lengths of the
1197      * strings -- that is, the value:
1198      * &lt;blockquote&gt;&lt;pre&gt;
1199      * this.length()-anotherString.length()
1200      * &lt;/pre&gt;&lt;/blockquote&gt;
1201      *
1202      * &lt;p&gt;For finer-grained String comparison, refer to
1203      * {@link java.text.Collator}.
1204      *
1205      * @param   anotherString   the {@code String} to be compared.
1206      * @return  the value {@code 0} if the argument string is equal to
1207      *          this string; a value less than {@code 0} if this string
1208      *          is lexicographically less than the string argument; and a
1209      *          value greater than {@code 0} if this string is
1210      *          lexicographically greater than the string argument.
1211      */
1212     public int compareTo(String anotherString) {
1213         byte v1[] = value;
1214         byte v2[] = anotherString.value;
<span class="line-modified">1215         byte coder = coder();</span>
<span class="line-modified">1216         if (coder == anotherString.coder()) {</span>
<span class="line-modified">1217             return coder == LATIN1 ? StringLatin1.compareTo(v1, v2)</span>
<span class="line-added">1218                                    : StringUTF16.compareTo(v1, v2);</span>
1219         }
<span class="line-modified">1220         return coder == LATIN1 ? StringLatin1.compareToUTF16(v1, v2)</span>
<span class="line-modified">1221                                : StringUTF16.compareToLatin1(v1, v2);</span>
1222      }
1223 
1224     /**
1225      * A Comparator that orders {@code String} objects as by
1226      * {@code compareToIgnoreCase}. This comparator is serializable.
1227      * &lt;p&gt;
1228      * Note that this Comparator does &lt;em&gt;not&lt;/em&gt; take locale into account,
1229      * and will result in an unsatisfactory ordering for certain locales.
1230      * The {@link java.text.Collator} class provides locale-sensitive comparison.
1231      *
1232      * @see     java.text.Collator
1233      * @since   1.2
1234      */
1235     public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER
1236                                          = new CaseInsensitiveComparator();
1237     private static class CaseInsensitiveComparator
1238             implements Comparator&lt;String&gt;, java.io.Serializable {
1239         // use serialVersionUID from JDK 1.2.2 for interoperability
<span class="line-added">1240         @java.io.Serial</span>
1241         private static final long serialVersionUID = 8575799808933029326L;
1242 
1243         public int compare(String s1, String s2) {
1244             byte v1[] = s1.value;
1245             byte v2[] = s2.value;
<span class="line-modified">1246             byte coder = s1.coder();</span>
<span class="line-modified">1247             if (coder == s2.coder()) {</span>
<span class="line-modified">1248                 return coder == LATIN1 ? StringLatin1.compareToCI(v1, v2)</span>
<span class="line-added">1249                                        : StringUTF16.compareToCI(v1, v2);</span>
1250             }
<span class="line-modified">1251             return coder == LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)</span>
<span class="line-modified">1252                                    : StringUTF16.compareToCI_Latin1(v1, v2);</span>
1253         }
1254 
1255         /** Replaces the de-serialized object. */
<span class="line-added">1256         @java.io.Serial</span>
1257         private Object readResolve() { return CASE_INSENSITIVE_ORDER; }
1258     }
1259 
1260     /**
1261      * Compares two strings lexicographically, ignoring case
1262      * differences. This method returns an integer whose sign is that of
1263      * calling {@code compareTo} with normalized versions of the strings
1264      * where case differences have been eliminated by calling
1265      * {@code Character.toLowerCase(Character.toUpperCase(character))} on
1266      * each character.
1267      * &lt;p&gt;
1268      * Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account,
1269      * and will result in an unsatisfactory ordering for certain locales.
1270      * The {@link java.text.Collator} class provides locale-sensitive comparison.
1271      *
1272      * @param   str   the {@code String} to be compared.
1273      * @return  a negative integer, zero, or a positive integer as the
1274      *          specified String is greater than, equal to, or less
1275      *          than this String, ignoring case considerations.
1276      * @see     java.text.Collator
</pre>
<hr />
<pre>
1307      * {@link java.text.Collator} class provides locale-sensitive comparison.
1308      *
1309      * @param   toffset   the starting offset of the subregion in this string.
1310      * @param   other     the string argument.
1311      * @param   ooffset   the starting offset of the subregion in the string
1312      *                    argument.
1313      * @param   len       the number of characters to compare.
1314      * @return  {@code true} if the specified subregion of this string
1315      *          exactly matches the specified subregion of the string argument;
1316      *          {@code false} otherwise.
1317      */
1318     public boolean regionMatches(int toffset, String other, int ooffset, int len) {
1319         byte tv[] = value;
1320         byte ov[] = other.value;
1321         // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.
1322         if ((ooffset &lt; 0) || (toffset &lt; 0) ||
1323              (toffset &gt; (long)length() - len) ||
1324              (ooffset &gt; (long)other.length() - len)) {
1325             return false;
1326         }
<span class="line-modified">1327         byte coder = coder();</span>
<span class="line-added">1328         if (coder == other.coder()) {</span>
1329             if (!isLatin1() &amp;&amp; (len &gt; 0)) {
1330                 toffset = toffset &lt;&lt; 1;
1331                 ooffset = ooffset &lt;&lt; 1;
1332                 len = len &lt;&lt; 1;
1333             }
1334             while (len-- &gt; 0) {
1335                 if (tv[toffset++] != ov[ooffset++]) {
1336                     return false;
1337                 }
1338             }
1339         } else {
<span class="line-modified">1340             if (coder == LATIN1) {</span>
1341                 while (len-- &gt; 0) {
1342                     if (StringLatin1.getChar(tv, toffset++) !=
1343                         StringUTF16.getChar(ov, ooffset++)) {
1344                         return false;
1345                     }
1346                 }
1347             } else {
1348                 while (len-- &gt; 0) {
1349                     if (StringUTF16.getChar(tv, toffset++) !=
1350                         StringLatin1.getChar(ov, ooffset++)) {
1351                         return false;
1352                     }
1353                 }
1354             }
1355         }
1356         return true;
1357     }
1358 
1359     /**
1360      * Tests if two string regions are equal.
</pre>
<hr />
<pre>
1402      * @param   len          the number of characters to compare.
1403      * @return  {@code true} if the specified subregion of this string
1404      *          matches the specified subregion of the string argument;
1405      *          {@code false} otherwise. Whether the matching is exact
1406      *          or case insensitive depends on the {@code ignoreCase}
1407      *          argument.
1408      */
1409     public boolean regionMatches(boolean ignoreCase, int toffset,
1410             String other, int ooffset, int len) {
1411         if (!ignoreCase) {
1412             return regionMatches(toffset, other, ooffset, len);
1413         }
1414         // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.
1415         if ((ooffset &lt; 0) || (toffset &lt; 0)
1416                 || (toffset &gt; (long)length() - len)
1417                 || (ooffset &gt; (long)other.length() - len)) {
1418             return false;
1419         }
1420         byte tv[] = value;
1421         byte ov[] = other.value;
<span class="line-modified">1422         byte coder = coder();</span>
<span class="line-modified">1423         if (coder == other.coder()) {</span>
<span class="line-added">1424             return coder == LATIN1</span>
1425               ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)
1426               : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);
1427         }
<span class="line-modified">1428         return coder == LATIN1</span>
1429               ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)
1430               : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);
1431     }
1432 
1433     /**
1434      * Tests if the substring of this string beginning at the
1435      * specified index starts with the specified prefix.
1436      *
1437      * @param   prefix    the prefix.
1438      * @param   toffset   where to begin looking in this string.
1439      * @return  {@code true} if the character sequence represented by the
1440      *          argument is a prefix of the substring of this object starting
1441      *          at index {@code toffset}; {@code false} otherwise.
1442      *          The result is {@code false} if {@code toffset} is
1443      *          negative or greater than the length of this
1444      *          {@code String} object; otherwise the result is the same
1445      *          as the result of the expression
1446      *          &lt;pre&gt;
1447      *          this.substring(toffset).startsWith(prefix)
1448      *          &lt;/pre&gt;
1449      */
1450     public boolean startsWith(String prefix, int toffset) {
1451         // Note: toffset might be near -1&gt;&gt;&gt;1.
1452         if (toffset &lt; 0 || toffset &gt; length() - prefix.length()) {
1453             return false;
1454         }
1455         byte ta[] = value;
1456         byte pa[] = prefix.value;
1457         int po = 0;
1458         int pc = pa.length;
<span class="line-modified">1459         byte coder = coder();</span>
<span class="line-modified">1460         if (coder == prefix.coder()) {</span>
<span class="line-added">1461             int to = (coder == LATIN1) ? toffset : toffset &lt;&lt; 1;</span>
1462             while (po &lt; pc) {
1463                 if (ta[to++] != pa[po++]) {
1464                     return false;
1465                 }
1466             }
1467         } else {
<span class="line-modified">1468             if (coder == LATIN1) {  // &amp;&amp; pcoder == UTF16</span>
1469                 return false;
1470             }
1471             // coder == UTF16 &amp;&amp; pcoder == LATIN1)
1472             while (po &lt; pc) {
1473                 if (StringUTF16.getChar(ta, toffset++) != (pa[po++] &amp; 0xff)) {
1474                     return false;
1475                }
1476             }
1477         }
1478         return true;
1479     }
1480 
1481     /**
1482      * Tests if this string starts with the specified prefix.
1483      *
1484      * @param   prefix   the prefix.
1485      * @return  {@code true} if the character sequence represented by the
1486      *          argument is a prefix of the character sequence represented by
1487      *          this string; {@code false} otherwise.
1488      *          Note also that {@code true} will be returned if the
</pre>
<hr />
<pre>
1507      *          as determined by the {@link #equals(Object)} method.
1508      */
1509     public boolean endsWith(String suffix) {
1510         return startsWith(suffix, length() - suffix.length());
1511     }
1512 
1513     /**
1514      * Returns a hash code for this string. The hash code for a
1515      * {@code String} object is computed as
1516      * &lt;blockquote&gt;&lt;pre&gt;
1517      * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
1518      * &lt;/pre&gt;&lt;/blockquote&gt;
1519      * using {@code int} arithmetic, where {@code s[i]} is the
1520      * &lt;i&gt;i&lt;/i&gt;th character of the string, {@code n} is the length of
1521      * the string, and {@code ^} indicates exponentiation.
1522      * (The hash value of the empty string is zero.)
1523      *
1524      * @return  a hash code value for this object.
1525      */
1526     public int hashCode() {
<span class="line-added">1527         // The hash or hashIsZero fields are subject to a benign data race,</span>
<span class="line-added">1528         // making it crucial to ensure that any observable result of the</span>
<span class="line-added">1529         // calculation in this method stays correct under any possible read of</span>
<span class="line-added">1530         // these fields. Necessary restrictions to allow this to be correct</span>
<span class="line-added">1531         // without explicit memory fences or similar concurrency primitives is</span>
<span class="line-added">1532         // that we can ever only write to one of these two fields for a given</span>
<span class="line-added">1533         // String instance, and that the computation is idempotent and derived</span>
<span class="line-added">1534         // from immutable state</span>
1535         int h = hash;
<span class="line-modified">1536         if (h == 0 &amp;&amp; !hashIsZero) {</span>
<span class="line-modified">1537             h = isLatin1() ? StringLatin1.hashCode(value)</span>
<span class="line-modified">1538                            : StringUTF16.hashCode(value);</span>
<span class="line-added">1539             if (h == 0) {</span>
<span class="line-added">1540                 hashIsZero = true;</span>
<span class="line-added">1541             } else {</span>
<span class="line-added">1542                 hash = h;</span>
<span class="line-added">1543             }</span>
1544         }
1545         return h;
1546     }
1547 
1548     /**
1549      * Returns the index within this string of the first occurrence of
1550      * the specified character. If a character with value
1551      * {@code ch} occurs in the character sequence represented by
1552      * this {@code String} object, then the index (in Unicode
1553      * code units) of the first such occurrence is returned. For
1554      * values of {@code ch} in the range from 0 to 0xFFFF
1555      * (inclusive), this is the smallest value &lt;i&gt;k&lt;/i&gt; such that:
1556      * &lt;blockquote&gt;&lt;pre&gt;
1557      * this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch
1558      * &lt;/pre&gt;&lt;/blockquote&gt;
1559      * is true. For other values of {@code ch}, it is the
1560      * smallest value &lt;i&gt;k&lt;/i&gt; such that:
1561      * &lt;blockquote&gt;&lt;pre&gt;
1562      * this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch
1563      * &lt;/pre&gt;&lt;/blockquote&gt;
</pre>
<hr />
<pre>
1681     public int lastIndexOf(int ch, int fromIndex) {
1682         return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)
1683                           : StringUTF16.lastIndexOf(value, ch, fromIndex);
1684     }
1685 
1686     /**
1687      * Returns the index within this string of the first occurrence of the
1688      * specified substring.
1689      *
1690      * &lt;p&gt;The returned index is the smallest value {@code k} for which:
1691      * &lt;pre&gt;{@code
1692      * this.startsWith(str, k)
1693      * }&lt;/pre&gt;
1694      * If no such value of {@code k} exists, then {@code -1} is returned.
1695      *
1696      * @param   str   the substring to search for.
1697      * @return  the index of the first occurrence of the specified substring,
1698      *          or {@code -1} if there is no such occurrence.
1699      */
1700     public int indexOf(String str) {
<span class="line-modified">1701         byte coder = coder();</span>
<span class="line-added">1702         if (coder == str.coder()) {</span>
1703             return isLatin1() ? StringLatin1.indexOf(value, str.value)
1704                               : StringUTF16.indexOf(value, str.value);
1705         }
<span class="line-modified">1706         if (coder == LATIN1) {  // str.coder == UTF16</span>
1707             return -1;
1708         }
1709         return StringUTF16.indexOfLatin1(value, str.value);
1710     }
1711 
1712     /**
1713      * Returns the index within this string of the first occurrence of the
1714      * specified substring, starting at the specified index.
1715      *
1716      * &lt;p&gt;The returned index is the smallest value {@code k} for which:
1717      * &lt;pre&gt;{@code
1718      *     k &gt;= Math.min(fromIndex, this.length()) &amp;&amp;
1719      *                   this.startsWith(str, k)
1720      * }&lt;/pre&gt;
1721      * If no such value of {@code k} exists, then {@code -1} is returned.
1722      *
1723      * @param   str         the substring to search for.
1724      * @param   fromIndex   the index from which to start the search.
1725      * @return  the index of the first occurrence of the specified substring,
1726      *          starting at the specified index,
</pre>
<hr />
<pre>
1850         if (srcCoder == LATIN1) {    // &amp;&amp; tgtCoder == UTF16
1851             return -1;
1852         }
1853         // srcCoder == UTF16 &amp;&amp; tgtCoder == LATIN1
1854         return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);
1855     }
1856 
1857     /**
1858      * Returns a string that is a substring of this string. The
1859      * substring begins with the character at the specified index and
1860      * extends to the end of this string. &lt;p&gt;
1861      * Examples:
1862      * &lt;blockquote&gt;&lt;pre&gt;
1863      * &quot;unhappy&quot;.substring(2) returns &quot;happy&quot;
1864      * &quot;Harbison&quot;.substring(3) returns &quot;bison&quot;
1865      * &quot;emptiness&quot;.substring(9) returns &quot;&quot; (an empty string)
1866      * &lt;/pre&gt;&lt;/blockquote&gt;
1867      *
1868      * @param      beginIndex   the beginning index, inclusive.
1869      * @return     the specified substring.
<span class="line-modified">1870      * @throws     IndexOutOfBoundsException  if</span>
1871      *             {@code beginIndex} is negative or larger than the
1872      *             length of this {@code String} object.
1873      */
1874     public String substring(int beginIndex) {
<span class="line-modified">1875         return substring(beginIndex, length());</span>











1876     }
1877 
1878     /**
1879      * Returns a string that is a substring of this string. The
1880      * substring begins at the specified {@code beginIndex} and
1881      * extends to the character at index {@code endIndex - 1}.
1882      * Thus the length of the substring is {@code endIndex-beginIndex}.
1883      * &lt;p&gt;
1884      * Examples:
1885      * &lt;blockquote&gt;&lt;pre&gt;
1886      * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;
1887      * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;
1888      * &lt;/pre&gt;&lt;/blockquote&gt;
1889      *
1890      * @param      beginIndex   the beginning index, inclusive.
1891      * @param      endIndex     the ending index, exclusive.
1892      * @return     the specified substring.
<span class="line-modified">1893      * @throws     IndexOutOfBoundsException  if the</span>
1894      *             {@code beginIndex} is negative, or
1895      *             {@code endIndex} is larger than the length of
1896      *             this {@code String} object, or
1897      *             {@code beginIndex} is larger than
1898      *             {@code endIndex}.
1899      */
1900     public String substring(int beginIndex, int endIndex) {
1901         int length = length();
1902         checkBoundsBeginEnd(beginIndex, endIndex, length);
1903         int subLen = endIndex - beginIndex;
1904         if (beginIndex == 0 &amp;&amp; endIndex == length) {
1905             return this;
1906         }
1907         return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)
1908                           : StringUTF16.newString(value, beginIndex, subLen);
1909     }
1910 
1911     /**
1912      * Returns a character sequence that is a subsequence of this sequence.
1913      *
</pre>
<hr />
<pre>
1948      * {@code String} object is returned. Otherwise, a
1949      * {@code String} object is returned that represents a character
1950      * sequence that is the concatenation of the character sequence
1951      * represented by this {@code String} object and the character
1952      * sequence represented by the argument string.&lt;p&gt;
1953      * Examples:
1954      * &lt;blockquote&gt;&lt;pre&gt;
1955      * &quot;cares&quot;.concat(&quot;s&quot;) returns &quot;caress&quot;
1956      * &quot;to&quot;.concat(&quot;get&quot;).concat(&quot;her&quot;) returns &quot;together&quot;
1957      * &lt;/pre&gt;&lt;/blockquote&gt;
1958      *
1959      * @param   str   the {@code String} that is concatenated to the end
1960      *                of this {@code String}.
1961      * @return  a string that represents the concatenation of this object&#39;s
1962      *          characters followed by the string argument&#39;s characters.
1963      */
1964     public String concat(String str) {
1965         if (str.isEmpty()) {
1966             return this;
1967         }
<span class="line-modified">1968         return StringConcatHelper.simpleConcat(this, str);</span>













1969     }
1970 
1971     /**
1972      * Returns a string resulting from replacing all occurrences of
1973      * {@code oldChar} in this string with {@code newChar}.
1974      * &lt;p&gt;
1975      * If the character {@code oldChar} does not occur in the
1976      * character sequence represented by this {@code String} object,
1977      * then a reference to this {@code String} object is returned.
1978      * Otherwise, a {@code String} object is returned that
1979      * represents a character sequence identical to the character sequence
1980      * represented by this {@code String} object, except that every
1981      * occurrence of {@code oldChar} is replaced by an occurrence
1982      * of {@code newChar}.
1983      * &lt;p&gt;
1984      * Examples:
1985      * &lt;blockquote&gt;&lt;pre&gt;
1986      * &quot;mesquite in your cellar&quot;.replace(&#39;e&#39;, &#39;o&#39;)
1987      *         returns &quot;mosquito in your collar&quot;
1988      * &quot;the war of baronets&quot;.replace(&#39;r&#39;, &#39;y&#39;)
</pre>
<hr />
<pre>
2137      * @since 1.4
2138      * @spec JSR-51
2139      */
2140     public String replaceAll(String regex, String replacement) {
2141         return Pattern.compile(regex).matcher(this).replaceAll(replacement);
2142     }
2143 
2144     /**
2145      * Replaces each substring of this string that matches the literal target
2146      * sequence with the specified literal replacement sequence. The
2147      * replacement proceeds from the beginning of the string to the end, for
2148      * example, replacing &quot;aa&quot; with &quot;b&quot; in the string &quot;aaa&quot; will result in
2149      * &quot;ba&quot; rather than &quot;ab&quot;.
2150      *
2151      * @param  target The sequence of char values to be replaced
2152      * @param  replacement The replacement sequence of char values
2153      * @return  The resulting string
2154      * @since 1.5
2155      */
2156     public String replace(CharSequence target, CharSequence replacement) {
<span class="line-modified">2157         String trgtStr = target.toString();</span>
2158         String replStr = replacement.toString();






2159         int thisLen = length();
<span class="line-added">2160         int trgtLen = trgtStr.length();</span>
<span class="line-added">2161         int replLen = replStr.length();</span>
<span class="line-added">2162 </span>
<span class="line-added">2163         if (trgtLen &gt; 0) {</span>
<span class="line-added">2164             if (trgtLen == 1 &amp;&amp; replLen == 1) {</span>
<span class="line-added">2165                 return replace(trgtStr.charAt(0), replStr.charAt(0));</span>
<span class="line-added">2166             }</span>
<span class="line-added">2167 </span>
<span class="line-added">2168             boolean thisIsLatin1 = this.isLatin1();</span>
<span class="line-added">2169             boolean trgtIsLatin1 = trgtStr.isLatin1();</span>
<span class="line-added">2170             boolean replIsLatin1 = replStr.isLatin1();</span>
<span class="line-added">2171             String ret = (thisIsLatin1 &amp;&amp; trgtIsLatin1 &amp;&amp; replIsLatin1)</span>
<span class="line-added">2172                     ? StringLatin1.replace(value, thisLen,</span>
<span class="line-added">2173                                            trgtStr.value, trgtLen,</span>
<span class="line-added">2174                                            replStr.value, replLen)</span>
<span class="line-added">2175                     : StringUTF16.replace(value, thisLen, thisIsLatin1,</span>
<span class="line-added">2176                                           trgtStr.value, trgtLen, trgtIsLatin1,</span>
<span class="line-added">2177                                           replStr.value, replLen, replIsLatin1);</span>
<span class="line-added">2178             if (ret != null) {</span>
<span class="line-added">2179                 return ret;</span>
<span class="line-added">2180             }</span>
<span class="line-added">2181             return this;</span>
<span class="line-added">2182 </span>
<span class="line-added">2183         } else { // trgtLen == 0</span>
<span class="line-added">2184             int resultLen;</span>
<span class="line-added">2185             try {</span>
<span class="line-added">2186                 resultLen = Math.addExact(thisLen, Math.multiplyExact(</span>
<span class="line-added">2187                         Math.addExact(thisLen, 1), replLen));</span>
<span class="line-added">2188             } catch (ArithmeticException ignored) {</span>
<span class="line-added">2189                 throw new OutOfMemoryError();</span>
<span class="line-added">2190             }</span>
2191 
<span class="line-modified">2192             StringBuilder sb = new StringBuilder(resultLen);</span>
<span class="line-modified">2193             sb.append(replStr);</span>
<span class="line-modified">2194             for (int i = 0; i &lt; thisLen; ++i) {</span>
<span class="line-added">2195                 sb.append(charAt(i)).append(replStr);</span>
<span class="line-added">2196             }</span>
<span class="line-added">2197             return sb.toString();</span>
2198         }







2199     }
2200 
2201     /**
2202      * Splits this string around matches of the given
2203      * &lt;a href=&quot;../util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt;.
2204      *
2205      * &lt;p&gt; The array returned by this method contains each substring of this
2206      * string that is terminated by another substring that matches the given
2207      * expression or is terminated by the end of the string.  The substrings in
2208      * the array are in the order in which they occur in this string.  If the
2209      * expression does not match any part of the input then the resulting array
2210      * has just one element, namely this string.
2211      *
2212      * &lt;p&gt; When there is a positive-width match at the beginning of this
2213      * string then an empty leading substring is included at the beginning
2214      * of the resulting array. A zero-width match at the beginning however
2215      * never produces such empty leading substring.
2216      *
2217      * &lt;p&gt; The {@code limit} parameter controls the number of times the
2218      * pattern is applied and therefore affects the length of the resulting
</pre>
<hr />
<pre>
2667      * object is returned, representing the substring of this string that
2668      * begins with the character at index &lt;i&gt;k&lt;/i&gt; and ends with the
2669      * character at index &lt;i&gt;m&lt;/i&gt;-that is, the result of
2670      * {@code this.substring(k, m + 1)}.
2671      * &lt;p&gt;
2672      * This method may be used to trim space (as defined above) from
2673      * the beginning and end of a string.
2674      *
2675      * @return  a string whose value is this string, with all leading
2676      *          and trailing space removed, or this string if it
2677      *          has no leading or trailing space.
2678      */
2679     public String trim() {
2680         String ret = isLatin1() ? StringLatin1.trim(value)
2681                                 : StringUTF16.trim(value);
2682         return ret == null ? this : ret;
2683     }
2684 
2685     /**
2686      * Returns a string whose value is this string, with all leading
<span class="line-modified">2687      * and trailing {@linkplain Character#isWhitespace(int) white space}</span>
2688      * removed.
2689      * &lt;p&gt;
2690      * If this {@code String} object represents an empty string,
2691      * or if all code points in this string are
<span class="line-modified">2692      * {@linkplain Character#isWhitespace(int) white space}, then an empty string</span>
2693      * is returned.
2694      * &lt;p&gt;
2695      * Otherwise, returns a substring of this string beginning with the first
<span class="line-modified">2696      * code point that is not a {@linkplain Character#isWhitespace(int) white space}</span>
2697      * up to and including the last code point that is not a
<span class="line-modified">2698      * {@linkplain Character#isWhitespace(int) white space}.</span>
2699      * &lt;p&gt;
2700      * This method may be used to strip
<span class="line-modified">2701      * {@linkplain Character#isWhitespace(int) white space} from</span>
2702      * the beginning and end of a string.
2703      *
2704      * @return  a string whose value is this string, with all leading
2705      *          and trailing white space removed
2706      *
2707      * @see Character#isWhitespace(int)
2708      *
2709      * @since 11
2710      */
2711     public String strip() {
2712         String ret = isLatin1() ? StringLatin1.strip(value)
2713                                 : StringUTF16.strip(value);
2714         return ret == null ? this : ret;
2715     }
2716 
2717     /**
2718      * Returns a string whose value is this string, with all leading
<span class="line-modified">2719      * {@linkplain Character#isWhitespace(int) white space} removed.</span>
2720      * &lt;p&gt;
2721      * If this {@code String} object represents an empty string,
2722      * or if all code points in this string are
<span class="line-modified">2723      * {@linkplain Character#isWhitespace(int) white space}, then an empty string</span>
2724      * is returned.
2725      * &lt;p&gt;
2726      * Otherwise, returns a substring of this string beginning with the first
<span class="line-modified">2727      * code point that is not a {@linkplain Character#isWhitespace(int) white space}</span>
2728      * up to and including the last code point of this string.
2729      * &lt;p&gt;
2730      * This method may be used to trim
<span class="line-modified">2731      * {@linkplain Character#isWhitespace(int) white space} from</span>
2732      * the beginning of a string.
2733      *
2734      * @return  a string whose value is this string, with all leading white
2735      *          space removed
2736      *
2737      * @see Character#isWhitespace(int)
2738      *
2739      * @since 11
2740      */
2741     public String stripLeading() {
2742         String ret = isLatin1() ? StringLatin1.stripLeading(value)
2743                                 : StringUTF16.stripLeading(value);
2744         return ret == null ? this : ret;
2745     }
2746 
2747     /**
2748      * Returns a string whose value is this string, with all trailing
<span class="line-modified">2749      * {@linkplain Character#isWhitespace(int) white space} removed.</span>
2750      * &lt;p&gt;
2751      * If this {@code String} object represents an empty string,
2752      * or if all characters in this string are
<span class="line-modified">2753      * {@linkplain Character#isWhitespace(int) white space}, then an empty string</span>
2754      * is returned.
2755      * &lt;p&gt;
2756      * Otherwise, returns a substring of this string beginning with the first
2757      * code point of this string up to and including the last code point
<span class="line-modified">2758      * that is not a {@linkplain Character#isWhitespace(int) white space}.</span>
2759      * &lt;p&gt;
2760      * This method may be used to trim
<span class="line-modified">2761      * {@linkplain Character#isWhitespace(int) white space} from</span>
2762      * the end of a string.
2763      *
2764      * @return  a string whose value is this string, with all trailing white
2765      *          space removed
2766      *
2767      * @see Character#isWhitespace(int)
2768      *
2769      * @since 11
2770      */
2771     public String stripTrailing() {
2772         String ret = isLatin1() ? StringLatin1.stripTrailing(value)
2773                                 : StringUTF16.stripTrailing(value);
2774         return ret == null ? this : ret;
2775     }
2776 
2777     /**
2778      * Returns {@code true} if the string is empty or contains only
<span class="line-modified">2779      * {@linkplain Character#isWhitespace(int) white space} codepoints,</span>
2780      * otherwise {@code false}.
2781      *
2782      * @return {@code true} if the string is empty or contains only
<span class="line-modified">2783      *         {@linkplain Character#isWhitespace(int) white space} codepoints,</span>
2784      *         otherwise {@code false}
2785      *
2786      * @see Character#isWhitespace(int)
2787      *
2788      * @since 11
2789      */
2790     public boolean isBlank() {
2791         return indexOfNonWhitespace() == length();
2792     }
2793 





2794     /**
2795      * Returns a stream of lines extracted from this string,
2796      * separated by line terminators.
2797      * &lt;p&gt;
2798      * A &lt;i&gt;line terminator&lt;/i&gt; is one of the following:
2799      * a line feed character {@code &quot;\n&quot;} (U+000A),
2800      * a carriage return character {@code &quot;\r&quot;} (U+000D),
2801      * or a carriage return followed immediately by a line feed
2802      * {@code &quot;\r\n&quot;} (U+000D U+000A).
2803      * &lt;p&gt;
2804      * A &lt;i&gt;line&lt;/i&gt; is either a sequence of zero or more characters
2805      * followed by a line terminator, or it is a sequence of one or
2806      * more characters followed by the end of the string. A
2807      * line does not include the line terminator.
2808      * &lt;p&gt;
2809      * The stream returned by this method contains the lines from
2810      * this string in the order in which they occur.
2811      *
2812      * @apiNote This definition of &lt;i&gt;line&lt;/i&gt; implies that an empty
2813      *          string has zero lines and that there is no empty line
2814      *          following a line terminator at the end of a string.
2815      *
2816      * @implNote This method provides better performance than
2817      *           split(&quot;\R&quot;) by supplying elements lazily and
2818      *           by faster search of new line terminators.
2819      *
2820      * @return  the stream of lines extracted from this string
2821      *
2822      * @since 11
2823      */
2824     public Stream&lt;String&gt; lines() {
<span class="line-modified">2825         return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);</span>
2826     }
2827 
2828     /**
2829      * Adjusts the indentation of each line of this string based on the value of
2830      * {@code n}, and normalizes line termination characters.
2831      * &lt;p&gt;
2832      * This string is conceptually separated into lines using
2833      * {@link String#lines()}. Each line is then adjusted as described below
2834      * and then suffixed with a line feed {@code &quot;\n&quot;} (U+000A). The resulting
2835      * lines are then concatenated and returned.
2836      * &lt;p&gt;
2837      * If {@code n &gt; 0} then {@code n} spaces (U+0020) are inserted at the
2838      * beginning of each line.
2839      * &lt;p&gt;
2840      * If {@code n &lt; 0} then up to {@code n}
<span class="line-modified">2841      * {@linkplain Character#isWhitespace(int) white space characters} are removed</span>
2842      * from the beginning of each line. If a given line does not contain
2843      * sufficient white space then all leading
<span class="line-modified">2844      * {@linkplain Character#isWhitespace(int) white space characters} are removed.</span>
2845      * Each white space character is treated as a single character. In
2846      * particular, the tab character {@code &quot;\t&quot;} (U+0009) is considered a
2847      * single character; it is not expanded.
2848      * &lt;p&gt;
2849      * If {@code n == 0} then the line remains unchanged. However, line
2850      * terminators are still normalized.
2851      *
2852      * @param n  number of leading
<span class="line-modified">2853      *           {@linkplain Character#isWhitespace(int) white space characters}</span>
2854      *           to add or remove
2855      *
2856      * @return string with indentation adjusted and line endings normalized
2857      *
2858      * @see String#lines()
2859      * @see String#isBlank()
2860      * @see Character#isWhitespace(int)
2861      *
2862      * @since 12
2863      */
2864     public String indent(int n) {
<span class="line-modified">2865         if (isEmpty()) {</span>
<span class="line-modified">2866             return &quot;&quot;;</span>
<span class="line-modified">2867         }</span>
<span class="line-modified">2868         Stream&lt;String&gt; stream = lines();</span>


2869         if (n &gt; 0) {
2870             final String spaces = &quot; &quot;.repeat(n);
2871             stream = stream.map(s -&gt; spaces + s);
2872         } else if (n == Integer.MIN_VALUE) {
2873             stream = stream.map(s -&gt; s.stripLeading());
2874         } else if (n &lt; 0) {
2875             stream = stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));
2876         }
2877         return stream.collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;));
2878     }
2879 
2880     private int indexOfNonWhitespace() {
2881         return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)
2882                           : StringUTF16.indexOfNonWhitespace(value);
2883     }
2884 
2885     private int lastIndexOfNonWhitespace() {
2886         return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)
2887                           : StringUTF16.lastIndexOfNonWhitespace(value);
2888     }
2889 
<span class="line-added">2890     /**</span>
<span class="line-added">2891      * {@preview Associated with text blocks, a preview feature of</span>
<span class="line-added">2892      *           the Java language.</span>
<span class="line-added">2893      *</span>
<span class="line-added">2894      *           This method is associated with &lt;i&gt;text blocks&lt;/i&gt;, a preview</span>
<span class="line-added">2895      *           feature of the Java language. Programs can only use this</span>
<span class="line-added">2896      *           method when preview features are enabled. Preview features</span>
<span class="line-added">2897      *           may be removed in a future release, or upgraded to permanent</span>
<span class="line-added">2898      *           features of the Java language.}</span>
<span class="line-added">2899      *</span>
<span class="line-added">2900      * Returns a string whose value is this string, with incidental</span>
<span class="line-added">2901      * {@linkplain Character#isWhitespace(int) white space} removed from</span>
<span class="line-added">2902      * the beginning and end of every line.</span>
<span class="line-added">2903      * &lt;p&gt;</span>
<span class="line-added">2904      * Incidental {@linkplain Character#isWhitespace(int) white space}</span>
<span class="line-added">2905      * is often present in a text block to align the content with the opening</span>
<span class="line-added">2906      * delimiter. For example, in the following code, dots represent incidental</span>
<span class="line-added">2907      * {@linkplain Character#isWhitespace(int) white space}:</span>
<span class="line-added">2908      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">2909      * String html = &quot;&quot;&quot;</span>
<span class="line-added">2910      * ..............&amp;lt;html&amp;gt;</span>
<span class="line-added">2911      * ..............    &amp;lt;body&amp;gt;</span>
<span class="line-added">2912      * ..............        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;</span>
<span class="line-added">2913      * ..............    &amp;lt;/body&amp;gt;</span>
<span class="line-added">2914      * ..............&amp;lt;/html&amp;gt;</span>
<span class="line-added">2915      * ..............&quot;&quot;&quot;;</span>
<span class="line-added">2916      * &lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">2917      * This method treats the incidental</span>
<span class="line-added">2918      * {@linkplain Character#isWhitespace(int) white space} as indentation to be</span>
<span class="line-added">2919      * stripped, producing a string that preserves the relative indentation of</span>
<span class="line-added">2920      * the content. Using | to visualize the start of each line of the string:</span>
<span class="line-added">2921      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">2922      * |&amp;lt;html&amp;gt;</span>
<span class="line-added">2923      * |    &amp;lt;body&amp;gt;</span>
<span class="line-added">2924      * |        &amp;lt;p&amp;gt;Hello, world&amp;lt;/p&amp;gt;</span>
<span class="line-added">2925      * |    &amp;lt;/body&amp;gt;</span>
<span class="line-added">2926      * |&amp;lt;/html&amp;gt;</span>
<span class="line-added">2927      * &lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">2928      * First, the individual lines of this string are extracted as if by using</span>
<span class="line-added">2929      * {@link String#lines()}.</span>
<span class="line-added">2930      * &lt;p&gt;</span>
<span class="line-added">2931      * Then, the &lt;i&gt;minimum indentation&lt;/i&gt; (min) is determined as follows.</span>
<span class="line-added">2932      * For each non-blank line (as defined by {@link String#isBlank()}), the</span>
<span class="line-added">2933      * leading {@linkplain Character#isWhitespace(int) white space} characters are</span>
<span class="line-added">2934      * counted. The leading {@linkplain Character#isWhitespace(int) white space}</span>
<span class="line-added">2935      * characters on the last line are also counted even if</span>
<span class="line-added">2936      * {@linkplain String#isBlank() blank}. The &lt;i&gt;min&lt;/i&gt; value is the smallest</span>
<span class="line-added">2937      * of these counts.</span>
<span class="line-added">2938      * &lt;p&gt;</span>
<span class="line-added">2939      * For each {@linkplain String#isBlank() non-blank} line, &lt;i&gt;min&lt;/i&gt; leading</span>
<span class="line-added">2940      * {@linkplain Character#isWhitespace(int) white space} characters are removed,</span>
<span class="line-added">2941      * and any trailing {@linkplain Character#isWhitespace(int) white space}</span>
<span class="line-added">2942      * characters are removed. {@linkplain String#isBlank() Blank} lines are</span>
<span class="line-added">2943      * replaced with the empty string.</span>
<span class="line-added">2944      *</span>
<span class="line-added">2945      * &lt;p&gt;</span>
<span class="line-added">2946      * Finally, the lines are joined into a new string, using the LF character</span>
<span class="line-added">2947      * {@code &quot;\n&quot;} (U+000A) to separate lines.</span>
<span class="line-added">2948      *</span>
<span class="line-added">2949      * @apiNote</span>
<span class="line-added">2950      * This method&#39;s primary purpose is to shift a block of lines as far as</span>
<span class="line-added">2951      * possible to the left, while preserving relative indentation. Lines</span>
<span class="line-added">2952      * that were indented the least will thus have no leading</span>
<span class="line-added">2953      * {@linkplain Character#isWhitespace(int) white space}.</span>
<span class="line-added">2954      * The line count of the result will be the same as line count of this</span>
<span class="line-added">2955      * string.</span>
<span class="line-added">2956      * If this string ends with a line terminator then the result will end</span>
<span class="line-added">2957      * with a line terminator.</span>
<span class="line-added">2958      *</span>
<span class="line-added">2959      * @implNote</span>
<span class="line-added">2960      * This method treats all {@linkplain Character#isWhitespace(int) white space}</span>
<span class="line-added">2961      * characters as having equal width. As long as the indentation on every</span>
<span class="line-added">2962      * line is consistently composed of the same character sequences, then the</span>
<span class="line-added">2963      * result will be as described above.</span>
<span class="line-added">2964      *</span>
<span class="line-added">2965      * @return string with incidental indentation removed and line</span>
<span class="line-added">2966      *         terminators normalized</span>
<span class="line-added">2967      *</span>
<span class="line-added">2968      * @see String#lines()</span>
<span class="line-added">2969      * @see String#isBlank()</span>
<span class="line-added">2970      * @see String#indent(int)</span>
<span class="line-added">2971      * @see Character#isWhitespace(int)</span>
<span class="line-added">2972      *</span>
<span class="line-added">2973      * @since 13</span>
<span class="line-added">2974      *</span>
<span class="line-added">2975      */</span>
<span class="line-added">2976     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.TEXT_BLOCKS,</span>
<span class="line-added">2977                                  essentialAPI=true)</span>
<span class="line-added">2978     public String stripIndent() {</span>
<span class="line-added">2979         int length = length();</span>
<span class="line-added">2980         if (length == 0) {</span>
<span class="line-added">2981             return &quot;&quot;;</span>
<span class="line-added">2982         }</span>
<span class="line-added">2983         char lastChar = charAt(length - 1);</span>
<span class="line-added">2984         boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;</span>
<span class="line-added">2985         List&lt;String&gt; lines = lines().collect(Collectors.toList());</span>
<span class="line-added">2986         final int outdent = optOut ? 0 : outdent(lines);</span>
<span class="line-added">2987         return lines.stream()</span>
<span class="line-added">2988             .map(line -&gt; {</span>
<span class="line-added">2989                 int firstNonWhitespace = line.indexOfNonWhitespace();</span>
<span class="line-added">2990                 int lastNonWhitespace = line.lastIndexOfNonWhitespace();</span>
<span class="line-added">2991                 int incidentalWhitespace = Math.min(outdent, firstNonWhitespace);</span>
<span class="line-added">2992                 return firstNonWhitespace &gt; lastNonWhitespace</span>
<span class="line-added">2993                     ? &quot;&quot; : line.substring(incidentalWhitespace, lastNonWhitespace);</span>
<span class="line-added">2994             })</span>
<span class="line-added">2995             .collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, optOut ? &quot;\n&quot; : &quot;&quot;));</span>
<span class="line-added">2996     }</span>
<span class="line-added">2997 </span>
<span class="line-added">2998     private static int outdent(List&lt;String&gt; lines) {</span>
<span class="line-added">2999         // Note: outdent is guaranteed to be zero or positive number.</span>
<span class="line-added">3000         // If there isn&#39;t a non-blank line then the last must be blank</span>
<span class="line-added">3001         int outdent = Integer.MAX_VALUE;</span>
<span class="line-added">3002         for (String line : lines) {</span>
<span class="line-added">3003             int leadingWhitespace = line.indexOfNonWhitespace();</span>
<span class="line-added">3004             if (leadingWhitespace != line.length()) {</span>
<span class="line-added">3005                 outdent = Integer.min(outdent, leadingWhitespace);</span>
<span class="line-added">3006             }</span>
<span class="line-added">3007         }</span>
<span class="line-added">3008         String lastLine = lines.get(lines.size() - 1);</span>
<span class="line-added">3009         if (lastLine.isBlank()) {</span>
<span class="line-added">3010             outdent = Integer.min(outdent, lastLine.length());</span>
<span class="line-added">3011         }</span>
<span class="line-added">3012         return outdent;</span>
<span class="line-added">3013     }</span>
<span class="line-added">3014 </span>
<span class="line-added">3015     /**</span>
<span class="line-added">3016      * {@preview Associated with text blocks, a preview feature of</span>
<span class="line-added">3017      *           the Java language.</span>
<span class="line-added">3018      *</span>
<span class="line-added">3019      *           This method is associated with &lt;i&gt;text blocks&lt;/i&gt;, a preview</span>
<span class="line-added">3020      *           feature of the Java language. Programs can only use this</span>
<span class="line-added">3021      *           method when preview features are enabled. Preview features</span>
<span class="line-added">3022      *           may be removed in a future release, or upgraded to permanent</span>
<span class="line-added">3023      *           features of the Java language.}</span>
<span class="line-added">3024      *</span>
<span class="line-added">3025      * Returns a string whose value is this string, with escape sequences</span>
<span class="line-added">3026      * translated as if in a string literal.</span>
<span class="line-added">3027      * &lt;p&gt;</span>
<span class="line-added">3028      * Escape sequences are translated as follows;</span>
<span class="line-added">3029      * &lt;table class=&quot;striped&quot;&gt;</span>
<span class="line-added">3030      *   &lt;caption style=&quot;display:none&quot;&gt;Translation&lt;/caption&gt;</span>
<span class="line-added">3031      *   &lt;thead&gt;</span>
<span class="line-added">3032      *   &lt;tr&gt;</span>
<span class="line-added">3033      *     &lt;th scope=&quot;col&quot;&gt;Escape&lt;/th&gt;</span>
<span class="line-added">3034      *     &lt;th scope=&quot;col&quot;&gt;Name&lt;/th&gt;</span>
<span class="line-added">3035      *     &lt;th scope=&quot;col&quot;&gt;Translation&lt;/th&gt;</span>
<span class="line-added">3036      *   &lt;/tr&gt;</span>
<span class="line-added">3037      *   &lt;/thead&gt;</span>
<span class="line-added">3038      *   &lt;tbody&gt;</span>
<span class="line-added">3039      *   &lt;tr&gt;</span>
<span class="line-added">3040      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cb}&lt;/th&gt;</span>
<span class="line-added">3041      *     &lt;td&gt;backspace&lt;/td&gt;</span>
<span class="line-added">3042      *     &lt;td&gt;{@code U+0008}&lt;/td&gt;</span>
<span class="line-added">3043      *   &lt;/tr&gt;</span>
<span class="line-added">3044      *   &lt;tr&gt;</span>
<span class="line-added">3045      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Ct}&lt;/th&gt;</span>
<span class="line-added">3046      *     &lt;td&gt;horizontal tab&lt;/td&gt;</span>
<span class="line-added">3047      *     &lt;td&gt;{@code U+0009}&lt;/td&gt;</span>
<span class="line-added">3048      *   &lt;/tr&gt;</span>
<span class="line-added">3049      *   &lt;tr&gt;</span>
<span class="line-added">3050      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cn}&lt;/th&gt;</span>
<span class="line-added">3051      *     &lt;td&gt;line feed&lt;/td&gt;</span>
<span class="line-added">3052      *     &lt;td&gt;{@code U+000A}&lt;/td&gt;</span>
<span class="line-added">3053      *   &lt;/tr&gt;</span>
<span class="line-added">3054      *   &lt;tr&gt;</span>
<span class="line-added">3055      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cf}&lt;/th&gt;</span>
<span class="line-added">3056      *     &lt;td&gt;form feed&lt;/td&gt;</span>
<span class="line-added">3057      *     &lt;td&gt;{@code U+000C}&lt;/td&gt;</span>
<span class="line-added">3058      *   &lt;/tr&gt;</span>
<span class="line-added">3059      *   &lt;tr&gt;</span>
<span class="line-added">3060      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cr}&lt;/th&gt;</span>
<span class="line-added">3061      *     &lt;td&gt;carriage return&lt;/td&gt;</span>
<span class="line-added">3062      *     &lt;td&gt;{@code U+000D}&lt;/td&gt;</span>
<span class="line-added">3063      *   &lt;/tr&gt;</span>
<span class="line-added">3064      *   &lt;tr&gt;</span>
<span class="line-added">3065      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005Cs}&lt;/th&gt;</span>
<span class="line-added">3066      *     &lt;td&gt;space&lt;/td&gt;</span>
<span class="line-added">3067      *     &lt;td&gt;{@code U+0020}&lt;/td&gt;</span>
<span class="line-added">3068      *   &lt;/tr&gt;</span>
<span class="line-added">3069      *   &lt;tr&gt;</span>
<span class="line-added">3070      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C&quot;}&lt;/th&gt;</span>
<span class="line-added">3071      *     &lt;td&gt;double quote&lt;/td&gt;</span>
<span class="line-added">3072      *     &lt;td&gt;{@code U+0022}&lt;/td&gt;</span>
<span class="line-added">3073      *   &lt;/tr&gt;</span>
<span class="line-added">3074      *   &lt;tr&gt;</span>
<span class="line-added">3075      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C&#39;}&lt;/th&gt;</span>
<span class="line-added">3076      *     &lt;td&gt;single quote&lt;/td&gt;</span>
<span class="line-added">3077      *     &lt;td&gt;{@code U+0027}&lt;/td&gt;</span>
<span class="line-added">3078      *   &lt;/tr&gt;</span>
<span class="line-added">3079      *   &lt;tr&gt;</span>
<span class="line-added">3080      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C\u005C}&lt;/th&gt;</span>
<span class="line-added">3081      *     &lt;td&gt;backslash&lt;/td&gt;</span>
<span class="line-added">3082      *     &lt;td&gt;{@code U+005C}&lt;/td&gt;</span>
<span class="line-added">3083      *   &lt;/tr&gt;</span>
<span class="line-added">3084      *   &lt;tr&gt;</span>
<span class="line-added">3085      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C0 - \u005C377}&lt;/th&gt;</span>
<span class="line-added">3086      *     &lt;td&gt;octal escape&lt;/td&gt;</span>
<span class="line-added">3087      *     &lt;td&gt;code point equivalents&lt;/td&gt;</span>
<span class="line-added">3088      *   &lt;/tr&gt;</span>
<span class="line-added">3089      *   &lt;tr&gt;</span>
<span class="line-added">3090      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C&lt;line-terminator&gt;}&lt;/th&gt;</span>
<span class="line-added">3091      *     &lt;td&gt;continuation&lt;/td&gt;</span>
<span class="line-added">3092      *     &lt;td&gt;discard&lt;/td&gt;</span>
<span class="line-added">3093      *   &lt;/tr&gt;</span>
<span class="line-added">3094      *   &lt;/tbody&gt;</span>
<span class="line-added">3095      * &lt;/table&gt;</span>
<span class="line-added">3096      *</span>
<span class="line-added">3097      * @implNote</span>
<span class="line-added">3098      * This method does &lt;em&gt;not&lt;/em&gt; translate Unicode escapes such as &quot;{@code \u005cu2022}&quot;.</span>
<span class="line-added">3099      * Unicode escapes are translated by the Java compiler when reading input characters and</span>
<span class="line-added">3100      * are not part of the string literal specification.</span>
<span class="line-added">3101      *</span>
<span class="line-added">3102      * @throws IllegalArgumentException when an escape sequence is malformed.</span>
<span class="line-added">3103      *</span>
<span class="line-added">3104      * @return String with escape sequences translated.</span>
<span class="line-added">3105      *</span>
<span class="line-added">3106      * @jls 3.10.7 Escape Sequences</span>
<span class="line-added">3107      *</span>
<span class="line-added">3108      * @since 13</span>
<span class="line-added">3109      */</span>
<span class="line-added">3110     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.TEXT_BLOCKS,</span>
<span class="line-added">3111                                  essentialAPI=true)</span>
<span class="line-added">3112     public String translateEscapes() {</span>
<span class="line-added">3113         if (isEmpty()) {</span>
<span class="line-added">3114             return &quot;&quot;;</span>
<span class="line-added">3115         }</span>
<span class="line-added">3116         char[] chars = toCharArray();</span>
<span class="line-added">3117         int length = chars.length;</span>
<span class="line-added">3118         int from = 0;</span>
<span class="line-added">3119         int to = 0;</span>
<span class="line-added">3120         while (from &lt; length) {</span>
<span class="line-added">3121             char ch = chars[from++];</span>
<span class="line-added">3122             if (ch == &#39;\\&#39;) {</span>
<span class="line-added">3123                 ch = from &lt; length ? chars[from++] : &#39;\0&#39;;</span>
<span class="line-added">3124                 switch (ch) {</span>
<span class="line-added">3125                 case &#39;b&#39;:</span>
<span class="line-added">3126                     ch = &#39;\b&#39;;</span>
<span class="line-added">3127                     break;</span>
<span class="line-added">3128                 case &#39;f&#39;:</span>
<span class="line-added">3129                     ch = &#39;\f&#39;;</span>
<span class="line-added">3130                     break;</span>
<span class="line-added">3131                 case &#39;n&#39;:</span>
<span class="line-added">3132                     ch = &#39;\n&#39;;</span>
<span class="line-added">3133                     break;</span>
<span class="line-added">3134                 case &#39;r&#39;:</span>
<span class="line-added">3135                     ch = &#39;\r&#39;;</span>
<span class="line-added">3136                     break;</span>
<span class="line-added">3137                 case &#39;s&#39;:</span>
<span class="line-added">3138                     ch = &#39; &#39;;</span>
<span class="line-added">3139                     break;</span>
<span class="line-added">3140                 case &#39;t&#39;:</span>
<span class="line-added">3141                     ch = &#39;\t&#39;;</span>
<span class="line-added">3142                     break;</span>
<span class="line-added">3143                 case &#39;\&#39;&#39;:</span>
<span class="line-added">3144                 case &#39;\&quot;&#39;:</span>
<span class="line-added">3145                 case &#39;\\&#39;:</span>
<span class="line-added">3146                     // as is</span>
<span class="line-added">3147                     break;</span>
<span class="line-added">3148                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:</span>
<span class="line-added">3149                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:</span>
<span class="line-added">3150                     int limit = Integer.min(from + (ch &lt;= &#39;3&#39; ? 2 : 1), length);</span>
<span class="line-added">3151                     int code = ch - &#39;0&#39;;</span>
<span class="line-added">3152                     while (from &lt; limit) {</span>
<span class="line-added">3153                         ch = chars[from];</span>
<span class="line-added">3154                         if (ch &lt; &#39;0&#39; || &#39;7&#39; &lt; ch) {</span>
<span class="line-added">3155                             break;</span>
<span class="line-added">3156                         }</span>
<span class="line-added">3157                         from++;</span>
<span class="line-added">3158                         code = (code &lt;&lt; 3) | (ch - &#39;0&#39;);</span>
<span class="line-added">3159                     }</span>
<span class="line-added">3160                     ch = (char)code;</span>
<span class="line-added">3161                     break;</span>
<span class="line-added">3162                 case &#39;\n&#39;:</span>
<span class="line-added">3163                     continue;</span>
<span class="line-added">3164                 case &#39;\r&#39;:</span>
<span class="line-added">3165                     if (from &lt; length &amp;&amp; chars[from] == &#39;\n&#39;) {</span>
<span class="line-added">3166                         from++;</span>
<span class="line-added">3167                     }</span>
<span class="line-added">3168                     continue;</span>
<span class="line-added">3169                 default: {</span>
<span class="line-added">3170                     String msg = String.format(</span>
<span class="line-added">3171                         &quot;Invalid escape sequence: \\%c \\\\u%04X&quot;,</span>
<span class="line-added">3172                         ch, (int)ch);</span>
<span class="line-added">3173                     throw new IllegalArgumentException(msg);</span>
<span class="line-added">3174                 }</span>
<span class="line-added">3175                 }</span>
<span class="line-added">3176             }</span>
<span class="line-added">3177 </span>
<span class="line-added">3178             chars[to++] = ch;</span>
<span class="line-added">3179         }</span>
<span class="line-added">3180 </span>
<span class="line-added">3181         return new String(chars, 0, to);</span>
<span class="line-added">3182     }</span>
<span class="line-added">3183 </span>
3184     /**
3185      * This method allows the application of a function to {@code this}
3186      * string. The function should expect a single String argument
3187      * and produce an {@code R} result.
3188      * &lt;p&gt;
3189      * Any exception thrown by {@code f()} will be propagated to the
3190      * caller.
3191      *
3192      * @param f    functional interface to a apply
3193      *
3194      * @param &lt;R&gt;  class of the result
3195      *
3196      * @return     the result of applying the function to this string
3197      *
3198      * @see java.util.function.Function
3199      *
3200      * @since 12
3201      */
3202     public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) {
3203         return f.apply(this);
</pre>
<hr />
<pre>
3326      *         &lt;a href=&quot;../util/Formatter.html#syntax&quot;&gt;conversion&lt;/a&gt;.
3327      *
3328      * @throws  java.util.IllegalFormatException
3329      *          If a format string contains an illegal syntax, a format
3330      *          specifier that is incompatible with the given arguments,
3331      *          insufficient arguments given the format string, or other
3332      *          illegal conditions.  For specification of all possible
3333      *          formatting errors, see the &lt;a
3334      *          href=&quot;../util/Formatter.html#detail&quot;&gt;Details&lt;/a&gt; section of the
3335      *          formatter class specification
3336      *
3337      * @return  A formatted string
3338      *
3339      * @see  java.util.Formatter
3340      * @since  1.5
3341      */
3342     public static String format(Locale l, String format, Object... args) {
3343         return new Formatter(l).format(format, args).toString();
3344     }
3345 
<span class="line-added">3346     /**</span>
<span class="line-added">3347      * {@preview Associated with text blocks, a preview feature of</span>
<span class="line-added">3348      *           the Java language.</span>
<span class="line-added">3349      *</span>
<span class="line-added">3350      *           This method is associated with &lt;i&gt;text blocks&lt;/i&gt;, a preview</span>
<span class="line-added">3351      *           feature of the Java language. Programs can only use this</span>
<span class="line-added">3352      *           method when preview features are enabled. Preview features</span>
<span class="line-added">3353      *           may be removed in a future release, or upgraded to permanent</span>
<span class="line-added">3354      *           features of the Java language.}</span>
<span class="line-added">3355      *</span>
<span class="line-added">3356      * Formats using this string as the format string, and the supplied</span>
<span class="line-added">3357      * arguments.</span>
<span class="line-added">3358      *</span>
<span class="line-added">3359      * @implSpec This method is equivalent to {@code String.format(this, args)}.</span>
<span class="line-added">3360      *</span>
<span class="line-added">3361      * @param  args</span>
<span class="line-added">3362      *         Arguments referenced by the format specifiers in this string.</span>
<span class="line-added">3363      *</span>
<span class="line-added">3364      * @return  A formatted string</span>
<span class="line-added">3365      *</span>
<span class="line-added">3366      * @see  java.lang.String#format(String,Object...)</span>
<span class="line-added">3367      * @see  java.util.Formatter</span>
<span class="line-added">3368      *</span>
<span class="line-added">3369      * @since 13</span>
<span class="line-added">3370      *</span>
<span class="line-added">3371      */</span>
<span class="line-added">3372     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.TEXT_BLOCKS,</span>
<span class="line-added">3373                                  essentialAPI=true)</span>
<span class="line-added">3374     public String formatted(Object... args) {</span>
<span class="line-added">3375         return new Formatter().format(this, args).toString();</span>
<span class="line-added">3376     }</span>
<span class="line-added">3377 </span>
3378     /**
3379      * Returns the string representation of the {@code Object} argument.
3380      *
3381      * @param   obj   an {@code Object}.
3382      * @return  if the argument is {@code null}, then a string equal to
3383      *          {@code &quot;null&quot;}; otherwise, the value of
3384      *          {@code obj.toString()} is returned.
3385      * @see     java.lang.Object#toString()
3386      */
3387     public static String valueOf(Object obj) {
3388         return (obj == null) ? &quot;null&quot; : obj.toString();
3389     }
3390 
3391     /**
3392      * Returns the string representation of the {@code char} array
3393      * argument. The contents of the character array are copied; subsequent
3394      * modification of the character array does not affect the returned
3395      * string.
3396      *
3397      * @param   data     the character array.
</pre>
<hr />
<pre>
3400      */
3401     public static String valueOf(char data[]) {
3402         return new String(data);
3403     }
3404 
3405     /**
3406      * Returns the string representation of a specific subarray of the
3407      * {@code char} array argument.
3408      * &lt;p&gt;
3409      * The {@code offset} argument is the index of the first
3410      * character of the subarray. The {@code count} argument
3411      * specifies the length of the subarray. The contents of the subarray
3412      * are copied; subsequent modification of the character array does not
3413      * affect the returned string.
3414      *
3415      * @param   data     the character array.
3416      * @param   offset   initial offset of the subarray.
3417      * @param   count    length of the subarray.
3418      * @return  a {@code String} that contains the characters of the
3419      *          specified subarray of the character array.
<span class="line-modified">3420      * @throws    IndexOutOfBoundsException if {@code offset} is</span>
3421      *          negative, or {@code count} is negative, or
3422      *          {@code offset+count} is larger than
3423      *          {@code data.length}.
3424      */
3425     public static String valueOf(char data[], int offset, int count) {
3426         return new String(data, offset, count);
3427     }
3428 
3429     /**
3430      * Equivalent to {@link #valueOf(char[], int, int)}.
3431      *
3432      * @param   data     the character array.
3433      * @param   offset   initial offset of the subarray.
3434      * @param   count    length of the subarray.
3435      * @return  a {@code String} that contains the characters of the
3436      *          specified subarray of the character array.
<span class="line-modified">3437      * @throws    IndexOutOfBoundsException if {@code offset} is</span>
3438      *          negative, or {@code count} is negative, or
3439      *          {@code offset+count} is larger than
3440      *          {@code data.length}.
3441      */
3442     public static String copyValueOf(char data[], int offset, int count) {
3443         return new String(data, offset, count);
3444     }
3445 
3446     /**
3447      * Equivalent to {@link #valueOf(char[])}.
3448      *
3449      * @param   data   the character array.
3450      * @return  a {@code String} that contains the characters of the
3451      *          character array.
3452      */
3453     public static String copyValueOf(char data[]) {
3454         return new String(data);
3455     }
3456 
3457     /**
</pre>
<hr />
<pre>
3682             this.value = Arrays.copyOfRange(val, 0, length &lt;&lt; 1);
3683         }
3684     }
3685 
3686    /*
3687     * Package private constructor which shares value array for speed.
3688     */
3689     String(byte[] value, byte coder) {
3690         this.value = value;
3691         this.coder = coder;
3692     }
3693 
3694     byte coder() {
3695         return COMPACT_STRINGS ? coder : UTF16;
3696     }
3697 
3698     byte[] value() {
3699         return value;
3700     }
3701 
<span class="line-modified">3702     boolean isLatin1() {</span>
3703         return COMPACT_STRINGS &amp;&amp; coder == LATIN1;
3704     }
3705 
3706     @Native static final byte LATIN1 = 0;
3707     @Native static final byte UTF16  = 1;
3708 
3709     /*
3710      * StringIndexOutOfBoundsException  if {@code index} is
3711      * negative or greater than or equal to {@code length}.
3712      */
3713     static void checkIndex(int index, int length) {
3714         if (index &lt; 0 || index &gt;= length) {
3715             throw new StringIndexOutOfBoundsException(&quot;index &quot; + index +
<span class="line-modified">3716                                                       &quot;, length &quot; + length);</span>
3717         }
3718     }
3719 
3720     /*
3721      * StringIndexOutOfBoundsException  if {@code offset}
3722      * is negative or greater than {@code length}.
3723      */
3724     static void checkOffset(int offset, int length) {
3725         if (offset &lt; 0 || offset &gt; length) {
3726             throw new StringIndexOutOfBoundsException(&quot;offset &quot; + offset +
<span class="line-modified">3727                                                       &quot;, length &quot; + length);</span>
3728         }
3729     }
3730 
3731     /*
3732      * Check {@code offset}, {@code count} against {@code 0} and {@code length}
3733      * bounds.
3734      *
3735      * @throws  StringIndexOutOfBoundsException
3736      *          If {@code offset} is negative, {@code count} is negative,
3737      *          or {@code offset} is greater than {@code length - count}
3738      */
3739     static void checkBoundsOffCount(int offset, int count, int length) {
3740         if (offset &lt; 0 || count &lt; 0 || offset &gt; length - count) {
3741             throw new StringIndexOutOfBoundsException(
3742                 &quot;offset &quot; + offset + &quot;, count &quot; + count + &quot;, length &quot; + length);
3743         }
3744     }
3745 
3746     /*
3747      * Check {@code begin}, {@code end} against {@code 0} and {@code length}
</pre>
</td>
</tr>
</table>
<center><a href="StrictMath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StringBuffer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/reflect/Method.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Member.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Modifier.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/Method.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,13 ***</span>
          }
          return genericInfo; //return cached repository
      }
  
      /**
<span class="line-modified">!      * Package-private constructor used by ReflectAccess to enable</span>
<span class="line-removed">-      * instantiation of these objects in Java code from the java.lang</span>
<span class="line-removed">-      * package via sun.reflect.LangReflectAccess.</span>
       */
      Method(Class&lt;?&gt; declaringClass,
             String name,
             Class&lt;?&gt;[] parameterTypes,
             Class&lt;?&gt; returnType,
<span class="line-new-header">--- 111,11 ---</span>
          }
          return genericInfo; //return cached repository
      }
  
      /**
<span class="line-modified">!      * Package-private constructor</span>
       */
      Method(Class&lt;?&gt; declaringClass,
             String name,
             Class&lt;?&gt;[] parameterTypes,
             Class&lt;?&gt; returnType,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 267,11 ***</span>
       * Returns a {@code Type} object that represents the formal return
       * type of the method represented by this {@code Method} object.
       *
       * &lt;p&gt;If the return type is a parameterized type,
       * the {@code Type} object returned must accurately reflect
<span class="line-modified">!      * the actual type parameters used in the source code.</span>
       *
       * &lt;p&gt;If the return type is a type variable or a parameterized type, it
       * is created. Otherwise, it is resolved.
       *
       * @return  a {@code Type} object that represents the formal return
<span class="line-new-header">--- 265,11 ---</span>
       * Returns a {@code Type} object that represents the formal return
       * type of the method represented by this {@code Method} object.
       *
       * &lt;p&gt;If the return type is a parameterized type,
       * the {@code Type} object returned must accurately reflect
<span class="line-modified">!      * the actual type arguments used in the source code.</span>
       *
       * &lt;p&gt;If the return type is a type variable or a parameterized type, it
       * is created. Otherwise, it is resolved.
       *
       * @return  a {@code Type} object that represents the formal return
</pre>
<hr />
<pre>
<span class="line-old-header">*** 401,11 ***</span>
       * {@code synchronized}, {@code native}, {@code strictfp}.
       *
       * @return a string describing this {@code Method}
       *
       * @jls 8.4.3 Method Modifiers
<span class="line-modified">!      * @jls 9.4   Method Declarations</span>
       * @jls 9.6.1 Annotation Type Elements
       */
      public String toString() {
          return sharedToString(Modifier.methodModifiers(),
                                isDefault(),
<span class="line-new-header">--- 399,11 ---</span>
       * {@code synchronized}, {@code native}, {@code strictfp}.
       *
       * @return a string describing this {@code Method}
       *
       * @jls 8.4.3 Method Modifiers
<span class="line-modified">!      * @jls 9.4 Method Declarations</span>
       * @jls 9.6.1 Annotation Type Elements
       */
      public String toString() {
          return sharedToString(Modifier.methodModifiers(),
                                isDefault(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,21 ***</span>
          sb.append(getName());
      }
  
      @Override
      String toShortString() {
<span class="line-modified">!         StringBuilder sb = new StringBuilder(&quot;method &quot;);</span>
<span class="line-modified">!         sb.append(getDeclaringClass().getTypeName()).append(&#39;.&#39;);</span>
<span class="line-modified">!         sb.append(getName());</span>
<span class="line-modified">!         sb.append(&#39;(&#39;);</span>
<span class="line-modified">!         StringJoiner sj = new StringJoiner(&quot;,&quot;);</span>
          for (Class&lt;?&gt; parameterType : getParameterTypes()) {
              sj.add(parameterType.getTypeName());
          }
<span class="line-modified">!         sb.append(sj);</span>
<span class="line-removed">-         sb.append(&#39;)&#39;);</span>
<span class="line-removed">-         return sb.toString();</span>
      }
  
      /**
       * Returns a string describing this {@code Method}, including type
       * parameters.  The string is formatted as the method access
<span class="line-new-header">--- 418,20 ---</span>
          sb.append(getName());
      }
  
      @Override
      String toShortString() {
<span class="line-modified">!         return &quot;method &quot; + getDeclaringClass().getTypeName() +</span>
<span class="line-modified">!                 &#39;.&#39; + toShortSignature();</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     String toShortSignature() {</span>
<span class="line-added">+         StringJoiner sj = new StringJoiner(&quot;,&quot;, getName() + &quot;(&quot;, &quot;)&quot;);</span>
          for (Class&lt;?&gt; parameterType : getParameterTypes()) {
              sj.add(parameterType.getTypeName());
          }
<span class="line-modified">!         return sj.toString();</span>
      }
  
      /**
       * Returns a string describing this {@code Method}, including type
       * parameters.  The string is formatted as the method access
</pre>
<hr />
<pre>
<span class="line-old-header">*** 472,11 ***</span>
       * include type parameters
       *
       * @since 1.5
       *
       * @jls 8.4.3 Method Modifiers
<span class="line-modified">!      * @jls 9.4   Method Declarations</span>
       * @jls 9.6.1 Annotation Type Elements
       */
      @Override
      public String toGenericString() {
          return sharedToGenericString(Modifier.methodModifiers(), isDefault());
<span class="line-new-header">--- 469,11 ---</span>
       * include type parameters
       *
       * @since 1.5
       *
       * @jls 8.4.3 Method Modifiers
<span class="line-modified">!      * @jls 9.4 Method Declarations</span>
       * @jls 9.6.1 Annotation Type Elements
       */
      @Override
      public String toGenericString() {
          return sharedToGenericString(Modifier.methodModifiers(), isDefault());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 504,11 ***</span>
       * &lt;p&gt;If the number of formal parameters required by the underlying method is
       * 0, the supplied {@code args} array may be of length 0 or null.
       *
       * &lt;p&gt;If the underlying method is an instance method, it is invoked
       * using dynamic method lookup as documented in The Java Language
<span class="line-modified">!      * Specification, section 15.12.4.4; in particular,</span>
       * overriding based on the runtime type of the target object may occur.
       *
       * &lt;p&gt;If the underlying method is static, the class that declared
       * the method is initialized if it has not already been initialized.
       *
<span class="line-new-header">--- 501,11 ---</span>
       * &lt;p&gt;If the number of formal parameters required by the underlying method is
       * 0, the supplied {@code args} array may be of length 0 or null.
       *
       * &lt;p&gt;If the underlying method is an instance method, it is invoked
       * using dynamic method lookup as documented in The Java Language
<span class="line-modified">!      * Specification, section {@jls 15.12.4.4}; in particular,</span>
       * overriding based on the runtime type of the target object may occur.
       *
       * &lt;p&gt;If the underlying method is static, the class that declared
       * the method is initialized if it has not already been initialized.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 525,28 ***</span>
       * @param args the arguments used for the method call
       * @return the result of dispatching the method represented by
       * this object on {@code obj} with parameters
       * {@code args}
       *
<span class="line-modified">!      * @exception IllegalAccessException    if this {@code Method} object</span>
       *              is enforcing Java language access control and the underlying
       *              method is inaccessible.
<span class="line-modified">!      * @exception IllegalArgumentException  if the method is an</span>
       *              instance method and the specified object argument
       *              is not an instance of the class or interface
       *              declaring the underlying method (or of a subclass
       *              or implementor thereof); if the number of actual
       *              and formal parameters differ; if an unwrapping
       *              conversion for primitive arguments fails; or if,
       *              after possible unwrapping, a parameter value
       *              cannot be converted to the corresponding formal
       *              parameter type by a method invocation conversion.
<span class="line-modified">!      * @exception InvocationTargetException if the underlying method</span>
       *              throws an exception.
<span class="line-modified">!      * @exception NullPointerException      if the specified object is null</span>
       *              and the method is an instance method.
<span class="line-modified">!      * @exception ExceptionInInitializerError if the initialization</span>
       * provoked by this method fails.
       */
      @CallerSensitive
      @ForceInline // to ensure Reflection.getCallerClass optimization
      @HotSpotIntrinsicCandidate
<span class="line-new-header">--- 522,28 ---</span>
       * @param args the arguments used for the method call
       * @return the result of dispatching the method represented by
       * this object on {@code obj} with parameters
       * {@code args}
       *
<span class="line-modified">!      * @throws    IllegalAccessException    if this {@code Method} object</span>
       *              is enforcing Java language access control and the underlying
       *              method is inaccessible.
<span class="line-modified">!      * @throws    IllegalArgumentException  if the method is an</span>
       *              instance method and the specified object argument
       *              is not an instance of the class or interface
       *              declaring the underlying method (or of a subclass
       *              or implementor thereof); if the number of actual
       *              and formal parameters differ; if an unwrapping
       *              conversion for primitive arguments fails; or if,
       *              after possible unwrapping, a parameter value
       *              cannot be converted to the corresponding formal
       *              parameter type by a method invocation conversion.
<span class="line-modified">!      * @throws    InvocationTargetException if the underlying method</span>
       *              throws an exception.
<span class="line-modified">!      * @throws    NullPointerException      if the specified object is null</span>
       *              and the method is an instance method.
<span class="line-modified">!      * @throws    ExceptionInInitializerError if the initialization</span>
       * provoked by this method fails.
       */
      @CallerSensitive
      @ForceInline // to ensure Reflection.getCallerClass optimization
      @HotSpotIntrinsicCandidate
</pre>
<center><a href="Member.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Modifier.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/reflect/Field.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Executable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="GenericSignatureFormatError.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/Field.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  96     // Accessor for factory
  97     private GenericsFactory getFactory() {
  98         Class&lt;?&gt; c = getDeclaringClass();
  99         // create scope and factory
 100         return CoreReflectionFactory.make(c, ClassScope.make(c));
 101     }
 102 
 103     // Accessor for generic info repository
 104     private FieldRepository getGenericInfo() {
 105         // lazily initialize repository if necessary
 106         if (genericInfo == null) {
 107             // create and cache generic info repository
 108             genericInfo = FieldRepository.make(getGenericSignature(),
 109                                                getFactory());
 110         }
 111         return genericInfo; //return cached repository
 112     }
 113 
 114 
 115     /**
<span class="line-modified"> 116      * Package-private constructor used by ReflectAccess to enable</span>
<span class="line-removed"> 117      * instantiation of these objects in Java code from the java.lang</span>
<span class="line-removed"> 118      * package via sun.reflect.LangReflectAccess.</span>
 119      */
 120     Field(Class&lt;?&gt; declaringClass,
 121           String name,
 122           Class&lt;?&gt; type,
 123           int modifiers,
 124           int slot,
 125           String signature,
 126           byte[] annotations)
 127     {
 128         this.clazz = declaringClass;
 129         this.name = name;
 130         this.type = type;
 131         this.modifiers = modifiers;
 132         this.slot = slot;
 133         this.signature = signature;
 134         this.annotations = annotations;
 135     }
 136 
 137     /**
 138      * Package-private routine (exposed to java.lang.Class via
</pre>
<hr />
<pre>
 226     public boolean isSynthetic() {
 227         return Modifier.isSynthetic(getModifiers());
 228     }
 229 
 230     /**
 231      * Returns a {@code Class} object that identifies the
 232      * declared type for the field represented by this
 233      * {@code Field} object.
 234      *
 235      * @return a {@code Class} object identifying the declared
 236      * type of the field represented by this object
 237      */
 238     public Class&lt;?&gt; getType() {
 239         return type;
 240     }
 241 
 242     /**
 243      * Returns a {@code Type} object that represents the declared type for
 244      * the field represented by this {@code Field} object.
 245      *
<span class="line-modified"> 246      * &lt;p&gt;If the {@code Type} is a parameterized type, the</span>
<span class="line-modified"> 247      * {@code Type} object returned must accurately reflect the</span>
<span class="line-modified"> 248      * actual type parameters used in the source code.</span>
 249      *
 250      * &lt;p&gt;If the type of the underlying field is a type variable or a
 251      * parameterized type, it is created. Otherwise, it is resolved.
 252      *
 253      * @return a {@code Type} object that represents the declared type for
 254      *     the field represented by this {@code Field} object
 255      * @throws GenericSignatureFormatError if the generic field
 256      *     signature does not conform to the format specified in
 257      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 258      * @throws TypeNotPresentException if the generic type
 259      *     signature of the underlying field refers to a non-existent
 260      *     type declaration
 261      * @throws MalformedParameterizedTypeException if the generic
 262      *     signature of the underlying field refers to a parameterized type
 263      *     that cannot be instantiated for any reason
 264      * @since 1.5
 265      */
 266     public Type getGenericType() {
 267         if (getGenericSignature() != null)
 268             return getGenericInfo().getGenericType();
</pre>
<hr />
<pre>
 378      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 379      * the underlying field is inaccessible, the method throws an
 380      * {@code IllegalAccessException}.
 381      * If the underlying field is static, the class that declared the
 382      * field is initialized if it has not already been initialized.
 383      *
 384      * &lt;p&gt;Otherwise, the value is retrieved from the underlying instance
 385      * or static field.  If the field has a primitive type, the value
 386      * is wrapped in an object before being returned, otherwise it is
 387      * returned as is.
 388      *
 389      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 390      * the field&#39;s value is obtained according to the preceding rules.
 391      *
 392      * @param obj object from which the represented field&#39;s value is
 393      * to be extracted
 394      * @return the value of the represented field in object
 395      * {@code obj}; primitive values are wrapped in an appropriate
 396      * object before being returned
 397      *
<span class="line-modified"> 398      * @exception IllegalAccessException    if this {@code Field} object</span>
 399      *              is enforcing Java language access control and the underlying
 400      *              field is inaccessible.
<span class="line-modified"> 401      * @exception IllegalArgumentException  if the specified object is not an</span>
 402      *              instance of the class or interface declaring the underlying
 403      *              field (or a subclass or implementor thereof).
<span class="line-modified"> 404      * @exception NullPointerException      if the specified object is null</span>
 405      *              and the field is an instance field.
<span class="line-modified"> 406      * @exception ExceptionInInitializerError if the initialization provoked</span>
 407      *              by this method fails.
 408      */
 409     @CallerSensitive
 410     @ForceInline // to ensure Reflection.getCallerClass optimization
 411     public Object get(Object obj)
 412         throws IllegalArgumentException, IllegalAccessException
 413     {
 414         if (!override) {
 415             Class&lt;?&gt; caller = Reflection.getCallerClass();
 416             checkAccess(caller, obj);
 417         }
 418         return getFieldAccessor(obj).get(obj);
 419     }
 420 
 421     /**
 422      * Gets the value of a static or instance {@code boolean} field.
 423      *
 424      * @param obj the object to extract the {@code boolean} value
 425      * from
 426      * @return the value of the {@code boolean} field
 427      *
<span class="line-modified"> 428      * @exception IllegalAccessException    if this {@code Field} object</span>
 429      *              is enforcing Java language access control and the underlying
 430      *              field is inaccessible.
<span class="line-modified"> 431      * @exception IllegalArgumentException  if the specified object is not</span>
 432      *              an instance of the class or interface declaring the
 433      *              underlying field (or a subclass or implementor
 434      *              thereof), or if the field value cannot be
 435      *              converted to the type {@code boolean} by a
 436      *              widening conversion.
<span class="line-modified"> 437      * @exception NullPointerException      if the specified object is null</span>
 438      *              and the field is an instance field.
<span class="line-modified"> 439      * @exception ExceptionInInitializerError if the initialization provoked</span>
 440      *              by this method fails.
 441      * @see       Field#get
 442      */
 443     @CallerSensitive
 444     @ForceInline // to ensure Reflection.getCallerClass optimization
 445     public boolean getBoolean(Object obj)
 446         throws IllegalArgumentException, IllegalAccessException
 447     {
 448         if (!override) {
 449             Class&lt;?&gt; caller = Reflection.getCallerClass();
 450             checkAccess(caller, obj);
 451         }
 452         return getFieldAccessor(obj).getBoolean(obj);
 453     }
 454 
 455     /**
 456      * Gets the value of a static or instance {@code byte} field.
 457      *
 458      * @param obj the object to extract the {@code byte} value
 459      * from
 460      * @return the value of the {@code byte} field
 461      *
<span class="line-modified"> 462      * @exception IllegalAccessException    if this {@code Field} object</span>
 463      *              is enforcing Java language access control and the underlying
 464      *              field is inaccessible.
<span class="line-modified"> 465      * @exception IllegalArgumentException  if the specified object is not</span>
 466      *              an instance of the class or interface declaring the
 467      *              underlying field (or a subclass or implementor
 468      *              thereof), or if the field value cannot be
 469      *              converted to the type {@code byte} by a
 470      *              widening conversion.
<span class="line-modified"> 471      * @exception NullPointerException      if the specified object is null</span>
 472      *              and the field is an instance field.
<span class="line-modified"> 473      * @exception ExceptionInInitializerError if the initialization provoked</span>
 474      *              by this method fails.
 475      * @see       Field#get
 476      */
 477     @CallerSensitive
 478     @ForceInline // to ensure Reflection.getCallerClass optimization
 479     public byte getByte(Object obj)
 480         throws IllegalArgumentException, IllegalAccessException
 481     {
 482         if (!override) {
 483             Class&lt;?&gt; caller = Reflection.getCallerClass();
 484             checkAccess(caller, obj);
 485         }
 486         return getFieldAccessor(obj).getByte(obj);
 487     }
 488 
 489     /**
 490      * Gets the value of a static or instance field of type
 491      * {@code char} or of another primitive type convertible to
 492      * type {@code char} via a widening conversion.
 493      *
 494      * @param obj the object to extract the {@code char} value
 495      * from
 496      * @return the value of the field converted to type {@code char}
 497      *
<span class="line-modified"> 498      * @exception IllegalAccessException    if this {@code Field} object</span>
 499      *              is enforcing Java language access control and the underlying
 500      *              field is inaccessible.
<span class="line-modified"> 501      * @exception IllegalArgumentException  if the specified object is not</span>
 502      *              an instance of the class or interface declaring the
 503      *              underlying field (or a subclass or implementor
 504      *              thereof), or if the field value cannot be
 505      *              converted to the type {@code char} by a
 506      *              widening conversion.
<span class="line-modified"> 507      * @exception NullPointerException      if the specified object is null</span>
 508      *              and the field is an instance field.
<span class="line-modified"> 509      * @exception ExceptionInInitializerError if the initialization provoked</span>
 510      *              by this method fails.
 511      * @see Field#get
 512      */
 513     @CallerSensitive
 514     @ForceInline // to ensure Reflection.getCallerClass optimization
 515     public char getChar(Object obj)
 516         throws IllegalArgumentException, IllegalAccessException
 517     {
 518         if (!override) {
 519             Class&lt;?&gt; caller = Reflection.getCallerClass();
 520             checkAccess(caller, obj);
 521         }
 522         return getFieldAccessor(obj).getChar(obj);
 523     }
 524 
 525     /**
 526      * Gets the value of a static or instance field of type
 527      * {@code short} or of another primitive type convertible to
 528      * type {@code short} via a widening conversion.
 529      *
 530      * @param obj the object to extract the {@code short} value
 531      * from
 532      * @return the value of the field converted to type {@code short}
 533      *
<span class="line-modified"> 534      * @exception IllegalAccessException    if this {@code Field} object</span>
 535      *              is enforcing Java language access control and the underlying
 536      *              field is inaccessible.
<span class="line-modified"> 537      * @exception IllegalArgumentException  if the specified object is not</span>
 538      *              an instance of the class or interface declaring the
 539      *              underlying field (or a subclass or implementor
 540      *              thereof), or if the field value cannot be
 541      *              converted to the type {@code short} by a
 542      *              widening conversion.
<span class="line-modified"> 543      * @exception NullPointerException      if the specified object is null</span>
 544      *              and the field is an instance field.
<span class="line-modified"> 545      * @exception ExceptionInInitializerError if the initialization provoked</span>
 546      *              by this method fails.
 547      * @see       Field#get
 548      */
 549     @CallerSensitive
 550     @ForceInline // to ensure Reflection.getCallerClass optimization
 551     public short getShort(Object obj)
 552         throws IllegalArgumentException, IllegalAccessException
 553     {
 554         if (!override) {
 555             Class&lt;?&gt; caller = Reflection.getCallerClass();
 556             checkAccess(caller, obj);
 557         }
 558         return getFieldAccessor(obj).getShort(obj);
 559     }
 560 
 561     /**
 562      * Gets the value of a static or instance field of type
 563      * {@code int} or of another primitive type convertible to
 564      * type {@code int} via a widening conversion.
 565      *
 566      * @param obj the object to extract the {@code int} value
 567      * from
 568      * @return the value of the field converted to type {@code int}
 569      *
<span class="line-modified"> 570      * @exception IllegalAccessException    if this {@code Field} object</span>
 571      *              is enforcing Java language access control and the underlying
 572      *              field is inaccessible.
<span class="line-modified"> 573      * @exception IllegalArgumentException  if the specified object is not</span>
 574      *              an instance of the class or interface declaring the
 575      *              underlying field (or a subclass or implementor
 576      *              thereof), or if the field value cannot be
 577      *              converted to the type {@code int} by a
 578      *              widening conversion.
<span class="line-modified"> 579      * @exception NullPointerException      if the specified object is null</span>
 580      *              and the field is an instance field.
<span class="line-modified"> 581      * @exception ExceptionInInitializerError if the initialization provoked</span>
 582      *              by this method fails.
 583      * @see       Field#get
 584      */
 585     @CallerSensitive
 586     @ForceInline // to ensure Reflection.getCallerClass optimization
 587     public int getInt(Object obj)
 588         throws IllegalArgumentException, IllegalAccessException
 589     {
 590         if (!override) {
 591             Class&lt;?&gt; caller = Reflection.getCallerClass();
 592             checkAccess(caller, obj);
 593         }
 594         return getFieldAccessor(obj).getInt(obj);
 595     }
 596 
 597     /**
 598      * Gets the value of a static or instance field of type
 599      * {@code long} or of another primitive type convertible to
 600      * type {@code long} via a widening conversion.
 601      *
 602      * @param obj the object to extract the {@code long} value
 603      * from
 604      * @return the value of the field converted to type {@code long}
 605      *
<span class="line-modified"> 606      * @exception IllegalAccessException    if this {@code Field} object</span>
 607      *              is enforcing Java language access control and the underlying
 608      *              field is inaccessible.
<span class="line-modified"> 609      * @exception IllegalArgumentException  if the specified object is not</span>
 610      *              an instance of the class or interface declaring the
 611      *              underlying field (or a subclass or implementor
 612      *              thereof), or if the field value cannot be
 613      *              converted to the type {@code long} by a
 614      *              widening conversion.
<span class="line-modified"> 615      * @exception NullPointerException      if the specified object is null</span>
 616      *              and the field is an instance field.
<span class="line-modified"> 617      * @exception ExceptionInInitializerError if the initialization provoked</span>
 618      *              by this method fails.
 619      * @see       Field#get
 620      */
 621     @CallerSensitive
 622     @ForceInline // to ensure Reflection.getCallerClass optimization
 623     public long getLong(Object obj)
 624         throws IllegalArgumentException, IllegalAccessException
 625     {
 626         if (!override) {
 627             Class&lt;?&gt; caller = Reflection.getCallerClass();
 628             checkAccess(caller, obj);
 629         }
 630         return getFieldAccessor(obj).getLong(obj);
 631     }
 632 
 633     /**
 634      * Gets the value of a static or instance field of type
 635      * {@code float} or of another primitive type convertible to
 636      * type {@code float} via a widening conversion.
 637      *
 638      * @param obj the object to extract the {@code float} value
 639      * from
 640      * @return the value of the field converted to type {@code float}
 641      *
<span class="line-modified"> 642      * @exception IllegalAccessException    if this {@code Field} object</span>
 643      *              is enforcing Java language access control and the underlying
 644      *              field is inaccessible.
<span class="line-modified"> 645      * @exception IllegalArgumentException  if the specified object is not</span>
 646      *              an instance of the class or interface declaring the
 647      *              underlying field (or a subclass or implementor
 648      *              thereof), or if the field value cannot be
 649      *              converted to the type {@code float} by a
 650      *              widening conversion.
<span class="line-modified"> 651      * @exception NullPointerException      if the specified object is null</span>
 652      *              and the field is an instance field.
<span class="line-modified"> 653      * @exception ExceptionInInitializerError if the initialization provoked</span>
 654      *              by this method fails.
 655      * @see Field#get
 656      */
 657     @CallerSensitive
 658     @ForceInline // to ensure Reflection.getCallerClass optimization
 659     public float getFloat(Object obj)
 660         throws IllegalArgumentException, IllegalAccessException
 661     {
 662         if (!override) {
 663             Class&lt;?&gt; caller = Reflection.getCallerClass();
 664             checkAccess(caller, obj);
 665         }
 666         return getFieldAccessor(obj).getFloat(obj);
 667     }
 668 
 669     /**
 670      * Gets the value of a static or instance field of type
 671      * {@code double} or of another primitive type convertible to
 672      * type {@code double} via a widening conversion.
 673      *
 674      * @param obj the object to extract the {@code double} value
 675      * from
 676      * @return the value of the field converted to type {@code double}
 677      *
<span class="line-modified"> 678      * @exception IllegalAccessException    if this {@code Field} object</span>
 679      *              is enforcing Java language access control and the underlying
 680      *              field is inaccessible.
<span class="line-modified"> 681      * @exception IllegalArgumentException  if the specified object is not</span>
 682      *              an instance of the class or interface declaring the
 683      *              underlying field (or a subclass or implementor
 684      *              thereof), or if the field value cannot be
 685      *              converted to the type {@code double} by a
 686      *              widening conversion.
<span class="line-modified"> 687      * @exception NullPointerException      if the specified object is null</span>
 688      *              and the field is an instance field.
<span class="line-modified"> 689      * @exception ExceptionInInitializerError if the initialization provoked</span>
 690      *              by this method fails.
 691      * @see       Field#get
 692      */
 693     @CallerSensitive
 694     @ForceInline // to ensure Reflection.getCallerClass optimization
 695     public double getDouble(Object obj)
 696         throws IllegalArgumentException, IllegalAccessException
 697     {
 698         if (!override) {
 699             Class&lt;?&gt; caller = Reflection.getCallerClass();
 700             checkAccess(caller, obj);
 701         }
 702         return getFieldAccessor(obj).getDouble(obj);
 703     }
 704 
 705     /**
 706      * Sets the field represented by this {@code Field} object on the
 707      * specified object argument to the specified new value. The new
 708      * value is automatically unwrapped if the underlying field has a
 709      * primitive type.
</pre>
<hr />
<pre>
 739      * a primitive type.  If this attempt fails, the method throws an
 740      * {@code IllegalArgumentException}.
 741      *
 742      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 743      * converted to the type of the underlying field by an identity or
 744      * widening conversion, the method throws an
 745      * {@code IllegalArgumentException}.
 746      *
 747      * &lt;p&gt;If the underlying field is static, the class that declared the
 748      * field is initialized if it has not already been initialized.
 749      *
 750      * &lt;p&gt;The field is set to the possibly unwrapped and widened new value.
 751      *
 752      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 753      * the field&#39;s value is set according to the preceding rules.
 754      *
 755      * @param obj the object whose field should be modified
 756      * @param value the new value for the field of {@code obj}
 757      * being modified
 758      *
<span class="line-modified"> 759      * @exception IllegalAccessException    if this {@code Field} object</span>
 760      *              is enforcing Java language access control and the underlying
 761      *              field is either inaccessible or final.
<span class="line-modified"> 762      * @exception IllegalArgumentException  if the specified object is not an</span>
 763      *              instance of the class or interface declaring the underlying
 764      *              field (or a subclass or implementor thereof),
 765      *              or if an unwrapping conversion fails.
<span class="line-modified"> 766      * @exception NullPointerException      if the specified object is null</span>
 767      *              and the field is an instance field.
<span class="line-modified"> 768      * @exception ExceptionInInitializerError if the initialization provoked</span>
 769      *              by this method fails.
 770      */
 771     @CallerSensitive
 772     @ForceInline // to ensure Reflection.getCallerClass optimization
 773     public void set(Object obj, Object value)
 774         throws IllegalArgumentException, IllegalAccessException
 775     {
 776         if (!override) {
 777             Class&lt;?&gt; caller = Reflection.getCallerClass();
 778             checkAccess(caller, obj);
 779         }
 780         getFieldAccessor(obj).set(obj, value);
 781     }
 782 
 783     /**
 784      * Sets the value of a field as a {@code boolean} on the specified object.
 785      * This method is equivalent to
 786      * {@code set(obj, zObj)},
 787      * where {@code zObj} is a {@code Boolean} object and
 788      * {@code zObj.booleanValue() == z}.
 789      *
 790      * @param obj the object whose field should be modified
 791      * @param z   the new value for the field of {@code obj}
 792      * being modified
 793      *
<span class="line-modified"> 794      * @exception IllegalAccessException    if this {@code Field} object</span>
 795      *              is enforcing Java language access control and the underlying
 796      *              field is either inaccessible or final.
<span class="line-modified"> 797      * @exception IllegalArgumentException  if the specified object is not an</span>
 798      *              instance of the class or interface declaring the underlying
 799      *              field (or a subclass or implementor thereof),
 800      *              or if an unwrapping conversion fails.
<span class="line-modified"> 801      * @exception NullPointerException      if the specified object is null</span>
 802      *              and the field is an instance field.
<span class="line-modified"> 803      * @exception ExceptionInInitializerError if the initialization provoked</span>
 804      *              by this method fails.
 805      * @see       Field#set
 806      */
 807     @CallerSensitive
 808     @ForceInline // to ensure Reflection.getCallerClass optimization
 809     public void setBoolean(Object obj, boolean z)
 810         throws IllegalArgumentException, IllegalAccessException
 811     {
 812         if (!override) {
 813             Class&lt;?&gt; caller = Reflection.getCallerClass();
 814             checkAccess(caller, obj);
 815         }
 816         getFieldAccessor(obj).setBoolean(obj, z);
 817     }
 818 
 819     /**
 820      * Sets the value of a field as a {@code byte} on the specified object.
 821      * This method is equivalent to
 822      * {@code set(obj, bObj)},
 823      * where {@code bObj} is a {@code Byte} object and
 824      * {@code bObj.byteValue() == b}.
 825      *
 826      * @param obj the object whose field should be modified
 827      * @param b   the new value for the field of {@code obj}
 828      * being modified
 829      *
<span class="line-modified"> 830      * @exception IllegalAccessException    if this {@code Field} object</span>
 831      *              is enforcing Java language access control and the underlying
 832      *              field is either inaccessible or final.
<span class="line-modified"> 833      * @exception IllegalArgumentException  if the specified object is not an</span>
 834      *              instance of the class or interface declaring the underlying
 835      *              field (or a subclass or implementor thereof),
 836      *              or if an unwrapping conversion fails.
<span class="line-modified"> 837      * @exception NullPointerException      if the specified object is null</span>
 838      *              and the field is an instance field.
<span class="line-modified"> 839      * @exception ExceptionInInitializerError if the initialization provoked</span>
 840      *              by this method fails.
 841      * @see       Field#set
 842      */
 843     @CallerSensitive
 844     @ForceInline // to ensure Reflection.getCallerClass optimization
 845     public void setByte(Object obj, byte b)
 846         throws IllegalArgumentException, IllegalAccessException
 847     {
 848         if (!override) {
 849             Class&lt;?&gt; caller = Reflection.getCallerClass();
 850             checkAccess(caller, obj);
 851         }
 852         getFieldAccessor(obj).setByte(obj, b);
 853     }
 854 
 855     /**
 856      * Sets the value of a field as a {@code char} on the specified object.
 857      * This method is equivalent to
 858      * {@code set(obj, cObj)},
 859      * where {@code cObj} is a {@code Character} object and
 860      * {@code cObj.charValue() == c}.
 861      *
 862      * @param obj the object whose field should be modified
 863      * @param c   the new value for the field of {@code obj}
 864      * being modified
 865      *
<span class="line-modified"> 866      * @exception IllegalAccessException    if this {@code Field} object</span>
 867      *              is enforcing Java language access control and the underlying
 868      *              field is either inaccessible or final.
<span class="line-modified"> 869      * @exception IllegalArgumentException  if the specified object is not an</span>
 870      *              instance of the class or interface declaring the underlying
 871      *              field (or a subclass or implementor thereof),
 872      *              or if an unwrapping conversion fails.
<span class="line-modified"> 873      * @exception NullPointerException      if the specified object is null</span>
 874      *              and the field is an instance field.
<span class="line-modified"> 875      * @exception ExceptionInInitializerError if the initialization provoked</span>
 876      *              by this method fails.
 877      * @see       Field#set
 878      */
 879     @CallerSensitive
 880     @ForceInline // to ensure Reflection.getCallerClass optimization
 881     public void setChar(Object obj, char c)
 882         throws IllegalArgumentException, IllegalAccessException
 883     {
 884         if (!override) {
 885             Class&lt;?&gt; caller = Reflection.getCallerClass();
 886             checkAccess(caller, obj);
 887         }
 888         getFieldAccessor(obj).setChar(obj, c);
 889     }
 890 
 891     /**
 892      * Sets the value of a field as a {@code short} on the specified object.
 893      * This method is equivalent to
 894      * {@code set(obj, sObj)},
 895      * where {@code sObj} is a {@code Short} object and
 896      * {@code sObj.shortValue() == s}.
 897      *
 898      * @param obj the object whose field should be modified
 899      * @param s   the new value for the field of {@code obj}
 900      * being modified
 901      *
<span class="line-modified"> 902      * @exception IllegalAccessException    if this {@code Field} object</span>
 903      *              is enforcing Java language access control and the underlying
 904      *              field is either inaccessible or final.
<span class="line-modified"> 905      * @exception IllegalArgumentException  if the specified object is not an</span>
 906      *              instance of the class or interface declaring the underlying
 907      *              field (or a subclass or implementor thereof),
 908      *              or if an unwrapping conversion fails.
<span class="line-modified"> 909      * @exception NullPointerException      if the specified object is null</span>
 910      *              and the field is an instance field.
<span class="line-modified"> 911      * @exception ExceptionInInitializerError if the initialization provoked</span>
 912      *              by this method fails.
 913      * @see       Field#set
 914      */
 915     @CallerSensitive
 916     @ForceInline // to ensure Reflection.getCallerClass optimization
 917     public void setShort(Object obj, short s)
 918         throws IllegalArgumentException, IllegalAccessException
 919     {
 920         if (!override) {
 921             Class&lt;?&gt; caller = Reflection.getCallerClass();
 922             checkAccess(caller, obj);
 923         }
 924         getFieldAccessor(obj).setShort(obj, s);
 925     }
 926 
 927     /**
 928      * Sets the value of a field as an {@code int} on the specified object.
 929      * This method is equivalent to
 930      * {@code set(obj, iObj)},
 931      * where {@code iObj} is an {@code Integer} object and
 932      * {@code iObj.intValue() == i}.
 933      *
 934      * @param obj the object whose field should be modified
 935      * @param i   the new value for the field of {@code obj}
 936      * being modified
 937      *
<span class="line-modified"> 938      * @exception IllegalAccessException    if this {@code Field} object</span>
 939      *              is enforcing Java language access control and the underlying
 940      *              field is either inaccessible or final.
<span class="line-modified"> 941      * @exception IllegalArgumentException  if the specified object is not an</span>
 942      *              instance of the class or interface declaring the underlying
 943      *              field (or a subclass or implementor thereof),
 944      *              or if an unwrapping conversion fails.
<span class="line-modified"> 945      * @exception NullPointerException      if the specified object is null</span>
 946      *              and the field is an instance field.
<span class="line-modified"> 947      * @exception ExceptionInInitializerError if the initialization provoked</span>
 948      *              by this method fails.
 949      * @see       Field#set
 950      */
 951     @CallerSensitive
 952     @ForceInline // to ensure Reflection.getCallerClass optimization
 953     public void setInt(Object obj, int i)
 954         throws IllegalArgumentException, IllegalAccessException
 955     {
 956         if (!override) {
 957             Class&lt;?&gt; caller = Reflection.getCallerClass();
 958             checkAccess(caller, obj);
 959         }
 960         getFieldAccessor(obj).setInt(obj, i);
 961     }
 962 
 963     /**
 964      * Sets the value of a field as a {@code long} on the specified object.
 965      * This method is equivalent to
 966      * {@code set(obj, lObj)},
 967      * where {@code lObj} is a {@code Long} object and
 968      * {@code lObj.longValue() == l}.
 969      *
 970      * @param obj the object whose field should be modified
 971      * @param l   the new value for the field of {@code obj}
 972      * being modified
 973      *
<span class="line-modified"> 974      * @exception IllegalAccessException    if this {@code Field} object</span>
 975      *              is enforcing Java language access control and the underlying
 976      *              field is either inaccessible or final.
<span class="line-modified"> 977      * @exception IllegalArgumentException  if the specified object is not an</span>
 978      *              instance of the class or interface declaring the underlying
 979      *              field (or a subclass or implementor thereof),
 980      *              or if an unwrapping conversion fails.
<span class="line-modified"> 981      * @exception NullPointerException      if the specified object is null</span>
 982      *              and the field is an instance field.
<span class="line-modified"> 983      * @exception ExceptionInInitializerError if the initialization provoked</span>
 984      *              by this method fails.
 985      * @see       Field#set
 986      */
 987     @CallerSensitive
 988     @ForceInline // to ensure Reflection.getCallerClass optimization
 989     public void setLong(Object obj, long l)
 990         throws IllegalArgumentException, IllegalAccessException
 991     {
 992         if (!override) {
 993             Class&lt;?&gt; caller = Reflection.getCallerClass();
 994             checkAccess(caller, obj);
 995         }
 996         getFieldAccessor(obj).setLong(obj, l);
 997     }
 998 
 999     /**
1000      * Sets the value of a field as a {@code float} on the specified object.
1001      * This method is equivalent to
1002      * {@code set(obj, fObj)},
1003      * where {@code fObj} is a {@code Float} object and
1004      * {@code fObj.floatValue() == f}.
1005      *
1006      * @param obj the object whose field should be modified
1007      * @param f   the new value for the field of {@code obj}
1008      * being modified
1009      *
<span class="line-modified">1010      * @exception IllegalAccessException    if this {@code Field} object</span>
1011      *              is enforcing Java language access control and the underlying
1012      *              field is either inaccessible or final.
<span class="line-modified">1013      * @exception IllegalArgumentException  if the specified object is not an</span>
1014      *              instance of the class or interface declaring the underlying
1015      *              field (or a subclass or implementor thereof),
1016      *              or if an unwrapping conversion fails.
<span class="line-modified">1017      * @exception NullPointerException      if the specified object is null</span>
1018      *              and the field is an instance field.
<span class="line-modified">1019      * @exception ExceptionInInitializerError if the initialization provoked</span>
1020      *              by this method fails.
1021      * @see       Field#set
1022      */
1023     @CallerSensitive
1024     @ForceInline // to ensure Reflection.getCallerClass optimization
1025     public void setFloat(Object obj, float f)
1026         throws IllegalArgumentException, IllegalAccessException
1027     {
1028         if (!override) {
1029             Class&lt;?&gt; caller = Reflection.getCallerClass();
1030             checkAccess(caller, obj);
1031         }
1032         getFieldAccessor(obj).setFloat(obj, f);
1033     }
1034 
1035     /**
1036      * Sets the value of a field as a {@code double} on the specified object.
1037      * This method is equivalent to
1038      * {@code set(obj, dObj)},
1039      * where {@code dObj} is a {@code Double} object and
1040      * {@code dObj.doubleValue() == d}.
1041      *
1042      * @param obj the object whose field should be modified
1043      * @param d   the new value for the field of {@code obj}
1044      * being modified
1045      *
<span class="line-modified">1046      * @exception IllegalAccessException    if this {@code Field} object</span>
1047      *              is enforcing Java language access control and the underlying
1048      *              field is either inaccessible or final.
<span class="line-modified">1049      * @exception IllegalArgumentException  if the specified object is not an</span>
1050      *              instance of the class or interface declaring the underlying
1051      *              field (or a subclass or implementor thereof),
1052      *              or if an unwrapping conversion fails.
<span class="line-modified">1053      * @exception NullPointerException      if the specified object is null</span>
1054      *              and the field is an instance field.
<span class="line-modified">1055      * @exception ExceptionInInitializerError if the initialization provoked</span>
1056      *              by this method fails.
1057      * @see       Field#set
1058      */
1059     @CallerSensitive
1060     @ForceInline // to ensure Reflection.getCallerClass optimization
1061     public void setDouble(Object obj, double d)
1062         throws IllegalArgumentException, IllegalAccessException
1063     {
1064         if (!override) {
1065             Class&lt;?&gt; caller = Reflection.getCallerClass();
1066             checkAccess(caller, obj);
1067         }
1068         getFieldAccessor(obj).setDouble(obj, d);
1069     }
1070 
1071     // check access to field
1072     private void checkAccess(Class&lt;?&gt; caller, Object obj)
1073         throws IllegalAccessException
1074     {
1075         checkAccess(caller, clazz,
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  96     // Accessor for factory
  97     private GenericsFactory getFactory() {
  98         Class&lt;?&gt; c = getDeclaringClass();
  99         // create scope and factory
 100         return CoreReflectionFactory.make(c, ClassScope.make(c));
 101     }
 102 
 103     // Accessor for generic info repository
 104     private FieldRepository getGenericInfo() {
 105         // lazily initialize repository if necessary
 106         if (genericInfo == null) {
 107             // create and cache generic info repository
 108             genericInfo = FieldRepository.make(getGenericSignature(),
 109                                                getFactory());
 110         }
 111         return genericInfo; //return cached repository
 112     }
 113 
 114 
 115     /**
<span class="line-modified"> 116      * Package-private constructor</span>


 117      */
 118     Field(Class&lt;?&gt; declaringClass,
 119           String name,
 120           Class&lt;?&gt; type,
 121           int modifiers,
 122           int slot,
 123           String signature,
 124           byte[] annotations)
 125     {
 126         this.clazz = declaringClass;
 127         this.name = name;
 128         this.type = type;
 129         this.modifiers = modifiers;
 130         this.slot = slot;
 131         this.signature = signature;
 132         this.annotations = annotations;
 133     }
 134 
 135     /**
 136      * Package-private routine (exposed to java.lang.Class via
</pre>
<hr />
<pre>
 224     public boolean isSynthetic() {
 225         return Modifier.isSynthetic(getModifiers());
 226     }
 227 
 228     /**
 229      * Returns a {@code Class} object that identifies the
 230      * declared type for the field represented by this
 231      * {@code Field} object.
 232      *
 233      * @return a {@code Class} object identifying the declared
 234      * type of the field represented by this object
 235      */
 236     public Class&lt;?&gt; getType() {
 237         return type;
 238     }
 239 
 240     /**
 241      * Returns a {@code Type} object that represents the declared type for
 242      * the field represented by this {@code Field} object.
 243      *
<span class="line-modified"> 244      * &lt;p&gt;If the declared type of the field is a parameterized type,</span>
<span class="line-modified"> 245      * the {@code Type} object returned must accurately reflect the</span>
<span class="line-modified"> 246      * actual type arguments used in the source code.</span>
 247      *
 248      * &lt;p&gt;If the type of the underlying field is a type variable or a
 249      * parameterized type, it is created. Otherwise, it is resolved.
 250      *
 251      * @return a {@code Type} object that represents the declared type for
 252      *     the field represented by this {@code Field} object
 253      * @throws GenericSignatureFormatError if the generic field
 254      *     signature does not conform to the format specified in
 255      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 256      * @throws TypeNotPresentException if the generic type
 257      *     signature of the underlying field refers to a non-existent
 258      *     type declaration
 259      * @throws MalformedParameterizedTypeException if the generic
 260      *     signature of the underlying field refers to a parameterized type
 261      *     that cannot be instantiated for any reason
 262      * @since 1.5
 263      */
 264     public Type getGenericType() {
 265         if (getGenericSignature() != null)
 266             return getGenericInfo().getGenericType();
</pre>
<hr />
<pre>
 376      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 377      * the underlying field is inaccessible, the method throws an
 378      * {@code IllegalAccessException}.
 379      * If the underlying field is static, the class that declared the
 380      * field is initialized if it has not already been initialized.
 381      *
 382      * &lt;p&gt;Otherwise, the value is retrieved from the underlying instance
 383      * or static field.  If the field has a primitive type, the value
 384      * is wrapped in an object before being returned, otherwise it is
 385      * returned as is.
 386      *
 387      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 388      * the field&#39;s value is obtained according to the preceding rules.
 389      *
 390      * @param obj object from which the represented field&#39;s value is
 391      * to be extracted
 392      * @return the value of the represented field in object
 393      * {@code obj}; primitive values are wrapped in an appropriate
 394      * object before being returned
 395      *
<span class="line-modified"> 396      * @throws    IllegalAccessException    if this {@code Field} object</span>
 397      *              is enforcing Java language access control and the underlying
 398      *              field is inaccessible.
<span class="line-modified"> 399      * @throws    IllegalArgumentException  if the specified object is not an</span>
 400      *              instance of the class or interface declaring the underlying
 401      *              field (or a subclass or implementor thereof).
<span class="line-modified"> 402      * @throws    NullPointerException      if the specified object is null</span>
 403      *              and the field is an instance field.
<span class="line-modified"> 404      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 405      *              by this method fails.
 406      */
 407     @CallerSensitive
 408     @ForceInline // to ensure Reflection.getCallerClass optimization
 409     public Object get(Object obj)
 410         throws IllegalArgumentException, IllegalAccessException
 411     {
 412         if (!override) {
 413             Class&lt;?&gt; caller = Reflection.getCallerClass();
 414             checkAccess(caller, obj);
 415         }
 416         return getFieldAccessor(obj).get(obj);
 417     }
 418 
 419     /**
 420      * Gets the value of a static or instance {@code boolean} field.
 421      *
 422      * @param obj the object to extract the {@code boolean} value
 423      * from
 424      * @return the value of the {@code boolean} field
 425      *
<span class="line-modified"> 426      * @throws    IllegalAccessException    if this {@code Field} object</span>
 427      *              is enforcing Java language access control and the underlying
 428      *              field is inaccessible.
<span class="line-modified"> 429      * @throws    IllegalArgumentException  if the specified object is not</span>
 430      *              an instance of the class or interface declaring the
 431      *              underlying field (or a subclass or implementor
 432      *              thereof), or if the field value cannot be
 433      *              converted to the type {@code boolean} by a
 434      *              widening conversion.
<span class="line-modified"> 435      * @throws    NullPointerException      if the specified object is null</span>
 436      *              and the field is an instance field.
<span class="line-modified"> 437      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 438      *              by this method fails.
 439      * @see       Field#get
 440      */
 441     @CallerSensitive
 442     @ForceInline // to ensure Reflection.getCallerClass optimization
 443     public boolean getBoolean(Object obj)
 444         throws IllegalArgumentException, IllegalAccessException
 445     {
 446         if (!override) {
 447             Class&lt;?&gt; caller = Reflection.getCallerClass();
 448             checkAccess(caller, obj);
 449         }
 450         return getFieldAccessor(obj).getBoolean(obj);
 451     }
 452 
 453     /**
 454      * Gets the value of a static or instance {@code byte} field.
 455      *
 456      * @param obj the object to extract the {@code byte} value
 457      * from
 458      * @return the value of the {@code byte} field
 459      *
<span class="line-modified"> 460      * @throws    IllegalAccessException    if this {@code Field} object</span>
 461      *              is enforcing Java language access control and the underlying
 462      *              field is inaccessible.
<span class="line-modified"> 463      * @throws    IllegalArgumentException  if the specified object is not</span>
 464      *              an instance of the class or interface declaring the
 465      *              underlying field (or a subclass or implementor
 466      *              thereof), or if the field value cannot be
 467      *              converted to the type {@code byte} by a
 468      *              widening conversion.
<span class="line-modified"> 469      * @throws    NullPointerException      if the specified object is null</span>
 470      *              and the field is an instance field.
<span class="line-modified"> 471      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 472      *              by this method fails.
 473      * @see       Field#get
 474      */
 475     @CallerSensitive
 476     @ForceInline // to ensure Reflection.getCallerClass optimization
 477     public byte getByte(Object obj)
 478         throws IllegalArgumentException, IllegalAccessException
 479     {
 480         if (!override) {
 481             Class&lt;?&gt; caller = Reflection.getCallerClass();
 482             checkAccess(caller, obj);
 483         }
 484         return getFieldAccessor(obj).getByte(obj);
 485     }
 486 
 487     /**
 488      * Gets the value of a static or instance field of type
 489      * {@code char} or of another primitive type convertible to
 490      * type {@code char} via a widening conversion.
 491      *
 492      * @param obj the object to extract the {@code char} value
 493      * from
 494      * @return the value of the field converted to type {@code char}
 495      *
<span class="line-modified"> 496      * @throws    IllegalAccessException    if this {@code Field} object</span>
 497      *              is enforcing Java language access control and the underlying
 498      *              field is inaccessible.
<span class="line-modified"> 499      * @throws    IllegalArgumentException  if the specified object is not</span>
 500      *              an instance of the class or interface declaring the
 501      *              underlying field (or a subclass or implementor
 502      *              thereof), or if the field value cannot be
 503      *              converted to the type {@code char} by a
 504      *              widening conversion.
<span class="line-modified"> 505      * @throws    NullPointerException      if the specified object is null</span>
 506      *              and the field is an instance field.
<span class="line-modified"> 507      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 508      *              by this method fails.
 509      * @see Field#get
 510      */
 511     @CallerSensitive
 512     @ForceInline // to ensure Reflection.getCallerClass optimization
 513     public char getChar(Object obj)
 514         throws IllegalArgumentException, IllegalAccessException
 515     {
 516         if (!override) {
 517             Class&lt;?&gt; caller = Reflection.getCallerClass();
 518             checkAccess(caller, obj);
 519         }
 520         return getFieldAccessor(obj).getChar(obj);
 521     }
 522 
 523     /**
 524      * Gets the value of a static or instance field of type
 525      * {@code short} or of another primitive type convertible to
 526      * type {@code short} via a widening conversion.
 527      *
 528      * @param obj the object to extract the {@code short} value
 529      * from
 530      * @return the value of the field converted to type {@code short}
 531      *
<span class="line-modified"> 532      * @throws    IllegalAccessException    if this {@code Field} object</span>
 533      *              is enforcing Java language access control and the underlying
 534      *              field is inaccessible.
<span class="line-modified"> 535      * @throws    IllegalArgumentException  if the specified object is not</span>
 536      *              an instance of the class or interface declaring the
 537      *              underlying field (or a subclass or implementor
 538      *              thereof), or if the field value cannot be
 539      *              converted to the type {@code short} by a
 540      *              widening conversion.
<span class="line-modified"> 541      * @throws    NullPointerException      if the specified object is null</span>
 542      *              and the field is an instance field.
<span class="line-modified"> 543      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 544      *              by this method fails.
 545      * @see       Field#get
 546      */
 547     @CallerSensitive
 548     @ForceInline // to ensure Reflection.getCallerClass optimization
 549     public short getShort(Object obj)
 550         throws IllegalArgumentException, IllegalAccessException
 551     {
 552         if (!override) {
 553             Class&lt;?&gt; caller = Reflection.getCallerClass();
 554             checkAccess(caller, obj);
 555         }
 556         return getFieldAccessor(obj).getShort(obj);
 557     }
 558 
 559     /**
 560      * Gets the value of a static or instance field of type
 561      * {@code int} or of another primitive type convertible to
 562      * type {@code int} via a widening conversion.
 563      *
 564      * @param obj the object to extract the {@code int} value
 565      * from
 566      * @return the value of the field converted to type {@code int}
 567      *
<span class="line-modified"> 568      * @throws    IllegalAccessException    if this {@code Field} object</span>
 569      *              is enforcing Java language access control and the underlying
 570      *              field is inaccessible.
<span class="line-modified"> 571      * @throws    IllegalArgumentException  if the specified object is not</span>
 572      *              an instance of the class or interface declaring the
 573      *              underlying field (or a subclass or implementor
 574      *              thereof), or if the field value cannot be
 575      *              converted to the type {@code int} by a
 576      *              widening conversion.
<span class="line-modified"> 577      * @throws    NullPointerException      if the specified object is null</span>
 578      *              and the field is an instance field.
<span class="line-modified"> 579      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 580      *              by this method fails.
 581      * @see       Field#get
 582      */
 583     @CallerSensitive
 584     @ForceInline // to ensure Reflection.getCallerClass optimization
 585     public int getInt(Object obj)
 586         throws IllegalArgumentException, IllegalAccessException
 587     {
 588         if (!override) {
 589             Class&lt;?&gt; caller = Reflection.getCallerClass();
 590             checkAccess(caller, obj);
 591         }
 592         return getFieldAccessor(obj).getInt(obj);
 593     }
 594 
 595     /**
 596      * Gets the value of a static or instance field of type
 597      * {@code long} or of another primitive type convertible to
 598      * type {@code long} via a widening conversion.
 599      *
 600      * @param obj the object to extract the {@code long} value
 601      * from
 602      * @return the value of the field converted to type {@code long}
 603      *
<span class="line-modified"> 604      * @throws    IllegalAccessException    if this {@code Field} object</span>
 605      *              is enforcing Java language access control and the underlying
 606      *              field is inaccessible.
<span class="line-modified"> 607      * @throws    IllegalArgumentException  if the specified object is not</span>
 608      *              an instance of the class or interface declaring the
 609      *              underlying field (or a subclass or implementor
 610      *              thereof), or if the field value cannot be
 611      *              converted to the type {@code long} by a
 612      *              widening conversion.
<span class="line-modified"> 613      * @throws    NullPointerException      if the specified object is null</span>
 614      *              and the field is an instance field.
<span class="line-modified"> 615      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 616      *              by this method fails.
 617      * @see       Field#get
 618      */
 619     @CallerSensitive
 620     @ForceInline // to ensure Reflection.getCallerClass optimization
 621     public long getLong(Object obj)
 622         throws IllegalArgumentException, IllegalAccessException
 623     {
 624         if (!override) {
 625             Class&lt;?&gt; caller = Reflection.getCallerClass();
 626             checkAccess(caller, obj);
 627         }
 628         return getFieldAccessor(obj).getLong(obj);
 629     }
 630 
 631     /**
 632      * Gets the value of a static or instance field of type
 633      * {@code float} or of another primitive type convertible to
 634      * type {@code float} via a widening conversion.
 635      *
 636      * @param obj the object to extract the {@code float} value
 637      * from
 638      * @return the value of the field converted to type {@code float}
 639      *
<span class="line-modified"> 640      * @throws    IllegalAccessException    if this {@code Field} object</span>
 641      *              is enforcing Java language access control and the underlying
 642      *              field is inaccessible.
<span class="line-modified"> 643      * @throws    IllegalArgumentException  if the specified object is not</span>
 644      *              an instance of the class or interface declaring the
 645      *              underlying field (or a subclass or implementor
 646      *              thereof), or if the field value cannot be
 647      *              converted to the type {@code float} by a
 648      *              widening conversion.
<span class="line-modified"> 649      * @throws    NullPointerException      if the specified object is null</span>
 650      *              and the field is an instance field.
<span class="line-modified"> 651      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 652      *              by this method fails.
 653      * @see Field#get
 654      */
 655     @CallerSensitive
 656     @ForceInline // to ensure Reflection.getCallerClass optimization
 657     public float getFloat(Object obj)
 658         throws IllegalArgumentException, IllegalAccessException
 659     {
 660         if (!override) {
 661             Class&lt;?&gt; caller = Reflection.getCallerClass();
 662             checkAccess(caller, obj);
 663         }
 664         return getFieldAccessor(obj).getFloat(obj);
 665     }
 666 
 667     /**
 668      * Gets the value of a static or instance field of type
 669      * {@code double} or of another primitive type convertible to
 670      * type {@code double} via a widening conversion.
 671      *
 672      * @param obj the object to extract the {@code double} value
 673      * from
 674      * @return the value of the field converted to type {@code double}
 675      *
<span class="line-modified"> 676      * @throws    IllegalAccessException    if this {@code Field} object</span>
 677      *              is enforcing Java language access control and the underlying
 678      *              field is inaccessible.
<span class="line-modified"> 679      * @throws    IllegalArgumentException  if the specified object is not</span>
 680      *              an instance of the class or interface declaring the
 681      *              underlying field (or a subclass or implementor
 682      *              thereof), or if the field value cannot be
 683      *              converted to the type {@code double} by a
 684      *              widening conversion.
<span class="line-modified"> 685      * @throws    NullPointerException      if the specified object is null</span>
 686      *              and the field is an instance field.
<span class="line-modified"> 687      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 688      *              by this method fails.
 689      * @see       Field#get
 690      */
 691     @CallerSensitive
 692     @ForceInline // to ensure Reflection.getCallerClass optimization
 693     public double getDouble(Object obj)
 694         throws IllegalArgumentException, IllegalAccessException
 695     {
 696         if (!override) {
 697             Class&lt;?&gt; caller = Reflection.getCallerClass();
 698             checkAccess(caller, obj);
 699         }
 700         return getFieldAccessor(obj).getDouble(obj);
 701     }
 702 
 703     /**
 704      * Sets the field represented by this {@code Field} object on the
 705      * specified object argument to the specified new value. The new
 706      * value is automatically unwrapped if the underlying field has a
 707      * primitive type.
</pre>
<hr />
<pre>
 737      * a primitive type.  If this attempt fails, the method throws an
 738      * {@code IllegalArgumentException}.
 739      *
 740      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 741      * converted to the type of the underlying field by an identity or
 742      * widening conversion, the method throws an
 743      * {@code IllegalArgumentException}.
 744      *
 745      * &lt;p&gt;If the underlying field is static, the class that declared the
 746      * field is initialized if it has not already been initialized.
 747      *
 748      * &lt;p&gt;The field is set to the possibly unwrapped and widened new value.
 749      *
 750      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 751      * the field&#39;s value is set according to the preceding rules.
 752      *
 753      * @param obj the object whose field should be modified
 754      * @param value the new value for the field of {@code obj}
 755      * being modified
 756      *
<span class="line-modified"> 757      * @throws    IllegalAccessException    if this {@code Field} object</span>
 758      *              is enforcing Java language access control and the underlying
 759      *              field is either inaccessible or final.
<span class="line-modified"> 760      * @throws    IllegalArgumentException  if the specified object is not an</span>
 761      *              instance of the class or interface declaring the underlying
 762      *              field (or a subclass or implementor thereof),
 763      *              or if an unwrapping conversion fails.
<span class="line-modified"> 764      * @throws    NullPointerException      if the specified object is null</span>
 765      *              and the field is an instance field.
<span class="line-modified"> 766      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 767      *              by this method fails.
 768      */
 769     @CallerSensitive
 770     @ForceInline // to ensure Reflection.getCallerClass optimization
 771     public void set(Object obj, Object value)
 772         throws IllegalArgumentException, IllegalAccessException
 773     {
 774         if (!override) {
 775             Class&lt;?&gt; caller = Reflection.getCallerClass();
 776             checkAccess(caller, obj);
 777         }
 778         getFieldAccessor(obj).set(obj, value);
 779     }
 780 
 781     /**
 782      * Sets the value of a field as a {@code boolean} on the specified object.
 783      * This method is equivalent to
 784      * {@code set(obj, zObj)},
 785      * where {@code zObj} is a {@code Boolean} object and
 786      * {@code zObj.booleanValue() == z}.
 787      *
 788      * @param obj the object whose field should be modified
 789      * @param z   the new value for the field of {@code obj}
 790      * being modified
 791      *
<span class="line-modified"> 792      * @throws    IllegalAccessException    if this {@code Field} object</span>
 793      *              is enforcing Java language access control and the underlying
 794      *              field is either inaccessible or final.
<span class="line-modified"> 795      * @throws    IllegalArgumentException  if the specified object is not an</span>
 796      *              instance of the class or interface declaring the underlying
 797      *              field (or a subclass or implementor thereof),
 798      *              or if an unwrapping conversion fails.
<span class="line-modified"> 799      * @throws    NullPointerException      if the specified object is null</span>
 800      *              and the field is an instance field.
<span class="line-modified"> 801      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 802      *              by this method fails.
 803      * @see       Field#set
 804      */
 805     @CallerSensitive
 806     @ForceInline // to ensure Reflection.getCallerClass optimization
 807     public void setBoolean(Object obj, boolean z)
 808         throws IllegalArgumentException, IllegalAccessException
 809     {
 810         if (!override) {
 811             Class&lt;?&gt; caller = Reflection.getCallerClass();
 812             checkAccess(caller, obj);
 813         }
 814         getFieldAccessor(obj).setBoolean(obj, z);
 815     }
 816 
 817     /**
 818      * Sets the value of a field as a {@code byte} on the specified object.
 819      * This method is equivalent to
 820      * {@code set(obj, bObj)},
 821      * where {@code bObj} is a {@code Byte} object and
 822      * {@code bObj.byteValue() == b}.
 823      *
 824      * @param obj the object whose field should be modified
 825      * @param b   the new value for the field of {@code obj}
 826      * being modified
 827      *
<span class="line-modified"> 828      * @throws    IllegalAccessException    if this {@code Field} object</span>
 829      *              is enforcing Java language access control and the underlying
 830      *              field is either inaccessible or final.
<span class="line-modified"> 831      * @throws    IllegalArgumentException  if the specified object is not an</span>
 832      *              instance of the class or interface declaring the underlying
 833      *              field (or a subclass or implementor thereof),
 834      *              or if an unwrapping conversion fails.
<span class="line-modified"> 835      * @throws    NullPointerException      if the specified object is null</span>
 836      *              and the field is an instance field.
<span class="line-modified"> 837      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 838      *              by this method fails.
 839      * @see       Field#set
 840      */
 841     @CallerSensitive
 842     @ForceInline // to ensure Reflection.getCallerClass optimization
 843     public void setByte(Object obj, byte b)
 844         throws IllegalArgumentException, IllegalAccessException
 845     {
 846         if (!override) {
 847             Class&lt;?&gt; caller = Reflection.getCallerClass();
 848             checkAccess(caller, obj);
 849         }
 850         getFieldAccessor(obj).setByte(obj, b);
 851     }
 852 
 853     /**
 854      * Sets the value of a field as a {@code char} on the specified object.
 855      * This method is equivalent to
 856      * {@code set(obj, cObj)},
 857      * where {@code cObj} is a {@code Character} object and
 858      * {@code cObj.charValue() == c}.
 859      *
 860      * @param obj the object whose field should be modified
 861      * @param c   the new value for the field of {@code obj}
 862      * being modified
 863      *
<span class="line-modified"> 864      * @throws    IllegalAccessException    if this {@code Field} object</span>
 865      *              is enforcing Java language access control and the underlying
 866      *              field is either inaccessible or final.
<span class="line-modified"> 867      * @throws    IllegalArgumentException  if the specified object is not an</span>
 868      *              instance of the class or interface declaring the underlying
 869      *              field (or a subclass or implementor thereof),
 870      *              or if an unwrapping conversion fails.
<span class="line-modified"> 871      * @throws    NullPointerException      if the specified object is null</span>
 872      *              and the field is an instance field.
<span class="line-modified"> 873      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 874      *              by this method fails.
 875      * @see       Field#set
 876      */
 877     @CallerSensitive
 878     @ForceInline // to ensure Reflection.getCallerClass optimization
 879     public void setChar(Object obj, char c)
 880         throws IllegalArgumentException, IllegalAccessException
 881     {
 882         if (!override) {
 883             Class&lt;?&gt; caller = Reflection.getCallerClass();
 884             checkAccess(caller, obj);
 885         }
 886         getFieldAccessor(obj).setChar(obj, c);
 887     }
 888 
 889     /**
 890      * Sets the value of a field as a {@code short} on the specified object.
 891      * This method is equivalent to
 892      * {@code set(obj, sObj)},
 893      * where {@code sObj} is a {@code Short} object and
 894      * {@code sObj.shortValue() == s}.
 895      *
 896      * @param obj the object whose field should be modified
 897      * @param s   the new value for the field of {@code obj}
 898      * being modified
 899      *
<span class="line-modified"> 900      * @throws    IllegalAccessException    if this {@code Field} object</span>
 901      *              is enforcing Java language access control and the underlying
 902      *              field is either inaccessible or final.
<span class="line-modified"> 903      * @throws    IllegalArgumentException  if the specified object is not an</span>
 904      *              instance of the class or interface declaring the underlying
 905      *              field (or a subclass or implementor thereof),
 906      *              or if an unwrapping conversion fails.
<span class="line-modified"> 907      * @throws    NullPointerException      if the specified object is null</span>
 908      *              and the field is an instance field.
<span class="line-modified"> 909      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 910      *              by this method fails.
 911      * @see       Field#set
 912      */
 913     @CallerSensitive
 914     @ForceInline // to ensure Reflection.getCallerClass optimization
 915     public void setShort(Object obj, short s)
 916         throws IllegalArgumentException, IllegalAccessException
 917     {
 918         if (!override) {
 919             Class&lt;?&gt; caller = Reflection.getCallerClass();
 920             checkAccess(caller, obj);
 921         }
 922         getFieldAccessor(obj).setShort(obj, s);
 923     }
 924 
 925     /**
 926      * Sets the value of a field as an {@code int} on the specified object.
 927      * This method is equivalent to
 928      * {@code set(obj, iObj)},
 929      * where {@code iObj} is an {@code Integer} object and
 930      * {@code iObj.intValue() == i}.
 931      *
 932      * @param obj the object whose field should be modified
 933      * @param i   the new value for the field of {@code obj}
 934      * being modified
 935      *
<span class="line-modified"> 936      * @throws    IllegalAccessException    if this {@code Field} object</span>
 937      *              is enforcing Java language access control and the underlying
 938      *              field is either inaccessible or final.
<span class="line-modified"> 939      * @throws    IllegalArgumentException  if the specified object is not an</span>
 940      *              instance of the class or interface declaring the underlying
 941      *              field (or a subclass or implementor thereof),
 942      *              or if an unwrapping conversion fails.
<span class="line-modified"> 943      * @throws    NullPointerException      if the specified object is null</span>
 944      *              and the field is an instance field.
<span class="line-modified"> 945      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 946      *              by this method fails.
 947      * @see       Field#set
 948      */
 949     @CallerSensitive
 950     @ForceInline // to ensure Reflection.getCallerClass optimization
 951     public void setInt(Object obj, int i)
 952         throws IllegalArgumentException, IllegalAccessException
 953     {
 954         if (!override) {
 955             Class&lt;?&gt; caller = Reflection.getCallerClass();
 956             checkAccess(caller, obj);
 957         }
 958         getFieldAccessor(obj).setInt(obj, i);
 959     }
 960 
 961     /**
 962      * Sets the value of a field as a {@code long} on the specified object.
 963      * This method is equivalent to
 964      * {@code set(obj, lObj)},
 965      * where {@code lObj} is a {@code Long} object and
 966      * {@code lObj.longValue() == l}.
 967      *
 968      * @param obj the object whose field should be modified
 969      * @param l   the new value for the field of {@code obj}
 970      * being modified
 971      *
<span class="line-modified"> 972      * @throws    IllegalAccessException    if this {@code Field} object</span>
 973      *              is enforcing Java language access control and the underlying
 974      *              field is either inaccessible or final.
<span class="line-modified"> 975      * @throws    IllegalArgumentException  if the specified object is not an</span>
 976      *              instance of the class or interface declaring the underlying
 977      *              field (or a subclass or implementor thereof),
 978      *              or if an unwrapping conversion fails.
<span class="line-modified"> 979      * @throws    NullPointerException      if the specified object is null</span>
 980      *              and the field is an instance field.
<span class="line-modified"> 981      * @throws    ExceptionInInitializerError if the initialization provoked</span>
 982      *              by this method fails.
 983      * @see       Field#set
 984      */
 985     @CallerSensitive
 986     @ForceInline // to ensure Reflection.getCallerClass optimization
 987     public void setLong(Object obj, long l)
 988         throws IllegalArgumentException, IllegalAccessException
 989     {
 990         if (!override) {
 991             Class&lt;?&gt; caller = Reflection.getCallerClass();
 992             checkAccess(caller, obj);
 993         }
 994         getFieldAccessor(obj).setLong(obj, l);
 995     }
 996 
 997     /**
 998      * Sets the value of a field as a {@code float} on the specified object.
 999      * This method is equivalent to
1000      * {@code set(obj, fObj)},
1001      * where {@code fObj} is a {@code Float} object and
1002      * {@code fObj.floatValue() == f}.
1003      *
1004      * @param obj the object whose field should be modified
1005      * @param f   the new value for the field of {@code obj}
1006      * being modified
1007      *
<span class="line-modified">1008      * @throws    IllegalAccessException    if this {@code Field} object</span>
1009      *              is enforcing Java language access control and the underlying
1010      *              field is either inaccessible or final.
<span class="line-modified">1011      * @throws    IllegalArgumentException  if the specified object is not an</span>
1012      *              instance of the class or interface declaring the underlying
1013      *              field (or a subclass or implementor thereof),
1014      *              or if an unwrapping conversion fails.
<span class="line-modified">1015      * @throws    NullPointerException      if the specified object is null</span>
1016      *              and the field is an instance field.
<span class="line-modified">1017      * @throws    ExceptionInInitializerError if the initialization provoked</span>
1018      *              by this method fails.
1019      * @see       Field#set
1020      */
1021     @CallerSensitive
1022     @ForceInline // to ensure Reflection.getCallerClass optimization
1023     public void setFloat(Object obj, float f)
1024         throws IllegalArgumentException, IllegalAccessException
1025     {
1026         if (!override) {
1027             Class&lt;?&gt; caller = Reflection.getCallerClass();
1028             checkAccess(caller, obj);
1029         }
1030         getFieldAccessor(obj).setFloat(obj, f);
1031     }
1032 
1033     /**
1034      * Sets the value of a field as a {@code double} on the specified object.
1035      * This method is equivalent to
1036      * {@code set(obj, dObj)},
1037      * where {@code dObj} is a {@code Double} object and
1038      * {@code dObj.doubleValue() == d}.
1039      *
1040      * @param obj the object whose field should be modified
1041      * @param d   the new value for the field of {@code obj}
1042      * being modified
1043      *
<span class="line-modified">1044      * @throws    IllegalAccessException    if this {@code Field} object</span>
1045      *              is enforcing Java language access control and the underlying
1046      *              field is either inaccessible or final.
<span class="line-modified">1047      * @throws    IllegalArgumentException  if the specified object is not an</span>
1048      *              instance of the class or interface declaring the underlying
1049      *              field (or a subclass or implementor thereof),
1050      *              or if an unwrapping conversion fails.
<span class="line-modified">1051      * @throws    NullPointerException      if the specified object is null</span>
1052      *              and the field is an instance field.
<span class="line-modified">1053      * @throws    ExceptionInInitializerError if the initialization provoked</span>
1054      *              by this method fails.
1055      * @see       Field#set
1056      */
1057     @CallerSensitive
1058     @ForceInline // to ensure Reflection.getCallerClass optimization
1059     public void setDouble(Object obj, double d)
1060         throws IllegalArgumentException, IllegalAccessException
1061     {
1062         if (!override) {
1063             Class&lt;?&gt; caller = Reflection.getCallerClass();
1064             checkAccess(caller, obj);
1065         }
1066         getFieldAccessor(obj).setDouble(obj, d);
1067     }
1068 
1069     // check access to field
1070     private void checkAccess(Class&lt;?&gt; caller, Object obj)
1071         throws IllegalAccessException
1072     {
1073         checkAccess(caller, clazz,
</pre>
</td>
</tr>
</table>
<center><a href="Executable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="GenericSignatureFormatError.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
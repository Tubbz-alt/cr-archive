diff a/src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template b/src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template
--- a/src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template
+++ b/src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template
@@ -22,10 +22,12 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package java.lang.invoke;
 
+import jdk.internal.access.JavaNioAccess;
+import jdk.internal.access.SharedSecrets;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.util.Preconditions;
 import jdk.internal.vm.annotation.ForceInline;
 
 import java.nio.ByteBuffer;
@@ -36,10 +38,12 @@
 
 #warn
 
 final class VarHandleByteArrayAs$Type$s extends VarHandleByteArrayBase {
 
+    static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
+
     static final int ALIGN = $BoxType$.BYTES - 1;
 
 #if[floatingPoint]
     @ForceInline
     static $rawType$ convEndian(boolean big, $type$ v) {
@@ -527,18 +531,19 @@
             return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);
         }
 
         @ForceInline
         static int index(ByteBuffer bb, int index) {
+            nioAccess.checkSegment(bb);
             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
         }
 
         @ForceInline
         static int indexRO(ByteBuffer bb, int index) {
             if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))
                 throw new ReadOnlyBufferException();
-            return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
+            return index(bb, index);
         }
 
         @ForceInline
         static long address(ByteBuffer bb, int index) {
             long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);

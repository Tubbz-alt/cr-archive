<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/nio/channels/DatagramChannel.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.nio.channels;
 27 
 28 import java.io.IOException;
 29 import java.net.ProtocolFamily;
 30 import java.net.DatagramSocket;
 31 import java.net.SocketOption;
 32 import java.net.SocketAddress;
 33 import java.nio.ByteBuffer;
 34 import java.nio.channels.spi.AbstractSelectableChannel;
 35 import java.nio.channels.spi.SelectorProvider;
 36 
 37 /**
 38  * A selectable channel for datagram-oriented sockets.
 39  *
 40  * &lt;p&gt; A datagram channel is created by invoking one of the {@link #open open} methods
 41  * of this class. It is not possible to create a channel for an arbitrary,
 42  * pre-existing datagram socket. A newly-created datagram channel is open but not
 43  * connected. A datagram channel need not be connected in order for the {@link #send
 44  * send} and {@link #receive receive} methods to be used.  A datagram channel may be
 45  * connected, by invoking its {@link #connect connect} method, in order to
 46  * avoid the overhead of the security checks are otherwise performed as part of
 47  * every send and receive operation.  A datagram channel must be connected in
 48  * order to use the {@link #read(java.nio.ByteBuffer) read} and {@link
 49  * #write(java.nio.ByteBuffer) write} methods, since those methods do not
 50  * accept or return socket addresses.
 51  *
 52  * &lt;p&gt; Once connected, a datagram channel remains connected until it is
 53  * disconnected or closed.  Whether or not a datagram channel is connected may
 54  * be determined by invoking its {@link #isConnected isConnected} method.
 55  *
 56  * &lt;p&gt; Socket options are configured using the {@link #setOption(SocketOption,Object)
 57  * setOption} method. A datagram channel to an Internet Protocol socket supports
 58  * the following options:
 59  * &lt;blockquote&gt;
 60  * &lt;table class=&quot;striped&quot;&gt;
 61  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;
 62  * &lt;thead&gt;
 63  *   &lt;tr&gt;
 64  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;
 65  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
 66  *   &lt;/tr&gt;
 67  * &lt;/thead&gt;
 68  * &lt;tbody&gt;
 69  *   &lt;tr&gt;
 70  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} &lt;/th&gt;
 71  *     &lt;td&gt; The size of the socket send buffer &lt;/td&gt;
 72  *   &lt;/tr&gt;
 73  *   &lt;tr&gt;
 74  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} &lt;/th&gt;
 75  *     &lt;td&gt; The size of the socket receive buffer &lt;/td&gt;
 76  *   &lt;/tr&gt;
 77  *   &lt;tr&gt;
 78  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} &lt;/th&gt;
 79  *     &lt;td&gt; Re-use address &lt;/td&gt;
 80  *   &lt;/tr&gt;
 81  *   &lt;tr&gt;
 82  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_BROADCAST SO_BROADCAST} &lt;/th&gt;
 83  *     &lt;td&gt; Allow transmission of broadcast datagrams &lt;/td&gt;
 84  *   &lt;/tr&gt;
 85  *   &lt;tr&gt;
 86  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_TOS IP_TOS} &lt;/th&gt;
 87  *     &lt;td&gt; The Type of Service (ToS) octet in the Internet Protocol (IP) header &lt;/td&gt;
 88  *   &lt;/tr&gt;
 89  *   &lt;tr&gt;
 90  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_IF IP_MULTICAST_IF} &lt;/th&gt;
 91  *     &lt;td&gt; The network interface for Internet Protocol (IP) multicast datagrams &lt;/td&gt;
 92  *   &lt;/tr&gt;
 93  *   &lt;tr&gt;
 94  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_TTL
 95  *       IP_MULTICAST_TTL} &lt;/th&gt;
 96  *     &lt;td&gt; The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast
 97  *       datagrams &lt;/td&gt;
 98  *   &lt;/tr&gt;
 99  *   &lt;tr&gt;
100  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP
101  *       IP_MULTICAST_LOOP} &lt;/th&gt;
102  *     &lt;td&gt; Loopback for Internet Protocol (IP) multicast datagrams &lt;/td&gt;
103  *   &lt;/tr&gt;
104  * &lt;/tbody&gt;
105  * &lt;/table&gt;
106  * &lt;/blockquote&gt;
107  * Additional (implementation specific) options may also be supported.
108  *
109  * &lt;p&gt; Datagram channels are safe for use by multiple concurrent threads.  They
110  * support concurrent reading and writing, though at most one thread may be
111  * reading and at most one thread may be writing at any given time.  &lt;/p&gt;
112  *
113  * @author Mark Reinhold
114  * @author JSR-51 Expert Group
115  * @since 1.4
116  */
117 
118 public abstract class DatagramChannel
119     extends AbstractSelectableChannel
120     implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, MulticastChannel
121 {
122 
123     /**
124      * Initializes a new instance of this class.
125      *
126      * @param  provider
127      *         The provider that created this channel
128      */
129     protected DatagramChannel(SelectorProvider provider) {
130         super(provider);
131     }
132 
133     /**
134      * Opens a datagram channel.
135      *
136      * &lt;p&gt; The new channel is created by invoking the {@link
137      * java.nio.channels.spi.SelectorProvider#openDatagramChannel()
138      * openDatagramChannel} method of the system-wide default {@link
139      * java.nio.channels.spi.SelectorProvider} object.  The channel will not be
140      * connected.
141      *
142      * &lt;p&gt; The {@link ProtocolFamily ProtocolFamily} of the channel&#39;s socket
143      * is platform (and possibly configuration) dependent and therefore unspecified.
144      * The {@link #open(ProtocolFamily) open} allows the protocol family to be
145      * selected when opening a datagram channel, and should be used to open
146      * datagram channels that are intended for Internet Protocol multicasting.
147      *
148      * @return  A new datagram channel
149      *
150      * @throws  IOException
151      *          If an I/O error occurs
152      */
153     public static DatagramChannel open() throws IOException {
154         return SelectorProvider.provider().openDatagramChannel();
155     }
156 
157     /**
158      * Opens a datagram channel.
159      *
160      * &lt;p&gt; The {@code family} parameter is used to specify the {@link
161      * ProtocolFamily}. If the datagram channel is to be used for IP multicasting
162      * then this should correspond to the address type of the multicast groups
163      * that this channel will join.
164      *
165      * &lt;p&gt; The new channel is created by invoking the {@link
166      * java.nio.channels.spi.SelectorProvider#openDatagramChannel(ProtocolFamily)
167      * openDatagramChannel} method of the system-wide default {@link
168      * java.nio.channels.spi.SelectorProvider} object.  The channel will not be
169      * connected.
170      *
171      * @param   family
172      *          The protocol family
173      *
174      * @return  A new datagram channel
175      *
176      * @throws  UnsupportedOperationException
177      *          If the specified protocol family is not supported. For example,
178      *          suppose the parameter is specified as {@link
179      *          java.net.StandardProtocolFamily#INET6 StandardProtocolFamily.INET6}
180      *          but IPv6 is not enabled on the platform.
181      * @throws  IOException
182      *          If an I/O error occurs
183      *
184      * @since   1.7
185      */
186     public static DatagramChannel open(ProtocolFamily family) throws IOException {
187         return SelectorProvider.provider().openDatagramChannel(family);
188     }
189 
190     /**
191      * Returns an operation set identifying this channel&#39;s supported
192      * operations.
193      *
194      * &lt;p&gt; Datagram channels support reading and writing, so this method
195      * returns {@code (}{@link SelectionKey#OP_READ} {@code |}&amp;nbsp;{@link
196      * SelectionKey#OP_WRITE}{@code )}.
197      *
198      * @return  The valid-operation set
199      */
200     public final int validOps() {
201         return (SelectionKey.OP_READ
202                 | SelectionKey.OP_WRITE);
203     }
204 
205 
206     // -- Socket-specific operations --
207 
208     /**
209      * @throws  AlreadyBoundException               {@inheritDoc}
210      * @throws  UnsupportedAddressTypeException     {@inheritDoc}
211      * @throws  ClosedChannelException              {@inheritDoc}
212      * @throws  IOException                         {@inheritDoc}
213      * @throws  SecurityException
214      *          If a security manager has been installed and its {@link
215      *          SecurityManager#checkListen checkListen} method denies the
216      *          operation
217      *
218      * @since 1.7
219      */
220     public abstract DatagramChannel bind(SocketAddress local)
221         throws IOException;
222 
223     /**
224      * @throws  UnsupportedOperationException           {@inheritDoc}
225      * @throws  IllegalArgumentException                {@inheritDoc}
226      * @throws  ClosedChannelException                  {@inheritDoc}
227      * @throws  IOException                             {@inheritDoc}
228      *
229      * @since 1.7
230      */
231     public abstract &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name, T value)
232         throws IOException;
233 
234     /**
235      * Retrieves a datagram socket associated with this channel.
236      *
237      * @return  A datagram socket associated with this channel
238      */
239     public abstract DatagramSocket socket();
240 
241     /**
242      * Tells whether or not this channel&#39;s socket is connected.
243      *
244      * @return  {@code true} if, and only if, this channel&#39;s socket
245      *          is {@link #isOpen open} and connected
246      */
247     public abstract boolean isConnected();
248 
249     /**
250      * Connects this channel&#39;s socket.
251      *
252      * &lt;p&gt; The channel&#39;s socket is configured so that it only receives
253      * datagrams from, and sends datagrams to, the given remote &lt;i&gt;peer&lt;/i&gt;
254      * address.  Once connected, datagrams may not be received from or sent to
255      * any other address.  Datagrams in the channel&#39;s {@linkplain
256      * java.net.StandardSocketOptions#SO_RCVBUF socket receive buffer}, which
257      * have not been {@linkplain #receive(ByteBuffer) received} before invoking
258      * this method, may be discarded.  The channel&#39;s socket remains connected
259      * until it is explicitly disconnected or until it is closed.
260      *
261      * &lt;p&gt; This method performs exactly the same security checks as the {@link
262      * java.net.DatagramSocket#connect connect} method of the {@link
263      * java.net.DatagramSocket} class.  That is, if a security manager has been
264      * installed then this method verifies that its {@link
265      * java.lang.SecurityManager#checkAccept checkAccept} and {@link
266      * java.lang.SecurityManager#checkConnect checkConnect} methods permit
267      * datagrams to be received from and sent to, respectively, the given
268      * remote address. Once connected, no further security checks are performed
269      * for datagrams received from, or sent to, the given remote address. Care
270      * should be taken to ensure that a connected datagram channel is not shared
271      * with untrusted code.
272      *
273      * &lt;p&gt; This method may be invoked at any time.  If another thread has
274      * already initiated a read or write operation upon this channel, then an
275      * invocation of this method will block until any such operation is
276      * complete.  If this channel&#39;s socket is not bound then this method will
277      * first cause the socket to be bound to an address that is assigned
278      * automatically, as if invoking the {@link #bind bind} method with a
279      * parameter of {@code null}.  &lt;/p&gt;
280      *
281      * @param  remote
282      *         The remote address to which this channel is to be connected
283      *
284      * @return  This datagram channel
285      *
286      * @throws  AlreadyConnectedException
287      *          If this channel is already connected
288      *
289      * @throws  ClosedChannelException
290      *          If this channel is closed
291      *
292      * @throws  AsynchronousCloseException
293      *          If another thread closes this channel
294      *          while the connect operation is in progress
295      *
296      * @throws  ClosedByInterruptException
297      *          If another thread interrupts the current thread
298      *          while the connect operation is in progress, thereby
299      *          closing the channel and setting the current thread&#39;s
300      *          interrupt status
301      *
302      * @throws  UnresolvedAddressException
303      *          If the given remote address is not fully resolved
304      *
305      * @throws  UnsupportedAddressTypeException
306      *          If the type of the given remote address is not supported
307      *
308      * @throws  SecurityException
309      *          If a security manager has been installed and it does not
310      *          permit access to the given remote address, or if unbound,
311      *          the security manager {@link SecurityManager#checkListen checkListen}
312      *          method denies the operation
313      *
314      * @throws  IOException
315      *          If some other I/O error occurs
316      */
317     public abstract DatagramChannel connect(SocketAddress remote)
318         throws IOException;
319 
320     /**
321      * Disconnects this channel&#39;s socket.
322      *
323      * &lt;p&gt; The channel&#39;s socket is configured so that it can receive datagrams
324      * from, and sends datagrams to, any remote address so long as the security
325      * manager, if installed, permits it.
326      *
327      * &lt;p&gt; This method may be invoked at any time.  If another thread has
328      * already initiated a read or write operation upon this channel, then an
329      * invocation of this method will block until any such operation is
330      * complete.
331      *
332      * &lt;p&gt; If this channel&#39;s socket is not connected, or if the channel is
333      * closed, then invoking this method has no effect.  &lt;/p&gt;
334      *
335      * @apiNote If this method throws an IOException, the channel&#39;s socket
336      * may be left in an unspecified state. It is strongly recommended that
337      * the channel be closed when disconnect fails.
338      *
339      * @return  This datagram channel
340      *
341      * @throws  IOException
342      *          If some other I/O error occurs
343      */
344     public abstract DatagramChannel disconnect() throws IOException;
345 
346     /**
347      * Returns the remote address to which this channel&#39;s socket is connected.
348      *
349      * @return  The remote address; {@code null} if the channel&#39;s socket is not
350      *          connected
351      *
352      * @throws  ClosedChannelException
353      *          If the channel is closed
354      * @throws  IOException
355      *          If an I/O error occurs
356      *
357      * @since 1.7
358      */
359     public abstract SocketAddress getRemoteAddress() throws IOException;
360 
361     /**
362      * Receives a datagram via this channel.
363      *
364      * &lt;p&gt; If a datagram is immediately available, or if this channel is in
365      * blocking mode and one eventually becomes available, then the datagram is
366      * copied into the given byte buffer and its source address is returned.
367      * If this channel is in non-blocking mode and a datagram is not
368      * immediately available then this method immediately returns
369      * {@code null}.
370      *
371      * &lt;p&gt; The datagram is transferred into the given byte buffer starting at
372      * its current position, as if by a regular {@link
373      * ReadableByteChannel#read(java.nio.ByteBuffer) read} operation.  If there
374      * are fewer bytes remaining in the buffer than are required to hold the
375      * datagram then the remainder of the datagram is silently discarded.
376      *
377      * &lt;p&gt; This method performs exactly the same security checks as the {@link
378      * java.net.DatagramSocket#receive receive} method of the {@link
379      * java.net.DatagramSocket} class.  That is, if the socket is not connected
380      * to a specific remote address and a security manager has been installed
381      * then for each datagram received this method verifies that the source&#39;s
382      * address and port number are permitted by the security manager&#39;s {@link
383      * java.lang.SecurityManager#checkAccept checkAccept} method. Datagrams
384      * that are not permitted by the security manager are silently discarded.
385      * The overhead of this security check can be avoided by first connecting
386      * the socket via the {@link #connect connect} method.
387      *
388      * &lt;p&gt; This method may be invoked at any time.  If another thread has
389      * already initiated a read operation upon this channel, however, then an
390      * invocation of this method will block until the first operation is
391      * complete. If this channel&#39;s socket is not bound then this method will
392      * first cause the socket to be bound to an address that is assigned
393      * automatically, as if invoking the {@link #bind bind} method with a
394      * parameter of {@code null}. &lt;/p&gt;
395      *
396      * @param  dst
397      *         The buffer into which the datagram is to be transferred
398      *
399      * @return  The datagram&#39;s source address,
400      *          or {@code null} if this channel is in non-blocking mode
401      *          and no datagram was immediately available
402      *
403      * @throws  IllegalArgumentException
404      *          If the buffer is read-only
405      *
406      * @throws  ClosedChannelException
407      *          If this channel is closed
408      *
409      * @throws  AsynchronousCloseException
410      *          If another thread closes this channel
411      *          while the read operation is in progress
412      *
413      * @throws  ClosedByInterruptException
414      *          If another thread interrupts the current thread
415      *          while the read operation is in progress, thereby
416      *          closing the channel and setting the current thread&#39;s
417      *          interrupt status
418      *
419      * @throws  SecurityException
420      *          If unbound, and a security manager has been installed and
421      *          its {@link SecurityManager#checkListen checkListen} method
422      *          denies the operation
423      *
424      * @throws  IOException
425      *          If some other I/O error occurs
426      */
427     public abstract SocketAddress receive(ByteBuffer dst) throws IOException;
428 
429     /**
430      * Sends a datagram via this channel.
431      *
432      * &lt;p&gt; If this channel is in non-blocking mode and there is sufficient room
433      * in the underlying output buffer, or if this channel is in blocking mode
434      * and sufficient room becomes available, then the remaining bytes in the
435      * given buffer are transmitted as a single datagram to the given target
436      * address.
437      *
438      * &lt;p&gt; The datagram is transferred from the byte buffer as if by a regular
439      * {@link WritableByteChannel#write(java.nio.ByteBuffer) write} operation.
440      *
441      * &lt;p&gt; This method performs exactly the same security checks as the {@link
442      * java.net.DatagramSocket#send send} method of the {@link
443      * java.net.DatagramSocket} class.  That is, if the socket is not connected
444      * to a specific remote address and a security manager has been installed
445      * then for each datagram sent this method verifies that the target address
446      * and port number are permitted by the security manager&#39;s {@link
447      * java.lang.SecurityManager#checkConnect checkConnect} method.  The
448      * overhead of this security check can be avoided by first connecting the
449      * socket via the {@link #connect connect} method.
450      *
451      * &lt;p&gt; This method may be invoked at any time.  If another thread has
452      * already initiated a write operation upon this channel, however, then an
453      * invocation of this method will block until the first operation is
454      * complete. If this channel&#39;s socket is not bound then this method will
455      * first cause the socket to be bound to an address that is assigned
456      * automatically, as if by invoking the {@link #bind bind} method with a
457      * parameter of {@code null}. &lt;/p&gt;
458      *
459      * @param  src
460      *         The buffer containing the datagram to be sent
461      *
462      * @param  target
463      *         The address to which the datagram is to be sent
464      *
465      * @return   The number of bytes sent, which will be either the number
466      *           of bytes that were remaining in the source buffer when this
467      *           method was invoked or, if this channel is non-blocking, may be
468      *           zero if there was insufficient room for the datagram in the
469      *           underlying output buffer
470      *
471      * @throws  AlreadyConnectedException
472      *          If this channel is connected to a different address
473      *          from that specified by {@code target}
474      *
475      * @throws  ClosedChannelException
476      *          If this channel is closed
477      *
478      * @throws  AsynchronousCloseException
479      *          If another thread closes this channel
480      *          while the read operation is in progress
481      *
482      * @throws  ClosedByInterruptException
483      *          If another thread interrupts the current thread
484      *          while the read operation is in progress, thereby
485      *          closing the channel and setting the current thread&#39;s
486      *          interrupt status
487      *
488      * @throws  UnresolvedAddressException
489      *          If the given remote address is not fully resolved
490      *
491      * @throws  UnsupportedAddressTypeException
492      *          If the type of the given remote address is not supported
493      *
494      * @throws  SecurityException
495      *          If a security manager has been installed and it does not permit
496      *          datagrams to be sent to the given address, or if unbound, and
497      *          the security manager&#39;s {@link SecurityManager#checkListen checkListen}
498      *          method denies the operation
499      *
500      * @throws  IOException
501      *          If some other I/O error occurs
502      */
503     public abstract int send(ByteBuffer src, SocketAddress target)
504         throws IOException;
505 
506 
507     // -- ByteChannel operations --
508 
509     /**
510      * Reads a datagram from this channel.
511      *
512      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
513      * connected, and it only accepts datagrams from the socket&#39;s peer.  If
514      * there are more bytes in the datagram than remain in the given buffer
515      * then the remainder of the datagram is silently discarded.  Otherwise
516      * this method behaves exactly as specified in the {@link
517      * ReadableByteChannel} interface.  &lt;/p&gt;
518      *
519      * @throws  NotYetConnectedException
520      *          If this channel&#39;s socket is not connected
521      */
522     public abstract int read(ByteBuffer dst) throws IOException;
523 
524     /**
525      * Reads a datagram from this channel.
526      *
527      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
528      * connected, and it only accepts datagrams from the socket&#39;s peer.  If
529      * there are more bytes in the datagram than remain in the given buffers
530      * then the remainder of the datagram is silently discarded.  Otherwise
531      * this method behaves exactly as specified in the {@link
532      * ScatteringByteChannel} interface.  &lt;/p&gt;
533      *
534      * @throws  NotYetConnectedException
535      *          If this channel&#39;s socket is not connected
536      */
537     public abstract long read(ByteBuffer[] dsts, int offset, int length)
538         throws IOException;
539 
540     /**
541      * Reads a datagram from this channel.
542      *
543      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
544      * connected, and it only accepts datagrams from the socket&#39;s peer.  If
545      * there are more bytes in the datagram than remain in the given buffers
546      * then the remainder of the datagram is silently discarded.  Otherwise
547      * this method behaves exactly as specified in the {@link
548      * ScatteringByteChannel} interface.  &lt;/p&gt;
549      *
550      * @throws  NotYetConnectedException
551      *          If this channel&#39;s socket is not connected
552      */
553     public final long read(ByteBuffer[] dsts) throws IOException {
554         return read(dsts, 0, dsts.length);
555     }
556 
557     /**
558      * Writes a datagram to this channel.
559      *
560      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
561      * connected, in which case it sends datagrams directly to the socket&#39;s
562      * peer.  Otherwise it behaves exactly as specified in the {@link
563      * WritableByteChannel} interface.  &lt;/p&gt;
564      *
565      * @throws  NotYetConnectedException
566      *          If this channel&#39;s socket is not connected
567      */
568     public abstract int write(ByteBuffer src) throws IOException;
569 
570     /**
571      * Writes a datagram to this channel.
572      *
573      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
574      * connected, in which case it sends datagrams directly to the socket&#39;s
575      * peer.  Otherwise it behaves exactly as specified in the {@link
576      * GatheringByteChannel} interface.  &lt;/p&gt;
577      *
578      * @return   The number of bytes sent, which will be either the number
579      *           of bytes that were remaining in the source buffer when this
580      *           method was invoked or, if this channel is non-blocking, may be
581      *           zero if there was insufficient room for the datagram in the
582      *           underlying output buffer
583      *
584      * @throws  NotYetConnectedException
585      *          If this channel&#39;s socket is not connected
586      */
587     public abstract long write(ByteBuffer[] srcs, int offset, int length)
588         throws IOException;
589 
590     /**
591      * Writes a datagram to this channel.
592      *
593      * &lt;p&gt; This method may only be invoked if this channel&#39;s socket is
594      * connected, in which case it sends datagrams directly to the socket&#39;s
595      * peer.  Otherwise it behaves exactly as specified in the {@link
596      * GatheringByteChannel} interface.  &lt;/p&gt;
597      *
598      * @return   The number of bytes sent, which will be either the number
599      *           of bytes that were remaining in the source buffer when this
600      *           method was invoked or, if this channel is non-blocking, may be
601      *           zero if there was insufficient room for the datagram in the
602      *           underlying output buffer
603      *
604      * @throws  NotYetConnectedException
605      *          If this channel&#39;s socket is not connected
606      */
607     public final long write(ByteBuffer[] srcs) throws IOException {
608         return write(srcs, 0, srcs.length);
609     }
610 
611     /**
612      * {@inheritDoc}
613      * &lt;p&gt;
614      * If there is a security manager set, its {@code checkConnect} method is
615      * called with the local address and {@code -1} as its arguments to see
616      * if the operation is allowed. If the operation is not allowed,
617      * a {@code SocketAddress} representing the
618      * {@link java.net.InetAddress#getLoopbackAddress loopback} address and the
619      * local port of the channel&#39;s socket is returned.
620      *
621      * @return  The {@code SocketAddress} that the socket is bound to, or the
622      *          {@code SocketAddress} representing the loopback address if
623      *          denied by the security manager, or {@code null} if the
624      *          channel&#39;s socket is not bound
625      *
626      * @throws  ClosedChannelException     {@inheritDoc}
627      * @throws  IOException                {@inheritDoc}
628      */
629     @Override
630     public abstract SocketAddress getLocalAddress() throws IOException;
631 
632 }
    </pre>
  </body>
</html>
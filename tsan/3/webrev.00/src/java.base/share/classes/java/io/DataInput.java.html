<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/io/DataInput.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.io;
 27 
 28 /**
 29  * The {@code DataInput} interface provides
 30  * for reading bytes from a binary stream and
 31  * reconstructing from them data in any of
 32  * the Java primitive types. There is also
 33  * a
 34  * facility for reconstructing a {@code String}
 35  * from data in
 36  * &lt;a href=&quot;#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
 37  * format.
 38  * &lt;p&gt;
 39  * It is generally true of all the reading
 40  * routines in this interface that if end of
 41  * file is reached before the desired number
 42  * of bytes has been read, an {@code EOFException}
 43  * (which is a kind of {@code IOException})
 44  * is thrown. If any byte cannot be read for
 45  * any reason other than end of file, an {@code IOException}
 46  * other than {@code EOFException} is
 47  * thrown. In particular, an {@code IOException}
 48  * may be thrown if the input stream has been
 49  * closed.
 50  *
 51  * &lt;h2&gt;&lt;a id=&quot;modified-utf-8&quot;&gt;Modified UTF-8&lt;/a&gt;&lt;/h2&gt;
 52  * &lt;p&gt;
 53  * Implementations of the DataInput and DataOutput interfaces represent
 54  * Unicode strings in a format that is a slight modification of UTF-8.
 55  * (For information regarding the standard UTF-8 format, see section
 56  * &lt;i&gt;3.9 Unicode Encoding Forms&lt;/i&gt; of &lt;i&gt;The Unicode Standard, Version
 57  * 4.0&lt;/i&gt;)
 58  *
 59  * &lt;ul&gt;
 60  * &lt;li&gt;Characters in the range {@code &#39;\u005Cu0001&#39;} to
 61  *         {@code &#39;\u005Cu007F&#39;} are represented by a single byte.
 62  * &lt;li&gt;The null character {@code &#39;\u005Cu0000&#39;} and characters
 63  *         in the range {@code &#39;\u005Cu0080&#39;} to {@code &#39;\u005Cu07FF&#39;} are
 64  *         represented by a pair of bytes.
 65  * &lt;li&gt;Characters in the range {@code &#39;\u005Cu0800&#39;}
 66  *         to {@code &#39;\u005CuFFFF&#39;} are represented by three bytes.
 67  * &lt;/ul&gt;
 68  *
 69  *   &lt;table class=&quot;plain&quot; style=&quot;margin-left:2em;&quot;&gt;
 70  *     &lt;caption&gt;Encoding of UTF-8 values&lt;/caption&gt;
 71  *     &lt;thead&gt;
 72  *     &lt;tr&gt;
 73  *       &lt;th scope=&quot;col&quot; rowspan=&quot;2&quot;&gt;Value&lt;/th&gt;
 74  *       &lt;th scope=&quot;col&quot; rowspan=&quot;2&quot;&gt;Byte&lt;/th&gt;
 75  *       &lt;th scope=&quot;col&quot; colspan=&quot;8&quot; id=&quot;bit_a&quot;&gt;Bit Values&lt;/th&gt;
 76  *     &lt;/tr&gt;
 77  *     &lt;tr&gt;
 78  *       &lt;!-- Value --&gt;
 79  *       &lt;!-- Byte --&gt;
 80  *       &lt;th scope=&quot;col&quot; style=&quot;width:3em&quot;&gt; 7 &lt;/th&gt;
 81  *       &lt;th scope=&quot;col&quot; style=&quot;width:3em&quot;&gt; 6 &lt;/th&gt;
 82  *       &lt;th scope=&quot;col&quot; style=&quot;width:3em&quot;&gt; 5 &lt;/th&gt;
 83  *       &lt;th scope=&quot;col&quot; style=&quot;width:3em&quot;&gt; 4 &lt;/th&gt;
 84  *       &lt;th scope=&quot;col&quot; style=&quot;width:3em&quot;&gt; 3 &lt;/th&gt;
 85  *       &lt;th scope=&quot;col&quot; style=&quot;width:3em&quot;&gt; 2 &lt;/th&gt;
 86  *       &lt;th scope=&quot;col&quot; style=&quot;width:3em&quot;&gt; 1 &lt;/th&gt;
 87  *       &lt;th scope=&quot;col&quot; style=&quot;width:3em&quot;&gt; 0 &lt;/th&gt;
 88  *     &lt;/thead&gt;
 89  *     &lt;tbody&gt;
 90  *     &lt;tr&gt;
 91  *       &lt;th scope=&quot;row&quot; style=&quot;text-align:left; font-weight:normal&quot;&gt;
 92  *         {@code \u005Cu0001} to {@code \u005Cu007F} &lt;/th&gt;
 93  *       &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:center&quot;&gt; 1 &lt;/th&gt;
 94  *       &lt;td style=&quot;text-align:center&quot;&gt;0
 95  *       &lt;td colspan=&quot;7&quot; style=&quot;text-align:right; padding-right:6em&quot;&gt;bits 6-0
 96  *     &lt;/tr&gt;
 97  *     &lt;tr&gt;
 98  *       &lt;th scope=&quot;row&quot; rowspan=&quot;2&quot; style=&quot;text-align:left; font-weight:normal&quot;&gt;
 99  *           {@code \u005Cu0000},&lt;br&gt;
100  *           {@code \u005Cu0080} to {@code \u005Cu07FF} &lt;/th&gt;
101  *       &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:center&quot;&gt; 1 &lt;/th&gt;
102  *       &lt;td style=&quot;text-align:center&quot;&gt;1
103  *       &lt;td style=&quot;text-align:center&quot;&gt;1
104  *       &lt;td style=&quot;text-align:center&quot;&gt;0
105  *       &lt;td colspan=&quot;5&quot; style=&quot;text-align:right; padding-right:6em&quot;&gt;bits 10-6
106  *     &lt;/tr&gt;
107  *     &lt;tr&gt;
108  *       &lt;!-- (value) --&gt;
109  *       &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:center&quot;&gt; 2 &lt;/th&gt;
110  *       &lt;td style=&quot;text-align:center&quot;&gt;1
111  *       &lt;td style=&quot;text-align:center&quot;&gt;0
112  *       &lt;td colspan=&quot;6&quot; style=&quot;text-align:right; padding-right:6em&quot;&gt;bits 5-0
113  *     &lt;/tr&gt;
114  *     &lt;tr&gt;
115  *       &lt;th scope=&quot;row&quot; rowspan=&quot;3&quot; style=&quot;text-align:left; font-weight:normal&quot;&gt;
116  *         {@code \u005Cu0800} to {@code \u005CuFFFF} &lt;/th&gt;
117  *       &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:center&quot;&gt; 1 &lt;/th&gt;
118  *       &lt;td style=&quot;text-align:center&quot;&gt;1
119  *       &lt;td style=&quot;text-align:center&quot;&gt;1
120  *       &lt;td style=&quot;text-align:center&quot;&gt;1
121  *       &lt;td style=&quot;text-align:center&quot;&gt;0
122  *       &lt;td colspan=&quot;4&quot; style=&quot;text-align:right; padding-right:6em&quot;&gt;bits 15-12
123  *     &lt;/tr&gt;
124  *     &lt;tr&gt;
125  *       &lt;!-- (value) --&gt;
126  *       &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:center&quot;&gt; 2 &lt;/th&gt;
127  *       &lt;td style=&quot;text-align:center&quot;&gt;1
128  *       &lt;td style=&quot;text-align:center&quot;&gt;0
129  *       &lt;td colspan=&quot;6&quot; style=&quot;text-align:right; padding-right:6em&quot;&gt;bits 11-6
130  *     &lt;/tr&gt;
131  *     &lt;tr&gt;
132  *       &lt;!-- (value) --&gt;
133  *       &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:center&quot;&gt; 3 &lt;/th&gt;
134  *       &lt;td style=&quot;text-align:center&quot;&gt;1
135  *       &lt;td style=&quot;text-align:center&quot;&gt;0
136  *       &lt;td colspan=&quot;6&quot; style=&quot;text-align:right; padding-right:6em&quot;&gt;bits 5-0
137  *     &lt;/tr&gt;
138  *     &lt;/tbody&gt;
139  *   &lt;/table&gt;
140  *
141  * &lt;p&gt;
142  * The differences between this format and the
143  * standard UTF-8 format are the following:
144  * &lt;ul&gt;
145  * &lt;li&gt;The null byte {@code &#39;\u005Cu0000&#39;} is encoded in 2-byte format
146  *     rather than 1-byte, so that the encoded strings never have
147  *     embedded nulls.
148  * &lt;li&gt;Only the 1-byte, 2-byte, and 3-byte formats are used.
149  * &lt;li&gt;&lt;a href=&quot;../lang/Character.html#unicode&quot;&gt;Supplementary characters&lt;/a&gt;
150  *     are represented in the form of surrogate pairs.
151  * &lt;/ul&gt;
152  * @author  Frank Yellin
153  * @see     java.io.DataInputStream
154  * @see     java.io.DataOutput
155  * @since   1.0
156  */
157 public interface DataInput {
158     /**
159      * Reads some bytes from an input
160      * stream and stores them into the buffer
161      * array {@code b}. The number of bytes
162      * read is equal
163      * to the length of {@code b}.
164      * &lt;p&gt;
165      * This method blocks until one of the
166      * following conditions occurs:
167      * &lt;ul&gt;
168      * &lt;li&gt;{@code b.length}
169      * bytes of input data are available, in which
170      * case a normal return is made.
171      *
172      * &lt;li&gt;End of
173      * file is detected, in which case an {@code EOFException}
174      * is thrown.
175      *
176      * &lt;li&gt;An I/O error occurs, in
177      * which case an {@code IOException} other
178      * than {@code EOFException} is thrown.
179      * &lt;/ul&gt;
180      * &lt;p&gt;
181      * If {@code b} is {@code null},
182      * a {@code NullPointerException} is thrown.
183      * If {@code b.length} is zero, then
184      * no bytes are read. Otherwise, the first
185      * byte read is stored into element {@code b[0]},
186      * the next one into {@code b[1]}, and
187      * so on.
188      * If an exception is thrown from
189      * this method, then it may be that some but
190      * not all bytes of {@code b} have been
191      * updated with data from the input stream.
192      *
193      * @param   b   the buffer into which the data is read.
194      * @throws  NullPointerException if {@code b} is {@code null}.
195      * @throws  EOFException  if this stream reaches the end before reading
196      *          all the bytes.
197      * @throws  IOException   if an I/O error occurs.
198      */
199     void readFully(byte b[]) throws IOException;
200 
201     /**
202      *
203      * Reads {@code len}
204      * bytes from
205      * an input stream.
206      * &lt;p&gt;
207      * This method
208      * blocks until one of the following conditions
209      * occurs:
210      * &lt;ul&gt;
211      * &lt;li&gt;{@code len} bytes
212      * of input data are available, in which case
213      * a normal return is made.
214      *
215      * &lt;li&gt;End of file
216      * is detected, in which case an {@code EOFException}
217      * is thrown.
218      *
219      * &lt;li&gt;An I/O error occurs, in
220      * which case an {@code IOException} other
221      * than {@code EOFException} is thrown.
222      * &lt;/ul&gt;
223      * &lt;p&gt;
224      * If {@code b} is {@code null},
225      * a {@code NullPointerException} is thrown.
226      * If {@code off} is negative, or {@code len}
227      * is negative, or {@code off+len} is
228      * greater than the length of the array {@code b},
229      * then an {@code IndexOutOfBoundsException}
230      * is thrown.
231      * If {@code len} is zero,
232      * then no bytes are read. Otherwise, the first
233      * byte read is stored into element {@code b[off]},
234      * the next one into {@code b[off+1]},
235      * and so on. The number of bytes read is,
236      * at most, equal to {@code len}.
237      *
238      * @param   b    the buffer into which the data is read.
239      * @param   off  an int specifying the offset in the data array {@code b}.
240      * @param   len  an int specifying the number of bytes to read.
241      * @throws  NullPointerException if {@code b} is {@code null}.
242      * @throws  IndexOutOfBoundsException if {@code off} is negative,
243      *          {@code len} is negative, or {@code len} is greater than
244      *          {@code b.length - off}.
245      * @throws  EOFException  if this stream reaches the end before reading
246      *          all the bytes.
247      * @throws  IOException   if an I/O error occurs.
248      */
249     void readFully(byte b[], int off, int len) throws IOException;
250 
251     /**
252      * Makes an attempt to skip over
253      * {@code n} bytes
254      * of data from the input
255      * stream, discarding the skipped bytes. However,
256      * it may skip
257      * over some smaller number of
258      * bytes, possibly zero. This may result from
259      * any of a
260      * number of conditions; reaching
261      * end of file before {@code n} bytes
262      * have been skipped is
263      * only one possibility.
264      * This method never throws an {@code EOFException}.
265      * The actual
266      * number of bytes skipped is returned.
267      *
268      * @param      n   the number of bytes to be skipped.
269      * @return     the number of bytes actually skipped.
270      * @throws     IOException   if an I/O error occurs.
271      */
272     int skipBytes(int n) throws IOException;
273 
274     /**
275      * Reads one input byte and returns
276      * {@code true} if that byte is nonzero,
277      * {@code false} if that byte is zero.
278      * This method is suitable for reading
279      * the byte written by the {@code writeBoolean}
280      * method of interface {@code DataOutput}.
281      *
282      * @return     the {@code boolean} value read.
283      * @throws     EOFException  if this stream reaches the end before reading
284      *               all the bytes.
285      * @throws     IOException   if an I/O error occurs.
286      */
287     boolean readBoolean() throws IOException;
288 
289     /**
290      * Reads and returns one input byte.
291      * The byte is treated as a signed value in
292      * the range {@code -128} through {@code 127},
293      * inclusive.
294      * This method is suitable for
295      * reading the byte written by the {@code writeByte}
296      * method of interface {@code DataOutput}.
297      *
298      * @return     the 8-bit value read.
299      * @throws     EOFException  if this stream reaches the end before reading
300      *               all the bytes.
301      * @throws     IOException   if an I/O error occurs.
302      */
303     byte readByte() throws IOException;
304 
305     /**
306      * Reads one input byte, zero-extends
307      * it to type {@code int}, and returns
308      * the result, which is therefore in the range
309      * {@code 0}
310      * through {@code 255}.
311      * This method is suitable for reading
312      * the byte written by the {@code writeByte}
313      * method of interface {@code DataOutput}
314      * if the argument to {@code writeByte}
315      * was intended to be a value in the range
316      * {@code 0} through {@code 255}.
317      *
318      * @return     the unsigned 8-bit value read.
319      * @throws     EOFException  if this stream reaches the end before reading
320      *               all the bytes.
321      * @throws     IOException   if an I/O error occurs.
322      */
323     int readUnsignedByte() throws IOException;
324 
325     /**
326      * Reads two input bytes and returns
327      * a {@code short} value. Let {@code a}
328      * be the first byte read and {@code b}
329      * be the second byte. The value
330      * returned
331      * is:
332      * &lt;pre&gt;{@code (short)((a &lt;&lt; 8) | (b &amp; 0xff))
333      * }&lt;/pre&gt;
334      * This method
335      * is suitable for reading the bytes written
336      * by the {@code writeShort} method of
337      * interface {@code DataOutput}.
338      *
339      * @return     the 16-bit value read.
340      * @throws     EOFException  if this stream reaches the end before reading
341      *               all the bytes.
342      * @throws     IOException   if an I/O error occurs.
343      */
344     short readShort() throws IOException;
345 
346     /**
347      * Reads two input bytes and returns
348      * an {@code int} value in the range {@code 0}
349      * through {@code 65535}. Let {@code a}
350      * be the first byte read and
351      * {@code b}
352      * be the second byte. The value returned is:
353      * &lt;pre&gt;{@code (((a &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
354      * }&lt;/pre&gt;
355      * This method is suitable for reading the bytes
356      * written by the {@code writeShort} method
357      * of interface {@code DataOutput}  if
358      * the argument to {@code writeShort}
359      * was intended to be a value in the range
360      * {@code 0} through {@code 65535}.
361      *
362      * @return     the unsigned 16-bit value read.
363      * @throws     EOFException  if this stream reaches the end before reading
364      *               all the bytes.
365      * @throws     IOException   if an I/O error occurs.
366      */
367     int readUnsignedShort() throws IOException;
368 
369     /**
370      * Reads two input bytes and returns a {@code char} value.
371      * Let {@code a}
372      * be the first byte read and {@code b}
373      * be the second byte. The value
374      * returned is:
375      * &lt;pre&gt;{@code (char)((a &lt;&lt; 8) | (b &amp; 0xff))
376      * }&lt;/pre&gt;
377      * This method
378      * is suitable for reading bytes written by
379      * the {@code writeChar} method of interface
380      * {@code DataOutput}.
381      *
382      * @return     the {@code char} value read.
383      * @throws     EOFException  if this stream reaches the end before reading
384      *               all the bytes.
385      * @throws     IOException   if an I/O error occurs.
386      */
387     char readChar() throws IOException;
388 
389     /**
390      * Reads four input bytes and returns an
391      * {@code int} value. Let {@code a-d}
392      * be the first through fourth bytes read. The value returned is:
393      * &lt;pre&gt;{@code
394      * (((a &amp; 0xff) &lt;&lt; 24) | ((b &amp; 0xff) &lt;&lt; 16) |
395      *  ((c &amp; 0xff) &lt;&lt;  8) | (d &amp; 0xff))
396      * }&lt;/pre&gt;
397      * This method is suitable
398      * for reading bytes written by the {@code writeInt}
399      * method of interface {@code DataOutput}.
400      *
401      * @return     the {@code int} value read.
402      * @throws     EOFException  if this stream reaches the end before reading
403      *               all the bytes.
404      * @throws     IOException   if an I/O error occurs.
405      */
406     int readInt() throws IOException;
407 
408     /**
409      * Reads eight input bytes and returns
410      * a {@code long} value. Let {@code a-h}
411      * be the first through eighth bytes read.
412      * The value returned is:
413      * &lt;pre&gt;{@code
414      * (((long)(a &amp; 0xff) &lt;&lt; 56) |
415      *  ((long)(b &amp; 0xff) &lt;&lt; 48) |
416      *  ((long)(c &amp; 0xff) &lt;&lt; 40) |
417      *  ((long)(d &amp; 0xff) &lt;&lt; 32) |
418      *  ((long)(e &amp; 0xff) &lt;&lt; 24) |
419      *  ((long)(f &amp; 0xff) &lt;&lt; 16) |
420      *  ((long)(g &amp; 0xff) &lt;&lt;  8) |
421      *  ((long)(h &amp; 0xff)))
422      * }&lt;/pre&gt;
423      * &lt;p&gt;
424      * This method is suitable
425      * for reading bytes written by the {@code writeLong}
426      * method of interface {@code DataOutput}.
427      *
428      * @return     the {@code long} value read.
429      * @throws     EOFException  if this stream reaches the end before reading
430      *               all the bytes.
431      * @throws     IOException   if an I/O error occurs.
432      */
433     long readLong() throws IOException;
434 
435     /**
436      * Reads four input bytes and returns
437      * a {@code float} value. It does this
438      * by first constructing an {@code int}
439      * value in exactly the manner
440      * of the {@code readInt}
441      * method, then converting this {@code int}
442      * value to a {@code float} in
443      * exactly the manner of the method {@code Float.intBitsToFloat}.
444      * This method is suitable for reading
445      * bytes written by the {@code writeFloat}
446      * method of interface {@code DataOutput}.
447      *
448      * @return     the {@code float} value read.
449      * @throws     EOFException  if this stream reaches the end before reading
450      *               all the bytes.
451      * @throws     IOException   if an I/O error occurs.
452      */
453     float readFloat() throws IOException;
454 
455     /**
456      * Reads eight input bytes and returns
457      * a {@code double} value. It does this
458      * by first constructing a {@code long}
459      * value in exactly the manner
460      * of the {@code readLong}
461      * method, then converting this {@code long}
462      * value to a {@code double} in exactly
463      * the manner of the method {@code Double.longBitsToDouble}.
464      * This method is suitable for reading
465      * bytes written by the {@code writeDouble}
466      * method of interface {@code DataOutput}.
467      *
468      * @return     the {@code double} value read.
469      * @throws     EOFException  if this stream reaches the end before reading
470      *               all the bytes.
471      * @throws     IOException   if an I/O error occurs.
472      */
473     double readDouble() throws IOException;
474 
475     /**
476      * Reads the next line of text from the input stream.
477      * It reads successive bytes, converting
478      * each byte separately into a character,
479      * until it encounters a line terminator or
480      * end of
481      * file; the characters read are then
482      * returned as a {@code String}. Note
483      * that because this
484      * method processes bytes,
485      * it does not support input of the full Unicode
486      * character set.
487      * &lt;p&gt;
488      * If end of file is encountered
489      * before even one byte can be read, then {@code null}
490      * is returned. Otherwise, each byte that is
491      * read is converted to type {@code char}
492      * by zero-extension. If the character {@code &#39;\n&#39;}
493      * is encountered, it is discarded and reading
494      * ceases. If the character {@code &#39;\r&#39;}
495      * is encountered, it is discarded and, if
496      * the following byte converts &amp;#32;to the
497      * character {@code &#39;\n&#39;}, then that is
498      * discarded also; reading then ceases. If
499      * end of file is encountered before either
500      * of the characters {@code &#39;\n&#39;} and
501      * {@code &#39;\r&#39;} is encountered, reading
502      * ceases. Once reading has ceased, a {@code String}
503      * is returned that contains all the characters
504      * read and not discarded, taken in order.
505      * Note that every character in this string
506      * will have a value less than {@code \u005Cu0100},
507      * that is, {@code (char)256}.
508      *
509      * @return the next line of text from the input stream,
510      *         or {@code null} if the end of file is
511      *         encountered before a byte can be read.
512      * @throws IOException  if an I/O error occurs.
513      */
514     String readLine() throws IOException;
515 
516     /**
517      * Reads in a string that has been encoded using a
518      * &lt;a href=&quot;#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
519      * format.
520      * The general contract of {@code readUTF}
521      * is that it reads a representation of a Unicode
522      * character string encoded in modified
523      * UTF-8 format; this string of characters
524      * is then returned as a {@code String}.
525      * &lt;p&gt;
526      * First, two bytes are read and used to
527      * construct an unsigned 16-bit integer in
528      * exactly the manner of the {@code readUnsignedShort}
529      * method . This integer value is called the
530      * &lt;i&gt;UTF length&lt;/i&gt; and specifies the number
531      * of additional bytes to be read. These bytes
532      * are then converted to characters by considering
533      * them in groups. The length of each group
534      * is computed from the value of the first
535      * byte of the group. The byte following a
536      * group, if any, is the first byte of the
537      * next group.
538      * &lt;p&gt;
539      * If the first byte of a group
540      * matches the bit pattern {@code 0xxxxxxx}
541      * (where {@code x} means &quot;may be {@code 0}
542      * or {@code 1}&quot;), then the group consists
543      * of just that byte. The byte is zero-extended
544      * to form a character.
545      * &lt;p&gt;
546      * If the first byte
547      * of a group matches the bit pattern {@code 110xxxxx},
548      * then the group consists of that byte {@code a}
549      * and a second byte {@code b}. If there
550      * is no byte {@code b} (because byte
551      * {@code a} was the last of the bytes
552      * to be read), or if byte {@code b} does
553      * not match the bit pattern {@code 10xxxxxx},
554      * then a {@code UTFDataFormatException}
555      * is thrown. Otherwise, the group is converted
556      * to the character:
557      * &lt;pre&gt;{@code (char)(((a &amp; 0x1F) &lt;&lt; 6) | (b &amp; 0x3F))
558      * }&lt;/pre&gt;
559      * If the first byte of a group
560      * matches the bit pattern {@code 1110xxxx},
561      * then the group consists of that byte {@code a}
562      * and two more bytes {@code b} and {@code c}.
563      * If there is no byte {@code c} (because
564      * byte {@code a} was one of the last
565      * two of the bytes to be read), or either
566      * byte {@code b} or byte {@code c}
567      * does not match the bit pattern {@code 10xxxxxx},
568      * then a {@code UTFDataFormatException}
569      * is thrown. Otherwise, the group is converted
570      * to the character:
571      * &lt;pre&gt;{@code
572      * (char)(((a &amp; 0x0F) &lt;&lt; 12) | ((b &amp; 0x3F) &lt;&lt; 6) | (c &amp; 0x3F))
573      * }&lt;/pre&gt;
574      * If the first byte of a group matches the
575      * pattern {@code 1111xxxx} or the pattern
576      * {@code 10xxxxxx}, then a {@code UTFDataFormatException}
577      * is thrown.
578      * &lt;p&gt;
579      * If end of file is encountered
580      * at any time during this entire process,
581      * then an {@code EOFException} is thrown.
582      * &lt;p&gt;
583      * After every group has been converted to
584      * a character by this process, the characters
585      * are gathered, in the same order in which
586      * their corresponding groups were read from
587      * the input stream, to form a {@code String},
588      * which is returned.
589      * &lt;p&gt;
590      * The {@code writeUTF}
591      * method of interface {@code DataOutput}
592      * may be used to write data that is suitable
593      * for reading by this method.
594      * @return     a Unicode string.
595      * @throws     EOFException            if this stream reaches the end
596      *               before reading all the bytes.
597      * @throws     IOException             if an I/O error occurs.
598      * @throws     UTFDataFormatException  if the bytes do not represent a
599      *               valid modified UTF-8 encoding of a string.
600      */
601     String readUTF() throws IOException;
602 }
    </pre>
  </body>
</html>
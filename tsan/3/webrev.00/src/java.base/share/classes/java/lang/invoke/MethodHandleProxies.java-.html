<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import java.lang.reflect.*;
 29 import java.security.AccessController;
 30 import java.security.PrivilegedAction;
 31 import sun.invoke.WrapperInstance;
 32 import java.util.ArrayList;
 33 import java.util.concurrent.ConcurrentHashMap;
 34 
 35 import jdk.internal.reflect.CallerSensitive;
 36 import jdk.internal.reflect.Reflection;
 37 import sun.reflect.misc.ReflectUtil;
 38 import static java.lang.invoke.MethodHandleStatics.*;
 39 
 40 /**
 41  * This class consists exclusively of static methods that help adapt
 42  * method handles to other JVM types, such as interfaces.
 43  *
 44  * @since 1.7
 45  */
 46 public class MethodHandleProxies {
 47 
 48     private MethodHandleProxies() { }  // do not instantiate
 49 
 50     /**
 51      * Produces an instance of the given single-method interface which redirects
 52      * its calls to the given method handle.
 53      * &lt;p&gt;
 54      * A single-method interface is an interface which declares a uniquely named method.
 55      * When determining the uniquely named method of a single-method interface,
 56      * the public {@code Object} methods ({@code toString}, {@code equals}, {@code hashCode})
 57      * are disregarded as are any default (non-abstract) methods.
 58      * For example, {@link java.util.Comparator} is a single-method interface,
 59      * even though it re-declares the {@code Object.equals} method and also
 60      * declares default methods, such as {@code Comparator.reverse}.
 61      * &lt;p&gt;
 62      * The interface must be public.  No additional access checks are performed.
 63      * &lt;p&gt;
 64      * The resulting instance of the required type will respond to
 65      * invocation of the type&#39;s uniquely named method by calling
 66      * the given target on the incoming arguments,
 67      * and returning or throwing whatever the target
 68      * returns or throws.  The invocation will be as if by
 69      * {@code target.invoke}.
 70      * The target&#39;s type will be checked before the
 71      * instance is created, as if by a call to {@code asType},
 72      * which may result in a {@code WrongMethodTypeException}.
 73      * &lt;p&gt;
 74      * The uniquely named method is allowed to be multiply declared,
 75      * with distinct type descriptors.  (E.g., it can be overloaded,
 76      * or can possess bridge methods.)  All such declarations are
 77      * connected directly to the target method handle.
 78      * Argument and return types are adjusted by {@code asType}
 79      * for each individual declaration.
 80      * &lt;p&gt;
 81      * The wrapper instance will implement the requested interface
 82      * and its super-types, but no other single-method interfaces.
 83      * This means that the instance will not unexpectedly
 84      * pass an {@code instanceof} test for any unrequested type.
 85      * &lt;p style=&quot;font-size:smaller;&quot;&gt;
 86      * &lt;em&gt;Implementation Note:&lt;/em&gt;
 87      * Therefore, each instance must implement a unique single-method interface.
 88      * Implementations may not bundle together
 89      * multiple single-method interfaces onto single implementation classes
 90      * in the style of {@link java.awt.AWTEventMulticaster}.
 91      * &lt;p&gt;
 92      * The method handle may throw an &lt;em&gt;undeclared exception&lt;/em&gt;,
 93      * which means any checked exception (or other checked throwable)
 94      * not declared by the requested type&#39;s single abstract method.
 95      * If this happens, the throwable will be wrapped in an instance of
 96      * {@link java.lang.reflect.UndeclaredThrowableException UndeclaredThrowableException}
 97      * and thrown in that wrapped form.
 98      * &lt;p&gt;
 99      * Like {@link java.lang.Integer#valueOf Integer.valueOf},
100      * {@code asInterfaceInstance} is a factory method whose results are defined
101      * by their behavior.
102      * It is not guaranteed to return a new instance for every call.
103      * &lt;p&gt;
104      * Because of the possibility of {@linkplain java.lang.reflect.Method#isBridge bridge methods}
105      * and other corner cases, the interface may also have several abstract methods
106      * with the same name but having distinct descriptors (types of returns and parameters).
107      * In this case, all the methods are bound in common to the one given target.
108      * The type check and effective {@code asType} conversion is applied to each
109      * method type descriptor, and all abstract methods are bound to the target in common.
110      * Beyond this type check, no further checks are made to determine that the
111      * abstract methods are related in any way.
112      * &lt;p&gt;
113      * Future versions of this API may accept additional types,
114      * such as abstract classes with single abstract methods.
115      * Future versions of this API may also equip wrapper instances
116      * with one or more additional public &quot;marker&quot; interfaces.
117      * &lt;p&gt;
118      * If a security manager is installed, this method is caller sensitive.
119      * During any invocation of the target method handle via the returned wrapper,
120      * the original creator of the wrapper (the caller) will be visible
121      * to context checks requested by the security manager.
122      *
123      * @param &lt;T&gt; the desired type of the wrapper, a single-method interface
124      * @param intfc a class object representing {@code T}
125      * @param target the method handle to invoke from the wrapper
126      * @return a correctly-typed wrapper for the given target
127      * @throws NullPointerException if either argument is null
128      * @throws IllegalArgumentException if the {@code intfc} is not a
129      *         valid argument to this method
130      * @throws WrongMethodTypeException if the target cannot
131      *         be converted to the type required by the requested interface
132      */
133     // Other notes to implementors:
134     // &lt;p&gt;
135     // No stable mapping is promised between the single-method interface and
136     // the implementation class C.  Over time, several implementation
137     // classes might be used for the same type.
138     // &lt;p&gt;
139     // If the implementation is able
140     // to prove that a wrapper of the required type
141     // has already been created for a given
142     // method handle, or for another method handle with the
143     // same behavior, the implementation may return that wrapper in place of
144     // a new wrapper.
145     // &lt;p&gt;
146     // This method is designed to apply to common use cases
147     // where a single method handle must interoperate with
148     // an interface that implements a function-like
149     // API.  Additional variations, such as single-abstract-method classes with
150     // private constructors, or interfaces with multiple but related
151     // entry points, must be covered by hand-written or automatically
152     // generated adapter classes.
153     //
154     @CallerSensitive
155     public static
156     &lt;T&gt; T asInterfaceInstance(final Class&lt;T&gt; intfc, final MethodHandle target) {
157         if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))
158             throw newIllegalArgumentException(&quot;not a public interface&quot;, intfc.getName());
159         final MethodHandle mh;
160         if (System.getSecurityManager() != null) {
161             final Class&lt;?&gt; caller = Reflection.getCallerClass();
162             final ClassLoader ccl = caller != null ? caller.getClassLoader() : null;
163             ReflectUtil.checkProxyPackageAccess(ccl, intfc);
164             mh = ccl != null ? bindCaller(target, caller) : target;
165         } else {
166             mh = target;
167         }
168         ClassLoader proxyLoader = intfc.getClassLoader();
169         if (proxyLoader == null) {
170             ClassLoader cl = Thread.currentThread().getContextClassLoader(); // avoid use of BCP
171             proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();
172         }
173         final Method[] methods = getSingleNameMethods(intfc);
174         if (methods == null)
175             throw newIllegalArgumentException(&quot;not a single-method interface&quot;, intfc.getName());
176         final MethodHandle[] vaTargets = new MethodHandle[methods.length];
177         for (int i = 0; i &lt; methods.length; i++) {
178             Method sm = methods[i];
179             MethodType smMT = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());
180             MethodHandle checkTarget = mh.asType(smMT);  // make throw WMT
181             checkTarget = checkTarget.asType(checkTarget.type().changeReturnType(Object.class));
182             vaTargets[i] = checkTarget.asSpreader(Object[].class, smMT.parameterCount());
183         }
184         final ConcurrentHashMap&lt;Method, MethodHandle&gt; defaultMethodMap =
185                 hasDefaultMethods(intfc) ? new ConcurrentHashMap&lt;&gt;() : null;
186         final InvocationHandler ih = new InvocationHandler() {
187                 private Object getArg(String name) {
188                     if ((Object)name == &quot;getWrapperInstanceTarget&quot;)  return target;
189                     if ((Object)name == &quot;getWrapperInstanceType&quot;)    return intfc;
190                     throw new AssertionError();
191                 }
192                 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
193                     for (int i = 0; i &lt; methods.length; i++) {
194                         if (method.equals(methods[i]))
195                             return vaTargets[i].invokeExact(args);
196                     }
197                     if (method.getDeclaringClass() == WrapperInstance.class)
198                         return getArg(method.getName());
199                     if (isObjectMethod(method))
200                         return callObjectMethod(proxy, method, args);
201                     if (isDefaultMethod(method)) {
202                         return callDefaultMethod(defaultMethodMap, proxy, intfc, method, args);
203                     }
204                     throw newInternalError(&quot;bad proxy method: &quot;+method);
205                 }
206             };
207 
208         final Object proxy;
209         if (System.getSecurityManager() != null) {
210             // sun.invoke.WrapperInstance is a restricted interface not accessible
211             // by any non-null class loader.
212             final ClassLoader loader = proxyLoader;
213             proxy = AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
214                 public Object run() {
215                     return Proxy.newProxyInstance(
216                             loader,
217                             new Class&lt;?&gt;[]{ intfc, WrapperInstance.class },
218                             ih);
219                 }
220             });
221         } else {
222             proxy = Proxy.newProxyInstance(proxyLoader,
223                                            new Class&lt;?&gt;[]{ intfc, WrapperInstance.class },
224                                            ih);
225         }
226         return intfc.cast(proxy);
227     }
228 
229     private static MethodHandle bindCaller(MethodHandle target, Class&lt;?&gt; hostClass) {
230         return MethodHandleImpl.bindCaller(target, hostClass).withVarargs(target.isVarargsCollector());
231     }
232 
233     /**
234      * Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
235      * @param x any reference
236      * @return true if the reference is not null and points to an object produced by {@code asInterfaceInstance}
237      */
238     public static
239     boolean isWrapperInstance(Object x) {
240         return x instanceof WrapperInstance;
241     }
242 
243     private static WrapperInstance asWrapperInstance(Object x) {
244         try {
245             if (x != null)
246                 return (WrapperInstance) x;
247         } catch (ClassCastException ex) {
248         }
249         throw newIllegalArgumentException(&quot;not a wrapper instance&quot;);
250     }
251 
252     /**
253      * Produces or recovers a target method handle which is behaviorally
254      * equivalent to the unique method of this wrapper instance.
255      * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
256      * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
257      * @param x any reference
258      * @return a method handle implementing the unique method
259      * @throws IllegalArgumentException if the reference x is not to a wrapper instance
260      */
261     public static
262     MethodHandle wrapperInstanceTarget(Object x) {
263         return asWrapperInstance(x).getWrapperInstanceTarget();
264     }
265 
266     /**
267      * Recovers the unique single-method interface type for which this wrapper instance was created.
268      * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
269      * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
270      * @param x any reference
271      * @return the single-method interface type for which the wrapper was created
272      * @throws IllegalArgumentException if the reference x is not to a wrapper instance
273      */
274     public static
275     Class&lt;?&gt; wrapperInstanceType(Object x) {
276         return asWrapperInstance(x).getWrapperInstanceType();
277     }
278 
279     private static
280     boolean isObjectMethod(Method m) {
281         switch (m.getName()) {
282         case &quot;toString&quot;:
283             return (m.getReturnType() == String.class
284                     &amp;&amp; m.getParameterTypes().length == 0);
285         case &quot;hashCode&quot;:
286             return (m.getReturnType() == int.class
287                     &amp;&amp; m.getParameterTypes().length == 0);
288         case &quot;equals&quot;:
289             return (m.getReturnType() == boolean.class
290                     &amp;&amp; m.getParameterTypes().length == 1
291                     &amp;&amp; m.getParameterTypes()[0] == Object.class);
292         }
293         return false;
294     }
295 
296     private static
297     Object callObjectMethod(Object self, Method m, Object[] args) {
298         assert(isObjectMethod(m)) : m;
299         switch (m.getName()) {
300         case &quot;toString&quot;:
301             return self.getClass().getName() + &quot;@&quot; + Integer.toHexString(self.hashCode());
302         case &quot;hashCode&quot;:
303             return System.identityHashCode(self);
304         case &quot;equals&quot;:
305             return (self == args[0]);
306         }
307         return null;
308     }
309 
310     private static
311     Method[] getSingleNameMethods(Class&lt;?&gt; intfc) {
312         ArrayList&lt;Method&gt; methods = new ArrayList&lt;&gt;();
313         String uniqueName = null;
314         for (Method m : intfc.getMethods()) {
315             if (isObjectMethod(m))  continue;
316             if (!Modifier.isAbstract(m.getModifiers()))  continue;
317             String mname = m.getName();
318             if (uniqueName == null)
319                 uniqueName = mname;
320             else if (!uniqueName.equals(mname))
321                 return null;  // too many abstract methods
322             methods.add(m);
323         }
324         if (uniqueName == null)  return null;
325         return methods.toArray(new Method[methods.size()]);
326     }
327 
328     private static
329     boolean isDefaultMethod(Method m) {
330         return !Modifier.isAbstract(m.getModifiers());
331     }
332 
333     private static
334     boolean hasDefaultMethods(Class&lt;?&gt; intfc) {
335         for (Method m : intfc.getMethods()) {
336             if (!isObjectMethod(m) &amp;&amp;
337                 !Modifier.isAbstract(m.getModifiers())) {
338                 return true;
339             }
340         }
341         return false;
342     }
343 
344     private static
345     Object callDefaultMethod(ConcurrentHashMap&lt;Method, MethodHandle&gt; defaultMethodMap,
346                              Object self, Class&lt;?&gt; intfc, Method m, Object[] args) throws Throwable {
347         assert(isDefaultMethod(m) &amp;&amp; !isObjectMethod(m)) : m;
348 
349         // Lazily compute the associated method handle from the method
350         MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -&gt; {
351             try {
352                 // Look up the default method for special invocation thereby
353                 // avoiding recursive invocation back to the proxy
354                 MethodHandle mh = MethodHandles.Lookup.IMPL_LOOKUP.findSpecial(
355                         intfc, mk.getName(),
356                         MethodType.methodType(mk.getReturnType(), mk.getParameterTypes()),
357                         self.getClass());
358                 return mh.asSpreader(Object[].class, mk.getParameterCount());
359             } catch (NoSuchMethodException | IllegalAccessException e) {
360                 // The method is known to exist and should be accessible, this
361                 // method would not be called unless the invokeinterface to the
362                 // default (public) method passed access control checks
363                 throw new InternalError(e);
364             }
365         });
366         return dmh.invoke(self, args);
367     }
368 }
    </pre>
  </body>
</html>
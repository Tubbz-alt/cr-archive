<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/constant/ClassDesc.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../annotation/IncompleteAnnotationException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Constable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/constant/ClassDesc.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55  * {@linkplain ClassDesc} directly.
 56  *
 57  * @see ConstantDescs
 58  *
 59  * @since 12
 60  */
 61 public interface ClassDesc
 62         extends ConstantDesc,
 63                 TypeDescriptor.OfField&lt;ClassDesc&gt; {
 64 
 65     /**
 66      * Returns a {@linkplain ClassDesc} for a class or interface type,
 67      * given the name of the class or interface, such as {@code &quot;java.lang.String&quot;}.
 68      * (To create a descriptor for an array type, either use {@link #ofDescriptor(String)}
 69      * or {@link #arrayType()}; to create a descriptor for a primitive type, use
 70      * {@link #ofDescriptor(String)} or use the predefined constants in
 71      * {@link ConstantDescs}).
 72      *
 73      * @param name the fully qualified (dot-separated) binary class name
 74      * @return a {@linkplain ClassDesc} describing the desired class
<span class="line-modified"> 75      * @throws NullPointerException if any argument is {@code null}</span>
 76      * @throws IllegalArgumentException if the name string is not in the
 77      * correct format
 78      */
 79     static ClassDesc of(String name) {
 80         ConstantUtils.validateBinaryClassName(requireNonNull(name));
 81         return ClassDesc.ofDescriptor(&quot;L&quot; + binaryToInternal(name) + &quot;;&quot;);
 82     }
 83 
 84     /**
 85      * Returns a {@linkplain ClassDesc} for a class or interface type,
 86      * given a package name and the unqualified (simple) name for the
 87      * class or interface.
 88      *
 89      * @param packageName the package name (dot-separated); if the package
 90      *                    name is the empty string, the class is considered to
 91      *                    be in the unnamed package
 92      * @param className the unqualified (simple) class name
 93      * @return a {@linkplain ClassDesc} describing the desired class
 94      * @throws NullPointerException if any argument is {@code null}
 95      * @throws IllegalArgumentException if the package name or class name are
</pre>
<hr />
<pre>
106     }
107 
108     /**
109      * Returns a {@linkplain ClassDesc} given a descriptor string for a class,
110      * interface, array, or primitive type.
111      *
112      * @apiNote
113      *
114      * A field type descriptor string for a non-array type is either
115      * a one-letter code corresponding to a primitive type
116      * ({@code &quot;J&quot;, &quot;I&quot;, &quot;C&quot;, &quot;S&quot;, &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;Z&quot;, &quot;V&quot;}), or the letter {@code &quot;L&quot;}, followed
117      * by the fully qualified binary name of a class, followed by {@code &quot;;&quot;}.
118      * A field type descriptor for an array type is the character {@code &quot;[&quot;}
119      * followed by the field descriptor for the component type.  Examples of
120      * valid type descriptor strings include {@code &quot;Ljava/lang/String;&quot;}, {@code &quot;I&quot;},
121      * {@code &quot;[I&quot;}, {@code &quot;V&quot;}, {@code &quot;[Ljava/lang/String;&quot;}, etc.
122      * See JVMS 4.3.2 (&quot;Field Descriptors&quot;) for more detail.
123      *
124      * @param descriptor a field descriptor string
125      * @return a {@linkplain ClassDesc} describing the desired class
<span class="line-modified">126      * @throws NullPointerException if any argument is {@code null}</span>
127      * @throws IllegalArgumentException if the name string is not in the
128      * correct format
129      * @jvms 4.3.2 Field Descriptors
130      * @jvms 4.4.1 The CONSTANT_Class_info Structure
131      */
132     static ClassDesc ofDescriptor(String descriptor) {
133         requireNonNull(descriptor);
134         if (descriptor.isEmpty()) {
135             throw new IllegalArgumentException(
136                     &quot;not a valid reference type descriptor: &quot; + descriptor);
137         }
138         int depth = ConstantUtils.arrayDepth(descriptor);
139         if (depth &gt; ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS) {
140             throw new IllegalArgumentException(
141                     &quot;Cannot create an array type descriptor with more than &quot; +
142                     ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS + &quot; dimensions&quot;);
143         }
144         return (descriptor.length() == 1)
145                ? new PrimitiveClassDescImpl(descriptor)
146                : new ReferenceClassDescImpl(descriptor);
</pre>
<hr />
<pre>
176      */
177     default ClassDesc arrayType(int rank) {
178         int currentDepth = ConstantUtils.arrayDepth(descriptorString());
179         if (rank &lt;= 0 || currentDepth + rank &gt; ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS)
180             throw new IllegalArgumentException(&quot;rank: &quot; + currentDepth + rank);
181         return ClassDesc.ofDescriptor(&quot;[&quot;.repeat(rank) + descriptorString());
182     }
183 
184     /**
185      * Returns a {@linkplain ClassDesc} for a nested class of the class or
186      * interface type described by this {@linkplain ClassDesc}.
187      *
188      * @apiNote
189      *
190      * Example: If descriptor {@code d} describes the class {@code java.util.Map}, a
191      * descriptor for the class {@code java.util.Map.Entry} could be obtained
192      * by {@code d.nested(&quot;Entry&quot;)}.
193      *
194      * @param nestedName the unqualified name of the nested class
195      * @return a {@linkplain ClassDesc} describing the nested class
<span class="line-modified">196      * @throws NullPointerException if any argument is {@code null}</span>
197      * @throws IllegalStateException if this {@linkplain ClassDesc} does not
198      * describe a class or interface type
199      * @throws IllegalArgumentException if the nested class name is invalid
200      */
201     default ClassDesc nested(String nestedName) {
202         validateMemberName(nestedName, false);
203         if (!isClassOrInterface())
204             throw new IllegalStateException(&quot;Outer class is not a class or interface type&quot;);
205         return ClassDesc.ofDescriptor(dropLastChar(descriptorString()) + &quot;$&quot; + nestedName + &quot;;&quot;);
206     }
207 
208     /**
209      * Returns a {@linkplain ClassDesc} for a nested class of the class or
210      * interface type described by this {@linkplain ClassDesc}.
211      *
212      * @param firstNestedName the unqualified name of the first level of nested class
213      * @param moreNestedNames the unqualified name(s) of the remaining levels of
214      *                       nested class
215      * @return a {@linkplain ClassDesc} describing the nested class
<span class="line-modified">216      * @throws NullPointerException if any argument is {@code null}</span>
217      * @throws IllegalStateException if this {@linkplain ClassDesc} does not
218      * describe a class or interface type
219      * @throws IllegalArgumentException if the nested class name is invalid
220      */
221     default ClassDesc nested(String firstNestedName, String... moreNestedNames) {
222         if (!isClassOrInterface())
223             throw new IllegalStateException(&quot;Outer class is not a class or interface type&quot;);





224         return moreNestedNames.length == 0
225                ? nested(firstNestedName)
226                : nested(firstNestedName + Stream.of(moreNestedNames).collect(joining(&quot;$&quot;, &quot;$&quot;, &quot;&quot;)));
227     }
228 
229     /**
230      * Returns whether this {@linkplain ClassDesc} describes an array type.
231      *
232      * @return whether this {@linkplain ClassDesc} describes an array type
233      */
234     default boolean isArray() {
235         return descriptorString().startsWith(&quot;[&quot;);
236     }
237 
238     /**
239      * Returns whether this {@linkplain ClassDesc} describes a primitive type.
240      *
241      * @return whether this {@linkplain ClassDesc} describes a primitive type
242      */
243     default boolean isPrimitive() {
</pre>
</td>
<td>
<hr />
<pre>
 55  * {@linkplain ClassDesc} directly.
 56  *
 57  * @see ConstantDescs
 58  *
 59  * @since 12
 60  */
 61 public interface ClassDesc
 62         extends ConstantDesc,
 63                 TypeDescriptor.OfField&lt;ClassDesc&gt; {
 64 
 65     /**
 66      * Returns a {@linkplain ClassDesc} for a class or interface type,
 67      * given the name of the class or interface, such as {@code &quot;java.lang.String&quot;}.
 68      * (To create a descriptor for an array type, either use {@link #ofDescriptor(String)}
 69      * or {@link #arrayType()}; to create a descriptor for a primitive type, use
 70      * {@link #ofDescriptor(String)} or use the predefined constants in
 71      * {@link ConstantDescs}).
 72      *
 73      * @param name the fully qualified (dot-separated) binary class name
 74      * @return a {@linkplain ClassDesc} describing the desired class
<span class="line-modified"> 75      * @throws NullPointerException if the argument is {@code null}</span>
 76      * @throws IllegalArgumentException if the name string is not in the
 77      * correct format
 78      */
 79     static ClassDesc of(String name) {
 80         ConstantUtils.validateBinaryClassName(requireNonNull(name));
 81         return ClassDesc.ofDescriptor(&quot;L&quot; + binaryToInternal(name) + &quot;;&quot;);
 82     }
 83 
 84     /**
 85      * Returns a {@linkplain ClassDesc} for a class or interface type,
 86      * given a package name and the unqualified (simple) name for the
 87      * class or interface.
 88      *
 89      * @param packageName the package name (dot-separated); if the package
 90      *                    name is the empty string, the class is considered to
 91      *                    be in the unnamed package
 92      * @param className the unqualified (simple) class name
 93      * @return a {@linkplain ClassDesc} describing the desired class
 94      * @throws NullPointerException if any argument is {@code null}
 95      * @throws IllegalArgumentException if the package name or class name are
</pre>
<hr />
<pre>
106     }
107 
108     /**
109      * Returns a {@linkplain ClassDesc} given a descriptor string for a class,
110      * interface, array, or primitive type.
111      *
112      * @apiNote
113      *
114      * A field type descriptor string for a non-array type is either
115      * a one-letter code corresponding to a primitive type
116      * ({@code &quot;J&quot;, &quot;I&quot;, &quot;C&quot;, &quot;S&quot;, &quot;B&quot;, &quot;D&quot;, &quot;F&quot;, &quot;Z&quot;, &quot;V&quot;}), or the letter {@code &quot;L&quot;}, followed
117      * by the fully qualified binary name of a class, followed by {@code &quot;;&quot;}.
118      * A field type descriptor for an array type is the character {@code &quot;[&quot;}
119      * followed by the field descriptor for the component type.  Examples of
120      * valid type descriptor strings include {@code &quot;Ljava/lang/String;&quot;}, {@code &quot;I&quot;},
121      * {@code &quot;[I&quot;}, {@code &quot;V&quot;}, {@code &quot;[Ljava/lang/String;&quot;}, etc.
122      * See JVMS 4.3.2 (&quot;Field Descriptors&quot;) for more detail.
123      *
124      * @param descriptor a field descriptor string
125      * @return a {@linkplain ClassDesc} describing the desired class
<span class="line-modified">126      * @throws NullPointerException if the argument is {@code null}</span>
127      * @throws IllegalArgumentException if the name string is not in the
128      * correct format
129      * @jvms 4.3.2 Field Descriptors
130      * @jvms 4.4.1 The CONSTANT_Class_info Structure
131      */
132     static ClassDesc ofDescriptor(String descriptor) {
133         requireNonNull(descriptor);
134         if (descriptor.isEmpty()) {
135             throw new IllegalArgumentException(
136                     &quot;not a valid reference type descriptor: &quot; + descriptor);
137         }
138         int depth = ConstantUtils.arrayDepth(descriptor);
139         if (depth &gt; ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS) {
140             throw new IllegalArgumentException(
141                     &quot;Cannot create an array type descriptor with more than &quot; +
142                     ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS + &quot; dimensions&quot;);
143         }
144         return (descriptor.length() == 1)
145                ? new PrimitiveClassDescImpl(descriptor)
146                : new ReferenceClassDescImpl(descriptor);
</pre>
<hr />
<pre>
176      */
177     default ClassDesc arrayType(int rank) {
178         int currentDepth = ConstantUtils.arrayDepth(descriptorString());
179         if (rank &lt;= 0 || currentDepth + rank &gt; ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS)
180             throw new IllegalArgumentException(&quot;rank: &quot; + currentDepth + rank);
181         return ClassDesc.ofDescriptor(&quot;[&quot;.repeat(rank) + descriptorString());
182     }
183 
184     /**
185      * Returns a {@linkplain ClassDesc} for a nested class of the class or
186      * interface type described by this {@linkplain ClassDesc}.
187      *
188      * @apiNote
189      *
190      * Example: If descriptor {@code d} describes the class {@code java.util.Map}, a
191      * descriptor for the class {@code java.util.Map.Entry} could be obtained
192      * by {@code d.nested(&quot;Entry&quot;)}.
193      *
194      * @param nestedName the unqualified name of the nested class
195      * @return a {@linkplain ClassDesc} describing the nested class
<span class="line-modified">196      * @throws NullPointerException if the argument is {@code null}</span>
197      * @throws IllegalStateException if this {@linkplain ClassDesc} does not
198      * describe a class or interface type
199      * @throws IllegalArgumentException if the nested class name is invalid
200      */
201     default ClassDesc nested(String nestedName) {
202         validateMemberName(nestedName, false);
203         if (!isClassOrInterface())
204             throw new IllegalStateException(&quot;Outer class is not a class or interface type&quot;);
205         return ClassDesc.ofDescriptor(dropLastChar(descriptorString()) + &quot;$&quot; + nestedName + &quot;;&quot;);
206     }
207 
208     /**
209      * Returns a {@linkplain ClassDesc} for a nested class of the class or
210      * interface type described by this {@linkplain ClassDesc}.
211      *
212      * @param firstNestedName the unqualified name of the first level of nested class
213      * @param moreNestedNames the unqualified name(s) of the remaining levels of
214      *                       nested class
215      * @return a {@linkplain ClassDesc} describing the nested class
<span class="line-modified">216      * @throws NullPointerException if any argument or its contents is {@code null}</span>
217      * @throws IllegalStateException if this {@linkplain ClassDesc} does not
218      * describe a class or interface type
219      * @throws IllegalArgumentException if the nested class name is invalid
220      */
221     default ClassDesc nested(String firstNestedName, String... moreNestedNames) {
222         if (!isClassOrInterface())
223             throw new IllegalStateException(&quot;Outer class is not a class or interface type&quot;);
<span class="line-added">224         validateMemberName(firstNestedName, false);</span>
<span class="line-added">225         requireNonNull(moreNestedNames);</span>
<span class="line-added">226         for (String addNestedNames : moreNestedNames) {</span>
<span class="line-added">227             validateMemberName(addNestedNames, false);</span>
<span class="line-added">228         }</span>
229         return moreNestedNames.length == 0
230                ? nested(firstNestedName)
231                : nested(firstNestedName + Stream.of(moreNestedNames).collect(joining(&quot;$&quot;, &quot;$&quot;, &quot;&quot;)));
232     }
233 
234     /**
235      * Returns whether this {@linkplain ClassDesc} describes an array type.
236      *
237      * @return whether this {@linkplain ClassDesc} describes an array type
238      */
239     default boolean isArray() {
240         return descriptorString().startsWith(&quot;[&quot;);
241     }
242 
243     /**
244      * Returns whether this {@linkplain ClassDesc} describes a primitive type.
245      *
246      * @return whether this {@linkplain ClassDesc} describes a primitive type
247      */
248     default boolean isPrimitive() {
</pre>
</td>
</tr>
</table>
<center><a href="../annotation/IncompleteAnnotationException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Constable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
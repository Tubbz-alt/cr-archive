<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.reflect;
 27 
<a name="2" id="anc2"></a><span class="line-modified"> 28 import jdk.internal.org.objectweb.asm.ClassWriter;</span>
<span class="line-modified"> 29 import jdk.internal.org.objectweb.asm.Label;</span>
<span class="line-modified"> 30 import jdk.internal.org.objectweb.asm.MethodVisitor;</span>
<span class="line-added"> 31 import jdk.internal.org.objectweb.asm.Opcodes;</span>
<span class="line-added"> 32 import sun.security.action.GetBooleanAction;</span>
<span class="line-added"> 33 </span>
 34 import java.io.IOException;
<a name="3" id="anc3"></a><span class="line-modified"> 35 import java.lang.invoke.MethodType;</span>


 36 import java.nio.file.Files;
 37 import java.nio.file.Path;
 38 import java.util.ArrayList;
<a name="4" id="anc4"></a><span class="line-added"> 39 import java.util.Arrays;</span>
 40 import java.util.HashMap;
<a name="5" id="anc5"></a><span class="line-added"> 41 import java.util.LinkedHashMap;</span>
 42 import java.util.LinkedList;
 43 import java.util.List;
 44 import java.util.ListIterator;
 45 import java.util.Map;
<a name="6" id="anc6"></a><span class="line-modified"> 46 </span>
<span class="line-added"> 47 import static jdk.internal.org.objectweb.asm.Opcodes.*;</span>
 48 
 49 /**
 50  * ProxyGenerator contains the code to generate a dynamic proxy class
 51  * for the java.lang.reflect.Proxy API.
<a name="7" id="anc7"></a><span class="line-modified"> 52  * &lt;p&gt;</span>
<span class="line-modified"> 53  * The external interface to ProxyGenerator is the static</span>
 54  * &quot;generateProxyClass&quot; method.
<a name="8" id="anc8"></a>


 55  */
<a name="9" id="anc9"></a><span class="line-modified"> 56 final class ProxyGenerator extends ClassWriter {</span>






 57 
<a name="10" id="anc10"></a><span class="line-modified"> 58     private static final String JL_CLASS = &quot;java/lang/Class&quot;;</span>
<span class="line-modified"> 59     private static final String JL_OBJECT = &quot;java/lang/Object&quot;;</span>
<span class="line-modified"> 60     private static final String JL_THROWABLE = &quot;java/lang/Throwable&quot;;</span>
<span class="line-added"> 61     private static final String JL_CLASS_NOT_FOUND_EX = &quot;java/lang/ClassNotFoundException&quot;;</span>
<span class="line-added"> 62     private static final String JL_NO_CLASS_DEF_FOUND_ERROR = &quot;java/lang/NoClassDefFoundError&quot;;</span>
<span class="line-added"> 63     private static final String JL_NO_SUCH_METHOD_EX = &quot;java/lang/NoSuchMethodException&quot;;</span>
<span class="line-added"> 64     private static final String JL_NO_SUCH_METHOD_ERROR = &quot;java/lang/NoSuchMethodError&quot;;</span>
 65 
<a name="11" id="anc11"></a><span class="line-modified"> 66     private static final String JLR_INVOCATION_HANDLER = &quot;java/lang/reflect/InvocationHandler&quot;;</span>
<span class="line-modified"> 67     private static final String JLR_PROXY = &quot;java/lang/reflect/Proxy&quot;;</span>
<span class="line-modified"> 68     private static final String JLR_UNDECLARED_THROWABLE_EX = &quot;java/lang/reflect/UndeclaredThrowableException&quot;;</span>

 69 
<a name="12" id="anc12"></a><span class="line-modified"> 70     private static final String LJL_CLASS = &quot;Ljava/lang/Class;&quot;;</span>
<span class="line-modified"> 71     private static final String LJLR_METHOD = &quot;Ljava/lang/reflect/Method;&quot;;</span>
<span class="line-modified"> 72     private static final String LJLR_INVOCATION_HANDLER = &quot;Ljava/lang/reflect/InvocationHandler;&quot;;</span>












































































































































































































































 73 
<a name="13" id="anc13"></a><span class="line-modified"> 74     private static final String MJLR_INVOCATIONHANDLER = &quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;;</span>
<span class="line-modified"> 75 </span>
<span class="line-modified"> 76     private static final String NAME_CTOR = &quot;&lt;init&gt;&quot;;</span>
<span class="line-modified"> 77     private static final String NAME_CLINIT = &quot;&lt;clinit&gt;&quot;;</span>
<span class="line-modified"> 78 </span>
<span class="line-added"> 79     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];</span>
 80 
 81     /**
<a name="14" id="anc14"></a><span class="line-modified"> 82      * name of field for storing a proxy instance&#39;s invocation handler</span>
 83      */
<a name="15" id="anc15"></a><span class="line-modified"> 84     private static final String handlerFieldName = &quot;h&quot;;</span>



 85 
 86     /**
<a name="16" id="anc16"></a><span class="line-modified"> 87      * debugging flag for saving generated class files</span>
<span class="line-modified"> 88      */</span>
<span class="line-modified"> 89     private static final boolean saveGeneratedFiles =</span>











 90             java.security.AccessController.doPrivileged(
<a name="17" id="anc17"></a><span class="line-modified"> 91                     new GetBooleanAction(</span>
<span class="line-modified"> 92                             &quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;));</span>



















 93 
<a name="18" id="anc18"></a><span class="line-modified"> 94     /* Preloaded ProxyMethod objects for methods in java.lang.Object */</span>
<span class="line-modified"> 95     private final static ProxyMethod hashCodeMethod;</span>
<span class="line-added"> 96     private final static ProxyMethod equalsMethod;</span>
<span class="line-added"> 97     private final static ProxyMethod toStringMethod;</span>
 98 
<a name="19" id="anc19"></a>



 99     static {
100         try {
<a name="20" id="anc20"></a><span class="line-modified">101             hashCodeMethod = new ProxyMethod(Object.class.getMethod(&quot;hashCode&quot;), &quot;m0&quot;);</span>
<span class="line-modified">102             equalsMethod = new ProxyMethod(Object.class.getMethod(&quot;equals&quot;, Object.class), &quot;m1&quot;);</span>
<span class="line-modified">103             toStringMethod = new ProxyMethod(Object.class.getMethod(&quot;toString&quot;), &quot;m2&quot;);</span>

104         } catch (NoSuchMethodException e) {
105             throw new NoSuchMethodError(e.getMessage());
106         }
107     }
108 
<a name="21" id="anc21"></a><span class="line-modified">109     /**</span>
<span class="line-modified">110      * Class loader</span>
<span class="line-modified">111      */</span>
<span class="line-modified">112     private final ClassLoader loader;</span>




113 
<a name="22" id="anc22"></a><span class="line-modified">114     /**</span>
<span class="line-modified">115      * Name of proxy class</span>
<span class="line-added">116      */</span>
<span class="line-added">117     private final String className;</span>
118 
<a name="23" id="anc23"></a><span class="line-modified">119     /**</span>
<span class="line-modified">120      * Proxy interfaces</span>
<span class="line-added">121      */</span>
<span class="line-added">122     private final List&lt;Class&lt;?&gt;&gt; interfaces;</span>
123 
<a name="24" id="anc24"></a><span class="line-modified">124     /**</span>
<span class="line-modified">125      * Proxy class access flags</span>
<span class="line-added">126      */</span>
<span class="line-added">127     private final int accessFlags;</span>
128 
129     /**
<a name="25" id="anc25"></a><span class="line-modified">130      * Maps method signature string to list of ProxyMethod objects for</span>
<span class="line-modified">131      * proxy methods with that signature.</span>
<span class="line-added">132      * Kept in insertion order to make it easier to compare old and new.</span>
133      */
<a name="26" id="anc26"></a><span class="line-modified">134     private final Map&lt;String, List&lt;ProxyMethod&gt;&gt; proxyMethods = new LinkedHashMap&lt;&gt;();</span>
135 
<a name="27" id="anc27"></a><span class="line-modified">136     /**</span>
<span class="line-modified">137      * Ordinal of next ProxyMethod object added to proxyMethods.</span>
<span class="line-added">138      * Indexes are reserved for hashcode(0), equals(1), toString(2).</span>
<span class="line-added">139      */</span>
<span class="line-added">140     private int proxyMethodCount = 3;</span>
141 
142     /**
143      * Construct a ProxyGenerator to generate a proxy class with the
144      * specified name and for the given interfaces.
<a name="28" id="anc28"></a><span class="line-modified">145      * &lt;p&gt;</span>
146      * A ProxyGenerator object contains the state for the ongoing
147      * generation of a particular proxy class.
148      */
<a name="29" id="anc29"></a><span class="line-modified">149     private ProxyGenerator(ClassLoader loader, String className, List&lt;Class&lt;?&gt;&gt; interfaces,</span>
<span class="line-added">150                            int accessFlags) {</span>
<span class="line-added">151         super(ClassWriter.COMPUTE_FRAMES);</span>
<span class="line-added">152         this.loader = loader;</span>
153         this.className = className;
154         this.interfaces = interfaces;
155         this.accessFlags = accessFlags;
156     }
157 
158     /**
<a name="30" id="anc30"></a><span class="line-modified">159      * Generate a proxy class given a name and a list of proxy interfaces.</span>
<span class="line-modified">160      *</span>
<span class="line-added">161      * @param name        the class name of the proxy class</span>
<span class="line-added">162      * @param interfaces  proxy interfaces</span>
<span class="line-added">163      * @param accessFlags access flags of the proxy class</span>
164      */
<a name="31" id="anc31"></a><span class="line-modified">165     static byte[] generateProxyClass(ClassLoader loader,</span>
<span class="line-modified">166                                      final String name,</span>
<span class="line-modified">167                                      List&lt;Class&lt;?&gt;&gt; interfaces,</span>
<span class="line-modified">168                                      int accessFlags) {</span>
<span class="line-modified">169         ProxyGenerator gen = new ProxyGenerator(loader, name, interfaces, accessFlags);</span>
<span class="line-modified">170         final byte[] classFile = gen.generateClassFile();</span>






































































































































171 
<a name="32" id="anc32"></a><span class="line-modified">172         if (saveGeneratedFiles) {</span>
<span class="line-modified">173             java.security.AccessController.doPrivileged(</span>
<span class="line-added">174                     new java.security.PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-added">175                         public Void run() {</span>
<span class="line-added">176                             try {</span>
<span class="line-added">177                                 int i = name.lastIndexOf(&#39;.&#39;);</span>
<span class="line-added">178                                 Path path;</span>
<span class="line-added">179                                 if (i &gt; 0) {</span>
<span class="line-added">180                                     Path dir = Path.of(dotToSlash(name.substring(0, i)));</span>
<span class="line-added">181                                     Files.createDirectories(dir);</span>
<span class="line-added">182                                     path = dir.resolve(name.substring(i + 1) + &quot;.class&quot;);</span>
<span class="line-added">183                                 } else {</span>
<span class="line-added">184                                     path = Path.of(name + &quot;.class&quot;);</span>
<span class="line-added">185                                 }</span>
<span class="line-added">186                                 Files.write(path, classFile);</span>
<span class="line-added">187                                 return null;</span>
<span class="line-added">188                             } catch (IOException e) {</span>
<span class="line-added">189                                 throw new InternalError(</span>
<span class="line-added">190                                         &quot;I/O exception saving generated file: &quot; + e);</span>
<span class="line-added">191                             }</span>
<span class="line-added">192                         }</span>
<span class="line-added">193                     });</span>
194         }
195 
<a name="33" id="anc33"></a><span class="line-modified">196         return classFile;</span>
197     }
198 
199     /**
<a name="34" id="anc34"></a><span class="line-modified">200      * Return an array of the type names from an array of Classes.</span>


201      *
<a name="35" id="anc35"></a><span class="line-modified">202      * @param classes an array of classes or interfaces</span>
<span class="line-modified">203      * @return the array of class names; or null if there are no classes</span>





204      */
<a name="36" id="anc36"></a><span class="line-modified">205     private static String[] typeNames(List&lt;Class&lt;?&gt;&gt; classes) {</span>
<span class="line-modified">206         if (classes == null || classes.size() == 0)</span>
<span class="line-modified">207             return null;</span>
<span class="line-modified">208         int size = classes.size();</span>
<span class="line-modified">209         String[] ifaces = new String[size];</span>
<span class="line-modified">210         for (int i = 0; i &lt; size; i++)</span>
<span class="line-modified">211             ifaces[i] = dotToSlash(classes.get(i).getName());</span>
<span class="line-modified">212         return ifaces;</span>


























213     }
214 
215     /**
216      * For a given set of proxy methods with the same signature, check
217      * that their return types are compatible according to the Proxy
218      * specification.
219      *
220      * Specifically, if there is more than one such method, then all
221      * of the return types must be reference types, and there must be
222      * one return type that is assignable to each of the rest of them.
223      */
224     private static void checkReturnTypes(List&lt;ProxyMethod&gt; methods) {
225         /*
226          * If there is only one method with a given signature, there
227          * cannot be a conflict.  This is the only case in which a
228          * primitive (or void) return type is allowed.
229          */
230         if (methods.size() &lt; 2) {
231             return;
232         }
233 
234         /*
235          * List of return types that are not yet known to be
236          * assignable from (&quot;covered&quot; by) any of the others.
237          */
238         LinkedList&lt;Class&lt;?&gt;&gt; uncoveredReturnTypes = new LinkedList&lt;&gt;();
239 
<a name="37" id="anc37"></a><span class="line-modified">240         nextNewReturnType:</span>
241         for (ProxyMethod pm : methods) {
242             Class&lt;?&gt; newReturnType = pm.returnType;
243             if (newReturnType.isPrimitive()) {
244                 throw new IllegalArgumentException(
<a name="38" id="anc38"></a><span class="line-modified">245                         &quot;methods with same signature &quot; +</span>
<span class="line-modified">246                                 pm.shortSignature +</span>
<span class="line-modified">247                                 &quot; but incompatible return types: &quot; +</span>
<span class="line-modified">248                                 newReturnType.getName() + &quot; and others&quot;);</span>

249             }
250             boolean added = false;
251 
252             /*
253              * Compare the new return type to the existing uncovered
254              * return types.
255              */
256             ListIterator&lt;Class&lt;?&gt;&gt; liter = uncoveredReturnTypes.listIterator();
257             while (liter.hasNext()) {
258                 Class&lt;?&gt; uncoveredReturnType = liter.next();
259 
260                 /*
261                  * If an existing uncovered return type is assignable
262                  * to this new one, then we can forget the new one.
263                  */
264                 if (newReturnType.isAssignableFrom(uncoveredReturnType)) {
265                     assert !added;
266                     continue nextNewReturnType;
267                 }
268 
269                 /*
270                  * If the new return type is assignable to an existing
271                  * uncovered one, then should replace the existing one
272                  * with the new one (or just forget the existing one,
273                  * if the new one has already be put in the list).
274                  */
275                 if (uncoveredReturnType.isAssignableFrom(newReturnType)) {
276                     // (we can assume that each return type is unique)
277                     if (!added) {
278                         liter.set(newReturnType);
279                         added = true;
280                     } else {
281                         liter.remove();
282                     }
283                 }
284             }
285 
286             /*
287              * If we got through the list of existing uncovered return
288              * types without an assignability relationship, then add
289              * the new return type to the list of uncovered ones.
290              */
291             if (!added) {
292                 uncoveredReturnTypes.add(newReturnType);
293             }
294         }
295 
296         /*
297          * We shouldn&#39;t end up with more than one return type that is
298          * not assignable from any of the others.
299          */
300         if (uncoveredReturnTypes.size() &gt; 1) {
301             ProxyMethod pm = methods.get(0);
302             throw new IllegalArgumentException(
<a name="39" id="anc39"></a><span class="line-modified">303                     &quot;methods with same signature &quot; +</span>
<span class="line-modified">304                             pm.shortSignature +</span>
<span class="line-modified">305                             &quot; but incompatible return types: &quot; + uncoveredReturnTypes);</span>
306         }
307     }
308 
309     /**
<a name="40" id="anc40"></a><span class="line-modified">310      * Given the exceptions declared in the throws clause of a proxy method,</span>
<span class="line-modified">311      * compute the exceptions that need to be caught from the invocation</span>
<span class="line-modified">312      * handler&#39;s invoke method and rethrown intact in the method&#39;s</span>
<span class="line-added">313      * implementation before catching other Throwables and wrapping them</span>
<span class="line-added">314      * in UndeclaredThrowableExceptions.</span>
<span class="line-added">315      *</span>
<span class="line-added">316      * The exceptions to be caught are returned in a List object.  Each</span>
<span class="line-added">317      * exception in the returned list is guaranteed to not be a subclass of</span>
<span class="line-added">318      * any of the other exceptions in the list, so the catch blocks for</span>
<span class="line-added">319      * these exceptions may be generated in any order relative to each other.</span>
<span class="line-added">320      *</span>
<span class="line-added">321      * Error and RuntimeException are each always contained by the returned</span>
<span class="line-added">322      * list (if none of their superclasses are contained), since those</span>
<span class="line-added">323      * unchecked exceptions should always be rethrown intact, and thus their</span>
<span class="line-added">324      * subclasses will never appear in the returned list.</span>
<span class="line-added">325      *</span>
<span class="line-added">326      * The returned List will be empty if java.lang.Throwable is in the</span>
<span class="line-added">327      * given list of declared exceptions, indicating that no exceptions</span>
<span class="line-added">328      * need to be caught.</span>
329      */
<a name="41" id="anc41"></a><span class="line-modified">330     private static List&lt;Class&lt;?&gt;&gt; computeUniqueCatchList(Class&lt;?&gt;[] exceptions) {</span>
<span class="line-modified">331         List&lt;Class&lt;?&gt;&gt; uniqueList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">332         // unique exceptions to catch</span>






333 
<a name="42" id="anc42"></a><span class="line-modified">334         uniqueList.add(Error.class);            // always catch/rethrow these</span>
<span class="line-modified">335         uniqueList.add(RuntimeException.class);</span>





336 
<a name="43" id="anc43"></a><span class="line-modified">337         nextException:</span>
<span class="line-added">338         for (Class&lt;?&gt; ex : exceptions) {</span>
<span class="line-added">339             if (ex.isAssignableFrom(Throwable.class)) {</span>
<span class="line-added">340                 /*</span>
<span class="line-added">341                  * If Throwable is declared to be thrown by the proxy method,</span>
<span class="line-added">342                  * then no catch blocks are necessary, because the invoke</span>
<span class="line-added">343                  * can, at most, throw Throwable anyway.</span>
<span class="line-added">344                  */</span>
<span class="line-added">345                 uniqueList.clear();</span>
<span class="line-added">346                 break;</span>
<span class="line-added">347             } else if (!Throwable.class.isAssignableFrom(ex)) {</span>
<span class="line-added">348                 /*</span>
<span class="line-added">349                  * Ignore types that cannot be thrown by the invoke method.</span>
<span class="line-added">350                  */</span>
<span class="line-added">351                 continue;</span>
<span class="line-added">352             }</span>
353             /*
<a name="44" id="anc44"></a><span class="line-modified">354              * Compare this exception against the current list of</span>
<span class="line-modified">355              * exceptions that need to be caught:</span>
356              */
<a name="45" id="anc45"></a><span class="line-modified">357             for (int j = 0; j &lt; uniqueList.size(); ) {</span>
<span class="line-modified">358                 Class&lt;?&gt; ex2 = uniqueList.get(j);</span>
<span class="line-modified">359                 if (ex2.isAssignableFrom(ex)) {</span>
<span class="line-modified">360                     /*</span>
<span class="line-modified">361                      * if a superclass of this exception is already on</span>
<span class="line-modified">362                      * the list to catch, then ignore this one and continue;</span>
<span class="line-modified">363                      */</span>
<span class="line-modified">364                     continue nextException;</span>
<span class="line-added">365                 } else if (ex.isAssignableFrom(ex2)) {</span>
<span class="line-added">366                     /*</span>
<span class="line-added">367                      * if a subclass of this exception is on the list</span>
<span class="line-added">368                      * to catch, then remove it;</span>
<span class="line-added">369                      */</span>
<span class="line-added">370                     uniqueList.remove(j);</span>
<span class="line-added">371                 } else {</span>
<span class="line-added">372                     j++;        // else continue comparing.</span>
<span class="line-added">373                 }</span>
<span class="line-added">374             }</span>
<span class="line-added">375             // This exception is unique (so far): add it to the list to catch.</span>
<span class="line-added">376             uniqueList.add(ex);</span>
377         }
<a name="46" id="anc46"></a><span class="line-added">378         return uniqueList;</span>
379     }
380 
381     /**
<a name="47" id="anc47"></a><span class="line-modified">382      * Convert a fully qualified class name that uses &#39;.&#39; as the package</span>
<span class="line-modified">383      * separator, the external representation used by the Java language</span>
<span class="line-modified">384      * and APIs, to a fully qualified class name that uses &#39;/&#39; as the</span>
<span class="line-added">385      * package separator, the representation used in the class file</span>
<span class="line-added">386      * format (see JVMS section {@jvms 4.2}).</span>
387      */
<a name="48" id="anc48"></a><span class="line-modified">388     private static String dotToSlash(String name) {</span>
<span class="line-modified">389         return name.replace(&#39;.&#39;, &#39;/&#39;);</span>
<span class="line-modified">390     }</span>












391 
392     /**
<a name="49" id="anc49"></a><span class="line-modified">393      * Return the number of abstract &quot;words&quot;, or consecutive local variable</span>
<span class="line-modified">394      * indexes, required to contain a value of the given type.  See JVMS</span>
<span class="line-modified">395      * section 3.6.1.</span>
<span class="line-added">396      * &lt;p&gt;</span>
<span class="line-added">397      * Note that the original version of the JVMS contained a definition of</span>
<span class="line-added">398      * this abstract notion of a &quot;word&quot; in section 3.4, but that definition</span>
<span class="line-added">399      * was removed for the second edition.</span>
400      */
<a name="50" id="anc50"></a><span class="line-modified">401     private static int getWordsPerType(Class&lt;?&gt; type) {</span>
<span class="line-modified">402         if (type == long.class || type == double.class) {</span>
<span class="line-modified">403             return 2;</span>
<span class="line-modified">404         } else {</span>
<span class="line-modified">405             return 1;</span>



















406         }
<a name="51" id="anc51"></a><span class="line-added">407     }</span>
408 
<a name="52" id="anc52"></a><span class="line-modified">409     /**</span>
<span class="line-modified">410      * Add to the given list all of the types in the &quot;from&quot; array that</span>
<span class="line-modified">411      * are not already contained in the list and are assignable to at</span>
<span class="line-modified">412      * least one of the types in the &quot;with&quot; array.</span>
<span class="line-modified">413      * &lt;p&gt;</span>
<span class="line-modified">414      * This method is useful for computing the greatest common set of</span>
<span class="line-modified">415      * declared exceptions from duplicate methods inherited from</span>
<span class="line-modified">416      * different interfaces.</span>
<span class="line-modified">417      */</span>
<span class="line-modified">418     private static void collectCompatibleTypes(Class&lt;?&gt;[] from,</span>
<span class="line-modified">419                                                Class&lt;?&gt;[] with,</span>
<span class="line-modified">420                                                List&lt;Class&lt;?&gt;&gt; list) {</span>
<span class="line-modified">421         for (Class&lt;?&gt; fc : from) {</span>
<span class="line-modified">422             if (!list.contains(fc)) {</span>
<span class="line-modified">423                 for (Class&lt;?&gt; wc : with) {</span>
<span class="line-modified">424                     if (wc.isAssignableFrom(fc)) {</span>
<span class="line-modified">425                         list.add(fc);</span>
<span class="line-modified">426                         break;</span>
<span class="line-modified">427                     }</span>
<span class="line-modified">428                 }</span>


































429             }
430         }
<a name="53" id="anc53"></a>
431     }
432 
433     /**
<a name="54" id="anc54"></a><span class="line-modified">434      * Returns the {@link ClassLoader} to be used by the default implementation of {@link</span>
<span class="line-modified">435      * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}&#39;s runtime type by</span>
<span class="line-modified">436      * default.</span>
<span class="line-added">437      *</span>
<span class="line-added">438      * @return ClassLoader</span>
439      */
<a name="55" id="anc55"></a><span class="line-modified">440     protected ClassLoader getClassLoader() {</span>
<span class="line-modified">441         return loader;</span>
<span class="line-modified">442     }</span>





443 
<a name="56" id="anc56"></a><span class="line-modified">444     /**</span>
<span class="line-modified">445      * Generate a class file for the proxy class.  This method drives the</span>
<span class="line-modified">446      * class file generation process.</span>
<span class="line-modified">447      */</span>
<span class="line-modified">448     private byte[] generateClassFile() {</span>
<span class="line-modified">449         visit(V14, accessFlags, dotToSlash(className), null,</span>
<span class="line-modified">450                 JLR_PROXY, typeNames(interfaces));</span>




451 
<a name="57" id="anc57"></a><span class="line-modified">452         /*</span>
<span class="line-modified">453          * Add proxy methods for the hashCode, equals,</span>
<span class="line-modified">454          * and toString methods of java.lang.Object.  This is done before</span>
<span class="line-added">455          * the methods from the proxy interfaces so that the methods from</span>
<span class="line-added">456          * java.lang.Object take precedence over duplicate methods in the</span>
<span class="line-added">457          * proxy interfaces.</span>
458          */
<a name="58" id="anc58"></a><span class="line-modified">459         addProxyMethod(hashCodeMethod);</span>
<span class="line-modified">460         addProxyMethod(equalsMethod);</span>
<span class="line-modified">461         addProxyMethod(toStringMethod);</span>

462 
<a name="59" id="anc59"></a><span class="line-modified">463         /*</span>
<span class="line-modified">464          * Accumulate all of the methods from the proxy interfaces.</span>
<span class="line-modified">465          */</span>
<span class="line-modified">466         for (Class&lt;?&gt; intf : interfaces) {</span>
<span class="line-modified">467             for (Method m : intf.getMethods()) {</span>
<span class="line-added">468                 if (!Modifier.isStatic(m.getModifiers())) {</span>
<span class="line-added">469                     addProxyMethod(m, intf);</span>
<span class="line-added">470                 }</span>
471             }
<a name="60" id="anc60"></a><span class="line-modified">472         }</span>










473 
<a name="61" id="anc61"></a><span class="line-modified">474         /*</span>
<span class="line-added">475          * For each set of proxy methods with the same signature,</span>
<span class="line-added">476          * verify that the methods&#39; return types are compatible.</span>
<span class="line-added">477          */</span>
<span class="line-added">478         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-added">479             checkReturnTypes(sigmethods);</span>
<span class="line-added">480         }</span>
481 
<a name="62" id="anc62"></a><span class="line-modified">482         generateConstructor();</span>



483 
<a name="63" id="anc63"></a><span class="line-modified">484         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-added">485             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-added">486                 // add static field for the Method object</span>
<span class="line-added">487                 visitField(Modifier.PRIVATE | Modifier.STATIC, pm.methodFieldName,</span>
<span class="line-added">488                         LJLR_METHOD, null, null);</span>
489 
<a name="64" id="anc64"></a><span class="line-modified">490                 // Generate code for proxy method</span>
<span class="line-added">491                 pm.generateMethod(this, className);</span>
<span class="line-added">492             }</span>
<span class="line-added">493         }</span>
494 
<a name="65" id="anc65"></a><span class="line-modified">495         generateStaticInitializer();</span>

496 
<a name="66" id="anc66"></a><span class="line-modified">497         return toByteArray();</span>
<span class="line-added">498     }</span>
499 
<a name="67" id="anc67"></a><span class="line-modified">500     /**</span>
<span class="line-added">501      * Add another method to be proxied, either by creating a new</span>
<span class="line-added">502      * ProxyMethod object or augmenting an old one for a duplicate</span>
<span class="line-added">503      * method.</span>
<span class="line-added">504      *</span>
<span class="line-added">505      * &quot;fromClass&quot; indicates the proxy interface that the method was</span>
<span class="line-added">506      * found through, which may be different from (a subinterface of)</span>
<span class="line-added">507      * the method&#39;s &quot;declaring class&quot;.  Note that the first Method</span>
<span class="line-added">508      * object passed for a given name and descriptor identifies the</span>
<span class="line-added">509      * Method object (and thus the declaring class) that will be</span>
<span class="line-added">510      * passed to the invocation handler&#39;s &quot;invoke&quot; method for a given</span>
<span class="line-added">511      * set of duplicate methods.</span>
<span class="line-added">512      */</span>
<span class="line-added">513     private void addProxyMethod(Method m, Class&lt;?&gt; fromClass) {</span>
<span class="line-added">514         Class&lt;?&gt; returnType = m.getReturnType();</span>
<span class="line-added">515         Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span>
516 
<a name="68" id="anc68"></a><span class="line-modified">517         String sig = m.toShortSignature();</span>
<span class="line-added">518         List&lt;ProxyMethod&gt; sigmethods = proxyMethods.computeIfAbsent(sig,</span>
<span class="line-added">519                 (f) -&gt; new ArrayList&lt;&gt;(3));</span>
<span class="line-added">520         for (ProxyMethod pm : sigmethods) {</span>
<span class="line-added">521             if (returnType == pm.returnType) {</span>
<span class="line-added">522                 /*</span>
<span class="line-added">523                  * Found a match: reduce exception types to the</span>
<span class="line-added">524                  * greatest set of exceptions that can be thrown</span>
<span class="line-added">525                  * compatibly with the throws clauses of both</span>
<span class="line-added">526                  * overridden methods.</span>
<span class="line-added">527                  */</span>
<span class="line-added">528                 List&lt;Class&lt;?&gt;&gt; legalExceptions = new ArrayList&lt;&gt;();</span>
<span class="line-added">529                 collectCompatibleTypes(</span>
<span class="line-added">530                         exceptionTypes, pm.exceptionTypes, legalExceptions);</span>
<span class="line-added">531                 collectCompatibleTypes(</span>
<span class="line-added">532                         pm.exceptionTypes, exceptionTypes, legalExceptions);</span>
<span class="line-added">533                 pm.exceptionTypes = legalExceptions.toArray(EMPTY_CLASS_ARRAY);</span>
<span class="line-added">534                 return;</span>
<span class="line-added">535             }</span>
<span class="line-added">536         }</span>
<span class="line-added">537         sigmethods.add(new ProxyMethod(m, sig, m.getParameterTypes(), returnType,</span>
<span class="line-added">538                 exceptionTypes, fromClass,</span>
<span class="line-added">539                 &quot;m&quot; + proxyMethodCount++));</span>
<span class="line-added">540     }</span>
541 
<a name="69" id="anc69"></a><span class="line-modified">542     /**</span>
<span class="line-added">543      * Add an existing ProxyMethod (hashcode, equals, toString).</span>
<span class="line-added">544      *</span>
<span class="line-added">545      * @param pm an existing ProxyMethod</span>
<span class="line-added">546      */</span>
<span class="line-added">547     private void addProxyMethod(ProxyMethod pm) {</span>
<span class="line-added">548         String sig = pm.shortSignature;</span>
<span class="line-added">549         List&lt;ProxyMethod&gt; sigmethods = proxyMethods.computeIfAbsent(sig,</span>
<span class="line-added">550                 (f) -&gt; new ArrayList&lt;&gt;(3));</span>
<span class="line-added">551         sigmethods.add(pm);</span>
<span class="line-added">552     }</span>
553 
<a name="70" id="anc70"></a><span class="line-modified">554     /**</span>
<span class="line-modified">555      * Generate the constructor method for the proxy class.</span>
<span class="line-modified">556      */</span>
<span class="line-added">557     private void generateConstructor() {</span>
<span class="line-added">558         MethodVisitor ctor = visitMethod(Modifier.PUBLIC, NAME_CTOR,</span>
<span class="line-added">559                 MJLR_INVOCATIONHANDLER, null, null);</span>
<span class="line-added">560         ctor.visitParameter(null, 0);</span>
<span class="line-added">561         ctor.visitCode();</span>
<span class="line-added">562         ctor.visitVarInsn(ALOAD, 0);</span>
<span class="line-added">563         ctor.visitVarInsn(ALOAD, 1);</span>
<span class="line-added">564         ctor.visitMethodInsn(INVOKESPECIAL, JLR_PROXY, NAME_CTOR,</span>
<span class="line-added">565                 MJLR_INVOCATIONHANDLER, false);</span>
<span class="line-added">566         ctor.visitInsn(RETURN);</span>
<span class="line-added">567 </span>
<span class="line-added">568         // Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored</span>
<span class="line-added">569         ctor.visitMaxs(-1, -1);</span>
<span class="line-added">570         ctor.visitEnd();</span>
<span class="line-added">571     }</span>
572 
<a name="71" id="anc71"></a><span class="line-modified">573     /**</span>
<span class="line-modified">574      * Generate the static initializer method for the proxy class.</span>
<span class="line-added">575      */</span>
<span class="line-added">576     private void generateStaticInitializer() {</span>
<span class="line-added">577 </span>
<span class="line-added">578         MethodVisitor mv = visitMethod(Modifier.STATIC, NAME_CLINIT,</span>
<span class="line-added">579                 &quot;()V&quot;, null, null);</span>
<span class="line-added">580         mv.visitCode();</span>
<span class="line-added">581         Label L_startBlock = new Label();</span>
<span class="line-added">582         Label L_endBlock = new Label();</span>
<span class="line-added">583         Label L_NoMethodHandler = new Label();</span>
<span class="line-added">584         Label L_NoClassHandler = new Label();</span>
<span class="line-added">585 </span>
<span class="line-added">586         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoMethodHandler,</span>
<span class="line-added">587                 JL_NO_SUCH_METHOD_EX);</span>
<span class="line-added">588         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoClassHandler,</span>
<span class="line-added">589                 JL_CLASS_NOT_FOUND_EX);</span>
<span class="line-added">590 </span>
<span class="line-added">591         mv.visitLabel(L_startBlock);</span>
<span class="line-added">592         for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {</span>
<span class="line-added">593             for (ProxyMethod pm : sigmethods) {</span>
<span class="line-added">594                 pm.codeFieldInitialization(mv, className);</span>
<span class="line-added">595             }</span>
<span class="line-added">596         }</span>
<span class="line-added">597         mv.visitInsn(RETURN);</span>
<span class="line-added">598         mv.visitLabel(L_endBlock);</span>
<span class="line-added">599         // Generate exception handler</span>
<span class="line-added">600 </span>
<span class="line-added">601         mv.visitLabel(L_NoMethodHandler);</span>
<span class="line-added">602         mv.visitVarInsn(ASTORE, 1);</span>
<span class="line-added">603         mv.visitTypeInsn(Opcodes.NEW, JL_NO_SUCH_METHOD_ERROR);</span>
<span class="line-added">604         mv.visitInsn(DUP);</span>
<span class="line-added">605         mv.visitVarInsn(ALOAD, 1);</span>
<span class="line-added">606         mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,</span>
<span class="line-added">607                 &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;, false);</span>
<span class="line-added">608         mv.visitMethodInsn(INVOKESPECIAL, JL_NO_SUCH_METHOD_ERROR,</span>
<span class="line-added">609                 &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);</span>
<span class="line-added">610         mv.visitInsn(ATHROW);</span>
<span class="line-added">611 </span>
<span class="line-added">612         mv.visitLabel(L_NoClassHandler);</span>
<span class="line-added">613         mv.visitVarInsn(ASTORE, 1);</span>
<span class="line-added">614         mv.visitTypeInsn(Opcodes.NEW, JL_NO_CLASS_DEF_FOUND_ERROR);</span>
<span class="line-added">615         mv.visitInsn(DUP);</span>
<span class="line-added">616         mv.visitVarInsn(ALOAD, 1);</span>
<span class="line-added">617         mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,</span>
<span class="line-added">618                 &quot;getMessage&quot;, &quot;()Ljava/lang/String;&quot;, false);</span>
<span class="line-added">619         mv.visitMethodInsn(INVOKESPECIAL, JL_NO_CLASS_DEF_FOUND_ERROR,</span>
<span class="line-added">620                 &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);</span>
<span class="line-added">621         mv.visitInsn(ATHROW);</span>
<span class="line-added">622 </span>
<span class="line-added">623         // Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored</span>
<span class="line-added">624         mv.visitMaxs(-1, -1);</span>
<span class="line-added">625         mv.visitEnd();</span>
<span class="line-added">626     }</span>
627 
<a name="72" id="anc72"></a><span class="line-modified">628     /**</span>
<span class="line-modified">629      * A ProxyMethod object represents a proxy method in the proxy class</span>
<span class="line-modified">630      * being generated: a method whose implementation will encode and</span>
<span class="line-modified">631      * dispatch invocations to the proxy instance&#39;s invocation handler.</span>
<span class="line-modified">632      */</span>
<span class="line-modified">633     private static class ProxyMethod {</span>


634 
<a name="73" id="anc73"></a><span class="line-modified">635         private final Method method;</span>
<span class="line-added">636         private final String shortSignature;</span>
<span class="line-added">637         private final Class&lt;?&gt; fromClass;</span>
<span class="line-added">638         private final Class&lt;?&gt;[] parameterTypes;</span>
<span class="line-added">639         private final Class&lt;?&gt; returnType;</span>
<span class="line-added">640         private final String methodFieldName;</span>
<span class="line-added">641         private Class&lt;?&gt;[] exceptionTypes;</span>
642 
<a name="74" id="anc74"></a><span class="line-modified">643         private ProxyMethod(Method method, String sig, Class&lt;?&gt;[] parameterTypes,</span>
<span class="line-added">644                             Class&lt;?&gt; returnType, Class&lt;?&gt;[] exceptionTypes,</span>
<span class="line-added">645                             Class&lt;?&gt; fromClass, String methodFieldName) {</span>
<span class="line-added">646             this.method = method;</span>
<span class="line-added">647             this.shortSignature = sig;</span>
<span class="line-added">648             this.parameterTypes = parameterTypes;</span>
<span class="line-added">649             this.returnType = returnType;</span>
<span class="line-added">650             this.exceptionTypes = exceptionTypes;</span>
<span class="line-added">651             this.fromClass = fromClass;</span>
<span class="line-added">652             this.methodFieldName = methodFieldName;</span>
<span class="line-added">653         }</span>
654 
<a name="75" id="anc75"></a><span class="line-modified">655         /**</span>
<span class="line-added">656          * Create a new specific ProxyMethod with a specific field name</span>
<span class="line-added">657          *</span>
<span class="line-added">658          * @param method          The method for which to create a proxy</span>
<span class="line-added">659          * @param methodFieldName the fieldName to generate</span>
<span class="line-added">660          */</span>
<span class="line-added">661         private ProxyMethod(Method method, String methodFieldName) {</span>
<span class="line-added">662             this(method, method.toShortSignature(),</span>
<span class="line-added">663                     method.getParameterTypes(), method.getReturnType(),</span>
<span class="line-added">664                     method.getExceptionTypes(), method.getDeclaringClass(), methodFieldName);</span>
<span class="line-added">665         }</span>
666 
<a name="76" id="anc76"></a><span class="line-modified">667         /**</span>
<span class="line-added">668          * Generate this method, including the code and exception table entry.</span>
<span class="line-added">669          */</span>
<span class="line-added">670         private void generateMethod(ClassWriter cw, String className) {</span>
<span class="line-added">671             MethodType mt = MethodType.methodType(returnType, parameterTypes);</span>
<span class="line-added">672             String desc = mt.toMethodDescriptorString();</span>
<span class="line-added">673             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_FINAL,</span>
<span class="line-added">674                     method.getName(), desc, null,</span>
<span class="line-added">675                     typeNames(Arrays.asList(exceptionTypes)));</span>
676 
<a name="77" id="anc77"></a><span class="line-modified">677             int[] parameterSlot = new int[parameterTypes.length];</span>
<span class="line-added">678             int nextSlot = 1;</span>
<span class="line-added">679             for (int i = 0; i &lt; parameterSlot.length; i++) {</span>
<span class="line-added">680                 parameterSlot[i] = nextSlot;</span>
<span class="line-added">681                 nextSlot += getWordsPerType(parameterTypes[i]);</span>
682             }
683 
<a name="78" id="anc78"></a><span class="line-modified">684             mv.visitCode();</span>
<span class="line-added">685             Label L_startBlock = new Label();</span>
<span class="line-added">686             Label L_endBlock = new Label();</span>
<span class="line-added">687             Label L_RuntimeHandler = new Label();</span>
<span class="line-added">688             Label L_ThrowableHandler = new Label();</span>
689 
690             List&lt;Class&lt;?&gt;&gt; catchList = computeUniqueCatchList(exceptionTypes);
691             if (catchList.size() &gt; 0) {
<a name="79" id="anc79"></a>
692                 for (Class&lt;?&gt; ex : catchList) {
<a name="80" id="anc80"></a><span class="line-modified">693                     mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_RuntimeHandler,</span>
<span class="line-modified">694                             dotToSlash(ex.getName()));</span>

695                 }
696 
<a name="81" id="anc81"></a><span class="line-modified">697                 mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_ThrowableHandler,</span>
<span class="line-modified">698                         JL_THROWABLE);</span>
<span class="line-modified">699             }</span>
<span class="line-modified">700             mv.visitLabel(L_startBlock);</span>










701 
<a name="82" id="anc82"></a><span class="line-modified">702             mv.visitVarInsn(ALOAD, 0);</span>
<span class="line-added">703             mv.visitFieldInsn(GETFIELD, JLR_PROXY, handlerFieldName,</span>
<span class="line-added">704                     LJLR_INVOCATION_HANDLER);</span>
<span class="line-added">705             mv.visitVarInsn(ALOAD, 0);</span>
<span class="line-added">706             mv.visitFieldInsn(GETSTATIC, dotToSlash(className), methodFieldName,</span>
<span class="line-added">707                     LJLR_METHOD);</span>
708 
<a name="83" id="anc83"></a><span class="line-modified">709             if (parameterTypes.length &gt; 0) {</span>
<span class="line-added">710                 // Create an array and fill with the parameters converting primitives to wrappers</span>
<span class="line-added">711                 emitIconstInsn(mv, parameterTypes.length);</span>
<span class="line-added">712                 mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_OBJECT);</span>
<span class="line-added">713                 for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="line-added">714                     mv.visitInsn(DUP);</span>
<span class="line-added">715                     emitIconstInsn(mv, i);</span>
<span class="line-added">716                     codeWrapArgument(mv, parameterTypes[i], parameterSlot[i]);</span>
<span class="line-added">717                     mv.visitInsn(Opcodes.AASTORE);</span>
<span class="line-added">718                 }</span>
<span class="line-added">719             } else {</span>
<span class="line-added">720                 mv.visitInsn(Opcodes.ACONST_NULL);</span>
<span class="line-added">721             }</span>
722 
<a name="84" id="anc84"></a><span class="line-modified">723             mv.visitMethodInsn(INVOKEINTERFACE, JLR_INVOCATION_HANDLER,</span>
<span class="line-modified">724                     &quot;invoke&quot;,</span>
<span class="line-modified">725                     &quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;&quot; +</span>
<span class="line-added">726                             &quot;[Ljava/lang/Object;)Ljava/lang/Object;&quot;, true);</span>
727 
<a name="85" id="anc85"></a><span class="line-modified">728             if (returnType == void.class) {</span>
<span class="line-added">729                 mv.visitInsn(POP);</span>
<span class="line-added">730                 mv.visitInsn(RETURN);</span>
<span class="line-added">731             } else {</span>
<span class="line-added">732                 codeUnwrapReturnValue(mv, returnType);</span>
733             }
734 
<a name="86" id="anc86"></a><span class="line-modified">735             mv.visitLabel(L_endBlock);</span>


736 
<a name="87" id="anc87"></a><span class="line-modified">737             // Generate exception handler</span>
<span class="line-modified">738             mv.visitLabel(L_RuntimeHandler);</span>
<span class="line-modified">739             mv.visitInsn(ATHROW);   // just rethrow the exception</span>




740 
<a name="88" id="anc88"></a><span class="line-modified">741             mv.visitLabel(L_ThrowableHandler);</span>
<span class="line-added">742             mv.visitVarInsn(ASTORE, 1);</span>
<span class="line-added">743             mv.visitTypeInsn(Opcodes.NEW, JLR_UNDECLARED_THROWABLE_EX);</span>
<span class="line-added">744             mv.visitInsn(DUP);</span>
<span class="line-added">745             mv.visitVarInsn(ALOAD, 1);</span>
<span class="line-added">746             mv.visitMethodInsn(INVOKESPECIAL, JLR_UNDECLARED_THROWABLE_EX,</span>
<span class="line-added">747                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/Throwable;)V&quot;, false);</span>
<span class="line-added">748             mv.visitInsn(ATHROW);</span>
<span class="line-added">749             // Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored</span>
<span class="line-added">750             mv.visitMaxs(-1, -1);</span>
<span class="line-added">751             mv.visitEnd();</span>
752         }
753 
754         /**
755          * Generate code for wrapping an argument of the given type
756          * whose value can be found at the specified local variable
757          * index, in order for it to be passed (as an Object) to the
<a name="89" id="anc89"></a><span class="line-modified">758          * invocation handler&#39;s &quot;invoke&quot; method.</span>

759          */
<a name="90" id="anc90"></a><span class="line-modified">760         private void codeWrapArgument(MethodVisitor mv, Class&lt;?&gt; type, int slot) {</span>



761             if (type.isPrimitive()) {
762                 PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
763 
764                 if (type == int.class ||
<a name="91" id="anc91"></a><span class="line-modified">765                         type == boolean.class ||</span>
<span class="line-modified">766                         type == byte.class ||</span>
<span class="line-modified">767                         type == char.class ||</span>
<span class="line-modified">768                         type == short.class) {</span>
<span class="line-modified">769                     mv.visitVarInsn(ILOAD, slot);</span>

770                 } else if (type == long.class) {
<a name="92" id="anc92"></a><span class="line-modified">771                     mv.visitVarInsn(LLOAD, slot);</span>
772                 } else if (type == float.class) {
<a name="93" id="anc93"></a><span class="line-modified">773                     mv.visitVarInsn(FLOAD, slot);</span>
774                 } else if (type == double.class) {
<a name="94" id="anc94"></a><span class="line-modified">775                     mv.visitVarInsn(DLOAD, slot);</span>
776                 } else {
777                     throw new AssertionError();
778                 }
<a name="95" id="anc95"></a><span class="line-modified">779                 mv.visitMethodInsn(INVOKESTATIC, prim.wrapperClassName, &quot;valueOf&quot;,</span>
<span class="line-modified">780                         prim.wrapperValueOfDesc, false);</span>




781             } else {
<a name="96" id="anc96"></a><span class="line-modified">782                 mv.visitVarInsn(ALOAD, slot);</span>

783             }
784         }
785 
786         /**
787          * Generate code for unwrapping a return value of the given
788          * type from the invocation handler&#39;s &quot;invoke&quot; method (as type
<a name="97" id="anc97"></a><span class="line-modified">789          * Object) to its correct type.</span>

790          */
<a name="98" id="anc98"></a><span class="line-modified">791         private void codeUnwrapReturnValue(MethodVisitor mv, Class&lt;?&gt; type) {</span>


792             if (type.isPrimitive()) {
793                 PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(type);
794 
<a name="99" id="anc99"></a><span class="line-modified">795                 mv.visitTypeInsn(CHECKCAST, prim.wrapperClassName);</span>
<span class="line-modified">796                 mv.visitMethodInsn(INVOKEVIRTUAL,</span>
<span class="line-modified">797                         prim.wrapperClassName,</span>
<span class="line-modified">798                         prim.unwrapMethodName, prim.unwrapMethodDesc, false);</span>



799 
800                 if (type == int.class ||
<a name="100" id="anc100"></a><span class="line-modified">801                         type == boolean.class ||</span>
<span class="line-modified">802                         type == byte.class ||</span>
<span class="line-modified">803                         type == char.class ||</span>
<span class="line-modified">804                         type == short.class) {</span>
<span class="line-modified">805                     mv.visitInsn(IRETURN);</span>

806                 } else if (type == long.class) {
<a name="101" id="anc101"></a><span class="line-modified">807                     mv.visitInsn(LRETURN);</span>
808                 } else if (type == float.class) {
<a name="102" id="anc102"></a><span class="line-modified">809                     mv.visitInsn(FRETURN);</span>
810                 } else if (type == double.class) {
<a name="103" id="anc103"></a><span class="line-modified">811                     mv.visitInsn(DRETURN);</span>
812                 } else {
813                     throw new AssertionError();
814                 }
<a name="104" id="anc104"></a>
815             } else {
<a name="105" id="anc105"></a><span class="line-modified">816                 mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));</span>
<span class="line-modified">817                 mv.visitInsn(ARETURN);</span>



818             }
819         }
820 
821         /**
822          * Generate code for initializing the static field that stores
<a name="106" id="anc106"></a><span class="line-modified">823          * the Method object for this proxy method.</span>

824          */
<a name="107" id="anc107"></a><span class="line-modified">825         private void codeFieldInitialization(MethodVisitor mv, String className) {</span>
<span class="line-modified">826             codeClassForName(mv, fromClass);</span>


827 
<a name="108" id="anc108"></a><span class="line-modified">828             mv.visitLdcInsn(method.getName());</span>
829 
<a name="109" id="anc109"></a><span class="line-modified">830             emitIconstInsn(mv, parameterTypes.length);</span>
831 
<a name="110" id="anc110"></a><span class="line-modified">832             mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_CLASS);</span>

833 
<a name="111" id="anc111"></a><span class="line-added">834             // Construct an array with the parameter types mapping primitives to Wrapper types</span>
835             for (int i = 0; i &lt; parameterTypes.length; i++) {
<a name="112" id="anc112"></a><span class="line-modified">836                 mv.visitInsn(DUP);</span>
<span class="line-modified">837                 emitIconstInsn(mv, i);</span>


838 
839                 if (parameterTypes[i].isPrimitive()) {
840                     PrimitiveTypeInfo prim =
<a name="113" id="anc113"></a><span class="line-modified">841                             PrimitiveTypeInfo.get(parameterTypes[i]);</span>
<span class="line-modified">842                     mv.visitFieldInsn(GETSTATIC,</span>
<span class="line-modified">843                             prim.wrapperClassName, &quot;TYPE&quot;, LJL_CLASS);</span>



844                 } else {
<a name="114" id="anc114"></a><span class="line-modified">845                     codeClassForName(mv, parameterTypes[i]);</span>
846                 }
<a name="115" id="anc115"></a><span class="line-modified">847                 mv.visitInsn(Opcodes.AASTORE);</span>

848             }
<a name="116" id="anc116"></a><span class="line-added">849             // lookup the method</span>
<span class="line-added">850             mv.visitMethodInsn(INVOKEVIRTUAL,</span>
<span class="line-added">851                     JL_CLASS,</span>
<span class="line-added">852                     &quot;getMethod&quot;,</span>
<span class="line-added">853                     &quot;(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;&quot;,</span>
<span class="line-added">854                     false);</span>
855 
<a name="117" id="anc117"></a><span class="line-modified">856             mv.visitFieldInsn(PUTSTATIC,</span>
<span class="line-modified">857                     dotToSlash(className),</span>
<span class="line-modified">858                     methodFieldName, LJLR_METHOD);</span>








859         }
<a name="118" id="anc118"></a>












860 
<a name="119" id="anc119"></a><span class="line-modified">861         /*</span>
<span class="line-modified">862          * =============== Code Generation Utility Methods ===============</span>
<span class="line-modified">863          */</span>






















864 
<a name="120" id="anc120"></a><span class="line-modified">865         /**</span>
<span class="line-added">866          * Generate code to invoke the Class.forName with the name of the given</span>
<span class="line-added">867          * class to get its Class object at runtime.  The code is written to</span>
<span class="line-added">868          * the supplied stream.  Note that the code generated by this method</span>
<span class="line-added">869          * may cause the checked ClassNotFoundException to be thrown.</span>
<span class="line-added">870          */</span>
<span class="line-added">871         private void codeClassForName(MethodVisitor mv, Class&lt;?&gt; cl) {</span>
<span class="line-added">872             mv.visitLdcInsn(cl.getName());</span>
<span class="line-added">873             mv.visitMethodInsn(INVOKESTATIC,</span>
<span class="line-added">874                     JL_CLASS,</span>
<span class="line-added">875                     &quot;forName&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;, false);</span>
<span class="line-added">876         }</span>
877 
<a name="121" id="anc121"></a><span class="line-modified">878         /**</span>
<span class="line-modified">879          * Visit a bytecode for a constant.</span>
<span class="line-modified">880          *</span>
<span class="line-added">881          * @param mv  The MethodVisitor</span>
<span class="line-added">882          * @param cst The constant value</span>
<span class="line-added">883          */</span>
<span class="line-added">884         private void emitIconstInsn(MethodVisitor mv, final int cst) {</span>
<span class="line-added">885             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {</span>
<span class="line-added">886                 mv.visitInsn(Opcodes.ICONST_0 + cst);</span>
<span class="line-added">887             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {</span>
<span class="line-added">888                 mv.visitIntInsn(Opcodes.BIPUSH, cst);</span>
<span class="line-added">889             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {</span>
<span class="line-added">890                 mv.visitIntInsn(Opcodes.SIPUSH, cst);</span>
<span class="line-added">891             } else {</span>
<span class="line-added">892                 mv.visitLdcInsn(cst);</span>
893             }
894         }
895 
<a name="122" id="anc122"></a><span class="line-modified">896         @Override</span>
<span class="line-modified">897         public String toString() {</span>
<span class="line-modified">898             return method.toShortString();</span>




















































899         }
<a name="123" id="anc123"></a>





900     }
901 
<a name="124" id="anc124"></a><span class="line-modified">902     /**</span>
<span class="line-modified">903      * A PrimitiveTypeInfo object contains assorted information about</span>
<span class="line-modified">904      * a primitive type in its public fields.  The struct for a particular</span>
<span class="line-modified">905      * primitive type can be obtained using the static &quot;get&quot; method.</span>





906      */
<a name="125" id="anc125"></a><span class="line-added">907     private static class PrimitiveTypeInfo {</span>
908 
<a name="126" id="anc126"></a><span class="line-modified">909         private static Map&lt;Class&lt;?&gt;, PrimitiveTypeInfo&gt; table = new HashMap&lt;&gt;();</span>
















910 
<a name="127" id="anc127"></a><span class="line-modified">911         static {</span>
<span class="line-modified">912             add(byte.class, Byte.class);</span>
<span class="line-modified">913             add(char.class, Character.class);</span>
<span class="line-modified">914             add(double.class, Double.class);</span>
<span class="line-modified">915             add(float.class, Float.class);</span>
<span class="line-added">916             add(int.class, Integer.class);</span>
<span class="line-added">917             add(long.class, Long.class);</span>
<span class="line-added">918             add(short.class, Short.class);</span>
<span class="line-added">919             add(boolean.class, Boolean.class);</span>
<span class="line-added">920         }</span>
921 
<a name="128" id="anc128"></a><span class="line-modified">922         /**</span>
<span class="line-modified">923          * name of corresponding wrapper class</span>
<span class="line-modified">924          */</span>
<span class="line-modified">925         private String wrapperClassName;</span>
<span class="line-modified">926         /**</span>
<span class="line-added">927          * method descriptor for wrapper class &quot;valueOf&quot; factory method</span>
<span class="line-added">928          */</span>
<span class="line-added">929         private String wrapperValueOfDesc;</span>
<span class="line-added">930         /**</span>
<span class="line-added">931          * name of wrapper class method for retrieving primitive value</span>
<span class="line-added">932          */</span>
<span class="line-added">933         private String unwrapMethodName;</span>
<span class="line-added">934         /**</span>
<span class="line-added">935          * descriptor of same method</span>
<span class="line-added">936          */</span>
<span class="line-added">937         private String unwrapMethodDesc;</span>
938 
<a name="129" id="anc129"></a><span class="line-modified">939         private PrimitiveTypeInfo(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-modified">940             assert primitiveClass.isPrimitive();</span>



























941 
<a name="130" id="anc130"></a><span class="line-modified">942             /**</span>
<span class="line-modified">943              * &quot;base type&quot; used in various descriptors (see JVMS section 4.3.2)</span>





















944              */
<a name="131" id="anc131"></a><span class="line-modified">945             String baseTypeString =</span>
<span class="line-modified">946                     Array.newInstance(primitiveClass, 0)</span>
<span class="line-modified">947                             .getClass().getName().substring(1);</span>
<span class="line-modified">948             wrapperClassName = dotToSlash(wrapperClass.getName());</span>
<span class="line-modified">949             wrapperValueOfDesc =</span>
<span class="line-modified">950                     &quot;(&quot; + baseTypeString + &quot;)L&quot; + wrapperClassName + &quot;;&quot;;</span>
<span class="line-modified">951             unwrapMethodName = primitiveClass.getName() + &quot;Value&quot;;</span>
<span class="line-modified">952             unwrapMethodDesc = &quot;()&quot; + baseTypeString;</span>













953         }
<a name="132" id="anc132"></a>
954 
<a name="133" id="anc133"></a><span class="line-modified">955         private static void add(Class&lt;?&gt; primitiveClass, Class&lt;?&gt; wrapperClass) {</span>
<span class="line-modified">956             table.put(primitiveClass,</span>
<span class="line-modified">957                     new PrimitiveTypeInfo(primitiveClass, wrapperClass));</span>





































































































































































































































































































958         }
959 
960         public static PrimitiveTypeInfo get(Class&lt;?&gt; cl) {
961             return table.get(cl);
962         }
963     }
<a name="134" id="anc134"></a>


















































































































































































































































































































































964 }
<a name="135" id="anc135"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="135" type="hidden" />
</body>
</html>
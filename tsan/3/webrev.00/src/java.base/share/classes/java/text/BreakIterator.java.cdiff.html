<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/text/BreakIterator.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Bidi.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CalendarBuilder.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/text/BreakIterator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,27 ***</span>
  import sun.util.locale.provider.LocaleProviderAdapter;
  import sun.util.locale.provider.LocaleServiceProviderPool;
  
  
  /**
<span class="line-modified">!  * The &lt;code&gt;BreakIterator&lt;/code&gt; class implements methods for finding</span>
<span class="line-modified">!  * the location of boundaries in text. Instances of &lt;code&gt;BreakIterator&lt;/code&gt;</span>
   * maintain a current position and scan over text
   * returning the index of characters where boundaries occur.
<span class="line-modified">!  * Internally, &lt;code&gt;BreakIterator&lt;/code&gt; scans text using a</span>
<span class="line-modified">!  * &lt;code&gt;CharacterIterator&lt;/code&gt;, and is thus able to scan text held</span>
<span class="line-modified">!  * by any object implementing that protocol. A &lt;code&gt;StringCharacterIterator&lt;/code&gt;</span>
<span class="line-modified">!  * is used to scan &lt;code&gt;String&lt;/code&gt; objects passed to &lt;code&gt;setText&lt;/code&gt;.</span>
   *
   * &lt;p&gt;
   * You use the factory methods provided by this class to create
   * instances of various types of break iterators. In particular,
<span class="line-modified">!  * use &lt;code&gt;getWordInstance&lt;/code&gt;, &lt;code&gt;getLineInstance&lt;/code&gt;,</span>
<span class="line-modified">!  * &lt;code&gt;getSentenceInstance&lt;/code&gt;, and &lt;code&gt;getCharacterInstance&lt;/code&gt;</span>
<span class="line-modified">!  * to create &lt;code&gt;BreakIterator&lt;/code&gt;s that perform</span>
   * word, line, sentence, and character boundary analysis respectively.
<span class="line-modified">!  * A single &lt;code&gt;BreakIterator&lt;/code&gt; can work only on one unit</span>
   * (word, line, sentence, and so on). You must use a different iterator
   * for each unit boundary analysis you wish to perform.
   *
   * &lt;p&gt;&lt;a id=&quot;line&quot;&gt;&lt;/a&gt;
   * Line boundary analysis determines where a text string can be
<span class="line-new-header">--- 46,27 ---</span>
  import sun.util.locale.provider.LocaleProviderAdapter;
  import sun.util.locale.provider.LocaleServiceProviderPool;
  
  
  /**
<span class="line-modified">!  * The {@code BreakIterator} class implements methods for finding</span>
<span class="line-modified">!  * the location of boundaries in text. Instances of {@code BreakIterator}</span>
   * maintain a current position and scan over text
   * returning the index of characters where boundaries occur.
<span class="line-modified">!  * Internally, {@code BreakIterator} scans text using a</span>
<span class="line-modified">!  * {@code CharacterIterator}, and is thus able to scan text held</span>
<span class="line-modified">!  * by any object implementing that protocol. A {@code StringCharacterIterator}</span>
<span class="line-modified">!  * is used to scan {@code String} objects passed to {@code setText}.</span>
   *
   * &lt;p&gt;
   * You use the factory methods provided by this class to create
   * instances of various types of break iterators. In particular,
<span class="line-modified">!  * use {@code getWordInstance}, {@code getLineInstance},</span>
<span class="line-modified">!  * {@code getSentenceInstance}, and {@code getCharacterInstance}</span>
<span class="line-modified">!  * to create {@code BreakIterator}s that perform</span>
   * word, line, sentence, and character boundary analysis respectively.
<span class="line-modified">!  * A single {@code BreakIterator} can work only on one unit</span>
   * (word, line, sentence, and so on). You must use a different iterator
   * for each unit boundary analysis you wish to perform.
   *
   * &lt;p&gt;&lt;a id=&quot;line&quot;&gt;&lt;/a&gt;
   * Line boundary analysis determines where a text string can be
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,11 ***</span>
   * For example, an accented character might be stored as a base character
   * and a diacritical mark. What users consider to be a character can
   * differ between languages.
   *
   * &lt;p&gt;
<span class="line-modified">!  * The &lt;code&gt;BreakIterator&lt;/code&gt; instances returned by the factory methods</span>
   * of this class are intended for use with natural languages only, not for
   * programming language text. It is however possible to define subclasses
   * that tokenize a programming language.
   *
   * &lt;P&gt;
<span class="line-new-header">--- 98,11 ---</span>
   * For example, an accented character might be stored as a base character
   * and a diacritical mark. What users consider to be a character can
   * differ between languages.
   *
   * &lt;p&gt;
<span class="line-modified">!  * The {@code BreakIterator} instances returned by the factory methods</span>
   * of this class are intended for use with natural languages only, not for
   * programming language text. It is however possible to define subclasses
   * that tokenize a programming language.
   *
   * &lt;P&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,80 ***</span>
      public abstract int last();
  
      /**
       * Returns the nth boundary from the current boundary. If either
       * the first or last text boundary has been reached, it returns
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the current position is set to either</span>
       * the first or last text boundary depending on which one is reached. Otherwise,
       * the iterator&#39;s current position is set to the new boundary.
       * For example, if the iterator&#39;s current position is the mth text boundary
       * and three more boundaries exist from the current boundary to the last text
       * boundary, the next(2) call will return m + 2. The new text position is set
       * to the (m + 2)th text boundary. A next(4) call would return
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the last text boundary would become the</span>
       * new text position.
       * @param n which boundary to return.  A value of 0
       * does nothing.  Negative values move to previous boundaries
       * and positive values move to later boundaries.
       * @return The character index of the nth boundary from the current position
<span class="line-modified">!      * or &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if either first or last text boundary</span>
       * has been reached.
       */
      public abstract int next(int n);
  
      /**
       * Returns the boundary following the current boundary. If the current boundary
<span class="line-modified">!      * is the last text boundary, it returns &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and</span>
       * the iterator&#39;s current position is unchanged. Otherwise, the iterator&#39;s
       * current position is set to the boundary following the current boundary.
       * @return The character index of the next text boundary or
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the last text</span>
       * boundary.
       * Equivalent to next(1).
       * @see #next(int)
       */
      public abstract int next();
  
      /**
       * Returns the boundary preceding the current boundary. If the current boundary
<span class="line-modified">!      * is the first text boundary, it returns &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and</span>
       * the iterator&#39;s current position is unchanged. Otherwise, the iterator&#39;s
       * current position is set to the boundary preceding the current boundary.
       * @return The character index of the previous text boundary or
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the first text</span>
       * boundary.
       */
      public abstract int previous();
  
      /**
       * Returns the first boundary following the specified character offset. If the
       * specified offset equals to the last text boundary, it returns
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the iterator&#39;s current position is unchanged.</span>
       * Otherwise, the iterator&#39;s current position is set to the returned boundary.
       * The value returned is always greater than the offset or the value
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt;.</span>
       * @param offset the character offset to begin scanning.
       * @return The first boundary after the specified offset or
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the last text boundary is passed in</span>
       * as the offset.
<span class="line-modified">!      * @exception  IllegalArgumentException if the specified offset is less than</span>
       * the first text boundary or greater than the last text boundary.
       */
      public abstract int following(int offset);
  
      /**
       * Returns the last boundary preceding the specified character offset. If the
       * specified offset equals to the first text boundary, it returns
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the iterator&#39;s current position is unchanged.</span>
       * Otherwise, the iterator&#39;s current position is set to the returned boundary.
       * The value returned is always less than the offset or the value
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt;.</span>
       * @param offset the character offset to begin scanning.
       * @return The last boundary before the specified offset or
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the first text boundary is passed in</span>
       * as the offset.
<span class="line-modified">!      * @exception   IllegalArgumentException if the specified offset is less than</span>
       * the first text boundary or greater than the last text boundary.
       * @since 1.2
       */
      public int preceding(int offset) {
          // NOTE:  This implementation is here solely because we can&#39;t add new
<span class="line-new-header">--- 272,80 ---</span>
      public abstract int last();
  
      /**
       * Returns the nth boundary from the current boundary. If either
       * the first or last text boundary has been reached, it returns
<span class="line-modified">!      * {@code BreakIterator.DONE} and the current position is set to either</span>
       * the first or last text boundary depending on which one is reached. Otherwise,
       * the iterator&#39;s current position is set to the new boundary.
       * For example, if the iterator&#39;s current position is the mth text boundary
       * and three more boundaries exist from the current boundary to the last text
       * boundary, the next(2) call will return m + 2. The new text position is set
       * to the (m + 2)th text boundary. A next(4) call would return
<span class="line-modified">!      * {@code BreakIterator.DONE} and the last text boundary would become the</span>
       * new text position.
       * @param n which boundary to return.  A value of 0
       * does nothing.  Negative values move to previous boundaries
       * and positive values move to later boundaries.
       * @return The character index of the nth boundary from the current position
<span class="line-modified">!      * or {@code BreakIterator.DONE} if either first or last text boundary</span>
       * has been reached.
       */
      public abstract int next(int n);
  
      /**
       * Returns the boundary following the current boundary. If the current boundary
<span class="line-modified">!      * is the last text boundary, it returns {@code BreakIterator.DONE} and</span>
       * the iterator&#39;s current position is unchanged. Otherwise, the iterator&#39;s
       * current position is set to the boundary following the current boundary.
       * @return The character index of the next text boundary or
<span class="line-modified">!      * {@code BreakIterator.DONE} if the current boundary is the last text</span>
       * boundary.
       * Equivalent to next(1).
       * @see #next(int)
       */
      public abstract int next();
  
      /**
       * Returns the boundary preceding the current boundary. If the current boundary
<span class="line-modified">!      * is the first text boundary, it returns {@code BreakIterator.DONE} and</span>
       * the iterator&#39;s current position is unchanged. Otherwise, the iterator&#39;s
       * current position is set to the boundary preceding the current boundary.
       * @return The character index of the previous text boundary or
<span class="line-modified">!      * {@code BreakIterator.DONE} if the current boundary is the first text</span>
       * boundary.
       */
      public abstract int previous();
  
      /**
       * Returns the first boundary following the specified character offset. If the
       * specified offset equals to the last text boundary, it returns
<span class="line-modified">!      * {@code BreakIterator.DONE} and the iterator&#39;s current position is unchanged.</span>
       * Otherwise, the iterator&#39;s current position is set to the returned boundary.
       * The value returned is always greater than the offset or the value
<span class="line-modified">!      * {@code BreakIterator.DONE}.</span>
       * @param offset the character offset to begin scanning.
       * @return The first boundary after the specified offset or
<span class="line-modified">!      * {@code BreakIterator.DONE} if the last text boundary is passed in</span>
       * as the offset.
<span class="line-modified">!      * @throws     IllegalArgumentException if the specified offset is less than</span>
       * the first text boundary or greater than the last text boundary.
       */
      public abstract int following(int offset);
  
      /**
       * Returns the last boundary preceding the specified character offset. If the
       * specified offset equals to the first text boundary, it returns
<span class="line-modified">!      * {@code BreakIterator.DONE} and the iterator&#39;s current position is unchanged.</span>
       * Otherwise, the iterator&#39;s current position is set to the returned boundary.
       * The value returned is always less than the offset or the value
<span class="line-modified">!      * {@code BreakIterator.DONE}.</span>
       * @param offset the character offset to begin scanning.
       * @return The last boundary before the specified offset or
<span class="line-modified">!      * {@code BreakIterator.DONE} if the first text boundary is passed in</span>
       * as the offset.
<span class="line-modified">!      * @throws      IllegalArgumentException if the specified offset is less than</span>
       * the first text boundary or greater than the last text boundary.
       * @since 1.2
       */
      public int preceding(int offset) {
          // NOTE:  This implementation is here solely because we can&#39;t add new
</pre>
<hr />
<pre>
<span class="line-old-header">*** 359,13 ***</span>
      }
  
      /**
       * Returns true if the specified character offset is a text boundary.
       * @param offset the character offset to check.
<span class="line-modified">!      * @return &lt;code&gt;true&lt;/code&gt; if &quot;offset&quot; is a boundary position,</span>
<span class="line-modified">!      * &lt;code&gt;false&lt;/code&gt; otherwise.</span>
<span class="line-modified">!      * @exception   IllegalArgumentException if the specified offset is less than</span>
       * the first text boundary or greater than the last text boundary.
       * @since 1.2
       */
      public boolean isBoundary(int offset) {
          // NOTE: This implementation probably is wrong for most situations
<span class="line-new-header">--- 359,13 ---</span>
      }
  
      /**
       * Returns true if the specified character offset is a text boundary.
       * @param offset the character offset to check.
<span class="line-modified">!      * @return {@code true} if &quot;offset&quot; is a boundary position,</span>
<span class="line-modified">!      * {@code false} otherwise.</span>
<span class="line-modified">!      * @throws      IllegalArgumentException if the specified offset is less than</span>
       * the first text boundary or greater than the last text boundary.
       * @since 1.2
       */
      public boolean isBoundary(int offset) {
          // NOTE: This implementation probably is wrong for most situations
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,11 ***</span>
  
      /**
       * Returns character index of the text boundary that was most
       * recently returned by next(), next(int), previous(), first(), last(),
       * following(int) or preceding(int). If any of these methods returns
<span class="line-modified">!      * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; because either first or last text boundary</span>
       * has been reached, it returns the first or last text boundary depending on
       * which one is reached.
       * @return The text boundary returned from the above methods, first or last
       * text boundary.
       * @see #next()
<span class="line-new-header">--- 388,11 ---</span>
  
      /**
       * Returns character index of the text boundary that was most
       * recently returned by next(), next(int), previous(), first(), last(),
       * following(int) or preceding(int). If any of these methods returns
<span class="line-modified">!      * {@code BreakIterator.DONE} because either first or last text boundary</span>
       * has been reached, it returns the first or last text boundary depending on
       * which one is reached.
       * @return The text boundary returned from the above methods, first or last
       * text boundary.
       * @see #next()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 435,99 ***</span>
  
      @SuppressWarnings(&quot;unchecked&quot;)
      private static final SoftReference&lt;BreakIteratorCache&gt;[] iterCache = (SoftReference&lt;BreakIteratorCache&gt;[]) new SoftReference&lt;?&gt;[4];
  
      /**
<span class="line-modified">!      * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance</span>
       * for &lt;a href=&quot;BreakIterator.html#word&quot;&gt;word breaks&lt;/a&gt;
       * for the {@linkplain Locale#getDefault() default locale}.
       * @return A break iterator for word breaks
       */
      public static BreakIterator getWordInstance()
      {
          return getWordInstance(Locale.getDefault());
      }
  
      /**
<span class="line-modified">!      * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance</span>
       * for &lt;a href=&quot;BreakIterator.html#word&quot;&gt;word breaks&lt;/a&gt;
       * for the given locale.
       * @param locale the desired locale
       * @return A break iterator for word breaks
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</span>
       */
      public static BreakIterator getWordInstance(Locale locale)
      {
          return getBreakInstance(locale, WORD_INDEX);
      }
  
      /**
<span class="line-modified">!      * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance</span>
       * for &lt;a href=&quot;BreakIterator.html#line&quot;&gt;line breaks&lt;/a&gt;
       * for the {@linkplain Locale#getDefault() default locale}.
       * @return A break iterator for line breaks
       */
      public static BreakIterator getLineInstance()
      {
          return getLineInstance(Locale.getDefault());
      }
  
      /**
<span class="line-modified">!      * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance</span>
       * for &lt;a href=&quot;BreakIterator.html#line&quot;&gt;line breaks&lt;/a&gt;
       * for the given locale.
       * @param locale the desired locale
       * @return A break iterator for line breaks
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</span>
       */
      public static BreakIterator getLineInstance(Locale locale)
      {
          return getBreakInstance(locale, LINE_INDEX);
      }
  
      /**
<span class="line-modified">!      * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance</span>
       * for &lt;a href=&quot;BreakIterator.html#character&quot;&gt;character breaks&lt;/a&gt;
       * for the {@linkplain Locale#getDefault() default locale}.
       * @return A break iterator for character breaks
       */
      public static BreakIterator getCharacterInstance()
      {
          return getCharacterInstance(Locale.getDefault());
      }
  
      /**
<span class="line-modified">!      * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance</span>
       * for &lt;a href=&quot;BreakIterator.html#character&quot;&gt;character breaks&lt;/a&gt;
       * for the given locale.
       * @param locale the desired locale
       * @return A break iterator for character breaks
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</span>
       */
      public static BreakIterator getCharacterInstance(Locale locale)
      {
          return getBreakInstance(locale, CHARACTER_INDEX);
      }
  
      /**
<span class="line-modified">!      * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance</span>
       * for &lt;a href=&quot;BreakIterator.html#sentence&quot;&gt;sentence breaks&lt;/a&gt;
       * for the {@linkplain Locale#getDefault() default locale}.
       * @return A break iterator for sentence breaks
       */
      public static BreakIterator getSentenceInstance()
      {
          return getSentenceInstance(Locale.getDefault());
      }
  
      /**
<span class="line-modified">!      * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance</span>
       * for &lt;a href=&quot;BreakIterator.html#sentence&quot;&gt;sentence breaks&lt;/a&gt;
       * for the given locale.
       * @param locale the desired locale
       * @return A break iterator for sentence breaks
<span class="line-modified">!      * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null</span>
       */
      public static BreakIterator getSentenceInstance(Locale locale)
      {
          return getBreakInstance(locale, SENTENCE_INDEX);
      }
<span class="line-new-header">--- 435,99 ---</span>
  
      @SuppressWarnings(&quot;unchecked&quot;)
      private static final SoftReference&lt;BreakIteratorCache&gt;[] iterCache = (SoftReference&lt;BreakIteratorCache&gt;[]) new SoftReference&lt;?&gt;[4];
  
      /**
<span class="line-modified">!      * Returns a new {@code BreakIterator} instance</span>
       * for &lt;a href=&quot;BreakIterator.html#word&quot;&gt;word breaks&lt;/a&gt;
       * for the {@linkplain Locale#getDefault() default locale}.
       * @return A break iterator for word breaks
       */
      public static BreakIterator getWordInstance()
      {
          return getWordInstance(Locale.getDefault());
      }
  
      /**
<span class="line-modified">!      * Returns a new {@code BreakIterator} instance</span>
       * for &lt;a href=&quot;BreakIterator.html#word&quot;&gt;word breaks&lt;/a&gt;
       * for the given locale.
       * @param locale the desired locale
       * @return A break iterator for word breaks
<span class="line-modified">!      * @throws    NullPointerException if {@code locale} is null</span>
       */
      public static BreakIterator getWordInstance(Locale locale)
      {
          return getBreakInstance(locale, WORD_INDEX);
      }
  
      /**
<span class="line-modified">!      * Returns a new {@code BreakIterator} instance</span>
       * for &lt;a href=&quot;BreakIterator.html#line&quot;&gt;line breaks&lt;/a&gt;
       * for the {@linkplain Locale#getDefault() default locale}.
       * @return A break iterator for line breaks
       */
      public static BreakIterator getLineInstance()
      {
          return getLineInstance(Locale.getDefault());
      }
  
      /**
<span class="line-modified">!      * Returns a new {@code BreakIterator} instance</span>
       * for &lt;a href=&quot;BreakIterator.html#line&quot;&gt;line breaks&lt;/a&gt;
       * for the given locale.
       * @param locale the desired locale
       * @return A break iterator for line breaks
<span class="line-modified">!      * @throws    NullPointerException if {@code locale} is null</span>
       */
      public static BreakIterator getLineInstance(Locale locale)
      {
          return getBreakInstance(locale, LINE_INDEX);
      }
  
      /**
<span class="line-modified">!      * Returns a new {@code BreakIterator} instance</span>
       * for &lt;a href=&quot;BreakIterator.html#character&quot;&gt;character breaks&lt;/a&gt;
       * for the {@linkplain Locale#getDefault() default locale}.
       * @return A break iterator for character breaks
       */
      public static BreakIterator getCharacterInstance()
      {
          return getCharacterInstance(Locale.getDefault());
      }
  
      /**
<span class="line-modified">!      * Returns a new {@code BreakIterator} instance</span>
       * for &lt;a href=&quot;BreakIterator.html#character&quot;&gt;character breaks&lt;/a&gt;
       * for the given locale.
       * @param locale the desired locale
       * @return A break iterator for character breaks
<span class="line-modified">!      * @throws    NullPointerException if {@code locale} is null</span>
       */
      public static BreakIterator getCharacterInstance(Locale locale)
      {
          return getBreakInstance(locale, CHARACTER_INDEX);
      }
  
      /**
<span class="line-modified">!      * Returns a new {@code BreakIterator} instance</span>
       * for &lt;a href=&quot;BreakIterator.html#sentence&quot;&gt;sentence breaks&lt;/a&gt;
       * for the {@linkplain Locale#getDefault() default locale}.
       * @return A break iterator for sentence breaks
       */
      public static BreakIterator getSentenceInstance()
      {
          return getSentenceInstance(Locale.getDefault());
      }
  
      /**
<span class="line-modified">!      * Returns a new {@code BreakIterator} instance</span>
       * for &lt;a href=&quot;BreakIterator.html#sentence&quot;&gt;sentence breaks&lt;/a&gt;
       * for the given locale.
       * @param locale the desired locale
       * @return A break iterator for sentence breaks
<span class="line-modified">!      * @throws    NullPointerException if {@code locale} is null</span>
       */
      public static BreakIterator getSentenceInstance(Locale locale)
      {
          return getBreakInstance(locale, SENTENCE_INDEX);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 578,20 ***</span>
          return iterator;
      }
  
      /**
       * Returns an array of all locales for which the
<span class="line-modified">!      * &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return</span>
       * localized instances.
       * The returned array represents the union of locales supported by the Java
       * runtime and by installed
       * {@link java.text.spi.BreakIteratorProvider BreakIteratorProvider} implementations.
<span class="line-modified">!      * It must contain at least a &lt;code&gt;Locale&lt;/code&gt;</span>
       * instance equal to {@link java.util.Locale#US Locale.US}.
       *
       * @return An array of locales for which localized
<span class="line-modified">!      *         &lt;code&gt;BreakIterator&lt;/code&gt; instances are available.</span>
       */
      public static synchronized Locale[] getAvailableLocales()
      {
          LocaleServiceProviderPool pool =
              LocaleServiceProviderPool.getPool(BreakIteratorProvider.class);
<span class="line-new-header">--- 578,20 ---</span>
          return iterator;
      }
  
      /**
       * Returns an array of all locales for which the
<span class="line-modified">!      * {@code get*Instance} methods of this class can return</span>
       * localized instances.
       * The returned array represents the union of locales supported by the Java
       * runtime and by installed
       * {@link java.text.spi.BreakIteratorProvider BreakIteratorProvider} implementations.
<span class="line-modified">!      * It must contain at least a {@code Locale}</span>
       * instance equal to {@link java.util.Locale#US Locale.US}.
       *
       * @return An array of locales for which localized
<span class="line-modified">!      *         {@code BreakIterator} instances are available.</span>
       */
      public static synchronized Locale[] getAvailableLocales()
      {
          LocaleServiceProviderPool pool =
              LocaleServiceProviderPool.getPool(BreakIteratorProvider.class);
</pre>
<center><a href="Bidi.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CalendarBuilder.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/Integer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="InstantiationException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InternalError.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Integer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,63 ***</span>
          // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;
          int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val);
          int chars = Math.max(((mag + (shift - 1)) / shift), 1);
          if (COMPACT_STRINGS) {
              byte[] buf = new byte[chars];
<span class="line-modified">!             formatUnsignedInt(val, shift, buf, 0, chars);</span>
              return new String(buf, LATIN1);
          } else {
              byte[] buf = new byte[chars * 2];
<span class="line-modified">!             formatUnsignedIntUTF16(val, shift, buf, 0, chars);</span>
              return new String(buf, UTF16);
          }
      }
  
      /**
<span class="line-modified">!      * Format an {@code int} (treated as unsigned) into a character buffer. If</span>
       * {@code len} exceeds the formatted ASCII representation of {@code val},
       * {@code buf} will be padded with leading zeroes.
       *
       * @param val the unsigned int to format
       * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<span class="line-modified">!      * @param buf the character buffer to write to</span>
<span class="line-removed">-      * @param offset the offset in the destination buffer to start at</span>
       * @param len the number of characters to write
       */
<span class="line-modified">!     static void formatUnsignedInt(int val, int shift, char[] buf, int offset, int len) {</span>
<span class="line-modified">!         // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;</span>
<span class="line-removed">-         // assert offset &gt;= 0 &amp;&amp; offset &lt; buf.length : &quot;illegal offset&quot;;</span>
<span class="line-removed">-         // assert len &gt; 0 &amp;&amp; (offset + len) &lt;= buf.length : &quot;illegal length&quot;;</span>
<span class="line-removed">-         int charPos = offset + len;</span>
<span class="line-removed">-         int radix = 1 &lt;&lt; shift;</span>
<span class="line-removed">-         int mask = radix - 1;</span>
<span class="line-removed">-         do {</span>
<span class="line-removed">-             buf[--charPos] = Integer.digits[val &amp; mask];</span>
<span class="line-removed">-             val &gt;&gt;&gt;= shift;</span>
<span class="line-removed">-         } while (charPos &gt; offset);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** byte[]/LATIN1 version    */</span>
<span class="line-removed">-     static void formatUnsignedInt(int val, int shift, byte[] buf, int offset, int len) {</span>
<span class="line-removed">-         int charPos = offset + len;</span>
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
              buf[--charPos] = (byte)Integer.digits[val &amp; mask];
              val &gt;&gt;&gt;= shift;
<span class="line-modified">!         } while (charPos &gt; offset);</span>
      }
  
<span class="line-modified">!     /** byte[]/UTF16 version    */</span>
<span class="line-modified">!     private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int offset, int len) {</span>
<span class="line-modified">!         int charPos = offset + len;</span>
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
              StringUTF16.putChar(buf, --charPos, Integer.digits[val &amp; mask]);
              val &gt;&gt;&gt;= shift;
<span class="line-modified">!         } while (charPos &gt; offset);</span>
      }
  
      static final byte[] DigitTens = {
          &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;,
          &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;,
<span class="line-new-header">--- 345,57 ---</span>
          // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;
          int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val);
          int chars = Math.max(((mag + (shift - 1)) / shift), 1);
          if (COMPACT_STRINGS) {
              byte[] buf = new byte[chars];
<span class="line-modified">!             formatUnsignedInt(val, shift, buf, chars);</span>
              return new String(buf, LATIN1);
          } else {
              byte[] buf = new byte[chars * 2];
<span class="line-modified">!             formatUnsignedIntUTF16(val, shift, buf, chars);</span>
              return new String(buf, UTF16);
          }
      }
  
      /**
<span class="line-modified">!      * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If</span>
       * {@code len} exceeds the formatted ASCII representation of {@code val},
       * {@code buf} will be padded with leading zeroes.
       *
       * @param val the unsigned int to format
       * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
<span class="line-modified">!      * @param buf the byte buffer to write to</span>
       * @param len the number of characters to write
       */
<span class="line-modified">!     private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {</span>
<span class="line-modified">!         int charPos = len;</span>
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
              buf[--charPos] = (byte)Integer.digits[val &amp; mask];
              val &gt;&gt;&gt;= shift;
<span class="line-modified">!         } while (charPos &gt; 0);</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If</span>
<span class="line-modified">!      * {@code len} exceeds the formatted ASCII representation of {@code val},</span>
<span class="line-added">+      * {@code buf} will be padded with leading zeroes.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param val the unsigned int to format</span>
<span class="line-added">+      * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)</span>
<span class="line-added">+      * @param buf the byte buffer to write to</span>
<span class="line-added">+      * @param len the number of characters to write</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {</span>
<span class="line-added">+         int charPos = len;</span>
          int radix = 1 &lt;&lt; shift;
          int mask = radix - 1;
          do {
              StringUTF16.putChar(buf, --charPos, Integer.digits[val &amp; mask]);
              val &gt;&gt;&gt;= shift;
<span class="line-modified">!         } while (charPos &gt; 0);</span>
      }
  
      static final byte[] DigitTens = {
          &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;,
          &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,11 ***</span>
       * @param      s   the {@code String} containing the integer
       *                  representation to be parsed
       * @param      radix   the radix to be used while parsing {@code s}.
       * @return     the integer represented by the string argument in the
       *             specified radix.
<span class="line-modified">!      * @exception  NumberFormatException if the {@code String}</span>
       *             does not contain a parsable {@code int}.
       */
      public static int parseInt(String s, int radix)
                  throws NumberFormatException
      {
<span class="line-new-header">--- 596,11 ---</span>
       * @param      s   the {@code String} containing the integer
       *                  representation to be parsed
       * @param      radix   the radix to be used while parsing {@code s}.
       * @return     the integer represented by the string argument in the
       *             specified radix.
<span class="line-modified">!      * @throws     NumberFormatException if the {@code String}</span>
       *             does not contain a parsable {@code int}.
       */
      public static int parseInt(String s, int radix)
                  throws NumberFormatException
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,11 ***</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="line-modified">!         s = Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          if (radix &lt; Character.MIN_RADIX) {
<span class="line-new-header">--- 690,11 ---</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="line-modified">!         Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          if (radix &lt; Character.MIN_RADIX) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 767,11 ***</span>
       * int)} method.
       *
       * @param s    a {@code String} containing the {@code int}
       *             representation to be parsed
       * @return     the integer value represented by the argument in decimal.
<span class="line-modified">!      * @exception  NumberFormatException  if the string does not contain a</span>
       *               parsable integer.
       */
      public static int parseInt(String s) throws NumberFormatException {
          return parseInt(s,10);
      }
<span class="line-new-header">--- 761,11 ---</span>
       * int)} method.
       *
       * @param s    a {@code String} containing the {@code int}
       *             representation to be parsed
       * @return     the integer value represented by the argument in decimal.
<span class="line-modified">!      * @throws     NumberFormatException  if the string does not contain a</span>
       *               parsable integer.
       */
      public static int parseInt(String s) throws NumberFormatException {
          return parseInt(s,10);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 879,11 ***</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="line-modified">!         s = Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          int start = beginIndex, len = endIndex - beginIndex;
<span class="line-new-header">--- 873,11 ---</span>
       *             {@link java.lang.Character#MAX_RADIX}.
       * @since  9
       */
      public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)
                  throws NumberFormatException {
<span class="line-modified">!         Objects.requireNonNull(s);</span>
  
          if (beginIndex &lt; 0 || beginIndex &gt; endIndex || endIndex &gt; s.length()) {
              throw new IndexOutOfBoundsException();
          }
          int start = beginIndex, len = endIndex - beginIndex;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 954,11 ***</span>
       * @param      s   the string to be parsed.
       * @param      radix the radix to be used in interpreting {@code s}
       * @return     an {@code Integer} object holding the value
       *             represented by the string argument in the specified
       *             radix.
<span class="line-modified">!      * @exception NumberFormatException if the {@code String}</span>
       *            does not contain a parsable {@code int}.
       */
      public static Integer valueOf(String s, int radix) throws NumberFormatException {
          return Integer.valueOf(parseInt(s,radix));
      }
<span class="line-new-header">--- 948,11 ---</span>
       * @param      s   the string to be parsed.
       * @param      radix the radix to be used in interpreting {@code s}
       * @return     an {@code Integer} object holding the value
       *             represented by the string argument in the specified
       *             radix.
<span class="line-modified">!      * @throws    NumberFormatException if the {@code String}</span>
       *            does not contain a parsable {@code int}.
       */
      public static Integer valueOf(String s, int radix) throws NumberFormatException {
          return Integer.valueOf(parseInt(s,radix));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 980,11 ***</span>
       * &lt;/blockquote&gt;
       *
       * @param      s   the string to be parsed.
       * @return     an {@code Integer} object holding the value
       *             represented by the string argument.
<span class="line-modified">!      * @exception  NumberFormatException  if the string cannot be parsed</span>
       *             as an integer.
       */
      public static Integer valueOf(String s) throws NumberFormatException {
          return Integer.valueOf(parseInt(s, 10));
      }
<span class="line-new-header">--- 974,11 ---</span>
       * &lt;/blockquote&gt;
       *
       * @param      s   the string to be parsed.
       * @return     an {@code Integer} object holding the value
       *             represented by the string argument.
<span class="line-modified">!      * @throws     NumberFormatException  if the string cannot be parsed</span>
       *             as an integer.
       */
      public static Integer valueOf(String s) throws NumberFormatException {
          return Integer.valueOf(parseInt(s, 10));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1118,20 ***</span>
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code byte}
       * after a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversions</span>
       */
      public byte byteValue() {
          return (byte)value;
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code short}
       * after a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversions</span>
       */
      public short shortValue() {
          return (short)value;
      }
  
<span class="line-new-header">--- 1112,20 ---</span>
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code byte}
       * after a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversion</span>
       */
      public byte byteValue() {
          return (byte)value;
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code short}
       * after a narrowing primitive conversion.
<span class="line-modified">!      * @jls 5.1.3 Narrowing Primitive Conversion</span>
       */
      public short shortValue() {
          return (short)value;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1145,30 ***</span>
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code long}
       * after a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversions</span>
       * @see Integer#toUnsignedLong(int)
       */
      public long longValue() {
          return (long)value;
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code float}
       * after a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversions</span>
       */
      public float floatValue() {
          return (float)value;
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code double}
       * after a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversions</span>
       */
      public double doubleValue() {
          return (double)value;
      }
  
<span class="line-new-header">--- 1139,30 ---</span>
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code long}
       * after a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversion</span>
       * @see Integer#toUnsignedLong(int)
       */
      public long longValue() {
          return (long)value;
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code float}
       * after a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversion</span>
       */
      public float floatValue() {
          return (float)value;
      }
  
      /**
       * Returns the value of this {@code Integer} as a {@code double}
       * after a widening primitive conversion.
<span class="line-modified">!      * @jls 5.1.2 Widening Primitive Conversion</span>
       */
      public double doubleValue() {
          return (double)value;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1397,11 ***</span>
       * permitted in the {@code String}.
       *
       * @param     nm the {@code String} to decode.
       * @return    an {@code Integer} object holding the {@code int}
       *             value represented by {@code nm}
<span class="line-modified">!      * @exception NumberFormatException  if the {@code String} does not</span>
       *            contain a parsable integer.
       * @see java.lang.Integer#parseInt(java.lang.String, int)
       */
      public static Integer decode(String nm) throws NumberFormatException {
          int radix = 10;
<span class="line-new-header">--- 1391,11 ---</span>
       * permitted in the {@code String}.
       *
       * @param     nm the {@code String} to decode.
       * @return    an {@code Integer} object holding the {@code int}
       *             value represented by {@code nm}
<span class="line-modified">!      * @throws    NumberFormatException  if the {@code String} does not</span>
       *            contain a parsable integer.
       * @see java.lang.Integer#parseInt(java.lang.String, int)
       */
      public static Integer decode(String nm) throws NumberFormatException {
          int radix = 10;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1861,7 ***</span>
<span class="line-new-header">--- 1855,8 ---</span>
      public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {
          return this;
      }
  
      /** use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added">+     @java.io.Serial</span>
      @Native private static final long serialVersionUID = 1360826667806852920L;
  }
</pre>
<center><a href="InstantiationException.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="InternalError.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
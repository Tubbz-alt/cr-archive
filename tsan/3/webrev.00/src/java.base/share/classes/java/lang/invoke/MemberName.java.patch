diff a/src/java.base/share/classes/java/lang/invoke/MemberName.java b/src/java.base/share/classes/java/lang/invoke/MemberName.java
--- a/src/java.base/share/classes/java/lang/invoke/MemberName.java
+++ b/src/java.base/share/classes/java/lang/invoke/MemberName.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -68,16 +68,18 @@
  * allows invocation.  A MemberName is much lighter than a Method,
  * since it contains about 7 fields to the 16 of Method (plus its sub-arrays),
  * and those seven fields omit much of the information in Method.
  * @author jrose
  */
-/*non-public*/ final class ResolvedMethodName {
+/*non-public*/
+final class ResolvedMethodName {
     //@Injected JVM_Method* vmtarget;
     //@Injected Class<?>    vmholder;
 };
 
-/*non-public*/ final class MemberName implements Member, Cloneable {
+/*non-public*/
+final class MemberName implements Member, Cloneable {
     private Class<?> clazz;       // class in which the member is defined
     private String   name;        // may be null if not yet materialized
     private Object   type;        // may be null if not yet materialized
     private int      flags;       // modifier bits; see reflect.Modifier
     private ResolvedMethodName method;    // cached resolved method information
@@ -308,11 +310,13 @@
             return true;
         if (name.equals("equals") && mtype.returnType() == boolean.class && mtype.parameterCount() == 1 && mtype.parameterType(0) == Object.class)
             return true;
         return false;
     }
-    /*non-public*/ boolean referenceKindIsConsistentWith(int originalRefKind) {
+
+    /*non-public*/
+    boolean referenceKindIsConsistentWith(int originalRefKind) {
         int refKind = getReferenceKind();
         if (refKind == originalRefKind)  return true;
         switch (originalRefKind) {
         case REF_invokeInterface:
             // Looking up an interface method, can get (e.g.) Object.hashCode
@@ -519,11 +523,11 @@
 
     /** Utility method to query whether this member is accessible from a given lookup class. */
     public boolean isAccessibleFrom(Class<?> lookupClass) {
         int mode = (ALL_ACCESS|MethodHandles.Lookup.PACKAGE|MethodHandles.Lookup.MODULE);
         return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,
-                                               lookupClass, mode);
+                                               lookupClass, null, mode);
     }
 
     /**
      * Check if MemberName is a call to a method named {@code name} in class {@code declaredClass}.
      */
@@ -928,17 +932,25 @@
         if (from != null)  {
             if (from == MethodHandles.publicLookup()) {
                 message += ", from public Lookup";
             } else {
                 Module m;
+                Class<?> plc;
                 if (from instanceof MethodHandles.Lookup) {
                     MethodHandles.Lookup lookup = (MethodHandles.Lookup)from;
+                    from = lookup.lookupClass();
                     m = lookup.lookupClass().getModule();
+                    plc = lookup.previousLookupClass();
                 } else {
-                    m = from.getClass().getModule();
+                    m = ((Class<?>)from).getModule();
+                    plc = null;
                 }
                 message += ", from " + from + " (" + m + ")";
+                if (plc != null) {
+                    message += ", previous lookup " +
+                        plc.getName() + " (" + plc.getModule() + ")";
+                }
             }
         }
         return new IllegalAccessException(message);
     }
     private String message() {
@@ -967,17 +979,19 @@
             ex.initCause((Throwable) resolution);
         return ex;
     }
 
     /** Actually making a query requires an access check. */
-    /*non-public*/ static Factory getFactory() {
+    /*non-public*/
+    static Factory getFactory() {
         return Factory.INSTANCE;
     }
     /** A factory type for resolving member names with the help of the VM.
      *  TBD: Define access-safe public constructors for this factory.
      */
-    /*non-public*/ static class Factory {
+    /*non-public*/
+    static class Factory {
         private Factory() { } // singleton pattern
         static Factory INSTANCE = new Factory();
 
         private static int ALLOWED_FLAGS = ALL_KINDS;
 
@@ -1088,13 +1102,12 @@
          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
          *  Access checking is performed on behalf of the given {@code lookupClass}.
          *  If lookup fails or access is not permitted, a {@linkplain ReflectiveOperationException} is thrown.
          *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
          */
-        public
-        <NoSuchMemberException extends ReflectiveOperationException>
-        MemberName resolveOrFail(byte refKind, MemberName m, Class<?> lookupClass,
+        public <NoSuchMemberException extends ReflectiveOperationException>
+                MemberName resolveOrFail(byte refKind, MemberName m, Class<?> lookupClass,
                                  Class<NoSuchMemberException> nsmClass)
                 throws IllegalAccessException, NoSuchMemberException {
             MemberName result = resolve(refKind, m, lookupClass, false);
             if (result.isResolved())
                 return result;
@@ -1106,12 +1119,11 @@
          *  Super types are searched (for inherited members) if {@code searchSupers} is true.
          *  Access checking is performed on behalf of the given {@code lookupClass}.
          *  If lookup fails or access is not permitted, return null.
          *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
          */
-        public
-        MemberName resolveOrNull(byte refKind, MemberName m, Class<?> lookupClass) {
+        public MemberName resolveOrNull(byte refKind, MemberName m, Class<?> lookupClass) {
             MemberName result = resolve(refKind, m, lookupClass, true);
             if (result != null && result.isResolved())
                 return result;
             return null;
         }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/regex/PrintPattern.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util.regex;
 27 
 28 import java.util.HashMap;
 29 import java.util.regex.Pattern.CharPredicate;
 30 import static java.util.regex.ASCII.*;
 31 
 32 /**
 33  * A utility class to print out the pattern node tree.
 34  */
 35 
 36 class PrintPattern {
 37 
 38     private static HashMap&lt;Pattern.Node, Integer&gt; ids = new HashMap&lt;&gt;();
 39 
 40     private static void print(Pattern.Node node, String text, int depth) {
 41         if (!ids.containsKey(node))
 42             ids.put(node, ids.size());
<a name="2" id="anc2"></a><span class="line-modified"> 43         print(&quot;%6d:%&quot; + (depth==0? &quot;&quot;: depth&lt;&lt;1) + &quot;s&lt;%s&gt;&quot;, ids.get(node), &quot;&quot;, text);</span>

 44         if (ids.containsKey(node.next))
<a name="3" id="anc3"></a><span class="line-modified"> 45             print(&quot; (=&gt;%d)&quot;, ids.get(node.next));</span>
<span class="line-modified"> 46         print(&quot;%n&quot;);</span>
 47     }
 48 
 49     private static void print(String s, int depth) {
<a name="4" id="anc4"></a><span class="line-modified"> 50         print(&quot;       %&quot; + (depth==0?&quot;&quot;:depth&lt;&lt;1) + &quot;s&lt;%s&gt;%n&quot;, &quot;&quot;, s);</span>
<span class="line-modified"> 51     }</span>
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53     private static void print(String fmt, Object ... args) {</span>
<span class="line-removed"> 54         System.err.printf(fmt, args);</span>
 55     }
 56 
 57     private static String toStringCPS(int[] cps) {
 58         StringBuilder sb = new StringBuilder(cps.length);
 59         for (int cp : cps)
 60             sb.append(toStringCP(cp));
 61         return sb.toString();
 62     }
 63 
 64     private static String toStringCP(int cp) {
 65         return (isPrint(cp) ? &quot;&quot; + (char)cp
 66                             : &quot;\\u&quot; + Integer.toString(cp, 16));
 67     }
 68 
 69     private static String toStringRange(int min, int max) {
 70        if (max == Pattern.MAX_REPS) {
 71            if (min == 0)
 72                return &quot; * &quot;;
 73            else if (min == 1)
 74                return &quot; + &quot;;
 75            return &quot;{&quot; + min + &quot;, max}&quot;;
 76        }
 77        return &quot;{&quot; + min + &quot;, &quot; +  max + &quot;}&quot;;
 78     }
 79 
 80     private static String toStringCtype(int type) {
 81         switch(type) {
 82         case UPPER:  return &quot;ASCII.UPPER&quot;;
 83         case LOWER:  return &quot;ASCII.LOWER&quot;;
 84         case DIGIT:  return &quot;ASCII.DIGIT&quot;;
 85         case SPACE:  return &quot;ASCII.SPACE&quot;;
 86         case PUNCT:  return &quot;ASCII.PUNCT&quot;;
 87         case CNTRL:  return &quot;ASCII.CNTRL&quot;;
 88         case BLANK:  return &quot;ASCII.BLANK&quot;;
 89         case UNDER:  return &quot;ASCII.UNDER&quot;;
 90         case ASCII:  return &quot;ASCII.ASCII&quot;;
 91         case ALPHA:  return &quot;ASCII.ALPHA&quot;;
 92         case ALNUM:  return &quot;ASCII.ALNUM&quot;;
 93         case GRAPH:  return &quot;ASCII.GRAPH&quot;;
 94         case WORD:   return &quot;ASCII.WORD&quot;;
 95         case XDIGIT: return &quot;ASCII.XDIGIT&quot;;
 96         default: return &quot;ASCII ?&quot;;
 97         }
 98     }
 99 
100     private static String toString(Pattern.Node node) {
101         String name = node.getClass().getName();
102         return name.substring(name.lastIndexOf(&#39;$&#39;) + 1);
103     }
104 
105     static HashMap&lt;CharPredicate, String&gt; pmap;
106     static {
107         pmap = new HashMap&lt;&gt;();
108         pmap.put(Pattern.ALL(), &quot;All&quot;);
109         pmap.put(Pattern.DOT(), &quot;Dot&quot;);
110         pmap.put(Pattern.UNIXDOT(), &quot;UnixDot&quot;);
111         pmap.put(Pattern.VertWS(), &quot;VertWS&quot;);
112         pmap.put(Pattern.HorizWS(), &quot;HorizWS&quot;);
113 
114         pmap.put(CharPredicates.ASCII_DIGIT(), &quot;ASCII.DIGIT&quot;);
115         pmap.put(CharPredicates.ASCII_WORD(),  &quot;ASCII.WORD&quot;);
116         pmap.put(CharPredicates.ASCII_SPACE(), &quot;ASCII.SPACE&quot;);
117     }
118 
119     static void walk(Pattern.Node node, int depth) {
120         depth++;
121         while(node != null) {
122             String name = toString(node);
123             String str;
124             if (node instanceof Pattern.Prolog) {
125                 print(node, name, depth);
126                 // print the loop here
127                 Pattern.Loop loop = ((Pattern.Prolog)node).loop;
128                 name = toString(loop);
129                 str = name + &quot; &quot; + toStringRange(loop.cmin, loop.cmax);
130                 print(loop, str, depth);
131                 walk(loop.body, depth);
132                 print(&quot;/&quot; + name, depth);
133                 node = loop;
134             } else if (node instanceof Pattern.Loop) {
135                 return;  // stop here, body.next -&gt; loop
136             } else if (node instanceof Pattern.Curly) {
137                 Pattern.Curly c = (Pattern.Curly)node;
138                 str = &quot;Curly &quot; + c.type + &quot; &quot; + toStringRange(c.cmin, c.cmax);
139                 print(node, str, depth);
140                 walk(c.atom, depth);
141                 print(&quot;/Curly&quot;, depth);
142             } else if (node instanceof Pattern.GroupCurly) {
143                 Pattern.GroupCurly gc = (Pattern.GroupCurly)node;
144                 str = &quot;GroupCurly &quot; + gc.groupIndex / 2 +
145                       &quot;, &quot; + gc.type + &quot; &quot; + toStringRange(gc.cmin, gc.cmax);
146                 print(node, str, depth);
147                 walk(gc.atom, depth);
148                 print(&quot;/GroupCurly&quot;, depth);
149             } else if (node instanceof Pattern.GroupHead) {
150                 Pattern.GroupHead head = (Pattern.GroupHead)node;
151                 Pattern.GroupTail tail = head.tail;
152                 print(head, &quot;Group.head &quot; + (tail.groupIndex / 2), depth);
153                 walk(head.next, depth);
154                 print(tail, &quot;/Group.tail &quot; + (tail.groupIndex / 2), depth);
155                 node = tail;
156             } else if (node instanceof Pattern.GroupTail) {
157                 return;  // stopper
158             } else if (node instanceof Pattern.Ques) {
159                 print(node, &quot;Ques &quot; + ((Pattern.Ques)node).type, depth);
160                 walk(((Pattern.Ques)node).atom, depth);
161                 print(&quot;/Ques&quot;, depth);
162             } else if (node instanceof Pattern.Branch) {
163                 Pattern.Branch b = (Pattern.Branch)node;
164                 print(b, name, depth);
165                 int i = 0;
166                 while (true) {
167                     if (b.atoms[i] != null) {
168                         walk(b.atoms[i], depth);
169                     } else {
170                         print(&quot;  (accepted)&quot;, depth);
171                     }
172                     if (++i == b.size)
173                         break;
174                     print(&quot;-branch.separator-&quot;, depth);
175                 }
176                 node = b.conn;
177                 print(node, &quot;/Branch&quot;, depth);
178             } else if (node instanceof Pattern.BranchConn) {
179                 return;
180             } else if (node instanceof Pattern.CharProperty) {
181                 str = pmap.get(((Pattern.CharProperty)node).predicate);
182                 if (str == null)
183                     str = toString(node);
184                 else
185                     str = &quot;Single \&quot;&quot; + str + &quot;\&quot;&quot;;
186                 print(node, str, depth);
187             } else if (node instanceof Pattern.SliceNode) {
188                 str = name + &quot;  \&quot;&quot; +
189                       toStringCPS(((Pattern.SliceNode)node).buffer) + &quot;\&quot;&quot;;
190                 print(node, str, depth);
191             } else if (node instanceof Pattern.CharPropertyGreedy) {
192                 Pattern.CharPropertyGreedy gcp = (Pattern.CharPropertyGreedy)node;
193                 String pstr = pmap.get(gcp.predicate);
194                 if (pstr == null)
195                     pstr = gcp.predicate.toString();
196                 else
197                     pstr = &quot;Single \&quot;&quot; + pstr + &quot;\&quot;&quot;;
<a name="5" id="anc5"></a><span class="line-modified">198                 str = name + &quot; &quot; + pstr + ((gcp.cmin == 0) ? &quot;*&quot; : &quot;+&quot;);</span>






199                 print(node, str, depth);
200             } else if (node instanceof Pattern.BackRef) {
201                 str = &quot;GroupBackRef &quot; + ((Pattern.BackRef)node).groupIndex / 2;
202                 print(node, str, depth);
203             } else if (node instanceof Pattern.LastNode) {
204                 print(node, &quot;END&quot;, depth);
205             } else if (node == Pattern.accept) {
206                 return;
207             } else {
208                 print(node, name, depth);
209             }
210             node = node.next;
211         }
212     }
213 
214     public static void main(String[] args) {
215         Pattern p = Pattern.compile(args[0]);
216         System.out.println(&quot;   Pattern: &quot; + p);
217         walk(p.root, 0);
218     }
219 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
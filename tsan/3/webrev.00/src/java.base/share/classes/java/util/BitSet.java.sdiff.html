<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/BitSet.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Base64.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Calendar.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/BitSet.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  66 public class BitSet implements Cloneable, java.io.Serializable {
  67     /*
  68      * BitSets are packed into arrays of &quot;words.&quot;  Currently a word is
  69      * a long, which consists of 64 bits, requiring 6 address bits.
  70      * The choice of word size is determined purely by performance concerns.
  71      */
  72     private static final int ADDRESS_BITS_PER_WORD = 6;
  73     private static final int BITS_PER_WORD = 1 &lt;&lt; ADDRESS_BITS_PER_WORD;
  74     private static final int BIT_INDEX_MASK = BITS_PER_WORD - 1;
  75 
  76     /* Used to shift left or right for a partial word mask */
  77     private static final long WORD_MASK = 0xffffffffffffffffL;
  78 
  79     /**
  80      * @serialField bits long[]
  81      *
  82      * The bits in this BitSet.  The ith bit is stored in bits[i/64] at
  83      * bit position i % 64 (where bit position 0 refers to the least
  84      * significant bit and 63 refers to the most significant bit).
  85      */

  86     private static final ObjectStreamField[] serialPersistentFields = {
  87         new ObjectStreamField(&quot;bits&quot;, long[].class),
  88     };
  89 
  90     /**
  91      * The internal field corresponding to the serialField &quot;bits&quot;.
  92      */
  93     private long[] words;
  94 
  95     /**
  96      * The number of words in the logical size of this BitSet.
  97      */
  98     private transient int wordsInUse = 0;
  99 
 100     /**
 101      * Whether the size of &quot;words&quot; is user-specified.  If so, we assume
 102      * the user knows what he&#39;s doing and try harder to preserve it.
 103      */
 104     private transient boolean sizeIsSticky = false;
 105 
 106     /* use serialVersionUID from JDK 1.0.2 for interoperability */

 107     private static final long serialVersionUID = 7997698588986878753L;
 108 
 109     /**
 110      * Given a bit index, return word index containing it.
 111      */
 112     private static int wordIndex(int bitIndex) {
 113         return bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;
 114     }
 115 
 116     /**
 117      * Every public method must preserve these invariants.
 118      */
 119     private void checkInvariants() {
 120         assert(wordsInUse == 0 || words[wordsInUse - 1] != 0);
 121         assert(wordsInUse &gt;= 0 &amp;&amp; wordsInUse &lt;= words.length);
 122         assert(wordsInUse == words.length || words[wordsInUse] == 0);
 123     }
 124 
 125     /**
 126      * Sets the field wordsInUse to the logical size in words of the bit set.
</pre>
<hr />
<pre>
1107             throw new InternalError(e);
1108         }
1109     }
1110 
1111     /**
1112      * Attempts to reduce internal storage used for the bits in this bit set.
1113      * Calling this method may, but is not required to, affect the value
1114      * returned by a subsequent call to the {@link #size()} method.
1115      */
1116     private void trimToSize() {
1117         if (wordsInUse != words.length) {
1118             words = Arrays.copyOf(words, wordsInUse);
1119             checkInvariants();
1120         }
1121     }
1122 
1123     /**
1124      * Save the state of the {@code BitSet} instance to a stream (i.e.,
1125      * serialize it).
1126      */

1127     private void writeObject(ObjectOutputStream s)
1128         throws IOException {
1129 
1130         checkInvariants();
1131 
1132         if (! sizeIsSticky)
1133             trimToSize();
1134 
1135         ObjectOutputStream.PutField fields = s.putFields();
1136         fields.put(&quot;bits&quot;, words);
1137         s.writeFields();
1138     }
1139 
1140     /**
1141      * Reconstitute the {@code BitSet} instance from a stream (i.e.,
1142      * deserialize it).
1143      */

1144     private void readObject(ObjectInputStream s)
1145         throws IOException, ClassNotFoundException {
1146 
1147         ObjectInputStream.GetField fields = s.readFields();
1148         words = (long[]) fields.get(&quot;bits&quot;, null);
1149 
1150         // Assume maximum length then find real length
1151         // because recalculateWordsInUse assumes maintenance
1152         // or reduction in logical size
1153         wordsInUse = words.length;
1154         recalculateWordsInUse();
1155         sizeIsSticky = (words.length &gt; 0 &amp;&amp; words[words.length-1] == 0L); // heuristic
1156         checkInvariants();
1157     }
1158 
1159     /**
1160      * Returns a string representation of this bit set. For every index
1161      * for which this {@code BitSet} contains a bit in the set
1162      * state, the decimal representation of that index is included in
1163      * the result. Such indices are listed in order from lowest to
</pre>
<hr />
<pre>
1165      * surrounded by braces, resulting in the usual mathematical
1166      * notation for a set of integers.
1167      *
1168      * &lt;p&gt;Example:
1169      * &lt;pre&gt;
1170      * BitSet drPepper = new BitSet();&lt;/pre&gt;
1171      * Now {@code drPepper.toString()} returns &quot;{@code {}}&quot;.
1172      * &lt;pre&gt;
1173      * drPepper.set(2);&lt;/pre&gt;
1174      * Now {@code drPepper.toString()} returns &quot;{@code {2}}&quot;.
1175      * &lt;pre&gt;
1176      * drPepper.set(4);
1177      * drPepper.set(10);&lt;/pre&gt;
1178      * Now {@code drPepper.toString()} returns &quot;{@code {2, 4, 10}}&quot;.
1179      *
1180      * @return a string representation of this bit set
1181      */
1182     public String toString() {
1183         checkInvariants();
1184 

1185         int numBits = (wordsInUse &gt; 128) ?
1186             cardinality() : wordsInUse * BITS_PER_WORD;
<span class="line-modified">1187         StringBuilder b = new StringBuilder(6*numBits + 2);</span>



1188         b.append(&#39;{&#39;);
1189 
1190         int i = nextSetBit(0);
1191         if (i != -1) {
1192             b.append(i);
1193             while (true) {
1194                 if (++i &lt; 0) break;
1195                 if ((i = nextSetBit(i)) &lt; 0) break;
1196                 int endOfRun = nextClearBit(i);
1197                 do { b.append(&quot;, &quot;).append(i); }
1198                 while (++i != endOfRun);
1199             }
1200         }
1201 
1202         b.append(&#39;}&#39;);
1203         return b.toString();
1204     }
1205 
1206     /**
1207      * Returns a stream of indices for which this {@code BitSet}
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  66 public class BitSet implements Cloneable, java.io.Serializable {
  67     /*
  68      * BitSets are packed into arrays of &quot;words.&quot;  Currently a word is
  69      * a long, which consists of 64 bits, requiring 6 address bits.
  70      * The choice of word size is determined purely by performance concerns.
  71      */
  72     private static final int ADDRESS_BITS_PER_WORD = 6;
  73     private static final int BITS_PER_WORD = 1 &lt;&lt; ADDRESS_BITS_PER_WORD;
  74     private static final int BIT_INDEX_MASK = BITS_PER_WORD - 1;
  75 
  76     /* Used to shift left or right for a partial word mask */
  77     private static final long WORD_MASK = 0xffffffffffffffffL;
  78 
  79     /**
  80      * @serialField bits long[]
  81      *
  82      * The bits in this BitSet.  The ith bit is stored in bits[i/64] at
  83      * bit position i % 64 (where bit position 0 refers to the least
  84      * significant bit and 63 refers to the most significant bit).
  85      */
<span class="line-added">  86     @java.io.Serial</span>
  87     private static final ObjectStreamField[] serialPersistentFields = {
  88         new ObjectStreamField(&quot;bits&quot;, long[].class),
  89     };
  90 
  91     /**
  92      * The internal field corresponding to the serialField &quot;bits&quot;.
  93      */
  94     private long[] words;
  95 
  96     /**
  97      * The number of words in the logical size of this BitSet.
  98      */
  99     private transient int wordsInUse = 0;
 100 
 101     /**
 102      * Whether the size of &quot;words&quot; is user-specified.  If so, we assume
 103      * the user knows what he&#39;s doing and try harder to preserve it.
 104      */
 105     private transient boolean sizeIsSticky = false;
 106 
 107     /* use serialVersionUID from JDK 1.0.2 for interoperability */
<span class="line-added"> 108     @java.io.Serial</span>
 109     private static final long serialVersionUID = 7997698588986878753L;
 110 
 111     /**
 112      * Given a bit index, return word index containing it.
 113      */
 114     private static int wordIndex(int bitIndex) {
 115         return bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;
 116     }
 117 
 118     /**
 119      * Every public method must preserve these invariants.
 120      */
 121     private void checkInvariants() {
 122         assert(wordsInUse == 0 || words[wordsInUse - 1] != 0);
 123         assert(wordsInUse &gt;= 0 &amp;&amp; wordsInUse &lt;= words.length);
 124         assert(wordsInUse == words.length || words[wordsInUse] == 0);
 125     }
 126 
 127     /**
 128      * Sets the field wordsInUse to the logical size in words of the bit set.
</pre>
<hr />
<pre>
1109             throw new InternalError(e);
1110         }
1111     }
1112 
1113     /**
1114      * Attempts to reduce internal storage used for the bits in this bit set.
1115      * Calling this method may, but is not required to, affect the value
1116      * returned by a subsequent call to the {@link #size()} method.
1117      */
1118     private void trimToSize() {
1119         if (wordsInUse != words.length) {
1120             words = Arrays.copyOf(words, wordsInUse);
1121             checkInvariants();
1122         }
1123     }
1124 
1125     /**
1126      * Save the state of the {@code BitSet} instance to a stream (i.e.,
1127      * serialize it).
1128      */
<span class="line-added">1129     @java.io.Serial</span>
1130     private void writeObject(ObjectOutputStream s)
1131         throws IOException {
1132 
1133         checkInvariants();
1134 
1135         if (! sizeIsSticky)
1136             trimToSize();
1137 
1138         ObjectOutputStream.PutField fields = s.putFields();
1139         fields.put(&quot;bits&quot;, words);
1140         s.writeFields();
1141     }
1142 
1143     /**
1144      * Reconstitute the {@code BitSet} instance from a stream (i.e.,
1145      * deserialize it).
1146      */
<span class="line-added">1147     @java.io.Serial</span>
1148     private void readObject(ObjectInputStream s)
1149         throws IOException, ClassNotFoundException {
1150 
1151         ObjectInputStream.GetField fields = s.readFields();
1152         words = (long[]) fields.get(&quot;bits&quot;, null);
1153 
1154         // Assume maximum length then find real length
1155         // because recalculateWordsInUse assumes maintenance
1156         // or reduction in logical size
1157         wordsInUse = words.length;
1158         recalculateWordsInUse();
1159         sizeIsSticky = (words.length &gt; 0 &amp;&amp; words[words.length-1] == 0L); // heuristic
1160         checkInvariants();
1161     }
1162 
1163     /**
1164      * Returns a string representation of this bit set. For every index
1165      * for which this {@code BitSet} contains a bit in the set
1166      * state, the decimal representation of that index is included in
1167      * the result. Such indices are listed in order from lowest to
</pre>
<hr />
<pre>
1169      * surrounded by braces, resulting in the usual mathematical
1170      * notation for a set of integers.
1171      *
1172      * &lt;p&gt;Example:
1173      * &lt;pre&gt;
1174      * BitSet drPepper = new BitSet();&lt;/pre&gt;
1175      * Now {@code drPepper.toString()} returns &quot;{@code {}}&quot;.
1176      * &lt;pre&gt;
1177      * drPepper.set(2);&lt;/pre&gt;
1178      * Now {@code drPepper.toString()} returns &quot;{@code {2}}&quot;.
1179      * &lt;pre&gt;
1180      * drPepper.set(4);
1181      * drPepper.set(10);&lt;/pre&gt;
1182      * Now {@code drPepper.toString()} returns &quot;{@code {2, 4, 10}}&quot;.
1183      *
1184      * @return a string representation of this bit set
1185      */
1186     public String toString() {
1187         checkInvariants();
1188 
<span class="line-added">1189         final int MAX_INITIAL_CAPACITY = Integer.MAX_VALUE - 8;</span>
1190         int numBits = (wordsInUse &gt; 128) ?
1191             cardinality() : wordsInUse * BITS_PER_WORD;
<span class="line-modified">1192         // Avoid overflow in the case of a humongous numBits</span>
<span class="line-added">1193         int initialCapacity = (numBits &lt;= (MAX_INITIAL_CAPACITY - 2) / 6) ?</span>
<span class="line-added">1194             6 * numBits + 2 : MAX_INITIAL_CAPACITY;</span>
<span class="line-added">1195         StringBuilder b = new StringBuilder(initialCapacity);</span>
1196         b.append(&#39;{&#39;);
1197 
1198         int i = nextSetBit(0);
1199         if (i != -1) {
1200             b.append(i);
1201             while (true) {
1202                 if (++i &lt; 0) break;
1203                 if ((i = nextSetBit(i)) &lt; 0) break;
1204                 int endOfRun = nextClearBit(i);
1205                 do { b.append(&quot;, &quot;).append(i); }
1206                 while (++i != endOfRun);
1207             }
1208         }
1209 
1210         b.append(&#39;}&#39;);
1211         return b.toString();
1212     }
1213 
1214     /**
1215      * Returns a stream of indices for which this {@code BitSet}
</pre>
</td>
</tr>
</table>
<center><a href="Base64.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Calendar.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
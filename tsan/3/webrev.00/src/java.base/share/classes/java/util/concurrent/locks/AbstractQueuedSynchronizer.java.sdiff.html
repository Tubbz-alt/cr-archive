<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractQueuedLongSynchronizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Condition.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent.locks;
  37 
<span class="line-removed">  38 import java.lang.invoke.MethodHandles;</span>
<span class="line-removed">  39 import java.lang.invoke.VarHandle;</span>
  40 import java.util.ArrayList;
  41 import java.util.Collection;
  42 import java.util.Date;
  43 import java.util.concurrent.TimeUnit;


  44 
  45 /**
  46  * Provides a framework for implementing blocking locks and related
  47  * synchronizers (semaphores, events, etc) that rely on
  48  * first-in-first-out (FIFO) wait queues.  This class is designed to
  49  * be a useful basis for most kinds of synchronizers that rely on a
  50  * single atomic {@code int} value to represent state. Subclasses
  51  * must define the protected methods that change this state, and which
  52  * define what that state means in terms of this object being acquired
  53  * or released.  Given these, the other methods in this class carry
  54  * out all queuing and blocking mechanics. Subclasses can maintain
  55  * other state fields, but only the atomically updated {@code int}
  56  * value manipulated using methods {@link #getState}, {@link
  57  * #setState} and {@link #compareAndSetState} is tracked with respect
  58  * to synchronization.
  59  *
  60  * &lt;p&gt;Subclasses should be defined as non-public internal helper
  61  * classes that are used to implement the synchronization properties
  62  * of their enclosing class.  Class
  63  * {@code AbstractQueuedSynchronizer} does not implement any
</pre>
<hr />
<pre>
  87  * invoked with the current {@link #getState} value fully releases
  88  * this object, and {@link #acquire}, given this saved state value,
  89  * eventually restores this object to its previous acquired state.  No
  90  * {@code AbstractQueuedSynchronizer} method otherwise creates such a
  91  * condition, so if this constraint cannot be met, do not use it.  The
  92  * behavior of {@link ConditionObject} depends of course on the
  93  * semantics of its synchronizer implementation.
  94  *
  95  * &lt;p&gt;This class provides inspection, instrumentation, and monitoring
  96  * methods for the internal queue, as well as similar methods for
  97  * condition objects. These can be exported as desired into classes
  98  * using an {@code AbstractQueuedSynchronizer} for their
  99  * synchronization mechanics.
 100  *
 101  * &lt;p&gt;Serialization of this class stores only the underlying atomic
 102  * integer maintaining state, so deserialized objects have empty
 103  * thread queues. Typical subclasses requiring serializability will
 104  * define a {@code readObject} method that restores this to a known
 105  * initial state upon deserialization.
 106  *
<span class="line-modified"> 107  * &lt;h3&gt;Usage&lt;/h3&gt;</span>
 108  *
 109  * &lt;p&gt;To use this class as the basis of a synchronizer, redefine the
 110  * following methods, as applicable, by inspecting and/or modifying
 111  * the synchronization state using {@link #getState}, {@link
 112  * #setState} and/or {@link #compareAndSetState}:
 113  *
 114  * &lt;ul&gt;
 115  * &lt;li&gt;{@link #tryAcquire}
 116  * &lt;li&gt;{@link #tryRelease}
 117  * &lt;li&gt;{@link #tryAcquireShared}
 118  * &lt;li&gt;{@link #tryReleaseShared}
 119  * &lt;li&gt;{@link #isHeldExclusively}
 120  * &lt;/ul&gt;
 121  *
 122  * Each of these methods by default throws {@link
 123  * UnsupportedOperationException}.  Implementations of these methods
 124  * must be internally thread-safe, and should in general be short and
 125  * not block. Defining these methods is the &lt;em&gt;only&lt;/em&gt; supported
 126  * means of using this class. All other methods are declared
 127  * {@code final} because they cannot be independently varied.
</pre>
<hr />
<pre>
 170  * against incoming threads.  Also, while acquires do not
 171  * &amp;quot;spin&amp;quot; in the usual sense, they may perform multiple
 172  * invocations of {@code tryAcquire} interspersed with other
 173  * computations before blocking.  This gives most of the benefits of
 174  * spins when exclusive synchronization is only briefly held, without
 175  * most of the liabilities when it isn&#39;t. If so desired, you can
 176  * augment this by preceding calls to acquire methods with
 177  * &quot;fast-path&quot; checks, possibly prechecking {@link #hasContended}
 178  * and/or {@link #hasQueuedThreads} to only do so if the synchronizer
 179  * is likely not to be contended.
 180  *
 181  * &lt;p&gt;This class provides an efficient and scalable basis for
 182  * synchronization in part by specializing its range of use to
 183  * synchronizers that can rely on {@code int} state, acquire, and
 184  * release parameters, and an internal FIFO wait queue. When this does
 185  * not suffice, you can build synchronizers from a lower level using
 186  * {@link java.util.concurrent.atomic atomic} classes, your own custom
 187  * {@link java.util.Queue} classes, and {@link LockSupport} blocking
 188  * support.
 189  *
<span class="line-modified"> 190  * &lt;h3&gt;Usage Examples&lt;/h3&gt;</span>
 191  *
 192  * &lt;p&gt;Here is a non-reentrant mutual exclusion lock class that uses
 193  * the value zero to represent the unlocked state, and one to
 194  * represent the locked state. While a non-reentrant lock
 195  * does not strictly require recording of the current owner
 196  * thread, this class does so anyway to make usage easier to monitor.
 197  * It also supports conditions and exposes some instrumentation methods:
 198  *
 199  * &lt;pre&gt; {@code
 200  * class Mutex implements Lock, java.io.Serializable {
 201  *
 202  *   // Our internal helper class
 203  *   private static class Sync extends AbstractQueuedSynchronizer {
 204  *     // Acquires the lock if state is zero
 205  *     public boolean tryAcquire(int acquires) {
 206  *       assert acquires == 1; // Otherwise unused
 207  *       if (compareAndSetState(0, 1)) {
 208  *         setExclusiveOwnerThread(Thread.currentThread());
 209  *         return true;
 210  *       }
</pre>
<hr />
<pre>
 295  *   public void await() throws InterruptedException {
 296  *     sync.acquireSharedInterruptibly(1);
 297  *   }
 298  * }}&lt;/pre&gt;
 299  *
 300  * @since 1.5
 301  * @author Doug Lea
 302  */
 303 public abstract class AbstractQueuedSynchronizer
 304     extends AbstractOwnableSynchronizer
 305     implements java.io.Serializable {
 306 
 307     private static final long serialVersionUID = 7373984972572414691L;
 308 
 309     /**
 310      * Creates a new {@code AbstractQueuedSynchronizer} instance
 311      * with initial synchronization state of zero.
 312      */
 313     protected AbstractQueuedSynchronizer() { }
 314 
<span class="line-modified"> 315     /**</span>
<span class="line-modified"> 316      * Wait queue node class.</span>
 317      *
<span class="line-modified"> 318      * &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and</span>
 319      * Hagersten) lock queue. CLH locks are normally used for
<span class="line-modified"> 320      * spinlocks.  We instead use them for blocking synchronizers, but</span>
<span class="line-modified"> 321      * use the same basic tactic of holding some of the control</span>
<span class="line-modified"> 322      * information about a thread in the predecessor of its node.  A</span>
<span class="line-modified"> 323      * &quot;status&quot; field in each node keeps track of whether a thread</span>
<span class="line-modified"> 324      * should block.  A node is signalled when its predecessor</span>
<span class="line-modified"> 325      * releases.  Each node of the queue otherwise serves as a</span>
<span class="line-modified"> 326      * specific-notification-style monitor holding a single waiting</span>
<span class="line-modified"> 327      * thread. The status field does NOT control whether threads are</span>
<span class="line-modified"> 328      * granted locks etc though.  A thread may try to acquire if it is</span>
<span class="line-modified"> 329      * first in the queue. But being first does not guarantee success;</span>
<span class="line-modified"> 330      * it only gives the right to contend.  So the currently released</span>
<span class="line-modified"> 331      * contender thread may need to rewait.</span>
<span class="line-modified"> 332      *</span>
<span class="line-modified"> 333      * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new</span>
<span class="line-modified"> 334      * tail. To dequeue, you just set the head field.</span>
<span class="line-modified"> 335      * &lt;pre&gt;</span>
<span class="line-modified"> 336      *      +------+  prev +-----+       +-----+</span>
<span class="line-modified"> 337      * head |      | &lt;---- |     | &lt;---- |     |  tail</span>
<span class="line-modified"> 338      *      +------+       +-----+       +-----+</span>
<span class="line-modified"> 339      * &lt;/pre&gt;</span>
<span class="line-modified"> 340      *</span>
<span class="line-modified"> 341      * &lt;p&gt;Insertion into a CLH queue requires only a single atomic</span>
<span class="line-modified"> 342      * operation on &quot;tail&quot;, so there is a simple atomic point of</span>
<span class="line-modified"> 343      * demarcation from unqueued to queued. Similarly, dequeuing</span>
<span class="line-modified"> 344      * involves only updating the &quot;head&quot;. However, it takes a bit</span>
<span class="line-modified"> 345      * more work for nodes to determine who their successors are,</span>
<span class="line-modified"> 346      * in part to deal with possible cancellation due to timeouts</span>
<span class="line-modified"> 347      * and interrupts.</span>
<span class="line-modified"> 348      *</span>
<span class="line-modified"> 349      * &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly</span>
<span class="line-modified"> 350      * needed to handle cancellation. If a node is cancelled, its</span>
<span class="line-modified"> 351      * successor is (normally) relinked to a non-cancelled</span>
<span class="line-modified"> 352      * predecessor. For explanation of similar mechanics in the case</span>
<span class="line-modified"> 353      * of spin locks, see the papers by Scott and Scherer at</span>
<span class="line-modified"> 354      * http://www.cs.rochester.edu/u/scott/synchronization/</span>
<span class="line-modified"> 355      *</span>
<span class="line-modified"> 356      * &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics.</span>
<span class="line-modified"> 357      * The thread id for each node is kept in its own node, so a</span>
<span class="line-modified"> 358      * predecessor signals the next node to wake up by traversing</span>
<span class="line-modified"> 359      * next link to determine which thread it is.  Determination of</span>
<span class="line-modified"> 360      * successor must avoid races with newly queued nodes to set</span>
<span class="line-modified"> 361      * the &quot;next&quot; fields of their predecessors.  This is solved</span>
<span class="line-modified"> 362      * when necessary by checking backwards from the atomically</span>
<span class="line-modified"> 363      * updated &quot;tail&quot; when a node&#39;s successor appears to be null.</span>
<span class="line-modified"> 364      * (Or, said differently, the next-links are an optimization</span>
<span class="line-modified"> 365      * so that we don&#39;t usually need a backward scan.)</span>
<span class="line-modified"> 366      *</span>
<span class="line-modified"> 367      * &lt;p&gt;Cancellation introduces some conservatism to the basic</span>
<span class="line-modified"> 368      * algorithms.  Since we must poll for cancellation of other</span>
<span class="line-modified"> 369      * nodes, we can miss noticing whether a cancelled node is</span>
<span class="line-modified"> 370      * ahead or behind us. This is dealt with by always unparking</span>
<span class="line-modified"> 371      * successors upon cancellation, allowing them to stabilize on</span>
<span class="line-modified"> 372      * a new predecessor, unless we can identify an uncancelled</span>
<span class="line-modified"> 373      * predecessor who will carry this responsibility.</span>
<span class="line-modified"> 374      *</span>
<span class="line-modified"> 375      * &lt;p&gt;CLH queues need a dummy header node to get started. But</span>
























 376      * we don&#39;t create them on construction, because it would be wasted
 377      * effort if there is never contention. Instead, the node
 378      * is constructed and head and tail pointers are set upon first
 379      * contention.
 380      *
<span class="line-modified"> 381      * &lt;p&gt;Threads waiting on Conditions use the same nodes, but</span>
<span class="line-modified"> 382      * use an additional link. Conditions only need to link nodes</span>
<span class="line-modified"> 383      * in simple (non-concurrent) linked queues because they are</span>
<span class="line-modified"> 384      * only accessed when exclusively held.  Upon await, a node is</span>
<span class="line-modified"> 385      * inserted into a condition queue.  Upon signal, the node is</span>
<span class="line-modified"> 386      * transferred to the main queue.  A special value of status</span>
<span class="line-modified"> 387      * field is used to mark which queue a node is on.</span>
<span class="line-modified"> 388      *</span>
<span class="line-modified"> 389      * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span>




























 390      * Scherer and Michael Scott, along with members of JSR-166
 391      * expert group, for helpful ideas, discussions, and critiques
 392      * on the design of this class.
 393      */
<span class="line-removed"> 394     static final class Node {</span>
<span class="line-removed"> 395         /** Marker to indicate a node is waiting in shared mode */</span>
<span class="line-removed"> 396         static final Node SHARED = new Node();</span>
<span class="line-removed"> 397         /** Marker to indicate a node is waiting in exclusive mode */</span>
<span class="line-removed"> 398         static final Node EXCLUSIVE = null;</span>
<span class="line-removed"> 399 </span>
<span class="line-removed"> 400         /** waitStatus value to indicate thread has cancelled. */</span>
<span class="line-removed"> 401         static final int CANCELLED =  1;</span>
<span class="line-removed"> 402         /** waitStatus value to indicate successor&#39;s thread needs unparking. */</span>
<span class="line-removed"> 403         static final int SIGNAL    = -1;</span>
<span class="line-removed"> 404         /** waitStatus value to indicate thread is waiting on condition. */</span>
<span class="line-removed"> 405         static final int CONDITION = -2;</span>
<span class="line-removed"> 406         /**</span>
<span class="line-removed"> 407          * waitStatus value to indicate the next acquireShared should</span>
<span class="line-removed"> 408          * unconditionally propagate.</span>
<span class="line-removed"> 409          */</span>
<span class="line-removed"> 410         static final int PROPAGATE = -3;</span>
 411 
<span class="line-modified"> 412         /**</span>
<span class="line-modified"> 413          * Status field, taking on only the values:</span>
<span class="line-modified"> 414          *   SIGNAL:     The successor of this node is (or will soon be)</span>
<span class="line-modified"> 415          *               blocked (via park), so the current node must</span>
<span class="line-modified"> 416          *               unpark its successor when it releases or</span>
<span class="line-modified"> 417          *               cancels. To avoid races, acquire methods must</span>
<span class="line-modified"> 418          *               first indicate they need a signal,</span>
<span class="line-modified"> 419          *               then retry the atomic acquire, and then,</span>
<span class="line-modified"> 420          *               on failure, block.</span>
<span class="line-modified"> 421          *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span>
<span class="line-modified"> 422          *               Nodes never leave this state. In particular,</span>
<span class="line-modified"> 423          *               a thread with cancelled node never again blocks.</span>
<span class="line-modified"> 424          *   CONDITION:  This node is currently on a condition queue.</span>
<span class="line-modified"> 425          *               It will not be used as a sync queue node</span>
<span class="line-modified"> 426          *               until transferred, at which time the status</span>
<span class="line-removed"> 427          *               will be set to 0. (Use of this value here has</span>
<span class="line-removed"> 428          *               nothing to do with the other uses of the</span>
<span class="line-removed"> 429          *               field, but simplifies mechanics.)</span>
<span class="line-removed"> 430          *   PROPAGATE:  A releaseShared should be propagated to other</span>
<span class="line-removed"> 431          *               nodes. This is set (for head node only) in</span>
<span class="line-removed"> 432          *               doReleaseShared to ensure propagation</span>
<span class="line-removed"> 433          *               continues, even if other operations have</span>
<span class="line-removed"> 434          *               since intervened.</span>
<span class="line-removed"> 435          *   0:          None of the above</span>
<span class="line-removed"> 436          *</span>
<span class="line-removed"> 437          * The values are arranged numerically to simplify use.</span>
<span class="line-removed"> 438          * Non-negative values mean that a node doesn&#39;t need to</span>
<span class="line-removed"> 439          * signal. So, most code doesn&#39;t need to check for particular</span>
<span class="line-removed"> 440          * values, just for sign.</span>
<span class="line-removed"> 441          *</span>
<span class="line-removed"> 442          * The field is initialized to 0 for normal sync nodes, and</span>
<span class="line-removed"> 443          * CONDITION for condition nodes.  It is modified using CAS</span>
<span class="line-removed"> 444          * (or when possible, unconditional volatile writes).</span>
<span class="line-removed"> 445          */</span>
<span class="line-removed"> 446         volatile int waitStatus;</span>
<span class="line-removed"> 447 </span>
<span class="line-removed"> 448         /**</span>
<span class="line-removed"> 449          * Link to predecessor node that current node/thread relies on</span>
<span class="line-removed"> 450          * for checking waitStatus. Assigned during enqueuing, and nulled</span>
<span class="line-removed"> 451          * out (for sake of GC) only upon dequeuing.  Also, upon</span>
<span class="line-removed"> 452          * cancellation of a predecessor, we short-circuit while</span>
<span class="line-removed"> 453          * finding a non-cancelled one, which will always exist</span>
<span class="line-removed"> 454          * because the head node is never cancelled: A node becomes</span>
<span class="line-removed"> 455          * head only as a result of successful acquire. A</span>
<span class="line-removed"> 456          * cancelled thread never succeeds in acquiring, and a thread only</span>
<span class="line-removed"> 457          * cancels itself, not any other node.</span>
<span class="line-removed"> 458          */</span>
<span class="line-removed"> 459         volatile Node prev;</span>
<span class="line-removed"> 460 </span>
<span class="line-removed"> 461         /**</span>
<span class="line-removed"> 462          * Link to the successor node that the current node/thread</span>
<span class="line-removed"> 463          * unparks upon release. Assigned during enqueuing, adjusted</span>
<span class="line-removed"> 464          * when bypassing cancelled predecessors, and nulled out (for</span>
<span class="line-removed"> 465          * sake of GC) when dequeued.  The enq operation does not</span>
<span class="line-removed"> 466          * assign next field of a predecessor until after attachment,</span>
<span class="line-removed"> 467          * so seeing a null next field does not necessarily mean that</span>
<span class="line-removed"> 468          * node is at end of queue. However, if a next field appears</span>
<span class="line-removed"> 469          * to be null, we can scan prev&#39;s from the tail to</span>
<span class="line-removed"> 470          * double-check.  The next field of cancelled nodes is set to</span>
<span class="line-removed"> 471          * point to the node itself instead of null, to make life</span>
<span class="line-removed"> 472          * easier for isOnSyncQueue.</span>
<span class="line-removed"> 473          */</span>
<span class="line-removed"> 474         volatile Node next;</span>
<span class="line-removed"> 475 </span>
<span class="line-removed"> 476         /**</span>
<span class="line-removed"> 477          * The thread that enqueued this node.  Initialized on</span>
<span class="line-removed"> 478          * construction and nulled out after use.</span>
<span class="line-removed"> 479          */</span>
<span class="line-removed"> 480         volatile Thread thread;</span>
<span class="line-removed"> 481 </span>
<span class="line-removed"> 482         /**</span>
<span class="line-removed"> 483          * Link to next node waiting on condition, or the special</span>
<span class="line-removed"> 484          * value SHARED.  Because condition queues are accessed only</span>
<span class="line-removed"> 485          * when holding in exclusive mode, we just need a simple</span>
<span class="line-removed"> 486          * linked queue to hold nodes while they are waiting on</span>
<span class="line-removed"> 487          * conditions. They are then transferred to the queue to</span>
<span class="line-removed"> 488          * re-acquire. And because conditions can only be exclusive,</span>
<span class="line-removed"> 489          * we save a field by using special value to indicate shared</span>
<span class="line-removed"> 490          * mode.</span>
<span class="line-removed"> 491          */</span>
<span class="line-removed"> 492         Node nextWaiter;</span>
<span class="line-removed"> 493 </span>
<span class="line-removed"> 494         /**</span>
<span class="line-removed"> 495          * Returns true if node is waiting in shared mode.</span>
<span class="line-removed"> 496          */</span>
<span class="line-removed"> 497         final boolean isShared() {</span>
<span class="line-removed"> 498             return nextWaiter == SHARED;</span>
 499         }
<span class="line-modified"> 500 </span>
<span class="line-modified"> 501         /**</span>
<span class="line-removed"> 502          * Returns previous node, or throws NullPointerException if null.</span>
<span class="line-removed"> 503          * Use when predecessor cannot be null.  The null check could</span>
<span class="line-removed"> 504          * be elided, but is present to help the VM.</span>
<span class="line-removed"> 505          *</span>
<span class="line-removed"> 506          * @return the predecessor of this node</span>
<span class="line-removed"> 507          */</span>
<span class="line-removed"> 508         final Node predecessor() {</span>
<span class="line-removed"> 509             Node p = prev;</span>
<span class="line-removed"> 510             if (p == null)</span>
<span class="line-removed"> 511                 throw new NullPointerException();</span>
<span class="line-removed"> 512             else</span>
<span class="line-removed"> 513                 return p;</span>
 514         }
<span class="line-modified"> 515 </span>
<span class="line-modified"> 516         /** Establishes initial head or SHARED marker. */</span>
<span class="line-removed"> 517         Node() {}</span>
<span class="line-removed"> 518 </span>
<span class="line-removed"> 519         /** Constructor used by addWaiter. */</span>
<span class="line-removed"> 520         Node(Node nextWaiter) {</span>
<span class="line-removed"> 521             this.nextWaiter = nextWaiter;</span>
<span class="line-removed"> 522             THREAD.set(this, Thread.currentThread());</span>
 523         }
<span class="line-modified"> 524 </span>
<span class="line-modified"> 525         /** Constructor used by addConditionWaiter. */</span>
<span class="line-removed"> 526         Node(int waitStatus) {</span>
<span class="line-removed"> 527             WAITSTATUS.set(this, waitStatus);</span>
<span class="line-removed"> 528             THREAD.set(this, Thread.currentThread());</span>
 529         }
<span class="line-modified"> 530 </span>
<span class="line-modified"> 531         /** CASes waitStatus field. */</span>
<span class="line-removed"> 532         final boolean compareAndSetWaitStatus(int expect, int update) {</span>
<span class="line-removed"> 533             return WAITSTATUS.compareAndSet(this, expect, update);</span>
 534         }
<span class="line-modified"> 535 </span>
<span class="line-modified"> 536         /** CASes next field. */</span>
<span class="line-removed"> 537         final boolean compareAndSetNext(Node expect, Node update) {</span>
<span class="line-removed"> 538             return NEXT.compareAndSet(this, expect, update);</span>
 539         }
 540 
<span class="line-modified"> 541         final void setPrevRelaxed(Node p) {</span>
<span class="line-modified"> 542             PREV.set(this, p);</span>





















 543         }
 544 
<span class="line-modified"> 545         // VarHandle mechanics</span>
<span class="line-modified"> 546         private static final VarHandle NEXT;</span>
<span class="line-modified"> 547         private static final VarHandle PREV;</span>
<span class="line-removed"> 548         private static final VarHandle THREAD;</span>
<span class="line-removed"> 549         private static final VarHandle WAITSTATUS;</span>
<span class="line-removed"> 550         static {</span>
<span class="line-removed"> 551             try {</span>
<span class="line-removed"> 552                 MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-removed"> 553                 NEXT = l.findVarHandle(Node.class, &quot;next&quot;, Node.class);</span>
<span class="line-removed"> 554                 PREV = l.findVarHandle(Node.class, &quot;prev&quot;, Node.class);</span>
<span class="line-removed"> 555                 THREAD = l.findVarHandle(Node.class, &quot;thread&quot;, Thread.class);</span>
<span class="line-removed"> 556                 WAITSTATUS = l.findVarHandle(Node.class, &quot;waitStatus&quot;, int.class);</span>
<span class="line-removed"> 557             } catch (ReflectiveOperationException e) {</span>
<span class="line-removed"> 558                 throw new ExceptionInInitializerError(e);</span>
<span class="line-removed"> 559             }</span>
 560         }
 561     }
 562 
 563     /**
<span class="line-modified"> 564      * Head of the wait queue, lazily initialized.  Except for</span>
<span class="line-removed"> 565      * initialization, it is modified only via method setHead.  Note:</span>
<span class="line-removed"> 566      * If head exists, its waitStatus is guaranteed not to be</span>
<span class="line-removed"> 567      * CANCELLED.</span>
 568      */
 569     private transient volatile Node head;
 570 
 571     /**
<span class="line-modified"> 572      * Tail of the wait queue, lazily initialized.  Modified only via</span>
<span class="line-removed"> 573      * method enq to add new wait node.</span>
 574      */
 575     private transient volatile Node tail;
 576 
 577     /**
 578      * The synchronization state.
 579      */
 580     private volatile int state;
 581 
 582     /**
 583      * Returns the current value of synchronization state.
 584      * This operation has memory semantics of a {@code volatile} read.
 585      * @return current state value
 586      */
 587     protected final int getState() {
 588         return state;
 589     }
 590 
 591     /**
 592      * Sets the value of synchronization state.
 593      * This operation has memory semantics of a {@code volatile} write.
 594      * @param newState the new state value
 595      */
 596     protected final void setState(int newState) {
 597         state = newState;
 598     }
 599 
 600     /**
 601      * Atomically sets synchronization state to the given updated
 602      * value if the current state value equals the expected value.
 603      * This operation has memory semantics of a {@code volatile} read
 604      * and write.
 605      *
 606      * @param expect the expected value
 607      * @param update the new value
 608      * @return {@code true} if successful. False return indicates that the actual
 609      *         value was not equal to the expected value.
 610      */
 611     protected final boolean compareAndSetState(int expect, int update) {
<span class="line-modified"> 612         return STATE.compareAndSet(this, expect, update);</span>
 613     }
 614 
 615     // Queuing utilities
 616 
<span class="line-modified"> 617     /**</span>
<span class="line-modified"> 618      * The number of nanoseconds for which it is faster to spin</span>
<span class="line-removed"> 619      * rather than to use timed park. A rough estimate suffices</span>
<span class="line-removed"> 620      * to improve responsiveness with very short timeouts.</span>
<span class="line-removed"> 621      */</span>
<span class="line-removed"> 622     static final long SPIN_FOR_TIMEOUT_THRESHOLD = 1000L;</span>
<span class="line-removed"> 623 </span>
<span class="line-removed"> 624     /**</span>
<span class="line-removed"> 625      * Inserts node into queue, initializing if necessary. See picture above.</span>
<span class="line-removed"> 626      * @param node the node to insert</span>
<span class="line-removed"> 627      * @return node&#39;s predecessor</span>
<span class="line-removed"> 628      */</span>
<span class="line-removed"> 629     private Node enq(Node node) {</span>
<span class="line-removed"> 630         for (;;) {</span>
<span class="line-removed"> 631             Node oldTail = tail;</span>
<span class="line-removed"> 632             if (oldTail != null) {</span>
<span class="line-removed"> 633                 node.setPrevRelaxed(oldTail);</span>
<span class="line-removed"> 634                 if (compareAndSetTail(oldTail, node)) {</span>
<span class="line-removed"> 635                     oldTail.next = node;</span>
<span class="line-removed"> 636                     return oldTail;</span>
<span class="line-removed"> 637                 }</span>
<span class="line-removed"> 638             } else {</span>
<span class="line-removed"> 639                 initializeSyncQueue();</span>
<span class="line-removed"> 640             }</span>
<span class="line-removed"> 641         }</span>
<span class="line-removed"> 642     }</span>
<span class="line-removed"> 643 </span>
<span class="line-removed"> 644     /**</span>
<span class="line-removed"> 645      * Creates and enqueues node for current thread and given mode.</span>
<span class="line-removed"> 646      *</span>
<span class="line-removed"> 647      * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span>
<span class="line-removed"> 648      * @return the new node</span>
<span class="line-removed"> 649      */</span>
<span class="line-removed"> 650     private Node addWaiter(Node mode) {</span>
<span class="line-removed"> 651         Node node = new Node(mode);</span>
<span class="line-removed"> 652 </span>
<span class="line-removed"> 653         for (;;) {</span>
<span class="line-removed"> 654             Node oldTail = tail;</span>
<span class="line-removed"> 655             if (oldTail != null) {</span>
<span class="line-removed"> 656                 node.setPrevRelaxed(oldTail);</span>
<span class="line-removed"> 657                 if (compareAndSetTail(oldTail, node)) {</span>
<span class="line-removed"> 658                     oldTail.next = node;</span>
<span class="line-removed"> 659                     return node;</span>
<span class="line-removed"> 660                 }</span>
<span class="line-removed"> 661             } else {</span>
<span class="line-removed"> 662                 initializeSyncQueue();</span>
<span class="line-removed"> 663             }</span>
<span class="line-removed"> 664         }</span>
<span class="line-removed"> 665     }</span>
<span class="line-removed"> 666 </span>
<span class="line-removed"> 667     /**</span>
<span class="line-removed"> 668      * Sets head of queue to be node, thus dequeuing. Called only by</span>
<span class="line-removed"> 669      * acquire methods.  Also nulls out unused fields for sake of GC</span>
<span class="line-removed"> 670      * and to suppress unnecessary signals and traversals.</span>
<span class="line-removed"> 671      *</span>
<span class="line-removed"> 672      * @param node the node</span>
<span class="line-removed"> 673      */</span>
<span class="line-removed"> 674     private void setHead(Node node) {</span>
<span class="line-removed"> 675         head = node;</span>
<span class="line-removed"> 676         node.thread = null;</span>
<span class="line-removed"> 677         node.prev = null;</span>
 678     }
 679 
<span class="line-modified"> 680     /**</span>
<span class="line-modified"> 681      * Wakes up node&#39;s successor, if one exists.</span>
<span class="line-modified"> 682      *</span>
<span class="line-modified"> 683      * @param node the node</span>
<span class="line-modified"> 684      */</span>
<span class="line-removed"> 685     private void unparkSuccessor(Node node) {</span>
<span class="line-removed"> 686         /*</span>
<span class="line-removed"> 687          * If status is negative (i.e., possibly needing signal) try</span>
<span class="line-removed"> 688          * to clear in anticipation of signalling.  It is OK if this</span>
<span class="line-removed"> 689          * fails or if status is changed by waiting thread.</span>
<span class="line-removed"> 690          */</span>
<span class="line-removed"> 691         int ws = node.waitStatus;</span>
<span class="line-removed"> 692         if (ws &lt; 0)</span>
<span class="line-removed"> 693             node.compareAndSetWaitStatus(ws, 0);</span>
<span class="line-removed"> 694 </span>
<span class="line-removed"> 695         /*</span>
<span class="line-removed"> 696          * Thread to unpark is held in successor, which is normally</span>
<span class="line-removed"> 697          * just the next node.  But if cancelled or apparently null,</span>
<span class="line-removed"> 698          * traverse backwards from tail to find the actual</span>
<span class="line-removed"> 699          * non-cancelled successor.</span>
<span class="line-removed"> 700          */</span>
<span class="line-removed"> 701         Node s = node.next;</span>
<span class="line-removed"> 702         if (s == null || s.waitStatus &gt; 0) {</span>
<span class="line-removed"> 703             s = null;</span>
<span class="line-removed"> 704             for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev)</span>
<span class="line-removed"> 705                 if (p.waitStatus &lt;= 0)</span>
<span class="line-removed"> 706                     s = p;</span>
<span class="line-removed"> 707         }</span>
<span class="line-removed"> 708         if (s != null)</span>
<span class="line-removed"> 709             LockSupport.unpark(s.thread);</span>
 710     }
 711 
 712     /**
<span class="line-modified"> 713      * Release action for shared mode -- signals successor and ensures</span>
<span class="line-modified"> 714      * propagation. (Note: For exclusive mode, release just amounts</span>
<span class="line-removed"> 715      * to calling unparkSuccessor of head if it needs signal.)</span>
 716      */
<span class="line-modified"> 717     private void doReleaseShared() {</span>
<span class="line-modified"> 718         /*</span>
<span class="line-modified"> 719          * Ensure that a release propagates, even if there are other</span>
<span class="line-modified"> 720          * in-progress acquires/releases.  This proceeds in the usual</span>
<span class="line-modified"> 721          * way of trying to unparkSuccessor of head if it needs</span>
<span class="line-modified"> 722          * signal. But if it does not, status is set to PROPAGATE to</span>
<span class="line-modified"> 723          * ensure that upon release, propagation continues.</span>
<span class="line-modified"> 724          * Additionally, we must loop in case a new node is added</span>
<span class="line-modified"> 725          * while we are doing this. Also, unlike other uses of</span>
<span class="line-modified"> 726          * unparkSuccessor, we need to know if CAS to reset status</span>
<span class="line-modified"> 727          * fails, if so rechecking.</span>
<span class="line-modified"> 728          */</span>
<span class="line-removed"> 729         for (;;) {</span>
<span class="line-removed"> 730             Node h = head;</span>
<span class="line-removed"> 731             if (h != null &amp;&amp; h != tail) {</span>
<span class="line-removed"> 732                 int ws = h.waitStatus;</span>
<span class="line-removed"> 733                 if (ws == Node.SIGNAL) {</span>
<span class="line-removed"> 734                     if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))</span>
<span class="line-removed"> 735                         continue;            // loop to recheck cases</span>
<span class="line-removed"> 736                     unparkSuccessor(h);</span>
 737                 }
<span class="line-removed"> 738                 else if (ws == 0 &amp;&amp;</span>
<span class="line-removed"> 739                          !h.compareAndSetWaitStatus(0, Node.PROPAGATE))</span>
<span class="line-removed"> 740                     continue;                // loop on failed CAS</span>
 741             }
<span class="line-removed"> 742             if (h == head)                   // loop if head changed</span>
<span class="line-removed"> 743                 break;</span>
 744         }
 745     }
 746 
<span class="line-modified"> 747     /**</span>
<span class="line-modified"> 748      * Sets head of queue, and checks if successor may be waiting</span>
<span class="line-modified"> 749      * in shared mode, if so propagating if either propagate &gt; 0 or</span>
<span class="line-modified"> 750      * PROPAGATE status was set.</span>
<span class="line-modified"> 751      *</span>
<span class="line-modified"> 752      * @param node the node</span>
<span class="line-removed"> 753      * @param propagate the return value from a tryAcquireShared</span>
<span class="line-removed"> 754      */</span>
<span class="line-removed"> 755     private void setHeadAndPropagate(Node node, int propagate) {</span>
<span class="line-removed"> 756         Node h = head; // Record old head for check below</span>
<span class="line-removed"> 757         setHead(node);</span>
<span class="line-removed"> 758         /*</span>
<span class="line-removed"> 759          * Try to signal next queued node if:</span>
<span class="line-removed"> 760          *   Propagation was indicated by caller,</span>
<span class="line-removed"> 761          *     or was recorded (as h.waitStatus either before</span>
<span class="line-removed"> 762          *     or after setHead) by a previous operation</span>
<span class="line-removed"> 763          *     (note: this uses sign-check of waitStatus because</span>
<span class="line-removed"> 764          *      PROPAGATE status may transition to SIGNAL.)</span>
<span class="line-removed"> 765          * and</span>
<span class="line-removed"> 766          *   The next node is waiting in shared mode,</span>
<span class="line-removed"> 767          *     or we don&#39;t know, because it appears null</span>
<span class="line-removed"> 768          *</span>
<span class="line-removed"> 769          * The conservatism in both of these checks may cause</span>
<span class="line-removed"> 770          * unnecessary wake-ups, but only when there are multiple</span>
<span class="line-removed"> 771          * racing acquires/releases, so most need signals now or soon</span>
<span class="line-removed"> 772          * anyway.</span>
<span class="line-removed"> 773          */</span>
<span class="line-removed"> 774         if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span>
<span class="line-removed"> 775             (h = head) == null || h.waitStatus &lt; 0) {</span>
<span class="line-removed"> 776             Node s = node.next;</span>
<span class="line-removed"> 777             if (s == null || s.isShared())</span>
<span class="line-removed"> 778                 doReleaseShared();</span>
<span class="line-removed"> 779         }</span>
 780     }
 781 
<span class="line-removed"> 782     // Utilities for various versions of acquire</span>
<span class="line-removed"> 783 </span>
 784     /**
<span class="line-modified"> 785      * Cancels an ongoing attempt to acquire.</span>
<span class="line-modified"> 786      *</span>
<span class="line-modified"> 787      * @param node the node</span>

 788      */
<span class="line-modified"> 789     private void cancelAcquire(Node node) {</span>
<span class="line-modified"> 790         // Ignore if node doesn&#39;t exist</span>
<span class="line-modified"> 791         if (node == null)</span>
<span class="line-modified"> 792             return;</span>
<span class="line-modified"> 793 </span>
<span class="line-removed"> 794         node.thread = null;</span>
<span class="line-removed"> 795 </span>
<span class="line-removed"> 796         // Skip cancelled predecessors</span>
<span class="line-removed"> 797         Node pred = node.prev;</span>
<span class="line-removed"> 798         while (pred.waitStatus &gt; 0)</span>
<span class="line-removed"> 799             node.prev = pred = pred.prev;</span>
<span class="line-removed"> 800 </span>
<span class="line-removed"> 801         // predNext is the apparent node to unsplice. CASes below will</span>
<span class="line-removed"> 802         // fail if not, in which case, we lost race vs another cancel</span>
<span class="line-removed"> 803         // or signal, so no further action is necessary, although with</span>
<span class="line-removed"> 804         // a possibility that a cancelled node may transiently remain</span>
<span class="line-removed"> 805         // reachable.</span>
<span class="line-removed"> 806         Node predNext = pred.next;</span>
<span class="line-removed"> 807 </span>
<span class="line-removed"> 808         // Can use unconditional write instead of CAS here.</span>
<span class="line-removed"> 809         // After this atomic step, other Nodes can skip past us.</span>
<span class="line-removed"> 810         // Before, we are free of interference from other threads.</span>
<span class="line-removed"> 811         node.waitStatus = Node.CANCELLED;</span>
<span class="line-removed"> 812 </span>
<span class="line-removed"> 813         // If we are the tail, remove ourselves.</span>
<span class="line-removed"> 814         if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {</span>
<span class="line-removed"> 815             pred.compareAndSetNext(predNext, null);</span>
<span class="line-removed"> 816         } else {</span>
<span class="line-removed"> 817             // If successor needs signal, try to set pred&#39;s next-link</span>
<span class="line-removed"> 818             // so it will get one. Otherwise wake it up to propagate.</span>
<span class="line-removed"> 819             int ws;</span>
<span class="line-removed"> 820             if (pred != head &amp;&amp;</span>
<span class="line-removed"> 821                 ((ws = pred.waitStatus) == Node.SIGNAL ||</span>
<span class="line-removed"> 822                  (ws &lt;= 0 &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &amp;&amp;</span>
<span class="line-removed"> 823                 pred.thread != null) {</span>
<span class="line-removed"> 824                 Node next = node.next;</span>
<span class="line-removed"> 825                 if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span>
<span class="line-removed"> 826                     pred.compareAndSetNext(predNext, next);</span>
<span class="line-removed"> 827             } else {</span>
<span class="line-removed"> 828                 unparkSuccessor(node);</span>
<span class="line-removed"> 829             }</span>
<span class="line-removed"> 830 </span>
<span class="line-removed"> 831             node.next = node; // help GC</span>
 832         }
 833     }
 834 
<span class="line-modified"> 835     /**</span>
<span class="line-modified"> 836      * Checks and updates status for a node that failed to acquire.</span>
<span class="line-modified"> 837      * Returns true if thread should block. This is the main signal</span>
<span class="line-modified"> 838      * control in all acquire loops.  Requires that pred == node.prev.</span>
<span class="line-modified"> 839      *</span>
<span class="line-modified"> 840      * @param pred node&#39;s predecessor holding status</span>
<span class="line-modified"> 841      * @param node the node</span>
<span class="line-removed"> 842      * @return {@code true} if thread should block</span>
<span class="line-removed"> 843      */</span>
<span class="line-removed"> 844     private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {</span>
<span class="line-removed"> 845         int ws = pred.waitStatus;</span>
<span class="line-removed"> 846         if (ws == Node.SIGNAL)</span>
<span class="line-removed"> 847             /*</span>
<span class="line-removed"> 848              * This node has already set status asking a release</span>
<span class="line-removed"> 849              * to signal it, so it can safely park.</span>
<span class="line-removed"> 850              */</span>
<span class="line-removed"> 851             return true;</span>
<span class="line-removed"> 852         if (ws &gt; 0) {</span>
<span class="line-removed"> 853             /*</span>
<span class="line-removed"> 854              * Predecessor was cancelled. Skip over predecessors and</span>
<span class="line-removed"> 855              * indicate retry.</span>
<span class="line-removed"> 856              */</span>
<span class="line-removed"> 857             do {</span>
<span class="line-removed"> 858                 node.prev = pred = pred.prev;</span>
<span class="line-removed"> 859             } while (pred.waitStatus &gt; 0);</span>
<span class="line-removed"> 860             pred.next = node;</span>
<span class="line-removed"> 861         } else {</span>
<span class="line-removed"> 862             /*</span>
<span class="line-removed"> 863              * waitStatus must be 0 or PROPAGATE.  Indicate that we</span>
<span class="line-removed"> 864              * need a signal, but don&#39;t park yet.  Caller will need to</span>
<span class="line-removed"> 865              * retry to make sure it cannot acquire before parking.</span>
<span class="line-removed"> 866              */</span>
<span class="line-removed"> 867             pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span>
 868         }
<span class="line-removed"> 869         return false;</span>
 870     }
 871 
 872     /**
<span class="line-modified"> 873      * Convenience method to interrupt current thread.</span>
<span class="line-removed"> 874      */</span>
<span class="line-removed"> 875     static void selfInterrupt() {</span>
<span class="line-removed"> 876         Thread.currentThread().interrupt();</span>
<span class="line-removed"> 877     }</span>
<span class="line-removed"> 878 </span>
<span class="line-removed"> 879     /**</span>
<span class="line-removed"> 880      * Convenience method to park and then check if interrupted.</span>
 881      *
<span class="line-modified"> 882      * @return {@code true} if interrupted</span>
<span class="line-removed"> 883      */</span>
<span class="line-removed"> 884     private final boolean parkAndCheckInterrupt() {</span>
<span class="line-removed"> 885         LockSupport.park(this);</span>
<span class="line-removed"> 886         return Thread.interrupted();</span>
<span class="line-removed"> 887     }</span>
<span class="line-removed"> 888 </span>
<span class="line-removed"> 889     /*</span>
<span class="line-removed"> 890      * Various flavors of acquire, varying in exclusive/shared and</span>
<span class="line-removed"> 891      * control modes.  Each is mostly the same, but annoyingly</span>
<span class="line-removed"> 892      * different.  Only a little bit of factoring is possible due to</span>
<span class="line-removed"> 893      * interactions of exception mechanics (including ensuring that we</span>
<span class="line-removed"> 894      * cancel if tryAcquire throws exception) and other control, at</span>
<span class="line-removed"> 895      * least not without hurting performance too much.</span>
<span class="line-removed"> 896      */</span>
<span class="line-removed"> 897 </span>
<span class="line-removed"> 898     /**</span>
<span class="line-removed"> 899      * Acquires in exclusive uninterruptible mode for thread already in</span>
<span class="line-removed"> 900      * queue. Used by condition wait methods as well as acquire.</span>
<span class="line-removed"> 901      *</span>
<span class="line-removed"> 902      * @param node the node</span>
 903      * @param arg the acquire argument
<span class="line-modified"> 904      * @return {@code true} if interrupted while waiting</span>




 905      */
<span class="line-modified"> 906     final boolean acquireQueued(final Node node, int arg) {</span>
<span class="line-modified"> 907         boolean interrupted = false;</span>
<span class="line-modified"> 908         try {</span>
<span class="line-modified"> 909             for (;;) {</span>
<span class="line-modified"> 910                 final Node p = node.predecessor();</span>
<span class="line-modified"> 911                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="line-removed"> 912                     setHead(node);</span>
<span class="line-removed"> 913                     p.next = null; // help GC</span>
<span class="line-removed"> 914                     return interrupted;</span>
<span class="line-removed"> 915                 }</span>
<span class="line-removed"> 916                 if (shouldParkAfterFailedAcquire(p, node))</span>
<span class="line-removed"> 917                     interrupted |= parkAndCheckInterrupt();</span>
<span class="line-removed"> 918             }</span>
<span class="line-removed"> 919         } catch (Throwable t) {</span>
<span class="line-removed"> 920             cancelAcquire(node);</span>
<span class="line-removed"> 921             if (interrupted)</span>
<span class="line-removed"> 922                 selfInterrupt();</span>
<span class="line-removed"> 923             throw t;</span>
<span class="line-removed"> 924         }</span>
<span class="line-removed"> 925     }</span>
 926 
<span class="line-modified"> 927     /**</span>
<span class="line-modified"> 928      * Acquires in exclusive interruptible mode.</span>
<span class="line-modified"> 929      * @param arg the acquire argument</span>
<span class="line-modified"> 930      */</span>
<span class="line-modified"> 931     private void doAcquireInterruptibly(int arg)</span>
<span class="line-modified"> 932         throws InterruptedException {</span>
<span class="line-modified"> 933         final Node node = addWaiter(Node.EXCLUSIVE);</span>
<span class="line-modified"> 934         try {</span>
<span class="line-modified"> 935             for (;;) {</span>
<span class="line-modified"> 936                 final Node p = node.predecessor();</span>
<span class="line-modified"> 937                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="line-modified"> 938                     setHead(node);</span>
<span class="line-modified"> 939                     p.next = null; // help GC</span>
<span class="line-modified"> 940                     return;</span>







 941                 }
<span class="line-removed"> 942                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-removed"> 943                     parkAndCheckInterrupt())</span>
<span class="line-removed"> 944                     throw new InterruptedException();</span>
 945             }
<span class="line-modified"> 946         } catch (Throwable t) {</span>
<span class="line-modified"> 947             cancelAcquire(node);</span>
<span class="line-modified"> 948             throw t;</span>
<span class="line-modified"> 949         }</span>
<span class="line-modified"> 950     }</span>
<span class="line-modified"> 951 </span>
<span class="line-modified"> 952     /**</span>
<span class="line-modified"> 953      * Acquires in exclusive timed mode.</span>
<span class="line-modified"> 954      *</span>
<span class="line-modified"> 955      * @param arg the acquire argument</span>
<span class="line-removed"> 956      * @param nanosTimeout max wait time</span>
<span class="line-removed"> 957      * @return {@code true} if acquired</span>
<span class="line-removed"> 958      */</span>
<span class="line-removed"> 959     private boolean doAcquireNanos(int arg, long nanosTimeout)</span>
<span class="line-removed"> 960             throws InterruptedException {</span>
<span class="line-removed"> 961         if (nanosTimeout &lt;= 0L)</span>
<span class="line-removed"> 962             return false;</span>
<span class="line-removed"> 963         final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-removed"> 964         final Node node = addWaiter(Node.EXCLUSIVE);</span>
<span class="line-removed"> 965         try {</span>
<span class="line-removed"> 966             for (;;) {</span>
<span class="line-removed"> 967                 final Node p = node.predecessor();</span>
<span class="line-removed"> 968                 if (p == head &amp;&amp; tryAcquire(arg)) {</span>
<span class="line-removed"> 969                     setHead(node);</span>
<span class="line-removed"> 970                     p.next = null; // help GC</span>
<span class="line-removed"> 971                     return true;</span>
 972                 }
<span class="line-modified"> 973                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="line-modified"> 974                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-modified"> 975                     cancelAcquire(node);</span>
<span class="line-modified"> 976                     return false;</span>








 977                 }
<span class="line-removed"> 978                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-removed"> 979                     nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed"> 980                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed"> 981                 if (Thread.interrupted())</span>
<span class="line-removed"> 982                     throw new InterruptedException();</span>
 983             }
<span class="line-modified"> 984         } catch (Throwable t) {</span>
<span class="line-modified"> 985             cancelAcquire(node);</span>
<span class="line-modified"> 986             throw t;</span>






























 987         }

 988     }
 989 
 990     /**
<span class="line-modified"> 991      * Acquires in shared uninterruptible mode.</span>
<span class="line-modified"> 992      * @param arg the acquire argument</span>

 993      */
<span class="line-modified"> 994     private void doAcquireShared(int arg) {</span>
<span class="line-modified"> 995         final Node node = addWaiter(Node.SHARED);</span>
<span class="line-modified"> 996         boolean interrupted = false;</span>
<span class="line-modified"> 997         try {</span>
<span class="line-modified"> 998             for (;;) {</span>
<span class="line-modified"> 999                 final Node p = node.predecessor();</span>
<span class="line-modified">1000                 if (p == head) {</span>
<span class="line-modified">1001                     int r = tryAcquireShared(arg);</span>
<span class="line-modified">1002                     if (r &gt;= 0) {</span>
<span class="line-modified">1003                         setHeadAndPropagate(node, r);</span>
<span class="line-modified">1004                         p.next = null; // help GC</span>
<span class="line-modified">1005                         return;</span>

1006                     }

1007                 }
<span class="line-modified">1008                 if (shouldParkAfterFailedAcquire(p, node))</span>
<span class="line-modified">1009                     interrupted |= parkAndCheckInterrupt();</span>
<span class="line-modified">1010             }</span>
<span class="line-modified">1011         } catch (Throwable t) {</span>
<span class="line-modified">1012             cancelAcquire(node);</span>
<span class="line-removed">1013             throw t;</span>
<span class="line-removed">1014         } finally {</span>
<span class="line-removed">1015             if (interrupted)</span>
<span class="line-removed">1016                 selfInterrupt();</span>
<span class="line-removed">1017         }</span>
<span class="line-removed">1018     }</span>
<span class="line-removed">1019 </span>
<span class="line-removed">1020     /**</span>
<span class="line-removed">1021      * Acquires in shared interruptible mode.</span>
<span class="line-removed">1022      * @param arg the acquire argument</span>
<span class="line-removed">1023      */</span>
<span class="line-removed">1024     private void doAcquireSharedInterruptibly(int arg)</span>
<span class="line-removed">1025         throws InterruptedException {</span>
<span class="line-removed">1026         final Node node = addWaiter(Node.SHARED);</span>
<span class="line-removed">1027         try {</span>
<span class="line-removed">1028             for (;;) {</span>
<span class="line-removed">1029                 final Node p = node.predecessor();</span>
<span class="line-removed">1030                 if (p == head) {</span>
<span class="line-removed">1031                     int r = tryAcquireShared(arg);</span>
<span class="line-removed">1032                     if (r &gt;= 0) {</span>
<span class="line-removed">1033                         setHeadAndPropagate(node, r);</span>
<span class="line-removed">1034                         p.next = null; // help GC</span>
<span class="line-removed">1035                         return;</span>
1036                     }

1037                 }
<span class="line-modified">1038                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-modified">1039                     parkAndCheckInterrupt())</span>
<span class="line-removed">1040                     throw new InterruptedException();</span>
1041             }
<span class="line-removed">1042         } catch (Throwable t) {</span>
<span class="line-removed">1043             cancelAcquire(node);</span>
<span class="line-removed">1044             throw t;</span>
1045         }
1046     }
1047 
1048     /**
<span class="line-modified">1049      * Acquires in shared timed mode.</span>
1050      *
<span class="line-modified">1051      * @param arg the acquire argument</span>
<span class="line-modified">1052      * @param nanosTimeout max wait time</span>
<span class="line-modified">1053      * @return {@code true} if acquired</span>
1054      */
<span class="line-modified">1055     private boolean doAcquireSharedNanos(int arg, long nanosTimeout)</span>
<span class="line-modified">1056             throws InterruptedException {</span>
<span class="line-modified">1057         if (nanosTimeout &lt;= 0L)</span>
<span class="line-modified">1058             return false;</span>
<span class="line-modified">1059         final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-modified">1060         final Node node = addWaiter(Node.SHARED);</span>
<span class="line-modified">1061         try {</span>
<span class="line-modified">1062             for (;;) {</span>
<span class="line-modified">1063                 final Node p = node.predecessor();</span>
<span class="line-modified">1064                 if (p == head) {</span>
<span class="line-modified">1065                     int r = tryAcquireShared(arg);</span>
<span class="line-modified">1066                     if (r &gt;= 0) {</span>
<span class="line-modified">1067                         setHeadAndPropagate(node, r);</span>
<span class="line-removed">1068                         p.next = null; // help GC</span>
<span class="line-removed">1069                         return true;</span>
<span class="line-removed">1070                     }</span>
<span class="line-removed">1071                 }</span>
<span class="line-removed">1072                 nanosTimeout = deadline - System.nanoTime();</span>
<span class="line-removed">1073                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-removed">1074                     cancelAcquire(node);</span>
<span class="line-removed">1075                     return false;</span>
<span class="line-removed">1076                 }</span>
<span class="line-removed">1077                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span>
<span class="line-removed">1078                     nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed">1079                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed">1080                 if (Thread.interrupted())</span>
<span class="line-removed">1081                     throw new InterruptedException();</span>
<span class="line-removed">1082             }</span>
<span class="line-removed">1083         } catch (Throwable t) {</span>
<span class="line-removed">1084             cancelAcquire(node);</span>
<span class="line-removed">1085             throw t;</span>
1086         }

1087     }
1088 
1089     // Main exported methods
1090 
1091     /**
1092      * Attempts to acquire in exclusive mode. This method should query
1093      * if the state of the object permits it to be acquired in the
1094      * exclusive mode, and if so to acquire it.
1095      *
1096      * &lt;p&gt;This method is always invoked by the thread performing
1097      * acquire.  If this method reports failure, the acquire method
1098      * may queue the thread, if it is not already queued, until it is
1099      * signalled by a release from some other thread. This can be used
1100      * to implement method {@link Lock#tryLock()}.
1101      *
1102      * &lt;p&gt;The default
1103      * implementation throws {@link UnsupportedOperationException}.
1104      *
1105      * @param arg the acquire argument. This value is always the one
1106      *        passed to an acquire method, or is the value saved on entry
</pre>
<hr />
<pre>
1219      *         {@code false} otherwise
1220      * @throws UnsupportedOperationException if conditions are not supported
1221      */
1222     protected boolean isHeldExclusively() {
1223         throw new UnsupportedOperationException();
1224     }
1225 
1226     /**
1227      * Acquires in exclusive mode, ignoring interrupts.  Implemented
1228      * by invoking at least once {@link #tryAcquire},
1229      * returning on success.  Otherwise the thread is queued, possibly
1230      * repeatedly blocking and unblocking, invoking {@link
1231      * #tryAcquire} until success.  This method can be used
1232      * to implement method {@link Lock#lock}.
1233      *
1234      * @param arg the acquire argument.  This value is conveyed to
1235      *        {@link #tryAcquire} but is otherwise uninterpreted and
1236      *        can represent anything you like.
1237      */
1238     public final void acquire(int arg) {
<span class="line-modified">1239         if (!tryAcquire(arg) &amp;&amp;</span>
<span class="line-modified">1240             acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span>
<span class="line-removed">1241             selfInterrupt();</span>
1242     }
1243 
1244     /**
1245      * Acquires in exclusive mode, aborting if interrupted.
1246      * Implemented by first checking interrupt status, then invoking
1247      * at least once {@link #tryAcquire}, returning on
1248      * success.  Otherwise the thread is queued, possibly repeatedly
1249      * blocking and unblocking, invoking {@link #tryAcquire}
1250      * until success or the thread is interrupted.  This method can be
1251      * used to implement method {@link Lock#lockInterruptibly}.
1252      *
1253      * @param arg the acquire argument.  This value is conveyed to
1254      *        {@link #tryAcquire} but is otherwise uninterpreted and
1255      *        can represent anything you like.
1256      * @throws InterruptedException if the current thread is interrupted
1257      */
1258     public final void acquireInterruptibly(int arg)
<span class="line-modified">1259             throws InterruptedException {</span>
<span class="line-modified">1260         if (Thread.interrupted())</span>

1261             throw new InterruptedException();
<span class="line-removed">1262         if (!tryAcquire(arg))</span>
<span class="line-removed">1263             doAcquireInterruptibly(arg);</span>
1264     }
1265 
1266     /**
1267      * Attempts to acquire in exclusive mode, aborting if interrupted,
1268      * and failing if the given timeout elapses.  Implemented by first
1269      * checking interrupt status, then invoking at least once {@link
1270      * #tryAcquire}, returning on success.  Otherwise, the thread is
1271      * queued, possibly repeatedly blocking and unblocking, invoking
1272      * {@link #tryAcquire} until success or the thread is interrupted
1273      * or the timeout elapses.  This method can be used to implement
1274      * method {@link Lock#tryLock(long, TimeUnit)}.
1275      *
1276      * @param arg the acquire argument.  This value is conveyed to
1277      *        {@link #tryAcquire} but is otherwise uninterpreted and
1278      *        can represent anything you like.
1279      * @param nanosTimeout the maximum number of nanoseconds to wait
1280      * @return {@code true} if acquired; {@code false} if timed out
1281      * @throws InterruptedException if the current thread is interrupted
1282      */
1283     public final boolean tryAcquireNanos(int arg, long nanosTimeout)
<span class="line-modified">1284             throws InterruptedException {</span>
<span class="line-modified">1285         if (Thread.interrupted())</span>
<span class="line-modified">1286             throw new InterruptedException();</span>
<span class="line-modified">1287         return tryAcquire(arg) ||</span>
<span class="line-modified">1288             doAcquireNanos(arg, nanosTimeout);</span>









1289     }
1290 
1291     /**
1292      * Releases in exclusive mode.  Implemented by unblocking one or
1293      * more threads if {@link #tryRelease} returns true.
1294      * This method can be used to implement method {@link Lock#unlock}.
1295      *
1296      * @param arg the release argument.  This value is conveyed to
1297      *        {@link #tryRelease} but is otherwise uninterpreted and
1298      *        can represent anything you like.
1299      * @return the value returned from {@link #tryRelease}
1300      */
1301     public final boolean release(int arg) {
1302         if (tryRelease(arg)) {
<span class="line-modified">1303             Node h = head;</span>
<span class="line-removed">1304             if (h != null &amp;&amp; h.waitStatus != 0)</span>
<span class="line-removed">1305                 unparkSuccessor(h);</span>
1306             return true;
1307         }
1308         return false;
1309     }
1310 
1311     /**
1312      * Acquires in shared mode, ignoring interrupts.  Implemented by
1313      * first invoking at least once {@link #tryAcquireShared},
1314      * returning on success.  Otherwise the thread is queued, possibly
1315      * repeatedly blocking and unblocking, invoking {@link
1316      * #tryAcquireShared} until success.
1317      *
1318      * @param arg the acquire argument.  This value is conveyed to
1319      *        {@link #tryAcquireShared} but is otherwise uninterpreted
1320      *        and can represent anything you like.
1321      */
1322     public final void acquireShared(int arg) {
1323         if (tryAcquireShared(arg) &lt; 0)
<span class="line-modified">1324             doAcquireShared(arg);</span>
1325     }
1326 
1327     /**
1328      * Acquires in shared mode, aborting if interrupted.  Implemented
1329      * by first checking interrupt status, then invoking at least once
1330      * {@link #tryAcquireShared}, returning on success.  Otherwise the
1331      * thread is queued, possibly repeatedly blocking and unblocking,
1332      * invoking {@link #tryAcquireShared} until success or the thread
1333      * is interrupted.
1334      * @param arg the acquire argument.
1335      * This value is conveyed to {@link #tryAcquireShared} but is
1336      * otherwise uninterpreted and can represent anything
1337      * you like.
1338      * @throws InterruptedException if the current thread is interrupted
1339      */
1340     public final void acquireSharedInterruptibly(int arg)
<span class="line-modified">1341             throws InterruptedException {</span>
<span class="line-modified">1342         if (Thread.interrupted())</span>


1343             throw new InterruptedException();
<span class="line-removed">1344         if (tryAcquireShared(arg) &lt; 0)</span>
<span class="line-removed">1345             doAcquireSharedInterruptibly(arg);</span>
1346     }
1347 
1348     /**
1349      * Attempts to acquire in shared mode, aborting if interrupted, and
1350      * failing if the given timeout elapses.  Implemented by first
1351      * checking interrupt status, then invoking at least once {@link
1352      * #tryAcquireShared}, returning on success.  Otherwise, the
1353      * thread is queued, possibly repeatedly blocking and unblocking,
1354      * invoking {@link #tryAcquireShared} until success or the thread
1355      * is interrupted or the timeout elapses.
1356      *
1357      * @param arg the acquire argument.  This value is conveyed to
1358      *        {@link #tryAcquireShared} but is otherwise uninterpreted
1359      *        and can represent anything you like.
1360      * @param nanosTimeout the maximum number of nanoseconds to wait
1361      * @return {@code true} if acquired; {@code false} if timed out
1362      * @throws InterruptedException if the current thread is interrupted
1363      */
1364     public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
1365             throws InterruptedException {
<span class="line-modified">1366         if (Thread.interrupted())</span>
<span class="line-modified">1367             throw new InterruptedException();</span>
<span class="line-modified">1368         return tryAcquireShared(arg) &gt;= 0 ||</span>
<span class="line-modified">1369             doAcquireSharedNanos(arg, nanosTimeout);</span>









1370     }
1371 
1372     /**
1373      * Releases in shared mode.  Implemented by unblocking one or more
1374      * threads if {@link #tryReleaseShared} returns true.
1375      *
1376      * @param arg the release argument.  This value is conveyed to
1377      *        {@link #tryReleaseShared} but is otherwise uninterpreted
1378      *        and can represent anything you like.
1379      * @return the value returned from {@link #tryReleaseShared}
1380      */
1381     public final boolean releaseShared(int arg) {
1382         if (tryReleaseShared(arg)) {
<span class="line-modified">1383             doReleaseShared();</span>
1384             return true;
1385         }
1386         return false;
1387     }
1388 
1389     // Queue inspection methods
1390 
1391     /**
1392      * Queries whether any threads are waiting to acquire. Note that
1393      * because cancellations due to interrupts and timeouts may occur
1394      * at any time, a {@code true} return does not guarantee that any
1395      * other thread will ever acquire.
1396      *
1397      * @return {@code true} if there may be other threads waiting to acquire
1398      */
1399     public final boolean hasQueuedThreads() {
1400         for (Node p = tail, h = head; p != h &amp;&amp; p != null; p = p.prev)
<span class="line-modified">1401             if (p.waitStatus &lt;= 0)</span>
1402                 return true;
1403         return false;
1404     }
1405 
1406     /**
1407      * Queries whether any threads have ever contended to acquire this
1408      * synchronizer; that is, if an acquire method has ever blocked.
1409      *
1410      * &lt;p&gt;In this implementation, this operation returns in
1411      * constant time.
1412      *
1413      * @return {@code true} if there has ever been contention
1414      */
1415     public final boolean hasContended() {
1416         return head != null;
1417     }
1418 
1419     /**
1420      * Returns the first (longest-waiting) thread in the queue, or
1421      * {@code null} if no threads are currently queued.
1422      *
1423      * &lt;p&gt;In this implementation, this operation normally returns in
1424      * constant time, but may iterate upon contention if other threads are
1425      * concurrently modifying the queue.
1426      *
1427      * @return the first (longest-waiting) thread in the queue, or
1428      *         {@code null} if no threads are currently queued
1429      */
1430     public final Thread getFirstQueuedThread() {
<span class="line-modified">1431         // handle only fast path, else relay</span>
<span class="line-modified">1432         return (head == tail) ? null : fullGetFirstQueuedThread();</span>
<span class="line-modified">1433     }</span>
<span class="line-modified">1434 </span>
<span class="line-modified">1435     /**</span>
<span class="line-modified">1436      * Version of getFirstQueuedThread called when fastpath fails.</span>
<span class="line-modified">1437      */</span>
<span class="line-modified">1438     private Thread fullGetFirstQueuedThread() {</span>
<span class="line-removed">1439         /*</span>
<span class="line-removed">1440          * The first node is normally head.next. Try to get its</span>
<span class="line-removed">1441          * thread field, ensuring consistent reads: If thread</span>
<span class="line-removed">1442          * field is nulled out or s.prev is no longer head, then</span>
<span class="line-removed">1443          * some other thread(s) concurrently performed setHead in</span>
<span class="line-removed">1444          * between some of our reads. We try this twice before</span>
<span class="line-removed">1445          * resorting to traversal.</span>
<span class="line-removed">1446          */</span>
<span class="line-removed">1447         Node h, s;</span>
<span class="line-removed">1448         Thread st;</span>
<span class="line-removed">1449         if (((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="line-removed">1450              s.prev == head &amp;&amp; (st = s.thread) != null) ||</span>
<span class="line-removed">1451             ((h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="line-removed">1452              s.prev == head &amp;&amp; (st = s.thread) != null))</span>
<span class="line-removed">1453             return st;</span>
<span class="line-removed">1454 </span>
<span class="line-removed">1455         /*</span>
<span class="line-removed">1456          * Head&#39;s next field might not have been set yet, or may have</span>
<span class="line-removed">1457          * been unset after setHead. So we must check to see if tail</span>
<span class="line-removed">1458          * is actually first node. If not, we continue on, safely</span>
<span class="line-removed">1459          * traversing from tail back to head to find first,</span>
<span class="line-removed">1460          * guaranteeing termination.</span>
<span class="line-removed">1461          */</span>
<span class="line-removed">1462 </span>
<span class="line-removed">1463         Thread firstThread = null;</span>
<span class="line-removed">1464         for (Node p = tail; p != null &amp;&amp; p != head; p = p.prev) {</span>
<span class="line-removed">1465             Thread t = p.thread;</span>
<span class="line-removed">1466             if (t != null)</span>
<span class="line-removed">1467                 firstThread = t;</span>
1468         }
<span class="line-modified">1469         return firstThread;</span>
1470     }
1471 
1472     /**
1473      * Returns true if the given thread is currently queued.
1474      *
1475      * &lt;p&gt;This implementation traverses the queue to determine
1476      * presence of the given thread.
1477      *
1478      * @param thread the thread
1479      * @return {@code true} if the given thread is on the queue
1480      * @throws NullPointerException if the thread is null
1481      */
1482     public final boolean isQueued(Thread thread) {
1483         if (thread == null)
1484             throw new NullPointerException();
1485         for (Node p = tail; p != null; p = p.prev)
<span class="line-modified">1486             if (p.thread == thread)</span>
1487                 return true;
1488         return false;
1489     }
1490 
1491     /**
1492      * Returns {@code true} if the apparent first queued thread, if one
1493      * exists, is waiting in exclusive mode.  If this method returns
1494      * {@code true}, and the current thread is attempting to acquire in
1495      * shared mode (that is, this method is invoked from {@link
1496      * #tryAcquireShared}) then it is guaranteed that the current thread
1497      * is not the first queued thread.  Used only as a heuristic in
1498      * ReentrantReadWriteLock.
1499      */
1500     final boolean apparentlyFirstQueuedIsExclusive() {
1501         Node h, s;
<span class="line-modified">1502         return (h = head) != null &amp;&amp;</span>
<span class="line-modified">1503             (s = h.next)  != null &amp;&amp;</span>
<span class="line-removed">1504             !s.isShared()         &amp;&amp;</span>
<span class="line-removed">1505             s.thread != null;</span>
1506     }
1507 
1508     /**
1509      * Queries whether any threads have been waiting to acquire longer
1510      * than the current thread.
1511      *
1512      * &lt;p&gt;An invocation of this method is equivalent to (but may be
1513      * more efficient than):
1514      * &lt;pre&gt; {@code
1515      * getFirstQueuedThread() != Thread.currentThread()
1516      *   &amp;&amp; hasQueuedThreads()}&lt;/pre&gt;
1517      *
1518      * &lt;p&gt;Note that because cancellations due to interrupts and
1519      * timeouts may occur at any time, a {@code true} return does not
1520      * guarantee that some other thread will acquire before the current
1521      * thread.  Likewise, it is possible for another thread to win a
1522      * race to enqueue after this method has returned {@code false},
1523      * due to the queue being empty.
1524      *
1525      * &lt;p&gt;This method is designed to be used by a fair synchronizer to
</pre>
<hr />
<pre>
1532      * synchronizer might look like this:
1533      *
1534      * &lt;pre&gt; {@code
1535      * protected boolean tryAcquire(int arg) {
1536      *   if (isHeldExclusively()) {
1537      *     // A reentrant acquire; increment hold count
1538      *     return true;
1539      *   } else if (hasQueuedPredecessors()) {
1540      *     return false;
1541      *   } else {
1542      *     // try to acquire normally
1543      *   }
1544      * }}&lt;/pre&gt;
1545      *
1546      * @return {@code true} if there is a queued thread preceding the
1547      *         current thread, and {@code false} if the current thread
1548      *         is at the head of the queue or the queue is empty
1549      * @since 1.7
1550      */
1551     public final boolean hasQueuedPredecessors() {
<span class="line-modified">1552         Node h, s;</span>
<span class="line-modified">1553         if ((h = head) != null) {</span>
<span class="line-modified">1554             if ((s = h.next) == null || s.waitStatus &gt; 0) {</span>
<span class="line-modified">1555                 s = null; // traverse in case of concurrent cancellation</span>
<span class="line-modified">1556                 for (Node p = tail; p != h &amp;&amp; p != null; p = p.prev) {</span>
<span class="line-modified">1557                     if (p.waitStatus &lt;= 0)</span>
<span class="line-removed">1558                         s = p;</span>
<span class="line-removed">1559                 }</span>
<span class="line-removed">1560             }</span>
<span class="line-removed">1561             if (s != null &amp;&amp; s.thread != Thread.currentThread())</span>
<span class="line-removed">1562                 return true;</span>
<span class="line-removed">1563         }</span>
<span class="line-removed">1564         return false;</span>
1565     }
1566 
1567     // Instrumentation and monitoring methods
1568 
1569     /**
1570      * Returns an estimate of the number of threads waiting to
1571      * acquire.  The value is only an estimate because the number of
1572      * threads may change dynamically while this method traverses
1573      * internal data structures.  This method is designed for use in
1574      * monitoring system state, not for synchronization control.
1575      *
1576      * @return the estimated number of threads waiting to acquire
1577      */
1578     public final int getQueueLength() {
1579         int n = 0;
1580         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1581             if (p.thread != null)</span>
1582                 ++n;
1583         }
1584         return n;
1585     }
1586 
1587     /**
1588      * Returns a collection containing threads that may be waiting to
1589      * acquire.  Because the actual set of threads may change
1590      * dynamically while constructing this result, the returned
1591      * collection is only a best-effort estimate.  The elements of the
1592      * returned collection are in no particular order.  This method is
1593      * designed to facilitate construction of subclasses that provide
1594      * more extensive monitoring facilities.
1595      *
1596      * @return the collection of threads
1597      */
1598     public final Collection&lt;Thread&gt; getQueuedThreads() {
1599         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1600         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1601             Thread t = p.thread;</span>
1602             if (t != null)
1603                 list.add(t);
1604         }
1605         return list;
1606     }
1607 
1608     /**
1609      * Returns a collection containing threads that may be waiting to
1610      * acquire in exclusive mode. This has the same properties
1611      * as {@link #getQueuedThreads} except that it only returns
1612      * those threads waiting due to an exclusive acquire.
1613      *
1614      * @return the collection of threads
1615      */
1616     public final Collection&lt;Thread&gt; getExclusiveQueuedThreads() {
1617         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1618         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1619             if (!p.isShared()) {</span>
<span class="line-modified">1620                 Thread t = p.thread;</span>
1621                 if (t != null)
1622                     list.add(t);
1623             }
1624         }
1625         return list;
1626     }
1627 
1628     /**
1629      * Returns a collection containing threads that may be waiting to
1630      * acquire in shared mode. This has the same properties
1631      * as {@link #getQueuedThreads} except that it only returns
1632      * those threads waiting due to a shared acquire.
1633      *
1634      * @return the collection of threads
1635      */
1636     public final Collection&lt;Thread&gt; getSharedQueuedThreads() {
1637         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1638         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1639             if (p.isShared()) {</span>
<span class="line-modified">1640                 Thread t = p.thread;</span>
1641                 if (t != null)
1642                     list.add(t);
1643             }
1644         }
1645         return list;
1646     }
1647 
1648     /**
1649      * Returns a string identifying this synchronizer, as well as its state.
1650      * The state, in brackets, includes the String {@code &quot;State =&quot;}
1651      * followed by the current value of {@link #getState}, and either
1652      * {@code &quot;nonempty&quot;} or {@code &quot;empty&quot;} depending on whether the
1653      * queue is empty.
1654      *
1655      * @return a string identifying this synchronizer, as well as its state
1656      */
1657     public String toString() {
1658         return super.toString()
1659             + &quot;[State = &quot; + getState() + &quot;, &quot;
1660             + (hasQueuedThreads() ? &quot;non&quot; : &quot;&quot;) + &quot;empty queue]&quot;;
1661     }
1662 
<span class="line-removed">1663 </span>
<span class="line-removed">1664     // Internal support methods for Conditions</span>
<span class="line-removed">1665 </span>
<span class="line-removed">1666     /**</span>
<span class="line-removed">1667      * Returns true if a node, always one that was initially placed on</span>
<span class="line-removed">1668      * a condition queue, is now waiting to reacquire on sync queue.</span>
<span class="line-removed">1669      * @param node the node</span>
<span class="line-removed">1670      * @return true if is reacquiring</span>
<span class="line-removed">1671      */</span>
<span class="line-removed">1672     final boolean isOnSyncQueue(Node node) {</span>
<span class="line-removed">1673         if (node.waitStatus == Node.CONDITION || node.prev == null)</span>
<span class="line-removed">1674             return false;</span>
<span class="line-removed">1675         if (node.next != null) // If has successor, it must be on queue</span>
<span class="line-removed">1676             return true;</span>
<span class="line-removed">1677         /*</span>
<span class="line-removed">1678          * node.prev can be non-null, but not yet on queue because</span>
<span class="line-removed">1679          * the CAS to place it on queue can fail. So we have to</span>
<span class="line-removed">1680          * traverse from tail to make sure it actually made it.  It</span>
<span class="line-removed">1681          * will always be near the tail in calls to this method, and</span>
<span class="line-removed">1682          * unless the CAS failed (which is unlikely), it will be</span>
<span class="line-removed">1683          * there, so we hardly ever traverse much.</span>
<span class="line-removed">1684          */</span>
<span class="line-removed">1685         return findNodeFromTail(node);</span>
<span class="line-removed">1686     }</span>
<span class="line-removed">1687 </span>
<span class="line-removed">1688     /**</span>
<span class="line-removed">1689      * Returns true if node is on sync queue by searching backwards from tail.</span>
<span class="line-removed">1690      * Called only when needed by isOnSyncQueue.</span>
<span class="line-removed">1691      * @return true if present</span>
<span class="line-removed">1692      */</span>
<span class="line-removed">1693     private boolean findNodeFromTail(Node node) {</span>
<span class="line-removed">1694         // We check for node first, since it&#39;s likely to be at or near tail.</span>
<span class="line-removed">1695         // tail is known to be non-null, so we could re-order to &quot;save&quot;</span>
<span class="line-removed">1696         // one null check, but we leave it this way to help the VM.</span>
<span class="line-removed">1697         for (Node p = tail;;) {</span>
<span class="line-removed">1698             if (p == node)</span>
<span class="line-removed">1699                 return true;</span>
<span class="line-removed">1700             if (p == null)</span>
<span class="line-removed">1701                 return false;</span>
<span class="line-removed">1702             p = p.prev;</span>
<span class="line-removed">1703         }</span>
<span class="line-removed">1704     }</span>
<span class="line-removed">1705 </span>
<span class="line-removed">1706     /**</span>
<span class="line-removed">1707      * Transfers a node from a condition queue onto sync queue.</span>
<span class="line-removed">1708      * Returns true if successful.</span>
<span class="line-removed">1709      * @param node the node</span>
<span class="line-removed">1710      * @return true if successfully transferred (else the node was</span>
<span class="line-removed">1711      * cancelled before signal)</span>
<span class="line-removed">1712      */</span>
<span class="line-removed">1713     final boolean transferForSignal(Node node) {</span>
<span class="line-removed">1714         /*</span>
<span class="line-removed">1715          * If cannot change waitStatus, the node has been cancelled.</span>
<span class="line-removed">1716          */</span>
<span class="line-removed">1717         if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))</span>
<span class="line-removed">1718             return false;</span>
<span class="line-removed">1719 </span>
<span class="line-removed">1720         /*</span>
<span class="line-removed">1721          * Splice onto queue and try to set waitStatus of predecessor to</span>
<span class="line-removed">1722          * indicate that thread is (probably) waiting. If cancelled or</span>
<span class="line-removed">1723          * attempt to set waitStatus fails, wake up to resync (in which</span>
<span class="line-removed">1724          * case the waitStatus can be transiently and harmlessly wrong).</span>
<span class="line-removed">1725          */</span>
<span class="line-removed">1726         Node p = enq(node);</span>
<span class="line-removed">1727         int ws = p.waitStatus;</span>
<span class="line-removed">1728         if (ws &gt; 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))</span>
<span class="line-removed">1729             LockSupport.unpark(node.thread);</span>
<span class="line-removed">1730         return true;</span>
<span class="line-removed">1731     }</span>
<span class="line-removed">1732 </span>
<span class="line-removed">1733     /**</span>
<span class="line-removed">1734      * Transfers node, if necessary, to sync queue after a cancelled wait.</span>
<span class="line-removed">1735      * Returns true if thread was cancelled before being signalled.</span>
<span class="line-removed">1736      *</span>
<span class="line-removed">1737      * @param node the node</span>
<span class="line-removed">1738      * @return true if cancelled before the node was signalled</span>
<span class="line-removed">1739      */</span>
<span class="line-removed">1740     final boolean transferAfterCancelledWait(Node node) {</span>
<span class="line-removed">1741         if (node.compareAndSetWaitStatus(Node.CONDITION, 0)) {</span>
<span class="line-removed">1742             enq(node);</span>
<span class="line-removed">1743             return true;</span>
<span class="line-removed">1744         }</span>
<span class="line-removed">1745         /*</span>
<span class="line-removed">1746          * If we lost out to a signal(), then we can&#39;t proceed</span>
<span class="line-removed">1747          * until it finishes its enq().  Cancelling during an</span>
<span class="line-removed">1748          * incomplete transfer is both rare and transient, so just</span>
<span class="line-removed">1749          * spin.</span>
<span class="line-removed">1750          */</span>
<span class="line-removed">1751         while (!isOnSyncQueue(node))</span>
<span class="line-removed">1752             Thread.yield();</span>
<span class="line-removed">1753         return false;</span>
<span class="line-removed">1754     }</span>
<span class="line-removed">1755 </span>
<span class="line-removed">1756     /**</span>
<span class="line-removed">1757      * Invokes release with current state value; returns saved state.</span>
<span class="line-removed">1758      * Cancels node and throws exception on failure.</span>
<span class="line-removed">1759      * @param node the condition node for this wait</span>
<span class="line-removed">1760      * @return previous sync state</span>
<span class="line-removed">1761      */</span>
<span class="line-removed">1762     final int fullyRelease(Node node) {</span>
<span class="line-removed">1763         try {</span>
<span class="line-removed">1764             int savedState = getState();</span>
<span class="line-removed">1765             if (release(savedState))</span>
<span class="line-removed">1766                 return savedState;</span>
<span class="line-removed">1767             throw new IllegalMonitorStateException();</span>
<span class="line-removed">1768         } catch (Throwable t) {</span>
<span class="line-removed">1769             node.waitStatus = Node.CANCELLED;</span>
<span class="line-removed">1770             throw t;</span>
<span class="line-removed">1771         }</span>
<span class="line-removed">1772     }</span>
<span class="line-removed">1773 </span>
1774     // Instrumentation methods for conditions
1775 
1776     /**
1777      * Queries whether the given ConditionObject
1778      * uses this synchronizer as its lock.
1779      *
1780      * @param condition the condition
1781      * @return {@code true} if owned
1782      * @throws NullPointerException if the condition is null
1783      */
1784     public final boolean owns(ConditionObject condition) {
1785         return condition.isOwnedBy(this);
1786     }
1787 
1788     /**
1789      * Queries whether any threads are waiting on the given condition
1790      * associated with this synchronizer. Note that because timeouts
1791      * and interrupts may occur at any time, a {@code true} return
1792      * does not guarantee that a future {@code signal} will awaken
1793      * any threads.  This method is designed primarily for use in
</pre>
<hr />
<pre>
1851         return condition.getWaitingThreads();
1852     }
1853 
1854     /**
1855      * Condition implementation for a {@link AbstractQueuedSynchronizer}
1856      * serving as the basis of a {@link Lock} implementation.
1857      *
1858      * &lt;p&gt;Method documentation for this class describes mechanics,
1859      * not behavioral specifications from the point of view of Lock
1860      * and Condition users. Exported versions of this class will in
1861      * general need to be accompanied by documentation describing
1862      * condition semantics that rely on those of the associated
1863      * {@code AbstractQueuedSynchronizer}.
1864      *
1865      * &lt;p&gt;This class is Serializable, but all fields are transient,
1866      * so deserialized conditions have no waiters.
1867      */
1868     public class ConditionObject implements Condition, java.io.Serializable {
1869         private static final long serialVersionUID = 1173984872572414699L;
1870         /** First node of condition queue. */
<span class="line-modified">1871         private transient Node firstWaiter;</span>
1872         /** Last node of condition queue. */
<span class="line-modified">1873         private transient Node lastWaiter;</span>
1874 
1875         /**
1876          * Creates a new {@code ConditionObject} instance.
1877          */
1878         public ConditionObject() { }
1879 
<span class="line-modified">1880         // Internal methods</span>
<span class="line-removed">1881 </span>
<span class="line-removed">1882         /**</span>
<span class="line-removed">1883          * Adds a new waiter to wait queue.</span>
<span class="line-removed">1884          * @return its new wait node</span>
<span class="line-removed">1885          */</span>
<span class="line-removed">1886         private Node addConditionWaiter() {</span>
<span class="line-removed">1887             if (!isHeldExclusively())</span>
<span class="line-removed">1888                 throw new IllegalMonitorStateException();</span>
<span class="line-removed">1889             Node t = lastWaiter;</span>
<span class="line-removed">1890             // If lastWaiter is cancelled, clean out.</span>
<span class="line-removed">1891             if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {</span>
<span class="line-removed">1892                 unlinkCancelledWaiters();</span>
<span class="line-removed">1893                 t = lastWaiter;</span>
<span class="line-removed">1894             }</span>
<span class="line-removed">1895 </span>
<span class="line-removed">1896             Node node = new Node(Node.CONDITION);</span>
<span class="line-removed">1897 </span>
<span class="line-removed">1898             if (t == null)</span>
<span class="line-removed">1899                 firstWaiter = node;</span>
<span class="line-removed">1900             else</span>
<span class="line-removed">1901                 t.nextWaiter = node;</span>
<span class="line-removed">1902             lastWaiter = node;</span>
<span class="line-removed">1903             return node;</span>
<span class="line-removed">1904         }</span>
1905 
1906         /**
<span class="line-modified">1907          * Removes and transfers nodes until hit non-cancelled one or</span>
<span class="line-removed">1908          * null. Split out from signal in part to encourage compilers</span>
<span class="line-removed">1909          * to inline the case of no waiters.</span>
<span class="line-removed">1910          * @param first (non-null) the first node on condition queue</span>
1911          */
<span class="line-modified">1912         private void doSignal(Node first) {</span>
<span class="line-modified">1913             do {</span>
<span class="line-modified">1914                 if ( (firstWaiter = first.nextWaiter) == null)</span>

1915                     lastWaiter = null;
<span class="line-modified">1916                 first.nextWaiter = null;</span>
<span class="line-modified">1917             } while (!transferForSignal(first) &amp;&amp;</span>
<span class="line-modified">1918                      (first = firstWaiter) != null);</span>
<span class="line-modified">1919         }</span>
<span class="line-removed">1920 </span>
<span class="line-removed">1921         /**</span>
<span class="line-removed">1922          * Removes and transfers all nodes.</span>
<span class="line-removed">1923          * @param first (non-null) the first node on condition queue</span>
<span class="line-removed">1924          */</span>
<span class="line-removed">1925         private void doSignalAll(Node first) {</span>
<span class="line-removed">1926             lastWaiter = firstWaiter = null;</span>
<span class="line-removed">1927             do {</span>
<span class="line-removed">1928                 Node next = first.nextWaiter;</span>
<span class="line-removed">1929                 first.nextWaiter = null;</span>
<span class="line-removed">1930                 transferForSignal(first);</span>
<span class="line-removed">1931                 first = next;</span>
<span class="line-removed">1932             } while (first != null);</span>
<span class="line-removed">1933         }</span>
<span class="line-removed">1934 </span>
<span class="line-removed">1935         /**</span>
<span class="line-removed">1936          * Unlinks cancelled waiter nodes from condition queue.</span>
<span class="line-removed">1937          * Called only while holding lock. This is called when</span>
<span class="line-removed">1938          * cancellation occurred during condition wait, and upon</span>
<span class="line-removed">1939          * insertion of a new waiter when lastWaiter is seen to have</span>
<span class="line-removed">1940          * been cancelled. This method is needed to avoid garbage</span>
<span class="line-removed">1941          * retention in the absence of signals. So even though it may</span>
<span class="line-removed">1942          * require a full traversal, it comes into play only when</span>
<span class="line-removed">1943          * timeouts or cancellations occur in the absence of</span>
<span class="line-removed">1944          * signals. It traverses all nodes rather than stopping at a</span>
<span class="line-removed">1945          * particular target to unlink all pointers to garbage nodes</span>
<span class="line-removed">1946          * without requiring many re-traversals during cancellation</span>
<span class="line-removed">1947          * storms.</span>
<span class="line-removed">1948          */</span>
<span class="line-removed">1949         private void unlinkCancelledWaiters() {</span>
<span class="line-removed">1950             Node t = firstWaiter;</span>
<span class="line-removed">1951             Node trail = null;</span>
<span class="line-removed">1952             while (t != null) {</span>
<span class="line-removed">1953                 Node next = t.nextWaiter;</span>
<span class="line-removed">1954                 if (t.waitStatus != Node.CONDITION) {</span>
<span class="line-removed">1955                     t.nextWaiter = null;</span>
<span class="line-removed">1956                     if (trail == null)</span>
<span class="line-removed">1957                         firstWaiter = next;</span>
<span class="line-removed">1958                     else</span>
<span class="line-removed">1959                         trail.nextWaiter = next;</span>
<span class="line-removed">1960                     if (next == null)</span>
<span class="line-removed">1961                         lastWaiter = trail;</span>
1962                 }
<span class="line-modified">1963                 else</span>
<span class="line-removed">1964                     trail = t;</span>
<span class="line-removed">1965                 t = next;</span>
1966             }
1967         }
1968 
<span class="line-removed">1969         // public methods</span>
<span class="line-removed">1970 </span>
1971         /**
1972          * Moves the longest-waiting thread, if one exists, from the
1973          * wait queue for this condition to the wait queue for the
1974          * owning lock.
1975          *
1976          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1977          *         returns {@code false}
1978          */
1979         public final void signal() {

1980             if (!isHeldExclusively())
1981                 throw new IllegalMonitorStateException();
<span class="line-removed">1982             Node first = firstWaiter;</span>
1983             if (first != null)
<span class="line-modified">1984                 doSignal(first);</span>
1985         }
1986 
1987         /**
1988          * Moves all threads from the wait queue for this condition to
1989          * the wait queue for the owning lock.
1990          *
1991          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1992          *         returns {@code false}
1993          */
1994         public final void signalAll() {

1995             if (!isHeldExclusively())
1996                 throw new IllegalMonitorStateException();
<span class="line-removed">1997             Node first = firstWaiter;</span>
1998             if (first != null)
<span class="line-modified">1999                 doSignalAll(first);</span>





























































2000         }
2001 
2002         /**
2003          * Implements uninterruptible condition wait.
2004          * &lt;ol&gt;
2005          * &lt;li&gt;Save lock state returned by {@link #getState}.
2006          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
2007          *     throwing IllegalMonitorStateException if it fails.
2008          * &lt;li&gt;Block until signalled.
2009          * &lt;li&gt;Reacquire by invoking specialized version of
2010          *     {@link #acquire} with saved state as argument.
2011          * &lt;/ol&gt;
2012          */
2013         public final void awaitUninterruptibly() {
<span class="line-modified">2014             Node node = addConditionWaiter();</span>
<span class="line-modified">2015             int savedState = fullyRelease(node);</span>

2016             boolean interrupted = false;
<span class="line-modified">2017             while (!isOnSyncQueue(node)) {</span>
<span class="line-removed">2018                 LockSupport.park(this);</span>
2019                 if (Thread.interrupted())
2020                     interrupted = true;








2021             }
<span class="line-modified">2022             if (acquireQueued(node, savedState) || interrupted)</span>
<span class="line-modified">2023                 selfInterrupt();</span>
<span class="line-modified">2024         }</span>
<span class="line-modified">2025 </span>
<span class="line-modified">2026         /*</span>
<span class="line-removed">2027          * For interruptible waits, we need to track whether to throw</span>
<span class="line-removed">2028          * InterruptedException, if interrupted while blocked on</span>
<span class="line-removed">2029          * condition, versus reinterrupt current thread, if</span>
<span class="line-removed">2030          * interrupted while blocked waiting to re-acquire.</span>
<span class="line-removed">2031          */</span>
<span class="line-removed">2032 </span>
<span class="line-removed">2033         /** Mode meaning to reinterrupt on exit from wait */</span>
<span class="line-removed">2034         private static final int REINTERRUPT =  1;</span>
<span class="line-removed">2035         /** Mode meaning to throw InterruptedException on exit from wait */</span>
<span class="line-removed">2036         private static final int THROW_IE    = -1;</span>
<span class="line-removed">2037 </span>
<span class="line-removed">2038         /**</span>
<span class="line-removed">2039          * Checks for interrupt, returning THROW_IE if interrupted</span>
<span class="line-removed">2040          * before signalled, REINTERRUPT if after signalled, or</span>
<span class="line-removed">2041          * 0 if not interrupted.</span>
<span class="line-removed">2042          */</span>
<span class="line-removed">2043         private int checkInterruptWhileWaiting(Node node) {</span>
<span class="line-removed">2044             return Thread.interrupted() ?</span>
<span class="line-removed">2045                 (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span>
<span class="line-removed">2046                 0;</span>
<span class="line-removed">2047         }</span>
<span class="line-removed">2048 </span>
<span class="line-removed">2049         /**</span>
<span class="line-removed">2050          * Throws InterruptedException, reinterrupts current thread, or</span>
<span class="line-removed">2051          * does nothing, depending on mode.</span>
<span class="line-removed">2052          */</span>
<span class="line-removed">2053         private void reportInterruptAfterWait(int interruptMode)</span>
<span class="line-removed">2054             throws InterruptedException {</span>
<span class="line-removed">2055             if (interruptMode == THROW_IE)</span>
<span class="line-removed">2056                 throw new InterruptedException();</span>
<span class="line-removed">2057             else if (interruptMode == REINTERRUPT)</span>
<span class="line-removed">2058                 selfInterrupt();</span>
2059         }
2060 
2061         /**
2062          * Implements interruptible condition wait.
2063          * &lt;ol&gt;
2064          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
2065          * &lt;li&gt;Save lock state returned by {@link #getState}.
2066          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
2067          *     throwing IllegalMonitorStateException if it fails.
2068          * &lt;li&gt;Block until signalled or interrupted.
2069          * &lt;li&gt;Reacquire by invoking specialized version of
2070          *     {@link #acquire} with saved state as argument.
2071          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
2072          * &lt;/ol&gt;
2073          */
2074         public final void await() throws InterruptedException {
2075             if (Thread.interrupted())
2076                 throw new InterruptedException();
<span class="line-modified">2077             Node node = addConditionWaiter();</span>
<span class="line-modified">2078             int savedState = fullyRelease(node);</span>
<span class="line-modified">2079             int interruptMode = 0;</span>
<span class="line-modified">2080             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">2081                 LockSupport.park(this);</span>
<span class="line-modified">2082                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-modified">2083                     break;</span>



















2084             }
<span class="line-removed">2085             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-removed">2086                 interruptMode = REINTERRUPT;</span>
<span class="line-removed">2087             if (node.nextWaiter != null) // clean up if cancelled</span>
<span class="line-removed">2088                 unlinkCancelledWaiters();</span>
<span class="line-removed">2089             if (interruptMode != 0)</span>
<span class="line-removed">2090                 reportInterruptAfterWait(interruptMode);</span>
2091         }
2092 
2093         /**
2094          * Implements timed condition wait.
2095          * &lt;ol&gt;
2096          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
2097          * &lt;li&gt;Save lock state returned by {@link #getState}.
2098          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
2099          *     throwing IllegalMonitorStateException if it fails.
2100          * &lt;li&gt;Block until signalled, interrupted, or timed out.
2101          * &lt;li&gt;Reacquire by invoking specialized version of
2102          *     {@link #acquire} with saved state as argument.
2103          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
2104          * &lt;/ol&gt;
2105          */
2106         public final long awaitNanos(long nanosTimeout)
2107                 throws InterruptedException {
2108             if (Thread.interrupted())
2109                 throw new InterruptedException();
<span class="line-modified">2110             // We don&#39;t check for nanosTimeout &lt;= 0L here, to allow</span>
<span class="line-modified">2111             // awaitNanos(0) as a way to &quot;yield the lock&quot;.</span>
<span class="line-modified">2112             final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-modified">2113             long initialNanos = nanosTimeout;</span>
<span class="line-modified">2114             Node node = addConditionWaiter();</span>
<span class="line-modified">2115             int savedState = fullyRelease(node);</span>
<span class="line-modified">2116             int interruptMode = 0;</span>
<span class="line-modified">2117             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">2118                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-modified">2119                     transferAfterCancelledWait(node);</span>
<span class="line-modified">2120                     break;</span>
<span class="line-modified">2121                 }</span>
<span class="line-removed">2122                 if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed">2123                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed">2124                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-removed">2125                     break;</span>
<span class="line-removed">2126                 nanosTimeout = deadline - System.nanoTime();</span>
2127             }
<span class="line-modified">2128             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-modified">2129                 interruptMode = REINTERRUPT;</span>
<span class="line-modified">2130             if (node.nextWaiter != null)</span>
<span class="line-modified">2131                 unlinkCancelledWaiters();</span>
<span class="line-modified">2132             if (interruptMode != 0)</span>
<span class="line-modified">2133                 reportInterruptAfterWait(interruptMode);</span>


2134             long remaining = deadline - System.nanoTime(); // avoid overflow
<span class="line-modified">2135             return (remaining &lt;= initialNanos) ? remaining : Long.MIN_VALUE;</span>
2136         }
2137 
2138         /**
2139          * Implements absolute timed condition wait.
2140          * &lt;ol&gt;
2141          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
2142          * &lt;li&gt;Save lock state returned by {@link #getState}.
2143          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
2144          *     throwing IllegalMonitorStateException if it fails.
2145          * &lt;li&gt;Block until signalled, interrupted, or timed out.
2146          * &lt;li&gt;Reacquire by invoking specialized version of
2147          *     {@link #acquire} with saved state as argument.
2148          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
2149          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
2150          * &lt;/ol&gt;
2151          */
2152         public final boolean awaitUntil(Date deadline)
2153                 throws InterruptedException {
2154             long abstime = deadline.getTime();
2155             if (Thread.interrupted())
2156                 throw new InterruptedException();
<span class="line-modified">2157             Node node = addConditionWaiter();</span>
<span class="line-modified">2158             int savedState = fullyRelease(node);</span>
<span class="line-modified">2159             boolean timedout = false;</span>
<span class="line-modified">2160             int interruptMode = 0;</span>
<span class="line-modified">2161             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">2162                 if (System.currentTimeMillis() &gt;= abstime) {</span>
<span class="line-modified">2163                     timedout = transferAfterCancelledWait(node);</span>
<span class="line-modified">2164                     break;</span>
<span class="line-modified">2165                 }</span>
<span class="line-modified">2166                 LockSupport.parkUntil(this, abstime);</span>
<span class="line-removed">2167                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-removed">2168                     break;</span>
2169             }
<span class="line-modified">2170             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-modified">2171                 interruptMode = REINTERRUPT;</span>
<span class="line-modified">2172             if (node.nextWaiter != null)</span>
<span class="line-modified">2173                 unlinkCancelledWaiters();</span>
<span class="line-modified">2174             if (interruptMode != 0)</span>
<span class="line-modified">2175                 reportInterruptAfterWait(interruptMode);</span>
<span class="line-modified">2176             return !timedout;</span>


2177         }
2178 
2179         /**
2180          * Implements timed condition wait.
2181          * &lt;ol&gt;
2182          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
2183          * &lt;li&gt;Save lock state returned by {@link #getState}.
2184          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
2185          *     throwing IllegalMonitorStateException if it fails.
2186          * &lt;li&gt;Block until signalled, interrupted, or timed out.
2187          * &lt;li&gt;Reacquire by invoking specialized version of
2188          *     {@link #acquire} with saved state as argument.
2189          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
2190          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
2191          * &lt;/ol&gt;
2192          */
2193         public final boolean await(long time, TimeUnit unit)
2194                 throws InterruptedException {
2195             long nanosTimeout = unit.toNanos(time);
2196             if (Thread.interrupted())
2197                 throw new InterruptedException();
<span class="line-modified">2198             // We don&#39;t check for nanosTimeout &lt;= 0L here, to allow</span>
<span class="line-modified">2199             // await(0, unit) as a way to &quot;yield the lock&quot;.</span>
<span class="line-modified">2200             final long deadline = System.nanoTime() + nanosTimeout;</span>
<span class="line-modified">2201             Node node = addConditionWaiter();</span>
<span class="line-modified">2202             int savedState = fullyRelease(node);</span>
<span class="line-modified">2203             boolean timedout = false;</span>
<span class="line-modified">2204             int interruptMode = 0;</span>
<span class="line-modified">2205             while (!isOnSyncQueue(node)) {</span>
<span class="line-modified">2206                 if (nanosTimeout &lt;= 0L) {</span>
<span class="line-modified">2207                     timedout = transferAfterCancelledWait(node);</span>
<span class="line-modified">2208                     break;</span>
<span class="line-modified">2209                 }</span>
<span class="line-removed">2210                 if (nanosTimeout &gt; SPIN_FOR_TIMEOUT_THRESHOLD)</span>
<span class="line-removed">2211                     LockSupport.parkNanos(this, nanosTimeout);</span>
<span class="line-removed">2212                 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span>
<span class="line-removed">2213                     break;</span>
<span class="line-removed">2214                 nanosTimeout = deadline - System.nanoTime();</span>
2215             }
<span class="line-modified">2216             if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span>
<span class="line-modified">2217                 interruptMode = REINTERRUPT;</span>
<span class="line-modified">2218             if (node.nextWaiter != null)</span>
<span class="line-modified">2219                 unlinkCancelledWaiters();</span>
<span class="line-modified">2220             if (interruptMode != 0)</span>
<span class="line-modified">2221                 reportInterruptAfterWait(interruptMode);</span>
<span class="line-modified">2222             return !timedout;</span>


2223         }
2224 
2225         //  support for instrumentation
2226 
2227         /**
2228          * Returns true if this condition was created by the given
2229          * synchronization object.
2230          *
2231          * @return {@code true} if owned
2232          */
2233         final boolean isOwnedBy(AbstractQueuedSynchronizer sync) {
2234             return sync == AbstractQueuedSynchronizer.this;
2235         }
2236 
2237         /**
2238          * Queries whether any threads are waiting on this condition.
2239          * Implements {@link AbstractQueuedSynchronizer#hasWaiters(ConditionObject)}.
2240          *
2241          * @return {@code true} if there are any waiting threads
2242          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
2243          *         returns {@code false}
2244          */
2245         protected final boolean hasWaiters() {
2246             if (!isHeldExclusively())
2247                 throw new IllegalMonitorStateException();
<span class="line-modified">2248             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">2249                 if (w.waitStatus == Node.CONDITION)</span>
2250                     return true;
2251             }
2252             return false;
2253         }
2254 
2255         /**
2256          * Returns an estimate of the number of threads waiting on
2257          * this condition.
2258          * Implements {@link AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)}.
2259          *
2260          * @return the estimated number of waiting threads
2261          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
2262          *         returns {@code false}
2263          */
2264         protected final int getWaitQueueLength() {
2265             if (!isHeldExclusively())
2266                 throw new IllegalMonitorStateException();
2267             int n = 0;
<span class="line-modified">2268             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">2269                 if (w.waitStatus == Node.CONDITION)</span>
2270                     ++n;
2271             }
2272             return n;
2273         }
2274 
2275         /**
2276          * Returns a collection containing those threads that may be
2277          * waiting on this Condition.
2278          * Implements {@link AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)}.
2279          *
2280          * @return the collection of threads
2281          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
2282          *         returns {@code false}
2283          */
2284         protected final Collection&lt;Thread&gt; getWaitingThreads() {
2285             if (!isHeldExclusively())
2286                 throw new IllegalMonitorStateException();
2287             ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
<span class="line-modified">2288             for (Node w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">2289                 if (w.waitStatus == Node.CONDITION) {</span>
<span class="line-modified">2290                     Thread t = w.thread;</span>
2291                     if (t != null)
2292                         list.add(t);
2293                 }
2294             }
2295             return list;
2296         }
2297     }
2298 
<span class="line-modified">2299     // VarHandle mechanics</span>
<span class="line-modified">2300     private static final VarHandle STATE;</span>
<span class="line-modified">2301     private static final VarHandle HEAD;</span>
<span class="line-modified">2302     private static final VarHandle TAIL;</span>




2303 
2304     static {
<span class="line-removed">2305         try {</span>
<span class="line-removed">2306             MethodHandles.Lookup l = MethodHandles.lookup();</span>
<span class="line-removed">2307             STATE = l.findVarHandle(AbstractQueuedSynchronizer.class, &quot;state&quot;, int.class);</span>
<span class="line-removed">2308             HEAD = l.findVarHandle(AbstractQueuedSynchronizer.class, &quot;head&quot;, Node.class);</span>
<span class="line-removed">2309             TAIL = l.findVarHandle(AbstractQueuedSynchronizer.class, &quot;tail&quot;, Node.class);</span>
<span class="line-removed">2310         } catch (ReflectiveOperationException e) {</span>
<span class="line-removed">2311             throw new ExceptionInInitializerError(e);</span>
<span class="line-removed">2312         }</span>
<span class="line-removed">2313 </span>
<span class="line-removed">2314         // Reduce the risk of rare disastrous classloading in first call to</span>
<span class="line-removed">2315         // LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span>
2316         Class&lt;?&gt; ensureLoaded = LockSupport.class;
2317     }
<span class="line-removed">2318 </span>
<span class="line-removed">2319     /**</span>
<span class="line-removed">2320      * Initializes head and tail fields on first contention.</span>
<span class="line-removed">2321      */</span>
<span class="line-removed">2322     private final void initializeSyncQueue() {</span>
<span class="line-removed">2323         Node h;</span>
<span class="line-removed">2324         if (HEAD.compareAndSet(this, null, (h = new Node())))</span>
<span class="line-removed">2325             tail = h;</span>
<span class="line-removed">2326     }</span>
<span class="line-removed">2327 </span>
<span class="line-removed">2328     /**</span>
<span class="line-removed">2329      * CASes tail field.</span>
<span class="line-removed">2330      */</span>
<span class="line-removed">2331     private final boolean compareAndSetTail(Node expect, Node update) {</span>
<span class="line-removed">2332         return TAIL.compareAndSet(this, expect, update);</span>
<span class="line-removed">2333     }</span>
2334 }
</pre>
</td>
<td>
<hr />
<pre>
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * Written by Doug Lea with assistance from members of JCP JSR-166
  32  * Expert Group and released to the public domain, as explained at
  33  * http://creativecommons.org/publicdomain/zero/1.0/
  34  */
  35 
  36 package java.util.concurrent.locks;
  37 


  38 import java.util.ArrayList;
  39 import java.util.Collection;
  40 import java.util.Date;
  41 import java.util.concurrent.TimeUnit;
<span class="line-added">  42 import java.util.concurrent.ForkJoinPool;</span>
<span class="line-added">  43 import jdk.internal.misc.Unsafe;</span>
  44 
  45 /**
  46  * Provides a framework for implementing blocking locks and related
  47  * synchronizers (semaphores, events, etc) that rely on
  48  * first-in-first-out (FIFO) wait queues.  This class is designed to
  49  * be a useful basis for most kinds of synchronizers that rely on a
  50  * single atomic {@code int} value to represent state. Subclasses
  51  * must define the protected methods that change this state, and which
  52  * define what that state means in terms of this object being acquired
  53  * or released.  Given these, the other methods in this class carry
  54  * out all queuing and blocking mechanics. Subclasses can maintain
  55  * other state fields, but only the atomically updated {@code int}
  56  * value manipulated using methods {@link #getState}, {@link
  57  * #setState} and {@link #compareAndSetState} is tracked with respect
  58  * to synchronization.
  59  *
  60  * &lt;p&gt;Subclasses should be defined as non-public internal helper
  61  * classes that are used to implement the synchronization properties
  62  * of their enclosing class.  Class
  63  * {@code AbstractQueuedSynchronizer} does not implement any
</pre>
<hr />
<pre>
  87  * invoked with the current {@link #getState} value fully releases
  88  * this object, and {@link #acquire}, given this saved state value,
  89  * eventually restores this object to its previous acquired state.  No
  90  * {@code AbstractQueuedSynchronizer} method otherwise creates such a
  91  * condition, so if this constraint cannot be met, do not use it.  The
  92  * behavior of {@link ConditionObject} depends of course on the
  93  * semantics of its synchronizer implementation.
  94  *
  95  * &lt;p&gt;This class provides inspection, instrumentation, and monitoring
  96  * methods for the internal queue, as well as similar methods for
  97  * condition objects. These can be exported as desired into classes
  98  * using an {@code AbstractQueuedSynchronizer} for their
  99  * synchronization mechanics.
 100  *
 101  * &lt;p&gt;Serialization of this class stores only the underlying atomic
 102  * integer maintaining state, so deserialized objects have empty
 103  * thread queues. Typical subclasses requiring serializability will
 104  * define a {@code readObject} method that restores this to a known
 105  * initial state upon deserialization.
 106  *
<span class="line-modified"> 107  * &lt;h2&gt;Usage&lt;/h2&gt;</span>
 108  *
 109  * &lt;p&gt;To use this class as the basis of a synchronizer, redefine the
 110  * following methods, as applicable, by inspecting and/or modifying
 111  * the synchronization state using {@link #getState}, {@link
 112  * #setState} and/or {@link #compareAndSetState}:
 113  *
 114  * &lt;ul&gt;
 115  * &lt;li&gt;{@link #tryAcquire}
 116  * &lt;li&gt;{@link #tryRelease}
 117  * &lt;li&gt;{@link #tryAcquireShared}
 118  * &lt;li&gt;{@link #tryReleaseShared}
 119  * &lt;li&gt;{@link #isHeldExclusively}
 120  * &lt;/ul&gt;
 121  *
 122  * Each of these methods by default throws {@link
 123  * UnsupportedOperationException}.  Implementations of these methods
 124  * must be internally thread-safe, and should in general be short and
 125  * not block. Defining these methods is the &lt;em&gt;only&lt;/em&gt; supported
 126  * means of using this class. All other methods are declared
 127  * {@code final} because they cannot be independently varied.
</pre>
<hr />
<pre>
 170  * against incoming threads.  Also, while acquires do not
 171  * &amp;quot;spin&amp;quot; in the usual sense, they may perform multiple
 172  * invocations of {@code tryAcquire} interspersed with other
 173  * computations before blocking.  This gives most of the benefits of
 174  * spins when exclusive synchronization is only briefly held, without
 175  * most of the liabilities when it isn&#39;t. If so desired, you can
 176  * augment this by preceding calls to acquire methods with
 177  * &quot;fast-path&quot; checks, possibly prechecking {@link #hasContended}
 178  * and/or {@link #hasQueuedThreads} to only do so if the synchronizer
 179  * is likely not to be contended.
 180  *
 181  * &lt;p&gt;This class provides an efficient and scalable basis for
 182  * synchronization in part by specializing its range of use to
 183  * synchronizers that can rely on {@code int} state, acquire, and
 184  * release parameters, and an internal FIFO wait queue. When this does
 185  * not suffice, you can build synchronizers from a lower level using
 186  * {@link java.util.concurrent.atomic atomic} classes, your own custom
 187  * {@link java.util.Queue} classes, and {@link LockSupport} blocking
 188  * support.
 189  *
<span class="line-modified"> 190  * &lt;h2&gt;Usage Examples&lt;/h2&gt;</span>
 191  *
 192  * &lt;p&gt;Here is a non-reentrant mutual exclusion lock class that uses
 193  * the value zero to represent the unlocked state, and one to
 194  * represent the locked state. While a non-reentrant lock
 195  * does not strictly require recording of the current owner
 196  * thread, this class does so anyway to make usage easier to monitor.
 197  * It also supports conditions and exposes some instrumentation methods:
 198  *
 199  * &lt;pre&gt; {@code
 200  * class Mutex implements Lock, java.io.Serializable {
 201  *
 202  *   // Our internal helper class
 203  *   private static class Sync extends AbstractQueuedSynchronizer {
 204  *     // Acquires the lock if state is zero
 205  *     public boolean tryAcquire(int acquires) {
 206  *       assert acquires == 1; // Otherwise unused
 207  *       if (compareAndSetState(0, 1)) {
 208  *         setExclusiveOwnerThread(Thread.currentThread());
 209  *         return true;
 210  *       }
</pre>
<hr />
<pre>
 295  *   public void await() throws InterruptedException {
 296  *     sync.acquireSharedInterruptibly(1);
 297  *   }
 298  * }}&lt;/pre&gt;
 299  *
 300  * @since 1.5
 301  * @author Doug Lea
 302  */
 303 public abstract class AbstractQueuedSynchronizer
 304     extends AbstractOwnableSynchronizer
 305     implements java.io.Serializable {
 306 
 307     private static final long serialVersionUID = 7373984972572414691L;
 308 
 309     /**
 310      * Creates a new {@code AbstractQueuedSynchronizer} instance
 311      * with initial synchronization state of zero.
 312      */
 313     protected AbstractQueuedSynchronizer() { }
 314 
<span class="line-modified"> 315     /*</span>
<span class="line-modified"> 316      * Overview.</span>
 317      *
<span class="line-modified"> 318      * The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and</span>
 319      * Hagersten) lock queue. CLH locks are normally used for
<span class="line-modified"> 320      * spinlocks.  We instead use them for blocking synchronizers by</span>
<span class="line-modified"> 321      * including explicit (&quot;prev&quot; and &quot;next&quot;) links plus a &quot;status&quot;</span>
<span class="line-modified"> 322      * field that allow nodes to signal successors when releasing</span>
<span class="line-modified"> 323      * locks, and handle cancellation due to interrupts and timeouts.</span>
<span class="line-modified"> 324      * The status field includes bits that track whether a thread</span>
<span class="line-modified"> 325      * needs a signal (using LockSupport.unpark). Despite these</span>
<span class="line-modified"> 326      * additions, we maintain most CLH locality properties.</span>
<span class="line-modified"> 327      *</span>
<span class="line-modified"> 328      * To enqueue into a CLH lock, you atomically splice it in as new</span>
<span class="line-modified"> 329      * tail. To dequeue, you set the head field, so the next eligible</span>
<span class="line-modified"> 330      * waiter becomes first.</span>
<span class="line-modified"> 331      *</span>
<span class="line-modified"> 332      *  +------+  prev +-------+       +------+</span>
<span class="line-modified"> 333      *  | head | &lt;---- | first | &lt;---- | tail |</span>
<span class="line-modified"> 334      *  +------+       +-------+       +------+</span>
<span class="line-modified"> 335      *</span>
<span class="line-modified"> 336      * Insertion into a CLH queue requires only a single atomic</span>
<span class="line-modified"> 337      * operation on &quot;tail&quot;, so there is a simple point of demarcation</span>
<span class="line-modified"> 338      * from unqueued to queued. The &quot;next&quot; link of the predecessor is</span>
<span class="line-modified"> 339      * set by the enqueuing thread after successful CAS. Even though</span>
<span class="line-modified"> 340      * non-atomic, this suffices to ensure that any blocked thread is</span>
<span class="line-modified"> 341      * signalled by a predecessor when eligible (although in the case</span>
<span class="line-modified"> 342      * of cancellation, possibly with the assistance of a signal in</span>
<span class="line-modified"> 343      * method cleanQueue). Signalling is based in part on a</span>
<span class="line-modified"> 344      * Dekker-like scheme in which the to-be waiting thread indicates</span>
<span class="line-modified"> 345      * WAITING status, then retries acquiring, and then rechecks</span>
<span class="line-modified"> 346      * status before blocking. The signaller atomically clears WAITING</span>
<span class="line-modified"> 347      * status when unparking.</span>
<span class="line-modified"> 348      *</span>
<span class="line-modified"> 349      * Dequeuing on acquire involves detaching (nulling) a node&#39;s</span>
<span class="line-modified"> 350      * &quot;prev&quot; node and then updating the &quot;head&quot;. Other threads check</span>
<span class="line-modified"> 351      * if a node is or was dequeued by checking &quot;prev&quot; rather than</span>
<span class="line-modified"> 352      * head. We enforce the nulling then setting order by spin-waiting</span>
<span class="line-modified"> 353      * if necessary. Because of this, the lock algorithm is not itself</span>
<span class="line-modified"> 354      * strictly &quot;lock-free&quot; because an acquiring thread may need to</span>
<span class="line-modified"> 355      * wait for a previous acquire to make progress. When used with</span>
<span class="line-modified"> 356      * exclusive locks, such progress is required anyway. However</span>
<span class="line-modified"> 357      * Shared mode may (uncommonly) require a spin-wait before</span>
<span class="line-modified"> 358      * setting head field to ensure proper propagation. (Historical</span>
<span class="line-modified"> 359      * note: This allows some simplifications and efficiencies</span>
<span class="line-modified"> 360      * compared to previous versions of this class.)</span>
<span class="line-modified"> 361      *</span>
<span class="line-modified"> 362      * A node&#39;s predecessor can change due to cancellation while it is</span>
<span class="line-modified"> 363      * waiting, until the node is first in queue, at which point it</span>
<span class="line-modified"> 364      * cannot change. The acquire methods cope with this by rechecking</span>
<span class="line-modified"> 365      * &quot;prev&quot; before waiting. The prev and next fields are modified</span>
<span class="line-modified"> 366      * only via CAS by cancelled nodes in method cleanQueue. The</span>
<span class="line-modified"> 367      * unsplice strategy is reminiscent of Michael-Scott queues in</span>
<span class="line-modified"> 368      * that after a successful CAS to prev field, other threads help</span>
<span class="line-modified"> 369      * fix next fields.  Because cancellation often occurs in bunches</span>
<span class="line-modified"> 370      * that complicate decisions about necessary signals, each call to</span>
<span class="line-modified"> 371      * cleanQueue traverses the queue until a clean sweep. Nodes that</span>
<span class="line-modified"> 372      * become relinked as first are unconditionally unparked</span>
<span class="line-modified"> 373      * (sometimes unnecessarily, but those cases are not worth</span>
<span class="line-modified"> 374      * avoiding).</span>
<span class="line-modified"> 375      *</span>
<span class="line-added"> 376      * A thread may try to acquire if it is first (frontmost) in the</span>
<span class="line-added"> 377      * queue, and sometimes before.  Being first does not guarantee</span>
<span class="line-added"> 378      * success; it only gives the right to contend. We balance</span>
<span class="line-added"> 379      * throughput, overhead, and fairness by allowing incoming threads</span>
<span class="line-added"> 380      * to &quot;barge&quot; and acquire the synchronizer while in the process of</span>
<span class="line-added"> 381      * enqueuing, in which case an awakened first thread may need to</span>
<span class="line-added"> 382      * rewait.  To counteract possible repeated unlucky rewaits, we</span>
<span class="line-added"> 383      * exponentially increase retries (up to 256) to acquire each time</span>
<span class="line-added"> 384      * a thread is unparked. Except in this case, AQS locks do not</span>
<span class="line-added"> 385      * spin; they instead interleave attempts to acquire with</span>
<span class="line-added"> 386      * bookkeeping steps. (Users who want spinlocks can use</span>
<span class="line-added"> 387      * tryAcquire.)</span>
<span class="line-added"> 388      *</span>
<span class="line-added"> 389      * To improve garbage collectibility, fields of nodes not yet on</span>
<span class="line-added"> 390      * list are null. (It is not rare to create and then throw away a</span>
<span class="line-added"> 391      * node without using it.) Fields of nodes coming off the list are</span>
<span class="line-added"> 392      * nulled out as soon as possible. This accentuates the challenge</span>
<span class="line-added"> 393      * of externally determining the first waiting thread (as in</span>
<span class="line-added"> 394      * method getFirstQueuedThread). This sometimes requires the</span>
<span class="line-added"> 395      * fallback of traversing backwards from the atomically updated</span>
<span class="line-added"> 396      * &quot;tail&quot; when fields appear null. (This is never needed in the</span>
<span class="line-added"> 397      * process of signalling though.)</span>
<span class="line-added"> 398      *</span>
<span class="line-added"> 399      * CLH queues need a dummy header node to get started. But</span>
 400      * we don&#39;t create them on construction, because it would be wasted
 401      * effort if there is never contention. Instead, the node
 402      * is constructed and head and tail pointers are set upon first
 403      * contention.
 404      *
<span class="line-modified"> 405      * Shared mode operations differ from Exclusive in that an acquire</span>
<span class="line-modified"> 406      * signals the next waiter to try to acquire if it is also</span>
<span class="line-modified"> 407      * Shared. The tryAcquireShared API allows users to indicate the</span>
<span class="line-modified"> 408      * degree of propagation, but in most applications, it is more</span>
<span class="line-modified"> 409      * efficient to ignore this, allowing the successor to try</span>
<span class="line-modified"> 410      * acquiring in any case.</span>
<span class="line-modified"> 411      *</span>
<span class="line-modified"> 412      * Threads waiting on Conditions use nodes with an additional</span>
<span class="line-modified"> 413      * link to maintain the (FIFO) list of conditions. Conditions only</span>
<span class="line-added"> 414      * need to link nodes in simple (non-concurrent) linked queues</span>
<span class="line-added"> 415      * because they are only accessed when exclusively held.  Upon</span>
<span class="line-added"> 416      * await, a node is inserted into a condition queue.  Upon signal,</span>
<span class="line-added"> 417      * the node is enqueued on the main queue.  A special status field</span>
<span class="line-added"> 418      * value is used to track and atomically trigger this.</span>
<span class="line-added"> 419      *</span>
<span class="line-added"> 420      * Accesses to fields head, tail, and state use full Volatile</span>
<span class="line-added"> 421      * mode, along with CAS. Node fields status, prev and next also do</span>
<span class="line-added"> 422      * so while threads may be signallable, but sometimes use weaker</span>
<span class="line-added"> 423      * modes otherwise. Accesses to field &quot;waiter&quot; (the thread to be</span>
<span class="line-added"> 424      * signalled) are always sandwiched between other atomic accesses</span>
<span class="line-added"> 425      * so are used in Plain mode. We use jdk.internal Unsafe versions</span>
<span class="line-added"> 426      * of atomic access methods rather than VarHandles to avoid</span>
<span class="line-added"> 427      * potential VM bootstrap issues.</span>
<span class="line-added"> 428      *</span>
<span class="line-added"> 429      * Most of the above is performed by primary internal method</span>
<span class="line-added"> 430      * acquire, that is invoked in some way by all exported acquire</span>
<span class="line-added"> 431      * methods.  (It is usually easy for compilers to optimize</span>
<span class="line-added"> 432      * call-site specializations when heavily used.)</span>
<span class="line-added"> 433      *</span>
<span class="line-added"> 434      * There are several arbitrary decisions about when and how to</span>
<span class="line-added"> 435      * check interrupts in both acquire and await before and/or after</span>
<span class="line-added"> 436      * blocking. The decisions are less arbitrary in implementation</span>
<span class="line-added"> 437      * updates because some users appear to rely on original behaviors</span>
<span class="line-added"> 438      * in ways that are racy and so (rarely) wrong in general but hard</span>
<span class="line-added"> 439      * to justify changing.</span>
<span class="line-added"> 440      *</span>
<span class="line-added"> 441      * Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill</span>
 442      * Scherer and Michael Scott, along with members of JSR-166
 443      * expert group, for helpful ideas, discussions, and critiques
 444      * on the design of this class.
 445      */

















 446 
<span class="line-modified"> 447     // Node status bits, also used as argument and return values</span>
<span class="line-modified"> 448     static final int WAITING   = 1;          // must be 1</span>
<span class="line-modified"> 449     static final int CANCELLED = 0x80000000; // must be negative</span>
<span class="line-modified"> 450     static final int COND      = 2;          // in a condition wait</span>
<span class="line-modified"> 451 </span>
<span class="line-modified"> 452     /** CLH Nodes */</span>
<span class="line-modified"> 453     abstract static class Node {</span>
<span class="line-modified"> 454         volatile Node prev;       // initially attached via casTail</span>
<span class="line-modified"> 455         volatile Node next;       // visibly nonnull when signallable</span>
<span class="line-modified"> 456         Thread waiter;            // visibly nonnull when enqueued</span>
<span class="line-modified"> 457         volatile int status;      // written by owner, atomic bit ops by others</span>
<span class="line-modified"> 458 </span>
<span class="line-modified"> 459         // methods for atomic operations</span>
<span class="line-modified"> 460         final boolean casPrev(Node c, Node v) {  // for cleanQueue</span>
<span class="line-modified"> 461             return U.weakCompareAndSetReference(this, PREV, c, v);</span>








































































 462         }
<span class="line-modified"> 463         final boolean casNext(Node c, Node v) {  // for cleanQueue</span>
<span class="line-modified"> 464             return U.weakCompareAndSetReference(this, NEXT, c, v);</span>












 465         }
<span class="line-modified"> 466         final int getAndUnsetStatus(int v) {     // for signalling</span>
<span class="line-modified"> 467             return U.getAndBitwiseAndInt(this, STATUS, ~v);</span>






 468         }
<span class="line-modified"> 469         final void setPrevRelaxed(Node p) {      // for off-queue assignment</span>
<span class="line-modified"> 470             U.putReference(this, PREV, p);</span>



 471         }
<span class="line-modified"> 472         final void setStatusRelaxed(int s) {     // for off-queue assignment</span>
<span class="line-modified"> 473             U.putInt(this, STATUS, s);</span>


 474         }
<span class="line-modified"> 475         final void clearStatus() {               // for reducing unneeded signals</span>
<span class="line-modified"> 476             U.putIntOpaque(this, STATUS, 0);</span>


 477         }
 478 
<span class="line-modified"> 479         private static final long STATUS</span>
<span class="line-modified"> 480             = U.objectFieldOffset(Node.class, &quot;status&quot;);</span>
<span class="line-added"> 481         private static final long NEXT</span>
<span class="line-added"> 482             = U.objectFieldOffset(Node.class, &quot;next&quot;);</span>
<span class="line-added"> 483         private static final long PREV</span>
<span class="line-added"> 484             = U.objectFieldOffset(Node.class, &quot;prev&quot;);</span>
<span class="line-added"> 485     }</span>
<span class="line-added"> 486 </span>
<span class="line-added"> 487     // Concrete classes tagged by type</span>
<span class="line-added"> 488     static final class ExclusiveNode extends Node { }</span>
<span class="line-added"> 489     static final class SharedNode extends Node { }</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491     static final class ConditionNode extends Node</span>
<span class="line-added"> 492         implements ForkJoinPool.ManagedBlocker {</span>
<span class="line-added"> 493         ConditionNode nextWaiter;            // link to next waiting node</span>
<span class="line-added"> 494 </span>
<span class="line-added"> 495         /**</span>
<span class="line-added"> 496          * Allows Conditions to be used in ForkJoinPools without</span>
<span class="line-added"> 497          * risking fixed pool exhaustion. This is usable only for</span>
<span class="line-added"> 498          * untimed Condition waits, not timed versions.</span>
<span class="line-added"> 499          */</span>
<span class="line-added"> 500         public final boolean isReleasable() {</span>
<span class="line-added"> 501             return status &lt;= 1 || Thread.currentThread().isInterrupted();</span>
 502         }
 503 
<span class="line-modified"> 504         public final boolean block() {</span>
<span class="line-modified"> 505             while (!isReleasable()) LockSupport.park();</span>
<span class="line-modified"> 506             return true;</span>












 507         }
 508     }
 509 
 510     /**
<span class="line-modified"> 511      * Head of the wait queue, lazily initialized.</span>



 512      */
 513     private transient volatile Node head;
 514 
 515     /**
<span class="line-modified"> 516      * Tail of the wait queue. After initialization, modified only via casTail.</span>

 517      */
 518     private transient volatile Node tail;
 519 
 520     /**
 521      * The synchronization state.
 522      */
 523     private volatile int state;
 524 
 525     /**
 526      * Returns the current value of synchronization state.
 527      * This operation has memory semantics of a {@code volatile} read.
 528      * @return current state value
 529      */
 530     protected final int getState() {
 531         return state;
 532     }
 533 
 534     /**
 535      * Sets the value of synchronization state.
 536      * This operation has memory semantics of a {@code volatile} write.
 537      * @param newState the new state value
 538      */
 539     protected final void setState(int newState) {
 540         state = newState;
 541     }
 542 
 543     /**
 544      * Atomically sets synchronization state to the given updated
 545      * value if the current state value equals the expected value.
 546      * This operation has memory semantics of a {@code volatile} read
 547      * and write.
 548      *
 549      * @param expect the expected value
 550      * @param update the new value
 551      * @return {@code true} if successful. False return indicates that the actual
 552      *         value was not equal to the expected value.
 553      */
 554     protected final boolean compareAndSetState(int expect, int update) {
<span class="line-modified"> 555         return U.compareAndSetInt(this, STATE, expect, update);</span>
 556     }
 557 
 558     // Queuing utilities
 559 
<span class="line-modified"> 560     private boolean casTail(Node c, Node v) {</span>
<span class="line-modified"> 561         return U.compareAndSetReference(this, TAIL, c, v);</span>



























































 562     }
 563 
<span class="line-modified"> 564     /** tries once to CAS a new dummy node for head */</span>
<span class="line-modified"> 565     private void tryInitializeHead() {</span>
<span class="line-modified"> 566         Node h = new ExclusiveNode();</span>
<span class="line-modified"> 567         if (U.compareAndSetReference(this, HEAD, null, h))</span>
<span class="line-modified"> 568             tail = h;</span>

























 569     }
 570 
 571     /**
<span class="line-modified"> 572      * Enqueues the node unless null. (Currently used only for</span>
<span class="line-modified"> 573      * ConditionNodes; other cases are interleaved with acquires.)</span>

 574      */
<span class="line-modified"> 575     final void enqueue(Node node) {</span>
<span class="line-modified"> 576         if (node != null) {</span>
<span class="line-modified"> 577             for (;;) {</span>
<span class="line-modified"> 578                 Node t = tail;</span>
<span class="line-modified"> 579                 node.setPrevRelaxed(t);        // avoid unnecessary fence</span>
<span class="line-modified"> 580                 if (t == null)                 // initialize</span>
<span class="line-modified"> 581                     tryInitializeHead();</span>
<span class="line-modified"> 582                 else if (casTail(t, node)) {</span>
<span class="line-modified"> 583                     t.next = node;</span>
<span class="line-modified"> 584                     if (t.status &lt; 0)          // wake up to clean link</span>
<span class="line-modified"> 585                         LockSupport.unpark(node.waiter);</span>
<span class="line-modified"> 586                     break;</span>








 587                 }



 588             }


 589         }
 590     }
 591 
<span class="line-modified"> 592     /** Returns true if node is found in traversal from tail */</span>
<span class="line-modified"> 593     final boolean isEnqueued(Node node) {</span>
<span class="line-modified"> 594         for (Node t = tail; t != null; t = t.prev)</span>
<span class="line-modified"> 595             if (t == node)</span>
<span class="line-modified"> 596                 return true;</span>
<span class="line-modified"> 597         return false;</span>



























 598     }
 599 


 600     /**
<span class="line-modified"> 601      * Wakes up the successor of given node, if one exists, and unsets its</span>
<span class="line-modified"> 602      * WAITING status to avoid park race. This may fail to wake up an</span>
<span class="line-modified"> 603      * eligible thread when one or more have been cancelled, but</span>
<span class="line-added"> 604      * cancelAcquire ensures liveness.</span>
 605      */
<span class="line-modified"> 606     private static void signalNext(Node h) {</span>
<span class="line-modified"> 607         Node s;</span>
<span class="line-modified"> 608         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp; s.status != 0) {</span>
<span class="line-modified"> 609             s.getAndUnsetStatus(WAITING);</span>
<span class="line-modified"> 610             LockSupport.unpark(s.waiter);</span>






































 611         }
 612     }
 613 
<span class="line-modified"> 614     /** Wakes up the given node if in shared mode */</span>
<span class="line-modified"> 615     private static void signalNextIfShared(Node h) {</span>
<span class="line-modified"> 616         Node s;</span>
<span class="line-modified"> 617         if (h != null &amp;&amp; (s = h.next) != null &amp;&amp;</span>
<span class="line-modified"> 618             (s instanceof SharedNode) &amp;&amp; s.status != 0) {</span>
<span class="line-modified"> 619             s.getAndUnsetStatus(WAITING);</span>
<span class="line-modified"> 620             LockSupport.unpark(s.waiter);</span>


























 621         }

 622     }
 623 
 624     /**
<span class="line-modified"> 625      * Main acquire method, invoked by all exported acquire methods.</span>







 626      *
<span class="line-modified"> 627      * @param node null unless a reacquiring Condition</span>




















 628      * @param arg the acquire argument
<span class="line-modified"> 629      * @param shared true if shared mode else exclusive</span>
<span class="line-added"> 630      * @param interruptible if abort and return negative on interrupt</span>
<span class="line-added"> 631      * @param timed if true use timed waits</span>
<span class="line-added"> 632      * @param time if timed, the System.nanoTime value to timeout</span>
<span class="line-added"> 633      * @return positive if acquired, 0 if timed out, negative if interrupted</span>
 634      */
<span class="line-modified"> 635     final int acquire(Node node, int arg, boolean shared,</span>
<span class="line-modified"> 636                       boolean interruptible, boolean timed, long time) {</span>
<span class="line-modified"> 637         Thread current = Thread.currentThread();</span>
<span class="line-modified"> 638         byte spins = 0, postSpins = 0;   // retries upon unpark of first thread</span>
<span class="line-modified"> 639         boolean interrupted = false, first = false;</span>
<span class="line-modified"> 640         Node pred = null;                // predecessor of node when enqueued</span>














 641 
<span class="line-modified"> 642         /*</span>
<span class="line-modified"> 643          * Repeatedly:</span>
<span class="line-modified"> 644          *  Check if node now first</span>
<span class="line-modified"> 645          *    if so, ensure head stable, else ensure valid predecessor</span>
<span class="line-modified"> 646          *  if node is first or not yet enqueued, try acquiring</span>
<span class="line-modified"> 647          *  else if node not yet created, create it</span>
<span class="line-modified"> 648          *  else if not yet enqueued, try once to enqueue</span>
<span class="line-modified"> 649          *  else if woken from park, retry (up to postSpins times)</span>
<span class="line-modified"> 650          *  else if WAITING status not set, set and retry</span>
<span class="line-modified"> 651          *  else park and clear WAITING status, and check cancellation</span>
<span class="line-modified"> 652          */</span>
<span class="line-modified"> 653 </span>
<span class="line-modified"> 654         for (;;) {</span>
<span class="line-modified"> 655             if (!first &amp;&amp; (pred = (node == null) ? null : node.prev) != null &amp;&amp;</span>
<span class="line-added"> 656                 !(first = (head == pred))) {</span>
<span class="line-added"> 657                 if (pred.status &lt; 0) {</span>
<span class="line-added"> 658                     cleanQueue();           // predecessor cancelled</span>
<span class="line-added"> 659                     continue;</span>
<span class="line-added"> 660                 } else if (pred.prev == null) {</span>
<span class="line-added"> 661                     Thread.onSpinWait();    // ensure serialization</span>
<span class="line-added"> 662                     continue;</span>
 663                 }



 664             }
<span class="line-modified"> 665             if (first || pred == null) {</span>
<span class="line-modified"> 666                 boolean acquired;</span>
<span class="line-modified"> 667                 try {</span>
<span class="line-modified"> 668                     if (shared)</span>
<span class="line-modified"> 669                         acquired = (tryAcquireShared(arg) &gt;= 0);</span>
<span class="line-modified"> 670                     else</span>
<span class="line-modified"> 671                         acquired = tryAcquire(arg);</span>
<span class="line-modified"> 672                 } catch (Throwable ex) {</span>
<span class="line-modified"> 673                     cancelAcquire(node, interrupted, false);</span>
<span class="line-modified"> 674                     throw ex;</span>
















 675                 }
<span class="line-modified"> 676                 if (acquired) {</span>
<span class="line-modified"> 677                     if (first) {</span>
<span class="line-modified"> 678                         node.prev = null;</span>
<span class="line-modified"> 679                         head = node;</span>
<span class="line-added"> 680                         pred.next = null;</span>
<span class="line-added"> 681                         node.waiter = null;</span>
<span class="line-added"> 682                         if (shared)</span>
<span class="line-added"> 683                             signalNextIfShared(node);</span>
<span class="line-added"> 684                         if (interrupted)</span>
<span class="line-added"> 685                             current.interrupt();</span>
<span class="line-added"> 686                     }</span>
<span class="line-added"> 687                     return 1;</span>
 688                 }





 689             }
<span class="line-modified"> 690             if (node == null) {                 // allocate; retry before enqueue</span>
<span class="line-modified"> 691                 if (shared)</span>
<span class="line-modified"> 692                     node = new SharedNode();</span>
<span class="line-added"> 693                 else</span>
<span class="line-added"> 694                     node = new ExclusiveNode();</span>
<span class="line-added"> 695             } else if (pred == null) {          // try to enqueue</span>
<span class="line-added"> 696                 node.waiter = current;</span>
<span class="line-added"> 697                 Node t = tail;</span>
<span class="line-added"> 698                 node.setPrevRelaxed(t);         // avoid unnecessary fence</span>
<span class="line-added"> 699                 if (t == null)</span>
<span class="line-added"> 700                     tryInitializeHead();</span>
<span class="line-added"> 701                 else if (!casTail(t, node))</span>
<span class="line-added"> 702                     node.setPrevRelaxed(null);  // back out</span>
<span class="line-added"> 703                 else</span>
<span class="line-added"> 704                     t.next = node;</span>
<span class="line-added"> 705             } else if (first &amp;&amp; spins != 0) {</span>
<span class="line-added"> 706                 --spins;                        // reduce unfairness on rewaits</span>
<span class="line-added"> 707                 Thread.onSpinWait();</span>
<span class="line-added"> 708             } else if (node.status == 0) {</span>
<span class="line-added"> 709                 node.status = WAITING;          // enable signal and recheck</span>
<span class="line-added"> 710             } else {</span>
<span class="line-added"> 711                 long nanos;</span>
<span class="line-added"> 712                 spins = postSpins = (byte)((postSpins &lt;&lt; 1) | 1);</span>
<span class="line-added"> 713                 if (!timed)</span>
<span class="line-added"> 714                     LockSupport.park(this);</span>
<span class="line-added"> 715                 else if ((nanos = time - System.nanoTime()) &gt; 0L)</span>
<span class="line-added"> 716                     LockSupport.parkNanos(this, nanos);</span>
<span class="line-added"> 717                 else</span>
<span class="line-added"> 718                     break;</span>
<span class="line-added"> 719                 node.clearStatus();</span>
<span class="line-added"> 720                 if ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span>
<span class="line-added"> 721                     break;</span>
<span class="line-added"> 722             }</span>
 723         }
<span class="line-added"> 724         return cancelAcquire(node, interrupted, interruptible);</span>
 725     }
 726 
 727     /**
<span class="line-modified"> 728      * Possibly repeatedly traverses from tail, unsplicing cancelled</span>
<span class="line-modified"> 729      * nodes until none are found. Unparks nodes that may have been</span>
<span class="line-added"> 730      * relinked to be next eligible acquirer.</span>
 731      */
<span class="line-modified"> 732     private void cleanQueue() {</span>
<span class="line-modified"> 733         for (;;) {                               // restart point</span>
<span class="line-modified"> 734             for (Node q = tail, s = null, p, n;;) { // (p, q, s) triples</span>
<span class="line-modified"> 735                 if (q == null || (p = q.prev) == null)</span>
<span class="line-modified"> 736                     return;                      // end of list</span>
<span class="line-modified"> 737                 if (s == null ? tail != q : (s.prev != q || s.status &lt; 0))</span>
<span class="line-modified"> 738                     break;                       // inconsistent</span>
<span class="line-modified"> 739                 if (q.status &lt; 0) {              // cancelled</span>
<span class="line-modified"> 740                     if ((s == null ? casTail(q, p) : s.casPrev(q, p)) &amp;&amp;</span>
<span class="line-modified"> 741                         q.prev == p) {</span>
<span class="line-modified"> 742                         p.casNext(q, s);         // OK if fails</span>
<span class="line-modified"> 743                         if (p.prev == null)</span>
<span class="line-added"> 744                             signalNext(p);</span>
 745                     }
<span class="line-added"> 746                     break;</span>
 747                 }
<span class="line-modified"> 748                 if ((n = p.next) != q) {         // help finish</span>
<span class="line-modified"> 749                     if (n != null &amp;&amp; q.prev == p) {</span>
<span class="line-modified"> 750                         p.casNext(n, q);</span>
<span class="line-modified"> 751                         if (p.prev == null)</span>
<span class="line-modified"> 752                             signalNext(p);</span>























 753                     }
<span class="line-added"> 754                     break;</span>
 755                 }
<span class="line-modified"> 756                 s = q;</span>
<span class="line-modified"> 757                 q = q.prev;</span>

 758             }



 759         }
 760     }
 761 
 762     /**
<span class="line-modified"> 763      * Cancels an ongoing attempt to acquire.</span>
 764      *
<span class="line-modified"> 765      * @param node the node (may be null if cancelled before enqueuing)</span>
<span class="line-modified"> 766      * @param interrupted true if thread interrupted</span>
<span class="line-modified"> 767      * @param interruptible if should report interruption vs reset</span>
 768      */
<span class="line-modified"> 769     private int cancelAcquire(Node node, boolean interrupted,</span>
<span class="line-modified"> 770                               boolean interruptible) {</span>
<span class="line-modified"> 771         if (node != null) {</span>
<span class="line-modified"> 772             node.waiter = null;</span>
<span class="line-modified"> 773             node.status = CANCELLED;</span>
<span class="line-modified"> 774             if (node.prev != null)</span>
<span class="line-modified"> 775                 cleanQueue();</span>
<span class="line-modified"> 776         }</span>
<span class="line-modified"> 777         if (interrupted) {</span>
<span class="line-modified"> 778             if (interruptible)</span>
<span class="line-modified"> 779                 return CANCELLED;</span>
<span class="line-modified"> 780             else</span>
<span class="line-modified"> 781                 Thread.currentThread().interrupt();</span>


















 782         }
<span class="line-added"> 783         return 0;</span>
 784     }
 785 
 786     // Main exported methods
 787 
 788     /**
 789      * Attempts to acquire in exclusive mode. This method should query
 790      * if the state of the object permits it to be acquired in the
 791      * exclusive mode, and if so to acquire it.
 792      *
 793      * &lt;p&gt;This method is always invoked by the thread performing
 794      * acquire.  If this method reports failure, the acquire method
 795      * may queue the thread, if it is not already queued, until it is
 796      * signalled by a release from some other thread. This can be used
 797      * to implement method {@link Lock#tryLock()}.
 798      *
 799      * &lt;p&gt;The default
 800      * implementation throws {@link UnsupportedOperationException}.
 801      *
 802      * @param arg the acquire argument. This value is always the one
 803      *        passed to an acquire method, or is the value saved on entry
</pre>
<hr />
<pre>
 916      *         {@code false} otherwise
 917      * @throws UnsupportedOperationException if conditions are not supported
 918      */
 919     protected boolean isHeldExclusively() {
 920         throw new UnsupportedOperationException();
 921     }
 922 
 923     /**
 924      * Acquires in exclusive mode, ignoring interrupts.  Implemented
 925      * by invoking at least once {@link #tryAcquire},
 926      * returning on success.  Otherwise the thread is queued, possibly
 927      * repeatedly blocking and unblocking, invoking {@link
 928      * #tryAcquire} until success.  This method can be used
 929      * to implement method {@link Lock#lock}.
 930      *
 931      * @param arg the acquire argument.  This value is conveyed to
 932      *        {@link #tryAcquire} but is otherwise uninterpreted and
 933      *        can represent anything you like.
 934      */
 935     public final void acquire(int arg) {
<span class="line-modified"> 936         if (!tryAcquire(arg))</span>
<span class="line-modified"> 937             acquire(null, arg, false, false, false, 0L);</span>

 938     }
 939 
 940     /**
 941      * Acquires in exclusive mode, aborting if interrupted.
 942      * Implemented by first checking interrupt status, then invoking
 943      * at least once {@link #tryAcquire}, returning on
 944      * success.  Otherwise the thread is queued, possibly repeatedly
 945      * blocking and unblocking, invoking {@link #tryAcquire}
 946      * until success or the thread is interrupted.  This method can be
 947      * used to implement method {@link Lock#lockInterruptibly}.
 948      *
 949      * @param arg the acquire argument.  This value is conveyed to
 950      *        {@link #tryAcquire} but is otherwise uninterpreted and
 951      *        can represent anything you like.
 952      * @throws InterruptedException if the current thread is interrupted
 953      */
 954     public final void acquireInterruptibly(int arg)
<span class="line-modified"> 955         throws InterruptedException {</span>
<span class="line-modified"> 956         if (Thread.interrupted() ||</span>
<span class="line-added"> 957             (!tryAcquire(arg) &amp;&amp; acquire(null, arg, false, true, false, 0L) &lt; 0))</span>
 958             throw new InterruptedException();


 959     }
 960 
 961     /**
 962      * Attempts to acquire in exclusive mode, aborting if interrupted,
 963      * and failing if the given timeout elapses.  Implemented by first
 964      * checking interrupt status, then invoking at least once {@link
 965      * #tryAcquire}, returning on success.  Otherwise, the thread is
 966      * queued, possibly repeatedly blocking and unblocking, invoking
 967      * {@link #tryAcquire} until success or the thread is interrupted
 968      * or the timeout elapses.  This method can be used to implement
 969      * method {@link Lock#tryLock(long, TimeUnit)}.
 970      *
 971      * @param arg the acquire argument.  This value is conveyed to
 972      *        {@link #tryAcquire} but is otherwise uninterpreted and
 973      *        can represent anything you like.
 974      * @param nanosTimeout the maximum number of nanoseconds to wait
 975      * @return {@code true} if acquired; {@code false} if timed out
 976      * @throws InterruptedException if the current thread is interrupted
 977      */
 978     public final boolean tryAcquireNanos(int arg, long nanosTimeout)
<span class="line-modified"> 979         throws InterruptedException {</span>
<span class="line-modified"> 980         if (!Thread.interrupted()) {</span>
<span class="line-modified"> 981             if (tryAcquire(arg))</span>
<span class="line-modified"> 982                 return true;</span>
<span class="line-modified"> 983             if (nanosTimeout &lt;= 0L)</span>
<span class="line-added"> 984                 return false;</span>
<span class="line-added"> 985             int stat = acquire(null, arg, false, true, true,</span>
<span class="line-added"> 986                                System.nanoTime() + nanosTimeout);</span>
<span class="line-added"> 987             if (stat &gt; 0)</span>
<span class="line-added"> 988                 return true;</span>
<span class="line-added"> 989             if (stat == 0)</span>
<span class="line-added"> 990                 return false;</span>
<span class="line-added"> 991         }</span>
<span class="line-added"> 992         throw new InterruptedException();</span>
 993     }
 994 
 995     /**
 996      * Releases in exclusive mode.  Implemented by unblocking one or
 997      * more threads if {@link #tryRelease} returns true.
 998      * This method can be used to implement method {@link Lock#unlock}.
 999      *
1000      * @param arg the release argument.  This value is conveyed to
1001      *        {@link #tryRelease} but is otherwise uninterpreted and
1002      *        can represent anything you like.
1003      * @return the value returned from {@link #tryRelease}
1004      */
1005     public final boolean release(int arg) {
1006         if (tryRelease(arg)) {
<span class="line-modified">1007             signalNext(head);</span>


1008             return true;
1009         }
1010         return false;
1011     }
1012 
1013     /**
1014      * Acquires in shared mode, ignoring interrupts.  Implemented by
1015      * first invoking at least once {@link #tryAcquireShared},
1016      * returning on success.  Otherwise the thread is queued, possibly
1017      * repeatedly blocking and unblocking, invoking {@link
1018      * #tryAcquireShared} until success.
1019      *
1020      * @param arg the acquire argument.  This value is conveyed to
1021      *        {@link #tryAcquireShared} but is otherwise uninterpreted
1022      *        and can represent anything you like.
1023      */
1024     public final void acquireShared(int arg) {
1025         if (tryAcquireShared(arg) &lt; 0)
<span class="line-modified">1026             acquire(null, arg, true, false, false, 0L);</span>
1027     }
1028 
1029     /**
1030      * Acquires in shared mode, aborting if interrupted.  Implemented
1031      * by first checking interrupt status, then invoking at least once
1032      * {@link #tryAcquireShared}, returning on success.  Otherwise the
1033      * thread is queued, possibly repeatedly blocking and unblocking,
1034      * invoking {@link #tryAcquireShared} until success or the thread
1035      * is interrupted.
1036      * @param arg the acquire argument.
1037      * This value is conveyed to {@link #tryAcquireShared} but is
1038      * otherwise uninterpreted and can represent anything
1039      * you like.
1040      * @throws InterruptedException if the current thread is interrupted
1041      */
1042     public final void acquireSharedInterruptibly(int arg)
<span class="line-modified">1043         throws InterruptedException {</span>
<span class="line-modified">1044         if (Thread.interrupted() ||</span>
<span class="line-added">1045             (tryAcquireShared(arg) &lt; 0 &amp;&amp;</span>
<span class="line-added">1046              acquire(null, arg, true, true, false, 0L) &lt; 0))</span>
1047             throw new InterruptedException();


1048     }
1049 
1050     /**
1051      * Attempts to acquire in shared mode, aborting if interrupted, and
1052      * failing if the given timeout elapses.  Implemented by first
1053      * checking interrupt status, then invoking at least once {@link
1054      * #tryAcquireShared}, returning on success.  Otherwise, the
1055      * thread is queued, possibly repeatedly blocking and unblocking,
1056      * invoking {@link #tryAcquireShared} until success or the thread
1057      * is interrupted or the timeout elapses.
1058      *
1059      * @param arg the acquire argument.  This value is conveyed to
1060      *        {@link #tryAcquireShared} but is otherwise uninterpreted
1061      *        and can represent anything you like.
1062      * @param nanosTimeout the maximum number of nanoseconds to wait
1063      * @return {@code true} if acquired; {@code false} if timed out
1064      * @throws InterruptedException if the current thread is interrupted
1065      */
1066     public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
1067             throws InterruptedException {
<span class="line-modified">1068         if (!Thread.interrupted()) {</span>
<span class="line-modified">1069             if (tryAcquireShared(arg) &gt;= 0)</span>
<span class="line-modified">1070                 return true;</span>
<span class="line-modified">1071             if (nanosTimeout &lt;= 0L)</span>
<span class="line-added">1072                 return false;</span>
<span class="line-added">1073             int stat = acquire(null, arg, true, true, true,</span>
<span class="line-added">1074                                System.nanoTime() + nanosTimeout);</span>
<span class="line-added">1075             if (stat &gt; 0)</span>
<span class="line-added">1076                 return true;</span>
<span class="line-added">1077             if (stat == 0)</span>
<span class="line-added">1078                 return false;</span>
<span class="line-added">1079         }</span>
<span class="line-added">1080         throw new InterruptedException();</span>
1081     }
1082 
1083     /**
1084      * Releases in shared mode.  Implemented by unblocking one or more
1085      * threads if {@link #tryReleaseShared} returns true.
1086      *
1087      * @param arg the release argument.  This value is conveyed to
1088      *        {@link #tryReleaseShared} but is otherwise uninterpreted
1089      *        and can represent anything you like.
1090      * @return the value returned from {@link #tryReleaseShared}
1091      */
1092     public final boolean releaseShared(int arg) {
1093         if (tryReleaseShared(arg)) {
<span class="line-modified">1094             signalNext(head);</span>
1095             return true;
1096         }
1097         return false;
1098     }
1099 
1100     // Queue inspection methods
1101 
1102     /**
1103      * Queries whether any threads are waiting to acquire. Note that
1104      * because cancellations due to interrupts and timeouts may occur
1105      * at any time, a {@code true} return does not guarantee that any
1106      * other thread will ever acquire.
1107      *
1108      * @return {@code true} if there may be other threads waiting to acquire
1109      */
1110     public final boolean hasQueuedThreads() {
1111         for (Node p = tail, h = head; p != h &amp;&amp; p != null; p = p.prev)
<span class="line-modified">1112             if (p.status &gt;= 0)</span>
1113                 return true;
1114         return false;
1115     }
1116 
1117     /**
1118      * Queries whether any threads have ever contended to acquire this
1119      * synchronizer; that is, if an acquire method has ever blocked.
1120      *
1121      * &lt;p&gt;In this implementation, this operation returns in
1122      * constant time.
1123      *
1124      * @return {@code true} if there has ever been contention
1125      */
1126     public final boolean hasContended() {
1127         return head != null;
1128     }
1129 
1130     /**
1131      * Returns the first (longest-waiting) thread in the queue, or
1132      * {@code null} if no threads are currently queued.
1133      *
1134      * &lt;p&gt;In this implementation, this operation normally returns in
1135      * constant time, but may iterate upon contention if other threads are
1136      * concurrently modifying the queue.
1137      *
1138      * @return the first (longest-waiting) thread in the queue, or
1139      *         {@code null} if no threads are currently queued
1140      */
1141     public final Thread getFirstQueuedThread() {
<span class="line-modified">1142         Thread first = null, w; Node h, s;</span>
<span class="line-modified">1143         if ((h = head) != null &amp;&amp; ((s = h.next) == null ||</span>
<span class="line-modified">1144                                    (first = s.waiter) == null ||</span>
<span class="line-modified">1145                                    s.prev == null)) {</span>
<span class="line-modified">1146             // traverse from tail on stale reads</span>
<span class="line-modified">1147             for (Node p = tail, q; p != null &amp;&amp; (q = p.prev) != null; p = q)</span>
<span class="line-modified">1148                 if ((w = p.waiter) != null)</span>
<span class="line-modified">1149                     first = w;</span>





























1150         }
<span class="line-modified">1151         return first;</span>
1152     }
1153 
1154     /**
1155      * Returns true if the given thread is currently queued.
1156      *
1157      * &lt;p&gt;This implementation traverses the queue to determine
1158      * presence of the given thread.
1159      *
1160      * @param thread the thread
1161      * @return {@code true} if the given thread is on the queue
1162      * @throws NullPointerException if the thread is null
1163      */
1164     public final boolean isQueued(Thread thread) {
1165         if (thread == null)
1166             throw new NullPointerException();
1167         for (Node p = tail; p != null; p = p.prev)
<span class="line-modified">1168             if (p.waiter == thread)</span>
1169                 return true;
1170         return false;
1171     }
1172 
1173     /**
1174      * Returns {@code true} if the apparent first queued thread, if one
1175      * exists, is waiting in exclusive mode.  If this method returns
1176      * {@code true}, and the current thread is attempting to acquire in
1177      * shared mode (that is, this method is invoked from {@link
1178      * #tryAcquireShared}) then it is guaranteed that the current thread
1179      * is not the first queued thread.  Used only as a heuristic in
1180      * ReentrantReadWriteLock.
1181      */
1182     final boolean apparentlyFirstQueuedIsExclusive() {
1183         Node h, s;
<span class="line-modified">1184         return (h = head) != null &amp;&amp; (s = h.next)  != null &amp;&amp;</span>
<span class="line-modified">1185             !(s instanceof SharedNode) &amp;&amp; s.waiter != null;</span>


1186     }
1187 
1188     /**
1189      * Queries whether any threads have been waiting to acquire longer
1190      * than the current thread.
1191      *
1192      * &lt;p&gt;An invocation of this method is equivalent to (but may be
1193      * more efficient than):
1194      * &lt;pre&gt; {@code
1195      * getFirstQueuedThread() != Thread.currentThread()
1196      *   &amp;&amp; hasQueuedThreads()}&lt;/pre&gt;
1197      *
1198      * &lt;p&gt;Note that because cancellations due to interrupts and
1199      * timeouts may occur at any time, a {@code true} return does not
1200      * guarantee that some other thread will acquire before the current
1201      * thread.  Likewise, it is possible for another thread to win a
1202      * race to enqueue after this method has returned {@code false},
1203      * due to the queue being empty.
1204      *
1205      * &lt;p&gt;This method is designed to be used by a fair synchronizer to
</pre>
<hr />
<pre>
1212      * synchronizer might look like this:
1213      *
1214      * &lt;pre&gt; {@code
1215      * protected boolean tryAcquire(int arg) {
1216      *   if (isHeldExclusively()) {
1217      *     // A reentrant acquire; increment hold count
1218      *     return true;
1219      *   } else if (hasQueuedPredecessors()) {
1220      *     return false;
1221      *   } else {
1222      *     // try to acquire normally
1223      *   }
1224      * }}&lt;/pre&gt;
1225      *
1226      * @return {@code true} if there is a queued thread preceding the
1227      *         current thread, and {@code false} if the current thread
1228      *         is at the head of the queue or the queue is empty
1229      * @since 1.7
1230      */
1231     public final boolean hasQueuedPredecessors() {
<span class="line-modified">1232         Thread first = null; Node h, s;</span>
<span class="line-modified">1233         if ((h = head) != null &amp;&amp; ((s = h.next) == null ||</span>
<span class="line-modified">1234                                    (first = s.waiter) == null ||</span>
<span class="line-modified">1235                                    s.prev == null))</span>
<span class="line-modified">1236             first = getFirstQueuedThread(); // retry via getFirstQueuedThread</span>
<span class="line-modified">1237         return first != null &amp;&amp; first != Thread.currentThread();</span>







1238     }
1239 
1240     // Instrumentation and monitoring methods
1241 
1242     /**
1243      * Returns an estimate of the number of threads waiting to
1244      * acquire.  The value is only an estimate because the number of
1245      * threads may change dynamically while this method traverses
1246      * internal data structures.  This method is designed for use in
1247      * monitoring system state, not for synchronization control.
1248      *
1249      * @return the estimated number of threads waiting to acquire
1250      */
1251     public final int getQueueLength() {
1252         int n = 0;
1253         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1254             if (p.waiter != null)</span>
1255                 ++n;
1256         }
1257         return n;
1258     }
1259 
1260     /**
1261      * Returns a collection containing threads that may be waiting to
1262      * acquire.  Because the actual set of threads may change
1263      * dynamically while constructing this result, the returned
1264      * collection is only a best-effort estimate.  The elements of the
1265      * returned collection are in no particular order.  This method is
1266      * designed to facilitate construction of subclasses that provide
1267      * more extensive monitoring facilities.
1268      *
1269      * @return the collection of threads
1270      */
1271     public final Collection&lt;Thread&gt; getQueuedThreads() {
1272         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1273         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1274             Thread t = p.waiter;</span>
1275             if (t != null)
1276                 list.add(t);
1277         }
1278         return list;
1279     }
1280 
1281     /**
1282      * Returns a collection containing threads that may be waiting to
1283      * acquire in exclusive mode. This has the same properties
1284      * as {@link #getQueuedThreads} except that it only returns
1285      * those threads waiting due to an exclusive acquire.
1286      *
1287      * @return the collection of threads
1288      */
1289     public final Collection&lt;Thread&gt; getExclusiveQueuedThreads() {
1290         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1291         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1292             if (!(p instanceof SharedNode)) {</span>
<span class="line-modified">1293                 Thread t = p.waiter;</span>
1294                 if (t != null)
1295                     list.add(t);
1296             }
1297         }
1298         return list;
1299     }
1300 
1301     /**
1302      * Returns a collection containing threads that may be waiting to
1303      * acquire in shared mode. This has the same properties
1304      * as {@link #getQueuedThreads} except that it only returns
1305      * those threads waiting due to a shared acquire.
1306      *
1307      * @return the collection of threads
1308      */
1309     public final Collection&lt;Thread&gt; getSharedQueuedThreads() {
1310         ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
1311         for (Node p = tail; p != null; p = p.prev) {
<span class="line-modified">1312             if (p instanceof SharedNode) {</span>
<span class="line-modified">1313                 Thread t = p.waiter;</span>
1314                 if (t != null)
1315                     list.add(t);
1316             }
1317         }
1318         return list;
1319     }
1320 
1321     /**
1322      * Returns a string identifying this synchronizer, as well as its state.
1323      * The state, in brackets, includes the String {@code &quot;State =&quot;}
1324      * followed by the current value of {@link #getState}, and either
1325      * {@code &quot;nonempty&quot;} or {@code &quot;empty&quot;} depending on whether the
1326      * queue is empty.
1327      *
1328      * @return a string identifying this synchronizer, as well as its state
1329      */
1330     public String toString() {
1331         return super.toString()
1332             + &quot;[State = &quot; + getState() + &quot;, &quot;
1333             + (hasQueuedThreads() ? &quot;non&quot; : &quot;&quot;) + &quot;empty queue]&quot;;
1334     }
1335 















































































































1336     // Instrumentation methods for conditions
1337 
1338     /**
1339      * Queries whether the given ConditionObject
1340      * uses this synchronizer as its lock.
1341      *
1342      * @param condition the condition
1343      * @return {@code true} if owned
1344      * @throws NullPointerException if the condition is null
1345      */
1346     public final boolean owns(ConditionObject condition) {
1347         return condition.isOwnedBy(this);
1348     }
1349 
1350     /**
1351      * Queries whether any threads are waiting on the given condition
1352      * associated with this synchronizer. Note that because timeouts
1353      * and interrupts may occur at any time, a {@code true} return
1354      * does not guarantee that a future {@code signal} will awaken
1355      * any threads.  This method is designed primarily for use in
</pre>
<hr />
<pre>
1413         return condition.getWaitingThreads();
1414     }
1415 
1416     /**
1417      * Condition implementation for a {@link AbstractQueuedSynchronizer}
1418      * serving as the basis of a {@link Lock} implementation.
1419      *
1420      * &lt;p&gt;Method documentation for this class describes mechanics,
1421      * not behavioral specifications from the point of view of Lock
1422      * and Condition users. Exported versions of this class will in
1423      * general need to be accompanied by documentation describing
1424      * condition semantics that rely on those of the associated
1425      * {@code AbstractQueuedSynchronizer}.
1426      *
1427      * &lt;p&gt;This class is Serializable, but all fields are transient,
1428      * so deserialized conditions have no waiters.
1429      */
1430     public class ConditionObject implements Condition, java.io.Serializable {
1431         private static final long serialVersionUID = 1173984872572414699L;
1432         /** First node of condition queue. */
<span class="line-modified">1433         private transient ConditionNode firstWaiter;</span>
1434         /** Last node of condition queue. */
<span class="line-modified">1435         private transient ConditionNode lastWaiter;</span>
1436 
1437         /**
1438          * Creates a new {@code ConditionObject} instance.
1439          */
1440         public ConditionObject() { }
1441 
<span class="line-modified">1442         // Signalling methods</span>
























1443 
1444         /**
<span class="line-modified">1445          * Removes and transfers one or all waiters to sync queue.</span>



1446          */
<span class="line-modified">1447         private void doSignal(ConditionNode first, boolean all) {</span>
<span class="line-modified">1448             while (first != null) {</span>
<span class="line-modified">1449                 ConditionNode next = first.nextWaiter;</span>
<span class="line-added">1450                 if ((firstWaiter = next) == null)</span>
1451                     lastWaiter = null;
<span class="line-modified">1452                 if ((first.getAndUnsetStatus(COND) &amp; COND) != 0) {</span>
<span class="line-modified">1453                     enqueue(first);</span>
<span class="line-modified">1454                     if (!all)</span>
<span class="line-modified">1455                         break;</span>










































1456                 }
<span class="line-modified">1457                 first = next;</span>


1458             }
1459         }
1460 


1461         /**
1462          * Moves the longest-waiting thread, if one exists, from the
1463          * wait queue for this condition to the wait queue for the
1464          * owning lock.
1465          *
1466          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1467          *         returns {@code false}
1468          */
1469         public final void signal() {
<span class="line-added">1470             ConditionNode first = firstWaiter;</span>
1471             if (!isHeldExclusively())
1472                 throw new IllegalMonitorStateException();

1473             if (first != null)
<span class="line-modified">1474                 doSignal(first, false);</span>
1475         }
1476 
1477         /**
1478          * Moves all threads from the wait queue for this condition to
1479          * the wait queue for the owning lock.
1480          *
1481          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1482          *         returns {@code false}
1483          */
1484         public final void signalAll() {
<span class="line-added">1485             ConditionNode first = firstWaiter;</span>
1486             if (!isHeldExclusively())
1487                 throw new IllegalMonitorStateException();

1488             if (first != null)
<span class="line-modified">1489                 doSignal(first, true);</span>
<span class="line-added">1490         }</span>
<span class="line-added">1491 </span>
<span class="line-added">1492         // Waiting methods</span>
<span class="line-added">1493 </span>
<span class="line-added">1494         /**</span>
<span class="line-added">1495          * Adds node to condition list and releases lock.</span>
<span class="line-added">1496          *</span>
<span class="line-added">1497          * @param node the node</span>
<span class="line-added">1498          * @return savedState to reacquire after wait</span>
<span class="line-added">1499          */</span>
<span class="line-added">1500         private int enableWait(ConditionNode node) {</span>
<span class="line-added">1501             if (isHeldExclusively()) {</span>
<span class="line-added">1502                 node.waiter = Thread.currentThread();</span>
<span class="line-added">1503                 node.setStatusRelaxed(COND | WAITING);</span>
<span class="line-added">1504                 ConditionNode last = lastWaiter;</span>
<span class="line-added">1505                 if (last == null)</span>
<span class="line-added">1506                     firstWaiter = node;</span>
<span class="line-added">1507                 else</span>
<span class="line-added">1508                     last.nextWaiter = node;</span>
<span class="line-added">1509                 lastWaiter = node;</span>
<span class="line-added">1510                 int savedState = getState();</span>
<span class="line-added">1511                 if (release(savedState))</span>
<span class="line-added">1512                     return savedState;</span>
<span class="line-added">1513             }</span>
<span class="line-added">1514             node.status = CANCELLED; // lock not held or inconsistent</span>
<span class="line-added">1515             throw new IllegalMonitorStateException();</span>
<span class="line-added">1516         }</span>
<span class="line-added">1517 </span>
<span class="line-added">1518         /**</span>
<span class="line-added">1519          * Returns true if a node that was initially placed on a condition</span>
<span class="line-added">1520          * queue is now ready to reacquire on sync queue.</span>
<span class="line-added">1521          * @param node the node</span>
<span class="line-added">1522          * @return true if is reacquiring</span>
<span class="line-added">1523          */</span>
<span class="line-added">1524         private boolean canReacquire(ConditionNode node) {</span>
<span class="line-added">1525             // check links, not status to avoid enqueue race</span>
<span class="line-added">1526             return node != null &amp;&amp; node.prev != null &amp;&amp; isEnqueued(node);</span>
<span class="line-added">1527         }</span>
<span class="line-added">1528 </span>
<span class="line-added">1529         /**</span>
<span class="line-added">1530          * Unlinks the given node and other non-waiting nodes from</span>
<span class="line-added">1531          * condition queue unless already unlinked.</span>
<span class="line-added">1532          */</span>
<span class="line-added">1533         private void unlinkCancelledWaiters(ConditionNode node) {</span>
<span class="line-added">1534             if (node == null || node.nextWaiter != null || node == lastWaiter) {</span>
<span class="line-added">1535                 ConditionNode w = firstWaiter, trail = null;</span>
<span class="line-added">1536                 while (w != null) {</span>
<span class="line-added">1537                     ConditionNode next = w.nextWaiter;</span>
<span class="line-added">1538                     if ((w.status &amp; COND) == 0) {</span>
<span class="line-added">1539                         w.nextWaiter = null;</span>
<span class="line-added">1540                         if (trail == null)</span>
<span class="line-added">1541                             firstWaiter = next;</span>
<span class="line-added">1542                         else</span>
<span class="line-added">1543                             trail.nextWaiter = next;</span>
<span class="line-added">1544                         if (next == null)</span>
<span class="line-added">1545                             lastWaiter = trail;</span>
<span class="line-added">1546                     } else</span>
<span class="line-added">1547                         trail = w;</span>
<span class="line-added">1548                     w = next;</span>
<span class="line-added">1549                 }</span>
<span class="line-added">1550             }</span>
1551         }
1552 
1553         /**
1554          * Implements uninterruptible condition wait.
1555          * &lt;ol&gt;
1556          * &lt;li&gt;Save lock state returned by {@link #getState}.
1557          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1558          *     throwing IllegalMonitorStateException if it fails.
1559          * &lt;li&gt;Block until signalled.
1560          * &lt;li&gt;Reacquire by invoking specialized version of
1561          *     {@link #acquire} with saved state as argument.
1562          * &lt;/ol&gt;
1563          */
1564         public final void awaitUninterruptibly() {
<span class="line-modified">1565             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1566             int savedState = enableWait(node);</span>
<span class="line-added">1567             LockSupport.setCurrentBlocker(this); // for back-compatibility</span>
1568             boolean interrupted = false;
<span class="line-modified">1569             while (!canReacquire(node)) {</span>

1570                 if (Thread.interrupted())
1571                     interrupted = true;
<span class="line-added">1572                 else if ((node.status &amp; COND) != 0) {</span>
<span class="line-added">1573                     try {</span>
<span class="line-added">1574                         ForkJoinPool.managedBlock(node);</span>
<span class="line-added">1575                     } catch (InterruptedException ie) {</span>
<span class="line-added">1576                         interrupted = true;</span>
<span class="line-added">1577                     }</span>
<span class="line-added">1578                 } else</span>
<span class="line-added">1579                     Thread.onSpinWait();    // awoke while enqueuing</span>
1580             }
<span class="line-modified">1581             LockSupport.setCurrentBlocker(null);</span>
<span class="line-modified">1582             node.clearStatus();</span>
<span class="line-modified">1583             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1584             if (interrupted)</span>
<span class="line-modified">1585                 Thread.currentThread().interrupt();</span>
































1586         }
1587 
1588         /**
1589          * Implements interruptible condition wait.
1590          * &lt;ol&gt;
1591          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1592          * &lt;li&gt;Save lock state returned by {@link #getState}.
1593          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1594          *     throwing IllegalMonitorStateException if it fails.
1595          * &lt;li&gt;Block until signalled or interrupted.
1596          * &lt;li&gt;Reacquire by invoking specialized version of
1597          *     {@link #acquire} with saved state as argument.
1598          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1599          * &lt;/ol&gt;
1600          */
1601         public final void await() throws InterruptedException {
1602             if (Thread.interrupted())
1603                 throw new InterruptedException();
<span class="line-modified">1604             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1605             int savedState = enableWait(node);</span>
<span class="line-modified">1606             LockSupport.setCurrentBlocker(this); // for back-compatibility</span>
<span class="line-modified">1607             boolean interrupted = false, cancelled = false;</span>
<span class="line-modified">1608             while (!canReacquire(node)) {</span>
<span class="line-modified">1609                 if (interrupted |= Thread.interrupted()) {</span>
<span class="line-modified">1610                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-added">1611                         break;              // else interrupted after signal</span>
<span class="line-added">1612                 } else if ((node.status &amp; COND) != 0) {</span>
<span class="line-added">1613                     try {</span>
<span class="line-added">1614                         ForkJoinPool.managedBlock(node);</span>
<span class="line-added">1615                     } catch (InterruptedException ie) {</span>
<span class="line-added">1616                         interrupted = true;</span>
<span class="line-added">1617                     }</span>
<span class="line-added">1618                 } else</span>
<span class="line-added">1619                     Thread.onSpinWait();    // awoke while enqueuing</span>
<span class="line-added">1620             }</span>
<span class="line-added">1621             LockSupport.setCurrentBlocker(null);</span>
<span class="line-added">1622             node.clearStatus();</span>
<span class="line-added">1623             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-added">1624             if (interrupted) {</span>
<span class="line-added">1625                 if (cancelled) {</span>
<span class="line-added">1626                     unlinkCancelledWaiters(node);</span>
<span class="line-added">1627                     throw new InterruptedException();</span>
<span class="line-added">1628                 }</span>
<span class="line-added">1629                 Thread.currentThread().interrupt();</span>
1630             }






1631         }
1632 
1633         /**
1634          * Implements timed condition wait.
1635          * &lt;ol&gt;
1636          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1637          * &lt;li&gt;Save lock state returned by {@link #getState}.
1638          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1639          *     throwing IllegalMonitorStateException if it fails.
1640          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1641          * &lt;li&gt;Reacquire by invoking specialized version of
1642          *     {@link #acquire} with saved state as argument.
1643          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1644          * &lt;/ol&gt;
1645          */
1646         public final long awaitNanos(long nanosTimeout)
1647                 throws InterruptedException {
1648             if (Thread.interrupted())
1649                 throw new InterruptedException();
<span class="line-modified">1650             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1651             int savedState = enableWait(node);</span>
<span class="line-modified">1652             long nanos = (nanosTimeout &lt; 0L) ? 0L : nanosTimeout;</span>
<span class="line-modified">1653             long deadline = System.nanoTime() + nanos;</span>
<span class="line-modified">1654             boolean cancelled = false, interrupted = false;</span>
<span class="line-modified">1655             while (!canReacquire(node)) {</span>
<span class="line-modified">1656                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="line-modified">1657                     (nanos = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="line-modified">1658                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-modified">1659                         break;</span>
<span class="line-modified">1660                 } else</span>
<span class="line-modified">1661                     LockSupport.parkNanos(this, nanos);</span>





1662             }
<span class="line-modified">1663             node.clearStatus();</span>
<span class="line-modified">1664             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1665             if (cancelled) {</span>
<span class="line-modified">1666                 unlinkCancelledWaiters(node);</span>
<span class="line-modified">1667                 if (interrupted)</span>
<span class="line-modified">1668                     throw new InterruptedException();</span>
<span class="line-added">1669             } else if (interrupted)</span>
<span class="line-added">1670                 Thread.currentThread().interrupt();</span>
1671             long remaining = deadline - System.nanoTime(); // avoid overflow
<span class="line-modified">1672             return (remaining &lt;= nanosTimeout) ? remaining : Long.MIN_VALUE;</span>
1673         }
1674 
1675         /**
1676          * Implements absolute timed condition wait.
1677          * &lt;ol&gt;
1678          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1679          * &lt;li&gt;Save lock state returned by {@link #getState}.
1680          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1681          *     throwing IllegalMonitorStateException if it fails.
1682          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1683          * &lt;li&gt;Reacquire by invoking specialized version of
1684          *     {@link #acquire} with saved state as argument.
1685          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1686          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1687          * &lt;/ol&gt;
1688          */
1689         public final boolean awaitUntil(Date deadline)
1690                 throws InterruptedException {
1691             long abstime = deadline.getTime();
1692             if (Thread.interrupted())
1693                 throw new InterruptedException();
<span class="line-modified">1694             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1695             int savedState = enableWait(node);</span>
<span class="line-modified">1696             boolean cancelled = false, interrupted = false;</span>
<span class="line-modified">1697             while (!canReacquire(node)) {</span>
<span class="line-modified">1698                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="line-modified">1699                     System.currentTimeMillis() &gt;= abstime) {</span>
<span class="line-modified">1700                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-modified">1701                         break;</span>
<span class="line-modified">1702                 } else</span>
<span class="line-modified">1703                     LockSupport.parkUntil(this, abstime);</span>


1704             }
<span class="line-modified">1705             node.clearStatus();</span>
<span class="line-modified">1706             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1707             if (cancelled) {</span>
<span class="line-modified">1708                 unlinkCancelledWaiters(node);</span>
<span class="line-modified">1709                 if (interrupted)</span>
<span class="line-modified">1710                     throw new InterruptedException();</span>
<span class="line-modified">1711             } else if (interrupted)</span>
<span class="line-added">1712                 Thread.currentThread().interrupt();</span>
<span class="line-added">1713             return !cancelled;</span>
1714         }
1715 
1716         /**
1717          * Implements timed condition wait.
1718          * &lt;ol&gt;
1719          * &lt;li&gt;If current thread is interrupted, throw InterruptedException.
1720          * &lt;li&gt;Save lock state returned by {@link #getState}.
1721          * &lt;li&gt;Invoke {@link #release} with saved state as argument,
1722          *     throwing IllegalMonitorStateException if it fails.
1723          * &lt;li&gt;Block until signalled, interrupted, or timed out.
1724          * &lt;li&gt;Reacquire by invoking specialized version of
1725          *     {@link #acquire} with saved state as argument.
1726          * &lt;li&gt;If interrupted while blocked in step 4, throw InterruptedException.
1727          * &lt;li&gt;If timed out while blocked in step 4, return false, else true.
1728          * &lt;/ol&gt;
1729          */
1730         public final boolean await(long time, TimeUnit unit)
1731                 throws InterruptedException {
1732             long nanosTimeout = unit.toNanos(time);
1733             if (Thread.interrupted())
1734                 throw new InterruptedException();
<span class="line-modified">1735             ConditionNode node = new ConditionNode();</span>
<span class="line-modified">1736             int savedState = enableWait(node);</span>
<span class="line-modified">1737             long nanos = (nanosTimeout &lt; 0L) ? 0L : nanosTimeout;</span>
<span class="line-modified">1738             long deadline = System.nanoTime() + nanos;</span>
<span class="line-modified">1739             boolean cancelled = false, interrupted = false;</span>
<span class="line-modified">1740             while (!canReacquire(node)) {</span>
<span class="line-modified">1741                 if ((interrupted |= Thread.interrupted()) ||</span>
<span class="line-modified">1742                     (nanos = deadline - System.nanoTime()) &lt;= 0L) {</span>
<span class="line-modified">1743                     if (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != 0)</span>
<span class="line-modified">1744                         break;</span>
<span class="line-modified">1745                 } else</span>
<span class="line-modified">1746                     LockSupport.parkNanos(this, nanos);</span>





1747             }
<span class="line-modified">1748             node.clearStatus();</span>
<span class="line-modified">1749             acquire(node, savedState, false, false, false, 0L);</span>
<span class="line-modified">1750             if (cancelled) {</span>
<span class="line-modified">1751                 unlinkCancelledWaiters(node);</span>
<span class="line-modified">1752                 if (interrupted)</span>
<span class="line-modified">1753                     throw new InterruptedException();</span>
<span class="line-modified">1754             } else if (interrupted)</span>
<span class="line-added">1755                 Thread.currentThread().interrupt();</span>
<span class="line-added">1756             return !cancelled;</span>
1757         }
1758 
1759         //  support for instrumentation
1760 
1761         /**
1762          * Returns true if this condition was created by the given
1763          * synchronization object.
1764          *
1765          * @return {@code true} if owned
1766          */
1767         final boolean isOwnedBy(AbstractQueuedSynchronizer sync) {
1768             return sync == AbstractQueuedSynchronizer.this;
1769         }
1770 
1771         /**
1772          * Queries whether any threads are waiting on this condition.
1773          * Implements {@link AbstractQueuedSynchronizer#hasWaiters(ConditionObject)}.
1774          *
1775          * @return {@code true} if there are any waiting threads
1776          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1777          *         returns {@code false}
1778          */
1779         protected final boolean hasWaiters() {
1780             if (!isHeldExclusively())
1781                 throw new IllegalMonitorStateException();
<span class="line-modified">1782             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1783                 if ((w.status &amp; COND) != 0)</span>
1784                     return true;
1785             }
1786             return false;
1787         }
1788 
1789         /**
1790          * Returns an estimate of the number of threads waiting on
1791          * this condition.
1792          * Implements {@link AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)}.
1793          *
1794          * @return the estimated number of waiting threads
1795          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1796          *         returns {@code false}
1797          */
1798         protected final int getWaitQueueLength() {
1799             if (!isHeldExclusively())
1800                 throw new IllegalMonitorStateException();
1801             int n = 0;
<span class="line-modified">1802             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1803                 if ((w.status &amp; COND) != 0)</span>
1804                     ++n;
1805             }
1806             return n;
1807         }
1808 
1809         /**
1810          * Returns a collection containing those threads that may be
1811          * waiting on this Condition.
1812          * Implements {@link AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)}.
1813          *
1814          * @return the collection of threads
1815          * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
1816          *         returns {@code false}
1817          */
1818         protected final Collection&lt;Thread&gt; getWaitingThreads() {
1819             if (!isHeldExclusively())
1820                 throw new IllegalMonitorStateException();
1821             ArrayList&lt;Thread&gt; list = new ArrayList&lt;&gt;();
<span class="line-modified">1822             for (ConditionNode w = firstWaiter; w != null; w = w.nextWaiter) {</span>
<span class="line-modified">1823                 if ((w.status &amp; COND) != 0) {</span>
<span class="line-modified">1824                     Thread t = w.waiter;</span>
1825                     if (t != null)
1826                         list.add(t);
1827                 }
1828             }
1829             return list;
1830         }
1831     }
1832 
<span class="line-modified">1833     // Unsafe</span>
<span class="line-modified">1834     private static final Unsafe U = Unsafe.getUnsafe();</span>
<span class="line-modified">1835     private static final long STATE</span>
<span class="line-modified">1836         = U.objectFieldOffset(AbstractQueuedSynchronizer.class, &quot;state&quot;);</span>
<span class="line-added">1837     private static final long HEAD</span>
<span class="line-added">1838         = U.objectFieldOffset(AbstractQueuedSynchronizer.class, &quot;head&quot;);</span>
<span class="line-added">1839     private static final long TAIL</span>
<span class="line-added">1840         = U.objectFieldOffset(AbstractQueuedSynchronizer.class, &quot;tail&quot;);</span>
1841 
1842     static {











1843         Class&lt;?&gt; ensureLoaded = LockSupport.class;
1844     }
















1845 }
</pre>
</td>
</tr>
</table>
<center><a href="AbstractQueuedLongSynchronizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Condition.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
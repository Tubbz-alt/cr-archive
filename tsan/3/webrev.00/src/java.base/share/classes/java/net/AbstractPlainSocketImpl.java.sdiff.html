<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/net/AbstractPlainSocketImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractPlainDatagramSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BindException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/net/AbstractPlainSocketImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.OutputStream;
 32 



 33 import java.util.Collections;
 34 import java.util.HashSet;

 35 import java.util.Set;
 36 
 37 import sun.net.ConnectionResetException;
 38 import sun.net.NetHooks;

 39 import sun.net.ResourceManager;


 40 import sun.net.util.SocketExceptions;
 41 
 42 /**
 43  * Default Socket Implementation. This implementation does
 44  * not implement any security checks.
 45  * Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.
 46  *
 47  * @author  Steven B. Byrne
 48  */
<span class="line-modified"> 49 abstract class AbstractPlainSocketImpl extends SocketImpl {</span>
 50     /* instance variable for SO_TIMEOUT */
 51     int timeout;   // timeout in millisec
 52     // traffic class
 53     private int trafficClass;
 54 
 55     private boolean shut_rd = false;
 56     private boolean shut_wr = false;
 57 
 58     private SocketInputStream socketInputStream = null;
 59     private SocketOutputStream socketOutputStream = null;
 60 
 61     /* number of threads using the FileDescriptor */
 62     protected int fdUseCount = 0;
 63 
 64     /* lock when increment/decrementing fdUseCount */
 65     protected final Object fdLock = new Object();
 66 
 67     /* indicates a close is pending on the file descriptor */
 68     protected boolean closePending = false;
 69 
 70     /* indicates connection reset state */
 71     private volatile boolean connectionReset;
 72 






 73    /* whether this Socket is a stream (TCP) socket or not (UDP)
 74     */
 75     protected boolean stream;
 76 



 77     /**
 78      * Load net library into runtime.
 79      */
 80     static {
<span class="line-modified"> 81         java.security.AccessController.doPrivileged(</span>
<span class="line-removed"> 82             new java.security.PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed"> 83                 public Void run() {</span>
<span class="line-removed"> 84                     System.loadLibrary(&quot;net&quot;);</span>
<span class="line-removed"> 85                     return null;</span>
<span class="line-removed"> 86                 }</span>
<span class="line-removed"> 87             });</span>
 88     }
 89 
 90     private static volatile boolean checkedReusePort;
 91     private static volatile boolean isReusePortAvailable;
 92 
 93     /**
 94      * Tells whether SO_REUSEPORT is supported.
 95      */
 96     static boolean isReusePortAvailable() {
 97         if (!checkedReusePort) {
 98             isReusePortAvailable = isReusePortAvailable0();
 99             checkedReusePort = true;
100         }
101         return isReusePortAvailable;
102     }
103 
<span class="line-modified">104     /**</span>
<span class="line-modified">105      * Returns a set of SocketOptions supported by this impl and by this impl&#39;s</span>
<span class="line-removed">106      * socket (Socket or ServerSocket)</span>
<span class="line-removed">107      *</span>
<span class="line-removed">108      * @return a Set of SocketOptions</span>
<span class="line-removed">109      */</span>
<span class="line-removed">110     @Override</span>
<span class="line-removed">111     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-removed">112         Set&lt;SocketOption&lt;?&gt;&gt; options;</span>
<span class="line-removed">113         if (isReusePortAvailable()) {</span>
<span class="line-removed">114             options = new HashSet&lt;&gt;();</span>
<span class="line-removed">115             options.addAll(super.supportedOptions());</span>
<span class="line-removed">116             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-removed">117             options = Collections.unmodifiableSet(options);</span>
<span class="line-removed">118         } else {</span>
<span class="line-removed">119             options = super.supportedOptions();</span>
<span class="line-removed">120         }</span>
<span class="line-removed">121         return options;</span>
122     }
123 
124     /**
125      * Creates a socket with a boolean that specifies whether this
126      * is a stream socket (true) or an unconnected UDP socket (false).
127      */
128     protected synchronized void create(boolean stream) throws IOException {
129         this.stream = stream;
130         if (!stream) {
131             ResourceManager.beforeUdpCreate();
132             // only create the fd after we know we will be able to create the socket
133             fd = new FileDescriptor();
134             try {
135                 socketCreate(false);
<span class="line-modified">136                 SocketCleanable.register(fd);</span>
137             } catch (IOException ioe) {
138                 ResourceManager.afterUdpClose();
139                 fd = null;
140                 throw ioe;
141             }
142         } else {
143             fd = new FileDescriptor();
144             socketCreate(true);
<span class="line-modified">145             SocketCleanable.register(fd);</span>
146         }
<span class="line-removed">147         if (socket != null)</span>
<span class="line-removed">148             socket.setCreated();</span>
<span class="line-removed">149         if (serverSocket != null)</span>
<span class="line-removed">150             serverSocket.setCreated();</span>
151     }
152 
153     /**
154      * Creates a socket and connects it to the specified port on
155      * the specified host.
156      * @param host the specified host
157      * @param port the specified port
158      */
159     protected void connect(String host, int port)
160         throws UnknownHostException, IOException
161     {
162         boolean connected = false;
163         try {
164             InetAddress address = InetAddress.getByName(host);
<span class="line-modified">165             this.port = port;</span>
166             this.address = address;




167 
168             connectToAddress(address, port, timeout);
169             connected = true;
170         } finally {
171             if (!connected) {
172                 try {
173                     close();
174                 } catch (IOException ioe) {
175                     /* Do nothing. If connect threw an exception then
176                        it will be passed up the call stack */
177                 }
178             }

179         }
180     }
181 
182     /**
183      * Creates a socket and connects it to the specified address on
184      * the specified port.
185      * @param address the address
186      * @param port the specified port
187      */
188     protected void connect(InetAddress address, int port) throws IOException {
<span class="line-modified">189         this.port = port;</span>
190         this.address = address;




191 
192         try {
193             connectToAddress(address, port, timeout);

194             return;
195         } catch (IOException e) {
196             // everything failed
197             close();
198             throw e;
199         }
200     }
201 
202     /**
203      * Creates a socket and connects it to the specified address on
204      * the specified port.
205      * @param address the address
206      * @param timeout the timeout value in milliseconds, or zero for no timeout.
207      * @throws IOException if connection fails
208      * @throws  IllegalArgumentException if address is null or is a
209      *          SocketAddress subclass not supported by this socket
210      * @since 1.4
211      */
212     protected void connect(SocketAddress address, int timeout)
213             throws IOException {
214         boolean connected = false;
215         try {
216             if (address == null || !(address instanceof InetSocketAddress))
217                 throw new IllegalArgumentException(&quot;unsupported address type&quot;);
218             InetSocketAddress addr = (InetSocketAddress) address;
219             if (addr.isUnresolved())
220                 throw new UnknownHostException(addr.getHostName());



221             this.port = addr.getPort();
<span class="line-modified">222             this.address = addr.getAddress();</span>
<span class="line-modified">223 </span>
<span class="line-modified">224             connectToAddress(this.address, port, timeout);</span>

225             connected = true;
226         } finally {
227             if (!connected) {
228                 try {
229                     close();
230                 } catch (IOException ioe) {
231                     /* Do nothing. If connect threw an exception then
232                        it will be passed up the call stack */
233                 }
234             }

235         }
236     }
237 
238     private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {
239         if (address.isAnyLocalAddress()) {
240             doConnect(InetAddress.getLocalHost(), port, timeout);
241         } else {
242             doConnect(address, port, timeout);
243         }
244     }
245 
246     public void setOption(int opt, Object val) throws SocketException {
247         if (isClosedOrPending()) {
248             throw new SocketException(&quot;Socket Closed&quot;);
249         }
250         boolean on = true;
251         switch (opt) {
252             /* check type safety b4 going native.  These should never
253              * fail, since only java.Socket* has access to
254              * PlainSocketImpl.setOption().
</pre>
<hr />
<pre>
364                 }
365             } catch (SocketException se) {
366                     // TODO - should make better effort to read TOS or TCLASS
367                     return trafficClass; // ipv6 tos
368             }
369         case SO_KEEPALIVE:
370             ret = socketGetOption(opt, null);
371             return Boolean.valueOf(ret != -1);
372         case SO_REUSEPORT:
373             if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {
374                 throw new UnsupportedOperationException(&quot;unsupported option&quot;);
375             }
376             ret = socketGetOption(opt, null);
377             return Boolean.valueOf(ret != -1);
378         // should never get here
379         default:
380             return null;
381         }
382     }
383 



























































































































384     /**
385      * The workhorse of the connection operation.  Tries several times to
386      * establish a connection to the given &lt;host, port&gt;.  If unsuccessful,
387      * throws an IOException indicating what went wrong.
388      */
389 
390     synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
391         synchronized (fdLock) {
<span class="line-modified">392             if (!closePending &amp;&amp; (socket == null || !socket.isBound())) {</span>
393                 NetHooks.beforeTcpConnect(fd, address, port);
394             }
395         }
396         try {
397             acquireFD();
398             try {
399                 socketConnect(address, port, timeout);
400                 /* socket may have been closed during poll/select */
401                 synchronized (fdLock) {
402                     if (closePending) {
403                         throw new SocketException (&quot;Socket closed&quot;);
404                     }
405                 }
<span class="line-removed">406                 // If we have a ref. to the Socket, then sets the flags</span>
<span class="line-removed">407                 // created, bound &amp; connected to true.</span>
<span class="line-removed">408                 // This is normally done in Socket.connect() but some</span>
<span class="line-removed">409                 // subclasses of Socket may call impl.connect() directly!</span>
<span class="line-removed">410                 if (socket != null) {</span>
<span class="line-removed">411                     socket.setBound();</span>
<span class="line-removed">412                     socket.setConnected();</span>
<span class="line-removed">413                 }</span>
414             } finally {
415                 releaseFD();
416             }
417         } catch (IOException e) {
418             close();
419             throw SocketExceptions.of(e, new InetSocketAddress(address, port));
420         }
421     }
422 
423     /**
424      * Binds the socket to the specified address of the specified local port.
425      * @param address the address
426      * @param lport the port
427      */
428     protected synchronized void bind(InetAddress address, int lport)
429         throws IOException
430     {
431        synchronized (fdLock) {
<span class="line-modified">432             if (!closePending &amp;&amp; (socket == null || !socket.isBound())) {</span>
433                 NetHooks.beforeTcpBind(fd, address, lport);
434             }
435         }



436         socketBind(address, lport);
<span class="line-modified">437         if (socket != null)</span>
<span class="line-removed">438             socket.setBound();</span>
<span class="line-removed">439         if (serverSocket != null)</span>
<span class="line-removed">440             serverSocket.setBound();</span>
441     }
442 
443     /**
444      * Listens, for a specified amount of time, for connections.
445      * @param count the amount of time to listen for connections
446      */
447     protected synchronized void listen(int count) throws IOException {
448         socketListen(count);
449     }
450 
451     /**
452      * Accepts connections.
<span class="line-modified">453      * @param s the connection</span>
454      */
<span class="line-modified">455     protected void accept(SocketImpl s) throws IOException {</span>

456         acquireFD();
457         try {
<span class="line-modified">458             socketAccept(s);</span>
459         } finally {
460             releaseFD();
461         }

462     }
463 
464     /**
465      * Gets an InputStream for this socket.
466      */
467     protected synchronized InputStream getInputStream() throws IOException {
468         synchronized (fdLock) {
469             if (isClosedOrPending())
470                 throw new IOException(&quot;Socket Closed&quot;);
471             if (shut_rd)
472                 throw new IOException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">473             if (socketInputStream == null)</span>
<span class="line-modified">474                 socketInputStream = new SocketInputStream(this);</span>






475         }
476         return socketInputStream;
477     }
478 
479     void setInputStream(SocketInputStream in) {
480         socketInputStream = in;
481     }
482 
483     /**
484      * Gets an OutputStream for this socket.
485      */
486     protected synchronized OutputStream getOutputStream() throws IOException {
487         synchronized (fdLock) {
488             if (isClosedOrPending())
489                 throw new IOException(&quot;Socket Closed&quot;);
490             if (shut_wr)
491                 throw new IOException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">492             if (socketOutputStream == null)</span>
<span class="line-modified">493                 socketOutputStream = new SocketOutputStream(this);</span>






494         }
495         return socketOutputStream;
496     }
497 
498     void setFileDescriptor(FileDescriptor fd) {
499         this.fd = fd;
500     }
501 
502     void setAddress(InetAddress address) {
503         this.address = address;
504     }
505 
506     void setPort(int port) {
507         this.port = port;
508     }
509 
510     void setLocalPort(int localport) {
511         this.localport = localport;
512     }
513 
</pre>
<hr />
<pre>
532          * of a connection reset then we move to the reset state.
533          *
534          * If are notified of a connection reset then check
535          * again if there are bytes buffered on the socket.
536          */
537         int n = 0;
538         try {
539             n = socketAvailable();
540         } catch (ConnectionResetException exc1) {
541             setConnectionReset();
542         }
543         return n;
544     }
545 
546     /**
547      * Closes the socket.
548      */
549     protected void close() throws IOException {
550         synchronized(fdLock) {
551             if (fd != null) {
<span class="line-removed">552                 if (!stream) {</span>
<span class="line-removed">553                     ResourceManager.afterUdpClose();</span>
<span class="line-removed">554                 }</span>
555                 if (fdUseCount == 0) {
556                     if (closePending) {
557                         return;
558                     }
559                     closePending = true;
560                     /*
561                      * We close the FileDescriptor in two-steps - first the
562                      * &quot;pre-close&quot; which closes the socket but doesn&#39;t
563                      * release the underlying file descriptor. This operation
564                      * may be lengthy due to untransmitted data and a long
565                      * linger interval. Once the pre-close is done we do the
566                      * actual socket to release the fd.
567                      */
568                     try {
569                         socketPreClose();
570                     } finally {
571                         socketClose();
572                     }
573                     fd = null;
574                     return;
575                 } else {
576                     /*
577                      * If a thread has acquired the fd and a close
578                      * isn&#39;t pending then use a deferred close.
579                      * Also decrement fdUseCount to signal the last
580                      * thread that releases the fd to close it.
581                      */
582                     if (!closePending) {
583                         closePending = true;
584                         fdUseCount--;
585                         socketPreClose();
586                     }
587                 }
588             }
589         }
590     }
591 
<span class="line-modified">592     void reset() throws IOException {</span>
<span class="line-modified">593         if (fd != null) {</span>
<span class="line-removed">594             socketClose();</span>
<span class="line-removed">595         }</span>
<span class="line-removed">596         fd = null;</span>
<span class="line-removed">597         super.reset();</span>
598     }
599 
<span class="line-removed">600 </span>
601     /**
602      * Shutdown read-half of the socket connection;
603      */
604     protected void shutdownInput() throws IOException {
605       if (fd != null) {
606           socketShutdown(SHUT_RD);
607           if (socketInputStream != null) {
608               socketInputStream.setEOF(true);
609           }
610           shut_rd = true;
611       }
612     }
613 
614     /**
615      * Shutdown write-half of the socket connection;
616      */
617     protected void shutdownOutput() throws IOException {
618       if (fd != null) {
619           socketShutdown(SHUT_WR);
620           shut_wr = true;
</pre>
<hr />
<pre>
694     /*
695      * Return the current value of SO_TIMEOUT
696      */
697     public int getTimeout() {
698         return timeout;
699     }
700 
701     /*
702      * &quot;Pre-close&quot; a socket by dup&#39;ing the file descriptor - this enables
703      * the socket to be closed without releasing the file descriptor.
704      */
705     private void socketPreClose() throws IOException {
706         socketClose0(true);
707     }
708 
709     /*
710      * Close the socket (and release the file descriptor).
711      */
712     protected void socketClose() throws IOException {
713         SocketCleanable.unregister(fd);
<span class="line-modified">714         socketClose0(false);</span>






715     }
716 
<span class="line-modified">717     abstract void socketCreate(boolean isServer) throws IOException;</span>
718     abstract void socketConnect(InetAddress address, int port, int timeout)
719         throws IOException;
720     abstract void socketBind(InetAddress address, int port)
721         throws IOException;
722     abstract void socketListen(int count)
723         throws IOException;
724     abstract void socketAccept(SocketImpl s)
725         throws IOException;
726     abstract int socketAvailable()
727         throws IOException;
728     abstract void socketClose0(boolean useDeferredClose)
729         throws IOException;
730     abstract void socketShutdown(int howto)
731         throws IOException;
732     abstract void socketSetOption(int cmd, boolean on, Object value)
733         throws SocketException;
734     abstract int socketGetOption(int opt, Object iaContainerObj) throws SocketException;
735     abstract void socketSendUrgentData(int data)
736         throws IOException;
737 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.net;
 27 
 28 import java.io.FileDescriptor;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.OutputStream;
 32 
<span class="line-added"> 33 import java.security.AccessController;</span>
<span class="line-added"> 34 import java.security.PrivilegedActionException;</span>
<span class="line-added"> 35 import java.security.PrivilegedExceptionAction;</span>
 36 import java.util.Collections;
 37 import java.util.HashSet;
<span class="line-added"> 38 import java.util.Objects;</span>
 39 import java.util.Set;
 40 
 41 import sun.net.ConnectionResetException;
 42 import sun.net.NetHooks;
<span class="line-added"> 43 import sun.net.PlatformSocketImpl;</span>
 44 import sun.net.ResourceManager;
<span class="line-added"> 45 import sun.net.ext.ExtendedSocketOptions;</span>
<span class="line-added"> 46 import sun.net.util.IPAddressUtil;</span>
 47 import sun.net.util.SocketExceptions;
 48 
 49 /**
 50  * Default Socket Implementation. This implementation does
 51  * not implement any security checks.
 52  * Note this class should &lt;b&gt;NOT&lt;/b&gt; be public.
 53  *
 54  * @author  Steven B. Byrne
 55  */
<span class="line-modified"> 56 abstract class AbstractPlainSocketImpl extends SocketImpl implements PlatformSocketImpl {</span>
 57     /* instance variable for SO_TIMEOUT */
 58     int timeout;   // timeout in millisec
 59     // traffic class
 60     private int trafficClass;
 61 
 62     private boolean shut_rd = false;
 63     private boolean shut_wr = false;
 64 
 65     private SocketInputStream socketInputStream = null;
 66     private SocketOutputStream socketOutputStream = null;
 67 
 68     /* number of threads using the FileDescriptor */
 69     protected int fdUseCount = 0;
 70 
 71     /* lock when increment/decrementing fdUseCount */
 72     protected final Object fdLock = new Object();
 73 
 74     /* indicates a close is pending on the file descriptor */
 75     protected boolean closePending = false;
 76 
 77     /* indicates connection reset state */
 78     private volatile boolean connectionReset;
 79 
<span class="line-added"> 80     /* indicates whether impl is bound  */</span>
<span class="line-added"> 81     boolean isBound;</span>
<span class="line-added"> 82 </span>
<span class="line-added"> 83     /* indicates whether impl is connected  */</span>
<span class="line-added"> 84     volatile boolean isConnected;</span>
<span class="line-added"> 85 </span>
 86    /* whether this Socket is a stream (TCP) socket or not (UDP)
 87     */
 88     protected boolean stream;
 89 
<span class="line-added"> 90     /* whether this is a server or not */</span>
<span class="line-added"> 91     final boolean isServer;</span>
<span class="line-added"> 92 </span>
 93     /**
 94      * Load net library into runtime.
 95      */
 96     static {
<span class="line-modified"> 97         jdk.internal.loader.BootLoader.loadLibrary(&quot;net&quot;);</span>






 98     }
 99 
100     private static volatile boolean checkedReusePort;
101     private static volatile boolean isReusePortAvailable;
102 
103     /**
104      * Tells whether SO_REUSEPORT is supported.
105      */
106     static boolean isReusePortAvailable() {
107         if (!checkedReusePort) {
108             isReusePortAvailable = isReusePortAvailable0();
109             checkedReusePort = true;
110         }
111         return isReusePortAvailable;
112     }
113 
<span class="line-modified">114     AbstractPlainSocketImpl(boolean isServer) {</span>
<span class="line-modified">115         this.isServer = isServer;</span>
















116     }
117 
118     /**
119      * Creates a socket with a boolean that specifies whether this
120      * is a stream socket (true) or an unconnected UDP socket (false).
121      */
122     protected synchronized void create(boolean stream) throws IOException {
123         this.stream = stream;
124         if (!stream) {
125             ResourceManager.beforeUdpCreate();
126             // only create the fd after we know we will be able to create the socket
127             fd = new FileDescriptor();
128             try {
129                 socketCreate(false);
<span class="line-modified">130                 SocketCleanable.register(fd, false);</span>
131             } catch (IOException ioe) {
132                 ResourceManager.afterUdpClose();
133                 fd = null;
134                 throw ioe;
135             }
136         } else {
137             fd = new FileDescriptor();
138             socketCreate(true);
<span class="line-modified">139             SocketCleanable.register(fd, true);</span>
140         }




141     }
142 
143     /**
144      * Creates a socket and connects it to the specified port on
145      * the specified host.
146      * @param host the specified host
147      * @param port the specified port
148      */
149     protected void connect(String host, int port)
150         throws UnknownHostException, IOException
151     {
152         boolean connected = false;
153         try {
154             InetAddress address = InetAddress.getByName(host);
<span class="line-modified">155             // recording this.address as supplied by caller before calling connect</span>
156             this.address = address;
<span class="line-added">157             this.port = port;</span>
<span class="line-added">158             if (address.isLinkLocalAddress()) {</span>
<span class="line-added">159                 address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">160             }</span>
161 
162             connectToAddress(address, port, timeout);
163             connected = true;
164         } finally {
165             if (!connected) {
166                 try {
167                     close();
168                 } catch (IOException ioe) {
169                     /* Do nothing. If connect threw an exception then
170                        it will be passed up the call stack */
171                 }
172             }
<span class="line-added">173             isConnected = connected;</span>
174         }
175     }
176 
177     /**
178      * Creates a socket and connects it to the specified address on
179      * the specified port.
180      * @param address the address
181      * @param port the specified port
182      */
183     protected void connect(InetAddress address, int port) throws IOException {
<span class="line-modified">184         // recording this.address as supplied by caller before calling connect</span>
185         this.address = address;
<span class="line-added">186         this.port = port;</span>
<span class="line-added">187         if (address.isLinkLocalAddress()) {</span>
<span class="line-added">188             address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">189         }</span>
190 
191         try {
192             connectToAddress(address, port, timeout);
<span class="line-added">193             isConnected = true;</span>
194             return;
195         } catch (IOException e) {
196             // everything failed
197             close();
198             throw e;
199         }
200     }
201 
202     /**
203      * Creates a socket and connects it to the specified address on
204      * the specified port.
205      * @param address the address
206      * @param timeout the timeout value in milliseconds, or zero for no timeout.
207      * @throws IOException if connection fails
208      * @throws  IllegalArgumentException if address is null or is a
209      *          SocketAddress subclass not supported by this socket
210      * @since 1.4
211      */
212     protected void connect(SocketAddress address, int timeout)
213             throws IOException {
214         boolean connected = false;
215         try {
216             if (address == null || !(address instanceof InetSocketAddress))
217                 throw new IllegalArgumentException(&quot;unsupported address type&quot;);
218             InetSocketAddress addr = (InetSocketAddress) address;
219             if (addr.isUnresolved())
220                 throw new UnknownHostException(addr.getHostName());
<span class="line-added">221             // recording this.address as supplied by caller before calling connect</span>
<span class="line-added">222             InetAddress ia = addr.getAddress();</span>
<span class="line-added">223             this.address = ia;</span>
224             this.port = addr.getPort();
<span class="line-modified">225             if (ia.isLinkLocalAddress()) {</span>
<span class="line-modified">226                 ia = IPAddressUtil.toScopedAddress(ia);</span>
<span class="line-modified">227             }</span>
<span class="line-added">228             connectToAddress(ia, port, timeout);</span>
229             connected = true;
230         } finally {
231             if (!connected) {
232                 try {
233                     close();
234                 } catch (IOException ioe) {
235                     /* Do nothing. If connect threw an exception then
236                        it will be passed up the call stack */
237                 }
238             }
<span class="line-added">239             isConnected = connected;</span>
240         }
241     }
242 
243     private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {
244         if (address.isAnyLocalAddress()) {
245             doConnect(InetAddress.getLocalHost(), port, timeout);
246         } else {
247             doConnect(address, port, timeout);
248         }
249     }
250 
251     public void setOption(int opt, Object val) throws SocketException {
252         if (isClosedOrPending()) {
253             throw new SocketException(&quot;Socket Closed&quot;);
254         }
255         boolean on = true;
256         switch (opt) {
257             /* check type safety b4 going native.  These should never
258              * fail, since only java.Socket* has access to
259              * PlainSocketImpl.setOption().
</pre>
<hr />
<pre>
369                 }
370             } catch (SocketException se) {
371                     // TODO - should make better effort to read TOS or TCLASS
372                     return trafficClass; // ipv6 tos
373             }
374         case SO_KEEPALIVE:
375             ret = socketGetOption(opt, null);
376             return Boolean.valueOf(ret != -1);
377         case SO_REUSEPORT:
378             if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {
379                 throw new UnsupportedOperationException(&quot;unsupported option&quot;);
380             }
381             ret = socketGetOption(opt, null);
382             return Boolean.valueOf(ret != -1);
383         // should never get here
384         default:
385             return null;
386         }
387     }
388 
<span class="line-added">389     static final ExtendedSocketOptions extendedOptions =</span>
<span class="line-added">390             ExtendedSocketOptions.getInstance();</span>
<span class="line-added">391 </span>
<span class="line-added">392     private static final Set&lt;SocketOption&lt;?&gt;&gt; clientSocketOptions = clientSocketOptions();</span>
<span class="line-added">393     private static final Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions = serverSocketOptions();</span>
<span class="line-added">394 </span>
<span class="line-added">395     private static Set&lt;SocketOption&lt;?&gt;&gt; clientSocketOptions() {</span>
<span class="line-added">396         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();</span>
<span class="line-added">397         options.add(StandardSocketOptions.SO_KEEPALIVE);</span>
<span class="line-added">398         options.add(StandardSocketOptions.SO_SNDBUF);</span>
<span class="line-added">399         options.add(StandardSocketOptions.SO_RCVBUF);</span>
<span class="line-added">400         options.add(StandardSocketOptions.SO_REUSEADDR);</span>
<span class="line-added">401         options.add(StandardSocketOptions.SO_LINGER);</span>
<span class="line-added">402         options.add(StandardSocketOptions.IP_TOS);</span>
<span class="line-added">403         options.add(StandardSocketOptions.TCP_NODELAY);</span>
<span class="line-added">404         if (isReusePortAvailable())</span>
<span class="line-added">405             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-added">406         options.addAll(ExtendedSocketOptions.clientSocketOptions());</span>
<span class="line-added">407         return Collections.unmodifiableSet(options);</span>
<span class="line-added">408     }</span>
<span class="line-added">409 </span>
<span class="line-added">410     private static Set&lt;SocketOption&lt;?&gt;&gt; serverSocketOptions() {</span>
<span class="line-added">411         HashSet&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();</span>
<span class="line-added">412         options.add(StandardSocketOptions.SO_RCVBUF);</span>
<span class="line-added">413         options.add(StandardSocketOptions.SO_REUSEADDR);</span>
<span class="line-added">414         options.add(StandardSocketOptions.IP_TOS);</span>
<span class="line-added">415         if (isReusePortAvailable())</span>
<span class="line-added">416             options.add(StandardSocketOptions.SO_REUSEPORT);</span>
<span class="line-added">417         options.addAll(ExtendedSocketOptions.serverSocketOptions());</span>
<span class="line-added">418         return Collections.unmodifiableSet(options);</span>
<span class="line-added">419     }</span>
<span class="line-added">420 </span>
<span class="line-added">421     @Override</span>
<span class="line-added">422     protected Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {</span>
<span class="line-added">423         if (isServer)</span>
<span class="line-added">424             return serverSocketOptions;</span>
<span class="line-added">425         else</span>
<span class="line-added">426             return clientSocketOptions;</span>
<span class="line-added">427     }</span>
<span class="line-added">428 </span>
<span class="line-added">429     @Override</span>
<span class="line-added">430     protected &lt;T&gt; void setOption(SocketOption&lt;T&gt; name, T value) throws IOException {</span>
<span class="line-added">431         Objects.requireNonNull(name);</span>
<span class="line-added">432         if (!supportedOptions().contains(name))</span>
<span class="line-added">433             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">434 </span>
<span class="line-added">435         if (!name.type().isInstance(value))</span>
<span class="line-added">436             throw new IllegalArgumentException(&quot;Invalid value &#39;&quot; + value + &quot;&#39;&quot;);</span>
<span class="line-added">437 </span>
<span class="line-added">438         if (isClosedOrPending())</span>
<span class="line-added">439             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">440 </span>
<span class="line-added">441         if (name == StandardSocketOptions.SO_KEEPALIVE) {</span>
<span class="line-added">442             setOption(SocketOptions.SO_KEEPALIVE, value);</span>
<span class="line-added">443         } else if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">444             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">445                 throw new IllegalArgumentException(&quot;Invalid send buffer size:&quot; + value);</span>
<span class="line-added">446             setOption(SocketOptions.SO_SNDBUF, value);</span>
<span class="line-added">447         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">448             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">449                 throw new IllegalArgumentException(&quot;Invalid recv buffer size:&quot; + value);</span>
<span class="line-added">450             setOption(SocketOptions.SO_RCVBUF, value);</span>
<span class="line-added">451         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">452             setOption(SocketOptions.SO_REUSEADDR, value);</span>
<span class="line-added">453         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">454             setOption(SocketOptions.SO_REUSEPORT, value);</span>
<span class="line-added">455         } else if (name == StandardSocketOptions.SO_LINGER ) {</span>
<span class="line-added">456             if (((Integer)value).intValue() &lt; 0)</span>
<span class="line-added">457                 setOption(SocketOptions.SO_LINGER, false);</span>
<span class="line-added">458             else</span>
<span class="line-added">459                 setOption(SocketOptions.SO_LINGER, value);</span>
<span class="line-added">460         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">461             int i = ((Integer)value).intValue();</span>
<span class="line-added">462             if (i &lt; 0 || i &gt; 255)</span>
<span class="line-added">463                 throw new IllegalArgumentException(&quot;Invalid IP_TOS value: &quot; + value);</span>
<span class="line-added">464             setOption(SocketOptions.IP_TOS, value);</span>
<span class="line-added">465         } else if (name == StandardSocketOptions.TCP_NODELAY) {</span>
<span class="line-added">466             setOption(SocketOptions.TCP_NODELAY, value);</span>
<span class="line-added">467         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">468             extendedOptions.setOption(fd, name, value);</span>
<span class="line-added">469         } else {</span>
<span class="line-added">470             throw new AssertionError(&quot;unknown option: &quot; + name);</span>
<span class="line-added">471         }</span>
<span class="line-added">472     }</span>
<span class="line-added">473 </span>
<span class="line-added">474     @Override</span>
<span class="line-added">475     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">476     protected &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {</span>
<span class="line-added">477         Objects.requireNonNull(name);</span>
<span class="line-added">478         if (!supportedOptions().contains(name))</span>
<span class="line-added">479             throw new UnsupportedOperationException(&quot;&#39;&quot; + name + &quot;&#39; not supported&quot;);</span>
<span class="line-added">480 </span>
<span class="line-added">481         if (isClosedOrPending())</span>
<span class="line-added">482             throw new SocketException(&quot;Socket closed&quot;);</span>
<span class="line-added">483 </span>
<span class="line-added">484         if (name == StandardSocketOptions.SO_KEEPALIVE) {</span>
<span class="line-added">485             return (T)getOption(SocketOptions.SO_KEEPALIVE);</span>
<span class="line-added">486         } else if (name == StandardSocketOptions.SO_SNDBUF) {</span>
<span class="line-added">487             return (T)getOption(SocketOptions.SO_SNDBUF);</span>
<span class="line-added">488         } else if (name == StandardSocketOptions.SO_RCVBUF) {</span>
<span class="line-added">489             return (T)getOption(SocketOptions.SO_RCVBUF);</span>
<span class="line-added">490         } else if (name == StandardSocketOptions.SO_REUSEADDR) {</span>
<span class="line-added">491             return (T)getOption(SocketOptions.SO_REUSEADDR);</span>
<span class="line-added">492         } else if (name == StandardSocketOptions.SO_REUSEPORT) {</span>
<span class="line-added">493             return (T)getOption(SocketOptions.SO_REUSEPORT);</span>
<span class="line-added">494         } else if (name == StandardSocketOptions.SO_LINGER) {</span>
<span class="line-added">495             Object value = getOption(SocketOptions.SO_LINGER);</span>
<span class="line-added">496             if (value instanceof Boolean) {</span>
<span class="line-added">497                 assert ((Boolean)value).booleanValue() == false;</span>
<span class="line-added">498                 value = -1;</span>
<span class="line-added">499             }</span>
<span class="line-added">500             return (T)value;</span>
<span class="line-added">501         } else if (name == StandardSocketOptions.IP_TOS) {</span>
<span class="line-added">502             return (T)getOption(SocketOptions.IP_TOS);</span>
<span class="line-added">503         } else if (name == StandardSocketOptions.TCP_NODELAY) {</span>
<span class="line-added">504             return (T)getOption(SocketOptions.TCP_NODELAY);</span>
<span class="line-added">505         } else if (extendedOptions.isOptionSupported(name)) {</span>
<span class="line-added">506             return (T) extendedOptions.getOption(fd, name);</span>
<span class="line-added">507         } else {</span>
<span class="line-added">508             throw new AssertionError(&quot;unknown option: &quot; + name);</span>
<span class="line-added">509         }</span>
<span class="line-added">510     }</span>
<span class="line-added">511 </span>
512     /**
513      * The workhorse of the connection operation.  Tries several times to
514      * establish a connection to the given &lt;host, port&gt;.  If unsuccessful,
515      * throws an IOException indicating what went wrong.
516      */
517 
518     synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {
519         synchronized (fdLock) {
<span class="line-modified">520             if (!closePending &amp;&amp; !isBound) {</span>
521                 NetHooks.beforeTcpConnect(fd, address, port);
522             }
523         }
524         try {
525             acquireFD();
526             try {
527                 socketConnect(address, port, timeout);
528                 /* socket may have been closed during poll/select */
529                 synchronized (fdLock) {
530                     if (closePending) {
531                         throw new SocketException (&quot;Socket closed&quot;);
532                     }
533                 }








534             } finally {
535                 releaseFD();
536             }
537         } catch (IOException e) {
538             close();
539             throw SocketExceptions.of(e, new InetSocketAddress(address, port));
540         }
541     }
542 
543     /**
544      * Binds the socket to the specified address of the specified local port.
545      * @param address the address
546      * @param lport the port
547      */
548     protected synchronized void bind(InetAddress address, int lport)
549         throws IOException
550     {
551        synchronized (fdLock) {
<span class="line-modified">552             if (!closePending &amp;&amp; !isBound) {</span>
553                 NetHooks.beforeTcpBind(fd, address, lport);
554             }
555         }
<span class="line-added">556         if (address.isLinkLocalAddress()) {</span>
<span class="line-added">557             address = IPAddressUtil.toScopedAddress(address);</span>
<span class="line-added">558         }</span>
559         socketBind(address, lport);
<span class="line-modified">560         isBound = true;</span>



561     }
562 
563     /**
564      * Listens, for a specified amount of time, for connections.
565      * @param count the amount of time to listen for connections
566      */
567     protected synchronized void listen(int count) throws IOException {
568         socketListen(count);
569     }
570 
571     /**
572      * Accepts connections.
<span class="line-modified">573      * @param si the socket impl</span>
574      */
<span class="line-modified">575     protected void accept(SocketImpl si) throws IOException {</span>
<span class="line-added">576         si.fd = new FileDescriptor();</span>
577         acquireFD();
578         try {
<span class="line-modified">579             socketAccept(si);</span>
580         } finally {
581             releaseFD();
582         }
<span class="line-added">583         SocketCleanable.register(si.fd, true);</span>
584     }
585 
586     /**
587      * Gets an InputStream for this socket.
588      */
589     protected synchronized InputStream getInputStream() throws IOException {
590         synchronized (fdLock) {
591             if (isClosedOrPending())
592                 throw new IOException(&quot;Socket Closed&quot;);
593             if (shut_rd)
594                 throw new IOException(&quot;Socket input is shutdown&quot;);
<span class="line-modified">595             if (socketInputStream == null) {</span>
<span class="line-modified">596                 PrivilegedExceptionAction&lt;SocketInputStream&gt; pa = () -&gt; new SocketInputStream(this);</span>
<span class="line-added">597                 try {</span>
<span class="line-added">598                     socketInputStream = AccessController.doPrivileged(pa);</span>
<span class="line-added">599                 } catch (PrivilegedActionException e) {</span>
<span class="line-added">600                     throw (IOException) e.getCause();</span>
<span class="line-added">601                 }</span>
<span class="line-added">602             }</span>
603         }
604         return socketInputStream;
605     }
606 
607     void setInputStream(SocketInputStream in) {
608         socketInputStream = in;
609     }
610 
611     /**
612      * Gets an OutputStream for this socket.
613      */
614     protected synchronized OutputStream getOutputStream() throws IOException {
615         synchronized (fdLock) {
616             if (isClosedOrPending())
617                 throw new IOException(&quot;Socket Closed&quot;);
618             if (shut_wr)
619                 throw new IOException(&quot;Socket output is shutdown&quot;);
<span class="line-modified">620             if (socketOutputStream == null) {</span>
<span class="line-modified">621                 PrivilegedExceptionAction&lt;SocketOutputStream&gt; pa = () -&gt; new SocketOutputStream(this);</span>
<span class="line-added">622                 try {</span>
<span class="line-added">623                     socketOutputStream = AccessController.doPrivileged(pa);</span>
<span class="line-added">624                 } catch (PrivilegedActionException e) {</span>
<span class="line-added">625                     throw (IOException) e.getCause();</span>
<span class="line-added">626                 }</span>
<span class="line-added">627             }</span>
628         }
629         return socketOutputStream;
630     }
631 
632     void setFileDescriptor(FileDescriptor fd) {
633         this.fd = fd;
634     }
635 
636     void setAddress(InetAddress address) {
637         this.address = address;
638     }
639 
640     void setPort(int port) {
641         this.port = port;
642     }
643 
644     void setLocalPort(int localport) {
645         this.localport = localport;
646     }
647 
</pre>
<hr />
<pre>
666          * of a connection reset then we move to the reset state.
667          *
668          * If are notified of a connection reset then check
669          * again if there are bytes buffered on the socket.
670          */
671         int n = 0;
672         try {
673             n = socketAvailable();
674         } catch (ConnectionResetException exc1) {
675             setConnectionReset();
676         }
677         return n;
678     }
679 
680     /**
681      * Closes the socket.
682      */
683     protected void close() throws IOException {
684         synchronized(fdLock) {
685             if (fd != null) {



686                 if (fdUseCount == 0) {
687                     if (closePending) {
688                         return;
689                     }
690                     closePending = true;
691                     /*
692                      * We close the FileDescriptor in two-steps - first the
693                      * &quot;pre-close&quot; which closes the socket but doesn&#39;t
694                      * release the underlying file descriptor. This operation
695                      * may be lengthy due to untransmitted data and a long
696                      * linger interval. Once the pre-close is done we do the
697                      * actual socket to release the fd.
698                      */
699                     try {
700                         socketPreClose();
701                     } finally {
702                         socketClose();
703                     }
704                     fd = null;
705                     return;
706                 } else {
707                     /*
708                      * If a thread has acquired the fd and a close
709                      * isn&#39;t pending then use a deferred close.
710                      * Also decrement fdUseCount to signal the last
711                      * thread that releases the fd to close it.
712                      */
713                     if (!closePending) {
714                         closePending = true;
715                         fdUseCount--;
716                         socketPreClose();
717                     }
718                 }
719             }
720         }
721     }
722 
<span class="line-modified">723     void reset() {</span>
<span class="line-modified">724         throw new InternalError(&quot;should not get here&quot;);</span>




725     }
726 

727     /**
728      * Shutdown read-half of the socket connection;
729      */
730     protected void shutdownInput() throws IOException {
731       if (fd != null) {
732           socketShutdown(SHUT_RD);
733           if (socketInputStream != null) {
734               socketInputStream.setEOF(true);
735           }
736           shut_rd = true;
737       }
738     }
739 
740     /**
741      * Shutdown write-half of the socket connection;
742      */
743     protected void shutdownOutput() throws IOException {
744       if (fd != null) {
745           socketShutdown(SHUT_WR);
746           shut_wr = true;
</pre>
<hr />
<pre>
820     /*
821      * Return the current value of SO_TIMEOUT
822      */
823     public int getTimeout() {
824         return timeout;
825     }
826 
827     /*
828      * &quot;Pre-close&quot; a socket by dup&#39;ing the file descriptor - this enables
829      * the socket to be closed without releasing the file descriptor.
830      */
831     private void socketPreClose() throws IOException {
832         socketClose0(true);
833     }
834 
835     /*
836      * Close the socket (and release the file descriptor).
837      */
838     protected void socketClose() throws IOException {
839         SocketCleanable.unregister(fd);
<span class="line-modified">840         try {</span>
<span class="line-added">841             socketClose0(false);</span>
<span class="line-added">842         } finally {</span>
<span class="line-added">843             if (!stream) {</span>
<span class="line-added">844                 ResourceManager.afterUdpClose();</span>
<span class="line-added">845             }</span>
<span class="line-added">846         }</span>
847     }
848 
<span class="line-modified">849     abstract void socketCreate(boolean stream) throws IOException;</span>
850     abstract void socketConnect(InetAddress address, int port, int timeout)
851         throws IOException;
852     abstract void socketBind(InetAddress address, int port)
853         throws IOException;
854     abstract void socketListen(int count)
855         throws IOException;
856     abstract void socketAccept(SocketImpl s)
857         throws IOException;
858     abstract int socketAvailable()
859         throws IOException;
860     abstract void socketClose0(boolean useDeferredClose)
861         throws IOException;
862     abstract void socketShutdown(int howto)
863         throws IOException;
864     abstract void socketSetOption(int cmd, boolean on, Object value)
865         throws SocketException;
866     abstract int socketGetOption(int opt, Object iaContainerObj) throws SocketException;
867     abstract void socketSendUrgentData(int data)
868         throws IOException;
869 
</pre>
</td>
</tr>
</table>
<center><a href="AbstractPlainDatagramSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BindException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/concurrent/ConcurrentSkipListSet.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  * This file is available under and governed by the GNU General Public
 27  * License version 2 only, as published by the Free Software Foundation.
 28  * However, the following notice accompanied the original version of this
 29  * file:
 30  *
 31  * Written by Doug Lea with assistance from members of JCP JSR-166
 32  * Expert Group and released to the public domain, as explained at
 33  * http://creativecommons.org/publicdomain/zero/1.0/
 34  */
 35 
 36 package java.util.concurrent;
 37 
 38 import java.lang.reflect.Field;
 39 import java.util.AbstractSet;
 40 import java.util.Collection;
 41 import java.util.Collections;
 42 import java.util.Comparator;
 43 import java.util.Iterator;
 44 import java.util.Map;
 45 import java.util.NavigableSet;
 46 import java.util.Set;
 47 import java.util.SortedSet;
 48 import java.util.Spliterator;
 49 
 50 /**
 51  * A scalable concurrent {@link NavigableSet} implementation based on
 52  * a {@link ConcurrentSkipListMap}.  The elements of the set are kept
 53  * sorted according to their {@linkplain Comparable natural ordering},
 54  * or by a {@link Comparator} provided at set creation time, depending
 55  * on which constructor is used.
 56  *
 57  * &lt;p&gt;This implementation provides expected average &lt;i&gt;log(n)&lt;/i&gt; time
 58  * cost for the {@code contains}, {@code add}, and {@code remove}
 59  * operations and their variants.  Insertion, removal, and access
 60  * operations safely execute concurrently by multiple threads.
 61  *
 62  * &lt;p&gt;Iterators and spliterators are
 63  * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
 64  *
 65  * &lt;p&gt;Ascending ordered views and their iterators are faster than
 66  * descending ones.
 67  *
 68  * &lt;p&gt;Beware that, unlike in most collections, the {@code size}
 69  * method is &lt;em&gt;not&lt;/em&gt; a constant-time operation. Because of the
 70  * asynchronous nature of these sets, determining the current number
 71  * of elements requires a traversal of the elements, and so may report
 72  * inaccurate results if this collection is modified during traversal.
 73  *
 74  * &lt;p&gt;Bulk operations that add, remove, or examine multiple elements,
 75  * such as {@link #addAll}, {@link #removeIf} or {@link #forEach},
 76  * are &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically.
 77  * For example, a {@code forEach} traversal concurrent with an {@code
 78  * addAll} operation might observe only some of the added elements.
 79  *
 80  * &lt;p&gt;This class and its iterators implement all of the
 81  * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Set} and {@link Iterator}
 82  * interfaces. Like most other concurrent collection implementations,
 83  * this class does not permit the use of {@code null} elements,
 84  * because {@code null} arguments and return values cannot be reliably
 85  * distinguished from the absence of elements.
 86  *
 87  * &lt;p&gt;This class is a member of the
 88  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 89  * Java Collections Framework&lt;/a&gt;.
 90  *
 91  * @author Doug Lea
 92  * @param &lt;E&gt; the type of elements maintained by this set
 93  * @since 1.6
 94  */
 95 public class ConcurrentSkipListSet&lt;E&gt;
 96     extends AbstractSet&lt;E&gt;
 97     implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable {
 98 
 99     private static final long serialVersionUID = -2479143111061671589L;
100 
101     /**
102      * The underlying map. Uses Boolean.TRUE as value for each
103      * element.  This field is declared final for the sake of thread
104      * safety, which entails some ugliness in clone().
105      */
<a name="1" id="anc1"></a><span class="line-added">106     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable</span>
107     private final ConcurrentNavigableMap&lt;E,Object&gt; m;
108 
109     /**
110      * Constructs a new, empty set that orders its elements according to
111      * their {@linkplain Comparable natural ordering}.
112      */
113     public ConcurrentSkipListSet() {
114         m = new ConcurrentSkipListMap&lt;E,Object&gt;();
115     }
116 
117     /**
118      * Constructs a new, empty set that orders its elements according to
119      * the specified comparator.
120      *
121      * @param comparator the comparator that will be used to order this set.
122      *        If {@code null}, the {@linkplain Comparable natural
123      *        ordering} of the elements will be used.
124      */
125     public ConcurrentSkipListSet(Comparator&lt;? super E&gt; comparator) {
126         m = new ConcurrentSkipListMap&lt;E,Object&gt;(comparator);
127     }
128 
129     /**
130      * Constructs a new set containing the elements in the specified
131      * collection, that orders its elements according to their
132      * {@linkplain Comparable natural ordering}.
133      *
134      * @param c The elements that will comprise the new set
135      * @throws ClassCastException if the elements in {@code c} are
136      *         not {@link Comparable}, or are not mutually comparable
137      * @throws NullPointerException if the specified collection or any
138      *         of its elements are null
139      */
140     public ConcurrentSkipListSet(Collection&lt;? extends E&gt; c) {
141         m = new ConcurrentSkipListMap&lt;E,Object&gt;();
142         addAll(c);
143     }
144 
145     /**
146      * Constructs a new set containing the same elements and using the
147      * same ordering as the specified sorted set.
148      *
149      * @param s sorted set whose elements will comprise the new set
150      * @throws NullPointerException if the specified sorted set or any
151      *         of its elements are null
152      */
153     public ConcurrentSkipListSet(SortedSet&lt;E&gt; s) {
154         m = new ConcurrentSkipListMap&lt;E,Object&gt;(s.comparator());
155         addAll(s);
156     }
157 
158     /**
159      * For use by submaps
160      */
161     ConcurrentSkipListSet(ConcurrentNavigableMap&lt;E,Object&gt; m) {
162         this.m = m;
163     }
164 
165     /**
166      * Returns a shallow copy of this {@code ConcurrentSkipListSet}
167      * instance. (The elements themselves are not cloned.)
168      *
169      * @return a shallow copy of this set
170      */
171     public ConcurrentSkipListSet&lt;E&gt; clone() {
172         try {
173             @SuppressWarnings(&quot;unchecked&quot;)
174             ConcurrentSkipListSet&lt;E&gt; clone =
175                 (ConcurrentSkipListSet&lt;E&gt;) super.clone();
176             clone.setMap(new ConcurrentSkipListMap&lt;E,Object&gt;(m));
177             return clone;
178         } catch (CloneNotSupportedException e) {
179             throw new InternalError();
180         }
181     }
182 
183     /* ---------------- Set operations -------------- */
184 
185     /**
186      * Returns the number of elements in this set.  If this set
187      * contains more than {@code Integer.MAX_VALUE} elements, it
188      * returns {@code Integer.MAX_VALUE}.
189      *
190      * &lt;p&gt;Beware that, unlike in most collections, this method is
191      * &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
192      * asynchronous nature of these sets, determining the current
193      * number of elements requires traversing them all to count them.
194      * Additionally, it is possible for the size to change during
195      * execution of this method, in which case the returned result
196      * will be inaccurate. Thus, this method is typically not very
197      * useful in concurrent applications.
198      *
199      * @return the number of elements in this set
200      */
201     public int size() {
202         return m.size();
203     }
204 
205     /**
206      * Returns {@code true} if this set contains no elements.
207      * @return {@code true} if this set contains no elements
208      */
209     public boolean isEmpty() {
210         return m.isEmpty();
211     }
212 
213     /**
214      * Returns {@code true} if this set contains the specified element.
215      * More formally, returns {@code true} if and only if this set
216      * contains an element {@code e} such that {@code o.equals(e)}.
217      *
218      * @param o object to be checked for containment in this set
219      * @return {@code true} if this set contains the specified element
220      * @throws ClassCastException if the specified element cannot be
221      *         compared with the elements currently in this set
222      * @throws NullPointerException if the specified element is null
223      */
224     public boolean contains(Object o) {
225         return m.containsKey(o);
226     }
227 
228     /**
229      * Adds the specified element to this set if it is not already present.
230      * More formally, adds the specified element {@code e} to this set if
231      * the set contains no element {@code e2} such that {@code e.equals(e2)}.
232      * If this set already contains the element, the call leaves the set
233      * unchanged and returns {@code false}.
234      *
235      * @param e element to be added to this set
236      * @return {@code true} if this set did not already contain the
237      *         specified element
238      * @throws ClassCastException if {@code e} cannot be compared
239      *         with the elements currently in this set
240      * @throws NullPointerException if the specified element is null
241      */
242     public boolean add(E e) {
243         return m.putIfAbsent(e, Boolean.TRUE) == null;
244     }
245 
246     /**
247      * Removes the specified element from this set if it is present.
248      * More formally, removes an element {@code e} such that
249      * {@code o.equals(e)}, if this set contains such an element.
250      * Returns {@code true} if this set contained the element (or
251      * equivalently, if this set changed as a result of the call).
252      * (This set will not contain the element once the call returns.)
253      *
254      * @param o object to be removed from this set, if present
255      * @return {@code true} if this set contained the specified element
256      * @throws ClassCastException if {@code o} cannot be compared
257      *         with the elements currently in this set
258      * @throws NullPointerException if the specified element is null
259      */
260     public boolean remove(Object o) {
261         return m.remove(o, Boolean.TRUE);
262     }
263 
264     /**
265      * Removes all of the elements from this set.
266      */
267     public void clear() {
268         m.clear();
269     }
270 
271     /**
272      * Returns an iterator over the elements in this set in ascending order.
273      *
274      * @return an iterator over the elements in this set in ascending order
275      */
276     public Iterator&lt;E&gt; iterator() {
277         return m.navigableKeySet().iterator();
278     }
279 
280     /**
281      * Returns an iterator over the elements in this set in descending order.
282      *
283      * @return an iterator over the elements in this set in descending order
284      */
285     public Iterator&lt;E&gt; descendingIterator() {
286         return m.descendingKeySet().iterator();
287     }
288 
289 
290     /* ---------------- AbstractSet Overrides -------------- */
291 
292     /**
293      * Compares the specified object with this set for equality.  Returns
294      * {@code true} if the specified object is also a set, the two sets
295      * have the same size, and every member of the specified set is
296      * contained in this set (or equivalently, every member of this set is
297      * contained in the specified set).  This definition ensures that the
298      * equals method works properly across different implementations of the
299      * set interface.
300      *
301      * @param o the object to be compared for equality with this set
302      * @return {@code true} if the specified object is equal to this set
303      */
304     public boolean equals(Object o) {
305         // Override AbstractSet version to avoid calling size()
306         if (o == this)
307             return true;
308         if (!(o instanceof Set))
309             return false;
310         Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
311         try {
312             return containsAll(c) &amp;&amp; c.containsAll(this);
313         } catch (ClassCastException | NullPointerException unused) {
314             return false;
315         }
316     }
317 
318     /**
319      * Removes from this set all of its elements that are contained in
320      * the specified collection.  If the specified collection is also
321      * a set, this operation effectively modifies this set so that its
322      * value is the &lt;i&gt;asymmetric set difference&lt;/i&gt; of the two sets.
323      *
324      * @param  c collection containing elements to be removed from this set
325      * @return {@code true} if this set changed as a result of the call
326      * @throws ClassCastException if the class of an element of this set
327      *         is incompatible with the specified collection
328      * (&lt;a href=&quot;{@docRoot}/java.base/java/util/Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
329      * @throws NullPointerException if the specified collection or any
330      *         of its elements are null
331      */
332     public boolean removeAll(Collection&lt;?&gt; c) {
333         // Override AbstractSet version to avoid unnecessary call to size()
334         boolean modified = false;
335         for (Object e : c)
336             if (remove(e))
337                 modified = true;
338         return modified;
339     }
340 
341     /* ---------------- Relational operations -------------- */
342 
343     /**
344      * @throws ClassCastException {@inheritDoc}
345      * @throws NullPointerException if the specified element is null
346      */
347     public E lower(E e) {
348         return m.lowerKey(e);
349     }
350 
351     /**
352      * @throws ClassCastException {@inheritDoc}
353      * @throws NullPointerException if the specified element is null
354      */
355     public E floor(E e) {
356         return m.floorKey(e);
357     }
358 
359     /**
360      * @throws ClassCastException {@inheritDoc}
361      * @throws NullPointerException if the specified element is null
362      */
363     public E ceiling(E e) {
364         return m.ceilingKey(e);
365     }
366 
367     /**
368      * @throws ClassCastException {@inheritDoc}
369      * @throws NullPointerException if the specified element is null
370      */
371     public E higher(E e) {
372         return m.higherKey(e);
373     }
374 
375     public E pollFirst() {
376         Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry();
377         return (e == null) ? null : e.getKey();
378     }
379 
380     public E pollLast() {
381         Map.Entry&lt;E,Object&gt; e = m.pollLastEntry();
382         return (e == null) ? null : e.getKey();
383     }
384 
385 
386     /* ---------------- SortedSet operations -------------- */
387 
388     public Comparator&lt;? super E&gt; comparator() {
389         return m.comparator();
390     }
391 
392     /**
393      * @throws java.util.NoSuchElementException {@inheritDoc}
394      */
395     public E first() {
396         return m.firstKey();
397     }
398 
399     /**
400      * @throws java.util.NoSuchElementException {@inheritDoc}
401      */
402     public E last() {
403         return m.lastKey();
404     }
405 
406     /**
407      * @throws ClassCastException {@inheritDoc}
408      * @throws NullPointerException if {@code fromElement} or
409      *         {@code toElement} is null
410      * @throws IllegalArgumentException {@inheritDoc}
411      */
412     public NavigableSet&lt;E&gt; subSet(E fromElement,
413                                   boolean fromInclusive,
414                                   E toElement,
415                                   boolean toInclusive) {
416         return new ConcurrentSkipListSet&lt;E&gt;
417             (m.subMap(fromElement, fromInclusive,
418                       toElement,   toInclusive));
419     }
420 
421     /**
422      * @throws ClassCastException {@inheritDoc}
423      * @throws NullPointerException if {@code toElement} is null
424      * @throws IllegalArgumentException {@inheritDoc}
425      */
426     public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
427         return new ConcurrentSkipListSet&lt;E&gt;(m.headMap(toElement, inclusive));
428     }
429 
430     /**
431      * @throws ClassCastException {@inheritDoc}
432      * @throws NullPointerException if {@code fromElement} is null
433      * @throws IllegalArgumentException {@inheritDoc}
434      */
435     public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
436         return new ConcurrentSkipListSet&lt;E&gt;(m.tailMap(fromElement, inclusive));
437     }
438 
439     /**
440      * @throws ClassCastException {@inheritDoc}
441      * @throws NullPointerException if {@code fromElement} or
442      *         {@code toElement} is null
443      * @throws IllegalArgumentException {@inheritDoc}
444      */
445     public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) {
446         return subSet(fromElement, true, toElement, false);
447     }
448 
449     /**
450      * @throws ClassCastException {@inheritDoc}
451      * @throws NullPointerException if {@code toElement} is null
452      * @throws IllegalArgumentException {@inheritDoc}
453      */
454     public NavigableSet&lt;E&gt; headSet(E toElement) {
455         return headSet(toElement, false);
456     }
457 
458     /**
459      * @throws ClassCastException {@inheritDoc}
460      * @throws NullPointerException if {@code fromElement} is null
461      * @throws IllegalArgumentException {@inheritDoc}
462      */
463     public NavigableSet&lt;E&gt; tailSet(E fromElement) {
464         return tailSet(fromElement, true);
465     }
466 
467     /**
468      * Returns a reverse order view of the elements contained in this set.
469      * The descending set is backed by this set, so changes to the set are
470      * reflected in the descending set, and vice-versa.
471      *
472      * &lt;p&gt;The returned set has an ordering equivalent to
473      * {@link Collections#reverseOrder(Comparator) Collections.reverseOrder}{@code (comparator())}.
474      * The expression {@code s.descendingSet().descendingSet()} returns a
475      * view of {@code s} essentially equivalent to {@code s}.
476      *
477      * @return a reverse order view of this set
478      */
479     public NavigableSet&lt;E&gt; descendingSet() {
480         return new ConcurrentSkipListSet&lt;E&gt;(m.descendingMap());
481     }
482 
483     /**
484      * Returns a {@link Spliterator} over the elements in this set.
485      *
486      * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#CONCURRENT},
487      * {@link Spliterator#NONNULL}, {@link Spliterator#DISTINCT},
488      * {@link Spliterator#SORTED} and {@link Spliterator#ORDERED}, with an
489      * encounter order that is ascending order.  Overriding implementations
490      * should document the reporting of additional characteristic values.
491      *
492      * &lt;p&gt;The {@linkplain Spliterator#getComparator() spliterator&#39;s comparator}
493      * is {@code null} if the {@linkplain #comparator() set&#39;s comparator}
494      * is {@code null}.
495      * Otherwise, the spliterator&#39;s comparator is the same as or imposes the
496      * same total ordering as the set&#39;s comparator.
497      *
498      * @return a {@code Spliterator} over the elements in this set
499      * @since 1.8
500      */
501     public Spliterator&lt;E&gt; spliterator() {
502         return (m instanceof ConcurrentSkipListMap)
503             ? ((ConcurrentSkipListMap&lt;E,?&gt;)m).keySpliterator()
504             : ((ConcurrentSkipListMap.SubMap&lt;E,?&gt;)m).new SubMapKeyIterator();
505     }
506 
507     /** Initializes map field; for use in clone. */
508     private void setMap(ConcurrentNavigableMap&lt;E,Object&gt; map) {
509         Field mapField = java.security.AccessController.doPrivileged(
510             (java.security.PrivilegedAction&lt;Field&gt;) () -&gt; {
511                 try {
512                     Field f = ConcurrentSkipListSet.class
513                         .getDeclaredField(&quot;m&quot;);
514                     f.setAccessible(true);
515                     return f;
516                 } catch (ReflectiveOperationException e) {
517                     throw new Error(e);
518                 }});
519         try {
520             mapField.set(this, map);
521         } catch (IllegalAccessException e) {
522             throw new Error(e);
523         }
524     }
525 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
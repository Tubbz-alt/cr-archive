<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/time/chrono/JapaneseEra.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * This file is available under and governed by the GNU General Public
 28  * License version 2 only, as published by the Free Software Foundation.
 29  * However, the following notice accompanied the original version of this
 30  * file:
 31  *
 32  * Copyright (c) 2012, Stephen Colebourne &amp; Michael Nascimento Santos
 33  *
 34  * All rights reserved.
 35  *
 36  * Redistribution and use in source and binary forms, with or without
 37  * modification, are permitted provided that the following conditions are met:
 38  *
 39  *  * Redistributions of source code must retain the above copyright notice,
 40  *    this list of conditions and the following disclaimer.
 41  *
 42  *  * Redistributions in binary form must reproduce the above copyright notice,
 43  *    this list of conditions and the following disclaimer in the documentation
 44  *    and/or other materials provided with the distribution.
 45  *
 46  *  * Neither the name of JSR-310 nor the names of its contributors
 47  *    may be used to endorse or promote products derived from this software
 48  *    without specific prior written permission.
 49  *
 50  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 51  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 52  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 53  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 54  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 55  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 56  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 57  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 58  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 59  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 60  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 61  */
 62 package java.time.chrono;
 63 
 64 import static java.time.chrono.JapaneseDate.MEIJI_6_ISODATE;
 65 import static java.time.temporal.ChronoField.ERA;
 66 
 67 import java.io.DataInput;
 68 import java.io.DataOutput;
 69 import java.io.IOException;
 70 import java.io.InvalidObjectException;
 71 import java.io.ObjectInputStream;
 72 import java.io.ObjectStreamException;
 73 import java.io.Serializable;
 74 import java.time.DateTimeException;
 75 import java.time.LocalDate;
 76 import java.time.format.DateTimeFormatterBuilder;
 77 import java.time.format.TextStyle;
 78 import java.time.temporal.ChronoField;
 79 import java.time.temporal.TemporalField;
 80 import java.time.temporal.UnsupportedTemporalTypeException;
 81 import java.time.temporal.ValueRange;
 82 import java.util.Arrays;
 83 import java.util.Locale;
 84 import java.util.Objects;
 85 
 86 import sun.util.calendar.CalendarDate;
 87 
 88 /**
 89  * An era in the Japanese Imperial calendar system.
 90  * &lt;p&gt;
 91  * The Japanese government defines the official name and start date of
 92  * each era. Eras are consecutive and their date ranges do not overlap,
 93  * so the end date of one era is always the day before the start date
 94  * of the next era.
 95  * &lt;p&gt;
 96  * The Java SE Platform supports all eras defined by the Japanese government,
 97  * beginning with the Meiji era. Each era is identified in the Platform by an
 98  * integer value and a name. The {@link #of(int)} and {@link #valueOf(String)}
 99  * methods may be used to obtain a singleton instance of {@code JapaneseEra}
100  * for each era. The {@link #values()} method returns the singleton instances
101  * of all supported eras.
102  * &lt;p&gt;
103  * For convenience, this class declares a number of public static final fields
104  * that refer to singleton instances returned by the {@link #values()} method.
105  *
106  * @apiNote
107  * The fields declared in this class may evolve over time, in line with the
108  * results of the {@link #values()} method. However, there is not necessarily
109  * a 1:1 correspondence between the fields and the singleton instances.
110  *
111  * @apiNote
112  * The Japanese government may announce a new era and define its start
113  * date but not its official name. In this scenario, the singleton instance
114  * that represents the new era may return a name that is not stable until
115  * the official name is defined. Developers should exercise caution when
116  * relying on the name returned by any singleton instance that does not
117  * correspond to a public static final field.
118  *
119  * @implSpec
120  * This class is immutable and thread-safe.
121  *
122  * @since 1.8
123  */
124 public final class JapaneseEra
125         implements Era, Serializable {
126 
127     // The offset value to 0-based index from the era value.
128     // i.e., getValue() + ERA_OFFSET == 0-based index
129     static final int ERA_OFFSET = 2;
130 
131     static final sun.util.calendar.Era[] ERA_CONFIG;
132 
133     /**
134      * The singleton instance for the &#39;Meiji&#39; era (1868-01-01 - 1912-07-29)
135      * which has the value -1.
136      */
137     public static final JapaneseEra MEIJI = new JapaneseEra(-1, LocalDate.of(1868, 1, 1));
138     /**
139      * The singleton instance for the &#39;Taisho&#39; era (1912-07-30 - 1926-12-24)
140      * which has the value 0.
141      */
142     public static final JapaneseEra TAISHO = new JapaneseEra(0, LocalDate.of(1912, 7, 30));
143     /**
144      * The singleton instance for the &#39;Showa&#39; era (1926-12-25 - 1989-01-07)
145      * which has the value 1.
146      */
147     public static final JapaneseEra SHOWA = new JapaneseEra(1, LocalDate.of(1926, 12, 25));
148     /**
149      * The singleton instance for the &#39;Heisei&#39; era (1989-01-08 - 2019-04-30)
150      * which has the value 2.
151      */
152     public static final JapaneseEra HEISEI = new JapaneseEra(2, LocalDate.of(1989, 1, 8));
153     /**
<a name="1" id="anc1"></a><span class="line-modified">154      * The singleton instance for the &#39;Reiwa&#39; era (2019-05-01 - )</span>
<span class="line-modified">155      * which has the value 3. The end date of this era is not specified, unless</span>
<span class="line-added">156      * the Japanese Government defines it.</span>
<span class="line-added">157      *</span>
<span class="line-added">158      * @since 13</span>
159      */
<a name="2" id="anc2"></a><span class="line-modified">160     public static final JapaneseEra REIWA = new JapaneseEra(3, LocalDate.of(2019, 5, 1));</span>
161 
162     // The number of predefined JapaneseEra constants.
163     // There may be a supplemental era defined by the property.
<a name="3" id="anc3"></a><span class="line-modified">164     private static final int N_ERA_CONSTANTS = REIWA.getValue() + ERA_OFFSET;</span>
165 
166     /**
167      * Serialization version.
168      */
<a name="4" id="anc4"></a><span class="line-added">169     @java.io.Serial</span>
170     private static final long serialVersionUID = 1466499369062886794L;
171 
172     // array for the singleton JapaneseEra instances
173     private static final JapaneseEra[] KNOWN_ERAS;
174 
175     static {
176         ERA_CONFIG = JapaneseChronology.JCAL.getEras();
177 
178         KNOWN_ERAS = new JapaneseEra[ERA_CONFIG.length];
179         KNOWN_ERAS[0] = MEIJI;
180         KNOWN_ERAS[1] = TAISHO;
181         KNOWN_ERAS[2] = SHOWA;
182         KNOWN_ERAS[3] = HEISEI;
<a name="5" id="anc5"></a><span class="line-modified">183         KNOWN_ERAS[4] = REIWA;</span>
184         for (int i = N_ERA_CONSTANTS; i &lt; ERA_CONFIG.length; i++) {
185             CalendarDate date = ERA_CONFIG[i].getSinceDate();
186             LocalDate isoDate = LocalDate.of(date.getYear(), date.getMonth(), date.getDayOfMonth());
187             KNOWN_ERAS[i] = new JapaneseEra(i - ERA_OFFSET + 1, isoDate);
188         }
189     };
190 
191     /**
192      * The era value.
193      * @serial
194      */
195     private final transient int eraValue;
196 
197     // the first day of the era
198     private final transient LocalDate since;
199 
200     /**
201      * Creates an instance.
202      *
203      * @param eraValue  the era value, validated
204      * @param since  the date representing the first date of the era, validated not null
205      */
206     private JapaneseEra(int eraValue, LocalDate since) {
207         this.eraValue = eraValue;
208         this.since = since;
209     }
210 
211     //-----------------------------------------------------------------------
212     /**
213      * Returns the Sun private Era instance corresponding to this {@code JapaneseEra}.
214      *
215      * @return the Sun private Era instance for this {@code JapaneseEra}.
216      */
217     sun.util.calendar.Era getPrivateEra() {
218         return ERA_CONFIG[ordinal(eraValue)];
219     }
220 
221     //-----------------------------------------------------------------------
222     /**
223      * Obtains an instance of {@code JapaneseEra} from an {@code int} value.
224      * &lt;ul&gt;
225      * &lt;li&gt;The value {@code 1} is associated with the &#39;Showa&#39; era, because
226      * it contains 1970-01-01 (ISO calendar system).&lt;/li&gt;
227      * &lt;li&gt;The values {@code -1} and {@code 0} are associated with two earlier
228      * eras, Meiji and Taisho, respectively.&lt;/li&gt;
229      * &lt;li&gt;A value greater than {@code 1} is associated with a later era,
230      * beginning with Heisei ({@code 2}).&lt;/li&gt;
231      * &lt;/ul&gt;
232      * &lt;p&gt;
233      * Every instance of {@code JapaneseEra} that is returned from the {@link #values()}
234      * method has an int value (available via {@link Era#getValue()} which is
235      * accepted by this method.
236      *
237      * @param japaneseEra  the era to represent
238      * @return the {@code JapaneseEra} singleton, not null
239      * @throws DateTimeException if the value is invalid
240      */
241     public static JapaneseEra of(int japaneseEra) {
242         int i = ordinal(japaneseEra);
243         if (i &lt; 0 || i &gt;= KNOWN_ERAS.length) {
244             throw new DateTimeException(&quot;Invalid era: &quot; + japaneseEra);
245         }
246         return KNOWN_ERAS[i];
247     }
248 
249     /**
250      * Returns the {@code JapaneseEra} with the name.
251      * &lt;p&gt;
252      * The string must match exactly the name of the era.
253      * (Extraneous whitespace characters are not permitted.)
254      * &lt;p&gt;
255      * Valid era names are the names of eras returned from {@link #values()}.
256      *
257      * @param japaneseEra  the japaneseEra name; non-null
258      * @return the {@code JapaneseEra} singleton, never null
259      * @throws IllegalArgumentException if there is not JapaneseEra with the specified name
260      */
261     public static JapaneseEra valueOf(String japaneseEra) {
262         Objects.requireNonNull(japaneseEra, &quot;japaneseEra&quot;);
263         for (JapaneseEra era : KNOWN_ERAS) {
264             if (era.getName().equals(japaneseEra)) {
265                 return era;
266             }
267         }
268         throw new IllegalArgumentException(&quot;japaneseEra is invalid&quot;);
269     }
270 
271     /**
272      * Returns an array of JapaneseEras. The array may contain eras defined
273      * by the Japanese government beyond the known era singletons.
274      *
275      * &lt;p&gt;
276      * This method may be used to iterate over the JapaneseEras as follows:
277      * &lt;pre&gt;
278      * for (JapaneseEra c : JapaneseEra.values())
279      *     System.out.println(c);
280      * &lt;/pre&gt;
281      *
282      * @return an array of JapaneseEras
283      */
284     public static JapaneseEra[] values() {
285         return Arrays.copyOf(KNOWN_ERAS, KNOWN_ERAS.length);
286     }
287 
288     /**
289      * {@inheritDoc}
290      *
291      * @param style {@inheritDoc}
292      * @param locale {@inheritDoc}
293      */
294     @Override
295     public String getDisplayName(TextStyle style, Locale locale) {
296         // If this JapaneseEra is a supplemental one, obtain the name from
297         // the era definition.
298         if (getValue() &gt; N_ERA_CONSTANTS - ERA_OFFSET) {
299             Objects.requireNonNull(locale, &quot;locale&quot;);
300             return style.asNormal() == TextStyle.NARROW ? getAbbreviation() : getName();
301         }
302 
303         return new DateTimeFormatterBuilder()
304             .appendText(ERA, style)
305             .toFormatter(locale)
306             .withChronology(JapaneseChronology.INSTANCE)
307             .format(this == MEIJI ? MEIJI_6_ISODATE : since);
308     }
309 
310     //-----------------------------------------------------------------------
311     /**
312      * Obtains an instance of {@code JapaneseEra} from a date.
313      *
314      * @param date  the date, not null
315      * @return the Era singleton, never null
316      */
317     static JapaneseEra from(LocalDate date) {
318         if (date.isBefore(MEIJI_6_ISODATE)) {
319             throw new DateTimeException(&quot;JapaneseDate before Meiji 6 are not supported&quot;);
320         }
321         for (int i = KNOWN_ERAS.length - 1; i &gt; 0; i--) {
322             JapaneseEra era = KNOWN_ERAS[i];
323             if (date.compareTo(era.since) &gt;= 0) {
324                 return era;
325             }
326         }
327         return null;
328     }
329 
330     static JapaneseEra toJapaneseEra(sun.util.calendar.Era privateEra) {
331         for (int i = ERA_CONFIG.length - 1; i &gt;= 0; i--) {
332             if (ERA_CONFIG[i].equals(privateEra)) {
333                 return KNOWN_ERAS[i];
334             }
335         }
336         return null;
337     }
338 
339     static sun.util.calendar.Era privateEraFrom(LocalDate isoDate) {
340         for (int i = KNOWN_ERAS.length - 1; i &gt; 0; i--) {
341             JapaneseEra era = KNOWN_ERAS[i];
342             if (isoDate.compareTo(era.since) &gt;= 0) {
343                 return ERA_CONFIG[i];
344             }
345         }
346         return null;
347     }
348 
349     /**
350      * Returns the index into the arrays from the Era value.
351      * the eraValue is a valid Era number, -1..2.
352      *
353      * @param eraValue  the era value to convert to the index
354      * @return the index of the current Era
355      */
356     private static int ordinal(int eraValue) {
357         return eraValue + ERA_OFFSET - 1;
358     }
359 
360     //-----------------------------------------------------------------------
361     /**
362      * Gets the numeric era {@code int} value.
363      * &lt;p&gt;
364      * The {@link #SHOWA} era that contains 1970-01-01 (ISO calendar system) has the value 1.
365      * Later eras are numbered from 2 ({@link #HEISEI}).
366      * Earlier eras are numbered 0 ({@link #TAISHO}), -1 ({@link #MEIJI})).
367      *
368      * @return the era value
369      */
370     @Override
371     public int getValue() {
372         return eraValue;
373     }
374 
375     //-----------------------------------------------------------------------
376     /**
377      * Gets the range of valid values for the specified field.
378      * &lt;p&gt;
379      * The range object expresses the minimum and maximum valid values for a field.
380      * This era is used to enhance the accuracy of the returned range.
381      * If it is not possible to return the range, because the field is not supported
382      * or for some other reason, an exception is thrown.
383      * &lt;p&gt;
384      * If the field is a {@link ChronoField} then the query is implemented here.
385      * The {@code ERA} field returns the range.
386      * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
387      * &lt;p&gt;
388      * If the field is not a {@code ChronoField}, then the result of this method
389      * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
390      * passing {@code this} as the argument.
391      * Whether the range can be obtained is determined by the field.
392      * &lt;p&gt;
393      * The range of valid Japanese eras can change over time due to the nature
394      * of the Japanese calendar system.
395      *
396      * @param field  the field to query the range for, not null
397      * @return the range of valid values for the field, not null
398      * @throws DateTimeException if the range for the field cannot be obtained
399      * @throws UnsupportedTemporalTypeException if the unit is not supported
400      */
401     @Override  // override as super would return range from 0 to 1
402     public ValueRange range(TemporalField field) {
403         if (field == ERA) {
404             return JapaneseChronology.INSTANCE.range(ERA);
405         }
406         return Era.super.range(field);
407     }
408 
409     //-----------------------------------------------------------------------
410     String getAbbreviation() {
411         return ERA_CONFIG[ordinal(getValue())].getAbbreviation();
412     }
413 
414     String getName() {
415         return ERA_CONFIG[ordinal(getValue())].getName();
416     }
417 
418     @Override
419     public String toString() {
420         return getName();
421     }
422 
423     //-----------------------------------------------------------------------
424     /**
425      * Defend against malicious streams.
426      *
427      * @param s the stream to read
428      * @throws InvalidObjectException always
429      */
<a name="6" id="anc6"></a><span class="line-added">430     @java.io.Serial</span>
431     private void readObject(ObjectInputStream s) throws InvalidObjectException {
432         throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
433     }
434 
435     //-----------------------------------------------------------------------
436     /**
437      * Writes the object using a
438      * &lt;a href=&quot;{@docRoot}/serialized-form.html#java.time.chrono.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
439      * @serialData
440      * &lt;pre&gt;
441      *  out.writeByte(5);        // identifies a JapaneseEra
442      *  out.writeInt(getValue());
443      * &lt;/pre&gt;
444      *
445      * @return the instance of {@code Ser}, not null
446      */
<a name="7" id="anc7"></a><span class="line-added">447     @java.io.Serial</span>
448     private Object writeReplace() {
449         return new Ser(Ser.JAPANESE_ERA_TYPE, this);
450     }
451 
452     void writeExternal(DataOutput out) throws IOException {
453         out.writeByte(this.getValue());
454     }
455 
456     static JapaneseEra readExternal(DataInput in) throws IOException {
457         byte eraValue = in.readByte();
458         return JapaneseEra.of(eraValue);
459     }
460 
461 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
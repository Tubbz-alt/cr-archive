<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleStatics.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandleProxies.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
135     // No stable mapping is promised between the single-method interface and
136     // the implementation class C.  Over time, several implementation
137     // classes might be used for the same type.
138     // &lt;p&gt;
139     // If the implementation is able
140     // to prove that a wrapper of the required type
141     // has already been created for a given
142     // method handle, or for another method handle with the
143     // same behavior, the implementation may return that wrapper in place of
144     // a new wrapper.
145     // &lt;p&gt;
146     // This method is designed to apply to common use cases
147     // where a single method handle must interoperate with
148     // an interface that implements a function-like
149     // API.  Additional variations, such as single-abstract-method classes with
150     // private constructors, or interfaces with multiple but related
151     // entry points, must be covered by hand-written or automatically
152     // generated adapter classes.
153     //
154     @CallerSensitive
<span class="line-modified">155     public static</span>
<span class="line-removed">156     &lt;T&gt; T asInterfaceInstance(final Class&lt;T&gt; intfc, final MethodHandle target) {</span>
157         if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))
158             throw newIllegalArgumentException(&quot;not a public interface&quot;, intfc.getName());
159         final MethodHandle mh;
160         if (System.getSecurityManager() != null) {
161             final Class&lt;?&gt; caller = Reflection.getCallerClass();
162             final ClassLoader ccl = caller != null ? caller.getClassLoader() : null;
163             ReflectUtil.checkProxyPackageAccess(ccl, intfc);
164             mh = ccl != null ? bindCaller(target, caller) : target;
165         } else {
166             mh = target;
167         }
168         ClassLoader proxyLoader = intfc.getClassLoader();
169         if (proxyLoader == null) {
170             ClassLoader cl = Thread.currentThread().getContextClassLoader(); // avoid use of BCP
171             proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();
172         }
173         final Method[] methods = getSingleNameMethods(intfc);
174         if (methods == null)
175             throw newIllegalArgumentException(&quot;not a single-method interface&quot;, intfc.getName());
176         final MethodHandle[] vaTargets = new MethodHandle[methods.length];
</pre>
<hr />
<pre>
218                             ih);
219                 }
220             });
221         } else {
222             proxy = Proxy.newProxyInstance(proxyLoader,
223                                            new Class&lt;?&gt;[]{ intfc, WrapperInstance.class },
224                                            ih);
225         }
226         return intfc.cast(proxy);
227     }
228 
229     private static MethodHandle bindCaller(MethodHandle target, Class&lt;?&gt; hostClass) {
230         return MethodHandleImpl.bindCaller(target, hostClass).withVarargs(target.isVarargsCollector());
231     }
232 
233     /**
234      * Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
235      * @param x any reference
236      * @return true if the reference is not null and points to an object produced by {@code asInterfaceInstance}
237      */
<span class="line-modified">238     public static</span>
<span class="line-removed">239     boolean isWrapperInstance(Object x) {</span>
240         return x instanceof WrapperInstance;
241     }
242 
243     private static WrapperInstance asWrapperInstance(Object x) {
244         try {
245             if (x != null)
246                 return (WrapperInstance) x;
247         } catch (ClassCastException ex) {
248         }
249         throw newIllegalArgumentException(&quot;not a wrapper instance&quot;);
250     }
251 
252     /**
253      * Produces or recovers a target method handle which is behaviorally
254      * equivalent to the unique method of this wrapper instance.
255      * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
256      * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
257      * @param x any reference
258      * @return a method handle implementing the unique method
259      * @throws IllegalArgumentException if the reference x is not to a wrapper instance
260      */
<span class="line-modified">261     public static</span>
<span class="line-removed">262     MethodHandle wrapperInstanceTarget(Object x) {</span>
263         return asWrapperInstance(x).getWrapperInstanceTarget();
264     }
265 
266     /**
267      * Recovers the unique single-method interface type for which this wrapper instance was created.
268      * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
269      * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
270      * @param x any reference
271      * @return the single-method interface type for which the wrapper was created
272      * @throws IllegalArgumentException if the reference x is not to a wrapper instance
273      */
<span class="line-modified">274     public static</span>
<span class="line-removed">275     Class&lt;?&gt; wrapperInstanceType(Object x) {</span>
276         return asWrapperInstance(x).getWrapperInstanceType();
277     }
278 
<span class="line-modified">279     private static</span>
<span class="line-removed">280     boolean isObjectMethod(Method m) {</span>
281         switch (m.getName()) {
282         case &quot;toString&quot;:
283             return (m.getReturnType() == String.class
284                     &amp;&amp; m.getParameterTypes().length == 0);
285         case &quot;hashCode&quot;:
286             return (m.getReturnType() == int.class
287                     &amp;&amp; m.getParameterTypes().length == 0);
288         case &quot;equals&quot;:
289             return (m.getReturnType() == boolean.class
290                     &amp;&amp; m.getParameterTypes().length == 1
291                     &amp;&amp; m.getParameterTypes()[0] == Object.class);
292         }
293         return false;
294     }
295 
<span class="line-modified">296     private static</span>
<span class="line-removed">297     Object callObjectMethod(Object self, Method m, Object[] args) {</span>
298         assert(isObjectMethod(m)) : m;
299         switch (m.getName()) {
300         case &quot;toString&quot;:
301             return self.getClass().getName() + &quot;@&quot; + Integer.toHexString(self.hashCode());
302         case &quot;hashCode&quot;:
303             return System.identityHashCode(self);
304         case &quot;equals&quot;:
305             return (self == args[0]);
306         }
307         return null;
308     }
309 
<span class="line-modified">310     private static</span>
<span class="line-removed">311     Method[] getSingleNameMethods(Class&lt;?&gt; intfc) {</span>
312         ArrayList&lt;Method&gt; methods = new ArrayList&lt;&gt;();
313         String uniqueName = null;
314         for (Method m : intfc.getMethods()) {
315             if (isObjectMethod(m))  continue;
316             if (!Modifier.isAbstract(m.getModifiers()))  continue;
317             String mname = m.getName();
318             if (uniqueName == null)
319                 uniqueName = mname;
320             else if (!uniqueName.equals(mname))
321                 return null;  // too many abstract methods
322             methods.add(m);
323         }
324         if (uniqueName == null)  return null;
325         return methods.toArray(new Method[methods.size()]);
326     }
327 
<span class="line-modified">328     private static</span>
<span class="line-removed">329     boolean isDefaultMethod(Method m) {</span>
330         return !Modifier.isAbstract(m.getModifiers());
331     }
332 
<span class="line-modified">333     private static</span>
<span class="line-removed">334     boolean hasDefaultMethods(Class&lt;?&gt; intfc) {</span>
335         for (Method m : intfc.getMethods()) {
336             if (!isObjectMethod(m) &amp;&amp;
337                 !Modifier.isAbstract(m.getModifiers())) {
338                 return true;
339             }
340         }
341         return false;
342     }
343 
<span class="line-modified">344     private static</span>
<span class="line-removed">345     Object callDefaultMethod(ConcurrentHashMap&lt;Method, MethodHandle&gt; defaultMethodMap,</span>
346                              Object self, Class&lt;?&gt; intfc, Method m, Object[] args) throws Throwable {
347         assert(isDefaultMethod(m) &amp;&amp; !isObjectMethod(m)) : m;
348 
349         // Lazily compute the associated method handle from the method
350         MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -&gt; {
351             try {
352                 // Look up the default method for special invocation thereby
353                 // avoiding recursive invocation back to the proxy
354                 MethodHandle mh = MethodHandles.Lookup.IMPL_LOOKUP.findSpecial(
355                         intfc, mk.getName(),
356                         MethodType.methodType(mk.getReturnType(), mk.getParameterTypes()),
357                         self.getClass());
358                 return mh.asSpreader(Object[].class, mk.getParameterCount());
359             } catch (NoSuchMethodException | IllegalAccessException e) {
360                 // The method is known to exist and should be accessible, this
361                 // method would not be called unless the invokeinterface to the
362                 // default (public) method passed access control checks
363                 throw new InternalError(e);
364             }
365         });
</pre>
</td>
<td>
<hr />
<pre>
135     // No stable mapping is promised between the single-method interface and
136     // the implementation class C.  Over time, several implementation
137     // classes might be used for the same type.
138     // &lt;p&gt;
139     // If the implementation is able
140     // to prove that a wrapper of the required type
141     // has already been created for a given
142     // method handle, or for another method handle with the
143     // same behavior, the implementation may return that wrapper in place of
144     // a new wrapper.
145     // &lt;p&gt;
146     // This method is designed to apply to common use cases
147     // where a single method handle must interoperate with
148     // an interface that implements a function-like
149     // API.  Additional variations, such as single-abstract-method classes with
150     // private constructors, or interfaces with multiple but related
151     // entry points, must be covered by hand-written or automatically
152     // generated adapter classes.
153     //
154     @CallerSensitive
<span class="line-modified">155     public static &lt;T&gt; T asInterfaceInstance(final Class&lt;T&gt; intfc, final MethodHandle target) {</span>

156         if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))
157             throw newIllegalArgumentException(&quot;not a public interface&quot;, intfc.getName());
158         final MethodHandle mh;
159         if (System.getSecurityManager() != null) {
160             final Class&lt;?&gt; caller = Reflection.getCallerClass();
161             final ClassLoader ccl = caller != null ? caller.getClassLoader() : null;
162             ReflectUtil.checkProxyPackageAccess(ccl, intfc);
163             mh = ccl != null ? bindCaller(target, caller) : target;
164         } else {
165             mh = target;
166         }
167         ClassLoader proxyLoader = intfc.getClassLoader();
168         if (proxyLoader == null) {
169             ClassLoader cl = Thread.currentThread().getContextClassLoader(); // avoid use of BCP
170             proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();
171         }
172         final Method[] methods = getSingleNameMethods(intfc);
173         if (methods == null)
174             throw newIllegalArgumentException(&quot;not a single-method interface&quot;, intfc.getName());
175         final MethodHandle[] vaTargets = new MethodHandle[methods.length];
</pre>
<hr />
<pre>
217                             ih);
218                 }
219             });
220         } else {
221             proxy = Proxy.newProxyInstance(proxyLoader,
222                                            new Class&lt;?&gt;[]{ intfc, WrapperInstance.class },
223                                            ih);
224         }
225         return intfc.cast(proxy);
226     }
227 
228     private static MethodHandle bindCaller(MethodHandle target, Class&lt;?&gt; hostClass) {
229         return MethodHandleImpl.bindCaller(target, hostClass).withVarargs(target.isVarargsCollector());
230     }
231 
232     /**
233      * Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
234      * @param x any reference
235      * @return true if the reference is not null and points to an object produced by {@code asInterfaceInstance}
236      */
<span class="line-modified">237     public static boolean isWrapperInstance(Object x) {</span>

238         return x instanceof WrapperInstance;
239     }
240 
241     private static WrapperInstance asWrapperInstance(Object x) {
242         try {
243             if (x != null)
244                 return (WrapperInstance) x;
245         } catch (ClassCastException ex) {
246         }
247         throw newIllegalArgumentException(&quot;not a wrapper instance&quot;);
248     }
249 
250     /**
251      * Produces or recovers a target method handle which is behaviorally
252      * equivalent to the unique method of this wrapper instance.
253      * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
254      * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
255      * @param x any reference
256      * @return a method handle implementing the unique method
257      * @throws IllegalArgumentException if the reference x is not to a wrapper instance
258      */
<span class="line-modified">259     public static MethodHandle wrapperInstanceTarget(Object x) {</span>

260         return asWrapperInstance(x).getWrapperInstanceTarget();
261     }
262 
263     /**
264      * Recovers the unique single-method interface type for which this wrapper instance was created.
265      * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
266      * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
267      * @param x any reference
268      * @return the single-method interface type for which the wrapper was created
269      * @throws IllegalArgumentException if the reference x is not to a wrapper instance
270      */
<span class="line-modified">271     public static Class&lt;?&gt; wrapperInstanceType(Object x) {</span>

272         return asWrapperInstance(x).getWrapperInstanceType();
273     }
274 
<span class="line-modified">275     private static boolean isObjectMethod(Method m) {</span>

276         switch (m.getName()) {
277         case &quot;toString&quot;:
278             return (m.getReturnType() == String.class
279                     &amp;&amp; m.getParameterTypes().length == 0);
280         case &quot;hashCode&quot;:
281             return (m.getReturnType() == int.class
282                     &amp;&amp; m.getParameterTypes().length == 0);
283         case &quot;equals&quot;:
284             return (m.getReturnType() == boolean.class
285                     &amp;&amp; m.getParameterTypes().length == 1
286                     &amp;&amp; m.getParameterTypes()[0] == Object.class);
287         }
288         return false;
289     }
290 
<span class="line-modified">291     private static Object callObjectMethod(Object self, Method m, Object[] args) {</span>

292         assert(isObjectMethod(m)) : m;
293         switch (m.getName()) {
294         case &quot;toString&quot;:
295             return self.getClass().getName() + &quot;@&quot; + Integer.toHexString(self.hashCode());
296         case &quot;hashCode&quot;:
297             return System.identityHashCode(self);
298         case &quot;equals&quot;:
299             return (self == args[0]);
300         }
301         return null;
302     }
303 
<span class="line-modified">304     private static Method[] getSingleNameMethods(Class&lt;?&gt; intfc) {</span>

305         ArrayList&lt;Method&gt; methods = new ArrayList&lt;&gt;();
306         String uniqueName = null;
307         for (Method m : intfc.getMethods()) {
308             if (isObjectMethod(m))  continue;
309             if (!Modifier.isAbstract(m.getModifiers()))  continue;
310             String mname = m.getName();
311             if (uniqueName == null)
312                 uniqueName = mname;
313             else if (!uniqueName.equals(mname))
314                 return null;  // too many abstract methods
315             methods.add(m);
316         }
317         if (uniqueName == null)  return null;
318         return methods.toArray(new Method[methods.size()]);
319     }
320 
<span class="line-modified">321     private static boolean isDefaultMethod(Method m) {</span>

322         return !Modifier.isAbstract(m.getModifiers());
323     }
324 
<span class="line-modified">325     private static boolean hasDefaultMethods(Class&lt;?&gt; intfc) {</span>

326         for (Method m : intfc.getMethods()) {
327             if (!isObjectMethod(m) &amp;&amp;
328                 !Modifier.isAbstract(m.getModifiers())) {
329                 return true;
330             }
331         }
332         return false;
333     }
334 
<span class="line-modified">335     private static Object callDefaultMethod(ConcurrentHashMap&lt;Method, MethodHandle&gt; defaultMethodMap,</span>

336                              Object self, Class&lt;?&gt; intfc, Method m, Object[] args) throws Throwable {
337         assert(isDefaultMethod(m) &amp;&amp; !isObjectMethod(m)) : m;
338 
339         // Lazily compute the associated method handle from the method
340         MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -&gt; {
341             try {
342                 // Look up the default method for special invocation thereby
343                 // avoiding recursive invocation back to the proxy
344                 MethodHandle mh = MethodHandles.Lookup.IMPL_LOOKUP.findSpecial(
345                         intfc, mk.getName(),
346                         MethodType.methodType(mk.getReturnType(), mk.getParameterTypes()),
347                         self.getClass());
348                 return mh.asSpreader(Object[].class, mk.getParameterCount());
349             } catch (NoSuchMethodException | IllegalAccessException e) {
350                 // The method is known to exist and should be accessible, this
351                 // method would not be called unless the invokeinterface to the
352                 // default (public) method passed access control checks
353                 throw new InternalError(e);
354             }
355         });
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandleInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleStatics.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
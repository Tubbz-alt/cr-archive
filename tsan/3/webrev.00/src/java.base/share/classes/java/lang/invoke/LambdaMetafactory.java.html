<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/invoke/LambdaMetafactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import java.io.Serializable;
 29 import java.util.Arrays;
 30 
 31 /**
 32  * &lt;p&gt;Methods to facilitate the creation of simple &quot;function objects&quot; that
 33  * implement one or more interfaces by delegation to a provided {@link MethodHandle},
 34  * possibly after type adaptation and partial evaluation of arguments.  These
 35  * methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code invokedynamic}
 36  * call sites, to support the &lt;em&gt;lambda expression&lt;/em&gt; and &lt;em&gt;method
 37  * reference expression&lt;/em&gt; features of the Java Programming Language.
 38  *
 39  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code MethodHandle}
 40  * proceeds in order through three phases:
 41  * &lt;ul&gt;
 42  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
 43  *     They take as arguments an interface to be implemented (typically a
 44  *     &lt;em&gt;functional interface&lt;/em&gt;, one with a single abstract method), a
 45  *     name and signature of a method from that interface to be implemented, a
 46  *     method handle describing the desired implementation behavior
 47  *     for that method, and possibly other additional metadata, and produce a
 48  *     {@link CallSite} whose target can be used to create suitable function
 49  *     objects.  Linkage may involve dynamically loading a new class that
 50  *     implements the target interface. The {@code CallSite} can be considered a
 51  *     &quot;factory&quot; for function objects and so these linkage methods are referred
 52  *     to as &quot;metafactories&quot;.&lt;/li&gt;
 53  *
 54  *     &lt;li&gt;&lt;em&gt;Capture&lt;/em&gt; occurs when the {@code CallSite}&#39;s target is
 55  *     invoked, typically through an {@code invokedynamic} call site,
 56  *     producing a function object.  This may occur many times for
 57  *     a single factory {@code CallSite}.  Capture may involve allocation of a
 58  *     new function object, or may return an existing function object.  The
 59  *     behavior {@code MethodHandle} may have additional parameters beyond those
 60  *     of the specified interface method; these are referred to as &lt;em&gt;captured
 61  *     parameters&lt;/em&gt;, which must be provided as arguments to the
 62  *     {@code CallSite} target, and which may be early-bound to the behavior
 63  *     {@code MethodHandle}.  The number of captured parameters and their types
 64  *     are determined during linkage.
 65  *     The identity of a function object produced by invoking the
 66  *     {@code CallSite}&#39;s target is unpredictable, and therefore
 67  *     identity-sensitive operations (such as reference equality, object
 68  *     locking, and {@code System.identityHashCode()} may produce different
 69  *     results in different implementations, or even upon different invocations
 70  *     in the same implementation.&lt;/li&gt;
 71  *
 72  *     &lt;li&gt;&lt;em&gt;Invocation&lt;/em&gt; occurs when an implemented interface method
 73  *     is invoked on a function object.  This may occur many times for a single
 74  *     function object.  The method referenced by the behavior {@code MethodHandle}
 75  *     is invoked with the captured arguments and any additional arguments
 76  *     provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.&lt;/li&gt;
 77  * &lt;/ul&gt;
 78  *
 79  * &lt;p&gt;It is sometimes useful to restrict the set of inputs or results permitted
 80  * at invocation.  For example, when the generic interface {@code Predicate&lt;T&gt;}
 81  * is parameterized as {@code Predicate&lt;String&gt;}, the input must be a
 82  * {@code String}, even though the method to implement allows any {@code Object}.
 83  * At linkage time, an additional {@link MethodType} parameter describes the
 84  * &quot;instantiated&quot; method type; on invocation, the arguments and eventual result
 85  * are checked against this {@code MethodType}.
 86  *
 87  * &lt;p&gt;This class provides two forms of linkage methods: a standard version
 88  * ({@link #metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)})
 89  * using an optimized protocol, and an alternate version
 90  * {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)}).
 91  * The alternate version is a generalization of the standard version, providing
 92  * additional control over the behavior of the generated function objects via
 93  * flags and additional arguments.  The alternate version adds the ability to
 94  * manage the following attributes of function objects:
 95  *
 96  * &lt;ul&gt;
 97  *     &lt;li&gt;&lt;em&gt;Bridging.&lt;/em&gt;  It is sometimes useful to implement multiple
 98  *     variations of the method signature, involving argument or return type
 99  *     adaptation.  This occurs when multiple distinct VM signatures for a method
100  *     are logically considered to be the same method by the language.  The
101  *     flag {@code FLAG_BRIDGES} indicates that a list of additional
102  *     {@code MethodType}s will be provided, each of which will be implemented
103  *     by the resulting function object.  These methods will share the same
104  *     name and instantiated type.&lt;/li&gt;
105  *
106  *     &lt;li&gt;&lt;em&gt;Multiple interfaces.&lt;/em&gt;  If needed, more than one interface
107  *     can be implemented by the function object.  (These additional interfaces
108  *     are typically marker interfaces with no methods.)  The flag {@code FLAG_MARKERS}
109  *     indicates that a list of additional interfaces will be provided, each of
110  *     which should be implemented by the resulting function object.&lt;/li&gt;
111  *
112  *     &lt;li&gt;&lt;em&gt;Serializability.&lt;/em&gt;  The generated function objects do not
113  *     generally support serialization.  If desired, {@code FLAG_SERIALIZABLE}
114  *     can be used to indicate that the function objects should be serializable.
115  *     Serializable function objects will use, as their serialized form,
116  *     instances of the class {@code SerializedLambda}, which requires additional
117  *     assistance from the capturing class (the class described by the
118  *     {@link MethodHandles.Lookup} parameter {@code caller}); see
119  *     {@link SerializedLambda} for details.&lt;/li&gt;
120  * &lt;/ul&gt;
121  *
122  * &lt;p&gt;Assume the linkage arguments are as follows:
123  * &lt;ul&gt;
124  *      &lt;li&gt;{@code invokedType} (describing the {@code CallSite} signature) has
125  *      K parameters of types (D1..Dk) and return type Rd;&lt;/li&gt;
126  *      &lt;li&gt;{@code samMethodType} (describing the implemented method type) has N
127  *      parameters, of types (U1..Un) and return type Ru;&lt;/li&gt;
128  *      &lt;li&gt;{@code implMethod} (the {@code MethodHandle} providing the
129  *      implementation has M parameters, of types (A1..Am) and return type Ra
130  *      (if the method describes an instance method, the method type of this
131  *      method handle already includes an extra first argument corresponding to
132  *      the receiver);&lt;/li&gt;
133  *      &lt;li&gt;{@code instantiatedMethodType} (allowing restrictions on invocation)
134  *      has N parameters, of types (T1..Tn) and return type Rt.&lt;/li&gt;
135  * &lt;/ul&gt;
136  *
137  * &lt;p&gt;Then the following linkage invariants must hold:
138  * &lt;ul&gt;
139  *     &lt;li&gt;Rd is an interface&lt;/li&gt;
140  *     &lt;li&gt;{@code implMethod} is a &lt;em&gt;direct method handle&lt;/em&gt;&lt;/li&gt;
141  *     &lt;li&gt;{@code samMethodType} and {@code instantiatedMethodType} have the same
142  *     arity N, and for i=1..N, Ti and Ui are the same type, or Ti and Ui are
143  *     both reference types and Ti is a subtype of Ui&lt;/li&gt;
144  *     &lt;li&gt;Either Rt and Ru are the same type, or both are reference types and
145  *     Rt is a subtype of Ru&lt;/li&gt;
146  *     &lt;li&gt;K + N = M&lt;/li&gt;
147  *     &lt;li&gt;For i=1..K, Di = Ai&lt;/li&gt;
148  *     &lt;li&gt;For i=1..N, Ti is adaptable to Aj, where j=i+k&lt;/li&gt;
149  *     &lt;li&gt;The return type Rt is void, or the return type Ra is not void and is
150  *     adaptable to Rt&lt;/li&gt;
151  * &lt;/ul&gt;
152  *
153  * &lt;p&gt;Further, at capture time, if {@code implMethod} corresponds to an instance
154  * method, and there are any capture arguments ({@code K &gt; 0}), then the first
155  * capture argument (corresponding to the receiver) must be non-null.
156  *
157  * &lt;p&gt;A type Q is considered adaptable to S as follows:
158  * &lt;table class=&quot;striped&quot;&gt;
159  *   &lt;caption style=&quot;display:none&quot;&gt;adaptable types&lt;/caption&gt;
160  *   &lt;thead&gt;
161  *     &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Q&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;S&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Link-time checks&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Invocation-time checks&lt;/th&gt;&lt;/tr&gt;
162  *   &lt;/thead&gt;
163  *   &lt;tbody&gt;
164  *     &lt;tr&gt;
165  *         &lt;th scope=&quot;row&quot;&gt;Primitive&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;Primitive&lt;/th&gt;
166  *         &lt;td&gt;Q can be converted to S via a primitive widening conversion&lt;/td&gt;
167  *         &lt;td&gt;None&lt;/td&gt;
168  *     &lt;/tr&gt;
169  *     &lt;tr&gt;
170  *         &lt;th scope=&quot;row&quot;&gt;Primitive&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;Reference&lt;/th&gt;
171  *         &lt;td&gt;S is a supertype of the Wrapper(Q)&lt;/td&gt;
172  *         &lt;td&gt;Cast from Wrapper(Q) to S&lt;/td&gt;
173  *     &lt;/tr&gt;
174  *     &lt;tr&gt;
175  *         &lt;th scope=&quot;row&quot;&gt;Reference&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;Primitive&lt;/th&gt;
176  *         &lt;td&gt;for parameter types: Q is a primitive wrapper and Primitive(Q)
177  *         can be widened to S
178  *         &lt;br&gt;for return types: If Q is a primitive wrapper, check that
179  *         Primitive(Q) can be widened to S&lt;/td&gt;
180  *         &lt;td&gt;If Q is not a primitive wrapper, cast Q to the base Wrapper(S);
181  *         for example Number for numeric types&lt;/td&gt;
182  *     &lt;/tr&gt;
183  *     &lt;tr&gt;
184  *         &lt;th scope=&quot;row&quot;&gt;Reference&lt;/th&gt;&lt;th scope=&quot;row&quot;&gt;Reference&lt;/th&gt;
185  *         &lt;td&gt;for parameter types: S is a supertype of Q
186  *         &lt;br&gt;for return types: none&lt;/td&gt;
187  *         &lt;td&gt;Cast from Q to S&lt;/td&gt;
188  *     &lt;/tr&gt;
189  *   &lt;/tbody&gt;
190  * &lt;/table&gt;
191  *
192  * @apiNote These linkage methods are designed to support the evaluation
193  * of &lt;em&gt;lambda expressions&lt;/em&gt; and &lt;em&gt;method references&lt;/em&gt; in the Java
194  * Language.  For every lambda expressions or method reference in the source code,
195  * there is a target type which is a functional interface.  Evaluating a lambda
196  * expression produces an object of its target type. The recommended mechanism
197  * for evaluating lambda expressions is to desugar the lambda body to a method,
198  * invoke an invokedynamic call site whose static argument list describes the
199  * sole method of the functional interface and the desugared implementation
200  * method, and returns an object (the lambda object) that implements the target
201  * type. (For method references, the implementation method is simply the
202  * referenced method; no desugaring is needed.)
203  *
204  * &lt;p&gt;The argument list of the implementation method and the argument list of
205  * the interface method(s) may differ in several ways.  The implementation
206  * methods may have additional arguments to accommodate arguments captured by
207  * the lambda expression; there may also be differences resulting from permitted
208  * adaptations of arguments, such as casting, boxing, unboxing, and primitive
209  * widening. (Varargs adaptations are not handled by the metafactories; these are
210  * expected to be handled by the caller.)
211  *
212  * &lt;p&gt;Invokedynamic call sites have two argument lists: a static argument list
213  * and a dynamic argument list.  The static argument list is stored in the
214  * constant pool; the dynamic argument is pushed on the operand stack at capture
215  * time.  The bootstrap method has access to the entire static argument list
216  * (which in this case, includes information describing the implementation method,
217  * the target interface, and the target interface method(s)), as well as a
218  * method signature describing the number and static types (but not the values)
219  * of the dynamic arguments and the static return type of the invokedynamic site.
220  *
221  * @implNote The implementation method is described with a method handle. In
222  * theory, any method handle could be used. Currently supported are direct method
223  * handles representing invocation of virtual, interface, constructor and static
224  * methods.
225  * @since 1.8
226  */
227 public final class LambdaMetafactory {
228 
229     private LambdaMetafactory() {}
230 
231     /** Flag for alternate metafactories indicating the lambda object
232      * must be serializable */
233     public static final int FLAG_SERIALIZABLE = 1 &lt;&lt; 0;
234 
235     /**
236      * Flag for alternate metafactories indicating the lambda object implements
237      * other marker interfaces
238      * besides Serializable
239      */
240     public static final int FLAG_MARKERS = 1 &lt;&lt; 1;
241 
242     /**
243      * Flag for alternate metafactories indicating the lambda object requires
244      * additional bridge methods
245      */
246     public static final int FLAG_BRIDGES = 1 &lt;&lt; 2;
247 
248     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
249     private static final MethodType[] EMPTY_MT_ARRAY = new MethodType[0];
250 
251     // LambdaMetafactory bootstrap methods are startup sensitive, and may be
252     // special cased in java.lang.invokeBootstrapMethodInvoker to ensure
253     // methods are invoked with exact type information to avoid generating
254     // code for runtime checks. Take care any changes or additions here are
255     // reflected there as appropriate.
256 
257     /**
258      * Facilitates the creation of simple &quot;function objects&quot; that implement one
259      * or more interfaces by delegation to a provided {@link MethodHandle},
260      * after appropriate type adaptation and partial evaluation of arguments.
261      * Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code invokedynamic}
262      * call sites, to support the &lt;em&gt;lambda expression&lt;/em&gt; and &lt;em&gt;method
263      * reference expression&lt;/em&gt; features of the Java Programming Language.
264      *
265      * &lt;p&gt;This is the standard, streamlined metafactory; additional flexibility
266      * is provided by {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)}.
267      * A general description of the behavior of this method is provided
268      * {@link LambdaMetafactory above}.
269      *
270      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
271      * invoked, the resulting function objects are instances of a class which
272      * implements the interface named by the return type of {@code invokedType},
273      * declares a method with the name given by {@code invokedName} and the
274      * signature given by {@code samMethodType}.  It may also override additional
275      * methods from {@code Object}.
276      *
277      * @param caller Represents a lookup context with the accessibility
278      *               privileges of the caller.  Specifically, the lookup context
279      *               must have {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
280      *               full privilege access}.
281      *               When used with {@code invokedynamic}, this is stacked
282      *               automatically by the VM.
283      * @param invokedName The name of the method to implement.  When used with
284      *                    {@code invokedynamic}, this is provided by the
285      *                    {@code NameAndType} of the {@code InvokeDynamic}
286      *                    structure and is stacked automatically by the VM.
287      * @param invokedType The expected signature of the {@code CallSite}.  The
288      *                    parameter types represent the types of capture variables;
289      *                    the return type is the interface to implement.   When
290      *                    used with {@code invokedynamic}, this is provided by
291      *                    the {@code NameAndType} of the {@code InvokeDynamic}
292      *                    structure and is stacked automatically by the VM.
293      *                    In the event that the implementation method is an
294      *                    instance method and this signature has any parameters,
295      *                    the first parameter in the invocation signature must
296      *                    correspond to the receiver.
297      * @param samMethodType Signature and return type of method to be implemented
298      *                      by the function object.
299      * @param implMethod A direct method handle describing the implementation
300      *                   method which should be called (with suitable adaptation
301      *                   of argument types, return types, and with captured
302      *                   arguments prepended to the invocation arguments) at
303      *                   invocation time.
304      * @param instantiatedMethodType The signature and return type that should
305      *                               be enforced dynamically at invocation time.
306      *                               This may be the same as {@code samMethodType},
307      *                               or may be a specialization of it.
308      * @return a CallSite whose target can be used to perform capture, generating
309      *         instances of the interface named by {@code invokedType}
310      * @throws LambdaConversionException If any of the linkage invariants
311      *                                   described {@link LambdaMetafactory above}
312      *                                   are violated, or the lookup context
313      *                                   does not have private access privileges.
314      */
315     public static CallSite metafactory(MethodHandles.Lookup caller,
316                                        String invokedName,
317                                        MethodType invokedType,
318                                        MethodType samMethodType,
319                                        MethodHandle implMethod,
320                                        MethodType instantiatedMethodType)
321             throws LambdaConversionException {
322         AbstractValidatingLambdaMetafactory mf;
323         mf = new InnerClassLambdaMetafactory(caller, invokedType,
324                                              invokedName, samMethodType,
325                                              implMethod, instantiatedMethodType,
326                                              false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);
327         mf.validateMetafactoryArgs();
328         return mf.buildCallSite();
329     }
330 
331     /**
332      * Facilitates the creation of simple &quot;function objects&quot; that implement one
333      * or more interfaces by delegation to a provided {@link MethodHandle},
334      * after appropriate type adaptation and partial evaluation of arguments.
335      * Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code invokedynamic}
336      * call sites, to support the &lt;em&gt;lambda expression&lt;/em&gt; and &lt;em&gt;method
337      * reference expression&lt;/em&gt; features of the Java Programming Language.
338      *
339      * &lt;p&gt;This is the general, more flexible metafactory; a streamlined version
340      * is provided by {@link #metafactory(java.lang.invoke.MethodHandles.Lookup,
341      * String, MethodType, MethodType, MethodHandle, MethodType)}.
342      * A general description of the behavior of this method is provided
343      * {@link LambdaMetafactory above}.
344      *
345      * &lt;p&gt;The argument list for this method includes three fixed parameters,
346      * corresponding to the parameters automatically stacked by the VM for the
347      * bootstrap method in an {@code invokedynamic} invocation, and an {@code Object[]}
348      * parameter that contains additional parameters.  The declared argument
349      * list for this method is:
350      *
351      * &lt;pre&gt;{@code
352      *  CallSite altMetafactory(MethodHandles.Lookup caller,
353      *                          String invokedName,
354      *                          MethodType invokedType,
355      *                          Object... args)
356      * }&lt;/pre&gt;
357      *
358      * &lt;p&gt;but it behaves as if the argument list is as follows:
359      *
360      * &lt;pre&gt;{@code
361      *  CallSite altMetafactory(MethodHandles.Lookup caller,
362      *                          String invokedName,
363      *                          MethodType invokedType,
364      *                          MethodType samMethodType,
365      *                          MethodHandle implMethod,
366      *                          MethodType instantiatedMethodType,
367      *                          int flags,
368      *                          int markerInterfaceCount,  // IF flags has MARKERS set
369      *                          Class... markerInterfaces, // IF flags has MARKERS set
370      *                          int bridgeCount,           // IF flags has BRIDGES set
371      *                          MethodType... bridges      // IF flags has BRIDGES set
372      *                          )
373      * }&lt;/pre&gt;
374      *
375      * &lt;p&gt;Arguments that appear in the argument list for
376      * {@link #metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType)}
377      * have the same specification as in that method.  The additional arguments
378      * are interpreted as follows:
379      * &lt;ul&gt;
380      *     &lt;li&gt;{@code flags} indicates additional options; this is a bitwise
381      *     OR of desired flags.  Defined flags are {@link #FLAG_BRIDGES},
382      *     {@link #FLAG_MARKERS}, and {@link #FLAG_SERIALIZABLE}.&lt;/li&gt;
383      *     &lt;li&gt;{@code markerInterfaceCount} is the number of additional interfaces
384      *     the function object should implement, and is present if and only if the
385      *     {@code FLAG_MARKERS} flag is set.&lt;/li&gt;
386      *     &lt;li&gt;{@code markerInterfaces} is a variable-length list of additional
387      *     interfaces to implement, whose length equals {@code markerInterfaceCount},
388      *     and is present if and only if the {@code FLAG_MARKERS} flag is set.&lt;/li&gt;
389      *     &lt;li&gt;{@code bridgeCount} is the number of additional method signatures
390      *     the function object should implement, and is present if and only if
391      *     the {@code FLAG_BRIDGES} flag is set.&lt;/li&gt;
392      *     &lt;li&gt;{@code bridges} is a variable-length list of additional
393      *     methods signatures to implement, whose length equals {@code bridgeCount},
394      *     and is present if and only if the {@code FLAG_BRIDGES} flag is set.&lt;/li&gt;
395      * &lt;/ul&gt;
396      *
397      * &lt;p&gt;Each class named by {@code markerInterfaces} is subject to the same
398      * restrictions as {@code Rd}, the return type of {@code invokedType},
399      * as described {@link LambdaMetafactory above}.  Each {@code MethodType}
400      * named by {@code bridges} is subject to the same restrictions as
401      * {@code samMethodType}, as described {@link LambdaMetafactory above}.
402      *
403      * &lt;p&gt;When FLAG_SERIALIZABLE is set in {@code flags}, the function objects
404      * will implement {@code Serializable}, and will have a {@code writeReplace}
405      * method that returns an appropriate {@link SerializedLambda}.  The
406      * {@code caller} class must have an appropriate {@code $deserializeLambda$}
407      * method, as described in {@link SerializedLambda}.
408      *
409      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
410      * invoked, the resulting function objects are instances of a class with
411      * the following properties:
412      * &lt;ul&gt;
413      *     &lt;li&gt;The class implements the interface named by the return type
414      *     of {@code invokedType} and any interfaces named by {@code markerInterfaces}&lt;/li&gt;
415      *     &lt;li&gt;The class declares methods with the name given by {@code invokedName},
416      *     and the signature given by {@code samMethodType} and additional signatures
417      *     given by {@code bridges}&lt;/li&gt;
418      *     &lt;li&gt;The class may override methods from {@code Object}, and may
419      *     implement methods related to serialization.&lt;/li&gt;
420      * &lt;/ul&gt;
421      *
422      * @param caller Represents a lookup context with the accessibility
423      *               privileges of the caller.  Specifically, the lookup context
424      *               must have {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
425      *               full privilege access}.
426      *               When used with {@code invokedynamic}, this is stacked
427      *               automatically by the VM.
428      * @param invokedName The name of the method to implement.  When used with
429      *                    {@code invokedynamic}, this is provided by the
430      *                    {@code NameAndType} of the {@code InvokeDynamic}
431      *                    structure and is stacked automatically by the VM.
432      * @param invokedType The expected signature of the {@code CallSite}.  The
433      *                    parameter types represent the types of capture variables;
434      *                    the return type is the interface to implement.   When
435      *                    used with {@code invokedynamic}, this is provided by
436      *                    the {@code NameAndType} of the {@code InvokeDynamic}
437      *                    structure and is stacked automatically by the VM.
438      *                    In the event that the implementation method is an
439      *                    instance method and this signature has any parameters,
440      *                    the first parameter in the invocation signature must
441      *                    correspond to the receiver.
442      * @param  args       An {@code Object[]} array containing the required
443      *                    arguments {@code samMethodType}, {@code implMethod},
444      *                    {@code instantiatedMethodType}, {@code flags}, and any
445      *                    optional arguments, as described
446      *                    {@link #altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)} above}
447      * @return a CallSite whose target can be used to perform capture, generating
448      *         instances of the interface named by {@code invokedType}
449      * @throws LambdaConversionException If any of the linkage invariants
450      *                                   described {@link LambdaMetafactory above}
451      *                                   are violated, or the lookup context
452      *                                   does not have private access privileges.
453      */
454     public static CallSite altMetafactory(MethodHandles.Lookup caller,
455                                           String invokedName,
456                                           MethodType invokedType,
457                                           Object... args)
458             throws LambdaConversionException {
459         MethodType samMethodType = (MethodType)args[0];
460         MethodHandle implMethod = (MethodHandle)args[1];
461         MethodType instantiatedMethodType = (MethodType)args[2];
462         int flags = (Integer) args[3];
463         Class&lt;?&gt;[] markerInterfaces;
464         MethodType[] bridges;
465         int argIndex = 4;
466         if ((flags &amp; FLAG_MARKERS) != 0) {
467             int markerCount = (Integer) args[argIndex++];
468             markerInterfaces = new Class&lt;?&gt;[markerCount];
469             System.arraycopy(args, argIndex, markerInterfaces, 0, markerCount);
470             argIndex += markerCount;
471         }
472         else
473             markerInterfaces = EMPTY_CLASS_ARRAY;
474         if ((flags &amp; FLAG_BRIDGES) != 0) {
475             int bridgeCount = (Integer) args[argIndex++];
476             bridges = new MethodType[bridgeCount];
477             System.arraycopy(args, argIndex, bridges, 0, bridgeCount);
478             argIndex += bridgeCount;
479         }
480         else
481             bridges = EMPTY_MT_ARRAY;
482 
483         boolean isSerializable = ((flags &amp; FLAG_SERIALIZABLE) != 0);
484         if (isSerializable) {
485             boolean foundSerializableSupertype = Serializable.class.isAssignableFrom(invokedType.returnType());
486             for (Class&lt;?&gt; c : markerInterfaces)
487                 foundSerializableSupertype |= Serializable.class.isAssignableFrom(c);
488             if (!foundSerializableSupertype) {
489                 markerInterfaces = Arrays.copyOf(markerInterfaces, markerInterfaces.length + 1);
490                 markerInterfaces[markerInterfaces.length-1] = Serializable.class;
491             }
492         }
493 
494         AbstractValidatingLambdaMetafactory mf
495                 = new InnerClassLambdaMetafactory(caller, invokedType,
496                                                   invokedName, samMethodType,
497                                                   implMethod,
498                                                   instantiatedMethodType,
499                                                   isSerializable,
500                                                   markerInterfaces, bridges);
501         mf.validateMetafactoryArgs();
502         return mf.buildCallSite();
503     }
504 }
    </pre>
  </body>
</html>
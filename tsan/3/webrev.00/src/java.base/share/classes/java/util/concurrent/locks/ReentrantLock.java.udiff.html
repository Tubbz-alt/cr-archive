<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/util/concurrent/locks/ReentrantLock.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LockSupport.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReentrantReadWriteLock.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/locks/ReentrantLock.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -117,43 +117,67 @@</span>
       */
      abstract static class Sync extends AbstractQueuedSynchronizer {
          private static final long serialVersionUID = -5179523762034025860L;
  
          /**
<span class="udiff-line-modified-removed">-          * Performs non-fair tryLock.  tryAcquire is implemented in</span>
<span class="udiff-line-removed">-          * subclasses, but both need nonfair try for trylock method.</span>
<span class="udiff-line-modified-added">+          * Performs non-fair tryLock.</span>
           */
          @ReservedStackAccess
<span class="udiff-line-modified-removed">-         final boolean nonfairTryAcquire(int acquires) {</span>
<span class="udiff-line-modified-removed">-             final Thread current = Thread.currentThread();</span>
<span class="udiff-line-modified-added">+         final boolean tryLock() {</span>
<span class="udiff-line-modified-added">+             Thread current = Thread.currentThread();</span>
              int c = getState();
              if (c == 0) {
<span class="udiff-line-modified-removed">-                 if (compareAndSetState(0, acquires)) {</span>
<span class="udiff-line-modified-added">+                 if (compareAndSetState(0, 1)) {</span>
                      setExclusiveOwnerThread(current);
                      return true;
                  }
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             else if (current == getExclusiveOwnerThread()) {</span>
<span class="udiff-line-removed">-                 int nextc = c + acquires;</span>
<span class="udiff-line-removed">-                 if (nextc &lt; 0) // overflow</span>
<span class="udiff-line-modified-added">+             } else if (getExclusiveOwnerThread() == current) {</span>
<span class="udiff-line-modified-added">+                 if (++c &lt; 0) // overflow</span>
                      throw new Error(&quot;Maximum lock count exceeded&quot;);
<span class="udiff-line-modified-removed">-                 setState(nextc);</span>
<span class="udiff-line-modified-added">+                 setState(c);</span>
                  return true;
              }
              return false;
          }
  
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Checks for reentrancy and acquires if lock immediately</span>
<span class="udiff-line-added">+          * available under fair vs nonfair rules. Locking methods</span>
<span class="udiff-line-added">+          * perform initialTryLock check before relaying to</span>
<span class="udiff-line-added">+          * corresponding AQS acquire methods.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         abstract boolean initialTryLock();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @ReservedStackAccess</span>
<span class="udiff-line-added">+         final void lock() {</span>
<span class="udiff-line-added">+             if (!initialTryLock())</span>
<span class="udiff-line-added">+                 acquire(1);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @ReservedStackAccess</span>
<span class="udiff-line-added">+         final void lockInterruptibly() throws InterruptedException {</span>
<span class="udiff-line-added">+             if (Thread.interrupted())</span>
<span class="udiff-line-added">+                 throw new InterruptedException();</span>
<span class="udiff-line-added">+             if (!initialTryLock())</span>
<span class="udiff-line-added">+                 acquireInterruptibly(1);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @ReservedStackAccess</span>
<span class="udiff-line-added">+         final boolean tryLockNanos(long nanos) throws InterruptedException {</span>
<span class="udiff-line-added">+             if (Thread.interrupted())</span>
<span class="udiff-line-added">+                 throw new InterruptedException();</span>
<span class="udiff-line-added">+             return initialTryLock() || tryAcquireNanos(1, nanos);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          @ReservedStackAccess
          protected final boolean tryRelease(int releases) {
              int c = getState() - releases;
<span class="udiff-line-modified-removed">-             if (Thread.currentThread() != getExclusiveOwnerThread())</span>
<span class="udiff-line-modified-added">+             if (getExclusiveOwnerThread() != Thread.currentThread())</span>
                  throw new IllegalMonitorStateException();
<span class="udiff-line-modified-removed">-             boolean free = false;</span>
<span class="udiff-line-modified-removed">-             if (c == 0) {</span>
<span class="udiff-line-removed">-                 free = true;</span>
<span class="udiff-line-modified-added">+             boolean free = (c == 0);</span>
<span class="udiff-line-modified-added">+             if (free)</span>
                  setExclusiveOwnerThread(null);
<span class="udiff-line-removed">-             }</span>
              setState(c);
              return free;
          }
  
          protected final boolean isHeldExclusively() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -193,40 +217,71 @@</span>
      /**
       * Sync object for non-fair locks
       */
      static final class NonfairSync extends Sync {
          private static final long serialVersionUID = 7316153563782823691L;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         final boolean initialTryLock() {</span>
<span class="udiff-line-added">+             Thread current = Thread.currentThread();</span>
<span class="udiff-line-added">+             if (compareAndSetState(0, 1)) { // first attempt is unguarded</span>
<span class="udiff-line-added">+                 setExclusiveOwnerThread(current);</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             } else if (getExclusiveOwnerThread() == current) {</span>
<span class="udiff-line-added">+                 int c = getState() + 1;</span>
<span class="udiff-line-added">+                 if (c &lt; 0) // overflow</span>
<span class="udiff-line-added">+                     throw new Error(&quot;Maximum lock count exceeded&quot;);</span>
<span class="udiff-line-added">+                 setState(c);</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             } else</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Acquire for non-reentrant cases after initialTryLock prescreen</span>
<span class="udiff-line-added">+          */</span>
          protected final boolean tryAcquire(int acquires) {
<span class="udiff-line-modified-removed">-             return nonfairTryAcquire(acquires);</span>
<span class="udiff-line-modified-added">+             if (getState() == 0 &amp;&amp; compareAndSetState(0, acquires)) {</span>
<span class="udiff-line-added">+                 setExclusiveOwnerThread(Thread.currentThread());</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return false;</span>
          }
      }
  
      /**
       * Sync object for fair locks
       */
      static final class FairSync extends Sync {
          private static final long serialVersionUID = -3000897897090466540L;
<span class="udiff-line-added">+ </span>
          /**
<span class="udiff-line-modified-removed">-          * Fair version of tryAcquire.  Don&#39;t grant access unless</span>
<span class="udiff-line-removed">-          * recursive call or no waiters or is first.</span>
<span class="udiff-line-modified-added">+          * Acquires only if reentrant or queue is empty.</span>
           */
<span class="udiff-line-modified-removed">-         @ReservedStackAccess</span>
<span class="udiff-line-modified-removed">-         protected final boolean tryAcquire(int acquires) {</span>
<span class="udiff-line-removed">-             final Thread current = Thread.currentThread();</span>
<span class="udiff-line-modified-added">+         final boolean initialTryLock() {</span>
<span class="udiff-line-modified-added">+             Thread current = Thread.currentThread();</span>
              int c = getState();
              if (c == 0) {
<span class="udiff-line-modified-removed">-                 if (!hasQueuedPredecessors() &amp;&amp;</span>
<span class="udiff-line-removed">-                     compareAndSetState(0, acquires)) {</span>
<span class="udiff-line-modified-added">+                 if (!hasQueuedThreads() &amp;&amp; compareAndSetState(0, 1)) {</span>
                      setExclusiveOwnerThread(current);
                      return true;
                  }
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             else if (current == getExclusiveOwnerThread()) {</span>
<span class="udiff-line-removed">-                 int nextc = c + acquires;</span>
<span class="udiff-line-removed">-                 if (nextc &lt; 0)</span>
<span class="udiff-line-modified-added">+             } else if (getExclusiveOwnerThread() == current) {</span>
<span class="udiff-line-modified-added">+                 if (++c &lt; 0) // overflow</span>
                      throw new Error(&quot;Maximum lock count exceeded&quot;);
<span class="udiff-line-modified-removed">-                 setState(nextc);</span>
<span class="udiff-line-modified-added">+                 setState(c);</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Acquires only if thread is first waiter or empty</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         protected final boolean tryAcquire(int acquires) {</span>
<span class="udiff-line-added">+             if (getState() == 0 &amp;&amp; !hasQueuedPredecessors() &amp;&amp;</span>
<span class="udiff-line-added">+                 compareAndSetState(0, acquires)) {</span>
<span class="udiff-line-added">+                 setExclusiveOwnerThread(Thread.currentThread());</span>
                  return true;
              }
              return false;
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -262,11 +317,11 @@</span>
       * current thread becomes disabled for thread scheduling
       * purposes and lies dormant until the lock has been acquired,
       * at which time the lock hold count is set to one.
       */
      public void lock() {
<span class="udiff-line-modified-removed">-         sync.acquire(1);</span>
<span class="udiff-line-modified-added">+         sync.lock();</span>
      }
  
      /**
       * Acquires the lock unless the current thread is
       * {@linkplain Thread#interrupt interrupted}.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -312,11 +367,11 @@</span>
       * interrupt over normal or reentrant acquisition of the lock.
       *
       * @throws InterruptedException if the current thread is interrupted
       */
      public void lockInterruptibly() throws InterruptedException {
<span class="udiff-line-modified-removed">-         sync.acquireInterruptibly(1);</span>
<span class="udiff-line-modified-added">+         sync.lockInterruptibly();</span>
      }
  
      /**
       * Acquires the lock only if it is not held by another thread at the time
       * of invocation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -342,11 +397,11 @@</span>
       * @return {@code true} if the lock was free and was acquired by the
       *         current thread, or the lock was already held by the current
       *         thread; and {@code false} otherwise
       */
      public boolean tryLock() {
<span class="udiff-line-modified-removed">-         return sync.nonfairTryAcquire(1);</span>
<span class="udiff-line-modified-added">+         return sync.tryLock();</span>
      }
  
      /**
       * Acquires the lock if it is not held by another thread within the given
       * waiting time and the current thread has not been
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -419,11 +474,11 @@</span>
       * @throws InterruptedException if the current thread is interrupted
       * @throws NullPointerException if the time unit is null
       */
      public boolean tryLock(long timeout, TimeUnit unit)
              throws InterruptedException {
<span class="udiff-line-modified-removed">-         return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span>
<span class="udiff-line-modified-added">+         return sync.tryLockNanos(unit.toNanos(timeout));</span>
      }
  
      /**
       * Attempts to release this lock.
       *
</pre>
<center><a href="LockSupport.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReentrantReadWriteLock.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/java/lang/invoke/package-info.java b/src/java.base/share/classes/java/lang/invoke/package-info.java
--- a/src/java.base/share/classes/java/lang/invoke/package-info.java
+++ b/src/java.base/share/classes/java/lang/invoke/package-info.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -51,16 +51,16 @@
  * <li>The {@code ldc} instruction makes use of bootstrap {@code MethodHandle} constants
  * to dynamically resolve custom constant values.
  * </li>
  * </ul>
  *
- * <h1><a id="jvm_mods"></a>Dynamic resolution of call sites and constants</h1>
+ * <h2><a id="jvm_mods"></a>Dynamic resolution of call sites and constants</h2>
  * The following low-level information summarizes relevant parts of the
  * Java Virtual Machine specification.  For full details, please see the
  * current version of that specification.
  *
- * <h2><a id="indyinsn"></a>Dynamically-computed call sites</h2>
+ * <h3><a id="indyinsn"></a>Dynamically-computed call sites</h3>
  * An {@code invokedynamic} instruction is originally in an unlinked state.
  * In this state, there is no target method for the instruction to invoke.
  * <p>
  * Before the JVM can execute an {@code invokedynamic} instruction,
  * the instruction must first be <em>linked</em>.
@@ -72,11 +72,11 @@
  * Each {@code invokedynamic} instruction statically specifies its own
  * bootstrap method as a constant pool reference.
  * The constant pool reference also specifies the invocation's name and method type descriptor,
  * just like {@code invokestatic} and the other invoke instructions.
  *
- * <h2><a id="condycon"></a>Dynamically-computed constants</h2>
+ * <h3><a id="condycon"></a>Dynamically-computed constants</h3>
  * The constant pool may contain constants tagged {@code CONSTANT_Dynamic},
  * equipped with bootstrap methods which perform their resolution.
  * Such a <em>dynamic constant</em> is originally in an unresolved state.
  * Before the JVM can use a dynamically-computed constant, it must first be <em>resolved</em>.
  * Dynamically-computed constant resolution is accomplished by calling a <em>bootstrap method</em>
@@ -88,11 +88,11 @@
  * The constant pool reference also specifies the constant's name and field type descriptor,
  * just like {@code getstatic} and the other field reference instructions.
  * (Roughly speaking, a dynamically-computed constant is to a dynamically-computed call site
  * as a {@code CONSTANT_Fieldref} is to a {@code CONSTANT_Methodref}.)
  *
- * <h2><a id="bsm"></a>Execution of bootstrap methods</h2>
+ * <h3><a id="bsm"></a>Execution of bootstrap methods</h3>
  * Resolving a dynamically-computed call site or constant
  * starts with resolving constants from the constant pool for the
  * following items:
  * <ul>
  * <li>the bootstrap method, a {@code CONSTANT_MethodHandle}</li>
@@ -134,11 +134,11 @@
  * {@code BootstrapMethodError} that wraps {@code E} is thrown.
  * If this happens, the same error will be thrown for all
  * subsequent attempts to execute the {@code invokedynamic} instruction or load the
  * dynamically-computed constant.
  *
- * <h2>Timing of resolution</h2>
+ * <h3>Timing of resolution</h3>
  * An {@code invokedynamic} instruction is linked just before its first execution.
  * A dynamically-computed constant is resolved just before the first time it is used
  * (by pushing it on the stack or linking it as a bootstrap method parameter).
  * The bootstrap method call implementing the linkage occurs within
  * a thread that is attempting a first execution or first use.
@@ -169,11 +169,11 @@
  * or to issue &ldquo;causeless&rdquo; bootstrap method calls.
  * Every {@code invokedynamic} instruction transitions at most once from unlinked to linked,
  * just before its first invocation.
  * There is no way to undo the effect of a completed bootstrap method call.
  *
- * <h2>Types of bootstrap methods</h2>
+ * <h3>Types of bootstrap methods</h3>
  * For a dynamically-computed call site, the bootstrap method is invoked with parameter
  * types {@code MethodHandles.Lookup}, {@code String}, {@code MethodType}, and the types
  * of any static arguments; the return type is {@code CallSite}.
  * <p>
  * For a dynamically-computed constant, the bootstrap method is invoked with parameter types
@@ -214,26 +214,26 @@
  * <tr><th scope="col">N</th><th scope="col">Sample bootstrap method</th></tr>
  * </thead>
  * <tbody>
  * <tr><th scope="row" style="font-weight:normal; vertical-align:top">*</th><td>
  *     <ul style="list-style:none; padding-left: 0; margin:0">
- *     <li><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args)</code>
- *     <li><code>CallSite bootstrap(Object... args)</code>
- *     <li><code>CallSite bootstrap(Object caller, Object... nameAndTypeWithArgs)</code>
+ *     <li>{@code CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args)}
+ *     <li>{@code CallSite bootstrap(Object... args)}
+ *     <li>{@code CallSite bootstrap(Object caller, Object... nameAndTypeWithArgs)}
  *     </ul></td></tr>
  * <tr><th scope="row" style="font-weight:normal; vertical-align:top">0</th><td>
  *     <ul style="list-style:none; padding-left: 0; margin:0">
- *     <li><code>CallSite bootstrap(Lookup caller, String name, MethodType type)</code>
- *     <li><code>CallSite bootstrap(Lookup caller, Object... nameAndType)</code>
+ *     <li>{@code CallSite bootstrap(Lookup caller, String name, MethodType type)}
+ *     <li>{@code CallSite bootstrap(Lookup caller, Object... nameAndType)}
  *     </ul></td></tr>
  * <tr><th scope="row" style="font-weight:normal; vertical-align:top">1</th><td>
- *     <code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object arg)</code></td></tr>
+ *     {@code CallSite bootstrap(Lookup caller, String name, MethodType type, Object arg)}</td></tr>
  * <tr><th scope="row" style="font-weight:normal; vertical-align:top">2</th><td>
  *     <ul style="list-style:none; padding-left: 0; margin:0">
- *     <li><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args)</code>
- *     <li><code>CallSite bootstrap(Lookup caller, String name, MethodType type, String... args)</code>
- *     <li><code>CallSite bootstrap(Lookup caller, String name, MethodType type, String x, int y)</code>
+ *     <li>{@code CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args)}
+ *     <li>{@code CallSite bootstrap(Lookup caller, String name, MethodType type, String... args)}
+ *     <li>{@code CallSite bootstrap(Lookup caller, String name, MethodType type, String x, int y)}
  *     </ul></td></tr>
  * </tbody>
  * </table>
  * The last example assumes that the extra arguments are of type
  * {@code String} and {@code Integer} (or {@code int}), respectively.

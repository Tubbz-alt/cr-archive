<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InnerClassLambdaMetafactory.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Invokers.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121,13 +121,17 @@</span>
  
      /** For generating LambdaForm interpreter entry points. */
      private InvokerBytecodeGenerator(String className, String invokerName, MethodType invokerType) {
          this(null, invokerType.parameterCount(),
               className, invokerName, invokerType);
<span class="udiff-line-added">+         MethodType mt = invokerType.erase();</span>
          // Create an array to map name indexes to locals indexes.
<span class="udiff-line-modified-removed">-         for (int i = 0; i &lt; localsMap.length; i++) {</span>
<span class="udiff-line-modified-removed">-             localsMap[i] = invokerType.parameterSlotCount() - invokerType.parameterSlotDepth(i);</span>
<span class="udiff-line-modified-added">+         localsMap[0] = 0; // localsMap has at least one element</span>
<span class="udiff-line-modified-added">+         for (int i = 1, index = 0; i &lt; localsMap.length; i++) {</span>
<span class="udiff-line-added">+             Wrapper w = Wrapper.forBasicType(mt.parameterType(i - 1));</span>
<span class="udiff-line-added">+             index += w.stackSlots();</span>
<span class="udiff-line-added">+             localsMap[i] = index;</span>
          }
      }
  
      /** For generating customized code for a single LambdaForm. */
      private InvokerBytecodeGenerator(String className, LambdaForm form, MethodType invokerType) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1162,11 +1166,11 @@</span>
        *  try {
        *      return a1.invokeBasic(a6, a7);
        *  } catch (Throwable e) {
        *      if (!a2.isInstance(e)) throw e;
        *      return a3.invokeBasic(ex, a6, a7);
<span class="udiff-line-modified-removed">-       *  }}</span>
<span class="udiff-line-modified-added">+       *  }}&lt;/pre&gt;&lt;/blockquote&gt;</span>
        */
      private Name emitGuardWithCatch(int pos) {
          Name args    = lambdaForm.names[pos];
          Name invoker = lambdaForm.names[pos+1];
          Name result  = lambdaForm.names[pos+2];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1257,30 +1261,31 @@</span>
       * &lt;blockquote&gt;&lt;pre&gt;{@code
       * TRY:                 (--)
       *                      load target                             (-- target)
       *                      load args                               (-- args... target)
       *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (depends)
<span class="udiff-line-modified-removed">-      * FINALLY_NORMAL:      (-- r)</span>
<span class="udiff-line-modified-removed">-      *                      load cleanup                            (-- cleanup r)</span>
<span class="udiff-line-modified-removed">-      *                      SWAP                                    (-- r cleanup)</span>
<span class="udiff-line-modified-removed">-      *                      ACONST_NULL                             (-- t r cleanup)</span>
<span class="udiff-line-modified-removed">-      *                      SWAP                                    (-- r t cleanup)</span>
<span class="udiff-line-modified-removed">-      *                      load args                               (-- args... r t cleanup)</span>
<span class="udiff-line-modified-removed">-      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r)</span>
<span class="udiff-line-modified-added">+      * FINALLY_NORMAL:      (-- r_2nd* r)</span>
<span class="udiff-line-modified-added">+      *                      store returned value                    (--)</span>
<span class="udiff-line-modified-added">+      *                      load cleanup                            (-- cleanup)</span>
<span class="udiff-line-modified-added">+      *                      ACONST_NULL                             (-- t cleanup)</span>
<span class="udiff-line-modified-added">+      *                      load returned value                     (-- r_2nd* r t cleanup)</span>
<span class="udiff-line-modified-added">+      *                      load args                               (-- args... r_2nd* r t cleanup)</span>
<span class="udiff-line-modified-added">+      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r_2nd* r)</span>
       *                      GOTO DONE
       * CATCH:               (-- t)
       *                      DUP                                     (-- t t)
       * FINALLY_EXCEPTIONAL: (-- t t)
       *                      load cleanup                            (-- cleanup t t)
       *                      SWAP                                    (-- t cleanup t)
<span class="udiff-line-modified-removed">-      *                      load default for r                      (-- r t cleanup t)</span>
<span class="udiff-line-modified-removed">-      *                      load args                               (-- args... r t cleanup t)</span>
<span class="udiff-line-modified-removed">-      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r t)</span>
<span class="udiff-line-modified-removed">-      *                      POP                                     (-- t)</span>
<span class="udiff-line-modified-added">+      *                      load default for r                      (-- r_2nd* r t cleanup t)</span>
<span class="udiff-line-modified-added">+      *                      load args                               (-- args... r_2nd* r t cleanup t)</span>
<span class="udiff-line-modified-added">+      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r_2nd* r t)</span>
<span class="udiff-line-modified-added">+      *                      POP/POP2*                               (-- t)</span>
       *                      ATHROW
       * DONE:                (-- r)
       * }&lt;/pre&gt;&lt;/blockquote&gt;
<span class="udiff-line-added">+      * * = depends on whether the return type takes up 2 stack slots.</span>
       */
      private Name emitTryFinally(int pos) {
          Name args    = lambdaForm.names[pos];
          Name invoker = lambdaForm.names[pos+1];
          Name result  = lambdaForm.names[pos+2];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1289,11 +1294,13 @@</span>
          Label lTo = new Label();
          Label lCatch = new Label();
          Label lDone = new Label();
  
          Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
<span class="udiff-line-added">+         BasicType basicReturnType = BasicType.basicType(returnType);</span>
          boolean isNonVoid = returnType != void.class;
<span class="udiff-line-added">+ </span>
          MethodType type = args.function.resolvedHandle().type()
                  .dropParameterTypes(0,1)
                  .changeReturnType(returnType);
          MethodType cleanupType = type.insertParameterTypes(0, Throwable.class);
          if (isNonVoid) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1310,17 +1317,18 @@</span>
          emitPushArguments(args, 1); // load args (skip 0: method handle)
          mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
          mv.visitLabel(lTo);
  
          // FINALLY_NORMAL:
<span class="udiff-line-modified-removed">-         emitPushArgument(invoker, 1); // load cleanup</span>
<span class="udiff-line-modified-added">+         int index = extendLocalsMap(new Class&lt;?&gt;[]{ returnType });</span>
          if (isNonVoid) {
<span class="udiff-line-modified-removed">-             mv.visitInsn(Opcodes.SWAP);</span>
<span class="udiff-line-modified-added">+             emitStoreInsn(basicReturnType, index);</span>
          }
<span class="udiff-line-added">+         emitPushArgument(invoker, 1); // load cleanup</span>
          mv.visitInsn(Opcodes.ACONST_NULL);
          if (isNonVoid) {
<span class="udiff-line-modified-removed">-             mv.visitInsn(Opcodes.SWAP);</span>
<span class="udiff-line-modified-added">+             emitLoadInsn(basicReturnType, index);</span>
          }
          emitPushArguments(args, 1); // load args (skip 0: method handle)
          mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
          mv.visitJumpInsn(Opcodes.GOTO, lDone);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1335,20 +1343,38 @@</span>
              emitZero(BasicType.basicType(returnType)); // load default for result
          }
          emitPushArguments(args, 1); // load args (skip 0: method handle)
          mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
          if (isNonVoid) {
<span class="udiff-line-modified-removed">-             mv.visitInsn(Opcodes.POP);</span>
<span class="udiff-line-modified-added">+             emitPopInsn(basicReturnType);</span>
          }
          mv.visitInsn(Opcodes.ATHROW);
  
          // DONE:
          mv.visitLabel(lDone);
  
          return result;
      }
  
<span class="udiff-line-added">+     private void emitPopInsn(BasicType type) {</span>
<span class="udiff-line-added">+         mv.visitInsn(popInsnOpcode(type));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static int popInsnOpcode(BasicType type) {</span>
<span class="udiff-line-added">+         switch (type) {</span>
<span class="udiff-line-added">+             case I_TYPE:</span>
<span class="udiff-line-added">+             case F_TYPE:</span>
<span class="udiff-line-added">+             case L_TYPE:</span>
<span class="udiff-line-added">+                 return Opcodes.POP;</span>
<span class="udiff-line-added">+             case J_TYPE:</span>
<span class="udiff-line-added">+             case D_TYPE:</span>
<span class="udiff-line-added">+                 return Opcodes.POP2;</span>
<span class="udiff-line-added">+             default:</span>
<span class="udiff-line-added">+                 throw new InternalError(&quot;unknown type: &quot; + type);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Emit bytecode for the loop idiom.
       * &lt;p&gt;
       * The pattern looks like (Cf. MethodHandleImpl.loop):
       * &lt;blockquote&gt;&lt;pre&gt;{@code
</pre>
<center><a href="InnerClassLambdaMetafactory.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Invokers.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
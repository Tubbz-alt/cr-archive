diff a/src/java.base/share/classes/java/io/PipedOutputStream.java b/src/java.base/share/classes/java/io/PipedOutputStream.java
--- a/src/java.base/share/classes/java/io/PipedOutputStream.java
+++ b/src/java.base/share/classes/java/io/PipedOutputStream.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -29,38 +29,37 @@
 
 /**
  * A piped output stream can be connected to a piped input stream
  * to create a communications pipe. The piped output stream is the
  * sending end of the pipe. Typically, data is written to a
- * <code>PipedOutputStream</code> object by one thread and data is
- * read from the connected <code>PipedInputStream</code> by some
+ * {@code PipedOutputStream} object by one thread and data is
+ * read from the connected {@code PipedInputStream} by some
  * other thread. Attempting to use both objects from a single thread
  * is not recommended as it may deadlock the thread.
  * The pipe is said to be <a id=BROKEN> <i>broken</i> </a> if a
  * thread that was reading data bytes from the connected piped input
  * stream is no longer alive.
  *
  * @author  James Gosling
  * @see     java.io.PipedInputStream
  * @since   1.0
  */
-public
-class PipedOutputStream extends OutputStream {
+public class PipedOutputStream extends OutputStream {
 
         /* REMIND: identification of the read and write sides needs to be
            more sophisticated.  Either using thread groups (but what about
            pipes within a thread?) or using finalization (but it may be a
            long time until the next GC). */
     private PipedInputStream sink;
 
     /**
      * Creates a piped output stream connected to the specified piped
      * input stream. Data bytes written to this stream will then be
-     * available as input from <code>snk</code>.
+     * available as input from {@code snk}.
      *
      * @param      snk   The piped input stream to connect to.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public PipedOutputStream(PipedInputStream snk)  throws IOException {
         connect(snk);
     }
 
@@ -76,24 +75,24 @@
     }
 
     /**
      * Connects this piped output stream to a receiver. If this object
      * is already connected to some other piped input stream, an
-     * <code>IOException</code> is thrown.
+     * {@code IOException} is thrown.
      * <p>
-     * If <code>snk</code> is an unconnected piped input stream and
-     * <code>src</code> is an unconnected piped output stream, they may
+     * If {@code snk} is an unconnected piped input stream and
+     * {@code src} is an unconnected piped output stream, they may
      * be connected by either the call:
      * <blockquote><pre>
      * src.connect(snk)</pre></blockquote>
      * or the call:
      * <blockquote><pre>
      * snk.connect(src)</pre></blockquote>
      * The two calls have the same effect.
      *
      * @param      snk   the piped input stream to connect to.
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public synchronized void connect(PipedInputStream snk) throws IOException {
         if (snk == null) {
             throw new NullPointerException();
         } else if (sink != null || snk.connected) {
@@ -104,16 +103,16 @@
         snk.out = 0;
         snk.connected = true;
     }
 
     /**
-     * Writes the specified <code>byte</code> to the piped output stream.
+     * Writes the specified {@code byte} to the piped output stream.
      * <p>
-     * Implements the <code>write</code> method of <code>OutputStream</code>.
+     * Implements the {@code write} method of {@code OutputStream}.
      *
-     * @param      b   the <code>byte</code> to be written.
-     * @exception IOException if the pipe is <a href=#BROKEN> broken</a>,
+     * @param   b   the {@code byte} to be written.
+     * @throws  IOException if the pipe is <a href=#BROKEN> broken</a>,
      *          {@link #connect(java.io.PipedInputStream) unconnected},
      *          closed, or if an I/O error occurs.
      */
     public void write(int b)  throws IOException {
         if (sink == null) {
@@ -121,19 +120,19 @@
         }
         sink.receive(b);
     }
 
     /**
-     * Writes <code>len</code> bytes from the specified byte array
-     * starting at offset <code>off</code> to this piped output stream.
+     * Writes {@code len} bytes from the specified byte array
+     * starting at offset {@code off} to this piped output stream.
      * This method blocks until all the bytes are written to the output
      * stream.
      *
-     * @param      b     the data.
-     * @param      off   the start offset in the data.
-     * @param      len   the number of bytes to write.
-     * @exception IOException if the pipe is <a href=#BROKEN> broken</a>,
+     * @param   b     the data.
+     * @param   off   the start offset in the data.
+     * @param   len   the number of bytes to write.
+     * @throws  IOException if the pipe is <a href=#BROKEN> broken</a>,
      *          {@link #connect(java.io.PipedInputStream) unconnected},
      *          closed, or if an I/O error occurs.
      */
     public void write(byte b[], int off, int len) throws IOException {
         if (sink == null) {
@@ -152,11 +151,11 @@
     /**
      * Flushes this output stream and forces any buffered output bytes
      * to be written out.
      * This will notify any readers that bytes are waiting in the pipe.
      *
-     * @exception IOException if an I/O error occurs.
+     * @throws    IOException if an I/O error occurs.
      */
     public synchronized void flush() throws IOException {
         if (sink != null) {
             synchronized (sink) {
                 sink.notifyAll();
@@ -167,11 +166,11 @@
     /**
      * Closes this piped output stream and releases any system resources
      * associated with this stream. This stream may no longer be used for
      * writing bytes.
      *
-     * @exception  IOException  if an I/O error occurs.
+     * @throws     IOException  if an I/O error occurs.
      */
     public void close()  throws IOException {
         if (sink != null) {
             sink.receivedLast();
         }

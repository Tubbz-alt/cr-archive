<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/nio/X-Buffer.java.template</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StringCharBuffer.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="channels/AsynchronousChannelGroup.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/nio/X-Buffer.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
  import java.util.stream.StreamSupport;
  import java.util.stream.$Streamtype$Stream;
  #end[streamableType]
  
  import java.util.Objects;
<span class="line-added">+ import jdk.internal.access.foreign.MemorySegmentProxy;</span>
  import jdk.internal.util.ArraysSupport;
  
  /**
   * $A$ $type$ buffer.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,21 ***</span>
  
      // Creates a new buffer with the given mark, position, limit, capacity,
      // backing array, and array offset
      //
      $Type$Buffer(int mark, int pos, int lim, int cap,   // package-private
<span class="line-modified">!                  $type$[] hb, int offset)</span>
      {
<span class="line-modified">!         super(mark, pos, lim, cap);</span>
          this.hb = hb;
          this.offset = offset;
      }
  
      // Creates a new buffer with the given mark, position, limit, and capacity
      //
<span class="line-modified">!     $Type$Buffer(int mark, int pos, int lim, int cap) { // package-private</span>
<span class="line-modified">!         this(mark, pos, lim, cap, null, 0);</span>
      }
  
      @Override
      Object base() {
          return hb;
<span class="line-new-header">--- 278,29 ---</span>
  
      // Creates a new buffer with the given mark, position, limit, capacity,
      // backing array, and array offset
      //
      $Type$Buffer(int mark, int pos, int lim, int cap,   // package-private
<span class="line-modified">!                  $type$[] hb, int offset, MemorySegmentProxy segment)</span>
      {
<span class="line-modified">!         super(mark, pos, lim, cap, segment);</span>
          this.hb = hb;
          this.offset = offset;
      }
  
      // Creates a new buffer with the given mark, position, limit, and capacity
      //
<span class="line-modified">!     $Type$Buffer(int mark, int pos, int lim, int cap, MemorySegmentProxy segment) { // package-private</span>
<span class="line-modified">!         this(mark, pos, lim, cap, null, 0, segment);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Creates a new buffer with given base, address and capacity</span>
<span class="line-added">+     //</span>
<span class="line-added">+     $Type$Buffer($type$[] hb, long addr, int cap, MemorySegmentProxy segment) { // package-private</span>
<span class="line-added">+         super(addr, cap, segment);</span>
<span class="line-added">+         this.hb = hb;</span>
<span class="line-added">+         this.offset = 0;</span>
      }
  
      @Override
      Object base() {
          return hb;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 346,11 ***</span>
       *          If the {@code capacity} is a negative integer
       */
      public static $Type$Buffer allocate(int capacity) {
          if (capacity &lt; 0)
              throw createCapacityException(capacity);
<span class="line-modified">!         return new Heap$Type$Buffer(capacity, capacity);</span>
      }
  
      /**
       * Wraps $a$ $type$ array into a buffer.
       *
<span class="line-new-header">--- 355,11 ---</span>
       *          If the {@code capacity} is a negative integer
       */
      public static $Type$Buffer allocate(int capacity) {
          if (capacity &lt; 0)
              throw createCapacityException(capacity);
<span class="line-modified">!         return new Heap$Type$Buffer(capacity, capacity, null);</span>
      }
  
      /**
       * Wraps $a$ $type$ array into a buffer.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,11 ***</span>
       */
      public static $Type$Buffer wrap($type$[] array,
                                      int offset, int length)
      {
          try {
<span class="line-modified">!             return new Heap$Type$Buffer(array, offset, length);</span>
          } catch (IllegalArgumentException x) {
              throw new IndexOutOfBoundsException();
          }
      }
  
<span class="line-new-header">--- 400,11 ---</span>
       */
      public static $Type$Buffer wrap($type$[] array,
                                      int offset, int length)
      {
          try {
<span class="line-modified">!             return new Heap$Type$Buffer(array, offset, length, null);</span>
          } catch (IllegalArgumentException x) {
              throw new IndexOutOfBoundsException();
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 770,11 ***</span>
       * @throws  IndexOutOfBoundsException
       *          If the preconditions on the {@code offset} and {@code length}
       *          parameters do not hold
       */
      public $Type$Buffer get($type$[] dst, int offset, int length) {
<span class="line-modified">!         checkBounds(offset, length, dst.length);</span>
          if (length &gt; remaining())
              throw new BufferUnderflowException();
          int end = offset + length;
          for (int i = offset; i &lt; end; i++)
              dst[i] = get();
<span class="line-new-header">--- 779,11 ---</span>
       * @throws  IndexOutOfBoundsException
       *          If the preconditions on the {@code offset} and {@code length}
       *          parameters do not hold
       */
      public $Type$Buffer get($type$[] dst, int offset, int length) {
<span class="line-modified">!         Objects.checkFromIndexSize(offset, length, dst.length);</span>
          if (length &gt; remaining())
              throw new BufferUnderflowException();
          int end = offset + length;
          for (int i = offset; i &lt; end; i++)
              dst[i] = get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 994,11 ***</span>
       *
       * @throws  ReadOnlyBufferException
       *          If this buffer is read-only
       */
      public $Type$Buffer put($type$[] src, int offset, int length) {
<span class="line-modified">!         checkBounds(offset, length, src.length);</span>
          if (length &gt; remaining())
              throw new BufferOverflowException();
          int end = offset + length;
          for (int i = offset; i &lt; end; i++)
              this.put(src[i]);
<span class="line-new-header">--- 1003,11 ---</span>
       *
       * @throws  ReadOnlyBufferException
       *          If this buffer is read-only
       */
      public $Type$Buffer put($type$[] src, int offset, int length) {
<span class="line-modified">!         Objects.checkFromIndexSize(offset, length, src.length);</span>
          if (length &gt; remaining())
              throw new BufferOverflowException();
          int end = offset + length;
          for (int i = offset; i &lt; end; i++)
              this.put(src[i]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1174,11 ***</span>
       *
       * @throws  ReadOnlyBufferException
       *          If this buffer is read-only
       */
      public $Type$Buffer put(String src, int start, int end) {
<span class="line-modified">!         checkBounds(start, end - start, src.length());</span>
          if (isReadOnly())
              throw new ReadOnlyBufferException();
          if (end - start &gt; remaining())
              throw new BufferOverflowException();
          for (int i = start; i &lt; end; i++)
<span class="line-new-header">--- 1183,11 ---</span>
       *
       * @throws  ReadOnlyBufferException
       *          If this buffer is read-only
       */
      public $Type$Buffer put(String src, int start, int end) {
<span class="line-modified">!         Objects.checkFromIndexSize(start, end - start, src.length());</span>
          if (isReadOnly())
              throw new ReadOnlyBufferException();
          if (end - start &gt; remaining())
              throw new BufferOverflowException();
          for (int i = start; i &lt; end; i++)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1858,18 ***</span>
          return this;
      }
  
      /**
       * Returns the memory address, pointing to the byte at the given index,
<span class="line-modified">!      * modulus the given unit size.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt; A return value greater than zero indicates the address of the byte at</span>
<span class="line-modified">!      * the index is misaligned for the unit size, and the value&#39;s quantity</span>
<span class="line-modified">!      * indicates how much the index should be rounded up or down to locate a</span>
<span class="line-modified">!      * byte at an aligned address.  Otherwise, a value of {@code 0} indicates</span>
<span class="line-modified">!      * that the address of the byte at the index is aligned for the unit size.</span>
<span class="line-modified">!      *</span>
       * @apiNote
       * This method may be utilized to determine if unit size bytes from an
       * index can be accessed atomically, if supported by the native platform.
       *
       * @implNote
<span class="line-new-header">--- 1867,31 ---</span>
          return this;
      }
  
      /**
       * Returns the memory address, pointing to the byte at the given index,
<span class="line-modified">!      * modulo the given unit size.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt; The return value is non-negative in the range of {@code 0}</span>
<span class="line-modified">!      * (inclusive) up to {@code unitSize} (exclusive), with zero indicating</span>
<span class="line-modified">!      * that the address of the byte at the index is aligned for the unit size,</span>
<span class="line-modified">!      * and a positive value that the address is misaligned for the unit size.</span>
<span class="line-modified">!      * If the address of the byte at the index is misaligned, the return value</span>
<span class="line-modified">!      * represents how much the index should be adjusted to locate a byte at an</span>
<span class="line-added">+      * aligned address.  Specifically, the index should either be decremented by</span>
<span class="line-added">+      * the return value if the latter is not greater than {@code index}, or be</span>
<span class="line-added">+      * incremented by the unit size minus the return value.  Therefore given</span>
<span class="line-added">+      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">+      * int value = alignmentOffset(index, unitSize)&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">+      * then the identities</span>
<span class="line-added">+      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">+      * alignmentOffset(index - value, unitSize) == 0, value &amp;le; index&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">+      * and</span>
<span class="line-added">+      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">+      * alignmentOffset(index + (unitSize - value), unitSize) == 0&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">+      * must hold.</span>
<span class="line-added">+      * </span>
       * @apiNote
       * This method may be utilized to determine if unit size bytes from an
       * index can be accessed atomically, if supported by the native platform.
       *
       * @implNote
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1881,11 ***</span>
       *         upper bounds check is performed
       *
       * @param  unitSize
       *         The unit size in bytes, must be a power of {@code 2}
       *
<span class="line-modified">!      * @return  The indexed byte&#39;s memory address modulus the unit size</span>
       *
       * @throws IllegalArgumentException
       *         If the index is negative or the unit size is not a power of
       *         {@code 2}
       *
<span class="line-new-header">--- 1903,11 ---</span>
       *         upper bounds check is performed
       *
       * @param  unitSize
       *         The unit size in bytes, must be a power of {@code 2}
       *
<span class="line-modified">!      * @return  The indexed byte&#39;s memory address modulo the unit size</span>
       *
       * @throws IllegalArgumentException
       *         If the index is negative or the unit size is not a power of
       *         {@code 2}
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1907,11 ***</span>
          if (unitSize &lt; 1 || (unitSize &amp; (unitSize - 1)) != 0)
              throw new IllegalArgumentException(&quot;Unit size not a power of two: &quot; + unitSize);
          if (unitSize &gt; 8 &amp;&amp; !isDirect())
              throw new UnsupportedOperationException(&quot;Unit size unsupported for non-direct buffers: &quot; + unitSize);
  
<span class="line-modified">!         return (int) ((address + index) % unitSize);</span>
      }
  
      /**
       * Creates a new byte buffer whose content is a shared and aligned
       * subsequence of this buffer&#39;s content.
<span class="line-new-header">--- 1929,11 ---</span>
          if (unitSize &lt; 1 || (unitSize &amp; (unitSize - 1)) != 0)
              throw new IllegalArgumentException(&quot;Unit size not a power of two: &quot; + unitSize);
          if (unitSize &gt; 8 &amp;&amp; !isDirect())
              throw new UnsupportedOperationException(&quot;Unit size unsupported for non-direct buffers: &quot; + unitSize);
  
<span class="line-modified">!         return (int) ((address + index) &amp; (unitSize - 1));</span>
      }
  
      /**
       * Creates a new byte buffer whose content is a shared and aligned
       * subsequence of this buffer&#39;s content.
</pre>
<center><a href="StringCharBuffer.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="channels/AsynchronousChannelGroup.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/math/BigInteger.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="BigDecimal.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MathContext.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/math/BigInteger.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -40,10 +40,11 @@</span>
  
  import jdk.internal.math.DoubleConsts;
  import jdk.internal.math.FloatConsts;
  import jdk.internal.HotSpotIntrinsicCandidate;
  import jdk.internal.vm.annotation.Stable;
<span class="udiff-line-added">+ import jdk.internal.vm.annotation.ForceInline;</span>
  
  /**
   * Immutable arbitrary-precision integers.  All operations behave as if
   * BigIntegers were represented in two&#39;s-complement notation (like Java&#39;s
   * primitive integer types).  BigInteger provides analogues to all of Java&#39;s
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2619,30 +2620,21 @@</span>
          }
      }
  
      // shifts a up to len right n bits assumes no leading zeros, 0&lt;n&lt;32
      static void primitiveRightShift(int[] a, int len, int n) {
<span class="udiff-line-modified-removed">-         int n2 = 32 - n;</span>
<span class="udiff-line-modified-removed">-         for (int i=len-1, c=a[i]; i &gt; 0; i--) {</span>
<span class="udiff-line-removed">-             int b = c;</span>
<span class="udiff-line-removed">-             c = a[i-1];</span>
<span class="udiff-line-removed">-             a[i] = (c &lt;&lt; n2) | (b &gt;&gt;&gt; n);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         Objects.checkFromToIndex(0, len, a.length);</span>
<span class="udiff-line-modified-added">+         shiftRightImplWorker(a, a, 1, n, len-1);</span>
          a[0] &gt;&gt;&gt;= n;
      }
  
      // shifts a up to len left n bits assumes no leading zeros, 0&lt;=n&lt;32
      static void primitiveLeftShift(int[] a, int len, int n) {
          if (len == 0 || n == 0)
              return;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         int n2 = 32 - n;</span>
<span class="udiff-line-removed">-         for (int i=0, c=a[i], m=i+len-1; i &lt; m; i++) {</span>
<span class="udiff-line-removed">-             int b = c;</span>
<span class="udiff-line-removed">-             c = a[i+1];</span>
<span class="udiff-line-removed">-             a[i] = (b &lt;&lt; n) | (c &gt;&gt;&gt; n2);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         Objects.checkFromToIndex(0, len, a.length);</span>
<span class="udiff-line-modified-added">+         shiftLeftImplWorker(a, a, 0, n, len-1);</span>
          a[len-1] &lt;&lt;= n;
      }
  
      /**
       * Calculate bitlength of contents of the first len elements an int array,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3351,18 +3343,29 @@</span>
                  newMag = new int[magLen + nInts + 1];
                  newMag[i++] = highBits;
              } else {
                  newMag = new int[magLen + nInts];
              }
<span class="udiff-line-modified-removed">-             int j=0;</span>
<span class="udiff-line-modified-removed">-             while (j &lt; magLen-1)</span>
<span class="udiff-line-modified-removed">-                 newMag[i++] = mag[j++] &lt;&lt; nBits | mag[j] &gt;&gt;&gt; nBits2;</span>
<span class="udiff-line-modified-removed">-             newMag[i] = mag[j] &lt;&lt; nBits;</span>
<span class="udiff-line-modified-added">+             int numIter = magLen - 1;</span>
<span class="udiff-line-modified-added">+             Objects.checkFromToIndex(0, numIter + 1, mag.length);</span>
<span class="udiff-line-modified-added">+             Objects.checkFromToIndex(i, numIter + i + 1, newMag.length);</span>
<span class="udiff-line-modified-added">+             shiftLeftImplWorker(newMag, mag, i, nBits, numIter);</span>
<span class="udiff-line-added">+             newMag[numIter + i] = mag[numIter] &lt;&lt; nBits;</span>
          }
          return newMag;
      }
  
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="udiff-line-added">+     private static void shiftLeftImplWorker(int[] newArr, int[] oldArr, int newIdx, int shiftCount, int numIter) {</span>
<span class="udiff-line-added">+         int shiftCountRight = 32 - shiftCount;</span>
<span class="udiff-line-added">+         int oldIdx = 0;</span>
<span class="udiff-line-added">+         while (oldIdx &lt; numIter) {</span>
<span class="udiff-line-added">+             newArr[newIdx++] = (oldArr[oldIdx++] &lt;&lt; shiftCount) | (oldArr[oldIdx] &gt;&gt;&gt; shiftCountRight);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Returns a BigInteger whose value is {@code (this &gt;&gt; n)}.  Sign
       * extension is performed.  The shift distance, {@code n}, may be
       * negative, in which case this method performs a left shift.
       * (Computes &lt;code&gt;floor(this / 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt;.)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3413,15 +3416,14 @@</span>
                  newMag = new int[magLen - nInts];
                  newMag[i++] = highBits;
              } else {
                  newMag = new int[magLen - nInts -1];
              }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-             int nBits2 = 32 - nBits;</span>
<span class="udiff-line-modified-removed">-             int j=0;</span>
<span class="udiff-line-modified-removed">-             while (j &lt; magLen - nInts - 1)</span>
<span class="udiff-line-removed">-                 newMag[i++] = (mag[j++] &lt;&lt; nBits2) | (mag[j] &gt;&gt;&gt; nBits);</span>
<span class="udiff-line-modified-added">+             int numIter = magLen - nInts - 1;</span>
<span class="udiff-line-modified-added">+             Objects.checkFromToIndex(0, numIter + 1, mag.length);</span>
<span class="udiff-line-modified-added">+             Objects.checkFromToIndex(i, numIter + i, newMag.length);</span>
<span class="udiff-line-modified-added">+             shiftRightImplWorker(newMag, mag, i, nBits, numIter);</span>
          }
  
          if (signum &lt; 0) {
              // Find out whether any one-bits were shifted off the end.
              boolean onesLost = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3435,10 +3437,21 @@</span>
          }
  
          return new BigInteger(newMag, signum);
      }
  
<span class="udiff-line-added">+     @ForceInline</span>
<span class="udiff-line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="udiff-line-added">+     private static void shiftRightImplWorker(int[] newArr, int[] oldArr, int newIdx, int shiftCount, int numIter) {</span>
<span class="udiff-line-added">+         int shiftCountLeft = 32 - shiftCount;</span>
<span class="udiff-line-added">+         int idx = numIter;</span>
<span class="udiff-line-added">+         int nidx = (newIdx == 0) ? numIter - 1 : numIter;</span>
<span class="udiff-line-added">+         while (nidx &gt;= newIdx) {</span>
<span class="udiff-line-added">+             newArr[nidx--] = (oldArr[idx--] &gt;&gt;&gt; shiftCount) | (oldArr[idx] &lt;&lt; shiftCountLeft);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      int[] javaIncrement(int[] val) {
          int lastSum = 0;
          for (int i=val.length-1;  i &gt;= 0 &amp;&amp; lastSum == 0; i--)
              lastSum = (val[i] += 1);
          if (lastSum == 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4602,10 +4615,11 @@</span>
          }
          return fn;
      }
  
      /** use serialVersionUID from JDK 1.1. for interoperability */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private static final long serialVersionUID = -8287574255936472291L;
  
      /**
       * Serializable fields for BigInteger.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4620,10 +4634,11 @@</span>
       * @serialField firstNonzeroByteNum int
       *              appears in the serialized form for backward compatibility
       * @serialField lowestSetBit int
       *              appears in the serialized form for backward compatibility
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private static final ObjectStreamField[] serialPersistentFields = {
          new ObjectStreamField(&quot;signum&quot;, Integer.TYPE),
          new ObjectStreamField(&quot;magnitude&quot;, byte[].class),
          new ObjectStreamField(&quot;bitCount&quot;, Integer.TYPE),
          new ObjectStreamField(&quot;bitLength&quot;, Integer.TYPE),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4641,10 +4656,11 @@</span>
       * bitLengthPlusOne and lowestSetBitPlusTwo, to 0 rather than some other
       * marker value. Therefore, no explicit action to set these fields needs to
       * be taken in readObject because those fields already have a 0 value by
       * default since defaultReadObject is not being used.
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void readObject(java.io.ObjectInputStream s)
          throws java.io.IOException, ClassNotFoundException {
          // prepare to read the alternate persistent fields
          ObjectInputStream.GetField fields = s.readFields();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4707,10 +4723,11 @@</span>
       * {@code bitCount}, {@code bitLength}, {@code lowestSetBit}, and
       * {@code firstNonzeroByteNum}, respectively.  These values are compatible
       * with older implementations, but will be ignored by current
       * implementations.
       */
<span class="udiff-line-added">+     @java.io.Serial</span>
      private void writeObject(ObjectOutputStream s) throws IOException {
          // set the values of the Serializable fields
          ObjectOutputStream.PutField fields = s.putFields();
          fields.put(&quot;signum&quot;, signum);
          fields.put(&quot;magnitude&quot;, magSerializedForm());
</pre>
<center><a href="BigDecimal.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="MathContext.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
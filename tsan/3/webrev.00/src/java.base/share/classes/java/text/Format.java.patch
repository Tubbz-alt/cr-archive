diff a/src/java.base/share/classes/java/text/Format.java b/src/java.base/share/classes/java/text/Format.java
--- a/src/java.base/share/classes/java/text/Format.java
+++ b/src/java.base/share/classes/java/text/Format.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -39,68 +39,68 @@
 package java.text;
 
 import java.io.Serializable;
 
 /**
- * <code>Format</code> is an abstract base class for formatting locale-sensitive
+ * {@code Format} is an abstract base class for formatting locale-sensitive
  * information such as dates, messages, and numbers.
  *
  * <p>
- * <code>Format</code> defines the programming interface for formatting
- * locale-sensitive objects into <code>String</code>s (the
- * <code>format</code> method) and for parsing <code>String</code>s back
- * into objects (the <code>parseObject</code> method).
+ * {@code Format} defines the programming interface for formatting
+ * locale-sensitive objects into {@code String}s (the
+ * {@code format} method) and for parsing {@code String}s back
+ * into objects (the {@code parseObject} method).
  *
  * <p>
- * Generally, a format's <code>parseObject</code> method must be able to parse
- * any string formatted by its <code>format</code> method. However, there may
+ * Generally, a format's {@code parseObject} method must be able to parse
+ * any string formatted by its {@code format} method. However, there may
  * be exceptional cases where this is not possible. For example, a
- * <code>format</code> method might create two adjacent integer numbers with
- * no separator in between, and in this case the <code>parseObject</code> could
+ * {@code format} method might create two adjacent integer numbers with
+ * no separator in between, and in this case the {@code parseObject} could
  * not tell which digits belong to which number.
  *
- * <h3>Subclassing</h3>
+ * <h2>Subclassing</h2>
  *
  * <p>
- * The Java Platform provides three specialized subclasses of <code>Format</code>--
- * <code>DateFormat</code>, <code>MessageFormat</code>, and
- * <code>NumberFormat</code>--for formatting dates, messages, and numbers,
+ * The Java Platform provides three specialized subclasses of {@code Format}--
+ * {@code DateFormat}, {@code MessageFormat}, and
+ * {@code NumberFormat}--for formatting dates, messages, and numbers,
  * respectively.
  * <p>
  * Concrete subclasses must implement three methods:
  * <ol>
- * <li> <code>format(Object obj, StringBuffer toAppendTo, FieldPosition pos)</code>
- * <li> <code>formatToCharacterIterator(Object obj)</code>
- * <li> <code>parseObject(String source, ParsePosition pos)</code>
+ * <li> {@code format(Object obj, StringBuffer toAppendTo, FieldPosition pos)}
+ * <li> {@code formatToCharacterIterator(Object obj)}
+ * <li> {@code parseObject(String source, ParsePosition pos)}
  * </ol>
  * These general methods allow polymorphic parsing and formatting of objects
- * and are used, for example, by <code>MessageFormat</code>.
- * Subclasses often also provide additional <code>format</code> methods for
- * specific input types as well as <code>parse</code> methods for specific
- * result types. Any <code>parse</code> method that does not take a
- * <code>ParsePosition</code> argument should throw <code>ParseException</code>
+ * and are used, for example, by {@code MessageFormat}.
+ * Subclasses often also provide additional {@code format} methods for
+ * specific input types as well as {@code parse} methods for specific
+ * result types. Any {@code parse} method that does not take a
+ * {@code ParsePosition} argument should throw {@code ParseException}
  * when no text in the required format is at the beginning of the input text.
  *
  * <p>
  * Most subclasses will also implement the following factory methods:
  * <ol>
  * <li>
- * <code>getInstance</code> for getting a useful format object appropriate
+ * {@code getInstance} for getting a useful format object appropriate
  * for the current locale
  * <li>
- * <code>getInstance(Locale)</code> for getting a useful format
+ * {@code getInstance(Locale)} for getting a useful format
  * object appropriate for the specified locale
  * </ol>
  * In addition, some subclasses may also implement other
- * <code>getXxxxInstance</code> methods for more specialized control. For
- * example, the <code>NumberFormat</code> class provides
- * <code>getPercentInstance</code> and <code>getCurrencyInstance</code>
+ * {@code getXxxxInstance} methods for more specialized control. For
+ * example, the {@code NumberFormat} class provides
+ * {@code getPercentInstance} and {@code getCurrencyInstance}
  * methods for getting specialized number formatters.
  *
  * <p>
- * Subclasses of <code>Format</code> that allow programmers to create objects
- * for locales (with <code>getInstance(Locale)</code> for example)
+ * Subclasses of {@code Format} that allow programmers to create objects
+ * for locales (with {@code getInstance(Locale)} for example)
  * must also implement the following class method:
  * <blockquote>
  * <pre>
  * public static Locale[] getAvailableLocales()
  * </pre>
@@ -110,14 +110,14 @@
  * And finally subclasses may define a set of constants to identify the various
  * fields in the formatted output. These constants are used to create a FieldPosition
  * object which identifies what information is contained in the field and its
  * position in the formatted result. These constants should be named
  * <code><em>item</em>_FIELD</code> where <code><em>item</em></code> identifies
- * the field. For examples of these constants, see <code>ERA_FIELD</code> and its
+ * the field. For examples of these constants, see {@code ERA_FIELD} and its
  * friends in {@link DateFormat}.
  *
- * <h4><a id="synchronization">Synchronization</a></h4>
+ * <h3><a id="synchronization">Synchronization</a></h3>
  *
  * <p>
  * Formats are generally not synchronized.
  * It is recommended to create separate format instances for each thread.
  * If multiple threads access a format concurrently, it must be synchronized
@@ -131,10 +131,11 @@
  * @author       Mark Davis
  * @since 1.1
  */
 public abstract class Format implements Serializable, Cloneable {
 
+    @java.io.Serial
     private static final long serialVersionUID = -299282585814624189L;
 
     /**
      * Sole constructor.  (For invocation by subclass constructors, typically
      * implicit.)
@@ -149,57 +150,57 @@
      *         new StringBuffer(), new FieldPosition(0)).toString();</code>
      * </blockquote>
      *
      * @param obj    The object to format
      * @return       Formatted string.
-     * @exception IllegalArgumentException if the Format cannot format the given
+     * @throws    IllegalArgumentException if the Format cannot format the given
      *            object
      */
     public final String format (Object obj) {
         return format(obj, new StringBuffer(), new FieldPosition(0)).toString();
     }
 
     /**
      * Formats an object and appends the resulting text to a given string
      * buffer.
-     * If the <code>pos</code> argument identifies a field used by the format,
+     * If the {@code pos} argument identifies a field used by the format,
      * then its indices are set to the beginning and end of the first such
      * field encountered.
      *
      * @param obj    The object to format
      * @param toAppendTo    where the text is to be appended
-     * @param pos    A <code>FieldPosition</code> identifying a field
+     * @param pos    A {@code FieldPosition} identifying a field
      *               in the formatted text
-     * @return       the string buffer passed in as <code>toAppendTo</code>,
+     * @return       the string buffer passed in as {@code toAppendTo},
      *               with formatted text appended
-     * @exception NullPointerException if <code>toAppendTo</code> or
-     *            <code>pos</code> is null
-     * @exception IllegalArgumentException if the Format cannot format the given
+     * @throws    NullPointerException if {@code toAppendTo} or
+     *            {@code pos} is null
+     * @throws    IllegalArgumentException if the Format cannot format the given
      *            object
      */
     public abstract StringBuffer format(Object obj,
                     StringBuffer toAppendTo,
                     FieldPosition pos);
 
     /**
-     * Formats an Object producing an <code>AttributedCharacterIterator</code>.
-     * You can use the returned <code>AttributedCharacterIterator</code>
+     * Formats an Object producing an {@code AttributedCharacterIterator}.
+     * You can use the returned {@code AttributedCharacterIterator}
      * to build the resulting String, as well as to determine information
      * about the resulting String.
      * <p>
      * Each attribute key of the AttributedCharacterIterator will be of type
-     * <code>Field</code>. It is up to each <code>Format</code> implementation
+     * {@code Field}. It is up to each {@code Format} implementation
      * to define what the legal values are for each attribute in the
-     * <code>AttributedCharacterIterator</code>, but typically the attribute
+     * {@code AttributedCharacterIterator}, but typically the attribute
      * key is also used as the attribute value.
      * <p>The default implementation creates an
-     * <code>AttributedCharacterIterator</code> with no attributes. Subclasses
+     * {@code AttributedCharacterIterator} with no attributes. Subclasses
      * that support fields should override this and create an
-     * <code>AttributedCharacterIterator</code> with meaningful attributes.
+     * {@code AttributedCharacterIterator} with meaningful attributes.
      *
-     * @exception NullPointerException if obj is null.
-     * @exception IllegalArgumentException when the Format cannot format the
+     * @throws    NullPointerException if obj is null.
+     * @throws    IllegalArgumentException when the Format cannot format the
      *            given object.
      * @param obj The object to format
      * @return AttributedCharacterIterator describing the formatted value.
      * @since 1.4
      */
@@ -209,36 +210,36 @@
 
     /**
      * Parses text from a string to produce an object.
      * <p>
      * The method attempts to parse text starting at the index given by
-     * <code>pos</code>.
-     * If parsing succeeds, then the index of <code>pos</code> is updated
+     * {@code pos}.
+     * If parsing succeeds, then the index of {@code pos} is updated
      * to the index after the last character used (parsing does not necessarily
      * use all characters up to the end of the string), and the parsed
-     * object is returned. The updated <code>pos</code> can be used to
+     * object is returned. The updated {@code pos} can be used to
      * indicate the starting point for the next call to this method.
-     * If an error occurs, then the index of <code>pos</code> is not
-     * changed, the error index of <code>pos</code> is set to the index of
+     * If an error occurs, then the index of {@code pos} is not
+     * changed, the error index of {@code pos} is set to the index of
      * the character where the error occurred, and null is returned.
      *
-     * @param source A <code>String</code>, part of which should be parsed.
-     * @param pos A <code>ParsePosition</code> object with index and error
+     * @param source A {@code String}, part of which should be parsed.
+     * @param pos A {@code ParsePosition} object with index and error
      *            index information as described above.
-     * @return An <code>Object</code> parsed from the string. In case of
+     * @return An {@code Object} parsed from the string. In case of
      *         error, returns null.
      * @throws NullPointerException if {@code source} or {@code pos} is null.
      */
     public abstract Object parseObject (String source, ParsePosition pos);
 
     /**
      * Parses text from the beginning of the given string to produce an object.
      * The method may not use the entire text of the given string.
      *
-     * @param source A <code>String</code> whose beginning should be parsed.
-     * @return An <code>Object</code> parsed from the string.
-     * @exception ParseException if the beginning of the specified string
+     * @param source A {@code String} whose beginning should be parsed.
+     * @return An {@code Object} parsed from the string.
+     * @throws    ParseException if the beginning of the specified string
      *            cannot be parsed.
      * @throws NullPointerException if {@code source} is null.
      */
     public Object parseObject(String source) throws ParseException {
         ParsePosition pos = new ParsePosition(0);
@@ -268,12 +269,12 @@
     // Convenience methods for creating AttributedCharacterIterators from
     // different parameters.
     //
 
     /**
-     * Creates an <code>AttributedCharacterIterator</code> for the String
-     * <code>s</code>.
+     * Creates an {@code AttributedCharacterIterator} for the String
+     * {@code s}.
      *
      * @param s String to create AttributedCharacterIterator from
      * @return AttributedCharacterIterator wrapping s
      */
     AttributedCharacterIterator createAttributedCharacterIterator(String s) {
@@ -281,13 +282,13 @@
 
         return as.getIterator();
     }
 
     /**
-     * Creates an <code>AttributedCharacterIterator</code> containing the
+     * Creates an {@code AttributedCharacterIterator} containing the
      * concatenated contents of the passed in
-     * <code>AttributedCharacterIterator</code>s.
+     * {@code AttributedCharacterIterator}s.
      *
      * @param iterators AttributedCharacterIterators used to create resulting
      *                  AttributedCharacterIterators
      * @return AttributedCharacterIterator wrapping passed in
      *         AttributedCharacterIterators
@@ -299,12 +300,12 @@
         return as.getIterator();
     }
 
     /**
      * Returns an AttributedCharacterIterator with the String
-     * <code>string</code> and additional key/value pair <code>key</code>,
-     * <code>value</code>.
+     * {@code string} and additional key/value pair {@code key},
+     * {@code value}.
      *
      * @param string String to create AttributedCharacterIterator from
      * @param key Key for AttributedCharacterIterator
      * @param value Value associated with key in AttributedCharacterIterator
      * @return AttributedCharacterIterator wrapping args
@@ -318,12 +319,12 @@
         return as.getIterator();
     }
 
     /**
      * Creates an AttributedCharacterIterator with the contents of
-     * <code>iterator</code> and the additional attribute <code>key</code>
-     * <code>value</code>.
+     * {@code iterator} and the additional attribute {@code key}
+     * {@code value}.
      *
      * @param iterator Initial AttributedCharacterIterator to add arg to
      * @param key Key for AttributedCharacterIterator
      * @param value Value associated with key in AttributedCharacterIterator
      * @return AttributedCharacterIterator wrapping args
@@ -338,19 +339,20 @@
     }
 
 
     /**
      * Defines constants that are used as attribute keys in the
-     * <code>AttributedCharacterIterator</code> returned
-     * from <code>Format.formatToCharacterIterator</code> and as
-     * field identifiers in <code>FieldPosition</code>.
+     * {@code AttributedCharacterIterator} returned
+     * from {@code Format.formatToCharacterIterator} and as
+     * field identifiers in {@code FieldPosition}.
      *
      * @since 1.4
      */
     public static class Field extends AttributedCharacterIterator.Attribute {
 
         // Proclaim serial compatibility with 1.4 FCS
+        @java.io.Serial
         private static final long serialVersionUID = 276966692217360283L;
 
         /**
          * Creates a Field with the specified name.
          *
@@ -361,27 +363,27 @@
         }
     }
 
 
     /**
-     * FieldDelegate is notified by the various <code>Format</code>
+     * FieldDelegate is notified by the various {@code Format}
      * implementations as they are formatting the Objects. This allows for
      * storage of the individual sections of the formatted String for
-     * later use, such as in a <code>FieldPosition</code> or for an
-     * <code>AttributedCharacterIterator</code>.
+     * later use, such as in a {@code FieldPosition} or for an
+     * {@code AttributedCharacterIterator}.
      * <p>
-     * Delegates should NOT assume that the <code>Format</code> will notify
+     * Delegates should NOT assume that the {@code Format} will notify
      * the delegate of fields in any particular order.
      *
      * @see FieldPosition#getFieldDelegate
      * @see CharacterIteratorFieldDelegate
      */
     interface FieldDelegate {
         /**
          * Notified when a particular region of the String is formatted. This
          * method will be invoked if there is no corresponding integer field id
-         * matching <code>attr</code>.
+         * matching {@code attr}.
          *
          * @param attr Identifies the field matched
          * @param value Value associated with the field
          * @param start Beginning location of the field, will be >= 0
          * @param end End of the field, will be >= start and <= buffer.length()

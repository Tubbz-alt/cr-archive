<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/ObjectInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectInputFilter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectInputValidation.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/ObjectInputStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.io.ObjectStreamClass.WeakClassKey;

  29 import java.lang.System.Logger;

  30 import java.lang.ref.ReferenceQueue;
  31 import java.lang.reflect.Array;
  32 import java.lang.reflect.Modifier;
  33 import java.lang.reflect.Proxy;
  34 import java.security.AccessControlContext;
  35 import java.security.AccessController;
  36 import java.security.PrivilegedAction;
  37 import java.security.PrivilegedActionException;
  38 import java.security.PrivilegedExceptionAction;
  39 import java.util.Arrays;
  40 import java.util.Map;
  41 import java.util.Objects;
  42 import java.util.concurrent.ConcurrentHashMap;
  43 import java.util.concurrent.ConcurrentMap;
  44 
  45 import static java.io.ObjectStreamClass.processQueue;
  46 
  47 import jdk.internal.access.SharedSecrets;
  48 import jdk.internal.misc.Unsafe;
  49 import sun.reflect.misc.ReflectUtil;
</pre>
<hr />
<pre>
  57  * &quot;Serialization and Deserialization&quot; section of the
  58  * {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
  59  * {@extLink serialization_filter_guide Serialization Filtering} describes best
  60  * practices for defensive use of serial filters.
  61  * &lt;/strong&gt;&lt;/p&gt;
  62  *
  63  * &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
  64  * persistent storage for graphs of objects when used with a FileOutputStream
  65  * and FileInputStream respectively.  ObjectInputStream is used to recover
  66  * those objects previously serialized. Other uses include passing objects
  67  * between hosts using a socket stream or for marshaling and unmarshaling
  68  * arguments and parameters in a remote communication system.
  69  *
  70  * &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
  71  * created from the stream match the classes present in the Java Virtual
  72  * Machine.  Classes are loaded as required using the standard mechanisms.
  73  *
  74  * &lt;p&gt;Only objects that support the java.io.Serializable or
  75  * java.io.Externalizable interface can be read from streams.
  76  *
<span class="line-modified">  77  * &lt;p&gt;The method &lt;code&gt;readObject&lt;/code&gt; is used to read an object from the</span>
  78  * stream.  Java&#39;s safe casting should be used to get the desired type.  In
  79  * Java, strings and arrays are objects and are treated as objects during
  80  * serialization. When read they need to be cast to the expected type.
  81  *
  82  * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
  83  * method on DataInput.
  84  *
  85  * &lt;p&gt;The default deserialization mechanism for objects restores the contents
  86  * of each field to the value and type it had when it was written.  Fields
  87  * declared as transient or static are ignored by the deserialization process.
  88  * References to other objects cause those objects to be read from the stream
  89  * as necessary.  Graphs of objects are restored correctly using a reference
  90  * sharing mechanism.  New objects are always allocated when deserializing,
  91  * which prevents existing objects from being overwritten.
  92  *
  93  * &lt;p&gt;Reading an object is analogous to running the constructors of a new
  94  * object.  Memory is allocated for the object and initialized to zero (NULL).
  95  * No-arg constructors are invoked for the non-serializable classes and then
  96  * the fields of the serializable classes are restored from the stream starting
  97  * with the serializable class closest to java.lang.object and finishing with
</pre>
<hr />
<pre>
 140  * restored by reading data from the ObjectInputStream for the individual
 141  * fields and making assignments to the appropriate fields of the object.
 142  * Reading primitive data types is supported by DataInput.
 143  *
 144  * &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
 145  * custom data written by the corresponding writeObject method will cause an
 146  * OptionalDataException to be thrown with an eof field value of true.
 147  * Non-object reads which exceed the end of the allotted data will reflect the
 148  * end of data in the same way that they would indicate the end of the stream:
 149  * bytewise reads will return -1 as the byte read or number of bytes read, and
 150  * primitive reads will throw EOFExceptions.  If there is no corresponding
 151  * writeObject method, then the end of default serialized data marks the end of
 152  * the allotted data.
 153  *
 154  * &lt;p&gt;Primitive and object read calls issued from within a readExternal method
 155  * behave in the same manner--if the stream is already positioned at the end of
 156  * data written by the corresponding writeExternal method, object reads will
 157  * throw OptionalDataExceptions with eof set to true, bytewise reads will
 158  * return -1, and primitive reads will throw EOFExceptions.  Note that this
 159  * behavior does not hold for streams written with the old
<span class="line-modified"> 160  * &lt;code&gt;ObjectStreamConstants.PROTOCOL_VERSION_1&lt;/code&gt; protocol, in which the</span>
 161  * end of data written by writeExternal methods is not demarcated, and hence
 162  * cannot be detected.
 163  *
 164  * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
 165  * the object for its particular class in the event that the serialization
 166  * stream does not list the given class as a superclass of the object being
 167  * deserialized.  This may occur in cases where the receiving party uses a
 168  * different version of the deserialized instance&#39;s class than the sending
 169  * party, and the receiver&#39;s version extends classes that are not extended by
 170  * the sender&#39;s version.  This may also occur if the serialization stream has
 171  * been tampered; hence, readObjectNoData is useful for initializing
 172  * deserialized objects properly despite a &quot;hostile&quot; or incomplete source
 173  * stream.
 174  *
 175  * &lt;p&gt;Serialization does not read or assign values to the fields of any object
 176  * that does not implement the java.io.Serializable interface.  Subclasses of
 177  * Objects that are not serializable can be serializable. In this case the
 178  * non-serializable class must have a no-arg constructor to allow its fields to
 179  * be initialized.  In this case it is the responsibility of the subclass to
 180  * save and restore the state of the non-serializable class. It is frequently
</pre>
<hr />
<pre>
 191  * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) system-wide filter}
 192  * can be configured that is applied to each {@code ObjectInputStream} unless replaced
 193  * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.
 194  *
 195  * &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
 196  * the ObjectInputStream and abort the reading process.
 197  *
 198  * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 199  * complete control over the contents and format of the object&#39;s serialized
 200  * form.  The methods of the Externalizable interface, writeExternal and
 201  * readExternal, are called to save and restore the objects state.  When
 202  * implemented by a class they can write and read their own state using all of
 203  * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 204  * the objects to handle any versioning that occurs.
 205  *
 206  * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
 207  * externalizable objects.  The serialized form of an enum constant consists
 208  * solely of its name; field values of the constant are not transmitted.  To
 209  * deserialize an enum constant, ObjectInputStream reads the constant name from
 210  * the stream; the deserialized constant is then obtained by calling the static
<span class="line-modified"> 211  * method &lt;code&gt;Enum.valueOf(Class, String)&lt;/code&gt; with the enum constant&#39;s</span>
 212  * base type and the received constant name as arguments.  Like other
 213  * serializable or externalizable objects, enum constants can function as the
 214  * targets of back references appearing subsequently in the serialization
 215  * stream.  The process by which enum constants are deserialized cannot be
 216  * customized: any class-specific readObject, readObjectNoData, and readResolve
 217  * methods defined by enum types are ignored during deserialization.
 218  * Similarly, any serialPersistentFields or serialVersionUID field declarations
 219  * are also ignored--all enum types have a fixed serialVersionUID of 0L.
 220  *

































 221  * @author      Mike Warres
 222  * @author      Roger Riggs
 223  * @see java.io.DataInput
 224  * @see java.io.ObjectOutputStream
 225  * @see java.io.Serializable
 226  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/input.html&quot;&gt;
 227  *     Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;
 228  * @since   1.1
 229  */
 230 public class ObjectInputStream
 231     extends InputStream implements ObjectInput, ObjectStreamConstants
 232 {
 233     /** handle value representing null */
 234     private static final int NULL_HANDLE = -1;
 235 
 236     /** marker for unshared objects in internal handle table */
 237     private static final Object unsharedMarker = new Object();
 238 
 239     /**
 240      * immutable table mapping primitive type names to corresponding
</pre>
<hr />
<pre>
 318     /**
 319      * Creates an ObjectInputStream that reads from the specified InputStream.
 320      * A serialization stream header is read from the stream and verified.
 321      * This constructor will block until the corresponding ObjectOutputStream
 322      * has written and flushed the header.
 323      *
 324      * &lt;p&gt;The serialization filter is initialized to the value of
 325      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 326      *
 327      * &lt;p&gt;If a security manager is installed, this constructor will check for
 328      * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 329      * directly or indirectly by the constructor of a subclass which overrides
 330      * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
 331      * methods.
 332      *
 333      * @param   in input stream to read from
 334      * @throws  StreamCorruptedException if the stream header is incorrect
 335      * @throws  IOException if an I/O error occurs while reading stream header
 336      * @throws  SecurityException if untrusted subclass illegally overrides
 337      *          security-sensitive methods
<span class="line-modified"> 338      * @throws  NullPointerException if &lt;code&gt;in&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</span>
 339      * @see     ObjectInputStream#ObjectInputStream()
 340      * @see     ObjectInputStream#readFields()
 341      * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
 342      */
 343     public ObjectInputStream(InputStream in) throws IOException {
 344         verifySubclass();
 345         bin = new BlockDataInputStream(in);
 346         handles = new HandleTable(10);
 347         vlist = new ValidationList();
 348         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 349         enableOverride = false;
 350         readStreamHeader();
 351         bin.setBlockDataMode(true);
 352     }
 353 
 354     /**
 355      * Provide a way for subclasses that are completely reimplementing
 356      * ObjectInputStream to not have to allocate private data just used by this
 357      * implementation of ObjectInputStream.
 358      *
 359      * &lt;p&gt;The serialization filter is initialized to the value of
 360      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 361      *
 362      * &lt;p&gt;If there is a security manager installed, this method first calls the
<span class="line-modified"> 363      * security manager&#39;s &lt;code&gt;checkPermission&lt;/code&gt; method with the</span>
<span class="line-modified"> 364      * &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;</span>
 365      * permission to ensure it&#39;s ok to enable subclassing.
 366      *
 367      * @throws  SecurityException if a security manager exists and its
<span class="line-modified"> 368      *          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling</span>
 369      *          subclassing.
 370      * @throws  IOException if an I/O error occurs while creating this stream
 371      * @see SecurityManager#checkPermission
 372      * @see java.io.SerializablePermission
 373      */
 374     protected ObjectInputStream() throws IOException, SecurityException {
 375         SecurityManager sm = System.getSecurityManager();
 376         if (sm != null) {
 377             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 378         }
 379         bin = null;
 380         handles = null;
 381         vlist = null;
 382         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 383         enableOverride = true;
 384     }
 385 
 386     /**
 387      * Read an object from the ObjectInputStream.  The class of the object, the
 388      * signature of the class, and the values of the non-transient and
</pre>
<hr />
<pre>
 401      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 402      * each object (regular or class) read to reconstruct the root object.
 403      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 404      *
 405      * &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
 406      * classes that should not be deserialized.  All exceptions are fatal to
 407      * the InputStream and leave it in an indeterminate state; it is up to the
 408      * caller to ignore or recover the stream state.
 409      *
 410      * @throws  ClassNotFoundException Class of a serialized object cannot be
 411      *          found.
 412      * @throws  InvalidClassException Something is wrong with a class used by
 413      *          serialization.
 414      * @throws  StreamCorruptedException Control information in the
 415      *          stream is inconsistent.
 416      * @throws  OptionalDataException Primitive data was found in the
 417      *          stream instead of objects.
 418      * @throws  IOException Any of the usual Input/Output related exceptions.
 419      */
 420     public final Object readObject()































 421         throws IOException, ClassNotFoundException
 422     {
 423         if (enableOverride) {
 424             return readObjectOverride();
 425         }
 426 



 427         // if nested read, passHandle contains handle of enclosing object
 428         int outerHandle = passHandle;
 429         try {
<span class="line-modified"> 430             Object obj = readObject0(false);</span>
 431             handles.markDependency(outerHandle, passHandle);
 432             ClassNotFoundException ex = handles.lookupException(passHandle);
 433             if (ex != null) {
 434                 throw ex;
 435             }
 436             if (depth == 0) {
 437                 vlist.doCallbacks();
 438                 freeze();
 439             }
 440             return obj;
 441         } finally {
 442             passHandle = outerHandle;
 443             if (closed &amp;&amp; depth == 0) {
 444                 clear();
 445             }
 446         }
 447     }
 448 
 449     /**
<span class="line-modified"> 450      * This method is called by trusted subclasses of ObjectOutputStream that</span>
<span class="line-modified"> 451      * constructed ObjectOutputStream using the protected no-arg constructor.</span>
 452      * The subclass is expected to provide an override method with the modifier
 453      * &quot;final&quot;.
 454      *
 455      * @return  the Object read from the stream.
 456      * @throws  ClassNotFoundException Class definition of a serialized object
 457      *          cannot be found.
 458      * @throws  OptionalDataException Primitive data was found in the stream
 459      *          instead of objects.
 460      * @throws  IOException if I/O errors occurred while reading from the
 461      *          underlying stream
 462      * @see #ObjectInputStream()
 463      * @see #readObject()
 464      * @since 1.2
 465      */
 466     protected Object readObjectOverride()
 467         throws IOException, ClassNotFoundException
 468     {
 469         return null;
 470     }
 471 
</pre>
<hr />
<pre>
 505      * constructed in security contexts possessing the
 506      * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
 507      * instantiate such a subclass without this permission will cause a
 508      * SecurityException to be thrown.
 509      *
 510      * @return  reference to deserialized object
 511      * @throws  ClassNotFoundException if class of an object to deserialize
 512      *          cannot be found
 513      * @throws  StreamCorruptedException if control information in the stream
 514      *          is inconsistent
 515      * @throws  ObjectStreamException if object to deserialize has already
 516      *          appeared in stream
 517      * @throws  OptionalDataException if primitive data is next in stream
 518      * @throws  IOException if an I/O error occurs during deserialization
 519      * @since   1.4
 520      */
 521     public Object readUnshared() throws IOException, ClassNotFoundException {
 522         // if nested read, passHandle contains handle of enclosing object
 523         int outerHandle = passHandle;
 524         try {
<span class="line-modified"> 525             Object obj = readObject0(true);</span>
 526             handles.markDependency(outerHandle, passHandle);
 527             ClassNotFoundException ex = handles.lookupException(passHandle);
 528             if (ex != null) {
 529                 throw ex;
 530             }
 531             if (depth == 0) {
 532                 vlist.doCallbacks();
 533                 freeze();
 534             }
 535             return obj;
 536         } finally {
 537             passHandle = outerHandle;
 538             if (closed &amp;&amp; depth == 0) {
 539                 clear();
 540             }
 541         }
 542     }
 543 
 544     /**
 545      * Read the non-static and non-transient fields of the current class from
</pre>
<hr />
<pre>
 570         }
 571         bin.setBlockDataMode(true);
 572         if (!curDesc.hasWriteObjectData()) {
 573             /*
 574              * Fix for 4360508: since stream does not contain terminating
 575              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 576              * knows to simulate end-of-custom-data behavior.
 577              */
 578             defaultDataEnd = true;
 579         }
 580         ClassNotFoundException ex = handles.lookupException(passHandle);
 581         if (ex != null) {
 582             throw ex;
 583         }
 584     }
 585 
 586     /**
 587      * Reads the persistent fields from the stream and makes them available by
 588      * name.
 589      *
<span class="line-modified"> 590      * @return  the &lt;code&gt;GetField&lt;/code&gt; object representing the persistent</span>
 591      *          fields of the object being deserialized
 592      * @throws  ClassNotFoundException if the class of a serialized object
 593      *          could not be found.
 594      * @throws  IOException if an I/O error occurs.
 595      * @throws  NotActiveException if the stream is not currently reading
 596      *          objects.
 597      * @since 1.2
 598      */
 599     public ObjectInputStream.GetField readFields()
 600         throws IOException, ClassNotFoundException
 601     {
 602         SerialCallbackContext ctx = curContext;
 603         if (ctx == null) {
 604             throw new NotActiveException(&quot;not in call to readObject&quot;);
 605         }
 606         ctx.checkAndSetUsed();
 607         ObjectStreamClass curDesc = ctx.getDesc();
 608         bin.setBlockDataMode(false);
 609         GetFieldImpl getField = new GetFieldImpl(curDesc);
 610         getField.readFields();
</pre>
<hr />
<pre>
 634      *          later callbacks. Within a priority, callbacks are processed in
 635      *          no particular order.
 636      * @throws  NotActiveException The stream is not currently reading objects
 637      *          so it is invalid to register a callback.
 638      * @throws  InvalidObjectException The validation object is null.
 639      */
 640     public void registerValidation(ObjectInputValidation obj, int prio)
 641         throws NotActiveException, InvalidObjectException
 642     {
 643         if (depth == 0) {
 644             throw new NotActiveException(&quot;stream inactive&quot;);
 645         }
 646         vlist.register(obj, prio);
 647     }
 648 
 649     /**
 650      * Load the local class equivalent of the specified stream class
 651      * description.  Subclasses may implement this method to allow classes to
 652      * be fetched from an alternate source.
 653      *
<span class="line-modified"> 654      * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is</span>
<span class="line-modified"> 655      * &lt;code&gt;annotateClass&lt;/code&gt;.  This method will be invoked only once for</span>
 656      * each unique class in the stream.  This method can be implemented by
 657      * subclasses to use an alternate loading mechanism but must return a
<span class="line-modified"> 658      * &lt;code&gt;Class&lt;/code&gt; object. Once returned, if the class is not an array</span>
 659      * class, its serialVersionUID is compared to the serialVersionUID of the
 660      * serialized class, and if there is a mismatch, the deserialization fails
 661      * and an {@link InvalidClassException} is thrown.
 662      *
 663      * &lt;p&gt;The default implementation of this method in
<span class="line-modified"> 664      * &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling</span>
 665      * &lt;pre&gt;
 666      *     Class.forName(desc.getName(), false, loader)
 667      * &lt;/pre&gt;
<span class="line-modified"> 668      * where &lt;code&gt;loader&lt;/code&gt; is the first class loader on the current</span>
 669      * thread&#39;s stack (starting from the currently executing method) that is
 670      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<span class="line-modified"> 671      * class loader} nor its ancestor; otherwise, &lt;code&gt;loader&lt;/code&gt; is the</span>
 672      * &lt;em&gt;platform class loader&lt;/em&gt;. If this call results in a
<span class="line-modified"> 673      * &lt;code&gt;ClassNotFoundException&lt;/code&gt; and the name of the passed</span>
<span class="line-modified"> 674      * &lt;code&gt;ObjectStreamClass&lt;/code&gt; instance is the Java language keyword</span>
<span class="line-modified"> 675      * for a primitive type or void, then the &lt;code&gt;Class&lt;/code&gt; object</span>
 676      * representing that primitive type or void will be returned
<span class="line-modified"> 677      * (e.g., an &lt;code&gt;ObjectStreamClass&lt;/code&gt; with the name</span>
<span class="line-modified"> 678      * &lt;code&gt;&quot;int&quot;&lt;/code&gt; will be resolved to &lt;code&gt;Integer.TYPE&lt;/code&gt;).</span>
<span class="line-modified"> 679      * Otherwise, the &lt;code&gt;ClassNotFoundException&lt;/code&gt; will be thrown to</span>
 680      * the caller of this method.
 681      *
<span class="line-modified"> 682      * @param   desc an instance of class &lt;code&gt;ObjectStreamClass&lt;/code&gt;</span>
<span class="line-modified"> 683      * @return  a &lt;code&gt;Class&lt;/code&gt; object corresponding to &lt;code&gt;desc&lt;/code&gt;</span>
 684      * @throws  IOException any of the usual Input/Output exceptions.
 685      * @throws  ClassNotFoundException if class of a serialized object cannot
 686      *          be found.
 687      */
 688     protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
 689         throws IOException, ClassNotFoundException
 690     {
 691         String name = desc.getName();
 692         try {
 693             return Class.forName(name, false, latestUserDefinedLoader());
 694         } catch (ClassNotFoundException ex) {
 695             Class&lt;?&gt; cl = primClasses.get(name);
 696             if (cl != null) {
 697                 return cl;
 698             } else {
 699                 throw ex;
 700             }
 701         }
 702     }
 703 
 704     /**
 705      * Returns a proxy class that implements the interfaces named in a proxy
 706      * class descriptor; subclasses may implement this method to read custom
 707      * data from the stream along with the descriptors for dynamic proxy
 708      * classes, allowing them to use an alternate loading mechanism for the
 709      * interfaces and the proxy class.
 710      *
 711      * &lt;p&gt;This method is called exactly once for each unique proxy class
 712      * descriptor in the stream.
 713      *
<span class="line-modified"> 714      * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is</span>
<span class="line-modified"> 715      * &lt;code&gt;annotateProxyClass&lt;/code&gt;.  For a given subclass of</span>
<span class="line-modified"> 716      * &lt;code&gt;ObjectInputStream&lt;/code&gt; that overrides this method, the</span>
<span class="line-modified"> 717      * &lt;code&gt;annotateProxyClass&lt;/code&gt; method in the corresponding subclass of</span>
<span class="line-modified"> 718      * &lt;code&gt;ObjectOutputStream&lt;/code&gt; must write any data or objects read by</span>
 719      * this method.
 720      *
 721      * &lt;p&gt;The default implementation of this method in
<span class="line-modified"> 722      * &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling</span>
<span class="line-modified"> 723      * &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; with the list of &lt;code&gt;Class&lt;/code&gt;</span>
<span class="line-modified"> 724      * objects for the interfaces that are named in the &lt;code&gt;interfaces&lt;/code&gt;</span>
<span class="line-modified"> 725      * parameter.  The &lt;code&gt;Class&lt;/code&gt; object for each interface name</span>
<span class="line-modified"> 726      * &lt;code&gt;i&lt;/code&gt; is the value returned by calling</span>
 727      * &lt;pre&gt;
 728      *     Class.forName(i, false, loader)
 729      * &lt;/pre&gt;
<span class="line-modified"> 730      * where &lt;code&gt;loader&lt;/code&gt; is the first class loader on the current</span>
 731      * thread&#39;s stack (starting from the currently executing method) that is
 732      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<span class="line-modified"> 733      * class loader} nor its ancestor; otherwise, &lt;code&gt;loader&lt;/code&gt; is the</span>
 734      * &lt;em&gt;platform class loader&lt;/em&gt;.
 735      * Unless any of the resolved interfaces are non-public, this same value
<span class="line-modified"> 736      * of &lt;code&gt;loader&lt;/code&gt; is also the class loader passed to</span>
<span class="line-modified"> 737      * &lt;code&gt;Proxy.getProxyClass&lt;/code&gt;; if non-public interfaces are present,</span>
 738      * their class loader is passed instead (if more than one non-public
 739      * interface class loader is encountered, an
<span class="line-modified"> 740      * &lt;code&gt;IllegalAccessError&lt;/code&gt; is thrown).</span>
<span class="line-modified"> 741      * If &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; throws an</span>
<span class="line-modified"> 742      * &lt;code&gt;IllegalArgumentException&lt;/code&gt;, &lt;code&gt;resolveProxyClass&lt;/code&gt;</span>
<span class="line-modified"> 743      * will throw a &lt;code&gt;ClassNotFoundException&lt;/code&gt; containing the</span>
<span class="line-modified"> 744      * &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</span>
 745      *
 746      * @param interfaces the list of interface names that were
 747      *                deserialized in the proxy class descriptor
 748      * @return  a proxy class for the specified interfaces
 749      * @throws        IOException any exception thrown by the underlying
<span class="line-modified"> 750      *                &lt;code&gt;InputStream&lt;/code&gt;</span>
 751      * @throws        ClassNotFoundException if the proxy class or any of the
 752      *                named interfaces could not be found
 753      * @see ObjectOutputStream#annotateProxyClass(Class)
 754      * @since 1.3
 755      */
 756     protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)
 757         throws IOException, ClassNotFoundException
 758     {
 759         ClassLoader latestLoader = latestUserDefinedLoader();
 760         ClassLoader nonPublicLoader = null;
 761         boolean hasNonPublicInterface = false;
 762 
 763         // define proxy in class loader of non-public interface(s), if any
 764         Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];
 765         for (int i = 0; i &lt; interfaces.length; i++) {
 766             Class&lt;?&gt; cl = Class.forName(interfaces[i], false, latestLoader);
 767             if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {
 768                 if (hasNonPublicInterface) {
 769                     if (nonPublicLoader != cl.getClassLoader()) {
 770                         throw new IllegalAccessError(
</pre>
<hr />
<pre>
 846     {
 847         if (enable == enableResolve) {
 848             return enable;
 849         }
 850         if (enable) {
 851             SecurityManager sm = System.getSecurityManager();
 852             if (sm != null) {
 853                 sm.checkPermission(SUBSTITUTION_PERMISSION);
 854             }
 855         }
 856         enableResolve = enable;
 857         return !enableResolve;
 858     }
 859 
 860     /**
 861      * The readStreamHeader method is provided to allow subclasses to read and
 862      * verify their own stream headers. It reads and verifies the magic number
 863      * and version number.
 864      *
 865      * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified"> 866      *          underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
 867      * @throws  StreamCorruptedException if control information in the stream
 868      *          is inconsistent
 869      */
 870     protected void readStreamHeader()
 871         throws IOException, StreamCorruptedException
 872     {
 873         short s0 = bin.readShort();
 874         short s1 = bin.readShort();
 875         if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
 876             throw new StreamCorruptedException(
 877                 String.format(&quot;invalid stream header: %04X%04X&quot;, s0, s1));
 878         }
 879     }
 880 
 881     /**
 882      * Read a class descriptor from the serialization stream.  This method is
 883      * called when the ObjectInputStream expects a class descriptor as the next
 884      * item in the serialization stream.  Subclasses of ObjectInputStream may
 885      * override this method to read in class descriptors that have been written
 886      * in non-standard formats (by subclasses of ObjectOutputStream which have
<span class="line-modified"> 887      * overridden the &lt;code&gt;writeClassDescriptor&lt;/code&gt; method).  By default,</span>
 888      * this method reads class descriptors according to the format defined in
 889      * the Object Serialization specification.
 890      *
 891      * @return  the class descriptor read
 892      * @throws  IOException If an I/O error has occurred.
 893      * @throws  ClassNotFoundException If the Class of a serialized object used
 894      *          in the class descriptor representation cannot be found
 895      * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
 896      * @since 1.3
 897      */
 898     protected ObjectStreamClass readClassDescriptor()
 899         throws IOException, ClassNotFoundException
 900     {
 901         ObjectStreamClass desc = new ObjectStreamClass();
 902         desc.readNonProxy(this);
 903         return desc;
 904     }
 905 
 906     /**
 907      * Reads a byte of data. This method will block if no input is available.
</pre>
<hr />
<pre>
 929      *          {@code buf.length - off}.
 930      * @throws  IOException If an I/O error has occurred.
 931      * @see java.io.DataInputStream#readFully(byte[],int,int)
 932      */
 933     public int read(byte[] buf, int off, int len) throws IOException {
 934         if (buf == null) {
 935             throw new NullPointerException();
 936         }
 937         int endoff = off + len;
 938         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
 939             throw new IndexOutOfBoundsException();
 940         }
 941         return bin.read(buf, off, len, false);
 942     }
 943 
 944     /**
 945      * Returns the number of bytes that can be read without blocking.
 946      *
 947      * @return  the number of available bytes.
 948      * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified"> 949      *          underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
 950      */
 951     public int available() throws IOException {
 952         return bin.available();
 953     }
 954 
 955     /**
 956      * Closes the input stream. Must be called to release any resources
 957      * associated with the stream.
 958      *
 959      * @throws  IOException If an I/O error has occurred.
 960      */
 961     public void close() throws IOException {
 962         /*
 963          * Even if stream already closed, propagate redundant close to
 964          * underlying stream to stay consistent with previous implementations.
 965          */
 966         closed = true;
 967         if (depth == 0) {
 968             clear();
 969         }
</pre>
<hr />
<pre>
1112         }
1113         bin.readFully(buf, off, len, false);
1114     }
1115 
1116     /**
1117      * Skips bytes.
1118      *
1119      * @param   len the number of bytes to be skipped
1120      * @return  the actual number of bytes skipped.
1121      * @throws  IOException If an I/O error has occurred.
1122      */
1123     public int skipBytes(int len) throws IOException {
1124         return bin.skipBytes(len);
1125     }
1126 
1127     /**
1128      * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
1129      *
1130      * @return  a String copy of the line.
1131      * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">1132      *          underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
1133      * @deprecated This method does not properly convert bytes to characters.
1134      *          see DataInputStream for the details and alternatives.
1135      */
1136     @Deprecated
1137     public String readLine() throws IOException {
1138         return bin.readLine();
1139     }
1140 
1141     /**
1142      * Reads a String in
1143      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
1144      * format.
1145      *
1146      * @return  the String.
1147      * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">1148      *          underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
1149      * @throws  UTFDataFormatException if read bytes do not represent a valid
1150      *          modified UTF-8 encoding of a string
1151      */
1152     public String readUTF() throws IOException {
1153         return bin.readUTF();
1154     }
1155 
1156     /**
1157      * Returns the serialization filter for this stream.
1158      * The serialization filter is the most recent filter set in
1159      * {@link #setObjectInputFilter setObjectInputFilter} or
1160      * the initial system-wide filter from
1161      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.
1162      *
1163      * @return the serialization filter for the stream; may be null
1164      * @since 9
1165      */
1166     public final ObjectInputFilter getObjectInputFilter() {
1167         return serialFilter;
1168     }
</pre>
<hr />
<pre>
1304      * @throws IllegalArgumentException if arrayType isn&#39;t actually an array type
1305      * @throws NegativeArraySizeException if arrayLength is negative
1306      * @throws InvalidClassException if the filter rejects creation
1307      */
1308     private void checkArray(Class&lt;?&gt; arrayType, int arrayLength) throws InvalidClassException {
1309         if (! arrayType.isArray()) {
1310             throw new IllegalArgumentException(&quot;not an array type&quot;);
1311         }
1312 
1313         if (arrayLength &lt; 0) {
1314             throw new NegativeArraySizeException();
1315         }
1316 
1317         filterCheck(arrayType, arrayLength);
1318     }
1319 
1320     /**
1321      * Provide access to the persistent fields read from the input stream.
1322      */
1323     public abstract static class GetField {




1324 
1325         /**
1326          * Get the ObjectStreamClass that describes the fields in the stream.
1327          *
1328          * @return  the descriptor class that describes the serializable fields
1329          */
1330         public abstract ObjectStreamClass getObjectStreamClass();
1331 
1332         /**
1333          * Return true if the named field is defaulted and has no value in this
1334          * stream.
1335          *
1336          * @param  name the name of the field
1337          * @return true, if and only if the named field is defaulted
1338          * @throws IOException if there are I/O errors while reading from
<span class="line-modified">1339          *         the underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1340          * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not</span>
1341          *         correspond to a serializable field
1342          */
1343         public abstract boolean defaulted(String name) throws IOException;
1344 
1345         /**
1346          * Get the value of the named boolean field from the persistent field.
1347          *
1348          * @param  name the name of the field
<span class="line-modified">1349          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
1350          *         have a value
<span class="line-modified">1351          * @return the value of the named &lt;code&gt;boolean&lt;/code&gt; field</span>
1352          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1353          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1354          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
1355          *         not serializable or if the field type is incorrect
1356          */
1357         public abstract boolean get(String name, boolean val)
1358             throws IOException;
1359 
1360         /**
1361          * Get the value of the named byte field from the persistent field.
1362          *
1363          * @param  name the name of the field
<span class="line-modified">1364          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
1365          *         have a value
<span class="line-modified">1366          * @return the value of the named &lt;code&gt;byte&lt;/code&gt; field</span>
1367          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1368          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1369          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
1370          *         not serializable or if the field type is incorrect
1371          */
1372         public abstract byte get(String name, byte val) throws IOException;
1373 
1374         /**
1375          * Get the value of the named char field from the persistent field.
1376          *
1377          * @param  name the name of the field
<span class="line-modified">1378          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
1379          *         have a value
<span class="line-modified">1380          * @return the value of the named &lt;code&gt;char&lt;/code&gt; field</span>
1381          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1382          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1383          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
1384          *         not serializable or if the field type is incorrect
1385          */
1386         public abstract char get(String name, char val) throws IOException;
1387 
1388         /**
1389          * Get the value of the named short field from the persistent field.
1390          *
1391          * @param  name the name of the field
<span class="line-modified">1392          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
1393          *         have a value
<span class="line-modified">1394          * @return the value of the named &lt;code&gt;short&lt;/code&gt; field</span>
1395          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1396          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1397          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
1398          *         not serializable or if the field type is incorrect
1399          */
1400         public abstract short get(String name, short val) throws IOException;
1401 
1402         /**
1403          * Get the value of the named int field from the persistent field.
1404          *
1405          * @param  name the name of the field
<span class="line-modified">1406          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
1407          *         have a value
<span class="line-modified">1408          * @return the value of the named &lt;code&gt;int&lt;/code&gt; field</span>
1409          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1410          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1411          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
1412          *         not serializable or if the field type is incorrect
1413          */
1414         public abstract int get(String name, int val) throws IOException;
1415 
1416         /**
1417          * Get the value of the named long field from the persistent field.
1418          *
1419          * @param  name the name of the field
<span class="line-modified">1420          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
1421          *         have a value
<span class="line-modified">1422          * @return the value of the named &lt;code&gt;long&lt;/code&gt; field</span>
1423          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1424          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1425          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
1426          *         not serializable or if the field type is incorrect
1427          */
1428         public abstract long get(String name, long val) throws IOException;
1429 
1430         /**
1431          * Get the value of the named float field from the persistent field.
1432          *
1433          * @param  name the name of the field
<span class="line-modified">1434          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
1435          *         have a value
<span class="line-modified">1436          * @return the value of the named &lt;code&gt;float&lt;/code&gt; field</span>
1437          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1438          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1439          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
1440          *         not serializable or if the field type is incorrect
1441          */
1442         public abstract float get(String name, float val) throws IOException;
1443 
1444         /**
1445          * Get the value of the named double field from the persistent field.
1446          *
1447          * @param  name the name of the field
<span class="line-modified">1448          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
1449          *         have a value
<span class="line-modified">1450          * @return the value of the named &lt;code&gt;double&lt;/code&gt; field</span>
1451          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1452          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1453          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
1454          *         not serializable or if the field type is incorrect
1455          */
1456         public abstract double get(String name, double val) throws IOException;
1457 
1458         /**
1459          * Get the value of the named Object field from the persistent field.
1460          *
1461          * @param  name the name of the field
<span class="line-modified">1462          * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</span>
1463          *         have a value
<span class="line-modified">1464          * @return the value of the named &lt;code&gt;Object&lt;/code&gt; field</span>
1465          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1466          *         underlying &lt;code&gt;InputStream&lt;/code&gt;</span>
<span class="line-modified">1467          * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is</span>
1468          *         not serializable or if the field type is incorrect
1469          */
1470         public abstract Object get(String name, Object val) throws IOException;
1471     }
1472 
1473     /**
1474      * Verifies that this (possibly subclass) instance can be constructed
1475      * without violating security constraints: the subclass must not override
1476      * security-sensitive non-final methods, or else the
1477      * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.
1478      */
1479     private void verifySubclass() {
1480         Class&lt;?&gt; cl = getClass();
1481         if (cl == ObjectInputStream.class) {
1482             return;
1483         }
1484         SecurityManager sm = System.getSecurityManager();
1485         if (sm == null) {
1486             return;
1487         }
</pre>
<hr />
<pre>
1521                             return Boolean.FALSE;
1522                         } catch (NoSuchMethodException ex) {
1523                         }
1524                     }
1525                     return Boolean.TRUE;
1526                 }
1527             }
1528         );
1529     }
1530 
1531     /**
1532      * Clears internal data structures.
1533      */
1534     private void clear() {
1535         handles.clear();
1536         vlist.clear();
1537     }
1538 
1539     /**
1540      * Underlying readObject implementation.


1541      */
<span class="line-modified">1542     private Object readObject0(boolean unshared) throws IOException {</span>
1543         boolean oldMode = bin.getBlockDataMode();
1544         if (oldMode) {
1545             int remain = bin.currentBlockRemaining();
1546             if (remain &gt; 0) {
1547                 throw new OptionalDataException(remain);
1548             } else if (defaultDataEnd) {
1549                 /*
1550                  * Fix for 4360508: stream is currently at the end of a field
1551                  * value block written via default serialization; since there
1552                  * is no terminating TC_ENDBLOCKDATA tag, simulate
1553                  * end-of-custom-data behavior explicitly.
1554                  */
1555                 throw new OptionalDataException(true);
1556             }
1557             bin.setBlockDataMode(false);
1558         }
1559 
1560         byte tc;
1561         while ((tc = bin.peekByte()) == TC_RESET) {
1562             bin.readByte();
1563             handleReset();
1564         }
1565 
1566         depth++;
1567         totalObjectRefs++;
1568         try {
1569             switch (tc) {
1570                 case TC_NULL:
1571                     return readNull();
1572 
1573                 case TC_REFERENCE:
<span class="line-modified">1574                     return readHandle(unshared);</span>

1575 
1576                 case TC_CLASS:



1577                     return readClass(unshared);
1578 
1579                 case TC_CLASSDESC:
1580                 case TC_PROXYCLASSDESC:



1581                     return readClassDesc(unshared);
1582 
1583                 case TC_STRING:
1584                 case TC_LONGSTRING:
1585                     return checkResolve(readString(unshared));
1586 
1587                 case TC_ARRAY:



1588                     return checkResolve(readArray(unshared));
1589 
1590                 case TC_ENUM:



1591                     return checkResolve(readEnum(unshared));
1592 
1593                 case TC_OBJECT:



1594                     return checkResolve(readOrdinaryObject(unshared));
1595 
1596                 case TC_EXCEPTION:



1597                     IOException ex = readFatalException();
1598                     throw new WriteAbortedException(&quot;writing aborted&quot;, ex);
1599 
1600                 case TC_BLOCKDATA:
1601                 case TC_BLOCKDATALONG:
1602                     if (oldMode) {
1603                         bin.setBlockDataMode(true);
1604                         bin.peek();             // force header read
1605                         throw new OptionalDataException(
1606                             bin.currentBlockRemaining());
1607                     } else {
1608                         throw new StreamCorruptedException(
1609                             &quot;unexpected block data&quot;);
1610                     }
1611 
1612                 case TC_ENDBLOCKDATA:
1613                     if (oldMode) {
1614                         throw new OptionalDataException(true);
1615                     } else {
1616                         throw new StreamCorruptedException(
</pre>
<hr />
<pre>
1948         ObjectStreamClass desc = readClassDesc(false);
1949         int len = bin.readInt();
1950 
1951         filterCheck(desc.forClass(), len);
1952 
1953         Object array = null;
1954         Class&lt;?&gt; cl, ccl = null;
1955         if ((cl = desc.forClass()) != null) {
1956             ccl = cl.getComponentType();
1957             array = Array.newInstance(ccl, len);
1958         }
1959 
1960         int arrayHandle = handles.assign(unshared ? unsharedMarker : array);
1961         ClassNotFoundException resolveEx = desc.getResolveException();
1962         if (resolveEx != null) {
1963             handles.markException(arrayHandle, resolveEx);
1964         }
1965 
1966         if (ccl == null) {
1967             for (int i = 0; i &lt; len; i++) {
<span class="line-modified">1968                 readObject0(false);</span>
1969             }
1970         } else if (ccl.isPrimitive()) {
1971             if (ccl == Integer.TYPE) {
1972                 bin.readInts((int[]) array, 0, len);
1973             } else if (ccl == Byte.TYPE) {
1974                 bin.readFully((byte[]) array, 0, len, true);
1975             } else if (ccl == Long.TYPE) {
1976                 bin.readLongs((long[]) array, 0, len);
1977             } else if (ccl == Float.TYPE) {
1978                 bin.readFloats((float[]) array, 0, len);
1979             } else if (ccl == Double.TYPE) {
1980                 bin.readDoubles((double[]) array, 0, len);
1981             } else if (ccl == Short.TYPE) {
1982                 bin.readShorts((short[]) array, 0, len);
1983             } else if (ccl == Character.TYPE) {
1984                 bin.readChars((char[]) array, 0, len);
1985             } else if (ccl == Boolean.TYPE) {
1986                 bin.readBooleans((boolean[]) array, 0, len);
1987             } else {
1988                 throw new InternalError();
1989             }
1990         } else {
1991             Object[] oa = (Object[]) array;
1992             for (int i = 0; i &lt; len; i++) {
<span class="line-modified">1993                 oa[i] = readObject0(false);</span>
1994                 handles.markDependency(arrayHandle, passHandle);
1995             }
1996         }
1997 
1998         handles.finish(arrayHandle);
1999         passHandle = arrayHandle;
2000         return array;
2001     }
2002 
2003     /**
2004      * Reads in and returns enum constant, or null if enum type is
2005      * unresolvable.  Sets passHandle to enum constant&#39;s assigned handle.
2006      */
2007     private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException {
2008         if (bin.readByte() != TC_ENUM) {
2009             throw new InternalError();
2010         }
2011 
2012         ObjectStreamClass desc = readClassDesc(false);
2013         if (!desc.isEnum()) {
</pre>
<hr />
<pre>
2026         if (cl != null) {
2027             try {
2028                 @SuppressWarnings(&quot;unchecked&quot;)
2029                 Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);
2030                 result = en;
2031             } catch (IllegalArgumentException ex) {
2032                 throw (IOException) new InvalidObjectException(
2033                     &quot;enum constant &quot; + name + &quot; does not exist in &quot; +
2034                     cl).initCause(ex);
2035             }
2036             if (!unshared) {
2037                 handles.setObject(enumHandle, result);
2038             }
2039         }
2040 
2041         handles.finish(enumHandle);
2042         passHandle = enumHandle;
2043         return result;
2044     }
2045 





2046     /**
2047      * Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
2048      * ObjectStreamClass, array, or enum constant) object, or null if object&#39;s
2049      * class is unresolvable (in which case a ClassNotFoundException will be
2050      * associated with object&#39;s handle).  Sets passHandle to object&#39;s assigned
2051      * handle.
2052      */
2053     private Object readOrdinaryObject(boolean unshared)
2054         throws IOException
2055     {
2056         if (bin.readByte() != TC_OBJECT) {
2057             throw new InternalError();
2058         }
2059 
2060         ObjectStreamClass desc = readClassDesc(false);
2061         desc.checkDeserialize();
2062 
2063         Class&lt;?&gt; cl = desc.forClass();
2064         if (cl == String.class || cl == Class.class
2065                 || cl == ObjectStreamClass.class) {
2066             throw new InvalidClassException(&quot;invalid class descriptor&quot;);
2067         }
2068 
2069         Object obj;
2070         try {
2071             obj = desc.isInstantiable() ? desc.newInstance() : null;
2072         } catch (Exception ex) {
2073             throw (IOException) new InvalidClassException(
2074                 desc.forClass().getName(),
2075                 &quot;unable to create instance&quot;).initCause(ex);
2076         }
2077 
2078         passHandle = handles.assign(unshared ? unsharedMarker : obj);
2079         ClassNotFoundException resolveEx = desc.getResolveException();
2080         if (resolveEx != null) {
2081             handles.markException(passHandle, resolveEx);
2082         }
2083 
<span class="line-modified">2084         if (desc.isExternalizable()) {</span>





2085             readExternalData((Externalizable) obj, desc);
2086         } else {
2087             readSerialData(obj, desc);
2088         }
2089 
2090         handles.finish(passHandle);
2091 
2092         if (obj != null &amp;&amp;
2093             handles.lookupException(passHandle) == null &amp;&amp;
2094             desc.hasReadResolveMethod())
2095         {
2096             Object rep = desc.invokeReadResolve(obj);
2097             if (unshared &amp;&amp; rep.getClass().isArray()) {
2098                 rep = cloneArray(rep);
2099             }
2100             if (rep != obj) {
2101                 // Filter the replacement object
2102                 if (rep != null) {
2103                     if (rep.getClass().isArray()) {
2104                         filterCheck(rep.getClass(), Array.getLength(rep));
</pre>
<hr />
<pre>
2150             }
2151         } finally {
2152             if (oldContext != null)
2153                 oldContext.check();
2154             curContext = oldContext;
2155         }
2156         /*
2157          * At this point, if the externalizable data was not written in
2158          * block-data form and either the externalizable class doesn&#39;t exist
2159          * locally (i.e., obj == null) or readExternal() just threw a
2160          * CNFException, then the stream is probably in an inconsistent state,
2161          * since some (or all) of the externalizable data may not have been
2162          * consumed.  Since there&#39;s no &quot;correct&quot; action to take in this case,
2163          * we mimic the behavior of past serialization implementations and
2164          * blindly hope that the stream is in sync; if it isn&#39;t and additional
2165          * externalizable data remains in the stream, a subsequent read will
2166          * most likely throw a StreamCorruptedException.
2167          */
2168     }
2169 





































2170     /**
2171      * Reads (or attempts to skip, if obj is null or is tagged with a
2172      * ClassNotFoundException) instance data for each serializable class of
2173      * object in stream, from superclass to subclass.  Expects that passHandle
2174      * is set to obj&#39;s handle before this method is called.
2175      */
2176     private void readSerialData(Object obj, ObjectStreamClass desc)
2177         throws IOException
2178     {
2179         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2180         // Best effort Failure Atomicity; slotValues will be non-null if field
2181         // values can be set after reading all field data in the hierarchy.
2182         // Field values can only be set after reading all data if there are no
2183         // user observable methods in the hierarchy, readObject(NoData). The
2184         // top most Serializable class in the hierarchy can be skipped.
2185         FieldValues[] slotValues = null;
2186 
2187         boolean hasSpecialReadMethod = false;
2188         for (int i = 1; i &lt; slots.length; i++) {
2189             ObjectStreamClass slotDesc = slots[i].desc;
</pre>
<hr />
<pre>
2290      */
2291     private void skipCustomData() throws IOException {
2292         int oldHandle = passHandle;
2293         for (;;) {
2294             if (bin.getBlockDataMode()) {
2295                 bin.skipBlockData();
2296                 bin.setBlockDataMode(false);
2297             }
2298             switch (bin.peekByte()) {
2299                 case TC_BLOCKDATA:
2300                 case TC_BLOCKDATALONG:
2301                     bin.setBlockDataMode(true);
2302                     break;
2303 
2304                 case TC_ENDBLOCKDATA:
2305                     bin.readByte();
2306                     passHandle = oldHandle;
2307                     return;
2308 
2309                 default:
<span class="line-modified">2310                     readObject0(false);</span>
2311                     break;
2312             }
2313         }
2314     }
2315 
<span class="line-modified">2316     private class FieldValues {</span>
2317         final byte[] primValues;
2318         final Object[] objValues;
2319 
2320         FieldValues(byte[] primValues, Object[] objValues) {
2321             this.primValues = primValues;
2322             this.objValues = objValues;
2323         }
2324     }
2325 
2326     /**
2327      * Reads in values of serializable fields declared by given class
2328      * descriptor. Expects that passHandle is set to obj&#39;s handle before this
2329      * method is called.
2330      */
2331     private FieldValues defaultReadFields(Object obj, ObjectStreamClass desc)
2332         throws IOException
2333     {
2334         Class&lt;?&gt; cl = desc.forClass();
2335         if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {
2336             throw new ClassCastException();
2337         }
2338 
2339         byte[] primVals = null;
2340         int primDataSize = desc.getPrimDataSize();
2341         if (primDataSize &gt; 0) {
2342             primVals = new byte[primDataSize];
2343             bin.readFully(primVals, 0, primDataSize, false);
2344         }
2345 
2346         Object[] objVals = null;
2347         int numObjFields = desc.getNumObjFields();
2348         if (numObjFields &gt; 0) {
2349             int objHandle = passHandle;
2350             ObjectStreamField[] fields = desc.getFields(false);
2351             objVals = new Object[numObjFields];
2352             int numPrimFields = fields.length - objVals.length;
2353             for (int i = 0; i &lt; objVals.length; i++) {
2354                 ObjectStreamField f = fields[numPrimFields + i];
<span class="line-modified">2355                 objVals[i] = readObject0(f.isUnshared());</span>
2356                 if (f.getField() != null) {
2357                     handles.markDependency(objHandle, passHandle);
2358                 }
2359             }
2360             passHandle = objHandle;
2361         }
2362 
2363         return new FieldValues(primVals, objVals);
2364     }
2365 
2366     /** Throws ClassCastException if any value is not assignable. */
2367     private void defaultCheckFieldValues(Object obj, ObjectStreamClass desc,
2368                                          FieldValues values) {
2369         Object[] objectValues = values.objValues;
2370         if (objectValues != null)
2371             desc.checkObjFieldValueTypes(obj, objectValues);
2372     }
2373 
2374     /** Sets field values in obj. */
2375     private void defaultSetFieldValues(Object obj, ObjectStreamClass desc,
2376                                        FieldValues values) {
2377         byte[] primValues = values.primValues;
2378         Object[] objectValues = values.objValues;
2379 
2380         if (primValues != null)
2381             desc.setPrimFieldValues(obj, primValues);
2382         if (objectValues != null)
2383             desc.setObjFieldValues(obj, objectValues);
2384     }
2385 
2386     /**
2387      * Reads in and returns IOException that caused serialization to abort.
2388      * All stream state is discarded prior to reading in fatal exception.  Sets
2389      * passHandle to fatal exception&#39;s handle.
2390      */
2391     private IOException readFatalException() throws IOException {
2392         if (bin.readByte() != TC_EXCEPTION) {
2393             throw new InternalError();
2394         }
2395         clear();
<span class="line-modified">2396         return (IOException) readObject0(false);</span>
2397     }
2398 
2399     /**
2400      * If recursion depth is 0, clears internal data structures; otherwise,
2401      * throws a StreamCorruptedException.  This method is called when a
2402      * TC_RESET typecode is encountered.
2403      */
2404     private void handleReset() throws StreamCorruptedException {
2405         if (depth &gt; 0) {
2406             throw new StreamCorruptedException(
2407                 &quot;unexpected reset; recursion depth: &quot; + depth);
2408         }
2409         clear();
2410     }
2411 
<span class="line-removed">2412     /**</span>
<span class="line-removed">2413      * Converts specified span of bytes into float values.</span>
<span class="line-removed">2414      */</span>
<span class="line-removed">2415     // REMIND: remove once hotspot inlines Float.intBitsToFloat</span>
<span class="line-removed">2416     private static native void bytesToFloats(byte[] src, int srcpos,</span>
<span class="line-removed">2417                                              float[] dst, int dstpos,</span>
<span class="line-removed">2418                                              int nfloats);</span>
<span class="line-removed">2419 </span>
<span class="line-removed">2420     /**</span>
<span class="line-removed">2421      * Converts specified span of bytes into double values.</span>
<span class="line-removed">2422      */</span>
<span class="line-removed">2423     // REMIND: remove once hotspot inlines Double.longBitsToDouble</span>
<span class="line-removed">2424     private static native void bytesToDoubles(byte[] src, int srcpos,</span>
<span class="line-removed">2425                                               double[] dst, int dstpos,</span>
<span class="line-removed">2426                                               int ndoubles);</span>
<span class="line-removed">2427 </span>
2428     /**
2429      * Returns the first non-null and non-platform class loader (not counting
2430      * class loaders of generated reflection implementation classes) up the
2431      * execution stack, or the platform class loader if only code from the
2432      * bootstrap and platform class loader is on the stack.
2433      */
2434     private static ClassLoader latestUserDefinedLoader() {
2435         return jdk.internal.misc.VM.latestUserDefinedLoader();
2436     }
2437 
2438     /**
2439      * Default GetField implementation.
2440      */
2441     private class GetFieldImpl extends GetField {
2442 
2443         /** class descriptor describing serializable fields */
2444         private final ObjectStreamClass desc;
2445         /** primitive field values */
2446         private final byte[] primVals;
2447         /** object field values */
</pre>
<hr />
<pre>
2514                 int objHandle = objHandles[off];
2515                 handles.markDependency(passHandle, objHandle);
2516                 return (handles.lookupException(objHandle) == null) ?
2517                     objVals[off] : null;
2518             } else {
2519                 return val;
2520             }
2521         }
2522 
2523         /**
2524          * Reads primitive and object field values from stream.
2525          */
2526         void readFields() throws IOException {
2527             bin.readFully(primVals, 0, primVals.length, false);
2528 
2529             int oldHandle = passHandle;
2530             ObjectStreamField[] fields = desc.getFields(false);
2531             int numPrimFields = fields.length - objVals.length;
2532             for (int i = 0; i &lt; objVals.length; i++) {
2533                 objVals[i] =
<span class="line-modified">2534                     readObject0(fields[numPrimFields + i].isUnshared());</span>
2535                 objHandles[i] = passHandle;
2536             }
2537             passHandle = oldHandle;
2538         }
2539 
2540         /**
2541          * Returns offset of field with given name and type.  A specified type
2542          * of null matches all types, Object.class matches all non-primitive
2543          * types, and any other non-null type matches assignable types only.
2544          * If no matching field is found in the (incoming) class
2545          * descriptor but a matching field is present in the associated local
2546          * class descriptor, returns -1.  Throws IllegalArgumentException if
2547          * neither incoming nor local class descriptor contains a match.
2548          */
2549         private int getFieldOffset(String name, Class&lt;?&gt; type) {
2550             ObjectStreamField field = desc.getField(name, type);
2551             if (field != null) {
2552                 return field.getOffset();
2553             } else if (desc.getLocalDesc().getField(name, type) != null) {
2554                 return -1;
</pre>
<hr />
<pre>
3412                 if (!blkmode) {
3413                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3414                     in.readFully(buf, 0, span &lt;&lt; 2);
3415                     stop = off + span;
3416                     pos = 0;
3417                 } else if (end - pos &lt; 4) {
3418                     v[off++] = din.readInt();
3419                     continue;
3420                 } else {
3421                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 2));
3422                 }
3423 
3424                 while (off &lt; stop) {
3425                     v[off++] = Bits.getInt(buf, pos);
3426                     pos += 4;
3427                 }
3428             }
3429         }
3430 
3431         void readFloats(float[] v, int off, int len) throws IOException {
<span class="line-modified">3432             int span, endoff = off + len;</span>
3433             while (off &lt; endoff) {
3434                 if (!blkmode) {
<span class="line-modified">3435                     span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);</span>
3436                     in.readFully(buf, 0, span &lt;&lt; 2);

3437                     pos = 0;
3438                 } else if (end - pos &lt; 4) {
3439                     v[off++] = din.readFloat();
3440                     continue;
3441                 } else {
<span class="line-modified">3442                     span = Math.min(endoff - off, ((end - pos) &gt;&gt; 2));</span>
3443                 }
3444 
<span class="line-modified">3445                 bytesToFloats(buf, pos, v, off, span);</span>
<span class="line-modified">3446                 off += span;</span>
<span class="line-modified">3447                 pos += span &lt;&lt; 2;</span>

3448             }
3449         }
3450 
3451         void readLongs(long[] v, int off, int len) throws IOException {
3452             int stop, endoff = off + len;
3453             while (off &lt; endoff) {
3454                 if (!blkmode) {
3455                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3456                     in.readFully(buf, 0, span &lt;&lt; 3);
3457                     stop = off + span;
3458                     pos = 0;
3459                 } else if (end - pos &lt; 8) {
3460                     v[off++] = din.readLong();
3461                     continue;
3462                 } else {
3463                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 3));
3464                 }
3465 
3466                 while (off &lt; stop) {
3467                     v[off++] = Bits.getLong(buf, pos);
3468                     pos += 8;
3469                 }
3470             }
3471         }
3472 
3473         void readDoubles(double[] v, int off, int len) throws IOException {
<span class="line-modified">3474             int span, endoff = off + len;</span>
3475             while (off &lt; endoff) {
3476                 if (!blkmode) {
<span class="line-modified">3477                     span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);</span>
3478                     in.readFully(buf, 0, span &lt;&lt; 3);

3479                     pos = 0;
3480                 } else if (end - pos &lt; 8) {
3481                     v[off++] = din.readDouble();
3482                     continue;
3483                 } else {
<span class="line-modified">3484                     span = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));</span>
3485                 }
3486 
<span class="line-modified">3487                 bytesToDoubles(buf, pos, v, off, span);</span>
<span class="line-modified">3488                 off += span;</span>
<span class="line-modified">3489                 pos += span &lt;&lt; 3;</span>

3490             }
3491         }
3492 
3493         /**
3494          * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
3495          * identical to standard UTF, except that it uses an 8 byte header
3496          * (instead of the standard 2 bytes) to convey the UTF encoding length.
3497          */
3498         String readLongUTF() throws IOException {
3499             return readUTFBody(readLong());
3500         }
3501 
3502         /**
3503          * Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
3504          * or 8-byte length header) of a UTF encoding, which occupies the next
3505          * utflen bytes.
3506          */
3507         private String readUTFBody(long utflen) throws IOException {
3508             StringBuilder sbuf;
3509             if (utflen &gt; 0 &amp;&amp; utflen &lt; Integer.MAX_VALUE) {
</pre>
<hr />
<pre>
3999             return ((byte[]) array).clone();
4000         } else if (array instanceof char[]) {
4001             return ((char[]) array).clone();
4002         } else if (array instanceof double[]) {
4003             return ((double[]) array).clone();
4004         } else if (array instanceof float[]) {
4005             return ((float[]) array).clone();
4006         } else if (array instanceof int[]) {
4007             return ((int[]) array).clone();
4008         } else if (array instanceof long[]) {
4009             return ((long[]) array).clone();
4010         } else if (array instanceof short[]) {
4011             return ((short[]) array).clone();
4012         } else {
4013             throw new AssertionError();
4014         }
4015     }
4016 
4017     static {
4018         SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);

4019     }
4020 
4021 }
</pre>
</td>
<td>
<hr />
<pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.io.ObjectStreamClass.WeakClassKey;
<span class="line-added">  29 import java.io.ObjectStreamClass.RecordSupport;</span>
  30 import java.lang.System.Logger;
<span class="line-added">  31 import java.lang.invoke.MethodHandle;</span>
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.reflect.Array;
  34 import java.lang.reflect.Modifier;
  35 import java.lang.reflect.Proxy;
  36 import java.security.AccessControlContext;
  37 import java.security.AccessController;
  38 import java.security.PrivilegedAction;
  39 import java.security.PrivilegedActionException;
  40 import java.security.PrivilegedExceptionAction;
  41 import java.util.Arrays;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 
  47 import static java.io.ObjectStreamClass.processQueue;
  48 
  49 import jdk.internal.access.SharedSecrets;
  50 import jdk.internal.misc.Unsafe;
  51 import sun.reflect.misc.ReflectUtil;
</pre>
<hr />
<pre>
  59  * &quot;Serialization and Deserialization&quot; section of the
  60  * {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
  61  * {@extLink serialization_filter_guide Serialization Filtering} describes best
  62  * practices for defensive use of serial filters.
  63  * &lt;/strong&gt;&lt;/p&gt;
  64  *
  65  * &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
  66  * persistent storage for graphs of objects when used with a FileOutputStream
  67  * and FileInputStream respectively.  ObjectInputStream is used to recover
  68  * those objects previously serialized. Other uses include passing objects
  69  * between hosts using a socket stream or for marshaling and unmarshaling
  70  * arguments and parameters in a remote communication system.
  71  *
  72  * &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
  73  * created from the stream match the classes present in the Java Virtual
  74  * Machine.  Classes are loaded as required using the standard mechanisms.
  75  *
  76  * &lt;p&gt;Only objects that support the java.io.Serializable or
  77  * java.io.Externalizable interface can be read from streams.
  78  *
<span class="line-modified">  79  * &lt;p&gt;The method {@code readObject} is used to read an object from the</span>
  80  * stream.  Java&#39;s safe casting should be used to get the desired type.  In
  81  * Java, strings and arrays are objects and are treated as objects during
  82  * serialization. When read they need to be cast to the expected type.
  83  *
  84  * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
  85  * method on DataInput.
  86  *
  87  * &lt;p&gt;The default deserialization mechanism for objects restores the contents
  88  * of each field to the value and type it had when it was written.  Fields
  89  * declared as transient or static are ignored by the deserialization process.
  90  * References to other objects cause those objects to be read from the stream
  91  * as necessary.  Graphs of objects are restored correctly using a reference
  92  * sharing mechanism.  New objects are always allocated when deserializing,
  93  * which prevents existing objects from being overwritten.
  94  *
  95  * &lt;p&gt;Reading an object is analogous to running the constructors of a new
  96  * object.  Memory is allocated for the object and initialized to zero (NULL).
  97  * No-arg constructors are invoked for the non-serializable classes and then
  98  * the fields of the serializable classes are restored from the stream starting
  99  * with the serializable class closest to java.lang.object and finishing with
</pre>
<hr />
<pre>
 142  * restored by reading data from the ObjectInputStream for the individual
 143  * fields and making assignments to the appropriate fields of the object.
 144  * Reading primitive data types is supported by DataInput.
 145  *
 146  * &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
 147  * custom data written by the corresponding writeObject method will cause an
 148  * OptionalDataException to be thrown with an eof field value of true.
 149  * Non-object reads which exceed the end of the allotted data will reflect the
 150  * end of data in the same way that they would indicate the end of the stream:
 151  * bytewise reads will return -1 as the byte read or number of bytes read, and
 152  * primitive reads will throw EOFExceptions.  If there is no corresponding
 153  * writeObject method, then the end of default serialized data marks the end of
 154  * the allotted data.
 155  *
 156  * &lt;p&gt;Primitive and object read calls issued from within a readExternal method
 157  * behave in the same manner--if the stream is already positioned at the end of
 158  * data written by the corresponding writeExternal method, object reads will
 159  * throw OptionalDataExceptions with eof set to true, bytewise reads will
 160  * return -1, and primitive reads will throw EOFExceptions.  Note that this
 161  * behavior does not hold for streams written with the old
<span class="line-modified"> 162  * {@code ObjectStreamConstants.PROTOCOL_VERSION_1} protocol, in which the</span>
 163  * end of data written by writeExternal methods is not demarcated, and hence
 164  * cannot be detected.
 165  *
 166  * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
 167  * the object for its particular class in the event that the serialization
 168  * stream does not list the given class as a superclass of the object being
 169  * deserialized.  This may occur in cases where the receiving party uses a
 170  * different version of the deserialized instance&#39;s class than the sending
 171  * party, and the receiver&#39;s version extends classes that are not extended by
 172  * the sender&#39;s version.  This may also occur if the serialization stream has
 173  * been tampered; hence, readObjectNoData is useful for initializing
 174  * deserialized objects properly despite a &quot;hostile&quot; or incomplete source
 175  * stream.
 176  *
 177  * &lt;p&gt;Serialization does not read or assign values to the fields of any object
 178  * that does not implement the java.io.Serializable interface.  Subclasses of
 179  * Objects that are not serializable can be serializable. In this case the
 180  * non-serializable class must have a no-arg constructor to allow its fields to
 181  * be initialized.  In this case it is the responsibility of the subclass to
 182  * save and restore the state of the non-serializable class. It is frequently
</pre>
<hr />
<pre>
 193  * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) system-wide filter}
 194  * can be configured that is applied to each {@code ObjectInputStream} unless replaced
 195  * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.
 196  *
 197  * &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
 198  * the ObjectInputStream and abort the reading process.
 199  *
 200  * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 201  * complete control over the contents and format of the object&#39;s serialized
 202  * form.  The methods of the Externalizable interface, writeExternal and
 203  * readExternal, are called to save and restore the objects state.  When
 204  * implemented by a class they can write and read their own state using all of
 205  * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 206  * the objects to handle any versioning that occurs.
 207  *
 208  * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
 209  * externalizable objects.  The serialized form of an enum constant consists
 210  * solely of its name; field values of the constant are not transmitted.  To
 211  * deserialize an enum constant, ObjectInputStream reads the constant name from
 212  * the stream; the deserialized constant is then obtained by calling the static
<span class="line-modified"> 213  * method {@code Enum.valueOf(Class, String)} with the enum constant&#39;s</span>
 214  * base type and the received constant name as arguments.  Like other
 215  * serializable or externalizable objects, enum constants can function as the
 216  * targets of back references appearing subsequently in the serialization
 217  * stream.  The process by which enum constants are deserialized cannot be
 218  * customized: any class-specific readObject, readObjectNoData, and readResolve
 219  * methods defined by enum types are ignored during deserialization.
 220  * Similarly, any serialPersistentFields or serialVersionUID field declarations
 221  * are also ignored--all enum types have a fixed serialVersionUID of 0L.
 222  *
<span class="line-added"> 223  * @implSpec</span>
<span class="line-added"> 224  * &lt;a id=&quot;record-serialization&quot;&gt;&lt;/a&gt;</span>
<span class="line-added"> 225  * Records are serialized differently than ordinary serializable or externalizable</span>
<span class="line-added"> 226  * objects. The serialized form of a record object is a sequence of values derived</span>
<span class="line-added"> 227  * from the record components. The stream format of a record object is the same as</span>
<span class="line-added"> 228  * that of an ordinary object in the stream. During deserialization, if the local</span>
<span class="line-added"> 229  * class equivalent of the specified stream class descriptor is a record class,</span>
<span class="line-added"> 230  * then first the stream fields are read and reconstructed to serve as the record&#39;s</span>
<span class="line-added"> 231  * component values; and second, a record object is created by invoking the</span>
<span class="line-added"> 232  * record&#39;s &lt;i&gt;canonical&lt;/i&gt; constructor with the component values as arguments (or the</span>
<span class="line-added"> 233  * default value for component&#39;s type if a component value is absent from the</span>
<span class="line-added"> 234  * stream).</span>
<span class="line-added"> 235  * Like other serializable or externalizable objects, record objects can function</span>
<span class="line-added"> 236  * as the target of back references appearing subsequently in the serialization</span>
<span class="line-added"> 237  * stream. However, a cycle in the graph where the record object is referred to,</span>
<span class="line-added"> 238  * either directly or transitively, by one of its components, is not preserved.</span>
<span class="line-added"> 239  * The record components are deserialized prior to the invocation of the record</span>
<span class="line-added"> 240  * constructor, hence this limitation (see</span>
<span class="line-added"> 241  * &lt;a href=&quot;{@docRoot}/../specs/serialization/serial-arch.html#cyclic-references&quot;&gt;</span>
<span class="line-added"> 242  * [Section 1.14, &quot;Circular References&quot;&lt;/a&gt; for additional information).</span>
<span class="line-added"> 243  * The process by which record objects are serialized or externalized cannot be</span>
<span class="line-added"> 244  * customized; any class-specific writeObject, readObject, readObjectNoData,</span>
<span class="line-added"> 245  * writeExternal, and readExternal methods defined by record classes are</span>
<span class="line-added"> 246  * ignored during serialization and deserialization. However, a substitute object</span>
<span class="line-added"> 247  * to be serialized or a designate replacement may be specified, by the</span>
<span class="line-added"> 248  * writeReplace and readResolve methods, respectively.  Any</span>
<span class="line-added"> 249  * serialPersistentFields field declaration is ignored. Documenting serializable</span>
<span class="line-added"> 250  * fields and data for record classes is unnecessary, since there is no variation</span>
<span class="line-added"> 251  * in the serial form, other than whether a substitute or replacement object is</span>
<span class="line-added"> 252  * used. The serialVersionUID of a record class is 0L unless explicitly</span>
<span class="line-added"> 253  * declared. The requirement for matching serialVersionUID values is waived for</span>
<span class="line-added"> 254  * record classes.</span>
<span class="line-added"> 255  *</span>
 256  * @author      Mike Warres
 257  * @author      Roger Riggs
 258  * @see java.io.DataInput
 259  * @see java.io.ObjectOutputStream
 260  * @see java.io.Serializable
 261  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/input.html&quot;&gt;
 262  *     Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;
 263  * @since   1.1
 264  */
 265 public class ObjectInputStream
 266     extends InputStream implements ObjectInput, ObjectStreamConstants
 267 {
 268     /** handle value representing null */
 269     private static final int NULL_HANDLE = -1;
 270 
 271     /** marker for unshared objects in internal handle table */
 272     private static final Object unsharedMarker = new Object();
 273 
 274     /**
 275      * immutable table mapping primitive type names to corresponding
</pre>
<hr />
<pre>
 353     /**
 354      * Creates an ObjectInputStream that reads from the specified InputStream.
 355      * A serialization stream header is read from the stream and verified.
 356      * This constructor will block until the corresponding ObjectOutputStream
 357      * has written and flushed the header.
 358      *
 359      * &lt;p&gt;The serialization filter is initialized to the value of
 360      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 361      *
 362      * &lt;p&gt;If a security manager is installed, this constructor will check for
 363      * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 364      * directly or indirectly by the constructor of a subclass which overrides
 365      * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
 366      * methods.
 367      *
 368      * @param   in input stream to read from
 369      * @throws  StreamCorruptedException if the stream header is incorrect
 370      * @throws  IOException if an I/O error occurs while reading stream header
 371      * @throws  SecurityException if untrusted subclass illegally overrides
 372      *          security-sensitive methods
<span class="line-modified"> 373      * @throws  NullPointerException if {@code in} is {@code null}</span>
 374      * @see     ObjectInputStream#ObjectInputStream()
 375      * @see     ObjectInputStream#readFields()
 376      * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
 377      */
 378     public ObjectInputStream(InputStream in) throws IOException {
 379         verifySubclass();
 380         bin = new BlockDataInputStream(in);
 381         handles = new HandleTable(10);
 382         vlist = new ValidationList();
 383         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 384         enableOverride = false;
 385         readStreamHeader();
 386         bin.setBlockDataMode(true);
 387     }
 388 
 389     /**
 390      * Provide a way for subclasses that are completely reimplementing
 391      * ObjectInputStream to not have to allocate private data just used by this
 392      * implementation of ObjectInputStream.
 393      *
 394      * &lt;p&gt;The serialization filter is initialized to the value of
 395      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 396      *
 397      * &lt;p&gt;If there is a security manager installed, this method first calls the
<span class="line-modified"> 398      * security manager&#39;s {@code checkPermission} method with the</span>
<span class="line-modified"> 399      * {@code SerializablePermission(&quot;enableSubclassImplementation&quot;)}</span>
 400      * permission to ensure it&#39;s ok to enable subclassing.
 401      *
 402      * @throws  SecurityException if a security manager exists and its
<span class="line-modified"> 403      *          {@code checkPermission} method denies enabling</span>
 404      *          subclassing.
 405      * @throws  IOException if an I/O error occurs while creating this stream
 406      * @see SecurityManager#checkPermission
 407      * @see java.io.SerializablePermission
 408      */
 409     protected ObjectInputStream() throws IOException, SecurityException {
 410         SecurityManager sm = System.getSecurityManager();
 411         if (sm != null) {
 412             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 413         }
 414         bin = null;
 415         handles = null;
 416         vlist = null;
 417         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 418         enableOverride = true;
 419     }
 420 
 421     /**
 422      * Read an object from the ObjectInputStream.  The class of the object, the
 423      * signature of the class, and the values of the non-transient and
</pre>
<hr />
<pre>
 436      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 437      * each object (regular or class) read to reconstruct the root object.
 438      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 439      *
 440      * &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
 441      * classes that should not be deserialized.  All exceptions are fatal to
 442      * the InputStream and leave it in an indeterminate state; it is up to the
 443      * caller to ignore or recover the stream state.
 444      *
 445      * @throws  ClassNotFoundException Class of a serialized object cannot be
 446      *          found.
 447      * @throws  InvalidClassException Something is wrong with a class used by
 448      *          serialization.
 449      * @throws  StreamCorruptedException Control information in the
 450      *          stream is inconsistent.
 451      * @throws  OptionalDataException Primitive data was found in the
 452      *          stream instead of objects.
 453      * @throws  IOException Any of the usual Input/Output related exceptions.
 454      */
 455     public final Object readObject()
<span class="line-added"> 456         throws IOException, ClassNotFoundException {</span>
<span class="line-added"> 457         return readObject(Object.class);</span>
<span class="line-added"> 458     }</span>
<span class="line-added"> 459 </span>
<span class="line-added"> 460     /**</span>
<span class="line-added"> 461      * Reads a String and only a string.</span>
<span class="line-added"> 462      *</span>
<span class="line-added"> 463      * @return  the String read</span>
<span class="line-added"> 464      * @throws  EOFException If end of file is reached.</span>
<span class="line-added"> 465      * @throws  IOException If other I/O error has occurred.</span>
<span class="line-added"> 466      */</span>
<span class="line-added"> 467     private String readString() throws IOException {</span>
<span class="line-added"> 468         try {</span>
<span class="line-added"> 469             return (String) readObject(String.class);</span>
<span class="line-added"> 470         } catch (ClassNotFoundException cnf) {</span>
<span class="line-added"> 471             throw new IllegalStateException(cnf);</span>
<span class="line-added"> 472         }</span>
<span class="line-added"> 473     }</span>
<span class="line-added"> 474 </span>
<span class="line-added"> 475     /**</span>
<span class="line-added"> 476      * Internal method to read an object from the ObjectInputStream of the expected type.</span>
<span class="line-added"> 477      * Called only from {@code readObject()} and {@code readString()}.</span>
<span class="line-added"> 478      * Only {@code Object.class} and {@code String.class} are supported.</span>
<span class="line-added"> 479      *</span>
<span class="line-added"> 480      * @param type the type expected; either Object.class or String.class</span>
<span class="line-added"> 481      * @return an object of the type</span>
<span class="line-added"> 482      * @throws  IOException Any of the usual Input/Output related exceptions.</span>
<span class="line-added"> 483      * @throws  ClassNotFoundException Class of a serialized object cannot be</span>
<span class="line-added"> 484      *          found.</span>
<span class="line-added"> 485      */</span>
<span class="line-added"> 486     private final Object readObject(Class&lt;?&gt; type)</span>
 487         throws IOException, ClassNotFoundException
 488     {
 489         if (enableOverride) {
 490             return readObjectOverride();
 491         }
 492 
<span class="line-added"> 493         if (! (type == Object.class || type == String.class))</span>
<span class="line-added"> 494             throw new AssertionError(&quot;internal error&quot;);</span>
<span class="line-added"> 495 </span>
 496         // if nested read, passHandle contains handle of enclosing object
 497         int outerHandle = passHandle;
 498         try {
<span class="line-modified"> 499             Object obj = readObject0(type, false);</span>
 500             handles.markDependency(outerHandle, passHandle);
 501             ClassNotFoundException ex = handles.lookupException(passHandle);
 502             if (ex != null) {
 503                 throw ex;
 504             }
 505             if (depth == 0) {
 506                 vlist.doCallbacks();
 507                 freeze();
 508             }
 509             return obj;
 510         } finally {
 511             passHandle = outerHandle;
 512             if (closed &amp;&amp; depth == 0) {
 513                 clear();
 514             }
 515         }
 516     }
 517 
 518     /**
<span class="line-modified"> 519      * This method is called by trusted subclasses of ObjectInputStream that</span>
<span class="line-modified"> 520      + constructed ObjectInputStream using the protected no-arg constructor.</span>
 521      * The subclass is expected to provide an override method with the modifier
 522      * &quot;final&quot;.
 523      *
 524      * @return  the Object read from the stream.
 525      * @throws  ClassNotFoundException Class definition of a serialized object
 526      *          cannot be found.
 527      * @throws  OptionalDataException Primitive data was found in the stream
 528      *          instead of objects.
 529      * @throws  IOException if I/O errors occurred while reading from the
 530      *          underlying stream
 531      * @see #ObjectInputStream()
 532      * @see #readObject()
 533      * @since 1.2
 534      */
 535     protected Object readObjectOverride()
 536         throws IOException, ClassNotFoundException
 537     {
 538         return null;
 539     }
 540 
</pre>
<hr />
<pre>
 574      * constructed in security contexts possessing the
 575      * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
 576      * instantiate such a subclass without this permission will cause a
 577      * SecurityException to be thrown.
 578      *
 579      * @return  reference to deserialized object
 580      * @throws  ClassNotFoundException if class of an object to deserialize
 581      *          cannot be found
 582      * @throws  StreamCorruptedException if control information in the stream
 583      *          is inconsistent
 584      * @throws  ObjectStreamException if object to deserialize has already
 585      *          appeared in stream
 586      * @throws  OptionalDataException if primitive data is next in stream
 587      * @throws  IOException if an I/O error occurs during deserialization
 588      * @since   1.4
 589      */
 590     public Object readUnshared() throws IOException, ClassNotFoundException {
 591         // if nested read, passHandle contains handle of enclosing object
 592         int outerHandle = passHandle;
 593         try {
<span class="line-modified"> 594             Object obj = readObject0(Object.class, true);</span>
 595             handles.markDependency(outerHandle, passHandle);
 596             ClassNotFoundException ex = handles.lookupException(passHandle);
 597             if (ex != null) {
 598                 throw ex;
 599             }
 600             if (depth == 0) {
 601                 vlist.doCallbacks();
 602                 freeze();
 603             }
 604             return obj;
 605         } finally {
 606             passHandle = outerHandle;
 607             if (closed &amp;&amp; depth == 0) {
 608                 clear();
 609             }
 610         }
 611     }
 612 
 613     /**
 614      * Read the non-static and non-transient fields of the current class from
</pre>
<hr />
<pre>
 639         }
 640         bin.setBlockDataMode(true);
 641         if (!curDesc.hasWriteObjectData()) {
 642             /*
 643              * Fix for 4360508: since stream does not contain terminating
 644              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 645              * knows to simulate end-of-custom-data behavior.
 646              */
 647             defaultDataEnd = true;
 648         }
 649         ClassNotFoundException ex = handles.lookupException(passHandle);
 650         if (ex != null) {
 651             throw ex;
 652         }
 653     }
 654 
 655     /**
 656      * Reads the persistent fields from the stream and makes them available by
 657      * name.
 658      *
<span class="line-modified"> 659      * @return  the {@code GetField} object representing the persistent</span>
 660      *          fields of the object being deserialized
 661      * @throws  ClassNotFoundException if the class of a serialized object
 662      *          could not be found.
 663      * @throws  IOException if an I/O error occurs.
 664      * @throws  NotActiveException if the stream is not currently reading
 665      *          objects.
 666      * @since 1.2
 667      */
 668     public ObjectInputStream.GetField readFields()
 669         throws IOException, ClassNotFoundException
 670     {
 671         SerialCallbackContext ctx = curContext;
 672         if (ctx == null) {
 673             throw new NotActiveException(&quot;not in call to readObject&quot;);
 674         }
 675         ctx.checkAndSetUsed();
 676         ObjectStreamClass curDesc = ctx.getDesc();
 677         bin.setBlockDataMode(false);
 678         GetFieldImpl getField = new GetFieldImpl(curDesc);
 679         getField.readFields();
</pre>
<hr />
<pre>
 703      *          later callbacks. Within a priority, callbacks are processed in
 704      *          no particular order.
 705      * @throws  NotActiveException The stream is not currently reading objects
 706      *          so it is invalid to register a callback.
 707      * @throws  InvalidObjectException The validation object is null.
 708      */
 709     public void registerValidation(ObjectInputValidation obj, int prio)
 710         throws NotActiveException, InvalidObjectException
 711     {
 712         if (depth == 0) {
 713             throw new NotActiveException(&quot;stream inactive&quot;);
 714         }
 715         vlist.register(obj, prio);
 716     }
 717 
 718     /**
 719      * Load the local class equivalent of the specified stream class
 720      * description.  Subclasses may implement this method to allow classes to
 721      * be fetched from an alternate source.
 722      *
<span class="line-modified"> 723      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is</span>
<span class="line-modified"> 724      * {@code annotateClass}.  This method will be invoked only once for</span>
 725      * each unique class in the stream.  This method can be implemented by
 726      * subclasses to use an alternate loading mechanism but must return a
<span class="line-modified"> 727      * {@code Class} object. Once returned, if the class is not an array</span>
 728      * class, its serialVersionUID is compared to the serialVersionUID of the
 729      * serialized class, and if there is a mismatch, the deserialization fails
 730      * and an {@link InvalidClassException} is thrown.
 731      *
 732      * &lt;p&gt;The default implementation of this method in
<span class="line-modified"> 733      * {@code ObjectInputStream} returns the result of calling</span>
 734      * &lt;pre&gt;
 735      *     Class.forName(desc.getName(), false, loader)
 736      * &lt;/pre&gt;
<span class="line-modified"> 737      * where {@code loader} is the first class loader on the current</span>
 738      * thread&#39;s stack (starting from the currently executing method) that is
 739      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<span class="line-modified"> 740      * class loader} nor its ancestor; otherwise, {@code loader} is the</span>
 741      * &lt;em&gt;platform class loader&lt;/em&gt;. If this call results in a
<span class="line-modified"> 742      * {@code ClassNotFoundException} and the name of the passed</span>
<span class="line-modified"> 743      * {@code ObjectStreamClass} instance is the Java language keyword</span>
<span class="line-modified"> 744      * for a primitive type or void, then the {@code Class} object</span>
 745      * representing that primitive type or void will be returned
<span class="line-modified"> 746      * (e.g., an {@code ObjectStreamClass} with the name</span>
<span class="line-modified"> 747      * {@code &quot;int&quot;} will be resolved to {@code Integer.TYPE}).</span>
<span class="line-modified"> 748      * Otherwise, the {@code ClassNotFoundException} will be thrown to</span>
 749      * the caller of this method.
 750      *
<span class="line-modified"> 751      * @param   desc an instance of class {@code ObjectStreamClass}</span>
<span class="line-modified"> 752      * @return  a {@code Class} object corresponding to {@code desc}</span>
 753      * @throws  IOException any of the usual Input/Output exceptions.
 754      * @throws  ClassNotFoundException if class of a serialized object cannot
 755      *          be found.
 756      */
 757     protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
 758         throws IOException, ClassNotFoundException
 759     {
 760         String name = desc.getName();
 761         try {
 762             return Class.forName(name, false, latestUserDefinedLoader());
 763         } catch (ClassNotFoundException ex) {
 764             Class&lt;?&gt; cl = primClasses.get(name);
 765             if (cl != null) {
 766                 return cl;
 767             } else {
 768                 throw ex;
 769             }
 770         }
 771     }
 772 
 773     /**
 774      * Returns a proxy class that implements the interfaces named in a proxy
 775      * class descriptor; subclasses may implement this method to read custom
 776      * data from the stream along with the descriptors for dynamic proxy
 777      * classes, allowing them to use an alternate loading mechanism for the
 778      * interfaces and the proxy class.
 779      *
 780      * &lt;p&gt;This method is called exactly once for each unique proxy class
 781      * descriptor in the stream.
 782      *
<span class="line-modified"> 783      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is</span>
<span class="line-modified"> 784      * {@code annotateProxyClass}.  For a given subclass of</span>
<span class="line-modified"> 785      * {@code ObjectInputStream} that overrides this method, the</span>
<span class="line-modified"> 786      * {@code annotateProxyClass} method in the corresponding subclass of</span>
<span class="line-modified"> 787      * {@code ObjectOutputStream} must write any data or objects read by</span>
 788      * this method.
 789      *
 790      * &lt;p&gt;The default implementation of this method in
<span class="line-modified"> 791      * {@code ObjectInputStream} returns the result of calling</span>
<span class="line-modified"> 792      * {@code Proxy.getProxyClass} with the list of {@code Class}</span>
<span class="line-modified"> 793      * objects for the interfaces that are named in the {@code interfaces}</span>
<span class="line-modified"> 794      * parameter.  The {@code Class} object for each interface name</span>
<span class="line-modified"> 795      * {@code i} is the value returned by calling</span>
 796      * &lt;pre&gt;
 797      *     Class.forName(i, false, loader)
 798      * &lt;/pre&gt;
<span class="line-modified"> 799      * where {@code loader} is the first class loader on the current</span>
 800      * thread&#39;s stack (starting from the currently executing method) that is
 801      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<span class="line-modified"> 802      * class loader} nor its ancestor; otherwise, {@code loader} is the</span>
 803      * &lt;em&gt;platform class loader&lt;/em&gt;.
 804      * Unless any of the resolved interfaces are non-public, this same value
<span class="line-modified"> 805      * of {@code loader} is also the class loader passed to</span>
<span class="line-modified"> 806      * {@code Proxy.getProxyClass}; if non-public interfaces are present,</span>
 807      * their class loader is passed instead (if more than one non-public
 808      * interface class loader is encountered, an
<span class="line-modified"> 809      * {@code IllegalAccessError} is thrown).</span>
<span class="line-modified"> 810      * If {@code Proxy.getProxyClass} throws an</span>
<span class="line-modified"> 811      * {@code IllegalArgumentException}, {@code resolveProxyClass}</span>
<span class="line-modified"> 812      * will throw a {@code ClassNotFoundException} containing the</span>
<span class="line-modified"> 813      * {@code IllegalArgumentException}.</span>
 814      *
 815      * @param interfaces the list of interface names that were
 816      *                deserialized in the proxy class descriptor
 817      * @return  a proxy class for the specified interfaces
 818      * @throws        IOException any exception thrown by the underlying
<span class="line-modified"> 819      *                {@code InputStream}</span>
 820      * @throws        ClassNotFoundException if the proxy class or any of the
 821      *                named interfaces could not be found
 822      * @see ObjectOutputStream#annotateProxyClass(Class)
 823      * @since 1.3
 824      */
 825     protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)
 826         throws IOException, ClassNotFoundException
 827     {
 828         ClassLoader latestLoader = latestUserDefinedLoader();
 829         ClassLoader nonPublicLoader = null;
 830         boolean hasNonPublicInterface = false;
 831 
 832         // define proxy in class loader of non-public interface(s), if any
 833         Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];
 834         for (int i = 0; i &lt; interfaces.length; i++) {
 835             Class&lt;?&gt; cl = Class.forName(interfaces[i], false, latestLoader);
 836             if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {
 837                 if (hasNonPublicInterface) {
 838                     if (nonPublicLoader != cl.getClassLoader()) {
 839                         throw new IllegalAccessError(
</pre>
<hr />
<pre>
 915     {
 916         if (enable == enableResolve) {
 917             return enable;
 918         }
 919         if (enable) {
 920             SecurityManager sm = System.getSecurityManager();
 921             if (sm != null) {
 922                 sm.checkPermission(SUBSTITUTION_PERMISSION);
 923             }
 924         }
 925         enableResolve = enable;
 926         return !enableResolve;
 927     }
 928 
 929     /**
 930      * The readStreamHeader method is provided to allow subclasses to read and
 931      * verify their own stream headers. It reads and verifies the magic number
 932      * and version number.
 933      *
 934      * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified"> 935      *          underlying {@code InputStream}</span>
 936      * @throws  StreamCorruptedException if control information in the stream
 937      *          is inconsistent
 938      */
 939     protected void readStreamHeader()
 940         throws IOException, StreamCorruptedException
 941     {
 942         short s0 = bin.readShort();
 943         short s1 = bin.readShort();
 944         if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
 945             throw new StreamCorruptedException(
 946                 String.format(&quot;invalid stream header: %04X%04X&quot;, s0, s1));
 947         }
 948     }
 949 
 950     /**
 951      * Read a class descriptor from the serialization stream.  This method is
 952      * called when the ObjectInputStream expects a class descriptor as the next
 953      * item in the serialization stream.  Subclasses of ObjectInputStream may
 954      * override this method to read in class descriptors that have been written
 955      * in non-standard formats (by subclasses of ObjectOutputStream which have
<span class="line-modified"> 956      * overridden the {@code writeClassDescriptor} method).  By default,</span>
 957      * this method reads class descriptors according to the format defined in
 958      * the Object Serialization specification.
 959      *
 960      * @return  the class descriptor read
 961      * @throws  IOException If an I/O error has occurred.
 962      * @throws  ClassNotFoundException If the Class of a serialized object used
 963      *          in the class descriptor representation cannot be found
 964      * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
 965      * @since 1.3
 966      */
 967     protected ObjectStreamClass readClassDescriptor()
 968         throws IOException, ClassNotFoundException
 969     {
 970         ObjectStreamClass desc = new ObjectStreamClass();
 971         desc.readNonProxy(this);
 972         return desc;
 973     }
 974 
 975     /**
 976      * Reads a byte of data. This method will block if no input is available.
</pre>
<hr />
<pre>
 998      *          {@code buf.length - off}.
 999      * @throws  IOException If an I/O error has occurred.
1000      * @see java.io.DataInputStream#readFully(byte[],int,int)
1001      */
1002     public int read(byte[] buf, int off, int len) throws IOException {
1003         if (buf == null) {
1004             throw new NullPointerException();
1005         }
1006         int endoff = off + len;
1007         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
1008             throw new IndexOutOfBoundsException();
1009         }
1010         return bin.read(buf, off, len, false);
1011     }
1012 
1013     /**
1014      * Returns the number of bytes that can be read without blocking.
1015      *
1016      * @return  the number of available bytes.
1017      * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">1018      *          underlying {@code InputStream}</span>
1019      */
1020     public int available() throws IOException {
1021         return bin.available();
1022     }
1023 
1024     /**
1025      * Closes the input stream. Must be called to release any resources
1026      * associated with the stream.
1027      *
1028      * @throws  IOException If an I/O error has occurred.
1029      */
1030     public void close() throws IOException {
1031         /*
1032          * Even if stream already closed, propagate redundant close to
1033          * underlying stream to stay consistent with previous implementations.
1034          */
1035         closed = true;
1036         if (depth == 0) {
1037             clear();
1038         }
</pre>
<hr />
<pre>
1181         }
1182         bin.readFully(buf, off, len, false);
1183     }
1184 
1185     /**
1186      * Skips bytes.
1187      *
1188      * @param   len the number of bytes to be skipped
1189      * @return  the actual number of bytes skipped.
1190      * @throws  IOException If an I/O error has occurred.
1191      */
1192     public int skipBytes(int len) throws IOException {
1193         return bin.skipBytes(len);
1194     }
1195 
1196     /**
1197      * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
1198      *
1199      * @return  a String copy of the line.
1200      * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">1201      *          underlying {@code InputStream}</span>
1202      * @deprecated This method does not properly convert bytes to characters.
1203      *          see DataInputStream for the details and alternatives.
1204      */
1205     @Deprecated
1206     public String readLine() throws IOException {
1207         return bin.readLine();
1208     }
1209 
1210     /**
1211      * Reads a String in
1212      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
1213      * format.
1214      *
1215      * @return  the String.
1216      * @throws  IOException if there are I/O errors while reading from the
<span class="line-modified">1217      *          underlying {@code InputStream}</span>
1218      * @throws  UTFDataFormatException if read bytes do not represent a valid
1219      *          modified UTF-8 encoding of a string
1220      */
1221     public String readUTF() throws IOException {
1222         return bin.readUTF();
1223     }
1224 
1225     /**
1226      * Returns the serialization filter for this stream.
1227      * The serialization filter is the most recent filter set in
1228      * {@link #setObjectInputFilter setObjectInputFilter} or
1229      * the initial system-wide filter from
1230      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.
1231      *
1232      * @return the serialization filter for the stream; may be null
1233      * @since 9
1234      */
1235     public final ObjectInputFilter getObjectInputFilter() {
1236         return serialFilter;
1237     }
</pre>
<hr />
<pre>
1373      * @throws IllegalArgumentException if arrayType isn&#39;t actually an array type
1374      * @throws NegativeArraySizeException if arrayLength is negative
1375      * @throws InvalidClassException if the filter rejects creation
1376      */
1377     private void checkArray(Class&lt;?&gt; arrayType, int arrayLength) throws InvalidClassException {
1378         if (! arrayType.isArray()) {
1379             throw new IllegalArgumentException(&quot;not an array type&quot;);
1380         }
1381 
1382         if (arrayLength &lt; 0) {
1383             throw new NegativeArraySizeException();
1384         }
1385 
1386         filterCheck(arrayType, arrayLength);
1387     }
1388 
1389     /**
1390      * Provide access to the persistent fields read from the input stream.
1391      */
1392     public abstract static class GetField {
<span class="line-added">1393         /**</span>
<span class="line-added">1394          * Constructor for subclasses to call.</span>
<span class="line-added">1395          */</span>
<span class="line-added">1396         public GetField() {}</span>
1397 
1398         /**
1399          * Get the ObjectStreamClass that describes the fields in the stream.
1400          *
1401          * @return  the descriptor class that describes the serializable fields
1402          */
1403         public abstract ObjectStreamClass getObjectStreamClass();
1404 
1405         /**
1406          * Return true if the named field is defaulted and has no value in this
1407          * stream.
1408          *
1409          * @param  name the name of the field
1410          * @return true, if and only if the named field is defaulted
1411          * @throws IOException if there are I/O errors while reading from
<span class="line-modified">1412          *         the underlying {@code InputStream}</span>
<span class="line-modified">1413          * @throws IllegalArgumentException if {@code name} does not</span>
1414          *         correspond to a serializable field
1415          */
1416         public abstract boolean defaulted(String name) throws IOException;
1417 
1418         /**
1419          * Get the value of the named boolean field from the persistent field.
1420          *
1421          * @param  name the name of the field
<span class="line-modified">1422          * @param  val the default value to use if {@code name} does not</span>
1423          *         have a value
<span class="line-modified">1424          * @return the value of the named {@code boolean} field</span>
1425          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1426          *         underlying {@code InputStream}</span>
<span class="line-modified">1427          * @throws IllegalArgumentException if type of {@code name} is</span>
1428          *         not serializable or if the field type is incorrect
1429          */
1430         public abstract boolean get(String name, boolean val)
1431             throws IOException;
1432 
1433         /**
1434          * Get the value of the named byte field from the persistent field.
1435          *
1436          * @param  name the name of the field
<span class="line-modified">1437          * @param  val the default value to use if {@code name} does not</span>
1438          *         have a value
<span class="line-modified">1439          * @return the value of the named {@code byte} field</span>
1440          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1441          *         underlying {@code InputStream}</span>
<span class="line-modified">1442          * @throws IllegalArgumentException if type of {@code name} is</span>
1443          *         not serializable or if the field type is incorrect
1444          */
1445         public abstract byte get(String name, byte val) throws IOException;
1446 
1447         /**
1448          * Get the value of the named char field from the persistent field.
1449          *
1450          * @param  name the name of the field
<span class="line-modified">1451          * @param  val the default value to use if {@code name} does not</span>
1452          *         have a value
<span class="line-modified">1453          * @return the value of the named {@code char} field</span>
1454          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1455          *         underlying {@code InputStream}</span>
<span class="line-modified">1456          * @throws IllegalArgumentException if type of {@code name} is</span>
1457          *         not serializable or if the field type is incorrect
1458          */
1459         public abstract char get(String name, char val) throws IOException;
1460 
1461         /**
1462          * Get the value of the named short field from the persistent field.
1463          *
1464          * @param  name the name of the field
<span class="line-modified">1465          * @param  val the default value to use if {@code name} does not</span>
1466          *         have a value
<span class="line-modified">1467          * @return the value of the named {@code short} field</span>
1468          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1469          *         underlying {@code InputStream}</span>
<span class="line-modified">1470          * @throws IllegalArgumentException if type of {@code name} is</span>
1471          *         not serializable or if the field type is incorrect
1472          */
1473         public abstract short get(String name, short val) throws IOException;
1474 
1475         /**
1476          * Get the value of the named int field from the persistent field.
1477          *
1478          * @param  name the name of the field
<span class="line-modified">1479          * @param  val the default value to use if {@code name} does not</span>
1480          *         have a value
<span class="line-modified">1481          * @return the value of the named {@code int} field</span>
1482          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1483          *         underlying {@code InputStream}</span>
<span class="line-modified">1484          * @throws IllegalArgumentException if type of {@code name} is</span>
1485          *         not serializable or if the field type is incorrect
1486          */
1487         public abstract int get(String name, int val) throws IOException;
1488 
1489         /**
1490          * Get the value of the named long field from the persistent field.
1491          *
1492          * @param  name the name of the field
<span class="line-modified">1493          * @param  val the default value to use if {@code name} does not</span>
1494          *         have a value
<span class="line-modified">1495          * @return the value of the named {@code long} field</span>
1496          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1497          *         underlying {@code InputStream}</span>
<span class="line-modified">1498          * @throws IllegalArgumentException if type of {@code name} is</span>
1499          *         not serializable or if the field type is incorrect
1500          */
1501         public abstract long get(String name, long val) throws IOException;
1502 
1503         /**
1504          * Get the value of the named float field from the persistent field.
1505          *
1506          * @param  name the name of the field
<span class="line-modified">1507          * @param  val the default value to use if {@code name} does not</span>
1508          *         have a value
<span class="line-modified">1509          * @return the value of the named {@code float} field</span>
1510          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1511          *         underlying {@code InputStream}</span>
<span class="line-modified">1512          * @throws IllegalArgumentException if type of {@code name} is</span>
1513          *         not serializable or if the field type is incorrect
1514          */
1515         public abstract float get(String name, float val) throws IOException;
1516 
1517         /**
1518          * Get the value of the named double field from the persistent field.
1519          *
1520          * @param  name the name of the field
<span class="line-modified">1521          * @param  val the default value to use if {@code name} does not</span>
1522          *         have a value
<span class="line-modified">1523          * @return the value of the named {@code double} field</span>
1524          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1525          *         underlying {@code InputStream}</span>
<span class="line-modified">1526          * @throws IllegalArgumentException if type of {@code name} is</span>
1527          *         not serializable or if the field type is incorrect
1528          */
1529         public abstract double get(String name, double val) throws IOException;
1530 
1531         /**
1532          * Get the value of the named Object field from the persistent field.
1533          *
1534          * @param  name the name of the field
<span class="line-modified">1535          * @param  val the default value to use if {@code name} does not</span>
1536          *         have a value
<span class="line-modified">1537          * @return the value of the named {@code Object} field</span>
1538          * @throws IOException if there are I/O errors while reading from the
<span class="line-modified">1539          *         underlying {@code InputStream}</span>
<span class="line-modified">1540          * @throws IllegalArgumentException if type of {@code name} is</span>
1541          *         not serializable or if the field type is incorrect
1542          */
1543         public abstract Object get(String name, Object val) throws IOException;
1544     }
1545 
1546     /**
1547      * Verifies that this (possibly subclass) instance can be constructed
1548      * without violating security constraints: the subclass must not override
1549      * security-sensitive non-final methods, or else the
1550      * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.
1551      */
1552     private void verifySubclass() {
1553         Class&lt;?&gt; cl = getClass();
1554         if (cl == ObjectInputStream.class) {
1555             return;
1556         }
1557         SecurityManager sm = System.getSecurityManager();
1558         if (sm == null) {
1559             return;
1560         }
</pre>
<hr />
<pre>
1594                             return Boolean.FALSE;
1595                         } catch (NoSuchMethodException ex) {
1596                         }
1597                     }
1598                     return Boolean.TRUE;
1599                 }
1600             }
1601         );
1602     }
1603 
1604     /**
1605      * Clears internal data structures.
1606      */
1607     private void clear() {
1608         handles.clear();
1609         vlist.clear();
1610     }
1611 
1612     /**
1613      * Underlying readObject implementation.
<span class="line-added">1614      * @param type a type expected to be deserialized; non-null</span>
<span class="line-added">1615      * @param unshared true if the object can not be a reference to a shared object, otherwise false</span>
1616      */
<span class="line-modified">1617     private Object readObject0(Class&lt;?&gt; type, boolean unshared) throws IOException {</span>
1618         boolean oldMode = bin.getBlockDataMode();
1619         if (oldMode) {
1620             int remain = bin.currentBlockRemaining();
1621             if (remain &gt; 0) {
1622                 throw new OptionalDataException(remain);
1623             } else if (defaultDataEnd) {
1624                 /*
1625                  * Fix for 4360508: stream is currently at the end of a field
1626                  * value block written via default serialization; since there
1627                  * is no terminating TC_ENDBLOCKDATA tag, simulate
1628                  * end-of-custom-data behavior explicitly.
1629                  */
1630                 throw new OptionalDataException(true);
1631             }
1632             bin.setBlockDataMode(false);
1633         }
1634 
1635         byte tc;
1636         while ((tc = bin.peekByte()) == TC_RESET) {
1637             bin.readByte();
1638             handleReset();
1639         }
1640 
1641         depth++;
1642         totalObjectRefs++;
1643         try {
1644             switch (tc) {
1645                 case TC_NULL:
1646                     return readNull();
1647 
1648                 case TC_REFERENCE:
<span class="line-modified">1649                     // check the type of the existing object</span>
<span class="line-added">1650                     return type.cast(readHandle(unshared));</span>
1651 
1652                 case TC_CLASS:
<span class="line-added">1653                     if (type == String.class) {</span>
<span class="line-added">1654                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);</span>
<span class="line-added">1655                     }</span>
1656                     return readClass(unshared);
1657 
1658                 case TC_CLASSDESC:
1659                 case TC_PROXYCLASSDESC:
<span class="line-added">1660                     if (type == String.class) {</span>
<span class="line-added">1661                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);</span>
<span class="line-added">1662                     }</span>
1663                     return readClassDesc(unshared);
1664 
1665                 case TC_STRING:
1666                 case TC_LONGSTRING:
1667                     return checkResolve(readString(unshared));
1668 
1669                 case TC_ARRAY:
<span class="line-added">1670                     if (type == String.class) {</span>
<span class="line-added">1671                         throw new ClassCastException(&quot;Cannot cast an array to java.lang.String&quot;);</span>
<span class="line-added">1672                     }</span>
1673                     return checkResolve(readArray(unshared));
1674 
1675                 case TC_ENUM:
<span class="line-added">1676                     if (type == String.class) {</span>
<span class="line-added">1677                         throw new ClassCastException(&quot;Cannot cast an enum to java.lang.String&quot;);</span>
<span class="line-added">1678                     }</span>
1679                     return checkResolve(readEnum(unshared));
1680 
1681                 case TC_OBJECT:
<span class="line-added">1682                     if (type == String.class) {</span>
<span class="line-added">1683                         throw new ClassCastException(&quot;Cannot cast an object to java.lang.String&quot;);</span>
<span class="line-added">1684                     }</span>
1685                     return checkResolve(readOrdinaryObject(unshared));
1686 
1687                 case TC_EXCEPTION:
<span class="line-added">1688                     if (type == String.class) {</span>
<span class="line-added">1689                         throw new ClassCastException(&quot;Cannot cast an exception to java.lang.String&quot;);</span>
<span class="line-added">1690                     }</span>
1691                     IOException ex = readFatalException();
1692                     throw new WriteAbortedException(&quot;writing aborted&quot;, ex);
1693 
1694                 case TC_BLOCKDATA:
1695                 case TC_BLOCKDATALONG:
1696                     if (oldMode) {
1697                         bin.setBlockDataMode(true);
1698                         bin.peek();             // force header read
1699                         throw new OptionalDataException(
1700                             bin.currentBlockRemaining());
1701                     } else {
1702                         throw new StreamCorruptedException(
1703                             &quot;unexpected block data&quot;);
1704                     }
1705 
1706                 case TC_ENDBLOCKDATA:
1707                     if (oldMode) {
1708                         throw new OptionalDataException(true);
1709                     } else {
1710                         throw new StreamCorruptedException(
</pre>
<hr />
<pre>
2042         ObjectStreamClass desc = readClassDesc(false);
2043         int len = bin.readInt();
2044 
2045         filterCheck(desc.forClass(), len);
2046 
2047         Object array = null;
2048         Class&lt;?&gt; cl, ccl = null;
2049         if ((cl = desc.forClass()) != null) {
2050             ccl = cl.getComponentType();
2051             array = Array.newInstance(ccl, len);
2052         }
2053 
2054         int arrayHandle = handles.assign(unshared ? unsharedMarker : array);
2055         ClassNotFoundException resolveEx = desc.getResolveException();
2056         if (resolveEx != null) {
2057             handles.markException(arrayHandle, resolveEx);
2058         }
2059 
2060         if (ccl == null) {
2061             for (int i = 0; i &lt; len; i++) {
<span class="line-modified">2062                 readObject0(Object.class, false);</span>
2063             }
2064         } else if (ccl.isPrimitive()) {
2065             if (ccl == Integer.TYPE) {
2066                 bin.readInts((int[]) array, 0, len);
2067             } else if (ccl == Byte.TYPE) {
2068                 bin.readFully((byte[]) array, 0, len, true);
2069             } else if (ccl == Long.TYPE) {
2070                 bin.readLongs((long[]) array, 0, len);
2071             } else if (ccl == Float.TYPE) {
2072                 bin.readFloats((float[]) array, 0, len);
2073             } else if (ccl == Double.TYPE) {
2074                 bin.readDoubles((double[]) array, 0, len);
2075             } else if (ccl == Short.TYPE) {
2076                 bin.readShorts((short[]) array, 0, len);
2077             } else if (ccl == Character.TYPE) {
2078                 bin.readChars((char[]) array, 0, len);
2079             } else if (ccl == Boolean.TYPE) {
2080                 bin.readBooleans((boolean[]) array, 0, len);
2081             } else {
2082                 throw new InternalError();
2083             }
2084         } else {
2085             Object[] oa = (Object[]) array;
2086             for (int i = 0; i &lt; len; i++) {
<span class="line-modified">2087                 oa[i] = readObject0(Object.class, false);</span>
2088                 handles.markDependency(arrayHandle, passHandle);
2089             }
2090         }
2091 
2092         handles.finish(arrayHandle);
2093         passHandle = arrayHandle;
2094         return array;
2095     }
2096 
2097     /**
2098      * Reads in and returns enum constant, or null if enum type is
2099      * unresolvable.  Sets passHandle to enum constant&#39;s assigned handle.
2100      */
2101     private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException {
2102         if (bin.readByte() != TC_ENUM) {
2103             throw new InternalError();
2104         }
2105 
2106         ObjectStreamClass desc = readClassDesc(false);
2107         if (!desc.isEnum()) {
</pre>
<hr />
<pre>
2120         if (cl != null) {
2121             try {
2122                 @SuppressWarnings(&quot;unchecked&quot;)
2123                 Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);
2124                 result = en;
2125             } catch (IllegalArgumentException ex) {
2126                 throw (IOException) new InvalidObjectException(
2127                     &quot;enum constant &quot; + name + &quot; does not exist in &quot; +
2128                     cl).initCause(ex);
2129             }
2130             if (!unshared) {
2131                 handles.setObject(enumHandle, result);
2132             }
2133         }
2134 
2135         handles.finish(enumHandle);
2136         passHandle = enumHandle;
2137         return result;
2138     }
2139 
<span class="line-added">2140     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2141     private static boolean isRecord(Class&lt;?&gt; cls) {</span>
<span class="line-added">2142         return cls.isRecord();</span>
<span class="line-added">2143     }</span>
<span class="line-added">2144 </span>
2145     /**
2146      * Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
2147      * ObjectStreamClass, array, or enum constant) object, or null if object&#39;s
2148      * class is unresolvable (in which case a ClassNotFoundException will be
2149      * associated with object&#39;s handle).  Sets passHandle to object&#39;s assigned
2150      * handle.
2151      */
2152     private Object readOrdinaryObject(boolean unshared)
2153         throws IOException
2154     {
2155         if (bin.readByte() != TC_OBJECT) {
2156             throw new InternalError();
2157         }
2158 
2159         ObjectStreamClass desc = readClassDesc(false);
2160         desc.checkDeserialize();
2161 
2162         Class&lt;?&gt; cl = desc.forClass();
2163         if (cl == String.class || cl == Class.class
2164                 || cl == ObjectStreamClass.class) {
2165             throw new InvalidClassException(&quot;invalid class descriptor&quot;);
2166         }
2167 
2168         Object obj;
2169         try {
2170             obj = desc.isInstantiable() ? desc.newInstance() : null;
2171         } catch (Exception ex) {
2172             throw (IOException) new InvalidClassException(
2173                 desc.forClass().getName(),
2174                 &quot;unable to create instance&quot;).initCause(ex);
2175         }
2176 
2177         passHandle = handles.assign(unshared ? unsharedMarker : obj);
2178         ClassNotFoundException resolveEx = desc.getResolveException();
2179         if (resolveEx != null) {
2180             handles.markException(passHandle, resolveEx);
2181         }
2182 
<span class="line-modified">2183         final boolean isRecord = cl != null &amp;&amp; isRecord(cl) ? true : false;</span>
<span class="line-added">2184         if (isRecord) {</span>
<span class="line-added">2185             assert obj == null;</span>
<span class="line-added">2186             obj = readRecord(desc);</span>
<span class="line-added">2187             handles.setObject(passHandle, obj);</span>
<span class="line-added">2188         } else if (desc.isExternalizable()) {</span>
2189             readExternalData((Externalizable) obj, desc);
2190         } else {
2191             readSerialData(obj, desc);
2192         }
2193 
2194         handles.finish(passHandle);
2195 
2196         if (obj != null &amp;&amp;
2197             handles.lookupException(passHandle) == null &amp;&amp;
2198             desc.hasReadResolveMethod())
2199         {
2200             Object rep = desc.invokeReadResolve(obj);
2201             if (unshared &amp;&amp; rep.getClass().isArray()) {
2202                 rep = cloneArray(rep);
2203             }
2204             if (rep != obj) {
2205                 // Filter the replacement object
2206                 if (rep != null) {
2207                     if (rep.getClass().isArray()) {
2208                         filterCheck(rep.getClass(), Array.getLength(rep));
</pre>
<hr />
<pre>
2254             }
2255         } finally {
2256             if (oldContext != null)
2257                 oldContext.check();
2258             curContext = oldContext;
2259         }
2260         /*
2261          * At this point, if the externalizable data was not written in
2262          * block-data form and either the externalizable class doesn&#39;t exist
2263          * locally (i.e., obj == null) or readExternal() just threw a
2264          * CNFException, then the stream is probably in an inconsistent state,
2265          * since some (or all) of the externalizable data may not have been
2266          * consumed.  Since there&#39;s no &quot;correct&quot; action to take in this case,
2267          * we mimic the behavior of past serialization implementations and
2268          * blindly hope that the stream is in sync; if it isn&#39;t and additional
2269          * externalizable data remains in the stream, a subsequent read will
2270          * most likely throw a StreamCorruptedException.
2271          */
2272     }
2273 
<span class="line-added">2274     /** Reads a record. */</span>
<span class="line-added">2275     private Object readRecord(ObjectStreamClass desc) throws IOException {</span>
<span class="line-added">2276         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span>
<span class="line-added">2277         if (slots.length != 1) {</span>
<span class="line-added">2278             // skip any superclass stream field values</span>
<span class="line-added">2279             for (int i = 0; i &lt; slots.length-1; i++) {</span>
<span class="line-added">2280                 ObjectStreamClass slotDesc = slots[i].desc;</span>
<span class="line-added">2281                 if (slots[i].hasData) {</span>
<span class="line-added">2282                     defaultReadFields(null, slotDesc);</span>
<span class="line-added">2283                 }</span>
<span class="line-added">2284             }</span>
<span class="line-added">2285         }</span>
<span class="line-added">2286 </span>
<span class="line-added">2287         FieldValues fieldValues = defaultReadFields(null, desc);</span>
<span class="line-added">2288 </span>
<span class="line-added">2289         // retrieve the canonical constructor</span>
<span class="line-added">2290         MethodHandle ctrMH = desc.getRecordConstructor();</span>
<span class="line-added">2291 </span>
<span class="line-added">2292         // bind the stream field values</span>
<span class="line-added">2293         ctrMH = RecordSupport.bindCtrValues(ctrMH, desc, fieldValues);</span>
<span class="line-added">2294 </span>
<span class="line-added">2295         try {</span>
<span class="line-added">2296             return ctrMH.invoke();</span>
<span class="line-added">2297         } catch (Exception e) {</span>
<span class="line-added">2298             InvalidObjectException ioe = new InvalidObjectException(e.getMessage());</span>
<span class="line-added">2299             ioe.initCause(e);</span>
<span class="line-added">2300             throw ioe;</span>
<span class="line-added">2301         } catch (Error e) {</span>
<span class="line-added">2302             throw e;</span>
<span class="line-added">2303         } catch (Throwable t) {</span>
<span class="line-added">2304             ObjectStreamException ose = new InvalidObjectException(</span>
<span class="line-added">2305                     &quot;ReflectiveOperationException during deserialization&quot;);</span>
<span class="line-added">2306             ose.initCause(t);</span>
<span class="line-added">2307             throw ose;</span>
<span class="line-added">2308         }</span>
<span class="line-added">2309     }</span>
<span class="line-added">2310 </span>
2311     /**
2312      * Reads (or attempts to skip, if obj is null or is tagged with a
2313      * ClassNotFoundException) instance data for each serializable class of
2314      * object in stream, from superclass to subclass.  Expects that passHandle
2315      * is set to obj&#39;s handle before this method is called.
2316      */
2317     private void readSerialData(Object obj, ObjectStreamClass desc)
2318         throws IOException
2319     {
2320         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2321         // Best effort Failure Atomicity; slotValues will be non-null if field
2322         // values can be set after reading all field data in the hierarchy.
2323         // Field values can only be set after reading all data if there are no
2324         // user observable methods in the hierarchy, readObject(NoData). The
2325         // top most Serializable class in the hierarchy can be skipped.
2326         FieldValues[] slotValues = null;
2327 
2328         boolean hasSpecialReadMethod = false;
2329         for (int i = 1; i &lt; slots.length; i++) {
2330             ObjectStreamClass slotDesc = slots[i].desc;
</pre>
<hr />
<pre>
2431      */
2432     private void skipCustomData() throws IOException {
2433         int oldHandle = passHandle;
2434         for (;;) {
2435             if (bin.getBlockDataMode()) {
2436                 bin.skipBlockData();
2437                 bin.setBlockDataMode(false);
2438             }
2439             switch (bin.peekByte()) {
2440                 case TC_BLOCKDATA:
2441                 case TC_BLOCKDATALONG:
2442                     bin.setBlockDataMode(true);
2443                     break;
2444 
2445                 case TC_ENDBLOCKDATA:
2446                     bin.readByte();
2447                     passHandle = oldHandle;
2448                     return;
2449 
2450                 default:
<span class="line-modified">2451                     readObject0(Object.class, false);</span>
2452                     break;
2453             }
2454         }
2455     }
2456 
<span class="line-modified">2457     /*package-private*/ class FieldValues {</span>
2458         final byte[] primValues;
2459         final Object[] objValues;
2460 
2461         FieldValues(byte[] primValues, Object[] objValues) {
2462             this.primValues = primValues;
2463             this.objValues = objValues;
2464         }
2465     }
2466 
2467     /**
2468      * Reads in values of serializable fields declared by given class
2469      * descriptor. Expects that passHandle is set to obj&#39;s handle before this
2470      * method is called.
2471      */
2472     private FieldValues defaultReadFields(Object obj, ObjectStreamClass desc)
2473         throws IOException
2474     {
2475         Class&lt;?&gt; cl = desc.forClass();
2476         if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {
2477             throw new ClassCastException();
2478         }
2479 
2480         byte[] primVals = null;
2481         int primDataSize = desc.getPrimDataSize();
2482         if (primDataSize &gt; 0) {
2483             primVals = new byte[primDataSize];
2484             bin.readFully(primVals, 0, primDataSize, false);
2485         }
2486 
2487         Object[] objVals = null;
2488         int numObjFields = desc.getNumObjFields();
2489         if (numObjFields &gt; 0) {
2490             int objHandle = passHandle;
2491             ObjectStreamField[] fields = desc.getFields(false);
2492             objVals = new Object[numObjFields];
2493             int numPrimFields = fields.length - objVals.length;
2494             for (int i = 0; i &lt; objVals.length; i++) {
2495                 ObjectStreamField f = fields[numPrimFields + i];
<span class="line-modified">2496                 objVals[i] = readObject0(Object.class, f.isUnshared());</span>
2497                 if (f.getField() != null) {
2498                     handles.markDependency(objHandle, passHandle);
2499                 }
2500             }
2501             passHandle = objHandle;
2502         }
2503 
2504         return new FieldValues(primVals, objVals);
2505     }
2506 
2507     /** Throws ClassCastException if any value is not assignable. */
2508     private void defaultCheckFieldValues(Object obj, ObjectStreamClass desc,
2509                                          FieldValues values) {
2510         Object[] objectValues = values.objValues;
2511         if (objectValues != null)
2512             desc.checkObjFieldValueTypes(obj, objectValues);
2513     }
2514 
2515     /** Sets field values in obj. */
2516     private void defaultSetFieldValues(Object obj, ObjectStreamClass desc,
2517                                        FieldValues values) {
2518         byte[] primValues = values.primValues;
2519         Object[] objectValues = values.objValues;
2520 
2521         if (primValues != null)
2522             desc.setPrimFieldValues(obj, primValues);
2523         if (objectValues != null)
2524             desc.setObjFieldValues(obj, objectValues);
2525     }
2526 
2527     /**
2528      * Reads in and returns IOException that caused serialization to abort.
2529      * All stream state is discarded prior to reading in fatal exception.  Sets
2530      * passHandle to fatal exception&#39;s handle.
2531      */
2532     private IOException readFatalException() throws IOException {
2533         if (bin.readByte() != TC_EXCEPTION) {
2534             throw new InternalError();
2535         }
2536         clear();
<span class="line-modified">2537         return (IOException) readObject0(Object.class, false);</span>
2538     }
2539 
2540     /**
2541      * If recursion depth is 0, clears internal data structures; otherwise,
2542      * throws a StreamCorruptedException.  This method is called when a
2543      * TC_RESET typecode is encountered.
2544      */
2545     private void handleReset() throws StreamCorruptedException {
2546         if (depth &gt; 0) {
2547             throw new StreamCorruptedException(
2548                 &quot;unexpected reset; recursion depth: &quot; + depth);
2549         }
2550         clear();
2551     }
2552 
















2553     /**
2554      * Returns the first non-null and non-platform class loader (not counting
2555      * class loaders of generated reflection implementation classes) up the
2556      * execution stack, or the platform class loader if only code from the
2557      * bootstrap and platform class loader is on the stack.
2558      */
2559     private static ClassLoader latestUserDefinedLoader() {
2560         return jdk.internal.misc.VM.latestUserDefinedLoader();
2561     }
2562 
2563     /**
2564      * Default GetField implementation.
2565      */
2566     private class GetFieldImpl extends GetField {
2567 
2568         /** class descriptor describing serializable fields */
2569         private final ObjectStreamClass desc;
2570         /** primitive field values */
2571         private final byte[] primVals;
2572         /** object field values */
</pre>
<hr />
<pre>
2639                 int objHandle = objHandles[off];
2640                 handles.markDependency(passHandle, objHandle);
2641                 return (handles.lookupException(objHandle) == null) ?
2642                     objVals[off] : null;
2643             } else {
2644                 return val;
2645             }
2646         }
2647 
2648         /**
2649          * Reads primitive and object field values from stream.
2650          */
2651         void readFields() throws IOException {
2652             bin.readFully(primVals, 0, primVals.length, false);
2653 
2654             int oldHandle = passHandle;
2655             ObjectStreamField[] fields = desc.getFields(false);
2656             int numPrimFields = fields.length - objVals.length;
2657             for (int i = 0; i &lt; objVals.length; i++) {
2658                 objVals[i] =
<span class="line-modified">2659                     readObject0(Object.class, fields[numPrimFields + i].isUnshared());</span>
2660                 objHandles[i] = passHandle;
2661             }
2662             passHandle = oldHandle;
2663         }
2664 
2665         /**
2666          * Returns offset of field with given name and type.  A specified type
2667          * of null matches all types, Object.class matches all non-primitive
2668          * types, and any other non-null type matches assignable types only.
2669          * If no matching field is found in the (incoming) class
2670          * descriptor but a matching field is present in the associated local
2671          * class descriptor, returns -1.  Throws IllegalArgumentException if
2672          * neither incoming nor local class descriptor contains a match.
2673          */
2674         private int getFieldOffset(String name, Class&lt;?&gt; type) {
2675             ObjectStreamField field = desc.getField(name, type);
2676             if (field != null) {
2677                 return field.getOffset();
2678             } else if (desc.getLocalDesc().getField(name, type) != null) {
2679                 return -1;
</pre>
<hr />
<pre>
3537                 if (!blkmode) {
3538                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3539                     in.readFully(buf, 0, span &lt;&lt; 2);
3540                     stop = off + span;
3541                     pos = 0;
3542                 } else if (end - pos &lt; 4) {
3543                     v[off++] = din.readInt();
3544                     continue;
3545                 } else {
3546                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 2));
3547                 }
3548 
3549                 while (off &lt; stop) {
3550                     v[off++] = Bits.getInt(buf, pos);
3551                     pos += 4;
3552                 }
3553             }
3554         }
3555 
3556         void readFloats(float[] v, int off, int len) throws IOException {
<span class="line-modified">3557             int stop, endoff = off + len;</span>
3558             while (off &lt; endoff) {
3559                 if (!blkmode) {
<span class="line-modified">3560                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);</span>
3561                     in.readFully(buf, 0, span &lt;&lt; 2);
<span class="line-added">3562                     stop = off + span;</span>
3563                     pos = 0;
3564                 } else if (end - pos &lt; 4) {
3565                     v[off++] = din.readFloat();
3566                     continue;
3567                 } else {
<span class="line-modified">3568                     stop = Math.min(endoff, ((end - pos) &gt;&gt; 2));</span>
3569                 }
3570 
<span class="line-modified">3571                 while (off &lt; stop) {</span>
<span class="line-modified">3572                     v[off++] = Bits.getFloat(buf, pos);</span>
<span class="line-modified">3573                     pos += 4;</span>
<span class="line-added">3574                 }</span>
3575             }
3576         }
3577 
3578         void readLongs(long[] v, int off, int len) throws IOException {
3579             int stop, endoff = off + len;
3580             while (off &lt; endoff) {
3581                 if (!blkmode) {
3582                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3583                     in.readFully(buf, 0, span &lt;&lt; 3);
3584                     stop = off + span;
3585                     pos = 0;
3586                 } else if (end - pos &lt; 8) {
3587                     v[off++] = din.readLong();
3588                     continue;
3589                 } else {
3590                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 3));
3591                 }
3592 
3593                 while (off &lt; stop) {
3594                     v[off++] = Bits.getLong(buf, pos);
3595                     pos += 8;
3596                 }
3597             }
3598         }
3599 
3600         void readDoubles(double[] v, int off, int len) throws IOException {
<span class="line-modified">3601             int stop, endoff = off + len;</span>
3602             while (off &lt; endoff) {
3603                 if (!blkmode) {
<span class="line-modified">3604                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);</span>
3605                     in.readFully(buf, 0, span &lt;&lt; 3);
<span class="line-added">3606                     stop = off + span;</span>
3607                     pos = 0;
3608                 } else if (end - pos &lt; 8) {
3609                     v[off++] = din.readDouble();
3610                     continue;
3611                 } else {
<span class="line-modified">3612                     stop = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));</span>
3613                 }
3614 
<span class="line-modified">3615                 while (off &lt; stop) {</span>
<span class="line-modified">3616                     v[off++] = Bits.getDouble(buf, pos);</span>
<span class="line-modified">3617                     pos += 8;</span>
<span class="line-added">3618                 }</span>
3619             }
3620         }
3621 
3622         /**
3623          * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
3624          * identical to standard UTF, except that it uses an 8 byte header
3625          * (instead of the standard 2 bytes) to convey the UTF encoding length.
3626          */
3627         String readLongUTF() throws IOException {
3628             return readUTFBody(readLong());
3629         }
3630 
3631         /**
3632          * Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
3633          * or 8-byte length header) of a UTF encoding, which occupies the next
3634          * utflen bytes.
3635          */
3636         private String readUTFBody(long utflen) throws IOException {
3637             StringBuilder sbuf;
3638             if (utflen &gt; 0 &amp;&amp; utflen &lt; Integer.MAX_VALUE) {
</pre>
<hr />
<pre>
4128             return ((byte[]) array).clone();
4129         } else if (array instanceof char[]) {
4130             return ((char[]) array).clone();
4131         } else if (array instanceof double[]) {
4132             return ((double[]) array).clone();
4133         } else if (array instanceof float[]) {
4134             return ((float[]) array).clone();
4135         } else if (array instanceof int[]) {
4136             return ((int[]) array).clone();
4137         } else if (array instanceof long[]) {
4138             return ((long[]) array).clone();
4139         } else if (array instanceof short[]) {
4140             return ((short[]) array).clone();
4141         } else {
4142             throw new AssertionError();
4143         }
4144     }
4145 
4146     static {
4147         SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);
<span class="line-added">4148         SharedSecrets.setJavaObjectInputStreamReadString(ObjectInputStream::readString);</span>
4149     }
4150 
4151 }
</pre>
</td>
</tr>
</table>
<center><a href="ObjectInputFilter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ObjectInputValidation.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
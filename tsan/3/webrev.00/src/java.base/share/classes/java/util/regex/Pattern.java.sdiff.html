<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/regex/Pattern.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Matcher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PatternSyntaxException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/regex/Pattern.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  26 package java.util.regex;
  27 
  28 import java.text.Normalizer;
  29 import java.text.Normalizer.Form;
  30 import java.util.Locale;
  31 import java.util.Iterator;
  32 import java.util.Map;
  33 import java.util.ArrayList;
  34 import java.util.HashMap;
  35 import java.util.LinkedHashSet;
  36 import java.util.List;
  37 import java.util.Set;
  38 import java.util.Arrays;
  39 import java.util.NoSuchElementException;
  40 import java.util.Spliterator;
  41 import java.util.Spliterators;
  42 import java.util.function.Predicate;
  43 import java.util.stream.Stream;
  44 import java.util.stream.StreamSupport;
  45 

  46 
  47 /**
  48  * A compiled representation of a regular expression.
  49  *
  50  * &lt;p&gt; A regular expression, specified as a string, must first be compiled into
  51  * an instance of this class.  The resulting pattern can then be used to create
  52  * a {@link Matcher} object that can match arbitrary {@linkplain
  53  * java.lang.CharSequence character sequences} against the regular
  54  * expression.  All of the state involved in performing a match resides in the
  55  * matcher, so many matchers can share the same pattern.
  56  *
  57  * &lt;p&gt; A typical invocation sequence is thus
  58  *
  59  * &lt;blockquote&gt;&lt;pre&gt;
  60  * Pattern p = Pattern.{@link #compile compile}(&quot;a*b&quot;);
  61  * Matcher m = p.{@link #matcher matcher}(&quot;aaaaab&quot;);
  62  * boolean b = m.{@link Matcher#matches matches}();&lt;/pre&gt;&lt;/blockquote&gt;
  63  *
  64  * &lt;p&gt; A {@link #matches matches} method is defined by this class as a
  65  * convenience for when a regular expression is used just once.  This method
  66  * compiles an expression and matches an input sequence against it in a single
  67  * invocation.  The statement
  68  *
  69  * &lt;blockquote&gt;&lt;pre&gt;
  70  * boolean b = Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;);&lt;/pre&gt;&lt;/blockquote&gt;
  71  *
  72  * is equivalent to the three statements above, though for repeated matches it
  73  * is less efficient since it does not allow the compiled pattern to be reused.
  74  *
  75  * &lt;p&gt; Instances of this class are immutable and are safe for use by multiple
  76  * concurrent threads.  Instances of the {@link Matcher} class are not safe for
  77  * such use.
  78  *
  79  *
<span class="line-modified">  80  * &lt;h3&gt;&lt;a id=&quot;sum&quot;&gt;Summary of regular-expression constructs&lt;/a&gt;&lt;/h3&gt;</span>
  81  *
  82  * &lt;table class=&quot;borderless&quot;&gt;
  83  * &lt;caption style=&quot;display:none&quot;&gt;Regular expression constructs, and what they match&lt;/caption&gt;
  84  * &lt;thead style=&quot;text-align:left&quot;&gt;
  85  * &lt;tr&gt;
  86  * &lt;th id=&quot;construct&quot;&gt;Construct&lt;/th&gt;
  87  * &lt;th id=&quot;matches&quot;&gt;Matches&lt;/th&gt;
  88  * &lt;/tr&gt;
  89  * &lt;/thead&gt;
  90  * &lt;tbody style=&quot;text-align:left&quot;&gt;
  91  *
  92  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;characters&quot;&gt;Characters&lt;/th&gt;&lt;/tr&gt;
  93  *
  94  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;x&quot;&gt;&lt;i&gt;x&lt;/i&gt;&lt;/th&gt;
  95  *     &lt;td headers=&quot;matches characters x&quot;&gt;The character &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
  96  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;backslash&quot;&gt;{@code \\}&lt;/th&gt;
  97  *     &lt;td headers=&quot;matches characters backslash&quot;&gt;The backslash character&lt;/td&gt;&lt;/tr&gt;
  98  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;octal_n&quot;&gt;{@code \0}&lt;i&gt;n&lt;/i&gt;&lt;/th&gt;
  99  *     &lt;td headers=&quot;matches characters octal_n&quot;&gt;The character with octal value {@code 0}&lt;i&gt;n&lt;/i&gt;
 100  *         (0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
</pre>
<hr />
<pre>
 339  *
 340  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_follow&quot;&gt;{@code \}&lt;/th&gt;
 341  *     &lt;td headers=&quot;matches quote quote_follow&quot;&gt;Nothing, but quotes the following character&lt;/td&gt;&lt;/tr&gt;
 342  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_begin&quot;&gt;{@code \Q}&lt;/th&gt;
 343  *     &lt;td headers=&quot;matches quote quote_begin&quot;&gt;Nothing, but quotes all characters until {@code \E}&lt;/td&gt;&lt;/tr&gt;
 344  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_end&quot;&gt;{@code \E}&lt;/th&gt;
 345  *     &lt;td headers=&quot;matches quote quote_end&quot;&gt;Nothing, but ends quoting started by {@code \Q}&lt;/td&gt;&lt;/tr&gt;
 346  *     &lt;!-- Metachars: !$()*+.&lt;&gt;?[\]^{|} --&gt;
 347  *
 348  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;special&quot;&gt;Special constructs (named-capturing and non-capturing)&lt;/th&gt;&lt;/tr&gt;
 349  *
 350  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;named_group&quot;&gt;&lt;code&gt;(?&amp;lt;&lt;a href=&quot;#groupname&quot;&gt;name&lt;/a&gt;&amp;gt;&lt;/code&gt;&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 351  *     &lt;td headers=&quot;matches special named_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a named-capturing group&lt;/td&gt;&lt;/tr&gt;
 352  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group&quot;&gt;{@code (?:}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 353  *     &lt;td headers=&quot;matches special non_capture_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a non-capturing group&lt;/td&gt;&lt;/tr&gt;
 354  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;flags&quot;&gt;&lt;code&gt;(?idmsuxU-idmsuxU)&amp;nbsp;&lt;/code&gt;&lt;/th&gt;
 355  *     &lt;td headers=&quot;matches special flags&quot;&gt;Nothing, but turns match flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt;
 356  * &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt; &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt;
 357  * &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a&gt; &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt;
 358  * on - off&lt;/td&gt;&lt;/tr&gt;
<span class="line-modified"> 359  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group_flags&quot;&gt;&lt;code&gt;(?idmsux-idmsux:&lt;/code&gt;&lt;i&gt;X&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;&lt;/th&gt;</span>
 360  *     &lt;td headers=&quot;matches special non_capture_group_flags&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a &lt;a href=&quot;#cg&quot;&gt;non-capturing group&lt;/a&gt; with the
 361  *         given flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt; &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt;
 362  * &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt; &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a &gt;
<span class="line-modified"> 363  * &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; on - off&lt;/td&gt;&lt;/tr&gt;</span>
 364  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookahead&quot;&gt;{@code (?=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 365  *     &lt;td headers=&quot;matches special pos_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookahead&lt;/td&gt;&lt;/tr&gt;
 366  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;neg_lookahead&quot;&gt;{@code (?!}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 367  *     &lt;td headers=&quot;matches special neg_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookahead&lt;/td&gt;&lt;/tr&gt;
 368  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookbehind&quot;&gt;{@code (?&lt;=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 369  *     &lt;td headers=&quot;matches special pos_lookbehind&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookbehind&lt;/td&gt;&lt;/tr&gt;
 370  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;neg_lookbehind&quot;&gt;{@code (?&lt;!}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 371  *     &lt;td headers=&quot;matches special neg_lookbehind&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookbehind&lt;/td&gt;&lt;/tr&gt;
 372  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;indep_non_capture_group&quot;&gt;{@code (?&gt;}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 373  *     &lt;td headers=&quot;matches special indep_non_capture_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as an independent, non-capturing group&lt;/td&gt;&lt;/tr&gt;
 374  *
 375  * &lt;/tbody&gt;
 376  * &lt;/table&gt;
 377  *
 378  * &lt;hr&gt;
 379  *
 380  *
<span class="line-modified"> 381  * &lt;h3&gt;&lt;a id=&quot;bs&quot;&gt;Backslashes, escapes, and quoting&lt;/a&gt;&lt;/h3&gt;</span>
 382  *
 383  * &lt;p&gt; The backslash character ({@code &#39;\&#39;}) serves to introduce escaped
 384  * constructs, as defined in the table above, as well as to quote characters
 385  * that otherwise would be interpreted as unescaped constructs.  Thus the
 386  * expression {@code \\} matches a single backslash and &lt;code&gt;\{&lt;/code&gt; matches a
 387  * left brace.
 388  *
 389  * &lt;p&gt; It is an error to use a backslash prior to any alphabetic character that
 390  * does not denote an escaped construct; these are reserved for future
 391  * extensions to the regular-expression language.  A backslash may be used
 392  * prior to a non-alphabetic character regardless of whether that character is
 393  * part of an unescaped construct.
 394  *
 395  * &lt;p&gt; Backslashes within string literals in Java source code are interpreted
 396  * as required by
 397  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
 398  * as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)
 399  * It is therefore necessary to double backslashes in string
 400  * literals that represent regular expressions to protect them from
 401  * interpretation by the Java bytecode compiler.  The string literal
 402  * &lt;code&gt;&quot;&amp;#92;b&quot;&lt;/code&gt;, for example, matches a single backspace character when
 403  * interpreted as a regular expression, while {@code &quot;\\b&quot;} matches a
 404  * word boundary.  The string literal {@code &quot;\(hello\)&quot;} is illegal
 405  * and leads to a compile-time error; in order to match the string
 406  * {@code (hello)} the string literal {@code &quot;\\(hello\\)&quot;}
 407  * must be used.
 408  *
<span class="line-modified"> 409  * &lt;h3&gt;&lt;a id=&quot;cc&quot;&gt;Character Classes&lt;/a&gt;&lt;/h3&gt;</span>
 410  *
 411  *    &lt;p&gt; Character classes may appear within other character classes, and
 412  *    may be composed by the union operator (implicit) and the intersection
 413  *    operator ({@code &amp;&amp;}).
 414  *    The union operator denotes a class that contains every character that is
 415  *    in at least one of its operand classes.  The intersection operator
 416  *    denotes a class that contains every character that is in both of its
 417  *    operand classes.
 418  *
 419  *    &lt;p&gt; The precedence of character-class operators is as follows, from
 420  *    highest to lowest:
 421  *
 422  *    &lt;table class=&quot;striped&quot; style=&quot;margin-left: 2em;&quot;&gt;
 423  *      &lt;caption style=&quot;display:none&quot;&gt;Precedence of character class operators.&lt;/caption&gt;
 424  *      &lt;thead&gt;
 425  *      &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Precedence&lt;th scope=&quot;col&quot;&gt;Name&lt;th scope=&quot;col&quot;&gt;Example
 426  *      &lt;/thead&gt;
 427  *      &lt;tbody&gt;
 428  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
 429  *        &lt;td&gt;Literal escape&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
</pre>
<hr />
<pre>
 432  *        &lt;td&gt;Grouping&lt;/td&gt;
 433  *        &lt;td&gt;{@code [...]}&lt;/td&gt;&lt;/tr&gt;
 434  *     &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
 435  *        &lt;td&gt;Range&lt;/td&gt;
 436  *        &lt;td&gt;{@code a-z}&lt;/td&gt;&lt;/tr&gt;
 437  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;4&lt;/th&gt;
 438  *        &lt;td&gt;Union&lt;/td&gt;
 439  *        &lt;td&gt;{@code [a-e][i-u]}&lt;/td&gt;&lt;/tr&gt;
 440  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;5&lt;/th&gt;
 441  *        &lt;td&gt;Intersection&lt;/td&gt;
 442  *        &lt;td&gt;{@code [a-z&amp;&amp;[aeiou]]}&lt;/td&gt;&lt;/tr&gt;
 443  *      &lt;/tbody&gt;
 444  *    &lt;/table&gt;
 445  *
 446  *    &lt;p&gt; Note that a different set of metacharacters are in effect inside
 447  *    a character class than outside a character class. For instance, the
 448  *    regular expression {@code .} loses its special meaning inside a
 449  *    character class, while the expression {@code -} becomes a range
 450  *    forming metacharacter.
 451  *
<span class="line-modified"> 452  * &lt;h3&gt;&lt;a id=&quot;lt&quot;&gt;Line terminators&lt;/a&gt;&lt;/h3&gt;</span>
 453  *
 454  * &lt;p&gt; A &lt;i&gt;line terminator&lt;/i&gt; is a one- or two-character sequence that marks
 455  * the end of a line of the input character sequence.  The following are
 456  * recognized as line terminators:
 457  *
 458  * &lt;ul&gt;
 459  *
 460  *   &lt;li&gt; A newline (line feed) character ({@code &#39;\n&#39;}),
 461  *
 462  *   &lt;li&gt; A carriage-return character followed immediately by a newline
 463  *   character ({@code &quot;\r\n&quot;}),
 464  *
 465  *   &lt;li&gt; A standalone carriage-return character ({@code &#39;\r&#39;}),
 466  *
 467  *   &lt;li&gt; A next-line character (&lt;code&gt;&#39;&amp;#92;u0085&#39;&lt;/code&gt;),
 468  *
 469  *   &lt;li&gt; A line-separator character (&lt;code&gt;&#39;&amp;#92;u2028&#39;&lt;/code&gt;), or
 470  *
 471  *   &lt;li&gt; A paragraph-separator character (&lt;code&gt;&#39;&amp;#92;u2029&#39;&lt;/code&gt;).
 472  *
 473  * &lt;/ul&gt;
 474  * &lt;p&gt;If {@link #UNIX_LINES} mode is activated, then the only line terminators
 475  * recognized are newline characters.
 476  *
 477  * &lt;p&gt; The regular expression {@code .} matches any character except a line
 478  * terminator unless the {@link #DOTALL} flag is specified.
 479  *
 480  * &lt;p&gt; By default, the regular expressions {@code ^} and {@code $} ignore
 481  * line terminators and only match at the beginning and the end, respectively,
 482  * of the entire input sequence. If {@link #MULTILINE} mode is activated then
 483  * {@code ^} matches at the beginning of input and after any line terminator
 484  * except at the end of input. When in {@link #MULTILINE} mode {@code $}
 485  * matches just before a line terminator or the end of the input sequence.
 486  *
<span class="line-modified"> 487  * &lt;h3&gt;&lt;a id=&quot;cg&quot;&gt;Groups and capturing&lt;/a&gt;&lt;/h3&gt;</span>
 488  *
<span class="line-modified"> 489  * &lt;h4&gt;&lt;a id=&quot;gnumber&quot;&gt;Group number&lt;/a&gt;&lt;/h4&gt;</span>
 490  * &lt;p&gt; Capturing groups are numbered by counting their opening parentheses from
 491  * left to right.  In the expression {@code ((A)(B(C)))}, for example, there
 492  * are four such groups: &lt;/p&gt;
 493  *
 494  * &lt;ol style=&quot;margin-left:2em;&quot;&gt;
 495  *   &lt;li&gt; {@code ((A)(B(C)))}
 496  *   &lt;li&gt; {@code (A)}
 497  *   &lt;li&gt; {@code (B(C))}
 498  *   &lt;li&gt; {@code (C)}
 499  * &lt;/ol&gt;
 500  *
 501  * &lt;p&gt; Group zero always stands for the entire expression.
 502  *
 503  * &lt;p&gt; Capturing groups are so named because, during a match, each subsequence
 504  * of the input sequence that matches such a group is saved.  The captured
 505  * subsequence may be used later in the expression, via a back reference, and
 506  * may also be retrieved from the matcher once the match operation is complete.
 507  *
<span class="line-modified"> 508  * &lt;h4&gt;&lt;a id=&quot;groupname&quot;&gt;Group name&lt;/a&gt;&lt;/h4&gt;</span>
 509  * &lt;p&gt;A capturing group can also be assigned a &quot;name&quot;, a {@code named-capturing group},
 510  * and then be back-referenced later by the &quot;name&quot;. Group names are composed of
 511  * the following characters. The first character must be a {@code letter}.
 512  *
 513  * &lt;ul&gt;
 514  *   &lt;li&gt; The uppercase letters {@code &#39;A&#39;} through {@code &#39;Z&#39;}
 515  *        (&lt;code&gt;&#39;&amp;#92;u0041&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u005a&#39;&lt;/code&gt;),
 516  *   &lt;li&gt; The lowercase letters {@code &#39;a&#39;} through {@code &#39;z&#39;}
 517  *        (&lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u007a&#39;&lt;/code&gt;),
 518  *   &lt;li&gt; The digits {@code &#39;0&#39;} through {@code &#39;9&#39;}
 519  *        (&lt;code&gt;&#39;&amp;#92;u0030&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u0039&#39;&lt;/code&gt;),
 520  * &lt;/ul&gt;
 521  *
 522  * &lt;p&gt; A {@code named-capturing group} is still numbered as described in
 523  * &lt;a href=&quot;#gnumber&quot;&gt;Group number&lt;/a&gt;.
 524  *
 525  * &lt;p&gt; The captured input associated with a group is always the subsequence
 526  * that the group most recently matched.  If a group is evaluated a second time
 527  * because of quantification then its previously-captured value, if any, will
 528  * be retained if the second evaluation fails.  Matching the string
 529  * {@code &quot;aba&quot;} against the expression {@code (a(b)?)+}, for example, leaves
 530  * group two set to {@code &quot;b&quot;}.  All captured input is discarded at the
 531  * beginning of each match.
 532  *
 533  * &lt;p&gt; Groups beginning with {@code (?} are either pure, &lt;i&gt;non-capturing&lt;/i&gt; groups
 534  * that do not capture text and do not count towards the group total, or
 535  * &lt;i&gt;named-capturing&lt;/i&gt; group.
 536  *
<span class="line-modified"> 537  * &lt;h3&gt; Unicode support &lt;/h3&gt;</span>
 538  *
 539  * &lt;p&gt; This class is in conformance with Level 1 of &lt;a
 540  * href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
 541  * Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;, plus RL2.1
<span class="line-modified"> 542  * Canonical Equivalents.</span>
 543  * &lt;p&gt;
 544  * &lt;b&gt;Unicode escape sequences&lt;/b&gt; such as &lt;code&gt;&amp;#92;u2014&lt;/code&gt; in Java source code
 545  * are processed as described in section 3.3 of
 546  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 547  * Such escape sequences are also implemented directly by the regular-expression
 548  * parser so that Unicode escapes can be used in expressions that are read from
 549  * files or from the keyboard.  Thus the strings &lt;code&gt;&quot;&amp;#92;u2014&quot;&lt;/code&gt; and
 550  * {@code &quot;\\u2014&quot;}, while not equal, compile into the same pattern, which
 551  * matches the character with hexadecimal value {@code 0x2014}.
 552  * &lt;p&gt;
 553  * A Unicode character can also be represented by using its &lt;b&gt;Hex notation&lt;/b&gt;
 554  * (hexadecimal code point value) directly as described in construct
 555  * &lt;code&gt;&amp;#92;x{...}&lt;/code&gt;, for example a supplementary character U+2011F can be
 556  * specified as &lt;code&gt;&amp;#92;x{2011F}&lt;/code&gt;, instead of two consecutive Unicode escape
 557  * sequences of the surrogate pair &lt;code&gt;&amp;#92;uD840&lt;/code&gt;&lt;code&gt;&amp;#92;uDD1F&lt;/code&gt;.
 558  * &lt;p&gt;
 559  * &lt;b&gt;Unicode character names&lt;/b&gt; are supported by the named character construct
 560  * &lt;code&gt;\N{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt;, for example, &lt;code&gt;\N{WHITE SMILING FACE}&lt;/code&gt;
 561  * specifies character &lt;code&gt;&amp;#92;u263A&lt;/code&gt;. The character names supported
 562  * by this class are the valid Unicode character names matched by
</pre>
<hr />
<pre>
 671  *     &lt;td&gt;A digit: {@code \p{IsDigit}}&lt;/td&gt;&lt;/tr&gt;
 672  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \D}&lt;/th&gt;
 673  *     &lt;td&gt;A non-digit: {@code [^\d]}&lt;/td&gt;&lt;/tr&gt;
 674  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \s}&lt;/th&gt;
 675  *     &lt;td&gt;A whitespace character: {@code \p{IsWhite_Space}}&lt;/td&gt;&lt;/tr&gt;
 676  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \S}&lt;/th&gt;
 677  *     &lt;td&gt;A non-whitespace character: {@code [^\s]}&lt;/td&gt;&lt;/tr&gt;
 678  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \w}&lt;/th&gt;
 679  *     &lt;td&gt;A word character: {@code [\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}]}&lt;/td&gt;&lt;/tr&gt;
 680  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \W}&lt;/th&gt;
 681  *     &lt;td&gt;A non-word character: {@code [^\w]}&lt;/td&gt;&lt;/tr&gt;
 682  * &lt;/tbody&gt;
 683  * &lt;/table&gt;
 684  * &lt;p&gt;
 685  * &lt;a id=&quot;jcc&quot;&gt;
 686  * Categories that behave like the java.lang.Character
 687  * boolean is&lt;i&gt;methodname&lt;/i&gt; methods (except for the deprecated ones) are
 688  * available through the same &lt;code&gt;\p{&lt;/code&gt;&lt;i&gt;prop&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; syntax where
 689  * the specified property has the name &lt;code&gt;java&lt;i&gt;methodname&lt;/i&gt;&lt;/code&gt;&lt;/a&gt;.
 690  *
<span class="line-modified"> 691  * &lt;h3&gt; Comparison to Perl 5 &lt;/h3&gt;</span>
 692  *
 693  * &lt;p&gt;The {@code Pattern} engine performs traditional NFA-based matching
 694  * with ordered alternation as occurs in Perl 5.
 695  *
 696  * &lt;p&gt; Perl constructs not supported by this class: &lt;/p&gt;
 697  *
 698  * &lt;ul&gt;
 699  *    &lt;li&gt;&lt;p&gt; The backreference constructs, &lt;code&gt;\g{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; for
 700  *    the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;&lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; and
 701  *    &lt;code&gt;\g{&lt;/code&gt;&lt;i&gt;name&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; for
 702  *    &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt;.
 703  *    &lt;/p&gt;&lt;/li&gt;
 704  *
 705  *    &lt;li&gt;&lt;p&gt; The conditional constructs
 706  *    {@code (?(}&lt;i&gt;condition&lt;/i&gt;{@code )}&lt;i&gt;X&lt;/i&gt;{@code )} and
 707  *    {@code (?(}&lt;i&gt;condition&lt;/i&gt;{@code )}&lt;i&gt;X&lt;/i&gt;{@code |}&lt;i&gt;Y&lt;/i&gt;{@code )},
 708  *    &lt;/p&gt;&lt;/li&gt;
 709  *
 710  *    &lt;li&gt;&lt;p&gt; The embedded code constructs &lt;code&gt;(?{&lt;/code&gt;&lt;i&gt;code&lt;/i&gt;&lt;code&gt;})&lt;/code&gt;
 711  *    and &lt;code&gt;(??{&lt;/code&gt;&lt;i&gt;code&lt;/i&gt;&lt;code&gt;})&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;
</pre>
<hr />
<pre>
 917      * folding.
 918      * &lt;p&gt;
 919      * Specifying this flag may impose a performance penalty.  &lt;/p&gt;
 920      * @since 1.7
 921      */
 922     public static final int UNICODE_CHARACTER_CLASS = 0x100;
 923 
 924     /**
 925      * Contains all possible flags for compile(regex, flags).
 926      */
 927     private static final int ALL_FLAGS = CASE_INSENSITIVE | MULTILINE |
 928             DOTALL | UNICODE_CASE | CANON_EQ | UNIX_LINES | LITERAL |
 929             UNICODE_CHARACTER_CLASS | COMMENTS;
 930 
 931     /* Pattern has only two serialized components: The pattern string
 932      * and the flags, which are all that is needed to recompile the pattern
 933      * when it is deserialized.
 934      */
 935 
 936     /** use serialVersionUID from Merlin b59 for interoperability */

 937     private static final long serialVersionUID = 5073258162644648461L;
 938 
 939     /**
 940      * The original regular-expression pattern string.
 941      *
 942      * @serial
 943      */
 944     private String pattern;
 945 
 946     /**
 947      * The original pattern flags.
 948      *
 949      * @serial
 950      */
 951     private int flags;
 952 
 953     /**
 954      * The temporary pattern flags used during compiling. The flags might be turn
 955      * on and off by embedded flag.
 956      */
</pre>
<hr />
<pre>
1358                 (lenHint &lt;&lt; 1) : (Integer.MAX_VALUE - 8);
1359 
1360         StringBuilder sb = new StringBuilder(lenHint);
1361         sb.append(&quot;\\Q&quot;);
1362         int current = 0;
1363         do {
1364             sb.append(s, current, slashEIndex)
1365                     .append(&quot;\\E\\\\E\\Q&quot;);
1366             current = slashEIndex + 2;
1367         } while ((slashEIndex = s.indexOf(&quot;\\E&quot;, current)) != -1);
1368 
1369         return sb.append(s, current, s.length())
1370                 .append(&quot;\\E&quot;)
1371                 .toString();
1372     }
1373 
1374     /**
1375      * Recompile the Pattern instance from a stream.  The original pattern
1376      * string is read in and the object tree is recompiled from it.
1377      */

1378     private void readObject(java.io.ObjectInputStream s)
1379         throws java.io.IOException, ClassNotFoundException {
1380 
1381         // Read in all fields
1382         s.defaultReadObject();
1383 
1384         // reset the flags
1385         flags0 = flags;
1386 
1387         // Initialize counts
1388         capturingGroupCount = 1;
1389         localCount = 0;
1390         localTCNCount = 0;
1391 
1392         // if length &gt; 0, the Pattern is lazily compiled
1393         if (pattern.isEmpty()) {
1394             root = new Start(lastAccept);
1395             matchRoot = lastAccept;
1396             compiled = true;
1397         }
</pre>
<hr />
<pre>
1407         if ((f &amp; ~ALL_FLAGS) != 0) {
1408             throw new IllegalArgumentException(&quot;Unknown flag 0x&quot;
1409                                                + Integer.toHexString(f));
1410         }
1411         pattern = p;
1412         flags = f;
1413 
1414         // to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present
1415         if ((flags &amp; UNICODE_CHARACTER_CLASS) != 0)
1416             flags |= UNICODE_CASE;
1417 
1418         // &#39;flags&#39; for compiling
1419         flags0 = flags;
1420 
1421         // Reset group index count
1422         capturingGroupCount = 1;
1423         localCount = 0;
1424         localTCNCount = 0;
1425 
1426         if (!pattern.isEmpty()) {
<span class="line-modified">1427             compile();</span>




1428         } else {
1429             root = new Start(lastAccept);
1430             matchRoot = lastAccept;
1431         }
1432     }
1433 
1434     /**
1435      * The pattern is converted to normalized form ({@link
1436      * java.text.Normalizer.Form#NFC NFC}, canonical decomposition,
1437      * followed by canonical composition for the character class
1438      * part, and {@link java.text.Normalizer.Form#NFD NFD},
1439      * canonical decomposition for the rest), and then a pure
1440      * group is constructed to match canonical equivalences of the
1441      * characters.
1442      */
1443     private static String normalize(String pattern) {
1444         int plen = pattern.length();
1445         StringBuilder pbuf = new StringBuilder(plen);
1446         char last = 0;
1447         int lastStart = 0;
</pre>
<hr />
<pre>
1483         int off0 = off;
1484         while (off &lt; limit &amp;&amp; ASCII.isAscii(src.charAt(off))) {
1485             off++;
1486         }
1487         if (off == limit) {
1488             dst.append(src, off0, limit);
1489             return;
1490         }
1491         off--;
1492         if (off &lt; off0)
1493             off = off0;
1494         else
1495             dst.append(src, off0, off);
1496         while (off &lt; limit) {
1497             int ch0 = src.codePointAt(off);
1498             if (&quot;.$|()[]{}^?*+\\&quot;.indexOf(ch0) != -1) {
1499                 dst.append((char)ch0);
1500                 off++;
1501                 continue;
1502             }
<span class="line-modified">1503             int j = off + Character.charCount(ch0);</span>
1504             int ch1;
<span class="line-removed">1505             while (j &lt; limit) {</span>
<span class="line-removed">1506                 ch1 = src.codePointAt(j);</span>
<span class="line-removed">1507                 if (Grapheme.isBoundary(ch0, ch1))</span>
<span class="line-removed">1508                     break;</span>
<span class="line-removed">1509                 ch0 = ch1;</span>
<span class="line-removed">1510                 j += Character.charCount(ch1);</span>
<span class="line-removed">1511             }</span>
1512             String seq = src.substring(off, j);
1513             String nfd = Normalizer.normalize(seq, Normalizer.Form.NFD);
1514             off = j;
<span class="line-modified">1515             if (nfd.length() &gt; 1) {</span>
1516                 ch0 = nfd.codePointAt(0);
1517                 ch1 = nfd.codePointAt(Character.charCount(ch0));
1518                 if (Character.getType(ch1) == Character.NON_SPACING_MARK) {
1519                     Set&lt;String&gt; altns = new LinkedHashSet&lt;&gt;();
1520                     altns.add(seq);
1521                     produceEquivalentAlternation(nfd, altns);
1522                     dst.append(&quot;(?:&quot;);
1523                     altns.forEach( s -&gt; dst.append(s).append(&#39;|&#39;));
1524                     dst.delete(dst.length() - 1, dst.length());
1525                     dst.append(&quot;)&quot;);
1526                     continue;
1527                 }
1528             }
1529             String nfc = Normalizer.normalize(seq, Normalizer.Form.NFC);
1530             if (!seq.equals(nfc) &amp;&amp; !nfd.equals(nfc))
1531                 dst.append(&quot;(?:&quot; + seq + &quot;|&quot; + nfd  + &quot;|&quot; + nfc + &quot;)&quot;);
1532             else if (!seq.equals(nfd))
1533                 dst.append(&quot;(?:&quot; + seq + &quot;|&quot; + nfd + &quot;)&quot;);
1534             else
1535                 dst.append(seq);
</pre>
<hr />
<pre>
1661 
1662     /**
1663      * Preprocess any \Q...\E sequences in `temp&#39;, meta-quoting them.
1664      * See the description of `quotemeta&#39; in perlfunc(1).
1665      */
1666     private void RemoveQEQuoting() {
1667         final int pLen = patternLength;
1668         int i = 0;
1669         while (i &lt; pLen-1) {
1670             if (temp[i] != &#39;\\&#39;)
1671                 i += 1;
1672             else if (temp[i + 1] != &#39;Q&#39;)
1673                 i += 2;
1674             else
1675                 break;
1676         }
1677         if (i &gt;= pLen - 1)    // No \Q sequence found
1678             return;
1679         int j = i;
1680         i += 2;
<span class="line-modified">1681         int[] newtemp = new int[j + 3*(pLen-i) + 2];</span>






1682         System.arraycopy(temp, 0, newtemp, 0, j);
1683 
1684         boolean inQuote = true;
1685         boolean beginQuote = true;
1686         while (i &lt; pLen) {
1687             int c = temp[i++];
1688             if (!ASCII.isAscii(c) || ASCII.isAlpha(c)) {
1689                 newtemp[j++] = c;
1690             } else if (ASCII.isDigit(c)) {
1691                 if (beginQuote) {
1692                     /*
1693                      * A unicode escape \[0xu] could be before this quote,
1694                      * and we don&#39;t want this numeric char to processed as
1695                      * part of the escape.
1696                      */
1697                     newtemp[j++] = &#39;\\&#39;;
1698                     newtemp[j++] = &#39;x&#39;;
1699                     newtemp[j++] = &#39;3&#39;;
1700                 }
1701                 newtemp[j++] = c;
</pre>
<hr />
<pre>
1946     /**
1947      * If in xmode parse past whitespace and comments.
1948      */
1949     private int parsePastWhitespace(int ch) {
1950         while (ASCII.isSpace(ch) || ch == &#39;#&#39;) {
1951             while (ASCII.isSpace(ch))
1952                 ch = temp[cursor++];
1953             if (ch == &#39;#&#39;)
1954                 ch = parsePastLine();
1955         }
1956         return ch;
1957     }
1958 
1959     /**
1960      * xmode parse past comment to end of line.
1961      */
1962     private int parsePastLine() {
1963         int ch = temp[cursor++];
1964         while (ch != 0 &amp;&amp; !isLineSeparator(ch))
1965             ch = temp[cursor++];




1966         return ch;
1967     }
1968 
1969     /**
1970      * xmode peek past comment to end of line.
1971      */
1972     private int peekPastLine() {
1973         int ch = temp[++cursor];
1974         while (ch != 0 &amp;&amp; !isLineSeparator(ch))
1975             ch = temp[++cursor];




1976         return ch;
1977     }
1978 
1979     /**
1980      * Determines if character is a line separator in the current mode
1981      */
1982     private boolean isLineSeparator(int ch) {
1983         if (has(UNIX_LINES)) {
1984             return ch == &#39;\n&#39;;
1985         } else {
1986             return (ch == &#39;\n&#39; ||
1987                     ch == &#39;\r&#39; ||
1988                     (ch|1) == &#39;\u2029&#39; ||
1989                     ch == &#39;\u0085&#39;);
1990         }
1991     }
1992 
1993     /**
1994      * Read the character after the next one, and advance the cursor by two.
1995      */
</pre>
<hr />
<pre>
2033      */
2034     private static final boolean isSupplementary(int ch) {
2035         return ch &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT ||
2036                Character.isSurrogate((char)ch);
2037     }
2038 
2039     /**
2040      *  The following methods handle the main parsing. They are sorted
2041      *  according to their precedence order, the lowest one first.
2042      */
2043 
2044     /**
2045      * The expression is parsed with branch nodes added for alternations.
2046      * This may be called recursively to parse sub expressions that may
2047      * contain alternations.
2048      */
2049     private Node expr(Node end) {
2050         Node prev = null;
2051         Node firstTail = null;
2052         Branch branch = null;
<span class="line-modified">2053         Node branchConn = null;</span>
2054 
2055         for (;;) {
2056             Node node = sequence(end);
2057             Node nodeTail = root;      //double return
2058             if (prev == null) {
2059                 prev = node;
2060                 firstTail = nodeTail;
2061             } else {
2062                 // Branch
2063                 if (branchConn == null) {
2064                     branchConn = new BranchConn();
2065                     branchConn.next = end;
2066                 }
2067                 if (node == end) {
2068                     // if the node returned from sequence() is &quot;end&quot;
2069                     // we have an empty expr, set a null atom into
2070                     // the branch to indicate to go &quot;next&quot; directly.
2071                     node = null;
2072                 } else {
2073                     // the &quot;tail.next&quot; of each atom goes to branchConn
</pre>
<hr />
<pre>
2083                         // when put the &quot;prev&quot; into the branch as the first atom.
2084                         firstTail.next = branchConn;
2085                     }
2086                     prev = branch = new Branch(prev, node, branchConn);
2087                 }
2088             }
2089             if (peek() != &#39;|&#39;) {
2090                 return prev;
2091             }
2092             next();
2093         }
2094     }
2095 
2096     @SuppressWarnings(&quot;fallthrough&quot;)
2097     /**
2098      * Parsing of sequences between alternations.
2099      */
2100     private Node sequence(Node end) {
2101         Node head = null;
2102         Node tail = null;
<span class="line-modified">2103         Node node = null;</span>
2104     LOOP:
2105         for (;;) {
2106             int ch = peek();
2107             switch (ch) {
2108             case &#39;(&#39;:
2109                 // Because group handles its own closure,
2110                 // we need to treat it differently
2111                 node = group0();
2112                 // Check for comment or flag group
2113                 if (node == null)
2114                     continue;
2115                 if (head == null)
2116                     head = node;
2117                 else
2118                     tail.next = node;
2119                 // Double return: Tail was returned in root
2120                 tail = root;
2121                 continue;
2122             case &#39;[&#39;:
2123                 if (has(CANON_EQ) &amp;&amp; !has(LITERAL))
</pre>
<hr />
<pre>
2181                 break LOOP;
2182             case &#39;]&#39;: // Now interpreting dangling ] and } as literals
2183             case &#39;}&#39;:
2184                 node = atom();
2185                 break;
2186             case &#39;?&#39;:
2187             case &#39;*&#39;:
2188             case &#39;+&#39;:
2189                 next();
2190                 throw error(&quot;Dangling meta character &#39;&quot; + ((char)ch) + &quot;&#39;&quot;);
2191             case 0:
2192                 if (cursor &gt;= patternLength) {
2193                     break LOOP;
2194                 }
2195                 // Fall through
2196             default:
2197                 node = atom();
2198                 break;
2199             }
2200 
<span class="line-modified">2201             node = closure(node);</span>

















2202             /* save the top dot-greedy nodes (.*, .+) as well
2203             if (node instanceof GreedyCharProperty &amp;&amp;
2204                 ((GreedyCharProperty)node).cp instanceof Dot) {
2205                 topClosureNodes.add(node);
2206             }
2207             */
2208             if (head == null) {
2209                 head = tail = node;
2210             } else {
2211                 tail.next = node;
2212                 tail = node;
2213             }
2214         }
2215         if (head == null) {
2216             return end;
2217         }
2218         tail.next = end;
2219         root = tail;      //double return
2220         return head;
2221     }
</pre>
<hr />
<pre>
2292                 // Fall through
2293             default:
2294                 prev = cursor;
2295                 append(ch, first);
2296                 first++;
2297                 if (isSupplementary(ch)) {
2298                     hasSupplementary = true;
2299                 }
2300                 ch = next();
2301                 continue;
2302             }
2303             break;
2304         }
2305         if (first == 1) {
2306             return newCharProperty(single(buffer[0]));
2307         } else {
2308             return newSlice(buffer, first, hasSupplementary);
2309         }
2310     }
2311 
<span class="line-modified">2312     private void append(int ch, int len) {</span>
<span class="line-modified">2313         if (len &gt;= buffer.length) {</span>
<span class="line-modified">2314             int[] tmp = new int[len+len];</span>
<span class="line-modified">2315             System.arraycopy(buffer, 0, tmp, 0, len);</span>
<span class="line-modified">2316             buffer = tmp;</span>


2317         }
<span class="line-modified">2318         buffer[len] = ch;</span>
2319     }
2320 
2321     /**
2322      * Parses a backref greedily, taking as many numbers as it
2323      * can. The first digit is always treated as a backref, but
2324      * multi digit numbers are only treated as a backref if at
2325      * least that many backrefs exist at this point in the regex.
2326      */
2327     private Node ref(int refNum) {
2328         boolean done = false;
2329         while(!done) {
2330             int ch = peek();
2331             switch(ch) {
2332             case &#39;0&#39;:
2333             case &#39;1&#39;:
2334             case &#39;2&#39;:
2335             case &#39;3&#39;:
2336             case &#39;4&#39;:
2337             case &#39;5&#39;:
2338             case &#39;6&#39;:
</pre>
<hr />
<pre>
2598             if (inclass) break;
2599             if (create) root = new End();
2600             return -1;
2601         default:
2602             return ch;
2603         }
2604         throw error(&quot;Illegal/unsupported escape sequence&quot;);
2605     }
2606 
2607     /**
2608      * Parse a character class, and return the node that matches it.
2609      *
2610      * Consumes a ] on the way out if consume is true. Usually consume
2611      * is true except for the case of [abc&amp;&amp;def] where def is a separate
2612      * right hand node with &quot;understood&quot; brackets.
2613      */
2614     private CharPredicate clazz(boolean consume) {
2615         CharPredicate prev = null;
2616         CharPredicate curr = null;
2617         BitClass bits = new BitClass();
<span class="line-removed">2618         BmpCharPredicate bitsP = ch -&gt; ch &lt; 256 &amp;&amp; bits.bits[ch];</span>
2619 
2620         boolean isNeg = false;
2621         boolean hasBits = false;
2622         int ch = next();
2623 
2624         // Negates if first char in a class, otherwise literal
2625         if (ch == &#39;^&#39; &amp;&amp; temp[cursor-1] == &#39;[&#39;) {
2626             ch = next();
2627             isNeg = true;
2628         }
2629         for (;;) {
2630             switch (ch) {
2631                 case &#39;[&#39;:
2632                     curr = clazz(true);
2633                     if (prev == null)
2634                         prev = curr;
2635                     else
2636                         prev = prev.union(curr);
2637                     ch = peek();
2638                     continue;
2639                 case &#39;&amp;&#39;:
2640                     ch = next();
2641                     if (ch == &#39;&amp;&#39;) {
2642                         ch = next();
2643                         CharPredicate right = null;
2644                         while (ch != &#39;]&#39; &amp;&amp; ch != &#39;&amp;&#39;) {
2645                             if (ch == &#39;[&#39;) {
2646                                 if (right == null)
2647                                     right = clazz(true);
2648                                 else
2649                                     right = right.union(clazz(true));
2650                             } else { // abc&amp;&amp;def
2651                                 unread();
2652                                 right = clazz(false);
2653                             }
2654                             ch = peek();
2655                         }
2656                         if (hasBits) {
2657                             // bits used, union has high precedence
2658                             if (prev == null) {
<span class="line-modified">2659                                 prev = curr = bitsP;</span>
2660                             } else {
<span class="line-modified">2661                                 prev = prev.union(bitsP);</span>
2662                             }
2663                             hasBits = false;
2664                         }
2665                         if (right != null)
2666                             curr = right;
2667                         if (prev == null) {
2668                             if (right == null)
2669                                 throw error(&quot;Bad class syntax&quot;);
2670                             else
2671                                 prev = right;
2672                         } else {
2673                             prev = prev.and(curr);
2674                         }
2675                     } else {
2676                         // treat as a literal &amp;
2677                         unread();
2678                         break;
2679                     }
2680                     continue;
2681                 case 0:
2682                     if (cursor &gt;= patternLength)
2683                         throw error(&quot;Unclosed character class&quot;);
2684                     break;
2685                 case &#39;]&#39;:
2686                     if (prev != null || hasBits) {
2687                         if (consume)
2688                             next();
2689                         if (prev == null)
<span class="line-modified">2690                             prev = bitsP;</span>
2691                         else if (hasBits)
<span class="line-modified">2692                             prev = prev.union(bitsP);</span>
2693                         if (isNeg)
2694                             return prev.negate();
2695                         return prev;
2696                     }
2697                     break;
2698                 default:
2699                     break;
2700             }
2701             curr = range(bits);
2702             if (curr == null) {    // the bits used
2703                 hasBits = true;
2704             } else {
2705                 if (prev == null)
2706                     prev = curr;
2707                 else if (prev != curr)
2708                     prev = prev.union(curr);
2709             }
2710             ch = peek();
2711         }
2712     }
</pre>
<hr />
<pre>
2870                 case &quot;block&quot;:
2871                     p = CharPredicates.forUnicodeBlock(value);
2872                     break;
2873                 case &quot;gc&quot;:
2874                 case &quot;general_category&quot;:
2875                     p = CharPredicates.forProperty(value);
2876                     break;
2877                 default:
2878                     break;
2879             }
2880             if (p == null)
2881                 throw error(&quot;Unknown Unicode property {name=&lt;&quot; + name + &quot;&gt;, &quot;
2882                              + &quot;value=&lt;&quot; + value + &quot;&gt;}&quot;);
2883 
2884         } else {
2885             if (name.startsWith(&quot;In&quot;)) {
2886                 // \p{InBlockName}
2887                 p = CharPredicates.forUnicodeBlock(name.substring(2));
2888             } else if (name.startsWith(&quot;Is&quot;)) {
2889                 // \p{IsGeneralCategory} and \p{IsScriptName}
<span class="line-modified">2890                 name = name.substring(2);</span>
<span class="line-modified">2891                 p = CharPredicates.forUnicodeProperty(name);</span>
2892                 if (p == null)
<span class="line-modified">2893                     p = CharPredicates.forProperty(name);</span>
2894                 if (p == null)
<span class="line-modified">2895                     p = CharPredicates.forUnicodeScript(name);</span>
2896             } else {
2897                 if (has(UNICODE_CHARACTER_CLASS)) {
2898                     p = CharPredicates.forPOSIXName(name);
2899                 }
2900                 if (p == null)
2901                     p = CharPredicates.forProperty(name);
2902             }
2903             if (p == null)
<span class="line-modified">2904                 throw error(&quot;Unknown character property name {In/Is&quot; + name + &quot;}&quot;);</span>
2905         }
2906         if (isComplement) {
2907             // it might be too expensive to detect if a complement of
2908             // CharProperty can match &quot;certain&quot; supplementary. So just
2909             // go with StartS.
2910             hasSupplementary = true;
2911             p = p.negate();
2912         }
2913         return p;
2914     }
2915 
2916     private CharProperty newCharProperty(CharPredicate p) {
2917         if (p == null)
2918             return null;
2919         if (p instanceof BmpCharPredicate)
2920             return new BmpCharProperty((BmpCharPredicate)p);
2921         else
2922             return new CharProperty(p);
2923     }
2924 
</pre>
<hr />
<pre>
2928      */
2929     private String groupname(int ch) {
2930         StringBuilder sb = new StringBuilder();
2931         if (!ASCII.isAlpha(ch))
2932             throw error(&quot;capturing group name does not start with a Latin letter&quot;);
2933         do {
2934             sb.append((char) ch);
2935         } while (ASCII.isAlnum(ch=read()));
2936         if (ch != &#39;&gt;&#39;)
2937             throw error(&quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;);
2938         return sb.toString();
2939     }
2940 
2941     /**
2942      * Parses a group and returns the head node of a set of nodes that process
2943      * the group. Sometimes a double return system is used where the tail is
2944      * returned in root.
2945      */
2946     private Node group0() {
2947         boolean capturingGroup = false;
<span class="line-modified">2948         Node head = null;</span>
<span class="line-modified">2949         Node tail = null;</span>
2950         int save = flags0;
2951         int saveTCNCount = topClosureNodes.size();
2952         root = null;
2953         int ch = next();
2954         if (ch == &#39;?&#39;) {
2955             ch = skip();
2956             switch (ch) {
2957             case &#39;:&#39;:   //  (?:xxx) pure group
2958                 head = createGroup(true);
2959                 tail = root;
2960                 head.next = expr(tail);
2961                 break;
2962             case &#39;=&#39;:   // (?=xxx) and (?!xxx) lookahead
2963             case &#39;!&#39;:
2964                 head = createGroup(true);
2965                 tail = root;
2966                 head.next = expr(tail);
2967                 if (ch == &#39;=&#39;) {
2968                     head = tail = new Pos(head);
2969                 } else {
</pre>
<hr />
<pre>
2978                 break;
2979             case &#39;&lt;&#39;:   // (?&lt;xxx)  look behind
2980                 ch = read();
2981                 if (ch != &#39;=&#39; &amp;&amp; ch != &#39;!&#39;) {
2982                     // named captured group
2983                     String name = groupname(ch);
2984                     if (namedGroups().containsKey(name))
2985                         throw error(&quot;Named capturing group &lt;&quot; + name
2986                                     + &quot;&gt; is already defined&quot;);
2987                     capturingGroup = true;
2988                     head = createGroup(false);
2989                     tail = root;
2990                     namedGroups().put(name, capturingGroupCount-1);
2991                     head.next = expr(tail);
2992                     break;
2993                 }
2994                 int start = cursor;
2995                 head = createGroup(true);
2996                 tail = root;
2997                 head.next = expr(tail);
<span class="line-modified">2998                 tail.next = lookbehindEnd;</span>
2999                 TreeInfo info = new TreeInfo();
3000                 head.study(info);
3001                 if (info.maxValid == false) {
3002                     throw error(&quot;Look-behind group does not have &quot;
3003                                 + &quot;an obvious maximum length&quot;);
3004                 }
3005                 boolean hasSupplementary = findSupplementary(start, patternLength);
3006                 if (ch == &#39;=&#39;) {
3007                     head = tail = (hasSupplementary ?
3008                                    new BehindS(head, info.maxLength,
3009                                                info.minLength) :
3010                                    new Behind(head, info.maxLength,
3011                                               info.minLength));
3012                 } else { // if (ch == &#39;!&#39;)
3013                     head = tail = (hasSupplementary ?
3014                                    new NotBehindS(head, info.maxLength,
3015                                                   info.minLength) :
3016                                    new NotBehind(head, info.maxLength,
3017                                                  info.minLength));
3018                 }
</pre>
<hr />
<pre>
3047 
3048         accept(&#39;)&#39;, &quot;Unclosed group&quot;);
3049         flags0 = save;
3050 
3051         // Check for quantifiers
3052         Node node = closure(head);
3053         if (node == head) { // No closure
3054             root = tail;
3055             return node;    // Dual return
3056         }
3057         if (head == tail) { // Zero length assertion
3058             root = node;
3059             return node;    // Dual return
3060         }
3061 
3062         // have group closure, clear all inner closure nodes from the
3063         // top list (no backtracking stopper optimization for inner
3064         if (saveTCNCount &lt; topClosureNodes.size())
3065             topClosureNodes.subList(saveTCNCount, topClosureNodes.size()).clear();
3066 













3067         if (node instanceof Ques) {
3068             Ques ques = (Ques) node;
3069             if (ques.type == Qtype.POSSESSIVE) {
3070                 root = node;
3071                 return node;
3072             }
<span class="line-modified">3073             tail.next = new BranchConn();</span>
<span class="line-modified">3074             tail = tail.next;</span>
3075             if (ques.type == Qtype.GREEDY) {
<span class="line-modified">3076                 head = new Branch(head, null, tail);</span>
3077             } else { // Reluctant quantifier
<span class="line-modified">3078                 head = new Branch(null, head, tail);</span>
3079             }
3080             root = tail;
3081             return head;
3082         } else if (node instanceof Curly) {
3083             Curly curly = (Curly) node;
3084             if (curly.type == Qtype.POSSESSIVE) {
3085                 root = node;
3086                 return node;
3087             }
3088             // Discover if the group is deterministic
3089             TreeInfo info = new TreeInfo();
3090             if (head.study(info)) { // Deterministic
3091                 GroupTail temp = (GroupTail) tail;
3092                 head = root = new GroupCurly(head.next, curly.cmin,
3093                                    curly.cmax, curly.type,
3094                                    ((GroupTail)tail).localIndex,
3095                                    ((GroupTail)tail).groupIndex,
3096                                              capturingGroup);
3097                 return head;
3098             } else { // Non-deterministic
</pre>
<hr />
<pre>
3211                 break;
3212             case &#39;x&#39;:
3213                 flags0 &amp;= ~COMMENTS;
3214                 break;
3215             case &#39;U&#39;:
3216                 flags0 &amp;= ~(UNICODE_CHARACTER_CLASS | UNICODE_CASE);
3217                 break;
3218             default:
3219                 return;
3220             }
3221             ch = next();
3222         }
3223     }
3224 
3225     static final int MAX_REPS   = 0x7FFFFFFF;
3226 
3227     static enum Qtype {
3228         GREEDY, LAZY, POSSESSIVE, INDEPENDENT
3229     }
3230 
<span class="line-modified">3231     private Node curly(Node prev, int cmin) {</span>
3232         int ch = next();
3233         if (ch == &#39;?&#39;) {
3234             next();
<span class="line-modified">3235             return new Curly(prev, cmin, MAX_REPS, Qtype.LAZY);</span>
3236         } else if (ch == &#39;+&#39;) {
3237             next();
<span class="line-modified">3238             return new Curly(prev, cmin, MAX_REPS, Qtype.POSSESSIVE);</span>
3239         }
<span class="line-modified">3240         if (prev instanceof BmpCharProperty) {</span>
<span class="line-modified">3241             return new BmpCharPropertyGreedy((BmpCharProperty)prev, cmin);</span>
<span class="line-modified">3242         } else if (prev instanceof CharProperty) {</span>
<span class="line-modified">3243             return new CharPropertyGreedy((CharProperty)prev, cmin);</span>







3244         }
<span class="line-modified">3245         return new Curly(prev, cmin, MAX_REPS, Qtype.GREEDY);</span>

























3246     }
3247 
3248     /**
3249      * Processes repetition. If the next character peeked is a quantifier
3250      * then new nodes must be appended to handle the repetition.
3251      * Prev could be a single or a group, so it could be a chain of nodes.
3252      */
3253     private Node closure(Node prev) {
<span class="line-removed">3254         Node atom;</span>
3255         int ch = peek();
3256         switch (ch) {
3257         case &#39;?&#39;:
<span class="line-modified">3258             ch = next();</span>
<span class="line-removed">3259             if (ch == &#39;?&#39;) {</span>
<span class="line-removed">3260                 next();</span>
<span class="line-removed">3261                 return new Ques(prev, Qtype.LAZY);</span>
<span class="line-removed">3262             } else if (ch == &#39;+&#39;) {</span>
<span class="line-removed">3263                 next();</span>
<span class="line-removed">3264                 return new Ques(prev, Qtype.POSSESSIVE);</span>
<span class="line-removed">3265             }</span>
<span class="line-removed">3266             return new Ques(prev, Qtype.GREEDY);</span>
3267         case &#39;*&#39;:
3268             return curly(prev, 0);
3269         case &#39;+&#39;:
3270             return curly(prev, 1);
3271         case &#39;{&#39;:
<span class="line-modified">3272             ch = temp[cursor+1];</span>
3273             if (ASCII.isDigit(ch)) {
<span class="line-modified">3274                 skip();</span>
<span class="line-modified">3275                 int cmin = 0;</span>
<span class="line-modified">3276                 do {</span>
<span class="line-modified">3277                     cmin = cmin * 10 + (ch - &#39;0&#39;);</span>
<span class="line-modified">3278                 } while (ASCII.isDigit(ch = read()));</span>
<span class="line-modified">3279                 int cmax = cmin;</span>
<span class="line-modified">3280                 if (ch == &#39;,&#39;) {</span>
<span class="line-modified">3281                     ch = read();</span>
<span class="line-modified">3282                     cmax = MAX_REPS;</span>
<span class="line-modified">3283                     if (ch != &#39;}&#39;) {</span>
<span class="line-modified">3284                         cmax = 0;</span>
<span class="line-modified">3285                         while (ASCII.isDigit(ch)) {</span>
<span class="line-modified">3286                             cmax = cmax * 10 + (ch - &#39;0&#39;);</span>
<span class="line-modified">3287                             ch = read();</span>




3288                         }


3289                     }


3290                 }
3291                 if (ch != &#39;}&#39;)
3292                     throw error(&quot;Unclosed counted closure&quot;);
<span class="line-modified">3293                 if (((cmin) | (cmax) | (cmax - cmin)) &lt; 0)</span>
3294                     throw error(&quot;Illegal repetition range&quot;);
<span class="line-modified">3295                 Curly curly;</span>
<span class="line-modified">3296                 ch = peek();</span>
<span class="line-modified">3297                 if (ch == &#39;?&#39;) {</span>
<span class="line-modified">3298                     next();</span>
<span class="line-removed">3299                     curly = new Curly(prev, cmin, cmax, Qtype.LAZY);</span>
<span class="line-removed">3300                 } else if (ch == &#39;+&#39;) {</span>
<span class="line-removed">3301                     next();</span>
<span class="line-removed">3302                     curly = new Curly(prev, cmin, cmax, Qtype.POSSESSIVE);</span>
<span class="line-removed">3303                 } else {</span>
<span class="line-removed">3304                     curly = new Curly(prev, cmin, cmax, Qtype.GREEDY);</span>
<span class="line-removed">3305                 }</span>
<span class="line-removed">3306                 return curly;</span>
3307             } else {
3308                 throw error(&quot;Illegal repetition&quot;);
3309             }
3310         default:
3311             return prev;
3312         }
3313     }
3314 
3315     /**
3316      *  Utility method for parsing control escape sequences.
3317      */
3318     private int c() {
3319         if (cursor &lt; patternLength) {
3320             return read() ^ 64;
3321         }
3322         throw error(&quot;Illegal control escape sequence&quot;);
3323     }
3324 
3325     /**
3326      *  Utility method for parsing octal escape sequences.
</pre>
<hr />
<pre>
3390         return n;
3391     }
3392 
3393     private int u() {
3394         int n = uxxxx();
3395         if (Character.isHighSurrogate((char)n)) {
3396             int cur = cursor();
3397             if (read() == &#39;\\&#39; &amp;&amp; read() == &#39;u&#39;) {
3398                 int n2 = uxxxx();
3399                 if (Character.isLowSurrogate((char)n2))
3400                     return Character.toCodePoint((char)n, (char)n2);
3401             }
3402             setcursor(cur);
3403         }
3404         return n;
3405     }
3406 
3407     private int N() {
3408         if (read() == &#39;{&#39;) {
3409             int i = cursor;
<span class="line-modified">3410             while (cursor &lt; patternLength &amp;&amp; read() != &#39;}&#39;) {}</span>
<span class="line-modified">3411             if (cursor &gt; patternLength)</span>
<span class="line-modified">3412                 throw error(&quot;Unclosed character name escape sequence&quot;);</span>

3413             String name = new String(temp, i, cursor - i - 1);
3414             try {
3415                 return Character.codePointOf(name);
3416             } catch (IllegalArgumentException x) {
3417                 throw error(&quot;Unknown character name [&quot; + name + &quot;]&quot;);
3418             }
3419         }
3420         throw error(&quot;Illegal character name escape sequence&quot;);
3421     }
3422 
3423     //
3424     // Utility methods for code point support
3425     //
3426     private static final int countChars(CharSequence seq, int index,
3427                                         int lengthInCodePoints) {
3428         // optimization
3429         if (lengthInCodePoints == 1 &amp;&amp; !Character.isHighSurrogate(seq.charAt(index))) {
3430             assert (index &gt;= 0 &amp;&amp; index &lt; seq.length());
3431             return 1;
3432         }
</pre>
<hr />
<pre>
3461 
3462     private static final int countCodePoints(CharSequence seq) {
3463         int length = seq.length();
3464         int n = 0;
3465         for (int i = 0; i &lt; length; ) {
3466             n++;
3467             if (Character.isHighSurrogate(seq.charAt(i++))) {
3468                 if (i &lt; length &amp;&amp; Character.isLowSurrogate(seq.charAt(i))) {
3469                     i++;
3470                 }
3471             }
3472         }
3473         return n;
3474     }
3475 
3476     /**
3477      *  Creates a bit vector for matching Latin-1 values. A normal BitClass
3478      *  never matches values above Latin-1, and a complemented BitClass always
3479      *  matches values above Latin-1.
3480      */
<span class="line-modified">3481     static final class BitClass extends BmpCharProperty {</span>
3482         final boolean[] bits;
3483         BitClass() {
<span class="line-modified">3484             this(new boolean[256]);</span>
<span class="line-removed">3485         }</span>
<span class="line-removed">3486         private BitClass(boolean[] bits) {</span>
<span class="line-removed">3487             super( ch -&gt; ch &lt; 256 &amp;&amp; bits[ch]);</span>
<span class="line-removed">3488             this.bits = bits;</span>
3489         }
3490         BitClass add(int c, int flags) {
3491             assert c &gt;= 0 &amp;&amp; c &lt;= 255;
3492             if ((flags &amp; CASE_INSENSITIVE) != 0) {
3493                 if (ASCII.isAscii(c)) {
3494                     bits[ASCII.toUpper(c)] = true;
3495                     bits[ASCII.toLower(c)] = true;
3496                 } else if ((flags &amp; UNICODE_CASE) != 0) {
3497                     bits[Character.toLowerCase(c)] = true;
3498                     bits[Character.toUpperCase(c)] = true;
3499                 }
3500             }
3501             bits[c] = true;
3502             return this;
3503         }



3504     }
3505 

3506     /**
3507      *  Utility method for creating a string slice matcher.
3508      */
3509     private Node newSlice(int[] buf, int count, boolean hasSupplementary) {
3510         int[] tmp = new int[count];
3511         if (has(CASE_INSENSITIVE)) {
3512             if (has(UNICODE_CASE)) {
3513                 for (int i = 0; i &lt; count; i++) {
3514                     tmp[i] = Character.toLowerCase(
3515                                  Character.toUpperCase(buf[i]));
3516                 }
3517                 return hasSupplementary? new SliceUS(tmp) : new SliceU(tmp);
3518             }
3519             for (int i = 0; i &lt; count; i++) {
3520                 tmp[i] = ASCII.toLower(buf[i]);
3521             }
3522             return hasSupplementary? new SliceIS(tmp) : new SliceI(tmp);
3523         }
3524         for (int i = 0; i &lt; count; i++) {
3525             tmp[i] = buf[i];
</pre>
<hr />
<pre>
3898                     }
3899                     return next.match(matcher, i, seq);
3900                 }
3901             } else {
3902                 matcher.hitEnd = true;
3903             }
3904             return false;
3905         }
3906         boolean study(TreeInfo info) {
3907             info.minLength++;
3908             info.maxLength += 2;
3909             return next.study(info);
3910         }
3911     }
3912 
3913     /**
3914      * Abstract node class to match one character satisfying some
3915      * boolean property.
3916      */
3917     static class CharProperty extends Node {
<span class="line-modified">3918         CharPredicate predicate;</span>
3919 
3920         CharProperty (CharPredicate predicate) {
3921             this.predicate = predicate;
3922         }
3923         boolean match(Matcher matcher, int i, CharSequence seq) {
3924             if (i &lt; matcher.to) {
3925                 int ch = Character.codePointAt(seq, i);
<span class="line-modified">3926                 return predicate.is(ch) &amp;&amp;</span>
<span class="line-modified">3927                        next.match(matcher, i + Character.charCount(ch), seq);</span>
<span class="line-modified">3928             } else {</span>
<span class="line-modified">3929                 matcher.hitEnd = true;</span>
<span class="line-modified">3930                 return false;</span>
3931             }


3932         }
3933         boolean study(TreeInfo info) {
3934             info.minLength++;
3935             info.maxLength++;
3936             return next.study(info);
3937         }
3938     }
3939 
3940     /**
3941      * Optimized version of CharProperty that works only for
3942      * properties never satisfied by Supplementary characters.
3943      */
3944     private static class BmpCharProperty extends CharProperty {
3945         BmpCharProperty (BmpCharPredicate predicate) {
3946             super(predicate);
3947         }
3948         boolean match(Matcher matcher, int i, CharSequence seq) {
3949             if (i &lt; matcher.to) {
3950                 return predicate.is(seq.charAt(i)) &amp;&amp;
3951                        next.match(matcher, i + 1, seq);
3952             } else {
3953                 matcher.hitEnd = true;
3954                 return false;
3955             }
3956         }
3957     }
3958 
3959     private static class NFCCharProperty extends Node {
3960         CharPredicate predicate;
3961         NFCCharProperty (CharPredicate predicate) {
3962             this.predicate = predicate;
3963         }
3964 
3965         boolean match(Matcher matcher, int i, CharSequence seq) {
3966             if (i &lt; matcher.to) {
3967                 int ch0 = Character.codePointAt(seq, i);
3968                 int n = Character.charCount(ch0);
3969                 int j = i + n;


3970                 while (j &lt; matcher.to) {
3971                     int ch1 = Character.codePointAt(seq, j);
3972                     if (Grapheme.isBoundary(ch0, ch1))
3973                         break;
3974                     ch0 = ch1;
3975                     j += Character.charCount(ch1);
3976                 }
3977                 if (i + n == j) {    // single, assume nfc cp
3978                     if (predicate.is(ch0))
3979                         return next.match(matcher, j, seq);
3980                 } else {
3981                     while (i + n &lt; j) {
3982                         String nfc = Normalizer.normalize(
3983                             seq.toString().substring(i, j), Normalizer.Form.NFC);
3984                         if (nfc.codePointCount(0, nfc.length()) == 1) {
3985                             if (predicate.is(nfc.codePointAt(0)) &amp;&amp;
3986                                 next.match(matcher, j, seq)) {
3987                                 return true;
3988                             }
3989                         }
</pre>
<hr />
<pre>
3995                 if (j &lt; matcher.to)
3996                     return false;
3997             }
3998             matcher.hitEnd = true;
3999             return false;
4000         }
4001 
4002         boolean study(TreeInfo info) {
4003             info.minLength++;
4004             info.deterministic = false;
4005             return next.study(info);
4006         }
4007     }
4008 
4009     /**
4010      * Node class that matches an unicode extended grapheme cluster
4011      */
4012     static class XGrapheme extends Node {
4013         boolean match(Matcher matcher, int i, CharSequence seq) {
4014             if (i &lt; matcher.to) {
<span class="line-modified">4015                 int ch0 = Character.codePointAt(seq, i);</span>
<span class="line-removed">4016                     i += Character.charCount(ch0);</span>
<span class="line-removed">4017                 while (i &lt; matcher.to) {</span>
<span class="line-removed">4018                     int ch1 = Character.codePointAt(seq, i);</span>
<span class="line-removed">4019                     if (Grapheme.isBoundary(ch0, ch1))</span>
<span class="line-removed">4020                         break;</span>
<span class="line-removed">4021                     ch0 = ch1;</span>
<span class="line-removed">4022                     i += Character.charCount(ch1);</span>
<span class="line-removed">4023                 }</span>
4024                 return next.match(matcher, i, seq);
4025             }
4026             matcher.hitEnd = true;
4027             return false;
4028         }
4029 
4030         boolean study(TreeInfo info) {
4031             info.minLength++;
4032             info.deterministic = false;
4033             return next.study(info);
4034         }
4035     }
4036 
4037     /**
4038      * Node class that handles grapheme boundaries
4039      */
4040     static class GraphemeBound extends Node {
4041         boolean match(Matcher matcher, int i, CharSequence seq) {
4042             int startIndex = matcher.from;
4043             int endIndex = matcher.to;
4044             if (matcher.transparentBounds) {
4045                 startIndex = 0;
4046                 endIndex = matcher.getTextLength();
4047             }
4048             if (i == startIndex) {
4049                 return next.match(matcher, i, seq);
4050             }
4051             if (i &lt; endIndex) {
4052                 if (Character.isSurrogatePair(seq.charAt(i-1), seq.charAt(i)) ||
<span class="line-modified">4053                     !Grapheme.isBoundary(Character.codePointBefore(seq, i),</span>
<span class="line-modified">4054                                          Character.codePointAt(seq, i))) {</span>

4055                     return false;
4056                 }
4057             } else {
4058                 matcher.hitEnd = true;
4059                 matcher.requireEnd = true;
4060             }
4061             return next.match(matcher, i, seq);
4062         }
4063     }
4064 
4065     /**
4066      * Base class for all Slice nodes
4067      */
4068     static class SliceNode extends Node {
4069         int[] buffer;
4070         SliceNode(int[] buf) {
4071             buffer = buf;
4072         }
4073         boolean study(TreeInfo info) {
4074             info.minLength += buffer.length;
</pre>
<hr />
<pre>
4247                 return next.match(matcher, i, seq);
4248             default:
4249                 return atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq);
4250             }
4251         }
4252         boolean study(TreeInfo info) {
4253             if (type != Qtype.INDEPENDENT) {
4254                 int minL = info.minLength;
4255                 atom.study(info);
4256                 info.minLength = minL;
4257                 info.deterministic = false;
4258                 return next.study(info);
4259             } else {
4260                 atom.study(info);
4261                 return next.study(info);
4262             }
4263         }
4264     }
4265 
4266     /**
<span class="line-modified">4267      * Handles the greedy style repetition with the minimum either be</span>
<span class="line-modified">4268      * 0 or 1 and the maximum be MAX_REPS, for * and + quantifier.</span>
4269      */
4270     static class CharPropertyGreedy extends Node {
4271         final CharPredicate predicate;
4272         final int cmin;
4273 
4274         CharPropertyGreedy(CharProperty cp, int cmin) {
4275             this.predicate = cp.predicate;
4276             this.cmin = cmin;
4277         }
<span class="line-modified">4278         boolean match(Matcher matcher, int i,  CharSequence seq) {</span>
4279             int n = 0;
4280             int to = matcher.to;
4281             // greedy, all the way down
4282             while (i &lt; to) {
4283                 int ch = Character.codePointAt(seq, i);
4284                 if (!predicate.is(ch))
4285                    break;
4286                 i += Character.charCount(ch);
4287                 n++;
4288             }
4289             if (i &gt;= to) {
4290                 matcher.hitEnd = true;
4291             }
4292             while (n &gt;= cmin) {
4293                 if (next.match(matcher, i, seq))
4294                     return true;
4295                 if (n == cmin)
4296                     return false;
4297                  // backing off if match fails
4298                 int ch = Character.codePointBefore(seq, i);
</pre>
<hr />
<pre>
4301             }
4302             return false;
4303         }
4304 
4305         boolean study(TreeInfo info) {
4306             info.minLength += cmin;
4307             if (info.maxValid) {
4308                 info.maxLength += MAX_REPS;
4309             }
4310             info.deterministic = false;
4311             return next.study(info);
4312         }
4313     }
4314 
4315     static final class BmpCharPropertyGreedy extends CharPropertyGreedy {
4316 
4317         BmpCharPropertyGreedy(BmpCharProperty bcp, int cmin) {
4318             super(bcp, cmin);
4319         }
4320 
<span class="line-modified">4321         boolean match(Matcher matcher, int i,  CharSequence seq) {</span>
4322             int n = 0;
4323             int to = matcher.to;
4324             while (i &lt; to &amp;&amp; predicate.is(seq.charAt(i))) {
4325                 i++; n++;
4326             }
4327             if (i &gt;= to) {
4328                 matcher.hitEnd = true;
4329             }
4330             while (n &gt;= cmin) {
4331                 if (next.match(matcher, i, seq))
4332                     return true;
4333                 i--; n--;  // backing off if match fails
4334             }
4335             return false;
4336         }
4337     }
4338 
4339     /**
4340      * Handles the curly-brace style repetition with a specified minimum and
4341      * maximum occurrences. The * quantifier is handled as a special case.
</pre>
<hr />
<pre>
4678                 info.maxValid = false;
4679             }
4680 
4681             if (info.deterministic &amp;&amp; cmin == cmax) {
4682                 info.deterministic = detm;
4683             } else {
4684                 info.deterministic = false;
4685             }
4686             return next.study(info);
4687         }
4688     }
4689 
4690     /**
4691      * A Guard node at the end of each atom node in a Branch. It
4692      * serves the purpose of chaining the &quot;match&quot; operation to
4693      * &quot;next&quot; but not the &quot;study&quot;, so we can collect the TreeInfo
4694      * of each atom node without including the TreeInfo of the
4695      * &quot;next&quot;.
4696      */
4697     static final class BranchConn extends Node {
<span class="line-modified">4698         BranchConn() {};</span>
4699         boolean match(Matcher matcher, int i, CharSequence seq) {
4700             return next.match(matcher, i, seq);
4701         }
4702         boolean study(TreeInfo info) {
4703             return info.deterministic;
4704         }
4705     }
4706 
4707     /**
4708      * Handles the branching of alternations. Note this is also used for
4709      * the ? quantifier to branch between the case where it matches once
4710      * and where it does not occur.
4711      */
4712     static final class Branch extends Node {
4713         Node[] atoms = new Node[2];
4714         int size = 2;
<span class="line-modified">4715         Node conn;</span>
<span class="line-modified">4716         Branch(Node first, Node second, Node branchConn) {</span>
4717             conn = branchConn;
4718             atoms[0] = first;
4719             atoms[1] = second;
4720         }
4721 
4722         void add(Node node) {
4723             if (size &gt;= atoms.length) {
<span class="line-modified">4724                 Node[] tmp = new Node[atoms.length*2];</span>
<span class="line-modified">4725                 System.arraycopy(atoms, 0, tmp, 0, atoms.length);</span>
<span class="line-modified">4726                 atoms = tmp;</span>

4727             }
4728             atoms[size++] = node;
4729         }
4730 
4731         boolean match(Matcher matcher, int i, CharSequence seq) {
4732             for (int n = 0; n &lt; size; n++) {
4733                 if (atoms[n] == null) {
4734                     if (conn.next.match(matcher, i, seq))
4735                         return true;
4736                 } else if (atoms[n].match(matcher, i, seq)) {
4737                     return true;
4738                 }
4739             }
4740             return false;
4741         }
4742 
4743         boolean study(TreeInfo info) {
4744             int minL = info.minLength;
4745             int maxL = info.maxLength;
4746             boolean maxV = info.maxValid;
</pre>
<hr />
<pre>
4775      * and restores them when the match is done.
4776      *
4777      * The matchRef is used when a reference to this group is accessed later
4778      * in the expression. The locals will have a negative value in them to
4779      * indicate that we do not want to unset the group if the reference
4780      * doesn&#39;t match.
4781      */
4782     static final class GroupHead extends Node {
4783         int localIndex;
4784         GroupTail tail;    // for debug/print only, match does not need to know
4785         GroupHead(int localCount) {
4786             localIndex = localCount;
4787         }
4788         boolean match(Matcher matcher, int i, CharSequence seq) {
4789             int save = matcher.locals[localIndex];
4790             matcher.locals[localIndex] = i;
4791             boolean ret = next.match(matcher, i, seq);
4792             matcher.locals[localIndex] = save;
4793             return ret;
4794         }
<span class="line-removed">4795         boolean matchRef(Matcher matcher, int i, CharSequence seq) {</span>
<span class="line-removed">4796             int save = matcher.locals[localIndex];</span>
<span class="line-removed">4797             matcher.locals[localIndex] = ~i; // HACK</span>
<span class="line-removed">4798             boolean ret = next.match(matcher, i, seq);</span>
<span class="line-removed">4799             matcher.locals[localIndex] = save;</span>
<span class="line-removed">4800             return ret;</span>
<span class="line-removed">4801         }</span>
<span class="line-removed">4802     }</span>
<span class="line-removed">4803 </span>
<span class="line-removed">4804     /**</span>
<span class="line-removed">4805      * Recursive reference to a group in the regular expression. It calls</span>
<span class="line-removed">4806      * matchRef because if the reference fails to match we would not unset</span>
<span class="line-removed">4807      * the group.</span>
<span class="line-removed">4808      */</span>
<span class="line-removed">4809     static final class GroupRef extends Node {</span>
<span class="line-removed">4810         GroupHead head;</span>
<span class="line-removed">4811         GroupRef(GroupHead head) {</span>
<span class="line-removed">4812             this.head = head;</span>
<span class="line-removed">4813         }</span>
<span class="line-removed">4814         boolean match(Matcher matcher, int i, CharSequence seq) {</span>
<span class="line-removed">4815             return head.matchRef(matcher, i, seq)</span>
<span class="line-removed">4816                 &amp;&amp; next.match(matcher, matcher.last, seq);</span>
<span class="line-removed">4817         }</span>
<span class="line-removed">4818         boolean study(TreeInfo info) {</span>
<span class="line-removed">4819             info.maxValid = false;</span>
<span class="line-removed">4820             info.deterministic = false;</span>
<span class="line-removed">4821             return next.study(info);</span>
<span class="line-removed">4822         }</span>
4823     }
4824 
4825     /**
4826      * The GroupTail handles the setting of group beginning and ending
4827      * locations when groups are successfully matched. It must also be able to
4828      * unset groups that have to be backed off of.
4829      *
4830      * The GroupTail node is also used when a previous group is referenced,
4831      * and in that case no group information needs to be set.
4832      */
4833     static final class GroupTail extends Node {
4834         int localIndex;
4835         int groupIndex;
4836         GroupTail(int localCount, int groupCount) {
4837             localIndex = localCount;
4838             groupIndex = groupCount + groupCount;
4839         }
4840         boolean match(Matcher matcher, int i, CharSequence seq) {
4841             int tmp = matcher.locals[localIndex];
4842             if (tmp &gt;= 0) { // This is the normal group case.
</pre>
<hr />
<pre>
4924                         matcher.localsPos[posIndex].contains(i)) {
4925                         return next.match(matcher, i, seq);
4926                     }
4927                     matcher.locals[countIndex] = count + 1;
4928                     boolean b = body.match(matcher, i, seq);
4929                     // If match failed we must backtrack, so
4930                     // the loop count should NOT be incremented
4931                     if (b)
4932                         return true;
4933                     matcher.locals[countIndex] = count;
4934                     // save the failed position
4935                     if (posIndex != -1) {
4936                         matcher.localsPos[posIndex].add(i);
4937                     }
4938                 }
4939             }
4940             return next.match(matcher, i, seq);
4941         }
4942         boolean matchInit(Matcher matcher, int i, CharSequence seq) {
4943             int save = matcher.locals[countIndex];
<span class="line-modified">4944             boolean ret = false;</span>
4945             if (posIndex != -1 &amp;&amp; matcher.localsPos[posIndex] == null) {
4946                 matcher.localsPos[posIndex] = new IntHashSet();
4947             }
4948             if (0 &lt; cmin) {
4949                 matcher.locals[countIndex] = 1;
4950                 ret = body.match(matcher, i, seq);
4951             } else if (0 &lt; cmax) {
4952                 matcher.locals[countIndex] = 1;
4953                 ret = body.match(matcher, i, seq);
4954                 if (ret == false)
4955                     ret = next.match(matcher, i, seq);
4956             } else {
4957                 ret = next.match(matcher, i, seq);
4958             }
4959             matcher.locals[countIndex] = save;
4960             return ret;
4961         }
4962         boolean study(TreeInfo info) {
4963             info.maxValid = false;
4964             info.deterministic = false;
</pre>
<hr />
<pre>
5138             for (;;) {
5139                 if (i &gt; matcher.to) {
5140                     matcher.hitEnd = true;
5141                     return false;
5142                 }
5143                 if (atom.match(matcher, i, seq)) {
5144                     return next.match(matcher, matcher.last, seq);
5145                 }
5146                 i += countChars(seq, i, 1);
5147                 matcher.first++;
5148             }
5149         }
5150         boolean study(TreeInfo info) {
5151             atom.study(info);
5152             info.maxValid = false;
5153             info.deterministic = false;
5154             return next.study(info);
5155         }
5156     }
5157 
<span class="line-removed">5158     static final class Conditional extends Node {</span>
<span class="line-removed">5159         Node cond, yes, not;</span>
<span class="line-removed">5160         Conditional(Node cond, Node yes, Node not) {</span>
<span class="line-removed">5161             this.cond = cond;</span>
<span class="line-removed">5162             this.yes = yes;</span>
<span class="line-removed">5163             this.not = not;</span>
<span class="line-removed">5164         }</span>
<span class="line-removed">5165         boolean match(Matcher matcher, int i, CharSequence seq) {</span>
<span class="line-removed">5166             if (cond.match(matcher, i, seq)) {</span>
<span class="line-removed">5167                 return yes.match(matcher, i, seq);</span>
<span class="line-removed">5168             } else {</span>
<span class="line-removed">5169                 return not.match(matcher, i, seq);</span>
<span class="line-removed">5170             }</span>
<span class="line-removed">5171         }</span>
<span class="line-removed">5172         boolean study(TreeInfo info) {</span>
<span class="line-removed">5173             int minL = info.minLength;</span>
<span class="line-removed">5174             int maxL = info.maxLength;</span>
<span class="line-removed">5175             boolean maxV = info.maxValid;</span>
<span class="line-removed">5176             info.reset();</span>
<span class="line-removed">5177             yes.study(info);</span>
<span class="line-removed">5178 </span>
<span class="line-removed">5179             int minL2 = info.minLength;</span>
<span class="line-removed">5180             int maxL2 = info.maxLength;</span>
<span class="line-removed">5181             boolean maxV2 = info.maxValid;</span>
<span class="line-removed">5182             info.reset();</span>
<span class="line-removed">5183             not.study(info);</span>
<span class="line-removed">5184 </span>
<span class="line-removed">5185             info.minLength = minL + Math.min(minL2, info.minLength);</span>
<span class="line-removed">5186             info.maxLength = maxL + Math.max(maxL2, info.maxLength);</span>
<span class="line-removed">5187             info.maxValid = (maxV &amp; maxV2 &amp; info.maxValid);</span>
<span class="line-removed">5188             info.deterministic = false;</span>
<span class="line-removed">5189             return next.study(info);</span>
<span class="line-removed">5190         }</span>
<span class="line-removed">5191     }</span>
<span class="line-removed">5192 </span>
5193     /**
5194      * Zero width positive lookahead.
5195      */
5196     static final class Pos extends Node {
5197         Node cond;
5198         Pos(Node cond) {
5199             this.cond = cond;
5200         }
5201         boolean match(Matcher matcher, int i, CharSequence seq) {
5202             int savedTo = matcher.to;
<span class="line-modified">5203             boolean conditionMatched = false;</span>
5204 
5205             // Relax transparent region boundaries for lookahead
5206             if (matcher.transparentBounds)
5207                 matcher.to = matcher.getTextLength();
5208             try {
5209                 conditionMatched = cond.match(matcher, i, seq);
5210             } finally {
5211                 // Reinstate region boundaries
5212                 matcher.to = savedTo;
5213             }
5214             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5215         }
5216     }
5217 
5218     /**
5219      * Zero width negative lookahead.
5220      */
5221     static final class Neg extends Node {
5222         Node cond;
5223         Neg(Node cond) {
5224             this.cond = cond;
5225         }
5226         boolean match(Matcher matcher, int i, CharSequence seq) {
5227             int savedTo = matcher.to;
<span class="line-modified">5228             boolean conditionMatched = false;</span>
5229 
5230             // Relax transparent region boundaries for lookahead
5231             if (matcher.transparentBounds)
5232                 matcher.to = matcher.getTextLength();
5233             try {
5234                 if (i &lt; matcher.to) {
5235                     conditionMatched = !cond.match(matcher, i, seq);
5236                 } else {
5237                     // If a negative lookahead succeeds then more input
5238                     // could cause it to fail!
5239                     matcher.requireEnd = true;
5240                     conditionMatched = !cond.match(matcher, i, seq);
5241                 }
5242             } finally {
5243                 // Reinstate region boundaries
5244                 matcher.to = savedTo;
5245             }
5246             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5247         }
5248     }
5249 
5250     /**
5251      * For use with lookbehinds; matches the position where the lookbehind
5252      * was encountered.
5253      */
<span class="line-modified">5254     static Node lookbehindEnd = new Node() {</span>




5255         boolean match(Matcher matcher, int i, CharSequence seq) {
5256             return i == matcher.lookbehindTo;
5257         }
<span class="line-modified">5258     };</span>
5259 
5260     /**
5261      * Zero width positive lookbehind.
5262      */
5263     static class Behind extends Node {
5264         Node cond;
5265         int rmax, rmin;
5266         Behind(Node cond, int rmax, int rmin) {
5267             this.cond = cond;
5268             this.rmax = rmax;
5269             this.rmin = rmin;
5270         }
5271 
5272         boolean match(Matcher matcher, int i, CharSequence seq) {
5273             int savedFrom = matcher.from;
5274             boolean conditionMatched = false;
5275             int startIndex = (!matcher.transparentBounds) ?
5276                              matcher.from : 0;
5277             int from = Math.max(i - rmax, startIndex);
5278             // Set end boundary
</pre>
<hr />
<pre>
5506          * Pre calculates arrays needed to generate the bad character
5507          * shift and the good suffix shift. Only the last seven bits
5508          * are used to see if chars match; This keeps the tables small
5509          * and covers the heavily used ASCII range, but occasionally
5510          * results in an aliased match for the bad character shift.
5511          */
5512         static Node optimize(Node node) {
5513             if (!(node instanceof Slice)) {
5514                 return node;
5515             }
5516 
5517             int[] src = ((Slice) node).buffer;
5518             int patternLength = src.length;
5519             // The BM algorithm requires a bit of overhead;
5520             // If the pattern is short don&#39;t use it, since
5521             // a shift larger than the pattern length cannot
5522             // be used anyway.
5523             if (patternLength &lt; 4) {
5524                 return node;
5525             }
<span class="line-modified">5526             int i, j, k;</span>
5527             int[] lastOcc = new int[128];
5528             int[] optoSft = new int[patternLength];
5529             // Precalculate part of the bad character shift
5530             // It is a table for where in the pattern each
5531             // lower 7-bit value occurs
5532             for (i = 0; i &lt; patternLength; i++) {
5533                 lastOcc[src[i]&amp;0x7F] = i + 1;
5534             }
5535             // Precalculate the good suffix shift
5536             // i is the shift amount being considered
5537 NEXT:       for (i = patternLength; i &gt; 0; i--) {
5538                 // j is the beginning index of suffix being considered
5539                 for (j = patternLength - 1; j &gt;= i; j--) {
5540                     // Testing for good suffix
5541                     if (src[j] == src[j-i]) {
5542                         // src[j..len] is a good suffix
5543                         optoSft[j-1] = i;
5544                     } else {
5545                         // No match. The array has already been
5546                         // filled up with correct values before.
</pre>
<hr />
<pre>
5661         boolean is(int ch);
5662 
5663         default CharPredicate and(CharPredicate p) {
5664             return ch -&gt; is(ch) &amp;&amp; p.is(ch);
5665         }
5666         default CharPredicate union(CharPredicate p) {
5667             return ch -&gt; is(ch) || p.is(ch);
5668         }
5669         default CharPredicate union(CharPredicate p1,
5670                                     CharPredicate p2 ) {
5671             return ch -&gt; is(ch) || p1.is(ch) || p2.is(ch);
5672         }
5673         default CharPredicate negate() {
5674             return ch -&gt; !is(ch);
5675         }
5676     }
5677 
5678     static interface BmpCharPredicate extends CharPredicate {
5679 
5680         default CharPredicate and(CharPredicate p) {
<span class="line-modified">5681             if(p instanceof BmpCharPredicate)</span>
5682                 return (BmpCharPredicate)(ch -&gt; is(ch) &amp;&amp; p.is(ch));
5683             return ch -&gt; is(ch) &amp;&amp; p.is(ch);
5684         }
5685         default CharPredicate union(CharPredicate p) {
5686             if (p instanceof BmpCharPredicate)
5687                 return (BmpCharPredicate)(ch -&gt; is(ch) || p.is(ch));
5688             return ch -&gt; is(ch) || p.is(ch);
5689         }
5690         static CharPredicate union(CharPredicate... predicates) {
5691             CharPredicate cp = ch -&gt; {
5692                 for (CharPredicate p : predicates) {
5693                     if (!p.is(ch))
5694                         return false;
5695                 }
5696                 return true;
5697             };
5698             for (CharPredicate p : predicates) {
5699                 if (! (p instanceof BmpCharPredicate))
5700                     return cp;
5701             }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  26 package java.util.regex;
  27 
  28 import java.text.Normalizer;
  29 import java.text.Normalizer.Form;
  30 import java.util.Locale;
  31 import java.util.Iterator;
  32 import java.util.Map;
  33 import java.util.ArrayList;
  34 import java.util.HashMap;
  35 import java.util.LinkedHashSet;
  36 import java.util.List;
  37 import java.util.Set;
  38 import java.util.Arrays;
  39 import java.util.NoSuchElementException;
  40 import java.util.Spliterator;
  41 import java.util.Spliterators;
  42 import java.util.function.Predicate;
  43 import java.util.stream.Stream;
  44 import java.util.stream.StreamSupport;
  45 
<span class="line-added">  46 import jdk.internal.util.ArraysSupport;</span>
  47 
  48 /**
  49  * A compiled representation of a regular expression.
  50  *
  51  * &lt;p&gt; A regular expression, specified as a string, must first be compiled into
  52  * an instance of this class.  The resulting pattern can then be used to create
  53  * a {@link Matcher} object that can match arbitrary {@linkplain
  54  * java.lang.CharSequence character sequences} against the regular
  55  * expression.  All of the state involved in performing a match resides in the
  56  * matcher, so many matchers can share the same pattern.
  57  *
  58  * &lt;p&gt; A typical invocation sequence is thus
  59  *
  60  * &lt;blockquote&gt;&lt;pre&gt;
  61  * Pattern p = Pattern.{@link #compile compile}(&quot;a*b&quot;);
  62  * Matcher m = p.{@link #matcher matcher}(&quot;aaaaab&quot;);
  63  * boolean b = m.{@link Matcher#matches matches}();&lt;/pre&gt;&lt;/blockquote&gt;
  64  *
  65  * &lt;p&gt; A {@link #matches matches} method is defined by this class as a
  66  * convenience for when a regular expression is used just once.  This method
  67  * compiles an expression and matches an input sequence against it in a single
  68  * invocation.  The statement
  69  *
  70  * &lt;blockquote&gt;&lt;pre&gt;
  71  * boolean b = Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;);&lt;/pre&gt;&lt;/blockquote&gt;
  72  *
  73  * is equivalent to the three statements above, though for repeated matches it
  74  * is less efficient since it does not allow the compiled pattern to be reused.
  75  *
  76  * &lt;p&gt; Instances of this class are immutable and are safe for use by multiple
  77  * concurrent threads.  Instances of the {@link Matcher} class are not safe for
  78  * such use.
  79  *
  80  *
<span class="line-modified">  81  * &lt;h2&gt;&lt;a id=&quot;sum&quot;&gt;Summary of regular-expression constructs&lt;/a&gt;&lt;/h2&gt;</span>
  82  *
  83  * &lt;table class=&quot;borderless&quot;&gt;
  84  * &lt;caption style=&quot;display:none&quot;&gt;Regular expression constructs, and what they match&lt;/caption&gt;
  85  * &lt;thead style=&quot;text-align:left&quot;&gt;
  86  * &lt;tr&gt;
  87  * &lt;th id=&quot;construct&quot;&gt;Construct&lt;/th&gt;
  88  * &lt;th id=&quot;matches&quot;&gt;Matches&lt;/th&gt;
  89  * &lt;/tr&gt;
  90  * &lt;/thead&gt;
  91  * &lt;tbody style=&quot;text-align:left&quot;&gt;
  92  *
  93  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;characters&quot;&gt;Characters&lt;/th&gt;&lt;/tr&gt;
  94  *
  95  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;x&quot;&gt;&lt;i&gt;x&lt;/i&gt;&lt;/th&gt;
  96  *     &lt;td headers=&quot;matches characters x&quot;&gt;The character &lt;i&gt;x&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
  97  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;backslash&quot;&gt;{@code \\}&lt;/th&gt;
  98  *     &lt;td headers=&quot;matches characters backslash&quot;&gt;The backslash character&lt;/td&gt;&lt;/tr&gt;
  99  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight: normal&quot; id=&quot;octal_n&quot;&gt;{@code \0}&lt;i&gt;n&lt;/i&gt;&lt;/th&gt;
 100  *     &lt;td headers=&quot;matches characters octal_n&quot;&gt;The character with octal value {@code 0}&lt;i&gt;n&lt;/i&gt;
 101  *         (0&amp;nbsp;{@code &lt;=}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;&amp;nbsp;{@code &lt;=}&amp;nbsp;7)&lt;/td&gt;&lt;/tr&gt;
</pre>
<hr />
<pre>
 340  *
 341  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_follow&quot;&gt;{@code \}&lt;/th&gt;
 342  *     &lt;td headers=&quot;matches quote quote_follow&quot;&gt;Nothing, but quotes the following character&lt;/td&gt;&lt;/tr&gt;
 343  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_begin&quot;&gt;{@code \Q}&lt;/th&gt;
 344  *     &lt;td headers=&quot;matches quote quote_begin&quot;&gt;Nothing, but quotes all characters until {@code \E}&lt;/td&gt;&lt;/tr&gt;
 345  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;quote_end&quot;&gt;{@code \E}&lt;/th&gt;
 346  *     &lt;td headers=&quot;matches quote quote_end&quot;&gt;Nothing, but ends quoting started by {@code \Q}&lt;/td&gt;&lt;/tr&gt;
 347  *     &lt;!-- Metachars: !$()*+.&lt;&gt;?[\]^{|} --&gt;
 348  *
 349  * &lt;tr&gt;&lt;th colspan=&quot;2&quot; style=&quot;padding-top:20px&quot; id=&quot;special&quot;&gt;Special constructs (named-capturing and non-capturing)&lt;/th&gt;&lt;/tr&gt;
 350  *
 351  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;named_group&quot;&gt;&lt;code&gt;(?&amp;lt;&lt;a href=&quot;#groupname&quot;&gt;name&lt;/a&gt;&amp;gt;&lt;/code&gt;&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 352  *     &lt;td headers=&quot;matches special named_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a named-capturing group&lt;/td&gt;&lt;/tr&gt;
 353  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group&quot;&gt;{@code (?:}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 354  *     &lt;td headers=&quot;matches special non_capture_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a non-capturing group&lt;/td&gt;&lt;/tr&gt;
 355  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;flags&quot;&gt;&lt;code&gt;(?idmsuxU-idmsuxU)&amp;nbsp;&lt;/code&gt;&lt;/th&gt;
 356  *     &lt;td headers=&quot;matches special flags&quot;&gt;Nothing, but turns match flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt;
 357  * &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt; &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt;
 358  * &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a&gt; &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt;
 359  * on - off&lt;/td&gt;&lt;/tr&gt;
<span class="line-modified"> 360  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;non_capture_group_flags&quot;&gt;{@code (?idmsuxU-idmsuxU:}&lt;i&gt;X&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;&lt;/th&gt;</span>
 361  *     &lt;td headers=&quot;matches special non_capture_group_flags&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as a &lt;a href=&quot;#cg&quot;&gt;non-capturing group&lt;/a&gt; with the
 362  *         given flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt; &lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt;
 363  * &lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt; &lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt; &lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a &gt;
<span class="line-modified"> 364  * &lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt; &lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt; on - off&lt;/td&gt;&lt;/tr&gt;</span>
 365  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookahead&quot;&gt;{@code (?=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 366  *     &lt;td headers=&quot;matches special pos_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookahead&lt;/td&gt;&lt;/tr&gt;
 367  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;neg_lookahead&quot;&gt;{@code (?!}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 368  *     &lt;td headers=&quot;matches special neg_lookahead&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookahead&lt;/td&gt;&lt;/tr&gt;
 369  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;pos_lookbehind&quot;&gt;{@code (?&lt;=}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 370  *     &lt;td headers=&quot;matches special pos_lookbehind&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width positive lookbehind&lt;/td&gt;&lt;/tr&gt;
 371  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;neg_lookbehind&quot;&gt;{@code (?&lt;!}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 372  *     &lt;td headers=&quot;matches special neg_lookbehind&quot;&gt;&lt;i&gt;X&lt;/i&gt;, via zero-width negative lookbehind&lt;/td&gt;&lt;/tr&gt;
 373  * &lt;tr&gt;&lt;th style=&quot;vertical-align:top; font-weight:normal&quot; id=&quot;indep_non_capture_group&quot;&gt;{@code (?&gt;}&lt;i&gt;X&lt;/i&gt;{@code )}&lt;/th&gt;
 374  *     &lt;td headers=&quot;matches special indep_non_capture_group&quot;&gt;&lt;i&gt;X&lt;/i&gt;, as an independent, non-capturing group&lt;/td&gt;&lt;/tr&gt;
 375  *
 376  * &lt;/tbody&gt;
 377  * &lt;/table&gt;
 378  *
 379  * &lt;hr&gt;
 380  *
 381  *
<span class="line-modified"> 382  * &lt;h2&gt;&lt;a id=&quot;bs&quot;&gt;Backslashes, escapes, and quoting&lt;/a&gt;&lt;/h2&gt;</span>
 383  *
 384  * &lt;p&gt; The backslash character ({@code &#39;\&#39;}) serves to introduce escaped
 385  * constructs, as defined in the table above, as well as to quote characters
 386  * that otherwise would be interpreted as unescaped constructs.  Thus the
 387  * expression {@code \\} matches a single backslash and &lt;code&gt;\{&lt;/code&gt; matches a
 388  * left brace.
 389  *
 390  * &lt;p&gt; It is an error to use a backslash prior to any alphabetic character that
 391  * does not denote an escaped construct; these are reserved for future
 392  * extensions to the regular-expression language.  A backslash may be used
 393  * prior to a non-alphabetic character regardless of whether that character is
 394  * part of an unescaped construct.
 395  *
 396  * &lt;p&gt; Backslashes within string literals in Java source code are interpreted
 397  * as required by
 398  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
 399  * as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)
 400  * It is therefore necessary to double backslashes in string
 401  * literals that represent regular expressions to protect them from
 402  * interpretation by the Java bytecode compiler.  The string literal
 403  * &lt;code&gt;&quot;&amp;#92;b&quot;&lt;/code&gt;, for example, matches a single backspace character when
 404  * interpreted as a regular expression, while {@code &quot;\\b&quot;} matches a
 405  * word boundary.  The string literal {@code &quot;\(hello\)&quot;} is illegal
 406  * and leads to a compile-time error; in order to match the string
 407  * {@code (hello)} the string literal {@code &quot;\\(hello\\)&quot;}
 408  * must be used.
 409  *
<span class="line-modified"> 410  * &lt;h2&gt;&lt;a id=&quot;cc&quot;&gt;Character Classes&lt;/a&gt;&lt;/h2&gt;</span>
 411  *
 412  *    &lt;p&gt; Character classes may appear within other character classes, and
 413  *    may be composed by the union operator (implicit) and the intersection
 414  *    operator ({@code &amp;&amp;}).
 415  *    The union operator denotes a class that contains every character that is
 416  *    in at least one of its operand classes.  The intersection operator
 417  *    denotes a class that contains every character that is in both of its
 418  *    operand classes.
 419  *
 420  *    &lt;p&gt; The precedence of character-class operators is as follows, from
 421  *    highest to lowest:
 422  *
 423  *    &lt;table class=&quot;striped&quot; style=&quot;margin-left: 2em;&quot;&gt;
 424  *      &lt;caption style=&quot;display:none&quot;&gt;Precedence of character class operators.&lt;/caption&gt;
 425  *      &lt;thead&gt;
 426  *      &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Precedence&lt;th scope=&quot;col&quot;&gt;Name&lt;th scope=&quot;col&quot;&gt;Example
 427  *      &lt;/thead&gt;
 428  *      &lt;tbody&gt;
 429  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
 430  *        &lt;td&gt;Literal escape&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
</pre>
<hr />
<pre>
 433  *        &lt;td&gt;Grouping&lt;/td&gt;
 434  *        &lt;td&gt;{@code [...]}&lt;/td&gt;&lt;/tr&gt;
 435  *     &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
 436  *        &lt;td&gt;Range&lt;/td&gt;
 437  *        &lt;td&gt;{@code a-z}&lt;/td&gt;&lt;/tr&gt;
 438  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;4&lt;/th&gt;
 439  *        &lt;td&gt;Union&lt;/td&gt;
 440  *        &lt;td&gt;{@code [a-e][i-u]}&lt;/td&gt;&lt;/tr&gt;
 441  *      &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;5&lt;/th&gt;
 442  *        &lt;td&gt;Intersection&lt;/td&gt;
 443  *        &lt;td&gt;{@code [a-z&amp;&amp;[aeiou]]}&lt;/td&gt;&lt;/tr&gt;
 444  *      &lt;/tbody&gt;
 445  *    &lt;/table&gt;
 446  *
 447  *    &lt;p&gt; Note that a different set of metacharacters are in effect inside
 448  *    a character class than outside a character class. For instance, the
 449  *    regular expression {@code .} loses its special meaning inside a
 450  *    character class, while the expression {@code -} becomes a range
 451  *    forming metacharacter.
 452  *
<span class="line-modified"> 453  * &lt;h2&gt;&lt;a id=&quot;lt&quot;&gt;Line terminators&lt;/a&gt;&lt;/h2&gt;</span>
 454  *
 455  * &lt;p&gt; A &lt;i&gt;line terminator&lt;/i&gt; is a one- or two-character sequence that marks
 456  * the end of a line of the input character sequence.  The following are
 457  * recognized as line terminators:
 458  *
 459  * &lt;ul&gt;
 460  *
 461  *   &lt;li&gt; A newline (line feed) character ({@code &#39;\n&#39;}),
 462  *
 463  *   &lt;li&gt; A carriage-return character followed immediately by a newline
 464  *   character ({@code &quot;\r\n&quot;}),
 465  *
 466  *   &lt;li&gt; A standalone carriage-return character ({@code &#39;\r&#39;}),
 467  *
 468  *   &lt;li&gt; A next-line character (&lt;code&gt;&#39;&amp;#92;u0085&#39;&lt;/code&gt;),
 469  *
 470  *   &lt;li&gt; A line-separator character (&lt;code&gt;&#39;&amp;#92;u2028&#39;&lt;/code&gt;), or
 471  *
 472  *   &lt;li&gt; A paragraph-separator character (&lt;code&gt;&#39;&amp;#92;u2029&#39;&lt;/code&gt;).
 473  *
 474  * &lt;/ul&gt;
 475  * &lt;p&gt;If {@link #UNIX_LINES} mode is activated, then the only line terminators
 476  * recognized are newline characters.
 477  *
 478  * &lt;p&gt; The regular expression {@code .} matches any character except a line
 479  * terminator unless the {@link #DOTALL} flag is specified.
 480  *
 481  * &lt;p&gt; By default, the regular expressions {@code ^} and {@code $} ignore
 482  * line terminators and only match at the beginning and the end, respectively,
 483  * of the entire input sequence. If {@link #MULTILINE} mode is activated then
 484  * {@code ^} matches at the beginning of input and after any line terminator
 485  * except at the end of input. When in {@link #MULTILINE} mode {@code $}
 486  * matches just before a line terminator or the end of the input sequence.
 487  *
<span class="line-modified"> 488  * &lt;h2&gt;&lt;a id=&quot;cg&quot;&gt;Groups and capturing&lt;/a&gt;&lt;/h2&gt;</span>
 489  *
<span class="line-modified"> 490  * &lt;h3&gt;&lt;a id=&quot;gnumber&quot;&gt;Group number&lt;/a&gt;&lt;/h3&gt;</span>
 491  * &lt;p&gt; Capturing groups are numbered by counting their opening parentheses from
 492  * left to right.  In the expression {@code ((A)(B(C)))}, for example, there
 493  * are four such groups: &lt;/p&gt;
 494  *
 495  * &lt;ol style=&quot;margin-left:2em;&quot;&gt;
 496  *   &lt;li&gt; {@code ((A)(B(C)))}
 497  *   &lt;li&gt; {@code (A)}
 498  *   &lt;li&gt; {@code (B(C))}
 499  *   &lt;li&gt; {@code (C)}
 500  * &lt;/ol&gt;
 501  *
 502  * &lt;p&gt; Group zero always stands for the entire expression.
 503  *
 504  * &lt;p&gt; Capturing groups are so named because, during a match, each subsequence
 505  * of the input sequence that matches such a group is saved.  The captured
 506  * subsequence may be used later in the expression, via a back reference, and
 507  * may also be retrieved from the matcher once the match operation is complete.
 508  *
<span class="line-modified"> 509  * &lt;h3&gt;&lt;a id=&quot;groupname&quot;&gt;Group name&lt;/a&gt;&lt;/h3&gt;</span>
 510  * &lt;p&gt;A capturing group can also be assigned a &quot;name&quot;, a {@code named-capturing group},
 511  * and then be back-referenced later by the &quot;name&quot;. Group names are composed of
 512  * the following characters. The first character must be a {@code letter}.
 513  *
 514  * &lt;ul&gt;
 515  *   &lt;li&gt; The uppercase letters {@code &#39;A&#39;} through {@code &#39;Z&#39;}
 516  *        (&lt;code&gt;&#39;&amp;#92;u0041&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u005a&#39;&lt;/code&gt;),
 517  *   &lt;li&gt; The lowercase letters {@code &#39;a&#39;} through {@code &#39;z&#39;}
 518  *        (&lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u007a&#39;&lt;/code&gt;),
 519  *   &lt;li&gt; The digits {@code &#39;0&#39;} through {@code &#39;9&#39;}
 520  *        (&lt;code&gt;&#39;&amp;#92;u0030&#39;&lt;/code&gt;&amp;nbsp;through&amp;nbsp;&lt;code&gt;&#39;&amp;#92;u0039&#39;&lt;/code&gt;),
 521  * &lt;/ul&gt;
 522  *
 523  * &lt;p&gt; A {@code named-capturing group} is still numbered as described in
 524  * &lt;a href=&quot;#gnumber&quot;&gt;Group number&lt;/a&gt;.
 525  *
 526  * &lt;p&gt; The captured input associated with a group is always the subsequence
 527  * that the group most recently matched.  If a group is evaluated a second time
 528  * because of quantification then its previously-captured value, if any, will
 529  * be retained if the second evaluation fails.  Matching the string
 530  * {@code &quot;aba&quot;} against the expression {@code (a(b)?)+}, for example, leaves
 531  * group two set to {@code &quot;b&quot;}.  All captured input is discarded at the
 532  * beginning of each match.
 533  *
 534  * &lt;p&gt; Groups beginning with {@code (?} are either pure, &lt;i&gt;non-capturing&lt;/i&gt; groups
 535  * that do not capture text and do not count towards the group total, or
 536  * &lt;i&gt;named-capturing&lt;/i&gt; group.
 537  *
<span class="line-modified"> 538  * &lt;h2&gt; Unicode support &lt;/h2&gt;</span>
 539  *
 540  * &lt;p&gt; This class is in conformance with Level 1 of &lt;a
 541  * href=&quot;http://www.unicode.org/reports/tr18/&quot;&gt;&lt;i&gt;Unicode Technical
 542  * Standard #18: Unicode Regular Expression&lt;/i&gt;&lt;/a&gt;, plus RL2.1
<span class="line-modified"> 543  * Canonical Equivalents and RL2.2 Extended Grapheme Clusters.</span>
 544  * &lt;p&gt;
 545  * &lt;b&gt;Unicode escape sequences&lt;/b&gt; such as &lt;code&gt;&amp;#92;u2014&lt;/code&gt; in Java source code
 546  * are processed as described in section 3.3 of
 547  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 548  * Such escape sequences are also implemented directly by the regular-expression
 549  * parser so that Unicode escapes can be used in expressions that are read from
 550  * files or from the keyboard.  Thus the strings &lt;code&gt;&quot;&amp;#92;u2014&quot;&lt;/code&gt; and
 551  * {@code &quot;\\u2014&quot;}, while not equal, compile into the same pattern, which
 552  * matches the character with hexadecimal value {@code 0x2014}.
 553  * &lt;p&gt;
 554  * A Unicode character can also be represented by using its &lt;b&gt;Hex notation&lt;/b&gt;
 555  * (hexadecimal code point value) directly as described in construct
 556  * &lt;code&gt;&amp;#92;x{...}&lt;/code&gt;, for example a supplementary character U+2011F can be
 557  * specified as &lt;code&gt;&amp;#92;x{2011F}&lt;/code&gt;, instead of two consecutive Unicode escape
 558  * sequences of the surrogate pair &lt;code&gt;&amp;#92;uD840&lt;/code&gt;&lt;code&gt;&amp;#92;uDD1F&lt;/code&gt;.
 559  * &lt;p&gt;
 560  * &lt;b&gt;Unicode character names&lt;/b&gt; are supported by the named character construct
 561  * &lt;code&gt;\N{&lt;/code&gt;...&lt;code&gt;}&lt;/code&gt;, for example, &lt;code&gt;\N{WHITE SMILING FACE}&lt;/code&gt;
 562  * specifies character &lt;code&gt;&amp;#92;u263A&lt;/code&gt;. The character names supported
 563  * by this class are the valid Unicode character names matched by
</pre>
<hr />
<pre>
 672  *     &lt;td&gt;A digit: {@code \p{IsDigit}}&lt;/td&gt;&lt;/tr&gt;
 673  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \D}&lt;/th&gt;
 674  *     &lt;td&gt;A non-digit: {@code [^\d]}&lt;/td&gt;&lt;/tr&gt;
 675  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \s}&lt;/th&gt;
 676  *     &lt;td&gt;A whitespace character: {@code \p{IsWhite_Space}}&lt;/td&gt;&lt;/tr&gt;
 677  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \S}&lt;/th&gt;
 678  *     &lt;td&gt;A non-whitespace character: {@code [^\s]}&lt;/td&gt;&lt;/tr&gt;
 679  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \w}&lt;/th&gt;
 680  *     &lt;td&gt;A word character: {@code [\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}]}&lt;/td&gt;&lt;/tr&gt;
 681  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code \W}&lt;/th&gt;
 682  *     &lt;td&gt;A non-word character: {@code [^\w]}&lt;/td&gt;&lt;/tr&gt;
 683  * &lt;/tbody&gt;
 684  * &lt;/table&gt;
 685  * &lt;p&gt;
 686  * &lt;a id=&quot;jcc&quot;&gt;
 687  * Categories that behave like the java.lang.Character
 688  * boolean is&lt;i&gt;methodname&lt;/i&gt; methods (except for the deprecated ones) are
 689  * available through the same &lt;code&gt;\p{&lt;/code&gt;&lt;i&gt;prop&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; syntax where
 690  * the specified property has the name &lt;code&gt;java&lt;i&gt;methodname&lt;/i&gt;&lt;/code&gt;&lt;/a&gt;.
 691  *
<span class="line-modified"> 692  * &lt;h2&gt; Comparison to Perl 5 &lt;/h2&gt;</span>
 693  *
 694  * &lt;p&gt;The {@code Pattern} engine performs traditional NFA-based matching
 695  * with ordered alternation as occurs in Perl 5.
 696  *
 697  * &lt;p&gt; Perl constructs not supported by this class: &lt;/p&gt;
 698  *
 699  * &lt;ul&gt;
 700  *    &lt;li&gt;&lt;p&gt; The backreference constructs, &lt;code&gt;\g{&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; for
 701  *    the &lt;i&gt;n&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt;&lt;a href=&quot;#cg&quot;&gt;capturing group&lt;/a&gt; and
 702  *    &lt;code&gt;\g{&lt;/code&gt;&lt;i&gt;name&lt;/i&gt;&lt;code&gt;}&lt;/code&gt; for
 703  *    &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt;.
 704  *    &lt;/p&gt;&lt;/li&gt;
 705  *
 706  *    &lt;li&gt;&lt;p&gt; The conditional constructs
 707  *    {@code (?(}&lt;i&gt;condition&lt;/i&gt;{@code )}&lt;i&gt;X&lt;/i&gt;{@code )} and
 708  *    {@code (?(}&lt;i&gt;condition&lt;/i&gt;{@code )}&lt;i&gt;X&lt;/i&gt;{@code |}&lt;i&gt;Y&lt;/i&gt;{@code )},
 709  *    &lt;/p&gt;&lt;/li&gt;
 710  *
 711  *    &lt;li&gt;&lt;p&gt; The embedded code constructs &lt;code&gt;(?{&lt;/code&gt;&lt;i&gt;code&lt;/i&gt;&lt;code&gt;})&lt;/code&gt;
 712  *    and &lt;code&gt;(??{&lt;/code&gt;&lt;i&gt;code&lt;/i&gt;&lt;code&gt;})&lt;/code&gt;,&lt;/p&gt;&lt;/li&gt;
</pre>
<hr />
<pre>
 918      * folding.
 919      * &lt;p&gt;
 920      * Specifying this flag may impose a performance penalty.  &lt;/p&gt;
 921      * @since 1.7
 922      */
 923     public static final int UNICODE_CHARACTER_CLASS = 0x100;
 924 
 925     /**
 926      * Contains all possible flags for compile(regex, flags).
 927      */
 928     private static final int ALL_FLAGS = CASE_INSENSITIVE | MULTILINE |
 929             DOTALL | UNICODE_CASE | CANON_EQ | UNIX_LINES | LITERAL |
 930             UNICODE_CHARACTER_CLASS | COMMENTS;
 931 
 932     /* Pattern has only two serialized components: The pattern string
 933      * and the flags, which are all that is needed to recompile the pattern
 934      * when it is deserialized.
 935      */
 936 
 937     /** use serialVersionUID from Merlin b59 for interoperability */
<span class="line-added"> 938     @java.io.Serial</span>
 939     private static final long serialVersionUID = 5073258162644648461L;
 940 
 941     /**
 942      * The original regular-expression pattern string.
 943      *
 944      * @serial
 945      */
 946     private String pattern;
 947 
 948     /**
 949      * The original pattern flags.
 950      *
 951      * @serial
 952      */
 953     private int flags;
 954 
 955     /**
 956      * The temporary pattern flags used during compiling. The flags might be turn
 957      * on and off by embedded flag.
 958      */
</pre>
<hr />
<pre>
1360                 (lenHint &lt;&lt; 1) : (Integer.MAX_VALUE - 8);
1361 
1362         StringBuilder sb = new StringBuilder(lenHint);
1363         sb.append(&quot;\\Q&quot;);
1364         int current = 0;
1365         do {
1366             sb.append(s, current, slashEIndex)
1367                     .append(&quot;\\E\\\\E\\Q&quot;);
1368             current = slashEIndex + 2;
1369         } while ((slashEIndex = s.indexOf(&quot;\\E&quot;, current)) != -1);
1370 
1371         return sb.append(s, current, s.length())
1372                 .append(&quot;\\E&quot;)
1373                 .toString();
1374     }
1375 
1376     /**
1377      * Recompile the Pattern instance from a stream.  The original pattern
1378      * string is read in and the object tree is recompiled from it.
1379      */
<span class="line-added">1380     @java.io.Serial</span>
1381     private void readObject(java.io.ObjectInputStream s)
1382         throws java.io.IOException, ClassNotFoundException {
1383 
1384         // Read in all fields
1385         s.defaultReadObject();
1386 
1387         // reset the flags
1388         flags0 = flags;
1389 
1390         // Initialize counts
1391         capturingGroupCount = 1;
1392         localCount = 0;
1393         localTCNCount = 0;
1394 
1395         // if length &gt; 0, the Pattern is lazily compiled
1396         if (pattern.isEmpty()) {
1397             root = new Start(lastAccept);
1398             matchRoot = lastAccept;
1399             compiled = true;
1400         }
</pre>
<hr />
<pre>
1410         if ((f &amp; ~ALL_FLAGS) != 0) {
1411             throw new IllegalArgumentException(&quot;Unknown flag 0x&quot;
1412                                                + Integer.toHexString(f));
1413         }
1414         pattern = p;
1415         flags = f;
1416 
1417         // to use UNICODE_CASE if UNICODE_CHARACTER_CLASS present
1418         if ((flags &amp; UNICODE_CHARACTER_CLASS) != 0)
1419             flags |= UNICODE_CASE;
1420 
1421         // &#39;flags&#39; for compiling
1422         flags0 = flags;
1423 
1424         // Reset group index count
1425         capturingGroupCount = 1;
1426         localCount = 0;
1427         localTCNCount = 0;
1428 
1429         if (!pattern.isEmpty()) {
<span class="line-modified">1430             try {</span>
<span class="line-added">1431                 compile();</span>
<span class="line-added">1432             } catch (StackOverflowError soe) {</span>
<span class="line-added">1433                 throw error(&quot;Stack overflow during pattern compilation&quot;);</span>
<span class="line-added">1434             }</span>
1435         } else {
1436             root = new Start(lastAccept);
1437             matchRoot = lastAccept;
1438         }
1439     }
1440 
1441     /**
1442      * The pattern is converted to normalized form ({@link
1443      * java.text.Normalizer.Form#NFC NFC}, canonical decomposition,
1444      * followed by canonical composition for the character class
1445      * part, and {@link java.text.Normalizer.Form#NFD NFD},
1446      * canonical decomposition for the rest), and then a pure
1447      * group is constructed to match canonical equivalences of the
1448      * characters.
1449      */
1450     private static String normalize(String pattern) {
1451         int plen = pattern.length();
1452         StringBuilder pbuf = new StringBuilder(plen);
1453         char last = 0;
1454         int lastStart = 0;
</pre>
<hr />
<pre>
1490         int off0 = off;
1491         while (off &lt; limit &amp;&amp; ASCII.isAscii(src.charAt(off))) {
1492             off++;
1493         }
1494         if (off == limit) {
1495             dst.append(src, off0, limit);
1496             return;
1497         }
1498         off--;
1499         if (off &lt; off0)
1500             off = off0;
1501         else
1502             dst.append(src, off0, off);
1503         while (off &lt; limit) {
1504             int ch0 = src.codePointAt(off);
1505             if (&quot;.$|()[]{}^?*+\\&quot;.indexOf(ch0) != -1) {
1506                 dst.append((char)ch0);
1507                 off++;
1508                 continue;
1509             }
<span class="line-modified">1510             int j = Grapheme.nextBoundary(src, off, limit);</span>
1511             int ch1;







1512             String seq = src.substring(off, j);
1513             String nfd = Normalizer.normalize(seq, Normalizer.Form.NFD);
1514             off = j;
<span class="line-modified">1515             if (nfd.codePointCount(0, nfd.length()) &gt; 1) {</span>
1516                 ch0 = nfd.codePointAt(0);
1517                 ch1 = nfd.codePointAt(Character.charCount(ch0));
1518                 if (Character.getType(ch1) == Character.NON_SPACING_MARK) {
1519                     Set&lt;String&gt; altns = new LinkedHashSet&lt;&gt;();
1520                     altns.add(seq);
1521                     produceEquivalentAlternation(nfd, altns);
1522                     dst.append(&quot;(?:&quot;);
1523                     altns.forEach( s -&gt; dst.append(s).append(&#39;|&#39;));
1524                     dst.delete(dst.length() - 1, dst.length());
1525                     dst.append(&quot;)&quot;);
1526                     continue;
1527                 }
1528             }
1529             String nfc = Normalizer.normalize(seq, Normalizer.Form.NFC);
1530             if (!seq.equals(nfc) &amp;&amp; !nfd.equals(nfc))
1531                 dst.append(&quot;(?:&quot; + seq + &quot;|&quot; + nfd  + &quot;|&quot; + nfc + &quot;)&quot;);
1532             else if (!seq.equals(nfd))
1533                 dst.append(&quot;(?:&quot; + seq + &quot;|&quot; + nfd + &quot;)&quot;);
1534             else
1535                 dst.append(seq);
</pre>
<hr />
<pre>
1661 
1662     /**
1663      * Preprocess any \Q...\E sequences in `temp&#39;, meta-quoting them.
1664      * See the description of `quotemeta&#39; in perlfunc(1).
1665      */
1666     private void RemoveQEQuoting() {
1667         final int pLen = patternLength;
1668         int i = 0;
1669         while (i &lt; pLen-1) {
1670             if (temp[i] != &#39;\\&#39;)
1671                 i += 1;
1672             else if (temp[i + 1] != &#39;Q&#39;)
1673                 i += 2;
1674             else
1675                 break;
1676         }
1677         if (i &gt;= pLen - 1)    // No \Q sequence found
1678             return;
1679         int j = i;
1680         i += 2;
<span class="line-modified">1681         int newTempLen;</span>
<span class="line-added">1682         try {</span>
<span class="line-added">1683             newTempLen = Math.addExact(j + 2, Math.multiplyExact(3, pLen - i));</span>
<span class="line-added">1684         } catch (ArithmeticException ae) {</span>
<span class="line-added">1685             throw new OutOfMemoryError();</span>
<span class="line-added">1686         }</span>
<span class="line-added">1687         int[] newtemp = new int[newTempLen];</span>
1688         System.arraycopy(temp, 0, newtemp, 0, j);
1689 
1690         boolean inQuote = true;
1691         boolean beginQuote = true;
1692         while (i &lt; pLen) {
1693             int c = temp[i++];
1694             if (!ASCII.isAscii(c) || ASCII.isAlpha(c)) {
1695                 newtemp[j++] = c;
1696             } else if (ASCII.isDigit(c)) {
1697                 if (beginQuote) {
1698                     /*
1699                      * A unicode escape \[0xu] could be before this quote,
1700                      * and we don&#39;t want this numeric char to processed as
1701                      * part of the escape.
1702                      */
1703                     newtemp[j++] = &#39;\\&#39;;
1704                     newtemp[j++] = &#39;x&#39;;
1705                     newtemp[j++] = &#39;3&#39;;
1706                 }
1707                 newtemp[j++] = c;
</pre>
<hr />
<pre>
1952     /**
1953      * If in xmode parse past whitespace and comments.
1954      */
1955     private int parsePastWhitespace(int ch) {
1956         while (ASCII.isSpace(ch) || ch == &#39;#&#39;) {
1957             while (ASCII.isSpace(ch))
1958                 ch = temp[cursor++];
1959             if (ch == &#39;#&#39;)
1960                 ch = parsePastLine();
1961         }
1962         return ch;
1963     }
1964 
1965     /**
1966      * xmode parse past comment to end of line.
1967      */
1968     private int parsePastLine() {
1969         int ch = temp[cursor++];
1970         while (ch != 0 &amp;&amp; !isLineSeparator(ch))
1971             ch = temp[cursor++];
<span class="line-added">1972         if (ch == 0 &amp;&amp; cursor &gt; patternLength) {</span>
<span class="line-added">1973             cursor = patternLength;</span>
<span class="line-added">1974             ch = temp[cursor++];</span>
<span class="line-added">1975         }</span>
1976         return ch;
1977     }
1978 
1979     /**
1980      * xmode peek past comment to end of line.
1981      */
1982     private int peekPastLine() {
1983         int ch = temp[++cursor];
1984         while (ch != 0 &amp;&amp; !isLineSeparator(ch))
1985             ch = temp[++cursor];
<span class="line-added">1986         if (ch == 0 &amp;&amp; cursor &gt; patternLength) {</span>
<span class="line-added">1987             cursor = patternLength;</span>
<span class="line-added">1988             ch = temp[cursor];</span>
<span class="line-added">1989         }</span>
1990         return ch;
1991     }
1992 
1993     /**
1994      * Determines if character is a line separator in the current mode
1995      */
1996     private boolean isLineSeparator(int ch) {
1997         if (has(UNIX_LINES)) {
1998             return ch == &#39;\n&#39;;
1999         } else {
2000             return (ch == &#39;\n&#39; ||
2001                     ch == &#39;\r&#39; ||
2002                     (ch|1) == &#39;\u2029&#39; ||
2003                     ch == &#39;\u0085&#39;);
2004         }
2005     }
2006 
2007     /**
2008      * Read the character after the next one, and advance the cursor by two.
2009      */
</pre>
<hr />
<pre>
2047      */
2048     private static final boolean isSupplementary(int ch) {
2049         return ch &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT ||
2050                Character.isSurrogate((char)ch);
2051     }
2052 
2053     /**
2054      *  The following methods handle the main parsing. They are sorted
2055      *  according to their precedence order, the lowest one first.
2056      */
2057 
2058     /**
2059      * The expression is parsed with branch nodes added for alternations.
2060      * This may be called recursively to parse sub expressions that may
2061      * contain alternations.
2062      */
2063     private Node expr(Node end) {
2064         Node prev = null;
2065         Node firstTail = null;
2066         Branch branch = null;
<span class="line-modified">2067         BranchConn branchConn = null;</span>
2068 
2069         for (;;) {
2070             Node node = sequence(end);
2071             Node nodeTail = root;      //double return
2072             if (prev == null) {
2073                 prev = node;
2074                 firstTail = nodeTail;
2075             } else {
2076                 // Branch
2077                 if (branchConn == null) {
2078                     branchConn = new BranchConn();
2079                     branchConn.next = end;
2080                 }
2081                 if (node == end) {
2082                     // if the node returned from sequence() is &quot;end&quot;
2083                     // we have an empty expr, set a null atom into
2084                     // the branch to indicate to go &quot;next&quot; directly.
2085                     node = null;
2086                 } else {
2087                     // the &quot;tail.next&quot; of each atom goes to branchConn
</pre>
<hr />
<pre>
2097                         // when put the &quot;prev&quot; into the branch as the first atom.
2098                         firstTail.next = branchConn;
2099                     }
2100                     prev = branch = new Branch(prev, node, branchConn);
2101                 }
2102             }
2103             if (peek() != &#39;|&#39;) {
2104                 return prev;
2105             }
2106             next();
2107         }
2108     }
2109 
2110     @SuppressWarnings(&quot;fallthrough&quot;)
2111     /**
2112      * Parsing of sequences between alternations.
2113      */
2114     private Node sequence(Node end) {
2115         Node head = null;
2116         Node tail = null;
<span class="line-modified">2117         Node node;</span>
2118     LOOP:
2119         for (;;) {
2120             int ch = peek();
2121             switch (ch) {
2122             case &#39;(&#39;:
2123                 // Because group handles its own closure,
2124                 // we need to treat it differently
2125                 node = group0();
2126                 // Check for comment or flag group
2127                 if (node == null)
2128                     continue;
2129                 if (head == null)
2130                     head = node;
2131                 else
2132                     tail.next = node;
2133                 // Double return: Tail was returned in root
2134                 tail = root;
2135                 continue;
2136             case &#39;[&#39;:
2137                 if (has(CANON_EQ) &amp;&amp; !has(LITERAL))
</pre>
<hr />
<pre>
2195                 break LOOP;
2196             case &#39;]&#39;: // Now interpreting dangling ] and } as literals
2197             case &#39;}&#39;:
2198                 node = atom();
2199                 break;
2200             case &#39;?&#39;:
2201             case &#39;*&#39;:
2202             case &#39;+&#39;:
2203                 next();
2204                 throw error(&quot;Dangling meta character &#39;&quot; + ((char)ch) + &quot;&#39;&quot;);
2205             case 0:
2206                 if (cursor &gt;= patternLength) {
2207                     break LOOP;
2208                 }
2209                 // Fall through
2210             default:
2211                 node = atom();
2212                 break;
2213             }
2214 
<span class="line-modified">2215             if (node instanceof LineEnding) {</span>
<span class="line-added">2216                 LineEnding le = (LineEnding)node;</span>
<span class="line-added">2217                 node = closureOfLineEnding(le);</span>
<span class="line-added">2218 </span>
<span class="line-added">2219                 if (node != le) {</span>
<span class="line-added">2220                     // LineEnding was replaced with an anonymous group</span>
<span class="line-added">2221                     if (head == null)</span>
<span class="line-added">2222                         head = node;</span>
<span class="line-added">2223                     else</span>
<span class="line-added">2224                         tail.next = node;</span>
<span class="line-added">2225                     // Double return: Tail was returned in root</span>
<span class="line-added">2226                     tail = root;</span>
<span class="line-added">2227                     continue;</span>
<span class="line-added">2228                 }</span>
<span class="line-added">2229             } else {</span>
<span class="line-added">2230                 node = closure(node);</span>
<span class="line-added">2231             }</span>
<span class="line-added">2232 </span>
2233             /* save the top dot-greedy nodes (.*, .+) as well
2234             if (node instanceof GreedyCharProperty &amp;&amp;
2235                 ((GreedyCharProperty)node).cp instanceof Dot) {
2236                 topClosureNodes.add(node);
2237             }
2238             */
2239             if (head == null) {
2240                 head = tail = node;
2241             } else {
2242                 tail.next = node;
2243                 tail = node;
2244             }
2245         }
2246         if (head == null) {
2247             return end;
2248         }
2249         tail.next = end;
2250         root = tail;      //double return
2251         return head;
2252     }
</pre>
<hr />
<pre>
2323                 // Fall through
2324             default:
2325                 prev = cursor;
2326                 append(ch, first);
2327                 first++;
2328                 if (isSupplementary(ch)) {
2329                     hasSupplementary = true;
2330                 }
2331                 ch = next();
2332                 continue;
2333             }
2334             break;
2335         }
2336         if (first == 1) {
2337             return newCharProperty(single(buffer[0]));
2338         } else {
2339             return newSlice(buffer, first, hasSupplementary);
2340         }
2341     }
2342 
<span class="line-modified">2343     private void append(int ch, int index) {</span>
<span class="line-modified">2344         int len = buffer.length;</span>
<span class="line-modified">2345         if (index - len &gt;= 0) {</span>
<span class="line-modified">2346             len = ArraysSupport.newLength(len,</span>
<span class="line-modified">2347                     1 + index - len, /* minimum growth */</span>
<span class="line-added">2348                     len              /* preferred growth */);</span>
<span class="line-added">2349             buffer = Arrays.copyOf(buffer, len);</span>
2350         }
<span class="line-modified">2351         buffer[index] = ch;</span>
2352     }
2353 
2354     /**
2355      * Parses a backref greedily, taking as many numbers as it
2356      * can. The first digit is always treated as a backref, but
2357      * multi digit numbers are only treated as a backref if at
2358      * least that many backrefs exist at this point in the regex.
2359      */
2360     private Node ref(int refNum) {
2361         boolean done = false;
2362         while(!done) {
2363             int ch = peek();
2364             switch(ch) {
2365             case &#39;0&#39;:
2366             case &#39;1&#39;:
2367             case &#39;2&#39;:
2368             case &#39;3&#39;:
2369             case &#39;4&#39;:
2370             case &#39;5&#39;:
2371             case &#39;6&#39;:
</pre>
<hr />
<pre>
2631             if (inclass) break;
2632             if (create) root = new End();
2633             return -1;
2634         default:
2635             return ch;
2636         }
2637         throw error(&quot;Illegal/unsupported escape sequence&quot;);
2638     }
2639 
2640     /**
2641      * Parse a character class, and return the node that matches it.
2642      *
2643      * Consumes a ] on the way out if consume is true. Usually consume
2644      * is true except for the case of [abc&amp;&amp;def] where def is a separate
2645      * right hand node with &quot;understood&quot; brackets.
2646      */
2647     private CharPredicate clazz(boolean consume) {
2648         CharPredicate prev = null;
2649         CharPredicate curr = null;
2650         BitClass bits = new BitClass();

2651 
2652         boolean isNeg = false;
2653         boolean hasBits = false;
2654         int ch = next();
2655 
2656         // Negates if first char in a class, otherwise literal
2657         if (ch == &#39;^&#39; &amp;&amp; temp[cursor-1] == &#39;[&#39;) {
2658             ch = next();
2659             isNeg = true;
2660         }
2661         for (;;) {
2662             switch (ch) {
2663                 case &#39;[&#39;:
2664                     curr = clazz(true);
2665                     if (prev == null)
2666                         prev = curr;
2667                     else
2668                         prev = prev.union(curr);
2669                     ch = peek();
2670                     continue;
2671                 case &#39;&amp;&#39;:
2672                     ch = next();
2673                     if (ch == &#39;&amp;&#39;) {
2674                         ch = next();
2675                         CharPredicate right = null;
2676                         while (ch != &#39;]&#39; &amp;&amp; ch != &#39;&amp;&#39;) {
2677                             if (ch == &#39;[&#39;) {
2678                                 if (right == null)
2679                                     right = clazz(true);
2680                                 else
2681                                     right = right.union(clazz(true));
2682                             } else { // abc&amp;&amp;def
2683                                 unread();
2684                                 right = clazz(false);
2685                             }
2686                             ch = peek();
2687                         }
2688                         if (hasBits) {
2689                             // bits used, union has high precedence
2690                             if (prev == null) {
<span class="line-modified">2691                                 prev = curr = bits;</span>
2692                             } else {
<span class="line-modified">2693                                 prev = prev.union(bits);</span>
2694                             }
2695                             hasBits = false;
2696                         }
2697                         if (right != null)
2698                             curr = right;
2699                         if (prev == null) {
2700                             if (right == null)
2701                                 throw error(&quot;Bad class syntax&quot;);
2702                             else
2703                                 prev = right;
2704                         } else {
2705                             prev = prev.and(curr);
2706                         }
2707                     } else {
2708                         // treat as a literal &amp;
2709                         unread();
2710                         break;
2711                     }
2712                     continue;
2713                 case 0:
2714                     if (cursor &gt;= patternLength)
2715                         throw error(&quot;Unclosed character class&quot;);
2716                     break;
2717                 case &#39;]&#39;:
2718                     if (prev != null || hasBits) {
2719                         if (consume)
2720                             next();
2721                         if (prev == null)
<span class="line-modified">2722                             prev = bits;</span>
2723                         else if (hasBits)
<span class="line-modified">2724                             prev = prev.union(bits);</span>
2725                         if (isNeg)
2726                             return prev.negate();
2727                         return prev;
2728                     }
2729                     break;
2730                 default:
2731                     break;
2732             }
2733             curr = range(bits);
2734             if (curr == null) {    // the bits used
2735                 hasBits = true;
2736             } else {
2737                 if (prev == null)
2738                     prev = curr;
2739                 else if (prev != curr)
2740                     prev = prev.union(curr);
2741             }
2742             ch = peek();
2743         }
2744     }
</pre>
<hr />
<pre>
2902                 case &quot;block&quot;:
2903                     p = CharPredicates.forUnicodeBlock(value);
2904                     break;
2905                 case &quot;gc&quot;:
2906                 case &quot;general_category&quot;:
2907                     p = CharPredicates.forProperty(value);
2908                     break;
2909                 default:
2910                     break;
2911             }
2912             if (p == null)
2913                 throw error(&quot;Unknown Unicode property {name=&lt;&quot; + name + &quot;&gt;, &quot;
2914                              + &quot;value=&lt;&quot; + value + &quot;&gt;}&quot;);
2915 
2916         } else {
2917             if (name.startsWith(&quot;In&quot;)) {
2918                 // \p{InBlockName}
2919                 p = CharPredicates.forUnicodeBlock(name.substring(2));
2920             } else if (name.startsWith(&quot;Is&quot;)) {
2921                 // \p{IsGeneralCategory} and \p{IsScriptName}
<span class="line-modified">2922                 String shortName = name.substring(2);</span>
<span class="line-modified">2923                 p = CharPredicates.forUnicodeProperty(shortName);</span>
2924                 if (p == null)
<span class="line-modified">2925                     p = CharPredicates.forProperty(shortName);</span>
2926                 if (p == null)
<span class="line-modified">2927                     p = CharPredicates.forUnicodeScript(shortName);</span>
2928             } else {
2929                 if (has(UNICODE_CHARACTER_CLASS)) {
2930                     p = CharPredicates.forPOSIXName(name);
2931                 }
2932                 if (p == null)
2933                     p = CharPredicates.forProperty(name);
2934             }
2935             if (p == null)
<span class="line-modified">2936                 throw error(&quot;Unknown character property name {&quot; + name + &quot;}&quot;);</span>
2937         }
2938         if (isComplement) {
2939             // it might be too expensive to detect if a complement of
2940             // CharProperty can match &quot;certain&quot; supplementary. So just
2941             // go with StartS.
2942             hasSupplementary = true;
2943             p = p.negate();
2944         }
2945         return p;
2946     }
2947 
2948     private CharProperty newCharProperty(CharPredicate p) {
2949         if (p == null)
2950             return null;
2951         if (p instanceof BmpCharPredicate)
2952             return new BmpCharProperty((BmpCharPredicate)p);
2953         else
2954             return new CharProperty(p);
2955     }
2956 
</pre>
<hr />
<pre>
2960      */
2961     private String groupname(int ch) {
2962         StringBuilder sb = new StringBuilder();
2963         if (!ASCII.isAlpha(ch))
2964             throw error(&quot;capturing group name does not start with a Latin letter&quot;);
2965         do {
2966             sb.append((char) ch);
2967         } while (ASCII.isAlnum(ch=read()));
2968         if (ch != &#39;&gt;&#39;)
2969             throw error(&quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;);
2970         return sb.toString();
2971     }
2972 
2973     /**
2974      * Parses a group and returns the head node of a set of nodes that process
2975      * the group. Sometimes a double return system is used where the tail is
2976      * returned in root.
2977      */
2978     private Node group0() {
2979         boolean capturingGroup = false;
<span class="line-modified">2980         Node head;</span>
<span class="line-modified">2981         Node tail;</span>
2982         int save = flags0;
2983         int saveTCNCount = topClosureNodes.size();
2984         root = null;
2985         int ch = next();
2986         if (ch == &#39;?&#39;) {
2987             ch = skip();
2988             switch (ch) {
2989             case &#39;:&#39;:   //  (?:xxx) pure group
2990                 head = createGroup(true);
2991                 tail = root;
2992                 head.next = expr(tail);
2993                 break;
2994             case &#39;=&#39;:   // (?=xxx) and (?!xxx) lookahead
2995             case &#39;!&#39;:
2996                 head = createGroup(true);
2997                 tail = root;
2998                 head.next = expr(tail);
2999                 if (ch == &#39;=&#39;) {
3000                     head = tail = new Pos(head);
3001                 } else {
</pre>
<hr />
<pre>
3010                 break;
3011             case &#39;&lt;&#39;:   // (?&lt;xxx)  look behind
3012                 ch = read();
3013                 if (ch != &#39;=&#39; &amp;&amp; ch != &#39;!&#39;) {
3014                     // named captured group
3015                     String name = groupname(ch);
3016                     if (namedGroups().containsKey(name))
3017                         throw error(&quot;Named capturing group &lt;&quot; + name
3018                                     + &quot;&gt; is already defined&quot;);
3019                     capturingGroup = true;
3020                     head = createGroup(false);
3021                     tail = root;
3022                     namedGroups().put(name, capturingGroupCount-1);
3023                     head.next = expr(tail);
3024                     break;
3025                 }
3026                 int start = cursor;
3027                 head = createGroup(true);
3028                 tail = root;
3029                 head.next = expr(tail);
<span class="line-modified">3030                 tail.next = LookBehindEndNode.INSTANCE;</span>
3031                 TreeInfo info = new TreeInfo();
3032                 head.study(info);
3033                 if (info.maxValid == false) {
3034                     throw error(&quot;Look-behind group does not have &quot;
3035                                 + &quot;an obvious maximum length&quot;);
3036                 }
3037                 boolean hasSupplementary = findSupplementary(start, patternLength);
3038                 if (ch == &#39;=&#39;) {
3039                     head = tail = (hasSupplementary ?
3040                                    new BehindS(head, info.maxLength,
3041                                                info.minLength) :
3042                                    new Behind(head, info.maxLength,
3043                                               info.minLength));
3044                 } else { // if (ch == &#39;!&#39;)
3045                     head = tail = (hasSupplementary ?
3046                                    new NotBehindS(head, info.maxLength,
3047                                                   info.minLength) :
3048                                    new NotBehind(head, info.maxLength,
3049                                                  info.minLength));
3050                 }
</pre>
<hr />
<pre>
3079 
3080         accept(&#39;)&#39;, &quot;Unclosed group&quot;);
3081         flags0 = save;
3082 
3083         // Check for quantifiers
3084         Node node = closure(head);
3085         if (node == head) { // No closure
3086             root = tail;
3087             return node;    // Dual return
3088         }
3089         if (head == tail) { // Zero length assertion
3090             root = node;
3091             return node;    // Dual return
3092         }
3093 
3094         // have group closure, clear all inner closure nodes from the
3095         // top list (no backtracking stopper optimization for inner
3096         if (saveTCNCount &lt; topClosureNodes.size())
3097             topClosureNodes.subList(saveTCNCount, topClosureNodes.size()).clear();
3098 
<span class="line-added">3099         return groupWithClosure(node, head, tail, capturingGroup);</span>
<span class="line-added">3100     }</span>
<span class="line-added">3101 </span>
<span class="line-added">3102     /**</span>
<span class="line-added">3103      * Transforms a Group with quantifiers into some special constructs</span>
<span class="line-added">3104      * (such as Branch or Loop/GroupCurly), if necessary.</span>
<span class="line-added">3105      *</span>
<span class="line-added">3106      * This method is applied either to actual groups or to the Unicode</span>
<span class="line-added">3107      * linebreak (aka \\R) represented as an anonymous group.</span>
<span class="line-added">3108      */</span>
<span class="line-added">3109     private Node groupWithClosure(Node node, Node head, Node tail,</span>
<span class="line-added">3110                                   boolean capturingGroup)</span>
<span class="line-added">3111     {</span>
3112         if (node instanceof Ques) {
3113             Ques ques = (Ques) node;
3114             if (ques.type == Qtype.POSSESSIVE) {
3115                 root = node;
3116                 return node;
3117             }
<span class="line-modified">3118             BranchConn branchConn = new BranchConn();</span>
<span class="line-modified">3119             tail = tail.next = branchConn;</span>
3120             if (ques.type == Qtype.GREEDY) {
<span class="line-modified">3121                 head = new Branch(head, null, branchConn);</span>
3122             } else { // Reluctant quantifier
<span class="line-modified">3123                 head = new Branch(null, head, branchConn);</span>
3124             }
3125             root = tail;
3126             return head;
3127         } else if (node instanceof Curly) {
3128             Curly curly = (Curly) node;
3129             if (curly.type == Qtype.POSSESSIVE) {
3130                 root = node;
3131                 return node;
3132             }
3133             // Discover if the group is deterministic
3134             TreeInfo info = new TreeInfo();
3135             if (head.study(info)) { // Deterministic
3136                 GroupTail temp = (GroupTail) tail;
3137                 head = root = new GroupCurly(head.next, curly.cmin,
3138                                    curly.cmax, curly.type,
3139                                    ((GroupTail)tail).localIndex,
3140                                    ((GroupTail)tail).groupIndex,
3141                                              capturingGroup);
3142                 return head;
3143             } else { // Non-deterministic
</pre>
<hr />
<pre>
3256                 break;
3257             case &#39;x&#39;:
3258                 flags0 &amp;= ~COMMENTS;
3259                 break;
3260             case &#39;U&#39;:
3261                 flags0 &amp;= ~(UNICODE_CHARACTER_CLASS | UNICODE_CASE);
3262                 break;
3263             default:
3264                 return;
3265             }
3266             ch = next();
3267         }
3268     }
3269 
3270     static final int MAX_REPS   = 0x7FFFFFFF;
3271 
3272     static enum Qtype {
3273         GREEDY, LAZY, POSSESSIVE, INDEPENDENT
3274     }
3275 
<span class="line-modified">3276     private Qtype qtype() {</span>
3277         int ch = next();
3278         if (ch == &#39;?&#39;) {
3279             next();
<span class="line-modified">3280             return Qtype.LAZY;</span>
3281         } else if (ch == &#39;+&#39;) {
3282             next();
<span class="line-modified">3283             return Qtype.POSSESSIVE;</span>
3284         }
<span class="line-modified">3285         return Qtype.GREEDY;</span>
<span class="line-modified">3286     }</span>
<span class="line-modified">3287 </span>
<span class="line-modified">3288     private Node curly(Node prev, int cmin) {</span>
<span class="line-added">3289         Qtype qtype = qtype();</span>
<span class="line-added">3290         if (qtype == Qtype.GREEDY) {</span>
<span class="line-added">3291             if (prev instanceof BmpCharProperty) {</span>
<span class="line-added">3292                 return new BmpCharPropertyGreedy((BmpCharProperty)prev, cmin);</span>
<span class="line-added">3293             } else if (prev instanceof CharProperty) {</span>
<span class="line-added">3294                 return new CharPropertyGreedy((CharProperty)prev, cmin);</span>
<span class="line-added">3295             }</span>
3296         }
<span class="line-modified">3297         return new Curly(prev, cmin, MAX_REPS, qtype);</span>
<span class="line-added">3298     }</span>
<span class="line-added">3299 </span>
<span class="line-added">3300     /**</span>
<span class="line-added">3301      * Processing repetition of a Unicode linebreak \\R.</span>
<span class="line-added">3302      */</span>
<span class="line-added">3303     private Node closureOfLineEnding(LineEnding le) {</span>
<span class="line-added">3304         int ch = peek();</span>
<span class="line-added">3305         if (ch != &#39;?&#39; &amp;&amp; ch != &#39;*&#39; &amp;&amp; ch != &#39;+&#39; &amp;&amp; ch != &#39;{&#39;) {</span>
<span class="line-added">3306             return le;</span>
<span class="line-added">3307         }</span>
<span class="line-added">3308 </span>
<span class="line-added">3309         // Replace the LineEnding with an anonymous group</span>
<span class="line-added">3310         // (?:\\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029])</span>
<span class="line-added">3311         Node grHead = createGroup(true);</span>
<span class="line-added">3312         Node grTail = root;</span>
<span class="line-added">3313         BranchConn branchConn = new BranchConn();</span>
<span class="line-added">3314         branchConn.next = grTail;</span>
<span class="line-added">3315         Node slice = new Slice(new int[] {0x0D, 0x0A});</span>
<span class="line-added">3316         slice.next = branchConn;</span>
<span class="line-added">3317         Node chClass = newCharProperty(x -&gt; x == 0x0A || x == 0x0B ||</span>
<span class="line-added">3318                 x == 0x0C || x == 0x0D || x == 0x85 || x == 0x2028 ||</span>
<span class="line-added">3319                 x == 0x2029);</span>
<span class="line-added">3320         chClass.next = branchConn;</span>
<span class="line-added">3321         grHead.next = new Branch(slice, chClass, branchConn);</span>
<span class="line-added">3322         return groupWithClosure(closure(grHead), grHead, grTail, false);</span>
3323     }
3324 
3325     /**
3326      * Processes repetition. If the next character peeked is a quantifier
3327      * then new nodes must be appended to handle the repetition.
3328      * Prev could be a single or a group, so it could be a chain of nodes.
3329      */
3330     private Node closure(Node prev) {

3331         int ch = peek();
3332         switch (ch) {
3333         case &#39;?&#39;:
<span class="line-modified">3334             return new Ques(prev, qtype());</span>








3335         case &#39;*&#39;:
3336             return curly(prev, 0);
3337         case &#39;+&#39;:
3338             return curly(prev, 1);
3339         case &#39;{&#39;:
<span class="line-modified">3340             ch = skip();</span>
3341             if (ASCII.isDigit(ch)) {
<span class="line-modified">3342                 int cmin = 0, cmax;</span>
<span class="line-modified">3343                 try {</span>
<span class="line-modified">3344                     do {</span>
<span class="line-modified">3345                         cmin = Math.addExact(Math.multiplyExact(cmin, 10),</span>
<span class="line-modified">3346                                              ch - &#39;0&#39;);</span>
<span class="line-modified">3347                     } while (ASCII.isDigit(ch = read()));</span>
<span class="line-modified">3348                     if (ch == &#39;,&#39;) {</span>
<span class="line-modified">3349                         ch = read();</span>
<span class="line-modified">3350                         if (ch == &#39;}&#39;) {</span>
<span class="line-modified">3351                             unread();</span>
<span class="line-modified">3352                             return curly(prev, cmin);</span>
<span class="line-modified">3353                         } else {</span>
<span class="line-modified">3354                             cmax = 0;</span>
<span class="line-modified">3355                             while (ASCII.isDigit(ch)) {</span>
<span class="line-added">3356                                 cmax = Math.addExact(Math.multiplyExact(cmax, 10),</span>
<span class="line-added">3357                                                      ch - &#39;0&#39;);</span>
<span class="line-added">3358                                 ch = read();</span>
<span class="line-added">3359                             }</span>
3360                         }
<span class="line-added">3361                     } else {</span>
<span class="line-added">3362                         cmax = cmin;</span>
3363                     }
<span class="line-added">3364                 } catch (ArithmeticException ae) {</span>
<span class="line-added">3365                     throw error(&quot;Illegal repetition range&quot;);</span>
3366                 }
3367                 if (ch != &#39;}&#39;)
3368                     throw error(&quot;Unclosed counted closure&quot;);
<span class="line-modified">3369                 if (cmax &lt; cmin)</span>
3370                     throw error(&quot;Illegal repetition range&quot;);
<span class="line-modified">3371                 unread();</span>
<span class="line-modified">3372                 return (cmin == 0 &amp;&amp; cmax == 1)</span>
<span class="line-modified">3373                         ? new Ques(prev, qtype())</span>
<span class="line-modified">3374                         : new Curly(prev, cmin, cmax, qtype());</span>








3375             } else {
3376                 throw error(&quot;Illegal repetition&quot;);
3377             }
3378         default:
3379             return prev;
3380         }
3381     }
3382 
3383     /**
3384      *  Utility method for parsing control escape sequences.
3385      */
3386     private int c() {
3387         if (cursor &lt; patternLength) {
3388             return read() ^ 64;
3389         }
3390         throw error(&quot;Illegal control escape sequence&quot;);
3391     }
3392 
3393     /**
3394      *  Utility method for parsing octal escape sequences.
</pre>
<hr />
<pre>
3458         return n;
3459     }
3460 
3461     private int u() {
3462         int n = uxxxx();
3463         if (Character.isHighSurrogate((char)n)) {
3464             int cur = cursor();
3465             if (read() == &#39;\\&#39; &amp;&amp; read() == &#39;u&#39;) {
3466                 int n2 = uxxxx();
3467                 if (Character.isLowSurrogate((char)n2))
3468                     return Character.toCodePoint((char)n, (char)n2);
3469             }
3470             setcursor(cur);
3471         }
3472         return n;
3473     }
3474 
3475     private int N() {
3476         if (read() == &#39;{&#39;) {
3477             int i = cursor;
<span class="line-modified">3478             while (read() != &#39;}&#39;) {</span>
<span class="line-modified">3479                 if (cursor &gt;= patternLength)</span>
<span class="line-modified">3480                     throw error(&quot;Unclosed character name escape sequence&quot;);</span>
<span class="line-added">3481             }</span>
3482             String name = new String(temp, i, cursor - i - 1);
3483             try {
3484                 return Character.codePointOf(name);
3485             } catch (IllegalArgumentException x) {
3486                 throw error(&quot;Unknown character name [&quot; + name + &quot;]&quot;);
3487             }
3488         }
3489         throw error(&quot;Illegal character name escape sequence&quot;);
3490     }
3491 
3492     //
3493     // Utility methods for code point support
3494     //
3495     private static final int countChars(CharSequence seq, int index,
3496                                         int lengthInCodePoints) {
3497         // optimization
3498         if (lengthInCodePoints == 1 &amp;&amp; !Character.isHighSurrogate(seq.charAt(index))) {
3499             assert (index &gt;= 0 &amp;&amp; index &lt; seq.length());
3500             return 1;
3501         }
</pre>
<hr />
<pre>
3530 
3531     private static final int countCodePoints(CharSequence seq) {
3532         int length = seq.length();
3533         int n = 0;
3534         for (int i = 0; i &lt; length; ) {
3535             n++;
3536             if (Character.isHighSurrogate(seq.charAt(i++))) {
3537                 if (i &lt; length &amp;&amp; Character.isLowSurrogate(seq.charAt(i))) {
3538                     i++;
3539                 }
3540             }
3541         }
3542         return n;
3543     }
3544 
3545     /**
3546      *  Creates a bit vector for matching Latin-1 values. A normal BitClass
3547      *  never matches values above Latin-1, and a complemented BitClass always
3548      *  matches values above Latin-1.
3549      */
<span class="line-modified">3550     static final class BitClass implements BmpCharPredicate {</span>
3551         final boolean[] bits;
3552         BitClass() {
<span class="line-modified">3553             bits = new boolean[256];</span>




3554         }
3555         BitClass add(int c, int flags) {
3556             assert c &gt;= 0 &amp;&amp; c &lt;= 255;
3557             if ((flags &amp; CASE_INSENSITIVE) != 0) {
3558                 if (ASCII.isAscii(c)) {
3559                     bits[ASCII.toUpper(c)] = true;
3560                     bits[ASCII.toLower(c)] = true;
3561                 } else if ((flags &amp; UNICODE_CASE) != 0) {
3562                     bits[Character.toLowerCase(c)] = true;
3563                     bits[Character.toUpperCase(c)] = true;
3564                 }
3565             }
3566             bits[c] = true;
3567             return this;
3568         }
<span class="line-added">3569         public boolean is(int ch) {</span>
<span class="line-added">3570             return ch &lt; 256 &amp;&amp; bits[ch];</span>
<span class="line-added">3571         }</span>
3572     }
3573 
<span class="line-added">3574 </span>
3575     /**
3576      *  Utility method for creating a string slice matcher.
3577      */
3578     private Node newSlice(int[] buf, int count, boolean hasSupplementary) {
3579         int[] tmp = new int[count];
3580         if (has(CASE_INSENSITIVE)) {
3581             if (has(UNICODE_CASE)) {
3582                 for (int i = 0; i &lt; count; i++) {
3583                     tmp[i] = Character.toLowerCase(
3584                                  Character.toUpperCase(buf[i]));
3585                 }
3586                 return hasSupplementary? new SliceUS(tmp) : new SliceU(tmp);
3587             }
3588             for (int i = 0; i &lt; count; i++) {
3589                 tmp[i] = ASCII.toLower(buf[i]);
3590             }
3591             return hasSupplementary? new SliceIS(tmp) : new SliceI(tmp);
3592         }
3593         for (int i = 0; i &lt; count; i++) {
3594             tmp[i] = buf[i];
</pre>
<hr />
<pre>
3967                     }
3968                     return next.match(matcher, i, seq);
3969                 }
3970             } else {
3971                 matcher.hitEnd = true;
3972             }
3973             return false;
3974         }
3975         boolean study(TreeInfo info) {
3976             info.minLength++;
3977             info.maxLength += 2;
3978             return next.study(info);
3979         }
3980     }
3981 
3982     /**
3983      * Abstract node class to match one character satisfying some
3984      * boolean property.
3985      */
3986     static class CharProperty extends Node {
<span class="line-modified">3987         final CharPredicate predicate;</span>
3988 
3989         CharProperty (CharPredicate predicate) {
3990             this.predicate = predicate;
3991         }
3992         boolean match(Matcher matcher, int i, CharSequence seq) {
3993             if (i &lt; matcher.to) {
3994                 int ch = Character.codePointAt(seq, i);
<span class="line-modified">3995                 i += Character.charCount(ch);</span>
<span class="line-modified">3996                 if (i &lt;= matcher.to) {</span>
<span class="line-modified">3997                     return predicate.is(ch) &amp;&amp;</span>
<span class="line-modified">3998                            next.match(matcher, i, seq);</span>
<span class="line-modified">3999                 }</span>
4000             }
<span class="line-added">4001             matcher.hitEnd = true;</span>
<span class="line-added">4002             return false;</span>
4003         }
4004         boolean study(TreeInfo info) {
4005             info.minLength++;
4006             info.maxLength++;
4007             return next.study(info);
4008         }
4009     }
4010 
4011     /**
4012      * Optimized version of CharProperty that works only for
4013      * properties never satisfied by Supplementary characters.
4014      */
4015     private static class BmpCharProperty extends CharProperty {
4016         BmpCharProperty (BmpCharPredicate predicate) {
4017             super(predicate);
4018         }
4019         boolean match(Matcher matcher, int i, CharSequence seq) {
4020             if (i &lt; matcher.to) {
4021                 return predicate.is(seq.charAt(i)) &amp;&amp;
4022                        next.match(matcher, i + 1, seq);
4023             } else {
4024                 matcher.hitEnd = true;
4025                 return false;
4026             }
4027         }
4028     }
4029 
4030     private static class NFCCharProperty extends Node {
4031         CharPredicate predicate;
4032         NFCCharProperty (CharPredicate predicate) {
4033             this.predicate = predicate;
4034         }
4035 
4036         boolean match(Matcher matcher, int i, CharSequence seq) {
4037             if (i &lt; matcher.to) {
4038                 int ch0 = Character.codePointAt(seq, i);
4039                 int n = Character.charCount(ch0);
4040                 int j = i + n;
<span class="line-added">4041                 // Fast check if it&#39;s necessary to call Normalizer;</span>
<span class="line-added">4042                 // testing Grapheme.isBoundary is enough for this case</span>
4043                 while (j &lt; matcher.to) {
4044                     int ch1 = Character.codePointAt(seq, j);
4045                     if (Grapheme.isBoundary(ch0, ch1))
4046                         break;
4047                     ch0 = ch1;
4048                     j += Character.charCount(ch1);
4049                 }
4050                 if (i + n == j) {    // single, assume nfc cp
4051                     if (predicate.is(ch0))
4052                         return next.match(matcher, j, seq);
4053                 } else {
4054                     while (i + n &lt; j) {
4055                         String nfc = Normalizer.normalize(
4056                             seq.toString().substring(i, j), Normalizer.Form.NFC);
4057                         if (nfc.codePointCount(0, nfc.length()) == 1) {
4058                             if (predicate.is(nfc.codePointAt(0)) &amp;&amp;
4059                                 next.match(matcher, j, seq)) {
4060                                 return true;
4061                             }
4062                         }
</pre>
<hr />
<pre>
4068                 if (j &lt; matcher.to)
4069                     return false;
4070             }
4071             matcher.hitEnd = true;
4072             return false;
4073         }
4074 
4075         boolean study(TreeInfo info) {
4076             info.minLength++;
4077             info.deterministic = false;
4078             return next.study(info);
4079         }
4080     }
4081 
4082     /**
4083      * Node class that matches an unicode extended grapheme cluster
4084      */
4085     static class XGrapheme extends Node {
4086         boolean match(Matcher matcher, int i, CharSequence seq) {
4087             if (i &lt; matcher.to) {
<span class="line-modified">4088                 i = Grapheme.nextBoundary(seq, i, matcher.to);</span>








4089                 return next.match(matcher, i, seq);
4090             }
4091             matcher.hitEnd = true;
4092             return false;
4093         }
4094 
4095         boolean study(TreeInfo info) {
4096             info.minLength++;
4097             info.deterministic = false;
4098             return next.study(info);
4099         }
4100     }
4101 
4102     /**
4103      * Node class that handles grapheme boundaries
4104      */
4105     static class GraphemeBound extends Node {
4106         boolean match(Matcher matcher, int i, CharSequence seq) {
4107             int startIndex = matcher.from;
4108             int endIndex = matcher.to;
4109             if (matcher.transparentBounds) {
4110                 startIndex = 0;
4111                 endIndex = matcher.getTextLength();
4112             }
4113             if (i == startIndex) {
4114                 return next.match(matcher, i, seq);
4115             }
4116             if (i &lt; endIndex) {
4117                 if (Character.isSurrogatePair(seq.charAt(i-1), seq.charAt(i)) ||
<span class="line-modified">4118                     Grapheme.nextBoundary(seq,</span>
<span class="line-modified">4119                         i - Character.charCount(Character.codePointBefore(seq, i)),</span>
<span class="line-added">4120                         i + Character.charCount(Character.codePointAt(seq, i))) &gt; i) {</span>
4121                     return false;
4122                 }
4123             } else {
4124                 matcher.hitEnd = true;
4125                 matcher.requireEnd = true;
4126             }
4127             return next.match(matcher, i, seq);
4128         }
4129     }
4130 
4131     /**
4132      * Base class for all Slice nodes
4133      */
4134     static class SliceNode extends Node {
4135         int[] buffer;
4136         SliceNode(int[] buf) {
4137             buffer = buf;
4138         }
4139         boolean study(TreeInfo info) {
4140             info.minLength += buffer.length;
</pre>
<hr />
<pre>
4313                 return next.match(matcher, i, seq);
4314             default:
4315                 return atom.match(matcher, i, seq) &amp;&amp; next.match(matcher, matcher.last, seq);
4316             }
4317         }
4318         boolean study(TreeInfo info) {
4319             if (type != Qtype.INDEPENDENT) {
4320                 int minL = info.minLength;
4321                 atom.study(info);
4322                 info.minLength = minL;
4323                 info.deterministic = false;
4324                 return next.study(info);
4325             } else {
4326                 atom.study(info);
4327                 return next.study(info);
4328             }
4329         }
4330     }
4331 
4332     /**
<span class="line-modified">4333      * Handles the greedy style repetition with the specified minimum</span>
<span class="line-modified">4334      * and the maximum equal to MAX_REPS, for *, + and {N,} quantifiers.</span>
4335      */
4336     static class CharPropertyGreedy extends Node {
4337         final CharPredicate predicate;
4338         final int cmin;
4339 
4340         CharPropertyGreedy(CharProperty cp, int cmin) {
4341             this.predicate = cp.predicate;
4342             this.cmin = cmin;
4343         }
<span class="line-modified">4344         boolean match(Matcher matcher, int i, CharSequence seq) {</span>
4345             int n = 0;
4346             int to = matcher.to;
4347             // greedy, all the way down
4348             while (i &lt; to) {
4349                 int ch = Character.codePointAt(seq, i);
4350                 if (!predicate.is(ch))
4351                    break;
4352                 i += Character.charCount(ch);
4353                 n++;
4354             }
4355             if (i &gt;= to) {
4356                 matcher.hitEnd = true;
4357             }
4358             while (n &gt;= cmin) {
4359                 if (next.match(matcher, i, seq))
4360                     return true;
4361                 if (n == cmin)
4362                     return false;
4363                  // backing off if match fails
4364                 int ch = Character.codePointBefore(seq, i);
</pre>
<hr />
<pre>
4367             }
4368             return false;
4369         }
4370 
4371         boolean study(TreeInfo info) {
4372             info.minLength += cmin;
4373             if (info.maxValid) {
4374                 info.maxLength += MAX_REPS;
4375             }
4376             info.deterministic = false;
4377             return next.study(info);
4378         }
4379     }
4380 
4381     static final class BmpCharPropertyGreedy extends CharPropertyGreedy {
4382 
4383         BmpCharPropertyGreedy(BmpCharProperty bcp, int cmin) {
4384             super(bcp, cmin);
4385         }
4386 
<span class="line-modified">4387         boolean match(Matcher matcher, int i, CharSequence seq) {</span>
4388             int n = 0;
4389             int to = matcher.to;
4390             while (i &lt; to &amp;&amp; predicate.is(seq.charAt(i))) {
4391                 i++; n++;
4392             }
4393             if (i &gt;= to) {
4394                 matcher.hitEnd = true;
4395             }
4396             while (n &gt;= cmin) {
4397                 if (next.match(matcher, i, seq))
4398                     return true;
4399                 i--; n--;  // backing off if match fails
4400             }
4401             return false;
4402         }
4403     }
4404 
4405     /**
4406      * Handles the curly-brace style repetition with a specified minimum and
4407      * maximum occurrences. The * quantifier is handled as a special case.
</pre>
<hr />
<pre>
4744                 info.maxValid = false;
4745             }
4746 
4747             if (info.deterministic &amp;&amp; cmin == cmax) {
4748                 info.deterministic = detm;
4749             } else {
4750                 info.deterministic = false;
4751             }
4752             return next.study(info);
4753         }
4754     }
4755 
4756     /**
4757      * A Guard node at the end of each atom node in a Branch. It
4758      * serves the purpose of chaining the &quot;match&quot; operation to
4759      * &quot;next&quot; but not the &quot;study&quot;, so we can collect the TreeInfo
4760      * of each atom node without including the TreeInfo of the
4761      * &quot;next&quot;.
4762      */
4763     static final class BranchConn extends Node {
<span class="line-modified">4764         BranchConn() {}</span>
4765         boolean match(Matcher matcher, int i, CharSequence seq) {
4766             return next.match(matcher, i, seq);
4767         }
4768         boolean study(TreeInfo info) {
4769             return info.deterministic;
4770         }
4771     }
4772 
4773     /**
4774      * Handles the branching of alternations. Note this is also used for
4775      * the ? quantifier to branch between the case where it matches once
4776      * and where it does not occur.
4777      */
4778     static final class Branch extends Node {
4779         Node[] atoms = new Node[2];
4780         int size = 2;
<span class="line-modified">4781         BranchConn conn;</span>
<span class="line-modified">4782         Branch(Node first, Node second, BranchConn branchConn) {</span>
4783             conn = branchConn;
4784             atoms[0] = first;
4785             atoms[1] = second;
4786         }
4787 
4788         void add(Node node) {
4789             if (size &gt;= atoms.length) {
<span class="line-modified">4790                 int len = ArraysSupport.newLength(size,</span>
<span class="line-modified">4791                         1,    /* minimum growth */</span>
<span class="line-modified">4792                         size  /* preferred growth */);</span>
<span class="line-added">4793                 atoms = Arrays.copyOf(atoms, len);</span>
4794             }
4795             atoms[size++] = node;
4796         }
4797 
4798         boolean match(Matcher matcher, int i, CharSequence seq) {
4799             for (int n = 0; n &lt; size; n++) {
4800                 if (atoms[n] == null) {
4801                     if (conn.next.match(matcher, i, seq))
4802                         return true;
4803                 } else if (atoms[n].match(matcher, i, seq)) {
4804                     return true;
4805                 }
4806             }
4807             return false;
4808         }
4809 
4810         boolean study(TreeInfo info) {
4811             int minL = info.minLength;
4812             int maxL = info.maxLength;
4813             boolean maxV = info.maxValid;
</pre>
<hr />
<pre>
4842      * and restores them when the match is done.
4843      *
4844      * The matchRef is used when a reference to this group is accessed later
4845      * in the expression. The locals will have a negative value in them to
4846      * indicate that we do not want to unset the group if the reference
4847      * doesn&#39;t match.
4848      */
4849     static final class GroupHead extends Node {
4850         int localIndex;
4851         GroupTail tail;    // for debug/print only, match does not need to know
4852         GroupHead(int localCount) {
4853             localIndex = localCount;
4854         }
4855         boolean match(Matcher matcher, int i, CharSequence seq) {
4856             int save = matcher.locals[localIndex];
4857             matcher.locals[localIndex] = i;
4858             boolean ret = next.match(matcher, i, seq);
4859             matcher.locals[localIndex] = save;
4860             return ret;
4861         }




























4862     }
4863 
4864     /**
4865      * The GroupTail handles the setting of group beginning and ending
4866      * locations when groups are successfully matched. It must also be able to
4867      * unset groups that have to be backed off of.
4868      *
4869      * The GroupTail node is also used when a previous group is referenced,
4870      * and in that case no group information needs to be set.
4871      */
4872     static final class GroupTail extends Node {
4873         int localIndex;
4874         int groupIndex;
4875         GroupTail(int localCount, int groupCount) {
4876             localIndex = localCount;
4877             groupIndex = groupCount + groupCount;
4878         }
4879         boolean match(Matcher matcher, int i, CharSequence seq) {
4880             int tmp = matcher.locals[localIndex];
4881             if (tmp &gt;= 0) { // This is the normal group case.
</pre>
<hr />
<pre>
4963                         matcher.localsPos[posIndex].contains(i)) {
4964                         return next.match(matcher, i, seq);
4965                     }
4966                     matcher.locals[countIndex] = count + 1;
4967                     boolean b = body.match(matcher, i, seq);
4968                     // If match failed we must backtrack, so
4969                     // the loop count should NOT be incremented
4970                     if (b)
4971                         return true;
4972                     matcher.locals[countIndex] = count;
4973                     // save the failed position
4974                     if (posIndex != -1) {
4975                         matcher.localsPos[posIndex].add(i);
4976                     }
4977                 }
4978             }
4979             return next.match(matcher, i, seq);
4980         }
4981         boolean matchInit(Matcher matcher, int i, CharSequence seq) {
4982             int save = matcher.locals[countIndex];
<span class="line-modified">4983             boolean ret;</span>
4984             if (posIndex != -1 &amp;&amp; matcher.localsPos[posIndex] == null) {
4985                 matcher.localsPos[posIndex] = new IntHashSet();
4986             }
4987             if (0 &lt; cmin) {
4988                 matcher.locals[countIndex] = 1;
4989                 ret = body.match(matcher, i, seq);
4990             } else if (0 &lt; cmax) {
4991                 matcher.locals[countIndex] = 1;
4992                 ret = body.match(matcher, i, seq);
4993                 if (ret == false)
4994                     ret = next.match(matcher, i, seq);
4995             } else {
4996                 ret = next.match(matcher, i, seq);
4997             }
4998             matcher.locals[countIndex] = save;
4999             return ret;
5000         }
5001         boolean study(TreeInfo info) {
5002             info.maxValid = false;
5003             info.deterministic = false;
</pre>
<hr />
<pre>
5177             for (;;) {
5178                 if (i &gt; matcher.to) {
5179                     matcher.hitEnd = true;
5180                     return false;
5181                 }
5182                 if (atom.match(matcher, i, seq)) {
5183                     return next.match(matcher, matcher.last, seq);
5184                 }
5185                 i += countChars(seq, i, 1);
5186                 matcher.first++;
5187             }
5188         }
5189         boolean study(TreeInfo info) {
5190             atom.study(info);
5191             info.maxValid = false;
5192             info.deterministic = false;
5193             return next.study(info);
5194         }
5195     }
5196 



































5197     /**
5198      * Zero width positive lookahead.
5199      */
5200     static final class Pos extends Node {
5201         Node cond;
5202         Pos(Node cond) {
5203             this.cond = cond;
5204         }
5205         boolean match(Matcher matcher, int i, CharSequence seq) {
5206             int savedTo = matcher.to;
<span class="line-modified">5207             boolean conditionMatched;</span>
5208 
5209             // Relax transparent region boundaries for lookahead
5210             if (matcher.transparentBounds)
5211                 matcher.to = matcher.getTextLength();
5212             try {
5213                 conditionMatched = cond.match(matcher, i, seq);
5214             } finally {
5215                 // Reinstate region boundaries
5216                 matcher.to = savedTo;
5217             }
5218             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5219         }
5220     }
5221 
5222     /**
5223      * Zero width negative lookahead.
5224      */
5225     static final class Neg extends Node {
5226         Node cond;
5227         Neg(Node cond) {
5228             this.cond = cond;
5229         }
5230         boolean match(Matcher matcher, int i, CharSequence seq) {
5231             int savedTo = matcher.to;
<span class="line-modified">5232             boolean conditionMatched;</span>
5233 
5234             // Relax transparent region boundaries for lookahead
5235             if (matcher.transparentBounds)
5236                 matcher.to = matcher.getTextLength();
5237             try {
5238                 if (i &lt; matcher.to) {
5239                     conditionMatched = !cond.match(matcher, i, seq);
5240                 } else {
5241                     // If a negative lookahead succeeds then more input
5242                     // could cause it to fail!
5243                     matcher.requireEnd = true;
5244                     conditionMatched = !cond.match(matcher, i, seq);
5245                 }
5246             } finally {
5247                 // Reinstate region boundaries
5248                 matcher.to = savedTo;
5249             }
5250             return conditionMatched &amp;&amp; next.match(matcher, i, seq);
5251         }
5252     }
5253 
5254     /**
5255      * For use with lookbehinds; matches the position where the lookbehind
5256      * was encountered.
5257      */
<span class="line-modified">5258     static class LookBehindEndNode extends Node {</span>
<span class="line-added">5259         private LookBehindEndNode() {} // Singleton</span>
<span class="line-added">5260 </span>
<span class="line-added">5261         static LookBehindEndNode INSTANCE = new LookBehindEndNode();</span>
<span class="line-added">5262 </span>
5263         boolean match(Matcher matcher, int i, CharSequence seq) {
5264             return i == matcher.lookbehindTo;
5265         }
<span class="line-modified">5266     }</span>
5267 
5268     /**
5269      * Zero width positive lookbehind.
5270      */
5271     static class Behind extends Node {
5272         Node cond;
5273         int rmax, rmin;
5274         Behind(Node cond, int rmax, int rmin) {
5275             this.cond = cond;
5276             this.rmax = rmax;
5277             this.rmin = rmin;
5278         }
5279 
5280         boolean match(Matcher matcher, int i, CharSequence seq) {
5281             int savedFrom = matcher.from;
5282             boolean conditionMatched = false;
5283             int startIndex = (!matcher.transparentBounds) ?
5284                              matcher.from : 0;
5285             int from = Math.max(i - rmax, startIndex);
5286             // Set end boundary
</pre>
<hr />
<pre>
5514          * Pre calculates arrays needed to generate the bad character
5515          * shift and the good suffix shift. Only the last seven bits
5516          * are used to see if chars match; This keeps the tables small
5517          * and covers the heavily used ASCII range, but occasionally
5518          * results in an aliased match for the bad character shift.
5519          */
5520         static Node optimize(Node node) {
5521             if (!(node instanceof Slice)) {
5522                 return node;
5523             }
5524 
5525             int[] src = ((Slice) node).buffer;
5526             int patternLength = src.length;
5527             // The BM algorithm requires a bit of overhead;
5528             // If the pattern is short don&#39;t use it, since
5529             // a shift larger than the pattern length cannot
5530             // be used anyway.
5531             if (patternLength &lt; 4) {
5532                 return node;
5533             }
<span class="line-modified">5534             int i, j;</span>
5535             int[] lastOcc = new int[128];
5536             int[] optoSft = new int[patternLength];
5537             // Precalculate part of the bad character shift
5538             // It is a table for where in the pattern each
5539             // lower 7-bit value occurs
5540             for (i = 0; i &lt; patternLength; i++) {
5541                 lastOcc[src[i]&amp;0x7F] = i + 1;
5542             }
5543             // Precalculate the good suffix shift
5544             // i is the shift amount being considered
5545 NEXT:       for (i = patternLength; i &gt; 0; i--) {
5546                 // j is the beginning index of suffix being considered
5547                 for (j = patternLength - 1; j &gt;= i; j--) {
5548                     // Testing for good suffix
5549                     if (src[j] == src[j-i]) {
5550                         // src[j..len] is a good suffix
5551                         optoSft[j-1] = i;
5552                     } else {
5553                         // No match. The array has already been
5554                         // filled up with correct values before.
</pre>
<hr />
<pre>
5669         boolean is(int ch);
5670 
5671         default CharPredicate and(CharPredicate p) {
5672             return ch -&gt; is(ch) &amp;&amp; p.is(ch);
5673         }
5674         default CharPredicate union(CharPredicate p) {
5675             return ch -&gt; is(ch) || p.is(ch);
5676         }
5677         default CharPredicate union(CharPredicate p1,
5678                                     CharPredicate p2 ) {
5679             return ch -&gt; is(ch) || p1.is(ch) || p2.is(ch);
5680         }
5681         default CharPredicate negate() {
5682             return ch -&gt; !is(ch);
5683         }
5684     }
5685 
5686     static interface BmpCharPredicate extends CharPredicate {
5687 
5688         default CharPredicate and(CharPredicate p) {
<span class="line-modified">5689             if (p instanceof BmpCharPredicate)</span>
5690                 return (BmpCharPredicate)(ch -&gt; is(ch) &amp;&amp; p.is(ch));
5691             return ch -&gt; is(ch) &amp;&amp; p.is(ch);
5692         }
5693         default CharPredicate union(CharPredicate p) {
5694             if (p instanceof BmpCharPredicate)
5695                 return (BmpCharPredicate)(ch -&gt; is(ch) || p.is(ch));
5696             return ch -&gt; is(ch) || p.is(ch);
5697         }
5698         static CharPredicate union(CharPredicate... predicates) {
5699             CharPredicate cp = ch -&gt; {
5700                 for (CharPredicate p : predicates) {
5701                     if (!p.is(ch))
5702                         return false;
5703                 }
5704                 return true;
5705             };
5706             for (CharPredicate p : predicates) {
5707                 if (! (p instanceof BmpCharPredicate))
5708                     return cp;
5709             }
</pre>
</td>
</tr>
</table>
<center><a href="Matcher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PatternSyntaxException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
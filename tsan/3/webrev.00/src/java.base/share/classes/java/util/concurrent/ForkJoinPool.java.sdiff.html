<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ExecutorService.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ForkJoinTask.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 850                     p.signalWork(null);
 851                 }
 852             }
 853         }
 854 
 855         /**
 856          * Version of push for shared queues. Call only with phase lock held.
 857          * @return true if should signal work
 858          */
 859         final boolean lockedPush(ForkJoinTask&lt;?&gt; task) {
 860             ForkJoinTask&lt;?&gt;[] a;
 861             boolean signal = false;
 862             int s = top, d = s - base, cap, m;
 863             if ((a = array) != null &amp;&amp; (cap = a.length) &gt; 0) {
 864                 a[(m = (cap - 1)) &amp; s] = task;
 865                 top = s + 1;
 866                 if (d == m)
 867                     growArray(true);
 868                 else {
 869                     phase = 0; // full volatile unlock
<span class="line-modified"> 870                     if (a[m &amp; (s - 1)] == null)</span>
<span class="line-modified"> 871                         signal = true;   // was empty</span>
 872                 }
 873             }
 874             return signal;
 875         }
 876 
 877         /**
 878          * Doubles the capacity of array. Call either by owner or with
 879          * lock held -- it is OK for base, but not top, to move while
 880          * resizings are in progress.
 881          */
 882         final void growArray(boolean locked) {
 883             ForkJoinTask&lt;?&gt;[] newA = null;
 884             try {
 885                 ForkJoinTask&lt;?&gt;[] oldA; int oldSize, newSize;
 886                 if ((oldA = array) != null &amp;&amp; (oldSize = oldA.length) &gt; 0 &amp;&amp;
 887                     (newSize = oldSize &lt;&lt; 1) &lt;= MAXIMUM_QUEUE_CAPACITY &amp;&amp;
 888                     newSize &gt; 0) {
 889                     try {
 890                         newA = new ForkJoinTask&lt;?&gt;[newSize];
 891                     } catch (OutOfMemoryError ex) {
</pre>
<hr />
<pre>
2650             else if (rc &gt; 0)
2651                 return false;
2652             else {
2653                 WorkQueue[] ws; WorkQueue v;
2654                 if ((ws = workQueues) != null) {
2655                     for (int i = 1; i &lt; ws.length; i += 2) {
2656                         if ((v = ws[i]) != null) {
2657                             if (v.source &gt; 0)
2658                                 return false;
2659                             --tc;
2660                         }
2661                     }
2662                 }
2663                 if (tc == 0 &amp;&amp; ctl == c)
2664                     return true;
2665             }
2666         }
2667     }
2668 
2669     /**
<span class="line-modified">2670      * Returns an estimate of the total number of tasks stolen from</span>
<span class="line-modified">2671      * one thread&#39;s work queue by another. The reported value</span>
<span class="line-modified">2672      * underestimates the actual total number of steals when the pool</span>
<span class="line-modified">2673      * is not quiescent. This value may be useful for monitoring and</span>
<span class="line-modified">2674      * tuning fork/join programs: in general, steal counts should be</span>
<span class="line-modified">2675      * high enough to keep threads busy, but low enough to avoid</span>
<span class="line-modified">2676      * overhead and contention across threads.</span>
2677      *
2678      * @return the number of steals
2679      */
2680     public long getStealCount() {
2681         long count = stealCount;
2682         WorkQueue[] ws; WorkQueue w;
2683         if ((ws = workQueues) != null) {
2684             for (int i = 1; i &lt; ws.length; i += 2) {
2685                 if ((w = ws[i]) != null)
2686                     count += (long)w.nsteals &amp; 0xffffffffL;
2687             }
2688         }
2689         return count;
2690     }
2691 
2692     /**
2693      * Returns an estimate of the total number of tasks currently held
2694      * in queues by worker threads (but not including tasks submitted
2695      * to the pool that have not begun executing). This value is only
2696      * an approximation, obtained by iterating across all threads in
</pre>
</td>
<td>
<hr />
<pre>
 850                     p.signalWork(null);
 851                 }
 852             }
 853         }
 854 
 855         /**
 856          * Version of push for shared queues. Call only with phase lock held.
 857          * @return true if should signal work
 858          */
 859         final boolean lockedPush(ForkJoinTask&lt;?&gt; task) {
 860             ForkJoinTask&lt;?&gt;[] a;
 861             boolean signal = false;
 862             int s = top, d = s - base, cap, m;
 863             if ((a = array) != null &amp;&amp; (cap = a.length) &gt; 0) {
 864                 a[(m = (cap - 1)) &amp; s] = task;
 865                 top = s + 1;
 866                 if (d == m)
 867                     growArray(true);
 868                 else {
 869                     phase = 0; // full volatile unlock
<span class="line-modified"> 870                     if (((s - base) &amp; ~1) == 0) // size 0 or 1</span>
<span class="line-modified"> 871                         signal = true;</span>
 872                 }
 873             }
 874             return signal;
 875         }
 876 
 877         /**
 878          * Doubles the capacity of array. Call either by owner or with
 879          * lock held -- it is OK for base, but not top, to move while
 880          * resizings are in progress.
 881          */
 882         final void growArray(boolean locked) {
 883             ForkJoinTask&lt;?&gt;[] newA = null;
 884             try {
 885                 ForkJoinTask&lt;?&gt;[] oldA; int oldSize, newSize;
 886                 if ((oldA = array) != null &amp;&amp; (oldSize = oldA.length) &gt; 0 &amp;&amp;
 887                     (newSize = oldSize &lt;&lt; 1) &lt;= MAXIMUM_QUEUE_CAPACITY &amp;&amp;
 888                     newSize &gt; 0) {
 889                     try {
 890                         newA = new ForkJoinTask&lt;?&gt;[newSize];
 891                     } catch (OutOfMemoryError ex) {
</pre>
<hr />
<pre>
2650             else if (rc &gt; 0)
2651                 return false;
2652             else {
2653                 WorkQueue[] ws; WorkQueue v;
2654                 if ((ws = workQueues) != null) {
2655                     for (int i = 1; i &lt; ws.length; i += 2) {
2656                         if ((v = ws[i]) != null) {
2657                             if (v.source &gt; 0)
2658                                 return false;
2659                             --tc;
2660                         }
2661                     }
2662                 }
2663                 if (tc == 0 &amp;&amp; ctl == c)
2664                     return true;
2665             }
2666         }
2667     }
2668 
2669     /**
<span class="line-modified">2670      * Returns an estimate of the total number of completed tasks that</span>
<span class="line-modified">2671      * were executed by a thread other than their submitter. The</span>
<span class="line-modified">2672      * reported value underestimates the actual total number of steals</span>
<span class="line-modified">2673      * when the pool is not quiescent. This value may be useful for</span>
<span class="line-modified">2674      * monitoring and tuning fork/join programs: in general, steal</span>
<span class="line-modified">2675      * counts should be high enough to keep threads busy, but low</span>
<span class="line-modified">2676      * enough to avoid overhead and contention across threads.</span>
2677      *
2678      * @return the number of steals
2679      */
2680     public long getStealCount() {
2681         long count = stealCount;
2682         WorkQueue[] ws; WorkQueue w;
2683         if ((ws = workQueues) != null) {
2684             for (int i = 1; i &lt; ws.length; i += 2) {
2685                 if ((w = ws[i]) != null)
2686                     count += (long)w.nsteals &amp; 0xffffffffL;
2687             }
2688         }
2689         return count;
2690     }
2691 
2692     /**
2693      * Returns an estimate of the total number of tasks currently held
2694      * in queues by worker threads (but not including tasks submitted
2695      * to the pool that have not begun executing). This value is only
2696      * an approximation, obtained by iterating across all threads in
</pre>
</td>
</tr>
</table>
<center><a href="ExecutorService.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ForkJoinTask.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
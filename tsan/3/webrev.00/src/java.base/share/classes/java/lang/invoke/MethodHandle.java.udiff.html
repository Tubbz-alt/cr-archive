<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/MethodHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemberName.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleImpl.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -50,11 +50,11 @@</span>
   * {@linkplain #asType conversion},
   * {@linkplain #bindTo insertion},
   * {@linkplain java.lang.invoke.MethodHandles#dropArguments deletion},
   * and {@linkplain java.lang.invoke.MethodHandles#filterArguments substitution}.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Method handle contents&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Method handle contents&lt;/h2&gt;</span>
   * Method handles are dynamically and strongly typed according to their parameter and return types.
   * They are not distinguished by the name or the defining class of their underlying methods.
   * A method handle must be invoked using a symbolic type descriptor which matches
   * the method handle&#39;s own {@linkplain #type() type descriptor}.
   * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -87,11 +87,11 @@</span>
   * which may be visible via the {@link java.lang.Object#getClass Object.getClass}
   * operation.  The programmer should not draw conclusions about a method handle
   * from its specific class, as the method handle class hierarchy (if any)
   * may change from time to time or across implementations from different vendors.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Method handle compilation&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Method handle compilation&lt;/h2&gt;</span>
   * A Java method call expression naming {@code invokeExact} or {@code invoke}
   * can invoke a method handle from Java source code.
   * From the viewpoint of source code, these methods can take any arguments
   * and their result can be cast to any return type.
   * Formally this is accomplished by giving the invoker methods
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -119,11 +119,11 @@</span>
   * As a corner case, an uncasted {@code null} argument is given
   * a symbolic type descriptor of {@code java.lang.Void}.
   * The ambiguity with the type {@code Void} is harmless, since there are no references of type
   * {@code Void} except the null reference.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Method handle invocation&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Method handle invocation&lt;/h2&gt;</span>
   * The first time an {@code invokevirtual} instruction is executed
   * it is linked by symbolically resolving the names in the instruction
   * and verifying that the method call is statically legal.
   * This also holds for calls to {@code invokeExact} and {@code invoke}.
   * In this case, the symbolic type descriptor emitted by the compiler is checked for
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162,11 +162,11 @@</span>
   * between caller and callee.
   * &lt;p&gt;
   * (&lt;em&gt;Note:&lt;/em&gt; The adjusted method handle {@code M2} is not directly observable,
   * and implementations are therefore not required to materialize it.)
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Invocation checking&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Invocation checking&lt;/h2&gt;</span>
   * In typical programs, method handle type matching will usually succeed.
   * But if a match fails, the JVM will throw a {@link WrongMethodTypeException},
   * either directly (in the case of {@code invokeExact}) or indirectly as if
   * by a failed call to {@code asType} (in the case of {@code invoke}).
   * &lt;p&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -203,11 +203,11 @@</span>
   * Thus, handles to non-public methods, or to methods in non-public classes,
   * should generally be kept secret.
   * They should not be passed to untrusted code unless their use from
   * the untrusted code would be harmless.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Method handle creation&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Method handle creation&lt;/h2&gt;</span>
   * Java code can create a method handle that directly accesses
   * any method, constructor, or field that is accessible to that code.
   * This is done via a reflective, capability-based API called
   * {@link java.lang.invoke.MethodHandles.Lookup MethodHandles.Lookup}.
   * For example, a static method handle can be obtained
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -220,12 +220,13 @@</span>
   * in a class file&#39;s constant pool as constants to be loaded by {@code ldc} bytecodes.
   * A new type of constant pool entry, {@code CONSTANT_MethodHandle},
   * refers directly to an associated {@code CONSTANT_Methodref},
   * {@code CONSTANT_InterfaceMethodref}, or {@code CONSTANT_Fieldref}
   * constant pool entry.
<span class="udiff-line-modified-removed">-  * (For full details on method handle constants,</span>
<span class="udiff-line-modified-removed">-  * see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)</span>
<span class="udiff-line-modified-added">+  * (For full details on method handle constants, see sections {@jvms</span>
<span class="udiff-line-modified-added">+  * 4.4.8} and {@jvms 5.4.3.5} of the Java Virtual Machine</span>
<span class="udiff-line-added">+  * Specification.)</span>
   * &lt;p&gt;
   * Method handles produced by lookups or constant loads from methods or
   * constructors with the variable arity modifier bit ({@code 0x0080})
   * have a corresponding variable arity, as if they were defined with
   * the help of {@link #asVarargsCollector asVarargsCollector}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -261,11 +262,11 @@</span>
   * an {@code invokespecial} instruction to the same method.
   * A non-virtual method handle can also be created to simulate the effect
   * of an {@code invokevirtual} or {@code invokeinterface} instruction on
   * a private method (as applicable).
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Usage examples&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Usage examples&lt;/h2&gt;</span>
   * Here are some examples of usage:
   * &lt;blockquote&gt;&lt;pre&gt;{@code
  Object x, y; String s; int i;
  MethodType mt; MethodHandle mh;
  MethodHandles.Lookup lookup = MethodHandles.lookup();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -307,11 +308,11 @@</span>
   * the symbolic type descriptor indicated in the following comment.
   * In these examples, the helper method {@code assertEquals} is assumed to
   * be a method which calls {@link java.util.Objects#equals(Object,Object) Objects.equals}
   * on its arguments, and asserts that the result is true.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Exceptions&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Exceptions&lt;/h2&gt;</span>
   * The methods {@code invokeExact} and {@code invoke} are declared
   * to throw {@link java.lang.Throwable Throwable},
   * which is to say that there is no static restriction on what a method handle
   * can throw.  Since the JVM does not distinguish between checked
   * and unchecked exceptions (other than by their class, of course),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -320,11 +321,11 @@</span>
   * code, methods which perform method handle calls must either explicitly
   * throw {@code Throwable}, or else must catch all
   * throwables locally, rethrowing only those which are legal in the context,
   * and wrapping ones which are illegal.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;&lt;a id=&quot;sigpoly&quot;&gt;&lt;/a&gt;Signature polymorphism&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;&lt;a id=&quot;sigpoly&quot;&gt;&lt;/a&gt;Signature polymorphism&lt;/h2&gt;</span>
   * The unusual compilation and linkage behavior of
   * {@code invokeExact} and plain {@code invoke}
   * is referenced by the term &lt;em&gt;signature polymorphism&lt;/em&gt;.
   * As defined in the Java Language Specification,
   * a signature polymorphic method is one which can operate with
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -345,11 +346,11 @@</span>
   * Bytecode generators, including the compiler back end, are required to emit
   * untransformed symbolic type descriptors for these methods.
   * Tools which determine symbolic linkage are required to accept such
   * untransformed descriptors, without reporting linkage errors.
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Interoperation between method handles and the Core Reflection API&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Interoperation between method handles and the Core Reflection API&lt;/h2&gt;</span>
   * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup Lookup} API,
   * any class member represented by a Core Reflection API object
   * can be converted to a behaviorally equivalent method handle.
   * For example, a reflective {@link java.lang.reflect.Method Method} can
   * be converted to a method handle using
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -387,11 +388,11 @@</span>
   * The {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
   * API is also able to return a method handle
   * to call {@code invokeExact} or plain {@code invoke},
   * for any specified type descriptor .
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;Interoperation between method handles and Java generics&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;Interoperation between method handles and Java generics&lt;/h2&gt;</span>
   * A method handle can be obtained on a method, constructor, or field
   * which is declared with Java generic types.
   * As with the Core Reflection API, the type of the method handle
   * will be constructed from the erasure of the source-level type.
   * When a method handle is invoked, the types of its arguments
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -414,11 +415,11 @@</span>
   * often generic across a wide range of function types, including
   * those of multiple arities.  It is impossible to represent such
   * genericity with a Java type parameter.&lt;/li&gt;
   * &lt;/ul&gt;
   *
<span class="udiff-line-modified-removed">-  * &lt;h1&gt;&lt;a id=&quot;maxarity&quot;&gt;&lt;/a&gt;Arity limits&lt;/h1&gt;</span>
<span class="udiff-line-modified-added">+  * &lt;h2&gt;&lt;a id=&quot;maxarity&quot;&gt;&lt;/a&gt;Arity limits&lt;/h2&gt;</span>
   * The JVM imposes on all methods and constructors of any kind an absolute
   * limit of 255 stacked arguments.  This limit can appear more restrictive
   * in certain cases:
   * &lt;ul&gt;
   * &lt;li&gt;A {@code long} or {@code double} argument counts (for purposes of arity limits) as two argument slots.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -446,15 +447,18 @@</span>
      @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
      @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
      @interface PolymorphicSignature { }
  
      private final MethodType type;
<span class="udiff-line-modified-removed">-     /*private*/ final LambdaForm form;</span>
<span class="udiff-line-modified-added">+     /*private*/</span>
<span class="udiff-line-added">+     final LambdaForm form;</span>
      // form is not private so that invokers can easily fetch it
<span class="udiff-line-modified-removed">-     /*private*/ MethodHandle asTypeCache;</span>
<span class="udiff-line-modified-added">+     /*private*/</span>
<span class="udiff-line-added">+     MethodHandle asTypeCache;</span>
      // asTypeCache is not private so that invokers can easily fetch it
<span class="udiff-line-modified-removed">-     /*non-public*/ byte customizationCount;</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     byte customizationCount;</span>
      // customizationCount should be accessible from invokers
  
      /**
       * Reports the type of this method handle.
       * Every invocation of this method handle via {@code invokeExact} must exactly match this type.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -468,11 +472,12 @@</span>
       * Package-private constructor for the method handle implementation hierarchy.
       * Method handle inheritance will be contained completely within
       * the {@code java.lang.invoke} package.
       */
      // @param type type (permanently assigned) of the new method handle
<span class="udiff-line-modified-removed">-     /*non-public*/ MethodHandle(MethodType type, LambdaForm form) {</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     MethodHandle(MethodType type, LambdaForm form) {</span>
          this.type = Objects.requireNonNull(type);
          this.form = Objects.requireNonNull(form).uncustomize();
  
          this.form.prepare();  // TO DO:  Try to delay this step until just before invocation.
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -551,51 +556,56 @@</span>
       * of the callee&#39;s return type.
       * @param args the signature-polymorphic parameter list, statically represented using varargs
       * @return the signature-polymorphic result, statically represented using {@code Object}
       */
      @HotSpotIntrinsicCandidate
<span class="udiff-line-modified-removed">-     /*non-public*/ final native @PolymorphicSignature Object invokeBasic(Object... args) throws Throwable;</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     final native @PolymorphicSignature Object invokeBasic(Object... args) throws Throwable;</span>
  
      /**
       * Private method for trusted invocation of a MemberName of kind {@code REF_invokeVirtual}.
       * The caller signature is restricted to basic types as with {@code invokeBasic}.
       * The trailing (not leading) argument must be a MemberName.
       * @param args the signature-polymorphic parameter list, statically represented using varargs
       * @return the signature-polymorphic result, statically represented using {@code Object}
       */
      @HotSpotIntrinsicCandidate
<span class="udiff-line-modified-removed">-     /*non-public*/ static native @PolymorphicSignature Object linkToVirtual(Object... args) throws Throwable;</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     static native @PolymorphicSignature Object linkToVirtual(Object... args) throws Throwable;</span>
  
      /**
       * Private method for trusted invocation of a MemberName of kind {@code REF_invokeStatic}.
       * The caller signature is restricted to basic types as with {@code invokeBasic}.
       * The trailing (not leading) argument must be a MemberName.
       * @param args the signature-polymorphic parameter list, statically represented using varargs
       * @return the signature-polymorphic result, statically represented using {@code Object}
       */
      @HotSpotIntrinsicCandidate
<span class="udiff-line-modified-removed">-     /*non-public*/ static native @PolymorphicSignature Object linkToStatic(Object... args) throws Throwable;</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     static native @PolymorphicSignature Object linkToStatic(Object... args) throws Throwable;</span>
  
      /**
       * Private method for trusted invocation of a MemberName of kind {@code REF_invokeSpecial}.
       * The caller signature is restricted to basic types as with {@code invokeBasic}.
       * The trailing (not leading) argument must be a MemberName.
       * @param args the signature-polymorphic parameter list, statically represented using varargs
       * @return the signature-polymorphic result, statically represented using {@code Object}
       */
      @HotSpotIntrinsicCandidate
<span class="udiff-line-modified-removed">-     /*non-public*/ static native @PolymorphicSignature Object linkToSpecial(Object... args) throws Throwable;</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     static native @PolymorphicSignature Object linkToSpecial(Object... args) throws Throwable;</span>
  
      /**
       * Private method for trusted invocation of a MemberName of kind {@code REF_invokeInterface}.
       * The caller signature is restricted to basic types as with {@code invokeBasic}.
       * The trailing (not leading) argument must be a MemberName.
       * @param args the signature-polymorphic parameter list, statically represented using varargs
       * @return the signature-polymorphic result, statically represented using {@code Object}
       */
      @HotSpotIntrinsicCandidate
<span class="udiff-line-modified-removed">-     /*non-public*/ static native @PolymorphicSignature Object linkToInterface(Object... args) throws Throwable;</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     static native @PolymorphicSignature Object linkToInterface(Object... args) throws Throwable;</span>
  
      /**
       * Performs a variable arity invocation, passing the arguments in the given array
       * to the method handle, as if via an inexact {@link #invoke invoke} from a call site
       * which mentions only the type {@code Object}, and whose actual argument count is the length
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -863,11 +873,12 @@</span>
          }
          return null;
      }
  
      /** Override this to change asType behavior. */
<span class="udiff-line-modified-removed">-     /*non-public*/ MethodHandle asTypeUncached(MethodType newType) {</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     MethodHandle asTypeUncached(MethodType newType) {</span>
          if (!type.isConvertibleTo(newType))
              throw new WrongMethodTypeException(&quot;cannot convert &quot;+this+&quot; to &quot;+newType);
          return asTypeCache = MethodHandleImpl.makePairwiseConvert(this, newType, true);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1240,11 +1251,12 @@</span>
  
      /**
       * See if {@code asCollector} can be validly called with the given arguments.
       * Return false if the last parameter is not an exact match to arrayType.
       */
<span class="udiff-line-modified-removed">-     /*non-public*/ boolean asCollectorChecks(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>
<span class="udiff-line-modified-added">+     /*non-public*/</span>
<span class="udiff-line-added">+     boolean asCollectorChecks(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</span>
          spreadArrayChecks(arrayType, arrayLength);
          int nargs = type().parameterCount();
          if (pos &lt; 0 || pos &gt;= nargs) {
              throw newIllegalArgumentException(&quot;bad collect position&quot;);
          }
</pre>
<center><a href="MemberName.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleImpl.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
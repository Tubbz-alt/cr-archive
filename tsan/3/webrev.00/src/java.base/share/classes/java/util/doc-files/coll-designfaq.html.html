<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/doc-files/coll-designfaq.html</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 &lt;!DOCTYPE html&gt;
  2 &lt;!--
  3  Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  4  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5 
  6  This code is free software; you can redistribute it and/or modify it
  7  under the terms of the GNU General Public License version 2 only, as
  8  published by the Free Software Foundation.  Oracle designates this
  9  particular file as subject to the &quot;Classpath&quot; exception as provided
 10  by Oracle in the LICENSE file that accompanied this code.
 11 
 12  This code is distributed in the hope that it will be useful, but WITHOUT
 13  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 14  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 15  version 2 for more details (a copy is included in the LICENSE file that
 16  accompanied this code).
 17 
 18  You should have received a copy of the GNU General Public License version
 19  2 along with this work; if not, write to the Free Software Foundation,
 20  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 21 
 22  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 23  or visit www.oracle.com if you need additional information or have any
 24  questions.
 25 --&gt;
 26 &lt;html lang=&quot;en-US&quot;&gt;
 27 &lt;head&gt;
 28 &lt;title&gt;Java Collections API Design FAQ&lt;/title&gt;
 29 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
 30 &lt;/head&gt;
 31 &lt;body&gt;
 32 &lt;h1&gt;Java Collections API Design FAQ&lt;/h1&gt;
 33 &lt;!-- Body text begins here --&gt;
 34 &lt;hr&gt;
 35 This document answers frequently asked questions concerning the
 36 design of the Java collections framework. It is derived from the
 37 large volume of traffic on the collections-comments alias. It
 38 serves as a design rationale for the collections framework.
 39 &lt;h2&gt;Core Interfaces - General Questions&lt;/h2&gt;
 40 &lt;ol&gt;
 41 &lt;li&gt;&lt;a href=&quot;#a1&quot;&gt;&lt;b&gt;Why don&#39;t you support immutability directly in
 42 the core collection interfaces so that you can do away with
 43 &lt;em&gt;optional operations&lt;/em&gt; (and
 44 UnsupportedOperationException)?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 45 &lt;li&gt;&lt;a href=&quot;#a2&quot;&gt;&lt;b&gt;Won&#39;t programmers have to surround any code
 46 that calls optional operations with a try-catch clause in case they
 47 throw an UnsupportedOperationException?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 48 &lt;li&gt;&lt;a href=&quot;#a3&quot;&gt;&lt;b&gt;Why isn&#39;t there a core interface for &quot;bags&quot;
 49 (AKA multisets)?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 50 &lt;li&gt;&lt;a href=&quot;#a28&quot;&gt;&lt;b&gt;Why didn&#39;t you use &quot;Beans-style names&quot; for
 51 consistency?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 52 &lt;/ol&gt;
 53 &lt;h2&gt;Collection Interface&lt;/h2&gt;
 54 &lt;ol&gt;
 55 &lt;li&gt;&lt;a href=&quot;#a5&quot;&gt;&lt;b&gt;Why doesn&#39;t Collection extend Cloneable and
 56 Serializable?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 57 &lt;li&gt;&lt;a href=&quot;#a6&quot;&gt;&lt;b&gt;Why don&#39;t you provide an &quot;apply&quot; method in
 58 Collection to apply a given method (&quot;upcall&quot;) to all the elements
 59 of the Collection?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 60 &lt;li&gt;&lt;a href=&quot;#a7&quot;&gt;&lt;b&gt;Why didn&#39;t you provide a &quot;Predicate&quot; interface,
 61 and related methods (e.g., a method to find the first element in
 62 the Collection satisfying the predicate)?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 63 &lt;li&gt;&lt;a href=&quot;#a8&quot;&gt;&lt;b&gt;Why don&#39;t you provide a form of the addAll
 64 method that takes an Enumeration (or an Iterator)?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 65 &lt;li&gt;&lt;a href=&quot;#a9&quot;&gt;&lt;b&gt;Why don&#39;t the concrete implementations in the
 66 JDK have Enumeration (or Iterator) constructors?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 67 &lt;li&gt;&lt;a href=&quot;#a10&quot;&gt;&lt;b&gt;Why don&#39;t you provide an Iterator.add
 68 method?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 69 &lt;/ol&gt;
 70 &lt;h2&gt;List Interface&lt;/h2&gt;
 71 &lt;ol&gt;
 72 &lt;li&gt;&lt;a href=&quot;#a11&quot;&gt;&lt;b&gt;Why don&#39;t you rename the List interface to
 73 Sequence; doesn&#39;t &quot;list&quot; generally suggest &quot;linked list&quot;? Also,
 74 doesn&#39;t it conflict with java.awt.List?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 75 &lt;li&gt;&lt;a href=&quot;#a12&quot;&gt;&lt;b&gt;Why don&#39;t you rename List&#39;s set method to
 76 replace, to avoid confusion with Set.&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 77 &lt;/ol&gt;
 78 &lt;h2&gt;Map Interface&lt;/h2&gt;
 79 &lt;ol&gt;
 80 &lt;li&gt;&lt;a href=&quot;#a14&quot;&gt;&lt;b&gt;Why doesn&#39;t Map extend
 81 Collection?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 82 &lt;/ol&gt;
 83 &lt;h2&gt;Iterator Interface&lt;/h2&gt;
 84 &lt;ol&gt;
 85 &lt;li&gt;&lt;a href=&quot;#a18&quot;&gt;&lt;b&gt;Why doesn&#39;t Iterator extend
 86 Enumeration?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 87 &lt;li&gt;&lt;a href=&quot;#a19&quot;&gt;&lt;b&gt;Why don&#39;t you provide an Iterator.peek method
 88 that allows you to look at the next element in an iteration without
 89 advancing the iterator?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 90 &lt;/ol&gt;
 91 &lt;h2&gt;Miscellaneous&lt;/h2&gt;
 92 &lt;ol&gt;
 93 &lt;li&gt;&lt;a href=&quot;#a23&quot;&gt;&lt;b&gt;Why did you write a new collections framework
 94 instead of adopting JGL (a preexisting collections package from
 95 ObjectSpace, Inc.) into the JDK?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
 96 &lt;li&gt;&lt;a href=&quot;#a26&quot;&gt;&lt;b&gt;Why don&#39;t you eliminate all of the methods and
 97 classes that return &quot;views&quot; (Collections backed by other
 98 collection-like objects). This would greatly reduce
 99 aliasing.&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
100 &lt;li&gt;&lt;a href=&quot;#a27&quot;&gt;&lt;b&gt;Why don&#39;t you provide for &quot;observable&quot;
101 collections that send out Events when they&#39;re
102 modified?&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
103 &lt;/ol&gt;
104 &lt;hr&gt;
105 &lt;h2&gt;Core Interfaces - General Questions&lt;/h2&gt;
106 &lt;ol&gt;
107 &lt;li&gt;&lt;a id=&quot;a1&quot;&gt;&lt;b&gt;Why don&#39;t you support immutability
108 directly in the core collection interfaces so that you can do away
109 with &lt;em&gt;optional operations&lt;/em&gt; (and
110 UnsupportedOperationException)?&lt;/b&gt;&lt;/a&gt;
111 &lt;p&gt;This is the most controversial design decision in the whole API.
112 Clearly, static (compile time) type checking is highly desirable,
113 and is the norm in Java. We would have supported it if we believed
114 it were feasible. Unfortunately, attempts to achieve this goal
115 cause an explosion in the size of the interface hierarchy, and do
116 not succeed in eliminating the need for runtime exceptions (though
117 they reduce it substantially).&lt;/p&gt;
118 &lt;p&gt;Doug Lea, who wrote a popular Java collections package that did
119 reflect mutability distinctions in its interface hierarchy, no
120 longer believes it is a viable approach, based on user experience
121 with his collections package. In his words (from personal
122 correspondence) &quot;Much as it pains me to say it, strong static
123 typing does not work for collection interfaces in Java.&quot;&lt;/p&gt;
124 &lt;p&gt;To illustrate the problem in gory detail, suppose you want to
125 add the notion of modifiability to the Hierarchy. You need four new
126 interfaces: ModifiableCollection, ModifiableSet, ModifiableList,
127 and ModifiableMap. What was previously a simple hierarchy is now a
128 messy heterarchy. Also, you need a new Iterator interface for use
129 with unmodifiable Collections, that does not contain the remove
130 operation. Now can you do away with UnsupportedOperationException?
131 Unfortunately not.&lt;/p&gt;
132 &lt;p&gt;Consider arrays. They implement most of the List operations, but
133 not remove and add. They are &quot;fixed-size&quot; Lists. If you want to
134 capture this notion in the hierarchy, you have to add two new
135 interfaces: VariableSizeList and VariableSizeMap. You don&#39;t have to
136 add VariableSizeCollection and VariableSizeSet, because they&#39;d be
137 identical to ModifiableCollection and ModifiableSet, but you might
138 choose to add them anyway for consistency&#39;s sake. Also, you need a
139 new variety of ListIterator that doesn&#39;t support the add and remove
140 operations, to go along with unmodifiable List. Now we&#39;re up to ten
141 or twelve interfaces, plus two new Iterator interfaces, instead of
142 our original four. Are we done? No.&lt;/p&gt;
143 &lt;p&gt;Consider logs (such as error logs, audit logs and journals for
144 recoverable data objects). They are natural append-only sequences,
145 that support all of the List operations except for remove and set
146 (replace). They require a new core interface, and a new
147 iterator.&lt;/p&gt;
148 &lt;p&gt;And what about immutable Collections, as opposed to unmodifiable
149 ones? (i.e., Collections that cannot be changed by the client AND
150 will never change for any other reason). Many argue that this is
151 the most important distinction of all, because it allows multiple
152 threads to access a collection concurrently without the need for
153 synchronization. Adding this support to the type hierarchy requires
154 four more interfaces.&lt;/p&gt;
155 &lt;p&gt;Now we&#39;re up to twenty or so interfaces and five iterators, and
156 it&#39;s almost certain that there are still collections arising in
157 practice that don&#39;t fit cleanly into any of the interfaces. For
158 example, the &lt;em&gt;collection-views&lt;/em&gt; returned by Map are natural
159 delete-only collections. Also, there are collections that will
160 reject certain elements on the basis of their value, so we still
161 haven&#39;t done away with runtime exceptions.&lt;/p&gt;
162 &lt;p&gt;When all was said and done, we felt that it was a sound
163 engineering compromise to sidestep the whole issue by providing a
164 very small set of core interfaces that can throw a runtime
165 exception.&lt;/p&gt;
166 &lt;/li&gt;
167 &lt;li&gt;&lt;a id=&quot;a2&quot;&gt;&lt;b&gt;Won&#39;t programmers have to surround any
168 code that calls optional operations with a try-catch clause in case
169 they throw an UnsupportedOperationException?&lt;/b&gt;&lt;/a&gt;
170 &lt;p&gt;It was never our intention that programs should catch these
171 exceptions: that&#39;s why they&#39;re unchecked (runtime) exceptions. They
172 should only arise as a result of programming errors, in which case,
173 your program will halt due to the uncaught exception.&lt;/p&gt;
174 &lt;/li&gt;
175 &lt;li&gt;&lt;a id=&quot;a3&quot;&gt;&lt;b&gt;Why isn&#39;t there a core interface for
176 &quot;bags&quot; (AKA multisets)?&lt;/b&gt;&lt;/a&gt;
177 &lt;p&gt;The Collection interface provides this functionality. We are not
178 providing any public implementations of this interface, as we think
179 that it wouldn&#39;t be used frequently enough to &quot;pull its weight.&quot; We
180 occasionally return such Collections, which are implemented easily
181 atop AbstractCollection (for example, the Collection returned by
182 Map.values).&lt;/p&gt;
183 &lt;/li&gt;
184 &lt;li&gt;&lt;a id=&quot;a28&quot;&gt;&lt;b&gt;Why didn&#39;t you use &quot;Beans-style
185 names&quot; for consistency?&lt;/b&gt;&lt;/a&gt;
186 &lt;p&gt;While the names of the new collections methods do not adhere to
187 the &quot;Beans naming conventions&quot;, we believe that they are
188 reasonable, consistent and appropriate to their purpose. It should
189 be remembered that the Beans naming conventions do not apply to the
190 JDK as a whole; the AWT did adopt these conventions, but that
191 decision was somewhat controversial. We suspect that the
192 collections APIs will be used quite pervasively, often with
193 multiple method calls on a single line of code, so it is important
194 that the names be short. Consider, for example, the Iterator
195 methods. Currently, a loop over a collection looks like this:&lt;/p&gt;
196 &lt;pre&gt;
197     for (Iterator i = c.iterator(); i.hasNext(); )
198         System.out.println(i.next());
199 &lt;/pre&gt;
200 Everything fits neatly on one line, even if the Collection name is
201 a long expression. If we named the methods &quot;getIterator&quot;,
202 &quot;hasNextElement&quot; and &quot;getNextElement&quot;, this would no longer be the
203 case. Thus, we adopted the &quot;traditional&quot; JDK style rather than the
204 Beans style.&lt;/li&gt;
205 &lt;/ol&gt;
206 &lt;hr&gt;
207 &lt;h2&gt;Collection Interface&lt;/h2&gt;
208 &lt;ol&gt;
209 &lt;li&gt;&lt;a id=&quot;a5&quot;&gt;&lt;b&gt;Why doesn&#39;t Collection extend Cloneable
210 and Serializable?&lt;/b&gt;&lt;/a&gt;
211 &lt;p&gt;Many Collection implementations (including all of the ones
212 provided by the JDK) will have a public clone method, but it would
213 be mistake to require it of all Collections. For example, what does
214 it mean to clone a Collection that&#39;s backed by a terabyte SQL
215 database? Should the method call cause the company to requisition a
216 new disk farm? Similar arguments hold for serializable.&lt;/p&gt;
217 &lt;p&gt;If the client doesn&#39;t know the actual type of a Collection, it&#39;s
218 much more flexible and less error prone to have the client decide
219 what type of Collection is desired, create an empty Collection of
220 this type, and use the addAll method to copy the elements of the
221 original collection into the new one.&lt;/p&gt;
222 &lt;/li&gt;
223 &lt;li&gt;&lt;a id=&quot;a6&quot;&gt;&lt;b&gt;Why don&#39;t you provide an &quot;apply&quot; method
224 in Collection to apply a given method (&quot;upcall&quot;) to all the
225 elements of the Collection?&lt;/b&gt;&lt;/a&gt;
226 &lt;p&gt;This is what is referred to as an &quot;Internal Iterator&quot; in the
227 &quot;Design Patterns&quot; book (Gamma et al.). We considered providing it,
228 but decided not to as it seems somewhat redundant to support
229 internal and external iterators, and Java already has a precedent
230 for external iterators (with Enumerations). The &quot;throw weight&quot; of
231 this functionality is increased by the fact that it requires a
232 public interface to describe upcalls.&lt;/p&gt;
233 &lt;/li&gt;
234 &lt;li&gt;&lt;a id=&quot;a7&quot;&gt;&lt;b&gt;Why didn&#39;t you provide a &quot;Predicate&quot;
235 interface, and related methods (e.g., a method to find the first
236 element in the Collection satisfying the predicate)?&lt;/b&gt;&lt;/a&gt;
237 &lt;p&gt;It&#39;s easy to implement this functionality atop Iterators, and
238 the resulting code may actually look cleaner as the user can inline
239 the predicate. Thus, it&#39;s not clear whether this facility pulls its
240 weight. It could be added to the Collections class at a later date
241 (implemented atop Iterator), if it&#39;s deemed useful.&lt;/p&gt;
242 &lt;/li&gt;
243 &lt;li&gt;&lt;a id=&quot;a8&quot;&gt;&lt;b&gt;Why don&#39;t you provide a form of the
244 addAll method that takes an Enumeration (or an Iterator)?&lt;/b&gt;&lt;/a&gt;
245 &lt;p&gt;Because we don&#39;t believe in using Enumerations (or Iterators) as
246 &quot;poor man&#39;s collections.&quot; This was occasionally done in prior
247 releases, but now that we have the Collection interface, it is the
248 preferred way to pass around abstract collections of objects.&lt;/p&gt;
249 &lt;/li&gt;
250 &lt;li&gt;&lt;a id=&quot;a9&quot;&gt;&lt;b&gt;Why don&#39;t the concrete implementations
251 in the JDK have Enumeration (or Iterator) constructors?&lt;/b&gt;&lt;/a&gt;
252 &lt;p&gt;Again, this is an instance of an Enumeration serving as a &quot;poor
253 man&#39;s collection&quot; and we&#39;re trying to discourage that. Note
254 however, that we strongly suggest that all concrete implementations
255 should have constructors that take a Collection (and create a new
256 Collection with the same elements).&lt;/p&gt;
257 &lt;/li&gt;
258 &lt;li&gt;&lt;a id=&quot;a10&quot;&gt;&lt;b&gt;Why don&#39;t you provide an Iterator.add
259 method?&lt;/b&gt;&lt;/a&gt;
260 &lt;p&gt;The semantics are unclear, given that the contract for Iterator
261 makes no guarantees about the order of iteration. Note, however,
262 that ListIterator does provide an add operation, as it does
263 guarantee the order of the iteration.&lt;/p&gt;
264 &lt;/li&gt;
265 &lt;/ol&gt;
266 &lt;hr&gt;
267 &lt;h2&gt;List Interface&lt;/h2&gt;
268 &lt;ol&gt;
269 &lt;li&gt;&lt;a id=&quot;a11&quot;&gt;&lt;b&gt;Why don&#39;t you rename the List
270 interface to Sequence; doesn&#39;t &quot;list&quot; generally suggest &quot;linked
271 list&quot;? Also, doesn&#39;t it conflict with java.awt.List?&lt;/b&gt;&lt;/a&gt;
272 &lt;p&gt;People were evenly divided as to whether List suggests linked
273 lists. Given the implementation naming convention,
274 &amp;lt;&lt;em&gt;Implementation&lt;/em&gt;&amp;gt;&amp;lt;&lt;em&gt;Interface&lt;/em&gt;&amp;gt;, there
275 was a strong desire to keep the core interface names short. Also,
276 several existing names (AbstractSequentialList, LinkedList) would
277 have been decidedly worse if we changed List to Sequence. The
278 naming conflict can be dealt with by the following incantation:&lt;/p&gt;
279 &lt;pre&gt;
280     import java.util.*;
281     import java.awt.*;
282     import java.util.List;   // Dictates interpretation of &quot;List&quot;
283 &lt;/pre&gt;&lt;/li&gt;
284 &lt;li&gt;&lt;a id=&quot;a12&quot;&gt;&lt;b&gt;Why don&#39;t you rename List&#39;s set
285 method to replace, to avoid confusion with Set.&lt;/b&gt;&lt;/a&gt;
286 &lt;p&gt;It was decided that the &quot;set/get&quot; naming convention was strongly
287 enough enshrined in the language that we&#39;d stick with it.&lt;/p&gt;
288 &lt;/li&gt;
289 &lt;/ol&gt;
290 &lt;hr&gt;
291 &lt;h2&gt;Map Interface&lt;/h2&gt;
292 &lt;ol&gt;
293 &lt;li&gt;&lt;a id=&quot;a14&quot;&gt;&lt;b&gt;Why doesn&#39;t Map extend
294 Collection?&lt;/b&gt;&lt;/a&gt;
295 &lt;p&gt;This was by design. We feel that mappings are not collections
296 and collections are not mappings. Thus, it makes little sense for
297 Map to extend the Collection interface (or vice versa).&lt;/p&gt;
298 &lt;p&gt;If a Map is a Collection, what are the elements? The only
299 reasonable answer is &quot;Key-value pairs&quot;, but this provides a very
300 limited (and not particularly useful) Map abstraction. You can&#39;t
301 ask what value a given key maps to, nor can you delete the entry
302 for a given key without knowing what value it maps to.&lt;/p&gt;
303 &lt;p&gt;Collection could be made to extend Map, but this raises the
304 question: what are the keys? There&#39;s no really satisfactory answer,
305 and forcing one leads to an unnatural interface.&lt;/p&gt;
306 &lt;p&gt;Maps can be &lt;em&gt;viewed&lt;/em&gt; as Collections (of keys, values, or
307 pairs), and this fact is reflected in the three &quot;Collection view
308 operations&quot; on Maps (keySet, entrySet, and values). While it is, in
309 principle, possible to view a List as a Map mapping indices to
310 elements, this has the nasty property that deleting an element from
311 the List changes the Key associated with every element before the
312 deleted element. That&#39;s why we don&#39;t have a map view operation on
313 Lists.&lt;/p&gt;
314 &lt;/li&gt;
315 &lt;/ol&gt;
316 &lt;hr&gt;
317 &lt;h2&gt;Iterator Interface&lt;/h2&gt;
318 &lt;ol&gt;
319 &lt;li&gt;&lt;a id=&quot;a18&quot;&gt;&lt;b&gt;Why doesn&#39;t Iterator extend
320 Enumeration?&lt;/b&gt;&lt;/a&gt;
321 &lt;p&gt;We view the method names for Enumeration as unfortunate. They&#39;re
322 very long, and very frequently used. Given that we were adding a
323 method and creating a whole new framework, we felt that it would be
324 foolish not to take advantage of the opportunity to improve the
325 names. Of course we could support the new and old names in
326 Iterator, but it doesn&#39;t seem worthwhile.&lt;/p&gt;
327 &lt;/li&gt;
328 &lt;li&gt;&lt;a id=&quot;a19&quot;&gt;&lt;b&gt;Why don&#39;t you provide an
329 Iterator.peek method that allows you to look at the next element in
330 an iteration without advancing the iterator?&lt;/b&gt;&lt;/a&gt;
331 &lt;p&gt;It can be implemented atop the current Iterators (a similar
332 pattern to java.io.PushbackInputStream). We believe that its use
333 would be rare enough that it isn&#39;t worth including in the interface
334 that everyone has to implement.&lt;/p&gt;
335 &lt;/li&gt;
336 &lt;/ol&gt;
337 &lt;hr&gt;
338 &lt;h2&gt;Miscellaneous&lt;/h2&gt;
339 &lt;ol&gt;
340 &lt;li&gt;&lt;a id=&quot;a23&quot;&gt;&lt;b&gt;Why did you write a new collections
341 framework instead of adopting JGL (a preexisting collections
342 package from ObjectSpace, Inc.) into the JDK?&lt;/b&gt;&lt;/a&gt;
343 &lt;p&gt;If you examine the goals for our Collections framework (in the
344 Overview), you&#39;ll see that we are not really &quot;playing in the same
345 space&quot; as JGL. Quoting from the &quot;Design Goals&quot; Section of the Java
346 Collections Overview: &quot;Our main design goal was to produce an API
347 that was reasonably small, both in size, and (more importantly) in
348 &#39;conceptual weight.&#39;&quot;&lt;/p&gt;
349 &lt;p&gt;JGL consists of approximately 130 classes and interfaces; its
350 main goal was consistency with the C++ Standard Template Library
351 (STL). This was &lt;em&gt;not&lt;/em&gt; one of our goals. Java has
352 traditionally stayed away from C++&#39;s more complex features (e.g.,
353 multiple inheritance, operator overloading). Our entire framework,
354 including all infrastructure, contains approximately 25 classes and
355 interfaces.&lt;/p&gt;
356 &lt;p&gt;While this may cause some discomfort for some C++ programmers,
357 we feel that it will be good for Java in the long run. As the Java
358 libraries mature, they inevitably grow, but we are trying as hard
359 as we can to keep them small and manageable, so that Java continues
360 to be an easy, fun language to learn and to use.&lt;/p&gt;
361 &lt;/li&gt;
362 &lt;li&gt;&lt;a id=&quot;a26&quot;&gt;&lt;b&gt;Why don&#39;t you eliminate all of the
363 methods and classes that return &quot;views&quot; (Collections backed by
364 other collection-like objects). This would greatly reduce
365 aliasing.&lt;/b&gt;&lt;/a&gt;
366 &lt;p&gt;Given that we provide core collection interfaces behind which
367 programmers can &quot;hide&quot; their own implementations, there will be
368 aliased collections whether the JDK provides them or not.
369 Eliminating all views from the JDK would greatly increase the cost
370 of common operations like making a Collection out of an array, and
371 would do away with many useful facilities (like synchronizing
372 wrappers). One view that we see as being particularly useful is
373 &lt;a href=
374 &quot;../List.html#subList(int,int)&quot;&gt;List.subList&lt;/a&gt;.
375 The existence of this method means that people who write methods
376 taking List on input do not have to write secondary forms taking an
377 offset and a length (as they do for arrays).&lt;/p&gt;
378 &lt;/li&gt;
379 &lt;li&gt;&lt;a id=&quot;a27&quot;&gt;&lt;b&gt;Why don&#39;t you provide for
380 &quot;observable&quot; collections that send out Events when they&#39;re
381 modified?&lt;/b&gt;&lt;/a&gt;
382 &lt;p&gt;Primarily, resource constraints. If we&#39;re going to commit to
383 such an API, it has to be something that works for everyone, that
384 we can live with for the long haul. We may provide such a facility
385 some day. In the meantime, it&#39;s not difficult to implement such a
386 facility on top of the public APIs.&lt;/p&gt;
387 &lt;/li&gt;
388 &lt;/ol&gt;
389 &lt;hr&gt;
390 &lt;p style=&quot;font-size:smaller&quot;&gt;
391 Copyright &amp;copy; 1998, 2017, Oracle and/or its affiliates. 500 Oracle Parkway&lt;br&gt;
392     Redwood Shores, CA 94065 USA. All rights reserved.&lt;/p&gt;
393 &lt;!-- Body text ends here --&gt;
394 &lt;/body&gt;
395 &lt;/html&gt;
    </pre>
  </body>
</html>
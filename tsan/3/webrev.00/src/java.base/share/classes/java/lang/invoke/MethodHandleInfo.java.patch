diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleInfo.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleInfo.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleInfo.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleInfo.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -33,19 +33,20 @@
 
 /**
  * A symbolic reference obtained by cracking a direct method handle
  * into its consitutent symbolic parts.
  * To crack a direct method handle, call {@link Lookup#revealDirect Lookup.revealDirect}.
- * <h1><a id="directmh"></a>Direct Method Handles</h1>
+ * <h2><a id="directmh"></a>Direct Method Handles</h2>
  * A <em>direct method handle</em> represents a method, constructor, or field without
  * any intervening argument bindings or other transformations.
  * The method, constructor, or field referred to by a direct method handle is called
  * its <em>underlying member</em>.
  * Direct method handles may be obtained in any of these ways:
  * <ul>
  * <li>By executing an {@code ldc} instruction on a {@code CONSTANT_MethodHandle} constant.
- *     (See the Java Virtual Machine Specification, sections 4.4.8 and 5.4.3.)
+ *     (See the Java Virtual Machine Specification, sections {@jvms
+ *     4.4.8} and {@jvms 5.4.3}.)
  * <li>By calling one of the <a href="MethodHandles.Lookup.html#lookups">Lookup Factory Methods</a>,
  *     such as {@link Lookup#findVirtual Lookup.findVirtual},
  *     to resolve a symbolic reference into a method handle.
  *     A symbolic reference consists of a class, name string, and type.
  * <li>By calling the factory method {@link Lookup#unreflect Lookup.unreflect}
@@ -56,11 +57,11 @@
  * <li>By calling the factory method {@link Lookup#unreflectGetter Lookup.unreflectGetter}
  *     or {@link Lookup#unreflectSetter Lookup.unreflectSetter}
  *     to convert a {@link Field} into a method handle.
  * </ul>
  *
- * <h1>Restrictions on Cracking</h1>
+ * <h2>Restrictions on Cracking</h2>
  * Given a suitable {@code Lookup} object, it is possible to crack any direct method handle
  * to recover a symbolic reference for the underlying method, constructor, or field.
  * Cracking must be done via a {@code Lookup} object equivalent to that which created
  * the target method handle, or which has enough access permissions to recreate
  * an equivalent method handle.
@@ -75,11 +76,11 @@
  * The requirement of lookup object matching provides a "fast fail" behavior
  * for programs which may otherwise trust erroneous revelation of a method
  * handle with symbolic information (or caller binding) from an unexpected scope.
  * Use {@link java.lang.invoke.MethodHandles#reflectAs} to override this limitation.
  *
- * <h1><a id="refkinds"></a>Reference kinds</h1>
+ * <h2><a id="refkinds"></a>Reference kinds</h2>
  * The <a href="MethodHandles.Lookup.html#lookups">Lookup Factory Methods</a>
  * correspond to all major use cases for methods, constructors, and fields.
  * These use cases may be distinguished using small integers as follows:
  * <table class="striped">
  * <caption style="display:none">reference kinds</caption>
@@ -125,12 +126,11 @@
  * </tr>
  * </tbody>
  * </table>
  * @since 1.8
  */
-public
-interface MethodHandleInfo {
+public interface MethodHandleInfo {
     /**
      * A direct method handle reference kind,
      * as defined in the <a href="MethodHandleInfo.html#refkinds">table above</a>.
      */
     public static final int
@@ -197,13 +197,13 @@
      * The underlying member must be accessible to the given lookup object.
      * @param <T> the desired type of the result, either {@link Member} or a subtype
      * @param expected a class object representing the desired result type {@code T}
      * @param lookup the lookup object that created this MethodHandleInfo, or one with equivalent access privileges
      * @return a reference to the method, constructor, or field object
-     * @exception ClassCastException if the member is not of the expected type
-     * @exception NullPointerException if either argument is {@code null}
-     * @exception IllegalArgumentException if the underlying member is not accessible to the given lookup object
+     * @throws    ClassCastException if the member is not of the expected type
+     * @throws    NullPointerException if either argument is {@code null}
+     * @throws    IllegalArgumentException if the underlying member is not accessible to the given lookup object
      */
     public <T extends Member> T reflectAs(Class<T> expected, Lookup lookup);
 
     /**
      * Returns the access modifiers of the underlying member.
@@ -241,11 +241,11 @@
      * Returns the descriptive name of the given reference kind,
      * as defined in the <a href="MethodHandleInfo.html#refkinds">table above</a>.
      * The conventional prefix "REF_" is omitted.
      * @param referenceKind an integer code for a kind of reference used to access a class member
      * @return a mixed-case string such as {@code "getField"}
-     * @exception IllegalArgumentException if the argument is not a valid
+     * @throws    IllegalArgumentException if the argument is not a valid
      *            <a href="MethodHandleInfo.html#refkinds">reference kind number</a>
      */
     public static String referenceKindToString(int referenceKind) {
         if (!MethodHandleNatives.refKindIsValid(referenceKind))
             throw newIllegalArgumentException("invalid reference kind", referenceKind);
@@ -276,13 +276,13 @@
      * @param kind the {@linkplain #getReferenceKind reference kind} part of the symbolic reference
      * @param defc the {@linkplain #getDeclaringClass declaring class} part of the symbolic reference
      * @param name the {@linkplain #getName member name} part of the symbolic reference
      * @param type the {@linkplain #getMethodType method type} part of the symbolic reference
      * @return a string of the form {@code "RK C.N:MT"}
-     * @exception IllegalArgumentException if the first argument is not a valid
+     * @throws    IllegalArgumentException if the first argument is not a valid
      *            <a href="MethodHandleInfo.html#refkinds">reference kind number</a>
-     * @exception NullPointerException if any reference argument is {@code null}
+     * @throws    NullPointerException if any reference argument is {@code null}
      */
     public static String toString(int kind, Class<?> defc, String name, MethodType type) {
         Objects.requireNonNull(name); Objects.requireNonNull(type);
         return String.format("%s %s.%s:%s", referenceKindToString(kind), defc.getName(), name, type);
     }

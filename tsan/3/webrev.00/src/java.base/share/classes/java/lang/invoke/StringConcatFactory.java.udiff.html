<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringConcatException.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarForm.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,24 +24,22 @@</span>
   */
  
  package java.lang.invoke;
  
  import jdk.internal.misc.Unsafe;
<span class="udiff-line-added">+ import jdk.internal.misc.VM;</span>
  import jdk.internal.org.objectweb.asm.ClassWriter;
  import jdk.internal.org.objectweb.asm.Label;
  import jdk.internal.org.objectweb.asm.MethodVisitor;
  import jdk.internal.org.objectweb.asm.Opcodes;
<span class="udiff-line-removed">- import jdk.internal.vm.annotation.ForceInline;</span>
  import sun.invoke.util.Wrapper;
<span class="udiff-line-removed">- import sun.security.action.GetPropertyAction;</span>
  
  import java.lang.invoke.MethodHandles.Lookup;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.List;
  import java.util.Objects;
<span class="udiff-line-removed">- import java.util.Properties;</span>
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.ConcurrentMap;
  import java.util.function.Function;
  
  import static jdk.internal.org.objectweb.asm.Opcodes.*;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -189,10 +187,12 @@</span>
      /**
       * Dump generated classes to disk, for debugging purposes.
       */
      private static final ProxyClassesDumper DUMPER;
  
<span class="udiff-line-added">+     private static final Class&lt;?&gt; STRING_HELPER;</span>
<span class="udiff-line-added">+ </span>
      static {
          // In case we need to double-back onto the StringConcatFactory during this
          // static initialization, make sure we have the reasonable defaults to complete
          // the static initialization properly. After that, actual users would use
          // the proper values we have read from the properties.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -200,19 +200,24 @@</span>
          // CACHE_ENABLE = false; // implied
          // CACHE = null;         // implied
          // DEBUG = false;        // implied
          // DUMPER = null;        // implied
  
<span class="udiff-line-modified-removed">-         Properties props = GetPropertyAction.privilegedGetProperties();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-added">+             STRING_HELPER = Class.forName(&quot;java.lang.StringConcatHelper&quot;);</span>
<span class="udiff-line-added">+         } catch (Throwable e) {</span>
<span class="udiff-line-added">+             throw new AssertionError(e);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          final String strategy =
<span class="udiff-line-modified-removed">-                 props.getProperty(&quot;java.lang.invoke.stringConcat&quot;);</span>
<span class="udiff-line-modified-added">+                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);</span>
          CACHE_ENABLE = Boolean.parseBoolean(
<span class="udiff-line-modified-removed">-                 props.getProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
<span class="udiff-line-modified-added">+                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
          DEBUG = Boolean.parseBoolean(
<span class="udiff-line-modified-removed">-                 props.getProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));</span>
<span class="udiff-line-modified-added">+                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));</span>
          final String dumpPath =
<span class="udiff-line-modified-removed">-                 props.getProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="udiff-line-modified-added">+                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
  
          STRATEGY = (strategy == null) ? DEFAULT_STRATEGY : Strategy.valueOf(strategy);
          CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;
          DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -433,12 +438,12 @@</span>
       * &lt;/ul&gt;
       *
       * @param lookup   Represents a lookup context with the accessibility
       *                 privileges of the caller. Specifically, the lookup
       *                 context must have
<span class="udiff-line-modified-removed">-      *                 &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;</span>
<span class="udiff-line-modified-removed">-      *                 privileges.</span>
<span class="udiff-line-modified-added">+      *                 {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()</span>
<span class="udiff-line-modified-added">+      *                 full privilege access}.</span>
       *                 When used with {@code invokedynamic}, this is stacked
       *                 automatically by the VM.
       * @param name     The name of the method to implement. This name is
       *                 arbitrary, and has no meaning for this linkage method.
       *                 When used with {@code invokedynamic}, this is provided by
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -543,12 +548,12 @@</span>
       * &lt;/ul&gt;
       *
       * @param lookup    Represents a lookup context with the accessibility
       *                  privileges of the caller. Specifically, the lookup
       *                  context must have
<span class="udiff-line-modified-removed">-      *                  &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;</span>
<span class="udiff-line-modified-removed">-      *                  privileges.</span>
<span class="udiff-line-modified-added">+      *                  {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()</span>
<span class="udiff-line-modified-added">+      *                  full privilege access}.</span>
       *                  When used with {@code invokedynamic}, this is stacked
       *                  automatically by the VM.
       * @param name      The name of the method to implement. This name is
       *                  arbitrary, and has no meaning for this linkage method.
       *                  When used with {@code invokedynamic}, this is provided
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1517,10 +1522,43 @@</span>
              // no instantiation
          }
  
          static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {
  
<span class="udiff-line-added">+             // Fast-path two-argument Object + Object concatenations</span>
<span class="udiff-line-added">+             if (recipe.getElements().size() == 2) {</span>
<span class="udiff-line-added">+                 // Two object arguments</span>
<span class="udiff-line-added">+                 if (mt.parameterCount() == 2 &amp;&amp;</span>
<span class="udiff-line-added">+                     !mt.parameterType(0).isPrimitive() &amp;&amp;</span>
<span class="udiff-line-added">+                     !mt.parameterType(1).isPrimitive() &amp;&amp;</span>
<span class="udiff-line-added">+                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;</span>
<span class="udiff-line-added">+                     recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     return SIMPLE;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 } else if (mt.parameterCount() == 1 &amp;&amp;</span>
<span class="udiff-line-added">+                            !mt.parameterType(0).isPrimitive()) {</span>
<span class="udiff-line-added">+                     // One Object argument, one constant</span>
<span class="udiff-line-added">+                     MethodHandle mh = SIMPLE;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;</span>
<span class="udiff-line-added">+                         recipe.getElements().get(1).getTag() == TAG_ARG) {</span>
<span class="udiff-line-added">+                         // First recipe element is a constant</span>
<span class="udiff-line-added">+                         return MethodHandles.insertArguments(mh, 0,</span>
<span class="udiff-line-added">+                                 recipe.getElements().get(0).getValue());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;</span>
<span class="udiff-line-added">+                                recipe.getElements().get(0).getTag() == TAG_ARG) {</span>
<span class="udiff-line-added">+                         // Second recipe element is a constant</span>
<span class="udiff-line-added">+                         return MethodHandles.insertArguments(mh, 1,</span>
<span class="udiff-line-added">+                                 recipe.getElements().get(1).getValue());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 // else... fall-through to slow-path</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              // Create filters and obtain filtered parameter types. Filters would be used in the beginning
              // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
              // The filtered argument type list is used all over in the combinators below.
              Class&lt;?&gt;[] ptypes = mt.parameterArray();
              MethodHandle[] filters = null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1542,37 +1580,78 @@</span>
              // Drop all remaining parameter types, leave only helper arguments:
              MethodHandle mh;
  
              mh = MethodHandles.dropArguments(NEW_STRING, 2, ptypes);
  
<span class="udiff-line-added">+             long initialLengthCoder = INITIAL_CODER;</span>
<span class="udiff-line-added">+ </span>
              // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
              // known from the combinators below. We are assembling the string backwards, so the index coded
              // into indexCoder is the *ending* index.
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // We need one prepender per argument, but also need to fold in constants. We do so by greedily</span>
<span class="udiff-line-added">+             // create prependers that fold in surrounding constants into the argument prepender. This reduces</span>
<span class="udiff-line-added">+             // the number of unique MH combinator tree shapes we&#39;ll create in an application.</span>
<span class="udiff-line-added">+             String prefixConstant = null, suffixConstant = null;</span>
<span class="udiff-line-added">+             int pos = -1;</span>
              for (RecipeElement el : recipe.getElements()) {
                  // Do the prepend, and put &quot;new&quot; index at index 1
                  switch (el.getTag()) {
                      case TAG_CONST: {
<span class="udiff-line-modified-removed">-                         MethodHandle prepender = MethodHandles.insertArguments(prepender(String.class), 2, el.getValue());</span>
<span class="udiff-line-modified-removed">-                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,</span>
<span class="udiff-line-modified-removed">-                                 1, 0 // indexCoder, storage</span>
<span class="udiff-line-modified-removed">-                         );</span>
<span class="udiff-line-modified-added">+                         String constantValue = el.getValue();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                         // Eagerly update the initialLengthCoder value</span>
<span class="udiff-line-modified-added">+                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                         if (pos &lt; 0) {</span>
<span class="udiff-line-added">+                             // Collecting into prefixConstant</span>
<span class="udiff-line-added">+                             prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;</span>
<span class="udiff-line-added">+                         } else {</span>
<span class="udiff-line-added">+                             // Collecting into suffixConstant</span>
<span class="udiff-line-added">+                             suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;</span>
<span class="udiff-line-added">+                         }</span>
                          break;
                      }
                      case TAG_ARG: {
<span class="udiff-line-modified-removed">-                         int pos = el.getArgPos();</span>
<span class="udiff-line-modified-removed">-                         MethodHandle prepender = prepender(ptypes[pos]);</span>
<span class="udiff-line-modified-removed">-                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                         if (pos &gt;= 0) {</span>
<span class="udiff-line-modified-added">+                             // Flush the previous non-constant arg with any prefix/suffix constant</span>
<span class="udiff-line-added">+                             mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="udiff-line-added">+                                 mh, 1,</span>
<span class="udiff-line-added">+                                 prepender(prefixConstant, ptypes[pos], suffixConstant),</span>
                                  1, 0, // indexCoder, storage
                                  2 + pos  // selected argument
<span class="udiff-line-modified-removed">-                         );</span>
<span class="udiff-line-modified-added">+                             );</span>
<span class="udiff-line-added">+                             prefixConstant = suffixConstant = null;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         // Mark the pos of next non-constant arg</span>
<span class="udiff-line-added">+                         pos = el.getArgPos();</span>
                          break;
                      }
                      default:
                          throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
                  }
              }
  
<span class="udiff-line-added">+             // Insert any trailing args, constants</span>
<span class="udiff-line-added">+             if (pos &gt;= 0) {</span>
<span class="udiff-line-added">+                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="udiff-line-added">+                     mh, 1,</span>
<span class="udiff-line-added">+                     prepender(prefixConstant, ptypes[pos], suffixConstant),</span>
<span class="udiff-line-added">+                     1, 0, // indexCoder, storage</span>
<span class="udiff-line-added">+                     2 + pos  // selected argument</span>
<span class="udiff-line-added">+                 );</span>
<span class="udiff-line-added">+             } else if (prefixConstant != null) {</span>
<span class="udiff-line-added">+                 assert (suffixConstant == null);</span>
<span class="udiff-line-added">+                 // Sole prefixConstant can only happen if there were no non-constant arguments</span>
<span class="udiff-line-added">+                 mh = MethodHandles.filterArgumentsWithCombiner(</span>
<span class="udiff-line-added">+                     mh, 1,</span>
<span class="udiff-line-added">+                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),</span>
<span class="udiff-line-added">+                     1, 0 // indexCoder, storage</span>
<span class="udiff-line-added">+                 );</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              // Fold in byte[] instantiation at argument 0
              mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, NEW_ARRAY,
                      1 // index
              );
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1585,103 +1664,115 @@</span>
              // Coders are more interesting. Only Object, String and char arguments (and constants)
              // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
              // and deduce the coder from there. Arguments would be either converted to Strings
              // during the initial filtering, or handled by specializations in MIXERS.
              //
<span class="udiff-line-modified-removed">-             // The method handle shape before and after all mixers are combined in is:</span>
<span class="udiff-line-modified-added">+             // The method handle shape before all mixers are combined in is:</span>
              //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
<span class="udiff-line-modified-removed">-             long initialLengthCoder = INITIAL_CODER;</span>
<span class="udiff-line-modified-added">+             //</span>
<span class="udiff-line-added">+             // We will bind the initialLengthCoder value to the last mixer (the one that will be</span>
<span class="udiff-line-added">+             // executed first), then fold that in. This leaves the shape after all mixers are</span>
<span class="udiff-line-added">+             // combined in as:</span>
<span class="udiff-line-added">+             //   (&lt;args&gt;)String = (&lt;args&gt;)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             int ac = -1;</span>
<span class="udiff-line-added">+             MethodHandle mix = null;</span>
              for (RecipeElement el : recipe.getElements()) {
                  switch (el.getTag()) {
                      case TAG_CONST:
<span class="udiff-line-modified-removed">-                         String constant = el.getValue();</span>
<span class="udiff-line-removed">-                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constant);</span>
<span class="udiff-line-modified-added">+                         // Constants already handled in the code above</span>
                          break;
                      case TAG_ARG:
<span class="udiff-line-modified-removed">-                         int ac = el.getArgPos();</span>
<span class="udiff-line-modified-added">+                         if (ac &gt;= 0) {</span>
<span class="udiff-line-added">+                             // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="udiff-line-added">+                             mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="udiff-line-added">+                                     0, // old-index</span>
<span class="udiff-line-added">+                                     1 + ac // selected argument</span>
<span class="udiff-line-added">+                             );</span>
<span class="udiff-line-added">+                         }</span>
  
<span class="udiff-line-added">+                         ac = el.getArgPos();</span>
                          Class&lt;?&gt; argClass = ptypes[ac];
<span class="udiff-line-modified-removed">-                         MethodHandle mix = mixer(argClass);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                         // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.</span>
<span class="udiff-line-removed">-                         mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,</span>
<span class="udiff-line-removed">-                                 0, // old-index</span>
<span class="udiff-line-removed">-                                 1 + ac // selected argument</span>
<span class="udiff-line-removed">-                         );</span>
<span class="udiff-line-modified-added">+                         mix = mixer(argClass);</span>
  
                          break;
                      default:
                          throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
                  }
              }
  
<span class="udiff-line-modified-removed">-             // Insert initial length and coder value here.</span>
<span class="udiff-line-modified-added">+             // Insert the initialLengthCoder value into the final mixer, then</span>
<span class="udiff-line-added">+             // fold that into the base method handle</span>
<span class="udiff-line-added">+             if (ac &gt;= 0) {</span>
<span class="udiff-line-added">+                 mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);</span>
<span class="udiff-line-added">+                 mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,</span>
<span class="udiff-line-added">+                         1 + ac // selected argument</span>
<span class="udiff-line-added">+                 );</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 // No mixer (constants only concat), insert initialLengthCoder directly</span>
<span class="udiff-line-added">+                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
              // The method handle shape here is (&lt;args&gt;).
<span class="udiff-line-removed">-             mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);</span>
  
              // Apply filters, converting the arguments:
              if (filters != null) {
                  mh = MethodHandles.filterArguments(mh, 0, filters);
              }
  
              return mh;
          }
  
<span class="udiff-line-modified-removed">-         @ForceInline</span>
<span class="udiff-line-modified-removed">-         private static byte[] newArray(long indexCoder) {</span>
<span class="udiff-line-modified-removed">-             byte coder = (byte)(indexCoder &gt;&gt; 32);</span>
<span class="udiff-line-modified-removed">-             int index = (int)indexCoder;</span>
<span class="udiff-line-removed">-             return (byte[]) UNSAFE.allocateUninitializedArray(byte.class, index &lt;&lt; coder);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         private static MethodHandle prepender(Class&lt;?&gt; cl) {</span>
<span class="udiff-line-removed">-             return PREPENDERS.computeIfAbsent(cl, PREPEND);</span>
<span class="udiff-line-modified-added">+         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {</span>
<span class="udiff-line-modified-added">+             return MethodHandles.insertArguments(</span>
<span class="udiff-line-modified-added">+                     MethodHandles.insertArguments(</span>
<span class="udiff-line-modified-added">+                         PREPENDERS.computeIfAbsent(cl, PREPEND),2, prefix), 3, suffix);</span>
          }
  
          private static MethodHandle mixer(Class&lt;?&gt; cl) {
              return MIXERS.computeIfAbsent(cl, MIX);
          }
  
          // This one is deliberately non-lambdified to optimize startup time:
<span class="udiff-line-modified-removed">-         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;Class&lt;?&gt;, MethodHandle&gt;() {</span>
<span class="udiff-line-modified-added">+         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {</span>
              @Override
              public MethodHandle apply(Class&lt;?&gt; c) {
                  return lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;prepend&quot;, long.class, long.class, byte[].class,
<span class="udiff-line-modified-removed">-                         Wrapper.asPrimitiveType(c));</span>
<span class="udiff-line-modified-added">+                         String.class, Wrapper.asPrimitiveType(c), String.class);</span>
              }
          };
  
          // This one is deliberately non-lambdified to optimize startup time:
<span class="udiff-line-modified-removed">-         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;Class&lt;?&gt;, MethodHandle&gt;() {</span>
<span class="udiff-line-modified-added">+         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {</span>
              @Override
              public MethodHandle apply(Class&lt;?&gt; c) {
                  return lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;mix&quot;, long.class, long.class,
                          Wrapper.asPrimitiveType(c));
              }
          };
  
<span class="udiff-line-added">+         private static final MethodHandle SIMPLE;</span>
          private static final MethodHandle NEW_STRING;
          private static final MethodHandle NEW_ARRAY;
          private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
          private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
          private static final long INITIAL_CODER;
<span class="udiff-line-removed">-         static final Class&lt;?&gt; STRING_HELPER;</span>
  
          static {
              try {
<span class="udiff-line-removed">-                 STRING_HELPER = Class.forName(&quot;java.lang.StringConcatHelper&quot;);</span>
                  MethodHandle initCoder = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;initialCoder&quot;, long.class);
                  INITIAL_CODER = (long) initCoder.invoke();
              } catch (Throwable e) {
                  throw new AssertionError(e);
              }
  
              PREPENDERS = new ConcurrentHashMap&lt;&gt;();
              MIXERS = new ConcurrentHashMap&lt;&gt;();
  
<span class="udiff-line-added">+             SIMPLE     = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;simpleConcat&quot;, String.class, Object.class, Object.class);</span>
              NEW_STRING = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;newString&quot;, String.class, byte[].class, long.class);
<span class="udiff-line-modified-removed">-             NEW_ARRAY  = lookupStatic(Lookup.IMPL_LOOKUP, MethodHandleInlineCopyStrategy.class, &quot;newArray&quot;, byte[].class, long.class);</span>
<span class="udiff-line-modified-added">+             NEW_ARRAY  = lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;newArray&quot;, byte[].class, long.class);</span>
          }
      }
  
      /**
       * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1690,26 +1781,12 @@</span>
      private static final class Stringifiers {
          private Stringifiers() {
              // no instantiation
          }
  
<span class="udiff-line-modified-removed">-         private static class ObjectStringifier {</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-             // We need some additional conversion for Objects in general, because String.valueOf(Object)</span>
<span class="udiff-line-removed">-             // may return null. String conversion rules in Java state we need to produce &quot;null&quot; String</span>
<span class="udiff-line-removed">-             // in this case, so we provide a customized version that deals with this problematic corner case.</span>
<span class="udiff-line-removed">-             private static String valueOf(Object value) {</span>
<span class="udiff-line-removed">-                 String s;</span>
<span class="udiff-line-removed">-                 return (value == null || (s = value.toString()) == null) ? &quot;null&quot; : s;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             // Could have used MethodHandles.lookup() instead of Lookup.IMPL_LOOKUP, if not for the fact</span>
<span class="udiff-line-removed">-             // java.lang.invoke Lookups are explicitly forbidden to be retrieved using that API.</span>
<span class="udiff-line-removed">-             private static final MethodHandle INSTANCE =</span>
<span class="udiff-line-removed">-                     lookupStatic(Lookup.IMPL_LOOKUP, ObjectStringifier.class, &quot;valueOf&quot;, String.class, Object.class);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         private static final MethodHandle OBJECT_INSTANCE =</span>
<span class="udiff-line-modified-added">+             lookupStatic(Lookup.IMPL_LOOKUP, STRING_HELPER, &quot;stringOf&quot;, String.class, Object.class);</span>
  
          private static class FloatStringifiers {
              private static final MethodHandle FLOAT_INSTANCE =
                      lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1749,11 +1826,11 @@</span>
           * @param t class to stringify
           * @return stringifier; null, if not available
           */
          static MethodHandle forMost(Class&lt;?&gt; t) {
              if (!t.isPrimitive()) {
<span class="udiff-line-modified-removed">-                 return ObjectStringifier.INSTANCE;</span>
<span class="udiff-line-modified-added">+                 return OBJECT_INSTANCE;</span>
              } else if (t == float.class) {
                  return FloatStringifiers.FLOAT_INSTANCE;
              } else if (t == double.class) {
                  return FloatStringifiers.DOUBLE_INSTANCE;
              }
</pre>
<center><a href="StringConcatException.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="VarForm.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>